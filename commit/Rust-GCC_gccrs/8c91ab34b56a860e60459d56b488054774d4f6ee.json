{"sha": "8c91ab34b56a860e60459d56b488054774d4f6ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM5MWFiMzRiNTZhODYwZTYwNDU5ZDU2YjQ4ODA1NDc3NGQ0ZjZlZQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2010-09-23T08:37:54Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2010-09-23T08:37:54Z"}, "message": "re PR fortran/38936 ([F03] ASSOCIATE construct / improved SELECT TYPE (a=>expr))\n\n2010-09-23  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\tPR fortran/44044\n\tPR fortran/45474\n\t* gfortran.h (gfc_check_vardef_context): New method.\n\t(struct symbol_attribute): New flag `select_type_temporary'.\n\t* primary.c (gfc_variable_attr): Clarify initialization of ref.\n\t(match_variable): Remove PROTECTED check and assignment check\n\tfor PARAMETERs (this is now done later).\n\t* match.c (gfc_match_iterator): Remove INTENT(IN) check.\n\t(gfc_match_associate): Defer initialization of newAssoc->variable.\n\t(gfc_match_nullify): Remove PURE definability check.\n\t(select_type_set_tmp): Set new `select_type_temporary' flag.\n\t* expr.c (gfc_check_assign): Remove INTENT(IN) check here.\n\t(gfc_check_pointer_assign): Ditto (and other checks removed).\n\t(gfc_check_vardef_context): New method.\n\t* interface.c (compare_parameter_protected): Removed.\n\t(compare_actual_formal): Use `gfc_check_vardef_context' for checks\n\trelated to INTENT([IN]OUT) arguments.\n\t* intrinsic.c (check_arglist): Check INTENT for intrinsics.\n\t* resolve.c (gfc_resolve_iterator): Use `gfc_check_vardef_context'.\n\t(remove_last_array_ref): New method.\n\t(resolve_deallocate_expr), (resolve_allocate_expr): Ditto.\n\t(resolve_allocate_deallocate): Ditto (for STAT and ERRMSG).\n\t(resolve_assoc_var): Remove checks for definability here.\n\t(resolve_select_type): Handle resolving of code->block here.\n\t(resolve_ordinary_assign): Remove PURE check.\n\t(resolve_code): Do not resolve code->blocks for SELECT TYPE here.\n\tUse `gfc_check_vardef_context' for assignments and pointer-assignments.\n\n2010-09-23  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/38936\n\tPR fortran/44044\n\tPR fortran/45474\n\t* gfortran.dg/intrinsic_intent_1.f03: New test.\n\t* gfortran.dg/select_type_17.f03: New test.\n\t* gfortran.dg/associate_5.f03: More definability tests.\n\t* gfortran.dg/enum_2.f90: Check definability.\n\t* gfortran.dg/allocatable_dummy_2.f90: Change expected error message.\n\t* gfortran.dg/allocate_alloc_opt_2.f90: Ditto.\n\t* gfortran.dg/char_expr_2.f90: Ditto.\n\t* gfortran.dg/deallocate_alloc_opt_2.f90: Ditto.\n\t* gfortran.dg/enum_5.f90: Ditto.\n\t* gfortran.dg/equiv_constraint_8.f90: Ditto.\n\t* gfortran.dg/impure_assignment_2.f90: Ditto.\n\t* gfortran.dg/impure_assignment_3.f90: Ditto.\n\t* gfortran.dg/intent_out_1.f90: Ditto.\n\t* gfortran.dg/intent_out_3.f90: Ditto.\n\t* gfortran.dg/pointer_assign_7.f90: Ditto.\n\t* gfortran.dg/pointer_intent_3.f90: Ditto.\n\t* gfortran.dg/pr19936_1.f90: Ditto.\n\t* gfortran.dg/proc_ptr_comp_3.f90: Ditto.\n\t* gfortran.dg/simpleif_2.f90: Ditto.\n\t* gfortran.dg/protected_5.f90: Ditto.\n\t* gfortran.dg/protected_4.f90: Ditto and remove invalid error check.\n\t* gfortran.dg/protected_6.f90: Ditto.\n\t* gfortran.dg/protected_7.f90: Ditto.\n\nFrom-SVN: r164550", "tree": {"sha": "67d09d55027e1b23ccff6e1f28d4f0e70c767536", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67d09d55027e1b23ccff6e1f28d4f0e70c767536"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c91ab34b56a860e60459d56b488054774d4f6ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c91ab34b56a860e60459d56b488054774d4f6ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c91ab34b56a860e60459d56b488054774d4f6ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c91ab34b56a860e60459d56b488054774d4f6ee/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42d9f9dd0f1f957a29afcefb29299f327643a008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42d9f9dd0f1f957a29afcefb29299f327643a008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42d9f9dd0f1f957a29afcefb29299f327643a008"}], "stats": {"total": 803, "additions": 521, "deletions": 282}, "files": [{"sha": "2860897869309918b6696c77febd23f4630dfbe6", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -1,3 +1,34 @@\n+2010-09-23  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\tPR fortran/44044\n+\tPR fortran/45474\n+\t* gfortran.h (gfc_check_vardef_context): New method.\n+\t(struct symbol_attribute): New flag `select_type_temporary'.\n+\t* primary.c (gfc_variable_attr): Clarify initialization of ref.\n+\t(match_variable): Remove PROTECTED check and assignment check\n+\tfor PARAMETERs (this is now done later).\n+\t* match.c (gfc_match_iterator): Remove INTENT(IN) check.\n+\t(gfc_match_associate): Defer initialization of newAssoc->variable.\n+\t(gfc_match_nullify): Remove PURE definability check.\n+\t(select_type_set_tmp): Set new `select_type_temporary' flag.\n+\t* expr.c (gfc_check_assign): Remove INTENT(IN) check here.\n+\t(gfc_check_pointer_assign): Ditto (and other checks removed).\n+\t(gfc_check_vardef_context): New method.\n+\t* interface.c (compare_parameter_protected): Removed.\n+\t(compare_actual_formal): Use `gfc_check_vardef_context' for checks\n+\trelated to INTENT([IN]OUT) arguments.\n+\t* intrinsic.c (check_arglist): Check INTENT for intrinsics.\n+\t* resolve.c (gfc_resolve_iterator): Use `gfc_check_vardef_context'.\n+\t(remove_last_array_ref): New method.\n+\t(resolve_deallocate_expr), (resolve_allocate_expr): Ditto.\n+\t(resolve_allocate_deallocate): Ditto (for STAT and ERRMSG).\n+\t(resolve_assoc_var): Remove checks for definability here.\n+\t(resolve_select_type): Handle resolving of code->block here.\n+\t(resolve_ordinary_assign): Remove PURE check.\n+\t(resolve_code): Do not resolve code->blocks for SELECT TYPE here.\n+\tUse `gfc_check_vardef_context' for assignments and pointer-assignments.\n+\n 2010-08-22  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* gfortran.texi (Argument list functions): Allow URL to wrap."}, {"sha": "5711634466634c119675cd7aab56779f4669ded5", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 188, "deletions": 45, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -3043,24 +3043,15 @@ gfc_check_assign (gfc_expr *lvalue, gfc_expr *rvalue, int conform)\n \n   sym = lvalue->symtree->n.sym;\n \n-  /* Check INTENT(IN), unless the object itself is the component or\n-     sub-component of a pointer.  */\n+  /* See if this is the component or subcomponent of a pointer.  */\n   has_pointer = sym->attr.pointer;\n-\n   for (ref = lvalue->ref; ref; ref = ref->next)\n     if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)\n       {\n \thas_pointer = 1;\n \tbreak;\n       }\n \n-  if (!has_pointer && sym->attr.intent == INTENT_IN)\n-    {\n-      gfc_error (\"Cannot assign to INTENT(IN) variable '%s' at %L\",\n-\t\t sym->name, &lvalue->where);\n-      return FAILURE;\n-    }\n-\n   /* 12.5.2.2, Note 12.26: The result variable is very similar to any other\n      variable local to a function subprogram.  Its existence begins when\n      execution of the function is initiated and ends when execution of the\n@@ -3239,7 +3230,7 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n   symbol_attribute attr;\n   gfc_ref *ref;\n   bool is_pure, rank_remap;\n-  int pointer, check_intent_in, proc_pointer;\n+  int proc_pointer;\n \n   if (lvalue->symtree->n.sym->ts.type == BT_UNKNOWN\n       && !lvalue->symtree->n.sym->attr.proc_pointer)\n@@ -3259,24 +3250,13 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       return FAILURE;\n     }\n \n-\n-  /* Check INTENT(IN), unless the object itself is the component or\n-     sub-component of a pointer.  */\n-  check_intent_in = 1;\n-  pointer = lvalue->symtree->n.sym->attr.pointer;\n   proc_pointer = lvalue->symtree->n.sym->attr.proc_pointer;\n \n   rank_remap = false;\n   for (ref = lvalue->ref; ref; ref = ref->next)\n     {\n-      if (pointer)\n-\tcheck_intent_in = 0;\n-\n       if (ref->type == REF_COMPONENT)\n-\t{\n-\t  pointer = ref->u.c.component->attr.pointer;\n-\t  proc_pointer = ref->u.c.component->attr.proc_pointer;\n-\t}\n+\tproc_pointer = ref->u.c.component->attr.proc_pointer;\n \n       if (ref->type == REF_ARRAY && ref->next == NULL)\n \t{\n@@ -3332,30 +3312,8 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t}\n     }\n \n-  if (check_intent_in && lvalue->symtree->n.sym->attr.intent == INTENT_IN)\n-    {\n-      gfc_error (\"Cannot assign to INTENT(IN) variable '%s' at %L\",\n-\t\t lvalue->symtree->n.sym->name, &lvalue->where);\n-      return FAILURE;\n-    }\n-\n-  if (!pointer && !proc_pointer\n-      && !(lvalue->ts.type == BT_CLASS\n-\t   && CLASS_DATA (lvalue)->attr.class_pointer))\n-    {\n-      gfc_error (\"Pointer assignment to non-POINTER at %L\", &lvalue->where);\n-      return FAILURE;\n-    }\n-\n   is_pure = gfc_pure (NULL);\n \n-  if (is_pure && gfc_impure_variable (lvalue->symtree->n.sym)\n-\t&& lvalue->symtree->n.sym->value != rvalue)\n-    {\n-      gfc_error (\"Bad pointer object in PURE procedure at %L\", &lvalue->where);\n-      return FAILURE;\n-    }\n-\n   /* If rvalue is a NULL() or NULLIFY, we're done. Otherwise the type,\n      kind, etc for lvalue and rvalue must match, and rvalue must be a\n      pure variable if we're in a pure function.  */\n@@ -4338,3 +4296,188 @@ gfc_build_intrinsic_call (const char* name, locus where, unsigned numarg, ...)\n \n   return result;\n }\n+\n+\n+/* Check if an expression may appear in a variable definition context\n+   (F2008, 16.6.7) or pointer association context (F2008, 16.6.8).\n+   This is called from the various places when resolving\n+   the pieces that make up such a context.\n+\n+   Optionally, a possible error message can be suppressed if context is NULL\n+   and just the return status (SUCCESS / FAILURE) be requested.  */\n+\n+gfc_try\n+gfc_check_vardef_context (gfc_expr* e, bool pointer, const char* context)\n+{\n+  gfc_symbol* sym;\n+  bool is_pointer;\n+  bool check_intentin;\n+  bool ptr_component;\n+  symbol_attribute attr;\n+  gfc_ref* ref;\n+\n+  if (e->expr_type != EXPR_VARIABLE)\n+    {\n+      if (context)\n+\tgfc_error (\"Non-variable expression in variable definition context (%s)\"\n+\t\t   \" at %L\", context, &e->where);\n+      return FAILURE;\n+    }\n+\n+  gcc_assert (e->symtree);\n+  sym = e->symtree->n.sym;\n+\n+  if (!pointer && sym->attr.flavor == FL_PARAMETER)\n+    {\n+      if (context)\n+\tgfc_error (\"Named constant '%s' in variable definition context (%s)\"\n+\t\t   \" at %L\", sym->name, context, &e->where);\n+      return FAILURE;\n+    }\n+  if (!pointer && sym->attr.flavor != FL_VARIABLE\n+      && !(sym->attr.flavor == FL_PROCEDURE && sym == sym->result)\n+      && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.proc_pointer))\n+    {\n+      if (context)\n+\tgfc_error (\"'%s' in variable definition context (%s) at %L is not\"\n+\t\t   \" a variable\", sym->name, context, &e->where);\n+      return FAILURE;\n+    }\n+\n+  /* Find out whether the expr is a pointer; this also means following\n+     component references to the last one.  */\n+  attr = gfc_expr_attr (e);\n+  is_pointer = (attr.pointer || attr.proc_pointer);\n+  if (pointer && !is_pointer)\n+    {\n+      if (context)\n+\tgfc_error (\"Non-POINTER in pointer association context (%s)\"\n+\t\t   \" at %L\", context, &e->where);\n+      return FAILURE;\n+    }\n+\n+  /* INTENT(IN) dummy argument.  Check this, unless the object itself is\n+     the component of sub-component of a pointer.  Obviously,\n+     procedure pointers are of no interest here.  */\n+  check_intentin = true;\n+  ptr_component = sym->attr.pointer;\n+  for (ref = e->ref; ref && check_intentin; ref = ref->next)\n+    {\n+      if (ptr_component && ref->type == REF_COMPONENT)\n+\tcheck_intentin = false;\n+      if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)\n+\tptr_component = true;\n+    }\n+  if (check_intentin && sym->attr.intent == INTENT_IN)\n+    {\n+      if (pointer && is_pointer)\n+\t{\n+\t  if (context)\n+\t    gfc_error (\"Dummy argument '%s' with INTENT(IN) in pointer\"\n+\t\t       \" association context (%s) at %L\",\n+\t\t       sym->name, context, &e->where);\n+\t  return FAILURE;\n+\t}\n+      if (!pointer && !is_pointer)\n+\t{\n+\t  if (context)\n+\t    gfc_error (\"Dummy argument '%s' with INTENT(IN) in variable\"\n+\t\t       \" definition context (%s) at %L\",\n+\t\t       sym->name, context, &e->where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  /* PROTECTED and use-associated.  */\n+  if (sym->attr.is_protected && sym->attr.use_assoc)\n+    {\n+      if (pointer && is_pointer)\n+\t{\n+\t  if (context)\n+\t    gfc_error (\"Variable '%s' is PROTECTED and can not appear in a\"\n+\t\t       \" pointer association context (%s) at %L\",\n+\t\t       sym->name, context, &e->where);\n+\t  return FAILURE;\n+\t}\n+      if (!pointer && !is_pointer)\n+\t{\n+\t  if (context)\n+\t    gfc_error (\"Variable '%s' is PROTECTED and can not appear in a\"\n+\t\t       \" variable definition context (%s) at %L\",\n+\t\t       sym->name, context, &e->where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  /* Variable not assignable from a PURE procedure but appears in\n+     variable definition context.  */\n+  if (!pointer && gfc_pure (NULL) && gfc_impure_variable (sym))\n+    {\n+      if (context)\n+\tgfc_error (\"Variable '%s' can not appear in a variable definition\"\n+\t\t   \" context (%s) at %L in PURE procedure\",\n+\t\t   sym->name, context, &e->where);\n+      return FAILURE;\n+    }\n+\n+  /* Check variable definition context for associate-names.  */\n+  if (!pointer && sym->assoc)\n+    {\n+      const char* name;\n+      gfc_association_list* assoc;\n+\n+      gcc_assert (sym->assoc->target);\n+\n+      /* If this is a SELECT TYPE temporary (the association is used internally\n+\t for SELECT TYPE), silently go over to the target.  */\n+      if (sym->attr.select_type_temporary)\n+\t{\n+\t  gfc_expr* t = sym->assoc->target;\n+\n+\t  gcc_assert (t->expr_type == EXPR_VARIABLE);\n+\t  name = t->symtree->name;\n+\n+\t  if (t->symtree->n.sym->assoc)\n+\t    assoc = t->symtree->n.sym->assoc;\n+\t  else\n+\t    assoc = sym->assoc;\n+\t}\n+      else\n+\t{\n+\t  name = sym->name;\n+\t  assoc = sym->assoc;\n+\t}\n+      gcc_assert (name && assoc);\n+\n+      /* Is association to a valid variable?  */\n+      if (!assoc->variable)\n+\t{\n+\t  if (context)\n+\t    {\n+\t      if (assoc->target->expr_type == EXPR_VARIABLE)\n+\t\tgfc_error (\"'%s' at %L associated to vector-indexed target can\"\n+\t\t\t   \" not be used in a variable definition context (%s)\",\n+\t\t\t   name, &e->where, context);\n+\t      else\n+\t\tgfc_error (\"'%s' at %L associated to expression can\"\n+\t\t\t   \" not be used in a variable definition context (%s)\",\n+\t\t\t   name, &e->where, context);\n+\t    }\n+\t  return FAILURE;\n+\t}\n+\n+      /* Target must be allowed to appear in a variable definition context.  */\n+      if (gfc_check_vardef_context (assoc->target, pointer, NULL) == FAILURE)\n+\t{\n+\t  if (context)\n+\t    gfc_error (\"Associate-name '%s' can not appear in a variable\"\n+\t\t       \" definition context (%s) at %L because its target\"\n+\t\t       \" at %L can not, either\",\n+\t\t       name, context, &e->where,\n+\t\t       &assoc->target->where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  return SUCCESS;\n+}"}, {"sha": "94b2b19c7cb6c95d9ede41ceab1baadcb30a649b", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -784,6 +784,9 @@ typedef struct\n   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,\n \t   private_comp:1, zero_comp:1, coarray_comp:1;\n \n+  /* This is a temporary selector for SELECT TYPE.  */\n+  unsigned select_type_temporary:1;\n+\n   /* Attributes set by compiler extensions (!GCC$ ATTRIBUTES).  */\n   unsigned ext_attr:EXT_ATTR_NUM;\n \n@@ -2726,6 +2729,7 @@ bool gfc_has_ultimate_allocatable (gfc_expr *);\n bool gfc_has_ultimate_pointer (gfc_expr *);\n \n gfc_expr* gfc_build_intrinsic_call (const char*, locus, unsigned, ...);\n+gfc_try gfc_check_vardef_context (gfc_expr*, bool, const char*);\n \n \n /* st.c */"}, {"sha": "5024fe86bdf2c28dd88366c34aaf81720434f645", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 12, "deletions": 49, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -1655,36 +1655,6 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n }\n \n \n-/* Given a symbol of a formal argument list and an expression, see if\n-   the two are compatible as arguments.  Returns nonzero if\n-   compatible, zero if not compatible.  */\n-\n-static int\n-compare_parameter_protected (gfc_symbol *formal, gfc_expr *actual)\n-{\n-  if (actual->expr_type != EXPR_VARIABLE)\n-    return 1;\n-\n-  if (!actual->symtree->n.sym->attr.is_protected)\n-    return 1;\n-\n-  if (!actual->symtree->n.sym->attr.use_assoc)\n-    return 1;\n-\n-  if (formal->attr.intent == INTENT_IN\n-      || formal->attr.intent == INTENT_UNKNOWN)\n-    return 1;\n-\n-  if (!actual->symtree->n.sym->attr.pointer)\n-    return 0;\n-\n-  if (actual->symtree->n.sym->attr.pointer && formal->attr.pointer)\n-    return 0;\n-\n-  return 1;\n-}\n-\n-\n /* Returns the storage size of a symbol (formal argument) or\n    zero if it cannot be determined.  */\n \n@@ -2205,27 +2175,20 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t}\n \n       /* Check intent = OUT/INOUT for definable actual argument.  */\n-      if ((a->expr->expr_type != EXPR_VARIABLE\n-\t   || (a->expr->symtree->n.sym->attr.flavor != FL_VARIABLE\n-\t       && a->expr->symtree->n.sym->attr.flavor != FL_PROCEDURE))\n-\t  && (f->sym->attr.intent == INTENT_OUT\n-\t      || f->sym->attr.intent == INTENT_INOUT))\n+      if ((f->sym->attr.intent == INTENT_OUT\n+\t  || f->sym->attr.intent == INTENT_INOUT))\n \t{\n-\t  if (where)\n-\t    gfc_error (\"Actual argument at %L must be definable as \"\n-\t\t       \"the dummy argument '%s' is INTENT = OUT/INOUT\",\n-\t\t       &a->expr->where, f->sym->name);\n-\t  return 0;\n-\t}\n+\t  const char* context = (where\n+\t\t\t\t ? _(\"actual argument to INTENT = OUT/INOUT\")\n+\t\t\t\t : NULL);\n \n-      if (!compare_parameter_protected(f->sym, a->expr))\n-\t{\n-\t  if (where)\n-\t    gfc_error (\"Actual argument at %L is use-associated with \"\n-\t\t       \"PROTECTED attribute and dummy argument '%s' is \"\n-\t\t       \"INTENT = OUT/INOUT\",\n-\t\t       &a->expr->where,f->sym->name);\n-\t  return 0;\n+\t  if (f->sym->attr.pointer\n+\t      && gfc_check_vardef_context (a->expr, true, context)\n+\t\t   == FAILURE)\n+\t    return 0;\n+\t  if (gfc_check_vardef_context (a->expr, false, context)\n+\t\t== FAILURE)\n+\t    return 0;\n \t}\n \n       if ((f->sym->attr.intent == INTENT_OUT"}, {"sha": "795c8caa38908803d80453c13e8115815a4fb908", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -3585,6 +3585,19 @@ check_arglist (gfc_actual_arglist **ap, gfc_intrinsic_sym *sym,\n \t\t       gfc_typename (&actual->expr->ts));\n \t  return FAILURE;\n \t}\n+\n+      /* If the formal argument is INTENT([IN]OUT), check for definability.  */\n+      if (formal->intent == INTENT_INOUT || formal->intent == INTENT_OUT)\n+\t{\n+\t  const char* context = (error_flag\n+\t\t\t\t ? _(\"actual argument to INTENT = OUT/INOUT\")\n+\t\t\t\t : NULL);\n+\n+\t  /* No pointer arguments for intrinsics.  */\n+\t  if (gfc_check_vardef_context (actual->expr, false, context)\n+\t\t== FAILURE)\n+\t    return FAILURE;\n+\t}\n     }\n \n   return SUCCESS;"}, {"sha": "836c95cc2df008b72c34ffa531acfb6cdef3a1f1", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -978,13 +978,6 @@ gfc_match_iterator (gfc_iterator *iter, int init_flag)\n       goto cleanup;\n     }\n \n-  if (var->symtree->n.sym->attr.intent == INTENT_IN)\n-    {\n-      gfc_error (\"Loop variable '%s' at %C cannot be INTENT(IN)\",\n-\t\t var->symtree->n.sym->name);\n-      goto cleanup;\n-    }\n-\n   gfc_match_char ('=');\n \n   var->symtree->n.sym->attr.implied_index = 1;\n@@ -1847,9 +1840,7 @@ gfc_match_associate (void)\n \n       /* The `variable' field is left blank for now; because the target is not\n \t yet resolved, we can't use gfc_has_vector_subscript to determine it\n-\t for now.  Instead, if the symbol is matched as variable, this field\n-\t is set -- and during resolution we check that.  */\n-      newAssoc->variable = 0;\n+\t for now.  This is set during resolution.  */\n \n       /* Put it into the list.  */\n       newAssoc->next = new_st.ext.block.assoc;\n@@ -3166,12 +3157,6 @@ gfc_match_nullify (void)\n       if (gfc_check_do_variable (p->symtree))\n \tgoto cleanup;\n \n-      if (gfc_pure (NULL) && gfc_impure_variable (p->symtree->n.sym))\n-\t{\n-\t  gfc_error (\"Illegal variable in NULLIFY at %C for a PURE procedure\");\n-\t  goto cleanup;\n-\t}\n-\n       /* build ' => NULL() '.  */\n       e = gfc_get_null_expr (&gfc_current_locus);\n \n@@ -4523,6 +4508,7 @@ select_type_set_tmp (gfc_typespec *ts)\n \t\t\t      &tmp->n.sym->as, false);\n       tmp->n.sym->attr.class_ok = 1;\n     }\n+  tmp->n.sym->attr.select_type_temporary = 1;\n \n   /* Add an association for it, so the rest of the parser knows it is\n      an associate-name.  The target will be set during resolution.  */"}, {"sha": "f6ceae91903850c48ae77a056b60f9d612a64e30", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -2007,7 +2007,6 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   if (expr->expr_type != EXPR_VARIABLE && expr->expr_type != EXPR_FUNCTION)\n     gfc_internal_error (\"gfc_variable_attr(): Expression isn't a variable\");\n \n-  ref = expr->ref;\n   sym = expr->symtree->n.sym;\n   attr = sym->attr;\n \n@@ -2031,7 +2030,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   if (ts != NULL && expr->ts.type == BT_UNKNOWN)\n     *ts = sym->ts;\n \n-  for (; ref; ref = ref->next)\n+  for (ref = expr->ref; ref; ref = ref->next)\n     switch (ref->type)\n       {\n       case REF_ARRAY:\n@@ -2986,13 +2985,7 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n   switch (sym->attr.flavor)\n     {\n     case FL_VARIABLE:\n-      if (sym->attr.is_protected && sym->attr.use_assoc)\n-\t{\n-\t  gfc_error (\"Assigning to PROTECTED variable at %C\");\n-\t  return MATCH_ERROR;\n-\t}\n-      if (sym->assoc)\n-\tsym->assoc->variable = 1;\n+      /* Everything is alright.  */\n       break;\n \n     case FL_UNKNOWN:\n@@ -3024,22 +3017,24 @@ match_variable (gfc_expr **result, int equiv_flag, int host_flag)\n \n     case FL_PARAMETER:\n       if (equiv_flag)\n-\tgfc_error (\"Named constant at %C in an EQUIVALENCE\");\n-      else\n-\tgfc_error (\"Cannot assign to a named constant at %C\");\n-      return MATCH_ERROR;\n+\t{\n+\t  gfc_error (\"Named constant at %C in an EQUIVALENCE\");\n+\t  return MATCH_ERROR;\n+\t}\n+      /* Otherwise this is checked for and an error given in the\n+\t variable definition context checks.  */\n       break;\n \n     case FL_PROCEDURE:\n       /* Check for a nonrecursive function result variable.  */\n       if (sym->attr.function\n-          && !sym->attr.external\n-          && sym->result == sym\n-          && (gfc_is_function_return_value (sym, gfc_current_ns)\n-              || (sym->attr.entry\n-                  && sym->ns == gfc_current_ns)\n-              || (sym->attr.entry\n-                  && sym->ns == gfc_current_ns->parent)))\n+\t  && !sym->attr.external\n+\t  && sym->result == sym\n+\t  && (gfc_is_function_return_value (sym, gfc_current_ns)\n+\t      || (sym->attr.entry\n+\t\t  && sym->ns == gfc_current_ns)\n+\t      || (sym->attr.entry\n+\t\t  && sym->ns == gfc_current_ns->parent)))\n \t{\n \t  /* If a function result is a derived type, then the derived\n \t     type may still have to be resolved.  */"}, {"sha": "30ca7ce2181cfd11e2a7d0a7db9e3f713a86e9da", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 91, "deletions": 90, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -2859,8 +2859,6 @@ gfc_iso_c_func_interface (gfc_symbol *sym, gfc_actual_arglist *args,\n \n /* Resolve a function call, which means resolving the arguments, then figuring\n    out which entity the name refers to.  */\n-/* TODO: Check procedure arguments so that an INTENT(IN) isn't passed\n-   to INTENT(OUT) or INTENT(INOUT).  */\n \n static gfc_try\n resolve_function (gfc_expr *expr)\n@@ -6131,12 +6129,9 @@ gfc_resolve_iterator (gfc_iterator *iter, bool real_ok)\n       == FAILURE)\n     return FAILURE;\n \n-  if (gfc_pure (NULL) && gfc_impure_variable (iter->var->symtree->n.sym))\n-    {\n-      gfc_error (\"Cannot assign to loop variable in PURE procedure at %L\",\n-\t\t &iter->var->where);\n-      return FAILURE;\n-    }\n+  if (gfc_check_vardef_context (iter->var, false, _(\"iterator variable\"))\n+      == FAILURE)\n+    return FAILURE;\n \n   if (gfc_resolve_iterator_expr (iter->start, real_ok,\n \t\t\t\t \"Start expression in DO loop\") == FAILURE)\n@@ -6331,14 +6326,11 @@ static gfc_try\n resolve_deallocate_expr (gfc_expr *e)\n {\n   symbol_attribute attr;\n-  int allocatable, pointer, check_intent_in;\n+  int allocatable, pointer;\n   gfc_ref *ref;\n   gfc_symbol *sym;\n   gfc_component *c;\n \n-  /* Check INTENT(IN), unless the object is a sub-component of a pointer.  */\n-  check_intent_in = 1;\n-\n   if (gfc_resolve_expr (e) == FAILURE)\n     return FAILURE;\n \n@@ -6359,9 +6351,6 @@ resolve_deallocate_expr (gfc_expr *e)\n     }\n   for (ref = e->ref; ref; ref = ref->next)\n     {\n-      if (pointer)\n-\tcheck_intent_in = 0;\n-\n       switch (ref->type)\n \t{\n \tcase REF_ARRAY:\n@@ -6399,12 +6388,11 @@ resolve_deallocate_expr (gfc_expr *e)\n       return FAILURE;\n     }\n \n-  if (check_intent_in && sym->attr.intent == INTENT_IN)\n-    {\n-      gfc_error (\"Cannot deallocate INTENT(IN) variable '%s' at %L\",\n-\t\t sym->name, &e->where);\n-      return FAILURE;\n-    }\n+  if (pointer\n+      && gfc_check_vardef_context (e, true, _(\"DEALLOCATE object\")) == FAILURE)\n+    return FAILURE;\n+  if (gfc_check_vardef_context (e, false, _(\"DEALLOCATE object\")) == FAILURE)\n+    return FAILURE;\n \n   if (e->ts.type == BT_CLASS)\n     {\n@@ -6464,6 +6452,31 @@ gfc_expr_to_initialize (gfc_expr *e)\n }\n \n \n+/* If the last ref of an expression is an array ref, return a copy of the\n+   expression with that one removed.  Otherwise, a copy of the original\n+   expression.  This is used for allocate-expressions and pointer assignment\n+   LHS, where there may be an array specification that needs to be stripped\n+   off when using gfc_check_vardef_context.  */\n+\n+static gfc_expr*\n+remove_last_array_ref (gfc_expr* e)\n+{\n+  gfc_expr* e2;\n+  gfc_ref** r;\n+\n+  e2 = gfc_copy_expr (e);\n+  for (r = &e2->ref; *r; r = &(*r)->next)\n+    if ((*r)->type == REF_ARRAY && !(*r)->next)\n+      {\n+\tgfc_free_ref_list (*r);\n+\t*r = NULL;\n+\tbreak;\n+      }\n+\n+  return e2;\n+}\n+\n+\n /* Used in resolve_allocate_expr to check that a allocation-object and\n    a source-expr are conformable.  This does not catch all possible \n    cases; in particular a runtime checking is needed.  */\n@@ -6526,17 +6539,16 @@ conformable_arrays (gfc_expr *e1, gfc_expr *e2)\n static gfc_try\n resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n {\n-  int i, pointer, allocatable, dimension, check_intent_in, is_abstract;\n+  int i, pointer, allocatable, dimension, is_abstract;\n   int codimension;\n   symbol_attribute attr;\n   gfc_ref *ref, *ref2;\n+  gfc_expr *e2;\n   gfc_array_ref *ar;\n   gfc_symbol *sym = NULL;\n   gfc_alloc *a;\n   gfc_component *c;\n-\n-  /* Check INTENT(IN), unless the object is a sub-component of a pointer.  */\n-  check_intent_in = 1;\n+  gfc_try t;\n \n   /* Mark the ultimost array component as being in allocate to allow DIMEN_STAR\n      checking of coarrays.  */\n@@ -6588,9 +6600,6 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \n       for (ref = e->ref; ref; ref2 = ref, ref = ref->next)\n \t{\n-\t  if (pointer)\n-\t    check_intent_in = 0;\n-\n \t  switch (ref->type)\n \t    {\n  \t      case REF_ARRAY:\n@@ -6677,12 +6686,18 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       goto failure;\n     }\n \n-  if (check_intent_in && sym->attr.intent == INTENT_IN)\n-    {\n-      gfc_error (\"Cannot allocate INTENT(IN) variable '%s' at %L\",\n-\t\t sym->name, &e->where);\n-      goto failure;\n-    }\n+  /* In the variable definition context checks, gfc_expr_attr is used\n+     on the expression.  This is fooled by the array specification\n+     present in e, thus we have to eliminate that one temporarily.  */\n+  e2 = remove_last_array_ref (e);\n+  t = SUCCESS;\n+  if (t == SUCCESS && pointer)\n+    t = gfc_check_vardef_context (e2, true, _(\"ALLOCATE object\"));\n+  if (t == SUCCESS)\n+    t = gfc_check_vardef_context (e2, false, _(\"ALLOCATE object\"));\n+  gfc_free_expr (e2);\n+  if (t == FAILURE)\n+    goto failure;\n \n   if (!code->expr3)\n     {\n@@ -6733,9 +6748,9 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   if (pointer || (dimension == 0 && codimension == 0))\n     goto success;\n \n-  /* Make sure the next-to-last reference node is an array specification.  */\n+  /* Make sure the last reference node is an array specifiction.  */\n \n-  if (ref2 == NULL || ref2->type != REF_ARRAY || ref2->u.ar.type == AR_FULL\n+  if (!ref2 || ref2->type != REF_ARRAY || ref2->u.ar.type == AR_FULL\n       || (dimension && ref2->u.ar.dimen == 0))\n     {\n       gfc_error (\"Array specification required in ALLOCATE statement \"\n@@ -6846,20 +6861,13 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n   gfc_expr *stat, *errmsg, *pe, *qe;\n   gfc_alloc *a, *p, *q;\n \n-  stat = code->expr1 ? code->expr1 : NULL;\n-\n-  errmsg = code->expr2 ? code->expr2 : NULL;\n+  stat = code->expr1;\n+  errmsg = code->expr2;\n \n   /* Check the stat variable.  */\n   if (stat)\n     {\n-      if (stat->symtree->n.sym->attr.intent == INTENT_IN)\n-\tgfc_error (\"Stat-variable '%s' at %L cannot be INTENT(IN)\",\n-\t\t   stat->symtree->n.sym->name, &stat->where);\n-\n-      if (gfc_pure (NULL) && gfc_impure_variable (stat->symtree->n.sym))\n-\tgfc_error (\"Illegal stat-variable at %L for a PURE procedure\",\n-\t\t   &stat->where);\n+      gfc_check_vardef_context (stat, false, _(\"STAT variable\"));\n \n       if ((stat->ts.type != BT_INTEGER\n \t   && !(stat->ref && (stat->ref->type == REF_ARRAY\n@@ -6902,13 +6910,7 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \tgfc_warning (\"ERRMSG at %L is useless without a STAT tag\",\n \t\t     &errmsg->where);\n \n-      if (errmsg->symtree->n.sym->attr.intent == INTENT_IN)\n-\tgfc_error (\"Errmsg-variable '%s' at %L cannot be INTENT(IN)\",\n-\t\t   errmsg->symtree->n.sym->name, &errmsg->where);\n-\n-      if (gfc_pure (NULL) && gfc_impure_variable (errmsg->symtree->n.sym))\n-\tgfc_error (\"Illegal errmsg-variable at %L for a PURE procedure\",\n-\t\t   &errmsg->where);\n+      gfc_check_vardef_context (errmsg, false, _(\"ERRMSG variable\"));\n \n       if ((errmsg->ts.type != BT_CHARACTER\n \t   && !(errmsg->ref\n@@ -7539,7 +7541,6 @@ static void\n resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n {\n   gfc_expr* target;\n-  bool to_var;\n \n   gcc_assert (sym->assoc);\n   gcc_assert (sym->attr.flavor == FL_VARIABLE);\n@@ -7573,22 +7574,8 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n   gcc_assert (sym->ts.type != BT_UNKNOWN);\n \n   /* See if this is a valid association-to-variable.  */\n-  to_var = (target->expr_type == EXPR_VARIABLE\n-\t    && !gfc_has_vector_subscript (target));\n-  if (sym->assoc->variable && !to_var)\n-    {\n-      if (target->expr_type == EXPR_VARIABLE)\n-\tgfc_error (\"'%s' at %L associated to vector-indexed target can not\"\n-\t\t   \" be used in a variable definition context\",\n-\t\t   sym->name, &sym->declared_at);\n-      else\n-\tgfc_error (\"'%s' at %L associated to expression can not\"\n-\t\t   \" be used in a variable definition context\",\n-\t\t   sym->name, &sym->declared_at);\n-\n-      return;\n-    }\n-  sym->assoc->variable = to_var;\n+  sym->assoc->variable = (target->expr_type == EXPR_VARIABLE\n+\t\t\t  && !gfc_has_vector_subscript (target));\n \n   /* Finally resolve if this is an array or not.  */\n   if (sym->attr.dimension && target->rank == 0)\n@@ -7617,7 +7604,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n /* Resolve a SELECT TYPE statement.  */\n \n static void\n-resolve_select_type (gfc_code *code)\n+resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n {\n   gfc_symbol *selector_type;\n   gfc_code *body, *new_st, *if_st, *tail;\n@@ -7895,8 +7882,13 @@ resolve_select_type (gfc_code *code)\n \tdefault_case->next = if_st;\n     }\n \n-  resolve_select (code);\n+  /* Resolve the internal code.  This can not be done earlier because\n+     it requires that the sym->assoc of selectors is set already.  */\n+  gfc_current_ns = ns;\n+  gfc_resolve_blocks (code->block, gfc_current_ns);\n+  gfc_current_ns = old_ns;\n \n+  resolve_select (code);\n }\n \n \n@@ -8657,7 +8649,6 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \t}\n     }\n \n-\n   if (lhs->ts.type == BT_CHARACTER\n \t&& gfc_option.warn_character_truncation)\n     {\n@@ -8698,15 +8689,6 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \n   if (gfc_pure (NULL))\n     {\n-      if (gfc_impure_variable (lhs->symtree->n.sym))\n-\t{\n-\t  gfc_error (\"Cannot assign to variable '%s' in PURE \"\n-\t\t     \"procedure at %L\",\n-\t\t      lhs->symtree->n.sym->name,\n-\t\t      &lhs->where);\n-\t  return rval;\n-\t}\n-\n       if (lhs->ts.type == BT_DERIVED\n \t    && lhs->expr_type == EXPR_VARIABLE\n \t    && lhs->ts.u.derived->attr.pointer_comp\n@@ -8810,9 +8792,8 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t      gfc_resolve_omp_do_blocks (code, ns);\n \t      break;\n \t    case EXEC_SELECT_TYPE:\n-\t      gfc_current_ns = code->ext.block.ns;\n-\t      gfc_resolve_blocks (code->block, gfc_current_ns);\n-\t      gfc_current_ns = ns;\n+\t      /* Blocks are handled in resolve_select_type because we have\n+\t\t to transform the SELECT TYPE into ASSOCIATE first.  */\n \t      break;\n \t    case EXEC_OMP_WORKSHARE:\n \t      omp_workshare_save = omp_workshare_flag;\n@@ -8899,6 +8880,10 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (t == FAILURE)\n \t    break;\n \n+\t  if (gfc_check_vardef_context (code->expr1, false, _(\"assignment\"))\n+\t\t== FAILURE)\n+\t    break;\n+\n \t  if (resolve_ordinary_assign (code, ns))\n \t    {\n \t      if (code->op == EXEC_COMPCALL)\n@@ -8923,11 +8908,27 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_POINTER_ASSIGN:\n-\t  if (t == FAILURE)\n-\t    break;\n+\t  {\n+\t    gfc_expr* e;\n \n-\t  gfc_check_pointer_assign (code->expr1, code->expr2);\n-\t  break;\n+\t    if (t == FAILURE)\n+\t      break;\n+\n+\t    /* This is both a variable definition and pointer assignment\n+\t       context, so check both of them.  For rank remapping, a final\n+\t       array ref may be present on the LHS and fool gfc_expr_attr\n+\t       used in gfc_check_vardef_context.  Remove it.  */\n+\t    e = remove_last_array_ref (code->expr1);\n+\t    t = gfc_check_vardef_context (e, true, _(\"pointer assignment\"));\n+\t    if (t == SUCCESS)\n+\t      t = gfc_check_vardef_context (e, false, _(\"pointer assignment\"));\n+\t    gfc_free_expr (e);\n+\t    if (t == FAILURE)\n+\t      break;\n+\n+\t    gfc_check_pointer_assign (code->expr1, code->expr2);\n+\t    break;\n+\t  }\n \n \tcase EXEC_ARITHMETIC_IF:\n \t  if (t == SUCCESS\n@@ -8970,7 +8971,7 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  break;\n \n \tcase EXEC_SELECT_TYPE:\n-\t  resolve_select_type (code);\n+\t  resolve_select_type (code, ns);\n \t  break;\n \n \tcase EXEC_BLOCK:"}, {"sha": "f02152b459bdb4dfd771250a7bd52c2cc0153fa5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -1,3 +1,32 @@\n+2010-09-23  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/38936\n+\tPR fortran/44044\n+\tPR fortran/45474\n+\t* gfortran.dg/intrinsic_intent_1.f03: New test.\n+\t* gfortran.dg/select_type_17.f03: New test.\n+\t* gfortran.dg/associate_5.f03: More definability tests.\n+\t* gfortran.dg/enum_2.f90: Check definability.\n+\t* gfortran.dg/allocatable_dummy_2.f90: Change expected error message.\n+\t* gfortran.dg/allocate_alloc_opt_2.f90: Ditto.\n+\t* gfortran.dg/char_expr_2.f90: Ditto.\n+\t* gfortran.dg/deallocate_alloc_opt_2.f90: Ditto.\n+\t* gfortran.dg/enum_5.f90: Ditto.\n+\t* gfortran.dg/equiv_constraint_8.f90: Ditto.\n+\t* gfortran.dg/impure_assignment_2.f90: Ditto.\n+\t* gfortran.dg/impure_assignment_3.f90: Ditto.\n+\t* gfortran.dg/intent_out_1.f90: Ditto.\n+\t* gfortran.dg/intent_out_3.f90: Ditto.\n+\t* gfortran.dg/pointer_assign_7.f90: Ditto.\n+\t* gfortran.dg/pointer_intent_3.f90: Ditto.\n+\t* gfortran.dg/pr19936_1.f90: Ditto.\n+\t* gfortran.dg/proc_ptr_comp_3.f90: Ditto.\n+\t* gfortran.dg/simpleif_2.f90: Ditto.\n+\t* gfortran.dg/protected_5.f90: Ditto.\n+\t* gfortran.dg/protected_4.f90: Ditto and remove invalid error check.\n+\t* gfortran.dg/protected_6.f90: Ditto.\n+\t* gfortran.dg/protected_7.f90: Ditto.\n+\n 2010-09-22  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/45710"}, {"sha": "1f0864ba37154366121b1acea6d9da123f22b0de", "filename": "gcc/testsuite/gfortran.dg/allocatable_dummy_2.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_2.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -16,13 +16,13 @@ end subroutine init\n     subroutine init2(x)\n         integer, allocatable, intent(in) :: x(:)\n \n-        allocate(x(3)) ! { dg-error \"Cannot allocate\" }\n+        allocate(x(3)) ! { dg-error \"variable definition context\" }\n     end subroutine init2\n \n     subroutine kill(x)\n         integer, allocatable, intent(in) :: x(:)\n         \n-        deallocate(x) ! { dg-error \"Cannot deallocate\" }\n+        deallocate(x) ! { dg-error \"variable definition context\" }\n     end subroutine kill\n \n end program alloc_dummy"}, {"sha": "a52b71e4984ba7b2e8be652e17243af983eda74b", "filename": "gcc/testsuite/gfortran.dg/allocate_alloc_opt_2.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_alloc_opt_2.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -6,7 +6,7 @@ subroutine sub(i, j, err)\n    integer, intent(in), allocatable :: i(:)\n    integer, allocatable :: m(:)\n    integer n\n-   allocate(i(2))                    ! { dg-error \"Cannot allocate\" \"\" }\n-   allocate(m(2), stat=j)            ! { dg-error \"cannot be\" \"\" }\n-   allocate(m(2),stat=n,errmsg=err)  ! { dg-error \"cannot be\" \"\" }\n+   allocate(i(2)) ! { dg-error \"variable definition context\" }\n+   allocate(m(2), stat=j) ! { dg-error \"variable definition context\" }\n+   allocate(m(2),stat=n,errmsg=err) ! { dg-error \"variable definition context\" }\n end subroutine sub"}, {"sha": "64345d323f3216946c2e3815aee5904f71d57f9e", "filename": "gcc/testsuite/gfortran.dg/associate_5.f03", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_5.f03?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -18,9 +18,26 @@ PROGRAM main\n     ptr => a ! { dg-error \"neither TARGET nor POINTER\" }\n   END ASSOCIATE\n \n-  ASSOCIATE (a => 5, & ! { dg-error \"variable definition context\" }\n-             b => arr((/ 1, 3 /))) ! { dg-error \"variable definition context\" }\n-    a = 4\n-    b = 7\n+  ASSOCIATE (a => 5, b => arr((/ 1, 3 /)))\n+    a = 4 ! { dg-error \"variable definition context\" }\n+    b = 7 ! { dg-error \"variable definition context\" }\n+    CALL test2 (a) ! { dg-error \"variable definition context\" }\n+    CALL test2 (b) ! { dg-error \"variable definition context\" }\n   END ASSOCIATE\n+\n+CONTAINS\n+\n+  SUBROUTINE test (x)\n+    INTEGER, INTENT(IN) :: x\n+    ASSOCIATE (y => x) ! { dg-error \"variable definition context\" }\n+      y = 5 ! { dg-error \"variable definition context\" }\n+      CALL test2 (x) ! { dg-error \"variable definition context\" }\n+    END ASSOCIATE\n+  END SUBROUTINE test\n+\n+  ELEMENTAL SUBROUTINE test2 (x)\n+    INTEGER, INTENT(OUT) :: x\n+    x = 5\n+  END SUBROUTINE test2\n+\n END PROGRAM main"}, {"sha": "f3bfb04b2c827891004cf243d5782703a6730bd9", "filename": "gcc/testsuite/gfortran.dg/char_expr_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_expr_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_expr_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_expr_2.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -11,5 +11,5 @@ subroutine foo(x)\n   end subroutine foo\n end interface\n character :: n(5)\n-call foo( (n) ) ! { dg-error \"must be definable\" }\n+call foo( (n) ) ! { dg-error \"Non-variable expression\" }\n end"}, {"sha": "0df75825195a0215257ec74b55b52bf4b1d77c75", "filename": "gcc/testsuite/gfortran.dg/deallocate_alloc_opt_2.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeallocate_alloc_opt_2.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -6,7 +6,7 @@ subroutine sub(i, j, err)\n    integer, intent(in), allocatable :: i(:)\n    integer, allocatable :: m(:)\n    integer n\n-   deallocate(i)                    ! { dg-error \"Cannot deallocate\" \"\" }\n-   deallocate(m, stat=j)            ! { dg-error \"cannot be\" \"\" }\n-   deallocate(m,stat=n,errmsg=err)  ! { dg-error \"cannot be\" \"\" }\n+   deallocate(i)                    ! { dg-error \"variable definition context\" }\n+   deallocate(m, stat=j)            ! { dg-error \"variable definition context\" }\n+   deallocate(m,stat=n,errmsg=err)  ! { dg-error \"variable definition context\" }\n end subroutine sub"}, {"sha": "8f7aea1f02e7469c03231d9ab3687c5da405025a", "filename": "gcc/testsuite/gfortran.dg/enum_2.f90", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_2.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -9,5 +9,7 @@ program main\n     enumerator blue = 1  ! { dg-error \"Syntax error in ENUMERATOR definition\" }\n   end enum\n \n+  red = 42 ! { dg-error \"variable definition context\" }\n+\n   enumerator :: sun  ! { dg-error \"ENUM\" }\n end program main"}, {"sha": "81a1dd5dfa4382f0193a7321e8bf96b2dc83a26d", "filename": "gcc/testsuite/gfortran.dg/enum_5.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fenum_5.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -10,7 +10,7 @@ program main\n     enumerator :: blue = 1  \n   end enum junk  ! { dg-error \"Syntax error\" }\n \n-  blue = 10  ! { dg-error \" assign to a named constant\" }\n+  blue = 10  ! { dg-error \"Unexpected assignment\" }\n \n end program main  ! { dg-error \"Expecting END ENUM\" }\n  ! { dg-error \"Unexpected end of file\" \"\" { target \"*-*-*\" } 0 }"}, {"sha": "1cb28b0318fea6c9c37913d0aef84e68c19f171d", "filename": "gcc/testsuite/gfortran.dg/equiv_constraint_8.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fequiv_constraint_8.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -9,7 +9,7 @@ pure integer function test(j)\n   common /z/ i\n   integer :: k\n   equivalence(i,k) ! { dg-error \"EQUIVALENCE object in the pure\" }\n-  k=1 ! { dg-error \"in PURE procedure at\" }\n+  k=1 ! { dg-error \"variable definition context\" }\n   test=i*j\n end function test\n end"}, {"sha": "6378ec8a47b38e812bc56ccdbbb109621c720a7f", "filename": "gcc/testsuite/gfortran.dg/impure_assignment_2.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_2.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -23,7 +23,7 @@ PURE FUNCTION give_next1(node)\n      TYPE(node_type), POINTER :: node\n      TYPE(node_type), POINTER :: give_next\n      give_next => node%next ! { dg-error \"Bad target\" }\n-     node%next => give_next ! { dg-error \"Bad pointer object\" }\n+     node%next => give_next ! { dg-error \"variable definition context\" }\n   END FUNCTION\n ! Comment #2\n   PURE integer FUNCTION give_next2(i)\n@@ -55,14 +55,14 @@ PURE FUNCTION TST(A) RESULT(RES)\n     TYPE(T1), POINTER :: RES\n     RES => A  ! { dg-error \"Bad target\" }\n     RES => B  ! { dg-error \"Bad target\" }\n-    B => RES  ! { dg-error \"Bad pointer object\" }\n+    B => RES  ! { dg-error \"variable definition context\" }\n   END FUNCTION\n   PURE FUNCTION TST2(A) RESULT(RES)\n     TYPE(T1), INTENT(IN), TARGET :: A\n     TYPE(T1), POINTER :: RES\n     allocate (RES)\n     RES = A\n-    B = RES  ! { dg-error \"Cannot assign\" }\n+    B = RES  ! { dg-error \"variable definition context\" }\n     RES = B\n   END FUNCTION\n END MODULE pr20882"}, {"sha": "8be19896ef59cafbb2c9c461014a6638cafa7d00", "filename": "gcc/testsuite/gfortran.dg/impure_assignment_3.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimpure_assignment_3.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -20,7 +20,7 @@ pure subroutine sub1(x)\n     class is (myType)\n       x%a = 42.\n       r3 =  43.\n-      g = 44.             ! { dg-error \"Cannot assign to variable\" }\n+      g = 44.             ! { dg-error \"variable definition context\" }\n     end select\n   end subroutine\n \n@@ -30,7 +30,7 @@ pure subroutine sub2\n       real :: r2\n       r1 = 45.\n       r2 = 46.\n-      g = 47.             ! { dg-error \"Cannot assign to variable\" }\n+      g = 47.             ! { dg-error \"variable definition context\" }\n     end block\n   end subroutine\n "}, {"sha": "98338bf47ad1821df775a3e7642b414fbba3cf53", "filename": "gcc/testsuite/gfortran.dg/intent_out_1.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_1.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -3,10 +3,10 @@\n ! Contributed by Paul Thomas  <pault@gcc@gnu.org>\n   real, parameter :: a =42.0\n   real :: b\n-  call foo(b + 2.0)    ! { dg-error \"must be definable\" }\n-  call foo(a)          ! { dg-error \"must be definable\" }\n-  call bar(b + 2.0)    ! { dg-error \"must be definable\" }\n-  call bar(a)          ! { dg-error \"must be definable\" }\n+  call foo(b + 2.0)    ! { dg-error \"variable definition context\" }\n+  call foo(a)          ! { dg-error \"variable definition context\" }\n+  call bar(b + 2.0)    ! { dg-error \"variable definition context\" }\n+  call bar(a)          ! { dg-error \"variable definition context\" }\n contains\n   subroutine foo(a)\n     real, intent(out) :: a"}, {"sha": "e3300c988f50ecf48c32d2d3dc63a9d1cd6508df", "filename": "gcc/testsuite/gfortran.dg/intent_out_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_out_3.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -15,6 +15,6 @@ SUBROUTINE S1(J)\n  END SUBROUTINE S1\n END MODULE M1\n USE M1\n-CALL S1(D1%I(3)) ! { dg-error \"must be definable\" }\n+CALL S1(D1%I(3)) ! { dg-error \"variable definition context\" }\n END\n ! { dg-final { cleanup-modules \"m1\" } }"}, {"sha": "1f39f7551a25ba8c6ff5cfe0c101348d25f2d15c", "filename": "gcc/testsuite/gfortran.dg/intrinsic_intent_1.f03", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_intent_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_intent_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_intent_1.f03?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -0,0 +1,11 @@\n+! { dg-do compile }\n+\n+! PR fortran/45474\n+! Definability checks for INTENT([IN]OUT) and intrinsics.\n+\n+! Contributed by Tobias Burnus, burnus@gcc.gnu.org.\n+\n+call execute_command_line(\"date\", .true.,(1),1,'aa') ! { dg-error \"variable definition context\" }\n+call execute_command_line(\"date\", .true.,1,(1),'aa') ! { dg-error \"variable definition context\" }\n+call execute_command_line(\"date\", .true.,1,1,('aa')) ! { dg-error \"variable definition context\" }\n+end"}, {"sha": "c85dc72c8ff65fa630668608bf655ca644485838", "filename": "gcc/testsuite/gfortran.dg/pointer_assign_7.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_assign_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_assign_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_assign_7.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -18,7 +18,7 @@ program point_of_no_return\n allocate(face)\n allocate(blu)\n \n-face%bla => blu  ! { dg-error \"Pointer assignment to non-POINTER\" }\n+face%bla => blu  ! { dg-error \"Non-POINTER in pointer association context\" }\n \n end program\n "}, {"sha": "7f87d10e9bbb6b41f68b1e4f7d2ce91d986441e5", "filename": "gcc/testsuite/gfortran.dg/pointer_intent_3.f90", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_intent_3.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -19,11 +19,11 @@ program test\n contains\n   subroutine a(p)\n     integer, pointer,intent(in) :: p\n-    p => null(p)! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n-    nullify(p)  ! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n-    allocate(p) ! { dg-error \"Cannot allocate INTENT\\\\(IN\\\\) variable\" }\n-    call c(p)   ! { dg-error \"is INTENT\\\\(IN\\\\) while interface specifies INTENT\\\\(INOUT\\\\)\" }\n-    deallocate(p) ! { dg-error \"Cannot deallocate INTENT\\\\(IN\\\\) variable\" }\n+    p => null(p)! { dg-error \"pointer association context\" }\n+    nullify(p)  ! { dg-error \"pointer association context\" }\n+    allocate(p) ! { dg-error \"pointer association context\" }\n+    call c(p)   ! { dg-error \"pointer association context\" }\n+    deallocate(p) ! { dg-error \"pointer association context\" }\n   end subroutine\n   subroutine c(p)\n     integer, pointer, intent(inout) :: p\n@@ -32,10 +32,10 @@ end subroutine c\n   subroutine b(t)\n     type(myT),intent(in) :: t\n     t%jp = 5\n-    t%jp => null(t%jp)  ! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n-    nullify(t%jp) ! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n-    t%j = 7 ! { dg-error \"Cannot assign to INTENT\\\\(IN\\\\) variable\" }\n-    allocate(t%jp) ! { dg-error \"Cannot allocate INTENT\\\\(IN\\\\) variable\" }\n-    deallocate(t%jp) ! { dg-error \"Cannot deallocate INTENT\\\\(IN\\\\) variable\" }\n+    t%jp => null(t%jp)  ! { dg-error \"pointer association context\" }\n+    nullify(t%jp) ! { dg-error \"pointer association context\" }\n+    t%j = 7 ! { dg-error \"variable definition context\" }\n+    allocate(t%jp) ! { dg-error \"pointer association context\" }\n+    deallocate(t%jp) ! { dg-error \"pointer association context\" }\n   end subroutine b\n end program"}, {"sha": "440c1d9d7026ed3f564ddb2d7c549e0bf8e6bf07", "filename": "gcc/testsuite/gfortran.dg/pr19936_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19936_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19936_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr19936_1.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n program pr19936_1\n   integer, parameter :: i=4\n-  print *,(/(i,i=1,4)/) ! { dg-error \"assign to a named constant\" }\n+  print *,(/(i,i=1,4)/) ! { dg-error \"variable definition context\" }\n end program pr19936_1"}, {"sha": "67d5b5360683dad0f1f1a94a3cb6ad20ed4c5888", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -38,7 +38,7 @@ subroutine sub\n \n x%ptr2 => x       ! { dg-error \"Invalid procedure pointer assignment\" }\n \n-x => x%ptr2       ! { dg-error \"Pointer assignment to non-POINTER\" }\n+x => x%ptr2       ! { dg-error \"Non-POINTER in pointer association context\" }\n \n print *, x%ptr1() ! { dg-error \"attribute conflicts with\" }\n call x%ptr2()     ! { dg-error \"attribute conflicts with\" }"}, {"sha": "7f0e49f09a480679d0eaad720eeee09f5c5e0fef", "filename": "gcc/testsuite/gfortran.dg/protected_4.f90", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_4.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -23,15 +23,15 @@ program main\n   integer   :: j \n   logical   :: asgnd\n   protected :: j ! { dg-error \"only allowed in specification part of a module\" }\n-  a = 43       ! { dg-error \"Assigning to PROTECTED variable\" }\n-  ap => null() ! { dg-error \"Assigning to PROTECTED variable\" }\n-  nullify(ap)  ! { dg-error \"Assigning to PROTECTED variable\" }\n-  ap => at     ! { dg-error \"Assigning to PROTECTED variable\" }\n-  ap = 3       ! { dg-error \"Assigning to PROTECTED variable\" }\n-  allocate(ap) ! { dg-error \"Assigning to PROTECTED variable\" }\n-  ap = 73      ! { dg-error \"Assigning to PROTECTED variable\" }\n-  call increment(a,at) ! { dg-error \"use-associated with PROTECTED attribute\" }\n-  call pointer_assignments(ap) ! { dg-error \"is use-associated with PROTECTED attribute\" }\n+  a = 43       ! { dg-error \"variable definition context\" }\n+  ap => null() ! { dg-error \"pointer association context\" }\n+  nullify(ap)  ! { dg-error \"pointer association context\" }\n+  ap => at     ! { dg-error \"pointer association context\" }\n+  ap = 3       ! OK\n+  allocate(ap) ! { dg-error \"pointer association context\" }\n+  ap = 73      ! OK\n+  call increment(a,at) ! { dg-error \"variable definition context\" }\n+  call pointer_assignments(ap) ! { dg-error \"pointer association context\" }\n   asgnd = pointer_check(ap)\n contains\n   subroutine increment(a1,a3)"}, {"sha": "85046c3cb9ae194a3de38543a5c83af42bc72418", "filename": "gcc/testsuite/gfortran.dg/protected_5.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_5.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -49,9 +49,9 @@ end module good2\n program main\n   use good2\n   implicit none\n-  t%j = 15             ! { dg-error \"Assigning to PROTECTED variable\" }\n-  nullify(t%p)         ! { dg-error \"Assigning to PROTECTED variable\" }\n-  allocate(t%array(15))! { dg-error \"Assigning to PROTECTED variable\" }\n+  t%j = 15             ! { dg-error \"variable definition context\" }\n+  nullify(t%p)         ! { dg-error \"pointer association context\" }\n+  allocate(t%array(15))! { dg-error \"variable definition context\" }\n end program main\n \n ! { dg-final { cleanup-modules \"good1 good2 bad1 bad2\" } }"}, {"sha": "e7f3e4e933742b3379dec89d120090942c83f8ef", "filename": "gcc/testsuite/gfortran.dg/protected_6.f90", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_6.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -19,15 +19,15 @@ end module protmod\n program main\n   use protmod\n   implicit none\n-  a = 43       ! { dg-error \"Assigning to PROTECTED variable\" }\n-  ap => null() ! { dg-error \"Assigning to PROTECTED variable\" }\n-  nullify(ap)  ! { dg-error \"Assigning to PROTECTED variable\" }\n-  ap => at     ! { dg-error \"Assigning to PROTECTED variable\" }\n-  ap = 3       ! { dg-error \"Assigning to PROTECTED variable\" }\n-  allocate(ap) ! { dg-error \"Assigning to PROTECTED variable\" }\n-  ap = 73      ! { dg-error \"Assigning to PROTECTED variable\" }\n-  call increment(a,at) ! { dg-error \"use-associated with PROTECTED attribute\" }\n-  call pointer_assignments(ap) ! { dg-error \"is use-associated with PROTECTED attribute\" }\n+  a = 43       ! { dg-error \"variable definition context\" }\n+  ap => null() ! { dg-error \"pointer association context\" }\n+  nullify(ap)  ! { dg-error \"pointer association context\" }\n+  ap => at     ! { dg-error \"pointer association context\" }\n+  ap = 3       ! OK\n+  allocate(ap) ! { dg-error \"pointer association context\" }\n+  ap = 73      ! OK\n+  call increment(a,at) ! { dg-error \"variable definition context\" }\n+  call pointer_assignments(ap) ! { dg-error \"pointer association context\" }\n contains\n   subroutine increment(a1,a3)\n     integer, intent(inout) :: a1, a3"}, {"sha": "abdc9592aaf345f4808bbb036c380cbbad460035", "filename": "gcc/testsuite/gfortran.dg/protected_7.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fprotected_7.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -13,8 +13,8 @@ program p\n   integer, pointer :: unprotected_pointer\n   ! The next two lines should be rejected; see PR 37513 why\n   ! we get such a strange error message.\n-  protected_pointer => unprotected_pointer ! { dg-error \"only allowed in specification part\" }\n-  protected_pointer =  unprotected_pointer ! { dg-error \"only allowed in specification part\" }\n+  protected_pointer => unprotected_pointer ! { dg-error \"pointer association context\" }\n+  protected_pointer =  unprotected_pointer ! OK\n   unprotected_pointer => protected_target  ! { dg-error \"target has PROTECTED attribute\" }\n   unprotected_pointer => protected_pointer ! OK\n end program p"}, {"sha": "af2a489d9714fda6274ad84e750ef40afe3f87f5", "filename": "gcc/testsuite/gfortran.dg/select_type_17.f03", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_17.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_17.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fselect_type_17.f03?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+\n+! PR fortran/44044\n+! Definability check for select type to expression.\n+! This is \"bonus feature #2\" from comment #3 of the PR.\n+\n+! Contributed by Janus Weil, janus@gcc.gnu.org.\n+\n+implicit none\n+\n+type :: t1\n+  integer :: i\n+end type\n+\n+type, extends(t1) :: t2\n+end type\n+\n+type(t1),target :: x1\n+type(t2),target :: x2\n+\n+select type ( y => fun(1) )\n+type is (t1)\n+  y%i = 1 ! { dg-error \"variable definition context\" }\n+type is (t2)\n+  y%i = 2 ! { dg-error \"variable definition context\" }\n+end select\n+\n+contains\n+\n+  function fun(i)\n+    class(t1),pointer :: fun\n+    integer :: i\n+    if (i>0) then\n+      fun => x1\n+    else if (i<0) then\n+      fun => x2\n+    else\n+      fun => NULL()\n+    end if\n+  end function\n+\n+end\n+"}, {"sha": "09c0d380416db97745c83bb16f6130701f977f75", "filename": "gcc/testsuite/gfortran.dg/simpleif_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimpleif_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c91ab34b56a860e60459d56b488054774d4f6ee/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimpleif_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimpleif_2.f90?ref=8c91ab34b56a860e60459d56b488054774d4f6ee", "patch": "@@ -10,6 +10,6 @@ module read\n     subroutine a\n       integer, parameter :: n = 2\n       if (i .eq. 0) read(j,*) k\n-      if (i .eq. 0) n = j    ! { dg-error \"assign to a named constant\" \"\" }\n+      if (i .eq. 0) n = j    ! { dg-error \"Named constant 'n' in variable definition context\" }\n     end subroutine a\n end module read"}]}