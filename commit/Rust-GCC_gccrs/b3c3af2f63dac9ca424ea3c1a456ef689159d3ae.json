{"sha": "b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNjM2FmMmY2M2RhYzljYTQyNGVhM2MxYTQ1NmVmNjg5MTU5ZDNhZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-08-05T14:11:53Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-08-05T14:11:53Z"}, "message": "tree.h (DID_INLINE_FUNC): Remove macro.\n\n2003-08-05  Steven Bosscher  <steven@gcc.gnu.org>\n\n\t* tree.h (DID_INLINE_FUNC): Remove macro.\n\t(DECL_DECLARED_INLINE_P): Move from c-tree.h and cp/cp-tree.h,\n\tadd tree check for FUNCTION_DECL.\n\t(DECL_ESTIMATED_INSNS): Move from c-common.h and java/java-tree.h.\n\t(struct tree_decl): Rename inlined_function_flag to\n\tdeclared_inline_flag.\n\t* c-common.h (c_lang_decl): Remove.\n\t(DECL_ESTIMATED_INSNS): Remove.\n\t* c-tree.h (struct lang_decl): Don't include c_lang_decl.\n\t(DECL_DECLARED_INLINE_P): Remove.\n\t* c-decl.c (grokdeclarator): Update comment.  With -finline-functions,\n\tdo not reset DECL_DECLARED_INLINE_P.  Don't use DID_INLINE_FUNC.\n\t(finish_function): Make uninlinable a bool.  Fixup call to\n\ttree_inlinable_function_p() and fix some code style issues.\n\t* cgraph.h (disgread_inline_limits): Fix spelling: `disregard'.\n\t* cgraph.c (dump_cgraph): Likewise.\n\t* cgraphunit.c (cgraph_decide_inlining): Likewise\n\t(cgraph_finalize_compilation_unit): Likewise.\n\tAlso update call to tree_inlinable_function_p().\n\t(cgraph_default_inline_p): Don't use DID_INLINE_FUNC.  Instead\n\tlook at DECL_DECLARED_INLINE and reverse logic.\n\t* print-tree.c (print_node): Likewise.\n\t* toplev.c (rest_of_handle_inlining): Don't use DID_INLINE_FUNC.\n\t* tree-inline.h (tree_inlinable_function_p): Make a bool.  Update\n\tprototype.\n\t* tree-inline.c (inlinable_function_p): Split up in this function to\n\tcheck for basic inlining inhibiting conditions, and new\n\tlimits_allow_inlining() function.  Warn if inlining is impossible\n\tbecause the inline candidate calls alloca or uses sjlj exceptions.\n\t(limits_allow_inlining): this new function to check if the inlining\n\tlimits are satisfied.  Throttle from currfn_max_inline_insns, not from\n\tMAX_INLINE_INSNS_SINGLE.  The latter only makes sense if\n\tMAX_INLINE_INSNS_AUTO and MAX_INLINE_INSNS_SINGLE are equal.\n\tUpdate prototypes.\n\t(tree_inlinable_function_p): Make a bool.  Update call to\n\tinlinable_function_p\n\t(expand_call_inline): Use limits_allow_inlining() when not in\n\tunit-at-a-time mode to decide on inlining.  Don't use DID_INLINE_FUNC,\n\tinstead see if the function was declared `inline'.\n\ncp/\n\t* cp-tree.h (struct lang_decl): Don't include c_lang_decl.\n\t(DECL_DECLARED_INLINE_P): Remove.\n\t* decl2.c (import_export_decl): Only look at DECL_DECLARED_INLINE_P\n\tif decl is a FUNCTION_DECL.  This never made sense, but now it is\n\trequired to avoid a tree check failure.\n\t* decl.c (grokfndecl): Don't touch DID_INLINE_FUNC.\n\t* optimize.c (maybe_clone_body): Likewise.\n\njava/\n\t* java-tree.h (DECL_ESTIMATED_INSNS): Remove.\n\nFrom-SVN: r70174", "tree": {"sha": "f99d1c794a4de2c3fc4751de63ab48b0674a8860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f99d1c794a4de2c3fc4751de63ab48b0674a8860"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/comments", "author": null, "committer": null, "parents": [{"sha": "158aa0f72ec70e63bd8e4efd3f4edadd2d95f96d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/158aa0f72ec70e63bd8e4efd3f4edadd2d95f96d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/158aa0f72ec70e63bd8e4efd3f4edadd2d95f96d"}], "stats": {"total": 450, "additions": 258, "deletions": 192}, "files": [{"sha": "09a41402d68da36763666a62b9e38490eee59b18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -1,3 +1,45 @@\n+2003-08-05  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tree.h (DID_INLINE_FUNC): Remove macro.\n+\t(DECL_DECLARED_INLINE_P): Move from c-tree.h and cp/cp-tree.h,\n+\tadd tree check for FUNCTION_DECL.\n+\t(DECL_ESTIMATED_INSNS): Move from c-common.h and java/java-tree.h.\n+\t(struct tree_decl): Rename inlined_function_flag to\n+\tdeclared_inline_flag.\n+\t* c-common.h (c_lang_decl): Remove.\n+\t(DECL_ESTIMATED_INSNS): Remove.\n+\t* c-tree.h (struct lang_decl): Don't include c_lang_decl.\n+\t(DECL_DECLARED_INLINE_P): Remove.\n+\t* c-decl.c (grokdeclarator): Update comment.  With -finline-functions,\n+\tdo not reset DECL_DECLARED_INLINE_P.  Don't use DID_INLINE_FUNC.\n+\t(finish_function): Make uninlinable a bool.  Fixup call to\n+\ttree_inlinable_function_p() and fix some code style issues.\n+\t* cgraph.h (disgread_inline_limits): Fix spelling: `disregard'.\n+\t* cgraph.c (dump_cgraph): Likewise.\n+\t* cgraphunit.c (cgraph_decide_inlining): Likewise\n+\t(cgraph_finalize_compilation_unit): Likewise.\n+\tAlso update call to tree_inlinable_function_p().\n+\t(cgraph_default_inline_p): Don't use DID_INLINE_FUNC.  Instead\n+\tlook at DECL_DECLARED_INLINE and reverse logic.\n+\t* print-tree.c (print_node): Likewise.\n+\t* toplev.c (rest_of_handle_inlining): Don't use DID_INLINE_FUNC.\n+\t* tree-inline.h (tree_inlinable_function_p): Make a bool.  Update\n+\tprototype.\n+\t* tree-inline.c (inlinable_function_p): Split up in this function to\n+\tcheck for basic inlining inhibiting conditions, and new\n+\tlimits_allow_inlining() function.  Warn if inlining is impossible\n+\tbecause the inline candidate calls alloca or uses sjlj exceptions.\n+\t(limits_allow_inlining): this new function to check if the inlining\n+\tlimits are satisfied.  Throttle from currfn_max_inline_insns, not from\n+\tMAX_INLINE_INSNS_SINGLE.  The latter only makes sense if\n+\tMAX_INLINE_INSNS_AUTO and MAX_INLINE_INSNS_SINGLE are equal.\n+\tUpdate prototypes.\n+\t(tree_inlinable_function_p): Make a bool.  Update call to\n+\tinlinable_function_p\n+\t(expand_call_inline): Use limits_allow_inlining() when not in\n+\tunit-at-a-time mode to decide on inlining.  Don't use DID_INLINE_FUNC,\n+\tinstead see if the function was declared `inline'.\n+\n 2003-08-05  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* gcse.c (try_replace_reg): Fix updating of note."}, {"sha": "bda560313e7de344163e9e92fb03e31ffd8899a7", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -346,22 +346,6 @@ extern void shadow_warning (enum sw_kind, const char *, tree);\n extern int field_decl_cmp (const void *, const void *);\n extern void resort_sorted_fields (void *, void *, gt_pointer_operator, \n                                   void *);\n-\n-/* Extra information associated with a DECL.  Other C dialects extend\n-   this structure in various ways.  The C front-end only uses this\n-   structure for FUNCTION_DECLs; all other DECLs have a NULL\n-   DECL_LANG_SPECIFIC field.  */\n-\n-struct c_lang_decl GTY(()) {\n-  unsigned declared_inline : 1;\n-};\n-\n-/* In a FUNCTION_DECL for which DECL_BUILT_IN does not hold, this is\n-     the approximate number of statements in this function.  There is\n-     no need for this number to be exact; it is only used in various\n-     heuristics regarding optimization.  */\n-#define DECL_ESTIMATED_INSNS(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n \f\n /* Switches common to the C front ends.  */\n "}, {"sha": "9c6af8035d296fbaab95e1a974e76a0a49c379be", "filename": "gcc/c-decl.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -4319,7 +4319,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  }\n \telse if (inlinep)\n \t  {\n-\t    /* Assume that otherwise the function can be inlined.  */\n+\t    /* Record that the function is declared `inline'.  */\n \t    DECL_DECLARED_INLINE_P (decl) = 1;\n \n \t    /* Do not mark bare declarations as DECL_INLINE.  Doing so\n@@ -4337,12 +4337,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t   two things: let the function be deferred until it is actually\n \t   needed, and let dwarf2 know that the function is inlinable.  */\n \telse if (flag_inline_trees == 2 && initialized)\n-\t  {\n-\t    if (!DECL_INLINE (decl))\n-\t\tDID_INLINE_FUNC (decl) = 1;\n-\t    DECL_INLINE (decl) = 1;\n-\t    DECL_DECLARED_INLINE_P (decl) = 0;\n-\t  }\n+\t  DECL_INLINE (decl) = 1;\n       }\n     else\n       {\n@@ -6157,7 +6152,7 @@ finish_function (int nested, int can_defer_p)\n       /* Function is parsed.\n \t Generate RTL for the body of this function or defer\n \t it for later expansion.  */\n-      int uninlinable = 1;\n+      bool uninlinable = true;\n \n       /* There's no reason to do any of the work here if we're only doing\n \t semantic analysis; this code just generates RTL.  */\n@@ -6174,14 +6169,14 @@ finish_function (int nested, int can_defer_p)\n \t     predicates depend on cfun and current_function_decl to\n \t     function completely.  */\n \t  timevar_push (TV_INTEGRATION);\n-\t  uninlinable = ! tree_inlinable_function_p (fndecl, 0);\n+\t  uninlinable = !tree_inlinable_function_p (fndecl);\n \n \t  if (can_defer_p\n \t      /* We defer functions marked inline *even if* the function\n \t\t itself is not inlinable.  This is because we don't yet\n \t\t know if the function will actually be used; we may be\n \t\t able to avoid emitting it entirely.  */\n-\t      && (! uninlinable || DECL_DECLARED_INLINE_P (fndecl))\n+\t      && (!uninlinable || DECL_DECLARED_INLINE_P (fndecl))\n \t      /* Save function tree for inlining.  Should return 0 if the\n \t\t language does not support function deferring or the\n \t\t function could not be deferred.  */"}, {"sha": "48b91f59199306443485a50903945f8eaf711758", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -58,7 +58,6 @@ union lang_tree_node\n \n struct lang_decl GTY(())\n {\n-  struct c_lang_decl base;\n   /* The return types and parameter types may have variable size.\n      This is a list of any SAVE_EXPRs that need to be evaluated to\n      compute those sizes.  */\n@@ -100,12 +99,6 @@ struct lang_decl GTY(())\n    and C_RID_YYCODE is the token number wanted by Yacc.  */\n #define C_IS_RESERVED_WORD(ID) TREE_LANG_FLAG_0 (ID)\n \n-/* This function was declared inline.  This flag controls the linkage\n-   semantics of 'inline'; whether or not the function is inlined is\n-   controlled by DECL_INLINE.  */\n-#define DECL_DECLARED_INLINE_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->base.declared_inline)\n-\n /* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n struct lang_type GTY(())\n {"}, {"sha": "fedecbcdba5718bc98bf7aa4b6e2cfc10e81910e", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -353,7 +353,7 @@ dump_cgraph (FILE *f)\n       if (DECL_SAVED_TREE (node->decl))\n \tfprintf (f, \" tree\");\n \n-      if (node->local.disgread_inline_limits)\n+      if (node->local.disregard_inline_limits)\n \tfprintf (f, \" always_inline\");\n       else if (node->local.inlinable)\n \tfprintf (f, \" inlinable\");"}, {"sha": "849c8ee5486e9414c07e70a26ec00f4704b284f7", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -33,10 +33,10 @@ struct cgraph_local_info GTY(())\n   /* Set once it has been finalized so we consider it to be output.  */\n   bool finalized;\n \n-  /* False when there is something making inlining impossible (such as va_arg) */\n+  /* False when there something makes inlining impossible (such as va_arg).  */\n   bool inlinable;\n   /* True when function should be inlined independently on it's size.  */\n-  bool disgread_inline_limits;\n+  bool disregard_inline_limits;\n   /* Size of the function before inlining.  */\n   int self_insns;\n };"}, {"sha": "b75c717e922dd9bc7b4ef56aa9a872b43deba055", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -189,12 +189,12 @@ cgraph_finalize_compilation_unit (void)\n       /* First kill forward declaration so reverse inlining works properly.  */\n       cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n \n-      node->local.inlinable = tree_inlinable_function_p (decl, 1);\n+      node->local.inlinable = tree_inlinable_function_p (decl);\n       DECL_ESTIMATED_INSNS (decl)\n         = (*lang_hooks.tree_inlining.estimate_num_insns) (decl);\n       node->local.self_insns = DECL_ESTIMATED_INSNS (decl);\n       if (node->local.inlinable)\n-\tnode->local.disgread_inline_limits\n+\tnode->local.disregard_inline_limits\n \t  = (*lang_hooks.tree_inlining.disregard_inline_limits) (decl);\n \n       for (edge = node->callees; edge; edge = edge->next_callee)\n@@ -321,7 +321,7 @@ cgraph_postorder (struct cgraph_node **order)\n   struct cgraph_edge *edge, last;\n \n   struct cgraph_node **stack =\n-    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n \n   /* We have to deal with cycles nicely, so use a depth first traversal\n      output algorithm.  Ignore the fact that some functions won't need\n@@ -735,10 +735,10 @@ cgraph_default_inline_p (struct cgraph_node *n)\n {\n   if (!DECL_INLINE (n->decl) || !DECL_SAVED_TREE (n->decl))\n     return false;\n-  if (DID_INLINE_FUNC (n->decl))\n-    return n->global.insns < MAX_INLINE_INSNS_AUTO;\n-  else\n+  if (DECL_DECLARED_INLINE_P (n->decl))\n     return n->global.insns < MAX_INLINE_INSNS_SINGLE;\n+  else\n+    return n->global.insns < MAX_INLINE_INSNS_AUTO;\n }\n \n /* We use greedy algorithm for inlining of small functions:\n@@ -756,7 +756,7 @@ cgraph_decide_inlining_of_small_functions (struct cgraph_node **inlined,\n   struct cgraph_node *node;\n   fibheap_t heap = fibheap_new ();\n   struct fibnode **heap_node =\n-    xcalloc (sizeof (struct fibnode *), cgraph_max_uid);\n+    xcalloc (cgraph_max_uid, sizeof (struct fibnode *));\n   int ninlined, ninlined_callees;\n   int max_insns = ((HOST_WIDEST_INT) initial_insns\n \t\t   * (100 + PARAM_VALUE (PARAM_INLINE_UNIT_GROWTH)) / 100);\n@@ -873,11 +873,11 @@ cgraph_decide_inlining (void)\n   struct cgraph_node *node;\n   int nnodes;\n   struct cgraph_node **order =\n-    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n   struct cgraph_node **inlined =\n-    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n   struct cgraph_node **inlined_callees =\n-    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n   int ninlined;\n   int ninlined_callees;\n   int i, y;\n@@ -917,7 +917,7 @@ cgraph_decide_inlining (void)\n       node = order[i];\n \n       for (e = node->callees; e; e = e->next_callee)\n-\tif (e->callee->local.disgread_inline_limits)\n+\tif (e->callee->local.disregard_inline_limits)\n \t  break;\n       if (!e)\n \tcontinue;\n@@ -928,7 +928,7 @@ cgraph_decide_inlining (void)\n       ninlined = cgraph_inlined_into (order[i], inlined);\n       for (; e; e = e->next_callee)\n \t{\n-\t  if (e->inline_call || !e->callee->local.disgread_inline_limits)\n+\t  if (e->inline_call || !e->callee->local.disregard_inline_limits)\n \t    continue;\n \t  if (e->callee->output || e->callee == node)\n \t    continue;\n@@ -1038,7 +1038,7 @@ cgraph_expand_functions (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_node **order =\n-    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+    xcalloc (cgraph_n_nodes, sizeof (struct cgraph_node *));\n   int order_pos = 0;\n   int i;\n "}, {"sha": "4cc62ac940816db230001e9eddf05e79d5848489", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -1,3 +1,13 @@\n+2003-08-05  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cp-tree.h (struct lang_decl): Don't include c_lang_decl.\n+\t(DECL_DECLARED_INLINE_P): Remove.\n+\t* decl2.c (import_export_decl): Only look at DECL_DECLARED_INLINE_P\n+\tif decl is a FUNCTION_DECL.  This never made sense, but now it is\n+\trequired to avoid a tree check failure.\n+\t* decl.c (grokfndecl): Don't touch DID_INLINE_FUNC.\n+\t* optimize.c (maybe_clone_body): Likewise.\n+\n 2003-08-04  Roger Sayle  <roger@eyesopen.com>\n \n \t* decl.c (cxx_insert_default_attributes): Delete."}, {"sha": "36dda85fe5b9ee57e2de728a4544721ce2d5f39f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -1637,8 +1637,6 @@ struct lang_type GTY(())\n \n struct lang_decl_flags GTY(())\n {\n-  struct c_lang_decl base;\n-\n   ENUM_BITFIELD(languages) language : 8;\n \n   unsigned operator_attr : 1;\n@@ -2849,12 +2847,6 @@ struct lang_decl GTY(())\n /* We know what we're doing with this decl now.  */\n #define DECL_INTERFACE_KNOWN(NODE) DECL_LANG_FLAG_5 (NODE)\n \n-/* This function was declared inline.  This flag controls the linkage\n-   semantics of 'inline'; whether or not the function is inlined is\n-   controlled by DECL_INLINE.  */\n-#define DECL_DECLARED_INLINE_P(NODE) \\\n-  (DECL_LANG_SPECIFIC (NODE)->decl_flags.base.declared_inline)\n-\n /* DECL_EXTERNAL must be set on a decl until the decl is actually emitted,\n    so that assemble_external will work properly.  So we have this flag to\n    tell us whether the decl is really not external.  */"}, {"sha": "503a635480c66e88a3ceb06d2f6102a95f421bec", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -8885,19 +8885,14 @@ grokfndecl (tree ctype,\n       DECL_NOT_REALLY_EXTERN (decl) = 1;\n     }\n \n-  DID_INLINE_FUNC (decl) = 0;\n   /* If the declaration was declared inline, mark it as such.  */\n   if (inlinep)\n     DECL_DECLARED_INLINE_P (decl) = 1;\n   /* We inline functions that are explicitly declared inline, or, when\n      the user explicitly asks us to, all functions.  */\n-  if (DECL_DECLARED_INLINE_P (decl))\n+  if (DECL_DECLARED_INLINE_P (decl)\n+      || (flag_inline_trees == 2 && !DECL_INLINE (decl) && funcdef_flag))\n     DECL_INLINE (decl) = 1;\n-  if (flag_inline_trees == 2 && !DECL_INLINE (decl) && funcdef_flag)\n-    {\n-      DID_INLINE_FUNC (decl) = 1;\n-      DECL_INLINE (decl) = 1;\n-    }\n \n   DECL_EXTERNAL (decl) = 1;\n   if (quals != NULL_TREE && TREE_CODE (type) == FUNCTION_TYPE)\n@@ -14248,8 +14243,6 @@ start_method (tree declspecs, tree declarator, tree attrlist)\n   check_template_shadow (fndecl);\n \n   DECL_DECLARED_INLINE_P (fndecl) = 1;\n-\n-  DID_INLINE_FUNC (fndecl) = 0;\n   if (flag_default_inline)\n     DECL_INLINE (fndecl) = 1;\n "}, {"sha": "46c4083c2a7bd630a2b2f586a1643a5d00a3efdc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -1743,7 +1743,8 @@ import_export_decl (tree decl)\n       if ((DECL_IMPLICIT_INSTANTIATION (decl)\n \t   || DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (decl))\n \t  && (flag_implicit_templates\n-\t      || (flag_implicit_inline_templates \n+\t      || (flag_implicit_inline_templates\n+\t\t  && TREE_CODE (decl) == FUNCTION_DECL \n \t\t  && DECL_DECLARED_INLINE_P (decl))))\n \t{\n \t  if (!TREE_PUBLIC (decl))"}, {"sha": "4cb5c695f3433cb6257c277f9979511b2ac48991", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -159,7 +159,6 @@ maybe_clone_body (tree fn)\n       /* Update CLONE's source position information to match FN's.  */\n       DECL_SOURCE_LOCATION (clone) = DECL_SOURCE_LOCATION (fn);\n       DECL_INLINE (clone) = DECL_INLINE (fn);\n-      DID_INLINE_FUNC (clone) = DID_INLINE_FUNC (fn);\n       DECL_DECLARED_INLINE_P (clone) = DECL_DECLARED_INLINE_P (fn);\n       DECL_COMDAT (clone) = DECL_COMDAT (fn);\n       DECL_WEAK (clone) = DECL_WEAK (fn);"}, {"sha": "bf11fa4d4ef124e2245a7c5d2ac9c3e86e619eb7", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -1,3 +1,7 @@\n+2003-08-05  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* java-tree.h (DECL_ESTIMATED_INSNS): Remove (moved to tree.h).\n+\n 2003-08-03  Tom Tromey  <tromey@redhat.com>\n \n \t* java-tree.h (METHOD_TRANSIENT): Removed."}, {"sha": "920d28866531c88804baaa2d331f5c93531babe1", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -906,12 +906,6 @@ union lang_tree_node\n /* The original WFL of a final variable. */\n #define DECL_FIELD_FINAL_WFL(NODE) \\\n   (DECL_LANG_SPECIFIC(NODE)->u.v.wfl)\n-/* In a FUNCTION_DECL for which DECL_BUILT_IN does not hold, this is\n-     the approximate number of instructions in this function.  There is\n-     no need for this number to be exact; it is only used in various\n-     heuristics regarding optimization.  */\n-#define DECL_ESTIMATED_INSNS(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n /* True if NODE is a local variable final. */\n #define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && DECL_FINAL (NODE))\n /* True if NODE is a final field. */"}, {"sha": "3d6c01e01eeb73e0cdee5729a987af5c59cb5a48", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -317,10 +317,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       if (TREE_CODE (node) == TYPE_DECL && TYPE_DECL_SUPPRESS_DEBUG (node))\n \tfputs (\" suppress-debug\", file);\n \n-      if (TREE_CODE (node) == FUNCTION_DECL && DID_INLINE_FUNC (node))\n-\tfputs (\" autoinline\", file);\n-      else if (TREE_CODE (node) == FUNCTION_DECL && DECL_INLINE (node))\n-\tfputs (\" inline\", file);\n+      if (TREE_CODE (node) == FUNCTION_DECL && DECL_INLINE (node))\n+\tfputs (DECL_DECLARED_INLINE_P (node) ? \" inline\" : \" autoinline\", file);\n       if (TREE_CODE (node) == FUNCTION_DECL && DECL_BUILT_IN (node))\n \tfputs (\" built-in\", file);\n       if (TREE_CODE (node) == FUNCTION_DECL && DECL_NO_STATIC_CHAIN (node))"}, {"sha": "1e5787783584b465957f7ff2a35f91a39addf462", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -2532,16 +2532,8 @@ rest_of_handle_inlining (tree decl)\n \t      return true;\n \t    }\n \t}\n-      else {\n-\t/* ??? Note that we used to just make it look like if\n-\t   the \"inline\" keyword was specified when we decide\n-\t   to inline it (because of -finline-functions).\n-\t   garloff@suse.de, 2002-04-24: Add another flag to\n-\t   actually record this piece of information.  */\n-\tif (!DECL_INLINE (decl))\n-\t  DID_INLINE_FUNC (decl) = 1;\n+      else\n \tinlinable = DECL_INLINE (decl) = 1;\n-      }\n     }\n \n   insns = get_insns ();"}, {"sha": "07664bdb69b301d4e366699ff4885977f80e55d7", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 159, "deletions": 99, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -116,7 +116,8 @@ static tree copy_body_r (tree *, int *, void *);\n static tree copy_body (inline_data *);\n static tree expand_call_inline (tree *, int *, void *);\n static void expand_calls_inline (tree *, inline_data *);\n-static int inlinable_function_p (tree, inline_data *, int);\n+static bool inlinable_function_p (tree);\n+static int limits_allow_inlining (tree, inline_data *);\n static tree remap_decl (tree, inline_data *);\n #ifndef INLINER_FOR_JAVA\n static tree initialize_inlined_parameters (inline_data *, tree, tree);\n@@ -873,10 +874,10 @@ declare_return_variable (struct inline_data *id, tree return_slot_addr,\n \n /* Returns nonzero if a function can be inlined as a tree.  */\n \n-int\n-tree_inlinable_function_p (tree fn, int nolimit)\n+bool\n+tree_inlinable_function_p (tree fn)\n {\n-  return inlinable_function_p (fn, NULL, nolimit);\n+  return inlinable_function_p (fn);\n }\n \n /* If *TP is possibly call to alloca, return nonzero.  */\n@@ -927,138 +928,197 @@ find_builtin_longjmp_call (tree exp)\n   return ret;\n }\n \n-/* Returns nonzero if FN is a function that can be inlined into the\n-   inlining context ID_.  If ID_ is NULL, check whether the function\n-   can be inlined at all.  */\n+/* Returns nonzero if FN is a function that does not have any\n+   fundamental inline blocking properties.  */\n \n-static int\n-inlinable_function_p (tree fn, inline_data *id, int nolimit)\n+static bool\n+inlinable_function_p (tree fn)\n {\n-  int inlinable;\n-  int currfn_insns = 0;\n-  int max_inline_insns_single = MAX_INLINE_INSNS_SINGLE;\n+  bool inlinable = true;\n+  bool calls_builtin_longjmp = false;\n+  bool calls_alloca = false;\n \n   /* If we've already decided this function shouldn't be inlined,\n      there's no need to check again.  */\n   if (DECL_UNINLINABLE (fn))\n-    return 0;\n+    return false;\n \n   /* See if there is any language-specific reason it cannot be\n      inlined.  (It is important that this hook be called early because\n-     in C++ it may result in template instantiation.)  */\n+     in C++ it may result in template instantiation.)\n+     If the function is not inlinable for language-specific reasons,\n+     it is left up to the langhook to explain why.  */\n   inlinable = !(*lang_hooks.tree_inlining.cannot_inline_tree_fn) (&fn);\n \n-  /* If we don't have the function body available, we can't inline\n-     it.  */\n-  if (! DECL_SAVED_TREE (fn))\n-    return 0;\n-\n-  /* We may be here either because fn is declared inline or because\n-     we use -finline-functions.  For the second case, we are more\n-     restrictive.  */\n-  if (DID_INLINE_FUNC (fn))\n-    max_inline_insns_single = MAX_INLINE_INSNS_AUTO;\n+  /* If we don't have the function body available, we can't inline it.\n+     However, this should not be recorded since we also get here for\n+     forward declared inline functions.  Therefore, return at once.  */\n+  if (!DECL_SAVED_TREE (fn))\n+    return false;\n+\n+  /* If we're not inlining at all, then we cannot inline this function.  */\n+  else if (!flag_inline_trees)\n+    inlinable = false;\n+\n+  /* Only try to inline functions if DECL_INLINE is set.  This should be\n+     true for all functions declared `inline', and for all other functions\n+     as well with -finline-functions.\n+\n+     Don't think of disregarding DECL_INLINE when flag_inline_trees == 2;\n+     it's the front-end that must set DECL_INLINE in this case, because\n+     dwarf2out loses if a function that does not have DECL_INLINE set is\n+     inlined anyway.  That is why we have both DECL_INLINE and\n+     DECL_DECLARED_INLINE_P.  */\n+  /* FIXME: When flag_inline_trees dies, the check for flag_unit_at_a_time\n+\t    here should be redundant.  */\n+  else if (!DECL_INLINE (fn) && !flag_unit_at_a_time)\n+    inlinable = false;\n \n-  /* The number of instructions (estimated) of current function.  */\n-  if (!nolimit && !DECL_ESTIMATED_INSNS (fn))\n-    DECL_ESTIMATED_INSNS (fn)\n-      = (*lang_hooks.tree_inlining.estimate_num_insns) (fn);\n-  currfn_insns = DECL_ESTIMATED_INSNS (fn);\n-\n-  /* If we're not inlining things, then nothing is inlinable.  */\n-  if (! flag_inline_trees)\n-    inlinable = 0;\n-  /* If we're not inlining all functions and the function was not\n-     declared `inline', we don't inline it.  Don't think of\n-     disregarding DECL_INLINE when flag_inline_trees == 2; it's the\n-     front-end that must set DECL_INLINE in this case, because\n-     dwarf2out loses if a function is inlined that doesn't have\n-     DECL_INLINE set.  */\n-  else if (! DECL_INLINE (fn) && !nolimit)\n-    inlinable = 0;\n #ifdef INLINER_FOR_JAVA\n   /* Synchronized methods can't be inlined.  This is a bug.  */\n   else if (METHOD_SYNCHRONIZED (fn))\n-    inlinable = 0;\n+    inlinable = false;\n #endif /* INLINER_FOR_JAVA */\n-  /* We can't inline functions that are too big.  Only allow a single\n-     function to be of MAX_INLINE_INSNS_SINGLE size.  Make special\n-     allowance for extern inline functions, though.  */\n-  else if (!nolimit\n-\t   && ! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n-\t   && currfn_insns > max_inline_insns_single)\n-    inlinable = 0;\n+\n   /* We can't inline functions that call __builtin_longjmp at all.\n      The non-local goto machinery really requires the destination\n      be in a different function.  If we allow the function calling\n      __builtin_longjmp to be inlined into the function calling\n      __builtin_setjmp, Things will Go Awry.  */\n   /* ??? Need front end help to identify \"regular\" non-local goto.  */\n   else if (find_builtin_longjmp_call (DECL_SAVED_TREE (fn)))\n-    inlinable = 0;\n-  /* Refuse to inline alloca call unless user explicitly forced so as this may\n-     change program's memory overhead drastically when the function using alloca\n-     is called in loop.  In GCC present in SPEC2000 inlining into schedule_block\n-     cause it to require 2GB of ram instead of 256MB.  */\n+    calls_builtin_longjmp = true;\n+\n+  /* Refuse to inline alloca call unless user explicitly forced so as this\n+     may change program's memory overhead drastically when the function\n+     using alloca is called in loop.  In GCC present in SPEC2000 inlining\n+     into schedule_block cause it to require 2GB of ram instead of 256MB.  */\n   else if (lookup_attribute (\"always_inline\", DECL_ATTRIBUTES (fn)) == NULL\n \t   && find_alloca_call (DECL_SAVED_TREE (fn)))\n-    inlinable = 0;\n+    calls_alloca = true;\n+\n+  if (calls_builtin_longjmp || calls_alloca)\n+    {\n+      /* See if we should warn about uninlinable functions.  Previously,\n+\t some of these warnings would be issued while trying to expand\n+\t the function inline, but that would cause multiple warnings\n+\t about functions that would for example call alloca.  But since\n+\t this a property of the function, just one warning is enough.\n+\t As a bonus we can now give more details about the reason why a\n+\t function is not inlinable.\n+\t We only warn for functions declared `inline' by the user.  */\n+      bool do_warning = (warn_inline\n+\t\t\t && DECL_INLINE (fn)\n+\t\t\t && DECL_DECLARED_INLINE_P (fn)\n+\t\t\t && !DECL_IN_SYSTEM_HEADER (fn));\n+\n+      if (do_warning && calls_builtin_longjmp)\n+\twarning (\"%Hfunction '%F' can never be inlined because it uses \"\n+\t\t \"setjmp-longjmp exception handling\",\n+\t\t &DECL_SOURCE_LOCATION (fn), fn);\n+      if (do_warning && calls_alloca)\n+\twarning (\"%Hfunction '%F' can never be inlined because it uses \"\n+\t\t \"setjmp-longjmp exception handling\",\n+\t\t &DECL_SOURCE_LOCATION (fn), fn);\n+\n+      inlinable = false;\n+    }\n \n   /* Squirrel away the result so that we don't have to check again.  */\n-  DECL_UNINLINABLE (fn) = ! inlinable;\n+  DECL_UNINLINABLE (fn) = !inlinable;\n+\n+  return inlinable;\n+}\n+\n+/* We can't inline functions that are too big.  Only allow a single\n+   function to be of MAX_INLINE_INSNS_SINGLE size.  Make special\n+   allowance for extern inline functions, though.\n \n-  /* In case we don't disregard the inlining limits and we basically\n-     can inline this function, investigate further.  */\n-  if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n-      && inlinable && !nolimit\n-      && currfn_insns > MIN_INLINE_INSNS)\n+   Return nonzero if the function FN can be inlined into the inlining\n+   context ID.  */\n+\n+static int\n+limits_allow_inlining (tree fn, inline_data *id)\n+{\n+  int estimated_insns = 0;\n+  size_t i;\n+\n+  /* Don't even bother if the function is not inlinable.  */\n+  if (!inlinable_function_p (fn))\n+    return 0;\n+\n+  /* Investigate the size of the function.  Return at once\n+     if the function body size is too large.  */\n+  if (!(*lang_hooks.tree_inlining.disregard_inline_limits) (fn))\n     {\n-      int sum_insns = (id ? id->inlined_insns : 0) + currfn_insns;\n-      /* In the extreme case that we have exceeded the recursive inlining\n-         limit by a huge factor (128), we just say no. Should not happen\n-         in real life.  */\n-      if (sum_insns > MAX_INLINE_INSNS * 128)\n-\t inlinable = 0;\n-      /* If we did not hit the extreme limit, we use a linear function\n-         with slope -1/MAX_INLINE_SLOPE to exceedingly decrease the\n-         allowable size. We always allow a size of MIN_INLINE_INSNS\n-         though.  */\n-      else if (sum_insns > MAX_INLINE_INSNS)\n+      int currfn_max_inline_insns;\n+\n+      /* If we haven't already done so, get an estimate of the number of\n+\t instructions that will be produces when expanding this function.  */\n+      if (!DECL_ESTIMATED_INSNS (fn))\n+\tDECL_ESTIMATED_INSNS (fn)\n+\t  = (*lang_hooks.tree_inlining.estimate_num_insns) (fn);\n+      estimated_insns = DECL_ESTIMATED_INSNS (fn);\n+\n+      /* We may be here either because fn is declared inline or because\n+\t we use -finline-functions.  For the second case, we are more\n+\t restrictive.\n+\n+\t FIXME: -finline-functions should imply -funit-at-a-time, it's\n+\t\tabout equally expensive but unit-at-a-time produces\n+\t\tbetter code.  */\n+      currfn_max_inline_insns = DECL_DECLARED_INLINE_P (fn) ?\n+\t\tMAX_INLINE_INSNS_SINGLE : MAX_INLINE_INSNS_AUTO;\n+\n+      /* If the function is too big to be inlined, adieu.  */\n+      if (estimated_insns > currfn_max_inline_insns)\n+\treturn 0;\n+\n+      /* We now know that we don't disregard the inlining limits and that \n+\t we basically should be able to inline this function.\n+\t We always allow inlining functions if we estimate that they are\n+\t smaller than MIN_INLINE_INSNS.  Otherwise, investigate further.  */\n+      if (estimated_insns > MIN_INLINE_INSNS)\n \t{\n-\t  int max_curr = MAX_INLINE_INSNS_SINGLE\n-\t\t\t- (sum_insns - MAX_INLINE_INSNS) / MAX_INLINE_SLOPE;\n-\t  if (currfn_insns > max_curr)\n-\t    inlinable = 0;\n+\t  int sum_insns = (id ? id->inlined_insns : 0) + estimated_insns;\n+\n+\t  /* In the extreme case that we have exceeded the recursive inlining\n+\t     limit by a huge factor (128), we just say no.\n+\n+\t     FIXME:  Should not happen in real life, but people have reported\n+\t\t     that it actually does!?  */\n+\t  if (sum_insns > MAX_INLINE_INSNS * 128)\n+\t    return 0;\n+\n+\t  /* If we did not hit the extreme limit, we use a linear function\n+\t     with slope -1/MAX_INLINE_SLOPE to exceedingly decrease the\n+\t     allowable size.  */\n+\t  else if (sum_insns > MAX_INLINE_INSNS)\n+\t    {\n+\t      if (estimated_insns > currfn_max_inline_insns\n+\t\t\t- (sum_insns - MAX_INLINE_INSNS) / MAX_INLINE_SLOPE)\n+\t        return 0;\n+\t    }\n \t}\n     }\n \n-  /* Check again, language hooks may have modified it.  */\n-  if (! inlinable || DECL_UNINLINABLE (fn))\n-    return 0;\n+  /* Don't allow recursive inlining.  */\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (id->fns); ++i)\n+    if (VARRAY_TREE (id->fns, i) == fn)\n+      return 0;\n \n-  /* Don't do recursive inlining, either.  We don't record this in\n-     DECL_UNINLINABLE; we may be able to inline this function later.  */\n-  if (id)\n+  if (DECL_INLINED_FNS (fn))\n     {\n-      size_t i;\n+      int j;\n+      tree inlined_fns = DECL_INLINED_FNS (fn);\n \n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (id->fns); ++i)\n-\tif (VARRAY_TREE (id->fns, i) == fn)\n+      for (j = 0; j < TREE_VEC_LENGTH (inlined_fns); ++j)\n+\tif (TREE_VEC_ELT (inlined_fns, j) == VARRAY_TREE (id->fns, 0))\n \t  return 0;\n-\n-      if (DECL_INLINED_FNS (fn))\n-\t{\n-\t  int j;\n-\t  tree inlined_fns = DECL_INLINED_FNS (fn);\n-\n-\t  for (j = 0; j < TREE_VEC_LENGTH (inlined_fns); ++j)\n-\t    if (TREE_VEC_ELT (inlined_fns, j) == VARRAY_TREE (id->fns, 0))\n-\t      return 0;\n-\t}\n     }\n \n-  /* Return the result.  */\n-  return inlinable;\n+  /* Go ahead, this function can be inlined.  */\n+  return 1;\n }\n \n /* If *TP is a CALL_EXPR, replace it with its inline expansion.  */\n@@ -1166,9 +1226,9 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n      inlining.  */\n   if ((flag_unit_at_a_time\n        && (!DECL_SAVED_TREE (fn) || !cgraph_inline_p (id->current_decl, fn)))\n-      || (!flag_unit_at_a_time && !inlinable_function_p (fn, id, 0)))\n+      || (!flag_unit_at_a_time && !limits_allow_inlining (fn, id)))\n     {\n-      if (warn_inline && DECL_INLINE (fn) && !DID_INLINE_FUNC (fn)\n+      if (warn_inline && DECL_INLINE (fn) && DECL_DECLARED_INLINE_P (fn)\n \t  && !DECL_IN_SYSTEM_HEADER (fn))\n \t{\n \t  warning (\"%Hinlining failed in call to '%F'\","}, {"sha": "febf9e7bc20e6dce12f8e9f329cd2c0c6e40d164", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -25,7 +25,7 @@ Boston, MA 02111-1307, USA.  */\n /* Function prototypes.  */\n \n void optimize_inline_calls (tree);\n-int tree_inlinable_function_p (tree, int);\n+bool tree_inlinable_function_p (tree);\n tree walk_tree (tree*, walk_tree_fn, void*, void*);\n tree walk_tree_without_duplicates (tree*, walk_tree_fn, void*);\n tree copy_tree_r (tree*, int*, void*);"}, {"sha": "cac3efc1e9b5904962794e2af066e080fa2b4235", "filename": "gcc/tree.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c3af2f63dac9ca424ea3c1a456ef689159d3ae/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b3c3af2f63dac9ca424ea3c1a456ef689159d3ae", "patch": "@@ -1473,10 +1473,12 @@ struct tree_type GTY(())\n    where it is called.  */\n #define DECL_INLINE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.inline_flag)\n \n-/* Nonzero in a FUNCTION_DECL means this function has been found inlinable\n-   only by virtue of -finline-functions  */\n-#define DID_INLINE_FUNC(NODE) \\\n-  (FUNCTION_DECL_CHECK (NODE)->decl.inlined_function_flag)\n+/* Nonzero in a FUNCTION_DECL means that this function was declared inline,\n+   such as via the `inline' keyword in C/C++.  This flag controls the linkage\n+   semantics of 'inline'; whether or not the function is inlined is\n+   controlled by DECL_INLINE.  */\n+#define DECL_DECLARED_INLINE_P(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->decl.declared_inline_flag)\n \n /* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n #define DECL_UNINLINABLE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.uninlinable)\n@@ -1606,6 +1608,13 @@ struct tree_type GTY(())\n #define DECL_POINTER_ALIAS_SET_KNOWN_P(NODE) \\\n   (DECL_POINTER_ALIAS_SET (NODE) != - 1)\n \n+/* In a FUNCTION_DECL for which DECL_BUILT_IN does not hold, this is\n+   the approximate number of statements in this function.  There is\n+   no need for this number to be exact; it is only used in various\n+   heuristics regarding optimization.  */\n+#define DECL_ESTIMATED_INSNS(NODE) \\\n+  (FUNCTION_DECL_CHECK (NODE)->decl.u1.i)\n+\n struct function;\n \n struct tree_decl GTY(())\n@@ -1646,7 +1655,7 @@ struct tree_decl GTY(())\n   unsigned user_align : 1;\n   unsigned uninlinable : 1;\n   unsigned thread_local_flag : 1;\n-  unsigned inlined_function_flag : 1;\n+  unsigned declared_inline_flag : 1;\n   unsigned unused : 3;\n   /* three unused bits.  */\n "}]}