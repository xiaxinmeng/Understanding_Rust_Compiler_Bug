{"sha": "d19fb8e32531c558578d0fbeef2ef6b23b077be1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE5ZmI4ZTMyNTMxYzU1ODU3OGQwZmJlZWYyZWY2YjIzYjA3N2JlMQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2000-12-04T00:23:35Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-12-04T00:23:35Z"}, "message": "Add support for XScale target\nAdd support for StrongARM target\n\nFrom-SVN: r37984", "tree": {"sha": "5e7f41866ef7dde9494ac0d08c878aab7b148bbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e7f41866ef7dde9494ac0d08c878aab7b148bbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d19fb8e32531c558578d0fbeef2ef6b23b077be1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19fb8e32531c558578d0fbeef2ef6b23b077be1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d19fb8e32531c558578d0fbeef2ef6b23b077be1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d19fb8e32531c558578d0fbeef2ef6b23b077be1/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "accc8668e30178fb889abac3b3ab820ebfec258e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/accc8668e30178fb889abac3b3ab820ebfec258e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/accc8668e30178fb889abac3b3ab820ebfec258e"}], "stats": {"total": 886, "additions": 811, "deletions": 75}, "files": [{"sha": "c74983a4f236bf0a41f80f0a75f427914f5c3af0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -1,3 +1,23 @@\n+2000-12-03  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config.gcc: Add support for StrongARM targets.\n+\t* config/arm/t-strongarm-elf: New file.\n+\t* config/arm/t-strongarm-coff: New file.\n+\t* config/arm/t-strongarm-pe: New file.\n+\t* config/arm/strongarm-pe.h: New file.\n+\n+2000-12-03  Nick Clifton  <nickc@redhat.com>\n+\n+\t* NEWS: Mention XScale has been added.\n+\t* config.gcc: Add support for XScale targets.\n+\t* config/arm/arm.h: Add support for XScale processor.\n+\t* config/arm/arm.c: Add support for XScale processor.\n+\t* config/arm/arm.md: Add support for XScale processor.\n+\t* config/arm/t-xscale-elf: New file.\n+\t* config/arm/t-xscale-coff: New file.\n+\t* config/arm/xscale-elf.h: New file.\n+\t* config/arm/xscale-coff.h: New file.\n+\n 2000-12-03  Richard Henderson  <rth@redhat.com>\n \n \t* bb-reorder.c (reorder_basic_blocks): Don't check for EH edges"}, {"sha": "5d1727bfc9853b52447660e97159f1751a4a4f7a", "filename": "gcc/config.gcc", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -213,6 +213,9 @@ strongarm*-*-*)\n arm*-*-*)\n \tcpu_type=arm\n \t;;\n+xscale-*-*)\n+\tcpu_type=arm\n+\t;;\n c*-convex-*)\n \tcpu_type=convex\n \t;;\n@@ -3114,6 +3117,28 @@ sparc64-*-linux*)\t\t# 64-bit Sparc's running GNU/Linux\n \tfi\n \tfloat_format=sparc\n \t;;\n+strongarm-*-elf*)\n+\ttm_file=arm/strongarm-elf.h\n+\ttmake_file=arm/t-strongarm-elf\n+\tout_file=arm/arm.c\n+\txm_file=arm/xm-arm.h\n+\tmd_file=arm/arm.md\n+\t;;\n+strongarm-*-coff*)\n+\ttm_file=arm/strongarm-coff.h\n+\ttmake_file=arm/t-strongarm-coff\n+\tout_file=arm/arm.c\n+\txm_file=arm/xm-arm.h\n+\tmd_file=arm/arm.md\n+\t;;\n+strongarm-*-pe)\n+\ttm_file=arm/strongarm-pe.h\n+\ttmake_file=arm/t-strongarm-pe\n+\tout_file=arm/arm.c\n+\txm_file=arm/xm-arm.h\n+\tmd_file=arm/arm.md\n+\textra_objs=pe.o\n+\t;;\n thumb*-*-*)\n \t{ echo \"config.gcc: error:\n *** The Thumb targets have been deprecated.  The equivalent\n@@ -3185,6 +3210,20 @@ we32k-att-sysv*)\n \txm_file=\"${xm_file} xm-svr3\"\n \tuse_collect2=yes\n \t;;\n+xscale-*-elf)\n+\ttm_file=arm/xscale-elf.h\n+\ttmake_file=arm/t-xscale-elf\n+\tout_file=arm/arm.c\n+\txm_file=arm/xm-arm.h\n+\tmd_file=arm/arm.md\n+\t;;\n+xscale-*-coff)\n+\ttm_file=arm/xscale-coff.h\n+\ttmake_file=arm/t-xscale-coff\n+\tout_file=arm/arm.c\n+\txm_file=arm/xm-arm.h\n+\tmd_file=arm/arm.md\n+\t;;\n *)\n \techo \"Configuration $machine not supported\" 1>&2\n \texit 1\n@@ -3280,6 +3319,7 @@ arm*-*-*)\n \t\txarm[236789] | xarm250 | xarm[67][01]0 \\\n \t\t| xarm7m | xarm7dm | xarm7dmi | xarm[79]tdmi \\\n \t\t| xarm7100 | xarm7500 | xarm7500fe | xarm810 \\\n+\t\t| xxscale \\\n \t\t| xstrongarm | xstrongarm110 | xstrongarm1100)\n \t\t\ttarget_cpu_default2=\"TARGET_CPU_$with_cpu\"\n \t\t\t;;"}, {"sha": "d0be97cfcce2e21322556cb01fa4523be2ef337a", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -197,6 +197,12 @@ extern void arm_mark_dllexport \t\tPARAMS ((tree));\n extern void arm_mark_dllimport \t\tPARAMS ((tree));\n #endif\n \n+extern void arm_init_builtins\t\tPARAMS ((void));\n+#if defined (TREE_CODE) && defined (RTX_CODE)\n+extern rtx arm_expand_builtin\t\tPARAMS ((tree, rtx, rtx,\n+\t\t\t\t\t       enum machine_mode, int));\n+#endif\n+\n #ifdef _C_PRAGMA_H  /* included from code that cares about pragmas */\n extern void arm_pr_long_calls\t\tPARAMS ((cpp_reader *));\n extern void arm_pr_no_long_calls\tPARAMS ((cpp_reader *));"}, {"sha": "32c772ab0ab82ae79fb307b468bb0225a463ce4a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 237, "deletions": 6, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -146,6 +146,8 @@ int    arm_structure_size_boundary = DEFAULT_STRUCTURE_SIZE_BOUNDARY;\n #define FL_THUMB      (1 << 6)        /* Thumb aware */\n #define FL_LDSCHED    (1 << 7)\t      /* Load scheduling necessary */\n #define FL_STRONG     (1 << 8)\t      /* StrongARM */\n+#define FL_ARCH5E     (1 << 9)        /* El Segundo extenstions to v5 */\n+#define FL_XSCALE     (1 << 10)\t      /* XScale */\n \n /* The bits in this mask specify which instructions we are\n    allowed to generate.  */\n@@ -175,6 +177,9 @@ int arm_ld_sched = 0;\n /* Nonzero if this chip is a StrongARM.  */\n int arm_is_strong = 0;\n \n+/* Nonzero if this chip is an XScale.  */\n+int arm_is_xscale = 0;\n+\n /* Nonzero if this chip is a an ARM6 or an ARM7.  */\n int arm_is_6_or_7 = 0;\n \n@@ -269,6 +274,7 @@ static struct processors all_cores[] =\n   {\"strongarm\",\t             FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n   {\"strongarm110\",           FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n   {\"strongarm1100\",          FL_MODE26 | FL_MODE32 | FL_FAST_MULT | FL_ARCH4 |            FL_LDSCHED | FL_STRONG },\n+  {\"xscale\",                             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_LDSCHED | FL_STRONG | FL_XSCALE | FL_ARCH5 },\n   \n   {NULL, 0}\n };\n@@ -286,6 +292,8 @@ static struct processors all_architectures[] =\n      implementations that support it, so we will leave it out for now.  */\n   { \"armv4t\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB },\n   { \"armv5\",     FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 },\n+  { \"armv5t\",    FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 },\n+  { \"armv5te\",   FL_CO_PROC |             FL_MODE32 | FL_FAST_MULT | FL_ARCH4 | FL_THUMB | FL_ARCH5 | FL_ARCH5E },\n   { NULL, 0 }\n };\n \n@@ -382,6 +390,7 @@ arm_override_options ()\n \t{ TARGET_CPU_arm810,    \"arm810\" },\n \t{ TARGET_CPU_arm9,      \"arm9\" },\n \t{ TARGET_CPU_strongarm, \"strongarm\" },\n+\t{ TARGET_CPU_xscale,    \"xscale\" },\n \t{ TARGET_CPU_generic,   \"arm\" },\n \t{ 0, 0 }\n       };\n@@ -516,7 +525,13 @@ arm_override_options ()\n       /* warning (\"ignoring -mapcs-frame because -mthumb was used.\"); */\n       target_flags &= ~ARM_FLAG_APCS_FRAME;\n     }\n-  \n+\n+  if (TARGET_HARD_FLOAT && (tune_flags & FL_XSCALE))\n+    {\n+      warning (\"XScale does not support hardware FP instructions.\");\n+      target_flags |= ARM_FLAG_SOFT_FLOAT;\n+    }\n+\n   /* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done\n      from here where no function is being compiled currently.  */\n   if ((target_flags & (THUMB_FLAG_LEAF_BACKTRACE | THUMB_FLAG_BACKTRACE))\n@@ -576,6 +591,7 @@ arm_override_options ()\n   arm_ld_sched      = (tune_flags & FL_LDSCHED) != 0;\n   arm_is_strong     = (tune_flags & FL_STRONG) != 0;\n   thumb_code\t    = (TARGET_ARM == 0);\n+  arm_is_xscale     = (tune_flags & FL_XSCALE) != 0;\n   arm_is_6_or_7     = (((tune_flags & (FL_MODE26 | FL_MODE32))\n \t\t       && !(tune_flags & FL_ARCH4))) != 0;\n   \n@@ -651,6 +667,9 @@ arm_override_options ()\n   if (optimize_size || (tune_flags & FL_LDSCHED))\n     arm_constant_limit = 1;\n   \n+  if (arm_is_xscale)\n+    arm_constant_limit = 2;\n+\n   /* If optimizing for size, bump the number of instructions that we\n      are prepared to conditionally execute (even on a StrongARM). \n      Otherwise for the StrongARM, which has early execution of branches,\n@@ -1718,7 +1737,7 @@ arm_encode_call_attribute (decl, flag)\n {\n   const char * str = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n   int          len = strlen (str);\n-  const char * newstr;\n+  char *       newstr;\n \n   if (TREE_CODE (decl) != FUNCTION_DECL)\n     return;\n@@ -2001,7 +2020,7 @@ legitimize_pic_address (orig, mode, reg)\n \t    emit_insn (gen_pic_load_addr_arm (address, orig));\n \t  else\n \t    emit_insn (gen_pic_load_addr_thumb (address, orig));\n-\t  \n+\n \t  pic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, address);\n \t  \n \t  emit_move_insn (address, pic_ref);\n@@ -2475,6 +2494,47 @@ arm_adjust_cost (insn, link, dep, cost)\n {\n   rtx i_pat, d_pat;\n \n+  /* Some true dependencies can have a higher cost depending\n+     on precisely how certain input operands are used.  */\n+  if (arm_is_xscale\n+      && REG_NOTE_KIND (link) == 0\n+      && recog_memoized (insn) < 0\n+      && recog_memoized (dep) < 0)\n+    {\n+      int shift_opnum = get_attr_shift (insn);\n+      enum attr_type attr_type = get_attr_type (dep);\n+\n+      /* If nonzero, SHIFT_OPNUM contains the operand number of a shifted\n+\t operand for INSN.  If we have a shifted input operand and the\n+\t instruction we depend on is another ALU instruction, then we may\n+\t have to account for an additional stall.  */\n+      if (shift_opnum != 0 && attr_type == TYPE_NORMAL)\n+\t{\n+\t  rtx shifted_operand;\n+\t  int opno;\n+\t  \n+\t  /* Get the shifted operand.  */\n+\t  extract_insn (insn);\n+\t  shifted_operand = recog_data.operand[shift_opnum];\n+\n+\t  /* Iterate over all the operands in DEP.  If we write an operand\n+\t     that overlaps with SHIFTED_OPERAND, then we have increase the\n+\t     cost of this dependency.  */\n+\t  extract_insn (dep);\n+\t  preprocess_constraints ();\n+\t  for (opno = 0; opno < recog_data.n_operands; opno++)\n+\t    {\n+\t      /* We can ignore strict inputs.  */\n+\t      if (recog_data.operand_type[opno] == OP_IN)\n+\t\tcontinue;\n+\n+\t      if (reg_overlap_mentioned_p (recog_data.operand[opno],\n+\t\t\t\t\t   shifted_operand))\n+\t\treturn 2;\n+\t    }\n+\t}\n+    }\n+\n   /* XXX This is not strictly true for the FPA.  */\n   if (REG_NOTE_KIND (link) == REG_DEP_ANTI\n       || REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n@@ -3822,7 +3882,7 @@ arm_valid_machine_decl_attribute (decl, attr, args)\n \n   if (is_attribute_p (\"naked\", attr))\n     return TREE_CODE (decl) == FUNCTION_DECL;\n-  \n+\n #ifdef ARM_PE\n   if (is_attribute_p (\"interfacearm\", attr))\n     return TREE_CODE (decl) == FUNCTION_DECL;\n@@ -3863,6 +3923,58 @@ arm_gen_load_multiple (base_regno, count, from, up, write_back, unchanging_p,\n   int sign = up ? 1 : -1;\n   rtx mem;\n \n+  /* XScale has load-store double instructions, but they have stricter\n+     alignment requirements than load-store multiple, so we can not\n+     use them.\n+\n+     For XScale ldm requires 2 + NREGS cycles to complete and blocks\n+     the pipeline until completion.\n+\n+\tNREGS\t\tCYCLES\n+\t  1\t\t  3\n+\t  2\t\t  4\n+\t  3\t\t  5\n+\t  4\t\t  6\n+\n+     An ldr instruction takes 1-3 cycles, but does not block the\n+     pipeline.\n+\n+\tNREGS\t\tCYCLES\n+\t  1\t\t 1-3\n+\t  2\t\t 2-6\n+\t  3\t\t 3-9\n+\t  4\t\t 4-12\n+\n+     Best case ldr will always win.  However, the more ldr instructions\n+     we issue, the less likely we are to be able to schedule them well.\n+     Using ldr instructions also increases code size.\n+\n+     As a compromise, we use ldr for counts of 1 or 2 regs, and ldm\n+     for counts of 3 or 4 regs.  */\n+  if (arm_is_xscale && count <= 2 && ! optimize_size)\n+    {\n+      rtx seq;\n+      \n+      start_sequence ();\n+      \n+      for (i = 0; i < count; i++)\n+\t{\n+\t  mem = gen_rtx_MEM (SImode, plus_constant (from, i * 4 * sign));\n+\t  RTX_UNCHANGING_P (mem) = unchanging_p;\n+\t  MEM_IN_STRUCT_P (mem) = in_struct_p;\n+\t  MEM_SCALAR_P (mem) = scalar_p;\n+\t  emit_move_insn (gen_rtx_REG (SImode, base_regno + i), mem);\n+\t}\n+\n+      if (write_back)\n+\temit_move_insn (from, plus_constant (from, count * 4 * sign));\n+\n+      seq = gen_sequence ();\n+      end_sequence ();\n+      \n+      return seq;\n+    }\n+\n   result = gen_rtx_PARALLEL (VOIDmode,\n \t\t\t     rtvec_alloc (count + (write_back ? 1 : 0)));\n   if (write_back)\n@@ -3904,6 +4016,32 @@ arm_gen_store_multiple (base_regno, count, to, up, write_back, unchanging_p,\n   int sign = up ? 1 : -1;\n   rtx mem;\n \n+  /* See arm_gen_load_multiple for discussion of\n+     the pros/cons of ldm/stm usage for XScale.  */\n+  if (arm_is_xscale && count <= 2 && ! optimize_size)\n+    {\n+      rtx seq;\n+      \n+      start_sequence ();\n+      \n+      for (i = 0; i < count; i++)\n+\t{\n+\t  mem = gen_rtx_MEM (SImode, plus_constant (to, i * 4 * sign));\n+\t  RTX_UNCHANGING_P (mem) = unchanging_p;\n+\t  MEM_IN_STRUCT_P (mem) = in_struct_p;\n+\t  MEM_SCALAR_P (mem) = scalar_p;\n+\t  emit_move_insn (mem, gen_rtx_REG (SImode, base_regno + i));\n+\t}\n+\n+      if (write_back)\n+\temit_move_insn (to, plus_constant (to, count * 4 * sign));\n+\n+      seq = gen_sequence ();\n+      end_sequence ();\n+      \n+      return seq;\n+    }\n+\n   result = gen_rtx_PARALLEL (VOIDmode,\n \t\t\t     rtvec_alloc (count + (write_back ? 1 : 0)));\n   if (write_back)\n@@ -4145,6 +4283,7 @@ arm_gen_rotated_half_load (memref)\n    If we are unable to support a dominance comparsison we return CC mode.  \n    This will then fail to match for the RTL expressions that generate this\n    call.  */\n+\n static enum machine_mode\n select_dominance_cc_mode (x, y, cond_or)\n      rtx x;\n@@ -5583,7 +5722,6 @@ arm_reorg (first)\n   /* Scan all the insns and record the operands that will need fixing.  */\n   for (insn = next_nonnote_insn (first); insn; insn = next_nonnote_insn (insn))\n     {\n-\n       if (GET_CODE (insn) == BARRIER)\n \tpush_minipool_barrier (insn, address);\n       else if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN\n@@ -7357,7 +7495,7 @@ arm_expand_prologue ()\n   rtx insn;\n   rtx ip_rtx;\n   int fp_offset = 0;\n-      \n+\n \n   /* Naked functions don't have prologues.  */\n   if (arm_naked_function_p (current_function_decl))\n@@ -8379,6 +8517,99 @@ arm_debugger_arg_offset (value, addr)\n   return value;\n }\n \n+#define def_builtin(NAME, TYPE, CODE) \\\n+  builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL_PTR)\n+\n+void\n+arm_init_builtins ()\n+{\n+  tree endlink = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n+  tree int_endlink = tree_cons (NULL_TREE, integer_type_node, endlink);\n+  tree pchar_type_node = build_pointer_type (char_type_node);\n+\n+  tree int_ftype_int, void_ftype_pchar;\n+\n+  /* void func (void *) */\n+  void_ftype_pchar\n+    = build_function_type (void_type_node,\n+\t\t\t   tree_cons (NULL_TREE, pchar_type_node, endlink));\n+\n+  /* int func (int) */\n+  int_ftype_int\n+    = build_function_type (integer_type_node, int_endlink);\n+\n+  /* Initialize arm V5 builtins.  */\n+  if (arm_arch5)\n+    {\n+      def_builtin (\"__builtin_clz\", int_ftype_int, ARM_BUILTIN_CLZ);\n+      def_builtin (\"__builtin_prefetch\", void_ftype_pchar,\n+\t\t   ARM_BUILTIN_PREFETCH);\n+    }\n+}\n+\n+/* Expand an expression EXP that calls a built-in function,\n+   with result going to TARGET if that's convenient\n+   (and in mode MODE if that's convenient).\n+   SUBTARGET may be used as the target for computing one of EXP's operands.\n+   IGNORE is nonzero if the value is to be ignored.  */\n+\n+rtx\n+arm_expand_builtin (exp, target, subtarget, mode, ignore)\n+     tree exp;\n+     rtx target;\n+     rtx subtarget ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     int ignore ATTRIBUTE_UNUSED;\n+{\n+  enum insn_code icode;\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  tree arg0;\n+  rtx op0, pat;\n+  enum machine_mode tmode, mode0;\n+  int fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  switch (fcode)\n+    {\n+    default:\n+      break;\n+      \n+    case ARM_BUILTIN_CLZ:\n+      icode = CODE_FOR_clz;\n+      arg0 = TREE_VALUE (arglist);\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+      tmode = insn_data[icode].operand[0].mode;\n+      mode0 = insn_data[icode].operand[1].mode;\n+\n+      if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n+\top0 = copy_to_mode_reg (mode0, op0);\n+      if (target == 0\n+\t  || GET_MODE (target) != tmode\n+\t  || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n+\ttarget = gen_reg_rtx (tmode);\n+      pat = GEN_FCN (icode) (target, op0);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+\n+    case ARM_BUILTIN_PREFETCH:\n+      icode = CODE_FOR_prefetch;\n+      arg0 = TREE_VALUE (arglist);\n+      op0 = expand_expr (arg0, NULL_RTX, VOIDmode, 0);\n+\n+      op0 = gen_rtx_MEM (SImode, copy_to_mode_reg (Pmode, op0));\n+\n+      pat = GEN_FCN (icode) (op0);\n+      if (! pat)\n+\treturn 0;\n+      emit_insn (pat);\n+      return target;\n+    }\n+  \n+  /* @@@ Should really do something sensible here.  */\n+  return NULL_RTX;\n+}\n \f\n /* Recursively search through all of the blocks in a function\n    checking to see if any of the variables created in that"}, {"sha": "4390204283a412d5e88a0ba4bb11ccfb00e05576", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -48,6 +48,7 @@ Boston, MA 02111-1307, USA.  */\n #define TARGET_CPU_strongarm1100 0x0040\n #define TARGET_CPU_arm9\t\t0x0080\n #define TARGET_CPU_arm9tdmi\t0x0080\n+#define TARGET_CPU_xscale       0x0100\n /* Configure didn't specify.  */\n #define TARGET_CPU_generic\t0x8000\n \n@@ -115,12 +116,16 @@ extern int current_function_anonymous_args;\n #if TARGET_CPU_DEFAULT == TARGET_CPU_arm8 || TARGET_CPU_DEFAULT == TARGET_CPU_arm810 || TARGET_CPU_DEFAULT == TARGET_CPU_strongarm || TARGET_CPU_DEFAULT == TARGET_CPU_strongarm110 || TARGET_CPU_DEFAULT == TARGET_CPU_strongarm1100 \n #define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_4__\"\n #else\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_xscale\n+#define CPP_ARCH_DEFAULT_SPEC \"-D__ARM_ARCH_5TE__ -D__XSCALE__\"\n+#else\n Unrecognized value in TARGET_CPU_DEFAULT.\n #endif\n #endif\n #endif\n #endif\n #endif\n+#endif\n \n #ifndef CPP_PREDEFINES\n #define CPP_PREDEFINES  \"-Acpu=arm -Amachine=arm\"\n@@ -161,6 +166,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n %{march=strongarm:-D__ARM_ARCH_4__} \\\n %{march=strongarm110:-D__ARM_ARCH_4__} \\\n %{march=strongarm1100:-D__ARM_ARCH_4__} \\\n+%{march=xscale:-D__ARM_ARCH_5TE__} \\\n+%{march=xscale:-D__XSCALE__} \\\n %{march=armv2:-D__ARM_ARCH_2__} \\\n %{march=armv2a:-D__ARM_ARCH_2__} \\\n %{march=armv3:-D__ARM_ARCH_3__} \\\n@@ -198,6 +205,8 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n  %{mcpu=strongarm:-D__ARM_ARCH_4__} \\\n  %{mcpu=strongarm110:-D__ARM_ARCH_4__} \\\n  %{mcpu=strongarm1100:-D__ARM_ARCH_4__} \\\n+ %{mcpu=xscale:-D__ARM_ARCH_5TE__} \\\n+ %{mcpu=xscale:-D__XSCALE__} \\\n  %{!mcpu*:%(cpp_cpu_arch_default)}} \\\n \"\n \n@@ -560,6 +569,9 @@ extern int thumb_code;\n /* Nonzero if this chip is a StrongARM.  */\n extern int arm_is_strong;\n \n+/* Nonzero if this chip is an XScale.  */\n+extern int arm_is_xscale;\n+\n /* Nonzero if this chip is a an ARM6 or an ARM7.  */\n extern int arm_is_6_or_7;\n \n@@ -696,9 +708,12 @@ extern int arm_is_6_or_7;\n #define BIGGEST_ALIGNMENT  32\n \n /* Make strings word-aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  (TREE_CODE (EXP) == STRING_CST        \\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+#define CONSTANT_ALIGNMENT_FACTOR (TARGET_THUMB || ! arm_is_xscale ? 1 : 2)\n+    \n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\\\n+  ((TREE_CODE (EXP) == STRING_CST\t\t\t\t\\\n+    && (ALIGN) < BITS_PER_WORD * CONSTANT_ALIGNMENT_FACTOR)\t\\\n+   ? BITS_PER_WORD * CONSTANT_ALIGNMENT_FACTOR : (ALIGN))\n \n /* Setting STRUCTURE_SIZE_BOUNDARY to 32 produces more efficient code, but the\n    value set in previous versions of this toolchain was 8, which produces more\n@@ -2050,63 +2065,63 @@ typedef struct\n    floating SYMBOL_REF to the constant pool.  Allow REG-only and\n    AUTINC-REG if handling TImode or HImode.  Other symbol refs must be\n    forced though a static cell to ensure addressability.  */\n-#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t \\\n-{\t\t\t\t\t\t\t\t\t \\\n-  if (ARM_BASE_REGISTER_RTX_P (X))\t\t\t\t\t \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n-  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t \\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t \\\n-\t   && ARM_REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n-  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t \\\n-\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t \\\n-\t       || (GET_CODE (X) == CONST\t\t\t\t \\\n-\t\t   && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t \\\n-\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 0)) == LABEL_REF\t \\\n-\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 1)) == CONST_INT))) \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n-  else if ((MODE) == TImode)\t\t\t\t\t\t \\\n-    ;\t\t\t\t\t\t\t\t\t \\\n-  else if ((MODE) == DImode || (TARGET_SOFT_FLOAT && (MODE) == DFmode))\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      if (GET_CODE (X) == PLUS && ARM_BASE_REGISTER_RTX_P (XEXP (X, 0))\t \\\n-\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t \\\n-          if (val == 4 || val == -4 || val == -8)\t\t\t \\\n-\t    goto LABEL;\t\t\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t \\\n-      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-      if (ARM_BASE_REGISTER_RTX_P (xop0))\t\t\t\t \\\n-\tARM_GO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL);\t \\\n-      else if (ARM_BASE_REGISTER_RTX_P (xop1))\t\t\t\t \\\n-\tARM_GO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL);\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-  /* Reload currently can't handle MINUS, so disable this for now */\t \\\n-  /* else if (GET_CODE (X) == MINUS)\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      rtx xop0 = XEXP (X,0);\t\t\t\t\t\t \\\n-      rtx xop1 = XEXP (X,1);\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-      if (ARM_BASE_REGISTER_RTX_P (xop0))\t\t\t\t \\\n-\tARM_GO_IF_LEGITIMATE_INDEX (MODE, -1, xop1, LABEL);\t\t \\\n-    } */\t\t\t\t\t\t\t\t \\\n-  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t \\\n-\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t \\\n-\t   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t \\\n-\t   && ! (flag_pic\t\t\t\t\t\t \\\n-\t\t && symbol_mentioned_p (get_pool_constant (X))))\t \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n-  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)\t \\\n-\t   && (GET_MODE_SIZE (MODE) <= 4)\t\t\t\t \\\n-\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t \\\n-\t   && ARM_REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t \\\n-    goto LABEL;\t\t\t\t\t\t\t\t \\\n+#define ARM_GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (ARM_BASE_REGISTER_RTX_P (X))\t\t\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t   && ARM_REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t\\\n+\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t\\\n+\t       || (GET_CODE (X) == CONST\t\t\t\t\\\n+\t\t   && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t\\\n+\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 0)) == LABEL_REF\t\\\n+\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 1)) == CONST_INT)))\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if ((MODE) == TImode)\t\t\t\t\t\t\\\n+    ;\t\t\t\t\t\t\t\t\t\\\n+  else if ((MODE) == DImode || (TARGET_SOFT_FLOAT && (MODE) == DFmode))\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (X) == PLUS && ARM_BASE_REGISTER_RTX_P (XEXP (X, 0))\t\\\n+\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1));\t\t\t\\\n+          if (val == 4 || val == -4 || val == -8)\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t\\\n+      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (ARM_BASE_REGISTER_RTX_P (xop0))\t\t\t\t\\\n+\tARM_GO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL);\t\\\n+      else if (ARM_BASE_REGISTER_RTX_P (xop1))\t\t\t\t\\\n+\tARM_GO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  /* Reload currently can't handle MINUS, so disable this for now */\t\\\n+  /* else if (GET_CODE (X) == MINUS)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx xop0 = XEXP (X,0);\t\t\t\t\t\t\\\n+      rtx xop1 = XEXP (X,1);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (ARM_BASE_REGISTER_RTX_P (xop0))\t\t\t\t\\\n+\tARM_GO_IF_LEGITIMATE_INDEX (MODE, -1, xop1, LABEL);\t\t\\\n+    } */\t\t\t\t\t\t\t\t\\\n+  else if (GET_MODE_CLASS (MODE) != MODE_FLOAT\t\t\t\t\\\n+\t   && GET_CODE (X) == SYMBOL_REF\t\t\t\t\\\n+\t   && CONSTANT_POOL_ADDRESS_P (X)\t\t\t\t\\\n+\t   && ! (flag_pic\t\t\t\t\t\t\\\n+\t\t && symbol_mentioned_p (get_pool_constant (X))))\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)\t\\\n+\t   && (GET_MODE_SIZE (MODE) <= 4)\t\t\t\t\\\n+\t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t   && ARM_REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n }\n      \n /* ---------------------thumb version----------------------------------*/     \n@@ -2355,6 +2370,9 @@ typedef struct\n    in one reasonably fast instruction.  */\n #define MOVE_MAX 4\n \n+#undef  MOVE_RATIO\n+#define MOVE_RATIO (arm_is_xscale ? 4 : 2)\n+\n /* Define if operations between registers always perform the operation\n    on the full register even if a narrower mode is specified.  */\n #define WORD_REGISTER_OPERATIONS\n@@ -2924,4 +2942,20 @@ extern int making_const_table;\n #define SPECIAL_MODE_PREDICATES\t\t\t\\\n  \"cc_register\", \"dominant_cc_register\",\n \n+enum arm_builtins\n+{\n+  ARM_BUILTIN_CLZ,\n+  ARM_BUILTIN_PREFETCH,\n+  ARM_BUILTIN_MAX\n+};\n+\n+#define MD_INIT_BUILTINS\t\\\n+  do\t\t\t\t\\\n+    {\t\t\t\t\\\n+      arm_init_builtins ();\t\\\n+    }\t\t\t\t\\\n+  while (0)\n+\n+#define MD_EXPAND_BUILTIN(EXP, TARGET, SUBTARGET, MODE, IGNORE) \\\n+    arm_expand_builtin ((EXP), (TARGET), (SUBTARGET), (MODE), (IGNORE))\n #endif /* __ARM_H__ */"}, {"sha": "5971cfab0ebe0a949c0900d01f9973bec2df5fbf", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 101, "deletions": 9, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -69,6 +69,11 @@\n ; scheduling decisions for the load unit and the multiplier.\n (define_attr \"is_strongarm\" \"no,yes\" (const (symbol_ref \"arm_is_strong\")))\n \n+;; Operand number of an input operand that is shifted.  Zero if the\n+;; given instruction does not shift one of its input operands.\n+(define_attr \"is_xscale\" \"no,yes\" (const (symbol_ref \"arm_is_xscale\")))\n+(define_attr \"shift\" \"\" (const_int 0))\n+\n ; Floating Point Unit.  If we only have floating point emulation, then there\n ; is no point in scheduling the floating point insns.  (Well, for best\n ; performance we should try and group them together).\n@@ -291,6 +296,18 @@\n (define_function_unit \"core\" 1 0\n   (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"load\")) 2 1)\n \n+;; We do not need to conditionalize the define_function_unit immediately\n+;; above.  This one will be ignored for anything other than xscale\n+;; compiles and for xscale compiles it provides a larger delay\n+;; and the scheduler will DTRT.\n+;; FIXME: this test needs to be revamped to not depend on this feature \n+;; of the scheduler.\n+\n+(define_function_unit \"core\" 1 0\n+  (and (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"load\"))\n+       (eq_attr \"is_xscale\" \"yes\"))\n+   3 1)\n+\n (define_function_unit \"core\" 1 0\n   (and (eq_attr \"ldsched\" \"!yes\") (eq_attr \"type\" \"load,store1\")) 2 2)\n \n@@ -1121,7 +1138,7 @@\n \t\t\t (const_int 0)))\n    (set (match_operand:SI 0 \"s_register_operand\" \"=&r,&r\")\n \t(mult:SI (match_dup 2) (match_dup 1)))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && !arm_is_xscale\"\n   \"mul%?s\\\\t%0, %2, %1\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"type\" \"mult\")]\n@@ -1134,7 +1151,7 @@\n \t\t\t  (match_operand:SI 1 \"s_register_operand\" \"%?r,0\"))\n \t\t\t (const_int 0)))\n    (clobber (match_scratch:SI 0 \"=&r,&r\"))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && !arm_is_xscale\"\n   \"mul%?s\\\\t%0, %2, %1\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"type\" \"mult\")]\n@@ -1165,7 +1182,7 @@\n    (set (match_operand:SI 0 \"s_register_operand\" \"=&r,&r,&r,&r\")\n \t(plus:SI (mult:SI (match_dup 2) (match_dup 1))\n \t\t (match_dup 3)))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && !arm_is_xscale\"\n   \"mla%?s\\\\t%0, %2, %1, %3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"type\" \"mult\")]\n@@ -1180,7 +1197,7 @@\n \t\t  (match_operand:SI 3 \"s_register_operand\" \"?r,r,0,0\"))\n \t (const_int 0)))\n    (clobber (match_scratch:SI 0 \"=&r,&r,&r,&r\"))]\n-  \"TARGET_ARM\"\n+  \"TARGET_ARM && !arm_is_xscale\"\n   \"mla%?s\\\\t%0, %2, %1, %3\"\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"type\" \"mult\")]\n@@ -1226,7 +1243,7 @@\n ;; Unnamed template to match long long unsigned multiply-accumlate (umlal)\n \n (define_insn \"*umulsidi3adddi\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=&r\")\n+  [(set (match_operand:DI 0 \"s_register_operand\" \"+&r\")\n \t(plus:DI\n \t (mult:DI\n \t  (zero_extend:DI (match_operand:SI 2 \"s_register_operand\" \"%r\"))\n@@ -1268,6 +1285,41 @@\n    (set_attr \"predicable\" \"yes\")]\n )\n \n+(define_insn \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(mult:SI (sign_extend:SI\n+\t\t  (match_operand:HI 1 \"s_register_operand\" \"%r\"))\n+\t\t (sign_extend:SI\n+\t\t  (match_operand:HI 2 \"s_register_operand\" \"r\"))))]\n+  \"TARGET_ARM && arm_is_xscale\"\n+  \"smulbb%?\\\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"mult\")]\n+)\n+\n+(define_insn \"*mulhisi3addsi\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t (mult:SI (sign_extend:SI\n+\t\t\t   (match_operand:HI 2 \"s_register_operand\" \"%r\"))\n+\t\t\t  (sign_extend:SI\n+\t\t\t   (match_operand:HI 3 \"s_register_operand\" \"r\")))))]\n+  \"TARGET_ARM && arm_is_xscale\"\n+  \"smlabb%?\\\\t%0,%2,%3,%1\"\n+  [(set_attr \"type\" \"mult\")]\n+)\n+\n+(define_insn \"*mulhidi3adddi\"\n+  [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n+\t(plus:DI\n+\t  (match_operand:DI 1 \"s_register_operand\" \"0\")\n+\t  (mult:DI (sign_extend:DI\n+\t \t    (match_operand:HI 2 \"s_register_operand\" \"%r\"))\n+\t\t   (sign_extend:DI\n+\t\t    (match_operand:HI 3 \"s_register_operand\" \"r\")))))]\n+  \"TARGET_ARM && arm_is_xscale\"\n+  \"smlalbb%?\\\\t%Q0, %R0, %2, %3\"\n+[(set_attr \"type\" \"mult\")])\n+\n (define_insn \"mulsf3\"\n   [(set (match_operand:SF 0 \"s_register_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"s_register_operand\" \"f\")\n@@ -2003,6 +2055,7 @@\n   \"TARGET_ARM\"\n   \"bic%?\\\\t%0, %1, %2%S4\"\n   [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"shift\" \"2\")\n    ]\n )\n \n@@ -2503,6 +2556,7 @@\n   \"TARGET_ARM\"\n   \"mov%?\\\\t%0, %1%S3\"\n   [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"shift\" \"1\")\n    ]\n )\n \n@@ -2517,6 +2571,7 @@\n   \"TARGET_ARM\"\n   \"mov%?s\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"1\")\n    ]\n )\n \n@@ -2530,6 +2585,7 @@\n   \"TARGET_ARM\"\n   \"mov%?s\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"1\")\n    ]\n )\n \n@@ -2541,6 +2597,7 @@\n   \"TARGET_ARM\"\n   \"mvn%?\\\\t%0, %1%S3\"\n   [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"shift\" \"1\")\n    ]\n )\n \n@@ -2555,6 +2612,7 @@\n   \"TARGET_ARM\"\n   \"mvn%?s\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"1\")\n    ]\n )\n \n@@ -2568,7 +2626,8 @@\n   \"TARGET_ARM\"\n   \"mvn%?s\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n-   ]\n+   (set_attr \"shift\" \"1\")\n+  ]\n )\n \n ;; We don't really have extzv, but defining this using shifts helps\n@@ -2713,6 +2772,7 @@\n    cmp\\\\t%0, #0\\;rsblt\\\\t%0, %0, #0\n    eor%?\\\\t%0, %1, %1, asr #31\\;sub%?\\\\t%0, %0, %1, asr #31\"\n   [(set_attr \"conds\" \"clob,*\")\n+   (set_attr \"shift\" \"1\")\n    ;; predicable can't be set based on the variant, so left as no\n    (set_attr \"length\" \"8\")]\n )\n@@ -2726,6 +2786,7 @@\n    cmp\\\\t%0, #0\\;rsbgt\\\\t%0, %0, #0\n    eor%?\\\\t%0, %1, %1, asr #31\\;rsb%?\\\\t%0, %0, %1, asr #31\"\n   [(set_attr \"conds\" \"clob,*\")\n+   (set_attr \"shift\" \"1\")\n    ;; predicable can't be set based on the variant, so left as no\n    (set_attr \"length\" \"8\")]\n )\n@@ -3056,6 +3117,7 @@\n     return \\\"mov%?\\\\t%R0, %Q0, asr #31\\\";\n   \"\n   [(set_attr \"length\" \"8\")\n+   (set_attr \"shift\" \"1\")\n    (set_attr \"predicable\" \"yes\")]\n )\n \n@@ -5471,6 +5533,7 @@\n   \"TARGET_ARM\"\n   \"cmp%?\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"1\")\n    ]\n )\n \n@@ -5483,6 +5546,7 @@\n   \"TARGET_ARM\"\n   \"cmp%?\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"1\")\n    ]\n )\n \n@@ -5495,6 +5559,7 @@\n   \"TARGET_ARM\"\n   \"cmn%?\\\\t%0, %1%S3\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"1\")\n    ]\n )\n \n@@ -6728,6 +6793,7 @@\n   \"TARGET_ARM\"\n   \"%i1%?\\\\t%0, %2, %4%S3\"\n   [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"shift\" \"4\")\n    ]\n )\n \n@@ -6745,6 +6811,7 @@\n   \"TARGET_ARM\"\n   \"%i1%?s\\\\t%0, %2, %4%S3\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"4\")\n    ]\n )\n \n@@ -6760,6 +6827,7 @@\n   \"TARGET_ARM\"\n   \"%i1%?s\\\\t%0, %2, %4%S3\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"4\")\n    ]\n )\n \n@@ -6772,6 +6840,7 @@\n   \"TARGET_ARM\"\n   \"sub%?\\\\t%0, %1, %3%S2\"\n   [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"shift\" \"3\")\n    ]\n )\n \n@@ -6789,6 +6858,7 @@\n   \"TARGET_ARM\"\n   \"sub%?s\\\\t%0, %1, %3%S2\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"3\") \n    ]\n )\n \n@@ -6804,6 +6874,7 @@\n   \"TARGET_ARM\"\n   \"sub%?s\\\\t%0, %1, %3%S2\"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"3\") \n    ]\n )\n \n@@ -6848,12 +6919,13 @@\n \t(plus:SI (plus:SI (match_op_dup 5 [(match_dup 3) (match_dup 4)])\n \t\t\t  (match_dup 1))\n \t\t (match_dup 2)))]\n-  \"TARGET_ARM && reload_in_progress\"\n+  \"TARGET_ARM && reload_in_progress && !arm_is_xscale\"\n   \"*\n     output_add_immediate (operands);\n     return \\\"add%?s\\\\t%0, %0, %3%S5\\\";\n   \"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"3\")\n    (set_attr \"length\" \"20\")]\n )\n \n@@ -6868,12 +6940,13 @@\n \t\t\t  (match_operand:SI 2 \"const_int_operand\" \"n\"))\n \t\t\t (const_int 0)))\n    (clobber (match_scratch:SI 0 \"=&r\"))]\n-  \"TARGET_ARM && reload_in_progress\"\n+  \"TARGET_ARM && reload_in_progress && !arm_is_xscale\"\n   \"*\n     output_add_immediate (operands);\n     return \\\"add%?s\\\\t%0, %0, %3%S5\\\";\n   \"\n   [(set_attr \"conds\" \"set\")\n+   (set_attr \"shift\" \"3\")\n    (set_attr \"length\" \"20\")]\n )\n \n@@ -6908,7 +6981,7 @@\n    (set (match_operand:SI 0 \"\" \"=&r\")\n \t(plus:SI (plus:SI (mult:SI (match_dup 3) (match_dup 4)) (match_dup 1))\n \t\t (match_dup 2)))]\n-  \"TARGET_ARM && reload_in_progress\"\n+  \"TARGET_ARM && reload_in_progress && !arm_is_xscale\"\n   \"*\n     output_add_immediate (operands);\n     output_asm_insn (\\\"mla%?s\\\\t%0, %3, %4, %0\\\", operands);\n@@ -7615,6 +7688,7 @@\n    mov%D5\\\\t%0, %1\\;mov%d5\\\\t%0, %2%S4\n    mvn%D5\\\\t%0, #%B1\\;mov%d5\\\\t%0, %2%S4\"\n   [(set_attr \"conds\" \"use\")\n+   (set_attr \"shift\" \"2\")\n    (set_attr \"length\" \"4,8,8\")]\n )\n \n@@ -7650,6 +7724,7 @@\n    mov%d5\\\\t%0, %1\\;mov%D5\\\\t%0, %2%S4\n    mvn%d5\\\\t%0, #%B1\\;mov%D5\\\\t%0, %2%S4\"\n   [(set_attr \"conds\" \"use\")\n+   (set_attr \"shift\" \"2\")\n    (set_attr \"length\" \"4,8,8\")]\n )\n \n@@ -7686,6 +7761,7 @@\n   \"TARGET_ARM\"\n   \"mov%d5\\\\t%0, %1%S6\\;mov%D5\\\\t%0, %3%S7\"\n   [(set_attr \"conds\" \"use\")\n+   (set_attr \"shift\" \"1\")\n    (set_attr \"length\" \"8\")]\n )\n \n@@ -8912,6 +8988,22 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n+;; V5 Instructions,\n+\n+(define_insn \"clz\"\n+  [(set (match_operand:SI             0 \"s_register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"s_register_operand\" \"r\")] 128))]\n+  \"TARGET_ARM\"\n+  \"clz\\\\t%0,%1\")\n+\n+;; XScale instructions.\n+\n+(define_insn \"prefetch\"\n+  [(unspec_volatile\n+    [(match_operand:SI 0 \"offsettable_memory_operand\" \"o\")] 129)]\n+  \"TARGET_ARM\"\n+  \"pld\\\\t%0\")\n+\n ;; General predication pattern\n \n (define_cond_exec"}, {"sha": "4ee08b0bb16d8eb8c04a9b6c3270ea9beeb7e069", "filename": "gcc/config/arm/strongarm-pe.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Fstrongarm-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Fstrongarm-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fstrongarm-pe.h?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -0,0 +1,26 @@\n+/* Definitions of target machine for GNU compiler, for ARM with PE obj format.\n+   Copyright (C) 1999 Free Software Foundation, Inc.\n+   Contributed by Doug Evans (dje@cygnus.com).\n+   \n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"arm/strongarm-coff.h\"\n+#include \"arm/pe.h\"\n+\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION\tfputs (\" (StrongARM/PE)\", stderr);"}, {"sha": "269ee33373d2e3e9273e6bb64fb35ff90a7229c5", "filename": "gcc/config/arm/t-strongarm-coff", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-strongarm-coff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-strongarm-coff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-strongarm-coff?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -0,0 +1,35 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+MULTILIB_OPTIONS  = mlittle-endian/mbig-endian mhard-float/msoft-float\n+MULTILIB_DIRNAMES = le be fpu soft\n+MULTILIB_MATCHES  = \n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+# Currently there is a bug somwehere in GCC's alias analysis\n+# or scheduling code that is breaking _fpmul_parts in libgcc1.c.\n+# Disabling function inlining is a workaround for this problem.\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline"}, {"sha": "a0f009b47c5acc220452f9e1b389fc81816dfe10", "filename": "gcc/config/arm/t-strongarm-elf", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-strongarm-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-strongarm-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-strongarm-elf?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -0,0 +1,39 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+MULTILIB_OPTIONS     = mlittle-endian/mbig-endian mhard-float/msoft-float\n+MULTILIB_DIRNAMES    = le be fpu soft\n+MULTILIB_EXCEPTIONS  =\n+MULTILIB_MATCHES     = mbig-endian=mbe mlittle-endian=mle\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n+\n+# If EXTRA_MULTILIB_PARTS is not defined above then define EXTRA_PARTS here\n+# EXTRA_PARTS = crtbegin.o crtend.o\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+# Currently there is a bug somewhere in GCC's alias analysis\n+# or scheduling code that is breaking _fpmul_parts in libgcc1.c.\n+# Disabling function inlining is a workaround for this problem.\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline"}, {"sha": "e487e5d931b72f979fbfd2676318e52f3c9ee6cb", "filename": "gcc/config/arm/t-strongarm-pe", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-strongarm-pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-strongarm-pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-strongarm-pe?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -0,0 +1,38 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+pe.o: $(srcdir)/config/arm/pe.c\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/arm/pe.c\n+\n+MULTILIB_OPTIONS  = mhard-float/msoft-float\n+MULTILIB_DIRNAMES = fpu soft\n+MULTILIB_MATCHES  = \n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+# Currently there is a bug somwehere in GCC's alias analysis\n+# or scheduling code that is breaking _fpmul_parts in libgcc1.c.\n+# Disabling function inlining is a workaround for this problem.\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline"}, {"sha": "ad84fad4f627698b5d0ac41eb21714af5fdf1eb6", "filename": "gcc/config/arm/t-xscale-coff", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-xscale-coff", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-xscale-coff", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-xscale-coff?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -0,0 +1,51 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func _call_via_rX _interwork_call_via_rX\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+MULTILIB_OPTIONS     = mlittle-endian/mbig-endian\n+MULTILIB_DIRNAMES    = le be\n+MULTILIB_EXCEPTIONS  = \n+MULTILIB_MATCHES     = mbig-endian=mbe mlittle-endian=mle\n+\n+# Note XScale does not support 26 bit APCS.\n+# Note XScale does not support hard FP\n+\n+MULTILIB_OPTIONS    += mno-thumb-interwork/mthumb-interwork\n+MULTILIB_DIRNAMES   += normal interwork\n+\n+MULTILIB_OPTIONS    += marm/mthumb\n+MULTILIB_DIRNAMES   += arm thumb\n+MULTILIB_EXCEPTIONS += *mhard-float/*mthumb*\n+\n+# CYGNUS LOCAL nickc/redundant multilibs\n+MULTILIB_REDUNDANT_DIRS = interwork/thumb=thumb\n+# END CYGNUS LOCAL\n+\n+\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n+LIBGCC               = stmp-multilib\n+INSTALL_LIBGCC       = install-multilib\n+\n+# Currently there is a bug somewhere in GCC's alias analysis\n+# or scheduling code that is breaking _fpmul_parts in libgcc1.c.\n+# Disabling function inlining is a workaround for this problem.\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline"}, {"sha": "ad84fad4f627698b5d0ac41eb21714af5fdf1eb6", "filename": "gcc/config/arm/t-xscale-elf", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-xscale-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Ft-xscale-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-xscale-elf?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -0,0 +1,51 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = arm/lib1funcs.asm\n+LIB1ASMFUNCS = _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _bb_init_func _call_via_rX _interwork_call_via_rX\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\techo '#ifndef __ARMEB__' >> fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n+\techo '#endif' >> fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#ifndef __ARMEB__' > dp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n+\techo '#endif' >> dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+MULTILIB_OPTIONS     = mlittle-endian/mbig-endian\n+MULTILIB_DIRNAMES    = le be\n+MULTILIB_EXCEPTIONS  = \n+MULTILIB_MATCHES     = mbig-endian=mbe mlittle-endian=mle\n+\n+# Note XScale does not support 26 bit APCS.\n+# Note XScale does not support hard FP\n+\n+MULTILIB_OPTIONS    += mno-thumb-interwork/mthumb-interwork\n+MULTILIB_DIRNAMES   += normal interwork\n+\n+MULTILIB_OPTIONS    += marm/mthumb\n+MULTILIB_DIRNAMES   += arm thumb\n+MULTILIB_EXCEPTIONS += *mhard-float/*mthumb*\n+\n+# CYGNUS LOCAL nickc/redundant multilibs\n+MULTILIB_REDUNDANT_DIRS = interwork/thumb=thumb\n+# END CYGNUS LOCAL\n+\n+\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n+LIBGCC               = stmp-multilib\n+INSTALL_LIBGCC       = install-multilib\n+\n+# Currently there is a bug somewhere in GCC's alias analysis\n+# or scheduling code that is breaking _fpmul_parts in libgcc1.c.\n+# Disabling function inlining is a workaround for this problem.\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc -fno-inline"}, {"sha": "8ce2e9b6a142ce266dcf4f7a33bb11b245947b17", "filename": "gcc/config/arm/xscale-coff.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Fxscale-coff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Fxscale-coff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fxscale-coff.h?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -0,0 +1,35 @@\n+/* Definitions for XScale systems using COFF\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Catherine Moore <clm@cygnus.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Run-time Target Specification.  */\n+#ifndef SUBTARGET_CPU_DEFAULT\n+#define SUBTARGET_CPU_DEFAULT \t\tTARGET_CPU_xscale\n+#endif\n+\n+#define SUBTARGET_EXTRA_ASM_SPEC \"%{!mcpu=*:-mxscale}\"\n+\n+#define MULTILIB_DEFAULTS \\\n+  { \"mlittle-endian\", \"mno-thumb-interwork\", \"marm\" }\n+\n+#include \"coff.h\"\n+\n+#undef  TARGET_VERSION\n+#define TARGET_VERSION\tfputs (\" (XScale/COFF)\", stderr);"}, {"sha": "3718d111c9df19486de75c0f9c8df85e09762f20", "filename": "gcc/config/arm/xscale-elf.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Fxscale-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d19fb8e32531c558578d0fbeef2ef6b23b077be1/gcc%2Fconfig%2Farm%2Fxscale-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fxscale-elf.h?ref=d19fb8e32531c558578d0fbeef2ef6b23b077be1", "patch": "@@ -0,0 +1,38 @@\n+/* Definitions for XScale architectures using ELF\n+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Catherine Moore <clm@cygnus.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Run-time Target Specification.  */\n+#ifndef TARGET_VERSION\n+#define TARGET_VERSION\tfputs (\" (XScale/ELF non-Linux)\", stderr);\n+#endif\n+\n+#ifndef SUBTARGET_CPU_DEFAULT\n+#define SUBTARGET_CPU_DEFAULT \t\tTARGET_CPU_xscale\n+#endif\n+\n+#define SUBTARGET_EXTRA_ASM_SPEC \"%{!mcpu=*:-mxscale}\"\n+\n+#ifndef MULTILIB_DEFAULTS\n+#define MULTILIB_DEFAULTS \\\n+  { \"mlittle-endian\", \"mno-thumb-interwork\", \"marm\" }\n+#endif\n+\n+#include \"unknown-elf.h\""}]}