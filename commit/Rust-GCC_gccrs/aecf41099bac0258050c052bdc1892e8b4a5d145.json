{"sha": "aecf41099bac0258050c052bdc1892e8b4a5d145", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVjZjQxMDk5YmFjMDI1ODA1MGMwNTJiZGMxODkyZThiNGE1ZDE0NQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-08-12T20:34:51Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-08-12T20:34:51Z"}, "message": "parse.y (java_check_regular_methods): Typo fixes.\n\n\t* parse.y (java_check_regular_methods): Typo fixes.  Call\n\tcheck_interface_throws_clauses.  Use\n\tcheck_concrete_throws_clauses.\n\t(check_interface_throws_clauses): New function.\n\t(check_concrete_throws_clauses): New function.\n\t(hack_is_accessible_p): New function.\n\t(find_most_specific_methods_list): Added FIXME.\n\t* typeck.c (lookup_do): Use `flags' argument to decide what to\n\tdo.  Reimplemented.\n\t(lookup_argument_method_generic): New function.\n\t(lookup_argument_method2): Removed.\n\t* jcf.h (ACC_INVISIBLE): New define.\n\t* jcf-write.c (generate_classfile): Skip invisible methods.\n\t* class.c (add_miranda_methods): New function.\n\t(layout_class_methods): Use it.\n\t(get_access_flags_from_decl): Use ACC_INVISIBLE.\n\t* java-tree.h (METHOD_INVISIBLE): New define.\n\t(lang_decl_func) [invisible]: New field.\n\t(lookup_argument_method_generic): Declare.\n\t(SEARCH_INTERFACE): New define.\n\t(SEARCH_SUPER): Likewise.\n\t(SEARCH_ONLY_INTERFACE): Likewise.\n\t(SEARCH_VISIBLE): Likewise.\n\t(lookup_argument_method2): Removed declaration.\n\nFrom-SVN: r70388", "tree": {"sha": "b0eccc2bad8dc4ad0fc0c2540ee347467640fdec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0eccc2bad8dc4ad0fc0c2540ee347467640fdec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aecf41099bac0258050c052bdc1892e8b4a5d145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aecf41099bac0258050c052bdc1892e8b4a5d145", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aecf41099bac0258050c052bdc1892e8b4a5d145", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aecf41099bac0258050c052bdc1892e8b4a5d145/comments", "author": null, "committer": null, "parents": [{"sha": "b9172475adce3fec9e36fe6b98eeedba31c0d1f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9172475adce3fec9e36fe6b98eeedba31c0d1f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9172475adce3fec9e36fe6b98eeedba31c0d1f0"}], "stats": {"total": 462, "additions": 349, "deletions": 113}, "files": [{"sha": "10358153bf0f0c9e27a5e71cdd1d4097cf97bd52", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=aecf41099bac0258050c052bdc1892e8b4a5d145", "patch": "@@ -1,3 +1,30 @@\n+2003-08-11  Tom Tromey  <tromey@redhat.com>\n+\n+\t* parse.y (java_check_regular_methods): Typo fixes.  Call\n+\tcheck_interface_throws_clauses.  Use\n+\tcheck_concrete_throws_clauses.\n+\t(check_interface_throws_clauses): New function.\n+\t(check_concrete_throws_clauses): New function.\n+\t(hack_is_accessible_p): New function.\n+\t(find_most_specific_methods_list): Added FIXME.\n+\t* typeck.c (lookup_do): Use `flags' argument to decide what to\n+\tdo.  Reimplemented.\n+\t(lookup_argument_method_generic): New function.\n+\t(lookup_argument_method2): Removed.\n+\t* jcf.h (ACC_INVISIBLE): New define.\n+\t* jcf-write.c (generate_classfile): Skip invisible methods.\n+\t* class.c (add_miranda_methods): New function.\n+\t(layout_class_methods): Use it.\n+\t(get_access_flags_from_decl): Use ACC_INVISIBLE.\n+\t* java-tree.h (METHOD_INVISIBLE): New define.\n+\t(lang_decl_func) [invisible]: New field.\n+\t(lookup_argument_method_generic): Declare.\n+\t(SEARCH_INTERFACE): New define.\n+\t(SEARCH_SUPER): Likewise.\n+\t(SEARCH_ONLY_INTERFACE): Likewise.\n+\t(SEARCH_VISIBLE): Likewise.\n+\t(lookup_argument_method2): Removed declaration.\n+\n 2003-08-05  Tom Tromey  <tromey@redhat.com>\n \n \tFix for PR java/11600:"}, {"sha": "620a8a2e6c96d467a66b239cb076a52d2a150598", "filename": "gcc/java/class.c", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=aecf41099bac0258050c052bdc1892e8b4a5d145", "patch": "@@ -57,6 +57,7 @@ static tree get_dispatch_table (tree, tree);\n static int supers_all_compiled (tree type);\n static void add_interface_do (tree, tree, int);\n static tree maybe_layout_super_class (tree, tree);\n+static void add_miranda_methods (tree, tree);\n static int assume_compiled (const char *);\n static tree build_method_symbols_entry (tree);\n \n@@ -1034,6 +1035,8 @@ get_access_flags_from_decl (tree decl)\n \taccess_flags |= ACC_ABSTRACT;\n       if (METHOD_STRICTFP (decl))\n \taccess_flags |= ACC_STRICT;\n+      if (METHOD_INVISIBLE (decl))\n+\taccess_flags |= ACC_INVISIBLE;\n       return access_flags;\n     }\n   abort ();\n@@ -1747,14 +1750,14 @@ layout_class (tree this_class)\n {\n   tree super_class = CLASSTYPE_SUPER (this_class);\n   tree field;\n-  \n+\n   class_list = tree_cons (this_class, NULL_TREE, class_list);\n   if (CLASS_BEING_LAIDOUT (this_class))\n     {\n       char buffer [1024];\n       char *report;\n       tree current;\n-      \n+\n       sprintf (buffer, \" with `%s'\",\n \t       IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class))));\n       obstack_grow (&temporary_obstack, buffer, strlen (buffer));\n@@ -1808,8 +1811,9 @@ layout_class (tree this_class)\n \n   layout_type (this_class);\n \n-  /* Also recursively load/layout any superinterfaces, but only if class was\n-  loaded from bytecode. The source parser will take care of this itself. */\n+  /* Also recursively load/layout any superinterfaces, but only if\n+     class was loaded from bytecode.  The source parser will take care\n+     of this itself.  */\n   if (!CLASS_FROM_SOURCE_P (this_class))\n     {\n       tree basetype_vec = TYPE_BINFO_BASETYPES (this_class);\n@@ -1837,14 +1841,61 @@ layout_class (tree this_class)\n \t}\n     }\n \n-  /* Convert the size back to an SI integer value */\n-  TYPE_SIZE_UNIT (this_class) = \n+  /* Convert the size back to an SI integer value.  */\n+  TYPE_SIZE_UNIT (this_class) =\n     fold (convert (int_type_node, TYPE_SIZE_UNIT (this_class)));\n \n   CLASS_BEING_LAIDOUT (this_class) = 0;\n   class_list = TREE_CHAIN (class_list);\n }\n \n+static void\n+add_miranda_methods (tree base_class, tree search_class)\n+{\n+  tree basetype_vec = TYPE_BINFO_BASETYPES (search_class);\n+  int i, n = TREE_VEC_LENGTH (basetype_vec);\n+  for (i = 1; i < n; ++i)\n+    {\n+      tree method_decl;\n+      tree elt = TREE_VEC_ELT (basetype_vec, i);\n+      if (elt == NULL_TREE)\n+\tbreak;\n+      elt = BINFO_TYPE (elt);\n+\n+      /* Note that order matters here.  However, all the base classes\n+\t will have been laid out at this point, so the order will\n+\t always be correct.  Also, this code must match similar layout\n+\t code in the runtime.  */\n+      for (method_decl = TYPE_METHODS (elt);\n+\t   method_decl; method_decl = TREE_CHAIN (method_decl))\n+\t{\n+\t  tree sig, override;\n+\n+\t  /* An interface can have <clinit>.  */\n+\t  if (ID_CLINIT_P (DECL_NAME (method_decl)))\n+\t    continue;\n+\n+\t  sig = build_java_argument_signature (TREE_TYPE (method_decl));\n+\t  override = lookup_argument_method (base_class,\n+\t\t\t\t\t     DECL_NAME (method_decl), sig);\n+\t  if (override == NULL_TREE)\n+\t    {\n+\t      /* Found a Miranda method.  Add it.  */\n+\t      tree new_method;\n+\t      sig = build_java_signature (TREE_TYPE (method_decl));\n+\t      new_method\n+\t\t= add_method (base_class,\n+\t\t\t      get_access_flags_from_decl (method_decl),\n+\t\t\t      DECL_NAME (method_decl), sig);\n+\t      METHOD_INVISIBLE (new_method) = 1;\n+\t    }\n+\t}\n+\n+      /* Try superinterfaces.  */\n+      add_miranda_methods (base_class, elt);\n+    }\n+}\n+\n void\n layout_class_methods (tree this_class)\n {\n@@ -1866,11 +1917,20 @@ layout_class_methods (tree this_class)\n   else\n     dtable_count = integer_zero_node;\n \n+  if (CLASS_ABSTRACT (TYPE_NAME (this_class)))\n+    {\n+      /* An abstract class can have methods which are declared only in\n+\t an implemented interface.  These are called \"Miranda\n+\t methods\".  We make a dummy method entry for such methods\n+\t here.  */\n+      add_miranda_methods (this_class, this_class);\n+    }\n+\n   TYPE_METHODS (this_class) = nreverse (TYPE_METHODS (this_class));\n \n   for (method_decl = TYPE_METHODS (this_class);\n        method_decl; method_decl = TREE_CHAIN (method_decl))\n-    dtable_count = layout_class_method (this_class, super_class, \n+    dtable_count = layout_class_method (this_class, super_class,\n \t\t\t\t\tmethod_decl, dtable_count);\n \n   TYPE_NVIRTUALS (this_class) = dtable_count;"}, {"sha": "0a7a542a9f5c92fda5c7ca67ff26a1a6ebbb4fbd", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=aecf41099bac0258050c052bdc1892e8b4a5d145", "patch": "@@ -977,6 +977,9 @@ struct lang_decl_func GTY(())\n   unsigned int fixed_ctor : 1;\n   unsigned int init_calls_this : 1;\n   unsigned int strictfp : 1;\n+  unsigned int invisible : 1;\t/* Set for methods we generate\n+\t\t\t\t   internally but which shouldn't be\n+\t\t\t\t   written to the .class file.  */\n };\n \n struct treetreehash_entry GTY(())\n@@ -1071,6 +1074,12 @@ struct lang_type GTY(())\n #define JCF_u4 unsigned long\n #define JCF_u2 unsigned short\n \n+/* Possible values to pass to lookup_argument_method_generic.  */\n+#define SEARCH_INTERFACE      1\n+#define SEARCH_SUPER          2\n+#define SEARCH_ONLY_INTERFACE 4\n+#define SEARCH_VISIBLE        8\n+\n extern void java_parse_file (int);\n extern bool java_mark_addressable (tree);\n extern tree java_type_for_mode (enum machine_mode, int);\n@@ -1084,7 +1093,7 @@ extern tree lookup_class (tree);\n extern tree lookup_java_constructor (tree, tree);\n extern tree lookup_java_method (tree, tree, tree);\n extern tree lookup_argument_method (tree, tree, tree);\n-extern tree lookup_argument_method2 (tree, tree, tree);\n+extern tree lookup_argument_method_generic (tree, tree, tree, int);\n extern int has_method (tree, tree);\n extern tree promote_type (tree);\n extern tree get_constant (struct JCF*, int);\n@@ -1302,6 +1311,7 @@ extern void init_resource_processing (void);\n #define METHOD_NATIVE(DECL) (DECL_LANG_SPECIFIC(DECL)->u.f.native)\n #define METHOD_ABSTRACT(DECL) DECL_LANG_FLAG_5 (DECL)\n #define METHOD_STRICTFP(DECL) (DECL_LANG_SPECIFIC (DECL)->u.f.strictfp)\n+#define METHOD_INVISIBLE(DECL) (DECL_LANG_SPECIFIC (DECL)->u.f.invisible)\n \n #define JAVA_FILE_P(NODE) TREE_LANG_FLAG_2 (NODE)\n #define CLASS_FILE_P(NODE) TREE_LANG_FLAG_3 (NODE)"}, {"sha": "3609807a4100d7e00bc796ca39909a64209fe833", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=aecf41099bac0258050c052bdc1892e8b4a5d145", "patch": "@@ -2919,6 +2919,12 @@ generate_classfile (tree clas, struct jcf_partial *state)\n       tree type = TREE_TYPE (part);\n       tree save_function = current_function_decl;\n       int synthetic_p = 0;\n+\n+      /* Invisible Miranda methods shouldn't end up in the .class\n+\t file.  */\n+      if (METHOD_INVISIBLE (part))\n+\tcontinue;\n+\n       current_function_decl = part;\n       ptr = append_chunk (NULL, 8, state);\n       i = get_access_flags (part);  PUT2 (i);"}, {"sha": "5b97fec95256b0f22042c5fd41cfdc45be642c9f", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=aecf41099bac0258050c052bdc1892e8b4a5d145", "patch": "@@ -230,6 +230,9 @@ typedef struct JCF GTY(()) {\n #define ACC_INTERFACE 0x0200\n #define ACC_ABSTRACT 0x0400\n #define ACC_STRICT 0x0800\n+/* \"Invisible\" refers to Miranda methods inserted into an abstract\n+   #class.  It is also used in the runtime.  */\n+#define ACC_INVISIBLE 0x1000\n \n #define ACC_VISIBILITY (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED)\n "}, {"sha": "a9f8d6ecc6b89e07ca4d0427bddff5a86b690c5d", "filename": "gcc/java/parse.y", "status": "modified", "additions": 134, "deletions": 22, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=aecf41099bac0258050c052bdc1892e8b4a5d145", "patch": "@@ -224,6 +224,7 @@ static void check_thrown_exceptions (int, tree, tree);\n static int check_thrown_exceptions_do (tree);\n static void purge_unchecked_exceptions (tree);\n static bool ctors_unchecked_throws_clause_p (tree);\n+static void check_concrete_throws_clauses (tree, tree, tree, tree);\n static void check_throws_clauses (tree, tree, tree);\n static void finish_method_declaration (tree);\n static tree build_super_invocation (tree);\n@@ -244,7 +245,9 @@ static void start_artificial_method_body (tree);\n static void end_artificial_method_body (tree);\n static int check_method_redefinition (tree, tree);\n static int check_method_types_complete (tree);\n+static bool hack_is_accessible_p (tree, tree);\n static void java_check_regular_methods (tree);\n+static void check_interface_throws_clauses (tree, tree);\n static void java_check_abstract_methods (tree);\n static void unreachable_stmt_error (tree);\n static tree find_expr_with_wfl (tree);\n@@ -6244,11 +6247,35 @@ java_check_methods (tree class_decl)\n   CLASS_METHOD_CHECKED_P (TREE_TYPE (class_decl)) = 1;\n }\n \n+/* Like not_accessible_p, but doesn't refer to the current class at\n+   all.  */\n+static bool\n+hack_is_accessible_p (tree member, tree from_where)\n+{\n+  int flags = get_access_flags_from_decl (member);\n+\n+  if (from_where == DECL_CONTEXT (member)\n+      || (flags & ACC_PUBLIC))\n+    return true;\n+\n+  if ((flags & ACC_PROTECTED))\n+    {\n+      if (inherits_from_p (from_where, DECL_CONTEXT (member)))\n+\treturn true;\n+    }\n+\n+  if ((flags & ACC_PRIVATE))\n+    return false;\n+\n+  /* Package private, or protected.  */\n+  return in_same_package (TYPE_NAME (from_where),\n+\t\t\t  TYPE_NAME (DECL_CONTEXT (member)));\n+}\n+\n /* Check all the methods of CLASS_DECL. Methods are first completed\n    then checked according to regular method existence rules.  If no\n    constructor for CLASS_DECL were encountered, then build its\n    declaration.  */\n-\n static void\n java_check_regular_methods (tree class_decl)\n {\n@@ -6298,7 +6325,8 @@ java_check_regular_methods (tree class_decl)\n \t}\n \n       sig = build_java_argument_signature (TREE_TYPE (method));\n-      found = lookup_argument_method2 (class, DECL_NAME (method), sig);\n+      found = lookup_argument_method_generic (class, DECL_NAME (method), sig,\n+\t\t\t\t\t      SEARCH_SUPER | SEARCH_INTERFACE);\n \n       /* Inner class can't declare static methods */\n       if (METHOD_STATIC (method) && !TOPLEVEL_CLASS_DECL_P (class_decl))\n@@ -6357,7 +6385,7 @@ java_check_regular_methods (tree class_decl)\n \t    continue;\n \t  parse_error_context\n \t    (method_wfl,\n-\t     \"%s methods can't be overriden. Method `%s' is %s in class `%s'\",\n+\t     \"%s methods can't be overridden. Method `%s' is %s in class `%s'\",\n \t     (METHOD_FINAL (found) ? \"Final\" : \"Static\"),\n \t     lang_printable_name (found, 0),\n \t     (METHOD_FINAL (found) ? \"final\" : \"static\"),\n@@ -6371,7 +6399,7 @@ java_check_regular_methods (tree class_decl)\n \t{\n \t  parse_error_context\n \t    (method_wfl,\n-\t     \"Instance methods can't be overriden by a static method. Method `%s' is an instance method in class `%s'\",\n+\t     \"Instance methods can't be overridden by a static method. Method `%s' is an instance method in class `%s'\",\n \t     lang_printable_name (found, 0),\n \t     IDENTIFIER_POINTER\n \t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n@@ -6380,7 +6408,7 @@ java_check_regular_methods (tree class_decl)\n \n       /* - Overriding/hiding public must be public\n \t - Overriding/hiding protected must be protected or public\n-         - If the overriden or hidden method has default (package)\n+         - If the overridden or hidden method has default (package)\n            access, then the overriding or hiding method must not be\n            private; otherwise, a compile-time error occurs.  If\n            `found' belongs to an interface, things have been already\n@@ -6402,13 +6430,20 @@ java_check_regular_methods (tree class_decl)\n \t  continue;\n \t}\n \n-      /* Overriding methods must have compatible `throws' clauses on checked\n-\t exceptions, if any */\n-      check_throws_clauses (method, method_wfl, found);\n-\n-      /* Inheriting multiple methods with the same signature. FIXME */\n+      /* Check this method against all the other implementations it\n+\t overrides.  Here we only check the class hierarchy; the rest\n+\t of the checking is done later.  If this method is just a\n+\t Miranda method, we can skip the check.  */\n+      if (! METHOD_INVISIBLE (method))\n+\tcheck_concrete_throws_clauses (class, method, DECL_NAME (method), sig);\n     }\n \n+  /* The above throws clause check only looked at superclasses.  Now\n+     we must also make sure that all methods declared in interfaces\n+     have compatible throws clauses.  FIXME: there are more efficient\n+     ways to organize this checking; we should implement one.  */\n+  check_interface_throws_clauses (class, class);\n+\n   if (!TYPE_NVIRTUALS (class))\n     TYPE_METHODS (class) = nreverse (TYPE_METHODS (class));\n \n@@ -6420,13 +6455,83 @@ java_check_regular_methods (tree class_decl)\n     abort ();\n }\n \n-/* Return a nonzero value if the `throws' clause of METHOD (if any)\n-   is incompatible with the `throws' clause of FOUND (if any).  */\n+/* Check to make sure that all the methods in all the interfaces\n+   implemented by CLASS_DECL are compatible with the concrete\n+   implementations available in CHECK_CLASS_DECL.  */\n+static void\n+check_interface_throws_clauses (tree check_class_decl, tree class_decl)\n+{\n+  for (; class_decl != NULL_TREE; class_decl = CLASSTYPE_SUPER (class_decl))\n+    {\n+      tree bases = TYPE_BINFO_BASETYPES (class_decl);\n+      int iface_len = TREE_VEC_LENGTH (bases) - 1;\n+      int i;\n+\n+      for (i = iface_len; i > 0; --i)\n+\t{\n+\t  tree interface = BINFO_TYPE (TREE_VEC_ELT (bases, i));\n+\t  tree iface_method;\n \n+\t  for (iface_method = TYPE_METHODS (interface);\n+\t       iface_method != NULL_TREE;\n+\t       iface_method = TREE_CHAIN (iface_method))\n+\t    {\n+\t      tree sig, method;\n+\n+\t      /* First look for a concrete method implemented or\n+\t\t inherited by this class.  No need to search\n+\t\t interfaces here, since we're already looking through\n+\t\t all of them.  */\n+\t      sig = build_java_argument_signature (TREE_TYPE (iface_method));\n+\t      method\n+\t\t= lookup_argument_method_generic (check_class_decl,\n+\t\t\t\t\t\t  DECL_NAME (iface_method),\n+\t\t\t\t\t\t  sig, SEARCH_VISIBLE);\n+\t      /* If we don't find an implementation, that is ok.  Any\n+\t\t potential errors from that are diagnosed elsewhere.\n+\t\t Also, multiple inheritance with conflicting throws\n+\t\t clauses is fine in the absence of a concrete\n+\t\t implementation.  */\n+\t      if (method != NULL_TREE && !METHOD_ABSTRACT (method))\n+\t\t{\n+\t\t  tree method_wfl = DECL_FUNCTION_WFL (method);\n+\t\t  check_throws_clauses (method, method_wfl, iface_method);\n+\t\t}\n+\t    }\n+\n+\t  /* Now check superinterfaces.  */\n+\t  check_interface_throws_clauses (check_class_decl, interface);\n+\t}\n+    }\n+}\n+\n+/* Check throws clauses of a method against the clauses of all the\n+   methods it overrides.  We do this by searching up the class\n+   hierarchy, examining all matching accessible methods.  */\n+static void\n+check_concrete_throws_clauses (tree class, tree self_method,\n+\t\t\t       tree name, tree signature)\n+{\n+  tree method = lookup_argument_method_generic (class, name, signature,\n+\t\t\t\t\t\tSEARCH_SUPER | SEARCH_VISIBLE);\n+  while (method != NULL_TREE)\n+    {\n+      if (! METHOD_INVISIBLE (method) && hack_is_accessible_p (method, class))\n+\tcheck_throws_clauses (self_method, DECL_FUNCTION_WFL (self_method),\n+\t\t\t      method);\n+\n+      method = lookup_argument_method_generic (DECL_CONTEXT (method),\n+\t\t\t\t\t       name, signature,\n+\t\t\t\t\t       SEARCH_SUPER | SEARCH_VISIBLE);\n+    }\n+}\n+\n+/* Generate an error if the `throws' clause of METHOD (if any) is\n+   incompatible with the `throws' clause of FOUND (if any).  */\n static void\n check_throws_clauses (tree method, tree method_wfl, tree found)\n {\n-  tree mthrows, fthrows;\n+  tree mthrows;\n \n   /* Can't check these things with class loaded from bytecode. FIXME */\n   if (!CLASS_FROM_SOURCE_P (DECL_CONTEXT (found)))\n@@ -6435,28 +6540,31 @@ check_throws_clauses (tree method, tree method_wfl, tree found)\n   for (mthrows = DECL_FUNCTION_THROWS (method);\n        mthrows; mthrows = TREE_CHAIN (mthrows))\n     {\n+      tree fthrows;\n+\n       /* We don't verify unchecked expressions */\n       if (IS_UNCHECKED_EXCEPTION_P (TREE_VALUE (mthrows)))\n \tcontinue;\n       /* Checked expression must be compatible */\n       for (fthrows = DECL_FUNCTION_THROWS (found);\n \t   fthrows; fthrows = TREE_CHAIN (fthrows))\n-\tif (inherits_from_p (TREE_VALUE (mthrows), TREE_VALUE (fthrows)))\n-\t  break;\n+\t{\n+\t  if (inherits_from_p (TREE_VALUE (mthrows), TREE_VALUE (fthrows)))\n+\t    break;\n+\t}\n       if (!fthrows)\n \t{\n \t  parse_error_context\n-\t    (method_wfl, \"Invalid checked exception class `%s' in `throws' clause. The exception must be a subclass of an exception thrown by `%s' from class `%s'\",\n+\t    (method_wfl, \"Invalid checked exception class `%s' in `throws' clause.  The exception must be a subclass of an exception thrown by `%s' from class `%s'\",\n \t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (TREE_VALUE (mthrows)))),\n \t     lang_printable_name (found, 0),\n \t     IDENTIFIER_POINTER\n-\t       (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n+\t     (DECL_NAME (TYPE_NAME (DECL_CONTEXT (found)))));\n \t}\n     }\n }\n \n /* Check abstract method of interface INTERFACE */\n-\n static void\n java_check_abstract_methods (tree interface_decl)\n {\n@@ -6470,8 +6578,7 @@ java_check_abstract_methods (tree interface_decl)\n       if (check_method_redefinition (interface, method))\n \tcontinue;\n \n-      /* 3- Overriding is OK as far as we preserve the return type and\n-\t the thrown exceptions (FIXME) */\n+      /* 3- Overriding is OK as far as we preserve the return type.  */\n       found = lookup_java_interface_method2 (interface, method);\n       if (found)\n \t{\n@@ -10100,7 +10207,7 @@ patch_method_invocation (tree patch, tree primary, tree where, int from_super,\n   tree this_arg = NULL_TREE;\n   int is_array_clone_call = 0;\n \n-  /* Should be overriden if everything goes well. Otherwise, if\n+  /* Should be overridden if everything goes well. Otherwise, if\n      something fails, it should keep this value. It stop the\n      evaluation of a bogus assignment. See java_complete_tree,\n      MODIFY_EXPR: for the reasons why we sometimes want to keep on\n@@ -11057,10 +11164,15 @@ find_most_specific_methods_list (tree list)\n \n   /* If we have several and they're all abstract, just pick the\n      closest one. */\n-  if (candidates > 0 && (candidates == abstract))\n+  if (candidates > 0 && candidates == abstract)\n     {\n+      /* FIXME: merge the throws clauses.  There is no convenient way\n+\t to do this in gcj right now, since ideally we'd like to\n+\t introduce a new METHOD_DECL here, but that is really not\n+\t possible.  */\n       new_list = nreverse (new_list);\n       TREE_CHAIN (new_list) = NULL_TREE;\n+      return new_list;\n     }\n \n   /* We have several (we couldn't find a most specific), all but one"}, {"sha": "972cb8b3686b3b5540633b0df9cbe785f1a81d3e", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 101, "deletions": 83, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aecf41099bac0258050c052bdc1892e8b4a5d145/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=aecf41099bac0258050c052bdc1892e8b4a5d145", "patch": "@@ -42,7 +42,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n static tree convert_ieee_real_to_integer (tree, tree);\n static tree parse_signature_type (const unsigned char **,\n \t\t\t\t  const unsigned char *);\n-static tree lookup_do (tree, tree, tree, tree, tree (*)(tree));\n+static tree lookup_do (tree, int, tree, tree, tree (*)(tree));\n static tree build_null_signature (tree);\n \n tree * type_map;\n@@ -687,124 +687,142 @@ set_java_signature (tree type, tree sig)\n #endif\n }\n \n-/* Search in class SEARCHED_CLASS (and its superclasses) for a method\n-   matching METHOD_NAME and signature SIGNATURE.  If SEARCHED_INTERFACE is\n-   not NULL_TREE then first search its superinterfaces for a similar match.\n-   Return the matched method DECL or NULL_TREE.  SIGNATURE_BUILDER is\n-   used on method candidates to build their (sometimes partial)\n-   signature.  */\n-\n+/* Search in SEARCHED_CLASS and its superclasses for a method matching\n+   METHOD_NAME and signature METHOD_SIGNATURE.  This function will\n+   only search for methods declared in the class hierarchy; interfaces\n+   will not be considered.  Returns NULL_TREE if the method is not\n+   found.  */\n tree\n-lookup_argument_method (tree searched_class, tree method_name, tree method_signature)\n+lookup_argument_method (tree searched_class, tree method_name,\n+\t\t\ttree method_signature)\n {\n-  return lookup_do (searched_class, NULL_TREE, method_name, method_signature, \n+  return lookup_do (searched_class, 0,\n+\t\t    method_name, method_signature, \n \t\t    build_java_argument_signature);\n }\n \n-/* Search in class SEARCHED_CLASS (and its superclasses and\n-   implemented interfaces) for a method matching METHOD_NAME and\n-   argument signature METHOD_SIGNATURE.  Return a FUNCTION_DECL on\n-   success, or NULL_TREE if none found.  (Contrast lookup_java_method,\n-   which takes into account return type.) */\n-\n+/* Like lookup_argument_method, but lets the caller set any flags\n+   desired.  */\n tree\n-lookup_argument_method2 (tree searched_class, tree method_name, tree method_signature)\n+lookup_argument_method_generic (tree searched_class, tree method_name,\n+\t\t\t\ttree method_signature, int flags)\n {\n-  return lookup_do (CLASSTYPE_SUPER (searched_class), searched_class,\n+  return lookup_do (searched_class, flags,\n \t\t    method_name, method_signature, \n \t\t    build_java_argument_signature);\n }\n \n+\n /* Search in class SEARCHED_CLASS (and its superclasses) for a method\n    matching METHOD_NAME and signature METHOD_SIGNATURE.  Return a\n    FUNCTION_DECL on success, or NULL_TREE if none found.  (Contrast\n-   lookup_argument_method, which ignores return type.) If\n+   lookup_argument_method, which ignores return type.)  If\n    SEARCHED_CLASS is an interface, search it too. */\n-\n tree\n-lookup_java_method (tree searched_class, tree method_name, tree method_signature)\n+lookup_java_method (tree searched_class, tree method_name,\n+\t\t    tree method_signature)\n {\n-  tree searched_interface;\n-  \n-  /* If this class is an interface class, search its superinterfaces\n-   * first. A superinterface is not an interface's superclass: a super\n-   * interface is implemented by the interface.  */\n-\n-  searched_interface = (CLASS_INTERFACE (TYPE_NAME (searched_class)) ?\n-\t\t\tsearched_class : NULL_TREE);\n-  return lookup_do (searched_class, searched_interface, method_name, \n+  return lookup_do (searched_class, SEARCH_INTERFACE, method_name, \n \t\t    method_signature, build_java_signature);\n }\n \n-/* Return true iff CLASS (or its ancestors) has a method METHOD_NAME. */\n-\n+/* Return true iff CLASS (or its ancestors) has a method METHOD_NAME. \ufffd*/\n int\n has_method (tree class, tree method_name)\n {\n-  return lookup_do (class, class,  method_name,\n-\t\t    NULL_TREE, build_null_signature) != NULL_TREE;\n+  return lookup_do (class, SEARCH_INTERFACE,\n+\t\t    method_name, NULL_TREE,\n+\t\t    build_null_signature) != NULL_TREE;\n }\n \n /* Search in class SEARCHED_CLASS (and its superclasses) for a method\n-   matching METHOD_NAME and signature SIGNATURE.  Also search in\n-   SEARCHED_INTERFACE (and its superinterfaces) for a similar match.\n+   matching METHOD_NAME and signature SIGNATURE.  FLAGS control some\n+   parameters of the search.\n+   \n+   SEARCH_INTERFACE means also search interfaces and superinterfaces\n+   of SEARCHED_CLASS.\n+   \n+   SEARCH_SUPER means skip SEARCHED_CLASS and start with its\n+   superclass.\n+   \n+   SEARCH_ONLY_INTERFACE means don't search ordinary classes, but\n+   instead only search interfaces and superinterfaces.\n+\n+   SEARCH_VISIBLE means skip methods for which METHOD_INVISIBLE is\n+   set.\n+\n    Return the matched method DECL or NULL_TREE.  SIGNATURE_BUILDER is\n    used on method candidates to build their (sometimes partial)\n    signature.  */\n-\n static tree\n-lookup_do (tree searched_class, tree searched_interface, tree method_name,\n+lookup_do (tree searched_class, int flags, tree method_name,\n \t   tree signature, tree (*signature_builder) (tree))\n {\n   tree method;\n-  \n-  if (searched_interface)\n-    {\n-      int i;\n-      int interface_len = \n-\tTREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (searched_interface)) - 1;\n-\n-      for (i = interface_len; i > 0; i--)\n-       {\n-         tree child = \n-\t   TREE_VEC_ELT (TYPE_BINFO_BASETYPES (searched_interface), i);\n-         tree iclass = BINFO_TYPE (child);\n-\n-         /* If the superinterface hasn't been loaded yet, do so now.  */\n-\t if (CLASS_FROM_SOURCE_P (iclass))\n-\t   safe_layout_class (iclass);\n-\t else if (!CLASS_LOADED_P (iclass))\n-\t   load_class (iclass, 1);\n-\n-         for (method = TYPE_METHODS (iclass);\n-              method != NULL_TREE;  method = TREE_CHAIN (method))\n-           {\n-             tree method_sig = (*signature_builder) (TREE_TYPE (method));\n-\n-\t     if (DECL_NAME (method) == method_name && method_sig == signature)\n-               return method;\n-           }\n-\n-         /* it could be defined in a supersuperinterface */\n-         if (CLASS_INTERFACE (TYPE_NAME (iclass)))\n-           {\n-             method = lookup_do (iclass, iclass, method_name, \n-\t\t\t\t signature, signature_builder);\n-             if (method != NULL_TREE) \n-\t       return method;\n-           }\n-       }\n-    }\n+  int first_time = 1;\n+\n+  /* If the incoming class is an interface, then we will only return\n+     a method declared in an interface context.  */\n+  if (searched_class != NULL_TREE\n+      && CLASS_INTERFACE (TYPE_NAME (searched_class)))\n+    flags |= SEARCH_ONLY_INTERFACE;\n \n   while (searched_class != NULL_TREE)\n     {\n-      for (method = TYPE_METHODS (searched_class);\n-\t   method != NULL_TREE;  method = TREE_CHAIN (method))\n-\t{\n-\t  tree method_sig = (*signature_builder) (TREE_TYPE (method));\n-\t  if (DECL_NAME (method) == method_name && method_sig == signature)\n-\t    return method;\n-\t}\n+      /* First search this class.  If we're only searching the\n+ \t superclass, skip this.  */\n+      if (! ((flags & SEARCH_SUPER) && first_time))\n+ \t{\n+ \t  for (method = TYPE_METHODS (searched_class);\n+ \t       method != NULL_TREE;  method = TREE_CHAIN (method))\n+ \t    {\n+ \t      tree method_sig = (*signature_builder) (TREE_TYPE (method));\n+ \t      if (DECL_NAME (method) == method_name && method_sig == signature)\n+\t\t{\n+\t\t  /* If the caller requires a visible method, then we\n+\t\t     skip invisible methods here.  */\n+\t\t  if (! (flags & SEARCH_VISIBLE)\n+\t\t      || ! METHOD_INVISIBLE (method))\n+\t\t    return method;\n+\t\t}\n+ \t    }\n+ \t}\n+      first_time = 0;\n+\n+      /* Search interfaces, if required.  */\n+      if ((flags & SEARCH_INTERFACE))\n+ \t{\n+ \t  int i;\n+ \t  int interface_len = \n+ \t    TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (searched_class)) - 1;\n+\n+ \t  for (i = interface_len; i > 0; i--)\n+ \t    {\n+ \t      tree child = \n+ \t\tTREE_VEC_ELT (TYPE_BINFO_BASETYPES (searched_class), i);\n+ \t      tree iclass = BINFO_TYPE (child);\n+\n+ \t      /* If the superinterface hasn't been loaded yet, do so now.  */\n+ \t      if (CLASS_FROM_SOURCE_P (iclass))\n+ \t\tsafe_layout_class (iclass);\n+ \t      else if (!CLASS_LOADED_P (iclass))\n+ \t\tload_class (iclass, 1);\n+\n+\t      /* Note that we don't care about SEARCH_VISIBLE here,\n+\t\t since an interface can never have an invisible\n+\t\t method.  */\n+ \t      method = lookup_do (iclass, SEARCH_INTERFACE,\n+\t\t\t\t  method_name, signature, signature_builder);\n+ \t      if (method != NULL_TREE) \n+ \t\treturn method;\n+ \t    }\n+ \t}\n+\n+      /* If we're only searching for interface methods, then we've\n+\t already searched all the superinterfaces.  Our superclass is\n+\t Object, but we don't want to search that.  */\n+      if ((flags & SEARCH_ONLY_INTERFACE))\n+\tbreak;\n       searched_class = CLASSTYPE_SUPER (searched_class);\n     }\n "}]}