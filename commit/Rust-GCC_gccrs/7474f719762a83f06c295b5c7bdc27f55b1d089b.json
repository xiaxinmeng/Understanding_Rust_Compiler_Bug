{"sha": "7474f719762a83f06c295b5c7bdc27f55b1d089b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ3NGY3MTk3NjJhODNmMDZjMjk1YjVjN2JkYzI3ZjU1YjFkMDg5Yg==", "commit": {"author": {"name": "Chen Liqin", "email": "liqin.gcc@gmail.com", "date": "2011-07-01T07:51:38Z"}, "committer": {"name": "Chen Liqin", "email": "liqin@gcc.gnu.org", "date": "2011-07-01T07:51:38Z"}, "message": "config.gcc (score-*-elf): Remove score7.o.\n\n2011-07-01  Chen Liqin  <liqin.gcc@gmail.com>\n\n        * config.gcc (score-*-elf): Remove score7.o.\n        * config/score/t-score-elf: Likewise.\n        * config/score/score.c: Merge score7 to score.c and remove forwarding functions.\n        * config/score/score7.c: Deleted.\n        * config/score/score7.h: Deleted.\n\nFrom-SVN: r175747", "tree": {"sha": "f4a7a0f6d75fc60389d4f90a65c22d12be5effca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4a7a0f6d75fc60389d4f90a65c22d12be5effca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7474f719762a83f06c295b5c7bdc27f55b1d089b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7474f719762a83f06c295b5c7bdc27f55b1d089b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7474f719762a83f06c295b5c7bdc27f55b1d089b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7474f719762a83f06c295b5c7bdc27f55b1d089b/comments", "author": null, "committer": null, "parents": [{"sha": "ab70d825c6eda82882708757b89f80b8f2f1d2f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab70d825c6eda82882708757b89f80b8f2f1d2f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab70d825c6eda82882708757b89f80b8f2f1d2f6"}], "stats": {"total": 3760, "additions": 1550, "deletions": 2210}, "files": [{"sha": "123606ab4ef92369e82fc756ba8699998e53f279", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7474f719762a83f06c295b5c7bdc27f55b1d089b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7474f719762a83f06c295b5c7bdc27f55b1d089b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7474f719762a83f06c295b5c7bdc27f55b1d089b", "patch": "@@ -1,3 +1,12 @@\n+2011-07-01  Chen Liqin  <liqin.gcc@gmail.com>\n+\n+\t* config.gcc (score-*-elf): Remove score7.o.\n+\t* config/score/t-score-elf: Likewise.\n+\t* config/score/score.c: Merge score7 to score.c and\n+\tremove forwarding functions.\n+\t* config/score/score7.c: Deleted.\n+\t* config/score/score7.h: Deleted.\n+\n 2011-07-01  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/49603"}, {"sha": "1c44a8e2d834e506647f326afafab897777ea632", "filename": "gcc/config.gcc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7474f719762a83f06c295b5c7bdc27f55b1d089b/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7474f719762a83f06c295b5c7bdc27f55b1d089b/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=7474f719762a83f06c295b5c7bdc27f55b1d089b", "patch": "@@ -2245,7 +2245,6 @@ score-*-elf)\n         tm_file=\"dbxelf.h elfos.h score/elf.h score/score.h newlib-stdint.h\"\n \textra_parts=\"crti.o crtn.o crtbegin.o crtend.o\"\n         tmake_file=\"${tmake_file} score/t-score-elf score/t-score-softfp soft-fp/t-softfp\"\n-        extra_objs=\"score7.o\"\n         ;;\n sh-*-elf* | sh[12346l]*-*-elf* | \\\n   sh-*-linux* | sh[2346lbe]*-*-linux* | \\"}, {"sha": "6325dd9b7a53cf08d399a15431a5911b489a4cfa", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 1541, "deletions": 247, "changes": 1788, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7474f719762a83f06c295b5c7bdc27f55b1d089b/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7474f719762a83f06c295b5c7bdc27f55b1d089b/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=7474f719762a83f06c295b5c7bdc27f55b1d089b", "patch": "@@ -47,11 +47,65 @@\n #include \"target-def.h\"\n #include \"integrate.h\"\n #include \"langhooks.h\"\n-#include \"score7.h\"\n+#include \"cfglayout.h\"\n #include \"df.h\"\n #include \"opts.h\"\n \n-static void score_option_override (void);\n+#define SCORE_SDATA_MAX                score_sdata_max\n+#define SCORE_STACK_ALIGN(LOC)         (((LOC) + 3) & ~3)\n+#define SCORE_PROLOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n+#define SCORE_EPILOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n+#define SCORE_DEFAULT_SDATA_MAX        8\n+\n+#define BITSET_P(VALUE, BIT)           (((VALUE) & (1L << (BIT))) != 0)\n+#define INS_BUF_SZ                     128\n+\n+enum score_address_type\n+{\n+  SCORE_ADD_REG,\n+  SCORE_ADD_CONST_INT,\n+  SCORE_ADD_SYMBOLIC\n+};\n+\n+struct score_frame_info\n+{\n+  HOST_WIDE_INT total_size;       /* bytes that the entire frame takes up  */\n+  HOST_WIDE_INT var_size;         /* bytes that variables take up  */\n+  HOST_WIDE_INT args_size;        /* bytes that outgoing arguments take up  */\n+  HOST_WIDE_INT gp_reg_size;      /* bytes needed to store gp regs  */\n+  HOST_WIDE_INT gp_sp_offset;     /* offset from new sp to store gp registers  */\n+  HOST_WIDE_INT cprestore_size;   /* # bytes that the .cprestore slot takes up  */\n+  unsigned int  mask;             /* mask of saved gp registers  */\n+  int num_gp;                     /* number of gp registers saved  */\n+};\n+\n+struct score_arg_info\n+{\n+  unsigned int num_bytes;     /* The argument's size in bytes  */\n+  unsigned int reg_words;     /* The number of words passed in registers  */\n+  unsigned int reg_offset;    /* The offset of the first register from  */\n+                              /* GP_ARG_FIRST or FP_ARG_FIRST etc  */\n+  unsigned int stack_words;   /* The number of words that must be passed  */\n+                              /* on the stack  */\n+  unsigned int stack_offset;  /* The offset from the start of the stack  */\n+                              /* overflow area  */\n+};\n+\n+#ifdef RTX_CODE\n+struct score_address_info\n+{\n+  enum score_address_type type;\n+  rtx reg;\n+  rtx offset;\n+  enum rtx_code code;\n+  enum score_symbol_type symbol_type;\n+};\n+#endif\n+\n+static int score_sdata_max;\n+static char score_ins[INS_BUF_SZ + 8];\n+\n+struct extern_list *extern_head = 0;\n \n #undef  TARGET_ASM_FILE_START\n #define TARGET_ASM_FILE_START           score_asm_file_start\n@@ -133,31 +187,261 @@ static void score_option_override (void);\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT\t\tscore_trampoline_init\n \n-struct extern_list *extern_head = 0;\n+/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n+   to the same object as SYMBOL.  */\n+static int\n+score_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n+{\n+  if (GET_CODE (symbol) != SYMBOL_REF)\n+    return 0;\n+\n+  if (CONSTANT_POOL_ADDRESS_P (symbol)\n+      && offset >= 0\n+      && offset < (int)GET_MODE_SIZE (get_pool_mode (symbol)))\n+    return 1;\n+\n+  if (SYMBOL_REF_DECL (symbol) != 0\n+      && offset >= 0\n+      && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Split X into a base and a constant offset, storing them in *BASE\n+   and *OFFSET respectively.  */\n+static void\n+score_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n+{\n+  *offset = 0;\n+\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      *offset += INTVAL (XEXP (x, 1));\n+      x = XEXP (x, 0);\n+    }\n+\n+  *base = x;\n+}\n+\n+/* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n+static enum score_symbol_type\n+score_classify_symbol (rtx x)\n+{\n+  if (GET_CODE (x) == LABEL_REF)\n+    return SYMBOL_GENERAL;\n+\n+  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n+\n+  if (CONSTANT_POOL_ADDRESS_P (x))\n+    {\n+      if (GET_MODE_SIZE (get_pool_mode (x)) <= SCORE_SDATA_MAX)\n+        return SYMBOL_SMALL_DATA;\n+      return SYMBOL_GENERAL;\n+    }\n+  if (SYMBOL_REF_SMALL_P (x))\n+    return SYMBOL_SMALL_DATA;\n+  return SYMBOL_GENERAL;\n+}\n \n-/* default 0 = NO_REGS  */\n-enum reg_class score_char_to_class[256];\n+/* Return true if the current function must save REGNO.  */\n+static int\n+score_save_reg_p (unsigned int regno)\n+{\n+  /* Check call-saved registers.  */\n+  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n+    return 1;\n+\n+  /* We need to save the old frame pointer before setting up a new one.  */\n+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n+    return 1;\n+\n+  /* We need to save the incoming return address if it is ever clobbered\n+     within the function.  */\n+  if (regno == RA_REGNUM && df_regs_ever_live_p (regno))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Return one word of double-word value OP, taking into account the fixed\n+   endianness of certain registers.  HIGH_P is true to select the high part,\n+   false to select the low part.  */\n+static rtx\n+score_subw (rtx op, int high_p)\n+{\n+  unsigned int byte;\n+  enum machine_mode mode = GET_MODE (op);\n+\n+  if (mode == VOIDmode)\n+    mode = DImode;\n+\n+  byte = (TARGET_LITTLE_ENDIAN ? high_p : !high_p) ? UNITS_PER_WORD : 0;\n+\n+  if (GET_CODE (op) == REG && REGNO (op) == HI_REGNUM)\n+    return gen_rtx_REG (SImode, high_p ? HI_REGNUM : LO_REGNUM);\n+\n+  if (GET_CODE (op) == MEM)\n+    return adjust_address (op, SImode, byte);\n+\n+  return simplify_gen_subreg (SImode, op, mode, byte);\n+}\n+\n+static struct score_frame_info *\n+score_cached_frame (void)\n+{\n+  static struct score_frame_info _frame_info;\n+  return &_frame_info;\n+}\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer.  SIZE is the size (in bytes) of the local variables.  */\n+static struct score_frame_info *\n+score_compute_frame_size (HOST_WIDE_INT size)\n+{\n+  unsigned int regno;\n+  struct score_frame_info *f = score_cached_frame ();\n+\n+  memset (f, 0, sizeof (struct score_frame_info));\n+  f->gp_reg_size = 0;\n+  f->mask = 0;\n+  f->var_size = SCORE_STACK_ALIGN (size);\n+  f->args_size = crtl->outgoing_args_size;\n+  f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n+  if (f->var_size == 0 && current_function_is_leaf)\n+    f->args_size = f->cprestore_size = 0;\n+\n+  if (f->args_size == 0 && cfun->calls_alloca)\n+    f->args_size = UNITS_PER_WORD;\n+\n+  f->total_size = f->var_size + f->args_size + f->cprestore_size;\n+  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n+    {\n+      if (score_save_reg_p (regno))\n+        {\n+          f->gp_reg_size += GET_MODE_SIZE (SImode);\n+          f->mask |= 1 << (regno - GP_REG_FIRST);\n+        }\n+    }\n+\n+  if (crtl->calls_eh_return)\n+    {\n+      unsigned int i;\n+      for (i = 0;; ++i)\n+        {\n+          regno = EH_RETURN_DATA_REGNO (i);\n+          if (regno == INVALID_REGNUM)\n+            break;\n+          f->gp_reg_size += GET_MODE_SIZE (SImode);\n+          f->mask |= 1 << (regno - GP_REG_FIRST);\n+        }\n+    }\n+\n+  f->total_size += f->gp_reg_size;\n+  f->num_gp = f->gp_reg_size / UNITS_PER_WORD;\n+\n+  if (f->mask)\n+    {\n+      HOST_WIDE_INT offset;\n+      offset = (f->args_size + f->cprestore_size + f->var_size\n+                + f->gp_reg_size - GET_MODE_SIZE (SImode));\n+      f->gp_sp_offset = offset;\n+    }\n+  else\n+    f->gp_sp_offset = 0;\n+\n+  return f;\n+}\n+\n+/* Return true if X is a valid base register for the given mode.\n+   Allow only hard registers if STRICT.  */\n+static int\n+score_valid_base_register_p (rtx x, int strict)\n+{\n+  if (!strict && GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+\n+  return (GET_CODE (x) == REG\n+          && score_regno_mode_ok_for_base_p (REGNO (x), strict));\n+}\n+\n+/* Return true if X is a valid address for machine mode MODE.  If it is,\n+   fill in INFO appropriately.  STRICT is true if we should only accept\n+   hard base registers.  */\n+static int\n+score_classify_address (struct score_address_info *info,\n+                        enum machine_mode mode, rtx x, int strict)\n+{\n+  info->code = GET_CODE (x);\n+\n+  switch (info->code)\n+    {\n+    case REG:\n+    case SUBREG:\n+      info->type = SCORE_ADD_REG;\n+      info->reg = x;\n+      info->offset = const0_rtx;\n+      return score_valid_base_register_p (info->reg, strict);\n+    case PLUS:\n+      info->type = SCORE_ADD_REG;\n+      info->reg = XEXP (x, 0);\n+      info->offset = XEXP (x, 1);\n+      return (score_valid_base_register_p (info->reg, strict)\n+              && GET_CODE (info->offset) == CONST_INT\n+              && IMM_IN_RANGE (INTVAL (info->offset), 15, 1));\n+    case PRE_DEC:\n+    case POST_DEC:\n+    case PRE_INC:\n+    case POST_INC:\n+      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (SImode))\n+        return false;\n+      info->type = SCORE_ADD_REG;\n+      info->reg = XEXP (x, 0);\n+      info->offset = GEN_INT (GET_MODE_SIZE (mode));\n+      return score_valid_base_register_p (info->reg, strict);\n+    case CONST_INT:\n+      info->type = SCORE_ADD_CONST_INT;\n+      return IMM_IN_RANGE (INTVAL (x), 15, 1);\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      info->type = SCORE_ADD_SYMBOLIC;\n+      return (score_symbolic_constant_p (x, &info->symbol_type)\n+              && (info->symbol_type == SYMBOL_GENERAL\n+                  || info->symbol_type == SYMBOL_SMALL_DATA));\n+    default:\n+      return 0;\n+    }\n+}\n \n /* Implement TARGET_RETURN_IN_MEMORY.  In S+core,\n    small structures are returned in a register.\n    Objects with varying size must still be returned in memory.  */\n static bool\n score_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_return_in_memory (type, fndecl);\n-  else\n-    gcc_unreachable ();\n+    return ((TYPE_MODE (type) == BLKmode)\n+            || (int_size_in_bytes (type) > 2 * UNITS_PER_WORD)\n+            || (int_size_in_bytes (type) == -1));\n }\n \n-/* Return nonzero when an argument must be passed by reference.  */\n-static bool\n-score_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n-                         enum machine_mode mode, const_tree type,\n-                         bool named ATTRIBUTE_UNUSED)\n+/* Return a legitimate address for REG + OFFSET.  */\n+static rtx\n+score_add_offset (rtx reg, HOST_WIDE_INT offset)\n {\n-  /* If we have a variable-sized parameter, we have no choice.  */\n-  return targetm.calls.must_pass_in_stack (mode, type);\n+  if (!IMM_IN_RANGE (offset, 15, 1))\n+    {\n+      reg = expand_simple_binop (GET_MODE (reg), PLUS,\n+                                 gen_int_mode (offset & 0xffffc000,\n+                                               GET_MODE (reg)),\n+                                 reg, NULL, 0, OPTAB_WIDEN);\n+      offset &= 0x3fff;\n+    }\n+\n+  return plus_constant (reg, offset);\n }\n \n /* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n@@ -167,86 +451,288 @@ score_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n                        HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n                        tree function)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function);\n+  rtx this_rtx, temp1, insn, fnaddr;\n+\n+  /* Pretend to be a post-reload pass while generating rtl.  */\n+  reload_completed = 1;\n+\n+  /* Mark the end of the (empty) prologue.  */\n+  emit_note (NOTE_INSN_PROLOGUE_END);\n+\n+  /* We need two temporary registers in some cases.  */\n+  temp1 = gen_rtx_REG (Pmode, 8);\n+\n+  /* Find out which register contains the \"this\" pointer.  */\n+  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n+    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n   else\n-    gcc_unreachable ();\n+    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n+\n+  /* Add DELTA to THIS_RTX.  */\n+  if (delta != 0)\n+    {\n+      rtx offset = GEN_INT (delta);\n+      if (!(delta >= -32768 && delta <= 32767))\n+        {\n+          emit_move_insn (temp1, offset);\n+          offset = temp1;\n+        }\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, offset));\n+    }\n+\n+  /* If needed, add *(*THIS_RTX + VCALL_OFFSET) to THIS_RTX.  */\n+  if (vcall_offset != 0)\n+    {\n+      rtx addr;\n+\n+      /* Set TEMP1 to *THIS_RTX.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this_rtx));\n+\n+      /* Set ADDR to a legitimate address for *THIS_RTX + VCALL_OFFSET.  */\n+      addr = score_add_offset (temp1, vcall_offset);\n+\n+      /* Load the offset and add it to THIS_RTX.  */\n+      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, temp1));\n+    }\n+\n+  /* Jump to the target function.  */\n+  fnaddr = XEXP (DECL_RTL (function), 0);\n+  insn = emit_call_insn (gen_sibcall_internal_score7 (fnaddr, const0_rtx));\n+  SIBLING_CALL_P (insn) = 1;\n+\n+  /* Run just enough of rest_of_compilation.  This sequence was\n+     \"borrowed\" from alpha.c.  */\n+  insn = get_insns ();\n+  insn_locators_alloc ();\n+  split_all_insns_noflow ();\n+  shorten_branches (insn);\n+  final_start_function (insn, file, 1);\n+  final (insn, file, 1);\n+  final_end_function ();\n+\n+  /* Clean up the vars set above.  Note that final_end_function resets\n+     the global pointer for us.  */\n+  reload_completed = 0;\n }\n \n-/* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n-static bool\n-score_function_ok_for_sibcall (ATTRIBUTE_UNUSED tree decl,\n-                               ATTRIBUTE_UNUSED tree exp)\n+/* Copy VALUE to a register and return that register.  If new psuedos\n+   are allowed, copy it into a new register, otherwise use DEST.  */\n+static rtx\n+score_force_temporary (rtx dest, rtx value)\n {\n-  return true;\n+  if (can_create_pseudo_p ())\n+    return force_reg (Pmode, value);\n+  else\n+    {\n+      emit_move_insn (copy_rtx (dest), value);\n+      return dest;\n+    }\n+}\n+\n+/* Return a LO_SUM expression for ADDR.  TEMP is as for score_force_temporary\n+   and is used to load the high part into a register.  */\n+static rtx\n+score_split_symbol (rtx temp, rtx addr)\n+{\n+  rtx high = score_force_temporary (temp,\n+                                     gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n+  return gen_rtx_LO_SUM (Pmode, high, addr);\n+}\n+\n+/* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n+   be legitimized in a way that the generic machinery might not expect,\n+   return the new address.  */\n+static rtx\n+score_legitimize_address (rtx x)\n+{\n+  enum score_symbol_type symbol_type;\n+\n+  if (score_symbolic_constant_p (x, &symbol_type)\n+      && symbol_type == SYMBOL_GENERAL)\n+    return score_split_symbol (0, x);\n+\n+  if (GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    {\n+      rtx reg = XEXP (x, 0);\n+      if (!score_valid_base_register_p (reg, 0))\n+        reg = copy_to_mode_reg (Pmode, reg);\n+      return score_add_offset (reg, INTVAL (XEXP (x, 1)));\n+    }\n+\n+  return x;\n+}\n+\n+/* Fill INFO with information about a single argument.  CUM is the\n+   cumulative state for earlier arguments.  MODE is the mode of this\n+   argument and TYPE is its type (if known).  NAMED is true if this\n+   is a named (fixed) argument rather than a variable one.  */\n+static void\n+score_classify_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+                    const_tree type, bool named, struct score_arg_info *info)\n+{\n+  int even_reg_p;\n+  unsigned int num_words, max_regs;\n+\n+  even_reg_p = 0;\n+  if (GET_MODE_CLASS (mode) == MODE_INT\n+      || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n+  else\n+    if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD && named)\n+      even_reg_p = 1;\n+\n+  if (TARGET_MUST_PASS_IN_STACK (mode, type))\n+    info->reg_offset = ARG_REG_NUM;\n+  else\n+    {\n+      info->reg_offset = cum->num_gprs;\n+      if (even_reg_p)\n+        info->reg_offset += info->reg_offset & 1;\n+    }\n+\n+  if (mode == BLKmode)\n+    info->num_bytes = int_size_in_bytes (type);\n+  else\n+    info->num_bytes = GET_MODE_SIZE (mode);\n+\n+  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  max_regs = ARG_REG_NUM - info->reg_offset;\n+\n+  /* Partition the argument between registers and stack.  */\n+  info->reg_words = MIN (num_words, max_regs);\n+  info->stack_words = num_words - info->reg_words;\n+\n+  /* The alignment applied to registers is also applied to stack arguments.  */\n+  if (info->stack_words)\n+    {\n+      info->stack_offset = cum->stack_words;\n+      if (even_reg_p)\n+        info->stack_offset += info->stack_offset & 1;\n+    }\n }\n \n /* Set up the stack and frame (if desired) for the function.  */\n static void\n score_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_function_prologue (file, size);\n-  else\n-    gcc_unreachable ();\n+  const char *fnname;\n+  struct score_frame_info *f = score_cached_frame ();\n+  HOST_WIDE_INT tsize = f->total_size;\n+\n+  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+  if (!flag_inhibit_size_directive)\n+    {\n+      fputs (\"\\t.ent\\t\", file);\n+      assemble_name (file, fnname);\n+      fputs (\"\\n\", file);\n+    }\n+  assemble_name (file, fnname);\n+  fputs (\":\\n\", file);\n+\n+  if (!flag_inhibit_size_directive)\n+    {\n+      fprintf (file,\n+               \"\\t.frame\\t%s,\" HOST_WIDE_INT_PRINT_DEC \",%s, %d\\t\\t\"\n+               \"# vars= \" HOST_WIDE_INT_PRINT_DEC \", regs= %d\"\n+               \", args= \" HOST_WIDE_INT_PRINT_DEC\n+               \", gp= \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+               (reg_names[(frame_pointer_needed)\n+                ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n+               tsize,\n+               reg_names[RA_REGNUM],\n+               current_function_is_leaf ? 1 : 0,\n+               f->var_size,\n+               f->num_gp,\n+               f->args_size,\n+               f->cprestore_size);\n+\n+      fprintf(file, \"\\t.mask\\t0x%08x,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+              f->mask,\n+              (f->gp_sp_offset - f->total_size));\n+    }\n }\n \n /* Do any necessary cleanup after a function to restore stack, frame,\n    and regs.  */\n static void\n-score_function_epilogue (FILE *file,\n-                         HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n+score_function_epilogue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_function_epilogue (file, size);\n-  else\n-    gcc_unreachable ();\n+  if (!flag_inhibit_size_directive)\n+    {\n+      const char *fnname;\n+      fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+      fputs (\"\\t.end\\t\", file);\n+      assemble_name (file, fnname);\n+      fputs (\"\\n\", file);\n+    }\n }\n \n-/* Implement TARGET_SCHED_ISSUE_RATE.  */\n-static int\n-score_issue_rate (void)\n+/* Returns true if X contains a SYMBOL_REF.  */\n+static bool\n+score_symbolic_expression_p (rtx x)\n {\n-  return 1;\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return true;\n+\n+  if (GET_CODE (x) == CONST)\n+    return score_symbolic_expression_p (XEXP (x, 0));\n+\n+  if (UNARY_P (x))\n+    return score_symbolic_expression_p (XEXP (x, 0));\n+\n+  if (ARITHMETIC_P (x))\n+    return (score_symbolic_expression_p (XEXP (x, 0))\n+            || score_symbolic_expression_p (XEXP (x, 1)));\n+\n+  return false;\n }\n \n /* Choose the section to use for the constant rtx expression X that has\n    mode MODE.  */\n static section *\n-score_select_rtx_section (enum machine_mode mode, rtx x,\n-                          unsigned HOST_WIDE_INT align)\n+score_select_rtx_section (enum machine_mode mode, rtx x, unsigned HOST_WIDE_INT align)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_select_rtx_section (mode, x, align);\n+  if (GET_MODE_SIZE (mode) <= SCORE_SDATA_MAX)\n+    return get_named_section (0, \".sdata\", 0);\n+  else if (flag_pic && score_symbolic_expression_p (x))\n+    return get_named_section (0, \".data.rel.ro\", 3);\n   else\n-    gcc_unreachable ();\n+    return mergeable_constant_section (mode, align, 0);\n }\n \n /* Implement TARGET_IN_SMALL_DATA_P.  */\n static bool\n score_in_small_data_p (const_tree decl)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_in_small_data_p (decl);\n-  else\n-    gcc_unreachable ();\n+  HOST_WIDE_INT size;\n+\n+  if (TREE_CODE (decl) == STRING_CST\n+      || TREE_CODE (decl) == FUNCTION_DECL)\n+    return false;\n+\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)\n+    {\n+      const char *name;\n+      name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n+      if (strcmp (name, \".sdata\") != 0\n+          && strcmp (name, \".sbss\") != 0)\n+        return true;\n+      if (!DECL_EXTERNAL (decl))\n+        return false;\n+    }\n+  size = int_size_in_bytes (TREE_TYPE (decl));\n+  return (size > 0 && size <= SCORE_SDATA_MAX);\n }\n \n /* Implement TARGET_ASM_FILE_START.  */\n static void\n score_asm_file_start (void)\n {\n-  if (TARGET_SCORE7D)\n-    fprintf (asm_out_file, \"# Sunplus S+core7d %s rev=%s\\n\",\n-             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n-  else if (TARGET_SCORE7)\n-    fprintf (asm_out_file, \"# Sunplus S+core7 %s rev=%s\\n\",\n-             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n-  else\n-    fprintf (asm_out_file, \"# Sunplus S+core unknown %s rev=%s\\n\",\n-             TARGET_LITTLE_ENDIAN ? \"el\" : \"eb\", SCORE_GCC_VERSION);\n-\n   default_file_start ();\n+  fprintf (asm_out_file, ASM_COMMENT_START\n+           \"GCC for S+core %s \\n\", SCORE_GCC_VERSION);\n \n   if (flag_pic)\n     fprintf (asm_out_file, \"\\t.set pic\\n\");\n@@ -257,38 +743,62 @@ score_asm_file_start (void)\n static void\n score_asm_file_end (void)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_asm_file_end ();\n-  else\n-    gcc_unreachable ();\n+  tree name_tree;\n+  struct extern_list *p;\n+  if (extern_head)\n+    {\n+      fputs (\"\\n\", asm_out_file);\n+      for (p = extern_head; p != 0; p = p->next)\n+        {\n+          name_tree = get_identifier (p->name);\n+          if (!TREE_ASM_WRITTEN (name_tree)\n+              && TREE_SYMBOL_REFERENCED (name_tree))\n+            {\n+              TREE_ASM_WRITTEN (name_tree) = 1;\n+              fputs (\"\\t.extern\\t\", asm_out_file);\n+              assemble_name (asm_out_file, p->name);\n+              fprintf (asm_out_file, \", %d\\n\", p->size);\n+            }\n+        }\n+    }\n }\n \n /* Implement TARGET_OPTION_OVERRIDE hook.  */\n static void\n score_option_override (void)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_option_override ();\n+  flag_pic = false;\n+  score_sdata_max = SCORE_DEFAULT_SDATA_MAX;\n+\n }\n \n /* Implement REGNO_REG_CLASS macro.  */\n int\n score_reg_class (int regno)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_reg_class (regno);\n-  else\n-    gcc_unreachable ();\n+  int c;\n+  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n+\n+  if (regno == FRAME_POINTER_REGNUM\n+      || regno == ARG_POINTER_REGNUM)\n+    return ALL_REGS;\n+\n+  for (c = 0; c < N_REG_CLASSES; c++)\n+    if (TEST_HARD_REG_BIT (reg_class_contents[c], regno))\n+      return c;\n+\n+  return NO_REGS;\n }\n \n /* Implement PREFERRED_RELOAD_CLASS macro.  */\n enum reg_class\n score_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_preferred_reload_class (x, rclass);\n-  else\n-    gcc_unreachable ();\n+  if (reg_class_subset_p (G16_REGS, rclass))\n+    return G16_REGS;\n+  if (reg_class_subset_p (G32_REGS, rclass))\n+    return G32_REGS;\n+  return rclass;\n }\n \n /* Implement SECONDARY_INPUT_RELOAD_CLASS\n@@ -298,10 +808,13 @@ score_secondary_reload_class (enum reg_class rclass,\n                               enum machine_mode mode ATTRIBUTE_UNUSED,\n                               rtx x)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_secondary_reload_class (rclass, mode, x);\n-  else\n-    gcc_unreachable ();\n+  int regno = -1;\n+  if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n+    regno = true_regnum (x);\n+\n+  if (!GR_REG_CLASS_P (rclass))\n+    return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n+  return NO_REGS;\n }\n \n \n@@ -310,20 +823,23 @@ score_secondary_reload_class (enum reg_class rclass,\n int\n score_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_hard_regno_mode_ok (regno, mode);\n+  int size = GET_MODE_SIZE (mode);\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n+\n+  if (mclass == MODE_CC)\n+    return regno == CC_REGNUM;\n+  else if (regno == FRAME_POINTER_REGNUM\n+           || regno == ARG_POINTER_REGNUM)\n+    return mclass == MODE_INT;\n+  else if (GP_REG_P (regno))\n+    /* ((regno <= (GP_REG_LAST- HARD_REGNO_NREGS (dummy, mode)) + 1)  */\n+    return !(regno & 1) || (size <= UNITS_PER_WORD);\n+  else if (CE_REG_P (regno))\n+    return (mclass == MODE_INT\n+            && ((size <= UNITS_PER_WORD)\n+                || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n   else\n-    gcc_unreachable ();\n-}\n-\n-/* We can always eliminate to the hard frame pointer.  We can eliminate\n-   to the stack pointer unless a frame pointer is needed.  */\n-\n-static bool\n-score_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n-{\n-  return (to == HARD_FRAME_POINTER_REGNUM\n-          || (to  == STACK_POINTER_REGNUM && !frame_pointer_needed));\n+    return (mclass == MODE_INT) && (size <= UNITS_PER_WORD);\n }\n \n /* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n@@ -333,121 +849,153 @@ HOST_WIDE_INT\n score_initial_elimination_offset (int from,\n                                   int to ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_initial_elimination_offset (from, to);\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Argument support functions.  */\n-\n-/* Initialize CUMULATIVE_ARGS for a function.  */\n-void\n-score_init_cumulative_args (CUMULATIVE_ARGS *cum,\n-                            tree fntype ATTRIBUTE_UNUSED,\n-                            rtx libname ATTRIBUTE_UNUSED)\n-{\n-  memset (cum, 0, sizeof (CUMULATIVE_ARGS));\n+  struct score_frame_info *f = score_compute_frame_size (get_frame_size ());\n+  switch (from)\n+    {\n+    case ARG_POINTER_REGNUM:\n+      return f->total_size;\n+    case FRAME_POINTER_REGNUM:\n+      return 0;\n+    default:\n+      gcc_unreachable ();\n+    }\n }\n \n /* Implement TARGET_FUNCTION_ARG_ADVANCE hook.  */\n static void\n-score_function_arg_advance (cumulative_args_t cum, enum machine_mode mode,\n+score_function_arg_advance (cumulative_args_t cum_args, enum machine_mode mode,\n                             const_tree type, bool named)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_function_arg_advance (get_cumulative_args (cum), mode, type, named);\n-  else\n-    gcc_unreachable ();\n+  struct score_arg_info info;\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_args);\n+  score_classify_arg (cum, mode, type, named, &info);\n+  cum->num_gprs = info.reg_offset + info.reg_words;\n+  if (info.stack_words > 0)\n+    cum->stack_words = info.stack_offset + info.stack_words;\n+  cum->arg_number++;\n }\n \n /* Implement TARGET_ARG_PARTIAL_BYTES macro.  */\n int\n-score_arg_partial_bytes (cumulative_args_t cum,\n+score_arg_partial_bytes (cumulative_args_t cum_args,\n                          enum machine_mode mode, tree type, bool named)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_arg_partial_bytes (get_cumulative_args (cum), mode, type,\n-\t\t\t\t     named);\n-  else\n-    gcc_unreachable ();\n+  struct score_arg_info info;\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_args);\n+  score_classify_arg (cum, mode, type, named, &info);\n+  return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n }\n \n /* Implement TARGET_FUNCTION_ARG hook.  */\n static rtx\n-score_function_arg (cumulative_args_t cum, enum machine_mode mode,\n+score_function_arg (cumulative_args_t cum_args, enum machine_mode mode,\n                     const_tree type, bool named)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_function_arg (get_cumulative_args (cum), mode, type, named);\n+  struct score_arg_info info;\n+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_args);\n+\n+  if (mode == VOIDmode || !named)\n+    return 0;\n+\n+  score_classify_arg (cum, mode, type, named, &info);\n+\n+  if (info.reg_offset == ARG_REG_NUM)\n+    return 0;\n+\n+  if (!info.stack_words)\n+    return gen_rtx_REG (mode, ARG_REG_FIRST + info.reg_offset);\n   else\n-    gcc_unreachable ();\n+    {\n+      rtx ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n+      unsigned int i, part_offset = 0;\n+      for (i = 0; i < info.reg_words; i++)\n+        {\n+          rtx reg;\n+          reg = gen_rtx_REG (SImode, ARG_REG_FIRST + info.reg_offset + i);\n+          XVECEXP (ret, 0, i) = gen_rtx_EXPR_LIST (SImode, reg,\n+                                                   GEN_INT (part_offset));\n+          part_offset += UNITS_PER_WORD;\n+        }\n+      return ret;\n+    }\n }\n \n /* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n    VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n    VALTYPE is null and MODE is the mode of the return value.  */\n rtx\n-score_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED,\n-                      enum machine_mode mode)\n+score_function_value (const_tree valtype, const_tree func, enum machine_mode mode)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_function_value (valtype, func, mode);\n-  else\n-    gcc_unreachable ();\n+  if (valtype)\n+    {\n+      int unsignedp;\n+      mode = TYPE_MODE (valtype);\n+      unsignedp = TYPE_UNSIGNED (valtype);\n+      mode = promote_function_mode (valtype, mode, &unsignedp, func, 1);\n+    }\n+  return gen_rtx_REG (mode, RT_REGNUM);\n }\n \n /* Implement TARGET_ASM_TRAMPOLINE_TEMPLATE.  */\n+\n static void\n score_asm_trampoline_template (FILE *f)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_asm_trampoline_template (f);\n-  else\n-    gcc_unreachable ();\n+  fprintf (f, \"\\t.set r1\\n\");\n+  fprintf (f, \"\\tmv r31, r3\\n\");\n+  fprintf (f, \"\\tbl nextinsn\\n\");\n+  fprintf (f, \"nextinsn:\\n\");\n+  fprintf (f, \"\\tlw r1, [r3, 6*4-8]\\n\");\n+  fprintf (f, \"\\tlw r23, [r3, 6*4-4]\\n\");\n+  fprintf (f, \"\\tmv r3, r31\\n\");\n+  fprintf (f, \"\\tbr! r1\\n\");\n+  fprintf (f, \"\\tnop!\\n\");\n+  fprintf (f, \"\\t.set nor1\\n\");\n }\n \n /* Implement TARGET_TRAMPOLINE_INIT.  */\n static void\n score_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n {\n-  if ( TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_trampoline_init (m_tramp, fndecl, chain_value);\n-  else  \n-    gcc_unreachable ();\n+#define CODE_SIZE        (TRAMPOLINE_INSNS * UNITS_PER_WORD)\n+\n+  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n+  rtx mem;\n+\n+  emit_block_move (m_tramp, assemble_trampoline_template (),\n+\t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n+\n+  mem = adjust_address (m_tramp, SImode, CODE_SIZE);\n+  emit_move_insn (mem, fnaddr);\n+  mem = adjust_address (m_tramp, SImode, CODE_SIZE + GET_MODE_SIZE (SImode));\n+  emit_move_insn (mem, chain_value);\n+\n+#undef CODE_SIZE\n }\n \n /* This function is used to implement REG_MODE_OK_FOR_BASE_P macro.  */\n int\n score_regno_mode_ok_for_base_p (int regno, int strict)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_regno_mode_ok_for_base_p (regno, strict);\n-  else\n-    gcc_unreachable ();\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (!strict)\n+        return 1;\n+      regno = reg_renumber[regno];\n+    }\n+  if (regno == ARG_POINTER_REGNUM\n+      || regno == FRAME_POINTER_REGNUM)\n+    return 1;\n+  return GP_REG_P (regno);\n }\n \n-/* Implement TARGET_LEGITIMIZE_ADDRESS_P.  */\n+/* Implement TARGET_LEGITIMATE_ADDRESS_P macro.  */\n static bool\n score_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_legitimate_address_p (mode, x, strict);\n-  else\n-    gcc_unreachable ();\n-}\n+  struct score_address_info addr;\n \n-/* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n-   be legitimized in a way that the generic machinery might not expect,\n-   return the new address, else return X.  */\n-static rtx\n-score_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n-\t\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_legitimize_address (x);\n-  else\n-    gcc_unreachable ();\n+  return score_classify_address (&addr, mode, x, strict);\n }\n \n /* Return a number assessing the cost of moving a register in class\n@@ -456,84 +1004,616 @@ int\n score_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n                           enum reg_class from, enum reg_class to)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_register_move_cost (mode, from, to);\n+  if (GR_REG_CLASS_P (from))\n+    {\n+      if (GR_REG_CLASS_P (to))\n+        return 2;\n+      else if (SP_REG_CLASS_P (to))\n+        return 4;\n+      else if (CP_REG_CLASS_P (to))\n+        return 5;\n+      else if (CE_REG_CLASS_P (to))\n+        return 6;\n+    }\n+  if (GR_REG_CLASS_P (to))\n+    {\n+      if (GR_REG_CLASS_P (from))\n+        return 2;\n+      else if (SP_REG_CLASS_P (from))\n+        return 4;\n+      else if (CP_REG_CLASS_P (from))\n+        return 5;\n+      else if (CE_REG_CLASS_P (from))\n+        return 6;\n+    }\n+  return 12;\n+}\n+\n+/* Return the number of instructions needed to load a symbol of the\n+   given type into a register.  */\n+static int\n+score_symbol_insns (enum score_symbol_type type)\n+{\n+  switch (type)\n+    {\n+    case SYMBOL_GENERAL:\n+      return 2;\n+\n+    case SYMBOL_SMALL_DATA:\n+      return 1;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Return the number of instructions needed to load or store a value\n+   of mode MODE at X.  Return 0 if X isn't valid for MODE.  */\n+static int\n+score_address_insns (rtx x, enum machine_mode mode)\n+{\n+  struct score_address_info addr;\n+  int factor;\n+\n+  if (mode == BLKmode)\n+    factor = 1;\n   else\n-    gcc_unreachable ();\n+    factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (score_classify_address (&addr, mode, x, false))\n+    switch (addr.type)\n+      {\n+      case SCORE_ADD_REG:\n+      case SCORE_ADD_CONST_INT:\n+        return factor;\n+\n+      case SCORE_ADD_SYMBOLIC:\n+        return factor * score_symbol_insns (addr.symbol_type);\n+      }\n+  return 0;\n }\n \n /* Implement TARGET_RTX_COSTS macro.  */\n bool\n-score_rtx_costs (rtx x, int code, int outer_code, int *total,\n-\t\t bool speed ATTRIBUTE_UNUSED)\n+score_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_rtx_costs (x, code, outer_code, total, speed);\n-  else\n-    gcc_unreachable ();\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+      if (outer_code == SET)\n+        {\n+          if (((INTVAL (x) & 0xffff) == 0) \n+              || (INTVAL (x) >= -32768 && INTVAL (x) <= 32767))\n+            *total = COSTS_N_INSNS (1);\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else if (outer_code == PLUS || outer_code == MINUS)\n+        {\n+          if (INTVAL (x) >= -8192 && INTVAL (x) <= 8191)\n+            *total = 0;\n+          else if (((INTVAL (x) & 0xffff) == 0)\n+                   || (INTVAL (x) >= -32768 && INTVAL (x) <= 32767))\n+            *total = 1;\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else if (outer_code == AND || outer_code == IOR)\n+        {\n+          if (INTVAL (x) >= 0 && INTVAL (x) <= 16383)\n+            *total = 0;\n+          else if (((INTVAL (x) & 0xffff) == 0)\n+                   || (INTVAL (x) >= 0 && INTVAL (x) <= 65535))\n+            *total = 1;\n+          else\n+            *total = COSTS_N_INSNS (2);\n+        }\n+      else\n+        {\n+          *total = 0;\n+        }\n+      return true;\n+\n+    case CONST:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case CONST_DOUBLE:\n+      *total = COSTS_N_INSNS (2);\n+      return true;\n+\n+    case MEM:\n+      {\n+        /* If the address is legitimate, return the number of\n+           instructions it needs, otherwise use the default handling.  */\n+        int n = score_address_insns (XEXP (x, 0), GET_MODE (x));\n+        if (n > 0)\n+          {\n+            *total = COSTS_N_INSNS (n + 1);\n+            return true;\n+          }\n+        return false;\n+      }\n+\n+    case FFS:\n+      *total = COSTS_N_INSNS (6);\n+      return true;\n+\n+    case NOT:\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (2);\n+          return true;\n+        }\n+      return false;\n+\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n+                                  ? 4 : 12);\n+          return true;\n+        }\n+      return false;\n+\n+    case ABS:\n+      *total = COSTS_N_INSNS (4);\n+      return true;\n+\n+    case PLUS:\n+    case MINUS:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (4);\n+          return true;\n+        }\n+      *total = COSTS_N_INSNS (1);\n+      return true;\n+\n+    case NEG:\n+      if (mode == DImode)\n+        {\n+          *total = COSTS_N_INSNS (4);\n+          return true;\n+        }\n+      return false;\n+\n+    case MULT:\n+      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (12);\n+      return true;\n+\n+    case DIV:\n+    case MOD:\n+    case UDIV:\n+    case UMOD:\n+      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (33);\n+      return true;\n+\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+      switch (GET_MODE (XEXP (x, 0)))\n+        {\n+        case QImode:\n+        case HImode:\n+          if (GET_CODE (XEXP (x, 0)) == MEM)\n+            {\n+              *total = COSTS_N_INSNS (2);\n+\n+              if (!TARGET_LITTLE_ENDIAN &&\n+                  side_effects_p (XEXP (XEXP (x, 0), 0)))\n+                *total = 100;\n+            }\n+          else\n+            *total = COSTS_N_INSNS (1);\n+          break;\n+\n+        default:\n+          *total = COSTS_N_INSNS (1);\n+          break;\n+        }\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n }\n \n /* Implement TARGET_ADDRESS_COST macro.  */\n int\n score_address_cost (rtx addr,\n \t\t    bool speed ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_address_cost (addr);\n-  else\n-    gcc_unreachable ();\n+  return score_address_insns (addr, SImode);\n }\n \n /* Implement ASM_OUTPUT_EXTERNAL macro.  */\n int\n score_output_external (FILE *file ATTRIBUTE_UNUSED,\n                        tree decl, const char *name)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_output_external (file, decl, name);\n-  else\n-    gcc_unreachable ();\n+  register struct extern_list *p;\n+\n+  if (score_in_small_data_p (decl))\n+    {\n+      p = ggc_alloc_extern_list ();\n+      p->next = extern_head;\n+      p->name = name;\n+      p->size = int_size_in_bytes (TREE_TYPE (decl));\n+      extern_head = p;\n+    }\n+  return 0;\n }\n \n /* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n    back to a previous frame.  */\n rtx\n score_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_return_addr (count, frame);\n-  else\n-    gcc_unreachable ();\n+  if (count != 0)\n+    return const0_rtx;\n+  return get_hard_reg_initial_val (Pmode, RA_REGNUM);\n }\n \n /* Implement PRINT_OPERAND macro.  */\n+/* Score-specific operand codes:\n+   '['        print .set nor1 directive\n+   ']'        print .set r1 directive\n+   'U'        print hi part of a CONST_INT rtx\n+   'E'        print log2(v)\n+   'F'        print log2(~v)\n+   'D'        print SFmode const double\n+   'S'        selectively print \"!\" if operand is 15bit instruction accessible\n+   'V'        print \"v!\" if operand is 15bit instruction accessible, or \"lfh!\"\n+   'L'        low  part of DImode reg operand\n+   'H'        high part of DImode reg operand\n+   'C'        print part of opcode for a branch condition.  */\n void\n score_print_operand (FILE *file, rtx op, int c)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_print_operand (file, op, c);\n+  enum rtx_code code = UNKNOWN;\n+  if (!PRINT_OPERAND_PUNCT_VALID_P (c))\n+    code = GET_CODE (op);\n+\n+  if (c == '[')\n+    {\n+      fprintf (file, \".set r1\\n\");\n+    }\n+  else if (c == ']')\n+    {\n+      fprintf (file, \"\\n\\t.set nor1\");\n+    }\n+  else if (c == 'U')\n+    {\n+      gcc_assert (code == CONST_INT);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n+               (INTVAL (op) >> 16) & 0xffff);\n+    }\n+  else if (c == 'D')\n+    {\n+      if (GET_CODE (op) == CONST_DOUBLE)\n+        {\n+          rtx temp = gen_lowpart (SImode, op);\n+          gcc_assert (GET_MODE (op) == SFmode);\n+          fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (temp) & 0xffffffff);\n+        }\n+      else\n+        output_addr_const (file, op);\n+    }\n+  else if (c == 'S')\n+    {\n+      gcc_assert (code == REG);\n+      if (G16_REG_P (REGNO (op)))\n+        fprintf (file, \"!\");\n+    }\n+  else if (c == 'V')\n+    {\n+      gcc_assert (code == REG);\n+      fprintf (file, G16_REG_P (REGNO (op)) ? \"v!\" : \"lfh!\");\n+    }\n+  else if (c == 'C')\n+    {\n+      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n+\n+      switch (code)\n+        {\n+        case EQ: fputs (\"eq\", file); break;\n+        case NE: fputs (\"ne\", file); break;\n+        case GT: fputs (\"gt\", file); break;\n+        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n+        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n+        case LE: fputs (\"le\", file); break;\n+        case GTU: fputs (\"gtu\", file); break;\n+        case GEU: fputs (\"cs\", file); break;\n+        case LTU: fputs (\"cc\", file); break;\n+        case LEU: fputs (\"leu\", file); break;\n+        default:\n+          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n+        }\n+    }\n+  else if (c == 'E')\n+    {\n+      unsigned HOST_WIDE_INT i;\n+      unsigned HOST_WIDE_INT pow2mask = 1;\n+      unsigned HOST_WIDE_INT val;\n+\n+      val = INTVAL (op);\n+      for (i = 0; i < 32; i++)\n+        {\n+          if (val == pow2mask)\n+            break;\n+          pow2mask <<= 1;\n+        }\n+      gcc_assert (i < 32);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+    }\n+  else if (c == 'F')\n+    {\n+      unsigned HOST_WIDE_INT i;\n+      unsigned HOST_WIDE_INT pow2mask = 1;\n+      unsigned HOST_WIDE_INT val;\n+\n+      val = ~INTVAL (op);\n+      for (i = 0; i < 32; i++)\n+        {\n+          if (val == pow2mask)\n+            break;\n+          pow2mask <<= 1;\n+        }\n+      gcc_assert (i < 32);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n+    }\n+  else if (code == REG)\n+    {\n+      int regnum = REGNO (op);\n+      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n+          || (c == 'L' && WORDS_BIG_ENDIAN))\n+        regnum ++;\n+      fprintf (file, \"%s\", reg_names[regnum]);\n+    }\n   else\n-    gcc_unreachable ();\n+    {\n+      switch (code)\n+        {\n+        case MEM:\n+          score_print_operand_address (file, op);\n+          break;\n+        default:\n+          output_addr_const (file, op);\n+        }\n+    }\n }\n \n /* Implement PRINT_OPERAND_ADDRESS macro.  */\n void\n score_print_operand_address (FILE *file, rtx x)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_print_operand_address (file, x);\n-  else\n-    gcc_unreachable ();\n+  struct score_address_info addr;\n+  enum rtx_code code = GET_CODE (x);\n+  enum machine_mode mode = GET_MODE (x);\n+\n+  if (code == MEM)\n+    x = XEXP (x, 0);\n+\n+  if (score_classify_address (&addr, mode, x, true))\n+    {\n+      switch (addr.type)\n+        {\n+        case SCORE_ADD_REG:\n+          {\n+            switch (addr.code)\n+              {\n+              case PRE_DEC:\n+                fprintf (file, \"[%s,-%ld]+\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case POST_DEC:\n+                fprintf (file, \"[%s]+,-%ld\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case PRE_INC:\n+                fprintf (file, \"[%s, %ld]+\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              case POST_INC:\n+                fprintf (file, \"[%s]+, %ld\", reg_names[REGNO (addr.reg)],\n+                         INTVAL (addr.offset));\n+                break;\n+              default:\n+                if (INTVAL(addr.offset) == 0)\n+                  fprintf(file, \"[%s]\", reg_names[REGNO (addr.reg)]);\n+                else\n+                  fprintf(file, \"[%s, %ld]\", reg_names[REGNO (addr.reg)],\n+                          INTVAL(addr.offset));\n+                break;\n+              }\n+          }\n+          return;\n+        case SCORE_ADD_CONST_INT:\n+        case SCORE_ADD_SYMBOLIC:\n+          output_addr_const (file, x);\n+          return;\n+        }\n+    }\n+  print_rtl (stderr, x);\n+  gcc_unreachable ();\n }\n \n /* Implement SELECT_CC_MODE macro.  */\n enum machine_mode\n score_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_select_cc_mode (op, x, y);\n+  if ((op == EQ || op == NE || op == LT || op == GE)\n+      && y == const0_rtx\n+      && GET_MODE (x) == SImode)\n+    {\n+      switch (GET_CODE (x))\n+        {\n+        case PLUS:\n+        case MINUS:\n+        case NEG:\n+        case AND:\n+        case IOR:\n+        case XOR:\n+        case NOT:\n+        case ASHIFT:\n+        case LSHIFTRT:\n+        case ASHIFTRT:\n+          return CC_NZmode;\n+\n+        case SIGN_EXTEND:\n+        case ZERO_EXTEND:\n+        case ROTATE:\n+        case ROTATERT:\n+          return (op == LT || op == GE) ? CC_Nmode : CCmode;\n+\n+        default:\n+          return CCmode;\n+        }\n+    }\n+\n+  if ((op == EQ || op == NE)\n+      && (GET_CODE (y) == NEG)\n+      && register_operand (XEXP (y, 0), SImode)\n+      && register_operand (x, SImode))\n+    {\n+      return CC_NZmode;\n+    }\n+\n+  return CCmode;\n+}\n+\n+/* Generate the prologue instructions for entry into a S+core function.  */\n+void\n+score_prologue (void)\n+{\n+#define EMIT_PL(_rtx)        RTX_FRAME_RELATED_P (_rtx) = 1\n+\n+  struct score_frame_info *f = score_compute_frame_size (get_frame_size ());\n+  HOST_WIDE_INT size;\n+  int regno;\n+\n+  size = f->total_size - f->gp_reg_size;\n+\n+  if (flag_pic)\n+    emit_insn (gen_cpload_score7 ());\n+\n+  for (regno = (int) GP_REG_LAST; regno >= (int) GP_REG_FIRST; regno--)\n+    {\n+      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n+        {\n+          rtx mem = gen_rtx_MEM (SImode,\n+                                 gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n+          rtx reg = gen_rtx_REG (SImode, regno);\n+          if (!crtl->calls_eh_return)\n+            MEM_READONLY_P (mem) = 1;\n+          EMIT_PL (emit_insn (gen_pushsi_score7 (mem, reg)));\n+        }\n+    }\n+\n+  if (size > 0)\n+    {\n+      rtx insn;\n+\n+      if (size >= -32768 && size <= 32767)\n+        EMIT_PL (emit_insn (gen_add3_insn (stack_pointer_rtx,\n+                                           stack_pointer_rtx,\n+                                           GEN_INT (-size))));\n+      else\n+        {\n+          EMIT_PL (emit_move_insn (gen_rtx_REG (Pmode, SCORE_PROLOGUE_TEMP_REGNUM),\n+                                   GEN_INT (size)));\n+          EMIT_PL (emit_insn\n+                   (gen_sub3_insn (stack_pointer_rtx,\n+                                   stack_pointer_rtx,\n+                                   gen_rtx_REG (Pmode,\n+                                                SCORE_PROLOGUE_TEMP_REGNUM))));\n+        }\n+      insn = get_last_insn ();\n+      REG_NOTES (insn) =\n+        alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+                         gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+                                      plus_constant (stack_pointer_rtx,\n+                                                     -size)),\n+                                      REG_NOTES (insn));\n+    }\n+\n+  if (frame_pointer_needed)\n+    EMIT_PL (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n+\n+  if (flag_pic && f->cprestore_size)\n+    {\n+      if (frame_pointer_needed)\n+        emit_insn (gen_cprestore_use_fp_score7 (GEN_INT (size - f->cprestore_size)));\n+      else\n+        emit_insn (gen_cprestore_use_sp_score7 (GEN_INT (size - f->cprestore_size)));\n+    }\n+\n+#undef EMIT_PL\n+}\n+\n+/* Generate the epilogue instructions in a S+core function.  */\n+void\n+score_epilogue (int sibcall_p)\n+{\n+  struct score_frame_info *f = score_compute_frame_size (get_frame_size ());\n+  HOST_WIDE_INT size;\n+  int regno;\n+  rtx base;\n+\n+  size = f->total_size - f->gp_reg_size;\n+\n+  if (!frame_pointer_needed)\n+    base = stack_pointer_rtx;\n   else\n-    gcc_unreachable ();\n+    base = hard_frame_pointer_rtx;\n+\n+  if (size)\n+    {\n+      if (size >= -32768 && size <= 32767)\n+        emit_insn (gen_add3_insn (base, base, GEN_INT (size)));\n+      else\n+        {\n+          emit_move_insn (gen_rtx_REG (Pmode, SCORE_EPILOGUE_TEMP_REGNUM),\n+                          GEN_INT (size));\n+          emit_insn (gen_add3_insn (base, base,\n+                                    gen_rtx_REG (Pmode,\n+                                                 SCORE_EPILOGUE_TEMP_REGNUM)));\n+        }\n+    }\n+\n+  if (base != stack_pointer_rtx)\n+    emit_move_insn (stack_pointer_rtx, base);\n+\n+  if (crtl->calls_eh_return)\n+    emit_insn (gen_add3_insn (stack_pointer_rtx,\n+                              stack_pointer_rtx,\n+                              EH_RETURN_STACKADJ_RTX));\n+\n+  for (regno = (int) GP_REG_FIRST; regno <= (int) GP_REG_LAST; regno++)\n+    {\n+      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n+        {\n+          rtx mem = gen_rtx_MEM (SImode,\n+                                 gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n+          rtx reg = gen_rtx_REG (SImode, regno);\n+\n+          if (!crtl->calls_eh_return)\n+            MEM_READONLY_P (mem) = 1;\n+\n+          emit_insn (gen_popsi_score7 (reg, mem));\n+        }\n+    }\n+\n+  if (!sibcall_p)\n+    emit_jump_insn (gen_return_internal_score7 (gen_rtx_REG (Pmode, RA_REGNUM)));\n }\n \n /* Return true if X is a symbolic constant that can be calculated in\n@@ -542,140 +1622,354 @@ score_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n int\n score_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_symbolic_constant_p (x, symbol_type);\n-  else\n-    gcc_unreachable ();\n-}\n+  HOST_WIDE_INT offset;\n \n-/* Generate the prologue instructions for entry into a S+core function.  */\n-void\n-score_prologue (void)\n-{\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_prologue ();\n+  score_split_const (x, &x, &offset);\n+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n+    *symbol_type = score_classify_symbol (x);\n   else\n-    gcc_unreachable ();\n+    return 0;\n+\n+  if (offset == 0)\n+    return 1;\n+\n+  /* if offset > 15bit, must reload  */\n+  if (!IMM_IN_RANGE (offset, 15, 1))\n+    return 0;\n+\n+  switch (*symbol_type)\n+    {\n+    case SYMBOL_GENERAL:\n+      return 1;\n+    case SYMBOL_SMALL_DATA:\n+      return score_offset_within_object_p (x, offset);\n+    }\n+  gcc_unreachable ();\n }\n \n-/* Generate the epilogue instructions in a S+core function.  */\n void\n-score_epilogue (int sibcall_p)\n+score_movsicc (rtx *ops)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_epilogue (sibcall_p);\n-  else\n-    gcc_unreachable ();\n+  enum machine_mode mode;\n+\n+  mode = score_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n+                          gen_rtx_COMPARE (mode, XEXP (ops[1], 0),\n+\t\t\t\t\t   XEXP (ops[1], 1))));\n }\n \n /* Call and sibcall pattern all need call this function.  */\n void\n score_call (rtx *ops, bool sib)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_call (ops, sib);\n+  rtx addr = XEXP (ops[0], 0);\n+  if (!call_insn_operand (addr, VOIDmode))\n+    {\n+      rtx oaddr = addr;\n+      addr = gen_reg_rtx (Pmode);\n+      gen_move_insn (addr, oaddr);\n+    }\n+\n+  if (sib)\n+    emit_call_insn (gen_sibcall_internal_score7 (addr, ops[1]));\n   else\n-    gcc_unreachable ();\n+    emit_call_insn (gen_call_internal_score7 (addr, ops[1]));\n }\n \n /* Call value and sibcall value pattern all need call this function.  */\n void\n score_call_value (rtx *ops, bool sib)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_call_value (ops, sib);\n-  else\n-    gcc_unreachable ();\n-}\n-\n-void\n-score_movsicc (rtx *ops)\n-{\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_movsicc (ops);\n+  rtx result = ops[0];\n+  rtx addr = XEXP (ops[1], 0);\n+  rtx arg = ops[2];\n+\n+  if (!call_insn_operand (addr, VOIDmode))\n+    {\n+      rtx oaddr = addr;\n+      addr = gen_reg_rtx (Pmode);\n+      gen_move_insn (addr, oaddr);\n+    }\n+\n+  if (sib)\n+    emit_call_insn (gen_sibcall_value_internal_score7 (result, addr, arg));\n   else\n-    gcc_unreachable ();\n+    emit_call_insn (gen_call_value_internal_score7 (result, addr, arg));\n }\n \n /* Machine Split  */\n void\n score_movdi (rtx *ops)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_movdi (ops);\n+  rtx dst = ops[0];\n+  rtx src = ops[1];\n+  rtx dst0 = score_subw (dst, 0);\n+  rtx dst1 = score_subw (dst, 1);\n+  rtx src0 = score_subw (src, 0);\n+  rtx src1 = score_subw (src, 1);\n+\n+  if (GET_CODE (dst0) == REG && reg_overlap_mentioned_p (dst0, src))\n+    {\n+      emit_move_insn (dst1, src1);\n+      emit_move_insn (dst0, src0);\n+    }\n   else\n-    gcc_unreachable ();\n+    {\n+      emit_move_insn (dst0, src0);\n+      emit_move_insn (dst1, src1);\n+    }\n }\n \n void\n score_zero_extract_andi (rtx *ops)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    score7_zero_extract_andi (ops);\n+  if (INTVAL (ops[1]) == 1 && const_uimm5 (ops[2], SImode))\n+    emit_insn (gen_zero_extract_bittst_score7 (ops[0], ops[2]));\n   else\n-    gcc_unreachable ();\n+    {\n+      unsigned HOST_WIDE_INT mask;\n+      mask = (0xffffffffU & ((1U << INTVAL (ops[1])) - 1U));\n+      mask = mask << INTVAL (ops[2]);\n+      emit_insn (gen_andsi3_cmp_score7 (ops[3], ops[0],\n+                                 gen_int_mode (mask, SImode)));\n+    }\n }\n \n-/* Output asm insn for move.  */\n-const char *\n-score_move (rtx *ops)\n+/* Check addr could be present as PRE/POST mode.  */\n+static bool\n+score_pindex_mem (rtx addr)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_move (ops);\n-  else\n-    gcc_unreachable ();\n+  if (GET_CODE (addr) == MEM)\n+    {\n+      switch (GET_CODE (XEXP (addr, 0)))\n+        {\n+        case PRE_DEC:\n+        case POST_DEC:\n+        case PRE_INC:\n+        case POST_INC:\n+          return true;\n+        default:\n+          break;\n+        }\n+    }\n+  return false;\n+}\n+\n+/* Output asm code for ld/sw insn.  */\n+static int\n+score_pr_addr_post (rtx *ops, int idata, int iaddr, char *ip, enum score_mem_unit unit)\n+{\n+  struct score_address_info ai;\n+\n+  gcc_assert (GET_CODE (ops[idata]) == REG);\n+  gcc_assert (score_classify_address (&ai, SImode, XEXP (ops[iaddr], 0), true));\n+\n+  if (!score_pindex_mem (ops[iaddr])\n+      && ai.type == SCORE_ADD_REG\n+      && GET_CODE (ai.offset) == CONST_INT\n+      && G16_REG_P (REGNO (ops[idata]))\n+      && G16_REG_P (REGNO (ai.reg)))\n+    {\n+      if (INTVAL (ai.offset) == 0)\n+        {\n+          ops[iaddr] = ai.reg;\n+          return snprintf (ip, INS_BUF_SZ,\n+                           \"!\\t%%%d, [%%%d]\", idata, iaddr);\n+        }\n+      if (REGNO (ai.reg) == HARD_FRAME_POINTER_REGNUM)\n+        {\n+          HOST_WIDE_INT offset = INTVAL (ai.offset);\n+          if (SCORE_ALIGN_UNIT (offset, unit)\n+              && (((offset >> unit) >= 0) && ((offset >> unit) <= 31)))\n+            {\n+              ops[iaddr] = ai.offset;\n+              return snprintf (ip, INS_BUF_SZ,\n+                               \"p!\\t%%%d, %%c%d\", idata, iaddr);\n+            }\n+        }\n+    }\n+  return snprintf (ip, INS_BUF_SZ, \"\\t%%%d, %%a%d\", idata, iaddr);\n }\n \n /* Output asm insn for load.  */\n const char *\n score_linsn (rtx *ops, enum score_mem_unit unit, bool sign)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_linsn (ops, unit, sign);\n+  const char *pre_ins[] =\n+    {\"lbu\", \"lhu\", \"lw\", \"??\", \"lb\", \"lh\", \"lw\", \"??\"};\n+  char *ip;\n+\n+  strcpy (score_ins, pre_ins[(sign ? 4 : 0) + unit]);\n+  ip = score_ins + strlen (score_ins);\n+\n+  if ((!sign && unit != SCORE_HWORD)\n+      || (sign && unit != SCORE_BYTE))\n+    score_pr_addr_post (ops, 0, 1, ip, unit);\n   else\n-    gcc_unreachable ();\n+    snprintf (ip, INS_BUF_SZ, \"\\t%%0, %%a1\");\n+\n+  return score_ins;\n }\n \n /* Output asm insn for store.  */\n const char *\n score_sinsn (rtx *ops, enum score_mem_unit unit)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_sinsn (ops, unit);\n-  else\n-    gcc_unreachable ();\n+  const char *pre_ins[] = {\"sb\", \"sh\", \"sw\"};\n+  char *ip;\n+\n+  strcpy (score_ins, pre_ins[unit]);\n+  ip = score_ins + strlen (score_ins);\n+  score_pr_addr_post (ops, 1, 0, ip, unit);\n+  return score_ins;\n }\n \n /* Output asm insn for load immediate.  */\n const char *\n score_limm (rtx *ops)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_limm (ops);\n+  HOST_WIDE_INT v;\n+\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == CONST_INT);\n+\n+  v = INTVAL (ops[1]);\n+  if (G16_REG_P (REGNO (ops[0])) && IMM_IN_RANGE (v, 8, 0))\n+    return \"ldiu!\\t%0, %c1\";\n+  else if (IMM_IN_RANGE (v, 16, 1))\n+    return \"ldi\\t%0, %c1\";\n+  else if ((v & 0xffff) == 0)\n+    return \"ldis\\t%0, %U1\";\n   else\n-    gcc_unreachable ();\n+    return \"li\\t%0, %c1\";\n }\n \n+/* Output asm insn for move.  */\n+const char *\n+score_move (rtx *ops)\n+{\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == REG);\n+\n+  if (G16_REG_P (REGNO (ops[0])))\n+    {\n+      if (G16_REG_P (REGNO (ops[1])))\n+        return \"mv!\\t%0, %1\";\n+      else\n+        return \"mlfh!\\t%0, %1\";\n+    }\n+  else if (G16_REG_P (REGNO (ops[1])))\n+    return \"mhfl!\\t%0, %1\";\n+  else\n+    return \"mv\\t%0, %1\";\n+}\n \n /* Generate add insn.  */\n const char *\n score_select_add_imm (rtx *ops, bool set_cc)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_select_add_imm (ops, set_cc);\n+  HOST_WIDE_INT v = INTVAL (ops[2]);\n+\n+  gcc_assert (GET_CODE (ops[2]) == CONST_INT);\n+  gcc_assert (REGNO (ops[0]) == REGNO (ops[1]));\n+\n+  if (set_cc && G16_REG_P (REGNO (ops[0])))\n+    {\n+      if (v > 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) v, 0, 15))\n+        {\n+          ops[2] = GEN_INT (ffs (v) - 1);\n+          return \"addei!\\t%0, %c2\";\n+        }\n+\n+      if (v < 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) (-v), 0, 15))\n+        {\n+          ops[2] = GEN_INT (ffs (-v) - 1);\n+          return \"subei!\\t%0, %c2\";\n+        }\n+    }\n+\n+  if (set_cc)\n+    return \"addi.c\\t%0, %c2\";\n   else\n-    gcc_unreachable ();\n+    return \"addi\\t%0, %c2\";\n }\n \n /* Output arith insn.  */\n const char *\n score_select (rtx *ops, const char *inst_pre,\n-            bool commu, const char *letter, bool set_cc)\n+              bool commu, const char *letter, bool set_cc)\n {\n-  if (TARGET_SCORE7 || TARGET_SCORE7D)\n-    return score7_select (ops, inst_pre, commu, letter, set_cc);\n+  gcc_assert (GET_CODE (ops[0]) == REG);\n+  gcc_assert (GET_CODE (ops[1]) == REG);\n+\n+  if (set_cc && G16_REG_P (REGNO (ops[0]))\n+      && (GET_CODE (ops[2]) == REG ? G16_REG_P (REGNO (ops[2])) : 1)\n+      && REGNO (ops[0]) == REGNO (ops[1]))\n+    {\n+      snprintf (score_ins, INS_BUF_SZ, \"%s!\\t%%0, %%%s2\", inst_pre, letter);\n+      return score_ins;\n+    }\n+\n+  if (commu && set_cc && G16_REG_P (REGNO (ops[0]))\n+      && G16_REG_P (REGNO (ops[1]))\n+      && REGNO (ops[0]) == REGNO (ops[2]))\n+    {\n+      gcc_assert (GET_CODE (ops[2]) == REG);\n+      snprintf (score_ins, INS_BUF_SZ, \"%s!\\t%%0, %%%s1\", inst_pre, letter);\n+      return score_ins;\n+    }\n+\n+  if (set_cc)\n+    snprintf (score_ins, INS_BUF_SZ, \"%s.c\\t%%0, %%1, %%%s2\", inst_pre, letter);\n   else\n-    gcc_unreachable ();\n+    snprintf (score_ins, INS_BUF_SZ, \"%s\\t%%0, %%1, %%%s2\", inst_pre, letter);\n+  return score_ins;\n+}\n+\n+/* Return nonzero when an argument must be passed by reference.  */\n+static bool\n+score_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,\n+                         enum machine_mode mode, const_tree type,\n+                         bool named ATTRIBUTE_UNUSED)\n+{\n+  /* If we have a variable-sized parameter, we have no choice.  */\n+  return targetm.calls.must_pass_in_stack (mode, type);\n+}\n+\n+/* Implement TARGET_FUNCTION_OK_FOR_SIBCALL.  */\n+static bool\n+score_function_ok_for_sibcall (ATTRIBUTE_UNUSED tree decl,\n+                               ATTRIBUTE_UNUSED tree exp)\n+{\n+  return true;\n+}\n+\n+/* Implement TARGET_SCHED_ISSUE_RATE.  */\n+static int\n+score_issue_rate (void)\n+{\n+  return 1;\n+}\n+\n+/* We can always eliminate to the hard frame pointer.  We can eliminate\n+   to the stack pointer unless a frame pointer is needed.  */\n+\n+static bool\n+score_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n+{\n+  return (to == HARD_FRAME_POINTER_REGNUM\n+          || (to  == STACK_POINTER_REGNUM && !frame_pointer_needed));\n+}\n+\n+/* Argument support functions.  */\n+\n+/* Initialize CUMULATIVE_ARGS for a function.  */\n+void\n+score_init_cumulative_args (CUMULATIVE_ARGS *cum,\n+                            tree fntype ATTRIBUTE_UNUSED,\n+                            rtx libname ATTRIBUTE_UNUSED)\n+{\n+  memset (cum, 0, sizeof (CUMULATIVE_ARGS));\n }\n \n static void"}, {"sha": "8a57362bab84a9d42ba18f6b099cba2aebfedc89", "filename": "gcc/config/score/score7.c", "status": "removed", "additions": 0, "deletions": 1797, "changes": 1797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab70d825c6eda82882708757b89f80b8f2f1d2f6/gcc%2Fconfig%2Fscore%2Fscore7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab70d825c6eda82882708757b89f80b8f2f1d2f6/gcc%2Fconfig%2Fscore%2Fscore7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.c?ref=ab70d825c6eda82882708757b89f80b8f2f1d2f6", "patch": "@@ -1,1797 +0,0 @@\n-/* score7.c for Sunplus S+CORE processor\n-   Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Sunnorth\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-attr.h\"\n-#include \"recog.h\"\n-#include \"diagnostic-core.h\"\n-#include \"output.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"optabs.h\"\n-#include \"flags.h\"\n-#include \"reload.h\"\n-#include \"tm_p.h\"\n-#include \"ggc.h\"\n-#include \"gstab.h\"\n-#include \"hashtab.h\"\n-#include \"debug.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-#include \"integrate.h\"\n-#include \"langhooks.h\"\n-#include \"cfglayout.h\"\n-#include \"score7.h\"\n-#include \"df.h\"\n-\n-#define BITSET_P(VALUE, BIT)      (((VALUE) & (1L << (BIT))) != 0)\n-#define INS_BUF_SZ                128\n-\n-extern enum reg_class score_char_to_class[256];\n-\n-static int score7_sdata_max;\n-static char score7_ins[INS_BUF_SZ + 8];\n-\n-/* Return true if SYMBOL is a SYMBOL_REF and OFFSET + SYMBOL points\n-   to the same object as SYMBOL.  */\n-static int\n-score7_offset_within_object_p (rtx symbol, HOST_WIDE_INT offset)\n-{\n-  if (GET_CODE (symbol) != SYMBOL_REF)\n-    return 0;\n-\n-  if (CONSTANT_POOL_ADDRESS_P (symbol)\n-      && offset >= 0\n-      && offset < (int)GET_MODE_SIZE (get_pool_mode (symbol)))\n-    return 1;\n-\n-  if (SYMBOL_REF_DECL (symbol) != 0\n-      && offset >= 0\n-      && offset < int_size_in_bytes (TREE_TYPE (SYMBOL_REF_DECL (symbol))))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Split X into a base and a constant offset, storing them in *BASE\n-   and *OFFSET respectively.  */\n-static void\n-score7_split_const (rtx x, rtx *base, HOST_WIDE_INT *offset)\n-{\n-  *offset = 0;\n-\n-  if (GET_CODE (x) == CONST)\n-    x = XEXP (x, 0);\n-\n-  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    {\n-      *offset += INTVAL (XEXP (x, 1));\n-      x = XEXP (x, 0);\n-    }\n-\n-  *base = x;\n-}\n-\n-/* Classify symbol X, which must be a SYMBOL_REF or a LABEL_REF.  */\n-static enum score_symbol_type\n-score7_classify_symbol (rtx x)\n-{\n-  if (GET_CODE (x) == LABEL_REF)\n-    return SYMBOL_GENERAL;\n-\n-  gcc_assert (GET_CODE (x) == SYMBOL_REF);\n-\n-  if (CONSTANT_POOL_ADDRESS_P (x))\n-    {\n-      if (GET_MODE_SIZE (get_pool_mode (x)) <= SCORE7_SDATA_MAX)\n-        return SYMBOL_SMALL_DATA;\n-      return SYMBOL_GENERAL;\n-    }\n-  if (SYMBOL_REF_SMALL_P (x))\n-    return SYMBOL_SMALL_DATA;\n-  return SYMBOL_GENERAL;\n-}\n-\n-/* Return true if the current function must save REGNO.  */\n-static int\n-score7_save_reg_p (unsigned int regno)\n-{\n-  /* Check call-saved registers.  */\n-  if (df_regs_ever_live_p (regno) && !call_used_regs[regno])\n-    return 1;\n-\n-  /* We need to save the old frame pointer before setting up a new one.  */\n-  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n-    return 1;\n-\n-  /* We need to save the incoming return address if it is ever clobbered\n-     within the function.  */\n-  if (regno == RA_REGNUM && df_regs_ever_live_p (regno))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return one word of double-word value OP, taking into account the fixed\n-   endianness of certain registers.  HIGH_P is true to select the high part,\n-   false to select the low part.  */\n-static rtx\n-score7_subw (rtx op, int high_p)\n-{\n-  unsigned int byte;\n-  enum machine_mode mode = GET_MODE (op);\n-\n-  if (mode == VOIDmode)\n-    mode = DImode;\n-\n-  byte = (TARGET_LITTLE_ENDIAN ? high_p : !high_p) ? UNITS_PER_WORD : 0;\n-\n-  if (GET_CODE (op) == REG && REGNO (op) == HI_REGNUM)\n-    return gen_rtx_REG (SImode, high_p ? HI_REGNUM : LO_REGNUM);\n-\n-  if (GET_CODE (op) == MEM)\n-    return adjust_address (op, SImode, byte);\n-\n-  return simplify_gen_subreg (SImode, op, mode, byte);\n-}\n-\n-static struct score7_frame_info *\n-score7_cached_frame (void)\n-{\n-  static struct score7_frame_info _frame_info;\n-  return &_frame_info;\n-}\n-\n-/* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer.  SIZE is the size (in bytes) of the local variables.  */\n-static struct score7_frame_info *\n-score7_compute_frame_size (HOST_WIDE_INT size)\n-{\n-  unsigned int regno;\n-  struct score7_frame_info *f = score7_cached_frame ();\n-\n-  memset (f, 0, sizeof (struct score7_frame_info));\n-  f->gp_reg_size = 0;\n-  f->mask = 0;\n-  f->var_size = SCORE7_STACK_ALIGN (size);\n-  f->args_size = crtl->outgoing_args_size;\n-  f->cprestore_size = flag_pic ? UNITS_PER_WORD : 0;\n-  if (f->var_size == 0 && current_function_is_leaf)\n-    f->args_size = f->cprestore_size = 0;\n-\n-  if (f->args_size == 0 && cfun->calls_alloca)\n-    f->args_size = UNITS_PER_WORD;\n-\n-  f->total_size = f->var_size + f->args_size + f->cprestore_size;\n-  for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n-    {\n-      if (score7_save_reg_p (regno))\n-        {\n-          f->gp_reg_size += GET_MODE_SIZE (SImode);\n-          f->mask |= 1 << (regno - GP_REG_FIRST);\n-        }\n-    }\n-\n-  if (crtl->calls_eh_return)\n-    {\n-      unsigned int i;\n-      for (i = 0;; ++i)\n-        {\n-          regno = EH_RETURN_DATA_REGNO (i);\n-          if (regno == INVALID_REGNUM)\n-            break;\n-          f->gp_reg_size += GET_MODE_SIZE (SImode);\n-          f->mask |= 1 << (regno - GP_REG_FIRST);\n-        }\n-    }\n-\n-  f->total_size += f->gp_reg_size;\n-  f->num_gp = f->gp_reg_size / UNITS_PER_WORD;\n-\n-  if (f->mask)\n-    {\n-      HOST_WIDE_INT offset;\n-      offset = (f->args_size + f->cprestore_size + f->var_size\n-                + f->gp_reg_size - GET_MODE_SIZE (SImode));\n-      f->gp_sp_offset = offset;\n-    }\n-  else\n-    f->gp_sp_offset = 0;\n-\n-  return f;\n-}\n-\n-/* Return true if X is a valid base register for the given mode.\n-   Allow only hard registers if STRICT.  */\n-static int\n-score7_valid_base_register_p (rtx x, int strict)\n-{\n-  if (!strict && GET_CODE (x) == SUBREG)\n-    x = SUBREG_REG (x);\n-\n-  return (GET_CODE (x) == REG\n-          && score7_regno_mode_ok_for_base_p (REGNO (x), strict));\n-}\n-\n-/* Return true if X is a valid address for machine mode MODE.  If it is,\n-   fill in INFO appropriately.  STRICT is true if we should only accept\n-   hard base registers.  */\n-static int\n-score7_classify_address (struct score7_address_info *info,\n-                         enum machine_mode mode, rtx x, int strict)\n-{\n-  info->code = GET_CODE (x);\n-\n-  switch (info->code)\n-    {\n-    case REG:\n-    case SUBREG:\n-      info->type = SCORE7_ADD_REG;\n-      info->reg = x;\n-      info->offset = const0_rtx;\n-      return score7_valid_base_register_p (info->reg, strict);\n-    case PLUS:\n-      info->type = SCORE7_ADD_REG;\n-      info->reg = XEXP (x, 0);\n-      info->offset = XEXP (x, 1);\n-      return (score7_valid_base_register_p (info->reg, strict)\n-              && GET_CODE (info->offset) == CONST_INT\n-              && IMM_IN_RANGE (INTVAL (info->offset), 15, 1));\n-    case PRE_DEC:\n-    case POST_DEC:\n-    case PRE_INC:\n-    case POST_INC:\n-      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (SImode))\n-        return false;\n-      info->type = SCORE7_ADD_REG;\n-      info->reg = XEXP (x, 0);\n-      info->offset = GEN_INT (GET_MODE_SIZE (mode));\n-      return score7_valid_base_register_p (info->reg, strict);\n-    case CONST_INT:\n-      info->type = SCORE7_ADD_CONST_INT;\n-      return IMM_IN_RANGE (INTVAL (x), 15, 1);\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      info->type = SCORE7_ADD_SYMBOLIC;\n-      return (score7_symbolic_constant_p (x, &info->symbol_type)\n-              && (info->symbol_type == SYMBOL_GENERAL\n-                  || info->symbol_type == SYMBOL_SMALL_DATA));\n-    default:\n-      return 0;\n-    }\n-}\n-\n-bool\n-score7_return_in_memory (const_tree type, const_tree fndecl ATTRIBUTE_UNUSED)\n-{\n-    return ((TYPE_MODE (type) == BLKmode)\n-            || (int_size_in_bytes (type) > 2 * UNITS_PER_WORD)\n-            || (int_size_in_bytes (type) == -1));\n-}\n-\n-/* Return a legitimate address for REG + OFFSET.  */\n-static rtx\n-score7_add_offset (rtx reg, HOST_WIDE_INT offset)\n-{\n-  if (!IMM_IN_RANGE (offset, 15, 1))\n-    {\n-      reg = expand_simple_binop (GET_MODE (reg), PLUS,\n-                                 gen_int_mode (offset & 0xffffc000,\n-                                               GET_MODE (reg)),\n-                                 reg, NULL, 0, OPTAB_WIDEN);\n-      offset &= 0x3fff;\n-    }\n-\n-  return plus_constant (reg, offset);\n-}\n-\n-/* Implement TARGET_ASM_OUTPUT_MI_THUNK.  Generate rtl rather than asm text\n-   in order to avoid duplicating too much logic from elsewhere.  */\n-void\n-score7_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n-                        HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n-                        tree function)\n-{\n-  rtx this_rtx, temp1, insn, fnaddr;\n-\n-  /* Pretend to be a post-reload pass while generating rtl.  */\n-  reload_completed = 1;\n-\n-  /* Mark the end of the (empty) prologue.  */\n-  emit_note (NOTE_INSN_PROLOGUE_END);\n-\n-  /* We need two temporary registers in some cases.  */\n-  temp1 = gen_rtx_REG (Pmode, 8);\n-\n-  /* Find out which register contains the \"this\" pointer.  */\n-  if (aggregate_value_p (TREE_TYPE (TREE_TYPE (function)), function))\n-    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST + 1);\n-  else\n-    this_rtx = gen_rtx_REG (Pmode, ARG_REG_FIRST);\n-\n-  /* Add DELTA to THIS_RTX.  */\n-  if (delta != 0)\n-    {\n-      rtx offset = GEN_INT (delta);\n-      if (!(delta >= -32768 && delta <= 32767))\n-        {\n-          emit_move_insn (temp1, offset);\n-          offset = temp1;\n-        }\n-      emit_insn (gen_add3_insn (this_rtx, this_rtx, offset));\n-    }\n-\n-  /* If needed, add *(*THIS_RTX + VCALL_OFFSET) to THIS_RTX.  */\n-  if (vcall_offset != 0)\n-    {\n-      rtx addr;\n-\n-      /* Set TEMP1 to *THIS_RTX.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, this_rtx));\n-\n-      /* Set ADDR to a legitimate address for *THIS_RTX + VCALL_OFFSET.  */\n-      addr = score7_add_offset (temp1, vcall_offset);\n-\n-      /* Load the offset and add it to THIS_RTX.  */\n-      emit_move_insn (temp1, gen_rtx_MEM (Pmode, addr));\n-      emit_insn (gen_add3_insn (this_rtx, this_rtx, temp1));\n-    }\n-\n-  /* Jump to the target function.  */\n-  fnaddr = XEXP (DECL_RTL (function), 0);\n-  insn = emit_call_insn (gen_sibcall_internal_score7 (fnaddr, const0_rtx));\n-  SIBLING_CALL_P (insn) = 1;\n-\n-  /* Run just enough of rest_of_compilation.  This sequence was\n-     \"borrowed\" from alpha.c.  */\n-  insn = get_insns ();\n-  insn_locators_alloc ();\n-  split_all_insns_noflow ();\n-  shorten_branches (insn);\n-  final_start_function (insn, file, 1);\n-  final (insn, file, 1);\n-  final_end_function ();\n-\n-  /* Clean up the vars set above.  Note that final_end_function resets\n-     the global pointer for us.  */\n-  reload_completed = 0;\n-}\n-\n-/* Copy VALUE to a register and return that register.  If new psuedos\n-   are allowed, copy it into a new register, otherwise use DEST.  */\n-static rtx\n-score7_force_temporary (rtx dest, rtx value)\n-{\n-  if (can_create_pseudo_p ())\n-    return force_reg (Pmode, value);\n-  else\n-    {\n-      emit_move_insn (copy_rtx (dest), value);\n-      return dest;\n-    }\n-}\n-\n-/* Return a LO_SUM expression for ADDR.  TEMP is as for score_force_temporary\n-   and is used to load the high part into a register.  */\n-static rtx\n-score7_split_symbol (rtx temp, rtx addr)\n-{\n-  rtx high = score7_force_temporary (temp,\n-                                     gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n-  return gen_rtx_LO_SUM (Pmode, high, addr);\n-}\n-\n-/* This function is used to implement LEGITIMIZE_ADDRESS.  If X can\n-   be legitimized in a way that the generic machinery might not expect,\n-   return the new address.  */\n-rtx\n-score7_legitimize_address (rtx x)\n-{\n-  enum score_symbol_type symbol_type;\n-\n-  if (score7_symbolic_constant_p (x, &symbol_type)\n-      && symbol_type == SYMBOL_GENERAL)\n-    return score7_split_symbol (0, x);\n-\n-  if (GET_CODE (x) == PLUS\n-      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    {\n-      rtx reg = XEXP (x, 0);\n-      if (!score7_valid_base_register_p (reg, 0))\n-        reg = copy_to_mode_reg (Pmode, reg);\n-      return score7_add_offset (reg, INTVAL (XEXP (x, 1)));\n-    }\n-\n-  return x;\n-}\n-\n-/* Fill INFO with information about a single argument.  CUM is the\n-   cumulative state for earlier arguments.  MODE is the mode of this\n-   argument and TYPE is its type (if known).  NAMED is true if this\n-   is a named (fixed) argument rather than a variable one.  */\n-static void\n-score7_classify_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-                     const_tree type, bool named, struct score7_arg_info *info)\n-{\n-  int even_reg_p;\n-  unsigned int num_words, max_regs;\n-\n-  even_reg_p = 0;\n-  if (GET_MODE_CLASS (mode) == MODE_INT\n-      || GET_MODE_CLASS (mode) == MODE_FLOAT)\n-    even_reg_p = (GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n-  else\n-    if (type != NULL_TREE && TYPE_ALIGN (type) > BITS_PER_WORD && named)\n-      even_reg_p = 1;\n-\n-  if (TARGET_MUST_PASS_IN_STACK (mode, type))\n-    info->reg_offset = ARG_REG_NUM;\n-  else\n-    {\n-      info->reg_offset = cum->num_gprs;\n-      if (even_reg_p)\n-        info->reg_offset += info->reg_offset & 1;\n-    }\n-\n-  if (mode == BLKmode)\n-    info->num_bytes = int_size_in_bytes (type);\n-  else\n-    info->num_bytes = GET_MODE_SIZE (mode);\n-\n-  num_words = (info->num_bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-  max_regs = ARG_REG_NUM - info->reg_offset;\n-\n-  /* Partition the argument between registers and stack.  */\n-  info->reg_words = MIN (num_words, max_regs);\n-  info->stack_words = num_words - info->reg_words;\n-\n-  /* The alignment applied to registers is also applied to stack arguments.  */\n-  if (info->stack_words)\n-    {\n-      info->stack_offset = cum->stack_words;\n-      if (even_reg_p)\n-        info->stack_offset += info->stack_offset & 1;\n-    }\n-}\n-\n-/* Set up the stack and frame (if desired) for the function.  */\n-void\n-score7_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n-{\n-  const char *fnname;\n-  struct score7_frame_info *f = score7_cached_frame ();\n-  HOST_WIDE_INT tsize = f->total_size;\n-\n-  fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-  if (!flag_inhibit_size_directive)\n-    {\n-      fputs (\"\\t.ent\\t\", file);\n-      assemble_name (file, fnname);\n-      fputs (\"\\n\", file);\n-    }\n-  assemble_name (file, fnname);\n-  fputs (\":\\n\", file);\n-\n-  if (!flag_inhibit_size_directive)\n-    {\n-      fprintf (file,\n-               \"\\t.frame\\t%s,\" HOST_WIDE_INT_PRINT_DEC \",%s, %d\\t\\t\"\n-               \"# vars= \" HOST_WIDE_INT_PRINT_DEC \", regs= %d\"\n-               \", args= \" HOST_WIDE_INT_PRINT_DEC\n-               \", gp= \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-               (reg_names[(frame_pointer_needed)\n-                ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n-               tsize,\n-               reg_names[RA_REGNUM],\n-               current_function_is_leaf ? 1 : 0,\n-               f->var_size,\n-               f->num_gp,\n-               f->args_size,\n-               f->cprestore_size);\n-\n-      fprintf(file, \"\\t.mask\\t0x%08x,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-              f->mask,\n-              (f->gp_sp_offset - f->total_size));\n-    }\n-}\n-\n-/* Do any necessary cleanup after a function to restore stack, frame,\n-   and regs.  */\n-void\n-score7_function_epilogue (FILE *file,\n-                          HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n-{\n-  if (!flag_inhibit_size_directive)\n-    {\n-      const char *fnname;\n-      fnname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n-      fputs (\"\\t.end\\t\", file);\n-      assemble_name (file, fnname);\n-      fputs (\"\\n\", file);\n-    }\n-}\n-\n-/* Returns true if X contains a SYMBOL_REF.  */\n-static bool\n-score7_symbolic_expression_p (rtx x)\n-{\n-  if (GET_CODE (x) == SYMBOL_REF)\n-    return true;\n-\n-  if (GET_CODE (x) == CONST)\n-    return score7_symbolic_expression_p (XEXP (x, 0));\n-\n-  if (UNARY_P (x))\n-    return score7_symbolic_expression_p (XEXP (x, 0));\n-\n-  if (ARITHMETIC_P (x))\n-    return (score7_symbolic_expression_p (XEXP (x, 0))\n-            || score7_symbolic_expression_p (XEXP (x, 1)));\n-\n-  return false;\n-}\n-\n-/* Choose the section to use for the constant rtx expression X that has\n-   mode MODE.  */\n-section *\n-score7_select_rtx_section (enum machine_mode mode, rtx x,\n-                           unsigned HOST_WIDE_INT align)\n-{\n-  if (GET_MODE_SIZE (mode) <= SCORE7_SDATA_MAX)\n-    return get_named_section (0, \".sdata\", 0);\n-  else if (flag_pic && score7_symbolic_expression_p (x))\n-    return get_named_section (0, \".data.rel.ro\", 3);\n-  else\n-    return mergeable_constant_section (mode, align, 0);\n-}\n-\n-/* Implement TARGET_IN_SMALL_DATA_P.  */\n-bool\n-score7_in_small_data_p (const_tree decl)\n-{\n-  HOST_WIDE_INT size;\n-\n-  if (TREE_CODE (decl) == STRING_CST\n-      || TREE_CODE (decl) == FUNCTION_DECL)\n-    return false;\n-\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_SECTION_NAME (decl) != 0)\n-    {\n-      const char *name;\n-      name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));\n-      if (strcmp (name, \".sdata\") != 0\n-          && strcmp (name, \".sbss\") != 0)\n-        return true;\n-      if (!DECL_EXTERNAL (decl))\n-        return false;\n-    }\n-  size = int_size_in_bytes (TREE_TYPE (decl));\n-  return (size > 0 && size <= SCORE7_SDATA_MAX);\n-}\n-\n-/* Implement TARGET_ASM_FILE_START.  */\n-void\n-score7_asm_file_start (void)\n-{\n-  default_file_start ();\n-  fprintf (asm_out_file, ASM_COMMENT_START\n-           \"GCC for S+core %s \\n\", SCORE_GCC_VERSION);\n-\n-  if (flag_pic)\n-    fprintf (asm_out_file, \"\\t.set pic\\n\");\n-}\n-\n-/* Implement TARGET_ASM_FILE_END.  When using assembler macros, emit\n-   .externs for any small-data variables that turned out to be external.  */\n-void\n-score7_asm_file_end (void)\n-{\n-  tree name_tree;\n-  struct extern_list *p;\n-  if (extern_head)\n-    {\n-      fputs (\"\\n\", asm_out_file);\n-      for (p = extern_head; p != 0; p = p->next)\n-        {\n-          name_tree = get_identifier (p->name);\n-          if (!TREE_ASM_WRITTEN (name_tree)\n-              && TREE_SYMBOL_REFERENCED (name_tree))\n-            {\n-              TREE_ASM_WRITTEN (name_tree) = 1;\n-              fputs (\"\\t.extern\\t\", asm_out_file);\n-              assemble_name (asm_out_file, p->name);\n-              fprintf (asm_out_file, \", %d\\n\", p->size);\n-            }\n-        }\n-    }\n-}\n-\n-/* Implement TARGET_OPTION_OVERRIDE hook.  */\n-void\n-score7_option_override (void)\n-{\n-  flag_pic = false;\n-  score7_sdata_max = SCORE7_DEFAULT_SDATA_MAX;\n-\n-}\n-\n-/* Implement REGNO_REG_CLASS macro.  */\n-int\n-score7_reg_class (int regno)\n-{\n-  int c;\n-  gcc_assert (regno >= 0 && regno < FIRST_PSEUDO_REGISTER);\n-\n-  if (regno == FRAME_POINTER_REGNUM\n-      || regno == ARG_POINTER_REGNUM)\n-    return ALL_REGS;\n-\n-  for (c = 0; c < N_REG_CLASSES; c++)\n-    if (TEST_HARD_REG_BIT (reg_class_contents[c], regno))\n-      return c;\n-\n-  return NO_REGS;\n-}\n-\n-/* Implement PREFERRED_RELOAD_CLASS macro.  */\n-enum reg_class\n-score7_preferred_reload_class (rtx x ATTRIBUTE_UNUSED, enum reg_class rclass)\n-{\n-  if (reg_class_subset_p (G16_REGS, rclass))\n-    return G16_REGS;\n-  if (reg_class_subset_p (G32_REGS, rclass))\n-    return G32_REGS;\n-  return rclass;\n-}\n-\n-/* Implement SECONDARY_INPUT_RELOAD_CLASS\n-   and SECONDARY_OUTPUT_RELOAD_CLASS macro.  */\n-enum reg_class\n-score7_secondary_reload_class (enum reg_class rclass,\n-                               enum machine_mode mode ATTRIBUTE_UNUSED,\n-                               rtx x)\n-{\n-  int regno = -1;\n-  if (GET_CODE (x) == REG || GET_CODE(x) == SUBREG)\n-    regno = true_regnum (x);\n-\n-  if (!GR_REG_CLASS_P (rclass))\n-    return GP_REG_P (regno) ? NO_REGS : G32_REGS;\n-  return NO_REGS;\n-}\n-\n-\n-/* Return truth value on whether or not a given hard register\n-   can support a given mode.  */\n-int\n-score7_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n-{\n-  int size = GET_MODE_SIZE (mode);\n-  enum mode_class mclass = GET_MODE_CLASS (mode);\n-\n-  if (mclass == MODE_CC)\n-    return regno == CC_REGNUM;\n-  else if (regno == FRAME_POINTER_REGNUM\n-           || regno == ARG_POINTER_REGNUM)\n-    return mclass == MODE_INT;\n-  else if (GP_REG_P (regno))\n-    /* ((regno <= (GP_REG_LAST- HARD_REGNO_NREGS (dummy, mode)) + 1)  */\n-    return !(regno & 1) || (size <= UNITS_PER_WORD);\n-  else if (CE_REG_P (regno))\n-    return (mclass == MODE_INT\n-            && ((size <= UNITS_PER_WORD)\n-                || (regno == CE_REG_FIRST && size == 2 * UNITS_PER_WORD)));\n-  else\n-    return (mclass == MODE_INT) && (size <= UNITS_PER_WORD);\n-}\n-\n-/* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n-   pointer or argument pointer.  TO is either the stack pointer or\n-   hard frame pointer.  */\n-HOST_WIDE_INT\n-score7_initial_elimination_offset (int from,\n-                                   int to ATTRIBUTE_UNUSED)\n-{\n-  struct score7_frame_info *f = score7_compute_frame_size (get_frame_size ());\n-  switch (from)\n-    {\n-    case ARG_POINTER_REGNUM:\n-      return f->total_size;\n-    case FRAME_POINTER_REGNUM:\n-      return 0;\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-/* Implement TARGET_FUNCTION_ARG_ADVANCE hook.  */\n-void\n-score7_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-                             const_tree type, bool named)\n-{\n-  struct score7_arg_info info;\n-  score7_classify_arg (cum, mode, type, named, &info);\n-  cum->num_gprs = info.reg_offset + info.reg_words;\n-  if (info.stack_words > 0)\n-    cum->stack_words = info.stack_offset + info.stack_words;\n-  cum->arg_number++;\n-}\n-\n-/* Implement TARGET_ARG_PARTIAL_BYTES macro.  */\n-int\n-score7_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n-                          enum machine_mode mode, tree type, bool named)\n-{\n-  struct score7_arg_info info;\n-  score7_classify_arg (cum, mode, type, named, &info);\n-  return info.stack_words > 0 ? info.reg_words * UNITS_PER_WORD : 0;\n-}\n-\n-/* Implement TARGET_FUNCTION_ARG hook.  */\n-rtx\n-score7_function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-                     const_tree type, bool named)\n-{\n-  struct score7_arg_info info;\n-\n-  if (mode == VOIDmode || !named)\n-    return 0;\n-\n-  score7_classify_arg (cum, mode, type, named, &info);\n-\n-  if (info.reg_offset == ARG_REG_NUM)\n-    return 0;\n-\n-  if (!info.stack_words)\n-    return gen_rtx_REG (mode, ARG_REG_FIRST + info.reg_offset);\n-  else\n-    {\n-      rtx ret = gen_rtx_PARALLEL (mode, rtvec_alloc (info.reg_words));\n-      unsigned int i, part_offset = 0;\n-      for (i = 0; i < info.reg_words; i++)\n-        {\n-          rtx reg;\n-          reg = gen_rtx_REG (SImode, ARG_REG_FIRST + info.reg_offset + i);\n-          XVECEXP (ret, 0, i) = gen_rtx_EXPR_LIST (SImode, reg,\n-                                                   GEN_INT (part_offset));\n-          part_offset += UNITS_PER_WORD;\n-        }\n-      return ret;\n-    }\n-}\n-\n-/* Implement FUNCTION_VALUE and LIBCALL_VALUE.  For normal calls,\n-   VALTYPE is the return type and MODE is VOIDmode.  For libcalls,\n-   VALTYPE is null and MODE is the mode of the return value.  */\n-rtx\n-score7_function_value (const_tree valtype, const_tree func,\n-\t\t       enum machine_mode mode)\n-{\n-  if (valtype)\n-    {\n-      int unsignedp;\n-      mode = TYPE_MODE (valtype);\n-      unsignedp = TYPE_UNSIGNED (valtype);\n-      mode = promote_function_mode (valtype, mode, &unsignedp, func, 1);\n-    }\n-  return gen_rtx_REG (mode, RT_REGNUM);\n-}\n-\n-/* Implement TARGET_ASM_TRAMPOLINE_TEMPLATE.  */\n-\n-void\n-score7_asm_trampoline_template (FILE *f)\n-{\n-  fprintf (f, \"\\t.set r1\\n\");\n-  fprintf (f, \"\\tmv r31, r3\\n\");\n-  fprintf (f, \"\\tbl nextinsn\\n\");\n-  fprintf (f, \"nextinsn:\\n\");\n-  fprintf (f, \"\\tlw r1, [r3, 6*4-8]\\n\");\n-  fprintf (f, \"\\tlw r23, [r3, 6*4-4]\\n\");\n-  fprintf (f, \"\\tmv r3, r31\\n\");\n-  fprintf (f, \"\\tbr! r1\\n\");\n-  fprintf (f, \"\\tnop!\\n\");\n-  fprintf (f, \"\\t.set nor1\\n\");\n-}\n-\n-/* Implement TARGET_TRAMPOLINE_INIT.  */\n-void\n-score7_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n-{\n-#define CODE_SIZE        (TRAMPOLINE_INSNS * UNITS_PER_WORD)\n-\n-  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n-  rtx addr = XEXP (m_tramp, 0);\n-  rtx mem;\n-\n-  emit_block_move (m_tramp, assemble_trampoline_template (),\n-\t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n-\n-  mem = adjust_address (m_tramp, SImode, CODE_SIZE);\n-  emit_move_insn (mem, fnaddr);\n-  mem = adjust_address (m_tramp, SImode, CODE_SIZE + GET_MODE_SIZE (SImode));\n-  emit_move_insn (mem, chain_value);\n-\n-#undef CODE_SIZE\n-}\n-\n-/* This function is used to implement REG_MODE_OK_FOR_BASE_P macro.  */\n-int\n-score7_regno_mode_ok_for_base_p (int regno, int strict)\n-{\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      if (!strict)\n-        return 1;\n-      regno = reg_renumber[regno];\n-    }\n-  if (regno == ARG_POINTER_REGNUM\n-      || regno == FRAME_POINTER_REGNUM)\n-    return 1;\n-  return GP_REG_P (regno);\n-}\n-\n-/* Implement TARGET_LEGITIMATE_ADDRESS_P macro.  */\n-bool\n-score7_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n-{\n-  struct score7_address_info addr;\n-\n-  return score7_classify_address (&addr, mode, x, strict);\n-}\n-\n-/* Return a number assessing the cost of moving a register in class\n-   FROM to class TO. */\n-int\n-score7_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n-                           enum reg_class from, enum reg_class to)\n-{\n-  if (GR_REG_CLASS_P (from))\n-    {\n-      if (GR_REG_CLASS_P (to))\n-        return 2;\n-      else if (SP_REG_CLASS_P (to))\n-        return 4;\n-      else if (CP_REG_CLASS_P (to))\n-        return 5;\n-      else if (CE_REG_CLASS_P (to))\n-        return 6;\n-    }\n-  if (GR_REG_CLASS_P (to))\n-    {\n-      if (GR_REG_CLASS_P (from))\n-        return 2;\n-      else if (SP_REG_CLASS_P (from))\n-        return 4;\n-      else if (CP_REG_CLASS_P (from))\n-        return 5;\n-      else if (CE_REG_CLASS_P (from))\n-        return 6;\n-    }\n-  return 12;\n-}\n-\n-/* Return the number of instructions needed to load a symbol of the\n-   given type into a register.  */\n-static int\n-score7_symbol_insns (enum score_symbol_type type)\n-{\n-  switch (type)\n-    {\n-    case SYMBOL_GENERAL:\n-      return 2;\n-\n-    case SYMBOL_SMALL_DATA:\n-      return 1;\n-    }\n-\n-  gcc_unreachable ();\n-}\n-\n-/* Return the number of instructions needed to load or store a value\n-   of mode MODE at X.  Return 0 if X isn't valid for MODE.  */\n-static int\n-score7_address_insns (rtx x, enum machine_mode mode)\n-{\n-  struct score7_address_info addr;\n-  int factor;\n-\n-  if (mode == BLKmode)\n-    factor = 1;\n-  else\n-    factor = (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-\n-  if (score7_classify_address (&addr, mode, x, false))\n-    switch (addr.type)\n-      {\n-      case SCORE7_ADD_REG:\n-      case SCORE7_ADD_CONST_INT:\n-        return factor;\n-\n-      case SCORE7_ADD_SYMBOLIC:\n-        return factor * score7_symbol_insns (addr.symbol_type);\n-      }\n-  return 0;\n-}\n-\n-/* Implement TARGET_RTX_COSTS macro.  */\n-bool\n-score7_rtx_costs (rtx x, int code, int outer_code, int *total,\n-\t\t  bool speed ATTRIBUTE_UNUSED)\n-{\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-      if (outer_code == SET)\n-        {\n-          if (((INTVAL (x) & 0xffff) == 0) \n-              || (INTVAL (x) >= -32768 && INTVAL (x) <= 32767))\n-            *total = COSTS_N_INSNS (1);\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else if (outer_code == PLUS || outer_code == MINUS)\n-        {\n-          if (INTVAL (x) >= -8192 && INTVAL (x) <= 8191)\n-            *total = 0;\n-          else if (((INTVAL (x) & 0xffff) == 0)\n-                   || (INTVAL (x) >= -32768 && INTVAL (x) <= 32767))\n-            *total = 1;\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else if (outer_code == AND || outer_code == IOR)\n-        {\n-          if (INTVAL (x) >= 0 && INTVAL (x) <= 16383)\n-            *total = 0;\n-          else if (((INTVAL (x) & 0xffff) == 0)\n-                   || (INTVAL (x) >= 0 && INTVAL (x) <= 65535))\n-            *total = 1;\n-          else\n-            *total = COSTS_N_INSNS (2);\n-        }\n-      else\n-        {\n-          *total = 0;\n-        }\n-      return true;\n-\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CONST_DOUBLE:\n-      *total = COSTS_N_INSNS (2);\n-      return true;\n-\n-    case MEM:\n-      {\n-        /* If the address is legitimate, return the number of\n-           instructions it needs, otherwise use the default handling.  */\n-        int n = score7_address_insns (XEXP (x, 0), GET_MODE (x));\n-        if (n > 0)\n-          {\n-            *total = COSTS_N_INSNS (n + 1);\n-            return true;\n-          }\n-        return false;\n-      }\n-\n-    case FFS:\n-      *total = COSTS_N_INSNS (6);\n-      return true;\n-\n-    case NOT:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case AND:\n-    case IOR:\n-    case XOR:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (2);\n-          return true;\n-        }\n-      return false;\n-\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n-                                  ? 4 : 12);\n-          return true;\n-        }\n-      return false;\n-\n-    case ABS:\n-      *total = COSTS_N_INSNS (4);\n-      return true;\n-\n-    case PLUS:\n-    case MINUS:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case NEG:\n-      if (mode == DImode)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n-      return false;\n-\n-    case MULT:\n-      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (12);\n-      return true;\n-\n-    case DIV:\n-    case MOD:\n-    case UDIV:\n-    case UMOD:\n-      *total = optimize_size ? COSTS_N_INSNS (2) : COSTS_N_INSNS (33);\n-      return true;\n-\n-    case SIGN_EXTEND:\n-    case ZERO_EXTEND:\n-      switch (GET_MODE (XEXP (x, 0)))\n-        {\n-        case QImode:\n-        case HImode:\n-          if (GET_CODE (XEXP (x, 0)) == MEM)\n-            {\n-              *total = COSTS_N_INSNS (2);\n-\n-              if (!TARGET_LITTLE_ENDIAN &&\n-                  side_effects_p (XEXP (XEXP (x, 0), 0)))\n-                *total = 100;\n-            }\n-          else\n-            *total = COSTS_N_INSNS (1);\n-          break;\n-\n-        default:\n-          *total = COSTS_N_INSNS (1);\n-          break;\n-        }\n-      return true;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Implement TARGET_ADDRESS_COST macro.  */\n-int\n-score7_address_cost (rtx addr)\n-{\n-  return score7_address_insns (addr, SImode);\n-}\n-\n-/* Implement ASM_OUTPUT_EXTERNAL macro.  */\n-int\n-score7_output_external (FILE *file ATTRIBUTE_UNUSED,\n-                        tree decl, const char *name)\n-{\n-  register struct extern_list *p;\n-\n-  if (score7_in_small_data_p (decl))\n-    {\n-      p = ggc_alloc_extern_list ();\n-      p->next = extern_head;\n-      p->name = name;\n-      p->size = int_size_in_bytes (TREE_TYPE (decl));\n-      extern_head = p;\n-    }\n-  return 0;\n-}\n-\n-/* Implement RETURN_ADDR_RTX.  Note, we do not support moving\n-   back to a previous frame.  */\n-rtx\n-score7_return_addr (int count, rtx frame ATTRIBUTE_UNUSED)\n-{\n-  if (count != 0)\n-    return const0_rtx;\n-  return get_hard_reg_initial_val (Pmode, RA_REGNUM);\n-}\n-\n-/* Implement PRINT_OPERAND macro.  */\n-/* Score-specific operand codes:\n-   '['        print .set nor1 directive\n-   ']'        print .set r1 directive\n-   'U'        print hi part of a CONST_INT rtx\n-   'E'        print log2(v)\n-   'F'        print log2(~v)\n-   'D'        print SFmode const double\n-   'S'        selectively print \"!\" if operand is 15bit instruction accessible\n-   'V'        print \"v!\" if operand is 15bit instruction accessible, or \"lfh!\"\n-   'L'        low  part of DImode reg operand\n-   'H'        high part of DImode reg operand\n-   'C'        print part of opcode for a branch condition.  */\n-void\n-score7_print_operand (FILE *file, rtx op, int c)\n-{\n-  enum rtx_code code = UNKNOWN;\n-  if (!PRINT_OPERAND_PUNCT_VALID_P (c))\n-    code = GET_CODE (op);\n-\n-  if (c == '[')\n-    {\n-      fprintf (file, \".set r1\\n\");\n-    }\n-  else if (c == ']')\n-    {\n-      fprintf (file, \"\\n\\t.set nor1\");\n-    }\n-  else if (c == 'U')\n-    {\n-      gcc_assert (code == CONST_INT);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX,\n-               (INTVAL (op) >> 16) & 0xffff);\n-    }\n-  else if (c == 'D')\n-    {\n-      if (GET_CODE (op) == CONST_DOUBLE)\n-        {\n-          rtx temp = gen_lowpart (SImode, op);\n-          gcc_assert (GET_MODE (op) == SFmode);\n-          fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (temp) & 0xffffffff);\n-        }\n-      else\n-        output_addr_const (file, op);\n-    }\n-  else if (c == 'S')\n-    {\n-      gcc_assert (code == REG);\n-      if (G16_REG_P (REGNO (op)))\n-        fprintf (file, \"!\");\n-    }\n-  else if (c == 'V')\n-    {\n-      gcc_assert (code == REG);\n-      fprintf (file, G16_REG_P (REGNO (op)) ? \"v!\" : \"lfh!\");\n-    }\n-  else if (c == 'C')\n-    {\n-      enum machine_mode mode = GET_MODE (XEXP (op, 0));\n-\n-      switch (code)\n-        {\n-        case EQ: fputs (\"eq\", file); break;\n-        case NE: fputs (\"ne\", file); break;\n-        case GT: fputs (\"gt\", file); break;\n-        case GE: fputs (mode != CCmode ? \"pl\" : \"ge\", file); break;\n-        case LT: fputs (mode != CCmode ? \"mi\" : \"lt\", file); break;\n-        case LE: fputs (\"le\", file); break;\n-        case GTU: fputs (\"gtu\", file); break;\n-        case GEU: fputs (\"cs\", file); break;\n-        case LTU: fputs (\"cc\", file); break;\n-        case LEU: fputs (\"leu\", file); break;\n-        default:\n-          output_operand_lossage (\"invalid operand for code: '%c'\", code);\n-        }\n-    }\n-  else if (c == 'E')\n-    {\n-      unsigned HOST_WIDE_INT i;\n-      unsigned HOST_WIDE_INT pow2mask = 1;\n-      unsigned HOST_WIDE_INT val;\n-\n-      val = INTVAL (op);\n-      for (i = 0; i < 32; i++)\n-        {\n-          if (val == pow2mask)\n-            break;\n-          pow2mask <<= 1;\n-        }\n-      gcc_assert (i < 32);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n-    }\n-  else if (c == 'F')\n-    {\n-      unsigned HOST_WIDE_INT i;\n-      unsigned HOST_WIDE_INT pow2mask = 1;\n-      unsigned HOST_WIDE_INT val;\n-\n-      val = ~INTVAL (op);\n-      for (i = 0; i < 32; i++)\n-        {\n-          if (val == pow2mask)\n-            break;\n-          pow2mask <<= 1;\n-        }\n-      gcc_assert (i < 32);\n-      fprintf (file, HOST_WIDE_INT_PRINT_HEX, i);\n-    }\n-  else if (code == REG)\n-    {\n-      int regnum = REGNO (op);\n-      if ((c == 'H' && !WORDS_BIG_ENDIAN)\n-          || (c == 'L' && WORDS_BIG_ENDIAN))\n-        regnum ++;\n-      fprintf (file, \"%s\", reg_names[regnum]);\n-    }\n-  else\n-    {\n-      switch (code)\n-        {\n-        case MEM:\n-          score7_print_operand_address (file, op);\n-          break;\n-        default:\n-          output_addr_const (file, op);\n-        }\n-    }\n-}\n-\n-/* Implement PRINT_OPERAND_ADDRESS macro.  */\n-void\n-score7_print_operand_address (FILE *file, rtx x)\n-{\n-  struct score7_address_info addr;\n-  enum rtx_code code = GET_CODE (x);\n-  enum machine_mode mode = GET_MODE (x);\n-\n-  if (code == MEM)\n-    x = XEXP (x, 0);\n-\n-  if (score7_classify_address (&addr, mode, x, true))\n-    {\n-      switch (addr.type)\n-        {\n-        case SCORE7_ADD_REG:\n-          {\n-            switch (addr.code)\n-              {\n-              case PRE_DEC:\n-                fprintf (file, \"[%s,-%ld]+\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case POST_DEC:\n-                fprintf (file, \"[%s]+,-%ld\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case PRE_INC:\n-                fprintf (file, \"[%s, %ld]+\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              case POST_INC:\n-                fprintf (file, \"[%s]+, %ld\", reg_names[REGNO (addr.reg)],\n-                         INTVAL (addr.offset));\n-                break;\n-              default:\n-                if (INTVAL(addr.offset) == 0)\n-                  fprintf(file, \"[%s]\", reg_names[REGNO (addr.reg)]);\n-                else\n-                  fprintf(file, \"[%s, %ld]\", reg_names[REGNO (addr.reg)],\n-                          INTVAL(addr.offset));\n-                break;\n-              }\n-          }\n-          return;\n-        case SCORE7_ADD_CONST_INT:\n-        case SCORE7_ADD_SYMBOLIC:\n-          output_addr_const (file, x);\n-          return;\n-        }\n-    }\n-  print_rtl (stderr, x);\n-  gcc_unreachable ();\n-}\n-\n-/* Implement SELECT_CC_MODE macro.  */\n-enum machine_mode\n-score7_select_cc_mode (enum rtx_code op, rtx x, rtx y)\n-{\n-  if ((op == EQ || op == NE || op == LT || op == GE)\n-      && y == const0_rtx\n-      && GET_MODE (x) == SImode)\n-    {\n-      switch (GET_CODE (x))\n-        {\n-        case PLUS:\n-        case MINUS:\n-        case NEG:\n-        case AND:\n-        case IOR:\n-        case XOR:\n-        case NOT:\n-        case ASHIFT:\n-        case LSHIFTRT:\n-        case ASHIFTRT:\n-          return CC_NZmode;\n-\n-        case SIGN_EXTEND:\n-        case ZERO_EXTEND:\n-        case ROTATE:\n-        case ROTATERT:\n-          return (op == LT || op == GE) ? CC_Nmode : CCmode;\n-\n-        default:\n-          return CCmode;\n-        }\n-    }\n-\n-  if ((op == EQ || op == NE)\n-      && (GET_CODE (y) == NEG)\n-      && register_operand (XEXP (y, 0), SImode)\n-      && register_operand (x, SImode))\n-    {\n-      return CC_NZmode;\n-    }\n-\n-  return CCmode;\n-}\n-\n-/* Generate the prologue instructions for entry into a S+core function.  */\n-void\n-score7_prologue (void)\n-{\n-#define EMIT_PL(_rtx)        RTX_FRAME_RELATED_P (_rtx) = 1\n-\n-  struct score7_frame_info *f = score7_compute_frame_size (get_frame_size ());\n-  HOST_WIDE_INT size;\n-  int regno;\n-\n-  size = f->total_size - f->gp_reg_size;\n-\n-  if (flag_pic)\n-    emit_insn (gen_cpload_score7 ());\n-\n-  for (regno = (int) GP_REG_LAST; regno >= (int) GP_REG_FIRST; regno--)\n-    {\n-      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n-        {\n-          rtx mem = gen_rtx_MEM (SImode,\n-                                 gen_rtx_PRE_DEC (SImode, stack_pointer_rtx));\n-          rtx reg = gen_rtx_REG (SImode, regno);\n-          if (!crtl->calls_eh_return)\n-            MEM_READONLY_P (mem) = 1;\n-          EMIT_PL (emit_insn (gen_pushsi_score7 (mem, reg)));\n-        }\n-    }\n-\n-  if (size > 0)\n-    {\n-      rtx insn;\n-\n-      if (size >= -32768 && size <= 32767)\n-        EMIT_PL (emit_insn (gen_add3_insn (stack_pointer_rtx,\n-                                           stack_pointer_rtx,\n-                                           GEN_INT (-size))));\n-      else\n-        {\n-          EMIT_PL (emit_move_insn (gen_rtx_REG (Pmode, SCORE7_PROLOGUE_TEMP_REGNUM),\n-                                   GEN_INT (size)));\n-          EMIT_PL (emit_insn\n-                   (gen_sub3_insn (stack_pointer_rtx,\n-                                   stack_pointer_rtx,\n-                                   gen_rtx_REG (Pmode,\n-                                                SCORE7_PROLOGUE_TEMP_REGNUM))));\n-        }\n-      insn = get_last_insn ();\n-      REG_NOTES (insn) =\n-        alloc_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n-                         gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n-                                      plus_constant (stack_pointer_rtx,\n-                                                     -size)),\n-                                      REG_NOTES (insn));\n-    }\n-\n-  if (frame_pointer_needed)\n-    EMIT_PL (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx));\n-\n-  if (flag_pic && f->cprestore_size)\n-    {\n-      if (frame_pointer_needed)\n-        emit_insn (gen_cprestore_use_fp_score7 (GEN_INT (size - f->cprestore_size)));\n-      else\n-        emit_insn (gen_cprestore_use_sp_score7 (GEN_INT (size - f->cprestore_size)));\n-    }\n-\n-#undef EMIT_PL\n-}\n-\n-/* Generate the epilogue instructions in a S+core function.  */\n-void\n-score7_epilogue (int sibcall_p)\n-{\n-  struct score7_frame_info *f = score7_compute_frame_size (get_frame_size ());\n-  HOST_WIDE_INT size;\n-  int regno;\n-  rtx base;\n-\n-  size = f->total_size - f->gp_reg_size;\n-\n-  if (!frame_pointer_needed)\n-    base = stack_pointer_rtx;\n-  else\n-    base = hard_frame_pointer_rtx;\n-\n-  if (size)\n-    {\n-      if (size >= -32768 && size <= 32767)\n-        emit_insn (gen_add3_insn (base, base, GEN_INT (size)));\n-      else\n-        {\n-          emit_move_insn (gen_rtx_REG (Pmode, SCORE7_EPILOGUE_TEMP_REGNUM),\n-                          GEN_INT (size));\n-          emit_insn (gen_add3_insn (base, base,\n-                                    gen_rtx_REG (Pmode,\n-                                                 SCORE7_EPILOGUE_TEMP_REGNUM)));\n-        }\n-    }\n-\n-  if (base != stack_pointer_rtx)\n-    emit_move_insn (stack_pointer_rtx, base);\n-\n-  if (crtl->calls_eh_return)\n-    emit_insn (gen_add3_insn (stack_pointer_rtx,\n-                              stack_pointer_rtx,\n-                              EH_RETURN_STACKADJ_RTX));\n-\n-  for (regno = (int) GP_REG_FIRST; regno <= (int) GP_REG_LAST; regno++)\n-    {\n-      if (BITSET_P (f->mask, regno - GP_REG_FIRST))\n-        {\n-          rtx mem = gen_rtx_MEM (SImode,\n-                                 gen_rtx_POST_INC (SImode, stack_pointer_rtx));\n-          rtx reg = gen_rtx_REG (SImode, regno);\n-\n-          if (!crtl->calls_eh_return)\n-            MEM_READONLY_P (mem) = 1;\n-\n-          emit_insn (gen_popsi_score7 (reg, mem));\n-        }\n-    }\n-\n-  if (!sibcall_p)\n-    emit_jump_insn (gen_return_internal_score7 (gen_rtx_REG (Pmode, RA_REGNUM)));\n-}\n-\n-/* Return true if X is a symbolic constant that can be calculated in\n-   the same way as a bare symbol.  If it is, store the type of the\n-   symbol in *SYMBOL_TYPE.  */\n-int\n-score7_symbolic_constant_p (rtx x, enum score_symbol_type *symbol_type)\n-{\n-  HOST_WIDE_INT offset;\n-\n-  score7_split_const (x, &x, &offset);\n-  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n-    *symbol_type = score7_classify_symbol (x);\n-  else\n-    return 0;\n-\n-  if (offset == 0)\n-    return 1;\n-\n-  /* if offset > 15bit, must reload  */\n-  if (!IMM_IN_RANGE (offset, 15, 1))\n-    return 0;\n-\n-  switch (*symbol_type)\n-    {\n-    case SYMBOL_GENERAL:\n-      return 1;\n-    case SYMBOL_SMALL_DATA:\n-      return score7_offset_within_object_p (x, offset);\n-    }\n-  gcc_unreachable ();\n-}\n-\n-void\n-score7_movsicc (rtx *ops)\n-{\n-  enum machine_mode mode;\n-\n-  mode = score7_select_cc_mode (GET_CODE (ops[1]), ops[2], ops[3]);\n-  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (mode, CC_REGNUM),\n-                          gen_rtx_COMPARE (mode, XEXP (ops[1], 0),\n-\t\t\t\t\t   XEXP (ops[1], 1))));\n-}\n-\n-/* Call and sibcall pattern all need call this function.  */\n-void\n-score7_call (rtx *ops, bool sib)\n-{\n-  rtx addr = XEXP (ops[0], 0);\n-  if (!call_insn_operand (addr, VOIDmode))\n-    {\n-      rtx oaddr = addr;\n-      addr = gen_reg_rtx (Pmode);\n-      gen_move_insn (addr, oaddr);\n-    }\n-\n-  if (sib)\n-    emit_call_insn (gen_sibcall_internal_score7 (addr, ops[1]));\n-  else\n-    emit_call_insn (gen_call_internal_score7 (addr, ops[1]));\n-}\n-\n-/* Call value and sibcall value pattern all need call this function.  */\n-void\n-score7_call_value (rtx *ops, bool sib)\n-{\n-  rtx result = ops[0];\n-  rtx addr = XEXP (ops[1], 0);\n-  rtx arg = ops[2];\n-\n-  if (!call_insn_operand (addr, VOIDmode))\n-    {\n-      rtx oaddr = addr;\n-      addr = gen_reg_rtx (Pmode);\n-      gen_move_insn (addr, oaddr);\n-    }\n-\n-  if (sib)\n-    emit_call_insn (gen_sibcall_value_internal_score7 (result, addr, arg));\n-  else\n-    emit_call_insn (gen_call_value_internal_score7 (result, addr, arg));\n-}\n-\n-/* Machine Split  */\n-void\n-score7_movdi (rtx *ops)\n-{\n-  rtx dst = ops[0];\n-  rtx src = ops[1];\n-  rtx dst0 = score7_subw (dst, 0);\n-  rtx dst1 = score7_subw (dst, 1);\n-  rtx src0 = score7_subw (src, 0);\n-  rtx src1 = score7_subw (src, 1);\n-\n-  if (GET_CODE (dst0) == REG && reg_overlap_mentioned_p (dst0, src))\n-    {\n-      emit_move_insn (dst1, src1);\n-      emit_move_insn (dst0, src0);\n-    }\n-  else\n-    {\n-      emit_move_insn (dst0, src0);\n-      emit_move_insn (dst1, src1);\n-    }\n-}\n-\n-void\n-score7_zero_extract_andi (rtx *ops)\n-{\n-  if (INTVAL (ops[1]) == 1 && const_uimm5 (ops[2], SImode))\n-    emit_insn (gen_zero_extract_bittst_score7 (ops[0], ops[2]));\n-  else\n-    {\n-      unsigned HOST_WIDE_INT mask;\n-      mask = (0xffffffffU & ((1U << INTVAL (ops[1])) - 1U));\n-      mask = mask << INTVAL (ops[2]);\n-      emit_insn (gen_andsi3_cmp_score7 (ops[3], ops[0],\n-                                 gen_int_mode (mask, SImode)));\n-    }\n-}\n-\n-/* Check addr could be present as PRE/POST mode.  */\n-static bool\n-score7_pindex_mem (rtx addr)\n-{\n-  if (GET_CODE (addr) == MEM)\n-    {\n-      switch (GET_CODE (XEXP (addr, 0)))\n-        {\n-        case PRE_DEC:\n-        case POST_DEC:\n-        case PRE_INC:\n-        case POST_INC:\n-          return true;\n-        default:\n-          break;\n-        }\n-    }\n-  return false;\n-}\n-\n-/* Output asm code for ld/sw insn.  */\n-static int\n-score7_pr_addr_post (rtx *ops, int idata, int iaddr, char *ip, enum score_mem_unit unit)\n-{\n-  struct score7_address_info ai;\n-\n-  gcc_assert (GET_CODE (ops[idata]) == REG);\n-  gcc_assert (score7_classify_address (&ai, SImode, XEXP (ops[iaddr], 0), true));\n-\n-  if (!score7_pindex_mem (ops[iaddr])\n-      && ai.type == SCORE7_ADD_REG\n-      && GET_CODE (ai.offset) == CONST_INT\n-      && G16_REG_P (REGNO (ops[idata]))\n-      && G16_REG_P (REGNO (ai.reg)))\n-    {\n-      if (INTVAL (ai.offset) == 0)\n-        {\n-          ops[iaddr] = ai.reg;\n-          return snprintf (ip, INS_BUF_SZ,\n-                           \"!\\t%%%d, [%%%d]\", idata, iaddr);\n-        }\n-      if (REGNO (ai.reg) == HARD_FRAME_POINTER_REGNUM)\n-        {\n-          HOST_WIDE_INT offset = INTVAL (ai.offset);\n-          if (SCORE_ALIGN_UNIT (offset, unit)\n-              && (((offset >> unit) >= 0) && ((offset >> unit) <= 31)))\n-            {\n-              ops[iaddr] = ai.offset;\n-              return snprintf (ip, INS_BUF_SZ,\n-                               \"p!\\t%%%d, %%c%d\", idata, iaddr);\n-            }\n-        }\n-    }\n-  return snprintf (ip, INS_BUF_SZ, \"\\t%%%d, %%a%d\", idata, iaddr);\n-}\n-\n-/* Output asm insn for load.  */\n-const char *\n-score7_linsn (rtx *ops, enum score_mem_unit unit, bool sign)\n-{\n-  const char *pre_ins[] =\n-    {\"lbu\", \"lhu\", \"lw\", \"??\", \"lb\", \"lh\", \"lw\", \"??\"};\n-  char *ip;\n-\n-  strcpy (score7_ins, pre_ins[(sign ? 4 : 0) + unit]);\n-  ip = score7_ins + strlen (score7_ins);\n-\n-  if ((!sign && unit != SCORE_HWORD)\n-      || (sign && unit != SCORE_BYTE))\n-    score7_pr_addr_post (ops, 0, 1, ip, unit);\n-  else\n-    snprintf (ip, INS_BUF_SZ, \"\\t%%0, %%a1\");\n-\n-  return score7_ins;\n-}\n-\n-/* Output asm insn for store.  */\n-const char *\n-score7_sinsn (rtx *ops, enum score_mem_unit unit)\n-{\n-  const char *pre_ins[] = {\"sb\", \"sh\", \"sw\"};\n-  char *ip;\n-\n-  strcpy (score7_ins, pre_ins[unit]);\n-  ip = score7_ins + strlen (score7_ins);\n-  score7_pr_addr_post (ops, 1, 0, ip, unit);\n-  return score7_ins;\n-}\n-\n-/* Output asm insn for load immediate.  */\n-const char *\n-score7_limm (rtx *ops)\n-{\n-  HOST_WIDE_INT v;\n-\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == CONST_INT);\n-\n-  v = INTVAL (ops[1]);\n-  if (G16_REG_P (REGNO (ops[0])) && IMM_IN_RANGE (v, 8, 0))\n-    return \"ldiu!\\t%0, %c1\";\n-  else if (IMM_IN_RANGE (v, 16, 1))\n-    return \"ldi\\t%0, %c1\";\n-  else if ((v & 0xffff) == 0)\n-    return \"ldis\\t%0, %U1\";\n-  else\n-    return \"li\\t%0, %c1\";\n-}\n-\n-/* Output asm insn for move.  */\n-const char *\n-score7_move (rtx *ops)\n-{\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == REG);\n-\n-  if (G16_REG_P (REGNO (ops[0])))\n-    {\n-      if (G16_REG_P (REGNO (ops[1])))\n-        return \"mv!\\t%0, %1\";\n-      else\n-        return \"mlfh!\\t%0, %1\";\n-    }\n-  else if (G16_REG_P (REGNO (ops[1])))\n-    return \"mhfl!\\t%0, %1\";\n-  else\n-    return \"mv\\t%0, %1\";\n-}\n-\n-/* Generate add insn.  */\n-const char *\n-score7_select_add_imm (rtx *ops, bool set_cc)\n-{\n-  HOST_WIDE_INT v = INTVAL (ops[2]);\n-\n-  gcc_assert (GET_CODE (ops[2]) == CONST_INT);\n-  gcc_assert (REGNO (ops[0]) == REGNO (ops[1]));\n-\n-  if (set_cc && G16_REG_P (REGNO (ops[0])))\n-    {\n-      if (v > 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) v, 0, 15))\n-        {\n-          ops[2] = GEN_INT (ffs (v) - 1);\n-          return \"addei!\\t%0, %c2\";\n-        }\n-\n-      if (v < 0 && IMM_IS_POW_OF_2 ((unsigned HOST_WIDE_INT) (-v), 0, 15))\n-        {\n-          ops[2] = GEN_INT (ffs (-v) - 1);\n-          return \"subei!\\t%0, %c2\";\n-        }\n-    }\n-\n-  if (set_cc)\n-    return \"addi.c\\t%0, %c2\";\n-  else\n-    return \"addi\\t%0, %c2\";\n-}\n-\n-/* Output arith insn.  */\n-const char *\n-score7_select (rtx *ops, const char *inst_pre,\n-               bool commu, const char *letter, bool set_cc)\n-{\n-  gcc_assert (GET_CODE (ops[0]) == REG);\n-  gcc_assert (GET_CODE (ops[1]) == REG);\n-\n-  if (set_cc && G16_REG_P (REGNO (ops[0]))\n-      && (GET_CODE (ops[2]) == REG ? G16_REG_P (REGNO (ops[2])) : 1)\n-      && REGNO (ops[0]) == REGNO (ops[1]))\n-    {\n-      snprintf (score7_ins, INS_BUF_SZ, \"%s!\\t%%0, %%%s2\", inst_pre, letter);\n-      return score7_ins;\n-    }\n-\n-  if (commu && set_cc && G16_REG_P (REGNO (ops[0]))\n-      && G16_REG_P (REGNO (ops[1]))\n-      && REGNO (ops[0]) == REGNO (ops[2]))\n-    {\n-      gcc_assert (GET_CODE (ops[2]) == REG);\n-      snprintf (score7_ins, INS_BUF_SZ, \"%s!\\t%%0, %%%s1\", inst_pre, letter);\n-      return score7_ins;\n-    }\n-\n-  if (set_cc)\n-    snprintf (score7_ins, INS_BUF_SZ, \"%s.c\\t%%0, %%1, %%%s2\", inst_pre, letter);\n-  else\n-    snprintf (score7_ins, INS_BUF_SZ, \"%s\\t%%0, %%1, %%%s2\", inst_pre, letter);\n-  return score7_ins;\n-}\n-"}, {"sha": "71654aae13352e2dc2ebcb8143726a0ff00dc177", "filename": "gcc/config/score/score7.h", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab70d825c6eda82882708757b89f80b8f2f1d2f6/gcc%2Fconfig%2Fscore%2Fscore7.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab70d825c6eda82882708757b89f80b8f2f1d2f6/gcc%2Fconfig%2Fscore%2Fscore7.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore7.h?ref=ab70d825c6eda82882708757b89f80b8f2f1d2f6", "patch": "@@ -1,158 +0,0 @@\n-/* score7.h for Sunplus S+CORE processor\n-   Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by Sunnorth\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_SCORE7_H\n-#define GCC_SCORE7_H\n-\n-enum score7_address_type\n-{\n-  SCORE7_ADD_REG,\n-  SCORE7_ADD_CONST_INT,\n-  SCORE7_ADD_SYMBOLIC\n-};\n-\n-struct score7_frame_info\n-{\n-  HOST_WIDE_INT total_size;       /* bytes that the entire frame takes up  */\n-  HOST_WIDE_INT var_size;         /* bytes that variables take up  */\n-  HOST_WIDE_INT args_size;        /* bytes that outgoing arguments take up  */\n-  HOST_WIDE_INT gp_reg_size;      /* bytes needed to store gp regs  */\n-  HOST_WIDE_INT gp_sp_offset;     /* offset from new sp to store gp registers  */\n-  HOST_WIDE_INT cprestore_size;   /* # bytes that the .cprestore slot takes up  */\n-  unsigned int  mask;             /* mask of saved gp registers  */\n-  int num_gp;                     /* number of gp registers saved  */\n-};\n-\n-struct score7_arg_info\n-{\n-  unsigned int num_bytes;     /* The argument's size in bytes  */\n-  unsigned int reg_words;     /* The number of words passed in registers  */\n-  unsigned int reg_offset;    /* The offset of the first register from  */\n-                              /* GP_ARG_FIRST or FP_ARG_FIRST etc  */\n-  unsigned int stack_words;   /* The number of words that must be passed  */\n-                              /* on the stack  */\n-  unsigned int stack_offset;  /* The offset from the start of the stack  */\n-                              /* overflow area  */\n-};\n-\n-#ifdef RTX_CODE\n-struct score7_address_info\n-{\n-  enum score7_address_type type;\n-  rtx reg;\n-  rtx offset;\n-  enum rtx_code code;\n-  enum score_symbol_type symbol_type;\n-};\n-#endif\n-\n-#define SCORE7_SDATA_MAX                score7_sdata_max\n-#define SCORE7_STACK_ALIGN(LOC)         (((LOC) + 3) & ~3)\n-#define SCORE7_PROLOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n-#define SCORE7_EPILOGUE_TEMP_REGNUM     (GP_REG_FIRST + 8)\n-#define SCORE7_DEFAULT_SDATA_MAX        8\n-\n-extern int score7_symbolic_constant_p (rtx x,\n-                                       enum score_symbol_type *symbol_type);\n-extern bool score7_return_in_memory (const_tree type,\n-                                     const_tree fndecl ATTRIBUTE_UNUSED);\n-extern void score7_output_mi_thunk (FILE *file,\n-                                    tree thunk_fndecl ATTRIBUTE_UNUSED,\n-                                    HOST_WIDE_INT delta,\n-                                    HOST_WIDE_INT vcall_offset,\n-                                    tree function);\n-extern rtx score7_legitimize_address (rtx x);\n-extern void\n-score7_function_prologue (FILE *file,\n-                          HOST_WIDE_INT size ATTRIBUTE_UNUSED);\n-extern void\n-score7_function_epilogue (FILE *file,\n-                          HOST_WIDE_INT size ATTRIBUTE_UNUSED);\n-extern section *score7_select_rtx_section (enum machine_mode mode, rtx x,\n-                                           unsigned HOST_WIDE_INT align);\n-extern bool score7_in_small_data_p (const_tree decl);\n-extern void score7_asm_file_start (void);\n-extern void score7_asm_file_end (void);\n-extern void score7_option_override (void);\n-extern int score7_reg_class (int regno);\n-extern enum reg_class score7_preferred_reload_class (rtx x ATTRIBUTE_UNUSED,\n-                                                     enum reg_class rclass);\n-extern enum\n-reg_class score7_secondary_reload_class (enum reg_class rclass,\n-                                         enum machine_mode mode ATTRIBUTE_UNUSED,\n-                                         rtx x);\n-extern int score7_const_ok_for_letter_p (HOST_WIDE_INT value, char c);\n-extern int score7_extra_constraint (rtx op, char c);\n-extern int score7_hard_regno_mode_ok (unsigned int regno,\n-                                      enum machine_mode mode);\n-extern HOST_WIDE_INT\n-score7_initial_elimination_offset (int from,\n-                                   int to ATTRIBUTE_UNUSED);\n-extern void score7_function_arg_advance (CUMULATIVE_ARGS *cum,\n-                                         enum machine_mode mode,\n-                                         const_tree type,\n-                                         bool named);\n-extern int score7_arg_partial_bytes (CUMULATIVE_ARGS *cum,\n-                                     enum machine_mode mode,\n-                                     tree type,\n-                                     bool named);\n-extern rtx score7_function_arg (const CUMULATIVE_ARGS *cum,\n-                                enum machine_mode mode,\n-                                const_tree type,\n-                                bool named);\n-extern rtx score7_function_value (const_tree valtype,\n-                                  const_tree func ATTRIBUTE_UNUSED,\n-                                  enum machine_mode mode);\n-extern void score7_asm_trampoline_template (FILE *);\n-extern void score7_trampoline_init (rtx, tree, rtx);\n-extern int score7_regno_mode_ok_for_base_p (int regno, int strict);\n-extern bool score7_legitimate_address_p (enum machine_mode mode, rtx x,\n-\t\t\t\t\t bool strict);\n-extern int score7_register_move_cost (enum machine_mode mode ATTRIBUTE_UNUSED,\n-                                      enum reg_class from,\n-                                      enum reg_class to);\n-extern bool score7_rtx_costs (rtx x, int code, int outer_code, int *total, bool speed);\n-extern int score7_address_cost (rtx addr);\n-extern int score7_output_external (FILE *file ATTRIBUTE_UNUSED,\n-                                   tree decl,\n-                                   const char *name);\n-extern rtx score7_return_addr (int count, rtx frame ATTRIBUTE_UNUSED);\n-extern void score7_print_operand (FILE *file, rtx op, int c);\n-extern void score7_print_operand_address (FILE *file, rtx x);\n-extern enum machine_mode score7_select_cc_mode (enum rtx_code op,\n-                                                rtx x,\n-                                                rtx y);\n-extern void score7_prologue (void);\n-extern void score7_epilogue (int sibcall_p);\n-extern void score7_call (rtx *ops, bool sib);\n-extern void score7_call_value (rtx *ops, bool sib);\n-extern void score7_movsicc (rtx *ops);\n-extern void score7_movdi (rtx *ops);\n-extern void score7_zero_extract_andi (rtx *ops);\n-extern const char * score7_select_add_imm (rtx *ops, bool set_cc);\n-extern const char * score7_select (rtx *ops, const char *inst_pre, bool commu,\n-                                   const char *letter, bool set_cc);\n-extern const char * score7_move (rtx *ops);\n-extern const char * score7_limm (rtx *ops);\n-extern const char *\n-score7_linsn (rtx *ops, enum score_mem_unit unit, bool sign);\n-extern const char *\n-score7_sinsn (rtx *ops, enum score_mem_unit unit);\n-#endif"}, {"sha": "fd080c1b1fe008f32e921eaad0070466c65b0d3e", "filename": "gcc/config/score/t-score-elf", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7474f719762a83f06c295b5c7bdc27f55b1d089b/gcc%2Fconfig%2Fscore%2Ft-score-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7474f719762a83f06c295b5c7bdc27f55b1d089b/gcc%2Fconfig%2Fscore%2Ft-score-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Ft-score-elf?ref=7474f719762a83f06c295b5c7bdc27f55b1d089b", "patch": "@@ -16,13 +16,6 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-# Additional Backend Files\n-score7.o: $(srcdir)/config/score/score7.c $(CONFIG_H) $(SYSTEM_H) \\\n-  coretypes.h $(TM_H) $(RTL_H) output.h flags.h $(TREE_H) \\\n-  expr.h toplev.h $(TM_P_H)\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t$(srcdir)/config/score/score7.c\n-\n # Assemble startup files.\n $(T)crti.o: $(srcdir)/config/score/crti.asm $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\"}]}