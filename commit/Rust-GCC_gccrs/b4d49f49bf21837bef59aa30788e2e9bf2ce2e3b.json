{"sha": "b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRkNDlmNDliZjIxODM3YmVmNTlhYTMwNzg4ZTJlOWJmMmNlMmUzYg==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2004-08-12T06:53:42Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-08-12T06:53:42Z"}, "message": "javaprims.h (_Jv_Utf8Const): Change struct to a class, with private fields and access methods.\n\n\n\t* gcj/javaprims.h (_Jv_Utf8Const): Change struct to a class,\n\twith private fields and access methods.\n\t(_Jv_NewStringUTF, _Jv_hashUtf8String): New function declarations.\n\t* gcj/cni.h (_Jv_NewStringUTF): Move to javaprims.h.\n\t* prims.cc (_Jv_Utf8COnst::init): New method implementation.\n\t( _Jv_makeUtf8Const): Rewrite using new constructors.\n\t(hashUtf8String): Rename to +_Jv_hashUtf8String and make non-static.\n\t* defineclass.cc: Use new _Utf8Const access/convenience methods.\n\t* jni.cc: Likewise.\n\t* resolve.cc: Likewise.\n\t* gcj/field.h: Likewise.\n\t* include/jvm.h: Likewise.\n\t* java/lang/Class.h: Likewise.\n\t* java/lang/natClass.cc: Likwise.\n\t* java/lang/natClassLoader.cc: Likewise\n\t* java/lang/reflect/natMethod.cc: Likewise\n\t* verify.cc: Likewise.\n\t(_Jv_BytecodeVerifier::make_utf8_const):  Optimize.\n\t(~_Jv_BytecodeVerifier):  Don't need second _Jv_Free call.\n\nFrom-SVN: r85854", "tree": {"sha": "ddcf219c5b73f37a94e4a0d174408bc041874a8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddcf219c5b73f37a94e4a0d174408bc041874a8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fbac6f3cf5a007c9888d1fecdd647338f9eb623f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbac6f3cf5a007c9888d1fecdd647338f9eb623f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbac6f3cf5a007c9888d1fecdd647338f9eb623f"}], "stats": {"total": 280, "additions": 163, "deletions": 117}, "files": [{"sha": "1d2af7aba92bedaee746e198c54536a45547dda6", "filename": "libjava/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -1,3 +1,25 @@\n+2004-08-09  Per Bothner  <per@bothner.com>\n+\n+\t* gcj/javaprims.h (_Jv_Utf8Const): Change struct to a class,\n+\twith private fields and access methods.\n+\t(_Jv_NewStringUTF, _Jv_hashUtf8String): New function declarations.\n+\t* gcj/cni.h (_Jv_NewStringUTF): Move to javaprims.h.\n+\t* prims.cc (_Jv_Utf8COnst::init): New method implementation.\n+\t( _Jv_makeUtf8Const): Rewrite using new constructors.\n+\t(hashUtf8String): Rename to +_Jv_hashUtf8String and make non-static.\n+\t* defineclass.cc: Use new _Utf8Const access/convenience methods.\n+\t* jni.cc: Likewise.\n+\t* resolve.cc: Likewise.\n+\t* gcj/field.h: Likewise.\n+\t* include/jvm.h: Likewise.\n+\t* java/lang/Class.h: Likewise.\n+\t* java/lang/natClass.cc: Likwise.\n+\t* java/lang/natClassLoader.cc: Likewise\n+\t* java/lang/reflect/natMethod.cc: Likewise\n+\t* verify.cc: Likewise.\n+\t(_Jv_BytecodeVerifier::make_utf8_const):  Optimize.\n+\t(~_Jv_BytecodeVerifier):  Don't need second _Jv_Free call.\n+\n 2004-08-10  Andrew Haley  <aph@redhat.com>\n \n \t* testsuite/libjava.lang/err14.java: New file."}, {"sha": "ad40fc8f7fce6a054383c702beab10b1ca5b8208", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -337,7 +337,7 @@ _Jv_ClassReader::parse ()\n   // tell everyone we're done.\n   def->state = JV_STATE_LOADED;\n   if (gcj::verbose_class_flag)\n-    fprintf (stderr, \"[Loaded (bytecode) %s]\\n\", (const char*)(def->name->data));\n+    fprintf (stderr, \"[Loaded (bytecode) %s]\\n\", def->name->chars());\n   def->notifyAll ();\n \n }\n@@ -890,7 +890,7 @@ _Jv_ClassReader::handleClassBegin\n       jstring msg = JvNewStringUTF (\"loaded class \");\n       msg = msg->concat (def->getName ());\n       msg = msg->concat (_Jv_NewStringUTF (\" was in fact named \"));\n-      jstring klass_name = _Jv_NewStringUTF (loadedName->data);\n+      jstring klass_name = loadedName->toString();\n       msg = msg->concat (klass_name);\n \n       throw_no_class_def_found_error (msg);\n@@ -1367,8 +1367,8 @@ void _Jv_ClassReader::throw_class_format_error (char *msg)\n   if (def->name != NULL)\n     {\n       jsize mlen = strlen (msg);\n-      unsigned char* data = (unsigned char*) def->name->data;\n-      int ulen = def->name->length;\n+      unsigned char* data = (unsigned char*) def->name->chars();\n+      int ulen = def->name->len();\n       unsigned char* limit = data + ulen;\n       jsize nlen = _Jv_strLengthUtf8 ((char *) data, ulen);\n       jsize len = nlen + mlen + 3;\n@@ -1500,8 +1500,8 @@ _Jv_VerifyOne (unsigned char* ptr, unsigned char* limit, bool void_ok)\n bool\n _Jv_VerifyFieldSignature (_Jv_Utf8Const*sig)\n {\n-  unsigned char* ptr = (unsigned char*) sig->data;\n-  unsigned char* limit = ptr + sig->length;\n+  unsigned char* ptr = (unsigned char*) sig->chars();\n+  unsigned char* limit = ptr + sig->len();\n \n   ptr = _Jv_VerifyOne (ptr, limit, false);\n \n@@ -1511,8 +1511,8 @@ _Jv_VerifyFieldSignature (_Jv_Utf8Const*sig)\n bool\n _Jv_VerifyMethodSignature (_Jv_Utf8Const*sig)\n {\n-  unsigned char* ptr = (unsigned char*) sig->data;\n-  unsigned char* limit = ptr + sig->length;\n+  unsigned char* ptr = (unsigned char*) sig->chars();\n+  unsigned char* limit = ptr + sig->len();\n \n   if (ptr == limit || UTF8_GET(ptr,limit) != '(')\n     return false;\n@@ -1566,8 +1566,8 @@ is_identifier_part (int c)\n bool\n _Jv_VerifyIdentifier (_Jv_Utf8Const* name)\n {\n-  unsigned char *ptr   = (unsigned char*) name->data;\n-  unsigned char *limit = ptr + name->length;\n+  unsigned char *ptr   = (unsigned char*) name->chars();\n+  unsigned char *limit = (unsigned char*) name->limit();\n   int ch;\n \n   if ((ch = UTF8_GET (ptr, limit))==-1\n@@ -1622,17 +1622,16 @@ _Jv_VerifyClassName (unsigned char* ptr, _Jv_ushort length)\n bool\n _Jv_VerifyClassName (_Jv_Utf8Const *name)\n {\n-  return _Jv_VerifyClassName ((unsigned char*)&name->data[0],\n-\t\t\t      (_Jv_ushort) name->length);\n+  return _Jv_VerifyClassName ((unsigned char*)name->chars(), name->len());\n }\n \n /* Returns true, if NAME1 and NAME2 represent classes in the same\n    package.  */\n bool\n _Jv_ClassNameSamePackage (_Jv_Utf8Const *name1, _Jv_Utf8Const *name2)\n {\n-  unsigned char* ptr1 = (unsigned char*) name1->data;\n-  unsigned char* limit1 = ptr1 + name1->length;\n+  unsigned char* ptr1 = (unsigned char*) name1->chars();\n+  unsigned char* limit1 = (unsigned char*) name1->limit();\n \n   unsigned char* last1 = ptr1;\n \n@@ -1648,20 +1647,19 @@ _Jv_ClassNameSamePackage (_Jv_Utf8Const *name1, _Jv_Utf8Const *name2)\n   }\n \n   // Now the length of NAME1's package name is LEN.\n-  int len = last1 - (unsigned char*) name1->data;\n+  int len = last1 - (unsigned char*) name1->chars();\n \n   // If this is longer than NAME2, then we're off.\n-  if (len > name2->length)\n+  if (len > name2->len())\n     return false;\n \n   // Then compare the first len bytes for equality.\n-  if (memcmp ((void*) name1->data, (void*) name2->data, len) == 0)\n+  if (memcmp ((void*) name1->chars(), (void*) name2->chars(), len) == 0)\n     {\n       // Check that there are no .'s after position LEN in NAME2.\n \n-      unsigned char* ptr2 = (unsigned char*) name2->data + len;\n-      unsigned char* limit2 =\n-\t(unsigned char*) name2->data + name2->length;\n+      unsigned char* ptr2 = (unsigned char*) name2->chars() + len;\n+      unsigned char* limit2 = (unsigned char*) name2->limit();\n \n       while (ptr2 < limit2)\n \t{"}, {"sha": "ee39738d228c9147fbf010f59dfa3c9ff963ca07", "filename": "libjava/gcj/cni.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fgcj%2Fcni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fgcj%2Fcni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fcni.h?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -20,7 +20,6 @@ details.  */\n \n #include <string.h>\n \n-extern \"C\" jstring _Jv_NewStringUTF (const char *bytes);\n extern \"C\" void _Jv_InitClass (jclass);\n extern \"C\" void *_Jv_AllocBytes (jsize size) __attribute__((__malloc__));\n "}, {"sha": "bd6b2c38046edd58a7e020b8d944ac53b77c753f", "filename": "libjava/gcj/field.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fgcj%2Ffield.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fgcj%2Ffield.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Ffield.h?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -68,7 +68,7 @@ struct _Jv_Field\n     { \n       if (!isResolved ()) \n \t{\n-\t  char first = ((_Jv_Utf8Const*)type)->data[0]; \n+\t  char first = ((_Jv_Utf8Const*)type)->first(); \n \t  return first == '[' || first == 'L';\n \t}\n       else"}, {"sha": "09e0c5534c7addf81c7dd2d329d4e833ac66ce5d", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -472,10 +472,13 @@ extern jint _Jv_FormatInt (jchar* bufend, jint num);\n extern \"C\" jchar* _Jv_GetStringChars (jstring str);\n extern \"C\" void _Jv_MonitorEnter (jobject);\n extern \"C\" void _Jv_MonitorExit (jobject);\n+extern \"C\" jstring _Jv_NewStringUTF (const char *bytes)\n+  __attribute__((__malloc__));\n extern \"C\" jstring _Jv_NewStringLatin1(const char*, jsize)\n   __attribute__((__malloc__));\n extern \"C\" jsize _Jv_GetStringUTFLength (jstring);\n extern \"C\" jsize _Jv_GetStringUTFRegion (jstring, jsize, jsize, char *);\n+extern \"C\" jint _Jv_hashUtf8String (char*, int);\n \n extern jint _Jv_CreateJavaVM (void* /*vm_args*/);\n \n@@ -500,11 +503,40 @@ typedef unsigned short _Jv_ushort __attribute__((__mode__(__HI__)));\n typedef unsigned int _Jv_uint __attribute__((__mode__(__SI__)));\n typedef unsigned int _Jv_ulong __attribute__((__mode__(__DI__)));\n \n-struct _Jv_Utf8Const\n+class _Jv_Utf8Const\n {\n   _Jv_ushort hash;\n   _Jv_ushort length;\t/* In bytes, of data portion, without final '\\0'. */\n   char data[1];\t\t/* In Utf8 format, with final '\\0'. */\n+ public:\n+  /** Return same value of java.lang.String's hashCode. */\n+  jint hash32() { return _Jv_hashUtf8String(data, length); }\n+  /** Return a hash code that has at least 16 bits of information. */\n+  _Jv_ushort hash16 () { return hash; }\n+  /** Return a hash code that has at least 8 bits of information. */\n+  _Jv_ushort hash8 () { return hash; }\n+  /** Length in bytes of the UTF8-encoding. */\n+  _Jv_ushort len () const { return length; }\n+  /** Pointer to the first byte in the NUL-terminated UTF8-encoding. */\n+  char* chars() { return data; }\n+  /** Pointer to the NUL byte that terminated the UTF8-encoding. */\n+  char* limit() { return data+length; }\n+  /** Return the first byte in the UTF8-encoding. */\n+  char first() const { return data[0]; }\n+  /** Create a (non-interned) java.lang.String from this UTF8Const. */\n+  jstring toString() { return _Jv_NewStringUTF(data); }\n+  /** Given an UTF8 string, how many bytes needed for a UTF8Const,\n+      including struct header, and final NUL.  I.e. what to pas to malloc. */\n+  static int space_needed (char *, int len)\n+  { return sizeof (_Jv_Utf8Const) + len + 1; }\n+  /** Given an allocated _Jv_Utf8Const, copy / fill it in. */\n+  void init (char *s, int len);\n+  friend jboolean _Jv_equalUtf8Consts (const _Jv_Utf8Const*, const _Jv_Utf8Const *);\n+  friend jboolean _Jv_equal (_Jv_Utf8Const*, jstring, jint);\n+  friend jboolean _Jv_equaln (_Jv_Utf8Const*, jstring, jint);\n+  friend _Jv_Utf8Const *_Jv_makeUtf8Const (char*, int);\n+  friend _Jv_Utf8Const *_Jv_makeUtf8Const (jstring);\n+  friend jstring _Jv_NewStringUtf8Const (_Jv_Utf8Const*);\n };\n \n "}, {"sha": "554e3459a479bfb8fa5f4d618954f29cf5ac24f4", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -352,7 +352,7 @@ static inline jboolean _Jv_isVirtualMethod (_Jv_Method *meth)\n {\n   using namespace java::lang::reflect;\n   return (((meth->accflags & (Modifier::STATIC | Modifier::PRIVATE)) == 0)\n-          && meth->name->data[0] != '<');\n+          && meth->name->first() != '<');\n }\n \n // This function is used to determine the hash code of an object."}, {"sha": "f6c6eec510de88ff31b4337b0f67edf8472ed303", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -212,7 +212,7 @@ class java::lang::Class : public java::lang::Object\n \n   inline jboolean isArray (void)\n     {\n-      return name->data[0] == '[';\n+      return name->first() == '[';\n     }\n \n   inline jclass getComponentType (void)"}, {"sha": "f68f2a9a74d05ca1c95610f109a9411f1a17735b", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -83,7 +83,7 @@ java::lang::Class::forName (jstring className, jboolean initialize,\n     throw new java::lang::ClassNotFoundException (className);\n \n   jclass klass = (buffer[0] == '[' \n-\t\t  ? _Jv_FindClassFromSignature (name->data, loader)\n+\t\t  ? _Jv_FindClassFromSignature (name->chars(), loader)\n \t\t  : _Jv_FindClass (name, loader));\n \n   if (klass == NULL)\n@@ -443,10 +443,7 @@ java::lang::Class::getDeclaredMethods (void)\n jstring\n java::lang::Class::getName (void)\n {\n-  char buffer[name->length + 1];  \n-  memcpy (buffer, name->data, name->length); \n-  buffer[name->length] = '\\0';\n-  return _Jv_NewStringUTF (buffer);\n+  return name->toString();\n }\n \n JArray<jclass> *\n@@ -889,7 +886,7 @@ _Jv_FindMethodInCache (jclass klass,\n                        _Jv_Utf8Const *name,\n                        _Jv_Utf8Const *signature)\n {\n-  int index = name->hash & MCACHE_SIZE;\n+  int index = name->hash16() & MCACHE_SIZE;\n   _Jv_mcache *mc = method_cache + index;\n   _Jv_Method *m = mc->method;\n \n@@ -907,7 +904,7 @@ _Jv_AddMethodToCache (jclass klass,\n {\n   _Jv_MonitorEnter (&java::lang::Class::class$); \n \n-  int index = method->name->hash & MCACHE_SIZE;\n+  int index = method->name->hash16() & MCACHE_SIZE;\n \n   method_cache[index].method = method;\n   method_cache[index].klass = klass;\n@@ -1285,9 +1282,9 @@ _Jv_GenerateITable (jclass klass, _Jv_ifaces *ifaces, jshort *itable_offsets)\n jstring\n _Jv_GetMethodString (jclass klass, _Jv_Utf8Const *name)\n {\n-  jstring r = JvNewStringUTF (klass->name->data);\n+  jstring r = klass->name->toString();\n   r = r->concat (JvNewStringUTF (\".\"));\n-  r = r->concat (JvNewStringUTF (name->data));\n+  r = r->concat (name->toString());\n   return r;\n }\n \n@@ -1329,7 +1326,7 @@ _Jv_AppendPartialITable (jclass klass, jclass iface, void **itable,\n \t    break;\n \t}\n \n-      if (meth && (meth->name->data[0] == '<'))\n+      if (meth && (meth->name->first() == '<'))\n \t{\n \t  // leave a placeholder in the itable for hidden init methods.\n           itable[pos] = NULL;\t\n@@ -1588,8 +1585,7 @@ _Jv_LinkSymbolTable(jclass klass)\n \n       // We're looking for a field or a method, and we can tell\n       // which is needed by looking at the signature.\n-      if (signature->length >= 2\n-\t  && signature->data[0] == '(')\n+      if (signature->first() == '(' && signature->len() >= 2)\n \t{\n  \t  // If the target class does not have a vtable_method_count yet, \n \t  // then we can't tell the offsets for its methods, so we must lay \n@@ -1683,8 +1679,7 @@ _Jv_LinkSymbolTable(jclass klass)\n       \n       // We're looking for a static field or a static method, and we\n       // can tell which is needed by looking at the signature.\n-      if (signature->length >= 2\n-\t  && signature->data[0] == '(')\n+      if (signature->first() == '(' && signature->len() >= 2)\n \t{\n  \t  // If the target class does not have a vtable_method_count yet, \n \t  // then we can't tell the offsets for its methods, so we must lay \n@@ -1695,7 +1690,7 @@ _Jv_LinkSymbolTable(jclass klass)\n \t      _Jv_LayoutVTableMethods (target_class);\n \t    }\n \t  \n-\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n+\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name,\n \t\t\t\t\t  sym.signature);\n \t  \n \t  if (meth != NULL)\n@@ -1829,8 +1824,7 @@ _Jv_LayoutVTableMethods (jclass klass)\n \t  superclass = _Jv_FindClass (name, klass->loader);\n \t  if (! superclass)\n \t    {\n-\t      jstring str = _Jv_NewStringUTF (name->data);\n-\t      throw new java::lang::NoClassDefFoundError (str);\n+\t      throw new java::lang::NoClassDefFoundError (name->toString());\n \t    }\n \t}\n       else"}, {"sha": "1ff47b4b54da5ee5a054be3741f60831473cb268", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -52,7 +52,7 @@ _Jv_WaitForState (jclass klass, int state)\n     {\n       klass->state = JV_STATE_LOADED;\n       if (gcj::verbose_class_flag)\n-\tfprintf (stderr, \"[Loaded (pre-compiled) %s]\\n\", (const char*)(klass->name->data));\n+\tfprintf (stderr, \"[Loaded (pre-compiled) %s]\\n\", klass->name->chars());\n     }\n   if (state == JV_STATE_LINKED)\n     {\n@@ -110,15 +110,15 @@ _Jv_PrepareCompiledClass (jclass klass)\n \t  _Jv_Utf8Const *name = pool->data[index].utf8;\n \t  \n \t  jclass found;\n-\t  if (name->data[0] == '[')\n-\t    found = _Jv_FindClassFromSignature (&name->data[0],\n+\t  if (name->first() == '[')\n+\t    found = _Jv_FindClassFromSignature (name->chars(),\n \t\t\t\t\t\tklass->loader);\n \t  else\n \t    found = _Jv_FindClass (name, klass->loader);\n \t\t\n \t  if (! found)\n \t    {\n-\t      jstring str = _Jv_NewStringUTF (name->data);\n+\t      jstring str = name->toString();\n \t      throw new java::lang::NoClassDefFoundError (str);\n \t    }\n \n@@ -182,7 +182,7 @@ _Jv_PrepareCompiledClass (jclass klass)\n \n   if (state == JV_STATE_COMPILED && gcj::verbose_class_flag)\n     fprintf (stderr, \"[Loaded (pre-compiled) %s]\\n\",\n-\t     (const char*)(klass->name->data));\n+\t     klass->name->chars());\n \n   klass->notifyAll ();\n \n@@ -207,7 +207,7 @@ _Jv_PrepareCompiledClass (jclass klass)\n #define HASH_LEN 1013\n \n // Hash function for Utf8Consts.\n-#define HASH_UTF(Utf) (((Utf)->hash) % HASH_LEN)\n+#define HASH_UTF(Utf) ((Utf)->hash16() % HASH_LEN)\n \n struct _Jv_LoaderInfo\n {\n@@ -348,7 +348,7 @@ _Jv_RegisterClassHookDefault (jclass klass)\n \t  // We size-limit MESSAGE so that you can't trash the stack.\n \t  char message[200];\n \t  strcpy (message, TEXT);\n-\t  strncpy (message + sizeof (TEXT) - 1, klass->name->data,\n+\t  strncpy (message + sizeof (TEXT) - 1, klass->name->chars(),\n \t\t   sizeof (message) - sizeof (TEXT));\n \t  message[sizeof (message) - 1] = '\\0';\n \t  if (! gcj::runtimeInitialized)\n@@ -390,7 +390,7 @@ _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n \n   if (! klass)\n     {\n-      jstring sname = _Jv_NewStringUTF (name->data);\n+      jstring sname = name->toString();\n \n       java::lang::ClassLoader *sys\n \t= java::lang::ClassLoader::getSystemClassLoader ();\n@@ -470,7 +470,7 @@ _Jv_NewArrayClass (jclass element, java::lang::ClassLoader *loader,\n       len = 3;\n     }\n   else\n-    len = element->name->length + 5;\n+    len = element->name->len() + 5;\n \n   {\n     char signature[len];\n@@ -483,8 +483,8 @@ _Jv_NewArrayClass (jclass element, java::lang::ClassLoader *loader,\n       }\n     else\n       {\n-\tsize_t length = element->name->length;\n-\tconst char *const name = element->name->data;\n+\tsize_t length = element->name->len();\n+\tconst char *const name = element->name->chars();\n \tif (name[0] != '[')\n \t  signature[index++] = 'L';\n \tmemcpy (&signature[index], name, length);"}, {"sha": "58b1cf6fecd0e7b03256ab472ee3acd676543c5f", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -246,7 +246,7 @@ _Jv_GetTypesFromSignature (jmethodID method,\n \n   _Jv_Utf8Const* sig = method->signature;\n   java::lang::ClassLoader *loader = declaringClass->getClassLoaderInternal();\n-  char *ptr = sig->data;\n+  char *ptr = sig->chars();\n   int numArgs = 0;\n   /* First just count the number of parameters. */\n   for (; ; ptr++)\n@@ -283,7 +283,7 @@ _Jv_GetTypesFromSignature (jmethodID method,\n   JArray<jclass> *args = (JArray<jclass> *)\n     JvNewObjectArray (numArgs, &java::lang::Class::class$, NULL);\n   jclass* argPtr = elements (args);\n-  for (ptr = sig->data; *ptr != '\\0'; ptr++)\n+  for (ptr = sig->chars(); *ptr != '\\0'; ptr++)\n     {\n       int num_arrays = 0;\n       jclass type;"}, {"sha": "7943fe0ef046670feeaff54f6b345d2da1aa0383", "filename": "libjava/jni.cc", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -1880,8 +1880,8 @@ _Jv_JNI_RegisterNatives (JNIEnv *env, jclass klass,\n \t{\n \t  _Jv_Method *self = &imeths[i];\n \n-\t  if (! strcmp (self->name->data, methods[j].name)\n-\t      && ! strcmp (self->signature->data, methods[j].signature))\n+\t  if (! strcmp (self->name->chars (), methods[j].name)\n+\t      && ! strcmp (self->signature->chars (), methods[j].signature))\n \t    {\n \t      if (! (self->accflags\n \t\t     & java::lang::reflect::Modifier::NATIVE))\n@@ -1985,8 +1985,8 @@ mangled_name (jclass klass, _Jv_Utf8Const *func_name,\n   // Don't use add_char because we need a literal `_'.\n   buf[here++] = '_';\n \n-  const unsigned char *fn = (const unsigned char *) func_name->data;\n-  const unsigned char *limit = fn + func_name->length;\n+  const unsigned char *fn = (const unsigned char *) func_name->chars ();\n+  const unsigned char *limit = fn + func_name->len ();\n   for (int i = 0; ; ++i)\n     {\n       int ch = UTF8_GET (fn, limit);\n@@ -2000,8 +2000,8 @@ mangled_name (jclass klass, _Jv_Utf8Const *func_name,\n   buf[here++] = '_';\n   buf[here++] = '_';\n \n-  const unsigned char *sig = (const unsigned char *) signature->data;\n-  limit = sig + signature->length;\n+  const unsigned char *sig = (const unsigned char *) signature->chars ();\n+  limit = sig + signature->len ();\n   JvAssert (sig[0] == '(');\n   ++sig;\n   while (1)\n@@ -2058,21 +2058,23 @@ extern \"C\" void *\n _Jv_LookupJNIMethod (jclass klass, _Jv_Utf8Const *name,\n \t\t     _Jv_Utf8Const *signature, MAYBE_UNUSED int args_size)\n {\n-  char buf[10 + 6 * (name->length + signature->length) + 12];\n+  int name_length = name->len();\n+  int sig_length = signature->len();\n+  char buf[10 + 6 * (name_length + sig_length) + 12];\n   int long_start;\n   void *function;\n \n   // Synchronize on something convenient.  Right now we use the hash.\n   JvSynchronize sync (global_ref_table);\n \n   // First see if we have an override in the hash table.\n-  strncpy (buf, name->data, name->length);\n-  buf[name->length] = '\\0';\n-  strncpy (buf + name->length + 1, signature->data, signature->length);\n-  buf[name->length + signature->length + 1] = '\\0';\n+  strncpy (buf, name->chars (), name_length);\n+  buf[name_length] = '\\0';\n+  strncpy (buf + name_length + 1, signature->chars (), sig_length);\n+  buf[name_length + sig_length + 1] = '\\0';\n   JNINativeMethod meth;\n   meth.name = buf;\n-  meth.signature = buf + name->length + 1;\n+  meth.signature = buf + name_length + 1;\n   function = nathash_find (&meth);\n   if (function != NULL)\n     return function;\n@@ -2139,7 +2141,7 @@ _Jv_LookupJNIMethod (jclass klass, _Jv_Utf8Const *name,\n           if (function == NULL)\n #endif /* WIN32 */\n             {\n-              jstring str = JvNewStringUTF (name->data);\n+              jstring str = JvNewStringUTF (name->chars ());\n               throw new java::lang::UnsatisfiedLinkError (str);\n             }\n \t}"}, {"sha": "7f3276e77d866ff8c1eb9484133e185097f8afd5", "filename": "libjava/prims.cc", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -255,8 +255,8 @@ _Jv_strLengthUtf8(char* str, int len)\n /* Calculate a hash value for a string encoded in Utf8 format.\n  * This returns the same hash value as specified or java.lang.String.hashCode.\n  */\n-static jint\n-hashUtf8String (char* str, int len)\n+jint\n+_Jv_hashUtf8String (char* str, int len)\n {\n   unsigned char* ptr = (unsigned char*) str;\n   unsigned char* limit = ptr + len;\n@@ -272,17 +272,24 @@ hashUtf8String (char* str, int len)\n   return hash;\n }\n \n+void\n+_Jv_Utf8Const::init(char *s, int len)\n+{\n+  ::memcpy (data, s, len);\n+  data[len] = 0;\n+  length = len;\n+  hash = _Jv_hashUtf8String (s, len) & 0xFFFF;\n+}\n+\n _Jv_Utf8Const *\n _Jv_makeUtf8Const (char* s, int len)\n {\n   if (len < 0)\n     len = strlen (s);\n-  Utf8Const* m = (Utf8Const*) _Jv_AllocBytes (sizeof(Utf8Const) + len + 1);\n-  memcpy (m->data, s, len);\n-  m->data[len] = 0;\n-  m->length = len;\n-  m->hash = hashUtf8String (s, len) & 0xFFFF;\n-  return (m);\n+  Utf8Const* m\n+    = (Utf8Const*) _Jv_AllocBytes (_Jv_Utf8Const::space_needed(s, len));\n+  m->init(s, len);\n+  return m;\n }\n \n _Jv_Utf8Const *"}, {"sha": "5ebefebecef5d101b1654e6a7c1f87731de6131a", "filename": "libjava/resolve.cc", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -43,7 +43,7 @@ _Jv_ResolveField (_Jv_Field *field, java::lang::ClassLoader *loader)\n   if (! field->isResolved ())\n     {\n       _Jv_Utf8Const *sig = (_Jv_Utf8Const*)field->type;\n-      field->type = _Jv_FindClassFromSignature (sig->data, loader);\n+      field->type = _Jv_FindClassFromSignature (sig->chars(), loader);\n       field->flags &= ~_Jv_FIELD_UNRESOLVED_FLAG;\n     }\n }\n@@ -87,15 +87,15 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n       _Jv_Utf8Const *name = pool->data[index].utf8;\n \n       jclass found;\n-      if (name->data[0] == '[')\n-\tfound = _Jv_FindClassFromSignature (&name->data[0],\n+      if (name->first() == '[')\n+\tfound = _Jv_FindClassFromSignature (name->chars(),\n \t\t\t\t\t    klass->loader);\n       else\n \tfound = _Jv_FindClass (name, klass->loader);\n \n       if (! found)\n \t{\n-\t  jstring str = _Jv_NewStringUTF (name->data);\n+\t  jstring str = name->toString();\n \t  // This exception is specified in JLS 2nd Ed, section 5.1.\n \t  throw new java::lang::NoClassDefFoundError (str);\n \t}\n@@ -154,7 +154,7 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n       jclass field_type = 0;\n \n       if (owner->loader != klass->loader)\n-\tfield_type = _Jv_FindClassFromSignature (field_type_name->data,\n+\tfield_type = _Jv_FindClassFromSignature (field_type_name->chars(),\n \t\t\t\t\t\t klass->loader);\n       \n       _Jv_Field* the_field = 0;\n@@ -204,7 +204,7 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n \t  sb->append(JvNewStringLatin1(\"field \"));\n \t  sb->append(owner->getName());\n \t  sb->append(JvNewStringLatin1(\".\"));\n-\t  sb->append(_Jv_NewStringUTF(field_name->data));\n+\t  sb->append(field_name->toString());\n \t  sb->append(JvNewStringLatin1(\" was not found.\"));\n \t  throw_incompatible_class_change_error(sb->toString());\n \t}\n@@ -306,7 +306,7 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n \t  sb->append(JvNewStringLatin1(\"method \"));\n \t  sb->append(owner->getName());\n \t  sb->append(JvNewStringLatin1(\".\"));\n-\t  sb->append(_Jv_NewStringUTF(method_name->data));\n+\t  sb->append(method_name->toString());\n \t  sb->append(JvNewStringLatin1(\" was not found.\"));\n \t  throw new java::lang::NoSuchMethodError (sb->toString());\n \t}\n@@ -356,8 +356,8 @@ _Jv_SearchMethodInClass (jclass cls, jclass klass,\n \t  sb->append(JvNewStringLatin1(\": \"));\n \t  sb->append(cls->getName());\n \t  sb->append(JvNewStringLatin1(\".\"));\n-\t  sb->append(_Jv_NewStringUTF(method_name->data));\n-\t  sb->append(_Jv_NewStringUTF(method_signature->data));\n+\t  sb->append(method_name->toString());\n+\t  sb->append(method_signature->toString());\n \t  throw new java::lang::IllegalAccessError (sb->toString());\n \t}\n     }\n@@ -376,7 +376,7 @@ _Jv_PrepareMissingMethods (jclass base, jclass iface_class)\n \t{\n \t  _Jv_Method *meth = &iface_class->interfaces[i]->methods[j];\n \t  // Don't bother with <clinit>.\n-\t  if (meth->name->data[0] == '<')\n+\t  if (meth->name->first() == '<')\n \t    continue;\n \t  _Jv_Method *new_meth = _Jv_LookupDeclaredMethod (base, meth->name,\n \t\t\t\t\t\t\t   meth->signature);\n@@ -859,7 +859,7 @@ int\n _Jv_count_arguments (_Jv_Utf8Const *signature,\n \t\t     jboolean staticp)\n {\n-  unsigned char *ptr = (unsigned char*) signature->data;\n+  unsigned char *ptr = (unsigned char*) signature->chars();\n   int arg_count = staticp ? 0 : 1;\n \n   /* first, count number of arguments */\n@@ -890,7 +890,7 @@ init_cif (_Jv_Utf8Const* signature,\n \t  ffi_type **arg_types,\n \t  ffi_type **rtype_p)\n {\n-  unsigned char *ptr = (unsigned char*) signature->data;\n+  unsigned char *ptr = (unsigned char*) signature->chars();\n \n   int arg_index = 0;\t\t// arg number\n   int item_count = 0;\t\t// stack-item count\n@@ -923,7 +923,7 @@ init_cif (_Jv_Utf8Const* signature,\n   ffi_type *rtype = get_ffi_type_from_signature (ptr);\n \n   ptr = skip_one_type (ptr);\n-  if (ptr != (unsigned char*)signature->data + signature->length)\n+  if (ptr != (unsigned char*)signature->chars() + signature->len())\n     throw_internal_error (\"did not find end of signature\");\n \n   if (ffi_prep_cif (cif, FFI_DEFAULT_ABI,"}, {"sha": "85a50aaba679c2af84ab5cc2bce207124c983b97", "filename": "libjava/verify.cc", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "patch": "@@ -179,28 +179,21 @@ class _Jv_BytecodeVerifier\n   // This method.\n   _Jv_InterpMethod *current_method;\n \n-  // A linked list of utf8 objects we allocate.  This is really ugly,\n-  // but without this our utf8 objects would be collected.\n+  // A linked list of utf8 objects we allocate.\n   linked<_Jv_Utf8Const> *utf8_list;\n \n   // A linked list of all ref_intersection objects we allocate.\n   ref_intersection *isect_list;\n \n   // Create a new Utf-8 constant and return it.  We do this to avoid\n-  // having our Utf-8 constants prematurely collected.  FIXME this is\n-  // ugly.\n+  // having our Utf-8 constants prematurely collected.\n   _Jv_Utf8Const *make_utf8_const (char *s, int len)\n   {\n-    _Jv_Utf8Const *val = _Jv_makeUtf8Const (s, len);\n-    _Jv_Utf8Const *r = (_Jv_Utf8Const *) _Jv_Malloc (sizeof (_Jv_Utf8Const)\n-\t\t\t\t\t\t     + val->length\n-\t\t\t\t\t\t     + 1);\n-    r->length = val->length;\n-    r->hash = val->hash;\n-    memcpy (r->data, val->data, val->length + 1);\n-\n-    linked<_Jv_Utf8Const> *lu\n-      = (linked<_Jv_Utf8Const> *) _Jv_Malloc (sizeof (linked<_Jv_Utf8Const>));\n+    linked<_Jv_Utf8Const> *lu = (linked<_Jv_Utf8Const> *)\n+      _Jv_Malloc (sizeof (linked<_Jv_Utf8Const>)\n+\t\t  + _Jv_Utf8Const::space_needed(s, len));\n+    _Jv_Utf8Const *r = (_Jv_Utf8Const *) (lu + 1);\n+    r->init(s, len);\n     lu->val = r;\n     lu->next = utf8_list;\n     utf8_list = lu;\n@@ -226,9 +219,9 @@ class _Jv_BytecodeVerifier\n     buf->append (JvNewStringLatin1 (\" in \"));\n     buf->append (current_class->getName());\n     buf->append ((jchar) ':');\n-    buf->append (JvNewStringUTF (method->get_method()->name->data));\n+    buf->append (method->get_method()->name->toString());\n     buf->append ((jchar) '(');\n-    buf->append (JvNewStringUTF (method->get_method()->signature->data));\n+    buf->append (method->get_method()->signature->toString());\n     buf->append ((jchar) ')');\n \n     buf->append (JvNewStringLatin1 (\": \"));\n@@ -372,9 +365,8 @@ class _Jv_BytecodeVerifier\n       java::lang::ClassLoader *loader\n \t= verifier->current_class->getClassLoaderInternal();\n       // We might see either kind of name.  Sigh.\n-      if (data.name->data[0] == 'L'\n-\t  && data.name->data[data.name->length - 1] == ';')\n-\tdata.klass = _Jv_FindClassFromSignature (data.name->data, loader);\n+      if (data.name->first() == 'L' && data.name->limit()[-1] == ';')\n+\tdata.klass = _Jv_FindClassFromSignature (data.name->chars(), loader);\n       else\n \tdata.klass = Class::forName (_Jv_NewStringUtf8Const (data.name),\n \t\t\t\t     false, loader);\n@@ -422,7 +414,7 @@ class _Jv_BytecodeVerifier\n       if (is_resolved)\n \treturn data.klass->isArray ();\n       else\n-\treturn data.name->data[0] == '[';\n+\treturn data.name->first() == '[';\n     }\n \n     bool isinterface (_Jv_BytecodeVerifier *verifier)\n@@ -463,7 +455,7 @@ class _Jv_BytecodeVerifier\n \t}\n       else\n \t{\n-\t  char *p = data.name->data;\n+\t  char *p = data.name->chars();\n \t  while (*p++ == '[')\n \t    ++ndims;\n \t}\n@@ -1992,9 +1984,9 @@ class _Jv_BytecodeVerifier\n \t\t\t\t      &name, &field_type);\n     if (class_type)\n       *class_type = ct;\n-    if (field_type->data[0] == '[' || field_type->data[0] == 'L')\n+    if (field_type->first() == '[' || field_type->first() == 'L')\n       return type (field_type, this);\n-    return get_type_val_for_signature (field_type->data[0]);\n+    return get_type_val_for_signature (field_type->first());\n   }\n \n   type check_method_constant (int index, bool is_interface,\n@@ -2050,7 +2042,8 @@ class _Jv_BytecodeVerifier\n   void compute_argument_types (_Jv_Utf8Const *signature,\n \t\t\t       type *types)\n   {\n-    char *p = signature->data;\n+    char *p = signature->chars();\n+\n     // Skip `('.\n     ++p;\n \n@@ -2061,7 +2054,7 @@ class _Jv_BytecodeVerifier\n \n   type compute_return_type (_Jv_Utf8Const *signature)\n   {\n-    char *p = signature->data;\n+    char *p = signature->chars();\n     while (*p != ')')\n       ++p;\n     ++p;\n@@ -2845,7 +2838,7 @@ class _Jv_BytecodeVerifier\n \t\t  if (opcode != op_invokespecial)\n \t\t    verify_fail (\"can't invoke <init>\");\n \t\t}\n-\t      else if (method_name->data[0] == '<')\n+\t      else if (method_name->first() == '<')\n \t\tverify_fail (\"can't invoke method starting with `<'\");\n \n \t      // Pop arguments and check types.\n@@ -3060,7 +3053,7 @@ class _Jv_BytecodeVerifier\n     // We just print the text as utf-8.  This is just for debugging\n     // anyway.\n     debug_print (\"--------------------------------\\n\");\n-    debug_print (\"-- Verifying method `%s'\\n\", m->self->name->data);\n+    debug_print (\"-- Verifying method `%s'\\n\", m->self->name->chars());\n \n     current_method = m;\n     bytecode = m->bytecode ();\n@@ -3081,7 +3074,6 @@ class _Jv_BytecodeVerifier\n     while (utf8_list != NULL)\n       {\n \tlinked<_Jv_Utf8Const> *n = utf8_list->next;\n-\t_Jv_Free (utf8_list->val);\n \t_Jv_Free (utf8_list);\n \tutf8_list = n;\n       }"}]}