{"sha": "20c16b361d24eb2d17d27e2648bc6a37a3fced4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBjMTZiMzYxZDI0ZWIyZDE3ZDI3ZTI2NDhiYzZhMzdhM2ZjZWQ0ZQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-09-30T14:09:45Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-09-30T14:09:45Z"}, "message": "tree-ssa-alias.c (collect_points_to_info_r): Move analysis of expressions...\n\n\n\t* tree-ssa-alias.c (collect_points_to_info_r): Move analysis of\n\texpressions...\n\t(add_pointed_to_expr): ... here.\n\tCall add_pointed_to_expr for variables with DECL_INITIAL set.\n\t* tree-dfa.c (add_referenced_var): Scan DECL_INITIAL of any\n\tpointer variable, if set.\n\nFrom-SVN: r88334", "tree": {"sha": "da76cc450482bad41e8ad307309025d51eed105f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da76cc450482bad41e8ad307309025d51eed105f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20c16b361d24eb2d17d27e2648bc6a37a3fced4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c16b361d24eb2d17d27e2648bc6a37a3fced4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20c16b361d24eb2d17d27e2648bc6a37a3fced4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c16b361d24eb2d17d27e2648bc6a37a3fced4e/comments", "author": null, "committer": null, "parents": [{"sha": "8b0add272f78b9922c065eaadaa267db070f66eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b0add272f78b9922c065eaadaa267db070f66eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b0add272f78b9922c065eaadaa267db070f66eb"}], "stats": {"total": 178, "additions": 86, "deletions": 92}, "files": [{"sha": "29486e3c98341cbc608e8a55e20277bb2388c987", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c16b361d24eb2d17d27e2648bc6a37a3fced4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c16b361d24eb2d17d27e2648bc6a37a3fced4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20c16b361d24eb2d17d27e2648bc6a37a3fced4e", "patch": "@@ -1,3 +1,12 @@\n+2004-09-30  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa-alias.c (collect_points_to_info_r): Move analysis of\n+\texpressions...\n+\t(add_pointed_to_expr): ... here.\n+\tCall add_pointed_to_expr for variables with DECL_INITIAL set.\n+\t* tree-dfa.c (add_referenced_var): Scan DECL_INITIAL of any\n+\tpointer variable, if set.\n+\n 2004-09-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/sh/sh.c: Follow spelling conventions."}, {"sha": "29de6704041acfaf4d10cd193e756cf76823c1c4", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c16b361d24eb2d17d27e2648bc6a37a3fced4e/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c16b361d24eb2d17d27e2648bc6a37a3fced4e/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=20c16b361d24eb2d17d27e2648bc6a37a3fced4e", "patch": "@@ -891,12 +891,11 @@ add_referenced_var (tree var, struct walk_state *walk_state)\n       if (is_global_var (var))\n \tmark_call_clobbered (var);\n \n-      /* If an initialized global variable then register the initializer\n-\t as well.  */\n-      if (POINTER_TYPE_P (TREE_TYPE (var))\n-\t  && TREE_READONLY (var)\n-\t  && DECL_INITIAL (var)\n-\t  && TREE_CODE (DECL_INITIAL (var)) == ADDR_EXPR)\n+      /* Scan DECL_INITIAL for pointer variables as they may contain\n+\t address arithmetic referencing the address of other\n+\t variables.  */\n+      if (DECL_INITIAL (var)\n+\t  && POINTER_TYPE_P (TREE_TYPE (var)))\n       \twalk_tree (&DECL_INITIAL (var), find_vars_r, walk_state, 0);\n     }\n }"}, {"sha": "9dab4c676ac95524a4a829962066c887d2dcc858", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 72, "deletions": 86, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c16b361d24eb2d17d27e2648bc6a37a3fced4e/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c16b361d24eb2d17d27e2648bc6a37a3fced4e/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=20c16b361d24eb2d17d27e2648bc6a37a3fced4e", "patch": "@@ -147,7 +147,6 @@ static void setup_pointers_and_addressables (struct alias_info *);\n static bool collect_points_to_info_r (tree, tree, void *);\n static bool is_escape_site (tree, size_t *);\n static void add_pointed_to_var (struct alias_info *, tree, tree);\n-static void add_pointed_to_expr (tree, tree);\n static void create_global_var (void);\n static void collect_points_to_info_for (struct alias_info *, tree);\n static bool ptr_is_dereferenced_by (tree, tree, bool *);\n@@ -1753,41 +1752,78 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n }\n \n \n-/* Add VALUE to the list of expressions pointed-to by PTR.  */\n+/* Add EXPR to the list of expressions pointed-to by PTR.  */\n \n static void\n-add_pointed_to_expr (tree ptr, tree value)\n+add_pointed_to_expr (struct alias_info *ai, tree ptr, tree expr)\n {\n-  if (TREE_CODE (value) == WITH_SIZE_EXPR)\n-    value = TREE_OPERAND (value, 0);\n-\n-  /* Pointer variables should have been handled by merge_pointed_to_info.  */\n-  gcc_assert (TREE_CODE (value) != SSA_NAME\n-\t      || !POINTER_TYPE_P (TREE_TYPE (value)));\n+  if (TREE_CODE (expr) == WITH_SIZE_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n \n   get_ptr_info (ptr);\n \n-  /* If VALUE is the result of a malloc-like call, then the area pointed to\n-     PTR is guaranteed to not alias with anything else.  */\n-  if (TREE_CODE (value) == CALL_EXPR\n-      && (call_expr_flags (value) & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n-    set_pt_malloc (ptr);\n-  else\n-    set_pt_anything (ptr);\n-\n-  if (dump_file)\n+  if (TREE_CODE (expr) == CALL_EXPR\n+      && (call_expr_flags (expr) & (ECF_MALLOC | ECF_MAY_BE_ALLOCA)))\n     {\n-      struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+      /* If EXPR is a malloc-like call, then the area pointed to PTR\n+\t is guaranteed to not alias with anything else.  */\n+      set_pt_malloc (ptr);\n+    }\n+  else if (TREE_CODE (expr) == ADDR_EXPR)\n+    {\n+      /* Found P_i = ADDR_EXPR  */\n+      add_pointed_to_var (ai, ptr, expr);\n+    }\n+  else if (TREE_CODE (expr) == SSA_NAME && POINTER_TYPE_P (TREE_TYPE (expr)))\n+    {\n+      /* Found P_i = Q_j.  */\n+      merge_pointed_to_info (ai, ptr, expr);\n+    }\n+  else if (TREE_CODE (expr) == PLUS_EXPR || TREE_CODE (expr) == MINUS_EXPR)\n+    {\n+      /* Found P_i = PLUS_EXPR or P_i = MINUS_EXPR  */\n+      tree op0 = TREE_OPERAND (expr, 0);\n+      tree op1 = TREE_OPERAND (expr, 1);\n+\n+      /* Both operands may be of pointer type.  FIXME: Shouldn't\n+\t we just expect PTR + OFFSET always?  */\n+      if (POINTER_TYPE_P (TREE_TYPE (op0))\n+\t  && TREE_CODE (op0) != INTEGER_CST)\n+\t{\n+\t  if (TREE_CODE (op0) == SSA_NAME)\n+\t    merge_pointed_to_info (ai, ptr, op0);\n+\t  else if (TREE_CODE (op0) == ADDR_EXPR)\n+\t    add_pointed_to_var (ai, ptr, op0);\n+\t  else\n+\t    set_pt_anything (ptr);\n+\t}\n \n-      fprintf (dump_file, \"Pointer \");\n-      print_generic_expr (dump_file, ptr, dump_flags);\n-      fprintf (dump_file, \" points to \");\n-      if (pi->pt_malloc)\n-\tfprintf (dump_file, \"malloc space: \");\n-      else\n-\tfprintf (dump_file, \"an arbitrary address: \");\n-      print_generic_expr (dump_file, value, dump_flags);\n-      fprintf (dump_file, \"\\n\");\n+      if (POINTER_TYPE_P (TREE_TYPE (op1))\n+\t  && TREE_CODE (op1) != INTEGER_CST)\n+\t{\n+\t  if (TREE_CODE (op1) == SSA_NAME)\n+\t    merge_pointed_to_info (ai, ptr, op1);\n+\t  else if (TREE_CODE (op1) == ADDR_EXPR)\n+\t    add_pointed_to_var (ai, ptr, op1);\n+\t  else\n+\t    set_pt_anything (ptr);\n+\t}\n+\n+      /* Neither operand is a pointer?  VAR can be pointing anywhere.\n+\t FIXME: Shouldn't we abort here?  If we get here, we found\n+\t PTR = INT_CST + INT_CST, which should not be a valid pointer\n+\t expression.  */\n+      if (!(POINTER_TYPE_P (TREE_TYPE (op0))\n+\t    && TREE_CODE (op0) != INTEGER_CST)\n+\t  && !(POINTER_TYPE_P (TREE_TYPE (op1))\n+\t       && TREE_CODE (op1) != INTEGER_CST))\n+\tset_pt_anything (ptr);\n+    }\n+  else\n+    {\n+      /* If we can't recognize the expression, assume that PTR may\n+\t point anywhere.  */\n+      set_pt_anything (ptr);\n     }\n }\n \n@@ -1860,62 +1896,10 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n       {\n \ttree rhs = TREE_OPERAND (stmt, 1);\n \tSTRIP_NOPS (rhs);\n-\n-\t/* Found P_i = ADDR_EXPR  */\n-\tif (TREE_CODE (rhs) == ADDR_EXPR)\n-\t  add_pointed_to_var (ai, var, rhs);\n-\n-\t/* Found P_i = Q_j.  */\n-\telse if (TREE_CODE (rhs) == SSA_NAME\n-\t\t && POINTER_TYPE_P (TREE_TYPE (rhs)))\n-\t  merge_pointed_to_info (ai, var, rhs);\n-\n-\t/* Found P_i = PLUS_EXPR or P_i = MINUS_EXPR  */\n-\telse if (TREE_CODE (rhs) == PLUS_EXPR\n-\t\t || TREE_CODE (rhs) == MINUS_EXPR)\n-\t  {\n-\t    tree op0 = TREE_OPERAND (rhs, 0);\n-\t    tree op1 = TREE_OPERAND (rhs, 1);\n-\t    \n-\t    /* Both operands may be of pointer type.  FIXME: Shouldn't\n-\t       we just expect PTR + OFFSET always?  */\n-\t    if (POINTER_TYPE_P (TREE_TYPE (op0))\n-\t\t&& TREE_CODE (op0) != INTEGER_CST)\n-\t      {\n-\t\tif (TREE_CODE (op0) == SSA_NAME)\n-\t\t  merge_pointed_to_info (ai, var, op0);\n-\t\telse if (TREE_CODE (op0) == ADDR_EXPR)\n-\t\t  add_pointed_to_var (ai, var, op0);\n-\t\telse\n-\t\t  add_pointed_to_expr (var, op0);\n-\t      }\n-\n-\t    if (POINTER_TYPE_P (TREE_TYPE (op1))\n-\t\t&& TREE_CODE (op1) != INTEGER_CST)\n-\t      {\n-\t\tif (TREE_CODE (op1) == SSA_NAME)\n-\t\t  merge_pointed_to_info (ai, var, op1);\n-\t\telse if (TREE_CODE (op1) == ADDR_EXPR)\n-\t\t  add_pointed_to_var (ai, var, op1);\n-\t\telse\n-\t\t  add_pointed_to_expr (var, op1);\n-\t      }\n-\n-\t    /* Neither operand is a pointer?  VAR can be pointing\n-\t       anywhere.  FIXME: Is this right?  If we get here, we\n-\t       found PTR = INT_CST + INT_CST.  */\n-\t    if (!(POINTER_TYPE_P (TREE_TYPE (op0))\n-\t\t  && TREE_CODE (op0) != INTEGER_CST)\n-\t\t&& !(POINTER_TYPE_P (TREE_TYPE (op1))\n-\t\t     && TREE_CODE (op1) != INTEGER_CST))\n-\t      add_pointed_to_expr (var, rhs);\n-\t  }\n-\n-\t/* Something else.  */\n-\telse\n-\t  add_pointed_to_expr (var, rhs);\n+\tadd_pointed_to_expr (ai, var, rhs);\n \tbreak;\n       }\n+\n     case ASM_EXPR:\n       /* Pointers defined by __asm__ statements can point anywhere.  */\n       set_pt_anything (var);\n@@ -1927,13 +1911,14 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n \t  tree decl = SSA_NAME_VAR (var);\n \t  \n \t  if (TREE_CODE (decl) == PARM_DECL)\n-\t    add_pointed_to_expr (var, decl);\n+\t    add_pointed_to_expr (ai, var, decl);\n \t  else if (DECL_INITIAL (decl))\n-\t    add_pointed_to_var (ai, var, DECL_INITIAL (decl));\n+\t    add_pointed_to_expr (ai, var, DECL_INITIAL (decl));\n \t  else\n-\t    add_pointed_to_expr (var, decl);\n+\t    add_pointed_to_expr (ai, var, decl);\n \t}\n       break;\n+\n     case PHI_NODE:\n       {\n         /* It STMT is a PHI node, then VAR is one of its arguments.  The\n@@ -1952,11 +1937,12 @@ collect_points_to_info_r (tree var, tree stmt, void *data)\n \t    \n \t  default:\n \t    gcc_assert (is_gimple_min_invariant (var));\n-\t    add_pointed_to_expr (lhs, var);\n+\t    add_pointed_to_expr (ai, lhs, var);\n \t    break;\n \t  }\n \tbreak;\n       }\n+\n     default:\n       gcc_unreachable ();\n     }"}]}