{"sha": "76bbe3972ba78757abdb3bb06cccc0b461914b01", "node_id": "C_kwDOANBUbNoAKDc2YmJlMzk3MmJhNzg3NTdhYmRiM2JiMDZjY2NjMGI0NjE5MTRiMDE", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-11-15T20:36:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-12-02T16:26:20Z"}, "message": "[Ada] Proof of Interfaces.C with SPARK\n\ngcc/ada/\n\n\t* libgnat/i-c.adb: Add ghost code.\n\t(C_Length_Ghost): New ghost functions to query the C length of a\n\tstring.\n\t(To_Ada): Insert constant Count_Cst where needed to comply with\n\tSPARK.  Homogeneize code between variants for char, wchar_t,\n\tchar16_t and char32_t. Use char16_nul and char32_nul\n\tsystematically instead of their value. Fix the type of index To\n\tto be Integer instead of Positive, to avoid a possible range\n\tcheck failure on an empty Target. Insert an exit statement to\n\tavoid a possible overflow failure when the last index in Target\n\tis Natural'Last (possibly on a small string as well).\n\t* libgnat/i-c.ads: Add contracts.\n\t(C_Length_Ghost): New ghost functions to query the C length of a\n\tstring.\n\t* libgnat/s-os_lib.adb: Remove pragma Compiler_Unit_Warning\n\tcausing a spurious error during compilation of GNAT, as this\n\tpragma is not needed anymore now that we bootstrap (stage1) with\n\tthe base compiler runtime.", "tree": {"sha": "ebef10b159d8b7902a3e2129ae1d438b6d0b9b1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebef10b159d8b7902a3e2129ae1d438b6d0b9b1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76bbe3972ba78757abdb3bb06cccc0b461914b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76bbe3972ba78757abdb3bb06cccc0b461914b01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76bbe3972ba78757abdb3bb06cccc0b461914b01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76bbe3972ba78757abdb3bb06cccc0b461914b01/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e650bf84bf61e88f05ffbf39ca677a1e3d2714a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e650bf84bf61e88f05ffbf39ca677a1e3d2714a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e650bf84bf61e88f05ffbf39ca677a1e3d2714a"}], "stats": {"total": 894, "additions": 825, "deletions": 69}, "files": [{"sha": "4ec920f7cab41706b4a71ff771074892e51663c4", "filename": "gcc/ada/libgnat/i-c.adb", "status": "modified", "additions": 436, "deletions": 36, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bbe3972ba78757abdb3bb06cccc0b461914b01/gcc%2Fada%2Flibgnat%2Fi-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bbe3972ba78757abdb3bb06cccc0b461914b01/gcc%2Fada%2Flibgnat%2Fi-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fi-c.adb?ref=76bbe3972ba78757abdb3bb06cccc0b461914b01", "patch": "@@ -29,7 +29,77 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body Interfaces.C is\n+--  Ghost code, loop invariants and assertions in this unit are meant for\n+--  analysis only, not for run-time checking, as it would be too costly\n+--  otherwise. This is enforced by setting the assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n+package body Interfaces.C\n+  with SPARK_Mode\n+is\n+\n+   --------------------\n+   -- C_Length_Ghost --\n+   --------------------\n+\n+   function C_Length_Ghost (Item : char_array) return size_t is\n+   begin\n+      for J in Item'Range loop\n+         if Item (J) = nul then\n+            return J - Item'First;\n+         end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Item (K) /= nul);\n+      end loop;\n+\n+      raise Program_Error;\n+   end C_Length_Ghost;\n+\n+   function C_Length_Ghost (Item : wchar_array) return size_t is\n+   begin\n+      for J in Item'Range loop\n+         if Item (J) = wide_nul then\n+            return J - Item'First;\n+         end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Item (K) /= wide_nul);\n+      end loop;\n+\n+      raise Program_Error;\n+   end C_Length_Ghost;\n+\n+   function C_Length_Ghost (Item : char16_array) return size_t is\n+   begin\n+      for J in Item'Range loop\n+         if Item (J) = char16_nul then\n+            return J - Item'First;\n+         end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Item (K) /= char16_nul);\n+      end loop;\n+\n+      raise Program_Error;\n+   end C_Length_Ghost;\n+\n+   function C_Length_Ghost (Item : char32_array) return size_t is\n+   begin\n+      for J in Item'Range loop\n+         if Item (J) = char32_nul then\n+            return J - Item'First;\n+         end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Item (K) /= char32_nul);\n+      end loop;\n+\n+      raise Program_Error;\n+   end C_Length_Ghost;\n \n    -----------------------\n    -- Is_Nul_Terminated --\n@@ -43,6 +113,9 @@ package body Interfaces.C is\n          if Item (J) = nul then\n             return True;\n          end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Item (K) /= nul);\n       end loop;\n \n       return False;\n@@ -56,6 +129,9 @@ package body Interfaces.C is\n          if Item (J) = wide_nul then\n             return True;\n          end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Item (K) /= wide_nul);\n       end loop;\n \n       return False;\n@@ -69,6 +145,9 @@ package body Interfaces.C is\n          if Item (J) = char16_nul then\n             return True;\n          end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Item (K) /= char16_nul);\n       end loop;\n \n       return False;\n@@ -82,6 +161,9 @@ package body Interfaces.C is\n          if Item (J) = char32_nul then\n             return True;\n          end if;\n+\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Item (K) /= char32_nul);\n       end loop;\n \n       return False;\n@@ -112,6 +194,13 @@ package body Interfaces.C is\n          From := Item'First;\n \n          loop\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant\n+              (for some J in From .. Item'Last => Item (J) = nul);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From when J /= From =>\n+                 Item (J) /= nul);\n+\n             if From > Item'Last then\n                raise Terminator_Error;\n             elsif Item (From) = nul then\n@@ -121,18 +210,26 @@ package body Interfaces.C is\n             end if;\n          end loop;\n \n+         pragma Assert (From = Item'First + C_Length_Ghost (Item));\n+\n          Count := Natural (From - Item'First);\n \n       else\n          Count := Item'Length;\n       end if;\n \n       declare\n-         R : String (1 .. Count);\n+         Count_Cst : constant Natural := Count;\n+         R : String (1 .. Count_Cst) with Relaxed_Initialization;\n \n       begin\n          for J in R'Range loop\n-            R (J) := To_Ada (Item (size_t (J) + (Item'First - 1)));\n+            R (J) := To_Ada (Item (size_t (J) - 1 + Item'First));\n+\n+            pragma Loop_Invariant (for all K in 1 .. J => R (K)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in 1 .. J =>\n+                R (K) = To_Ada (Item (size_t (K) - 1 + Item'First)));\n          end loop;\n \n          return R;\n@@ -148,12 +245,19 @@ package body Interfaces.C is\n       Trim_Nul : Boolean := True)\n    is\n       From : size_t;\n-      To   : Positive;\n+      To   : Integer;\n \n    begin\n       if Trim_Nul then\n          From := Item'First;\n          loop\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant\n+              (for some J in From .. Item'Last => Item (J) = nul);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From when J /= From =>\n+                Item (J) /= nul);\n+\n             if From > Item'Last then\n                raise Terminator_Error;\n             elsif Item (From) = nul then\n@@ -178,11 +282,28 @@ package body Interfaces.C is\n \n          for J in 1 .. Count loop\n             Target (To) := Character (Item (From));\n+\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant (To in Target'Range);\n+            pragma Loop_Invariant (To = Target'First + (J - 1));\n+            pragma Loop_Invariant (From = Item'First + size_t (J - 1));\n+            pragma Loop_Invariant\n+              (for all J in Target'First .. To => Target (J)'Initialized);\n+            pragma Loop_Invariant\n+              (Target (Target'First .. To)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Target'First .. To =>\n+                Target (K) =\n+                  To_Ada (Item (size_t (K - Target'First) + Item'First)));\n+\n+            --  Avoid possible overflow when incrementing To in the last\n+            --  iteration of the loop.\n+            exit when J = Count;\n+\n             From := From + 1;\n             To   := To + 1;\n          end loop;\n       end if;\n-\n    end To_Ada;\n \n    --  Convert wchar_t to Wide_Character\n@@ -206,6 +327,13 @@ package body Interfaces.C is\n          From := Item'First;\n \n          loop\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant\n+              (for some J in From .. Item'Last => Item (J) = wide_nul);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From when J /= From =>\n+                 Item (J) /= wide_nul);\n+\n             if From > Item'Last then\n                raise Terminator_Error;\n             elsif Item (From) = wide_nul then\n@@ -215,18 +343,26 @@ package body Interfaces.C is\n             end if;\n          end loop;\n \n+         pragma Assert (From = Item'First + C_Length_Ghost (Item));\n+\n          Count := Natural (From - Item'First);\n \n       else\n          Count := Item'Length;\n       end if;\n \n       declare\n-         R : Wide_String (1 .. Count);\n+         Count_Cst : constant Natural := Count;\n+         R : Wide_String (1 .. Count_Cst) with Relaxed_Initialization;\n \n       begin\n          for J in R'Range loop\n-            R (J) := To_Ada (Item (size_t (J) + (Item'First - 1)));\n+            R (J) := To_Ada (Item (size_t (J) - 1 + Item'First));\n+\n+            pragma Loop_Invariant (for all K in 1 .. J => R (K)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in 1 .. J =>\n+                R (K) = To_Ada (Item (size_t (K) - 1 + Item'First)));\n          end loop;\n \n          return R;\n@@ -242,12 +378,19 @@ package body Interfaces.C is\n       Trim_Nul : Boolean := True)\n    is\n       From : size_t;\n-      To   : Positive;\n+      To   : Integer;\n \n    begin\n       if Trim_Nul then\n          From := Item'First;\n          loop\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant\n+              (for some J in From .. Item'Last => Item (J) = wide_nul);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From when J /= From =>\n+                Item (J) /= wide_nul);\n+\n             if From > Item'Last then\n                raise Terminator_Error;\n             elsif Item (From) = wide_nul then\n@@ -272,6 +415,24 @@ package body Interfaces.C is\n \n          for J in 1 .. Count loop\n             Target (To) := To_Ada (Item (From));\n+\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant (To in Target'Range);\n+            pragma Loop_Invariant (To = Target'First + (J - 1));\n+            pragma Loop_Invariant (From = Item'First + size_t (J - 1));\n+            pragma Loop_Invariant\n+              (for all J in Target'First .. To => Target (J)'Initialized);\n+            pragma Loop_Invariant\n+              (Target (Target'First .. To)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Target'First .. To =>\n+                Target (K) =\n+                  To_Ada (Item (size_t (K - Target'First) + Item'First)));\n+\n+            --  Avoid possible overflow when incrementing To in the last\n+            --  iteration of the loop.\n+            exit when J = Count;\n+\n             From := From + 1;\n             To   := To + 1;\n          end loop;\n@@ -299,27 +460,42 @@ package body Interfaces.C is\n          From := Item'First;\n \n          loop\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant\n+              (for some J in From .. Item'Last => Item (J) = char16_nul);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From when J /= From =>\n+                 Item (J) /= char16_nul);\n+\n             if From > Item'Last then\n                raise Terminator_Error;\n-            elsif Item (From) = char16_t'Val (0) then\n+            elsif Item (From) = char16_nul then\n                exit;\n             else\n                From := From + 1;\n             end if;\n          end loop;\n \n+         pragma Assert (From = Item'First + C_Length_Ghost (Item));\n+\n          Count := Natural (From - Item'First);\n \n       else\n          Count := Item'Length;\n       end if;\n \n       declare\n-         R : Wide_String (1 .. Count);\n+         Count_Cst : constant Natural := Count;\n+         R : Wide_String (1 .. Count_Cst) with Relaxed_Initialization;\n \n       begin\n          for J in R'Range loop\n-            R (J) := To_Ada (Item (size_t (J) + (Item'First - 1)));\n+            R (J) := To_Ada (Item (size_t (J) - 1 + Item'First));\n+\n+            pragma Loop_Invariant (for all K in 1 .. J => R (K)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in 1 .. J =>\n+                R (K) = To_Ada (Item (size_t (K) - 1 + Item'First)));\n          end loop;\n \n          return R;\n@@ -335,15 +511,22 @@ package body Interfaces.C is\n       Trim_Nul : Boolean := True)\n    is\n       From : size_t;\n-      To   : Positive;\n+      To   : Integer;\n \n    begin\n       if Trim_Nul then\n          From := Item'First;\n          loop\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant\n+              (for some J in From .. Item'Last => Item (J) = char16_nul);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From when J /= From =>\n+                Item (J) /= char16_nul);\n+\n             if From > Item'Last then\n                raise Terminator_Error;\n-            elsif Item (From) = char16_t'Val (0) then\n+            elsif Item (From) = char16_nul then\n                exit;\n             else\n                From := From + 1;\n@@ -365,6 +548,24 @@ package body Interfaces.C is\n \n          for J in 1 .. Count loop\n             Target (To) := To_Ada (Item (From));\n+\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant (To in Target'Range);\n+            pragma Loop_Invariant (To = Target'First + (J - 1));\n+            pragma Loop_Invariant (From = Item'First + size_t (J - 1));\n+            pragma Loop_Invariant\n+              (for all J in Target'First .. To => Target (J)'Initialized);\n+            pragma Loop_Invariant\n+              (Target (Target'First .. To)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Target'First .. To =>\n+                Target (K) =\n+                  To_Ada (Item (size_t (K - Target'First) + Item'First)));\n+\n+            --  Avoid possible overflow when incrementing To in the last\n+            --  iteration of the loop.\n+            exit when J = Count;\n+\n             From := From + 1;\n             To   := To + 1;\n          end loop;\n@@ -392,27 +593,42 @@ package body Interfaces.C is\n          From := Item'First;\n \n          loop\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant\n+              (for some J in From .. Item'Last => Item (J) = char32_nul);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From when J /= From =>\n+                 Item (J) /= char32_nul);\n+\n             if From > Item'Last then\n                raise Terminator_Error;\n-            elsif Item (From) = char32_t'Val (0) then\n+            elsif Item (From) = char32_nul then\n                exit;\n             else\n                From := From + 1;\n             end if;\n          end loop;\n \n+         pragma Assert (From = Item'First + C_Length_Ghost (Item));\n+\n          Count := Natural (From - Item'First);\n \n       else\n          Count := Item'Length;\n       end if;\n \n       declare\n-         R : Wide_Wide_String (1 .. Count);\n+         Count_Cst : constant Natural := Count;\n+         R : Wide_Wide_String (1 .. Count_Cst) with Relaxed_Initialization;\n \n       begin\n          for J in R'Range loop\n-            R (J) := To_Ada (Item (size_t (J) + (Item'First - 1)));\n+            R (J) := To_Ada (Item (size_t (J) - 1 + Item'First));\n+\n+            pragma Loop_Invariant (for all K in 1 .. J => R (K)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in 1 .. J =>\n+                R (K) = To_Ada (Item (size_t (K) - 1 + Item'First)));\n          end loop;\n \n          return R;\n@@ -428,15 +644,22 @@ package body Interfaces.C is\n       Trim_Nul : Boolean := True)\n    is\n       From : size_t;\n-      To   : Positive;\n+      To   : Integer;\n \n    begin\n       if Trim_Nul then\n          From := Item'First;\n          loop\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant\n+              (for some J in From .. Item'Last => Item (J) = char32_nul);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From when J /= From =>\n+                Item (J) /= char32_nul);\n+\n             if From > Item'Last then\n                raise Terminator_Error;\n-            elsif Item (From) = char32_t'Val (0) then\n+            elsif Item (From) = char32_nul then\n                exit;\n             else\n                From := From + 1;\n@@ -458,6 +681,24 @@ package body Interfaces.C is\n \n          for J in 1 .. Count loop\n             Target (To) := To_Ada (Item (From));\n+\n+            pragma Loop_Invariant (From in Item'Range);\n+            pragma Loop_Invariant (To in Target'Range);\n+            pragma Loop_Invariant (To = Target'First + (J - 1));\n+            pragma Loop_Invariant (From = Item'First + size_t (J - 1));\n+            pragma Loop_Invariant\n+              (for all J in Target'First .. To => Target (J)'Initialized);\n+            pragma Loop_Invariant\n+              (Target (Target'First .. To)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Target'First .. To =>\n+                Target (K) =\n+                  To_Ada (Item (size_t (K - Target'First) + Item'First)));\n+\n+            --  Avoid possible overflow when incrementing To in the last\n+            --  iteration of the loop.\n+            exit when J = Count;\n+\n             From := From + 1;\n             To   := To + 1;\n          end loop;\n@@ -484,14 +725,26 @@ package body Interfaces.C is\n    begin\n       if Append_Nul then\n          declare\n-            R : char_array (0 .. Item'Length);\n+            R : char_array (0 .. Item'Length) with Relaxed_Initialization;\n \n          begin\n             for J in Item'Range loop\n                R (size_t (J - Item'First)) := To_C (Item (J));\n+\n+               pragma Loop_Invariant\n+                 (for all K in 0 .. size_t (J - Item'First) =>\n+                    R (K)'Initialized);\n+               pragma Loop_Invariant\n+                 (for all K in Item'First .. J =>\n+                    R (size_t (K - Item'First)) = To_C (Item (K)));\n             end loop;\n \n             R (R'Last) := nul;\n+\n+            pragma Assert\n+              (for all J in Item'Range =>\n+                 R (size_t (J - Item'First)) = To_C (Item (J)));\n+\n             return R;\n          end;\n \n@@ -512,11 +765,19 @@ package body Interfaces.C is\n \n          else\n             declare\n-               R : char_array (0 .. Item'Length - 1);\n+               R : char_array (0 .. Item'Length - 1)\n+                 with Relaxed_Initialization;\n \n             begin\n                for J in Item'Range loop\n                   R (size_t (J - Item'First)) := To_C (Item (J));\n+\n+                  pragma Loop_Invariant\n+                    (for all K in 0 .. size_t (J - Item'First) =>\n+                       R (K)'Initialized);\n+                  pragma Loop_Invariant\n+                    (for all K in Item'First .. J =>\n+                       R (size_t (K - Item'First)) = To_C (Item (K)));\n                end loop;\n \n                return R;\n@@ -543,6 +804,19 @@ package body Interfaces.C is\n          To := Target'First;\n          for From in Item'Range loop\n             Target (To) := char (Item (From));\n+\n+            pragma Loop_Invariant (To in Target'Range);\n+            pragma Loop_Invariant\n+              (To - Target'First = size_t (From - Item'First));\n+            pragma Loop_Invariant\n+              (for all J in Target'First .. To => Target (J)'Initialized);\n+            pragma Loop_Invariant\n+              (Target (Target'First .. To)'Initialized);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From =>\n+                 Target (Target'First + size_t (J - Item'First)) =\n+                   To_C (Item (J)));\n+\n             To := To + 1;\n          end loop;\n \n@@ -576,14 +850,26 @@ package body Interfaces.C is\n    begin\n       if Append_Nul then\n          declare\n-            R : wchar_array (0 .. Item'Length);\n+            R : wchar_array (0 .. Item'Length) with Relaxed_Initialization;\n \n          begin\n             for J in Item'Range loop\n                R (size_t (J - Item'First)) := To_C (Item (J));\n+\n+               pragma Loop_Invariant\n+                 (for all K in 0 .. size_t (J - Item'First) =>\n+                    R (K)'Initialized);\n+               pragma Loop_Invariant\n+                 (for all K in Item'First .. J =>\n+                    R (size_t (K - Item'First)) = To_C (Item (K)));\n             end loop;\n \n             R (R'Last) := wide_nul;\n+\n+            pragma Assert\n+              (for all J in Item'Range =>\n+                 R (size_t (J - Item'First)) = To_C (Item (J)));\n+\n             return R;\n          end;\n \n@@ -600,11 +886,19 @@ package body Interfaces.C is\n \n          else\n             declare\n-               R : wchar_array (0 .. Item'Length - 1);\n+               R : wchar_array (0 .. Item'Length - 1)\n+                 with Relaxed_Initialization;\n \n             begin\n-               for J in size_t range 0 .. Item'Length - 1 loop\n-                  R (J) := To_C (Item (Integer (J) + Item'First));\n+               for J in Item'Range loop\n+                  R (size_t (J - Item'First)) := To_C (Item (J));\n+\n+                  pragma Loop_Invariant\n+                    (for all K in 0 .. size_t (J - Item'First) =>\n+                       R (K)'Initialized);\n+                  pragma Loop_Invariant\n+                    (for all K in Item'First .. J =>\n+                       R (size_t (K - Item'First)) = To_C (Item (K)));\n                end loop;\n \n                return R;\n@@ -631,9 +925,31 @@ package body Interfaces.C is\n          To := Target'First;\n          for From in Item'Range loop\n             Target (To) := To_C (Item (From));\n+\n+            pragma Loop_Invariant (To in Target'Range);\n+            pragma Loop_Invariant\n+              (To - Target'First = size_t (From - Item'First));\n+            pragma Loop_Invariant\n+              (for all J in Target'First .. To => Target (J)'Initialized);\n+            pragma Loop_Invariant\n+              (Target (Target'First .. To)'Initialized);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From =>\n+                Target (Target'First + size_t (J - Item'First)) =\n+                  To_C (Item (J)));\n+\n             To := To + 1;\n          end loop;\n \n+         pragma Assert\n+           (for all J in Item'Range =>\n+             Target (Target'First + size_t (J - Item'First)) =\n+               To_C (Item (J)));\n+         pragma Assert\n+           (if Item'Length /= 0 then\n+             Target (Target'First ..\n+                     Target'First + (Item'Length - 1))'Initialized);\n+\n          if Append_Nul then\n             if To > Target'Last then\n                raise Constraint_Error;\n@@ -664,14 +980,26 @@ package body Interfaces.C is\n    begin\n       if Append_Nul then\n          declare\n-            R : char16_array (0 .. Item'Length);\n+            R : char16_array (0 .. Item'Length) with Relaxed_Initialization;\n \n          begin\n             for J in Item'Range loop\n                R (size_t (J - Item'First)) := To_C (Item (J));\n+\n+               pragma Loop_Invariant\n+                 (for all K in 0 .. size_t (J - Item'First) =>\n+                    R (K)'Initialized);\n+               pragma Loop_Invariant\n+                 (for all K in Item'First .. J =>\n+                    R (size_t (K - Item'First)) = To_C (Item (K)));\n             end loop;\n \n-            R (R'Last) := char16_t'Val (0);\n+            R (R'Last) := char16_nul;\n+\n+            pragma Assert\n+              (for all J in Item'Range =>\n+                 R (size_t (J - Item'First)) = To_C (Item (J)));\n+\n             return R;\n          end;\n \n@@ -688,11 +1016,19 @@ package body Interfaces.C is\n \n          else\n             declare\n-               R : char16_array (0 .. Item'Length - 1);\n+               R : char16_array (0 .. Item'Length - 1)\n+                 with Relaxed_Initialization;\n \n             begin\n-               for J in size_t range 0 .. Item'Length - 1 loop\n-                  R (J) := To_C (Item (Integer (J) + Item'First));\n+               for J in Item'Range loop\n+                  R (size_t (J - Item'First)) := To_C (Item (J));\n+\n+                  pragma Loop_Invariant\n+                    (for all K in 0 .. size_t (J - Item'First) =>\n+                       R (K)'Initialized);\n+                  pragma Loop_Invariant\n+                    (for all K in Item'First .. J =>\n+                       R (size_t (K - Item'First)) = To_C (Item (K)));\n                end loop;\n \n                return R;\n@@ -719,14 +1055,36 @@ package body Interfaces.C is\n          To := Target'First;\n          for From in Item'Range loop\n             Target (To) := To_C (Item (From));\n+\n+            pragma Loop_Invariant (To in Target'Range);\n+            pragma Loop_Invariant\n+              (To - Target'First = size_t (From - Item'First));\n+            pragma Loop_Invariant\n+              (for all J in Target'First .. To => Target (J)'Initialized);\n+            pragma Loop_Invariant\n+              (Target (Target'First .. To)'Initialized);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From =>\n+                Target (Target'First + size_t (J - Item'First)) =\n+                  To_C (Item (J)));\n+\n             To := To + 1;\n          end loop;\n \n+         pragma Assert\n+           (for all J in Item'Range =>\n+             Target (Target'First + size_t (J - Item'First)) =\n+               To_C (Item (J)));\n+         pragma Assert\n+           (if Item'Length /= 0 then\n+             Target (Target'First ..\n+                     Target'First + (Item'Length - 1))'Initialized);\n+\n          if Append_Nul then\n             if To > Target'Last then\n                raise Constraint_Error;\n             else\n-               Target (To) := char16_t'Val (0);\n+               Target (To) := char16_nul;\n                Count := Item'Length + 1;\n             end if;\n \n@@ -752,14 +1110,26 @@ package body Interfaces.C is\n    begin\n       if Append_Nul then\n          declare\n-            R : char32_array (0 .. Item'Length);\n+            R : char32_array (0 .. Item'Length) with Relaxed_Initialization;\n \n          begin\n             for J in Item'Range loop\n                R (size_t (J - Item'First)) := To_C (Item (J));\n+\n+               pragma Loop_Invariant\n+                 (for all K in 0 .. size_t (J - Item'First) =>\n+                    R (K)'Initialized);\n+               pragma Loop_Invariant\n+                 (for all K in Item'First .. J =>\n+                    R (size_t (K - Item'First)) = To_C (Item (K)));\n             end loop;\n \n-            R (R'Last) := char32_t'Val (0);\n+            R (R'Last) := char32_nul;\n+\n+            pragma Assert\n+              (for all J in Item'Range =>\n+                 R (size_t (J - Item'First)) = To_C (Item (J)));\n+\n             return R;\n          end;\n \n@@ -775,11 +1145,19 @@ package body Interfaces.C is\n \n          else\n             declare\n-               R : char32_array (0 .. Item'Length - 1);\n+               R : char32_array (0 .. Item'Length - 1)\n+                 with Relaxed_Initialization;\n \n             begin\n-               for J in size_t range 0 .. Item'Length - 1 loop\n-                  R (J) := To_C (Item (Integer (J) + Item'First));\n+               for J in Item'Range loop\n+                  R (size_t (J - Item'First)) := To_C (Item (J));\n+\n+                  pragma Loop_Invariant\n+                    (for all K in 0 .. size_t (J - Item'First) =>\n+                       R (K)'Initialized);\n+                  pragma Loop_Invariant\n+                    (for all K in Item'First .. J =>\n+                       R (size_t (K - Item'First)) = To_C (Item (K)));\n                end loop;\n \n                return R;\n@@ -806,14 +1184,36 @@ package body Interfaces.C is\n          To := Target'First;\n          for From in Item'Range loop\n             Target (To) := To_C (Item (From));\n+\n+            pragma Loop_Invariant (To in Target'Range);\n+            pragma Loop_Invariant\n+              (To - Target'First = size_t (From - Item'First));\n+            pragma Loop_Invariant\n+              (for all J in Target'First .. To => Target (J)'Initialized);\n+            pragma Loop_Invariant\n+              (Target (Target'First .. To)'Initialized);\n+            pragma Loop_Invariant\n+              (for all J in Item'First .. From =>\n+                Target (Target'First + size_t (J - Item'First)) =\n+                  To_C (Item (J)));\n+\n             To := To + 1;\n          end loop;\n \n+         pragma Assert\n+           (for all J in Item'Range =>\n+             Target (Target'First + size_t (J - Item'First)) =\n+               To_C (Item (J)));\n+         pragma Assert\n+           (if Item'Length /= 0 then\n+             Target (Target'First ..\n+                     Target'First + (Item'Length - 1))'Initialized);\n+\n          if Append_Nul then\n             if To > Target'Last then\n                raise Constraint_Error;\n             else\n-               Target (To) := char32_t'Val (0);\n+               Target (To) := char32_nul;\n                Count := Item'Length + 1;\n             end if;\n "}, {"sha": "2023b753dfd6a6b9d091c5e151f109cf98018e91", "filename": "gcc/ada/libgnat/i-c.ads", "status": "modified", "additions": 389, "deletions": 31, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bbe3972ba78757abdb3bb06cccc0b461914b01/gcc%2Fada%2Flibgnat%2Fi-c.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bbe3972ba78757abdb3bb06cccc0b461914b01/gcc%2Fada%2Flibgnat%2Fi-c.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fi-c.ads?ref=76bbe3972ba78757abdb3bb06cccc0b461914b01", "patch": "@@ -13,10 +13,30 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Contract_Cases => Ignore,\n+                         Ghost          => Ignore);\n+\n with System.Parameters;\n \n-package Interfaces.C is\n-   pragma Pure;\n+package Interfaces.C\n+  with SPARK_Mode, Pure\n+is\n+   --  Each of the types declared in Interfaces.C is C-compatible.\n+\n+   --  The types int, short, long, unsigned, ptrdiff_t, size_t, double,\n+   --  char, wchar_t, char16_t, and char32_t correspond respectively to the\n+   --  C types having the same names. The types signed_char, unsigned_short,\n+   --  unsigned_long, unsigned_char, C_bool, C_float, and long_double\n+   --  correspond respectively to the C types signed char, unsigned\n+   --  short, unsigned long, unsigned char, bool, float, and long double.\n \n    --  Declaration's based on C's <limits.h>\n \n@@ -49,7 +69,11 @@ package Interfaces.C is\n    type unsigned_char is mod (UCHAR_MAX + 1);\n    for unsigned_char'Size use CHAR_BIT;\n \n-   subtype plain_char is unsigned_char; -- ??? should be parameterized\n+   --  Note: Ada RM states that the type of the subtype plain_char is either\n+   --  signed_char or unsigned_char, depending on the C implementation. GNAT\n+   --  instead choses unsigned_char always.\n+\n+   subtype plain_char is unsigned_char;\n \n    --  Note: the Integer qualifications used in the declaration of ptrdiff_t\n    --  avoid ambiguities when compiling in the presence of s-auxdec.ads and\n@@ -80,33 +104,133 @@ package Interfaces.C is\n \n    nul : constant char := char'First;\n \n-   function To_C   (Item : Character) return char;\n-   function To_Ada (Item : char)      return Character;\n+   --  The functions To_C and To_Ada map between the Ada type Character and the\n+   --  C type char.\n+\n+   function To_C (Item : Character) return char\n+   with\n+     Post => To_C'Result = char'Val (Character'Pos (Item));\n+\n+   function To_Ada (Item : char) return Character\n+   with\n+     Post => To_Ada'Result = Character'Val (char'Pos (Item));\n \n    type char_array is array (size_t range <>) of aliased char;\n    for char_array'Component_Size use CHAR_BIT;\n \n-   function Is_Nul_Terminated (Item : char_array) return Boolean;\n+   function Is_Nul_Terminated (Item : char_array) return Boolean\n+   with\n+     Post => Is_Nul_Terminated'Result = (for some C of Item => C = nul);\n+   --  The result of Is_Nul_Terminated is True if Item contains nul, and is\n+   --  False otherwise.\n+\n+   function C_Length_Ghost (Item : char_array) return size_t\n+   with\n+     Ghost,\n+     Pre  => Is_Nul_Terminated (Item),\n+     Post => C_Length_Ghost'Result <= Item'Last - Item'First\n+       and then Item (Item'First + C_Length_Ghost'Result) = nul\n+       and then (for all J in Item'First .. Item'First + C_Length_Ghost'Result\n+                   when J /= Item'First + C_Length_Ghost'Result =>\n+                     Item (J) /= nul);\n+   --  Ghost function to compute the length of a char_array up to the first nul\n+   --  character.\n \n    function To_C\n      (Item       : String;\n-      Append_Nul : Boolean := True) return char_array;\n+      Append_Nul : Boolean := True) return char_array\n+   with\n+     Pre  => not (Append_Nul = False and then Item'Length = 0),\n+     Post => To_C'Result'First = 0\n+       and then To_C'Result'Length =\n+         (if Append_Nul then Item'Length + 1 else Item'Length)\n+       and then (for all J in Item'Range =>\n+                   To_C'Result (size_t (J - Item'First)) = To_C (Item (J)))\n+       and then (if Append_Nul then To_C'Result (To_C'Result'Last) = nul);\n+   --  The result of To_C is a char_array value of length Item'Length (if\n+   --  Append_Nul is False) or Item'Length+1 (if Append_Nul is True). The lower\n+   --  bound is 0. For each component Item(I), the corresponding component\n+   --  in the result is To_C applied to Item(I). The value nul is appended if\n+   --  Append_Nul is True. If Append_Nul is False and Item'Length is 0, then\n+   --  To_C propagates Constraint_Error.\n \n    function To_Ada\n      (Item     : char_array;\n-      Trim_Nul : Boolean := True) return String;\n+      Trim_Nul : Boolean := True) return String\n+   with\n+     Pre  => (if Trim_Nul then\n+                Is_Nul_Terminated (Item)\n+                  and then C_Length_Ghost (Item) <= size_t (Natural'Last)\n+              else\n+                Item'Last - Item'First < size_t (Natural'Last)),\n+     Post => To_Ada'Result'First = 1\n+       and then To_Ada'Result'Length =\n+         (if Trim_Nul then C_Length_Ghost (Item) else Item'Length)\n+       and then (for all J in To_Ada'Result'Range =>\n+                   To_Ada'Result (J) =\n+                     To_Ada (Item (size_t (J) - 1 + Item'First)));\n+   --  The result of To_Ada is a String whose length is Item'Length (if\n+   --  Trim_Nul is False) or the length of the slice of Item preceding the\n+   --  first nul (if Trim_Nul is True). The lower bound of the result is 1.\n+   --  If Trim_Nul is False, then for each component Item(I) the corresponding\n+   --  component in the result is To_Ada applied to Item(I). If Trim_Nul\n+   --  is True, then for each component Item(I) before the first nul the\n+   --  corresponding component in the result is To_Ada applied to Item(I). The\n+   --  function propagates Terminator_Error if Trim_Nul is True and Item does\n+   --  not contain nul.\n \n    procedure To_C\n      (Item       : String;\n       Target     : out char_array;\n       Count      : out size_t;\n-      Append_Nul : Boolean := True);\n+      Append_Nul : Boolean := True)\n+   with\n+     Relaxed_Initialization => Target,\n+     Pre  => Target'Length >=\n+       (if Append_Nul then Item'Length + 1 else Item'Length),\n+     Post => Count = (if Append_Nul then Item'Length + 1 else Item'Length)\n+       and then\n+         (if Count /= 0 then\n+           Target (Target'First .. Target'First + (Count - 1))'Initialized)\n+       and then\n+         (for all J in Item'Range =>\n+           Target (Target'First + size_t (J - Item'First)) = To_C (Item (J)))\n+       and then\n+         (if Append_Nul then Target (Target'First + (Count - 1)) = nul);\n+   --  For procedure To_C, each element of Item is converted (via the To_C\n+   --  function) to a char, which is assigned to the corresponding element of\n+   --  Target. If Append_Nul is True, nul is then assigned to the next element\n+   --  of Target. In either case, Count is set to the number of Target elements\n+   --  assigned. If Target is not long enough, Constraint_Error is propagated.\n \n    procedure To_Ada\n      (Item     : char_array;\n       Target   : out String;\n       Count    : out Natural;\n-      Trim_Nul : Boolean := True);\n+      Trim_Nul : Boolean := True)\n+   with\n+     Relaxed_Initialization => Target,\n+     Pre  => (if Trim_Nul then\n+                Is_Nul_Terminated (Item)\n+                  and then C_Length_Ghost (Item) <= size_t (Target'Length)\n+              else\n+                Item'Last - Item'First < size_t (Target'Length)),\n+     Post => Count =\n+         (if Trim_Nul then Natural (C_Length_Ghost (Item)) else Item'Length)\n+       and then\n+         (if Count /= 0 then\n+           Target (Target'First .. Target'First + (Count - 1))'Initialized)\n+       and then\n+         (for all J in Target'First .. Target'First + (Count - 1) =>\n+           Target (J) =\n+             To_Ada (Item (size_t (J - Target'First) + Item'First)));\n+   --  For procedure To_Ada, each element of Item (if Trim_Nul is False) or\n+   --  each element of Item preceding the first nul (if Trim_Nul is True) is\n+   --  converted (via the To_Ada function) to a Character, which is assigned\n+   --  to the corresponding element of Target. Count is set to the number of\n+   --  Target elements assigned. If Target is not long enough, Constraint_Error\n+   --  is propagated. If Trim_Nul is True and Item does not contain nul, then\n+   --  Terminator_Error is propagated.\n \n    ------------------------------------\n    -- Wide Character and Wide String --\n@@ -117,32 +241,110 @@ package Interfaces.C is\n \n    wide_nul : constant wchar_t := wchar_t'First;\n \n-   function To_C   (Item : Wide_Character) return wchar_t;\n-   function To_Ada (Item : wchar_t)        return Wide_Character;\n+   --  To_C and To_Ada provide the mappings between the Ada and C wide\n+   --  character types.\n+\n+   function To_C (Item : Wide_Character) return wchar_t\n+   with\n+     Post => To_C'Result = wchar_t (Item);\n+\n+   function To_Ada (Item : wchar_t) return Wide_Character\n+   with\n+     Post => To_Ada'Result = Wide_Character (Item);\n \n    type wchar_array is array (size_t range <>) of aliased wchar_t;\n \n-   function Is_Nul_Terminated (Item : wchar_array) return Boolean;\n+   function Is_Nul_Terminated (Item : wchar_array) return Boolean\n+   with\n+     Post => Is_Nul_Terminated'Result = (for some C of Item => C = wide_nul);\n+   --  The result of Is_Nul_Terminated is True if Item contains wide_nul, and\n+   --  is False otherwise.\n+\n+   --  The To_C and To_Ada subprograms that convert between Wide_String and\n+   --  wchar_array have analogous effects to the To_C and To_Ada subprograms\n+   --  that convert between String and char_array, except that wide_nul is\n+   --  used instead of nul.\n+\n+   function C_Length_Ghost (Item : wchar_array) return size_t\n+   with\n+     Ghost,\n+     Pre  => Is_Nul_Terminated (Item),\n+     Post => C_Length_Ghost'Result <= Item'Last - Item'First\n+       and then Item (Item'First + C_Length_Ghost'Result) = wide_nul\n+       and then (for all J in Item'First .. Item'First + C_Length_Ghost'Result\n+                   when J /= Item'First + C_Length_Ghost'Result =>\n+                     Item (J) /= wide_nul);\n+   --  Ghost function to compute the length of a wchar_array up to the first\n+   --  wide_nul character.\n \n    function To_C\n      (Item       : Wide_String;\n-      Append_Nul : Boolean := True) return wchar_array;\n+      Append_Nul : Boolean := True) return wchar_array\n+   with\n+     Pre  => not (Append_Nul = False and then Item'Length = 0),\n+     Post => To_C'Result'First = 0\n+       and then To_C'Result'Length =\n+         (if Append_Nul then Item'Length + 1 else Item'Length)\n+       and then (for all J in Item'Range =>\n+                   To_C'Result (size_t (J - Item'First)) = To_C (Item (J)))\n+       and then (if Append_Nul then To_C'Result (To_C'Result'Last) = wide_nul);\n \n    function To_Ada\n      (Item     : wchar_array;\n-      Trim_Nul : Boolean := True) return Wide_String;\n+      Trim_Nul : Boolean := True) return Wide_String\n+   with\n+     Pre  => (if Trim_Nul then\n+                Is_Nul_Terminated (Item)\n+                  and then C_Length_Ghost (Item) <= size_t (Natural'Last)\n+              else\n+                Item'Last - Item'First < size_t (Natural'Last)),\n+     Post => To_Ada'Result'First = 1\n+       and then To_Ada'Result'Length =\n+         (if Trim_Nul then C_Length_Ghost (Item) else Item'Length)\n+       and then (for all J in To_Ada'Result'Range =>\n+                   To_Ada'Result (J) =\n+                     To_Ada (Item (size_t (J) - 1 + Item'First)));\n \n    procedure To_C\n      (Item       : Wide_String;\n       Target     : out wchar_array;\n       Count      : out size_t;\n-      Append_Nul : Boolean := True);\n+      Append_Nul : Boolean := True)\n+   with\n+     Relaxed_Initialization => Target,\n+     Pre  => Target'Length >=\n+       (if Append_Nul then Item'Length + 1 else Item'Length),\n+     Post => Count = (if Append_Nul then Item'Length + 1 else Item'Length)\n+       and then\n+         (if Count /= 0 then\n+           Target (Target'First .. Target'First + (Count - 1))'Initialized)\n+       and then\n+         (for all J in Item'Range =>\n+           Target (Target'First + size_t (J - Item'First)) = To_C (Item (J)))\n+       and then\n+         (if Append_Nul then Target (Target'First + (Count - 1)) = wide_nul);\n \n    procedure To_Ada\n      (Item     : wchar_array;\n       Target   : out Wide_String;\n       Count    : out Natural;\n-      Trim_Nul : Boolean := True);\n+      Trim_Nul : Boolean := True)\n+   with\n+     Relaxed_Initialization => Target,\n+     Pre  => (if Trim_Nul then\n+                Is_Nul_Terminated (Item)\n+                  and then C_Length_Ghost (Item) <= size_t (Target'Length)\n+              else\n+                Item'Last - Item'First < size_t (Target'Length)),\n+     Post => Count =\n+         (if Trim_Nul then Natural (C_Length_Ghost (Item)) else Item'Length)\n+       and then\n+         (if Count /= 0 then\n+           Target (Target'First .. Target'First + (Count - 1))'Initialized)\n+       and then\n+         (for all J in Target'First .. Target'First + (Count - 1) =>\n+           Target (J) =\n+             To_Ada (Item (size_t (J - Target'First) + Item'First)));\n \n    Terminator_Error : exception;\n \n@@ -156,40 +358,118 @@ package Interfaces.C is\n    char16_nul : constant char16_t := char16_t'Val (0);\n    pragma Ada_05 (char16_nul);\n \n-   function To_C (Item : Wide_Character) return char16_t;\n+   --  To_C and To_Ada provide mappings between the Ada and C 16-bit character\n+   --  types.\n+\n+   function To_C (Item : Wide_Character) return char16_t\n+   with\n+     Post => To_C'Result = char16_t (Item);\n    pragma Ada_05 (To_C);\n \n-   function To_Ada (Item : char16_t) return Wide_Character;\n+   function To_Ada (Item : char16_t) return Wide_Character\n+   with\n+     Post => To_Ada'Result = Wide_Character (Item);\n    pragma Ada_05 (To_Ada);\n \n    type char16_array is array (size_t range <>) of aliased char16_t;\n    pragma Ada_05 (char16_array);\n \n-   function Is_Nul_Terminated (Item : char16_array) return Boolean;\n+   function Is_Nul_Terminated (Item : char16_array) return Boolean\n+   with\n+     Post => Is_Nul_Terminated'Result = (for some C of Item => C = char16_nul);\n    pragma Ada_05 (Is_Nul_Terminated);\n+   --  The result of Is_Nul_Terminated is True if Item contains char16_nul, and\n+   --  is False otherwise.\n+\n+   --  The To_C and To_Ada subprograms that convert between Wide_String and\n+   --  char16_array have analogous effects to the To_C and To_Ada subprograms\n+   --  that convert between String and char_array, except that char16_nul is\n+   --  used instead of nul.\n+\n+   function C_Length_Ghost (Item : char16_array) return size_t\n+   with\n+     Ghost,\n+     Pre  => Is_Nul_Terminated (Item),\n+     Post => C_Length_Ghost'Result <= Item'Last - Item'First\n+       and then Item (Item'First + C_Length_Ghost'Result) = char16_nul\n+       and then (for all J in Item'First .. Item'First + C_Length_Ghost'Result\n+                   when J /= Item'First + C_Length_Ghost'Result =>\n+                     Item (J) /= char16_nul);\n+   --  Ghost function to compute the length of a char16_array up to the first\n+   --  char16_nul character.\n \n    function To_C\n      (Item       : Wide_String;\n-      Append_Nul : Boolean := True) return char16_array;\n+      Append_Nul : Boolean := True) return char16_array\n+   with\n+     Pre  => not (Append_Nul = False and then Item'Length = 0),\n+     Post => To_C'Result'First = 0\n+       and then To_C'Result'Length =\n+         (if Append_Nul then Item'Length + 1 else Item'Length)\n+       and then (for all J in Item'Range =>\n+                   To_C'Result (size_t (J - Item'First)) = To_C (Item (J)))\n+       and then\n+         (if Append_Nul then To_C'Result (To_C'Result'Last) = char16_nul);\n    pragma Ada_05 (To_C);\n \n    function To_Ada\n      (Item     : char16_array;\n-      Trim_Nul : Boolean := True) return Wide_String;\n+      Trim_Nul : Boolean := True) return Wide_String\n+   with\n+     Pre  => (if Trim_Nul then\n+                Is_Nul_Terminated (Item)\n+                  and then C_Length_Ghost (Item) <= size_t (Natural'Last)\n+              else\n+                Item'Last - Item'First < size_t (Natural'Last)),\n+     Post => To_Ada'Result'First = 1\n+       and then To_Ada'Result'Length =\n+         (if Trim_Nul then C_Length_Ghost (Item) else Item'Length)\n+       and then (for all J in To_Ada'Result'Range =>\n+                   To_Ada'Result (J) =\n+                     To_Ada (Item (size_t (J) - 1 + Item'First)));\n    pragma Ada_05 (To_Ada);\n \n    procedure To_C\n      (Item       : Wide_String;\n       Target     : out char16_array;\n       Count      : out size_t;\n-      Append_Nul : Boolean := True);\n+      Append_Nul : Boolean := True)\n+   with\n+     Relaxed_Initialization => Target,\n+     Pre  => Target'Length >=\n+       (if Append_Nul then Item'Length + 1 else Item'Length),\n+     Post => Count = (if Append_Nul then Item'Length + 1 else Item'Length)\n+       and then\n+         (if Count /= 0 then\n+           Target (Target'First .. Target'First + (Count - 1))'Initialized)\n+       and then\n+         (for all J in Item'Range =>\n+           Target (Target'First + size_t (J - Item'First)) = To_C (Item (J)))\n+       and then\n+         (if Append_Nul then Target (Target'First + (Count - 1)) = char16_nul);\n    pragma Ada_05 (To_C);\n \n    procedure To_Ada\n      (Item     : char16_array;\n       Target   : out Wide_String;\n       Count    : out Natural;\n-      Trim_Nul : Boolean := True);\n+      Trim_Nul : Boolean := True)\n+   with\n+     Relaxed_Initialization => Target,\n+     Pre  => (if Trim_Nul then\n+                Is_Nul_Terminated (Item)\n+                  and then C_Length_Ghost (Item) <= size_t (Target'Length)\n+              else\n+                Item'Last - Item'First < size_t (Target'Length)),\n+     Post => Count =\n+         (if Trim_Nul then Natural (C_Length_Ghost (Item)) else Item'Length)\n+       and then\n+         (if Count /= 0 then\n+           Target (Target'First .. Target'First + (Count - 1))'Initialized)\n+       and then\n+         (for all J in Target'First .. Target'First + (Count - 1) =>\n+           Target (J) =\n+             To_Ada (Item (size_t (J - Target'First) + Item'First)));\n    pragma Ada_05 (To_Ada);\n \n    type char32_t is new Wide_Wide_Character;\n@@ -198,40 +478,118 @@ package Interfaces.C is\n    char32_nul : constant char32_t := char32_t'Val (0);\n    pragma Ada_05 (char32_nul);\n \n-   function To_C (Item : Wide_Wide_Character) return char32_t;\n+   --  To_C and To_Ada provide mappings between the Ada and C 32-bit character\n+   --  types.\n+\n+   function To_C (Item : Wide_Wide_Character) return char32_t\n+   with\n+     Post => To_C'Result = char32_t (Item);\n    pragma Ada_05 (To_C);\n \n-   function To_Ada (Item : char32_t) return Wide_Wide_Character;\n+   function To_Ada (Item : char32_t) return Wide_Wide_Character\n+   with\n+     Post => To_Ada'Result = Wide_Wide_Character (Item);\n    pragma Ada_05 (To_Ada);\n \n    type char32_array is array (size_t range <>) of aliased char32_t;\n    pragma Ada_05 (char32_array);\n \n-   function Is_Nul_Terminated (Item : char32_array) return Boolean;\n+   function Is_Nul_Terminated (Item : char32_array) return Boolean\n+   with\n+     Post => Is_Nul_Terminated'Result = (for some C of Item => C = char32_nul);\n    pragma Ada_05 (Is_Nul_Terminated);\n+   --  The result of Is_Nul_Terminated is True if Item contains char32_nul, and\n+   --  is False otherwise.\n+\n+   function C_Length_Ghost (Item : char32_array) return size_t\n+   with\n+     Ghost,\n+     Pre  => Is_Nul_Terminated (Item),\n+     Post => C_Length_Ghost'Result <= Item'Last - Item'First\n+       and then Item (Item'First + C_Length_Ghost'Result) = char32_nul\n+       and then (for all J in Item'First .. Item'First + C_Length_Ghost'Result\n+                   when J /= Item'First + C_Length_Ghost'Result =>\n+                     Item (J) /= char32_nul);\n+   --  Ghost function to compute the length of a char32_array up to the first\n+   --  char32_nul character.\n+\n+   --  The To_C and To_Ada subprograms that convert between Wide_Wide_String\n+   --  and char32_array have analogous effects to the To_C and To_Ada\n+   --  subprograms that convert between String and char_array, except\n+   --  that char32_nul is used instead of nul.\n \n    function To_C\n      (Item       : Wide_Wide_String;\n-      Append_Nul : Boolean := True) return char32_array;\n+      Append_Nul : Boolean := True) return char32_array\n+   with\n+     Pre  => not (Append_Nul = False and then Item'Length = 0),\n+     Post => To_C'Result'First = 0\n+       and then To_C'Result'Length =\n+         (if Append_Nul then Item'Length + 1 else Item'Length)\n+       and then (for all J in Item'Range =>\n+                   To_C'Result (size_t (J - Item'First)) = To_C (Item (J)))\n+       and then\n+         (if Append_Nul then To_C'Result (To_C'Result'Last) = char32_nul);\n    pragma Ada_05 (To_C);\n \n    function To_Ada\n      (Item     : char32_array;\n-      Trim_Nul : Boolean := True) return Wide_Wide_String;\n+      Trim_Nul : Boolean := True) return Wide_Wide_String\n+   with\n+     Pre  => (if Trim_Nul then\n+                Is_Nul_Terminated (Item)\n+                  and then C_Length_Ghost (Item) <= size_t (Natural'Last)\n+              else\n+                Item'Last - Item'First < size_t (Natural'Last)),\n+     Post => To_Ada'Result'First = 1\n+       and then To_Ada'Result'Length =\n+         (if Trim_Nul then C_Length_Ghost (Item) else Item'Length)\n+       and then (for all J in To_Ada'Result'Range =>\n+                   To_Ada'Result (J) =\n+                     To_Ada (Item (size_t (J) - 1 + Item'First)));\n    pragma Ada_05 (To_Ada);\n \n    procedure To_C\n      (Item       : Wide_Wide_String;\n       Target     : out char32_array;\n       Count      : out size_t;\n-      Append_Nul : Boolean := True);\n+      Append_Nul : Boolean := True)\n+   with\n+     Relaxed_Initialization => Target,\n+     Pre  => Target'Length >=\n+       (if Append_Nul then Item'Length + 1 else Item'Length),\n+     Post => Count = (if Append_Nul then Item'Length + 1 else Item'Length)\n+       and then\n+         (if Count /= 0 then\n+           Target (Target'First .. Target'First + (Count - 1))'Initialized)\n+       and then\n+         (for all J in Item'Range =>\n+           Target (Target'First + size_t (J - Item'First)) = To_C (Item (J)))\n+       and then\n+         (if Append_Nul then Target (Target'First + (Count - 1)) = char32_nul);\n    pragma Ada_05 (To_C);\n \n    procedure To_Ada\n      (Item     : char32_array;\n       Target   : out Wide_Wide_String;\n       Count    : out Natural;\n-      Trim_Nul : Boolean := True);\n+      Trim_Nul : Boolean := True)\n+   with\n+     Relaxed_Initialization => Target,\n+     Pre  => (if Trim_Nul then\n+                Is_Nul_Terminated (Item)\n+                  and then C_Length_Ghost (Item) <= size_t (Target'Length)\n+              else\n+                Item'Last - Item'First < size_t (Target'Length)),\n+     Post => Count =\n+         (if Trim_Nul then Natural (C_Length_Ghost (Item)) else Item'Length)\n+       and then\n+         (if Count /= 0 then\n+           Target (Target'First .. Target'First + (Count - 1))'Initialized)\n+       and then\n+         (for all J in Target'First .. Target'First + (Count - 1) =>\n+           Target (J) =\n+             To_Ada (Item (size_t (J - Target'First) + Item'First)));\n    pragma Ada_05 (To_Ada);\n \n end Interfaces.C;"}, {"sha": "7df06c4b9eaa06604ffc59facc093e667b1fb027", "filename": "gcc/ada/libgnat/s-os_lib.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76bbe3972ba78757abdb3bb06cccc0b461914b01/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76bbe3972ba78757abdb3bb06cccc0b461914b01/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-os_lib.adb?ref=76bbe3972ba78757abdb3bb06cccc0b461914b01", "patch": "@@ -29,8 +29,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Compiler_Unit_Warning;\n-\n with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n with System; use System;"}]}