{"sha": "0202018521e5aaf55b500210ddd4b603c67477ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIwMjAxODUyMWU1YWFmNTViNTAwMjEwZGRkNGI2MDNjNjc0NzdhYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-06-10T03:13:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-06-10T03:13:19Z"}, "message": "init.c (resolve_offset_ref): Handle default-initialization.\n\n\t* init.c (resolve_offset_ref): Handle default-initialization.\n\t* except.c (build_throw): Handle throwing NULL.\n\t* typeck.c (build_x_function_call): Use resolve_offset_ref.\n\t* search.c (compute_access): Only strip an anonymous union\n\tfor a FIELD_DECL.\n\t* call.c (add_builtin_candidates): Tweak.\n\t* cvt.c (build_expr_type_conversion): Restore code for conversion\n\tfrom class types.\n\t* decl2.c (delete_sanity): Use it.  Clean up.\n\t* typeck.c (comp_ptr_ttypes_real): Fix cv-qual comparisons.\n        * typeck.c (c_expand_return): Don't warn about void expressions on\n        return statements in functions returning void.\n\nFrom-SVN: r20399", "tree": {"sha": "fd4cb18ef47acf65e1a8266f89e6044dcb05772e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd4cb18ef47acf65e1a8266f89e6044dcb05772e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0202018521e5aaf55b500210ddd4b603c67477ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0202018521e5aaf55b500210ddd4b603c67477ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0202018521e5aaf55b500210ddd4b603c67477ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0202018521e5aaf55b500210ddd4b603c67477ab/comments", "author": null, "committer": null, "parents": [{"sha": "0365438d33268e5541586feb37fd1e490e1a874c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0365438d33268e5541586feb37fd1e490e1a874c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0365438d33268e5541586feb37fd1e490e1a874c"}], "stats": {"total": 526, "additions": 305, "deletions": 221}, "files": [{"sha": "c84e3e204d139d10028c90c7d254f6f9d5d5073f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0202018521e5aaf55b500210ddd4b603c67477ab", "patch": "@@ -1,3 +1,27 @@\n+1998-06-10  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (resolve_offset_ref): Handle default-initialization.\n+\n+\t* except.c (build_throw): Handle throwing NULL.\n+\n+\t* typeck.c (build_x_function_call): Use resolve_offset_ref.\n+\n+\t* search.c (compute_access): Only strip an anonymous union\n+\tfor a FIELD_DECL.\n+\n+\t* call.c (add_builtin_candidates): Tweak.\n+\n+\t* cvt.c (build_expr_type_conversion): Restore code for conversion\n+\tfrom class types.\n+\t* decl2.c (delete_sanity): Use it.  Clean up.\n+\n+\t* typeck.c (comp_ptr_ttypes_real): Fix cv-qual comparisons.\n+\n+1998-06-10  Branko Cibej  <branko.cibej@hermes.si>\n+\n+        * typeck.c (c_expand_return): Don't warn about void expressions on\n+        return statements in functions returning void.\n+\n 1998-06-09  Mark Mitchell  <mark@markmitchell.com>\n \n \t* pt.c (fn_type_unification): Revise documentation.  Tidy."}, {"sha": "7a74213bc21929f9c672261cdea7c8b4ae8faf58", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0202018521e5aaf55b500210ddd4b603c67477ab", "patch": "@@ -1807,6 +1807,11 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \t{\n \t  tree convs = lookup_conversions (argtypes[i]);\n \n+\t  if (i == 0 && code == MODIFY_EXPR && code2 == NOP_EXPR)\n+\t    return candidates;\n+\n+\t  convs = lookup_conversions (argtypes[i]);\n+\n \t  if (code == COND_EXPR)\n \t    {\n \t      if (real_lvalue_p (args[i]))\n@@ -1816,9 +1821,8 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \t      types[i] = scratch_tree_cons\n \t\t(NULL_TREE, TYPE_MAIN_VARIANT (argtypes[i]), types[i]);\n \t    }\n-\t\t\n-\t  else if (! convs || (i == 0 && code == MODIFY_EXPR\n-\t\t\t       && code2 == NOP_EXPR))\n+\n+\t  else if (! convs)\n \t    return candidates;\n \n \t  for (; convs; convs = TREE_CHAIN (convs))"}, {"sha": "5c4c0b0b9f113888dcc13cd88981c9095bed0e16", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 85, "deletions": 22, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=0202018521e5aaf55b500210ddd4b603c67477ab", "patch": "@@ -941,36 +941,99 @@ build_expr_type_conversion (desires, expr, complain)\n      int complain;\n {\n   tree basetype = TREE_TYPE (expr);\n+  tree conv;\n+  tree winner = NULL_TREE;\n \n   if (TREE_CODE (basetype) == OFFSET_TYPE)\n     expr = resolve_offset_ref (expr);\n   expr = convert_from_reference (expr);\n   basetype = TREE_TYPE (expr);\n \n-  switch (TREE_CODE (basetype))\n-    {\n-    case INTEGER_TYPE:\n-      if ((desires & WANT_NULL) && TREE_CODE (expr) == INTEGER_CST\n-\t  && integer_zerop (expr))\n-\treturn expr;\n-      /* else fall through...  */\n-\n-    case BOOLEAN_TYPE:\n-      return (desires & WANT_INT) ? expr : NULL_TREE;\n-    case ENUMERAL_TYPE:\n-      return (desires & WANT_ENUM) ? expr : NULL_TREE;\n-    case REAL_TYPE:\n-      return (desires & WANT_FLOAT) ? expr : NULL_TREE;\n-    case POINTER_TYPE:\n-      return (desires & WANT_POINTER) ? expr : NULL_TREE;\n+  if (! IS_AGGR_TYPE (basetype))\n+    switch (TREE_CODE (basetype))\n+      {\n+      case INTEGER_TYPE:\n+\tif ((desires & WANT_NULL) && TREE_CODE (expr) == INTEGER_CST\n+\t    && integer_zerop (expr))\n+\t  return expr;\n+\t/* else fall through...  */\n+\n+      case BOOLEAN_TYPE:\n+\treturn (desires & WANT_INT) ? expr : NULL_TREE;\n+      case ENUMERAL_TYPE:\n+\treturn (desires & WANT_ENUM) ? expr : NULL_TREE;\n+      case REAL_TYPE:\n+\treturn (desires & WANT_FLOAT) ? expr : NULL_TREE;\n+      case POINTER_TYPE:\n+\treturn (desires & WANT_POINTER) ? expr : NULL_TREE;\n \t\n-    case FUNCTION_TYPE:\n-    case ARRAY_TYPE:\n-      return ((desires & WANT_POINTER) ? default_conversion (expr)\n-\t      : NULL_TREE);\n+      case FUNCTION_TYPE:\n+      case ARRAY_TYPE:\n+\treturn (desires & WANT_POINTER) ? default_conversion (expr)\n+     \t                                : NULL_TREE;\n+      default:\n+\treturn NULL_TREE;\n+      }\n+\n+  /* The code for conversions from class type is currently only used for\n+     delete expressions.  Other expressions are handled by build_new_op.  */\n+\n+  if (! TYPE_HAS_CONVERSION (basetype))\n+    return NULL_TREE;\n+\n+  for (conv = lookup_conversions (basetype); conv; conv = TREE_CHAIN (conv))\n+    {\n+      int win = 0;\n+      tree candidate;\n+      tree cand = TREE_VALUE (conv);\n+\n+      if (winner && winner == cand)\n+\tcontinue;\n+\n+      candidate = TREE_TYPE (TREE_TYPE (cand));\n+      if (TREE_CODE (candidate) == REFERENCE_TYPE)\n+\tcandidate = TREE_TYPE (candidate);\n+\n+      switch (TREE_CODE (candidate))\n+\t{\n+\tcase BOOLEAN_TYPE:\n+\tcase INTEGER_TYPE:\n+\t  win = (desires & WANT_INT); break;\n+\tcase ENUMERAL_TYPE:\n+\t  win = (desires & WANT_ENUM); break;\n+\tcase REAL_TYPE:\n+\t  win = (desires & WANT_FLOAT); break;\n+\tcase POINTER_TYPE:\n+\t  win = (desires & WANT_POINTER); break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      if (win)\n+\t{\n+\t  if (winner)\n+\t    {\n+\t      if (complain)\n+\t\t{\n+\t\t  cp_error (\"ambiguous default type conversion from `%T'\",\n+\t\t\t    basetype);\n+\t\t  cp_error (\"  candidate conversions include `%D' and `%D'\",\n+\t\t\t    winner, cand);\n+\t\t}\n+\t      return error_mark_node;\n+\t    }\n+\t  else\n+\t    winner = cand;\n+\t}\n+    }\n \n-    default:\n-      break;\n+  if (winner)\n+    {\n+      tree type = TREE_TYPE (TREE_TYPE (winner));\n+      if (TREE_CODE (type) == REFERENCE_TYPE)\n+\ttype = TREE_TYPE (type);\n+      return build_user_type_conversion (type, expr, LOOKUP_NORMAL);\n     }\n \n   return NULL_TREE;"}, {"sha": "b498599f6f1aad9fc4441f050129029eb6c25d69", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 31, "deletions": 53, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=0202018521e5aaf55b500210ddd4b603c67477ab", "patch": "@@ -1236,9 +1236,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n      tree exp, size;\n      int doing_vec, use_global_delete;\n {\n-  tree t;\n-  tree type;\n-  enum tree_code code;\n+  tree t, type;\n   /* For a regular vector delete (aka, no size argument) we will pass\n      this down as a NULL_TREE into build_vec_delete.  */\n   tree maxindex = NULL_TREE;\n@@ -1254,65 +1252,45 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n       return t;\n     }\n \n-  t = exp;\n-  if (TREE_CODE (t) == OFFSET_REF)\n-    t = resolve_offset_ref (t);\n-  t = stabilize_reference (convert_from_reference (t));\n-  type = TREE_TYPE (t);\n-  code = TREE_CODE (type);\n+  if (TREE_CODE (exp) == OFFSET_REF)\n+    exp = resolve_offset_ref (exp);\n+  exp = convert_from_reference (exp);\n+  t = stabilize_reference (exp);\n+  t = build_expr_type_conversion (WANT_POINTER, t, 1);\n \n-  switch (doing_vec)\n+  if (t == NULL_TREE || t == error_mark_node)\n     {\n-    case 2:\n-      maxindex = build_binary_op (MINUS_EXPR, size, integer_one_node, 1);\n-      pedwarn (\"anachronistic use of array size in vector delete\");\n-      /* Fall through.  */\n-    case 1:\n-      break;\n-    default:\n-      if (code != POINTER_TYPE)\n-\t{\n-\t  cp_error (\"type `%#T' argument given to `delete', expected pointer\",\n-\t\t    type);\n-\t  return error_mark_node;\n-\t}\n-\n-      /* Deleting a pointer with the value zero is valid and has no effect.  */\n-      if (integer_zerop (t))\n-\treturn build1 (NOP_EXPR, void_type_node, t);\n+      cp_error (\"type `%#T' argument given to `delete', expected pointer\",\n+\t\tTREE_TYPE (exp));\n+      return error_mark_node;\n     }\n \n-  if (code == POINTER_TYPE)\n+  if (doing_vec == 2)\n     {\n-#if 0\n-      /* As of Valley Forge, you can delete a pointer to const.  */\n-      if (TREE_READONLY (TREE_TYPE (type)))\n-\t{\n-\t  error (\"`const *' cannot be deleted\");\n-\t  return error_mark_node;\n-\t}\n-#endif\n-      /* You can't delete functions.  */\n-      if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-\t{\n-\t  error (\"cannot delete a function\");\n-\t  return error_mark_node;\n-\t}\n+      maxindex = build_binary_op (MINUS_EXPR, size, integer_one_node, 1);\n+      pedwarn (\"anachronistic use of array size in vector delete\");\n     }\n \n-#if 0\n-  /* If the type has no destructor, then we should build a regular\n-     delete, instead of a vector delete.  Otherwise, we would end\n-     up passing a bogus offset into __builtin_delete, which is\n-     not expecting it.  */ \n-  if (doing_vec\n-      && TREE_CODE (type) == POINTER_TYPE\n-      && !TYPE_HAS_DESTRUCTOR (TREE_TYPE (type)))\n+  type = TREE_TYPE (t);\n+\n+  /* As of Valley Forge, you can delete a pointer to const.  */\n+\n+  /* You can't delete functions.  */\n+  if (TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n     {\n-      doing_vec = 0;\n-      use_global_delete = 1;\n+      error (\"cannot delete a function\");\n+      return error_mark_node;\n     }\n-#endif\n+\n+  /* An array can't have been allocated by new, so complain.  */\n+  if (TREE_CODE (t) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (t, 0)) == VAR_DECL\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0))) == ARRAY_TYPE)\n+    cp_warning (\"deleting array `%#D'\", TREE_OPERAND (t, 0));\n+\n+  /* Deleting a pointer with the value zero is valid and has no effect.  */\n+  if (integer_zerop (t))\n+    return build1 (NOP_EXPR, void_type_node, t);\n \n   if (doing_vec)\n     return build_vec_delete (t, maxindex, integer_one_node,"}, {"sha": "dba0f0919c44d0a9fa0ce8fc022fac56c55fe8c1", "filename": "gcc/cp/except.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=0202018521e5aaf55b500210ddd4b603c67477ab", "patch": "@@ -1077,13 +1077,21 @@ tree\n build_throw (e)\n      tree e;\n {\n-  if (e != error_mark_node)\n+  if (e == error_mark_node)\n+    return e;\n+\n+  if (processing_template_decl)\n+    return build_min (THROW_EXPR, void_type_node, e);\n+\n+  if (! flag_ansi && e == null_node)\n     {\n-      if (processing_template_decl)\n-\treturn build_min (THROW_EXPR, void_type_node, e);\n-      e = build1 (THROW_EXPR, void_type_node, e);\n-      TREE_SIDE_EFFECTS (e) = 1;\n-      TREE_USED (e) = 1;\n+      cp_warning (\"throwing NULL\");\n+      e = integer_zero_node;\n     }\n+\n+  e = build1 (THROW_EXPR, void_type_node, e);\n+  TREE_SIDE_EFFECTS (e) = 1;\n+  TREE_USED (e) = 1;\n+\n   return e;\n }"}, {"sha": "828729c3c6c27ca6195a3ef40b88f96cc96cdc55", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0202018521e5aaf55b500210ddd4b603c67477ab", "patch": "@@ -197,9 +197,11 @@ perform_member_init (member, name, init, explicit)\n \t{\n \t  if (explicit)\n \t    {\n-\t      cp_error (\"incomplete initializer for member `%D' of class `%T' which has no constructor\",\n-\t\t\tmember, current_class_type);\n-\t      init = error_mark_node;\n+\t      /* default-initialization.  */\n+\t      if (AGGREGATE_TYPE_P (type))\n+\t\tinit = build (CONSTRUCTOR, type, NULL_TREE, NULL_TREE);\n+\t      else\n+\t\tinit = integer_zero_node;\n \t    }\n \t  /* member traversal: note it leaves init NULL */\n \t  else if (TREE_CODE (TREE_TYPE (member)) == REFERENCE_TYPE)\n@@ -222,7 +224,8 @@ perform_member_init (member, name, init, explicit)\n \t current_member_init_list.  */\n       if (init || explicit)\n \t{\n-\t  decl = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n+\t  decl = build_component_ref (current_class_ref, name, NULL_TREE,\n+\t\t\t\t      explicit);\n \t  expand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \t}\n     }\n@@ -238,7 +241,8 @@ perform_member_init (member, name, init, explicit)\n       push_obstacks_nochange ();\n       resume_temporary_allocation ();\n \n-      expr = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n+      expr = build_component_ref (current_class_ref, name, NULL_TREE,\n+\t\t\t\t  explicit);\n       expr = build_delete (type, expr, integer_zero_node,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n "}, {"sha": "3f5f4f2397230c51c59004545e789a2caf6acf3d", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 110, "deletions": 111, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=0202018521e5aaf55b500210ddd4b603c67477ab", "patch": "@@ -697,18 +697,18 @@ static const short yyrline[] = { 0,\n   3174,  3176,  3178,  3180,  3183,  3184,  3186,  3189,  3190,  3193,\n   3193,  3196,  3196,  3199,  3199,  3201,  3203,  3205,  3207,  3213,\n   3219,  3222,  3225,  3231,  3233,  3235,  3239,  3241,  3244,  3251,\n-  3257,  3266,  3270,  3272,  3275,  3277,  3280,  3284,  3286,  3289,\n-  3291,  3294,  3311,  3317,  3325,  3327,  3329,  3333,  3336,  3337,\n-  3345,  3349,  3353,  3356,  3357,  3363,  3366,  3369,  3371,  3375,\n-  3380,  3383,  3393,  3398,  3399,  3406,  3409,  3412,  3414,  3417,\n-  3419,  3429,  3443,  3447,  3450,  3452,  3456,  3460,  3463,  3466,\n-  3468,  3472,  3474,  3481,  3488,  3491,  3494,  3498,  3502,  3508,\n-  3512,  3517,  3519,  3522,  3527,  3533,  3544,  3547,  3549,  3553,\n-  3558,  3560,  3567,  3570,  3572,  3574,  3580,  3585,  3588,  3590,\n-  3592,  3594,  3596,  3598,  3600,  3602,  3604,  3606,  3608,  3610,\n-  3612,  3614,  3616,  3618,  3620,  3622,  3624,  3626,  3628,  3630,\n-  3632,  3634,  3636,  3638,  3640,  3642,  3644,  3646,  3648,  3650,\n-  3653,  3655\n+  3257,  3265,  3269,  3271,  3274,  3276,  3279,  3283,  3285,  3288,\n+  3290,  3293,  3310,  3316,  3324,  3326,  3328,  3332,  3335,  3336,\n+  3344,  3348,  3352,  3355,  3356,  3362,  3365,  3368,  3370,  3374,\n+  3379,  3382,  3392,  3397,  3398,  3405,  3408,  3411,  3413,  3416,\n+  3418,  3428,  3442,  3446,  3449,  3451,  3455,  3459,  3462,  3465,\n+  3467,  3471,  3473,  3480,  3487,  3490,  3493,  3497,  3501,  3507,\n+  3511,  3516,  3518,  3521,  3526,  3532,  3543,  3546,  3548,  3552,\n+  3557,  3559,  3566,  3569,  3571,  3573,  3579,  3584,  3587,  3589,\n+  3591,  3593,  3595,  3597,  3599,  3601,  3603,  3605,  3607,  3609,\n+  3611,  3613,  3615,  3617,  3619,  3621,  3623,  3625,  3627,  3629,\n+  3631,  3633,  3635,  3637,  3639,  3641,  3643,  3645,  3647,  3649,\n+  3652,  3654\n };\n #endif\n \n@@ -7185,7 +7185,7 @@ case 730:\n #line 3252 \"parse.y\"\n { \n                   expand_start_all_catch (); \n-                  expand_start_catch (NULL);\n+                  start_catch_handler (NULL);\n                 ;\n     break;}\n case 731:\n@@ -7194,46 +7194,45 @@ case 731:\n \t\t  int nested = (hack_decl_function_context\n \t\t\t\t(current_function_decl) != NULL_TREE);\n \t\t  expand_end_all_catch ();\n-                  expand_end_catch ();\n \t\t  finish_function (lineno, (int)yyvsp[-3].itype, nested);\n \t\t;\n     break;}\n case 732:\n-#line 3268 \"parse.y\"\n+#line 3267 \"parse.y\"\n { yyval.ttype = begin_try_block (); ;\n     break;}\n case 733:\n-#line 3270 \"parse.y\"\n+#line 3269 \"parse.y\"\n { finish_try_block (yyvsp[-1].ttype); ;\n     break;}\n case 734:\n-#line 3272 \"parse.y\"\n+#line 3271 \"parse.y\"\n { finish_handler_sequence (yyvsp[-3].ttype); ;\n     break;}\n case 737:\n-#line 3282 \"parse.y\"\n+#line 3281 \"parse.y\"\n { yyval.ttype = begin_handler(); ;\n     break;}\n case 738:\n-#line 3284 \"parse.y\"\n+#line 3283 \"parse.y\"\n { finish_handler_parms (yyvsp[-1].ttype); ;\n     break;}\n case 739:\n-#line 3286 \"parse.y\"\n+#line 3285 \"parse.y\"\n { finish_handler (yyvsp[-3].ttype); ;\n     break;}\n case 742:\n-#line 3296 \"parse.y\"\n+#line 3295 \"parse.y\"\n { expand_start_catch_block (NULL_TREE, NULL_TREE); ;\n     break;}\n case 743:\n-#line 3312 \"parse.y\"\n+#line 3311 \"parse.y\"\n { check_for_new_type (\"inside exception declarations\", yyvsp[-1].ftype);\n \t\t  expand_start_catch_block (TREE_PURPOSE (yyvsp[-1].ftype.t),\n \t\t\t\t\t    TREE_VALUE (yyvsp[-1].ftype.t)); ;\n     break;}\n case 744:\n-#line 3319 \"parse.y\"\n+#line 3318 \"parse.y\"\n { tree label;\n \t\tdo_label:\n \t\t  label = define_label (input_filename, lineno, yyvsp[-1].ttype);\n@@ -7242,98 +7241,98 @@ case 744:\n \t\t;\n     break;}\n case 745:\n-#line 3326 \"parse.y\"\n+#line 3325 \"parse.y\"\n { goto do_label; ;\n     break;}\n case 746:\n-#line 3328 \"parse.y\"\n+#line 3327 \"parse.y\"\n { goto do_label; ;\n     break;}\n case 747:\n-#line 3330 \"parse.y\"\n+#line 3329 \"parse.y\"\n { goto do_label; ;\n     break;}\n case 748:\n-#line 3335 \"parse.y\"\n+#line 3334 \"parse.y\"\n { if (yyvsp[-1].ttype) cplus_expand_expr_stmt (yyvsp[-1].ttype); ;\n     break;}\n case 750:\n-#line 3338 \"parse.y\"\n+#line 3337 \"parse.y\"\n { if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids compound statements inside for initializations\");\n \t\t;\n     break;}\n case 751:\n-#line 3347 \"parse.y\"\n+#line 3346 \"parse.y\"\n { emit_line_note (input_filename, lineno);\n \t\t  yyval.ttype = NULL_TREE; ;\n     break;}\n case 752:\n-#line 3350 \"parse.y\"\n+#line 3349 \"parse.y\"\n { emit_line_note (input_filename, lineno); ;\n     break;}\n case 753:\n-#line 3355 \"parse.y\"\n+#line 3354 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 755:\n-#line 3358 \"parse.y\"\n+#line 3357 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 756:\n-#line 3365 \"parse.y\"\n+#line 3364 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 759:\n-#line 3372 \"parse.y\"\n+#line 3371 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, yyvsp[0].ttype); ;\n     break;}\n case 760:\n-#line 3377 \"parse.y\"\n+#line 3376 \"parse.y\"\n { yyval.ttype = build_tree_list (yyval.ttype, yyvsp[-1].ttype); ;\n     break;}\n case 761:\n-#line 3382 \"parse.y\"\n+#line 3381 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyval.ttype, NULL_TREE); ;\n     break;}\n case 762:\n-#line 3384 \"parse.y\"\n+#line 3383 \"parse.y\"\n { yyval.ttype = tree_cons (NULL_TREE, yyvsp[0].ttype, yyval.ttype); ;\n     break;}\n case 763:\n-#line 3395 \"parse.y\"\n+#line 3394 \"parse.y\"\n {\n \t\t  yyval.ttype = empty_parms();\n \t\t;\n     break;}\n case 765:\n-#line 3400 \"parse.y\"\n+#line 3399 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE, yyvsp[0].ftype.t), 0);\n \t\t  check_for_new_type (\"inside parameter list\", yyvsp[0].ftype); ;\n     break;}\n case 766:\n-#line 3408 \"parse.y\"\n+#line 3407 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyval.ttype, 0); ;\n     break;}\n case 767:\n-#line 3410 \"parse.y\"\n+#line 3409 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 768:\n-#line 3413 \"parse.y\"\n+#line 3412 \"parse.y\"\n { yyval.ttype = finish_parmlist (yyvsp[-1].ttype, 1); ;\n     break;}\n case 769:\n-#line 3415 \"parse.y\"\n+#line 3414 \"parse.y\"\n { yyval.ttype = finish_parmlist (build_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t yyvsp[-1].ftype.t), 1); ;\n     break;}\n case 770:\n-#line 3418 \"parse.y\"\n+#line 3417 \"parse.y\"\n { yyval.ttype = finish_parmlist (NULL_TREE, 1); ;\n     break;}\n case 771:\n-#line 3420 \"parse.y\"\n+#line 3419 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7345,7 +7344,7 @@ case 771:\n \t\t;\n     break;}\n case 772:\n-#line 3430 \"parse.y\"\n+#line 3429 \"parse.y\"\n {\n \t\t  /* This helps us recover from really nasty\n \t\t     parse errors, for example, a missing right\n@@ -7358,98 +7357,98 @@ case 772:\n \t\t;\n     break;}\n case 773:\n-#line 3445 \"parse.y\"\n+#line 3444 \"parse.y\"\n { maybe_snarf_defarg (); ;\n     break;}\n case 774:\n-#line 3447 \"parse.y\"\n+#line 3446 \"parse.y\"\n { yyval.ttype = yyvsp[0].ttype; ;\n     break;}\n case 777:\n-#line 3458 \"parse.y\"\n+#line 3457 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[0].ftype.t); ;\n     break;}\n case 778:\n-#line 3461 \"parse.y\"\n+#line 3460 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t); ;\n     break;}\n case 779:\n-#line 3464 \"parse.y\"\n+#line 3463 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[0].ftype);\n \t\t  yyval.ttype = chainon (yyval.ttype, yyvsp[0].ftype.t); ;\n     break;}\n case 780:\n-#line 3467 \"parse.y\"\n+#line 3466 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (NULL_TREE, yyvsp[0].ttype)); ;\n     break;}\n case 781:\n-#line 3469 \"parse.y\"\n+#line 3468 \"parse.y\"\n { yyval.ttype = chainon (yyval.ttype, build_tree_list (yyvsp[0].ttype, yyvsp[-2].ttype)); ;\n     break;}\n case 783:\n-#line 3475 \"parse.y\"\n+#line 3474 \"parse.y\"\n { check_for_new_type (\"in a parameter list\", yyvsp[-1].ftype);\n \t\t  yyval.ttype = build_tree_list (NULL_TREE, yyvsp[-1].ftype.t); ;\n     break;}\n case 784:\n-#line 3485 \"parse.y\"\n+#line 3484 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); ;\n     break;}\n case 785:\n-#line 3489 \"parse.y\"\n+#line 3488 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[-1].ftype.t, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 786:\n-#line 3492 \"parse.y\"\n+#line 3491 \"parse.y\"\n { yyval.ftype.t = build_tree_list (get_decl_list (yyvsp[-1].ftype.t), yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 787:\n-#line 3495 \"parse.y\"\n+#line 3494 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag; ;\n     break;}\n case 788:\n-#line 3499 \"parse.y\"\n+#line 3498 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[0].ftype.t);\n \t\t  yyval.ftype.t = build_tree_list (specs, NULL_TREE); \n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag; ;\n     break;}\n case 789:\n-#line 3503 \"parse.y\"\n+#line 3502 \"parse.y\"\n { tree specs = strip_attrs (yyvsp[-1].ttype);\n \t\t  yyval.ftype.t = build_tree_list (specs, yyvsp[0].ttype); \n \t\t  yyval.ftype.new_type_flag = 0; ;\n     break;}\n case 790:\n-#line 3510 \"parse.y\"\n+#line 3509 \"parse.y\"\n { yyval.ftype.t = build_tree_list (NULL_TREE, yyvsp[0].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[0].ftype.new_type_flag;  ;\n     break;}\n case 791:\n-#line 3513 \"parse.y\"\n+#line 3512 \"parse.y\"\n { yyval.ftype.t = build_tree_list (yyvsp[0].ttype, yyvsp[-1].ftype.t);\n \t\t  yyval.ftype.new_type_flag = yyvsp[-1].ftype.new_type_flag;  ;\n     break;}\n case 794:\n-#line 3524 \"parse.y\"\n+#line 3523 \"parse.y\"\n { see_typename (); ;\n     break;}\n case 795:\n-#line 3529 \"parse.y\"\n+#line 3528 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  yyval.ttype = build_tree_list (integer_type_node, NULL_TREE);\n \t\t;\n     break;}\n case 796:\n-#line 3534 \"parse.y\"\n+#line 3533 \"parse.y\"\n {\n \t\t  error (\"type specifier omitted for parameter\");\n \t\t  if (TREE_CODE (yyval.ttype) == SCOPE_REF\n@@ -7460,188 +7459,188 @@ case 796:\n \t\t;\n     break;}\n case 797:\n-#line 3546 \"parse.y\"\n+#line 3545 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 798:\n-#line 3548 \"parse.y\"\n+#line 3547 \"parse.y\"\n { yyval.ttype = yyvsp[-1].ttype; ;\n     break;}\n case 799:\n-#line 3550 \"parse.y\"\n+#line 3549 \"parse.y\"\n { yyval.ttype = build_decl_list (NULL_TREE, NULL_TREE); ;\n     break;}\n case 800:\n-#line 3555 \"parse.y\"\n+#line 3554 \"parse.y\"\n { yyval.ttype = build_decl_list (NULL_TREE, groktypename(yyvsp[0].ftype.t)); ;\n     break;}\n case 802:\n-#line 3561 \"parse.y\"\n+#line 3560 \"parse.y\"\n {\n \t\t  TREE_CHAIN (yyvsp[0].ttype) = yyval.ttype;\n \t\t  yyval.ttype = yyvsp[0].ttype;\n \t\t;\n     break;}\n case 803:\n-#line 3569 \"parse.y\"\n+#line 3568 \"parse.y\"\n { yyval.ttype = NULL_TREE; ;\n     break;}\n case 804:\n-#line 3571 \"parse.y\"\n+#line 3570 \"parse.y\"\n { yyval.ttype = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 805:\n-#line 3573 \"parse.y\"\n+#line 3572 \"parse.y\"\n { yyval.ttype = make_reference_declarator (yyvsp[-1].ttype, yyvsp[0].ttype); ;\n     break;}\n case 806:\n-#line 3575 \"parse.y\"\n+#line 3574 \"parse.y\"\n { tree arg = make_pointer_declarator (yyvsp[-1].ttype, yyvsp[0].ttype);\n \t\t  yyval.ttype = build_parse_node (SCOPE_REF, yyvsp[-2].ttype, arg);\n \t\t;\n     break;}\n case 807:\n-#line 3582 \"parse.y\"\n+#line 3581 \"parse.y\"\n { got_scope = NULL_TREE; ;\n     break;}\n case 808:\n-#line 3587 \"parse.y\"\n+#line 3586 \"parse.y\"\n { yyval.ttype = ansi_opname[MULT_EXPR]; ;\n     break;}\n case 809:\n-#line 3589 \"parse.y\"\n+#line 3588 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_DIV_EXPR]; ;\n     break;}\n case 810:\n-#line 3591 \"parse.y\"\n+#line 3590 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUNC_MOD_EXPR]; ;\n     break;}\n case 811:\n-#line 3593 \"parse.y\"\n+#line 3592 \"parse.y\"\n { yyval.ttype = ansi_opname[PLUS_EXPR]; ;\n     break;}\n case 812:\n-#line 3595 \"parse.y\"\n+#line 3594 \"parse.y\"\n { yyval.ttype = ansi_opname[MINUS_EXPR]; ;\n     break;}\n case 813:\n-#line 3597 \"parse.y\"\n+#line 3596 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_AND_EXPR]; ;\n     break;}\n case 814:\n-#line 3599 \"parse.y\"\n+#line 3598 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_IOR_EXPR]; ;\n     break;}\n case 815:\n-#line 3601 \"parse.y\"\n+#line 3600 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_XOR_EXPR]; ;\n     break;}\n case 816:\n-#line 3603 \"parse.y\"\n+#line 3602 \"parse.y\"\n { yyval.ttype = ansi_opname[BIT_NOT_EXPR]; ;\n     break;}\n case 817:\n-#line 3605 \"parse.y\"\n+#line 3604 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPOUND_EXPR]; ;\n     break;}\n case 818:\n-#line 3607 \"parse.y\"\n+#line 3606 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 819:\n-#line 3609 \"parse.y\"\n+#line 3608 \"parse.y\"\n { yyval.ttype = ansi_opname[LT_EXPR]; ;\n     break;}\n case 820:\n-#line 3611 \"parse.y\"\n+#line 3610 \"parse.y\"\n { yyval.ttype = ansi_opname[GT_EXPR]; ;\n     break;}\n case 821:\n-#line 3613 \"parse.y\"\n+#line 3612 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 822:\n-#line 3615 \"parse.y\"\n+#line 3614 \"parse.y\"\n { yyval.ttype = ansi_assopname[yyvsp[0].code]; ;\n     break;}\n case 823:\n-#line 3617 \"parse.y\"\n+#line 3616 \"parse.y\"\n { yyval.ttype = ansi_opname [MODIFY_EXPR]; ;\n     break;}\n case 824:\n-#line 3619 \"parse.y\"\n+#line 3618 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 825:\n-#line 3621 \"parse.y\"\n+#line 3620 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 826:\n-#line 3623 \"parse.y\"\n+#line 3622 \"parse.y\"\n { yyval.ttype = ansi_opname[POSTINCREMENT_EXPR]; ;\n     break;}\n case 827:\n-#line 3625 \"parse.y\"\n+#line 3624 \"parse.y\"\n { yyval.ttype = ansi_opname[PREDECREMENT_EXPR]; ;\n     break;}\n case 828:\n-#line 3627 \"parse.y\"\n+#line 3626 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ANDIF_EXPR]; ;\n     break;}\n case 829:\n-#line 3629 \"parse.y\"\n+#line 3628 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_ORIF_EXPR]; ;\n     break;}\n case 830:\n-#line 3631 \"parse.y\"\n+#line 3630 \"parse.y\"\n { yyval.ttype = ansi_opname[TRUTH_NOT_EXPR]; ;\n     break;}\n case 831:\n-#line 3633 \"parse.y\"\n+#line 3632 \"parse.y\"\n { yyval.ttype = ansi_opname[COND_EXPR]; ;\n     break;}\n case 832:\n-#line 3635 \"parse.y\"\n+#line 3634 \"parse.y\"\n { yyval.ttype = ansi_opname[yyvsp[0].code]; ;\n     break;}\n case 833:\n-#line 3637 \"parse.y\"\n+#line 3636 \"parse.y\"\n { yyval.ttype = ansi_opname[COMPONENT_REF]; ;\n     break;}\n case 834:\n-#line 3639 \"parse.y\"\n+#line 3638 \"parse.y\"\n { yyval.ttype = ansi_opname[MEMBER_REF]; ;\n     break;}\n case 835:\n-#line 3641 \"parse.y\"\n+#line 3640 \"parse.y\"\n { yyval.ttype = ansi_opname[CALL_EXPR]; ;\n     break;}\n case 836:\n-#line 3643 \"parse.y\"\n+#line 3642 \"parse.y\"\n { yyval.ttype = ansi_opname[ARRAY_REF]; ;\n     break;}\n case 837:\n-#line 3645 \"parse.y\"\n+#line 3644 \"parse.y\"\n { yyval.ttype = ansi_opname[NEW_EXPR]; ;\n     break;}\n case 838:\n-#line 3647 \"parse.y\"\n+#line 3646 \"parse.y\"\n { yyval.ttype = ansi_opname[DELETE_EXPR]; ;\n     break;}\n case 839:\n-#line 3649 \"parse.y\"\n+#line 3648 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_NEW_EXPR]; ;\n     break;}\n case 840:\n-#line 3651 \"parse.y\"\n+#line 3650 \"parse.y\"\n { yyval.ttype = ansi_opname[VEC_DELETE_EXPR]; ;\n     break;}\n case 841:\n-#line 3654 \"parse.y\"\n+#line 3653 \"parse.y\"\n { yyval.ttype = grokoptypename (yyvsp[-1].ftype.t, yyvsp[0].ttype); ;\n     break;}\n case 842:\n-#line 3656 \"parse.y\"\n+#line 3655 \"parse.y\"\n { yyval.ttype = ansi_opname[ERROR_MARK]; ;\n     break;}\n }\n@@ -7842,7 +7841,7 @@ case 842:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 3659 \"parse.y\"\n+#line 3658 \"parse.y\"\n \n \n #ifdef SPEW_DEBUG"}, {"sha": "4bece8bf8902d84ece9c3d26ce12877b4a0ae6f0", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=0202018521e5aaf55b500210ddd4b603c67477ab", "patch": "@@ -961,15 +961,14 @@ compute_access (basetype_path, field)\n     return access_public_node;\n \n   previous_scope = current_scope ();\n-  \n-  context = DECL_CLASS_CONTEXT (field);\n-  if (context == NULL_TREE)\n-    context = DECL_CONTEXT (field);\n+\n+  context = DECL_REAL_CONTEXT (field);\n \n   /* Fields coming from nested anonymous unions have their DECL_CLASS_CONTEXT\n      slot set to the union type rather than the record type containing\n      the anonymous union.  */\n-  if (context && ANON_UNION_TYPE_P (context))\n+  if (context && ANON_UNION_TYPE_P (context)\n+      && TREE_CODE (field) == FIELD_DECL)\n     context = TYPE_CONTEXT (context);\n \n   /* Virtual function tables are never private.  But we should know that"}, {"sha": "81563983a613f57297634d5be3cc69356cf2a6b3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0202018521e5aaf55b500210ddd4b603c67477ab/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=0202018521e5aaf55b500210ddd4b603c67477ab", "patch": "@@ -2564,8 +2564,19 @@ build_x_function_call (function, params, decl)\n \tdecl = current_class_ref;\n \n       decl_addr = build_unary_op (ADDR_EXPR, decl, 0);\n-      function = get_member_function_from_ptrfunc (&decl_addr,\n-\t\t\t\t\t\t   TREE_OPERAND (function, 1));\n+\n+      /* Sigh.  OFFSET_REFs are being used for too many things.\n+\t They're being used both for -> and ->*, and we want to resolve\n+\t the -> cases here, but leave the ->*.  We could use\n+\t resolve_offset_ref for those, too, but it would call\n+         get_member_function_from_ptrfunc and decl_addr wouldn't get\n+         updated properly.  Nasty.  */\n+      if (TREE_CODE (TREE_OPERAND (function, 1)) == FIELD_DECL)\n+\tfunction = resolve_offset_ref (function);\n+      else\n+\tfunction = TREE_OPERAND (function, 1);\n+\n+      function = get_member_function_from_ptrfunc (&decl_addr, function);\n       params = expr_tree_cons (NULL_TREE, decl_addr, params);\n       return build_function_call (function, params);\n     }\n@@ -7271,8 +7282,7 @@ c_expand_return (retval)\n   if (valtype == NULL_TREE || TREE_CODE (valtype) == VOID_TYPE)\n     {\n       current_function_returns_null = 1;\n-      if ((pedantic && ! DECL_ARTIFICIAL (current_function_decl))\n-\t  || TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n+      if (TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n \tpedwarn (\"`return' with a value, in function returning void\");\n       expand_return (retval);\n       return;\n@@ -7477,22 +7487,17 @@ comp_ptr_ttypes_real (to, from, constp)\n \t so the usual checks are not appropriate.  */\n       if (TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n \t{\n-\t  switch (comp_cv_qualification (from, to))\n-\t    {\n-\t    case 1:\n-\t      /* FROM is more cv-qualified than TO.  */\n-\t      return 0;\n+\t  if (TYPE_READONLY (from) > TYPE_READONLY (to)\n+\t      || TYPE_VOLATILE (from) > TYPE_VOLATILE (to))\n+\t    return 0;\n \n-\t    case -1:\n-\t      /* TO is more cv-qualified than FROM.  */\n+\t  if (TYPE_READONLY (to) > TYPE_READONLY (from)\n+\t      || TYPE_VOLATILE (to) > TYPE_VOLATILE (from))\n+\t    {\n \t      if (constp == 0)\n \t\treturn 0;\n-\t      else \n+\t      else\n \t\t++to_more_cv_qualified;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n \t    }\n \n \t  if (constp > 0)"}]}