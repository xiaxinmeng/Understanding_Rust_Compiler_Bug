{"sha": "20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2", "node_id": "C_kwDOANBUbNoAKDIwYWExZWI2Y2I4NGU2YTA0ODdiNDdiMjhiMDAxMDljNWY0NmE3ZTI", "commit": {"author": {"name": "Harald Anlauf", "email": "anlauf@gmx.de", "date": "2022-08-31T09:50:35Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-25T12:44:53Z"}, "message": "fortran: Support clobbering with implicit interfaces [PR105012]\n\nBefore procedure calls, we clobber actual arguments whose associated\ndummy is INTENT(OUT).  This only applies to procedures with explicit\ninterfaces, as the knowledge of the interface is necessary to know\nwhether an argument has the INTENT(OUT) attribute.\n\nThis change also enables clobber generation for procedure calls without\nexplicit interface, when the procedure has been defined in the same\nfile because we can use the dummy arguments' characteristics from the\nprocedure definition in that case.\n\nThe knowledge of the dummy characteristics is directly available through\ngfc_actual_arglist\u2019s associated_dummy pointers which have been populated\nas a side effect of calling gfc_check_externals.\n\n\tPR fortran/105012\n\ngcc/fortran/ChangeLog:\n\n\t* trans-expr.cc (gfc_conv_procedure_call): Use dummy\n\tinformation from associated_dummy if there is no information\n\tfrom the procedure interface.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/intent_optimize_5.f90: New test.\n\nCo-Authored-By: Mikael Morin <mikael@gcc.gnu.org>", "tree": {"sha": "af1634cf383540559ef381c52c428bdcf00a8483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af1634cf383540559ef381c52c428bdcf00a8483"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2/comments", "author": {"login": "harald-anlauf", "id": 90786862, "node_id": "MDQ6VXNlcjkwNzg2ODYy", "avatar_url": "https://avatars.githubusercontent.com/u/90786862?v=4", "gravatar_id": "", "url": "https://api.github.com/users/harald-anlauf", "html_url": "https://github.com/harald-anlauf", "followers_url": "https://api.github.com/users/harald-anlauf/followers", "following_url": "https://api.github.com/users/harald-anlauf/following{/other_user}", "gists_url": "https://api.github.com/users/harald-anlauf/gists{/gist_id}", "starred_url": "https://api.github.com/users/harald-anlauf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/harald-anlauf/subscriptions", "organizations_url": "https://api.github.com/users/harald-anlauf/orgs", "repos_url": "https://api.github.com/users/harald-anlauf/repos", "events_url": "https://api.github.com/users/harald-anlauf/events{/privacy}", "received_events_url": "https://api.github.com/users/harald-anlauf/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29919bf3b6449bafd02e795abbb1966e3990c1fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29919bf3b6449bafd02e795abbb1966e3990c1fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29919bf3b6449bafd02e795abbb1966e3990c1fc"}], "stats": {"total": 43, "additions": 39, "deletions": 4}, "files": [{"sha": "214726220f73a0d593384a5c6fb40ad9307c6e1f", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2", "patch": "@@ -6505,10 +6505,21 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    {\n \t\t      gfc_conv_expr_reference (&parmse, e);\n \n-\t\t      if (fsym\n-\t\t\t  && fsym->attr.intent == INTENT_OUT\n-\t\t\t  && !fsym->attr.allocatable\n-\t\t\t  && !fsym->attr.pointer\n+\t\t      gfc_symbol *dsym = fsym;\n+\t\t      gfc_dummy_arg *dummy;\n+\n+\t\t      /* Use associated dummy as fallback for formal\n+\t\t\t argument if there is no explicit interface.  */\n+\t\t      if (dsym == NULL\n+\t\t\t  && (dummy = arg->associated_dummy)\n+\t\t\t  && dummy->intrinsicness == GFC_NON_INTRINSIC_DUMMY_ARG\n+\t\t\t  && dummy->u.non_intrinsic->sym)\n+\t\t\tdsym = dummy->u.non_intrinsic->sym;\n+\n+\t\t      if (dsym\n+\t\t\t  && dsym->attr.intent == INTENT_OUT\n+\t\t\t  && !dsym->attr.allocatable\n+\t\t\t  && !dsym->attr.pointer\n \t\t\t  && e->expr_type == EXPR_VARIABLE\n \t\t\t  && e->ref == NULL\n \t\t\t  && e->symtree"}, {"sha": "2f184bf84a84b617f75dcdf16f9a2c73d7e24bd4", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_5.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_5.f90?ref=20aa1eb6cb84e6a0487b47b28b00109c5f46a7e2", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/105012\n+! Check that the INTENT(OUT) attribute causes one clobber to be emitted in\n+! the caller before the call to Y in the *.original dump, and the\n+! initialization constant to be optimized away in the *.optimized dump,\n+! despite the non-explicit interface if the subroutine with the INTENT(OUT)\n+! is declared in the same file.\n+\n+SUBROUTINE Y (Z)\n+      integer, intent(out) :: Z\n+      Z = 42\n+END SUBROUTINE Y\n+PROGRAM TEST\n+    integer :: X\n+    X = 123456789\n+    CALL Y (X)\n+    if (X.ne.42) STOP 1\n+END PROGRAM\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump \"x = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }"}]}