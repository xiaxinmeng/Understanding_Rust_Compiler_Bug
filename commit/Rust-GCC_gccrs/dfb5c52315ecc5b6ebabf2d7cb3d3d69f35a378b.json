{"sha": "dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZiNWM1MjMxNWVjYzViNmViYWJmMmQ3Y2IzZDNkNjlmMzVhMzc4Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-12-22T18:00:39Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-12-22T18:00:39Z"}, "message": "re PR c++/18464 (error message about \"non-lvalue in unary '&'\" when using ?: operator)\n\n\tPR c++/18464\n\t* call.c (build_this): In templates, do not bother with\n\tbuild_unary_op.\n\t* typeck.c (unary_complex_lvalue): In a template, always refuse\n\tsimplifications.\n\n\tPR c++/18492\n\t* cp-gimplify.c (cp_genericize): Relax assertion.\n\n\tPR c++/11224\n\t* cvt.c (convert_to_void): Warn about unused values.\n\n\tPR c++/18257\n\t* rtti.c (emit_support_tinfos): On systems without weak symbols,\n\temit the runtime library type-info objects as non-COMDAT.\n\n\tPR c++/18464\n\t* g++.dg/template/cond5.C: New test.\n\n\tPR c++/18492\n\t* g++.dg/inherit/thunk3.C: New test.\n\n\tPR c++/11224\n\t* g++.dg/warn/Wunused-9.C: New test.\n\nFrom-SVN: r92491", "tree": {"sha": "92d85ea737af3ab701ec3aa12c9d0ae5763ee5c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92d85ea737af3ab701ec3aa12c9d0ae5763ee5c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/comments", "author": null, "committer": null, "parents": [{"sha": "606145e4e0e54d412059033a6261c53bf11d7b6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/606145e4e0e54d412059033a6261c53bf11d7b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/606145e4e0e54d412059033a6261c53bf11d7b6d"}], "stats": {"total": 213, "additions": 181, "deletions": 32}, "files": [{"sha": "accc1e30296f59f5512a3bb8a32c70597e1837ef", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -1,3 +1,21 @@\n+2004-12-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/18464\n+\t* call.c (build_this): In templates, do not bother with\n+\tbuild_unary_op.\n+\t* typeck.c (unary_complex_lvalue): In a template, always refuse\n+\tsimplifications. \n+\n+\tPR c++/18492\n+\t* cp-gimplify.c (cp_genericize): Relax assertion.\n+\n+\tPR c++/11224\n+\t* cvt.c (convert_to_void): Warn about unused values.\n+\n+\tPR c++/18257\n+\t* rtti.c (emit_support_tinfos): On systems without weak symbols,\n+\temit the runtime library type-info objects as non-COMDAT. \n+\n 2004-12-21  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/18378"}, {"sha": "f94526af85cc17587349440f9a48c4eea3bab8c7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -2333,10 +2333,18 @@ any_strictly_viable (struct z_candidate *cands)\n   return false;\n }\n \n+/* OBJ is being used in an expression like \"OBJ.f (...)\".  In other\n+   words, it is about to become the \"this\" pointer for a member\n+   function call.  Take the address of the object.  */\n+\n static tree\n build_this (tree obj)\n {\n-  /* Fix this to work on non-lvalues.  */\n+  /* In a template, we are only concerned about the type of the\n+     expression, so we can take a shortcut.  */\n+  if (processing_template_decl)\n+    return build_address (obj);\n+\n   return build_unary_op (ADDR_EXPR, obj, 0);\n }\n "}, {"sha": "413a93380104e6d340511d1bf874d583f8ebe899", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -334,17 +334,19 @@ cp_genericize (tree fndecl)\n \n   /* Fix up the types of parms passed by invisible reference.  */\n   for (t = DECL_ARGUMENTS (fndecl); t; t = TREE_CHAIN (t))\n-    {\n-      gcc_assert (!DECL_BY_REFERENCE (t));\n-      if (TREE_ADDRESSABLE (TREE_TYPE (t)))\n-\t{\n-\t  gcc_assert (DECL_ARG_TYPE (t) != TREE_TYPE (t));\n-\t  TREE_TYPE (t) = DECL_ARG_TYPE (t);\n-\t  DECL_BY_REFERENCE (t) = 1;\n-\t  TREE_ADDRESSABLE (t) = 0;\n-\t  relayout_decl (t);\n-\t}\n-    }\n+    if (TREE_ADDRESSABLE (TREE_TYPE (t)))\n+      {\n+\t/* If a function's arguments are copied to create a thunk,\n+\t   then DECL_BY_REFERENCE will be set -- but the type of the\n+\t   argument will be a pointer type, so we will never get\n+\t   here.  */\n+\tgcc_assert (!DECL_BY_REFERENCE (t));\n+\tgcc_assert (DECL_ARG_TYPE (t) != TREE_TYPE (t));\n+\tTREE_TYPE (t) = DECL_ARG_TYPE (t);\n+\tDECL_BY_REFERENCE (t) = 1;\n+\tTREE_ADDRESSABLE (t) = 0;\n+\trelayout_decl (t);\n+      }\n \n   /* Do the same for the return value.  */\n   if (TREE_ADDRESSABLE (TREE_TYPE (DECL_RESULT (fndecl))))"}, {"sha": "64db10097a200357236bc2d0b5bf93a13141ead2", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -909,9 +909,43 @@ convert_to_void (tree expr, const char *implicit)\n   \n   if (expr != error_mark_node && !VOID_TYPE_P (TREE_TYPE (expr)))\n     {\n-      if (implicit && warn_unused_value\n-\t  && !TREE_SIDE_EFFECTS (expr) && !TREE_NO_WARNING (expr))\n-\twarning (\"%s has no effect\", implicit);\n+      if (implicit && warn_unused_value && !TREE_NO_WARNING (expr))\n+\t{\n+\t  /* The middle end does not warn about expressions that have\n+\t     been explicitly cast to void, so we must do so here.  */\n+\t  if (!TREE_SIDE_EFFECTS (expr))\n+\t    warning (\"%s has no effect\", implicit);\n+\t  else \n+\t    { \n+\t      tree e;\n+\t      enum tree_code code;\n+\t      enum tree_code_class class;\n+\t      \n+\t      e = expr;\n+\t      /* We might like to warn about (say) \"(int) f()\", as the\n+\t\t cast has no effect, but the compiler itself will\n+\t\t generate implicit conversions under some\n+\t\t circmstances.  (For example a block copy will be\n+\t\t turned into a call to \"__builtin_memcpy\", with a\n+\t\t conversion of the return value to an appropriate\n+\t\t type.)  So, to avoid false positives, we strip\n+\t\t conversions.  */\n+\t      STRIP_NOPS (e);\n+\n+\t      code = TREE_CODE (e);\n+\t      class = TREE_CODE_CLASS (code);\n+\t      if (class == tcc_comparison\n+\t\t   || class == tcc_unary\n+\t\t   || (class == tcc_binary \n+\t\t       && !(code == MODIFY_EXPR\n+\t\t\t    || code == INIT_EXPR\n+\t\t\t    || code == PREDECREMENT_EXPR\n+\t\t\t    || code == PREINCREMENT_EXPR\n+\t\t\t    || code == POSTDECREMENT_EXPR\n+\t\t\t    || code == POSTINCREMENT_EXPR)))\n+\t\twarning (\"value computed is not used\");\n+\t    }\n+\t}\n       expr = build1 (CONVERT_EXPR, void_type_node, expr);\n     }\n   return expr;"}, {"sha": "6c92d19c52880ae85c3d739cbaa8b8b82f7cce78", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -1345,22 +1345,32 @@ emit_support_tinfos (void)\n   for (ix = 0; fundamentals[ix]; ix++)\n     {\n       tree bltn = *fundamentals[ix];\n-      tree bltn_ptr = build_pointer_type (bltn);\n-      tree bltn_const_ptr = build_pointer_type\n-              (build_qualified_type (bltn, TYPE_QUAL_CONST));\n-      tree tinfo;\n-      \n-      tinfo = get_tinfo_decl (bltn);\n-      TREE_USED (tinfo) = 1;\n-      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (tinfo)) = 1;\n-      \n-      tinfo = get_tinfo_decl (bltn_ptr);\n-      TREE_USED (tinfo) = 1;\n-      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (tinfo)) = 1;\n-      \n-      tinfo = get_tinfo_decl (bltn_const_ptr);\n-      TREE_USED (tinfo) = 1;\n-      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (tinfo)) = 1;\n+      tree types[3] = {\n+\tbltn,\n+\tbuild_pointer_type (bltn),\n+\tbuild_pointer_type (build_qualified_type (bltn, TYPE_QUAL_CONST))\n+      };\n+      int i;\n+\n+      for (i = 0; i < 3; ++i)\n+\t{\n+\t  tree tinfo;\n+\t  tinfo = get_tinfo_decl (types[i]);\n+\t  TREE_USED (tinfo) = 1;\n+\t  mark_needed (tinfo);\n+\t  /* The C++ ABI requires that these objects be COMDAT.  But,\n+\t     On systems without weak symbols, initialized COMDAT \n+\t     objects are emitted with internal linkage.  (See\n+\t     comdat_linkage for details.)  Since we want these objects\n+\t     to have external linkage so that copies do not have to be\n+\t     emitted in code outside the runtime library, we make them\n+\t     non-COMDAT here.  */\n+\t  if (!flag_weak)\n+\t    {\n+\t      gcc_assert (TREE_PUBLIC (tinfo) && !DECL_COMDAT (tinfo));\n+\t      DECL_INTERFACE_KNOWN (tinfo) = 1;\n+\t    }\n+\t}\n     }\n }\n "}, {"sha": "6ce3811bf3fa61ec29cbfc36a6ee1c00a61e5004", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -4153,11 +4153,18 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n    for certain kinds of expressions which are not really lvalues\n    but which we can accept as lvalues.\n \n-   If ARG is not a kind of expression we can handle, return zero.  */\n+   If ARG is not a kind of expression we can handle, return\n+   NULL_TREE.  */\n    \n tree\n unary_complex_lvalue (enum tree_code code, tree arg)\n {\n+  /* Inside a template, making these kinds of adjustments is\n+     pointless; we are only concerned with the type of the\n+     expression.  */\n+  if (processing_template_decl)\n+    return NULL_TREE;\n+\n   /* Handle (a, b) used as an \"lvalue\".  */\n   if (TREE_CODE (arg) == COMPOUND_EXPR)\n     {"}, {"sha": "555353a2d567615f230f6b647461dcf34e88886e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -1,3 +1,14 @@\n+2004-12-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/18464\n+\t* g++.dg/template/cond5.C: New test.\n+\n+\tPR c++/18492\n+\t* g++.dg/inherit/thunk3.C: New test.\n+\n+\tPR c++/11224\n+\t* g++.dg/warn/Wunused-9.C: New test.\n+\t\n 2004-12-22  Janis Johnson  <janis187@us.ibm.com>\n \n \t* lib/gcc-dg.exp (dg-xfail-if): Fix the flags compared against."}, {"sha": "9787aa9c6c278390bf59f2cf4808fe8d50e05b2d", "filename": "gcc/testsuite/g++.dg/inherit/thunk3.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fthunk3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fthunk3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fthunk3.C?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -0,0 +1,12 @@\n+// PR c++/18492\n+\n+struct X{ ~X(); };\n+struct B\n+{\n+  virtual void a( X ) = 0;\n+}; \n+struct D : public virtual B \n+{\n+  void a( X );\n+}; \n+void D::a( X ){}"}, {"sha": "bba31e6afb282408557eae0d0a3bbc457673bd42", "filename": "gcc/testsuite/g++.dg/template/cond5.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcond5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcond5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcond5.C?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/18464\n+\n+struct A\n+{\n+  A(int);\n+  operator void*() const;\n+};\n+\n+template<int> void foo(const A& x) { 0 ? x : (x ? x : 0); }"}, {"sha": "30e3f6d69555850c1e3bce8d0b749571d68b00de", "filename": "gcc/testsuite/g++.dg/warn/Wunused-9.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWunused-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWunused-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWunused-9.C?ref=dfb5c52315ecc5b6ebabf2d7cb3d3d69f35a378b", "patch": "@@ -0,0 +1,38 @@\n+// PR c++/11224\n+// { dg-options \"-Wunused\" }\n+\n+struct someclass {\n+\n+  bool isEmpty() const { return true; }\n+};\n+\n+int main()\n+{\n+  bool bOk = false;\n+  someclass foo;\n+\n+  bOk == foo.isEmpty(); // { dg-warning \"not used\" }\n+\n+  return bOk;\n+}\n+\n+int& f();\n+\n+void g() {\n+  f() == 0; // { dg-warning \"not used\" }\n+  f() != 1; // { dg-warning \"not used\" }\n+  f() < 2; // { dg-warning \"not used\" }\n+  f() > 3; // { dg-warning \"not used\" }\n+  f() <= 4; // { dg-warning \"not used\" }\n+  f() >= 5; // { dg-warning \"not used\" }\n+  f() + 6; // { dg-warning \"not used\" }\n+  f() - 7; // { dg-warning \"not used\" }\n+  f() * 8; // { dg-warning \"not used\" }\n+  f() / 9; // { dg-warning \"not used\" }\n+  +f(); // { dg-warning \"not used\" \"\" { xfail *-*-* } }\n+  -f(); // { dg-warning \"not used\" }\n+  ++f();\n+  --f();\n+  f() = 10;\n+  f() <<= 11; \n+}"}]}