{"sha": "9e824336e5ae0b5e293a778dcec78cb01d1bd953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU4MjQzMzZlNWFlMGI1ZTI5M2E3NzhkY2VjNzhjYjAxZDFiZDk1Mw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-06-09T21:34:08Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-06-09T21:34:08Z"}, "message": "tree-scalar-evolution.c (follow_ssa_edge_in_rhs, [...]): Keep more precise track of the size of the expression.\n\n\t* tree-scalar-evolution.c (follow_ssa_edge_in_rhs,\n\tfollow_ssa_edge_in_condition_phi, follow_ssa_edge): Keep more precise\n\ttrack of the size of the expression.\n\t* cfghooks.c (merge_blocks): Remove block from loops structure only\n\tafter call of the merge_blocks hook.\n\n\t* gcc.dg/tree-ssa/loop-28.c: New testcase.\n\nFrom-SVN: r125595", "tree": {"sha": "bfeea6566a3710480f5e9a593f94251b8b3cec45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfeea6566a3710480f5e9a593f94251b8b3cec45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e824336e5ae0b5e293a778dcec78cb01d1bd953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e824336e5ae0b5e293a778dcec78cb01d1bd953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e824336e5ae0b5e293a778dcec78cb01d1bd953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e824336e5ae0b5e293a778dcec78cb01d1bd953/comments", "author": null, "committer": null, "parents": [{"sha": "408a86c03e9236cd848a21a8301e94c0f86edb62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/408a86c03e9236cd848a21a8301e94c0f86edb62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/408a86c03e9236cd848a21a8301e94c0f86edb62"}], "stats": {"total": 61, "additions": 57, "deletions": 4}, "files": [{"sha": "830517d3b4ef1f2d3fd7668656ebcd08859aee5d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e824336e5ae0b5e293a778dcec78cb01d1bd953", "patch": "@@ -1,3 +1,11 @@\n+2007-06-09  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-scalar-evolution.c (follow_ssa_edge_in_rhs,\n+\tfollow_ssa_edge_in_condition_phi, follow_ssa_edge): Keep more precise\n+\ttrack of the size of the expression.\n+\t* cfghooks.c (merge_blocks): Remove block from loops structure only\n+\tafter call of the merge_blocks hook.\n+\n 2007-06-09  Tom Tromey  <tromey@redhat.com>\n \n \t* c-decl.c (grokdeclarator): Added 'deprecated_state' argument."}, {"sha": "98b5e349e7073151cf3ee7ec9dcf7d2a6402b518", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=9e824336e5ae0b5e293a778dcec78cb01d1bd953", "patch": "@@ -646,11 +646,11 @@ merge_blocks (basic_block a, basic_block b)\n   if (!cfg_hooks->merge_blocks)\n     internal_error (\"%s does not support merge_blocks\", cfg_hooks->name);\n \n+  cfg_hooks->merge_blocks (a, b);\n+\n   if (current_loops != NULL)\n     remove_bb_from_loops (b);\n \n-  cfg_hooks->merge_blocks (a, b);\n-\n   /* Normally there should only be one successor of A and that is B, but\n      partway though the merge of blocks for conditional_execution we'll\n      be merging a TEST block with THEN and ELSE successors.  Free the"}, {"sha": "821e1c569c3bfb390301fa58f12cb4d307f78c81", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e824336e5ae0b5e293a778dcec78cb01d1bd953", "patch": "@@ -1,3 +1,7 @@\n+2007-06-09  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-28.c: New testcase.\n+\n 2007-06-09  Ian Lance Taylor  <iant@google.com>\n \n \tPR tree-optimization/32169"}, {"sha": "19f0ac5c18416ce071d2d5dfa326c1face3bb071", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-28.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-28.c?ref=9e824336e5ae0b5e293a778dcec78cb01d1bd953", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -fdump-tree-final_cleanup -fdump-tree-aprefetch --param max-unrolled-insns=1000\" } */\n+\n+char x[100000];\n+\n+void foo(int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    x[i] = (char) i;\n+}\n+\n+/* There should be 64 MEMs in the unrolled loop and one more in the copy of the loop\n+   for the rest of the iterations.  */\n+\n+/* { dg-final { scan-tree-dump-times \"MEM\" 65 \"final_cleanup\" } } */\n+\n+/* There should be no i_a = i_b assignments.  */\n+/* { dg-final { scan-tree-dump-times \"i_.*= i_\\[0-9\\]*;\" 0 \"aprefetch\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"aprefetch\" } } */"}, {"sha": "a5444abb38427fcbb7ba6f059cf56ee5d402d6c6", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e824336e5ae0b5e293a778dcec78cb01d1bd953/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=9e824336e5ae0b5e293a778dcec78cb01d1bd953", "patch": "@@ -1056,6 +1056,12 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t    {\n \t      /* Match an assignment under the form: \n \t\t \"a = b + c\".  */\n+      \n+\t      /* We want only assignments of form \"name + name\" contribute to\n+\t\t LIMIT, as the other cases do not necessarily contribute to\n+\t\t the complexity of the expression.  */\n+\t      limit++;\n+\n \t      evol = *evolution_of_loop;\n \t      res = follow_ssa_edge \n \t\t(loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n@@ -1141,6 +1147,13 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n \t{\n \t  /* Match an assignment under the form: \n \t     \"a = b - ...\".  */\n+\n+\t  /* We want only assignments of form \"name - name\" contribute to\n+\t     LIMIT, as the other cases do not necessarily contribute to\n+\t     the complexity of the expression.  */\n+\t  if (TREE_CODE (rhs1) == SSA_NAME)\n+\t    limit++;\n+\n \t  res = follow_ssa_edge (loop, SSA_NAME_DEF_STMT (rhs0), halting_phi, \n \t\t\t\t evolution_of_loop, limit);\n \t  if (res == t_true)\n@@ -1255,6 +1268,10 @@ follow_ssa_edge_in_condition_phi (struct loop *loop,\n \n   *evolution_of_loop = evolution_of_branch;\n \n+  /* If the phi node is just a copy, do not increase the limit.  */\n+  if (PHI_NUM_ARGS (condition_phi) > 1)\n+    limit++;\n+\n   for (i = 1; i < PHI_NUM_ARGS (condition_phi); i++)\n     {\n       /* Quickly give up when the evolution of one of the branches is\n@@ -1338,7 +1355,7 @@ follow_ssa_edge (struct loop *loop, tree def, tree halting_phi,\n     return t_false;\n   \n   /* Give up if the path is longer than the MAX that we allow.  */\n-  if (limit++ > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))\n+  if (limit > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))\n     return t_dont_know;\n   \n   def_loop = loop_containing_stmt (def);\n@@ -1369,7 +1386,7 @@ follow_ssa_edge (struct loop *loop, tree def, tree halting_phi,\n       /* Inner loop.  */\n       if (flow_loop_nested_p (loop, def_loop))\n \treturn follow_ssa_edge_inner_loop_phi \n-\t  (loop, def, halting_phi, evolution_of_loop, limit);\n+\t  (loop, def, halting_phi, evolution_of_loop, limit + 1);\n \n       /* Outer loop.  */\n       return t_false;"}]}