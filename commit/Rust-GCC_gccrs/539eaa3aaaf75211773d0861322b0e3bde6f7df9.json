{"sha": "539eaa3aaaf75211773d0861322b0e3bde6f7df9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM5ZWFhM2FhYWY3NTIxMTc3M2QwODYxMzIyYjBlM2JkZTZmN2RmOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-20T04:18:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-20T04:18:08Z"}, "message": "re PR middle-end/19304 (wrong code for spec test from emit_move_change_mode)\n\n        PR middle-end/19304\n        * expr.c (emit_move_change_mode): New argument force; use\n        simplify_gen_subreg if true.\n        (emit_move_via_alt_mode): Merge into ...\n        (emit_move_via_integer): ... here.\n        (emit_move_ccmode): Use emit_move_change_mode directly.\n\nFrom-SVN: r93944", "tree": {"sha": "57795ca936236a40d7b3f6d2d97ea19ea21faac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57795ca936236a40d7b3f6d2d97ea19ea21faac5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/539eaa3aaaf75211773d0861322b0e3bde6f7df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539eaa3aaaf75211773d0861322b0e3bde6f7df9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/539eaa3aaaf75211773d0861322b0e3bde6f7df9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/539eaa3aaaf75211773d0861322b0e3bde6f7df9/comments", "author": null, "committer": null, "parents": [{"sha": "72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72910a0b3b6c68d3ca4d636b9a06923c07a45df8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72910a0b3b6c68d3ca4d636b9a06923c07a45df8"}], "stats": {"total": 55, "additions": 31, "deletions": 24}, "files": [{"sha": "e3d1f0d82e27745cfec45cab9d9c69f32e0893d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539eaa3aaaf75211773d0861322b0e3bde6f7df9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539eaa3aaaf75211773d0861322b0e3bde6f7df9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=539eaa3aaaf75211773d0861322b0e3bde6f7df9", "patch": "@@ -1,3 +1,12 @@\n+2005-01-19  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/19304\n+\t* expr.c (emit_move_change_mode): New argument force; use\n+\tsimplify_gen_subreg if true.\n+\t(emit_move_via_alt_mode): Merge into ...\n+\t(emit_move_via_integer): ... here.\n+\t(emit_move_ccmode): Use emit_move_change_mode directly.\n+\n 2005-01-19  Richard Henderson  <rth@redhat.com>\n \n \tPR target/19518"}, {"sha": "cc725e4d79ed631ddfe1099d06772e4d97a74b68", "filename": "gcc/expr.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/539eaa3aaaf75211773d0861322b0e3bde6f7df9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/539eaa3aaaf75211773d0861322b0e3bde6f7df9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=539eaa3aaaf75211773d0861322b0e3bde6f7df9", "patch": "@@ -2707,13 +2707,14 @@ read_complex_part (rtx cplx, bool imag_p)\n \t\t\t    true, NULL_RTX, imode, imode);\n }\n \f\n-/* A subroutine of emit_move_via_alt_mode.  Yet another lowpart generator.\n+/* A subroutine of emit_move_insn_1.  Yet another lowpart generator.\n    NEW_MODE and OLD_MODE are the same size.  Return NULL if X cannot be\n-   represented in NEW_MODE.  */\n+   represented in NEW_MODE.  If FORCE is true, this will never happen, as\n+   we'll force-create a SUBREG if needed.  */\n \n static rtx\n emit_move_change_mode (enum machine_mode new_mode,\n-\t\t       enum machine_mode old_mode, rtx x)\n+\t\t       enum machine_mode old_mode, rtx x, bool force)\n {\n   rtx ret;\n \n@@ -2735,30 +2736,17 @@ emit_move_change_mode (enum machine_mode new_mode,\n \t that the new mode is ok for a hard register.  If we were to use\n \t simplify_gen_subreg, we would create the subreg, but would\n \t probably run into the target not being able to implement it.  */\n-      ret = simplify_subreg (new_mode, x, old_mode, 0);\n+      /* Except, of course, when FORCE is true, when this is exactly what\n+\t we want.  Which is needed for CCmodes on some targets.  */\n+      if (force)\n+\tret = simplify_gen_subreg (new_mode, x, old_mode, 0);\n+      else\n+\tret = simplify_subreg (new_mode, x, old_mode, 0);\n     }\n \n   return ret;\n }\n \n-/* A subroutine of emit_move_insn_1.  Generate a move from Y into X using\n-   ALT_MODE instead of the operand's natural mode, MODE.  CODE is the insn\n-   code for the move in ALT_MODE, and is known to be valid.  Returns the\n-   instruction emitted, or NULL if X or Y cannot be represented in ALT_MODE.  */\n-\n-static rtx\n-emit_move_via_alt_mode (enum machine_mode alt_mode, enum machine_mode mode,\n-\t\t\tenum insn_code code, rtx x, rtx y)\n-{\n-  x = emit_move_change_mode (alt_mode, mode, x);\n-  if (x == NULL_RTX)\n-    return NULL_RTX;\n-  y = emit_move_change_mode (alt_mode, mode, y);\n-  if (y == NULL_RTX)\n-    return NULL_RTX;\n-  return emit_insn (GEN_FCN (code) (x, y));\n-}\n-\n /* A subroutine of emit_move_insn_1.  Generate a move from Y into X using\n    an integer mode of the same size as MODE.  Returns the instruction\n    emitted, or NULL if such a move could not be generated.  */\n@@ -2779,7 +2767,13 @@ emit_move_via_integer (enum machine_mode mode, rtx x, rtx y)\n   if (code == CODE_FOR_nothing)\n     return NULL_RTX;\n \n-  return emit_move_via_alt_mode (imode, mode, code, x, y);\n+  x = emit_move_change_mode (imode, mode, x, false);\n+  if (x == NULL_RTX)\n+    return NULL_RTX;\n+  y = emit_move_change_mode (imode, mode, y, false);\n+  if (y == NULL_RTX)\n+    return NULL_RTX;\n+  return emit_insn (GEN_FCN (code) (x, y));\n }\n \n /* A subroutine of emit_move_insn_1.  X is a push_operand in MODE.\n@@ -2943,7 +2937,11 @@ emit_move_ccmode (enum machine_mode mode, rtx x, rtx y)\n     {\n       enum insn_code code = mov_optab->handlers[CCmode].insn_code;\n       if (code != CODE_FOR_nothing)\n-\treturn emit_move_via_alt_mode (CCmode, mode, code, x, y);\n+\t{\n+\t  x = emit_move_change_mode (CCmode, mode, x, true);\n+\t  y = emit_move_change_mode (CCmode, mode, y, true);\n+\t  return emit_insn (GEN_FCN (code) (x, y));\n+\t}\n     }\n \n   /* Otherwise, find the MODE_INT mode of the same width.  */"}]}