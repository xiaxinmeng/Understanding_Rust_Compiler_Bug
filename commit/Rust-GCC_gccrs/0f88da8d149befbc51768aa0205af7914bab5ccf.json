{"sha": "0f88da8d149befbc51768aa0205af7914bab5ccf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY4OGRhOGQxNDliZWZiYzUxNzY4YWEwMjA1YWY3OTE0YmFiNWNjZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2011-05-03T00:03:38Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2011-05-03T00:03:38Z"}, "message": "functional (bind): Remove from overload set when first argument type might be a socket file descriptor.\n\n2011-05-03  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n\t* include/std/functional (bind): Remove from overload set when first\n\targument type might be a socket file descriptor.\n\t* testsuite/20_util/bind/socket.cc: New.\n\nFrom-SVN: r173279", "tree": {"sha": "39770ca44c592c150d9d3cf96053a78b5f84a7a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39770ca44c592c150d9d3cf96053a78b5f84a7a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f88da8d149befbc51768aa0205af7914bab5ccf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f88da8d149befbc51768aa0205af7914bab5ccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f88da8d149befbc51768aa0205af7914bab5ccf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f88da8d149befbc51768aa0205af7914bab5ccf/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd8ac087e6e14949cf8d223b55432c16ec7b2126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd8ac087e6e14949cf8d223b55432c16ec7b2126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd8ac087e6e14949cf8d223b55432c16ec7b2126"}], "stats": {"total": 106, "additions": 86, "deletions": 20}, "files": [{"sha": "2a3a80f3a1aa7797c4a509c411cf1f49e3e63e91", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f88da8d149befbc51768aa0205af7914bab5ccf/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f88da8d149befbc51768aa0205af7914bab5ccf/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0f88da8d149befbc51768aa0205af7914bab5ccf", "patch": "@@ -1,3 +1,9 @@\n+2011-05-03  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/std/functional (bind): Remove from overload set when first\n+\targument type might be a socket file descriptor.\n+\t* testsuite/20_util/bind/socket.cc: New.\n+\n 2011-05-03  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/48848"}, {"sha": "f8ea41cc3eeb3a93669a0dc373a87e1992aee596", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f88da8d149befbc51768aa0205af7914bab5ccf/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f88da8d149befbc51768aa0205af7914bab5ccf/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=0f88da8d149befbc51768aa0205af7914bab5ccf", "patch": "@@ -1422,56 +1422,75 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n     struct is_bind_expression<_Bind_result<_Result, _Signature> >\n     : public true_type { };\n \n-  template<typename _Functor, typename... _ArgTypes>\n+  // Trait type used to remove std::bind() from overload set via SFINAE\n+  // when first argument has integer type, so that std::bind() will\n+  // not be a better match than ::bind() from the BSD Sockets API.\n+  template<typename _Tp>\n+    class __is_socketlike\n+    {\n+      typedef typename decay<_Tp>::type _Tp2;\n+    public:\n+      static const bool value =\n+\tis_integral<_Tp2>::value || is_enum<_Tp2>::value;\n+    };\n+\n+  template<bool _SocketLike, typename _Func, typename... _BoundArgs>\n     struct _Bind_helper\n     {\n-      typedef _Maybe_wrap_member_pointer<typename decay<_Functor>::type>\n+      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>\n \t__maybe_type;\n-      typedef typename __maybe_type::type __functor_type;\n-      typedef _Bind<__functor_type(typename decay<_ArgTypes>::type...)> type;\n+      typedef typename __maybe_type::type __func_type;\n+      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;\n     };\n \n+  // Partial specialization for is_socketlike == true, does not define\n+  // nested type so std::bind() will not participate in overload resolution\n+  // when the first argument might be a socket file descriptor.\n+  template<typename _Func, typename... _BoundArgs>\n+    struct _Bind_helper<true, _Func, _BoundArgs...>\n+    { };\n+\n   /**\n    *  @brief Function template for std::bind.\n    *  @ingroup binders\n    */\n-  template<typename _Functor, typename... _ArgTypes>\n-    inline\n-    typename _Bind_helper<_Functor, _ArgTypes...>::type\n-    bind(_Functor&& __f, _ArgTypes&&... __args)\n+  template<typename _Func, typename... _BoundArgs>\n+    inline typename\n+    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type\n+    bind(_Func&& __f, _BoundArgs&&... __args)\n     {\n-      typedef _Bind_helper<_Functor, _ArgTypes...> __helper_type;\n+      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;\n       typedef typename __helper_type::__maybe_type __maybe_type;\n       typedef typename __helper_type::type __result_type;\n-      return __result_type(__maybe_type::__do_wrap(std::forward<_Functor>(__f)),\n-\t\t\t   std::forward<_ArgTypes>(__args)...);\n+      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),\n+\t\t\t   std::forward<_BoundArgs>(__args)...);\n     }\n \n-  template<typename _Result, typename _Functor, typename... _ArgTypes>\n+  template<typename _Result, typename _Func, typename... _BoundArgs>\n     struct _Bindres_helper\n     {\n-      typedef _Maybe_wrap_member_pointer<typename decay<_Functor>::type>\n+      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>\n \t__maybe_type;\n       typedef typename __maybe_type::type __functor_type;\n       typedef _Bind_result<_Result,\n-\t\t\t   __functor_type(typename decay<_ArgTypes>::type...)>\n+\t\t\t   __functor_type(typename decay<_BoundArgs>::type...)>\n \ttype;\n     };\n \n   /**\n    *  @brief Function template for std::bind<R>.\n    *  @ingroup binders\n    */\n-  template<typename _Result, typename _Functor, typename... _ArgTypes>\n+  template<typename _Result, typename _Func, typename... _BoundArgs>\n     inline\n-    typename _Bindres_helper<_Result, _Functor, _ArgTypes...>::type\n-    bind(_Functor&& __f, _ArgTypes&&... __args)\n+    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type\n+    bind(_Func&& __f, _BoundArgs&&... __args)\n     {\n-      typedef _Bindres_helper<_Result, _Functor, _ArgTypes...> __helper_type;\n+      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;\n       typedef typename __helper_type::__maybe_type __maybe_type;\n       typedef typename __helper_type::type __result_type;\n-      return __result_type(__maybe_type::__do_wrap(std::forward<_Functor>(__f)),\n-\t\t\t   std::forward<_ArgTypes>(__args)...);\n+      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),\n+\t\t\t   std::forward<_BoundArgs>(__args)...);\n     }\n \n   /**"}, {"sha": "d3ccea2b3ebe63cbc1eeecd5914661615e5b9d6d", "filename": "libstdc++-v3/testsuite/20_util/bind/socket.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f88da8d149befbc51768aa0205af7914bab5ccf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fsocket.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f88da8d149befbc51768aa0205af7914bab5ccf/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fsocket.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2Fsocket.cc?ref=0f88da8d149befbc51768aa0205af7914bab5ccf", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 20.8.9 Function template bind\n+\n+// Verify that calls to bind() in BSD sockets API do not match std::bind()\n+// (this is a GNU extension)\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++0x\" }\n+\n+#include <functional>\n+\n+struct my_sockaddr { };\n+typedef long my_socklen_t;\n+int bind(int, const my_sockaddr*, my_socklen_t);\n+\n+using namespace std;\n+\n+int test01()\n+{\n+  int fd = 1;\n+  my_sockaddr sa;           // N.B. non-const\n+  size_t len = sizeof(sa);  // N.B. size_t not socklen_t\n+  return bind(fd, &sa, sizeof(sa));\n+}\n+"}]}