{"sha": "95f79357c5e37b27626a5513b612f8b598e5e8ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVmNzkzNTdjNWUzN2IyNzYyNmE1NTEzYjYxMmY4YjU5OGU1ZThjZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-10-09T21:27:38Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-10-09T21:27:38Z"}, "message": "c-decl.c (start_decl): Unconditionally issue error for 'typedef foo = bar'.\n\ngcc:\n\t* c-decl.c (start_decl): Unconditionally issue error for\n\t'typedef foo = bar'.\n\t(finish_decl): Remove special case for TYPE_DECL with initializer.\n\n\t* doc/extend.texi: Delete \"Naming Types\" section.  Change all\n\tcross-references to that section to refer to \"Typeof\" instead.\n\tAdd the useful safe-max()-macro example from \"Naming Types\" to\n\t\"Typeof\", rewritten using that extension.\n\ngcc/cp:\n\t* decl.c (start_decl): Unconditionally issue error for\n\t'typedef foo = bar'.\n\t(cp_finish_decl): Remove special case for TYPE_DECL with initializer.\n\t(grokdeclarator): Remove redundant error for 'typedef foo = bar'.\n\ngcc/testsuite:\n\t* g++.dg/ext/typedef-init.C: New test.\n\t* gcc.dg/typedef-init.c: New test.\n\nFrom-SVN: r57995", "tree": {"sha": "5c1833358257015d0bc6c32fda4a348ff65b9084", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c1833358257015d0bc6c32fda4a348ff65b9084"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95f79357c5e37b27626a5513b612f8b598e5e8ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f79357c5e37b27626a5513b612f8b598e5e8ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95f79357c5e37b27626a5513b612f8b598e5e8ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f79357c5e37b27626a5513b612f8b598e5e8ce/comments", "author": null, "committer": null, "parents": [{"sha": "10a38dba685e4c5fe4902bbac5d85bb86326e87f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10a38dba685e4c5fe4902bbac5d85bb86326e87f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10a38dba685e4c5fe4902bbac5d85bb86326e87f"}], "stats": {"total": 174, "additions": 101, "deletions": 73}, "files": [{"sha": "fbe859a5d1b4c123982ecec0c884cf49cb8c9a00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95f79357c5e37b27626a5513b612f8b598e5e8ce", "patch": "@@ -1,3 +1,16 @@\n+2002-10-09  Zack Weinberg  <zack@codesourcery.com>\n+\n+\tPR c/7353\n+\t* c-decl.c (start_decl): Unconditionally issue error for\n+\t'typedef foo = bar'.\n+\t(finish_decl): Remove special case for TYPE_DECL with initializer.\n+\n+\t* doc/extend.texi: Delete \"Naming Types\" section.  Change all\n+\tcross-references to that section to refer to \"Typeof\" instead.\n+\tAdd the useful safe-max()-macro example from \"Naming Types\" to\n+\t\"Typeof\", rewritten using that extension.  Add some compatibility\n+\tnotes to \"Typeof.\"\n+\n 2002-10-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* loop.c: Revert 2002-08-15 change."}, {"sha": "60fade47df44e60799a3d4972b103f6bd7922517", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=95f79357c5e37b27626a5513b612f8b598e5e8ce", "patch": "@@ -2821,15 +2821,9 @@ start_decl (declarator, declspecs, initialized, attributes)\n     switch (TREE_CODE (decl))\n       {\n       case TYPE_DECL:\n-\t/* typedef foo = bar  means give foo the same type as bar.\n-\t   We haven't parsed bar yet, so `finish_decl' will fix that up.\n-\t   Any other case of an initialization in a TYPE_DECL is an error.  */\n-\tif (pedantic || list_length (declspecs) > 1)\n-\t  {\n-\t    error (\"typedef `%s' is initialized\",\n-\t\t   IDENTIFIER_POINTER (DECL_NAME (decl)));\n-\t    initialized = 0;\n-\t  }\n+\terror (\"typedef `%s' is initialized\",\n+\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\tinitialized = 0;\n \tbreak;\n \n       case FUNCTION_DECL:\n@@ -2988,16 +2982,7 @@ finish_decl (decl, init, asmspec_tree)\n     init = 0;\n \n   if (init)\n-    {\n-      if (TREE_CODE (decl) != TYPE_DECL)\n-\tstore_init_value (decl, init);\n-      else\n-\t{\n-\t  /* typedef foo = bar; store the type of bar as the type of foo.  */\n-\t  TREE_TYPE (decl) = TREE_TYPE (init);\n-\t  DECL_INITIAL (decl) = init = 0;\n-\t}\n-    }\n+    store_init_value (decl, init);\n \n   /* Deduce size of array from initialization, if not already known */\n   if (TREE_CODE (type) == ARRAY_TYPE"}, {"sha": "edb8694b3f65acf7cb7d03d270b57373eca06343", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=95f79357c5e37b27626a5513b612f8b598e5e8ce", "patch": "@@ -1,3 +1,10 @@\n+2002-10-09  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* decl.c (start_decl): Unconditionally issue error for\n+\t'typedef foo = bar'.\n+\t(cp_finish_decl): Remove special case for TYPE_DECL with initializer.\n+\t(grokdeclarator): Remove redundant error for 'typedef foo = bar'.\n+\n 2002-10-09  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* decl2.c (prune_vtable_vardecl): Delete unused function.\n@@ -84,7 +91,7 @@\n 2002-10-02  Matt Austern  <austern@apple.com>\n \t* decl.c (walk_vtables_r): Fixed typo that caused result to\n \tnever get a nonzero value.\n-\t\n+\n 2002-10-02  Roger Sayle  <roger@eyesopen.com>\n \n \tPR optimization/6627\n@@ -98,7 +105,7 @@\n \n \t* class.c (check_field_decls): Changed warning about const member\n \tvariables so that it doesn't get issued for a class aggregate.\n-\t\n+\n 2002-10-01  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (cp_finish_decl): Make sure array types are laid out,\n@@ -181,12 +188,12 @@\n \t(dfs_unuse_fields): Likewise.\n \t* tree.c (pod_type_p): Handle error_mark_node.\n \t(zero_init_p): Likewise.\n-\t* typeck.c (lookup_anon_field): Skip FIELD_DECLs for base \n+\t* typeck.c (lookup_anon_field): Skip FIELD_DECLs for base\n \tsubobjects.\n \t* typeck2.c (store_init_value): Remove #if 0'd code.\n \t(force_store_init_value): Remove.\n \t(process_init_constructor): Use build_zero_init.\n-\t\n+\n 2002-09-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/7788\n@@ -214,7 +221,7 @@\n \teven number of bytes when computing the size without virtual\n \tbases.\n \t* cp/cp-tree.h (abi_version_at_least): New macro.\n-\t\n+\n 2002-09-21  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* ChangeLog: Follow spelling conventions."}, {"sha": "8ab8a5e1bb516a5c4f1fa358c52f44de56d7d5aa", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=95f79357c5e37b27626a5513b612f8b598e5e8ce", "patch": "@@ -7290,14 +7290,8 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n     switch (TREE_CODE (decl))\n       {\n       case TYPE_DECL:\n-\t/* typedef foo = bar  means give foo the same type as bar.\n-\t   We haven't parsed bar yet, so `cp_finish_decl' will fix that up.\n-\t   Any other case of an initialization in a TYPE_DECL is an error.  */\n-\tif (pedantic || list_length (declspecs) > 1)\n-\t  {\n-\t    error (\"typedef `%D' is initialized\", decl);\n-\t    initialized = 0;\n-\t  }\n+\terror (\"typedef `%D' is initialized\", decl);\n+\tinitialized = 0;\n \tbreak;\n \n       case FUNCTION_DECL:\n@@ -8156,12 +8150,6 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n   /* Take care of TYPE_DECLs up front.  */\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n-      if (init && DECL_INITIAL (decl))\n-\t{\n-\t  /* typedef foo = bar; store the type of bar as the type of foo.  */\n-\t  TREE_TYPE (decl) = type = TREE_TYPE (init);\n-\t  DECL_INITIAL (decl) = init = NULL_TREE;\n-\t}\n       if (type != error_mark_node\n \t  && IS_AGGR_TYPE (type) && DECL_NAME (decl))\n \t{\n@@ -11365,9 +11353,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       bad_specifiers (decl, \"type\", virtualp, quals != NULL_TREE,\n \t\t      inlinep, friendp, raises != NULL_TREE);\n \n-      if (initialized)\n-\terror (\"typedef declaration includes an initializer\");\n-\n       return decl;\n     }\n "}, {"sha": "f583a6747b5ec5754d7c74ff93b572685d19b4bf", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=95f79357c5e37b27626a5513b612f8b598e5e8ce", "patch": "@@ -427,7 +427,6 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Labels as Values::    Getting pointers to labels, and computed gotos.\n * Nested Functions::    As in Algol and Pascal, lexical scoping of functions.\n * Constructing Calls::\tDispatching a call to another function.\n-* Naming Types::        Giving a name to the type of some expression.\n * Typeof::              @code{typeof}: referring to the type of an expression.\n * Lvalues::             Using @samp{?:}, @samp{,} and casts in lvalues.\n * Conditionals::        Omitting the middle operand of a @samp{?:} expression.\n@@ -538,8 +537,7 @@ the value of an enumeration constant, the width of a bit-field, or\n the initial value of a static variable.\n \n If you don't know the type of the operand, you can still do this, but you\n-must use @code{typeof} (@pxref{Typeof}) or type naming (@pxref{Naming\n-Types}).\n+must use @code{typeof} (@pxref{Typeof}).\n \n Statement expressions are not supported fully in G++, and their fate\n there is unclear.  (It is possible that they will become fully supported\n@@ -888,29 +886,6 @@ the containing function.  You should specify, for @var{result}, a value\n returned by @code{__builtin_apply}.\n @end deftypefn\n \n-@node Naming Types\n-@section Naming an Expression's Type\n-@cindex naming types\n-\n-You can give a name to the type of an expression using a @code{typedef}\n-declaration with an initializer.  Here is how to define @var{name} as a\n-type name for the type of @var{exp}:\n-\n-@example\n-typedef @var{name} = @var{exp};\n-@end example\n-\n-This is useful in conjunction with the statements-within-expressions\n-feature.  Here is how the two together can be used to define a safe\n-``maximum'' macro that operates on any arithmetic type:\n-\n-@example\n-#define max(a,b) \\\n-  (@{typedef _ta = (a), _tb = (b);  \\\n-    _ta _a = (a); _tb _b = (b);     \\\n-    _a > _b ? _a : _b; @})\n-@end example\n-\n @cindex underscores in variables in macros\n @cindex @samp{_} in variables in macros\n @cindex local variables in macros\n@@ -962,6 +937,21 @@ A @code{typeof}-construct can be used anywhere a typedef name could be\n used.  For example, you can use it in a declaration, in a cast, or inside\n of @code{sizeof} or @code{typeof}.\n \n+@code{typeof} is often useful in conjunction with the\n+statements-within-expressions feature.  Here is how the two together can\n+be used to define a safe ``maximum'' macro that operates on any\n+arithmetic type and evaluates each of its arguments exactly once:\n+\n+@example\n+#define max(a,b) \\\n+  (@{ typeof (a) _a = (a); \\\n+      typeof (b) _b = (b); \\\n+    _a > _b ? _a : _b; @})\n+@end example\n+\n+@noindent\n+Some more examples of the use of @code{typeof}:\n+\n @itemize @bullet\n @item\n This declares @code{y} with the type of what @code{x} points to.\n@@ -1011,6 +1001,26 @@ Thus, @code{array (pointer (char), 4)} is the type of arrays of 4\n pointers to @code{char}.\n @end itemize\n \n+@emph{Compatibility Note:} In addition to @code{typeof}, GCC 2 supported\n+a more limited extension which permitted one to write\n+\n+@example\n+typedef @var{T} = @var{expr};\n+@end example\n+\n+@noindent\n+with the effect of declaring @var{T} to have the type of the expression\n+@var{expr}.  This extension does not work with GCC 3 (versions between\n+3.0 and 3.2 will crash; 3.2.1 and later give an error).  Code which\n+relies on it should be rewritten to use @code{typeof}:\n+\n+@example\n+typedef typeof(@var{expr}) @var{T};\n+@end example\n+\n+@noindent\n+This will work with all versions of GCC@.\n+\n @node Lvalues\n @section Generalized Lvalues\n @cindex compound expressions as lvalues\n@@ -6827,12 +6837,12 @@ the minimum value of variables @var{i} and @var{j}.\n \n However, side effects in @code{X} or @code{Y} may cause unintended\n behavior.  For example, @code{MIN (i++, j++)} will fail, incrementing\n-the smaller counter twice.  A GNU C extension allows you to write safe\n-macros that avoid this kind of problem (@pxref{Naming Types,,Naming an\n-Expression's Type}).  However, writing @code{MIN} and @code{MAX} as\n-macros also forces you to use function-call notation for a\n-fundamental arithmetic operation.  Using GNU C++ extensions, you can\n-write @w{@samp{int min = i <? j;}} instead.\n+the smaller counter twice.  The GNU C @code{typeof} extension allows you\n+to write safe macros that avoid this kind of problem (@pxref{Typeof}).\n+However, writing @code{MIN} and @code{MAX} as macros also forces you to\n+use function-call notation for a fundamental arithmetic operation.\n+Using GNU C++ extensions, you can write @w{@samp{int min = i <? j;}}\n+instead.\n \n Since @code{<?} and @code{>?} are built into the compiler, they properly\n handle expressions with side-effects;  @w{@samp{int min = i++ <? j++;}}"}, {"sha": "f3122fd1ef2d2ca1072f86955ac2b97bac065db2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=95f79357c5e37b27626a5513b612f8b598e5e8ce", "patch": "@@ -1,3 +1,8 @@\n+2002-10-09  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* g++.dg/ext/typedef-init.C: New test.\n+\t* gcc.dg/typedef-init.c: New test.\n+\n 2002-10-09  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* gcc.dg/cpp/paste13.c: New test."}, {"sha": "5602783b4990e3f671f6def24f574eeffffb97e8", "filename": "gcc/testsuite/g++.dg/ext/typedef-init.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftypedef-init.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftypedef-init.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftypedef-init.C?ref=95f79357c5e37b27626a5513b612f8b598e5e8ce", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fpermissive\" } // suppress default -pedantic-errors */\n+\n+/* This code used to be a legitimate, if dubious, extension.  However,\n+   it's been broken since GCC 3.0 (caused ICE) and we have now removed\n+   the extension.  See PR c/7353.\n+\n+   C++ issues a warning in addition to the error, since this construct\n+   appears to be a case of implicit int (forbidden in std. C++) until\n+   we get to the equals sign.  */\n+\n+typedef A = 0;  /* { dg-error \"initialized\" \"typedef A = B\" } */\n+                /* { dg-warning \"no type\" \"also warns\" { target *-*-* } 12 } */\n+A a;            /* { dg-bogus \"\" \"no error cascade\" } */"}, {"sha": "9cb4830b74bd74f8b73f80b209f808422cc130f0", "filename": "gcc/testsuite/gcc.dg/typedef-init.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Ftestsuite%2Fgcc.dg%2Ftypedef-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f79357c5e37b27626a5513b612f8b598e5e8ce/gcc%2Ftestsuite%2Fgcc.dg%2Ftypedef-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftypedef-init.c?ref=95f79357c5e37b27626a5513b612f8b598e5e8ce", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu89\" } // suppress default -pedantic-errors */\n+\n+/* This code used to be a legitimate, if dubious, extension.  However,\n+   it's been broken since GCC 3.0 (caused ICE) and we have now removed\n+   the extension.  See PR c/7353.  */\n+\n+typedef A = 0;  /* { dg-error \"initialized\" \"typedef A = B\" } */\n+A a;            /* { dg-bogus \"\" \"no error cascade\" } */"}]}