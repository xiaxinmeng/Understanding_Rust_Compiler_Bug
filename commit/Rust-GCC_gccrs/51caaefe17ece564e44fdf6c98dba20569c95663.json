{"sha": "51caaefe17ece564e44fdf6c98dba20569c95663", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFjYWFlZmUxN2VjZTU2NGU0NGZkZjZjOThkYmEyMDU2OWM5NTY2Mw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2005-11-13T09:55:11Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-11-13T09:55:11Z"}, "message": "re PR middle-end/24003 (17 ACATS regressions (fixed point or decimal artihmetic))\n\n\tPR middle-end/24003\n\t* calls.c (expand_call): If TARGET is a MEM and some part of the\n\targument area has been saved, force TARGET to a register.\n\n\nCo-Authored-By: Ian Lance Taylor <ian@airs.com>\n\nFrom-SVN: r106860", "tree": {"sha": "19b659552e41d64e2cf5e934a33e7119dada4c08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19b659552e41d64e2cf5e934a33e7119dada4c08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51caaefe17ece564e44fdf6c98dba20569c95663", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51caaefe17ece564e44fdf6c98dba20569c95663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51caaefe17ece564e44fdf6c98dba20569c95663", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51caaefe17ece564e44fdf6c98dba20569c95663/comments", "author": null, "committer": null, "parents": [{"sha": "5d723e5434e83d9de5271f6d1c24a694826450a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d723e5434e83d9de5271f6d1c24a694826450a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d723e5434e83d9de5271f6d1c24a694826450a8"}], "stats": {"total": 100, "additions": 88, "deletions": 12}, "files": [{"sha": "dcd74dae752c2b90e2a802a5e916f8a6b1ddb18d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51caaefe17ece564e44fdf6c98dba20569c95663/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51caaefe17ece564e44fdf6c98dba20569c95663/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51caaefe17ece564e44fdf6c98dba20569c95663", "patch": "@@ -1,3 +1,10 @@\n+2005-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n+            Ian Lance Taylor  <ian@airs.com>\n+\n+\tPR middle-end/24003\n+\t* calls.c (expand_call): If TARGET is a MEM and some part of the\n+\targument area has been saved, force TARGET to a register.\n+\n 2005-11-13  Razya Ladelsky <razya@il.ibm.com>\n \n         * ipa-prop.c (ipa_callsite_compute_param ): Removed obsolete type "}, {"sha": "2cc15fc2e819e7087158258cddff0ffbc296354f", "filename": "gcc/calls.c", "status": "modified", "additions": 35, "deletions": 12, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51caaefe17ece564e44fdf6c98dba20569c95663/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51caaefe17ece564e44fdf6c98dba20569c95663/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=51caaefe17ece564e44fdf6c98dba20569c95663", "patch": "@@ -2857,6 +2857,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t       && GET_MODE (target) == TYPE_MODE (TREE_TYPE (exp))\n \t       && GET_MODE (target) == GET_MODE (valreg))\n \t{\n+\t  bool may_overlap = false;\n+\n \t  /* We have to copy a return value in a CLASS_LIKELY_SPILLED hard\n \t     reg to a plain register.  */\n \t  if (REG_P (valreg)\n@@ -2865,19 +2867,40 @@ expand_call (tree exp, rtx target, int ignore)\n \t      && !(REG_P (target) && !HARD_REGISTER_P (target)))\n \t    valreg = copy_to_reg (valreg);\n \n-\t  /* TARGET and VALREG cannot be equal at this point because the\n-\t     latter would not have REG_FUNCTION_VALUE_P true, while the\n-\t     former would if it were referring to the same register.\n-\n-\t     If they refer to the same register, this move will be a no-op,\n-\t     except when function inlining is being done.  */\n-\t  emit_move_insn (target, valreg);\n+\t  /* If TARGET is a MEM in the argument area, and we have\n+\t     saved part of the argument area, then we can't store\n+\t     directly into TARGET as it may get overwritten when we\n+\t     restore the argument save area below.  Don't work too\n+\t     hard though and simply force TARGET to a register if it\n+\t     is a MEM; the optimizer is quite likely to sort it out.  */\n+\t  if (ACCUMULATE_OUTGOING_ARGS && pass && MEM_P (target))\n+\t    for (i = 0; i < num_actuals; i++)\n+\t      if (args[i].save_area)\n+\t\t{\n+\t\t  may_overlap = true;\n+\t\t  break;\n+\t\t}\n \n-\t  /* If we are setting a MEM, this code must be executed.  Since it is\n-\t     emitted after the call insn, sibcall optimization cannot be\n-\t     performed in that case.  */\n-\t  if (MEM_P (target))\n-\t    sibcall_failure = 1;\n+\t  if (may_overlap)\n+\t    target = copy_to_reg (valreg);\n+\t  else\n+\t    {\n+\t      /* TARGET and VALREG cannot be equal at this point\n+\t\t because the latter would not have\n+\t\t REG_FUNCTION_VALUE_P true, while the former would if\n+\t\t it were referring to the same register.\n+\n+\t\t If they refer to the same register, this move will be\n+\t\t a no-op, except when function inlining is being\n+\t\t done.  */\n+\t      emit_move_insn (target, valreg);\n+\n+\t      /* If we are setting a MEM, this code must be executed.\n+\t\t Since it is emitted after the call insn, sibcall\n+\t\t optimization cannot be performed in that case.  */\n+\t      if (MEM_P (target))\n+\t\tsibcall_failure = 1;\n+\t    }\n \t}\n       else if (TYPE_MODE (TREE_TYPE (exp)) == BLKmode)\n \t{"}, {"sha": "e6f9757c0ea58ba8cc700aae858a205831a039d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51caaefe17ece564e44fdf6c98dba20569c95663/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51caaefe17ece564e44fdf6c98dba20569c95663/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=51caaefe17ece564e44fdf6c98dba20569c95663", "patch": "@@ -1,3 +1,7 @@\n+2005-11-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/nested-calls-1.c: New test.\n+\n 2005-11-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* gfortran.dg/complex_intrinsic_1.f90: New test."}, {"sha": "b3f08becac0cad92d6c3054482d051134ae82575", "filename": "gcc/testsuite/gcc.dg/nested-calls-1.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51caaefe17ece564e44fdf6c98dba20569c95663/gcc%2Ftestsuite%2Fgcc.dg%2Fnested-calls-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51caaefe17ece564e44fdf6c98dba20569c95663/gcc%2Ftestsuite%2Fgcc.dg%2Fnested-calls-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnested-calls-1.c?ref=51caaefe17ece564e44fdf6c98dba20569c95663", "patch": "@@ -0,0 +1,42 @@\n+/* PR middle-end/24003 */\n+/* Contributed by Eric Botcazou <ebotcazou@adacore.com> */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-std=c99 -O -fno-inline\" } */\n+/* { dg-options \"-std=c99 -O -fno-inline -mtune=i686\" { target { i?86-*-* && ilp32 } } } */\n+\n+#include <limits.h>\n+\n+typedef unsigned long uns32_t;\n+typedef unsigned long long uns64_t;\n+\n+extern void abort(void);\n+\n+uns32_t lo (uns64_t p)\n+{\n+  return (uns32_t)p;\n+}\n+\n+uns64_t concat (uns32_t p1, uns32_t p2)\n+{\n+#if LLONG_MAX > 2147483647L\n+  return ((uns64_t)p1 << 32) | p2;\n+#else\n+  return 0;\n+#endif\n+}\n+\n+uns64_t lshift32 (uns64_t p1, uns32_t p2)\n+{\n+  return concat (lo (p1), p2);\n+}\n+\n+int main(void)\n+{\n+#if LLONG_MAX > 2147483647L\n+  if (lshift32 (0xFFFFFFFF12345678ULL, 0x90ABCDEFUL) != 0x1234567890ABCDEFULL)\n+    abort ();\n+#endif\n+\n+  return 0;\n+}"}]}