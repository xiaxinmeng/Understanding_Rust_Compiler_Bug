{"sha": "30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBkYzE5MDJhNzc3OTY2ZGMxZDFkYWQwZmI1ZjE5YjdhOTYwZTVjYQ==", "commit": {"author": {"name": "Alan Hayward", "email": "alan.hayward@arm.com", "date": "2018-08-06T09:51:01Z"}, "committer": {"name": "Alan Hayward", "email": "alahay01@gcc.gnu.org", "date": "2018-08-06T09:51:01Z"}, "message": "lra support for clobber_high\n\ngcc/\n\t* lra-eliminations.c (lra_eliminate_regs_1): Check for clobber high.\n\t(mark_not_eliminable): Likewise.\n\t* lra-int.h (struct lra_insn_reg): Add clobber high marker.\n\t* lra-lives.c (process_bb_lives): Check for clobber high.\n\t* lra.c (new_insn_reg): Remember clobber highs.\n\t(collect_non_operand_hard_regs): Check for clobber high.\n\t(lra_set_insn_recog_data): Likewise.\n\t(add_regs_to_insn_regno_info): Likewise.\n\t(lra_update_insn_regno_info): Likewise.\n\nFrom-SVN: r263329", "tree": {"sha": "72e457f4dfa5196e0fff6049463f9962e1b6b92b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72e457f4dfa5196e0fff6049463f9962e1b6b92b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/comments", "author": {"login": "a74nh", "id": 4146708, "node_id": "MDQ6VXNlcjQxNDY3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a74nh", "html_url": "https://github.com/a74nh", "followers_url": "https://api.github.com/users/a74nh/followers", "following_url": "https://api.github.com/users/a74nh/following{/other_user}", "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}", "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions", "organizations_url": "https://api.github.com/users/a74nh/orgs", "repos_url": "https://api.github.com/users/a74nh/repos", "events_url": "https://api.github.com/users/a74nh/events{/privacy}", "received_events_url": "https://api.github.com/users/a74nh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a7fa0c213063683b2011c735bbf78ee8185fbfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a7fa0c213063683b2011c735bbf78ee8185fbfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a7fa0c213063683b2011c735bbf78ee8185fbfd"}], "stats": {"total": 122, "additions": 92, "deletions": 30}, "files": [{"sha": "8d9b158861d667bf917bd50361ce68ea09fbd5d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "patch": "@@ -1,3 +1,15 @@\n+2018-08-06  Alan Hayward  <alan.hayward@arm.com>\n+\n+\t* lra-eliminations.c (lra_eliminate_regs_1): Check for clobber high.\n+\t(mark_not_eliminable): Likewise.\n+\t* lra-int.h (struct lra_insn_reg): Add clobber high marker.\n+\t* lra-lives.c (process_bb_lives): Check for clobber high.\n+\t* lra.c (new_insn_reg): Remember clobber highs.\n+\t(collect_non_operand_hard_regs): Check for clobber high.\n+\t(lra_set_insn_recog_data): Likewise.\n+\t(add_regs_to_insn_regno_info): Likewise.\n+\t(lra_update_insn_regno_info): Likewise.\n+\n 2018-08-06  Alan Hayward  <alan.hayward@arm.com>\n \n \t* rtl.h (reg_is_clobbered_by_clobber_high): Add declarations."}, {"sha": "d0cfaa8714a8400a6db5da1ffef58b6225f743bd", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "patch": "@@ -654,6 +654,7 @@ lra_eliminate_regs_1 (rtx_insn *insn, rtx x, machine_mode mem_mode,\n       return x;\n \n     case CLOBBER:\n+    case CLOBBER_HIGH:\n     case SET:\n       gcc_unreachable ();\n \n@@ -806,6 +807,16 @@ mark_not_eliminable (rtx x, machine_mode mem_mode)\n \t    setup_can_eliminate (ep, false);\n       return;\n \n+    case CLOBBER_HIGH:\n+      gcc_assert (REG_P (XEXP (x, 0)));\n+      gcc_assert (REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER);\n+      for (ep = reg_eliminate;\n+\t   ep < &reg_eliminate[NUM_ELIMINABLE_REGS];\n+\t   ep++)\n+\tif (reg_is_clobbered_by_clobber_high (ep->to_rtx, XEXP (x, 0)))\n+\t  setup_can_eliminate (ep, false);\n+      return;\n+\n     case SET:\n       if (SET_DEST (x) == stack_pointer_rtx\n \t  && GET_CODE (SET_SRC (x)) == PLUS"}, {"sha": "5267b53c5e321526fb7eaae05f869dc0019e923f", "filename": "gcc/lra-int.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "patch": "@@ -168,6 +168,8 @@ struct lra_insn_reg\n   /* True if there is an early clobber alternative for this\n      operand.  */\n   unsigned int early_clobber : 1;\n+  /* True if the reg is clobber highed by the operand.  */\n+  unsigned int clobber_high : 1;\n   /* The corresponding regno of the register.  */\n   int regno;\n   /* Next reg info of the same insn.  */"}, {"sha": "433c819d9e3fcdae0bd6b67aa64ddfc878acbbe9", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "patch": "@@ -658,7 +658,7 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n       bool call_p;\n       int n_alt, dst_regno, src_regno;\n       rtx set;\n-      struct lra_insn_reg *reg;\n+      struct lra_insn_reg *reg, *hr;\n \n       if (!NONDEBUG_INSN_P (curr_insn))\n \tcontinue;\n@@ -690,11 +690,12 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\tbreak;\n \t      }\n \t  for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n-\t    if (reg->type != OP_IN)\n+\t    if (reg->type != OP_IN && !reg->clobber_high)\n \t      {\n \t\tremove_p = false;\n \t\tbreak;\n \t      }\n+\n \t  if (remove_p && ! volatile_refs_p (PATTERN (curr_insn)))\n \t    {\n \t      dst_regno = REGNO (SET_DEST (set));\n@@ -812,14 +813,24 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t unused values because they still conflict with quantities\n \t that are live at the time of the definition.  */\n       for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n-\tif (reg->type != OP_IN)\n-\t  {\n-\t    need_curr_point_incr\n-\t      |= mark_regno_live (reg->regno, reg->biggest_mode,\n-\t\t\t\t  curr_point);\n-\t    check_pseudos_live_through_calls (reg->regno,\n-\t\t\t\t\t      last_call_used_reg_set);\n-\t  }\n+\t{\n+\t  if (reg->type != OP_IN)\n+\t    {\n+\t      need_curr_point_incr\n+\t\t|= mark_regno_live (reg->regno, reg->biggest_mode,\n+\t\t\t\t    curr_point);\n+\t      check_pseudos_live_through_calls (reg->regno,\n+\t\t\t\t\t\tlast_call_used_reg_set);\n+\t    }\n+\n+\t  if (reg->regno >= FIRST_PSEUDO_REGISTER)\n+\t    for (hr = curr_static_id->hard_regs; hr != NULL; hr = hr->next)\n+\t      if (hr->clobber_high\n+\t\t  && maybe_gt (GET_MODE_SIZE (PSEUDO_REGNO_MODE (reg->regno)),\n+\t\t\t       GET_MODE_SIZE (hr->biggest_mode)))\n+\t\tSET_HARD_REG_BIT (lra_reg_info[reg->regno].conflict_hard_regs,\n+\t\t\t\t  hr->regno);\n+\t}\n \n       for (reg = curr_static_id->hard_regs; reg != NULL; reg = reg->next)\n \tif (reg->type != OP_IN)"}, {"sha": "aa768fb2a23196625d5b284560902a345a7595ea", "filename": "gcc/lra.c", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30dc1902a777966dc1d1dad0fb5f19b7a960e5ca/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=30dc1902a777966dc1d1dad0fb5f19b7a960e5ca", "patch": "@@ -535,13 +535,14 @@ object_allocator<lra_insn_reg> lra_insn_reg_pool (\"insn regs\");\n    clobbered in the insn (EARLY_CLOBBER), and reference to the next\n    insn reg info (NEXT).  If REGNO can be early clobbered,\n    alternatives in which it can be early clobbered are given by\n-   EARLY_CLOBBER_ALTS.  */\n+   EARLY_CLOBBER_ALTS.  CLOBBER_HIGH marks if reference is a clobber\n+   high.  */\n static struct lra_insn_reg *\n new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n \t      machine_mode mode,\n \t      bool subreg_p, bool early_clobber,\n \t      alternative_mask early_clobber_alts,\n-\t      struct lra_insn_reg *next)\n+\t      struct lra_insn_reg *next, bool clobber_high)\n {\n   lra_insn_reg *ir = lra_insn_reg_pool.allocate ();\n   ir->type = type;\n@@ -552,6 +553,7 @@ new_insn_reg (rtx_insn *insn, int regno, enum op_type type,\n   ir->subreg_p = subreg_p;\n   ir->early_clobber = early_clobber;\n   ir->early_clobber_alts = early_clobber_alts;\n+  ir->clobber_high = clobber_high;\n   ir->regno = regno;\n   ir->next = next;\n   return ir;\n@@ -821,12 +823,13 @@ setup_operand_alternative (lra_insn_recog_data_t data,\n    not the insn operands, in X with TYPE (in/out/inout) and flag that\n    it is early clobbered in the insn (EARLY_CLOBBER) and add the info\n    to LIST.  X is a part of insn given by DATA.\t Return the result\n-   list.  */\n+   list.  CLOBBER_HIGH marks if X is a clobber high.  */\n static struct lra_insn_reg *\n collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n \t\t\t       lra_insn_recog_data_t data,\n \t\t\t       struct lra_insn_reg *list,\n-\t\t\t       enum op_type type, bool early_clobber)\n+\t\t\t       enum op_type type, bool early_clobber,\n+\t\t\t       bool clobber_high)\n {\n   int i, j, regno, last;\n   bool subreg_p;\n@@ -890,7 +893,8 @@ collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n #endif\n \t      list = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n \t\t\t\t   early_clobber,\n-\t\t\t\t   early_clobber ? ALL_ALTERNATIVES : 0, list);\n+\t\t\t\t   early_clobber ? ALL_ALTERNATIVES : 0, list,\n+\t\t\t\t   clobber_high);\n \t    }\n \t}\n       return list;\n@@ -899,36 +903,44 @@ collect_non_operand_hard_regs (rtx_insn *insn, rtx *x,\n     {\n     case SET:\n       list = collect_non_operand_hard_regs (insn, &SET_DEST (op), data,\n-\t\t\t\t\t    list, OP_OUT, false);\n+\t\t\t\t\t    list, OP_OUT, false, false);\n       list = collect_non_operand_hard_regs (insn, &SET_SRC (op), data,\n-\t\t\t\t\t    list, OP_IN, false);\n+\t\t\t\t\t    list, OP_IN, false, false);\n       break;\n     case CLOBBER:\n       /* We treat clobber of non-operand hard registers as early clobber.  */\n       list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n-\t\t\t\t\t    list, OP_OUT, true);\n+\t\t\t\t\t    list, OP_OUT, true, false);\n+      break;\n+    case CLOBBER_HIGH:\n+      /* Clobber high should always span exactly one register.  */\n+      gcc_assert (REG_NREGS (XEXP (op, 0)) == 1);\n+      /* We treat clobber of non-operand hard registers as early clobber.  */\n+      list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n+\t\t\t\t\t    list, OP_OUT, true, true);\n       break;\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n       list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n-\t\t\t\t\t    list, OP_INOUT, false);\n+\t\t\t\t\t    list, OP_INOUT, false, false);\n       break;\n     case PRE_MODIFY: case POST_MODIFY:\n       list = collect_non_operand_hard_regs (insn, &XEXP (op, 0), data,\n-\t\t\t\t\t    list, OP_INOUT, false);\n+\t\t\t\t\t    list, OP_INOUT, false, false);\n       list = collect_non_operand_hard_regs (insn, &XEXP (op, 1), data,\n-\t\t\t\t\t    list, OP_IN, false);\n+\t\t\t\t\t    list, OP_IN, false, false);\n       break;\n     default:\n       fmt = GET_RTX_FORMAT (code);\n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t{\n \t  if (fmt[i] == 'e')\n \t    list = collect_non_operand_hard_regs (insn, &XEXP (op, i), data,\n-\t\t\t\t\t\t  list, OP_IN, false);\n+\t\t\t\t\t\t  list, OP_IN, false, false);\n \t  else if (fmt[i] == 'E')\n \t    for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n \t      list = collect_non_operand_hard_regs (insn, &XVECEXP (op, i, j),\n-\t\t\t\t\t\t    data, list, OP_IN, false);\n+\t\t\t\t\t\t    data, list, OP_IN, false,\n+\t\t\t\t\t\t    false);\n \t}\n     }\n   return list;\n@@ -1081,7 +1093,7 @@ lra_set_insn_recog_data (rtx_insn *insn)\n   else\n     insn_static_data->hard_regs\n       = collect_non_operand_hard_regs (insn, &PATTERN (insn), data,\n-\t\t\t\t       NULL, OP_IN, false);\n+\t\t\t\t       NULL, OP_IN, false, false);\n   data->arg_hard_regs = NULL;\n   if (CALL_P (insn))\n     {\n@@ -1107,6 +1119,11 @@ lra_set_insn_recog_data (rtx_insn *insn)\n \t      arg_hard_regs[n_hard_regs++]\n \t\t= regno + i + (use_p ? 0 : FIRST_PSEUDO_REGISTER);\n \t  }\n+\telse if (GET_CODE (XEXP (link, 0)) == CLOBBER_HIGH)\n+\t  /* We could support CLOBBER_HIGH and treat it in the same way as\n+\t     HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that yet.  */\n+\t  gcc_unreachable ();\n+\n       if (n_hard_regs != 0)\n \t{\n \t  arg_hard_regs[n_hard_regs++] = -1;\n@@ -1469,7 +1486,7 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n \t{\n \t  data->regs = new_insn_reg (data->insn, regno, type, mode, subreg_p,\n \t\t\t\t     early_clobber, early_clobber_alts,\n-\t\t\t\t     data->regs);\n+\t\t\t\t     data->regs, false);\n \t  return;\n \t}\n       else\n@@ -1482,7 +1499,8 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n \t\t     structure.  */\n \t\t  data->regs = new_insn_reg (data->insn, regno, type, mode,\n \t\t\t\t\t     subreg_p, early_clobber,\n-\t\t\t\t\t     early_clobber_alts, data->regs);\n+\t\t\t\t\t     early_clobber_alts, data->regs,\n+\t\t\t\t\t     false);\n \t\telse\n \t\t  {\n \t\t    if (curr->type != type)\n@@ -1509,6 +1527,8 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x,\n       add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_OUT,\n \t\t\t\t   true, ALL_ALTERNATIVES);\n       break;\n+    case CLOBBER_HIGH:\n+      gcc_unreachable ();\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n       add_regs_to_insn_regno_info (data, XEXP (x, 0), insn, OP_INOUT, false, 0);\n       break;\n@@ -1643,10 +1663,16 @@ lra_update_insn_regno_info (rtx_insn *insn)\n     for (link = CALL_INSN_FUNCTION_USAGE (insn);\n \t link != NULL_RTX;\n \t link = XEXP (link, 1))\n-      if (((code = GET_CODE (XEXP (link, 0))) == USE || code == CLOBBER)\n-\t  && MEM_P (XEXP (XEXP (link, 0), 0)))\n-\tadd_regs_to_insn_regno_info (data, XEXP (XEXP (link, 0), 0), insn,\n-\t\t\t\t     code == USE ? OP_IN : OP_OUT, false, 0);\n+      {\n+\tcode = GET_CODE (XEXP (link, 0));\n+\t/* We could support CLOBBER_HIGH and treat it in the same way as\n+\t   HARD_REGNO_CALL_PART_CLOBBERED, but no port needs that yet.  */\n+\tgcc_assert (code != CLOBBER_HIGH);\n+\tif ((code == USE || code == CLOBBER)\n+\t    && MEM_P (XEXP (XEXP (link, 0), 0)))\n+\t  add_regs_to_insn_regno_info (data, XEXP (XEXP (link, 0), 0), insn,\n+\t\t\t\t       code == USE ? OP_IN : OP_OUT, false, 0);\n+      }\n   if (NONDEBUG_INSN_P (insn))\n     setup_insn_reg_info (data, freq);\n }"}]}