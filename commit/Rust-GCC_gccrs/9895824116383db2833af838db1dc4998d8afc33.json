{"sha": "9895824116383db2833af838db1dc4998d8afc33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg5NTgyNDExNjM4M2RiMjgzM2FmODM4ZGIxZGM0OTk4ZDhhZmMzMw==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@redhat.com", "date": "2011-07-28T10:41:51Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2011-07-28T10:41:51Z"}, "message": "tree-vrp.c (simplify_stmt_using_ranges): Remove TRUTH_NOT_EXPR case.\n\n2011-07-28  Kai Tietz  <ktietz@redhat.com>\n\n        * tree-vrp.c (simplify_stmt_using_ranges): Remove\n        TRUTH_NOT_EXPR case.\n        (simplify_truth_ops_using_ranges): Likewise.\n        (build_assert_expr_for): Likewise.\n        (build_assert_expr_for_1): Remove TRUTH_NOT_EXPR case\n        and handle BIT_NOT_EXPR for truth-operation.\n\nFrom-SVN: r176866", "tree": {"sha": "705a67e759f87d5cdb39284a5622195d98196c1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/705a67e759f87d5cdb39284a5622195d98196c1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9895824116383db2833af838db1dc4998d8afc33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9895824116383db2833af838db1dc4998d8afc33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9895824116383db2833af838db1dc4998d8afc33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9895824116383db2833af838db1dc4998d8afc33/comments", "author": null, "committer": null, "parents": [{"sha": "f627fef27a65762e1299098150bab3dab7c1f78f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f627fef27a65762e1299098150bab3dab7c1f78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f627fef27a65762e1299098150bab3dab7c1f78f"}], "stats": {"total": 92, "additions": 42, "deletions": 50}, "files": [{"sha": "3be00e9dcee34180addde574e1be9d6fa0a3a36d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9895824116383db2833af838db1dc4998d8afc33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9895824116383db2833af838db1dc4998d8afc33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9895824116383db2833af838db1dc4998d8afc33", "patch": "@@ -1,3 +1,12 @@\n+2011-07-28  Kai Tietz  <ktietz@redhat.com>\n+\n+\t* tree-vrp.c (simplify_stmt_using_ranges): Remove\n+\tTRUTH_NOT_EXPR case.\n+\t(simplify_truth_ops_using_ranges): Likewise.\n+\t(build_assert_expr_for): Likewise.\n+\t(build_assert_expr_for_1): Remove TRUTH_NOT_EXPR case\n+\tand handle BIT_NOT_EXPR for truth-operation.\n+\n 2011-07-28  Georg-Johann Lay  <avr@gjlay.de>\n \t\n \tPR target/49313"}, {"sha": "b53ef5e75e27ce6b64809558a2d71c2077f3d5c7", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 33, "deletions": 50, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9895824116383db2833af838db1dc4998d8afc33/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9895824116383db2833af838db1dc4998d8afc33/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9895824116383db2833af838db1dc4998d8afc33", "patch": "@@ -3972,13 +3972,6 @@ build_assert_expr_for (tree cond, tree v)\n       tree a = build2 (ASSERT_EXPR, TREE_TYPE (v), v, cond);\n       assertion = gimple_build_assign (n, a);\n     }\n-  else if (TREE_CODE (cond) == TRUTH_NOT_EXPR)\n-    {\n-      /* Given !V, build the assignment N = false.  */\n-      tree op0 = TREE_OPERAND (cond, 0);\n-      gcc_assert (op0 == v);\n-      assertion = gimple_build_assign (n, boolean_false_node);\n-    }\n   else if (TREE_CODE (cond) == SSA_NAME)\n     {\n       /* Given V, build the assignment N = true.  */\n@@ -4525,7 +4518,8 @@ register_edge_assert_for_1 (tree op, enum tree_code code,\n       retval |= register_edge_assert_for_1 (gimple_assign_rhs2 (op_def),\n \t\t\t\t\t    code, e, bsi);\n     }\n-  else if (gimple_assign_rhs_code (op_def) == TRUTH_NOT_EXPR)\n+  else if (gimple_assign_rhs_code (op_def) == BIT_NOT_EXPR\n+\t   && TYPE_PRECISION (TREE_TYPE (gimple_assign_lhs (op_def))) == 1)\n     {\n       /* Recurse, flipping CODE.  */\n       code = invert_tree_comparison (code, false);\n@@ -6754,6 +6748,9 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n   bool sop = false;\n   bool need_conversion;\n \n+  /* We handle only !=/== case here.  */\n+  gcc_assert (rhs_code == EQ_EXPR || rhs_code == NE_EXPR);\n+\n   op0 = gimple_assign_rhs1 (stmt);\n   if (TYPE_PRECISION (TREE_TYPE (op0)) != 1)\n     {\n@@ -6770,52 +6767,40 @@ simplify_truth_ops_using_ranges (gimple_stmt_iterator *gsi, gimple stmt)\n         return false;\n     }\n \n-  if (rhs_code == TRUTH_NOT_EXPR)\n+  op1 = gimple_assign_rhs2 (stmt);\n+\n+  /* Reduce number of cases to handle.  */\n+  if (is_gimple_min_invariant (op1))\n     {\n-      rhs_code = NE_EXPR;\n-      op1 = build_int_cst (TREE_TYPE (op0), 1);\n+      if (!integer_zerop (op1)\n+\t  && !integer_onep (op1)\n+\t  && !integer_all_onesp (op1))\n+\treturn false;\n+\n+      /* Limit the number of cases we have to consider.  */\n+      if (rhs_code == EQ_EXPR)\n+\t{\n+\t  rhs_code = NE_EXPR;\n+\t  /* OP1 is a constant.  */\n+\t  op1 = fold_unary (TRUTH_NOT_EXPR, TREE_TYPE (op1), op1);\n+\t}\n     }\n   else\n     {\n-      op1 = gimple_assign_rhs2 (stmt);\n+      /* Punt on A == B as there is no BIT_XNOR_EXPR.  */\n+      if (rhs_code == EQ_EXPR)\n+\treturn false;\n \n-      /* Reduce number of cases to handle.  */\n-      if (is_gimple_min_invariant (op1))\n+      if (TYPE_PRECISION (TREE_TYPE (op1)) != 1)\n \t{\n-          /* Exclude anything that should have been already folded.  */\n-\t  if (rhs_code != EQ_EXPR\n-\t      && rhs_code != NE_EXPR)\n+\t  vr = get_value_range (op1);\n+\t  val = compare_range_with_value (GE_EXPR, vr, integer_zero_node, &sop);\n+\t  if (!val || !integer_onep (val))\n \t    return false;\n \n-\t  if (!integer_zerop (op1)\n-\t      && !integer_onep (op1)\n-\t      && !integer_all_onesp (op1))\n+\t  val = compare_range_with_value (LE_EXPR, vr, integer_one_node, &sop);\n+\t  if (!val || !integer_onep (val))\n \t    return false;\n-\n-\t  /* Limit the number of cases we have to consider.  */\n-\t  if (rhs_code == EQ_EXPR)\n-\t    {\n-\t      rhs_code = NE_EXPR;\n-\t      op1 = fold_unary (TRUTH_NOT_EXPR, TREE_TYPE (op1), op1);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Punt on A == B as there is no BIT_XNOR_EXPR.  */\n-\t  if (rhs_code == EQ_EXPR)\n-\t    return false;\n-\n-\t  if (TYPE_PRECISION (TREE_TYPE (op1)) != 1)\n-\t    {\n-\t      vr = get_value_range (op1);\n-\t      val = compare_range_with_value (GE_EXPR, vr, integer_zero_node, &sop);\n-\t      if (!val || !integer_onep (val))\n-\t        return false;\n-\n-\t      val = compare_range_with_value (LE_EXPR, vr, integer_one_node, &sop);\n-\t      if (!val || !integer_onep (val))\n-\t        return false;\n-\t    }\n \t}\n     }\n \n@@ -7514,11 +7499,9 @@ simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)\n \t{\n \tcase EQ_EXPR:\n \tcase NE_EXPR:\n-\tcase TRUTH_NOT_EXPR:\n-          /* Transform EQ_EXPR, NE_EXPR, TRUTH_NOT_EXPR into BIT_XOR_EXPR\n-\t     or identity if the RHS is zero or one, and the LHS are known\n-\t     to be boolean values.  Transform all TRUTH_*_EXPR into\n-             BIT_*_EXPR if both arguments are known to be boolean values.  */\n+          /* Transform EQ_EXPR, NE_EXPR into BIT_XOR_EXPR or identity\n+\t     if the RHS is zero or one, and the LHS are known to be boolean\n+\t     values.  */\n \t  if (INTEGRAL_TYPE_P (TREE_TYPE (rhs1)))\n \t    return simplify_truth_ops_using_ranges (gsi, stmt);\n \t  break;"}]}