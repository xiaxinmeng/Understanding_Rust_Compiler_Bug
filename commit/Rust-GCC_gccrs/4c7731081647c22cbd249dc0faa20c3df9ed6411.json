{"sha": "4c7731081647c22cbd249dc0faa20c3df9ed6411", "node_id": "C_kwDOANBUbNoAKDRjNzczMTA4MTY0N2MyMmNiZDI0OWRjMGZhYTIwYzNkZjllZDY0MTE", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-29T09:18:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-29T11:46:39Z"}, "message": "Fix peeling for alignment with negative step\n\nThe following fixes a regression causing us to no longer peel\nnegative step loops for alignment.  With dr_misalignment now\napplying the bias for negative step we have to do the reverse\nwhen adjusting the misalignment for peeled DRs.\n\n2021-09-29  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-data-refs.c (vect_dr_misalign_for_aligned_access):\n\tNew helper.\n\t(vect_update_misalignment_for_peel): Use it to update\n\tmisaligned to the value necessary for an aligned access.\n\t(vect_get_peeling_costs_all_drs): Likewise.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\n\t* gcc.target/i386/vect-alignment-peeling-1.c: New testcase.\n\t* gcc.target/i386/vect-alignment-peeling-2.c: Likewise.", "tree": {"sha": "174a6e344ceac511ebd4f06a875c851aa473198c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/174a6e344ceac511ebd4f06a875c851aa473198c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c7731081647c22cbd249dc0faa20c3df9ed6411", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7731081647c22cbd249dc0faa20c3df9ed6411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c7731081647c22cbd249dc0faa20c3df9ed6411", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7731081647c22cbd249dc0faa20c3df9ed6411/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a459ee44c0a74b0df0485ed7a56683816c02aae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a459ee44c0a74b0df0485ed7a56683816c02aae9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a459ee44c0a74b0df0485ed7a56683816c02aae9"}], "stats": {"total": 219, "additions": 213, "deletions": 6}, "files": [{"sha": "4aa536ba86c93526a40744e42be1f86d737af2cf", "filename": "gcc/testsuite/gcc.target/i386/vect-alignment-peeling-1.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7731081647c22cbd249dc0faa20c3df9ed6411/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-alignment-peeling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7731081647c22cbd249dc0faa20c3df9ed6411/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-alignment-peeling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-alignment-peeling-1.c?ref=4c7731081647c22cbd249dc0faa20c3df9ed6411", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do run { target lp64 } } */\n+/* This is a test exercising peeling for alignment for a negative step\n+   vector loop.  We're forcing atom tuning here because that has a higher\n+   unaligned vs aligned cost unlike most other archs.  */\n+/* { dg-options \"-O3 -march=x86-64 -mtune=atom -fdump-tree-vect-details -save-temps\" } */\n+\n+float a[1024], b[1024];\n+\n+void __attribute__((noipa)) foo1 ()\n+{\n+  for (int i = 507; i > 1; --i)\n+    a[i] = b[i] * 2.;\n+}\n+void __attribute__((noipa)) foo2 ()\n+{\n+  for (int i = 506; i > 1; --i)\n+    a[i] = b[i] * 2.;\n+}\n+void __attribute__((noipa)) foo3 ()\n+{\n+  for (int i = 505; i > 1; --i)\n+    a[i] = b[i] * 2.;\n+}\n+void __attribute__((noipa)) foo4 ()\n+{\n+  for (int i = 504; i > 1; --i)\n+    a[i] = b[i] * 2.;\n+}\n+void __attribute__((noipa)) foo5 (int start)\n+{\n+  for (int i = start; i > 1; --i)\n+    a[i] = b[i] * 2.;\n+}\n+\n+int main()\n+{\n+  for (int i = 2; i < 508; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo1 ();\n+  for (int i = 2; i < 508; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+\n+  for (int i = 2; i < 507; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo2 ();\n+  for (int i = 2; i < 507; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+\n+  for (int i = 2; i < 506; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo3 ();\n+  for (int i = 2; i < 506; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+\n+  for (int i = 2; i < 505; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo4 ();\n+  for (int i = 2; i < 505; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+\n+  for (int i = 2; i < 506; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo5 (505);\n+  for (int i = 2; i < 506; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 4 \"vect\" } } */ \n+/* Verify all vector accesses are emitted as aligned.  */\n+/* { dg-final { scan-assembler-not \"movup\" } } */"}, {"sha": "834bf0f770d66d1513dacb9cfb66387a75da3b76", "filename": "gcc/testsuite/gcc.target/i386/vect-alignment-peeling-2.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7731081647c22cbd249dc0faa20c3df9ed6411/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-alignment-peeling-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7731081647c22cbd249dc0faa20c3df9ed6411/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-alignment-peeling-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-alignment-peeling-2.c?ref=4c7731081647c22cbd249dc0faa20c3df9ed6411", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do run { target lp64 } } */\n+/* This is a test exercising peeling for alignment for a positive step\n+   vector loop.  We're forcing atom tuning here because that has a higher\n+   unaligned vs aligned cost unlike most other archs.  */\n+/* { dg-options \"-O3 -march=x86-64 -mtune=atom -fdump-tree-vect-details -save-temps\" } */\n+\n+float a[1024], b[1024];\n+\n+void __attribute__((noipa)) foo1 ()\n+{\n+  for (int i = 2; i < 508; ++i)\n+    a[i] = b[i] * 2.;\n+}\n+void __attribute__((noipa)) foo2 ()\n+{\n+  for (int i = 3; i < 508; ++i)\n+    a[i] = b[i] * 2.;\n+}\n+void __attribute__((noipa)) foo3 ()\n+{\n+  for (int i = 4; i < 508; ++i)\n+    a[i] = b[i] * 2.;\n+}\n+void __attribute__((noipa)) foo4 ()\n+{\n+  for (int i = 5; i < 508; ++i)\n+    a[i] = b[i] * 2.;\n+}\n+void __attribute__((noipa)) foo5 (int start)\n+{\n+  for (int i = start; i < 508; ++i)\n+    a[i] = b[i] * 2.;\n+}\n+\n+int main()\n+{\n+  for (int i = 2; i < 508; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo1 ();\n+  for (int i = 2; i < 508; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+\n+  for (int i = 3; i < 508; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo2 ();\n+  for (int i = 3; i < 508; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+\n+  for (int i = 4; i < 508; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo3 ();\n+  for (int i = 4; i < 508; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+\n+  for (int i = 5; i < 508; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo4 ();\n+  for (int i = 5; i < 508; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+\n+  for (int i = 3; i < 508; ++i)\n+    {\n+      __asm__ volatile (\"\" : : : \"memory\");\n+      b[i] = i;\n+    }\n+  foo5 (3);\n+  for (int i = 3; i < 508; ++i)\n+    if (a[i] != 2*i)\n+      __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 4 \"vect\" } } */ \n+/* Verify all vector accesses are emitted as aligned.  */\n+/* { dg-final { scan-assembler-not \"movup\" } } */"}, {"sha": "1c6fc4a8f0f507758a7e2cb9ed7db716a7f6b6a8", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c7731081647c22cbd249dc0faa20c3df9ed6411/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c7731081647c22cbd249dc0faa20c3df9ed6411/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=4c7731081647c22cbd249dc0faa20c3df9ed6411", "patch": "@@ -1214,6 +1214,29 @@ vect_dr_aligned_if_peeled_dr_is (dr_vec_info *dr_info,\n   return vect_dr_aligned_if_related_peeled_dr_is (dr_info, dr_peel_info);\n }\n \n+/* Compute the value for dr_info->misalign so that the access appears\n+   aligned.  This is used by peeling to compensate for dr_misalignment\n+   applying the offset for negative step.  */\n+\n+int\n+vect_dr_misalign_for_aligned_access (dr_vec_info *dr_info)\n+{\n+  if (tree_int_cst_sgn (DR_STEP (dr_info->dr)) >= 0)\n+    return 0;\n+\n+  tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n+  poly_int64 misalignment\n+    = ((TYPE_VECTOR_SUBPARTS (vectype) - 1)\n+       * TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (vectype))));\n+\n+  unsigned HOST_WIDE_INT target_alignment_c;\n+  int misalign;\n+  if (!dr_info->target_alignment.is_constant (&target_alignment_c)\n+      || !known_misalignment (misalignment, target_alignment_c, &misalign))\n+    return DR_MISALIGNMENT_UNKNOWN;\n+  return misalign;\n+}\n+\n /* Function vect_update_misalignment_for_peel.\n    Sets DR_INFO's misalignment\n    - to 0 if it has the same alignment as DR_PEEL_INFO,\n@@ -1233,17 +1256,18 @@ vect_update_misalignment_for_peel (dr_vec_info *dr_info,\n   /* If dr_info is aligned of dr_peel_info is, then mark it so.  */\n   if (vect_dr_aligned_if_peeled_dr_is (dr_info, dr_peel_info))\n     {\n-      SET_DR_MISALIGNMENT (dr_info, 0);\n+      SET_DR_MISALIGNMENT (dr_info,\n+\t\t\t   vect_dr_misalign_for_aligned_access (dr_peel_info));\n       return;\n     }\n \n   unsigned HOST_WIDE_INT alignment;\n   tree vectype = STMT_VINFO_VECTYPE (dr_info->stmt);\n   if (DR_TARGET_ALIGNMENT (dr_info).is_constant (&alignment)\n       && known_alignment_for_access_p (dr_info, vectype)\n-      && known_alignment_for_access_p (dr_peel_info, vectype))\n+      && npeel != -1)\n     {\n-      int misal = dr_misalignment (dr_info, vectype);\n+      int misal = dr_info->misalignment;\n       misal += npeel * TREE_INT_CST_LOW (DR_STEP (dr_info->dr));\n       misal &= alignment - 1;\n       set_dr_misalignment (dr_info, misal);\n@@ -1516,7 +1540,8 @@ vect_get_peeling_costs_all_drs (loop_vec_info loop_vinfo,\n       if (npeel == 0)\n \t;\n       else if (unknown_misalignment && dr_info == dr0_info)\n-\tSET_DR_MISALIGNMENT (dr_info, 0);\n+\tSET_DR_MISALIGNMENT (dr_info,\n+\t\t\t     vect_dr_misalign_for_aligned_access (dr0_info));\n       else\n \tvect_update_misalignment_for_peel (dr_info, dr0_info, npeel);\n       vect_get_data_access_cost (loop_vinfo, dr_info, inside_cost, outside_cost,\n@@ -2278,7 +2303,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n             LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) = npeel;\n           else\n \t    LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) = -1;\n-\t  SET_DR_MISALIGNMENT (dr0_info, 0);\n+\t  SET_DR_MISALIGNMENT (dr0_info,\n+\t\t\t       vect_dr_misalign_for_aligned_access (dr0_info));\n \t  if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2402,7 +2428,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       FOR_EACH_VEC_ELT (may_misalign_stmts, i, stmt_info)\n         {\n \t  dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n-\t  SET_DR_MISALIGNMENT (dr_info, 0);\n+\t  SET_DR_MISALIGNMENT (dr_info,\n+\t\t\t       vect_dr_misalign_for_aligned_access (dr_info));\n \t  if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n                              \"Alignment of access forced using versioning.\\n\");"}]}