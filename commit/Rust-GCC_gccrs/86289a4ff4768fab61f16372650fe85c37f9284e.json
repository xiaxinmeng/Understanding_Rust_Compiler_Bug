{"sha": "86289a4ff4768fab61f16372650fe85c37f9284e", "node_id": "C_kwDOANBUbNoAKDg2Mjg5YTRmZjQ3NjhmYWI2MWYxNjM3MjY1MGZlODVjMzdmOTI4NGU", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-11-13T06:23:45Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2021-11-13T13:15:24Z"}, "message": "libsanitizer: Merge with upstream\n\nMerged revision: 82bc6a094e85014f1891ef9407496f44af8fe442\n\nwith the fix for PR sanitizer/102911", "tree": {"sha": "4e2328cbff3a90cb8739f7e6fd95621d8aa16789", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e2328cbff3a90cb8739f7e6fd95621d8aa16789"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86289a4ff4768fab61f16372650fe85c37f9284e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86289a4ff4768fab61f16372650fe85c37f9284e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86289a4ff4768fab61f16372650fe85c37f9284e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86289a4ff4768fab61f16372650fe85c37f9284e/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a30a2e43e4a357919ecfa916451966f8e32b5176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a30a2e43e4a357919ecfa916451966f8e32b5176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a30a2e43e4a357919ecfa916451966f8e32b5176"}], "stats": {"total": 802, "additions": 469, "deletions": 333}, "files": [{"sha": "01913de5d6664beef8feae4df898c5b9063dad56", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -1,4 +1,4 @@\n-78d3e0a4f1406b17cdecc77540e09210670fe9a9\n+82bc6a094e85014f1891ef9407496f44af8fe442\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "3fa36742060bdbdd8457d2b3cba59ffd9726e002", "filename": "libsanitizer/asan/asan_allocator.cpp", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_allocator.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_allocator.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -102,19 +102,18 @@ class ChunkHeader {\n \n  public:\n   uptr UsedSize() const {\n-    uptr R = user_requested_size_lo;\n-    if (sizeof(uptr) > sizeof(user_requested_size_lo))\n-      R += (uptr)user_requested_size_hi << (8 * sizeof(user_requested_size_lo));\n-    return R;\n+    static_assert(sizeof(user_requested_size_lo) == 4,\n+                  \"Expression below requires this\");\n+    return FIRST_32_SECOND_64(0, ((uptr)user_requested_size_hi << 32)) +\n+           user_requested_size_lo;\n   }\n \n   void SetUsedSize(uptr size) {\n     user_requested_size_lo = size;\n-    if (sizeof(uptr) > sizeof(user_requested_size_lo)) {\n-      size >>= (8 * sizeof(user_requested_size_lo));\n-      user_requested_size_hi = size;\n-      CHECK_EQ(user_requested_size_hi, size);\n-    }\n+    static_assert(sizeof(user_requested_size_lo) == 4,\n+                  \"Expression below requires this\");\n+    user_requested_size_hi = FIRST_32_SECOND_64(0, size >> 32);\n+    CHECK_EQ(UsedSize(), size);\n   }\n \n   void SetAllocContext(u32 tid, u32 stack) {"}, {"sha": "5f56fe6f457d12ffd9478eb14fac199adb4fec0e", "filename": "libsanitizer/asan/asan_globals.cpp", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_globals.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_globals.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -154,6 +154,23 @@ static void CheckODRViolationViaIndicator(const Global *g) {\n   }\n }\n \n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n+  }\n+}\n+\n // Clang provides two different ways for global variables protection:\n // it can poison the global itself or its private alias. In former\n // case we may poison same symbol multiple times, that can help us to\n@@ -199,6 +216,8 @@ static void RegisterGlobal(const Global *g) {\n     // where two globals with the same name are defined in different modules.\n     if (UseODRIndicator(g))\n       CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);"}, {"sha": "047b044c8bf47da51e74436dc088b2740fd162dc", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -81,12 +81,7 @@ void InitializePlatformInterceptors();\n #if ASAN_HAS_EXCEPTIONS && !SANITIZER_WINDOWS && !SANITIZER_SOLARIS && \\\n     !SANITIZER_NETBSD\n # define ASAN_INTERCEPT___CXA_THROW 1\n-# if ! defined(ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION) \\\n-     || ASAN_HAS_CXA_RETHROW_PRIMARY_EXCEPTION\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n-# else\n-#   define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 0\n-# endif\n+# define ASAN_INTERCEPT___CXA_RETHROW_PRIMARY_EXCEPTION 1\n # if defined(_GLIBCXX_SJLJ_EXCEPTIONS) || (SANITIZER_IOS && defined(__arm__))\n #  define ASAN_INTERCEPT__UNWIND_SJLJ_RAISEEXCEPTION 1\n # else"}, {"sha": "bab80b96f584b90feda283928d28e321e6e880d1", "filename": "libsanitizer/asan/asan_malloc_linux.cpp", "status": "modified", "additions": 25, "deletions": 90, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -21,129 +21,66 @@\n #  include \"asan_interceptors.h\"\n #  include \"asan_internal.h\"\n #  include \"asan_stack.h\"\n+#  include \"lsan/lsan_common.h\"\n #  include \"sanitizer_common/sanitizer_allocator_checks.h\"\n+#  include \"sanitizer_common/sanitizer_allocator_dlsym.h\"\n #  include \"sanitizer_common/sanitizer_errno.h\"\n #  include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n \n // ---------------------- Replacement functions ---------------- {{{1\n using namespace __asan;\n \n-static uptr allocated_for_dlsym;\n-static uptr last_dlsym_alloc_size_in_words;\n-static const uptr kDlsymAllocPoolSize = 1024;\n-static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];\n-\n-static inline bool IsInDlsymAllocPool(const void *ptr) {\n-  uptr off = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n-  return off < allocated_for_dlsym * sizeof(alloc_memory_for_dlsym[0]);\n-}\n-\n-static void *AllocateFromLocalPool(uptr size_in_bytes) {\n-  uptr size_in_words = RoundUpTo(size_in_bytes, kWordSize) / kWordSize;\n-  void *mem = (void*)&alloc_memory_for_dlsym[allocated_for_dlsym];\n-  last_dlsym_alloc_size_in_words = size_in_words;\n-  allocated_for_dlsym += size_in_words;\n-  CHECK_LT(allocated_for_dlsym, kDlsymAllocPoolSize);\n-  return mem;\n-}\n-\n-static void DeallocateFromLocalPool(const void *ptr) {\n-  // Hack: since glibc 2.27 dlsym no longer uses stack-allocated memory to store\n-  // error messages and instead uses malloc followed by free. To avoid pool\n-  // exhaustion due to long object filenames, handle that special case here.\n-  uptr prev_offset = allocated_for_dlsym - last_dlsym_alloc_size_in_words;\n-  void *prev_mem = (void*)&alloc_memory_for_dlsym[prev_offset];\n-  if (prev_mem == ptr) {\n-    REAL(memset)(prev_mem, 0, last_dlsym_alloc_size_in_words * kWordSize);\n-    allocated_for_dlsym = prev_offset;\n-    last_dlsym_alloc_size_in_words = 0;\n+struct DlsymAlloc : public DlSymAllocator<DlsymAlloc> {\n+  static bool UseImpl() { return asan_init_is_running; }\n+  static void OnAllocate(const void *ptr, uptr size) {\n+#  if CAN_SANITIZE_LEAKS\n+    // Suppress leaks from dlerror(). Previously dlsym hack on global array was\n+    // used by leak sanitizer as a root region.\n+    __lsan_register_root_region(ptr, size);\n+#  endif\n   }\n-}\n-\n-static int PosixMemalignFromLocalPool(void **memptr, uptr alignment,\n-                                      uptr size_in_bytes) {\n-  if (UNLIKELY(!CheckPosixMemalignAlignment(alignment)))\n-    return errno_EINVAL;\n-\n-  CHECK(alignment >= kWordSize);\n-\n-  uptr addr = (uptr)&alloc_memory_for_dlsym[allocated_for_dlsym];\n-  uptr aligned_addr = RoundUpTo(addr, alignment);\n-  uptr aligned_size = RoundUpTo(size_in_bytes, kWordSize);\n-\n-  uptr *end_mem = (uptr*)(aligned_addr + aligned_size);\n-  uptr allocated = end_mem - alloc_memory_for_dlsym;\n-  if (allocated >= kDlsymAllocPoolSize)\n-    return errno_ENOMEM;\n-\n-  allocated_for_dlsym = allocated;\n-  *memptr = (void*)aligned_addr;\n-  return 0;\n-}\n-\n-static inline bool MaybeInDlsym() {\n-  // Fuchsia doesn't use dlsym-based interceptors.\n-  return !SANITIZER_FUCHSIA && asan_init_is_running;\n-}\n-\n-static inline bool UseLocalPool() { return MaybeInDlsym(); }\n-\n-static void *ReallocFromLocalPool(void *ptr, uptr size) {\n-  const uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n-  const uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);\n-  void *new_ptr;\n-  if (UNLIKELY(UseLocalPool())) {\n-    new_ptr = AllocateFromLocalPool(size);\n-  } else {\n-    ENSURE_ASAN_INITED();\n-    GET_STACK_TRACE_MALLOC;\n-    new_ptr = asan_malloc(size, &stack);\n+  static void OnFree(const void *ptr, uptr size) {\n+#  if CAN_SANITIZE_LEAKS\n+    __lsan_unregister_root_region(ptr, size);\n+#  endif\n   }\n-  internal_memcpy(new_ptr, ptr, copy_size);\n-  return new_ptr;\n-}\n+};\n \n INTERCEPTOR(void, free, void *ptr) {\n-  if (UNLIKELY(IsInDlsymAllocPool(ptr))) {\n-    DeallocateFromLocalPool(ptr);\n-    return;\n-  }\n+  if (DlsymAlloc::PointerIsMine(ptr))\n+    return DlsymAlloc::Free(ptr);\n   GET_STACK_TRACE_FREE;\n   asan_free(ptr, &stack, FROM_MALLOC);\n }\n \n #if SANITIZER_INTERCEPT_CFREE\n INTERCEPTOR(void, cfree, void *ptr) {\n-  if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n-    return;\n+  if (DlsymAlloc::PointerIsMine(ptr))\n+    return DlsymAlloc::Free(ptr);\n   GET_STACK_TRACE_FREE;\n   asan_free(ptr, &stack, FROM_MALLOC);\n }\n #endif // SANITIZER_INTERCEPT_CFREE\n \n INTERCEPTOR(void*, malloc, uptr size) {\n-  if (UNLIKELY(UseLocalPool()))\n-    // Hack: dlsym calls malloc before REAL(malloc) is retrieved from dlsym.\n-    return AllocateFromLocalPool(size);\n+  if (DlsymAlloc::Use())\n+    return DlsymAlloc::Allocate(size);\n   ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   return asan_malloc(size, &stack);\n }\n \n INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n-  if (UNLIKELY(UseLocalPool()))\n-    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n-    return AllocateFromLocalPool(nmemb * size);\n+  if (DlsymAlloc::Use())\n+    return DlsymAlloc::Callocate(nmemb, size);\n   ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   return asan_calloc(nmemb, size, &stack);\n }\n \n INTERCEPTOR(void*, realloc, void *ptr, uptr size) {\n-  if (UNLIKELY(IsInDlsymAllocPool(ptr)))\n-    return ReallocFromLocalPool(ptr, size);\n-  if (UNLIKELY(UseLocalPool()))\n-    return AllocateFromLocalPool(size);\n+  if (DlsymAlloc::Use() || DlsymAlloc::PointerIsMine(ptr))\n+    return DlsymAlloc::Realloc(ptr, size);\n   ENSURE_ASAN_INITED();\n   GET_STACK_TRACE_MALLOC;\n   return asan_realloc(ptr, size, &stack);\n@@ -205,8 +142,6 @@ INTERCEPTOR(int, mallopt, int cmd, int value) {\n #endif // SANITIZER_INTERCEPT_MALLOPT_AND_MALLINFO\n \n INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n-  if (UNLIKELY(UseLocalPool()))\n-    return PosixMemalignFromLocalPool(memptr, alignment, size);\n   GET_STACK_TRACE_MALLOC;\n   return asan_posix_memalign(memptr, alignment, size, &stack);\n }"}, {"sha": "e5a7f2007aea8b8208e929e08ee675a55cd252eb", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -165,7 +165,7 @@ static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n static const u64 kRiscv64_ShadowOffset64 = 0xd55550000;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n-static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kPPC64_ShadowOffset64 = 1ULL << 44;\n static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kSPARC64_ShadowOffset64 = 1ULL << 43;  // 0x80000000000\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000"}, {"sha": "6f0ea64472c687242fe35b76f3fa04baf62c006f", "filename": "libsanitizer/hwasan/hwasan.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -345,7 +345,7 @@ __attribute__((constructor(0))) void __hwasan_init() {\n \n   // Needs to be called here because flags()->random_tags might not have been\n   // initialized when InitInstrumentation() was called.\n-  GetCurrentThread()->InitRandomState();\n+  GetCurrentThread()->EnsureRandomStateInited();\n \n   SetPrintfAndReportCallback(AppendToErrorMessageBuffer);\n   // This may call libc -> needs initialized shadow."}, {"sha": "9cd82dbabd19b90f869e56999f6bb476dd74fac6", "filename": "libsanitizer/hwasan/hwasan_allocation_functions.cpp", "status": "modified", "additions": 19, "deletions": 40, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_allocation_functions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_allocation_functions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_allocation_functions.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -14,29 +14,17 @@\n \n #include \"hwasan.h\"\n #include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_allocator_dlsym.h\"\n #include \"sanitizer_common/sanitizer_allocator_interface.h\"\n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n \n #if !SANITIZER_FUCHSIA\n \n using namespace __hwasan;\n \n-static uptr allocated_for_dlsym;\n-static const uptr kDlsymAllocPoolSize = 1024;\n-static uptr alloc_memory_for_dlsym[kDlsymAllocPoolSize];\n-\n-static bool IsInDlsymAllocPool(const void *ptr) {\n-  uptr off = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n-  return off < sizeof(alloc_memory_for_dlsym);\n-}\n-\n-static void *AllocateFromLocalPool(uptr size_in_bytes) {\n-  uptr size_in_words = RoundUpTo(size_in_bytes, kWordSize) / kWordSize;\n-  void *mem = (void *)&alloc_memory_for_dlsym[allocated_for_dlsym];\n-  allocated_for_dlsym += size_in_words;\n-  CHECK_LT(allocated_for_dlsym, kDlsymAllocPoolSize);\n-  return mem;\n-}\n+struct DlsymAlloc : public DlSymAllocator<DlsymAlloc> {\n+  static bool UseImpl() { return !hwasan_inited; }\n+};\n \n extern \"C\" {\n \n@@ -83,17 +71,21 @@ void *__sanitizer_pvalloc(uptr size) {\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_free(void *ptr) {\n-  GET_MALLOC_STACK_TRACE;\n-  if (!ptr || UNLIKELY(IsInDlsymAllocPool(ptr)))\n+  if (!ptr)\n     return;\n+  if (DlsymAlloc::PointerIsMine(ptr))\n+    return DlsymAlloc::Free(ptr);\n+  GET_MALLOC_STACK_TRACE;\n   hwasan_free(ptr, &stack);\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_cfree(void *ptr) {\n-  GET_MALLOC_STACK_TRACE;\n-  if (!ptr || UNLIKELY(IsInDlsymAllocPool(ptr)))\n+  if (!ptr)\n     return;\n+  if (DlsymAlloc::PointerIsMine(ptr))\n+    return DlsymAlloc::Free(ptr);\n+  GET_MALLOC_STACK_TRACE;\n   hwasan_free(ptr, &stack);\n }\n \n@@ -119,29 +111,17 @@ void __sanitizer_malloc_stats(void) {\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void *__sanitizer_calloc(uptr nmemb, uptr size) {\n+  if (DlsymAlloc::Use())\n+    return DlsymAlloc::Callocate(nmemb, size);\n   GET_MALLOC_STACK_TRACE;\n-  if (UNLIKELY(!hwasan_inited))\n-    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n-    return AllocateFromLocalPool(nmemb * size);\n   return hwasan_calloc(nmemb, size, &stack);\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void *__sanitizer_realloc(void *ptr, uptr size) {\n+  if (DlsymAlloc::Use() || DlsymAlloc::PointerIsMine(ptr))\n+    return DlsymAlloc::Realloc(ptr, size);\n   GET_MALLOC_STACK_TRACE;\n-  if (UNLIKELY(IsInDlsymAllocPool(ptr))) {\n-    uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n-    uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);\n-    void *new_ptr;\n-    if (UNLIKELY(!hwasan_inited)) {\n-      new_ptr = AllocateFromLocalPool(copy_size);\n-    } else {\n-      copy_size = size;\n-      new_ptr = hwasan_malloc(copy_size, &stack);\n-    }\n-    internal_memcpy(new_ptr, ptr, copy_size);\n-    return new_ptr;\n-  }\n   return hwasan_realloc(ptr, size, &stack);\n }\n \n@@ -153,12 +133,11 @@ void *__sanitizer_reallocarray(void *ptr, uptr nmemb, uptr size) {\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void *__sanitizer_malloc(uptr size) {\n-  GET_MALLOC_STACK_TRACE;\n   if (UNLIKELY(!hwasan_init_is_running))\n     ENSURE_HWASAN_INITED();\n-  if (UNLIKELY(!hwasan_inited))\n-    // Hack: dlsym calls malloc before REAL(malloc) is retrieved from dlsym.\n-    return AllocateFromLocalPool(size);\n+  if (DlsymAlloc::Use())\n+    return DlsymAlloc::Allocate(size);\n+  GET_MALLOC_STACK_TRACE;\n   return hwasan_malloc(size, &stack);\n }\n "}, {"sha": "6ed1da335428066498d6e99f96d22cc986c19e65", "filename": "libsanitizer/hwasan/hwasan_exceptions.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_exceptions.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_exceptions.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_exceptions.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -29,8 +29,8 @@ typedef _Unwind_Reason_Code PersonalityFn(int version, _Unwind_Action actions,\n // is statically linked and the sanitizer runtime and the program are linked\n // against different unwinders. The _Unwind_Context data structure is opaque so\n // it may be incompatible between unwinders.\n-typedef _Unwind_Word GetGRFn(_Unwind_Context* context, int index);\n-typedef _Unwind_Word GetCFAFn(_Unwind_Context* context);\n+typedef uintptr_t GetGRFn(_Unwind_Context* context, int index);\n+typedef uintptr_t GetCFAFn(_Unwind_Context* context);\n \n extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE _Unwind_Reason_Code\n __hwasan_personality_wrapper(int version, _Unwind_Action actions,"}, {"sha": "94e5c5fb69c783b9978d44c19aa5578edc069802", "filename": "libsanitizer/hwasan/hwasan_fuchsia.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_fuchsia.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -130,7 +130,7 @@ static void ThreadCreateHook(void *hook, bool aborted) {\n static void ThreadStartHook(void *hook, thrd_t self) {\n   Thread *thread = static_cast<Thread *>(hook);\n   FinishThreadInitialization(thread);\n-  thread->InitRandomState();\n+  thread->EnsureRandomStateInited();\n }\n \n // This is the function that sets up the stack ring buffer and enables us to use"}, {"sha": "ba9e23621cc2ae9707ce01c40394a2720d138200", "filename": "libsanitizer/hwasan/hwasan_linux.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_linux.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -250,7 +250,7 @@ void InstallAtExitHandler() { atexit(HwasanAtExit); }\n // ---------------------- TSD ---------------- {{{1\n \n extern \"C\" void __hwasan_thread_enter() {\n-  hwasanThreadList().CreateCurrentThread()->InitRandomState();\n+  hwasanThreadList().CreateCurrentThread()->EnsureRandomStateInited();\n }\n \n extern \"C\" void __hwasan_thread_exit() {"}, {"sha": "c776ae179cec2e5ed38b12a9fa3d9ab93a465c68", "filename": "libsanitizer/hwasan/hwasan_thread.cpp", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_thread.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_thread.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_thread.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -1,15 +1,15 @@\n \n+#include \"hwasan_thread.h\"\n+\n #include \"hwasan.h\"\n+#include \"hwasan_interface_internal.h\"\n #include \"hwasan_mapping.h\"\n-#include \"hwasan_thread.h\"\n #include \"hwasan_poisoning.h\"\n-#include \"hwasan_interface_internal.h\"\n-\n+#include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_file.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n \n-\n namespace __hwasan {\n \n static u32 RandomSeed() {\n@@ -27,6 +27,7 @@ static u32 RandomSeed() {\n \n void Thread::InitRandomState() {\n   random_state_ = flags()->random_tags ? RandomSeed() : unique_id_;\n+  random_state_inited_ = true;\n \n   // Push a random number of zeros onto the ring buffer so that the first stack\n   // tag base will be random.\n@@ -40,8 +41,9 @@ void Thread::Init(uptr stack_buffer_start, uptr stack_buffer_size,\n   CHECK_EQ(0, stack_top_);\n   CHECK_EQ(0, stack_bottom_);\n \n-  static u64 unique_id;\n-  unique_id_ = unique_id++;\n+  static atomic_uint64_t unique_id;\n+  unique_id_ = atomic_fetch_add(&unique_id, 1, memory_order_relaxed);\n+\n   if (auto sz = flags()->heap_history_size)\n     heap_allocations_ = HeapAllocationsRingBuffer::New(sz);\n \n@@ -123,17 +125,21 @@ static u32 xorshift(u32 state) {\n // Generate a (pseudo-)random non-zero tag.\n tag_t Thread::GenerateRandomTag(uptr num_bits) {\n   DCHECK_GT(num_bits, 0);\n-  if (tagging_disabled_) return 0;\n+  if (tagging_disabled_)\n+    return 0;\n   tag_t tag;\n   const uptr tag_mask = (1ULL << num_bits) - 1;\n   do {\n     if (flags()->random_tags) {\n-      if (!random_buffer_)\n+      if (!random_buffer_) {\n+        EnsureRandomStateInited();\n         random_buffer_ = random_state_ = xorshift(random_state_);\n+      }\n       CHECK(random_buffer_);\n       tag = random_buffer_ & tag_mask;\n       random_buffer_ >>= num_bits;\n     } else {\n+      EnsureRandomStateInited();\n       random_state_ += 1;\n       tag = random_state_ & tag_mask;\n     }"}, {"sha": "3db7c1a9454f30211e637c3023e2911be4f931a6", "filename": "libsanitizer/hwasan/hwasan_thread.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fhwasan%2Fhwasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fhwasan%2Fhwasan_thread.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -28,12 +28,17 @@ class Thread {\n \n   void Init(uptr stack_buffer_start, uptr stack_buffer_size,\n             const InitState *state = nullptr);\n-  void InitRandomState();\n+\n   void InitStackAndTls(const InitState *state = nullptr);\n \n   // Must be called from the thread itself.\n   void InitStackRingBuffer(uptr stack_buffer_start, uptr stack_buffer_size);\n \n+  inline void EnsureRandomStateInited() {\n+    if (UNLIKELY(!random_state_inited_))\n+      InitRandomState();\n+  }\n+\n   void Destroy();\n \n   uptr stack_top() { return stack_top_; }\n@@ -70,6 +75,7 @@ class Thread {\n   // via mmap() and *must* be valid in zero-initialized state.\n   void ClearShadowForThreadStackAndTLS();\n   void Print(const char *prefix);\n+  void InitRandomState();\n   uptr vfork_spill_;\n   uptr stack_top_;\n   uptr stack_bottom_;\n@@ -89,6 +95,8 @@ class Thread {\n \n   bool announced_;\n \n+  bool random_state_inited_;  // Whether InitRandomState() has been called.\n+\n   friend struct ThreadListHead;\n };\n "}, {"sha": "308dbb3e41dab111571e6b3515e66dd73ab542d4", "filename": "libsanitizer/lsan/lsan_common.cpp", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Flsan%2Flsan_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Flsan%2Flsan_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -131,18 +131,13 @@ static LeakSuppressionContext *GetSuppressionContext() {\n   return suppression_ctx;\n }\n \n-static InternalMmapVector<RootRegion> *root_regions;\n+static InternalMmapVectorNoCtor<RootRegion> root_regions;\n \n-InternalMmapVector<RootRegion> const *GetRootRegions() { return root_regions; }\n-\n-void InitializeRootRegions() {\n-  CHECK(!root_regions);\n-  ALIGNED(64) static char placeholder[sizeof(InternalMmapVector<RootRegion>)];\n-  root_regions = new (placeholder) InternalMmapVector<RootRegion>();\n+InternalMmapVectorNoCtor<RootRegion> const *GetRootRegions() {\n+  return &root_regions;\n }\n \n void InitCommonLsan() {\n-  InitializeRootRegions();\n   if (common_flags()->detect_leaks) {\n     // Initialization which can fail or print warnings should only be done if\n     // LSan is actually enabled.\n@@ -426,10 +421,8 @@ static void ProcessRootRegion(Frontier *frontier,\n // Scans root regions for heap pointers.\n static void ProcessRootRegions(Frontier *frontier) {\n   if (!flags()->use_root_regions) return;\n-  CHECK(root_regions);\n-  for (uptr i = 0; i < root_regions->size(); i++) {\n-    ProcessRootRegion(frontier, (*root_regions)[i]);\n-  }\n+  for (uptr i = 0; i < root_regions.size(); i++)\n+    ProcessRootRegion(frontier, root_regions[i]);\n }\n \n static void FloodFillTag(Frontier *frontier, ChunkTag tag) {\n@@ -966,9 +959,8 @@ SANITIZER_INTERFACE_ATTRIBUTE\n void __lsan_register_root_region(const void *begin, uptr size) {\n #if CAN_SANITIZE_LEAKS\n   Lock l(&global_mutex);\n-  CHECK(root_regions);\n   RootRegion region = {reinterpret_cast<uptr>(begin), size};\n-  root_regions->push_back(region);\n+  root_regions.push_back(region);\n   VReport(1, \"Registered root region at %p of size %zu\\n\", begin, size);\n #endif // CAN_SANITIZE_LEAKS\n }\n@@ -977,15 +969,14 @@ SANITIZER_INTERFACE_ATTRIBUTE\n void __lsan_unregister_root_region(const void *begin, uptr size) {\n #if CAN_SANITIZE_LEAKS\n   Lock l(&global_mutex);\n-  CHECK(root_regions);\n   bool removed = false;\n-  for (uptr i = 0; i < root_regions->size(); i++) {\n-    RootRegion region = (*root_regions)[i];\n+  for (uptr i = 0; i < root_regions.size(); i++) {\n+    RootRegion region = root_regions[i];\n     if (region.begin == reinterpret_cast<uptr>(begin) && region.size == size) {\n       removed = true;\n-      uptr last_index = root_regions->size() - 1;\n-      (*root_regions)[i] = (*root_regions)[last_index];\n-      root_regions->pop_back();\n+      uptr last_index = root_regions.size() - 1;\n+      root_regions[i] = root_regions[last_index];\n+      root_regions.pop_back();\n       VReport(1, \"Unregistered root region at %p of size %zu\\n\", begin, size);\n       break;\n     }"}, {"sha": "f9b55e4e80063e63969e8f83930436cf75282f68", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -140,7 +140,7 @@ struct CheckForLeaksParam {\n   bool success = false;\n };\n \n-InternalMmapVector<RootRegion> const *GetRootRegions();\n+InternalMmapVectorNoCtor<RootRegion> const *GetRootRegions();\n void ScanRootRegion(Frontier *frontier, RootRegion const &region,\n                     uptr region_begin, uptr region_end, bool is_readable);\n void ForEachExtraStackRangeCb(uptr begin, uptr end, void* arg);\n@@ -280,6 +280,13 @@ int __lsan_is_turned_off();\n \n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n const char *__lsan_default_suppressions();\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __lsan_register_root_region(const void *p, __lsan::uptr size);\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __lsan_unregister_root_region(const void *p, __lsan::uptr size);\n+\n }  // extern \"C\"\n \n #endif  // LSAN_COMMON_H"}, {"sha": "4301dcc615d72ba41c34de032f10f8a2ae30c693", "filename": "libsanitizer/lsan/lsan_common_mac.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Flsan%2Flsan_common_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_mac.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -149,7 +149,7 @@ void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n   kern_return_t err = KERN_SUCCESS;\n   mach_msg_type_number_t count = VM_REGION_SUBMAP_INFO_COUNT_64;\n \n-  InternalMmapVector<RootRegion> const *root_regions = GetRootRegions();\n+  InternalMmapVectorNoCtor<RootRegion> const *root_regions = GetRootRegions();\n \n   while (err == KERN_SUCCESS) {\n     struct vm_region_submap_info_64 info;"}, {"sha": "22999d567f62beb2d440e2d13f852f140982f81d", "filename": "libsanitizer/lsan/lsan_interceptors.cpp", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Flsan%2Flsan_interceptors.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -13,6 +13,7 @@\n \n #include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_allocator.h\"\n+#include \"sanitizer_common/sanitizer_allocator_dlsym.h\"\n #include \"sanitizer_common/sanitizer_allocator_report.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n@@ -43,6 +44,22 @@ int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n int pthread_setspecific(unsigned key, const void *v);\n }\n \n+struct DlsymAlloc : DlSymAllocator<DlsymAlloc> {\n+  static bool UseImpl() { return lsan_init_is_running; }\n+  static void OnAllocate(const void *ptr, uptr size) {\n+#if CAN_SANITIZE_LEAKS\n+    // Suppress leaks from dlerror(). Previously dlsym hack on global array was\n+    // used by leak sanitizer as a root region.\n+    __lsan_register_root_region(ptr, size);\n+#endif\n+  }\n+  static void OnFree(const void *ptr, uptr size) {\n+#if CAN_SANITIZE_LEAKS\n+    __lsan_unregister_root_region(ptr, size);\n+#endif\n+  }\n+};\n+\n ///// Malloc/free interceptors. /////\n \n namespace std {\n@@ -52,41 +69,34 @@ namespace std {\n \n #if !SANITIZER_MAC\n INTERCEPTOR(void*, malloc, uptr size) {\n+  if (DlsymAlloc::Use())\n+    return DlsymAlloc::Allocate(size);\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n   return lsan_malloc(size, stack);\n }\n \n INTERCEPTOR(void, free, void *p) {\n+  if (DlsymAlloc::PointerIsMine(p))\n+    return DlsymAlloc::Free(p);\n   ENSURE_LSAN_INITED;\n   lsan_free(p);\n }\n \n INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n-  // This hack is not required for Fuchsia because there are no dlsym calls\n-  // involved in setting up interceptors.\n-#if !SANITIZER_FUCHSIA\n-  if (lsan_init_is_running) {\n-    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n-    const uptr kCallocPoolSize = 1024;\n-    static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n-    static uptr allocated;\n-    uptr size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;\n-    void *mem = (void*)&calloc_memory_for_dlsym[allocated];\n-    allocated += size_in_words;\n-    CHECK(allocated < kCallocPoolSize);\n-    return mem;\n-  }\n-#endif  // !SANITIZER_FUCHSIA\n+  if (DlsymAlloc::Use())\n+    return DlsymAlloc::Callocate(nmemb, size);\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n   return lsan_calloc(nmemb, size, stack);\n }\n \n-INTERCEPTOR(void*, realloc, void *q, uptr size) {\n+INTERCEPTOR(void *, realloc, void *ptr, uptr size) {\n+  if (DlsymAlloc::Use() || DlsymAlloc::PointerIsMine(ptr))\n+    return DlsymAlloc::Realloc(ptr, size);\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n-  return lsan_realloc(q, size, stack);\n+  return lsan_realloc(ptr, size, stack);\n }\n \n INTERCEPTOR(void*, reallocarray, void *q, uptr nmemb, uptr size) {"}, {"sha": "7e2fa91089f13b7d1bce6b0ac1cbbb85ab8ea04f", "filename": "libsanitizer/sanitizer_common/sanitizer_addrhashmap.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_addrhashmap.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -39,6 +39,11 @@ namespace __sanitizer {\n //   the current thread has exclusive access to the data\n //   if !h.exists() then the element never existed\n // }\n+// {\n+//   Map::Handle h(&m, addr, false, true);\n+//   this will create a new element or return a handle to an existing element\n+//   if !h.created() this thread does *not* have exclusive access to the data\n+// }\n template<typename T, uptr kSize>\n class AddrHashMap {\n  private:\n@@ -89,6 +94,12 @@ class AddrHashMap {\n     bool                   create_;\n   };\n \n+  typedef void (*ForEachCallback)(const uptr key, const T &val, void *arg);\n+  // ForEach acquires a lock on each bucket while iterating over\n+  // elements. Note that this only ensures that the structure of the hashmap is\n+  // unchanged, there may be a data race to the element itself.\n+  void ForEach(ForEachCallback cb, void *arg);\n+\n  private:\n   friend class Handle;\n   Bucket *table_;\n@@ -98,6 +109,33 @@ class AddrHashMap {\n   uptr calcHash(uptr addr);\n };\n \n+template <typename T, uptr kSize>\n+void AddrHashMap<T, kSize>::ForEach(ForEachCallback cb, void *arg) {\n+  for (uptr n = 0; n < kSize; n++) {\n+    Bucket *bucket = &table_[n];\n+\n+    ReadLock lock(&bucket->mtx);\n+\n+    for (uptr i = 0; i < kBucketSize; i++) {\n+      Cell *c = &bucket->cells[i];\n+      uptr addr1 = atomic_load(&c->addr, memory_order_acquire);\n+      if (addr1 != 0)\n+        cb(addr1, c->val, arg);\n+    }\n+\n+    // Iterate over any additional cells.\n+    if (AddBucket *add =\n+            (AddBucket *)atomic_load(&bucket->add, memory_order_acquire)) {\n+      for (uptr i = 0; i < add->size; i++) {\n+        Cell *c = &add->cells[i];\n+        uptr addr1 = atomic_load(&c->addr, memory_order_acquire);\n+        if (addr1 != 0)\n+          cb(addr1, c->val, arg);\n+      }\n+    }\n+  }\n+}\n+\n template<typename T, uptr kSize>\n AddrHashMap<T, kSize>::Handle::Handle(AddrHashMap<T, kSize> *map, uptr addr) {\n   map_ = map;"}, {"sha": "9a3602f730b308e6f81f251a2077d383890d1aa4", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_combined.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -112,15 +112,13 @@ class CombinedAllocator {\n     return new_p;\n   }\n \n-  bool PointerIsMine(void *p) {\n+  bool PointerIsMine(const void *p) const {\n     if (primary_.PointerIsMine(p))\n       return true;\n     return secondary_.PointerIsMine(p);\n   }\n \n-  bool FromPrimary(void *p) {\n-    return primary_.PointerIsMine(p);\n-  }\n+  bool FromPrimary(const void *p) const { return primary_.PointerIsMine(p); }\n \n   void *GetMetaData(const void *p) {\n     if (primary_.PointerIsMine(p))"}, {"sha": "92b1373ef84d1aa400aca267655e5274a8aed5be", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_dlsym.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_dlsym.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_dlsym.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_dlsym.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -0,0 +1,79 @@\n+//===-- sanitizer_allocator_dlsym.h -----------------------------*- C++ -*-===//\n+//\n+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n+// See https://llvm.org/LICENSE.txt for license information.\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Hack: Sanitizer initializer calls dlsym which may need to allocate and call\n+// back into uninitialized sanitizer.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_ALLOCATOR_DLSYM_H\n+#define SANITIZER_ALLOCATOR_DLSYM_H\n+\n+#include \"sanitizer_allocator_internal.h\"\n+\n+namespace __sanitizer {\n+\n+template <typename Details>\n+struct DlSymAllocator {\n+  static bool Use() {\n+    // Fuchsia doesn't use dlsym-based interceptors.\n+    return !SANITIZER_FUCHSIA && UNLIKELY(Details::UseImpl());\n+  }\n+\n+  static bool PointerIsMine(const void *ptr) {\n+    // Fuchsia doesn't use dlsym-based interceptors.\n+    return !SANITIZER_FUCHSIA &&\n+           UNLIKELY(internal_allocator()->FromPrimary(ptr));\n+  }\n+\n+  static void *Allocate(uptr size_in_bytes) {\n+    void *ptr = InternalAlloc(size_in_bytes, nullptr, kWordSize);\n+    CHECK(internal_allocator()->FromPrimary(ptr));\n+    Details::OnAllocate(ptr,\n+                        internal_allocator()->GetActuallyAllocatedSize(ptr));\n+    return ptr;\n+  }\n+\n+  static void *Callocate(SIZE_T nmemb, SIZE_T size) {\n+    void *ptr = InternalCalloc(nmemb, size);\n+    CHECK(internal_allocator()->FromPrimary(ptr));\n+    Details::OnAllocate(ptr,\n+                        internal_allocator()->GetActuallyAllocatedSize(ptr));\n+    return ptr;\n+  }\n+\n+  static void Free(void *ptr) {\n+    uptr size = internal_allocator()->GetActuallyAllocatedSize(ptr);\n+    Details::OnFree(ptr, size);\n+    InternalFree(ptr);\n+  }\n+\n+  static void *Realloc(void *ptr, uptr new_size) {\n+    if (!ptr)\n+      return Allocate(new_size);\n+    CHECK(internal_allocator()->FromPrimary(ptr));\n+    if (!new_size) {\n+      Free(ptr);\n+      return nullptr;\n+    }\n+    uptr size = internal_allocator()->GetActuallyAllocatedSize(ptr);\n+    uptr memcpy_size = Min(new_size, size);\n+    void *new_ptr = Allocate(new_size);\n+    if (new_ptr)\n+      internal_memcpy(new_ptr, ptr, memcpy_size);\n+    Free(ptr);\n+    return new_ptr;\n+  }\n+\n+  static void OnAllocate(const void *ptr, uptr size) {}\n+  static void OnFree(const void *ptr, uptr size) {}\n+};\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_ALLOCATOR_DLSYM_H"}, {"sha": "ae1b7e0d5f1c491a8ba29b471a2377155e3e866f", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary32.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -189,7 +189,7 @@ class SizeClassAllocator32 {\n     sci->free_list.push_front(b);\n   }\n \n-  bool PointerIsMine(const void *p) {\n+  bool PointerIsMine(const void *p) const {\n     uptr mem = reinterpret_cast<uptr>(p);\n     if (SANITIZER_SIGN_EXTENDED_ADDRESSES)\n       mem &= (kSpaceSize - 1);\n@@ -293,9 +293,7 @@ class SizeClassAllocator32 {\n     return res;\n   }\n \n-  uptr ComputeRegionBeg(uptr mem) {\n-    return mem & ~(kRegionSize - 1);\n-  }\n+  uptr ComputeRegionBeg(uptr mem) const { return mem & ~(kRegionSize - 1); }\n \n   uptr AllocateRegion(AllocatorStats *stat, uptr class_id) {\n     DCHECK_LT(class_id, kNumClasses);"}, {"sha": "c24354cb5b2ae21eada240019c3d9ee16e6df966", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_secondary.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -161,7 +161,7 @@ class LargeMmapAllocator {\n     return res;\n   }\n \n-  bool PointerIsMine(const void *p) {\n+  bool PointerIsMine(const void *p) const {\n     return GetBlockBegin(p) != nullptr;\n   }\n \n@@ -179,7 +179,7 @@ class LargeMmapAllocator {\n     return GetHeader(p) + 1;\n   }\n \n-  void *GetBlockBegin(const void *ptr) {\n+  void *GetBlockBegin(const void *ptr) const {\n     uptr p = reinterpret_cast<uptr>(ptr);\n     SpinMutexLock l(&mutex_);\n     uptr nearest_chunk = 0;\n@@ -301,7 +301,7 @@ class LargeMmapAllocator {\n     return GetHeader(reinterpret_cast<uptr>(p));\n   }\n \n-  void *GetUser(const Header *h) {\n+  void *GetUser(const Header *h) const {\n     CHECK(IsAligned((uptr)h, page_size_));\n     return reinterpret_cast<void*>(reinterpret_cast<uptr>(h) + page_size_);\n   }\n@@ -318,5 +318,5 @@ class LargeMmapAllocator {\n   struct Stats {\n     uptr n_allocs, n_frees, currently_allocated, max_allocated, by_size_log[64];\n   } stats;\n-  StaticSpinMutex mutex_;\n+  mutable StaticSpinMutex mutex_;\n };"}, {"sha": "0749f633b4bcf54c41f82b1193fba59fa7eb9c69", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -293,7 +293,7 @@ class DeadlockDetector {\n   }\n \n   // Returns true iff dtls is empty (no locks are currently held) and we can\n-  // add the node to the currently held locks w/o chanding the global state.\n+  // add the node to the currently held locks w/o changing the global state.\n   // This operation is thread-safe as it only touches the dtls.\n   bool onFirstLock(DeadlockDetectorTLS<BV> *dtls, uptr node, u32 stk = 0) {\n     if (!dtls->empty()) return false;"}, {"sha": "aa59d9718ca89cc554bdf677df3e64ddd233ca59", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cpp", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -150,14 +150,34 @@ const int FUTEX_WAKE_PRIVATE = FUTEX_WAKE | FUTEX_PRIVATE_FLAG;\n \n namespace __sanitizer {\n \n-#if SANITIZER_LINUX && defined(__x86_64__)\n-#include \"sanitizer_syscall_linux_x86_64.inc\"\n-#elif SANITIZER_LINUX && SANITIZER_RISCV64\n-#include \"sanitizer_syscall_linux_riscv64.inc\"\n-#elif SANITIZER_LINUX && defined(__aarch64__)\n-#include \"sanitizer_syscall_linux_aarch64.inc\"\n-#elif SANITIZER_LINUX && defined(__arm__)\n-#include \"sanitizer_syscall_linux_arm.inc\"\n+void SetSigProcMask(__sanitizer_sigset_t *set, __sanitizer_sigset_t *old) {\n+  CHECK_EQ(0, internal_sigprocmask(SIG_SETMASK, set, old));\n+}\n+\n+ScopedBlockSignals::ScopedBlockSignals(__sanitizer_sigset_t *copy) {\n+  __sanitizer_sigset_t set;\n+  internal_sigfillset(&set);\n+#  if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  // Glibc uses SIGSETXID signal during setuid call. If this signal is blocked\n+  // on any thread, setuid call hangs.\n+  // See test/sanitizer_common/TestCases/Linux/setuid.c.\n+  internal_sigdelset(&set, 33);\n+#  endif\n+  SetSigProcMask(&set, &saved_);\n+  if (copy)\n+    internal_memcpy(copy, &saved_, sizeof(saved_));\n+}\n+\n+ScopedBlockSignals::~ScopedBlockSignals() { SetSigProcMask(&saved_, nullptr); }\n+\n+#  if SANITIZER_LINUX && defined(__x86_64__)\n+#    include \"sanitizer_syscall_linux_x86_64.inc\"\n+#  elif SANITIZER_LINUX && SANITIZER_RISCV64\n+#    include \"sanitizer_syscall_linux_riscv64.inc\"\n+#  elif SANITIZER_LINUX && defined(__aarch64__)\n+#    include \"sanitizer_syscall_linux_aarch64.inc\"\n+#  elif SANITIZER_LINUX && defined(__arm__)\n+#    include \"sanitizer_syscall_linux_arm.inc\"\n #  elif SANITIZER_LINUX && defined(__hexagon__)\n #    include \"sanitizer_syscall_linux_hexagon.inc\"\n #  else\n@@ -1741,17 +1761,9 @@ HandleSignalMode GetHandleSignalMode(int signum) {\n #if !SANITIZER_GO\n void *internal_start_thread(void *(*func)(void *arg), void *arg) {\n   // Start the thread with signals blocked, otherwise it can steal user signals.\n-  __sanitizer_sigset_t set, old;\n-  internal_sigfillset(&set);\n-#if SANITIZER_LINUX && !SANITIZER_ANDROID\n-  // Glibc uses SIGSETXID signal during setuid call. If this signal is blocked\n-  // on any thread, setuid call hangs (see test/tsan/setuid.c).\n-  internal_sigdelset(&set, 33);\n-#endif\n-  internal_sigprocmask(SIG_SETMASK, &set, &old);\n+  ScopedBlockSignals block(nullptr);\n   void *th;\n   real_pthread_create(&th, nullptr, func, arg);\n-  internal_sigprocmask(SIG_SETMASK, &old, nullptr);\n   return th;\n }\n \n@@ -1773,7 +1785,7 @@ struct __sanitizer_esr_context {\n \n static bool Aarch64GetESR(ucontext_t *ucontext, u64 *esr) {\n   static const u32 kEsrMagic = 0x45535201;\n-  u8 *aux = ucontext->uc_mcontext.__reserved;\n+  u8 *aux = reinterpret_cast<u8 *>(ucontext->uc_mcontext.__reserved);\n   while (true) {\n     _aarch64_ctx *ctx = (_aarch64_ctx *)aux;\n     if (ctx->size == 0) break;"}, {"sha": "6a235db0ee2eedaa64306426e677bab6ced98e8e", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -49,7 +49,17 @@ uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count);\n uptr internal_sigaltstack(const void* ss, void* oss);\n uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n     __sanitizer_sigset_t *oldset);\n-#if SANITIZER_GLIBC\n+\n+void SetSigProcMask(__sanitizer_sigset_t *set, __sanitizer_sigset_t *oldset);\n+struct ScopedBlockSignals {\n+  explicit ScopedBlockSignals(__sanitizer_sigset_t *copy);\n+  ~ScopedBlockSignals();\n+\n+ private:\n+  __sanitizer_sigset_t saved_;\n+};\n+\n+#  if SANITIZER_GLIBC\n uptr internal_clock_gettime(__sanitizer_clockid_t clk_id, void *tp);\n #endif\n "}, {"sha": "7ce9e25da342d8d70312d956a68b137f29326eb8", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cpp", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -759,13 +759,9 @@ u32 GetNumberOfCPUs() {\n #elif SANITIZER_SOLARIS\n   return sysconf(_SC_NPROCESSORS_ONLN);\n #else\n-#if defined(CPU_COUNT)\n   cpu_set_t CPUs;\n   CHECK_EQ(sched_getaffinity(0, sizeof(cpu_set_t), &CPUs), 0);\n   return CPU_COUNT(&CPUs);\n-#else\n-  return 1;\n-#endif\n #endif\n }\n "}, {"sha": "b67203d4c10e8ff07417d29f2a8f98f74129a2ba", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cpp", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -37,7 +37,7 @@\n extern char **environ;\n #endif\n \n-#if defined(__has_include) && __has_include(<os/trace.h>) && defined(__BLOCKS__)\n+#if defined(__has_include) && __has_include(<os/trace.h>)\n #define SANITIZER_OS_TRACE 1\n #include <os/trace.h>\n #else\n@@ -70,15 +70,7 @@ extern \"C\" {\n #include <mach/mach_time.h>\n #include <mach/vm_statistics.h>\n #include <malloc/malloc.h>\n-#if defined(__has_builtin) && __has_builtin(__builtin_os_log_format)\n-# include <os/log.h>\n-#else\n-   /* Without support for __builtin_os_log_format, fall back to the older\n-      method.  */\n-# define OS_LOG_DEFAULT 0\n-# define os_log_error(A,B,C) \\\n-  asl_log(nullptr, nullptr, ASL_LEVEL_ERR, \"%s\", (C));\n-#endif\n+#include <os/log.h>\n #include <pthread.h>\n #include <sched.h>\n #include <signal.h>\n@@ -551,6 +543,9 @@ uptr TlsBaseAddr() {\n   asm(\"movq %%gs:0,%0\" : \"=r\"(segbase));\n #elif defined(__i386__)\n   asm(\"movl %%gs:0,%0\" : \"=r\"(segbase));\n+#elif defined(__aarch64__)\n+  asm(\"mrs %x0, tpidrro_el0\" : \"=r\"(segbase));\n+  segbase &= 0x07ul;  // clearing lower bits, cpu id stored there\n #endif\n   return segbase;\n }"}, {"sha": "0b6af5a3c0edc649c4d65dfd1a6ca1bce13aa9b9", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -14,26 +14,6 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_platform.h\"\n-\n-/* TARGET_OS_OSX is not present in SDKs before Darwin16 (macOS 10.12) use\n-   TARGET_OS_MAC (we have no support for iOS in any form for these versions,\n-   so there's no ambiguity).  */\n-#if !defined(TARGET_OS_OSX) && TARGET_OS_MAC\n-# define TARGET_OS_OSX 1\n-#endif\n-\n-/* Other TARGET_OS_xxx are not present on earlier versions, define them to\n-   0 (we have no support for them; they are not valid targets anyway).  */\n-#ifndef TARGET_OS_IOS\n-#define TARGET_OS_IOS 0\n-#endif\n-#ifndef TARGET_OS_TV\n-#define TARGET_OS_TV 0\n-#endif\n-#ifndef TARGET_OS_WATCH\n-#define TARGET_OS_WATCH 0\n-#endif\n-\n #if SANITIZER_MAC\n #include \"sanitizer_posix.h\"\n "}, {"sha": "764e2cef5e74dfe62cc2f5ed0398fc4d85717335", "filename": "libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -23,6 +23,7 @@\n #include <sys/mman.h>\n \n #include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_allocator_dlsym.h\"\n #include \"sanitizer_common/sanitizer_mac.h\"\n \n // Similar code is used in Google Perftools,\n@@ -192,20 +193,15 @@ void *__sanitizer_mz_malloc(malloc_zone_t *zone, uptr size) {\n   return p;\n }\n \n+struct DlsymAlloc : public DlSymAllocator<DlsymAlloc> {\n+  static bool UseImpl() { return !COMMON_MALLOC_SANITIZER_INITIALIZED; }\n+};\n+\n extern \"C\"\n SANITIZER_INTERFACE_ATTRIBUTE\n void *__sanitizer_mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n-  if (UNLIKELY(!COMMON_MALLOC_SANITIZER_INITIALIZED)) {\n-    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n-    const size_t kCallocPoolSize = 1024;\n-    static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n-    static size_t allocated;\n-    size_t size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;\n-    void *mem = (void*)&calloc_memory_for_dlsym[allocated];\n-    allocated += size_in_words;\n-    CHECK(allocated < kCallocPoolSize);\n-    return mem;\n-  }\n+  if (DlsymAlloc::Use())\n+    return DlsymAlloc::Callocate(nmemb, size);\n   COMMON_MALLOC_CALLOC(nmemb, size);\n   return p;\n }\n@@ -223,6 +219,8 @@ extern \"C\"\n SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_mz_free(malloc_zone_t *zone, void *ptr) {\n   if (!ptr) return;\n+  if (DlsymAlloc::PointerIsMine(ptr))\n+    return DlsymAlloc::Free(ptr);\n   COMMON_MALLOC_FREE(ptr);\n }\n "}, {"sha": "14610f2df78df5a002ac8419e8d103dd0b961e05", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -465,9 +465,9 @@\n #define SANITIZER_INTERCEPT_STAT                                        \\\n   (SI_FREEBSD || SI_MAC || SI_ANDROID || SI_NETBSD || SI_SOLARIS ||     \\\n    SI_STAT_LINUX)\n-#define SANITIZER_INTERCEPT_LSTAT (SI_NETBSD || SI_FREEBSD)\n-#define SANITIZER_INTERCEPT___XSTAT                             \\\n-  (!SANITIZER_INTERCEPT_STAT && SI_POSIX) || SI_STAT_LINUX\n+#define SANITIZER_INTERCEPT_LSTAT (SI_NETBSD || SI_FREEBSD || SI_STAT_LINUX)\n+#define SANITIZER_INTERCEPT___XSTAT \\\n+  ((!SANITIZER_INTERCEPT_STAT && SI_POSIX) || SI_STAT_LINUX)\n #define SANITIZER_INTERCEPT___XSTAT64 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT___LXSTAT SANITIZER_INTERCEPT___XSTAT\n #define SANITIZER_INTERCEPT___LXSTAT64 SI_LINUX_NOT_ANDROID"}, {"sha": "9d577570ea1e2e219b4a08c64f450794d6a145d7", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cpp", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -26,10 +26,7 @@\n \n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n-// fine with newer headers, too.  Beware that with <sys/stat.h>, struct stat\n-// takes the form of struct stat64 on 32-bit platforms if _FILE_OFFSET_BITS=64.\n-// Also, for some platforms (e.g. mips) there are additional members in the\n-// <sys/stat.h> struct stat:s.\n+// fine with newer headers, too.\n #include <linux/posix_types.h>\n #  if defined(__x86_64__) || defined(__mips__) || defined(__hexagon__)\n #    include <sys/stat.h>"}, {"sha": "d69b344dd613d6e2f25c39d839cbf5a899ddf81d", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -83,7 +83,7 @@ const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__mips__)\n const unsigned struct_kernel_stat_sz = SANITIZER_ANDROID\n                                            ? FIRST_32_SECOND_64(104, 128)\n-                                           : FIRST_32_SECOND_64(144, 216);\n+                                           : FIRST_32_SECOND_64(160, 216);\n const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__s390__) && !defined(__s390x__)\n const unsigned struct_kernel_stat_sz = 64;"}, {"sha": "055af366ef06e2f41b4ad9ac0cb227d8d838fb59", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -65,13 +65,23 @@ class MemoryMappedSegment {\n   MemoryMappedSegmentData *data_;\n };\n \n-class MemoryMappingLayout {\n+class MemoryMappingLayoutBase {\n+ public:\n+  virtual bool Next(MemoryMappedSegment *segment) { UNIMPLEMENTED(); }\n+  virtual bool Error() const { UNIMPLEMENTED(); };\n+  virtual void Reset() { UNIMPLEMENTED(); }\n+\n+ protected:\n+  ~MemoryMappingLayoutBase() {}\n+};\n+\n+class MemoryMappingLayout final : public MemoryMappingLayoutBase {\n  public:\n   explicit MemoryMappingLayout(bool cache_enabled);\n   ~MemoryMappingLayout();\n-  bool Next(MemoryMappedSegment *segment);\n-  bool Error() const;\n-  void Reset();\n+  virtual bool Next(MemoryMappedSegment *segment) override;\n+  virtual bool Error() const override;\n+  virtual void Reset() override;\n   // In some cases, e.g. when running under a sandbox on Linux, ASan is unable\n   // to obtain the memory mappings. It should fall back to pre-cached data\n   // instead of aborting."}, {"sha": "37e9e6dd08d7b2bc3eba2582536ef98cde0228a3", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cpp", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -86,8 +86,8 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n@@ -110,21 +110,14 @@ void BufferedStackTrace::UnwindFast(uptr pc, uptr bp, uptr stack_top,\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n #ifdef __powerpc__\n-    // PowerPC ABIs specify that the return address is saved on the\n-    // *caller's* stack frame.  Thus we must dereference the back chain\n-    // to find the caller frame before extracting it.\n+    // PowerPC ABIs specify that the return address is saved at offset\n+    // 16 of the *caller's* stack frame.  Thus we must dereference the\n+    // back chain to find the caller frame before extracting it.\n     uhwptr *caller_frame = (uhwptr*)frame[0];\n     if (!IsValidFrame((uptr)caller_frame, stack_top, bottom) ||\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n-    // For most ABIs the offset where the return address is saved is two\n-    // register sizes.  The exception is the SVR4 ABI, which uses an\n-    // offset of only one register size.\n-#ifdef _CALL_SYSV\n-    uhwptr pc1 = caller_frame[1];\n-#else\n     uhwptr pc1 = caller_frame[2];\n-#endif\n #elif defined(__s390__)\n     uhwptr pc1 = frame[14];\n #elif defined(__riscv)"}, {"sha": "9a85ee00d2d71e82f853e44e6f725c8ee4997496", "filename": "libsanitizer/tsan/tsan_interceptors_posix.cpp", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_posix.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -2189,7 +2189,7 @@ void atfork_child() {\n     return;\n   ThreadState *thr = cur_thread();\n   const uptr pc = StackTrace::GetCurrentPc();\n-  ForkChildAfter(thr, pc);\n+  ForkChildAfter(thr, pc, true);\n   FdOnFork(thr, pc);\n }\n \n@@ -2210,6 +2210,37 @@ TSAN_INTERCEPTOR(int, vfork, int fake) {\n   return WRAP(fork)(fake);\n }\n \n+#if SANITIZER_LINUX\n+TSAN_INTERCEPTOR(int, clone, int (*fn)(void *), void *stack, int flags,\n+                 void *arg, int *parent_tid, void *tls, pid_t *child_tid) {\n+  SCOPED_INTERCEPTOR_RAW(clone, fn, stack, flags, arg, parent_tid, tls,\n+                         child_tid);\n+  struct Arg {\n+    int (*fn)(void *);\n+    void *arg;\n+  };\n+  auto wrapper = +[](void *p) -> int {\n+    auto *thr = cur_thread();\n+    uptr pc = GET_CURRENT_PC();\n+    // Start the background thread for fork, but not for clone.\n+    // For fork we did this always and it's known to work (or user code has\n+    // adopted). But if we do this for the new clone interceptor some code\n+    // (sandbox2) fails. So model we used to do for years and don't start the\n+    // background thread after clone.\n+    ForkChildAfter(thr, pc, false);\n+    FdOnFork(thr, pc);\n+    auto *arg = static_cast<Arg *>(p);\n+    return arg->fn(arg->arg);\n+  };\n+  ForkBefore(thr, pc);\n+  Arg arg_wrapper = {fn, arg};\n+  int pid = REAL(clone)(wrapper, stack, flags, &arg_wrapper, parent_tid, tls,\n+                        child_tid);\n+  ForkParentAfter(thr, pc);\n+  return pid;\n+}\n+#endif\n+\n #if !SANITIZER_MAC && !SANITIZER_ANDROID\n typedef int (*dl_iterate_phdr_cb_t)(__sanitizer_dl_phdr_info *info, SIZE_T size,\n                                     void *data);\n@@ -2544,7 +2575,7 @@ static void syscall_post_fork(uptr pc, int pid) {\n   ThreadState *thr = cur_thread();\n   if (pid == 0) {\n     // child\n-    ForkChildAfter(thr, pc);\n+    ForkChildAfter(thr, pc, true);\n     FdOnFork(thr, pc);\n   } else if (pid > 0) {\n     // parent\n@@ -2841,6 +2872,9 @@ void InitializeInterceptors() {\n \n   TSAN_INTERCEPT(fork);\n   TSAN_INTERCEPT(vfork);\n+#if SANITIZER_LINUX\n+  TSAN_INTERCEPT(clone);\n+#endif\n #if !SANITIZER_ANDROID\n   TSAN_INTERCEPT(dl_iterate_phdr);\n #endif"}, {"sha": "46dec04b8759ef7d3555149547faec1f8ed8cdba", "filename": "libsanitizer/tsan/tsan_rtl.cpp", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_rtl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -506,7 +506,8 @@ void ForkParentAfter(ThreadState *thr, uptr pc) NO_THREAD_SAFETY_ANALYSIS {\n   ctx->thread_registry.Unlock();\n }\n \n-void ForkChildAfter(ThreadState *thr, uptr pc) NO_THREAD_SAFETY_ANALYSIS {\n+void ForkChildAfter(ThreadState *thr, uptr pc,\n+                    bool start_thread) NO_THREAD_SAFETY_ANALYSIS {\n   thr->suppress_reports--;  // Enabled in ForkBefore.\n   thr->ignore_interceptors--;\n   ScopedErrorReportLock::Unlock();\n@@ -518,7 +519,8 @@ void ForkChildAfter(ThreadState *thr, uptr pc) NO_THREAD_SAFETY_ANALYSIS {\n   VPrintf(1, \"ThreadSanitizer: forked new process with pid %d,\"\n       \" parent had %d threads\\n\", (int)internal_getpid(), (int)nthread);\n   if (nthread == 1) {\n-    StartBackgroundThread();\n+    if (start_thread)\n+      StartBackgroundThread();\n   } else {\n     // We've just forked a multi-threaded process. We cannot reasonably function\n     // after that (some mutexes may be locked before fork). So just enable"}, {"sha": "eab83704240d8174d798ba4d48f67fd8dffd62dc", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -440,7 +440,7 @@ void InitializeDynamicAnnotations();\n \n void ForkBefore(ThreadState *thr, uptr pc);\n void ForkParentAfter(ThreadState *thr, uptr pc);\n-void ForkChildAfter(ThreadState *thr, uptr pc);\n+void ForkChildAfter(ThreadState *thr, uptr pc, bool start_thread);\n \n void ReportRace(ThreadState *thr);\n bool OutputReport(ThreadState *thr, const ScopedReport &srep);"}, {"sha": "632b19d18158028ce350ed0e4f7fdd03f5fa70bc", "filename": "libsanitizer/tsan/tsan_rtl_amd64.S", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -42,6 +42,25 @@ ASM_SYMBOL(__tsan_trace_switch_thunk):\n   push %r11\n   CFI_ADJUST_CFA_OFFSET(8)\n   CFI_REL_OFFSET(%r11, 0)\n+  # All XMM registers are caller-saved.\n+  sub $0x100, %rsp\n+  CFI_ADJUST_CFA_OFFSET(0x100)\n+  vmovdqu %xmm0, 0x0(%rsp)\n+  vmovdqu %xmm1, 0x10(%rsp)\n+  vmovdqu %xmm2, 0x20(%rsp)\n+  vmovdqu %xmm3, 0x30(%rsp)\n+  vmovdqu %xmm4, 0x40(%rsp)\n+  vmovdqu %xmm5, 0x50(%rsp)\n+  vmovdqu %xmm6, 0x60(%rsp)\n+  vmovdqu %xmm7, 0x70(%rsp)\n+  vmovdqu %xmm8, 0x80(%rsp)\n+  vmovdqu %xmm9, 0x90(%rsp)\n+  vmovdqu %xmm10, 0xa0(%rsp)\n+  vmovdqu %xmm11, 0xb0(%rsp)\n+  vmovdqu %xmm12, 0xc0(%rsp)\n+  vmovdqu %xmm13, 0xd0(%rsp)\n+  vmovdqu %xmm14, 0xe0(%rsp)\n+  vmovdqu %xmm15, 0xf0(%rsp)\n   # Align stack frame.\n   push %rbx  # non-scratch\n   CFI_ADJUST_CFA_OFFSET(8)\n@@ -59,6 +78,24 @@ ASM_SYMBOL(__tsan_trace_switch_thunk):\n   pop %rbx\n   CFI_ADJUST_CFA_OFFSET(-8)\n   # Restore scratch registers.\n+  vmovdqu 0x0(%rsp), %xmm0\n+  vmovdqu 0x10(%rsp), %xmm1\n+  vmovdqu 0x20(%rsp), %xmm2\n+  vmovdqu 0x30(%rsp), %xmm3\n+  vmovdqu 0x40(%rsp), %xmm4\n+  vmovdqu 0x50(%rsp), %xmm5\n+  vmovdqu 0x60(%rsp), %xmm6\n+  vmovdqu 0x70(%rsp), %xmm7\n+  vmovdqu 0x80(%rsp), %xmm8\n+  vmovdqu 0x90(%rsp), %xmm9\n+  vmovdqu 0xa0(%rsp), %xmm10\n+  vmovdqu 0xb0(%rsp), %xmm11\n+  vmovdqu 0xc0(%rsp), %xmm12\n+  vmovdqu 0xd0(%rsp), %xmm13\n+  vmovdqu 0xe0(%rsp), %xmm14\n+  vmovdqu 0xf0(%rsp), %xmm15\n+  add $0x100, %rsp\n+  CFI_ADJUST_CFA_OFFSET(-0x100)\n   pop %r11\n   CFI_ADJUST_CFA_OFFSET(-8)\n   pop %r10\n@@ -123,6 +160,25 @@ ASM_SYMBOL(__tsan_report_race_thunk):\n   push %r11\n   CFI_ADJUST_CFA_OFFSET(8)\n   CFI_REL_OFFSET(%r11, 0)\n+  # All XMM registers are caller-saved.\n+  sub $0x100, %rsp\n+  CFI_ADJUST_CFA_OFFSET(0x100)\n+  vmovdqu %xmm0, 0x0(%rsp)\n+  vmovdqu %xmm1, 0x10(%rsp)\n+  vmovdqu %xmm2, 0x20(%rsp)\n+  vmovdqu %xmm3, 0x30(%rsp)\n+  vmovdqu %xmm4, 0x40(%rsp)\n+  vmovdqu %xmm5, 0x50(%rsp)\n+  vmovdqu %xmm6, 0x60(%rsp)\n+  vmovdqu %xmm7, 0x70(%rsp)\n+  vmovdqu %xmm8, 0x80(%rsp)\n+  vmovdqu %xmm9, 0x90(%rsp)\n+  vmovdqu %xmm10, 0xa0(%rsp)\n+  vmovdqu %xmm11, 0xb0(%rsp)\n+  vmovdqu %xmm12, 0xc0(%rsp)\n+  vmovdqu %xmm13, 0xd0(%rsp)\n+  vmovdqu %xmm14, 0xe0(%rsp)\n+  vmovdqu %xmm15, 0xf0(%rsp)\n   # Align stack frame.\n   push %rbx  # non-scratch\n   CFI_ADJUST_CFA_OFFSET(8)\n@@ -140,6 +196,24 @@ ASM_SYMBOL(__tsan_report_race_thunk):\n   pop %rbx\n   CFI_ADJUST_CFA_OFFSET(-8)\n   # Restore scratch registers.\n+  vmovdqu 0x0(%rsp), %xmm0\n+  vmovdqu 0x10(%rsp), %xmm1\n+  vmovdqu 0x20(%rsp), %xmm2\n+  vmovdqu 0x30(%rsp), %xmm3\n+  vmovdqu 0x40(%rsp), %xmm4\n+  vmovdqu 0x50(%rsp), %xmm5\n+  vmovdqu 0x60(%rsp), %xmm6\n+  vmovdqu 0x70(%rsp), %xmm7\n+  vmovdqu 0x80(%rsp), %xmm8\n+  vmovdqu 0x90(%rsp), %xmm9\n+  vmovdqu 0xa0(%rsp), %xmm10\n+  vmovdqu 0xb0(%rsp), %xmm11\n+  vmovdqu 0xc0(%rsp), %xmm12\n+  vmovdqu 0xd0(%rsp), %xmm13\n+  vmovdqu 0xe0(%rsp), %xmm14\n+  vmovdqu 0xf0(%rsp), %xmm15\n+  add $0x100, %rsp\n+  CFI_ADJUST_CFA_OFFSET(-0x100)\n   pop %r11\n   CFI_ADJUST_CFA_OFFSET(-8)\n   pop %r10"}, {"sha": "8285e21aa1ec7a797dfcf4840ee5a7851106b497", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -1,6 +1,5 @@\n #include \"tsan_ppc_regs.h\"\n \n-        .machine altivec\n         .section .text\n         .hidden __tsan_setjmp\n         .globl _setjmp"}, {"sha": "25cefd46ce27ced7fb6092d8d04b5074c56ebe95", "filename": "libsanitizer/ubsan/ubsan_flags.cpp", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fubsan%2Fubsan_flags.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -50,7 +50,6 @@ void InitializeFlags() {\n   {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n-    cf.print_summary = false;\n     cf.external_symbolizer_path = GetFlag(\"UBSAN_SYMBOLIZER_PATH\");\n     OverrideCommonFlags(cf);\n   }"}, {"sha": "e201e6bba22078e3d873aeb5792b98ecd860cdaa", "filename": "libsanitizer/ubsan/ubsan_handlers.cpp", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fubsan%2Fubsan_handlers.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cpp?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -894,21 +894,6 @@ void __ubsan_handle_cfi_bad_type(CFICheckFailData *Data, ValueHandle Vtable,\n \n }  // namespace __ubsan\n \n-void __ubsan::__ubsan_handle_cfi_bad_icall(CFIBadIcallData *CallData,\n-                                           ValueHandle Function) {\n-  GET_REPORT_OPTIONS(false);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-}\n-\n-void __ubsan::__ubsan_handle_cfi_bad_icall_abort(CFIBadIcallData *CallData,\n-                                                 ValueHandle Function) {\n-  GET_REPORT_OPTIONS(true);\n-  CFICheckFailData Data = {CFITCK_ICall, CallData->Loc, CallData->Type};\n-  handleCFIBadIcall(&Data, Function, Opts);\n-  Die();\n-}\n-\n void __ubsan::__ubsan_handle_cfi_check_fail(CFICheckFailData *Data,\n                                             ValueHandle Value,\n                                             uptr ValidVtable) {"}, {"sha": "219fb15de55fe02a4544422095baa0d8532baaa0", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -215,20 +215,12 @@ enum CFITypeCheckKind : unsigned char {\n   CFITCK_VMFCall,\n };\n \n-struct CFIBadIcallData {\n-  SourceLocation Loc;\n-  const TypeDescriptor &Type;\n-};\n-\n struct CFICheckFailData {\n   CFITypeCheckKind CheckKind;\n   SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n-/// \\brief Handle control flow integrity failure for indirect function calls.\n-RECOVERABLE(cfi_bad_icall, CFIBadIcallData *Data, ValueHandle Function)\n-\n /// \\brief Handle control flow integrity failures.\n RECOVERABLE(cfi_check_fail, CFICheckFailData *Data, ValueHandle Function,\n             uptr VtableIsValid)"}, {"sha": "d2cc2e10bd2f023b8d9aa1685a79a192a6d1e1e8", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86289a4ff4768fab61f16372650fe85c37f9284e/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=86289a4ff4768fab61f16372650fe85c37f9284e", "patch": "@@ -12,7 +12,6 @@\n #ifndef UBSAN_PLATFORM_H\n #define UBSAN_PLATFORM_H\n \n-#ifndef CAN_SANITIZE_UB\n // Other platforms should be easy to add, and probably work as-is.\n #if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__) ||        \\\n     defined(__NetBSD__) || defined(__DragonFly__) ||                           \\\n@@ -22,6 +21,5 @@\n #else\n # define CAN_SANITIZE_UB 0\n #endif\n-#endif //CAN_SANITIZE_UB\n \n #endif"}]}