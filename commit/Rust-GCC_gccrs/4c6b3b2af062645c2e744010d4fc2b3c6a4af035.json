{"sha": "4c6b3b2af062645c2e744010d4fc2b3c6a4af035", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM2YjNiMmFmMDYyNjQ1YzJlNzQ0MDEwZDRmYzJiM2M2YTRhZjAzNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-07-18T08:54:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2000-07-18T08:54:33Z"}, "message": "calls.c (store_arg): Return non-zero if sibcall_failure is desired.\n\n\t* calls.c (store_arg): Return non-zero if sibcall_failure is\n\tdesired.\n\t(expand_call): Adjust caller.\n\t* gcc.c-torture/execute/20000717-5.c: New test.\n\t* gcc.c-torture/execute/20000717-1.x: Removed.\n\nFrom-SVN: r35117", "tree": {"sha": "ce199b5558bf3556d55470271b06cd8224c00987", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce199b5558bf3556d55470271b06cd8224c00987"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c6b3b2af062645c2e744010d4fc2b3c6a4af035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c6b3b2af062645c2e744010d4fc2b3c6a4af035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c6b3b2af062645c2e744010d4fc2b3c6a4af035", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c6b3b2af062645c2e744010d4fc2b3c6a4af035/comments", "author": null, "committer": null, "parents": [{"sha": "e81b4d6305ef9885149e87d374a909e8ff442edb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e81b4d6305ef9885149e87d374a909e8ff442edb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e81b4d6305ef9885149e87d374a909e8ff442edb"}], "stats": {"total": 116, "additions": 95, "deletions": 21}, "files": [{"sha": "b183280c9929e6cbaf570b58bc647a65e9c8deed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c6b3b2af062645c2e744010d4fc2b3c6a4af035/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c6b3b2af062645c2e744010d4fc2b3c6a4af035/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c6b3b2af062645c2e744010d4fc2b3c6a4af035", "patch": "@@ -1,3 +1,9 @@\n+2000-07-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* calls.c (store_arg): Return non-zero if sibcall_failure is\n+\tdesired.\n+\t(expand_call): Adjust caller.\n+\n 2000-07-17  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n         * diagnostic.h (report_diagnostic): Change prototype.\n@@ -14,7 +20,7 @@\n         * c-errors.c (pedwarn_c99): Adjust call to report_diagnostic. End\n         varaible argument list.\n \t\n-2000-02-17  Zack Weinberg  <zack@wolery.cumb.org>\n+2000-07-17  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpphash.c: Don't include hashtab.h.  Most macro-handling code\n \tmoved to cppmacro.c.\n@@ -41,7 +47,7 @@\n \n \t* cppmain.c: Do not set pfile->printer if no_output is on.\n \n-2000-02-15  Neil Booth  <neilb@earthling.net>\n+2000-07-15  Neil Booth  <neilb@earthling.net>\n \n \t* cpplib.c: Change all directive-handler functions to return\n \tvoid, not int."}, {"sha": "8c5b9bcd29c902e49af6a9da2bf2b52c84956a22", "filename": "gcc/calls.c", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c6b3b2af062645c2e744010d4fc2b3c6a4af035/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c6b3b2af062645c2e744010d4fc2b3c6a4af035/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4c6b3b2af062645c2e744010d4fc2b3c6a4af035", "patch": "@@ -191,7 +191,7 @@ static void emit_call_1\t\tPARAMS ((rtx, tree, tree, HOST_WIDE_INT,\n static void precompute_register_parameters\tPARAMS ((int,\n \t\t\t\t\t\t\t struct arg_data *,\n \t\t\t\t\t\t\t int *));\n-static void store_one_arg\tPARAMS ((struct arg_data *, rtx, int, int,\n+static int store_one_arg\tPARAMS ((struct arg_data *, rtx, int, int,\n \t\t\t\t\t int));\n static void store_unaligned_arguments_into_pseudos PARAMS ((struct arg_data *,\n \t\t\t\t\t\t\t    int));\n@@ -1952,10 +1952,10 @@ check_sibcall_argument_overlap_1 (x)\n     {\n       if (XEXP (x, 0) == current_function_internal_arg_pointer)\n \ti = 0;\n-      else if (GET_CODE (XEXP (x, 0)) == PLUS &&\n-\t       XEXP (XEXP (x, 0), 0) ==\n-\t\t current_function_internal_arg_pointer &&\n-\t       GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n+      else if (GET_CODE (XEXP (x, 0)) == PLUS\n+\t       && XEXP (XEXP (x, 0), 0) ==\n+\t\t  current_function_internal_arg_pointer\n+\t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n \ti = INTVAL (XEXP (XEXP (x, 0), 1));\n       else\n \treturn 0;\n@@ -2947,10 +2947,12 @@ expand_call (exp, target, ignore)\n \t  {\n \t    rtx before_arg = get_last_insn ();\n \n-\t    store_one_arg (&args[i], argblock, flags,\n-\t\t\t   adjusted_args_size.var != 0, reg_parm_stack_space);\n-\t    if (pass == 0 &&\n-\t\tcheck_sibcall_argument_overlap (before_arg, &args[i]))\n+\t    if (store_one_arg (&args[i], argblock, flags,\n+\t\t\t       adjusted_args_size.var != 0,\n+\t\t\t       reg_parm_stack_space)\n+\t\t|| (pass == 0\n+\t\t    && check_sibcall_argument_overlap (before_arg,\n+\t\t\t\t\t\t       &args[i])))\n \t      sibcall_failure = 1;\n \t  }\n \n@@ -2969,10 +2971,12 @@ expand_call (exp, target, ignore)\n \t    {\n \t      rtx before_arg = get_last_insn ();\n \n-\t      store_one_arg (&args[i], argblock, flags,\n-\t\t\t     adjusted_args_size.var != 0, reg_parm_stack_space);\n-\t      if (pass == 0 &&\n-\t\t  check_sibcall_argument_overlap (before_arg, &args[i]))\n+\t      if (store_one_arg (&args[i], argblock, flags,\n+\t\t\t\t adjusted_args_size.var != 0,\n+\t\t\t\t reg_parm_stack_space)\n+\t\t  || (pass == 0\n+\t\t      && check_sibcall_argument_overlap (before_arg,\n+\t\t\t\t\t\t\t &args[i])))\n \t\tsibcall_failure = 1;\n \t    }\n \n@@ -4218,9 +4222,12 @@ target_for_arg (type, size, args_addr, offset)\n    argument stack.  This is used if ACCUMULATE_OUTGOING_ARGS to indicate\n    that we need not worry about saving and restoring the stack.\n \n-   FNDECL is the declaration of the function we are calling.  */\n+   FNDECL is the declaration of the function we are calling.\n+   \n+   Return non-zero if this arg should cause sibcall failure,\n+   zero otherwise.  */\n \n-static void\n+static int\n store_one_arg (arg, argblock, flags, variable_size,\n \t       reg_parm_stack_space)\n      struct arg_data *arg;\n@@ -4234,9 +4241,10 @@ store_one_arg (arg, argblock, flags, variable_size,\n   int partial = 0;\n   int used = 0;\n   int i, lower_bound = 0, upper_bound = 0;\n+  int sibcall_failure = 0;\n \n   if (TREE_CODE (pval) == ERROR_MARK)\n-    return;\n+    return 1;\n \n   /* Push a new temporary level for any temporaries we make for\n      this argument.  */\n@@ -4451,6 +4459,39 @@ store_one_arg (arg, argblock, flags, variable_size,\n \t  size_rtx = expr_size (pval);\n \t}\n \n+      if ((flags & ECF_SIBCALL) && GET_CODE (arg->value) == MEM)\n+\t{\n+\t  /* emit_push_insn might not work properly if arg->value and\n+\t     argblock + arg->offset areas overlap.  */\n+\t  rtx x = arg->value;\n+\t  int i = 0;\n+\n+\t  if (XEXP (x, 0) == current_function_internal_arg_pointer\n+\t      || (GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t  && XEXP (XEXP (x, 0), 0) ==\n+\t\t     current_function_internal_arg_pointer\n+\t\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT))\n+\t    {\n+\t      if (XEXP (x, 0) != current_function_internal_arg_pointer)\n+\t\ti = INTVAL (XEXP (XEXP (x, 0), 1));\n+\n+\t      /* expand_call should ensure this */\n+\t      if (arg->offset.var || GET_CODE (size_rtx) != CONST_INT)\n+\t\tabort ();\n+\n+\t      if (arg->offset.constant > i)\n+\t\t{\n+\t\t  if (arg->offset.constant < i + INTVAL (size_rtx))\n+\t\t    sibcall_failure = 1;\n+\t\t}\n+\t      else if (arg->offset.constant < i)\n+\t\t{\n+\t\t  if (i < arg->offset.constant + INTVAL (size_rtx))\n+\t\t    sibcall_failure = 1;\n+\t\t}\n+\t    }\n+\t}\n+\n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,\n \t\t      TYPE_ALIGN (TREE_TYPE (pval)), partial, reg, excess,\n \t\t      argblock, ARGS_SIZE_RTX (arg->offset),\n@@ -4482,4 +4523,6 @@ store_one_arg (arg, argblock, flags, variable_size,\n   preserve_temp_slots (NULL_RTX);\n   free_temp_slots ();\n   pop_temp_slots ();\n+\n+  return sibcall_failure;\n }"}, {"sha": "42c8a64f059b81ac49d3c670c95a389bba33b8b0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c6b3b2af062645c2e744010d4fc2b3c6a4af035/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c6b3b2af062645c2e744010d4fc2b3c6a4af035/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4c6b3b2af062645c2e744010d4fc2b3c6a4af035", "patch": "@@ -1,3 +1,8 @@\n+2000-07-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.c-torture/execute/20000717-5.c: New test.\n+\t* gcc.c-torture/execute/20000717-1.x: Removed.\n+\n 2000-07-17  Richard Henderson  <rth@cygnus.com>\n \n \t* gcc.c-torture/execute/20000717-4.c: New test."}, {"sha": "1005ae6c8504557b798c5e221ea8eced8aa97cb2", "filename": "gcc/testsuite/gcc.c-torture/execute/20000717-1.x", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81b4d6305ef9885149e87d374a909e8ff442edb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000717-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81b4d6305ef9885149e87d374a909e8ff442edb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000717-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000717-1.x?ref=e81b4d6305ef9885149e87d374a909e8ff442edb", "patch": "@@ -1,3 +0,0 @@\n-set torture_execute_xfail \"*-*-*\"\n-\n-return 0"}, {"sha": "49dcbbc66f1760bfa73ab1dc03110417ee574b53", "filename": "gcc/testsuite/gcc.c-torture/execute/20000717-5.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c6b3b2af062645c2e744010d4fc2b3c6a4af035/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000717-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c6b3b2af062645c2e744010d4fc2b3c6a4af035/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000717-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20000717-5.c?ref=4c6b3b2af062645c2e744010d4fc2b3c6a4af035", "patch": "@@ -0,0 +1,23 @@\n+typedef struct trio { int a, b, c; } trio;\n+\n+int\n+bar (int i, int j, int k, trio t)\n+{\n+  if (t.a != 1 || t.b != 2 || t.c != 3 ||\n+      i != 4 || j != 5 || k != 6)\n+    abort ();\n+}\n+\n+int\n+foo (trio t, int i, int j, int k)\n+{\n+  return bar (i, j, k, t);\n+}\n+\n+main ()\n+{\n+  trio t = { 1, 2, 3 };\n+\n+  foo (t, 4, 5, 6);\n+  exit (0);\n+}"}]}