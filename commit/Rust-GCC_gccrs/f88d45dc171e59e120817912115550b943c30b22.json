{"sha": "f88d45dc171e59e120817912115550b943c30b22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg4ZDQ1ZGMxNzFlNTllMTIwODE3OTEyMTE1NTUwYjk0M2MzMGIyMg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-02-22T13:33:31Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2016-02-22T13:33:31Z"}, "message": "re PR rtl-optimization/69806 ([SH] Combine doesn't see constant)\n\ngcc/\n\tPR target/69806\n\tPR target/54089\n\t* config/sh/sh.c (sh_lshrsi_clobbers_t_reg_p, sh_dynamicalize_shift_p):\n\tHandle negative shift counts.\n\t* config/sh/sh.md (ashlsi3, lshrsi3_n, lshrsi3_n_clobbers_t): Don't use\n\tforce_reg on the shift constant.\n\t(lshrsi3): Likewise.  Expand into lshrsi3_n* instead of lshrsi3_d.\n\t(lshrsi3_d): Handle negative shift counts.\n\ngcc/testsuite/\n\tPR target/69806\n\tPR target/54089\n\t* gcc.target/sh/pr54089-10.c: New.\n\nFrom-SVN: r233601", "tree": {"sha": "edb2f6b914dc2e288c537e24bcb365233f139a86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edb2f6b914dc2e288c537e24bcb365233f139a86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f88d45dc171e59e120817912115550b943c30b22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88d45dc171e59e120817912115550b943c30b22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f88d45dc171e59e120817912115550b943c30b22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88d45dc171e59e120817912115550b943c30b22/comments", "author": null, "committer": null, "parents": [{"sha": "bddb7adb4411ec4c9653e61accb3db25e3b2c405", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bddb7adb4411ec4c9653e61accb3db25e3b2c405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bddb7adb4411ec4c9653e61accb3db25e3b2c405"}], "stats": {"total": 200, "additions": 190, "deletions": 10}, "files": [{"sha": "14e3adb4b7921074b3262cf85f6cade26113b0a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88d45dc171e59e120817912115550b943c30b22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88d45dc171e59e120817912115550b943c30b22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f88d45dc171e59e120817912115550b943c30b22", "patch": "@@ -1,3 +1,14 @@\n+2016-02-22  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/69806\n+\tPR target/54089\n+\t* config/sh/sh.c (sh_lshrsi_clobbers_t_reg_p, sh_dynamicalize_shift_p):\n+\tHandle negative shift counts.\n+\t* config/sh/sh.md (ashlsi3, lshrsi3_n, lshrsi3_n_clobbers_t): Don't use\n+\tforce_reg on the shift constant.\n+\t(lshrsi3): Likewise.  Expand into lshrsi3_n* instead of lshrsi3_d.\n+\t(lshrsi3_d): Handle negative shift counts.\n+\n 2016-02-22  Richard Biener  <rguenther@suse.de>\n \t    Tom de Vries  <tom@codesourcery.com>\n "}, {"sha": "8c8fe3c671564337a7c23da2aa81f5e400253ddd", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88d45dc171e59e120817912115550b943c30b22/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88d45dc171e59e120817912115550b943c30b22/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=f88d45dc171e59e120817912115550b943c30b22", "patch": "@@ -3259,7 +3259,8 @@ sh_lshrsi_clobbers_t_reg_p (rtx shift_amount)\n {\n   gcc_assert (CONST_INT_P (shift_amount));\n \n-  const int shift_amount_i = INTVAL (shift_amount) & 31;\n+  /* For right shifts the constant might be negative.  */\n+  const int shift_amount_i = std::abs (INTVAL (shift_amount)) & 31;\n  \n   /* Special case for shift count of 31: use shll-movt sequence.  */\n   if (shift_amount_i == 31)\n@@ -3278,7 +3279,8 @@ sh_dynamicalize_shift_p (rtx count)\n {\n   gcc_assert (CONST_INT_P (count));\n \n-  const int shift_amount_i = INTVAL (count) & 31;\n+  /* For right shifts the constant might be negative.  */\n+  const int shift_amount_i = std::abs (INTVAL (count)) & 31;\n   int insn_count;\n \n   /* For left and right shifts, there are shorter 2 insn sequences for"}, {"sha": "c0a9249c68d87d5371d6fcca27d2c55256c2f681", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88d45dc171e59e120817912115550b943c30b22/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88d45dc171e59e120817912115550b943c30b22/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=f88d45dc171e59e120817912115550b943c30b22", "patch": "@@ -5011,7 +5011,10 @@ label:\n     }\n   if (TARGET_DYNSHIFT\n       && CONST_INT_P (operands[2]) && sh_dynamicalize_shift_p (operands[2]))\n-      operands[2] = force_reg (SImode, operands[2]);\n+    {\n+      /* Don't force the constant into a reg yet.  Some other optimizations\n+\t might not see through the reg that holds the shift count.  */\n+    }\n \n   /*  If the ashlsi3_* insn is going to clobber the T_REG it must be\n       expanded here.  */\n@@ -5567,9 +5570,12 @@ label:\n   if (TARGET_DYNSHIFT\n       && CONST_INT_P (operands[2]) && sh_dynamicalize_shift_p (operands[2]))\n     {\n-      rtx neg_count = force_reg (SImode,\n-\t\t\t         gen_int_mode (- INTVAL (operands[2]), SImode));\n-      emit_insn (gen_lshrsi3_d (operands[0], operands[1], neg_count));\n+      /* Don't force the constant into a reg yet.  Some other optimizations\n+\t might not see through the reg that holds the shift count.  */\n+      if (sh_lshrsi_clobbers_t_reg_p (operands[2]))\n+        emit_insn (gen_lshrsi3_n_clobbers_t (operands[0], operands[1], operands[2]));\n+      else\n+        emit_insn (gen_lshrsi3_n (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n \n@@ -5621,6 +5627,10 @@ label:\n    && ! sh_lshrsi_clobbers_t_reg_p (operands[2])\"\n   [(const_int 0)]\n {\n+  /* The shift count const_int is a negative value for all dynamic\n+     right shift insns.  */\n+  operands[2] = GEN_INT (- INTVAL (operands[2]));\n+\n   if (satisfies_constraint_P27 (operands[2]))\n     {\n       /* This will not be done for a shift amount of 1, because it would\n@@ -5679,8 +5689,7 @@ label:\n     {\n       /* If this pattern was picked and dynamic shifts are supported, switch\n \t to dynamic shift pattern before reload.  */\n-      operands[2] = force_reg (SImode,\n-\t\t\t       gen_int_mode (- INTVAL (operands[2]), SImode));\n+      operands[2] = GEN_INT (- INTVAL (operands[2]));\n       emit_insn (gen_lshrsi3_d (operands[0], operands[1], operands[2]));\n     }\n   else\n@@ -5711,8 +5720,7 @@ label:\n     {\n       /* If this pattern was picked and dynamic shifts are supported, switch\n \t to dynamic shift pattern before reload.  */\n-      operands[2] = force_reg (SImode,\n-\t\t\t       gen_int_mode (- INTVAL (operands[2]), SImode));\n+      operands[2] = GEN_INT (- INTVAL (operands[2]));\n       emit_insn (gen_lshrsi3_d (operands[0], operands[1], operands[2]));\n     }\n   else"}, {"sha": "927af63cde2303b99352332f0700cd0bb5560bfc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88d45dc171e59e120817912115550b943c30b22/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88d45dc171e59e120817912115550b943c30b22/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f88d45dc171e59e120817912115550b943c30b22", "patch": "@@ -1,3 +1,9 @@\n+2016-02-22  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/69806\n+\tPR target/54089\n+\t* gcc.target/sh/pr54089-10.c: New.\n+\n 2016-02-20  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/69423"}, {"sha": "85aeabd122c6d2f6b763db76d074ed0689ca2ded", "filename": "gcc/testsuite/gcc.target/sh/pr54089-10.c", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f88d45dc171e59e120817912115550b943c30b22/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f88d45dc171e59e120817912115550b943c30b22/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-10.c?ref=f88d45dc171e59e120817912115550b943c30b22", "patch": "@@ -0,0 +1,153 @@\n+/* Check that there are no redundant zero extensions around logical right\n+   shifts.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O1\" }  */\n+/* { dg-final { scan-assembler-times \"extu\" 20 } }  */\n+\n+/* { dg-final { scan-assembler-times \"shll\" 2 { target { \"! sh2a\" && has_dyn_shift } } } }  */\n+/* { dg-final { scan-assembler-times \"shll\" 3 { target { \"! sh2a\" && \"! has_dyn_shift\" } } } }  */\n+/* { dg-final { scan-assembler-times \"movt\" 2 { target { ! sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"bld\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"movt\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"movrt\" 1 { target { sh2a } } } }  */\n+/* { dg-final { scan-assembler-times \"cmp/pz\" 1 { target { sh2a } } } }  */\n+\n+/* { dg-final { scan-assembler-times \"shld\" 9 { target { has_dyn_shift } } } }  */\n+\n+void\n+test_0 (unsigned char* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 1;\n+}\n+\n+void\n+test_1 (unsigned char* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 2;\n+}\n+\n+void\n+test_2 (unsigned char* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 3;\n+}\n+\n+void\n+test_3 (unsigned char* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 4;\n+}\n+\n+void\n+test_4 (unsigned char* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 5;\n+}\n+\n+void\n+test_5 (unsigned char* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 6;\n+}\n+\n+void\n+test_6 (unsigned char* x, unsigned int* y)\n+{\n+  /* non-SH2A: shll, movt\n+     SH2A: bld, movt */\n+  y[0] = x[1] >> 7;\n+}\n+\n+\n+void\n+test_100 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 1;\n+}\n+\n+void\n+test_101 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 2;\n+}\n+\n+void\n+test_102 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 3;\n+}\n+\n+void\n+test_103 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 4;\n+}\n+\n+void\n+test_104 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 5;\n+}\n+\n+void\n+test_105 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 6;\n+}\n+\n+void\n+test_106 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 7;\n+}\n+\n+void\n+test_107 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 8;\n+}\n+\n+void\n+test_108 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 9;\n+}\n+\n+void\n+test_109 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 10;\n+}\n+\n+void\n+test_110 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 11;\n+}\n+\n+void\n+test_111 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 12;\n+}\n+\n+void\n+test_112 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 13;\n+}\n+\n+void\n+test_113 (unsigned short* x, unsigned int* y)\n+{\n+  y[0] = x[1] >> 14;\n+}\n+\n+void\n+test_114 (unsigned short* x, unsigned int* y)\n+{\n+  /* non-SH2A: shll, movt\n+     SH2A: cmp/pz, movrt */\n+  y[0] = x[1] >> 15;\n+}"}]}