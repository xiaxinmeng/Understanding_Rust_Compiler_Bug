{"sha": "1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkwNmQ2YjRkYzRjZjZiZGRiODJlOWRjMzUzNDQzODIzMDAzMGE4ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-11-03T19:52:58Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-11-03T19:52:58Z"}, "message": "Use type_hash_eq langhook in check_qualified_type.\n\ngcc/\n\t* tree.c (check_lang_type): New.\n\t(check_qualified_type): Use it.\n\t(check_aligned_type): Use it.\n\t* tree.h: Declare it.\ngcc/cp/\n\t* tree.c (cp_check_qualified_type): Call check_base_type instead\n\tof check_qualified_type.\n\t(cxx_type_hash_eq): Check ref-qualifiers.\n\t* typeck.c (apply_memfn_quals): No need to mess with TYPE_CANONICAL.\n\nFrom-SVN: r241831", "tree": {"sha": "bba16b05930156885aa3e5b7fb63e4b7cfd29e1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bba16b05930156885aa3e5b7fb63e4b7cfd29e1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b302001e3a04e8d2911989816c8907bf3e5c2389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b302001e3a04e8d2911989816c8907bf3e5c2389", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b302001e3a04e8d2911989816c8907bf3e5c2389"}], "stats": {"total": 58, "additions": 44, "deletions": 14}, "files": [{"sha": "dbbdba725eea266b9946006e5c1e0912a37a649e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "patch": "@@ -1,3 +1,10 @@\n+2016-11-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree.c (check_lang_type): New.\n+\t(check_qualified_type): Use it.\n+\t(check_aligned_type): Use it.\n+\t* tree.h: Declare it.\n+\n 2016-11-03  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config.gcc (arm-wrs-vxworks): Set target_cpu_cname."}, {"sha": "c60c81de1f2290451f045bae7b67628cd44ce153", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "patch": "@@ -1,3 +1,10 @@\n+2016-11-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree.c (cp_check_qualified_type): Call check_base_type instead\n+\tof check_qualified_type.\n+\t(cxx_type_hash_eq): Check ref-qualifiers.\n+\t* typeck.c (apply_memfn_quals): No need to mess with TYPE_CANONICAL.\n+\n 2016-11-01  Jason Merrill  <jason@redhat.com>\n \n \tImplement P0136R1, Rewording inheriting constructors."}, {"sha": "4dc6e226851712a624fbabaabc5a7839b06a60fe", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "patch": "@@ -1980,7 +1980,8 @@ static bool\n cp_check_qualified_type (const_tree cand, const_tree base, int type_quals,\n \t\t\t cp_ref_qualifier rqual, tree raises)\n {\n-  return (check_qualified_type (cand, base, type_quals)\n+  return (TYPE_QUALS (cand) == type_quals\n+\t  && check_base_type (cand, base)\n \t  && comp_except_specs (raises, TYPE_RAISES_EXCEPTIONS (cand),\n \t\t\t\tce_exact)\n \t  && type_memfn_rqual (cand) == rqual);\n@@ -4080,16 +4081,16 @@ cp_build_type_attribute_variant (tree type, tree attributes)\n }\n \n /* Return TRUE if TYPE1 and TYPE2 are identical for type hashing purposes.\n-   Called only after doing all language independent checks.  Only\n-   to check TYPE_RAISES_EXCEPTIONS for FUNCTION_TYPE, the rest is already\n-   compared in type_hash_eq.  */\n+   Called only after doing all language independent checks.  */\n \n bool\n cxx_type_hash_eq (const_tree typea, const_tree typeb)\n {\n   gcc_assert (TREE_CODE (typea) == FUNCTION_TYPE\n \t      || TREE_CODE (typea) == METHOD_TYPE);\n \n+  if (type_memfn_rqual (typea) != type_memfn_rqual (typeb))\n+    return false;\n   return comp_except_specs (TYPE_RAISES_EXCEPTIONS (typea),\n \t\t\t    TYPE_RAISES_EXCEPTIONS (typeb), ce_exact);\n }"}, {"sha": "45b7d264088f552d0904e21e03dce8b5e79400ae", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "patch": "@@ -9227,13 +9227,6 @@ apply_memfn_quals (tree type, cp_cv_quals memfn_quals, cp_ref_qualifier rqual)\n   /* This should really have a different TYPE_MAIN_VARIANT, but that gets\n      complex.  */\n   tree result = build_qualified_type (type, memfn_quals);\n-  if (tree canon = TYPE_CANONICAL (result))\n-    if (canon != result)\n-      /* check_qualified_type doesn't check the ref-qualifier, so make sure\n-\t TYPE_CANONICAL is correct.  */\n-      TYPE_CANONICAL (result)\n-\t= build_ref_qualified_type (canon, type_memfn_rqual (result));\n-  result = build_exception_variant (result, TYPE_RAISES_EXCEPTIONS (type));\n   return build_ref_qualified_type (result, rqual);\n }\n "}, {"sha": "6cd01a736e57c1d0b9acd2d0bb8e345c308881ee", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "patch": "@@ -120,7 +120,7 @@ struct lang_hooks_for_types\n   /* Return TRUE if TYPE1 and TYPE2 are identical for type hashing purposes.\n      Called only after doing all language independent checks.\n      At present, this function is only called when both TYPE1 and TYPE2 are\n-     FUNCTION_TYPEs.  */\n+     FUNCTION_TYPE or METHOD_TYPE.  */\n   bool (*type_hash_eq) (const_tree, const_tree);\n \n   /* Return TRUE if TYPE uses a hidden descriptor and fills in information"}, {"sha": "434aff1c4eea24b586b9cc6c08fb007c113690b5", "filename": "gcc/tree.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "patch": "@@ -6497,6 +6497,21 @@ set_type_quals (tree type, int type_quals)\n   TYPE_ADDR_SPACE (type) = DECODE_QUAL_ADDR_SPACE (type_quals);\n }\n \n+/* Returns true iff CAND and BASE have equivalent language-specific\n+   qualifiers.  */\n+\n+bool\n+check_lang_type (const_tree cand, const_tree base)\n+{\n+  if (lang_hooks.types.type_hash_eq == NULL)\n+    return true;\n+  /* type_hash_eq currently only applies to these types.  */\n+  if (TREE_CODE (cand) != FUNCTION_TYPE\n+      && TREE_CODE (cand) != METHOD_TYPE)\n+    return true;\n+  return lang_hooks.types.type_hash_eq (cand, base);\n+}\n+\n /* Returns true iff unqualified CAND and BASE are equivalent.  */\n \n bool\n@@ -6517,7 +6532,8 @@ bool\n check_qualified_type (const_tree cand, const_tree base, int type_quals)\n {\n   return (TYPE_QUALS (cand) == type_quals\n-\t  && check_base_type (cand, base));\n+\t  && check_base_type (cand, base)\n+\t  && check_lang_type (cand, base));\n }\n \n /* Returns true iff CAND is equivalent to BASE with ALIGN.  */\n@@ -6532,7 +6548,8 @@ check_aligned_type (const_tree cand, const_tree base, unsigned int align)\n \t  /* Check alignment.  */\n \t  && TYPE_ALIGN (cand) == align\n \t  && attribute_list_equal (TYPE_ATTRIBUTES (cand),\n-\t\t\t\t   TYPE_ATTRIBUTES (base)));\n+\t\t\t\t   TYPE_ATTRIBUTES (base))\n+\t  && check_lang_type (cand, base));\n }\n \n /* This function checks to see if TYPE matches the size one of the built-in "}, {"sha": "6a98b6ee0b6820b389bcd929a1fbf0c6e38f5d62", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1906d6b4dc4cf6bddb82e9dc3534438230030a8e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1906d6b4dc4cf6bddb82e9dc3534438230030a8e", "patch": "@@ -4214,6 +4214,11 @@ extern tree merge_dllimport_decl_attributes (tree, tree);\n /* Handle a \"dllimport\" or \"dllexport\" attribute.  */\n extern tree handle_dll_attribute (tree *, tree, tree, int, bool *);\n \n+/* Returns true iff CAND and BASE have equivalent language-specific\n+   qualifiers.  */\n+\n+extern bool check_lang_type (const_tree cand, const_tree base);\n+\n /* Returns true iff unqualified CAND and BASE are equivalent.  */\n \n extern bool check_base_type (const_tree cand, const_tree base);"}]}