{"sha": "01c196ea91cce2665bc7e8df7edfd7dca0352d86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFjMTk2ZWE5MWNjZTI2NjViYzdlOGRmN2VkZmQ3ZGNhMDM1MmQ4Ng==", "commit": {"author": {"name": "Tom de Vries", "email": "vries@codesourcery.com", "date": "2012-06-20T00:57:23Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2012-06-20T00:57:23Z"}, "message": "2012-06-19  Tom de Vries  <vries@codesourcery.com>\n\t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n\n\t* config/mips/mips.c (mips_emit_pre_atomic_barrier_p,)\n\t(mips_emit_post_atomic_barrier_p): New static functions.\n\t(mips_process_sync_loop): Use them.  Emit sync memory barriers in\n\taccordance with memory model semantics.  Add return of CMP result for\n\tcompare_and_swap.\n\t* config/mips/mips.md: Update comment.\n\t(sync_cmp): New attribute.\n\t(sync_memmodel): New attribute replacing sync_release_barrier.\n\t* config/mips/sync.md (UNSPEC_ATOMIC_COMPARE_AND_SWAP,)\n\t(UNSPEC_ATOMIC_EXCHANGE, UNSPEC_ATOMIC_FETCH_OP): New constants.\n\t(sync_lock_test_and_set, test_and_set_12): Update.\n\t(atomic_compare_and_swap, atomic_exchange, atomic_exchange_llsc,)\n\t(atomic_fetch_add, atomic_fetch_add_llsc): New patterns.\n\nCo-Authored-By: Maxim Kuvyrkov <maxim@codesourcery.com>\n\nFrom-SVN: r188803", "tree": {"sha": "cc80416977299664a93d282bbcace60a7d765062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc80416977299664a93d282bbcace60a7d765062"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01c196ea91cce2665bc7e8df7edfd7dca0352d86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c196ea91cce2665bc7e8df7edfd7dca0352d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01c196ea91cce2665bc7e8df7edfd7dca0352d86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c196ea91cce2665bc7e8df7edfd7dca0352d86/comments", "author": null, "committer": null, "parents": [{"sha": "e98f6824d6ce199d5a3a2d27800ac523d5135cea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e98f6824d6ce199d5a3a2d27800ac523d5135cea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e98f6824d6ce199d5a3a2d27800ac523d5135cea"}], "stats": {"total": 208, "additions": 199, "deletions": 9}, "files": [{"sha": "069b61c9535b5ab44e4a642e5df697586617aa45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c196ea91cce2665bc7e8df7edfd7dca0352d86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c196ea91cce2665bc7e8df7edfd7dca0352d86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01c196ea91cce2665bc7e8df7edfd7dca0352d86", "patch": "@@ -1,3 +1,20 @@\n+2012-06-19  Tom de Vries  <vries@codesourcery.com>\n+\t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* config/mips/mips.c (mips_emit_pre_atomic_barrier_p,)\n+\t(mips_emit_post_atomic_barrier_p): New static functions.\n+\t(mips_process_sync_loop): Use them.  Emit sync memory barriers in\n+\taccordance with memory model semantics.  Add return of CMP result for\n+\tcompare_and_swap.\n+\t* config/mips/mips.md: Update comment.\n+\t(sync_cmp): New attribute.\n+\t(sync_memmodel): New attribute replacing sync_release_barrier.\n+\t* config/mips/sync.md (UNSPEC_ATOMIC_COMPARE_AND_SWAP,)\n+\t(UNSPEC_ATOMIC_EXCHANGE, UNSPEC_ATOMIC_FETCH_OP): New constants.\n+\t(sync_lock_test_and_set, test_and_set_12): Update.\n+\t(atomic_compare_and_swap, atomic_exchange, atomic_exchange_llsc,)\n+\t(atomic_fetch_add, atomic_fetch_add_llsc): New patterns.\n+\n 2012-06-19  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/rs6000/spe.md (*mov_si<mode>_e500_subreg0): Rename to"}, {"sha": "f37c19499d7ff2f442b9b9502970b7ed255a87d2", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 67, "deletions": 4, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c196ea91cce2665bc7e8df7edfd7dca0352d86/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c196ea91cce2665bc7e8df7edfd7dca0352d86/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=01c196ea91cce2665bc7e8df7edfd7dca0352d86", "patch": "@@ -11976,6 +11976,45 @@ mips_sync_insn2_template (enum attr_sync_insn2 type)\n   gcc_unreachable ();\n }\n \n+/* Subroutines of the mips_process_sync_loop.\n+   Emit barriers as needed for the memory MODEL.  */\n+\n+static bool\n+mips_emit_pre_atomic_barrier_p (enum memmodel model)\n+{\n+  switch (model)\n+    {\n+    case MEMMODEL_RELAXED:\n+    case MEMMODEL_CONSUME:\n+    case MEMMODEL_ACQUIRE:\n+      return false;\n+    case MEMMODEL_RELEASE:\n+    case MEMMODEL_ACQ_REL:\n+    case MEMMODEL_SEQ_CST:\n+      return true;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+static bool\n+mips_emit_post_atomic_barrier_p (enum memmodel model)\n+{\n+  switch (model)\n+    {\n+    case MEMMODEL_RELAXED:\n+    case MEMMODEL_CONSUME:\n+    case MEMMODEL_RELEASE:\n+      return false;\n+    case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_ACQ_REL:\n+    case MEMMODEL_SEQ_CST:\n+      return true;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* OPERANDS are the operands to a sync loop instruction and INDEX is\n    the value of the one of the sync_* attributes.  Return the operand\n    referred to by the attribute, or DEFAULT_VALUE if the insn doesn't\n@@ -11996,11 +12035,13 @@ static void\n mips_process_sync_loop (rtx insn, rtx *operands)\n {\n   rtx at, mem, oldval, newval, inclusive_mask, exclusive_mask;\n-  rtx required_oldval, insn1_op2, tmp1, tmp2, tmp3;\n+  rtx required_oldval, insn1_op2, tmp1, tmp2, tmp3, cmp;\n   unsigned int tmp3_insn;\n   enum attr_sync_insn1 insn1;\n   enum attr_sync_insn2 insn2;\n   bool is_64bit_p;\n+  int memmodel_attr;\n+  enum memmodel model;\n \n   /* Read an operand from the sync_WHAT attribute and store it in\n      variable WHAT.  DEFAULT is the default value if no attribute\n@@ -12017,6 +12058,7 @@ mips_process_sync_loop (rtx insn, rtx *operands)\n   /* Read the other attributes.  */\n   at = gen_rtx_REG (GET_MODE (mem), AT_REGNUM);\n   READ_OPERAND (oldval, at);\n+  READ_OPERAND (cmp, 0);\n   READ_OPERAND (newval, at);\n   READ_OPERAND (inclusive_mask, 0);\n   READ_OPERAND (exclusive_mask, 0);\n@@ -12025,10 +12067,23 @@ mips_process_sync_loop (rtx insn, rtx *operands)\n   insn1 = get_attr_sync_insn1 (insn);\n   insn2 = get_attr_sync_insn2 (insn);\n \n+  memmodel_attr = get_attr_sync_memmodel (insn);\n+  switch (memmodel_attr)\n+    {\n+    case 10:\n+      model = MEMMODEL_ACQ_REL;\n+      break;\n+    case 11:\n+      model = MEMMODEL_ACQUIRE;\n+      break;\n+    default:\n+      model = INTVAL (operands[memmodel_attr]);\n+    }\n+\n   mips_multi_start ();\n \n   /* Output the release side of the memory barrier.  */\n-  if (get_attr_sync_release_barrier (insn) == SYNC_RELEASE_BARRIER_YES)\n+  if (mips_emit_pre_atomic_barrier_p (model))\n     {\n       if (required_oldval == 0 && TARGET_OCTEON)\n \t{\n@@ -12066,6 +12121,10 @@ mips_process_sync_loop (rtx insn, rtx *operands)\n \t  tmp1 = at;\n \t}\n       mips_multi_add_insn (\"bne\\t%0,%z1,2f\", tmp1, required_oldval, NULL);\n+\n+      /* CMP = 0 [delay slot].  */\n+      if (cmp)\n+        mips_multi_add_insn (\"li\\t%0,0\", cmp, NULL);\n     }\n \n   /* $TMP1 = OLDVAL & EXCLUSIVE_MASK.  */\n@@ -12129,11 +12188,15 @@ mips_process_sync_loop (rtx insn, rtx *operands)\n       mips_multi_copy_insn (tmp3_insn);\n       mips_multi_set_operand (mips_multi_last_index (), 0, newval);\n     }\n-  else\n+  else if (!(required_oldval && cmp))\n     mips_multi_add_insn (\"nop\", NULL);\n \n+  /* CMP = 1 -- either standalone or in a delay slot.  */\n+  if (required_oldval && cmp)\n+    mips_multi_add_insn (\"li\\t%0,1\", cmp, NULL);\n+\n   /* Output the acquire side of the memory barrier.  */\n-  if (TARGET_SYNC_AFTER_SC)\n+  if (TARGET_SYNC_AFTER_SC && mips_emit_post_atomic_barrier_p (model))\n     mips_multi_add_insn (\"sync\", NULL);\n \n   /* Output the exit label, if needed.  */"}, {"sha": "5b1735fe7f580aeb14b166cf6f4ea642c0802aeb", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c196ea91cce2665bc7e8df7edfd7dca0352d86/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c196ea91cce2665bc7e8df7edfd7dca0352d86/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=01c196ea91cce2665bc7e8df7edfd7dca0352d86", "patch": "@@ -349,13 +349,15 @@\n ;;       if (RELEASE_BARRIER == YES) sync\n ;;    1: OLDVAL = *MEM\n ;;       if ((OLDVAL & INCLUSIVE_MASK) != REQUIRED_OLDVAL) goto 2\n+;;         CMP  = 0 [delay slot]\n ;;       $TMP1 = OLDVAL & EXCLUSIVE_MASK\n ;;       $TMP2 = INSN1 (OLDVAL, INSN1_OP2)\n ;;       $TMP3 = INSN2 ($TMP2, INCLUSIVE_MASK)\n ;;       $AT |= $TMP1 | $TMP3\n ;;       if (!commit (*MEM = $AT)) goto 1.\n ;;         if (INSN1 != MOVE && INSN1 != LI) NEWVAL = $TMP3 [delay slot]\n-;;       sync\n+;;       CMP  = 1\n+;;       if (ACQUIRE_BARRIER == YES) sync\n ;;    2:\n ;;\n ;; where \"$\" values are temporaries and where the other values are\n@@ -364,6 +366,7 @@\n ;; specified, the following values are used instead:\n ;;\n ;;    - OLDVAL: $AT\n+;;    - CMP: NONE\n ;;    - NEWVAL: $AT\n ;;    - INCLUSIVE_MASK: -1\n ;;    - REQUIRED_OLDVAL: OLDVAL & INCLUSIVE_MASK\n@@ -375,6 +378,7 @@\n ;; but the gen* programs don't yet support that.\n (define_attr \"sync_mem\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n (define_attr \"sync_oldval\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n+(define_attr \"sync_cmp\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n (define_attr \"sync_newval\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n (define_attr \"sync_inclusive_mask\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n (define_attr \"sync_exclusive_mask\" \"none,0,1,2,3,4,5\" (const_string \"none\"))\n@@ -384,8 +388,11 @@\n   (const_string \"move\"))\n (define_attr \"sync_insn2\" \"nop,and,xor,not\"\n   (const_string \"nop\"))\n-(define_attr \"sync_release_barrier\" \"yes,no\"\n-  (const_string \"yes\"))\n+;; Memory model specifier.\n+;; \"0\"-\"9\" values specify the operand that stores the memory model value.\n+;; \"10\" specifies MEMMODEL_ACQ_REL,\n+;; \"11\" specifies MEMMODEL_ACQUIRE.\n+(define_attr \"sync_memmodel\" \"\" (const_int 10))\n \n ;; Length of instruction in bytes.\n (define_attr \"length\" \"\""}, {"sha": "604aefa3d0e5180e09292d121e4c0c6a09fcef80", "filename": "gcc/config/mips/sync.md", "status": "modified", "additions": 105, "deletions": 2, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c196ea91cce2665bc7e8df7edfd7dca0352d86/gcc%2Fconfig%2Fmips%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c196ea91cce2665bc7e8df7edfd7dca0352d86/gcc%2Fconfig%2Fmips%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fsync.md?ref=01c196ea91cce2665bc7e8df7edfd7dca0352d86", "patch": "@@ -29,6 +29,9 @@\n   UNSPEC_SYNC_EXCHANGE\n   UNSPEC_SYNC_EXCHANGE_12\n   UNSPEC_MEMORY_BARRIER\n+  UNSPEC_ATOMIC_COMPARE_AND_SWAP\n+  UNSPEC_ATOMIC_EXCHANGE\n+  UNSPEC_ATOMIC_FETCH_OP\n ])\n \n ;; Atomic fetch bitwise operations.\n@@ -54,6 +57,7 @@\n   \"GENERATE_SYNC\"\n   { return mips_output_sync (); })\n \n+;; Can be removed in favor of atomic_compare_and_swap below.\n (define_insn \"sync_compare_and_swap<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n \t(match_operand:GPR 1 \"memory_operand\" \"+R,R\"))\n@@ -368,6 +372,7 @@\n    (set_attr \"sync_mem\" \"0\")\n    (set_attr \"sync_insn1_op2\" \"1\")])\n \n+;; Can be removed in favor of atomic_fetch_add below.\n (define_insn \"sync_old_add<mode>\"\n   [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n \t(match_operand:GPR 1 \"memory_operand\" \"+R,R\"))\n@@ -521,7 +526,7 @@\n \t UNSPEC_SYNC_EXCHANGE))]\n   \"GENERATE_LL_SC\"\n   { return mips_output_sync_loop (insn, operands); }\n-  [(set_attr \"sync_release_barrier\" \"no\")\n+  [(set_attr \"sync_memmodel\" \"11\")\n    (set_attr \"sync_insn1\" \"li,move\")\n    (set_attr \"sync_oldval\" \"0\")\n    (set_attr \"sync_mem\" \"1\")\n@@ -550,11 +555,109 @@\n \t  UNSPEC_SYNC_EXCHANGE_12))]\n   \"GENERATE_LL_SC\"\n   { return mips_output_sync_loop (insn, operands); }\n-  [(set_attr \"sync_release_barrier\" \"no\")\n+  [(set_attr \"sync_memmodel\" \"11\")\n    (set_attr \"sync_oldval\" \"0\")\n    (set_attr \"sync_mem\" \"1\")\n    ;; Unused, but needed to give the number of operands expected by\n    ;; the expander.\n    (set_attr \"sync_inclusive_mask\" \"2\")\n    (set_attr \"sync_exclusive_mask\" \"3\")\n    (set_attr \"sync_insn1_op2\" \"4\")])\n+\n+(define_insn \"atomic_compare_and_swap<mode>\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n+\t;; Logically this unspec is an \"eq\" operator, but we need to obscure\n+\t;; reads and writes from/to memory with an unspec to prevent\n+\t;; optimizations on shared memory locations.  Otherwise, comparison in\n+\t;; { mem = 2; if (atomic_cmp_swap(mem,...) == 2) ...; }\n+\t;; would be optimized away.  In addition to that we need to use\n+\t;; unspec_volatile, not just plain unspec -- for the sake of other\n+\t;; threads -- to make sure we don't remove the entirety of the pattern\n+\t;; just because current thread doesn't observe any effect from it.\n+\t;; TODO: the obscuring unspec can be relaxed for permissive memory\n+\t;; models.\n+\t;; Same applies to other atomic_* patterns.\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"memory_operand\" \"+R,R\")\n+\t\t\t      (match_operand:GPR 3 \"reg_or_0_operand\" \"dJ,dJ\")]\n+\t UNSPEC_ATOMIC_COMPARE_AND_SWAP))\n+   (set (match_operand:GPR 1 \"register_operand\" \"=&d,&d\")\n+\t(unspec_volatile:GPR [(match_dup 2)]\n+\t UNSPEC_ATOMIC_COMPARE_AND_SWAP))\n+   (set (match_dup 2)\n+\t(unspec_volatile:GPR [(match_dup 2)\n+\t\t\t      (match_dup 3)\n+\t\t\t      (match_operand:GPR 4 \"arith_operand\" \"I,d\")]\n+\t UNSPEC_ATOMIC_COMPARE_AND_SWAP))\n+   (unspec_volatile:GPR [(match_operand:SI 5 \"const_int_operand\")\n+\t\t\t (match_operand:SI 6 \"const_int_operand\")\n+\t\t\t (match_operand:SI 7 \"const_int_operand\")]\n+    UNSPEC_ATOMIC_COMPARE_AND_SWAP)]\n+  \"GENERATE_LL_SC\"\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"li,move\")\n+   (set_attr \"sync_oldval\" \"1\")\n+   (set_attr \"sync_cmp\" \"0\")\n+   (set_attr \"sync_mem\" \"2\")\n+   (set_attr \"sync_required_oldval\" \"3\")\n+   (set_attr \"sync_insn1_op2\" \"4\")\n+   (set_attr \"sync_memmodel\" \"6\")])\n+\n+(define_expand \"atomic_exchange<mode>\"\n+  [(match_operand:GPR 0 \"register_operand\")\n+   (match_operand:GPR 1 \"memory_operand\")\n+   (match_operand:GPR 2 \"arith_operand\")\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"GENERATE_LL_SC\"\n+{\n+    emit_insn (gen_atomic_exchange<mode>_llsc (operands[0], operands[1],\n+\t\t\t\t\t       operands[2], operands[3]));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_exchange<mode>_llsc\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n+\t(unspec_volatile:GPR [(match_operand:GPR 1 \"memory_operand\" \"+R,R\")]\n+\t UNSPEC_ATOMIC_EXCHANGE))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR [(match_operand:GPR 2 \"arith_operand\" \"I,d\")]\n+\t UNSPEC_ATOMIC_EXCHANGE))\n+   (unspec_volatile:GPR [(match_operand:SI 3 \"const_int_operand\")]\n+    UNSPEC_ATOMIC_EXCHANGE)]\n+  \"GENERATE_LL_SC\"\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"li,move\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")\n+   (set_attr \"sync_memmodel\" \"3\")])\n+\n+(define_expand \"atomic_fetch_add<mode>\"\n+  [(match_operand:GPR 0 \"register_operand\")\n+   (match_operand:GPR 1 \"memory_operand\")\n+   (match_operand:GPR 2 \"arith_operand\")\n+   (match_operand:SI 3 \"const_int_operand\")]\n+  \"GENERATE_LL_SC\"\n+{\n+    emit_insn (gen_atomic_fetch_add<mode>_llsc (operands[0], operands[1],\n+\t\t\t\t\t\toperands[2], operands[3]));\n+  DONE;\n+})\n+\n+(define_insn \"atomic_fetch_add<mode>_llsc\"\n+  [(set (match_operand:GPR 0 \"register_operand\" \"=&d,&d\")\n+\t(unspec_volatile:GPR [(match_operand:GPR 1 \"memory_operand\" \"+R,R\")]\n+\t UNSPEC_ATOMIC_FETCH_OP))\n+   (set (match_dup 1)\n+\t(unspec_volatile:GPR\n+\t [(plus:GPR (match_dup 1)\n+\t\t    (match_operand:GPR 2 \"arith_operand\" \"I,d\"))]\n+\t UNSPEC_ATOMIC_FETCH_OP))\n+   (unspec_volatile:GPR [(match_operand:SI 3 \"const_int_operand\")]\n+    UNSPEC_ATOMIC_FETCH_OP)]\n+  \"GENERATE_LL_SC\"\n+  { return mips_output_sync_loop (insn, operands); }\n+  [(set_attr \"sync_insn1\" \"addiu,addu\")\n+   (set_attr \"sync_oldval\" \"0\")\n+   (set_attr \"sync_mem\" \"1\")\n+   (set_attr \"sync_insn1_op2\" \"2\")\n+   (set_attr \"sync_memmodel\" \"3\")])"}]}