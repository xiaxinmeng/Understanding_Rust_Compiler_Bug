{"sha": "ba54039439a720eb5da51dc54d4e1e0e5b2d99c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE1NDAzOTQzOWE3MjBlYjVkYTUxZGM1NGQ0ZTFlMGU1YjJkOTljNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "1999-12-03T11:58:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "1999-12-03T11:58:27Z"}, "message": "* frame.c (fde_split): Reimplement to avoid variable sized array.\n\nFrom-SVN: r30768", "tree": {"sha": "58d744ce646f323ed7892ee5a84f2ee2476aa8b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58d744ce646f323ed7892ee5a84f2ee2476aa8b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f7b6c6b5286c9af20d6d1a861af7505d65a434fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b6c6b5286c9af20d6d1a861af7505d65a434fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7b6c6b5286c9af20d6d1a861af7505d65a434fe"}], "stats": {"total": 53, "additions": 39, "deletions": 14}, "files": [{"sha": "51af97f3f9a856ba49735f77a0376e84bb439cd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba54039439a720eb5da51dc54d4e1e0e5b2d99c5", "patch": "@@ -1,3 +1,7 @@\n+1999-12-03  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* frame.c (fde_split): Reimplement to avoid variable sized array.\n+\n Thu Dec  2 18:59:48 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* combine.c (try_combine): Before fixing up LOG_LINKS for the"}, {"sha": "fa011d342b63657c9702616b00ddf1a68112dd60", "filename": "gcc/frame.c", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5/gcc%2Fframe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba54039439a720eb5da51dc54d4e1e0e5b2d99c5/gcc%2Fframe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.c?ref=ba54039439a720eb5da51dc54d4e1e0e5b2d99c5", "patch": "@@ -300,33 +300,54 @@ fde_insert (fde_accumulator *accu, fde *this_fde)\n \n /* Split LINEAR into a linear sequence with low values and an erratic\n    sequence with high values, put the linear one (of longest possible\n-   length) into LINEAR and the erratic one into ERRATIC. This is O(N).  */\n+   length) into LINEAR and the erratic one into ERRATIC. This is O(N).\n+   \n+   Because the longest linear sequence we are trying to locate within the\n+   incoming LINEAR array can be interspersed with (high valued) erratic\n+   entries.  We construct a chain indicating the sequenced entries.\n+   To avoid having to allocate this chain, we overlay it onto the space of\n+   the ERRATIC array during construction.  A final pass iterates over the\n+   chain to determine what should be placed in the ERRATIC array, and\n+   what is the linear sequence.  This overlay is safe from aliasing.  */\n static inline void\n fde_split (fde_vector *linear, fde_vector *erratic)\n {\n+  static fde *marker;\n   size_t count = linear->count;\n-  size_t linear_max = (size_t) -1;\n-  size_t previous_max[count];\n-  size_t i, j;\n+  fde **chain_end = &marker;\n+  size_t i, j, k;\n \n+  /* This should optimize out, but it is wise to make sure this assumption\n+     is correct. Should these have different sizes, we cannot cast between\n+     them and the overlaying onto ERRATIC will not work.  */\n+  if (sizeof (fde *) != sizeof (fde **))\n+    abort ();\n+  \n   for (i = 0; i < count; i++)\n     {\n-      for (j = linear_max;\n-           j != (size_t) -1\n-           && fde_compare (linear->array[i], linear->array[j]) < 0;\n-           j = previous_max[j])\n+      fde **probe;\n+      \n+      for (probe = chain_end;\n+           probe != &marker && fde_compare (linear->array[i], *probe) < 0;\n+           probe = chain_end)\n         {\n-          erratic->array[erratic->count++] = linear->array[j];\n-          linear->array[j] = (fde *) NULL;\n+          chain_end = (fde **)erratic->array[probe - linear->array];\n+          erratic->array[probe - linear->array] = NULL;\n         }\n-      previous_max[i] = j;\n-      linear_max = i;\n+      erratic->array[i] = (fde *)chain_end;\n+      chain_end = &linear->array[i];\n     }\n \n-  for (i = 0, j = 0; i < count; i++)\n-    if (linear->array[i] != (fde *) NULL)\n+  /* Each entry in LINEAR which is part of the linear sequence we have\n+     discovered will correspond to a non-NULL entry in the chain we built in\n+     the ERRATIC array.  */\n+  for (i = j = k = 0; i < count; i++)\n+    if (erratic->array[i])\n       linear->array[j++] = linear->array[i];\n+    else\n+      erratic->array[k++] = linear->array[i];\n   linear->count = j;\n+  erratic->count = k;\n }\n \n /* This is O(n log(n)).  BSD/OS defines heapsort in stdlib.h, so we must"}]}