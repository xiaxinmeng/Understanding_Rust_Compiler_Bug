{"sha": "ea99e0becf7057b7112a267b55e39e9b8c24db13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE5OWUwYmVjZjcwNTdiNzExMmEyNjdiNTVlMzllOWI4YzI0ZGIxMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-01-11T13:13:37Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-01-11T13:13:37Z"}, "message": "cgraph.c (cgraph_insert_node_to_hashtable): New function.\n\n\t* cgraph.c (cgraph_insert_node_to_hashtable): New function.\n\t* cgraph.h (cgraph_node): Add inline_decl.\n\t(cgraph_insert_node_to_hashtable): Declare.\n\t(save_inline_function_body): Declare.\n\t* cgraphunit.c (verify_cgraph_node): Inline edges might point to inline\n\tclones.\n\t(cgraph_preserve_function_body_p): Do not presrve when dump is enabled.\n\t(cgraph_function_versioning): Update call of tree_function_versioning.\n\t(save_inline_function_body): New function.\n\t* function.h (struct function): Kill saved_eh, saved_cfg, saved_args,\n\tsaved_static_chain_decl, saved_blocks and saved-unexpanded_var_list.\n\t* ipa-inline.c (cgraph_mark_inline_edge): Look for inline clones.\n\t(cgraph_default_inline_p): Likewise.\n\t(cgraph_decide_inlining_incrementally): Likewise.\n\t* tree-inline.c (inline_data): Kill saving_p add update_clones_p.\n\t(copy_bb): Kill saving; do updating of clones.\n\t(copy_cfg_body): Kill saving.\n\t(initialize_inlined-parameters): Likewise.\n\t(expand_call_inline): Likewise.\n\t(save_body): Kill.\n\t(tree_function_versioning): New parameter \"update_clones\".\n\t(inlining_p): Kill saving.\n\t* tree-inline.h (tree_function_versioning): Update prototype.\n\t* tree-optimize.c (tree_rest_of_compilation): Use clonning instead of\n\tsaving.\n\nFrom-SVN: r109580", "tree": {"sha": "7528e0c14251773ead6e3aa9eaaf90a59556ee1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7528e0c14251773ead6e3aa9eaaf90a59556ee1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea99e0becf7057b7112a267b55e39e9b8c24db13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea99e0becf7057b7112a267b55e39e9b8c24db13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea99e0becf7057b7112a267b55e39e9b8c24db13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea99e0becf7057b7112a267b55e39e9b8c24db13/comments", "author": null, "committer": null, "parents": [{"sha": "abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abcb0cdc2005f2cfb5ac9f1dedd5269b5f51c89f"}], "stats": {"total": 382, "additions": 163, "deletions": 219}, "files": [{"sha": "d95cbb823287abfafe42924f2a8d55ef8d12c70a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea99e0becf7057b7112a267b55e39e9b8c24db13", "patch": "@@ -1,3 +1,31 @@\n+2006-01-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_insert_node_to_hashtable): New function.\n+\t* cgraph.h (cgraph_node): Add inline_decl.\n+\t(cgraph_insert_node_to_hashtable): Declare.\n+\t(save_inline_function_body): Declare.\n+\t* cgraphunit.c (verify_cgraph_node): Inline edges might point to inline\n+\tclones.\n+\t(cgraph_preserve_function_body_p): Do not presrve when dump is enabled.\n+\t(cgraph_function_versioning): Update call of tree_function_versioning.\n+\t(save_inline_function_body): New function.\n+\t* function.h (struct function): Kill saved_eh, saved_cfg, saved_args,\n+\tsaved_static_chain_decl, saved_blocks and saved-unexpanded_var_list.\n+\t* ipa-inline.c (cgraph_mark_inline_edge): Look for inline clones.\n+\t(cgraph_default_inline_p): Likewise.\n+\t(cgraph_decide_inlining_incrementally): Likewise.\n+\t* tree-inline.c (inline_data): Kill saving_p add update_clones_p.\n+\t(copy_bb): Kill saving; do updating of clones.\n+\t(copy_cfg_body): Kill saving.\n+\t(initialize_inlined-parameters): Likewise.\n+\t(expand_call_inline): Likewise.\n+\t(save_body): Kill.\n+\t(tree_function_versioning): New parameter \"update_clones\".\n+\t(inlining_p): Kill saving.\n+\t* tree-inline.h (tree_function_versioning): Update prototype.\n+\t* tree-optimize.c (tree_rest_of_compilation): Use clonning instead of\n+\tsaving.\n+\n 2006-01-11  Ian Lance Taylor <ian@airs.com>\n \n \t* combine.c (struct undo): Remove is_int.  Enumify types of undos."}, {"sha": "88cf8ac818ed0e241b044372aea4d8d4daccb8fe", "filename": "gcc/cgraph.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ea99e0becf7057b7112a267b55e39e9b8c24db13", "patch": "@@ -214,6 +214,19 @@ cgraph_node (tree decl)\n   return node;\n }\n \n+/* Insert already constructed node into hashtable.  */\n+\n+void\n+cgraph_insert_node_to_hashtable (struct cgraph_node *node)\n+{\n+  struct cgraph_node **slot;\n+\n+  slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, node, INSERT);\n+\n+  gcc_assert (!*slot);\n+  *slot = node;\n+}\n+\n /* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n \n static bool"}, {"sha": "78b0fad3e862f3bfa77fae60d0e0bf178bc42693", "filename": "gcc/cgraph.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ea99e0becf7057b7112a267b55e39e9b8c24db13", "patch": "@@ -161,6 +161,11 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   bool externally_visible;\n   /* Set for aliases once they got through assemble_alias.  */\n   bool alias;\n+\n+  /* In non-unit-at-a-time mode the function body of inline candidates is saved\n+     into clone before compiling so the function in original form can be\n+     inlined later.  This pointer points to the clone.  */\n+  tree inline_decl;\n };\n \n struct cgraph_edge GTY((chain_next (\"%h.next_caller\"), chain_prev (\"%h.prev_caller\")))\n@@ -225,6 +230,7 @@ extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n void dump_cgraph_node (FILE *, struct cgraph_node *);\n+void cgraph_insert_node_to_hashtable (struct cgraph_node *node);\n void dump_varpool (FILE *);\n void dump_cgraph_varpool_node (FILE *, struct cgraph_varpool_node *);\n void cgraph_remove_edge (struct cgraph_edge *);\n@@ -281,6 +287,7 @@ void cgraph_reset_static_var_maps (void);\n void init_cgraph (void);\n struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n                                                 varray_type, varray_type);\n+struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n \n /* In ipa.c  */\n bool cgraph_remove_unreachable_nodes (bool, FILE *);"}, {"sha": "ae2dd51f887dc20f3c6b5f4e396f7a99efd83f8b", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ea99e0becf7057b7112a267b55e39e9b8c24db13", "patch": "@@ -748,7 +748,8 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t    debug_generic_stmt (stmt);\n \t\t\t    error_found = true;\n \t\t\t  }\n-\t\t\tif (e->callee->decl != cgraph_node (decl)->decl)\n+\t\t\tif (e->callee->decl != cgraph_node (decl)->decl\n+\t\t\t    && e->inline_failed)\n \t\t\t  {\n \t\t\t    error (\"edge points to wrong declaration:\");\n \t\t\t    debug_tree (e->callee->decl);\n@@ -1202,9 +1203,6 @@ bool\n cgraph_preserve_function_body_p (tree decl)\n {\n   struct cgraph_node *node;\n-  /* Keep the body; we're going to dump it.  */\n-  if (dump_enabled_p (TDI_tree_all))\n-    return true;\n   if (!cgraph_global_info_ready)\n     return (DECL_INLINE (decl) && !flag_really_no_inline);\n   /* Look if there is any clone around.  */\n@@ -1504,7 +1502,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n \t\t\t\t     redirect_callers);\n \n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (old_decl, new_decl, tree_map);\n+  tree_function_versioning (old_decl, new_decl, tree_map, false);\n   /* Update the call_expr on the edges to call the new version node. */\n   update_call_expr (new_version_node);\n \n@@ -1521,3 +1519,57 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n   new_version_node->lowered = true;\n   return new_version_node;\n }\n+\n+/* Produce separate function body for inline clones so the offline copy can be\n+   modified without affecting them.  */\n+struct cgraph_node *\n+save_inline_function_body (struct cgraph_node *node)\n+{\n+  struct cgraph_node *first_clone;\n+\n+  gcc_assert (node == cgraph_node (node->decl));\n+\n+  cgraph_lower_function (node);\n+\n+  /* In non-unit-at-a-time we construct full fledged clone we never output to\n+     assembly file.  This clone is pointed out by inline_decl of orginal function\n+     and inlining infrastructure knows how to deal with this.  */\n+  if (!flag_unit_at_a_time)\n+    {\n+      struct cgraph_edge *e;\n+\n+      first_clone = cgraph_clone_node (node, node->count, 0, false);\n+      first_clone->needed = 0;\n+      first_clone->reachable = 1;\n+      /* Recursively clone all bodies.  */\n+      for (e = first_clone->callees; e; e = e->next_callee)\n+\tif (!e->inline_failed)\n+\t  cgraph_clone_inlined_nodes (e, true, false);\n+    }\n+  else\n+    first_clone = node->next_clone;\n+\n+  first_clone->decl = copy_node (node->decl);\n+  node->next_clone = NULL;\n+  if (!flag_unit_at_a_time)\n+    node->inline_decl = first_clone->decl;\n+  first_clone->prev_clone = NULL;\n+  cgraph_insert_node_to_hashtable (first_clone);\n+  gcc_assert (first_clone == cgraph_node (first_clone->decl));\n+\n+  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n+  tree_function_versioning (node->decl, first_clone->decl, NULL, true);\n+\n+  DECL_EXTERNAL (first_clone->decl) = 0;\n+  DECL_ONE_ONLY (first_clone->decl) = 0;\n+  TREE_PUBLIC (first_clone->decl) = 0;\n+  DECL_COMDAT (first_clone->decl) = 0;\n+\n+  for (node = first_clone->next_clone; node; node = node->next_clone)\n+    node->decl = first_clone->decl;\n+#ifdef ENABLE_CHECKING\n+  verify_cgraph_node (first_clone);\n+#endif\n+  return first_clone;\n+}\n+"}, {"sha": "e1e173b33b2891da689e724fca46e64a136b2aee", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=ea99e0becf7057b7112a267b55e39e9b8c24db13", "patch": "@@ -162,25 +162,14 @@ struct expr_status GTY(())\n struct function GTY(())\n {\n   struct eh_status *eh;\n-  struct eh_status *saved_eh;\n   struct expr_status *expr;\n   struct emit_status *emit;\n   struct varasm_status *varasm;\n \n   /* The control flow graph for this function.  */\n   struct control_flow_graph *cfg;\n-  struct control_flow_graph *saved_cfg;\n   bool after_inlining;\n \n-  /* For tree-optimize.c.  */\n-\n-  /* Saved tree and arguments during tree optimization.  Used later for\n-     inlining */\n-  tree saved_args;\n-  tree saved_static_chain_decl;\n-  tree saved_blocks;\n-  tree saved_unexpanded_var_list;\n-\n   /* For function.c.  */\n \n   /* Points to the FUNCTION_DECL of this function.  */"}, {"sha": "fa91cbd96dc50840d31f92cdaf1423534055aa87", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ea99e0becf7057b7112a267b55e39e9b8c24db13", "patch": "@@ -158,6 +158,9 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original)\n   int old_insns = 0, new_insns = 0;\n   struct cgraph_node *to = NULL, *what;\n \n+  if (e->callee->inline_decl)\n+    cgraph_redirect_edge_callee (e, cgraph_node (e->callee->inline_decl));\n+\n   gcc_assert (e->inline_failed);\n   e->inline_failed = NULL;\n \n@@ -283,21 +286,25 @@ cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n bool\n cgraph_default_inline_p (struct cgraph_node *n, const char **reason)\n {\n-  if (!DECL_INLINE (n->decl))\n+  tree decl = n->decl;\n+\n+  if (n->inline_decl)\n+    decl = n->inline_decl;\n+  if (!DECL_INLINE (decl))\n     {\n       if (reason)\n \t*reason = N_(\"function not inlinable\");\n       return false;\n     }\n \n-  if (!DECL_SAVED_TREE (n->decl))\n+  if (!DECL_STRUCT_FUNCTION (decl)->cfg)\n     {\n       if (reason)\n \t*reason = N_(\"function body not available\");\n       return false;\n     }\n \n-  if (DECL_DECLARED_INLINE_P (n->decl))\n+  if (DECL_DECLARED_INLINE_P (decl))\n     {\n       if (n->global.insns >= MAX_INLINE_INSNS_SINGLE)\n \t{\n@@ -1046,7 +1053,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n         && !cgraph_recursive_inlining_p (node, e->callee, &e->inline_failed)\n \t/* ??? It is possible that renaming variable removed the function body\n \t   in duplicate_decls. See gcc.c-torture/compile/20011119-2.c  */\n-\t&& DECL_SAVED_TREE (e->callee->decl))\n+\t&& (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n       {\n         if (dump_file && early)\n \t  {\n@@ -1069,7 +1076,7 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n \t      || (cgraph_estimate_size_after_inlining (1, e->caller, node)\n \t          <= e->caller->global.insns))\n \t  && cgraph_check_inline_limits (node, e->callee, &e->inline_failed)\n-\t  && DECL_SAVED_TREE (e->callee->decl))\n+\t  && (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n \t{\n \t  if (cgraph_default_inline_p (e->callee, &failed_reason))\n \t    {"}, {"sha": "be38fc937e11734692ae9a79d9d9d743dfd4cc2a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 36, "deletions": 142, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ea99e0becf7057b7112a267b55e39e9b8c24db13", "patch": "@@ -111,9 +111,7 @@ typedef struct inline_data\n   tree callee;\n   /* FUNCTION_DECL for function being inlined into.  */\n   tree caller;\n-  /* struct function for function being inlined.  Usually this is the same\n-     as DECL_STRUCT_FUNCTION (callee), but can be different if saved_cfg\n-     and saved_eh are in use.  */\n+  /* struct function for function being inlined.  */\n   struct function *callee_cfun;\n   /* The VAR_DECL for the return value.  */\n   tree retvar;\n@@ -125,10 +123,11 @@ typedef struct inline_data\n      distinguish between those two situations.  This flag is true if\n      we are cloning, rather than inlining.  */\n   bool cloning_p;\n-  /* Similarly for saving function body.  */\n-  bool saving_p;\n   /* Versioning function is slightly different from inlining. */\n   bool versioning_p;\n+  /* If set, the call_stmt of edges in clones of caller functions will\n+     be updated.  */\n+  bool update_clones_p;\n   /* Callgraph node of function we are inlining into.  */\n   struct cgraph_node *node;\n   /* Callgraph node of currently inlined function.  */\n@@ -750,46 +749,33 @@ copy_bb (inline_data *id, basic_block bb, int frequency_scale, int count_scale)\n \t     callgraph edges and update or duplicate them.  */\n \t  if (call && (decl = get_callee_fndecl (call)))\n \t    {\n-\t      if (id->saving_p)\n-\t\t{\n-\t\t  struct cgraph_node *node;\n-\t\t  struct cgraph_edge *edge;\n-\n-\t\t  /* We're saving a copy of the body, so we'll update the\n-\t\t     callgraph nodes in place.  Note that we avoid\n-\t\t     altering the original callgraph node; we begin with\n-\t\t     the first clone.  */\n-\t\t  for (node = id->node->next_clone;\n-\t\t       node;\n-\t\t       node = node->next_clone)\n-\t\t    {\n-\t\t      edge = cgraph_edge (node, orig_stmt);\n-\t\t      gcc_assert (edge);\n-\t\t      edge->call_stmt = stmt;\n-\t\t    }\n-\t\t}\n-\t      else\n+\t      if (!id->versioning_p)\n \t\t{\n \t\t  struct cgraph_edge *edge;\n \n \t\t  /* We're cloning or inlining this body; duplicate the\n \t\t     associate callgraph nodes.  */\n-\t\t  if (!id->versioning_p)\n-\t\t    {\n-\t\t      edge = cgraph_edge (id->current_node, orig_stmt);\n-\t\t      if (edge)\n-\t\t\tcgraph_clone_edge (edge, id->node, stmt,\n-\t\t\t\t\t   REG_BR_PROB_BASE, 1, true);\n-\t\t    }\n+\t\t  edge = cgraph_edge (id->current_node, orig_stmt);\n+\t\t  if (edge)\n+\t\t    cgraph_clone_edge (edge, id->node, stmt,\n+\t\t\t\t       REG_BR_PROB_BASE, 1, true);\n \t\t}\n-\t      if (id->versioning_p)\n+\t      else\n \t\t{\n \t\t  /* Update the call_expr on the edges from the new version\n \t\t     to its callees. */\n \t\t  struct cgraph_edge *edge;\n \t\t  edge = cgraph_edge (id->node, orig_stmt);\n \t\t  if (edge)\n-\t\t    edge->call_stmt = stmt;\n+\t\t    {\n+\t\t      edge->call_stmt = stmt;\n+\t\t      if (id->update_clones_p)\n+\t\t\t{\n+\t\t\t  struct cgraph_node *n;\n+\t\t\t  for (n = id->node->next_clone; n; n = n->next_clone)\n+\t\t            cgraph_edge (n, orig_stmt)->call_stmt = stmt;\n+\t\t\t}\n+\t\t     }\n \t\t}\n \t    }\n \t  /* If you think we can abort here, you are wrong.\n@@ -917,7 +903,7 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n     (struct function *) ggc_alloc_cleared (sizeof (struct function));\n   basic_block bb;\n   tree new_fndecl = NULL;\n-  bool saving_or_cloning;\n+  bool versioning_or_cloning;\n   int count_scale, frequency_scale;\n \n   if (ENTRY_BLOCK_PTR_FOR_FUNCTION (callee_cfun)->count)\n@@ -942,24 +928,14 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n \n   *cfun_to_copy = *DECL_STRUCT_FUNCTION (callee_fndecl);\n \n-  /* If there is a saved_cfg+saved_args lurking in the\n-     struct function, a copy of the callee body was saved there, and\n-     the 'struct cgraph edge' nodes have been fudged to point into the\n-     saved body.  Accordingly, we want to copy that saved body so the\n-     callgraph edges will be recognized and cloned properly.  */\n-  if (cfun_to_copy->saved_cfg)\n-    {\n-      cfun_to_copy->cfg = cfun_to_copy->saved_cfg;\n-      cfun_to_copy->eh = cfun_to_copy->saved_eh;\n-    }\n   id->callee_cfun = cfun_to_copy;\n \n   /* If saving or cloning a function body, create new basic_block_info\n      and label_to_block_maps.  Otherwise, we're duplicating a function\n      body for inlining; insert our new blocks and labels into the\n      existing varrays.  */\n-  saving_or_cloning = (id->saving_p || id->cloning_p || id->versioning_p);\n-  if (saving_or_cloning)\n+  versioning_or_cloning = (id->cloning_p || id->versioning_p);\n+  if (versioning_or_cloning)\n     {\n       new_cfun =\n \t(struct function *) ggc_alloc_cleared (sizeof (struct function));\n@@ -995,7 +971,7 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n   /* Duplicate any exception-handling regions.  */\n   if (cfun->eh)\n     {\n-      if (saving_or_cloning)\n+      if (versioning_or_cloning)\n         init_eh_for_function ();\n       id->eh_region_offset = duplicate_eh_regions (cfun_to_copy,\n \t\t     \t\t\t\t   remap_decl_1,\n@@ -1011,7 +987,7 @@ copy_cfg_body (inline_data * id, gcov_type count, int frequency,\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n     bb->aux = NULL;\n \n-  if (saving_or_cloning)\n+  if (versioning_or_cloning)\n     pop_cfun ();\n \n   return new_fndecl;\n@@ -1183,8 +1159,6 @@ initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n \n   /* Figure out what the parameters are.  */\n   parms = DECL_ARGUMENTS (fn);\n-  if (fn == current_function_decl)\n-    parms = cfun->saved_args;\n \n   /* Loop through the parameter declarations, replacing each with an\n      equivalent VAR_DECL, appropriately initialized.  */\n@@ -1204,8 +1178,7 @@ initialize_inlined_parameters (inline_data *id, tree args, tree static_chain,\n \n   /* Initialize the static chain.  */\n   p = DECL_STRUCT_FUNCTION (fn)->static_chain_decl;\n-  if (fn == current_function_decl)\n-    p = DECL_STRUCT_FUNCTION (fn)->saved_static_chain_decl;\n+  gcc_assert (fn != current_function_decl);\n   if (p)\n     {\n       /* No static chain?  Seems like a bug in tree-nested.c.  */\n@@ -2039,6 +2012,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \t}\n       goto egress;\n     }\n+  fn = cg_edge->callee->decl;\n \n #ifdef ENABLE_CHECKING\n   if (cg_edge->callee->decl != id->node->decl)\n@@ -2095,9 +2069,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   /* Record the function we are about to inline.  */\n   id->callee = fn;\n \n-  if (DECL_STRUCT_FUNCTION (fn)->saved_blocks)\n-    add_lexical_block (id->block, remap_blocks (DECL_STRUCT_FUNCTION (fn)->saved_blocks, id));\n-  else if (DECL_INITIAL (fn))\n+  if (DECL_INITIAL (fn))\n     add_lexical_block (id->block, remap_blocks (DECL_INITIAL (fn), id));\n \n   /* Return statements in the function body will be replaced by jumps\n@@ -2155,8 +2127,6 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \n   /* Add local vars in this inlined callee to caller.  */\n   t_step = id->callee_cfun->unexpanded_var_list;\n-  if (id->callee_cfun->saved_unexpanded_var_list)\n-    t_step = id->callee_cfun->saved_unexpanded_var_list;\n   for (; t_step; t_step = TREE_CHAIN (t_step))\n     {\n       var = TREE_VALUE (t_step);\n@@ -2331,86 +2301,6 @@ clone_body (tree clone, tree fn, void *arg_map)\n   append_to_statement_list_force (copy_generic_body (&id), &DECL_SAVED_TREE (clone));\n }\n \n-/* Save duplicate body in FN.  MAP is used to pass around splay tree\n-   used to update arguments in restore_body.  */\n-\n-/* Make and return duplicate of body in FN.  Put copies of DECL_ARGUMENTS\n-   in *arg_copy and of the static chain, if any, in *sc_copy.  */\n-\n-void\n-save_body (tree fn, tree *arg_copy, tree *sc_copy)\n-{\n-  inline_data id;\n-  tree newdecl, *parg;\n-  basic_block fn_entry_block;\n-  tree t_step;\n-\n-  memset (&id, 0, sizeof (id));\n-  id.callee = fn;\n-  id.callee_cfun = DECL_STRUCT_FUNCTION (fn);\n-  id.caller = fn;\n-  id.node = cgraph_node (fn);\n-  id.saving_p = true;\n-  id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n-  *arg_copy = DECL_ARGUMENTS (fn);\n-\n-  for (parg = arg_copy; *parg; parg = &TREE_CHAIN (*parg))\n-    {\n-      tree new = copy_node (*parg);\n-\n-      lang_hooks.dup_lang_specific_decl (new);\n-      DECL_ABSTRACT_ORIGIN (new) = DECL_ORIGIN (*parg);\n-      insert_decl_map (&id, *parg, new);\n-      TREE_CHAIN (new) = TREE_CHAIN (*parg);\n-      *parg = new;\n-    }\n-\n-  *sc_copy = DECL_STRUCT_FUNCTION (fn)->static_chain_decl;\n-  if (*sc_copy)\n-    {\n-      tree new = copy_node (*sc_copy);\n-\n-      lang_hooks.dup_lang_specific_decl (new);\n-      DECL_ABSTRACT_ORIGIN (new) = DECL_ORIGIN (*sc_copy);\n-      insert_decl_map (&id, *sc_copy, new);\n-      TREE_CHAIN (new) = TREE_CHAIN (*sc_copy);\n-      *sc_copy = new;\n-    }\n-\n-  /* We're not inside any EH region.  */\n-  id.eh_region = -1;\n-\n-  insert_decl_map (&id, DECL_RESULT (fn), DECL_RESULT (fn));\n-\n-  DECL_STRUCT_FUNCTION (fn)->saved_blocks\n-    = remap_blocks (DECL_INITIAL (fn), &id);\n-  for (t_step = id.callee_cfun->unexpanded_var_list;\n-       t_step;\n-       t_step = TREE_CHAIN (t_step))\n-    {\n-      tree var = TREE_VALUE (t_step);\n-      if (TREE_STATIC (var) && !TREE_ASM_WRITTEN (var))\n-\tcfun->saved_unexpanded_var_list\n-\t  = tree_cons (NULL_TREE, var, cfun->saved_unexpanded_var_list);\n-      else \n-\tcfun->saved_unexpanded_var_list\n-\t  = tree_cons (NULL_TREE, remap_decl (var, &id),\n-\t\t       cfun->saved_unexpanded_var_list);\n-    }\n-\n-  /* Actually copy the body, including a new (struct function *) and CFG.\n-     EH info is also duplicated so its labels point into the copied\n-     CFG, not the original.  */\n-  fn_entry_block = ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (fn));\n-  newdecl = copy_body (&id, fn_entry_block->count, fn_entry_block->frequency,\n-\t\t       NULL, NULL);\n-  DECL_STRUCT_FUNCTION (fn)->saved_cfg = DECL_STRUCT_FUNCTION (newdecl)->cfg;\n-  DECL_STRUCT_FUNCTION (fn)->saved_eh = DECL_STRUCT_FUNCTION (newdecl)->eh;\n-\n-  /* Clean up.  */\n-  splay_tree_delete (id.decl_map);\n-}\n-\n /* Passed to walk_tree.  Copies the node pointed to, if appropriate.  */\n \n tree\n@@ -2807,9 +2697,11 @@ tree_versionable_function_p (tree fndecl)\n    respectively.  In case we want to replace a DECL \n    tree with another tree while duplicating the function's \n    body, TREE_MAP represents the mapping between these \n-   trees.  */\n+   trees. If UPDATE_CLONES is set, the call_stmt fields\n+   of edges of clones of the function will be updated.  */\n void\n-tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map)\n+tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n+\t\t\t  bool update_clones)\n {\n   struct cgraph_node *old_version_node;\n   struct cgraph_node *new_version_node;\n@@ -2835,8 +2727,9 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map)\n   DECL_ABSTRACT_ORIGIN (new_decl) = DECL_ORIGIN (old_decl);\n \n   /* Generate a new name for the new version. */\n-  DECL_NAME (new_decl) =\n-    create_tmp_var_name (NULL);\n+  if (!update_clones)\n+    DECL_NAME (new_decl) =\n+      create_tmp_var_name (NULL);\n   /* Create a new SYMBOL_REF rtx for the new name. */\n   if (DECL_RTL (old_decl) != NULL)\n     {\n@@ -2856,6 +2749,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map)\n   id.current_node = cgraph_node (old_decl);\n   \n   id.versioning_p = true;\n+  id.update_clones_p = update_clones;\n   id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n   id.caller = new_decl;\n   id.callee = old_decl;\n@@ -2982,7 +2876,7 @@ replace_ref_tree (inline_data * id, tree * tp)\n static inline bool\n inlining_p (inline_data * id)\n {\n-  return (!id->saving_p && !id->cloning_p && !id->versioning_p);\n+  return (!id->cloning_p && !id->versioning_p);\n }\n \n /* Duplicate a type, fields and all.  */"}, {"sha": "7c53239e24427b264172f28a35f9478edc718767", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=ea99e0becf7057b7112a267b55e39e9b8c24db13", "patch": "@@ -35,7 +35,7 @@ void push_cfun (struct function *new_cfun);\n void pop_cfun (void);\n int estimate_num_insns (tree expr);\n bool tree_versionable_function_p (tree);\n-void tree_function_versioning (tree, tree, varray_type);\n+void tree_function_versioning (tree, tree, varray_type, bool);\n \n /* Copy a declaration when one function is substituted inline into\n    another.  It is used also for versioning.  */"}, {"sha": "34f2d4630772a1c9cab4209df023a041cfd495bd", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 9, "deletions": 55, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea99e0becf7057b7112a267b55e39e9b8c24db13/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=ea99e0becf7057b7112a267b55e39e9b8c24db13", "patch": "@@ -348,12 +348,19 @@ void\n tree_rest_of_compilation (tree fndecl)\n {\n   location_t saved_loc;\n-  struct cgraph_node *saved_node = NULL, *node;\n+  struct cgraph_node *node;\n \n   timevar_push (TV_EXPAND);\n \n   gcc_assert (!flag_unit_at_a_time || cgraph_global_info_ready);\n \n+  node = cgraph_node (fndecl);\n+\n+  /* We might need the body of this function so that we can expand\n+     it inline somewhere else.  */\n+  if (cgraph_preserve_function_body_p (fndecl))\n+    save_inline_function_body (node);\n+\n   /* Initialize the RTL code for the function.  */\n   current_function_decl = fndecl;\n   saved_loc = input_location;\n@@ -367,26 +374,6 @@ tree_rest_of_compilation (tree fndecl)\n   cfun->x_dont_save_pending_sizes_p = 1;\n   cfun->after_inlining = true;\n \n-  node = cgraph_node (fndecl);\n-\n-  /* We might need the body of this function so that we can expand\n-     it inline somewhere else.  This means not lowering some constructs\n-     such as exception handling.  */\n-  if (cgraph_preserve_function_body_p (fndecl))\n-    {\n-      if (!flag_unit_at_a_time)\n-\t{\n-\t  struct cgraph_edge *e;\n-\n-\t  saved_node = cgraph_clone_node (node, node->count, 1, false);\n-\t  for (e = saved_node->callees; e; e = e->next_callee)\n-\t    if (!e->inline_failed)\n-\t      cgraph_clone_inlined_nodes (e, true, false);\n-\t}\n-      cfun->saved_static_chain_decl = cfun->static_chain_decl;\n-      save_body (fndecl, &cfun->saved_args, &cfun->saved_static_chain_decl);\n-    }\n-\n   if (flag_inline_trees)\n     {\n       struct cgraph_edge *e;\n@@ -429,40 +416,7 @@ tree_rest_of_compilation (tree fndecl)\n   /* Release the default bitmap obstack.  */\n   bitmap_obstack_release (NULL);\n   \n-  /* Restore original body if still needed.  */\n-  if (cfun->saved_cfg)\n-    {\n-      DECL_ARGUMENTS (fndecl) = cfun->saved_args;\n-      cfun->cfg = cfun->saved_cfg;\n-      cfun->eh = cfun->saved_eh;\n-      DECL_INITIAL (fndecl) = cfun->saved_blocks;\n-      cfun->unexpanded_var_list = cfun->saved_unexpanded_var_list;\n-      cfun->saved_cfg = NULL;\n-      cfun->saved_eh = NULL;\n-      cfun->saved_args = NULL_TREE;\n-      cfun->saved_blocks = NULL_TREE;\n-      cfun->saved_unexpanded_var_list = NULL_TREE;\n-      cfun->static_chain_decl = cfun->saved_static_chain_decl;\n-      cfun->saved_static_chain_decl = NULL;\n-      /* When not in unit-at-a-time mode, we must preserve out of line copy\n-\t representing node before inlining.  Restore original outgoing edges\n-\t using clone we created earlier.  */\n-      if (!flag_unit_at_a_time)\n-\t{\n-\t  struct cgraph_edge *e;\n-\n-\t  node = cgraph_node (current_function_decl);\n-\t  cgraph_node_remove_callees (node);\n-\t  node->callees = saved_node->callees;\n-\t  saved_node->callees = NULL;\n-\t  update_inlined_to_pointers (node, node);\n-\t  for (e = node->callees; e; e = e->next_callee)\n-\t    e->caller = node;\n-\t  cgraph_remove_node (saved_node);\n-\t}\n-    }\n-  else\n-    DECL_SAVED_TREE (fndecl) = NULL;\n+  DECL_SAVED_TREE (fndecl) = NULL;\n   cfun = 0;\n \n   /* If requested, warn about function definitions where the function will"}]}