{"sha": "8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFmMmZlYzQwYmZkNjg4OWFiNDdiNDdkMGE5Y2ZhYTUxMDJjMjUwNw==", "commit": {"author": {"name": "Russell Yanofsky", "email": "russ@yanofsky.org", "date": "2007-05-31T01:18:22Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2007-05-31T01:18:22Z"}, "message": "re PR c++/7412 ([DR 106] References to references)\n\n2007-05-30  Russell Yanofsky <russ@yanofsky.org>\n            Douglas Gregor <doug.gregor@gmail.com>\n            Pedro Lamarao <pedro.lamarao@mndfck.org>\n            Howard Hinnant <howard.hinnant@gmail.com>\n\n\tPR c++/7412\n\tPR c++/29939\n        * g++.dg/cpp0x/rv8p.C: New.\n        * g++.dg/cpp0x/temp-constructor-bug.C: New.\n        * g++.dg/cpp0x/cast-bug.C: New.\n        * g++.dg/cpp0x/elision_weak.C: New.\n        * g++.dg/cpp0x/collapse-bug.C: New.\n        * g++.dg/cpp0x/rv3p.C: New.\n        * g++.dg/cpp0x/rv7n.C: New.\n        * g++.dg/cpp0x/overload-conv-1.C: New.\n        * g++.dg/cpp0x/rv2n.C: New.\n        * g++.dg/cpp0x/deduce.C: New.\n        * g++.dg/cpp0x/temp-va-arg-bug.C: New.\n        * g++.dg/cpp0x/rv6p.C: New.\n        * g++.dg/cpp0x/template_deduction.C: New.\n        * g++.dg/cpp0x/implicit-copy.C: New.\n        * g++.dg/cpp0x/rv1p.C: New.\n        * g++.dg/cpp0x/cast.C: New.\n        * g++.dg/cpp0x/rv5n.C: New.\n        * g++.dg/cpp0x/collapse.C: New.\n        * g++.dg/cpp0x/overload-conv-2.C: New.\n        * g++.dg/cpp0x/rv4p.C: New.\n\t* g++.dg/cpp0x/rvo.C: New.\n        * g++.dg/cpp0x/iop.C: New.\n        * g++.dg/cpp0x/rv3n.C: New.\n        * g++.dg/cpp0x/rv7p.C: New.\n        * g++.dg/cpp0x/reference_collapsing.C: New.\n        * g++.dg/cpp0x/overload.C: New.\n        * g++.dg/cpp0x/named.C: New.\n        * g++.dg/cpp0x/rv2p.C: New.\n        * g++.dg/cpp0x/rv6n.C: New.\n        * g++.dg/cpp0x/not_special.C: New.\n        * g++.dg/cpp0x/bind.C: New.\n        * g++.dg/cpp0x/rv1n.C: New.\n        * g++.dg/cpp0x/rv5p.C: New.\n        * g++.dg/cpp0x/elision.C: New.\n        * g++.dg/cpp0x/named_refs.C: New.\n        * g++.dg/cpp0x/unnamed_refs.C: New.\n        * g++.dg/cpp0x/rv4n.C: New.\n        * g++.dg/cpp0x/elision_neg.C: New.\n        * g++.dg/init/copy7.C: Run in C++98 mode.\n        * g++.dg/overload/arg1.C: Ditto.\n        * g++.dg/overload/arg4.C: Ditto.\n\t\n2007-05-30  Russell Yanofsky <russ@yanofsky.org>\n            Douglas Gregor <doug.gregor@gmail.com>\n            Pedro Lamarao <pedro.lamarao@mndfck.org>\n            Howard Hinnant <howard.hinnant@gmail.com>\n\n\tPR c++/7412\n\tPR c++/29939\n\t* typeck.c (comptypes): Don't consider rvalue and lvalue\n\treference types to be equivalent.\n\t(check_return_expr): Move from certain lvalues when returning\n\tthem.\n\t* decl.c (grokdeclarator): Implement reference collapsing.\n\t(copy_fn_p): Don't consider constructors taking rvalue references\n\tto be copy constructors.\n\t(move_fn_p): New.\n        * call.c (conversion): New \"rvaluedness_matches_p\" member.\n\t(convert_class_to_reference): Require reference type as first\n\tparameter instead of base type.\n\t(reference_binding): Add logic to handle rvalue references.\n\t(implicit_conversion): Update inaccurate comment.\n\t(convert_like_real): Disable creation of temporaries that are\n\timpossible to initialize for types with move constructors.\n\t(build_over_call): Elide move constructors when possible.\n\t(maybe_handle_implicit_object): Set \"rvaluedness_matches_p\".\n\t(maybe_handle_ref_bind): Return conversion instead of type node.\n\t(compare_ics): Add logic to use \"rvaluedness_matches_p\" values to\n\tdetermine preferred conversion sequences.\n\t* cp-tree.h (TYPE_REF_IS_RVALUE): New.\n\t(LOOKUP_PREFER_RVALUE): New.\n\t(DECL_MOVE_CONSTRUCTOR_P): New.\n\t(struct cp_declarator): Add \"reference\" member for reference\n\ttypes, with new \"rvalue_ref\" flag.\n\t(cp_build_reference_type): Declare.\n\t(move_fn_p): Declare.\n\t* error.c (dump_type_prefix): Format rvalue reference types\n\tcorrectly in error messages.\n\t* except.c (build_throw): Move from certain lvalues when\n\tthrowing.\n\t* mangle.c (write_type): Mangle rvalue references differently\n\tthan regular references.\n\t* parser.c (make_reference_declarator): Add boolean parameter for\n\trvalue references.\n\t(cp_parser_make_indirect_declarator): New.\n\t(cp_parser_new_declarator_opt): Call\n\tcp_parser_make_indirect_declarator. \n\t(cp_parser_conversion_declarator_opt): Ditto.\n\t(cp_parser_declarator): Ditto.\n\t(cp_parser_ptr_operator): Parse \"&&\" tokens into rvalue reference\n\tdeclarators.\n\t* pt.c (tsubst): Implement reference collapsing.\n\t(maybe_adjust_types_for_deduction): Implement special template\n\tparameter deduction rule for rvalue references.\n\t(type_unification_real): Update calls to\n\tmaybe_adjust_types_for_deduction.\n\t(try_one_overload): Ditto.\n\t(unify_pack_expansion): Ditto.\n\t* tree.c (lvalue_p_1): Handle rvalue reference types.\n\t(cp_build_reference_type): New.\n\nFrom-SVN: r125211", "tree": {"sha": "6d0815a650d1201c2dd1e4b249977bfe4379c548", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d0815a650d1201c2dd1e4b249977bfe4379c548"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/comments", "author": {"login": "ryanofsky", "id": 7133040, "node_id": "MDQ6VXNlcjcxMzMwNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ryanofsky", "html_url": "https://github.com/ryanofsky", "followers_url": "https://api.github.com/users/ryanofsky/followers", "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}", "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}", "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions", "organizations_url": "https://api.github.com/users/ryanofsky/orgs", "repos_url": "https://api.github.com/users/ryanofsky/repos", "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}", "received_events_url": "https://api.github.com/users/ryanofsky/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0ae581acf1fbef4189f22a23a00b6d827aee4b1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae581acf1fbef4189f22a23a00b6d827aee4b1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ae581acf1fbef4189f22a23a00b6d827aee4b1b"}], "stats": {"total": 10591, "additions": 10486, "deletions": 105}, "files": [{"sha": "447556e95dc3daaf6cdd167cd1a2df8a7c6b17e1", "filename": "ChangeLog", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -457,6 +457,7 @@\n \tinstall-gcc.\n \t* Makefile.in: Regenerate.\n \n+>>>>>>> .merge-right.r70\n 2006-12-04  Richard Guenther  <rguenther@suse.de>\n \n \t* MAINTAINERS (Non-Algorithmic Maintainers): New section."}, {"sha": "22171e4e347a79571479b46687dbec0ebdc4fc48", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -1,3 +1,62 @@\n+2007-05-30  Russell Yanofsky <russ@yanofsky.org>\n+            Douglas Gregor <doug.gregor@gmail.com>\n+            Pedro Lamarao <pedro.lamarao@mndfck.org>\n+            Howard Hinnant <howard.hinnant@gmail.com>\n+\n+\tPR c++/7412\n+\tPR c++/29939\n+\t* typeck.c (comptypes): Don't consider rvalue and lvalue\n+\treference types to be equivalent.\n+\t(check_return_expr): Move from certain lvalues when returning\n+\tthem.\n+\t* decl.c (grokdeclarator): Implement reference collapsing.\n+\t(copy_fn_p): Don't consider constructors taking rvalue references\n+\tto be copy constructors.\n+\t(move_fn_p): New.\n+        * call.c (conversion): New \"rvaluedness_matches_p\" member.\n+\t(convert_class_to_reference): Require reference type as first\n+\tparameter instead of base type.\n+\t(reference_binding): Add logic to handle rvalue references.\n+\t(implicit_conversion): Update inaccurate comment.\n+\t(convert_like_real): Disable creation of temporaries that are\n+\timpossible to initialize for types with move constructors.\n+\t(build_over_call): Elide move constructors when possible.\n+\t(maybe_handle_implicit_object): Set \"rvaluedness_matches_p\".\n+\t(maybe_handle_ref_bind): Return conversion instead of type node.\n+\t(compare_ics): Add logic to use \"rvaluedness_matches_p\" values to\n+\tdetermine preferred conversion sequences.\n+\t* cp-tree.h (TYPE_REF_IS_RVALUE): New.\n+\t(LOOKUP_PREFER_RVALUE): New.\n+\t(DECL_MOVE_CONSTRUCTOR_P): New.\n+\t(struct cp_declarator): Add \"reference\" member for reference\n+\ttypes, with new \"rvalue_ref\" flag.\n+\t(cp_build_reference_type): Declare.\n+\t(move_fn_p): Declare.\n+\t* error.c (dump_type_prefix): Format rvalue reference types\n+\tcorrectly in error messages.\n+\t* except.c (build_throw): Move from certain lvalues when\n+\tthrowing.\n+\t* mangle.c (write_type): Mangle rvalue references differently\n+\tthan regular references.\n+\t* parser.c (make_reference_declarator): Add boolean parameter for\n+\trvalue references.\n+\t(cp_parser_make_indirect_declarator): New.\n+\t(cp_parser_new_declarator_opt): Call\n+\tcp_parser_make_indirect_declarator. \n+\t(cp_parser_conversion_declarator_opt): Ditto.\n+\t(cp_parser_declarator): Ditto.\n+\t(cp_parser_ptr_operator): Parse \"&&\" tokens into rvalue reference\n+\tdeclarators.\n+\t* pt.c (tsubst): Implement reference collapsing.\n+\t(maybe_adjust_types_for_deduction): Implement special template\n+\tparameter deduction rule for rvalue references.\n+\t(type_unification_real): Update calls to\n+\tmaybe_adjust_types_for_deduction.\n+\t(try_one_overload): Ditto.\n+\t(unify_pack_expansion): Ditto.\n+\t* tree.c (lvalue_p_1): Handle rvalue reference types.\n+\t(cp_build_reference_type): New.\n+\n 2007-05-30  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/31809"}, {"sha": "bf565fcb5eb235af4f3616647392566320e851e1", "filename": "gcc/cp/call.c", "status": "modified", "additions": 83, "deletions": 27, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -97,6 +97,10 @@ struct conversion {\n   /* If KIND is ck_ptr or ck_pmem, true to indicate that a conversion\n      from a pointer-to-derived to pointer-to-base is being performed.  */\n   BOOL_BITFIELD base_p : 1;\n+  /* If KIND is ck_ref_bind, true when either an lvalue reference is\n+     being bound to an lvalue expression or an rvalue reference is\n+     being bound to an rvalue expression. */\n+  BOOL_BITFIELD rvaluedness_matches_p: 1;\n   /* The type of the expression resulting from the conversion.  */\n   tree type;\n   union {\n@@ -176,7 +180,7 @@ static conversion *standard_conversion (tree, tree, tree, bool, int);\n static conversion *reference_binding (tree, tree, tree, bool, int);\n static conversion *build_conv (conversion_kind, tree, conversion *);\n static bool is_subseq (conversion *, conversion *);\n-static tree maybe_handle_ref_bind (conversion **);\n+static conversion *maybe_handle_ref_bind (conversion **);\n static void maybe_handle_implicit_object (conversion **);\n static struct z_candidate *add_candidate\n \t(struct z_candidate **, tree, tree, size_t,\n@@ -918,12 +922,12 @@ reference_compatible_p (tree t1, tree t2)\n    converted to T as in [over.match.ref].  */\n \n static conversion *\n-convert_class_to_reference (tree t, tree s, tree expr)\n+convert_class_to_reference (tree reference_type, tree s, tree expr)\n {\n   tree conversions;\n   tree arglist;\n   conversion *conv;\n-  tree reference_type;\n+  tree t;\n   struct z_candidate *candidates;\n   struct z_candidate *cand;\n   bool any_viable_p;\n@@ -957,7 +961,7 @@ convert_class_to_reference (tree t, tree s, tree expr)\n   arglist = build_int_cst (build_pointer_type (s), 0);\n   arglist = build_tree_list (NULL_TREE, arglist);\n \n-  reference_type = build_reference_type (t);\n+  t = TREE_TYPE (reference_type);\n \n   while (conversions)\n     {\n@@ -1020,6 +1024,9 @@ convert_class_to_reference (tree t, tree s, tree expr)\n \t      cand->second_conv\n \t\t= (direct_reference_binding\n \t\t   (reference_type, identity_conv));\n+\t      cand->second_conv->rvaluedness_matches_p\n+\t\t= TYPE_REF_IS_RVALUE (TREE_TYPE (TREE_TYPE (cand->fn)))\n+\t\t  == TYPE_REF_IS_RVALUE (reference_type);\n \t      cand->second_conv->bad_p |= cand->convs[0]->bad_p;\n \t    }\n \t}\n@@ -1146,7 +1153,16 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n     to = build_qualified_type (to, cp_type_quals (from));\n   compatible_p = reference_compatible_p (to, from);\n \n-  if (lvalue_p && compatible_p)\n+  /* Directly bind reference when target expression's type is compatible with\n+     the reference and expression is an lvalue. In C++0x, the wording in\n+     [8.5.3/5 dcl.init.ref] is changed to also allow direct bindings for const\n+     and rvalue references to rvalues of compatible class type, as part of\n+     DR391. */\n+  if (compatible_p\n+      && (lvalue_p\n+\t  || (flag_cpp0x\n+\t      && (CP_TYPE_CONST_NON_VOLATILE_P(to) || TYPE_REF_IS_RVALUE (rto))\n+\t      && CLASS_TYPE_P (from))))\n     {\n       /* [dcl.init.ref]\n \n@@ -1159,6 +1175,15 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \t lvalue.  */\n       conv = build_identity_conv (from, expr);\n       conv = direct_reference_binding (rto, conv);\n+\n+      if (flags & LOOKUP_PREFER_RVALUE)\n+\t/* The top-level caller requested that we pretend that the lvalue\n+\t   be treated as an rvalue.  */\n+\tconv->rvaluedness_matches_p = TYPE_REF_IS_RVALUE (rto);\n+      else\n+\tconv->rvaluedness_matches_p \n+          = (TYPE_REF_IS_RVALUE (rto) == !lvalue_p);\n+\n       if ((lvalue_p & clk_bitfield) != 0\n \t  || ((lvalue_p & clk_packed) != 0 && !TYPE_PACKED (to)))\n \t/* For the purposes of overload resolution, we ignore the fact\n@@ -1191,7 +1216,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \n \tthe reference is bound to the lvalue result of the conversion\n \tin the second case.  */\n-      conv = convert_class_to_reference (to, from, expr);\n+      conv = convert_class_to_reference (rto, from, expr);\n       if (conv)\n \treturn conv;\n     }\n@@ -1214,8 +1239,10 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n \n   /* [dcl.init.ref]\n \n-     Otherwise, the reference shall be to a non-volatile const type.  */\n-  if (!CP_TYPE_CONST_NON_VOLATILE_P (to))\n+     Otherwise, the reference shall be to a non-volatile const type.\n+\n+     Under C++0x, [8.5.3/5 dcl.init.ref] it may also be an rvalue reference */\n+  if (!CP_TYPE_CONST_NON_VOLATILE_P (to) && !TYPE_REF_IS_RVALUE (rto))\n     return NULL;\n \n   /* [dcl.init.ref]\n@@ -1238,6 +1265,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n     {\n       conv = build_identity_conv (from, expr);\n       conv = direct_reference_binding (rto, conv);\n+      conv->rvaluedness_matches_p = TYPE_REF_IS_RVALUE (rto);\n       if (!(flags & LOOKUP_CONSTRUCTOR_CALLABLE))\n \tconv->u.next->check_copy_constructor_p = true;\n       return conv;\n@@ -1262,6 +1290,7 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags)\n   /* This reference binding, unlike those above, requires the\n      creation of a temporary.  */\n   conv->need_temporary_p = true;\n+  conv->rvaluedness_matches_p = TYPE_REF_IS_RVALUE (rto);\n \n   return conv;\n }\n@@ -1303,7 +1332,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \tconv = cand->second_conv;\n \n       /* We used to try to bind a reference to a temporary here, but that\n-\t is now handled by the recursive call to this function at the end\n+\t is now handled after the recursive call to this function at the end\n \t of reference_binding.  */\n       return conv;\n     }\n@@ -4448,13 +4477,22 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       {\n \ttree ref_type = totype;\n \n-\t/* If necessary, create a temporary.  */\n-\tif (convs->need_temporary_p || !lvalue_p (expr))\n+\t/* If necessary, create a temporary. \n+\n+           VA_ARG_EXPR and CONSTRUCTOR expressions are special cases\n+           that need temporaries, even when their types are reference\n+           compatible with the type of reference being bound, so the\n+           upcoming call to build_unary_op (ADDR_EXPR, expr, ...)\n+           doesn't fail.  */\n+\tif (convs->need_temporary_p\n+\t    || TREE_CODE (expr) == CONSTRUCTOR\n+\t    || TREE_CODE (expr) == VA_ARG_EXPR)\n \t  {\n \t    tree type = convs->u.next->type;\n \t    cp_lvalue_kind lvalue = real_lvalue_p (expr);\n \n-\t    if (!CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (ref_type)))\n+\t    if (!CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (ref_type))\n+\t\t&& !TYPE_REF_IS_RVALUE (ref_type))\n \t      {\n \t\t/* If the reference is volatile or non-const, we\n \t\t   cannot create a temporary.  */\n@@ -4963,7 +5001,9 @@ build_over_call (struct z_candidate *cand, int flags)\n \n   if (! flag_elide_constructors)\n     /* Do things the hard way.  */;\n-  else if (cand->num_convs == 1 && DECL_COPY_CONSTRUCTOR_P (fn))\n+  else if (cand->num_convs == 1 \n+           && (DECL_COPY_CONSTRUCTOR_P (fn) \n+               || DECL_MOVE_CONSTRUCTOR_P (fn)))\n     {\n       tree targ;\n       arg = argarray[num_artificial_parms_for (fn)];\n@@ -5697,28 +5737,28 @@ maybe_handle_implicit_object (conversion **ics)\n \tt = t->u.next;\n       t = build_identity_conv (TREE_TYPE (t->type), NULL_TREE);\n       t = direct_reference_binding (reference_type, t);\n+      t->rvaluedness_matches_p = 1;\n       *ics = t;\n     }\n }\n \n /* If *ICS is a REF_BIND set *ICS to the remainder of the conversion,\n-   and return the type to which the reference refers.  Otherwise,\n-   leave *ICS unchanged and return NULL_TREE.  */\n+   and return the initial reference binding conversion. Otherwise,\n+   leave *ICS unchanged and return NULL.  */\n \n-static tree\n+static conversion *\n maybe_handle_ref_bind (conversion **ics)\n {\n   if ((*ics)->kind == ck_ref_bind)\n     {\n       conversion *old_ics = *ics;\n-      tree type = TREE_TYPE (old_ics->type);\n       *ics = old_ics->u.next;\n       (*ics)->user_conv_p = old_ics->user_conv_p;\n       (*ics)->bad_p = old_ics->bad_p;\n-      return type;\n+      return old_ics;\n     }\n \n-  return NULL_TREE;\n+  return NULL;\n }\n \n /* Compare two implicit conversion sequences according to the rules set out in\n@@ -5742,18 +5782,18 @@ compare_ics (conversion *ics1, conversion *ics2)\n   conversion_rank rank1, rank2;\n \n   /* REF_BINDING is nonzero if the result of the conversion sequence\n-     is a reference type.   In that case TARGET_TYPE is the\n-     type referred to by the reference.  */\n-  tree target_type1;\n-  tree target_type2;\n+     is a reference type.   In that case REF_CONV is the reference\n+     binding conversion. */\n+  conversion *ref_conv1;\n+  conversion *ref_conv2;\n \n   /* Handle implicit object parameters.  */\n   maybe_handle_implicit_object (&ics1);\n   maybe_handle_implicit_object (&ics2);\n \n   /* Handle reference parameters.  */\n-  target_type1 = maybe_handle_ref_bind (&ics1);\n-  target_type2 = maybe_handle_ref_bind (&ics2);\n+  ref_conv1 = maybe_handle_ref_bind (&ics1);\n+  ref_conv2 = maybe_handle_ref_bind (&ics2);\n \n   /* [over.ics.rank]\n \n@@ -6044,15 +6084,31 @@ compare_ics (conversion *ics1, conversion *ics2)\n \n   /* [over.ics.rank]\n \n+     --S1 and S2 are reference bindings (_dcl.init.ref_) and neither refers\n+     to an implicit object parameter, and either S1 binds an lvalue reference\n+     to an lvalue and S2 binds an rvalue reference or S1 binds an rvalue\n+     reference to an rvalue and S2 binds an lvalue reference\n+     (C++0x draft standard, 13.3.3.2)\n+\n      --S1 and S2 are reference bindings (_dcl.init.ref_), and the\n      types to which the references refer are the same type except for\n      top-level cv-qualifiers, and the type to which the reference\n      initialized by S2 refers is more cv-qualified than the type to\n      which the reference initialized by S1 refers */\n \n-  if (target_type1 && target_type2\n+  if (ref_conv1 && ref_conv2\n       && same_type_ignoring_top_level_qualifiers_p (to_type1, to_type2))\n-    return comp_cv_qualification (target_type2, target_type1);\n+    {\n+      if (ref_conv1->rvaluedness_matches_p\n+\t  && !ref_conv2->rvaluedness_matches_p)\n+\treturn 1;\n+      else if (!ref_conv1->rvaluedness_matches_p\n+\t  && ref_conv2->rvaluedness_matches_p)\n+\treturn -1;\n+\n+      return comp_cv_qualification (TREE_TYPE (ref_conv2->type),\n+\t\t\t\t    TREE_TYPE (ref_conv1->type));\n+    }\n \n   /* Neither conversion sequence is better than the other.  */\n   return 0;"}, {"sha": "5e5cc9ee0aea62bce4337c595aea331b0613961e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -57,6 +57,7 @@ struct diagnostic_context;\n       BASELINK_QUALIFIED_P (in BASELINK)\n       TARGET_EXPR_IMPLICIT_P (in TARGET_EXPR)\n       TEMPLATE_PARM_PARAMETER_PACK (in TEMPLATE_PARM_INDEX)\n+      TYPE_REF_IS_RVALUE (in REFERENCE_TYPE)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -1759,6 +1760,10 @@ struct lang_decl GTY(())\n #define DECL_COPY_CONSTRUCTOR_P(NODE) \\\n   (DECL_CONSTRUCTOR_P (NODE) && copy_fn_p (NODE) > 0)\n \n+/* Nonzero if NODE (a FUNCTION_DECL) is a move constructor.  */\n+#define DECL_MOVE_CONSTRUCTOR_P(NODE) \\\n+  (DECL_CONSTRUCTOR_P (NODE) && move_fn_p (NODE))\n+\n /* Nonzero if NODE is a destructor.  */\n #define DECL_DESTRUCTOR_P(NODE)\t\t\t\t\\\n   (DECL_LANG_SPECIFIC (NODE)->decl_flags.destructor_attr)\n@@ -2813,6 +2818,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define TYPE_REF_OBJ_P(NODE)\t\t\t\t\t\\\n   (TREE_CODE (NODE) == REFERENCE_TYPE && TYPE_OBJ_P (TREE_TYPE (NODE)))\n \n+/* True if reference type NODE is an rvalue reference */\n+#define TYPE_REF_IS_RVALUE(NODE) \\\n+  TREE_LANG_FLAG_0 (REFERENCE_TYPE_CHECK (NODE))\n+\n /* Returns true if NODE is a pointer to an object, or a pointer to\n    void.  Keep these checks in ascending tree code order.  */\n #define TYPE_PTROBV_P(NODE)\t\t\t\t\t\\\n@@ -3687,6 +3696,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n    (Normally, these entities are registered in the symbol table, but\n    not found by lookup.)  */\n #define LOOKUP_HIDDEN (LOOKUP_CONSTRUCTOR_CALLABLE << 1)\n+/* Prefer that the lvalue be treated as an rvalue.  */\n+#define LOOKUP_PREFER_RVALUE (LOOKUP_HIDDEN << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))\n@@ -4007,13 +4018,21 @@ struct cp_declarator {\n       /* The bounds to the array.  */\n       tree bounds;\n     } array;\n-    /* For cdk_pointer, cdk_reference, and cdk_ptrmem.  */\n+    /* For cdk_pointer and cdk_ptrmem.  */\n     struct {\n       /* The cv-qualifiers for the pointer.  */\n       cp_cv_quals qualifiers;\n       /* For cdk_ptrmem, the class type containing the member.  */\n       tree class_type;\n     } pointer;\n+    /* For cdk_reference */\n+    struct {\n+      /* The cv-qualifiers for the reference.  These qualifiers are\n+         only used to diagnose ill-formed code.  */\n+      cp_cv_quals qualifiers;\n+      /* Whether this is an rvalue reference */\n+      bool rvalue_ref;\n+    } reference;\n   } u;\n };\n \n@@ -4176,6 +4195,7 @@ extern tree build_ptrmem_type\t\t\t(tree, tree);\n /* the grokdeclarator prototype is in decl.h */\n extern tree build_this_parm\t\t\t(tree, cp_cv_quals);\n extern int copy_fn_p\t\t\t\t(tree);\n+extern bool move_fn_p                           (tree);\n extern tree get_scope_of_declarator\t\t(const cp_declarator *);\n extern void grok_special_member_properties\t(tree);\n extern int grok_ctor_properties\t\t\t(tree, tree);\n@@ -4684,6 +4704,7 @@ extern int is_dummy_object\t\t\t(tree);\n extern const struct attribute_spec cxx_attribute_table[];\n extern tree make_ptrmem_cst\t\t\t(tree, tree);\n extern tree cp_build_type_attribute_variant     (tree, tree);\n+extern tree cp_build_reference_type\t\t(tree, bool);\n extern tree cp_build_qualified_type_real\t(tree, int, tsubst_flags_t);\n #define cp_build_qualified_type(TYPE, QUALS) \\\n   cp_build_qualified_type_real ((TYPE), (QUALS), tf_warning_or_error)"}, {"sha": "f28ab092703d09645c0df8ca4da1b5dc1142b97d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 102, "deletions": 5, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -7794,10 +7794,24 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t  if (TREE_CODE (type) == REFERENCE_TYPE)\n \t    {\n-\t      error (declarator->kind == cdk_reference\n-\t\t     ? \"cannot declare reference to %q#T\"\n-\t\t     : \"cannot declare pointer to %q#T\", type);\n-\t      type = TREE_TYPE (type);\n+\t      if (declarator->kind != cdk_reference)\n+\t\t{\n+\t\t  error (\"cannot declare pointer to %q#T\", type);\n+\t\t  type = TREE_TYPE (type);\n+\t\t}\n+\n+\t      /* In C++0x, we allow reference to reference declarations\n+\t\t that occur indirectly through typedefs [7.1.3/8 dcl.typedef]\n+\t\t and template type arguments [14.3.1/4 temp.arg.type]. The\n+\t\t check for direct reference to reference declarations, which\n+\t\t are still forbidden, occurs below. Reasoning behind the change\n+\t\t can be found in DR106, DR540, and the rvalue reference\n+\t\t proposals. */\n+\t      else if (!flag_cpp0x)\n+\t\t{\n+\t\t  error (\"cannot declare reference to %q#T\", type);\n+\t\t  type = TREE_TYPE (type);\n+\t\t}\n \t    }\n \t  else if (VOID_TYPE_P (type))\n \t    {\n@@ -7823,8 +7837,39 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t  if (declarator->kind == cdk_reference)\n \t    {\n+\t      /* In C++0x, the type we are creating a reference to might be\n+\t\t a typedef which is itself a reference type. In that case,\n+\t\t we follow the reference collapsing rules in\n+\t\t [7.1.3/8 dcl.typedef] to create the final reference type:\n+\n+\t\t \"If a typedef TD names a type that is a reference to a type\n+\t\t T, an attempt to create the type 'lvalue reference to cv TD'\n+\t\t creates the type 'lvalue reference to T,' while an attempt\n+\t\t to create the type \"rvalue reference to cv TD' creates the\n+\t\t type TD.\"\n+              */\n \t      if (!VOID_TYPE_P (type))\n-\t\ttype = build_reference_type (type);\n+\t\ttype = cp_build_reference_type\n+\t\t       ((TREE_CODE (type) == REFERENCE_TYPE\n+\t\t\t ? TREE_TYPE (type) : type),\n+\t\t\t(declarator->u.reference.rvalue_ref\n+\t\t\t && (TREE_CODE(type) != REFERENCE_TYPE\n+\t\t\t     || TYPE_REF_IS_RVALUE (type))));\n+\n+\t      /* In C++0x, we need this check for direct reference to\n+\t\t reference declarations, which are forbidden by\n+\t\t [8.3.2/5 dcl.ref]. Reference to reference declarations\n+\t\t are only allowed indirectly through typedefs and template\n+\t\t type arguments. Example:\n+\n+\t\t   void foo(int & &);      // invalid ref-to-ref decl\n+\n+\t\t   typedef int & int_ref;\n+\t\t   void foo(int_ref &);    // valid ref-to-ref decl\n+\t      */\n+\t      if (inner_declarator && inner_declarator->kind == cdk_reference)\n+\t\terror (\"cannot declare reference to %q#T, which is not \"\n+\t\t       \"a typedef or a template type argument\", type);\n \t    }\n \t  else if (TREE_CODE (type) == METHOD_TYPE)\n \t    type = build_ptrmemfunc_type (build_pointer_type (type));\n@@ -9075,6 +9120,7 @@ copy_fn_p (tree d)\n       result = -1;\n     }\n   else if (TREE_CODE (arg_type) == REFERENCE_TYPE\n+\t   && !TYPE_REF_IS_RVALUE (arg_type)\n \t   && TYPE_MAIN_VARIANT (TREE_TYPE (arg_type)) == DECL_CONTEXT (d))\n     {\n       if (CP_TYPE_CONST_P (TREE_TYPE (arg_type)))\n@@ -9092,6 +9138,57 @@ copy_fn_p (tree d)\n   return result;\n }\n \n+/* D is a constructor or overloaded `operator='.\n+\n+   Let T be the class in which D is declared. Then, this function\n+   returns true when D is a move constructor or move assignment\n+   operator, false otherwise.  */\n+\n+bool\n+move_fn_p (tree d)\n+{\n+  tree args;\n+  tree arg_type;\n+  bool result = false;\n+\n+  gcc_assert (DECL_FUNCTION_MEMBER_P (d));\n+\n+  if (!flag_cpp0x)\n+    /* There are no move constructors if we aren't in C++0x mode.  */\n+    return false;\n+\n+  if (TREE_CODE (d) == TEMPLATE_DECL\n+      || (DECL_TEMPLATE_INFO (d)\n+         && DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (d))))\n+    /* Instantiations of template member functions are never copy\n+       functions.  Note that member functions of templated classes are\n+       represented as template functions internally, and we must\n+       accept those as copy functions.  */\n+    return 0;\n+\n+  args = FUNCTION_FIRST_USER_PARMTYPE (d);\n+  if (!args)\n+    return 0;\n+\n+  arg_type = TREE_VALUE (args);\n+  if (arg_type == error_mark_node)\n+    return 0;\n+\n+  if (TREE_CODE (arg_type) == REFERENCE_TYPE\n+      && TYPE_REF_IS_RVALUE (arg_type)\n+      && same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (arg_type)),\n+                      DECL_CONTEXT (d)))\n+    result = true;\n+\n+  args = TREE_CHAIN (args);\n+\n+  if (args && args != void_list_node && !TREE_PURPOSE (args))\n+    /* There are more non-optional args.  */\n+    return false;\n+\n+  return result;\n+}\n+\n /* Remember any special properties of member function DECL.  */\n \n void grok_special_member_properties (tree decl)"}, {"sha": "6121436a7949b53ca01cd9bf0a2041e56f847394", "filename": "gcc/cp/error.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -542,7 +542,15 @@ dump_type_prefix (tree t, int flags)\n \t    pp_cxx_whitespace (cxx_pp);\n \t    pp_cxx_left_paren (cxx_pp);\n \t  }\n-\tpp_character (cxx_pp, \"&*\"[TREE_CODE (t) == POINTER_TYPE]);\n+\tif (TREE_CODE (t) == POINTER_TYPE)\n+\t  pp_character(cxx_pp, '*');\n+\telse if (TREE_CODE (t) == REFERENCE_TYPE)\n+\t{\n+\t  if (TYPE_REF_IS_RVALUE (t))\n+\t    pp_string (cxx_pp, \"&&\");\n+\t  else\n+\t    pp_character (cxx_pp, '&');\n+\t}\n \tpp_base (cxx_pp)->padding = pp_before;\n \tpp_cxx_cv_qualifier_seq (cxx_pp, t);\n       }"}, {"sha": "059754f36cdfff16bb4dcb67ae3ba0d8b8e6d569", "filename": "gcc/cp/except.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -709,12 +709,25 @@ build_throw (tree exp)\n       /* And initialize the exception object.  */\n       if (CLASS_TYPE_P (temp_type))\n \t{\n+\t  int flags = LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING;\n+\n+\t  /* Under C++0x [12.8/16 class.copy], a thrown lvalue is sometimes\n+\t     treated as an rvalue for the purposes of overload resolution\n+\t     to favor move constructors over copy constructors.  */\n+\t  if (/* Must be a local, automatic variable.  */\n+\t      TREE_CODE (exp) == VAR_DECL\n+\t      && DECL_CONTEXT (exp) == current_function_decl\n+\t      && ! TREE_STATIC (exp)\n+\t      /* The variable must not have the `volatile' qualifier.  */\n+\t      && !(cp_type_quals (TREE_TYPE (exp)) & TYPE_QUAL_VOLATILE))\n+\t    flags = flags | LOOKUP_PREFER_RVALUE;\n+\n \t  /* Call the copy constructor.  */\n \t  exp = (build_special_member_call\n \t\t (object, complete_ctor_identifier,\n \t\t  build_tree_list (NULL_TREE, exp),\n \t\t  TREE_TYPE (object),\n-\t\t  LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING));\n+\t\t  flags));\n \t  if (exp == error_mark_node)\n \t    {\n \t      error (\"  in thrown expression\");"}, {"sha": "5a66b4603845ade09e240c3311061e76df21920c", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -1541,6 +1541,10 @@ write_local_name (const tree function, const tree local_entity,\n \t    ::= G <type>    # imaginary (C 2000)     [not supported]\n \t    ::= U <source-name> <type>   # vendor extended type qualifier\n \n+   C++0x extensions\n+\n+     <type> ::= RR <type>   # rvalue reference-to\n+\n    TYPE is a type node.  */\n \n static void\n@@ -1635,6 +1639,8 @@ write_type (tree type)\n \t  break;\n \n \tcase REFERENCE_TYPE:\n+\t  if (TYPE_REF_IS_RVALUE (type))\n+            write_char('R');\n \t  write_char ('R');\n \t  write_type (TREE_TYPE (type));\n \t  break;"}, {"sha": "c1a3276bb8eaadb6c8508aad8505b02dbf3f9bdb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 54, "deletions": 44, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -858,7 +858,7 @@ static cp_declarator *make_array_declarator\n static cp_declarator *make_pointer_declarator\n   (cp_cv_quals, cp_declarator *);\n static cp_declarator *make_reference_declarator\n-  (cp_cv_quals, cp_declarator *);\n+  (cp_cv_quals, cp_declarator *, bool);\n static cp_parameter_declarator *make_parameter_declarator\n   (cp_decl_specifier_seq *, cp_declarator *, tree);\n static cp_declarator *make_ptrmem_declarator\n@@ -960,14 +960,15 @@ make_pointer_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target)\n /* Like make_pointer_declarator -- but for references.  */\n \n cp_declarator *\n-make_reference_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target)\n+make_reference_declarator (cp_cv_quals cv_qualifiers, cp_declarator *target,\n+\t\t\t   bool rvalue_ref)\n {\n   cp_declarator *declarator;\n \n   declarator = make_declarator (cdk_reference);\n   declarator->declarator = target;\n-  declarator->u.pointer.qualifiers = cv_qualifiers;\n-  declarator->u.pointer.class_type = NULL_TREE;\n+  declarator->u.reference.qualifiers = cv_qualifiers;\n+  declarator->u.reference.rvalue_ref = rvalue_ref;\n   if (target)\n     {\n       declarator->parameter_pack_p = target->parameter_pack_p;\n@@ -2015,6 +2016,8 @@ static bool cp_parser_is_keyword\n   (cp_token *, enum rid);\n static tree cp_parser_make_typename_type\n   (cp_parser *, tree, tree);\n+static cp_declarator * cp_parser_make_indirect_declarator\n+  (enum tree_code, tree, cp_cv_quals, cp_declarator *);\n \n /* Returns nonzero if we are parsing tentatively.  */\n \n@@ -2689,6 +2692,27 @@ cp_parser_make_typename_type (cp_parser *parser, tree scope, tree id)\n   return make_typename_type (scope, id, typename_type, tf_error);\n }\n \n+/* This is a wrapper around the\n+   make_{pointer,ptrmem,reference}_declarator functions that decides\n+   which one to call based on the CODE and CLASS_TYPE arguments. The\n+   CODE argument should be one of the values returned by\n+   cp_parser_ptr_operator. */\n+static cp_declarator *\n+cp_parser_make_indirect_declarator (enum tree_code code, tree class_type,\n+\t\t\t\t    cp_cv_quals cv_qualifiers,\n+\t\t\t\t    cp_declarator *target)\n+{\n+  if (code == INDIRECT_REF)\n+    if (class_type == NULL_TREE)\n+      return make_pointer_declarator (cv_qualifiers, target);\n+    else\n+      return make_ptrmem_declarator (cv_qualifiers, class_type, target);\n+  else if (code == ADDR_EXPR && class_type == NULL_TREE)\n+    return make_reference_declarator (cv_qualifiers, target, false);\n+  else if (code == NON_LVALUE_EXPR && class_type == NULL_TREE)\n+    return make_reference_declarator (cv_qualifiers, target, true);\n+  gcc_unreachable ();\n+}\n \n /* Create a new C++ parser.  */\n \n@@ -5532,15 +5556,8 @@ cp_parser_new_declarator_opt (cp_parser* parser)\n       /* Parse another optional declarator.  */\n       declarator = cp_parser_new_declarator_opt (parser);\n \n-      /* Create the representation of the declarator.  */\n-      if (type)\n-\tdeclarator = make_ptrmem_declarator (cv_quals, type, declarator);\n-      else if (code == INDIRECT_REF)\n-\tdeclarator = make_pointer_declarator (cv_quals, declarator);\n-      else\n-\tdeclarator = make_reference_declarator (cv_quals, declarator);\n-\n-      return declarator;\n+      return cp_parser_make_indirect_declarator\n+\t(code, type, cv_quals, declarator);\n     }\n \n   /* If the next token is a `[', there is a direct-new-declarator.  */\n@@ -8460,16 +8477,8 @@ cp_parser_conversion_declarator_opt (cp_parser* parser)\n       /* Parse another optional declarator.  */\n       declarator = cp_parser_conversion_declarator_opt (parser);\n \n-      /* Create the representation of the declarator.  */\n-      if (class_type)\n-\tdeclarator = make_ptrmem_declarator (cv_quals, class_type,\n-\t\t\t\t\t     declarator);\n-      else if (code == INDIRECT_REF)\n-\tdeclarator = make_pointer_declarator (cv_quals, declarator);\n-      else\n-\tdeclarator = make_reference_declarator (cv_quals, declarator);\n-\n-      return declarator;\n+      return cp_parser_make_indirect_declarator\n+\t(code, class_type, cv_quals, declarator);\n    }\n \n   return NULL;\n@@ -12072,15 +12081,8 @@ cp_parser_declarator (cp_parser* parser,\n \t  && !cp_parser_parse_definitely (parser))\n \tdeclarator = NULL;\n \n-      /* Build the representation of the ptr-operator.  */\n-      if (class_type)\n-\tdeclarator = make_ptrmem_declarator (cv_quals,\n-\t\t\t\t\t     class_type,\n-\t\t\t\t\t     declarator);\n-      else if (code == INDIRECT_REF)\n-\tdeclarator = make_pointer_declarator (cv_quals, declarator);\n-      else\n-\tdeclarator = make_reference_declarator (cv_quals, declarator);\n+      declarator = cp_parser_make_indirect_declarator\n+\t(code, class_type, cv_quals, declarator);\n     }\n   /* Everything else is a direct-declarator.  */\n   else\n@@ -12558,12 +12560,15 @@ cp_parser_direct_declarator (cp_parser* parser,\n      & cv-qualifier-seq [opt]\n \n    Returns INDIRECT_REF if a pointer, or pointer-to-member, was used.\n-   Returns ADDR_EXPR if a reference was used.  In the case of a\n-   pointer-to-member, *TYPE is filled in with the TYPE containing the\n-   member.  *CV_QUALS is filled in with the cv-qualifier-seq, or\n-   TYPE_UNQUALIFIED, if there are no cv-qualifiers.  Returns\n-   ERROR_MARK if an error occurred.  */\n-\n+   Returns ADDR_EXPR if a reference was used, or NON_LVALUE_EXPR for\n+   an rvalue reference. In the case of a pointer-to-member, *TYPE is\n+   filled in with the TYPE containing the member.  *CV_QUALS is\n+   filled in with the cv-qualifier-seq, or TYPE_UNQUALIFIED, if there\n+   are no cv-qualifiers.  Returns ERROR_MARK if an error occurred.\n+   Note that the tree codes returned by this function have nothing\n+   to do with the types of trees that will be eventually be created\n+   to represent the pointer or reference type being parsed. They are\n+   just constants with suggestive names. */\n static enum tree_code\n cp_parser_ptr_operator (cp_parser* parser,\n \t\t\ttree* type,\n@@ -12579,13 +12584,18 @@ cp_parser_ptr_operator (cp_parser* parser,\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n-  /* If it's a `*' or `&' we have a pointer or reference.  */\n-  if (token->type == CPP_MULT || token->type == CPP_AND)\n-    {\n-      /* Remember which ptr-operator we were processing.  */\n-      code = (token->type == CPP_AND ? ADDR_EXPR : INDIRECT_REF);\n \n-      /* Consume the `*' or `&'.  */\n+  /* If it's a `*', `&' or `&&' we have a pointer or reference.  */\n+  if (token->type == CPP_MULT)\n+    code = INDIRECT_REF;\n+  else if (token->type == CPP_AND)\n+    code = ADDR_EXPR;\n+  else if (flag_cpp0x && token->type == CPP_AND_AND) /* C++0x only */\n+    code = NON_LVALUE_EXPR;\n+\n+  if (code != ERROR_MARK)\n+    {\n+      /* Consume the `*', `&' or `&&'.  */\n       cp_lexer_consume_token (parser->lexer);\n \n       /* A `*' can be followed by a cv-qualifier-seq, and so can a"}, {"sha": "47f3c0de05b2cc1aa09e7ba23f47ba7d6680225d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -114,7 +114,8 @@ static void tsubst_enum\t(tree, tree, tree);\n static tree add_to_template_args (tree, tree);\n static tree add_outermost_template_args (tree, tree);\n static bool check_instantiated_args (tree, tree, tsubst_flags_t);\n-static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*);\n+static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*,\n+\t\t\t\t\t     tree);\n static int  type_unification_real (tree, tree, tree, tree,\n \t\t\t\t   int, unification_kind_t, int);\n static void note_template_header (int);\n@@ -8729,8 +8730,13 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \n \t   -- Attempting to create a pointer to reference type.\n \t   -- Attempting to create a reference to a reference type or\n-\t      a reference to void.  */\n-\tif (TREE_CODE (type) == REFERENCE_TYPE\n+\t      a reference to void.\n+\n+\t  Core issue 106 says that creating a reference to a reference\n+\t  during instantiation is no longer a cause for failure. We\n+\t  only enforce this check in strict C++98 mode.  */\n+\tif ((TREE_CODE (type) == REFERENCE_TYPE\n+\t     && ((!flag_cpp0x && flag_iso) || code != REFERENCE_TYPE))\n \t    || (code == REFERENCE_TYPE && TREE_CODE (type) == VOID_TYPE))\n \t  {\n \t    static location_t last_loc;\n@@ -8764,8 +8770,22 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    if (TREE_CODE (type) == METHOD_TYPE)\n \t      r = build_ptrmemfunc_type (r);\n \t  }\n+\telse if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t  /* In C++0x, during template argument substitution, when there is an\n+\t     attempt to create a reference to a reference type, reference\n+\t     collapsing is applied as described in [14.3.1/4 temp.arg.type]:\n+\n+\t     \"If a template-argument for a template-parameter T names a type\n+\t     that is a reference to a type A, an attempt to create the type\n+\t     'lvalue reference to cv T' creates the type 'lvalue reference to\n+\t     A,' while an attempt to create the type type rvalue reference to\n+\t     cv T' creates the type T\"\n+\t  */\n+\t  r = cp_build_reference_type\n+\t      (TREE_TYPE (type),\n+\t       TYPE_REF_IS_RVALUE (t) && TYPE_REF_IS_RVALUE (type));\n \telse\n-\t  r = build_reference_type (type);\n+\t  r = cp_build_reference_type (type, TYPE_REF_IS_RVALUE (t));\n \tr = cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);\n \n \tif (r != error_mark_node)\n@@ -11231,12 +11251,14 @@ fn_type_unification (tree fn,\n    sections are symmetric.  PARM is the type of a function parameter\n    or the return type of the conversion function.  ARG is the type of\n    the argument passed to the call, or the type of the value\n-   initialized with the result of the conversion function.  */\n+   initialized with the result of the conversion function.\n+   ARG_EXPR is the original argument expression, which may be null.  */\n \n static int\n maybe_adjust_types_for_deduction (unification_kind_t strict,\n \t\t\t\t  tree* parm,\n-\t\t\t\t  tree* arg)\n+\t\t\t\t  tree* arg,\n+\t\t\t\t  tree arg_expr)\n {\n   int result = 0;\n \n@@ -11290,6 +11312,16 @@ maybe_adjust_types_for_deduction (unification_kind_t strict,\n \t*arg = TYPE_MAIN_VARIANT (*arg);\n     }\n \n+  /* From C++0x [14.8.2.1/3 temp.deduct.call] (after DR606), \"If P is\n+     of the form T&&, where T is a template parameter, and the argument\n+     is an lvalue, T is deduced as A& */\n+  if (TREE_CODE (*parm) == REFERENCE_TYPE\n+      && TYPE_REF_IS_RVALUE (*parm)\n+      && TREE_CODE (TREE_TYPE (*parm)) == TEMPLATE_TYPE_PARM\n+      && cp_type_quals (TREE_TYPE (*parm)) == TYPE_UNQUALIFIED\n+      && arg_expr && real_lvalue_p (arg_expr))\n+    *arg = build_reference_type (*arg);\n+\n   /* [temp.deduct.call]\n \n      If P is a cv-qualified type, the top level cv-qualifiers\n@@ -11326,7 +11358,7 @@ type_unification_real (tree tparms,\n \t\t       unification_kind_t strict,\n \t\t       int flags)\n {\n-  tree parm, arg;\n+  tree parm, arg, arg_expr;\n   int i;\n   int ntparms = TREE_VEC_LENGTH (tparms);\n   int sub_strict;\n@@ -11371,6 +11403,7 @@ type_unification_real (tree tparms,\n       parms = TREE_CHAIN (parms);\n       arg = TREE_VALUE (args);\n       args = TREE_CHAIN (args);\n+      arg_expr = NULL;\n \n       if (arg == error_mark_node)\n \treturn 1;\n@@ -11419,6 +11452,7 @@ type_unification_real (tree tparms,\n \t\treturn 1;\n \t      continue;\n \t    }\n+\t  arg_expr = arg;\n \t  arg = unlowered_expr_type (arg);\n \t  if (arg == error_mark_node)\n \t    return 1;\n@@ -11428,7 +11462,8 @@ type_unification_real (tree tparms,\n \tint arg_strict = sub_strict;\n \n \tif (!subr)\n-\t  arg_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg);\n+\t  arg_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg,\n+\t\t\t\t\t\t\t  arg_expr);\n \n \tif (unify (tparms, targs, parm, arg, arg_strict))\n \t  return 1;\n@@ -11678,7 +11713,7 @@ try_one_overload (tree tparms,\n   else if (addr_p)\n     arg = build_pointer_type (arg);\n \n-  sub_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg);\n+  sub_strict |= maybe_adjust_types_for_deduction (strict, &parm, &arg, NULL);\n \n   /* We don't copy orig_targs for this because if we have already deduced\n      some template args from previous args, unify would complain when we\n@@ -12014,7 +12049,7 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n \n             if (!subr)\n               arg_strict |= \n-                maybe_adjust_types_for_deduction (strict, &parm, &arg);\n+                maybe_adjust_types_for_deduction (strict, &parm, &arg, NULL);\n           }\n \n         if (!skip_arg_p)"}, {"sha": "dceb3f9fff273e398257b472d5a7246753e8ac4c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -64,8 +64,28 @@ lvalue_p_1 (tree ref,\n   cp_lvalue_kind op1_lvalue_kind = clk_none;\n   cp_lvalue_kind op2_lvalue_kind = clk_none;\n \n+  /* Expressions of reference type are sometimes wrapped in\n+     INDIRECT_REFs.  INDIRECT_REFs are just internal compiler\n+     representation, not part of the language, so we have to look\n+     through them.  */\n+  if (TREE_CODE (ref) == INDIRECT_REF\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (ref, 0)))\n+\t  == REFERENCE_TYPE)\n+    return lvalue_p_1 (TREE_OPERAND (ref, 0),\n+                       treat_class_rvalues_as_lvalues);\n+\n   if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n-    return clk_ordinary;\n+    {\n+      /* unnamed rvalue references are rvalues */\n+      if (TYPE_REF_IS_RVALUE (TREE_TYPE (ref))\n+\t  && TREE_CODE (ref) != PARM_DECL\n+\t  && TREE_CODE (ref) != VAR_DECL\n+\t  && TREE_CODE (ref) != COMPONENT_REF)\n+\treturn clk_none;\n+\n+      /* lvalue references and named rvalue refences are lvalues */\n+      return clk_ordinary;\n+    }\n \n   if (ref == current_class_ptr)\n     return clk_none;\n@@ -588,6 +608,53 @@ build_cplus_array_type (tree elt_type, tree index_type)\n \n   return t;\n }\n+\n+/* Return a reference type node referring to TO_TYPE.  If RVAL is\n+   true, return an rvalue reference type, otherwise return an lvalue\n+   reference type.  If a type node exists, reuse it, otherwise create\n+   a new one.  */\n+tree\n+cp_build_reference_type (tree to_type, bool rval)\n+{\n+  tree lvalue_ref, t;\n+  lvalue_ref = build_reference_type (to_type);\n+  if (!rval)\n+    return lvalue_ref;\n+\n+  /* This code to create rvalue reference types is based on and tied\n+     to the code creating lvalue reference types in the middle-end\n+     functions build_reference_type_for_mode and build_reference_type.\n+\n+     It works by putting the rvalue reference type nodes after the\n+     lvalue reference nodes in the TYPE_NEXT_REF_TO linked list, so\n+     they will effectively be ignored by the middle end.  */\n+\n+  for (t = lvalue_ref; (t = TYPE_NEXT_REF_TO (t)); )\n+    if (TYPE_REF_IS_RVALUE (t))\n+      return t;\n+\n+  t = copy_node (lvalue_ref);\n+\n+  TYPE_REF_IS_RVALUE (t) = true;\n+  TYPE_NEXT_REF_TO (t) = TYPE_NEXT_REF_TO (lvalue_ref);\n+  TYPE_NEXT_REF_TO (lvalue_ref) = t;\n+  TYPE_MAIN_VARIANT (t) = t;\n+\n+  if (TYPE_STRUCTURAL_EQUALITY_P (to_type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (t);\n+  else if (TYPE_CANONICAL (to_type) != to_type)\n+    TYPE_CANONICAL (t) \n+      = cp_build_reference_type (TYPE_CANONICAL (to_type), rval);\n+  else\n+    TYPE_CANONICAL (t) = t;\n+\n+  layout_type (t);\n+\n+  return t;\n+\n+}\n+\n+\n \f\n /* Make a variant of TYPE, qualified with the TYPE_QUALS.  Handles\n    arrays correctly.  In particular, if TYPE is an array of T's, and"}, {"sha": "5712ba810c1813a19f93581b517cd7bf24d409ca", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -1026,8 +1026,12 @@ structural_comptypes (tree t1, tree t2, int strict)\n \treturn false;\n       break;\n \n-    case POINTER_TYPE:\n     case REFERENCE_TYPE:\n+      if (TYPE_REF_IS_RVALUE (t1) != TYPE_REF_IS_RVALUE (t2))\n+\treturn false;\n+      /* fall through to checks for pointer types */\n+\n+    case POINTER_TYPE:\n       if (TYPE_MODE (t1) != TYPE_MODE (t2)\n \t  || TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2)\n \t  || !same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n@@ -6532,6 +6536,7 @@ check_return_expr (tree retval, bool *no_warning)\n      promotions.  */\n   tree valtype;\n   int fn_returns_value_p;\n+  bool named_return_value_okay_p;\n \n   *no_warning = false;\n \n@@ -6680,20 +6685,26 @@ check_return_expr (tree retval, bool *no_warning)\n \n      See finish_function and finalize_nrv for the rest of this optimization.  */\n \n+  named_return_value_okay_p = \n+    (retval != NULL_TREE\n+     /* Must be a local, automatic variable.  */\n+     && TREE_CODE (retval) == VAR_DECL\n+     && DECL_CONTEXT (retval) == current_function_decl\n+     && ! TREE_STATIC (retval)\n+     && (DECL_ALIGN (retval)\n+         >= DECL_ALIGN (DECL_RESULT (current_function_decl)))\n+     /* The cv-unqualified type of the returned value must be the\n+        same as the cv-unqualified return type of the\n+        function.  */\n+     && same_type_p ((TYPE_MAIN_VARIANT (TREE_TYPE (retval))),\n+                     (TYPE_MAIN_VARIANT\n+                      (TREE_TYPE (TREE_TYPE (current_function_decl))))));\n+     \n   if (fn_returns_value_p && flag_elide_constructors)\n     {\n-      if (retval != NULL_TREE\n-\t  && (current_function_return_value == NULL_TREE\n-\t      || current_function_return_value == retval)\n-\t  && TREE_CODE (retval) == VAR_DECL\n-\t  && DECL_CONTEXT (retval) == current_function_decl\n-\t  && ! TREE_STATIC (retval)\n-\t  && (DECL_ALIGN (retval)\n-\t      >= DECL_ALIGN (DECL_RESULT (current_function_decl)))\n-\t  && same_type_p ((TYPE_MAIN_VARIANT\n-\t\t\t   (TREE_TYPE (retval))),\n-\t\t\t  (TYPE_MAIN_VARIANT\n-\t\t\t   (TREE_TYPE (TREE_TYPE (current_function_decl))))))\n+      if (named_return_value_okay_p\n+          && (current_function_return_value == NULL_TREE\n+              || current_function_return_value == retval))\n \tcurrent_function_return_value = retval;\n       else\n \tcurrent_function_return_value = error_mark_node;\n@@ -6712,18 +6723,29 @@ check_return_expr (tree retval, bool *no_warning)\n     {\n       /* The type the function is declared to return.  */\n       tree functype = TREE_TYPE (TREE_TYPE (current_function_decl));\n+      int flags = LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING;\n \n       /* The functype's return type will have been set to void, if it\n \t was an incomplete type.  Just treat this as 'return;' */\n       if (VOID_TYPE_P (functype))\n \treturn error_mark_node;\n \n+      /* Under C++0x [12.8/16 class.copy], a returned lvalue is sometimes\n+\t treated as an rvalue for the purposes of overload resolution to\n+\t favor move constructors over copy constructors.  */\n+      if (flag_cpp0x \n+          && named_return_value_okay_p\n+          /* The variable must not have the `volatile' qualifier.  */\n+\t  && !(cp_type_quals (TREE_TYPE (retval)) & TYPE_QUAL_VOLATILE)\n+\t  /* The return type must be a class type.  */\n+\t  && CLASS_TYPE_P (TREE_TYPE (TREE_TYPE (current_function_decl))))\n+\tflags = flags | LOOKUP_PREFER_RVALUE;\n+\n       /* First convert the value to the function's return type, then\n \t to the type of return value's location to handle the\n \t case that functype is smaller than the valtype.  */\n       retval = convert_for_initialization\n-\t(NULL_TREE, functype, retval, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n-\t \"return\", NULL_TREE, 0);\n+\t(NULL_TREE, functype, retval, flags, \"return\", NULL_TREE, 0);\n       retval = convert (valtype, retval);\n \n       /* If the conversion failed, treat this just like `return;'.  */"}, {"sha": "4ebf0027742024de40d1ca94f166749dad4a1da8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -1,3 +1,52 @@\n+2007-05-30  Russell Yanofsky <russ@yanofsky.org>\n+            Douglas Gregor <doug.gregor@gmail.com>\n+            Pedro Lamarao <pedro.lamarao@mndfck.org>\n+            Howard Hinnant <howard.hinnant@gmail.com>\n+\n+\tPR c++/7412\n+\tPR c++/29939\n+        * g++.dg/cpp0x/rv8p.C: New.\n+        * g++.dg/cpp0x/temp-constructor-bug.C: New.\n+        * g++.dg/cpp0x/cast-bug.C: New.\n+        * g++.dg/cpp0x/elision_weak.C: New.\n+        * g++.dg/cpp0x/collapse-bug.C: New.\n+        * g++.dg/cpp0x/rv3p.C: New.\n+        * g++.dg/cpp0x/rv7n.C: New.\n+        * g++.dg/cpp0x/overload-conv-1.C: New.\n+        * g++.dg/cpp0x/rv2n.C: New.\n+        * g++.dg/cpp0x/deduce.C: New.\n+        * g++.dg/cpp0x/temp-va-arg-bug.C: New.\n+        * g++.dg/cpp0x/rv6p.C: New.\n+        * g++.dg/cpp0x/template_deduction.C: New.\n+        * g++.dg/cpp0x/implicit-copy.C: New.\n+        * g++.dg/cpp0x/rv1p.C: New.\n+        * g++.dg/cpp0x/cast.C: New.\n+        * g++.dg/cpp0x/rv5n.C: New.\n+        * g++.dg/cpp0x/collapse.C: New.\n+        * g++.dg/cpp0x/overload-conv-2.C: New.\n+        * g++.dg/cpp0x/rv4p.C: New.\n+\t* g++.dg/cpp0x/rvo.C: New.\n+        * g++.dg/cpp0x/iop.C: New.\n+        * g++.dg/cpp0x/rv3n.C: New.\n+        * g++.dg/cpp0x/rv7p.C: New.\n+        * g++.dg/cpp0x/reference_collapsing.C: New.\n+        * g++.dg/cpp0x/overload.C: New.\n+        * g++.dg/cpp0x/named.C: New.\n+        * g++.dg/cpp0x/rv2p.C: New.\n+        * g++.dg/cpp0x/rv6n.C: New.\n+        * g++.dg/cpp0x/not_special.C: New.\n+        * g++.dg/cpp0x/bind.C: New.\n+        * g++.dg/cpp0x/rv1n.C: New.\n+        * g++.dg/cpp0x/rv5p.C: New.\n+        * g++.dg/cpp0x/elision.C: New.\n+        * g++.dg/cpp0x/named_refs.C: New.\n+        * g++.dg/cpp0x/unnamed_refs.C: New.\n+        * g++.dg/cpp0x/rv4n.C: New.\n+        * g++.dg/cpp0x/elision_neg.C: New.\n+        * g++.dg/init/copy7.C: Run in C++98 mode.\n+        * g++.dg/overload/arg1.C: Ditto.\n+        * g++.dg/overload/arg4.C: Ditto.\n+\n 2007-05-30  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/31809"}, {"sha": "42a2ac203dba9d0d4890727c594ae9be996eb0fe", "filename": "gcc/testsuite/g++.dg/cpp0x/bind.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fbind.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fbind.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fbind.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,8 @@\n+// { dg-options \"--std=c++0x\" }\n+struct S{};\n+void f(S&&);\n+\n+int main()\n+{\n+  f(S());\n+}"}, {"sha": "211f88b2b19409139bc8b286592a8e2d4198eba1", "filename": "gcc/testsuite/g++.dg/cpp0x/cast-bug.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcast-bug.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcast-bug.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcast-bug.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options \"--std=c++0x\" }\n+struct S\n+{\n+  S();\n+  S(S &&);\n+private:\n+  S(S &);\n+};\n+\n+S f()\n+{\n+  S s;\n+  return static_cast<S&&>(s);\n+}"}, {"sha": "4cc7f2edcf85e5634db7e9ea57a12ad4a8e78970", "filename": "gcc/testsuite/g++.dg/cpp0x/cast.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcast.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcast.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcast.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,30 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test cast from lvalue to rvalue\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+\n+struct A {};\n+\n+one foo(const A&) {return one();}\n+two foo(A&&)      {return two();}\n+\n+int test1()\n+{\n+    A a;\n+    sa<sizeof(foo(a)) == 1> t1;\n+    sa<sizeof(foo(static_cast<A&&>(a))) == 2> t2;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test1();\n+}"}, {"sha": "02a59cd1d21f5bec20f10090391642503f843ef9", "filename": "gcc/testsuite/g++.dg/cpp0x/collapse-bug.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcollapse-bug.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcollapse-bug.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcollapse-bug.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,16 @@\n+// { dg-options \"--std=c++0x\" }\n+template<typename T, typename U> struct same_type;\n+template<typename T> struct same_type<T, T> {};\n+\n+template <typename T>\n+struct S\n+{\n+  typedef T const (&type)();\n+};\n+\n+void f()\n+{\n+  // initial implementation didn't ignore const qualifier on\n+  // reference, resulting in a typedef of 'const int& (&)()'\n+  same_type<S<int &>::type, int&(&)()>();\n+}"}, {"sha": "96c32732461f58071db41b3a1f622d0f494603a8", "filename": "gcc/testsuite/g++.dg/cpp0x/collapse.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcollapse.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcollapse.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fcollapse.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"--std=c++0x\" }\n+template<typename T, typename U> struct same_type;\n+template<typename T> struct same_type<T, T> {};\n+\n+typedef int & lref;\n+typedef int const & clref;\n+typedef int && rref;\n+typedef int const && crref;\n+\n+template<typename T>\n+struct S\n+{\n+  typedef T & lref;\n+  typedef T const & clref;\n+  typedef T && rref;\n+  typedef T const && crref;\n+};\n+\n+void f()\n+{\n+  same_type<lref &, int &>();\n+  same_type<lref &&, int &>();\n+  same_type<rref &, int &>();\n+  same_type<rref &&, int &&>();\n+\n+  same_type<rref const &, int &>();\n+  same_type<crref volatile &&, int const &&>();\n+  same_type<clref const &&, int const &>();\n+\n+  same_type<S<int &>::lref &, int &>();\n+  same_type<S<int &&>::lref &&, int &>();\n+  same_type<S<int &>::rref &, int &>();\n+  same_type<S<int &&>::rref &&, int &&>();\n+\n+  same_type<S<int const &>::rref, int const &>();\n+  same_type<S<int volatile &&>::crref, int volatile &&>();\n+  same_type<S<int const &&>::clref, int const &>();\n+}"}, {"sha": "6bd05160898e113e2e40f70670769c2f9d32a428", "filename": "gcc/testsuite/g++.dg/cpp0x/deduce.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdeduce.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdeduce.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdeduce.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"--std=c++0x\" }\n+template<typename T, typename U> struct same_type;\n+template<typename T> struct same_type<T, T> {};\n+\n+int lval_int;\n+int rval_int();\n+int const lval_const_int=0;\n+int const rval_const_int();\n+\n+template <typename T> void deduce_lval_int(T && t)\n+{\n+  same_type<T, int &>();\n+}\n+\n+template <typename T> void deduce_rval_int(T && t)\n+{\n+  same_type<T, int>();\n+}\n+\n+template <typename T> void deduce_lval_const_int(T && t)\n+{\n+  same_type<T, const int &>();\n+}\n+\n+template <typename T> void deduce_rval_const_int(T && t)\n+{\n+  same_type<T, const int>();\n+}\n+\n+void f()\n+{\n+  deduce_lval_int(lval_int);\n+  deduce_rval_int(rval_int());\n+  deduce_lval_const_int(lval_const_int);\n+  deduce_rval_const_int(rval_const_int());\n+}"}, {"sha": "35d5e4b02fb4dc827592440ef1aae93ae70df097", "filename": "gcc/testsuite/g++.dg/cpp0x/elision.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,76 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test: Implicit cast to rvalue when eliding copy\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+\n+class move_only\n+{\n+    move_only(const move_only&);\n+    move_only& operator=(const move_only&);\n+public:\n+    move_only() {}\n+    move_only(move_only&&) {}\n+    move_only& operator=(move_only&&) {return *this;}\n+};\n+\n+move_only\n+test1()\n+{\n+    return move_only();\n+}\n+\n+move_only\n+test2()\n+{\n+    move_only x;\n+    return x;\n+}\n+\n+move_only\n+test3(bool b)\n+{\n+    move_only x1;\n+    if (b)\n+    {\n+        move_only x2;\n+        return x2;\n+    }\n+    return x1;\n+}\n+\n+void\n+test4(bool b)\n+{\n+    if (!b)\n+        throw move_only();\n+}\n+\n+void\n+test5(bool b)\n+{\n+    move_only x;\n+    if (!b)\n+        throw x;\n+}\n+\n+extern bool b;\n+\n+int main()\n+{\n+    move_only t1 = test1();\n+    move_only t2 = test2();\n+    move_only t3 = test3(b);\n+    test4(b);\n+    test5(b);\n+    return 0;\n+}\n+\n+bool b = true;"}, {"sha": "78feac72a5bec8edc76cc6dac0e624c5c31fc777", "filename": "gcc/testsuite/g++.dg/cpp0x/elision_neg.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_neg.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,44 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test: Implicit cast to rvalue when eliding copy\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+\n+class move_only\n+{\n+    move_only(const move_only&); // { dg-error \"is private\" }\n+    move_only& operator=(const move_only&);\n+public:\n+    move_only() {}\n+    move_only(move_only&&) {}\n+    move_only& operator=(move_only&&) {return *this;}\n+};\n+\n+move_only\n+test1()\n+{\n+    static move_only x;\n+    return x;  //  { dg-error \"within this context\" }\n+}\n+\n+move_only\n+test2(move_only&& x)\n+{\n+    return x;  //  { dg-error \"within this context\" }\n+}\n+\n+int main()\n+{\n+    move_only t1 = test1();\n+    move_only t2 = test2(move_only());\n+    return 0;\n+}\n+\n+bool b = true;"}, {"sha": "e8ba7551d84e9c87499e09f632a4ae727cae7470", "filename": "gcc/testsuite/g++.dg/cpp0x/elision_weak.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_weak.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_weak.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_weak.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+\n+struct S\n+{\n+  S() {}\n+  S(S&) {}\n+};\n+\n+S f()\n+{\n+  S s;\n+  return s;\n+}\n+\n+void g()\n+{\n+  S s;\n+  throw s;\n+}"}, {"sha": "ea680a8961b1542aedd75532a9c087c8dd4f760d", "filename": "gcc/testsuite/g++.dg/cpp0x/implicit-copy.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit-copy.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit-copy.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fimplicit-copy.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"--std=c++0x\" }\n+struct S\n+{\n+  S();\n+private:\n+  S(S const &&);\n+  S & operator=(S const &&);\n+};\n+\n+void f()\n+{\n+  S a;\n+  S b(a);\n+  a = b;\n+}"}, {"sha": "5aecf9f504e6f9da7151b9e76d041c65b91d798c", "filename": "gcc/testsuite/g++.dg/cpp0x/iop.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fiop.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fiop.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fiop.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,41 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test that the implicit object parameter is *not* an rvalue reference, but is instead\n+//   identical to that specified in C++03.  That is, the implicit object parameter is\n+//   an lvalue reference that can bind to an rvalue. :-\\\n+//   See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html under the\n+//   section \"Revision 1 Summary and Rationale\" for more details.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+\n+struct os\n+{\n+    one operator<<(int);\n+};\n+\n+struct A\n+{\n+    A(int);\n+};\n+\n+two operator<<(os&, const A&);\n+\n+void test()\n+{\n+    os o;\n+    sa<sizeof(o << 1) == 1> t1;  // Calls os::operator<<(int)\n+                                 // Would be ambiguous if the implicit object parameter\n+                                 // was an rvalue reference.\n+}\n+\n+int main()\n+{\n+    return 0;\n+}"}, {"sha": "b91e6989425fb8697877e8ceef79b5c8dfbef3e1", "filename": "gcc/testsuite/g++.dg/cpp0x/named.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnamed.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnamed.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnamed.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"--std=c++0x\" }\n+// { dg-do link }\n+\n+struct S {};\n+struct T\n+{\n+  T(S && s_) : s(s_) {}\n+  S && get() { return s; }\n+  operator S&&() { return s; }\n+  S && s;\n+};\n+\n+void named(S const &) {}\n+void named(S&&);\n+\n+void unnamed(S const &);\n+void unnamed(S&&) {}\n+\n+void f(S && p)\n+{\n+  S && s(p);\n+  T t(s);\n+\n+  named(s);                          // variable reference\n+  named(p);                          // parameter reference\n+  named(t.s);                        // class member access\n+\n+  unnamed(t.get());                  // function return\n+  unnamed(t);                        // implicit conversion\n+  unnamed(static_cast<S&&>(s));      // cast to rvalue\n+}\n+\n+int main()\n+{\n+}"}, {"sha": "96d7e787f0608c5b98f740966d96ea8f4ca90d10", "filename": "gcc/testsuite/g++.dg/cpp0x/named_refs.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnamed_refs.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnamed_refs.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnamed_refs.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,28 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test: Named rvalue references are treated as lvalues.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+\n+struct A {};\n+\n+one foo(const A&) {return one();}\n+two foo(A&&)      {return two();}\n+\n+int test1(A&& a)\n+{\n+    sa<sizeof(foo(a)) == 1> t1;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test1(A());\n+}"}, {"sha": "f94b82a0c1a369f9ff0cfd36a8f050a130c217b5", "filename": "gcc/testsuite/g++.dg/cpp0x/not_special.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnot_special.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnot_special.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnot_special.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,54 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test that move constructor and move assignement are not special.\n+//   That is, their presence should not inhibit compiler generated\n+//   copy ctor or assignment.  Rather they should overload with the\n+//   compiler generated special members.\n+\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <assert.h>\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+\n+int copy = 0;\n+int assign = 0;\n+\n+struct base\n+{\n+    base() {}\n+    base(const base&) {++copy;}\n+    base& operator=(const base&) {++assign; return *this;}\n+};\n+\n+struct derived\n+    : base\n+{\n+    derived() {}\n+    derived(derived&&) {}\n+    derived& operator=(derived&&) {return *this;}\n+};\n+\n+int test1()\n+{\n+    derived d;\n+    derived d2(static_cast<derived&&>(d));  // should not call base::(const base&)\n+    assert(copy == 0);\n+    derived d3(d);                          // should     call base::(const base&)\n+    assert(copy == 1);\n+    d2 = static_cast<derived&&>(d);         // should not call base::operator=\n+    assert(assign == 0);\n+    d3 = d;                                 // should     call base::operator=\n+    assert(assign == 1);\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test1();\n+}"}, {"sha": "778111283ff5c8b84af30ef3a5d9b21415df9777", "filename": "gcc/testsuite/g++.dg/cpp0x/overload-conv-1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload-conv-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload-conv-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload-conv-1.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"--std=c++0x\" }\n+// { dg-do link }\n+\n+struct S {};\n+\n+struct T\n+{\n+  operator S() { return S(); }\n+};\n+\n+struct U\n+{\n+  operator S&() { return *static_cast<S*>(0); }\n+};\n+\n+void f(const S&);\n+void f(S&&) {}\n+\n+void g(const S&) {}\n+void g(S&&);\n+\n+int main()\n+{\n+  T t;\n+  f(t);\n+\n+  U u;\n+  g(u);\n+}"}, {"sha": "0e622bcacb25f6bc452ad497db3cdd56a482d1a8", "filename": "gcc/testsuite/g++.dg/cpp0x/overload-conv-2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload-conv-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload-conv-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload-conv-2.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options \"--std=c++0x\" }\n+// { dg-do link }\n+\n+struct T {};\n+struct S\n+{\n+  S(T const &) {}\n+};\n+\n+void f(const S&);\n+void f(S&&) {}\n+\n+int main()\n+{\n+  T t;\n+  f(t);\n+}"}, {"sha": "945860cddb1acdfd6456687396fd2ca7d28e0643", "filename": "gcc/testsuite/g++.dg/cpp0x/overload.C", "status": "added", "additions": 703, "deletions": 0, "changes": 703, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Foverload.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,703 @@\n+// { dg-options \"--std=c++0x\" }\n+// { dg-do link }\n+// Generated by overload.py\n+\n+struct S{};\n+\n+S l;                             // lvalue (l)\n+S const cl = l;                  // const lvalue (cl)\n+S r() { return l; }              // rvalue (r)\n+S const cr() { return l; }       // const rvalue (cr)\n+S & nl = l;                      // named lvalue reference (nl)\n+S const & ncl = l;               // named const lvalue reference (ncl)\n+S && nr = l;                     // named rvalue reference (nr)\n+S const && ncr = l;              // named const rvalue reference (ncr)\n+S & ul() { return l; }           // unnamed lvalue reference (ul)\n+S const & ucl() { return l; }    // unnamed const lvalue reference (ucl)\n+S && ur() { return l; }          // unnamed rvalue reference (ur)\n+S const && ucr() { return l; }   // unnamed const rvalue reference (ucr)\n+\n+void l0001(const S&&) {}\n+\n+void l0010(S&&) {}\n+\n+void l0011(S&&) {}\n+void l0011(const S&&);\n+\n+void l0100(const S&) {}\n+\n+void l0101(const S&) {}\n+void l0101(const S&&);\n+\n+void l0110(const S&) {}\n+void l0110(S&&);\n+\n+void l0111(const S&) {}\n+void l0111(S&&);\n+void l0111(const S&&);\n+\n+void l1000(S&) {}\n+\n+void l1001(S&) {}\n+void l1001(const S&&);\n+\n+void l1010(S&) {}\n+void l1010(S&&);\n+\n+void l1011(S&) {}\n+void l1011(S&&);\n+void l1011(const S&&);\n+\n+void l1100(S&) {}\n+void l1100(const S&);\n+\n+void l1101(S&) {}\n+void l1101(const S&);\n+void l1101(const S&&);\n+\n+void l1110(S&) {}\n+void l1110(const S&);\n+void l1110(S&&);\n+\n+void l1111(S&) {}\n+void l1111(const S&);\n+void l1111(S&&);\n+void l1111(const S&&);\n+\n+void cl0001(const S&&) {}\n+\n+void cl0011(S&&);\n+void cl0011(const S&&) {}\n+\n+void cl0100(const S&) {}\n+\n+void cl0101(const S&) {}\n+void cl0101(const S&&);\n+\n+void cl0110(const S&) {}\n+void cl0110(S&&);\n+\n+void cl0111(const S&) {}\n+void cl0111(S&&);\n+void cl0111(const S&&);\n+\n+void cl1001(S&);\n+void cl1001(const S&&) {}\n+\n+void cl1011(S&);\n+void cl1011(S&&);\n+void cl1011(const S&&) {}\n+\n+void cl1100(S&);\n+void cl1100(const S&) {}\n+\n+void cl1101(S&);\n+void cl1101(const S&) {}\n+void cl1101(const S&&);\n+\n+void cl1110(S&);\n+void cl1110(const S&) {}\n+void cl1110(S&&);\n+\n+void cl1111(S&);\n+void cl1111(const S&) {}\n+void cl1111(S&&);\n+void cl1111(const S&&);\n+\n+void r0001(const S&&) {}\n+\n+void r0010(S&&) {}\n+\n+void r0011(S&&) {}\n+void r0011(const S&&);\n+\n+void r0100(const S&) {}\n+\n+void r0101(const S&);\n+void r0101(const S&&) {}\n+\n+void r0110(const S&);\n+void r0110(S&&) {}\n+\n+void r0111(const S&);\n+void r0111(S&&) {}\n+void r0111(const S&&);\n+\n+void r1001(S&);\n+void r1001(const S&&) {}\n+\n+void r1010(S&);\n+void r1010(S&&) {}\n+\n+void r1011(S&);\n+void r1011(S&&) {}\n+void r1011(const S&&);\n+\n+void r1100(S&);\n+void r1100(const S&) {}\n+\n+void r1101(S&);\n+void r1101(const S&);\n+void r1101(const S&&) {}\n+\n+void r1110(S&);\n+void r1110(const S&);\n+void r1110(S&&) {}\n+\n+void r1111(S&);\n+void r1111(const S&);\n+void r1111(S&&) {}\n+void r1111(const S&&);\n+\n+void cr0001(const S&&) {}\n+\n+void cr0011(S&&);\n+void cr0011(const S&&) {}\n+\n+void cr0100(const S&) {}\n+\n+void cr0101(const S&);\n+void cr0101(const S&&) {}\n+\n+void cr0110(const S&) {}\n+void cr0110(S&&);\n+\n+void cr0111(const S&);\n+void cr0111(S&&);\n+void cr0111(const S&&) {}\n+\n+void cr1001(S&);\n+void cr1001(const S&&) {}\n+\n+void cr1011(S&);\n+void cr1011(S&&);\n+void cr1011(const S&&) {}\n+\n+void cr1100(S&);\n+void cr1100(const S&) {}\n+\n+void cr1101(S&);\n+void cr1101(const S&);\n+void cr1101(const S&&) {}\n+\n+void cr1110(S&);\n+void cr1110(const S&) {}\n+void cr1110(S&&);\n+\n+void cr1111(S&);\n+void cr1111(const S&);\n+void cr1111(S&&);\n+void cr1111(const S&&) {}\n+\n+void nl0001(const S&&) {}\n+\n+void nl0010(S&&) {}\n+\n+void nl0011(S&&) {}\n+void nl0011(const S&&);\n+\n+void nl0100(const S&) {}\n+\n+void nl0101(const S&) {}\n+void nl0101(const S&&);\n+\n+void nl0110(const S&) {}\n+void nl0110(S&&);\n+\n+void nl0111(const S&) {}\n+void nl0111(S&&);\n+void nl0111(const S&&);\n+\n+void nl1000(S&) {}\n+\n+void nl1001(S&) {}\n+void nl1001(const S&&);\n+\n+void nl1010(S&) {}\n+void nl1010(S&&);\n+\n+void nl1011(S&) {}\n+void nl1011(S&&);\n+void nl1011(const S&&);\n+\n+void nl1100(S&) {}\n+void nl1100(const S&);\n+\n+void nl1101(S&) {}\n+void nl1101(const S&);\n+void nl1101(const S&&);\n+\n+void nl1110(S&) {}\n+void nl1110(const S&);\n+void nl1110(S&&);\n+\n+void nl1111(S&) {}\n+void nl1111(const S&);\n+void nl1111(S&&);\n+void nl1111(const S&&);\n+\n+void ncl0001(const S&&) {}\n+\n+void ncl0011(S&&);\n+void ncl0011(const S&&) {}\n+\n+void ncl0100(const S&) {}\n+\n+void ncl0101(const S&) {}\n+void ncl0101(const S&&);\n+\n+void ncl0110(const S&) {}\n+void ncl0110(S&&);\n+\n+void ncl0111(const S&) {}\n+void ncl0111(S&&);\n+void ncl0111(const S&&);\n+\n+void ncl1001(S&);\n+void ncl1001(const S&&) {}\n+\n+void ncl1011(S&);\n+void ncl1011(S&&);\n+void ncl1011(const S&&) {}\n+\n+void ncl1100(S&);\n+void ncl1100(const S&) {}\n+\n+void ncl1101(S&);\n+void ncl1101(const S&) {}\n+void ncl1101(const S&&);\n+\n+void ncl1110(S&);\n+void ncl1110(const S&) {}\n+void ncl1110(S&&);\n+\n+void ncl1111(S&);\n+void ncl1111(const S&) {}\n+void ncl1111(S&&);\n+void ncl1111(const S&&);\n+\n+void nr0001(const S&&) {}\n+\n+void nr0010(S&&) {}\n+\n+void nr0011(S&&) {}\n+void nr0011(const S&&);\n+\n+void nr0100(const S&) {}\n+\n+void nr0101(const S&) {}\n+void nr0101(const S&&);\n+\n+void nr0110(const S&) {}\n+void nr0110(S&&);\n+\n+void nr0111(const S&) {}\n+void nr0111(S&&);\n+void nr0111(const S&&);\n+\n+void nr1000(S&) {}\n+\n+void nr1001(S&) {}\n+void nr1001(const S&&);\n+\n+void nr1010(S&) {}\n+void nr1010(S&&);\n+\n+void nr1011(S&) {}\n+void nr1011(S&&);\n+void nr1011(const S&&);\n+\n+void nr1100(S&) {}\n+void nr1100(const S&);\n+\n+void nr1101(S&) {}\n+void nr1101(const S&);\n+void nr1101(const S&&);\n+\n+void nr1110(S&) {}\n+void nr1110(const S&);\n+void nr1110(S&&);\n+\n+void nr1111(S&) {}\n+void nr1111(const S&);\n+void nr1111(S&&);\n+void nr1111(const S&&);\n+\n+void ncr0001(const S&&) {}\n+\n+void ncr0011(S&&);\n+void ncr0011(const S&&) {}\n+\n+void ncr0100(const S&) {}\n+\n+void ncr0101(const S&) {}\n+void ncr0101(const S&&);\n+\n+void ncr0110(const S&) {}\n+void ncr0110(S&&);\n+\n+void ncr0111(const S&) {}\n+void ncr0111(S&&);\n+void ncr0111(const S&&);\n+\n+void ncr1001(S&);\n+void ncr1001(const S&&) {}\n+\n+void ncr1011(S&);\n+void ncr1011(S&&);\n+void ncr1011(const S&&) {}\n+\n+void ncr1100(S&);\n+void ncr1100(const S&) {}\n+\n+void ncr1101(S&);\n+void ncr1101(const S&) {}\n+void ncr1101(const S&&);\n+\n+void ncr1110(S&);\n+void ncr1110(const S&) {}\n+void ncr1110(S&&);\n+\n+void ncr1111(S&);\n+void ncr1111(const S&) {}\n+void ncr1111(S&&);\n+void ncr1111(const S&&);\n+\n+void ul0001(const S&&) {}\n+\n+void ul0010(S&&) {}\n+\n+void ul0011(S&&) {}\n+void ul0011(const S&&);\n+\n+void ul0100(const S&) {}\n+\n+void ul0101(const S&) {}\n+void ul0101(const S&&);\n+\n+void ul0110(const S&) {}\n+void ul0110(S&&);\n+\n+void ul0111(const S&) {}\n+void ul0111(S&&);\n+void ul0111(const S&&);\n+\n+void ul1000(S&) {}\n+\n+void ul1001(S&) {}\n+void ul1001(const S&&);\n+\n+void ul1010(S&) {}\n+void ul1010(S&&);\n+\n+void ul1011(S&) {}\n+void ul1011(S&&);\n+void ul1011(const S&&);\n+\n+void ul1100(S&) {}\n+void ul1100(const S&);\n+\n+void ul1101(S&) {}\n+void ul1101(const S&);\n+void ul1101(const S&&);\n+\n+void ul1110(S&) {}\n+void ul1110(const S&);\n+void ul1110(S&&);\n+\n+void ul1111(S&) {}\n+void ul1111(const S&);\n+void ul1111(S&&);\n+void ul1111(const S&&);\n+\n+void ucl0001(const S&&) {}\n+\n+void ucl0011(S&&);\n+void ucl0011(const S&&) {}\n+\n+void ucl0100(const S&) {}\n+\n+void ucl0101(const S&) {}\n+void ucl0101(const S&&);\n+\n+void ucl0110(const S&) {}\n+void ucl0110(S&&);\n+\n+void ucl0111(const S&) {}\n+void ucl0111(S&&);\n+void ucl0111(const S&&);\n+\n+void ucl1001(S&);\n+void ucl1001(const S&&) {}\n+\n+void ucl1011(S&);\n+void ucl1011(S&&);\n+void ucl1011(const S&&) {}\n+\n+void ucl1100(S&);\n+void ucl1100(const S&) {}\n+\n+void ucl1101(S&);\n+void ucl1101(const S&) {}\n+void ucl1101(const S&&);\n+\n+void ucl1110(S&);\n+void ucl1110(const S&) {}\n+void ucl1110(S&&);\n+\n+void ucl1111(S&);\n+void ucl1111(const S&) {}\n+void ucl1111(S&&);\n+void ucl1111(const S&&);\n+\n+void ur0001(const S&&) {}\n+\n+void ur0010(S&&) {}\n+\n+void ur0011(S&&) {}\n+void ur0011(const S&&);\n+\n+void ur0100(const S&) {}\n+\n+void ur0101(const S&);\n+void ur0101(const S&&) {}\n+\n+void ur0110(const S&);\n+void ur0110(S&&) {}\n+\n+void ur0111(const S&);\n+void ur0111(S&&) {}\n+void ur0111(const S&&);\n+\n+void ur1001(S&);\n+void ur1001(const S&&) {}\n+\n+void ur1010(S&);\n+void ur1010(S&&) {}\n+\n+void ur1011(S&);\n+void ur1011(S&&) {}\n+void ur1011(const S&&);\n+\n+void ur1100(S&);\n+void ur1100(const S&) {}\n+\n+void ur1101(S&);\n+void ur1101(const S&);\n+void ur1101(const S&&) {}\n+\n+void ur1110(S&);\n+void ur1110(const S&);\n+void ur1110(S&&) {}\n+\n+void ur1111(S&);\n+void ur1111(const S&);\n+void ur1111(S&&) {}\n+void ur1111(const S&&);\n+\n+void ucr0001(const S&&) {}\n+\n+void ucr0011(S&&);\n+void ucr0011(const S&&) {}\n+\n+void ucr0100(const S&) {}\n+\n+void ucr0101(const S&);\n+void ucr0101(const S&&) {}\n+\n+void ucr0110(const S&) {}\n+void ucr0110(S&&);\n+\n+void ucr0111(const S&);\n+void ucr0111(S&&);\n+void ucr0111(const S&&) {}\n+\n+void ucr1001(S&);\n+void ucr1001(const S&&) {}\n+\n+void ucr1011(S&);\n+void ucr1011(S&&);\n+void ucr1011(const S&&) {}\n+\n+void ucr1100(S&);\n+void ucr1100(const S&) {}\n+\n+void ucr1101(S&);\n+void ucr1101(const S&);\n+void ucr1101(const S&&) {}\n+\n+void ucr1110(S&);\n+void ucr1110(const S&) {}\n+void ucr1110(S&&);\n+\n+void ucr1111(S&);\n+void ucr1111(const S&);\n+void ucr1111(S&&);\n+void ucr1111(const S&&) {}\n+\n+\n+int main()\n+{\n+  l0001(l);\n+  l0010(l);\n+  l0011(l);\n+  l0100(l);\n+  l0101(l);\n+  l0110(l);\n+  l0111(l);\n+  l1000(l);\n+  l1001(l);\n+  l1010(l);\n+  l1011(l);\n+  l1100(l);\n+  l1101(l);\n+  l1110(l);\n+  l1111(l);\n+  cl0001(cl);\n+  cl0011(cl);\n+  cl0100(cl);\n+  cl0101(cl);\n+  cl0110(cl);\n+  cl0111(cl);\n+  cl1001(cl);\n+  cl1011(cl);\n+  cl1100(cl);\n+  cl1101(cl);\n+  cl1110(cl);\n+  cl1111(cl);\n+  r0001(r());\n+  r0010(r());\n+  r0011(r());\n+  r0100(r());\n+  r0101(r());\n+  r0110(r());\n+  r0111(r());\n+  r1001(r());\n+  r1010(r());\n+  r1011(r());\n+  r1100(r());\n+  r1101(r());\n+  r1110(r());\n+  r1111(r());\n+  cr0001(cr());\n+  cr0011(cr());\n+  cr0100(cr());\n+  cr0101(cr());\n+  cr0110(cr());\n+  cr0111(cr());\n+  cr1001(cr());\n+  cr1011(cr());\n+  cr1100(cr());\n+  cr1101(cr());\n+  cr1110(cr());\n+  cr1111(cr());\n+  nl0001(nl);\n+  nl0010(nl);\n+  nl0011(nl);\n+  nl0100(nl);\n+  nl0101(nl);\n+  nl0110(nl);\n+  nl0111(nl);\n+  nl1000(nl);\n+  nl1001(nl);\n+  nl1010(nl);\n+  nl1011(nl);\n+  nl1100(nl);\n+  nl1101(nl);\n+  nl1110(nl);\n+  nl1111(nl);\n+  ncl0001(ncl);\n+  ncl0011(ncl);\n+  ncl0100(ncl);\n+  ncl0101(ncl);\n+  ncl0110(ncl);\n+  ncl0111(ncl);\n+  ncl1001(ncl);\n+  ncl1011(ncl);\n+  ncl1100(ncl);\n+  ncl1101(ncl);\n+  ncl1110(ncl);\n+  ncl1111(ncl);\n+  nr0001(nr);\n+  nr0010(nr);\n+  nr0011(nr);\n+  nr0100(nr);\n+  nr0101(nr);\n+  nr0110(nr);\n+  nr0111(nr);\n+  nr1000(nr);\n+  nr1001(nr);\n+  nr1010(nr);\n+  nr1011(nr);\n+  nr1100(nr);\n+  nr1101(nr);\n+  nr1110(nr);\n+  nr1111(nr);\n+  ncr0001(ncr);\n+  ncr0011(ncr);\n+  ncr0100(ncr);\n+  ncr0101(ncr);\n+  ncr0110(ncr);\n+  ncr0111(ncr);\n+  ncr1001(ncr);\n+  ncr1011(ncr);\n+  ncr1100(ncr);\n+  ncr1101(ncr);\n+  ncr1110(ncr);\n+  ncr1111(ncr);\n+  ul0001(ul());\n+  ul0010(ul());\n+  ul0011(ul());\n+  ul0100(ul());\n+  ul0101(ul());\n+  ul0110(ul());\n+  ul0111(ul());\n+  ul1000(ul());\n+  ul1001(ul());\n+  ul1010(ul());\n+  ul1011(ul());\n+  ul1100(ul());\n+  ul1101(ul());\n+  ul1110(ul());\n+  ul1111(ul());\n+  ucl0001(ucl());\n+  ucl0011(ucl());\n+  ucl0100(ucl());\n+  ucl0101(ucl());\n+  ucl0110(ucl());\n+  ucl0111(ucl());\n+  ucl1001(ucl());\n+  ucl1011(ucl());\n+  ucl1100(ucl());\n+  ucl1101(ucl());\n+  ucl1110(ucl());\n+  ucl1111(ucl());\n+  ur0001(ur());\n+  ur0010(ur());\n+  ur0011(ur());\n+  ur0100(ur());\n+  ur0101(ur());\n+  ur0110(ur());\n+  ur0111(ur());\n+  ur1001(ur());\n+  ur1010(ur());\n+  ur1011(ur());\n+  ur1100(ur());\n+  ur1101(ur());\n+  ur1110(ur());\n+  ur1111(ur());\n+  ucr0001(ucr());\n+  ucr0011(ucr());\n+  ucr0100(ucr());\n+  ucr0101(ucr());\n+  ucr0110(ucr());\n+  ucr0111(ucr());\n+  ucr1001(ucr());\n+  ucr1011(ucr());\n+  ucr1100(ucr());\n+  ucr1101(ucr());\n+  ucr1110(ucr());\n+  ucr1111(ucr());\n+\n+  return 0;\n+}"}, {"sha": "5b682e304598b586a6e498c01521cb85ddc937eb", "filename": "gcc/testsuite/g++.dg/cpp0x/reference_collapsing.C", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Freference_collapsing.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Freference_collapsing.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Freference_collapsing.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,175 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test the reference collapsing rules.  Note that there are recent differences\n+//    for how cv-qualifications are applied to reference types. 7.1.3, 14.3.1\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+template <class T, T v>\n+struct integral_constant\n+{\n+\tstatic const T                  value = v;\n+\ttypedef T                       value_type;\n+\ttypedef integral_constant<T, v> type;\n+};\n+\n+typedef integral_constant<bool, true>  true_type;\n+typedef integral_constant<bool, false> false_type;\n+\n+template <class T> struct is_lvalue_reference     : public integral_constant<bool, false> {};\n+template <class T> struct is_lvalue_reference<T&> : public integral_constant<bool, true> {};\n+\n+template <class T> struct is_rvalue_reference      : public integral_constant<bool, false> {};\n+template <class T> struct is_rvalue_reference<T&&> : public integral_constant<bool, true> {};\n+\n+template <class T> struct remove_reference      {typedef T type;};\n+template <class T> struct remove_reference<T&>  {typedef T type;};\n+template <class T> struct remove_reference<T&&> {typedef T type;};\n+\n+template <class T> struct is_const          : public integral_constant<bool, false> {};\n+template <class T> struct is_const<T const> : public integral_constant<bool, true> {};\n+\n+template <class T> struct is_volatile             : public integral_constant<bool, false> {};\n+template <class T> struct is_volatile<T volatile> : public integral_constant<bool, true> {};\n+\n+struct A {};\n+\n+typedef A& Alref;\n+typedef const A& cAlref;\n+typedef volatile A& vAlref;\n+typedef const volatile A& cvAlref;\n+\n+typedef A&& Arref;\n+typedef const A&& cArref;\n+typedef volatile A&& vArref;\n+typedef const volatile A&& cvArref;\n+\n+template <class T, bool is_lvalue_ref, bool is_rvalue_ref, bool s_const, bool s_volatile>\n+void test()\n+{\n+    sa<is_lvalue_reference<T>::value == is_lvalue_ref> t1;\n+    sa<is_rvalue_reference<T>::value == is_rvalue_ref> t2;\n+    sa<is_const   <typename remove_reference<T>::type>::value == s_const>    t3;\n+    sa<is_volatile<typename remove_reference<T>::type>::value == s_volatile> t4;\n+    sa<is_const   <typename remove_reference<const          T>::type>::value == s_const   > t5;\n+    sa<is_volatile<typename remove_reference<      volatile T>::type>::value == s_volatile> t6;\n+}\n+\n+int main()\n+{\n+    // sanity check\n+    test<               A&,   true, false, false, false>();\n+    test<const          A&,   true, false,  true, false>();\n+    test<      volatile A&,   true, false, false,  true>();\n+    test<const volatile A&,   true, false,  true,  true>();\n+    test<               A&&, false,  true, false, false>();\n+    test<const          A&&, false,  true,  true, false>();\n+    test<      volatile A&&, false,  true, false,  true>();\n+    test<const volatile A&&, false,  true,  true,  true>();\n+\n+// lvalue reference test\n+\n+    // Alref\n+    test<               Alref&,  true, false, false, false>();\n+    test<const          Alref&,  true, false, false, false>();\n+    test<      volatile Alref&,  true, false, false, false>();\n+    test<const volatile Alref&,  true, false, false, false>();\n+\n+    // cAlref\n+    test<               cAlref&,  true, false,  true, false>();\n+    test<const          cAlref&,  true, false,  true, false>();\n+    test<      volatile cAlref&,  true, false,  true, false>();\n+    test<const volatile cAlref&,  true, false,  true, false>();\n+\n+    // vAlref\n+    test<               vAlref&,  true, false, false,  true>();\n+    test<const          vAlref&,  true, false, false,  true>();\n+    test<      volatile vAlref&,  true, false, false,  true>();\n+    test<const volatile vAlref&,  true, false, false,  true>();\n+\n+    // cvAlref\n+    test<               cvAlref&,  true, false,  true,  true>();\n+    test<const          cvAlref&,  true, false,  true,  true>();\n+    test<      volatile cvAlref&,  true, false,  true,  true>();\n+    test<const volatile cvAlref&,  true, false,  true,  true>();\n+\n+    // Arref\n+    test<               Arref&,  true, false, false, false>();\n+    test<const          Arref&,  true, false, false, false>();\n+    test<      volatile Arref&,  true, false, false, false>();\n+    test<const volatile Arref&,  true, false, false, false>();\n+\n+    // cArref\n+    test<               cArref&,  true, false,  true, false>();\n+    test<const          cArref&,  true, false,  true, false>();\n+    test<      volatile cArref&,  true, false,  true, false>();\n+    test<const volatile cArref&,  true, false,  true, false>();\n+\n+    // vArref\n+    test<               vArref&,  true, false, false,  true>();\n+    test<const          vArref&,  true, false, false,  true>();\n+    test<      volatile vArref&,  true, false, false,  true>();\n+    test<const volatile vArref&,  true, false, false,  true>();\n+\n+    // vArref\n+    test<               cvArref&,  true, false,  true,  true>();\n+    test<const          cvArref&,  true, false,  true,  true>();\n+    test<      volatile cvArref&,  true, false,  true,  true>();\n+    test<const volatile cvArref&,  true, false,  true,  true>();\n+\n+// rvalue reference test\n+\n+    // Alref\n+    test<               Alref&&,  true, false, false, false>();\n+    test<const          Alref&&,  true, false, false, false>();\n+    test<      volatile Alref&&,  true, false, false, false>();\n+    test<const volatile Alref&&,  true, false, false, false>();\n+\n+    // cAlref\n+    test<               cAlref&&,  true, false,  true, false>();\n+    test<const          cAlref&&,  true, false,  true, false>();\n+    test<      volatile cAlref&&,  true, false,  true, false>();\n+    test<const volatile cAlref&&,  true, false,  true, false>();\n+\n+    // vAlref\n+    test<               vAlref&&,  true, false, false,  true>();\n+    test<const          vAlref&&,  true, false, false,  true>();\n+    test<      volatile vAlref&&,  true, false, false,  true>();\n+    test<const volatile vAlref&&,  true, false, false,  true>();\n+\n+    // cvAlref\n+    test<               cvAlref&&,  true, false,  true,  true>();\n+    test<const          cvAlref&&,  true, false,  true,  true>();\n+    test<      volatile cvAlref&&,  true, false,  true,  true>();\n+    test<const volatile cvAlref&&,  true, false,  true,  true>();\n+\n+    // Arref\n+    test<               Arref&&, false,  true, false, false>();\n+    test<const          Arref&&, false,  true, false, false>();\n+    test<      volatile Arref&&, false,  true, false, false>();\n+    test<const volatile Arref&&, false,  true, false, false>();\n+\n+    // cArref\n+    test<               cArref&&, false,  true,  true, false>();\n+    test<const          cArref&&, false,  true,  true, false>();\n+    test<      volatile cArref&&, false,  true,  true, false>();\n+    test<const volatile cArref&&, false,  true,  true, false>();\n+\n+    // vArref\n+    test<               vArref&&, false,  true, false,  true>();\n+    test<const          vArref&&, false,  true, false,  true>();\n+    test<      volatile vArref&&, false,  true, false,  true>();\n+    test<const volatile vArref&&, false,  true, false,  true>();\n+\n+    // cvArref\n+    test<               cvArref&&, false,  true,  true,  true>();\n+    test<const          cvArref&&, false,  true,  true,  true>();\n+    test<      volatile cvArref&&, false,  true,  true,  true>();\n+    test<const volatile cvArref&&, false,  true,  true,  true>();\n+\n+    return 0;\n+}"}, {"sha": "10b5dc256b4bc28b4911faae3cf73ac06c8fc359", "filename": "gcc/testsuite/g++.dg/cpp0x/rv1n.C", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv1n.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv1n.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv1n.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,149 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 1 at a time\n+\n+one   sink_1_1(               A&);  // { dg-error \"\" }\n+\n+int test1_1()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_1_1(ca);           // { dg-error \"invalid initialization\" }\n+    sink_1_1(va);           // { dg-error \"invalid initialization\" }\n+    sink_1_1(cva);          // { dg-error \"invalid initialization\" }\n+    sink_1_1(source());     // { dg-error \"invalid initialization\" }\n+    sink_1_1(c_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_1(v_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_1(cv_source());  // { dg-error \"invalid initialization\" }\n+    return 0;\n+}\n+\n+two   sink_1_2(const          A&);  // { dg-error \"\" }\n+\n+int test1_2()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_1_2(va);           // { dg-error \"invalid initialization\" }\n+    sink_1_2(cva);          // { dg-error \"invalid initialization\" }\n+    sink_1_2(v_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_2(cv_source());  // { dg-error \"invalid initialization\" }\n+    return 0;\n+}\n+\n+three sink_1_3(volatile       A&);  // { dg-error \"\" }\n+\n+int test1_3()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_1_3(ca);           // { dg-error \"invalid initialization\" }\n+    sink_1_3(cva);          // { dg-error \"invalid initialization\" }\n+    sink_1_3(source());     // { dg-error \"invalid initialization\" }\n+    sink_1_3(c_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_3(v_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_3(cv_source());  // { dg-error \"invalid initialization\" }\n+    return 0;\n+}\n+\n+four  sink_1_4(const volatile A&);  // { dg-error \"\" }\n+\n+int test1_4()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_1_4(source());     // { dg-error \"invalid initialization\" }\n+    sink_1_4(c_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_4(v_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_4(cv_source());  // { dg-error \"invalid initialization\" }\n+    return 0;\n+}\n+\n+five  sink_1_5(               A&&);  // { dg-error \"\" }\n+\n+int test1_5()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_1_5(ca);           // { dg-error \"invalid initialization\" }\n+    sink_1_5(va);           // { dg-error \"invalid initialization\" }\n+    sink_1_5(cva);          // { dg-error \"invalid initialization\" }\n+    sink_1_5(c_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_5(v_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_5(cv_source());  // { dg-error \"invalid initialization\" }\n+    return 0;\n+}\n+\n+six   sink_1_6(const          A&&);  // { dg-error \"\" }\n+\n+int test1_6()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_1_6(va);           // { dg-error \"invalid initialization\" }\n+    sink_1_6(cva);          // { dg-error \"invalid initialization\" }\n+    sink_1_6(v_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_6(cv_source());  // { dg-error \"invalid initialization\" }\n+    return 0;\n+}\n+\n+seven sink_1_7(volatile       A&&);  // { dg-error \"\" }\n+\n+int test1_7()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_1_7(ca);           // { dg-error \"invalid initialization\" }\n+    sink_1_7(cva);          // { dg-error \"invalid initialization\" }\n+    sink_1_7(c_source());   // { dg-error \"invalid initialization\" }\n+    sink_1_7(cv_source());  // { dg-error \"invalid initialization\" }\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test1_1() + test1_2() + test1_3() + test1_5() +\n+           test1_6() + test1_7();\n+}"}, {"sha": "6241885654ec93b964a564205e90b3324cdcec57", "filename": "gcc/testsuite/g++.dg/cpp0x/rv1p.C", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv1p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv1p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv1p.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,154 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 1 at a time\n+\n+one   sink_1_1(               A&);\n+\n+int test1_1()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_1_1(a))           == 1> t1;\n+    return 0;\n+}\n+\n+two   sink_1_2(const          A&);\n+\n+int test1_2()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_1_2(a))           == 2> t1;\n+    sa<sizeof(sink_1_2(ca))          == 2> t2;\n+    sa<sizeof(sink_1_2(source()))    == 2> t5;\n+    sa<sizeof(sink_1_2(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+three sink_1_3(volatile       A&);\n+\n+int test1_3()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_1_3(a))           == 3> t1;\n+    sa<sizeof(sink_1_3(va))          == 3> t3;\n+    return 0;\n+}\n+\n+four  sink_1_4(const volatile A&);\n+\n+int test1_4()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_1_4(a))           == 4> t1;\n+    sa<sizeof(sink_1_4(ca))          == 4> t2;\n+    sa<sizeof(sink_1_4(va))          == 4> t3;\n+    sa<sizeof(sink_1_4(cva))         == 4> t4;\n+    return 0;\n+}\n+\n+five  sink_1_5(               A&&);\n+\n+int test1_5()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_1_5(a))           == 5> t1;\n+    sa<sizeof(sink_1_5(source()))    == 5> t5;\n+    return 0;\n+}\n+\n+six   sink_1_6(const          A&&);\n+\n+int test1_6()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_1_6(a))           == 6> t1;\n+    sa<sizeof(sink_1_6(ca))          == 6> t2;\n+    sa<sizeof(sink_1_6(source()))    == 6> t5;\n+    sa<sizeof(sink_1_6(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+seven sink_1_7(volatile       A&&);\n+\n+int test1_7()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_1_7(a))           == 7> t1;\n+    sa<sizeof(sink_1_7(va))          == 7> t3;\n+    sa<sizeof(sink_1_7(source()))    == 7> t5;\n+    sa<sizeof(sink_1_7(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+eight sink_1_8(const volatile A&&);\n+\n+int test1_8()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_1_8(a))           == 8> t1;\n+    sa<sizeof(sink_1_8(ca))          == 8> t2;\n+    sa<sizeof(sink_1_8(va))          == 8> t3;\n+    sa<sizeof(sink_1_8(cva))         == 8> t4;\n+    sa<sizeof(sink_1_8(source()))    == 8> t5;\n+    sa<sizeof(sink_1_8(c_source()))  == 8> t6;\n+    sa<sizeof(sink_1_8(v_source()))  == 8> t7;\n+    sa<sizeof(sink_1_8(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test1_1() + test1_2() + test1_3() + test1_4() +\n+           test1_5() + test1_6() + test1_7() + test1_8();\n+}"}, {"sha": "df35358a6c1f9d196c4bcdef2f04f7ef40a35fbb", "filename": "gcc/testsuite/g++.dg/cpp0x/rv2n.C", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv2n.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv2n.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv2n.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,370 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 2 at a time\n+\n+one   sink_2_12(               A&);  // { dg-error \"\" }\n+two   sink_2_12(const          A&);  // { dg-error \"\" }\n+\n+int test2_12()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_12(va);           // { dg-error \"no match\" }\n+    sink_2_12(cva);          // { dg-error \"no match\" }\n+    sink_2_12(v_source());   // { dg-error \"no match\" }\n+    sink_2_12(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_2_13(               A&);  // { dg-error \"\" }\n+three sink_2_13(volatile       A&);  // { dg-error \"\" }\n+\n+int test2_13()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_13(ca);           // { dg-error \"no match\" }\n+    sink_2_13(cva);          // { dg-error \"no match\" }\n+    sink_2_13(source());     // { dg-error \"no match\" }\n+    sink_2_13(c_source());   // { dg-error \"no match\" }\n+    sink_2_13(v_source());   // { dg-error \"no match\" }\n+    sink_2_13(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_2_14(               A&);  // { dg-error \"\" }\n+four  sink_2_14(const volatile A&);  // { dg-error \"\" }\n+\n+int test2_14()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_14(source());     // { dg-error \"no match\" }\n+    sink_2_14(c_source());   // { dg-error \"no match\" }\n+    sink_2_14(v_source());   // { dg-error \"no match\" }\n+    sink_2_14(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_2_15(               A&);  // { dg-error \"\" }\n+five  sink_2_15(               A&&);  // { dg-error \"\" }\n+\n+int test2_15()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+   sink_2_15(ca);           // { dg-error \"no match\" }\n+   sink_2_15(va);           // { dg-error \"no match\" }\n+   sink_2_15(cva);          // { dg-error \"no match\" }\n+   sink_2_15(c_source());   // { dg-error \"no match\" }\n+   sink_2_15(v_source());   // { dg-error \"no match\" }\n+   sink_2_15(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_2_16(               A&);  // { dg-error \"\" }\n+six   sink_2_16(const          A&&);  // { dg-error \"\" }\n+\n+int test2_16()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_16(va);           // { dg-error \"no match\" }\n+    sink_2_16(cva);          // { dg-error \"no match\" }\n+    sink_2_16(v_source());   // { dg-error \"no match\" }\n+    sink_2_16(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_2_17(               A&);  // { dg-error \"\" }\n+seven sink_2_17(volatile       A&&);  // { dg-error \"\" }\n+\n+int test2_17()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_17(ca);           // { dg-error \"no match\" }\n+    sink_2_17(cva);          // { dg-error \"no match\" }\n+    sink_2_17(c_source());   // { dg-error \"no match\" }\n+    sink_2_17(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_2_23(const          A&);  // { dg-error \"\" }\n+three sink_2_23(volatile       A&);  // { dg-error \"\" }\n+\n+int test2_23()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_23(a);            // { dg-error \"ambiguous\" }\n+    sink_2_23(cva);          // { dg-error \"no match\" }\n+    sink_2_23(v_source());   // { dg-error \"no match\" }\n+    sink_2_23(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_2_24(const          A&);  // { dg-error \"\" }\n+four  sink_2_24(const volatile A&);  // { dg-error \"\" }\n+\n+int test2_24()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_24(v_source());   // { dg-error \"no match\" }\n+    sink_2_24(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_2_34(volatile       A&);  // { dg-error \"\" }\n+four  sink_2_34(const volatile A&);  // { dg-error \"\" }\n+\n+int test2_34()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_34(source());     // { dg-error \"no match\" }\n+    sink_2_34(c_source());   // { dg-error \"no match\" }\n+    sink_2_34(v_source());   // { dg-error \"no match\" }\n+    sink_2_34(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_2_25(const          A&);  // { dg-error \"\" }\n+five  sink_2_25(               A&&);  // { dg-error \"\" }\n+\n+int test2_25()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+   sink_2_25(va);           // { dg-error \"no match\" }\n+   sink_2_25(cva);          // { dg-error \"no match\" }\n+   sink_2_25(v_source());   // { dg-error \"no match\" }\n+   sink_2_25(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_2_26(const          A&);  // { dg-error \"\" }\n+six   sink_2_26(const          A&&);  // { dg-error \"\" }\n+\n+int test2_26()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_26(va);           // { dg-error \"no match\" }\n+    sink_2_26(cva);          // { dg-error \"no match\" }\n+    sink_2_26(v_source());   // { dg-error \"no match\" }\n+    sink_2_26(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_2_27(const          A&);  // { dg-error \"\" }\n+seven sink_2_27(volatile       A&&);  // { dg-error \"\" }\n+\n+int test2_27()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_27(cva);          // { dg-error \"no match\" }\n+    sink_2_27(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_2_35(volatile       A&);  // { dg-error \"\" }\n+five  sink_2_35(               A&&);  // { dg-error \"\" }\n+\n+int test2_35()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_35(ca);           // { dg-error \"no match\" }\n+    sink_2_35(cva);          // { dg-error \"no match\" }\n+    sink_2_35(c_source());   // { dg-error \"no match\" }\n+    sink_2_35(v_source());   // { dg-error \"no match\" }\n+    sink_2_35(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_2_36(volatile       A&);  // { dg-error \"\" }\n+six   sink_2_36(const          A&&);  // { dg-error \"\" }\n+\n+int test2_36()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_36(cva);          // { dg-error \"no match\" }\n+    sink_2_36(v_source());   // { dg-error \"no match\" }\n+    sink_2_36(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_2_37(volatile       A&);  // { dg-error \"\" }\n+seven sink_2_37(volatile       A&&);  // { dg-error \"\" }\n+\n+int test2_37()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_37(ca);           // { dg-error \"no match\" }\n+    sink_2_37(cva);          // { dg-error \"no match\" }\n+    sink_2_37(c_source());   // { dg-error \"no match\" }\n+    sink_2_37(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+four  sink_2_45(const volatile A&);   // { dg-error \"\" }\n+five  sink_2_45(               A&&);  // { dg-error \"\" }\n+\n+int test2_45()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_45(c_source());   // { dg-error \"no match\" }\n+    sink_2_45(v_source());   // { dg-error \"no match\" }\n+    sink_2_45(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+four  sink_2_46(const volatile A&);   // { dg-error \"\" }\n+six   sink_2_46(const          A&&);  // { dg-error \"\" }\n+\n+int test2_46()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_46(v_source());   // { dg-error \"no match\" }\n+    sink_2_46(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+four  sink_2_47(const volatile A&);   // { dg-error \"\" }\n+seven sink_2_47(volatile       A&&);  // { dg-error \"\" }\n+\n+int test2_47()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_47(c_source());   // { dg-error \"no match\" }\n+    sink_2_47(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+five  sink_2_56(               A&&);  // { dg-error \"\" }\n+six   sink_2_56(const          A&&);  // { dg-error \"\" }\n+\n+int test2_56()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_56(va);           // { dg-error \"no match\" }\n+    sink_2_56(cva);          // { dg-error \"no match\" }\n+    sink_2_56(v_source());   // { dg-error \"no match\" }\n+    sink_2_56(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+five  sink_2_57(               A&&);  // { dg-error \"\" }\n+seven sink_2_57(volatile       A&&);  // { dg-error \"\" }\n+\n+int test2_57()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_57(ca);           // { dg-error \"no match\" }\n+    sink_2_57(cva);          // { dg-error \"no match\" }\n+    sink_2_57(c_source());   // { dg-error \"no match\" }\n+    sink_2_57(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+six   sink_2_67(const          A&&);  // { dg-error \"\" }\n+seven sink_2_67(volatile       A&&);  // { dg-error \"\" }\n+\n+int test2_67()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_2_67(a);            // { dg-error \"ambiguous\" }\n+    sink_2_67(cva);          // { dg-error \"no match\" }\n+    sink_2_67(source());     // { dg-error \"ambiguous\" }\n+    sink_2_67(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test2_12() + test2_13() + test2_15() + test2_16() +\n+           test2_17() + test2_23() + test2_25() + test2_26() +\n+           test2_27() + test2_35() + test2_36() + test2_37() +\n+           test2_56() + test2_57() + test2_67();\n+}"}, {"sha": "0d12aac75e149a86d13ef75314d0620a7f72c798", "filename": "gcc/testsuite/g++.dg/cpp0x/rv2p.C", "status": "added", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv2p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv2p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv2p.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,536 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 2 at a time\n+\n+one   sink_2_12(               A&);\n+two   sink_2_12(const          A&);\n+\n+int test2_12()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_12(a))           == 1> t1;\n+    sa<sizeof(sink_2_12(ca))          == 2> t2;\n+    sa<sizeof(sink_2_12(source()))    == 2> t5;\n+    sa<sizeof(sink_2_12(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+one   sink_2_13(               A&);\n+three sink_2_13(volatile       A&);\n+\n+int test2_13()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_13(a))           == 1> t1;\n+    sa<sizeof(sink_2_13(va))          == 3> t3;\n+    return 0;\n+}\n+\n+one   sink_2_14(               A&);\n+four  sink_2_14(const volatile A&);\n+\n+int test2_14()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_14(a))           == 1> t1;\n+    sa<sizeof(sink_2_14(ca))          == 4> t2;\n+    sa<sizeof(sink_2_14(va))          == 4> t3;\n+    sa<sizeof(sink_2_14(cva))         == 4> t4;\n+    return 0;\n+}\n+\n+one   sink_2_15(               A&);\n+five  sink_2_15(               A&&);\n+\n+int test2_15()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_15(a))           == 1> t1;\n+    sa<sizeof(sink_2_15(source()))    == 5> t5;\n+    return 0;\n+}\n+\n+one   sink_2_16(               A&);\n+six   sink_2_16(const          A&&);\n+\n+int test2_16()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_16(a))           == 1> t1;\n+    sa<sizeof(sink_2_16(ca))          == 6> t2;\n+    sa<sizeof(sink_2_16(source()))    == 6> t5;\n+    sa<sizeof(sink_2_16(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_2_17(               A&);\n+seven sink_2_17(volatile       A&&);\n+\n+int test2_17()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_17(a))           == 1> t1;\n+    sa<sizeof(sink_2_17(va))          == 7> t3;\n+    sa<sizeof(sink_2_17(source()))    == 7> t5;\n+    sa<sizeof(sink_2_17(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_2_18(               A&);\n+eight sink_2_18(const volatile A&&);\n+\n+int test2_18()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_18(a))           == 1> t1;\n+    sa<sizeof(sink_2_18(ca))          == 8> t2;\n+    sa<sizeof(sink_2_18(va))          == 8> t3;\n+    sa<sizeof(sink_2_18(cva))         == 8> t4;\n+    sa<sizeof(sink_2_18(source()))    == 8> t5;\n+    sa<sizeof(sink_2_18(c_source()))  == 8> t6;\n+    sa<sizeof(sink_2_18(v_source()))  == 8> t7;\n+    sa<sizeof(sink_2_18(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_2_23(const          A&);\n+three sink_2_23(volatile       A&);\n+\n+int test2_23()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_23(ca))          == 2> t2;\n+    sa<sizeof(sink_2_23(va))          == 3> t3;\n+    sa<sizeof(sink_2_23(source()))    == 2> t5;\n+    sa<sizeof(sink_2_23(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+two   sink_2_24(const          A&);\n+four  sink_2_24(const volatile A&);\n+\n+int test2_24()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_24(a))           == 2> t1;\n+    sa<sizeof(sink_2_24(ca))          == 2> t2;\n+    sa<sizeof(sink_2_24(va))          == 4> t3;\n+    sa<sizeof(sink_2_24(cva))         == 4> t4;\n+    sa<sizeof(sink_2_24(source()))    == 2> t5;\n+    sa<sizeof(sink_2_24(c_source()))  == 2> t6;\n+//    sa<sizeof(sink_2_24(v_source()))  == 4> t7;\n+//    sa<sizeof(sink_2_24(cv_source())) == 4> t8;\n+    return 0;\n+}\n+\n+two   sink_2_25(const          A&);\n+five  sink_2_25(               A&&);\n+\n+int test2_25()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_25(a))           == 2> t1;\n+    sa<sizeof(sink_2_25(ca))          == 2> t2;\n+    sa<sizeof(sink_2_25(source()))    == 5> t5;\n+    sa<sizeof(sink_2_25(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+two   sink_2_26(const          A&);\n+six   sink_2_26(const          A&&);\n+\n+int test2_26()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_26(a))           == 2> t1;\n+    sa<sizeof(sink_2_26(ca))          == 2> t2;\n+    sa<sizeof(sink_2_26(source()))    == 6> t5;\n+    sa<sizeof(sink_2_26(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+two   sink_2_27(const          A&);\n+seven sink_2_27(volatile       A&&);\n+\n+int test2_27()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_27(a))           == 2> t1;\n+    sa<sizeof(sink_2_27(ca))          == 2> t2;\n+    sa<sizeof(sink_2_27(va))          == 7> t3;\n+    sa<sizeof(sink_2_27(source()))    == 7> t5;\n+    sa<sizeof(sink_2_27(c_source()))  == 2> t6;\n+    sa<sizeof(sink_2_27(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_2_28(const          A&);\n+eight sink_2_28(const volatile A&&);\n+\n+int test2_28()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_28(a))           == 2> t1;\n+    sa<sizeof(sink_2_28(ca))          == 2> t2;\n+    sa<sizeof(sink_2_28(va))          == 8> t3;\n+    sa<sizeof(sink_2_28(cva))         == 8> t4;\n+    sa<sizeof(sink_2_28(source()))    == 8> t5;\n+    sa<sizeof(sink_2_28(c_source()))  == 8> t6;\n+    sa<sizeof(sink_2_28(v_source()))  == 8> t7;\n+    sa<sizeof(sink_2_28(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_2_34(volatile       A&);\n+four  sink_2_34(const volatile A&);\n+\n+int test2_34()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_34(a))           == 3> t1;\n+    sa<sizeof(sink_2_34(ca))          == 4> t2;\n+    sa<sizeof(sink_2_34(va))          == 3> t3;\n+    sa<sizeof(sink_2_34(cva))         == 4> t4;\n+//    sa<sizeof(sink_2_34(source()))    == 4> t5;\n+//    sa<sizeof(sink_2_34(c_source()))  == 4> t6;\n+//    sa<sizeof(sink_2_34(v_source()))  == 4> t7;\n+//    sa<sizeof(sink_2_34(cv_source())) == 4> t8;\n+    return 0;\n+}\n+\n+three sink_2_35(volatile       A&);\n+five  sink_2_35(               A&&);\n+\n+int test2_35()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_35(a))           == 3> t1;\n+    sa<sizeof(sink_2_35(va))          == 3> t3;\n+    sa<sizeof(sink_2_35(source()))    == 5> t5;\n+    return 0;\n+}\n+\n+three sink_2_36(volatile       A&);\n+six   sink_2_36(const          A&&);\n+\n+int test2_36()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_36(a))           == 3> t1;\n+    sa<sizeof(sink_2_36(ca))          == 6> t2;\n+    sa<sizeof(sink_2_36(va))          == 3> t3;\n+    sa<sizeof(sink_2_36(source()))    == 6> t5;\n+    sa<sizeof(sink_2_36(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+three sink_2_37(volatile       A&);\n+seven sink_2_37(volatile       A&&);\n+\n+int test2_37()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_37(a))           == 3> t1;\n+    sa<sizeof(sink_2_37(va))          == 3> t3;\n+    sa<sizeof(sink_2_37(source()))    == 7> t5;\n+    sa<sizeof(sink_2_37(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+three sink_2_38(volatile       A&);\n+eight sink_2_38(const volatile A&&);\n+\n+int test2_38()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_38(a))           == 3> t1;\n+    sa<sizeof(sink_2_38(ca))          == 8> t2;\n+    sa<sizeof(sink_2_38(va))          == 3> t3;\n+    sa<sizeof(sink_2_38(cva))         == 8> t4;\n+    sa<sizeof(sink_2_38(source()))    == 8> t5;\n+    sa<sizeof(sink_2_38(c_source()))  == 8> t6;\n+    sa<sizeof(sink_2_38(v_source()))  == 8> t7;\n+    sa<sizeof(sink_2_38(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+four  sink_2_45(const volatile A&);\n+five  sink_2_45(               A&&);\n+\n+int test2_45()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_45(a))           == 4> t1;\n+    sa<sizeof(sink_2_45(ca))          == 4> t2;\n+    sa<sizeof(sink_2_45(va))          == 4> t3;\n+    sa<sizeof(sink_2_45(cva))         == 4> t4;\n+    sa<sizeof(sink_2_45(source()))    == 5> t5;\n+//    sa<sizeof(sink_2_45(c_source()))  == 4> t6;\n+//    sa<sizeof(sink_2_45(v_source()))  == 4> t7;\n+//    sa<sizeof(sink_2_45(cv_source())) == 4> t8;\n+    return 0;\n+}\n+\n+four  sink_2_46(const volatile A&);\n+six   sink_2_46(const          A&&);\n+\n+int test2_46()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_46(a))           == 4> t1;\n+    sa<sizeof(sink_2_46(ca))          == 4> t2;\n+    sa<sizeof(sink_2_46(va))          == 4> t3;\n+    sa<sizeof(sink_2_46(cva))         == 4> t4;\n+    sa<sizeof(sink_2_46(source()))    == 6> t5;\n+    sa<sizeof(sink_2_46(c_source()))  == 6> t6;\n+//    sa<sizeof(sink_2_46(v_source()))  == 4> t7;\n+//    sa<sizeof(sink_2_46(cv_source())) == 4> t8;\n+    return 0;\n+}\n+\n+four  sink_2_47(const volatile A&);\n+seven sink_2_47(volatile       A&&);\n+\n+int test2_47()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_47(a))           == 4> t1;\n+    sa<sizeof(sink_2_47(ca))          == 4> t2;\n+    sa<sizeof(sink_2_47(va))          == 4> t3;\n+    sa<sizeof(sink_2_47(cva))         == 4> t4;\n+    sa<sizeof(sink_2_47(source()))    == 7> t5;\n+//    sa<sizeof(sink_2_47(c_source()))  == 4> t6;\n+    sa<sizeof(sink_2_47(v_source()))  == 7> t7;\n+//    sa<sizeof(sink_2_47(cv_source())) == 4> t8;\n+    return 0;\n+}\n+\n+four  sink_2_48(const volatile A&);\n+eight sink_2_48(const volatile A&&);\n+\n+int test2_48()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_48(a))           == 4> t1;\n+    sa<sizeof(sink_2_48(ca))          == 4> t2;\n+    sa<sizeof(sink_2_48(va))          == 4> t3;\n+    sa<sizeof(sink_2_48(cva))         == 4> t4;\n+    sa<sizeof(sink_2_48(source()))    == 8> t5;\n+    sa<sizeof(sink_2_48(c_source()))  == 8> t6;\n+    sa<sizeof(sink_2_48(v_source()))  == 8> t7;\n+    sa<sizeof(sink_2_48(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+five  sink_2_56(               A&&);\n+six   sink_2_56(const          A&&);\n+\n+int test2_56()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_56(a))           == 5> t1;\n+    sa<sizeof(sink_2_56(ca))          == 6> t2;\n+    sa<sizeof(sink_2_56(source()))    == 5> t5;\n+    sa<sizeof(sink_2_56(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+five  sink_2_57(               A&&);\n+seven sink_2_57(volatile       A&&);\n+\n+int test2_57()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_57(a))           == 5> t1;\n+    sa<sizeof(sink_2_57(va))          == 7> t3;\n+    sa<sizeof(sink_2_57(source()))    == 5> t5;\n+    sa<sizeof(sink_2_57(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+five  sink_2_58(               A&&);\n+eight sink_2_58(const volatile A&&);\n+\n+int test2_58()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_58(a))           == 5> t1;\n+    sa<sizeof(sink_2_58(ca))          == 8> t2;\n+    sa<sizeof(sink_2_58(va))          == 8> t3;\n+    sa<sizeof(sink_2_58(cva))         == 8> t4;\n+    sa<sizeof(sink_2_58(source()))    == 5> t5;\n+    sa<sizeof(sink_2_58(c_source()))  == 8> t6;\n+    sa<sizeof(sink_2_58(v_source()))  == 8> t7;\n+    sa<sizeof(sink_2_58(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+six   sink_2_67(const          A&&);\n+seven sink_2_67(volatile       A&&);\n+\n+int test2_67()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_67(ca))          == 6> t2;\n+    sa<sizeof(sink_2_67(va))          == 7> t3;\n+    sa<sizeof(sink_2_67(c_source()))  == 6> t6;\n+    sa<sizeof(sink_2_67(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+six   sink_2_68(const          A&&);\n+eight sink_2_68(const volatile A&&);\n+\n+int test2_68()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_68(a))           == 6> t1;\n+    sa<sizeof(sink_2_68(ca))          == 6> t2;\n+    sa<sizeof(sink_2_68(va))          == 8> t3;\n+    sa<sizeof(sink_2_68(cva))         == 8> t4;\n+    sa<sizeof(sink_2_68(source()))    == 6> t5;\n+    sa<sizeof(sink_2_68(c_source()))  == 6> t6;\n+    sa<sizeof(sink_2_68(v_source()))  == 8> t7;\n+    sa<sizeof(sink_2_68(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+seven sink_2_78(volatile       A&&);\n+eight sink_2_78(const volatile A&&);\n+\n+int test2_78()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_2_78(a))           == 7> t1;\n+    sa<sizeof(sink_2_78(ca))          == 8> t2;\n+    sa<sizeof(sink_2_78(va))          == 7> t3;\n+    sa<sizeof(sink_2_78(cva))         == 8> t4;\n+    sa<sizeof(sink_2_78(source()))    == 7> t5;\n+    sa<sizeof(sink_2_78(c_source()))  == 8> t6;\n+    sa<sizeof(sink_2_78(v_source()))  == 7> t7;\n+    sa<sizeof(sink_2_78(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test2_12() + test2_13() + test2_14() + test2_15() +\n+           test2_16() + test2_17() + test2_18() + test2_23() +\n+           test2_24() + test2_25() + test2_26() + test2_27() +\n+           test2_28() + test2_34() + test2_35() + test2_36() +\n+           test2_37() + test2_38() + test2_45() + test2_46() +\n+           test2_47() + test2_48() + test2_56() + test2_57() +\n+           test2_58() + test2_67() + test2_68() + test2_78();\n+}"}, {"sha": "e04ef4fee3468238eaa580fa0d803eb91b305cc3", "filename": "gcc/testsuite/g++.dg/cpp0x/rv3n.C", "status": "added", "additions": 627, "deletions": 0, "changes": 627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv3n.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv3n.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv3n.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,627 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 3 at a time\n+\n+one   sink_3_123(               A&);  // { dg-error \"\" }\n+two   sink_3_123(const          A&);  // { dg-error \"\" }\n+three sink_3_123(volatile       A&);  // { dg-error \"\" }\n+\n+int test3_123()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_123(cva);          // { dg-error \"no match\" }\n+    sink_3_123(v_source());   // { dg-error \"no match\" }\n+    sink_3_123(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_125(               A&);  // { dg-error \"\" }\n+two   sink_3_125(const          A&);  // { dg-error \"\" }\n+five  sink_3_125(               A&&);  // { dg-error \"\" }\n+\n+one   sink_3_124(               A&);  // { dg-error \"\" }\n+two   sink_3_124(const          A&);  // { dg-error \"\" }\n+four  sink_3_124(const volatile A&);  // { dg-error \"\" }\n+\n+int test3_124()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_124(v_source());   // { dg-error \"no match\" }\n+    sink_3_124(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+int test3_125()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_125(va);           // { dg-error \"no match\" }\n+    sink_3_125(cva);          // { dg-error \"no match\" }\n+    sink_3_125(v_source());   // { dg-error \"no match\" }\n+    sink_3_125(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_126(               A&);  // { dg-error \"\" }\n+two   sink_3_126(const          A&);  // { dg-error \"\" }\n+six   sink_3_126(const          A&&);  // { dg-error \"\" }\n+\n+int test3_126()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_126(va);           // { dg-error \"no match\" }\n+    sink_3_126(cva);          // { dg-error \"no match\" }\n+    sink_3_126(v_source());   // { dg-error \"no match\" }\n+    sink_3_126(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_127(               A&);  // { dg-error \"\" }\n+two   sink_3_127(const          A&);  // { dg-error \"\" }\n+seven sink_3_127(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_127()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_127(cva);          // { dg-error \"no match\" }\n+    sink_3_127(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_134(               A&);  // { dg-error \"\" }\n+three sink_3_134(volatile       A&);  // { dg-error \"\" }\n+four  sink_3_134(const volatile A&);  // { dg-error \"\" }\n+\n+int test3_134()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_134(source());     // { dg-error \"no match\" }\n+    sink_3_134(c_source());   // { dg-error \"no match\" }\n+    sink_3_134(v_source());   // { dg-error \"no match\" }\n+    sink_3_134(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_135(               A&);  // { dg-error \"\" }\n+three sink_3_135(volatile       A&);  // { dg-error \"\" }\n+five  sink_3_135(               A&&);  // { dg-error \"\" }\n+\n+int test3_135()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_135(ca);           // { dg-error \"no match\" }\n+    sink_3_135(cva);          // { dg-error \"no match\" }\n+    sink_3_135(c_source());   // { dg-error \"no match\" }\n+    sink_3_135(v_source());   // { dg-error \"no match\" }\n+    sink_3_135(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_136(               A&);  // { dg-error \"\" }\n+three sink_3_136(volatile       A&);  // { dg-error \"\" }\n+six   sink_3_136(const          A&&);  // { dg-error \"\" }\n+\n+int test3_136()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_136(cva);          // { dg-error \"no match\" }\n+    sink_3_136(v_source());   // { dg-error \"no match\" }\n+    sink_3_136(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_137(               A&);  // { dg-error \"\" }\n+three sink_3_137(volatile       A&);  // { dg-error \"\" }\n+seven sink_3_137(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_137()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_137(ca);           // { dg-error \"no match\" }\n+    sink_3_137(cva);          // { dg-error \"no match\" }\n+    sink_3_137(c_source());   // { dg-error \"no match\" }\n+    sink_3_137(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_145(               A&);  // { dg-error \"\" }\n+four  sink_3_145(const volatile A&);  // { dg-error \"\" }\n+five  sink_3_145(               A&&);  // { dg-error \"\" }\n+\n+int test3_145()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_145(c_source());   // { dg-error \"no match\" }\n+    sink_3_145(v_source());   // { dg-error \"no match\" }\n+    sink_3_145(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_146(               A&);  // { dg-error \"\" }\n+four  sink_3_146(const volatile A&);  // { dg-error \"\" }\n+six   sink_3_146(const          A&&);  // { dg-error \"\" }\n+\n+int test3_146()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_146(v_source());   // { dg-error \"no match\" }\n+    sink_3_146(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_147(               A&);  // { dg-error \"\" }\n+four  sink_3_147(const volatile A&);  // { dg-error \"\" }\n+seven sink_3_147(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_147()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_147(c_source());   // { dg-error \"no match\" }\n+    sink_3_147(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_156(               A&);  // { dg-error \"\" }\n+five  sink_3_156(               A&&);  // { dg-error \"\" }\n+six   sink_3_156(const          A&&);  // { dg-error \"\" }\n+\n+int test3_156()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_156(va);           // { dg-error \"no match\" }\n+    sink_3_156(cva);          // { dg-error \"no match\" }\n+    sink_3_156(v_source());   // { dg-error \"no match\" }\n+    sink_3_156(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_157(               A&);  // { dg-error \"\" }\n+five  sink_3_157(               A&&);  // { dg-error \"\" }\n+seven sink_3_157(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_157()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_157(ca);           // { dg-error \"no match\" }\n+    sink_3_157(cva);          // { dg-error \"no match\" }\n+    sink_3_157(c_source());   // { dg-error \"no match\" }\n+    sink_3_157(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_3_167(               A&);  // { dg-error \"\" }\n+six   sink_3_167(const          A&&);  // { dg-error \"\" }\n+seven sink_3_167(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_167()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_167(cva);          // { dg-error \"no match\" }\n+    sink_3_167(source());     // { dg-error \"ambiguous\" }\n+    sink_3_167(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_234(const          A&);  // { dg-error \"\" }\n+three sink_3_234(volatile       A&);  // { dg-error \"\" }\n+four  sink_3_234(const volatile A&);  // { dg-error \"\" }\n+\n+int test3_234()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_234(a);            // { dg-error \"ambiguous\" }\n+    sink_3_234(v_source());   // { dg-error \"no match\" }\n+    sink_3_234(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_235(const          A&);  // { dg-error \"\" }\n+three sink_3_235(volatile       A&);  // { dg-error \"\" }\n+five  sink_3_235(               A&&);  // { dg-error \"\" }\n+\n+int test3_235()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_235(a);            // { dg-error \"ambiguous\" }\n+    sink_3_235(cva);          // { dg-error \"no match\" }\n+    sink_3_235(v_source());   // { dg-error \"no match\" }\n+    sink_3_235(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_236(const          A&);  // { dg-error \"\" }\n+three sink_3_236(volatile       A&);  // { dg-error \"\" }\n+six   sink_3_236(const          A&&);  // { dg-error \"\" }\n+\n+int test3_236()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_236(a);            // { dg-error \"ambiguous\" }\n+    sink_3_236(cva);          // { dg-error \"no match\" }\n+    sink_3_236(v_source());   // { dg-error \"no match\" }\n+    sink_3_236(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_237(const          A&);  // { dg-error \"\" }\n+three sink_3_237(volatile       A&);  // { dg-error \"\" }\n+seven sink_3_237(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_237()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_237(a);            // { dg-error \"ambiguous\" }\n+    sink_3_237(cva);          // { dg-error \"no match\" }\n+    sink_3_237(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_238(const          A&);  // { dg-error \"\" }\n+three sink_3_238(volatile       A&);  // { dg-error \"\" }\n+eight sink_3_238(const volatile A&&);  // { dg-error \"\" }\n+\n+int test3_238()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_238(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_3_245(const          A&);  // { dg-error \"\" }\n+four  sink_3_245(const volatile A&);  // { dg-error \"\" }\n+five  sink_3_245(               A&&);  // { dg-error \"\" }\n+\n+int test3_245()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_245(v_source());   // { dg-error \"no match\" }\n+    sink_3_245(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_246(const          A&);  // { dg-error \"\" }\n+four  sink_3_246(const volatile A&);  // { dg-error \"\" }\n+six   sink_3_246(const          A&&);  // { dg-error \"\" }\n+\n+int test3_246()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_246(v_source());   // { dg-error \"no match\" }\n+    sink_3_246(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_247(const          A&);  // { dg-error \"\" }\n+four  sink_3_247(const volatile A&);  // { dg-error \"\" }\n+seven sink_3_247(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_247()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_247(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_256(const          A&);  // { dg-error \"\" }\n+five  sink_3_256(               A&&);  // { dg-error \"\" }\n+six   sink_3_256(const          A&&);  // { dg-error \"\" }\n+\n+int test3_256()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_256(va);           // { dg-error \"no match\" }\n+    sink_3_256(cva);          // { dg-error \"no match\" }\n+    sink_3_256(v_source());   // { dg-error \"no match\" }\n+    sink_3_256(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_257(const          A&);  // { dg-error \"\" }\n+five  sink_3_257(               A&&);  // { dg-error \"\" }\n+seven sink_3_257(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_257()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_257(cva);          // { dg-error \"no match\" }\n+    sink_3_257(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_3_267(const          A&);  // { dg-error \"\" }\n+six   sink_3_267(const          A&&);  // { dg-error \"\" }\n+seven sink_3_267(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_267()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_267(cva);          // { dg-error \"no match\" }\n+    sink_3_267(source());     // { dg-error \"ambiguous\" }\n+    sink_3_267(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_3_345(volatile       A&);  // { dg-error \"\" }\n+four  sink_3_345(const volatile A&);  // { dg-error \"\" }\n+five  sink_3_345(               A&&);  // { dg-error \"\" }\n+\n+int test3_345()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_345(c_source());   // { dg-error \"no match\" }\n+    sink_3_345(v_source());   // { dg-error \"no match\" }\n+    sink_3_345(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_3_346(volatile       A&);  // { dg-error \"\" }\n+four  sink_3_346(const volatile A&);  // { dg-error \"\" }\n+six   sink_3_346(const          A&&);  // { dg-error \"\" }\n+\n+int test3_346()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_346(v_source());   // { dg-error \"no match\" }\n+    sink_3_346(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_3_347(volatile       A&);  // { dg-error \"\" }\n+four  sink_3_347(const volatile A&);  // { dg-error \"\" }\n+seven sink_3_347(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_347()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_347(c_source());   // { dg-error \"no match\" }\n+    sink_3_347(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_3_356(volatile       A&);  // { dg-error \"\" }\n+five  sink_3_356(               A&&);  // { dg-error \"\" }\n+six   sink_3_356(const          A&&);  // { dg-error \"\" }\n+\n+int test3_356()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_356(cva);          // { dg-error \"no match\" }\n+    sink_3_356(v_source());   // { dg-error \"no match\" }\n+    sink_3_356(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_3_357(volatile       A&);  // { dg-error \"\" }\n+five  sink_3_357(               A&&);  // { dg-error \"\" }\n+seven sink_3_357(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_357()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_357(ca);           // { dg-error \"no match\" }\n+    sink_3_357(cva);          // { dg-error \"no match\" }\n+    sink_3_357(c_source());   // { dg-error \"no match\" }\n+    sink_3_357(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_3_367(volatile       A&);  // { dg-error \"\" }\n+six   sink_3_367(const          A&&);  // { dg-error \"\" }\n+seven sink_3_367(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_367()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_367(cva);          // { dg-error \"no match\" }\n+    sink_3_367(source());     // { dg-error \"ambiguous\" }\n+    sink_3_367(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+four  sink_3_456(const volatile A&);  // { dg-error \"\" }\n+five  sink_3_456(               A&&);  // { dg-error \"\" }\n+six   sink_3_456(const          A&&);  // { dg-error \"\" }\n+\n+int test3_456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_456(v_source());   // { dg-error \"no match\" }\n+    sink_3_456(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+four  sink_3_457(const volatile A&);  // { dg-error \"\" }\n+five  sink_3_457(               A&&);  // { dg-error \"\" }\n+seven sink_3_457(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_457(c_source());   // { dg-error \"no match\" }\n+    sink_3_457(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+four  sink_3_467(const volatile A&);  // { dg-error \"\" }\n+six   sink_3_467(const          A&&);  // { dg-error \"\" }\n+seven sink_3_467(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_467(source());     // { dg-error \"ambiguous\" }\n+    sink_3_467(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+five  sink_3_567(               A&&);  // { dg-error \"\" }\n+six   sink_3_567(const          A&&);  // { dg-error \"\" }\n+seven sink_3_567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test3_567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_567(cva);          // { dg-error \"no match\" }\n+    sink_3_567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+six   sink_3_678(const          A&&);  // { dg-error \"\" }\n+seven sink_3_678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_3_678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test3_678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_3_678(a);          // { dg-error \"ambiguous\" }\n+    sink_3_678(source());   // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test3_123() + test3_125() + test3_126() + test3_127() +\n+           test3_135() + test3_136() + test3_137() + test3_156() +\n+           test3_157() + test3_167() + test3_234() + test3_235() +\n+           test3_236() + test3_237() + test3_238() + test3_256() +\n+           test3_257() + test3_267() + test3_356() + test3_357() +\n+           test3_367() + test3_467() + test3_567() + test3_678();\n+}"}, {"sha": "c688b11e2367a7e0fb82b4a21d26b0536a6f93b8", "filename": "gcc/testsuite/g++.dg/cpp0x/rv3p.C", "status": "added", "additions": 1120, "deletions": 0, "changes": 1120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv3p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv3p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv3p.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,1120 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 3 at a time\n+\n+one   sink_3_123(               A&);\n+two   sink_3_123(const          A&);\n+three sink_3_123(volatile       A&);\n+\n+int test3_123()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_123(a))           == 1> t1;\n+    sa<sizeof(sink_3_123(ca))          == 2> t2;\n+    sa<sizeof(sink_3_123(va))          == 3> t3;\n+    sa<sizeof(sink_3_123(source()))    == 2> t5;\n+    sa<sizeof(sink_3_123(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+one   sink_3_124(               A&);\n+two   sink_3_124(const          A&);\n+four  sink_3_124(const volatile A&);\n+\n+int test3_124()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_124(a))           == 1> t1;\n+    sa<sizeof(sink_3_124(ca))          == 2> t2;\n+    sa<sizeof(sink_3_124(va))          == 4> t3;\n+    sa<sizeof(sink_3_124(cva))         == 4> t4;\n+    sa<sizeof(sink_3_124(source()))    == 2> t5;\n+    sa<sizeof(sink_3_124(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+one   sink_3_125(               A&);\n+two   sink_3_125(const          A&);\n+five  sink_3_125(               A&&);\n+\n+int test3_125()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_125(a))           == 1> t1;\n+    sa<sizeof(sink_3_125(ca))          == 2> t2;\n+    sa<sizeof(sink_3_125(source()))    == 5> t5;\n+    sa<sizeof(sink_3_125(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+one   sink_3_126(               A&);\n+two   sink_3_126(const          A&);\n+six   sink_3_126(const          A&&);\n+\n+int test3_126()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_126(a))           == 1> t1;\n+    sa<sizeof(sink_3_126(ca))          == 2> t2;\n+    sa<sizeof(sink_3_126(source()))    == 6> t5;\n+    sa<sizeof(sink_3_126(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_3_127(               A&);\n+two   sink_3_127(const          A&);\n+seven sink_3_127(volatile       A&&);\n+\n+int test3_127()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_127(a))           == 1> t1;\n+    sa<sizeof(sink_3_127(ca))          == 2> t2;\n+    sa<sizeof(sink_3_127(va))          == 7> t3;\n+    sa<sizeof(sink_3_127(source()))    == 7> t5;\n+    sa<sizeof(sink_3_127(c_source()))  == 2> t6;\n+    sa<sizeof(sink_3_127(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_3_128(               A&);\n+two   sink_3_128(const          A&);\n+eight sink_3_128(const volatile A&&);\n+\n+int test3_128()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_128(a))           == 1> t1;\n+    sa<sizeof(sink_3_128(ca))          == 2> t2;\n+    sa<sizeof(sink_3_128(va))          == 8> t3;\n+    sa<sizeof(sink_3_128(cva))         == 8> t4;\n+    sa<sizeof(sink_3_128(source()))    == 8> t5;\n+    sa<sizeof(sink_3_128(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_128(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_128(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_3_134(               A&);\n+three sink_3_134(volatile       A&);\n+four  sink_3_134(const volatile A&);\n+\n+int test3_134()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_134(a))           == 1> t1;\n+    sa<sizeof(sink_3_134(ca))          == 4> t2;\n+    sa<sizeof(sink_3_134(va))          == 3> t3;\n+    sa<sizeof(sink_3_134(cva))         == 4> t4;\n+    return 0;\n+}\n+\n+one   sink_3_135(               A&);\n+three sink_3_135(volatile       A&);\n+five  sink_3_135(               A&&);\n+\n+int test3_135()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_135(a))           == 1> t1;\n+    sa<sizeof(sink_3_135(va))          == 3> t3;\n+    sa<sizeof(sink_3_135(source()))    == 5> t5;\n+    return 0;\n+}\n+\n+one   sink_3_136(               A&);\n+three sink_3_136(volatile       A&);\n+six   sink_3_136(const          A&&);\n+\n+int test3_136()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_136(a))           == 1> t1;\n+    sa<sizeof(sink_3_136(ca))          == 6> t2;\n+    sa<sizeof(sink_3_136(va))          == 3> t3;\n+    sa<sizeof(sink_3_136(source()))    == 6> t5;\n+    sa<sizeof(sink_3_136(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_3_137(               A&);\n+three sink_3_137(volatile       A&);\n+seven sink_3_137(volatile       A&&);\n+\n+int test3_137()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_137(a))           == 1> t1;\n+    sa<sizeof(sink_3_137(va))          == 3> t3;\n+    sa<sizeof(sink_3_137(source()))    == 7> t5;\n+    sa<sizeof(sink_3_137(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_3_138(               A&);\n+three sink_3_138(volatile       A&);\n+eight sink_3_138(const volatile A&&);\n+\n+int test3_138()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_138(a))           == 1> t1;\n+    sa<sizeof(sink_3_138(ca))          == 8> t2;\n+    sa<sizeof(sink_3_138(va))          == 3> t3;\n+    sa<sizeof(sink_3_138(cva))         == 8> t4;\n+    sa<sizeof(sink_3_138(source()))    == 8> t5;\n+    sa<sizeof(sink_3_138(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_138(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_138(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_3_145(               A&);\n+four  sink_3_145(const volatile A&);\n+five  sink_3_145(               A&&);\n+\n+int test3_145()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_145(a))           == 1> t1;\n+    sa<sizeof(sink_3_145(ca))          == 4> t2;\n+    sa<sizeof(sink_3_145(va))          == 4> t3;\n+    sa<sizeof(sink_3_145(cva))         == 4> t4;\n+    sa<sizeof(sink_3_145(source()))    == 5> t5;\n+    return 0;\n+}\n+\n+one   sink_3_146(               A&);\n+four  sink_3_146(const volatile A&);\n+six   sink_3_146(const          A&&);\n+\n+int test3_146()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_146(a))           == 1> t1;\n+    sa<sizeof(sink_3_146(ca))          == 4> t2;\n+    sa<sizeof(sink_3_146(va))          == 4> t3;\n+    sa<sizeof(sink_3_146(cva))         == 4> t4;\n+    sa<sizeof(sink_3_146(source()))    == 6> t5;\n+    sa<sizeof(sink_3_146(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_3_147(               A&);\n+four  sink_3_147(const volatile A&);\n+seven sink_3_147(volatile       A&&);\n+\n+int test3_147()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_147(a))           == 1> t1;\n+    sa<sizeof(sink_3_147(ca))          == 4> t2;\n+    sa<sizeof(sink_3_147(va))          == 4> t3;\n+    sa<sizeof(sink_3_147(cva))         == 4> t4;\n+    sa<sizeof(sink_3_147(source()))    == 7> t5;\n+    sa<sizeof(sink_3_147(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_3_148(               A&);\n+four  sink_3_148(const volatile A&);\n+eight sink_3_148(const volatile A&&);\n+\n+int test3_148()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_148(a))           == 1> t1;\n+    sa<sizeof(sink_3_148(ca))          == 4> t2;\n+    sa<sizeof(sink_3_148(va))          == 4> t3;\n+    sa<sizeof(sink_3_148(cva))         == 4> t4;\n+    sa<sizeof(sink_3_148(source()))    == 8> t5;\n+    sa<sizeof(sink_3_148(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_148(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_148(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_3_156(               A&);\n+five  sink_3_156(               A&&);\n+six   sink_3_156(const          A&&);\n+\n+int test3_156()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_156(a))           == 1> t1;\n+    sa<sizeof(sink_3_156(ca))          == 6> t2;\n+    sa<sizeof(sink_3_156(source()))    == 5> t5;\n+    sa<sizeof(sink_3_156(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_3_157(               A&);\n+five  sink_3_157(               A&&);\n+seven sink_3_157(volatile       A&&);\n+\n+int test3_157()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_157(a))           == 1> t1;\n+    sa<sizeof(sink_3_157(va))          == 7> t3;\n+    sa<sizeof(sink_3_157(source()))    == 5> t5;\n+    sa<sizeof(sink_3_157(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_3_158(               A&);\n+five  sink_3_158(               A&&);\n+eight sink_3_158(const volatile A&&);\n+\n+int test3_158()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_158(a))           == 1> t1;\n+    sa<sizeof(sink_3_158(ca))          == 8> t2;\n+    sa<sizeof(sink_3_158(va))          == 8> t3;\n+    sa<sizeof(sink_3_158(cva))         == 8> t4;\n+    sa<sizeof(sink_3_158(source()))    == 5> t5;\n+    sa<sizeof(sink_3_158(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_158(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_158(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_3_167(               A&);\n+six   sink_3_167(const          A&&);\n+seven sink_3_167(volatile       A&&);\n+\n+int test3_167()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_167(a))           == 1> t1;\n+    sa<sizeof(sink_3_167(ca))          == 6> t2;\n+    sa<sizeof(sink_3_167(va))          == 7> t3;\n+    sa<sizeof(sink_3_167(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_167(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_3_168(               A&);\n+six   sink_3_168(const          A&&);\n+eight sink_3_168(const volatile A&&);\n+\n+int test3_168()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_168(a))           == 1> t1;\n+    sa<sizeof(sink_3_168(ca))          == 6> t2;\n+    sa<sizeof(sink_3_168(va))          == 8> t3;\n+    sa<sizeof(sink_3_168(cva))         == 8> t4;\n+    sa<sizeof(sink_3_168(source()))    == 6> t5;\n+    sa<sizeof(sink_3_168(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_168(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_168(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_3_178(               A&);\n+seven sink_3_178(volatile       A&&);\n+eight sink_3_178(const volatile A&&);\n+\n+int test3_178()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_178(a))           == 1> t1;\n+    sa<sizeof(sink_3_178(ca))          == 8> t2;\n+    sa<sizeof(sink_3_178(va))          == 7> t3;\n+    sa<sizeof(sink_3_178(cva))         == 8> t4;\n+    sa<sizeof(sink_3_178(source()))    == 7> t5;\n+    sa<sizeof(sink_3_178(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_178(v_source()))  == 7> t7;\n+    sa<sizeof(sink_3_178(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_3_234(const          A&);\n+three sink_3_234(volatile       A&);\n+four  sink_3_234(const volatile A&);\n+\n+int test3_234()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_234(ca))          == 2> t2;\n+    sa<sizeof(sink_3_234(va))          == 3> t3;\n+    sa<sizeof(sink_3_234(cva))         == 4> t4;\n+    sa<sizeof(sink_3_234(source()))    == 2> t5;\n+    sa<sizeof(sink_3_234(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+two   sink_3_235(const          A&);\n+three sink_3_235(volatile       A&);\n+five  sink_3_235(               A&&);\n+\n+int test3_235()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_235(ca))          == 2> t2;\n+    sa<sizeof(sink_3_235(va))          == 3> t3;\n+    sa<sizeof(sink_3_235(source()))    == 5> t5;\n+    sa<sizeof(sink_3_235(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+two   sink_3_236(const          A&);\n+three sink_3_236(volatile       A&);\n+six   sink_3_236(const          A&&);\n+\n+int test3_236()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_236(ca))          == 2> t2;\n+    sa<sizeof(sink_3_236(va))          == 3> t3;\n+    sa<sizeof(sink_3_236(source()))    == 6> t5;\n+    sa<sizeof(sink_3_236(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+two   sink_3_237(const          A&);\n+three sink_3_237(volatile       A&);\n+seven sink_3_237(volatile       A&&);\n+\n+int test3_237()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_237(ca))          == 2> t2;\n+    sa<sizeof(sink_3_237(va))          == 3> t3;\n+    sa<sizeof(sink_3_237(source()))    == 7> t5;\n+    sa<sizeof(sink_3_237(c_source()))  == 2> t6;\n+    sa<sizeof(sink_3_237(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_3_238(const          A&);\n+three sink_3_238(volatile       A&);\n+eight sink_3_238(const volatile A&&);\n+\n+int test3_238()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_238(ca))          == 2> t2;\n+    sa<sizeof(sink_3_238(va))          == 3> t3;\n+    sa<sizeof(sink_3_238(cva))         == 8> t4;\n+    sa<sizeof(sink_3_238(source()))    == 8> t5;\n+    sa<sizeof(sink_3_238(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_238(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_238(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_3_245(const          A&);\n+four  sink_3_245(const volatile A&);\n+five  sink_3_245(               A&&);\n+\n+int test3_245()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_245(a))           == 2> t1;\n+    sa<sizeof(sink_3_245(ca))          == 2> t2;\n+    sa<sizeof(sink_3_245(va))          == 4> t3;\n+    sa<sizeof(sink_3_245(cva))         == 4> t4;\n+    sa<sizeof(sink_3_245(source()))    == 5> t5;\n+    sa<sizeof(sink_3_245(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+two   sink_3_246(const          A&);\n+four  sink_3_246(const volatile A&);\n+six   sink_3_246(const          A&&);\n+\n+int test3_246()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_246(a))           == 2> t1;\n+    sa<sizeof(sink_3_246(ca))          == 2> t2;\n+    sa<sizeof(sink_3_246(va))          == 4> t3;\n+    sa<sizeof(sink_3_246(cva))         == 4> t4;\n+    sa<sizeof(sink_3_246(source()))    == 6> t5;\n+    sa<sizeof(sink_3_246(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+two   sink_3_247(const          A&);\n+four  sink_3_247(const volatile A&);\n+seven sink_3_247(volatile       A&&);\n+\n+int test3_247()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_247(a))           == 2> t1;\n+    sa<sizeof(sink_3_247(ca))          == 2> t2;\n+    sa<sizeof(sink_3_247(va))          == 4> t3;\n+    sa<sizeof(sink_3_247(cva))         == 4> t4;\n+    sa<sizeof(sink_3_247(source()))    == 7> t5;\n+    sa<sizeof(sink_3_247(c_source()))  == 2> t6;\n+    sa<sizeof(sink_3_247(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_3_248(const          A&);\n+four  sink_3_248(const volatile A&);\n+eight sink_3_248(const volatile A&&);\n+\n+int test3_248()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_248(a))           == 2> t1;\n+    sa<sizeof(sink_3_248(ca))          == 2> t2;\n+    sa<sizeof(sink_3_248(va))          == 4> t3;\n+    sa<sizeof(sink_3_248(cva))         == 4> t4;\n+    sa<sizeof(sink_3_248(source()))    == 8> t5;\n+    sa<sizeof(sink_3_248(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_248(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_248(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_3_256(const          A&);\n+five  sink_3_256(               A&&);\n+six   sink_3_256(const          A&&);\n+\n+int test3_256()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_256(a))           == 2> t1;\n+    sa<sizeof(sink_3_256(ca))          == 2> t2;\n+    sa<sizeof(sink_3_256(source()))    == 5> t5;\n+    sa<sizeof(sink_3_256(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+two   sink_3_257(const          A&);\n+five  sink_3_257(               A&&);\n+seven sink_3_257(volatile       A&&);\n+\n+int test3_257()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_257(a))           == 2> t1;\n+    sa<sizeof(sink_3_257(ca))          == 2> t2;\n+    sa<sizeof(sink_3_257(va))          == 7> t3;\n+    sa<sizeof(sink_3_257(source()))    == 5> t5;\n+    sa<sizeof(sink_3_257(c_source()))  == 2> t6;\n+    sa<sizeof(sink_3_257(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_3_258(const          A&);\n+five  sink_3_258(               A&&);\n+eight sink_3_258(const volatile A&&);\n+\n+int test3_258()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_258(a))           == 2> t1;\n+    sa<sizeof(sink_3_258(ca))          == 2> t2;\n+    sa<sizeof(sink_3_258(va))          == 8> t3;\n+    sa<sizeof(sink_3_258(cva))         == 8> t4;\n+    sa<sizeof(sink_3_258(source()))    == 5> t5;\n+    sa<sizeof(sink_3_258(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_258(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_258(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_3_267(const          A&);\n+six   sink_3_267(const          A&&);\n+seven sink_3_267(volatile       A&&);\n+\n+int test3_267()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_267(a))           == 2> t1;\n+    sa<sizeof(sink_3_267(ca))          == 2> t2;\n+    sa<sizeof(sink_3_267(va))          == 7> t3;\n+    sa<sizeof(sink_3_267(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_267(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_3_268(const          A&);\n+six   sink_3_268(const          A&&);\n+eight sink_3_268(const volatile A&&);\n+\n+int test3_268()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_268(a))           == 2> t1;\n+    sa<sizeof(sink_3_268(ca))          == 2> t2;\n+    sa<sizeof(sink_3_268(va))          == 8> t3;\n+    sa<sizeof(sink_3_268(cva))         == 8> t4;\n+    sa<sizeof(sink_3_268(source()))    == 6> t5;\n+    sa<sizeof(sink_3_268(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_268(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_268(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_3_278(const          A&);\n+seven sink_3_278(volatile       A&&);\n+eight sink_3_278(const volatile A&&);\n+\n+int test3_278()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_278(a))           == 2> t1;\n+    sa<sizeof(sink_3_278(ca))          == 2> t2;\n+    sa<sizeof(sink_3_278(va))          == 7> t3;\n+    sa<sizeof(sink_3_278(cva))         == 8> t4;\n+    sa<sizeof(sink_3_278(source()))    == 7> t5;\n+    sa<sizeof(sink_3_278(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_278(v_source()))  == 7> t7;\n+    sa<sizeof(sink_3_278(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_3_345(volatile       A&);\n+four  sink_3_345(const volatile A&);\n+five  sink_3_345(               A&&);\n+\n+int test3_345()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_345(a))           == 3> t1;\n+    sa<sizeof(sink_3_345(ca))          == 4> t2;\n+    sa<sizeof(sink_3_345(va))          == 3> t3;\n+    sa<sizeof(sink_3_345(cva))         == 4> t4;\n+    sa<sizeof(sink_3_345(source()))    == 5> t5;\n+    return 0;\n+}\n+\n+three sink_3_346(volatile       A&);\n+four  sink_3_346(const volatile A&);\n+six   sink_3_346(const          A&&);\n+\n+int test3_346()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_346(a))           == 3> t1;\n+    sa<sizeof(sink_3_346(ca))          == 4> t2;\n+    sa<sizeof(sink_3_346(va))          == 3> t3;\n+    sa<sizeof(sink_3_346(cva))         == 4> t4;\n+    sa<sizeof(sink_3_346(source()))    == 6> t5;\n+    sa<sizeof(sink_3_346(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+three sink_3_347(volatile       A&);\n+four  sink_3_347(const volatile A&);\n+seven sink_3_347(volatile       A&&);\n+\n+int test3_347()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_347(a))           == 3> t1;\n+    sa<sizeof(sink_3_347(ca))          == 4> t2;\n+    sa<sizeof(sink_3_347(va))          == 3> t3;\n+    sa<sizeof(sink_3_347(cva))         == 4> t4;\n+    sa<sizeof(sink_3_347(source()))    == 7> t5;\n+    sa<sizeof(sink_3_347(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+three sink_3_348(volatile       A&);\n+four  sink_3_348(const volatile A&);\n+eight sink_3_348(const volatile A&&);\n+\n+int test3_348()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_348(a))           == 3> t1;\n+    sa<sizeof(sink_3_348(ca))          == 4> t2;\n+    sa<sizeof(sink_3_348(va))          == 3> t3;\n+    sa<sizeof(sink_3_348(cva))         == 4> t4;\n+    sa<sizeof(sink_3_348(source()))    == 8> t5;\n+    sa<sizeof(sink_3_348(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_348(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_348(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_3_356(volatile       A&);\n+five  sink_3_356(               A&&);\n+six   sink_3_356(const          A&&);\n+\n+int test3_356()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_356(a))           == 3> t1;\n+    sa<sizeof(sink_3_356(ca))          == 6> t2;\n+    sa<sizeof(sink_3_356(va))          == 3> t3;\n+    sa<sizeof(sink_3_356(source()))    == 5> t5;\n+    sa<sizeof(sink_3_356(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+three sink_3_357(volatile       A&);\n+five  sink_3_357(               A&&);\n+seven sink_3_357(volatile       A&&);\n+\n+int test3_357()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_357(a))           == 3> t1;\n+    sa<sizeof(sink_3_357(va))          == 3> t3;\n+    sa<sizeof(sink_3_357(source()))    == 5> t5;\n+    sa<sizeof(sink_3_357(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+three sink_3_358(volatile       A&);\n+five  sink_3_358(               A&&);\n+eight sink_3_358(const volatile A&&);\n+\n+int test3_358()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_358(a))           == 3> t1;\n+    sa<sizeof(sink_3_358(ca))          == 8> t2;\n+    sa<sizeof(sink_3_358(va))          == 3> t3;\n+    sa<sizeof(sink_3_358(cva))         == 8> t4;\n+    sa<sizeof(sink_3_358(source()))    == 5> t5;\n+    sa<sizeof(sink_3_358(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_358(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_358(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_3_367(volatile       A&);\n+six   sink_3_367(const          A&&);\n+seven sink_3_367(volatile       A&&);\n+\n+int test3_367()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_367(a))           == 3> t1;\n+    sa<sizeof(sink_3_367(ca))          == 6> t2;\n+    sa<sizeof(sink_3_367(va))          == 3> t3;\n+    sa<sizeof(sink_3_367(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_367(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+three sink_3_368(volatile       A&);\n+six   sink_3_368(const          A&&);\n+eight sink_3_368(const volatile A&&);\n+\n+int test3_368()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_368(a))           == 3> t1;\n+    sa<sizeof(sink_3_368(ca))          == 6> t2;\n+    sa<sizeof(sink_3_368(va))          == 3> t3;\n+    sa<sizeof(sink_3_368(cva))         == 8> t4;\n+    sa<sizeof(sink_3_368(source()))    == 6> t5;\n+    sa<sizeof(sink_3_368(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_368(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_368(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_3_378(volatile       A&);\n+seven sink_3_378(volatile       A&&);\n+eight sink_3_378(const volatile A&&);\n+\n+int test3_378()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_378(a))           == 3> t1;\n+    sa<sizeof(sink_3_378(ca))          == 8> t2;\n+    sa<sizeof(sink_3_378(va))          == 3> t3;\n+    sa<sizeof(sink_3_378(cva))         == 8> t4;\n+    sa<sizeof(sink_3_378(source()))    == 7> t5;\n+    sa<sizeof(sink_3_378(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_378(v_source()))  == 7> t7;\n+    sa<sizeof(sink_3_378(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+four  sink_3_456(const volatile A&);\n+five  sink_3_456(               A&&);\n+six   sink_3_456(const          A&&);\n+\n+int test3_456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_456(a))           == 4> t1;\n+    sa<sizeof(sink_3_456(ca))          == 4> t2;\n+    sa<sizeof(sink_3_456(va))          == 4> t3;\n+    sa<sizeof(sink_3_456(cva))         == 4> t4;\n+    sa<sizeof(sink_3_456(source()))    == 5> t5;\n+    sa<sizeof(sink_3_456(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+four  sink_3_457(const volatile A&);\n+five  sink_3_457(               A&&);\n+seven sink_3_457(volatile       A&&);\n+\n+int test3_457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_457(a))           == 4> t1;\n+    sa<sizeof(sink_3_457(ca))          == 4> t2;\n+    sa<sizeof(sink_3_457(va))          == 4> t3;\n+    sa<sizeof(sink_3_457(cva))         == 4> t4;\n+    sa<sizeof(sink_3_457(source()))    == 5> t5;\n+    sa<sizeof(sink_3_457(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+four  sink_3_458(const volatile A&);\n+five  sink_3_458(               A&&);\n+eight sink_3_458(const volatile A&&);\n+\n+int test3_458()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_458(a))           == 4> t1;\n+    sa<sizeof(sink_3_458(ca))          == 4> t2;\n+    sa<sizeof(sink_3_458(va))          == 4> t3;\n+    sa<sizeof(sink_3_458(cva))         == 4> t4;\n+    sa<sizeof(sink_3_458(source()))    == 5> t5;\n+    sa<sizeof(sink_3_458(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_458(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_458(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+four  sink_3_467(const volatile A&);\n+six   sink_3_467(const          A&&);\n+seven sink_3_467(volatile       A&&);\n+\n+int test3_467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_467(a))           == 4> t1;\n+    sa<sizeof(sink_3_467(ca))          == 4> t2;\n+    sa<sizeof(sink_3_467(va))          == 4> t3;\n+    sa<sizeof(sink_3_467(cva))         == 4> t4;\n+    sa<sizeof(sink_3_467(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_467(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+four  sink_3_468(const volatile A&);\n+six   sink_3_468(const          A&&);\n+eight sink_3_468(const volatile A&&);\n+\n+int test3_468()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_468(a))           == 4> t1;\n+    sa<sizeof(sink_3_468(ca))          == 4> t2;\n+    sa<sizeof(sink_3_468(va))          == 4> t3;\n+    sa<sizeof(sink_3_468(cva))         == 4> t4;\n+    sa<sizeof(sink_3_468(source()))    == 6> t5;\n+    sa<sizeof(sink_3_468(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_468(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_468(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+four  sink_3_478(const volatile A&);\n+seven sink_3_478(volatile       A&&);\n+eight sink_3_478(const volatile A&&);\n+\n+int test3_478()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_478(a))           == 4> t1;\n+    sa<sizeof(sink_3_478(ca))          == 4> t2;\n+    sa<sizeof(sink_3_478(va))          == 4> t3;\n+    sa<sizeof(sink_3_478(cva))         == 4> t4;\n+    sa<sizeof(sink_3_478(source()))    == 7> t5;\n+    sa<sizeof(sink_3_478(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_478(v_source()))  == 7> t7;\n+    sa<sizeof(sink_3_478(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+five  sink_3_567(               A&&);\n+six   sink_3_567(const          A&&);\n+seven sink_3_567(volatile       A&&);\n+\n+int test3_567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_567(a))           == 5> t1;\n+    sa<sizeof(sink_3_567(ca))          == 6> t2;\n+    sa<sizeof(sink_3_567(va))          == 7> t3;\n+    sa<sizeof(sink_3_567(source()))    == 5> t5;\n+    sa<sizeof(sink_3_567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+five  sink_3_568(               A&&);\n+six   sink_3_568(const          A&&);\n+eight sink_3_568(const volatile A&&);\n+\n+int test3_568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_568(a))           == 5> t1;\n+    sa<sizeof(sink_3_568(ca))          == 6> t2;\n+    sa<sizeof(sink_3_568(va))          == 8> t3;\n+    sa<sizeof(sink_3_568(cva))         == 8> t4;\n+    sa<sizeof(sink_3_568(source()))    == 5> t5;\n+    sa<sizeof(sink_3_568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_3_568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+five  sink_3_578(               A&&);\n+seven sink_3_578(volatile       A&&);\n+eight sink_3_578(const volatile A&&);\n+\n+int test3_578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_578(a))           == 5> t1;\n+    sa<sizeof(sink_3_578(ca))          == 8> t2;\n+    sa<sizeof(sink_3_578(va))          == 7> t3;\n+    sa<sizeof(sink_3_578(cva))         == 8> t4;\n+    sa<sizeof(sink_3_578(source()))    == 5> t5;\n+    sa<sizeof(sink_3_578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_3_578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_3_578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+six   sink_3_678(const          A&&);\n+seven sink_3_678(volatile       A&&);\n+eight sink_3_678(const volatile A&&);\n+\n+int test3_678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_3_678(ca))          == 6> t2;\n+    sa<sizeof(sink_3_678(va))          == 7> t3;\n+    sa<sizeof(sink_3_678(cva))         == 8> t4;\n+    sa<sizeof(sink_3_678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_3_678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_3_678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test3_123() + test3_124() + test3_125() + test3_126() +\n+           test3_127() + test3_128() + test3_134() + test3_135() +\n+           test3_136() + test3_137() + test3_138() + test3_145() +\n+           test3_146() + test3_147() + test3_148() + test3_156() +\n+           test3_157() + test3_158() + test3_167() + test3_168() +\n+           test3_178() + test3_234() + test3_235() + test3_236() +\n+           test3_237() + test3_238() + test3_245() + test3_246() +\n+           test3_247() + test3_248() + test3_256() + test3_257() +\n+           test3_258() + test3_267() + test3_268() + test3_278() +\n+           test3_345() + test3_346() + test3_347() + test3_348() +\n+           test3_356() + test3_357() + test3_358() + test3_367() +\n+           test3_368() + test3_378() + test3_456() + test3_457() +\n+           test3_458() + test3_467() + test3_468() + test3_478() +\n+           test3_567() + test3_568() + test3_578() + test3_678();\n+}"}, {"sha": "302ab8eedcc756abf1d10f2a233908c922a6c6f6", "filename": "gcc/testsuite/g++.dg/cpp0x/rv4n.C", "status": "added", "additions": 735, "deletions": 0, "changes": 735, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv4n.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv4n.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv4n.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,735 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 4 at a time\n+\n+one   sink_4_1234(               A&);  // { dg-error \"\" }\n+two   sink_4_1234(const          A&);  // { dg-error \"\" }\n+three sink_4_1234(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_1234(const volatile A&);  // { dg-error \"\" }\n+\n+int test4_1234()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1234(v_source());   // { dg-error \"no match\" }\n+    sink_4_1234(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1235(               A&);  // { dg-error \"\" }\n+two   sink_4_1235(const          A&);  // { dg-error \"\" }\n+three sink_4_1235(volatile       A&);  // { dg-error \"\" }\n+five  sink_4_1235(               A&&);  // { dg-error \"\" }\n+\n+int test4_1235()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1235(cva);          // { dg-error \"no match\" }\n+    sink_4_1235(v_source());   // { dg-error \"no match\" }\n+    sink_4_1235(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1236(               A&);  // { dg-error \"\" }\n+two   sink_4_1236(const          A&);  // { dg-error \"\" }\n+three sink_4_1236(volatile       A&);  // { dg-error \"\" }\n+six   sink_4_1236(const          A&&);  // { dg-error \"\" }\n+\n+int test4_1236()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1236(cva);          // { dg-error \"no match\" }\n+    sink_4_1236(v_source());   // { dg-error \"no match\" }\n+    sink_4_1236(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1237(               A&);  // { dg-error \"\" }\n+two   sink_4_1237(const          A&);  // { dg-error \"\" }\n+three sink_4_1237(volatile       A&);  // { dg-error \"\" }\n+seven sink_4_1237(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1237()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1237(cva);          // { dg-error \"no match\" }\n+    sink_4_1237(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1245(               A&);  // { dg-error \"\" }\n+two   sink_4_1245(const          A&);  // { dg-error \"\" }\n+four  sink_4_1245(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_1245(               A&&);  // { dg-error \"\" }\n+\n+int test4_1245()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1245(v_source());   // { dg-error \"no match\" }\n+    sink_4_1245(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1246(               A&);  // { dg-error \"\" }\n+two   sink_4_1246(const          A&);  // { dg-error \"\" }\n+four  sink_4_1246(const volatile A&);  // { dg-error \"\" }\n+six   sink_4_1246(const          A&&);  // { dg-error \"\" }\n+\n+int test4_1246()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1246(v_source());   // { dg-error \"no match\" }\n+    sink_4_1246(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1247(               A&);  // { dg-error \"\" }\n+two   sink_4_1247(const          A&);  // { dg-error \"\" }\n+four  sink_4_1247(const volatile A&);  // { dg-error \"\" }\n+seven sink_4_1247(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1247()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1247(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1256(               A&);  // { dg-error \"\" }\n+two   sink_4_1256(const          A&);  // { dg-error \"\" }\n+five  sink_4_1256(               A&&);  // { dg-error \"\" }\n+six   sink_4_1256(const          A&&);  // { dg-error \"\" }\n+\n+int test4_1256()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1256(va);           // { dg-error \"no match\" }\n+    sink_4_1256(cva);          // { dg-error \"no match\" }\n+    sink_4_1256(v_source());   // { dg-error \"no match\" }\n+    sink_4_1256(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1257(               A&);  // { dg-error \"\" }\n+two   sink_4_1257(const          A&);  // { dg-error \"\" }\n+five  sink_4_1257(               A&&);  // { dg-error \"\" }\n+seven sink_4_1257(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1257()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1257(cva);          // { dg-error \"no match\" }\n+    sink_4_1257(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1267(               A&);  // { dg-error \"\" }\n+two   sink_4_1267(const          A&);  // { dg-error \"\" }\n+six   sink_4_1267(const          A&&);  // { dg-error \"\" }\n+seven sink_4_1267(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1267()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1267(cva);          // { dg-error \"no match\" }\n+    sink_4_1267(source());     // { dg-error \"ambiguous\" }\n+    sink_4_1267(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1345(               A&);  // { dg-error \"\" }\n+three sink_4_1345(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_1345(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_1345(               A&&);  // { dg-error \"\" }\n+\n+int test4_1345()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1345(c_source());   // { dg-error \"no match\" }\n+    sink_4_1345(v_source());   // { dg-error \"no match\" }\n+    sink_4_1345(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1346(               A&);  // { dg-error \"\" }\n+three sink_4_1346(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_1346(const volatile A&);  // { dg-error \"\" }\n+six   sink_4_1346(const          A&&);  // { dg-error \"\" }\n+\n+int test4_1346()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1346(v_source());   // { dg-error \"no match\" }\n+    sink_4_1346(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1347(               A&);  // { dg-error \"\" }\n+three sink_4_1347(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_1347(const volatile A&);  // { dg-error \"\" }\n+seven sink_4_1347(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1347()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1347(c_source());   // { dg-error \"no match\" }\n+    sink_4_1347(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1356(               A&);  // { dg-error \"\" }\n+three sink_4_1356(volatile       A&);  // { dg-error \"\" }\n+five  sink_4_1356(               A&&);  // { dg-error \"\" }\n+six   sink_4_1356(const          A&&);  // { dg-error \"\" }\n+\n+int test4_1356()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1356(cva);          // { dg-error \"no match\" }\n+    sink_4_1356(v_source());   // { dg-error \"no match\" }\n+    sink_4_1356(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1357(               A&);  // { dg-error \"\" }\n+three sink_4_1357(volatile       A&);  // { dg-error \"\" }\n+five  sink_4_1357(               A&&);  // { dg-error \"\" }\n+seven sink_4_1357(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1357()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1357(ca);           // { dg-error \"no match\" }\n+    sink_4_1357(cva);          // { dg-error \"no match\" }\n+    sink_4_1357(c_source());   // { dg-error \"no match\" }\n+    sink_4_1357(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1367(               A&);  // { dg-error \"\" }\n+three sink_4_1367(volatile       A&);  // { dg-error \"\" }\n+six   sink_4_1367(const          A&&);  // { dg-error \"\" }\n+seven sink_4_1367(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1367()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1367(cva);          // { dg-error \"no match\" }\n+    sink_4_1367(source());     // { dg-error \"ambiguous\" }\n+    sink_4_1367(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1456(               A&);  // { dg-error \"\" }\n+four  sink_4_1456(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_1456(               A&&);  // { dg-error \"\" }\n+six   sink_4_1456(const          A&&);  // { dg-error \"\" }\n+\n+int test4_1456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1456(v_source());   // { dg-error \"no match\" }\n+    sink_4_1456(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1457(               A&);  // { dg-error \"\" }\n+four  sink_4_1457(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_1457(               A&&);  // { dg-error \"\" }\n+seven sink_4_1457(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1457(c_source());   // { dg-error \"no match\" }\n+    sink_4_1457(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1467(               A&);  // { dg-error \"\" }\n+four  sink_4_1467(const volatile A&);  // { dg-error \"\" }\n+six   sink_4_1467(const          A&&);  // { dg-error \"\" }\n+seven sink_4_1467(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1467(source());     // { dg-error \"ambiguous\" }\n+    sink_4_1467(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1567(               A&);  // { dg-error \"\" }\n+five  sink_4_1567(               A&&);  // { dg-error \"\" }\n+six   sink_4_1567(const          A&&);  // { dg-error \"\" }\n+seven sink_4_1567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_1567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1567(cva);          // { dg-error \"no match\" }\n+    sink_4_1567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_4_1678(               A&);\n+six   sink_4_1678(const          A&&);  // { dg-error \"\" }\n+seven sink_4_1678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_4_1678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test4_1678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_1678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_4_2345(const          A&);  // { dg-error \"\" }\n+three sink_4_2345(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_2345(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_2345(               A&&);  // { dg-error \"\" }\n+\n+int test4_2345()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2345(a);            // { dg-error \"ambiguous\" }\n+    sink_4_2345(v_source());   // { dg-error \"no match\" }\n+    sink_4_2345(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2346(const          A&);  // { dg-error \"\" }\n+three sink_4_2346(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_2346(const volatile A&);  // { dg-error \"\" }\n+six   sink_4_2346(const          A&&);  // { dg-error \"\" }\n+\n+int test4_2346()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2346(a);            // { dg-error \"ambiguous\" }\n+    sink_4_2346(v_source());   // { dg-error \"no match\" }\n+    sink_4_2346(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2347(const          A&);  // { dg-error \"\" }\n+three sink_4_2347(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_2347(const volatile A&);  // { dg-error \"\" }\n+seven sink_4_2347(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_2347()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2347(a);            // { dg-error \"ambiguous\" }\n+    sink_4_2347(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2348(const          A&);  // { dg-error \"\" }\n+three sink_4_2348(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_2348(const volatile A&);  // { dg-error \"\" }\n+eight sink_4_2348(const volatile A&&);  // { dg-error \"\" }\n+\n+int test4_2348()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2348(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_4_2356(const          A&);  // { dg-error \"\" }\n+three sink_4_2356(volatile       A&);  // { dg-error \"\" }\n+five  sink_4_2356(               A&&);  // { dg-error \"\" }\n+six   sink_4_2356(const          A&&);  // { dg-error \"\" }\n+\n+int test4_2356()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2356(a);            // { dg-error \"ambiguous\" }\n+    sink_4_2356(cva);          // { dg-error \"no match\" }\n+    sink_4_2356(v_source());   // { dg-error \"no match\" }\n+    sink_4_2356(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2357(const          A&);  // { dg-error \"\" }\n+three sink_4_2357(volatile       A&);  // { dg-error \"\" }\n+five  sink_4_2357(               A&&);  // { dg-error \"\" }\n+seven sink_4_2357(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_2357()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2357(a);            // { dg-error \"ambiguous\" }\n+    sink_4_2357(cva);          // { dg-error \"no match\" }\n+    sink_4_2357(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2358(const          A&);  // { dg-error \"\" }\n+three sink_4_2358(volatile       A&);  // { dg-error \"\" }\n+five  sink_4_2358(               A&&);  // { dg-error \"\" }\n+eight sink_4_2358(const volatile A&&);  // { dg-error \"\" }\n+\n+int test4_2358()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2358(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_4_2367(const          A&);  // { dg-error \"\" }\n+three sink_4_2367(volatile       A&);  // { dg-error \"\" }\n+six   sink_4_2367(const          A&&);  // { dg-error \"\" }\n+seven sink_4_2367(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_2367()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2367(a);            // { dg-error \"ambiguous\" }\n+    sink_4_2367(cva);          // { dg-error \"no match\" }\n+    sink_4_2367(source());     // { dg-error \"ambiguous\" }\n+    sink_4_2367(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2368(const          A&);  // { dg-error \"\" }\n+three sink_4_2368(volatile       A&);  // { dg-error \"\" }\n+six   sink_4_2368(const          A&&);  // { dg-error \"\" }\n+eight sink_4_2368(const volatile A&&);  // { dg-error \"\" }\n+\n+int test4_2368()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2368(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_4_2378(const          A&);  // { dg-error \"\" }\n+three sink_4_2378(volatile       A&);  // { dg-error \"\" }\n+seven sink_4_2378(volatile       A&&);  // { dg-error \"\" }\n+eight sink_4_2378(const volatile A&&);  // { dg-error \"\" }\n+\n+int test4_2378()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2378(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_4_2456(const          A&);  // { dg-error \"\" }\n+four  sink_4_2456(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_2456(               A&&);  // { dg-error \"\" }\n+six   sink_4_2456(const          A&&);  // { dg-error \"\" }\n+\n+int test4_2456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2456(v_source());   // { dg-error \"no match\" }\n+    sink_4_2456(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2457(const          A&);  // { dg-error \"\" }\n+four  sink_4_2457(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_2457(               A&&);  // { dg-error \"\" }\n+seven sink_4_2457(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_2457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2457(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2467(const          A&);  // { dg-error \"\" }\n+four  sink_4_2467(const volatile A&);  // { dg-error \"\" }\n+six   sink_4_2467(const          A&&);  // { dg-error \"\" }\n+seven sink_4_2467(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_2467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2467(source());     // { dg-error \"ambiguous\" }\n+    sink_4_2467(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2567(const          A&);  // { dg-error \"\" }\n+five  sink_4_2567(               A&&);  // { dg-error \"\" }\n+six   sink_4_2567(const          A&&);  // { dg-error \"\" }\n+seven sink_4_2567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_2567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2567(cva);          // { dg-error \"no match\" }\n+    sink_4_2567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_4_2678(const          A&);  // { dg-error \"\" }\n+six   sink_4_2678(const          A&&);  // { dg-error \"\" }\n+seven sink_4_2678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_4_2678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test4_2678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_2678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+three sink_4_3456(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_3456(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_3456(               A&&);  // { dg-error \"\" }\n+six   sink_4_3456(const          A&&);  // { dg-error \"\" }\n+\n+int test4_3456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_3456(v_source());   // { dg-error \"no match\" }\n+    sink_4_3456(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_4_3457(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_3457(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_3457(               A&&);  // { dg-error \"\" }\n+seven sink_4_3457(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_3457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_3457(c_source());   // { dg-error \"no match\" }\n+    sink_4_3457(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_4_3467(volatile       A&);  // { dg-error \"\" }\n+four  sink_4_3467(const volatile A&);  // { dg-error \"\" }\n+six   sink_4_3467(const          A&&);  // { dg-error \"\" }\n+seven sink_4_3467(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_3467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_3467(source());     // { dg-error \"ambiguous\" }\n+    sink_4_3467(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_4_3567(volatile       A&);  // { dg-error \"\" }\n+five  sink_4_3567(               A&&);  // { dg-error \"\" }\n+six   sink_4_3567(const          A&&);  // { dg-error \"\" }\n+seven sink_4_3567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_3567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_3567(cva);          // { dg-error \"no match\" }\n+    sink_4_3567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_4_3678(volatile       A&);\n+six   sink_4_3678(const          A&&);  // { dg-error \"\" }\n+seven sink_4_3678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_4_3678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test4_3678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_3678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+four  sink_4_4567(const volatile A&);  // { dg-error \"\" }\n+five  sink_4_4567(               A&&);  // { dg-error \"\" }\n+six   sink_4_4567(const          A&&);  // { dg-error \"\" }\n+seven sink_4_4567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test4_4567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_4567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+four  sink_4_4678(const volatile A&);\n+six   sink_4_4678(const          A&&);  // { dg-error \"\" }\n+seven sink_4_4678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_4_4678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test4_4678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_4_4678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test4_1235() + test4_1236() + test4_1237() + test4_1256() + test4_1257() +\n+           test4_1267() + test4_1356() + test4_1357() + test4_1467() + test4_1567() +\n+           test4_1678() + test4_2345() + test4_2346() + test4_2347() + test4_2348() +\n+           test4_2356() + test4_2357() + test4_2358() + test4_2367() + test4_2368() +\n+           test4_2378() + test4_2467() + test4_2567() + test4_2678() + test4_3467() +\n+           test4_3567() + test4_3678() + test4_4678();\n+}"}, {"sha": "a486e75e2e30d31242adf0eabe4defd529b2806e", "filename": "gcc/testsuite/g++.dg/cpp0x/rv4p.C", "status": "added", "additions": 1497, "deletions": 0, "changes": 1497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv4p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv4p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv4p.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,1497 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 4 at a time\n+\n+one   sink_4_1234(               A&);\n+two   sink_4_1234(const          A&);\n+three sink_4_1234(volatile       A&);\n+four  sink_4_1234(const volatile A&);\n+\n+int test4_1234()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1234(a))           == 1> t1;\n+    sa<sizeof(sink_4_1234(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1234(va))          == 3> t3;\n+    sa<sizeof(sink_4_1234(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1234(source()))    == 2> t5;\n+    sa<sizeof(sink_4_1234(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+one   sink_4_1235(               A&);\n+two   sink_4_1235(const          A&);\n+three sink_4_1235(volatile       A&);\n+five  sink_4_1235(               A&&);\n+\n+int test4_1235()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1235(a))           == 1> t1;\n+    sa<sizeof(sink_4_1235(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1235(va))          == 3> t3;\n+    sa<sizeof(sink_4_1235(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1235(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+one   sink_4_1236(               A&);\n+two   sink_4_1236(const          A&);\n+three sink_4_1236(volatile       A&);\n+six   sink_4_1236(const          A&&);\n+\n+int test4_1236()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1236(a))           == 1> t1;\n+    sa<sizeof(sink_4_1236(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1236(va))          == 3> t3;\n+    sa<sizeof(sink_4_1236(source()))    == 6> t5;\n+    sa<sizeof(sink_4_1236(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_4_1237(               A&);\n+two   sink_4_1237(const          A&);\n+three sink_4_1237(volatile       A&);\n+seven sink_4_1237(volatile       A&&);\n+\n+int test4_1237()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1237(a))           == 1> t1;\n+    sa<sizeof(sink_4_1237(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1237(va))          == 3> t3;\n+    sa<sizeof(sink_4_1237(source()))    == 7> t5;\n+    sa<sizeof(sink_4_1237(c_source()))  == 2> t6;\n+    sa<sizeof(sink_4_1237(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1238(               A&);\n+two   sink_4_1238(const          A&);\n+three sink_4_1238(volatile       A&);\n+eight sink_4_1238(const volatile A&&);\n+\n+int test4_1238()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1238(a))           == 1> t1;\n+    sa<sizeof(sink_4_1238(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1238(va))          == 3> t3;\n+    sa<sizeof(sink_4_1238(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1238(source()))    == 8> t5;\n+    sa<sizeof(sink_4_1238(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1238(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1238(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1245(               A&);\n+two   sink_4_1245(const          A&);\n+four  sink_4_1245(const volatile A&);\n+five  sink_4_1245(               A&&);\n+\n+int test4_1245()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1245(a))           == 1> t1;\n+    sa<sizeof(sink_4_1245(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1245(va))          == 4> t3;\n+    sa<sizeof(sink_4_1245(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1245(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1245(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+one   sink_4_1246(               A&);\n+two   sink_4_1246(const          A&);\n+four  sink_4_1246(const volatile A&);\n+six   sink_4_1246(const          A&&);\n+\n+int test4_1246()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1246(a))           == 1> t1;\n+    sa<sizeof(sink_4_1246(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1246(va))          == 4> t3;\n+    sa<sizeof(sink_4_1246(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1246(source()))    == 6> t5;\n+    sa<sizeof(sink_4_1246(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_4_1247(               A&);\n+two   sink_4_1247(const          A&);\n+four  sink_4_1247(const volatile A&);\n+seven sink_4_1247(volatile       A&&);\n+\n+int test4_1247()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1247(a))           == 1> t1;\n+    sa<sizeof(sink_4_1247(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1247(va))          == 4> t3;\n+    sa<sizeof(sink_4_1247(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1247(source()))    == 7> t5;\n+    sa<sizeof(sink_4_1247(c_source()))  == 2> t6;\n+    sa<sizeof(sink_4_1247(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1248(               A&);\n+two   sink_4_1248(const          A&);\n+four  sink_4_1248(const volatile A&);\n+eight sink_4_1248(const volatile A&&);\n+\n+int test4_1248()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1248(a))           == 1> t1;\n+    sa<sizeof(sink_4_1248(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1248(va))          == 4> t3;\n+    sa<sizeof(sink_4_1248(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1248(source()))    == 8> t5;\n+    sa<sizeof(sink_4_1248(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1248(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1248(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1256(               A&);\n+two   sink_4_1256(const          A&);\n+five  sink_4_1256(               A&&);\n+six   sink_4_1256(const          A&&);\n+\n+int test4_1256()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1256(a))           == 1> t1;\n+    sa<sizeof(sink_4_1256(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1256(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1256(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_4_1257(               A&);\n+two   sink_4_1257(const          A&);\n+five  sink_4_1257(               A&&);\n+seven sink_4_1257(volatile       A&&);\n+\n+int test4_1257()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1257(a))           == 1> t1;\n+    sa<sizeof(sink_4_1257(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1257(va))          == 7> t3;\n+    sa<sizeof(sink_4_1257(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1257(c_source()))  == 2> t6;\n+    sa<sizeof(sink_4_1257(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1258(               A&);\n+two   sink_4_1258(const          A&);\n+five  sink_4_1258(               A&&);\n+eight sink_4_1258(const volatile A&&);\n+\n+int test4_1258()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1258(a))           == 1> t1;\n+    sa<sizeof(sink_4_1258(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1258(va))          == 8> t3;\n+    sa<sizeof(sink_4_1258(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1258(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1258(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1258(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1258(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1267(               A&);\n+two   sink_4_1267(const          A&);\n+six   sink_4_1267(const          A&&);\n+seven sink_4_1267(volatile       A&&);\n+\n+int test4_1267()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1267(a))           == 1> t1;\n+    sa<sizeof(sink_4_1267(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1267(va))          == 7> t3;\n+    sa<sizeof(sink_4_1267(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_1267(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1268(               A&);\n+two   sink_4_1268(const          A&);\n+six   sink_4_1268(const          A&&);\n+eight sink_4_1268(const volatile A&&);\n+\n+int test4_1268()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1268(a))           == 1> t1;\n+    sa<sizeof(sink_4_1268(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1268(va))          == 8> t3;\n+    sa<sizeof(sink_4_1268(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1268(source()))    == 6> t5;\n+    sa<sizeof(sink_4_1268(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_1268(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1268(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1278(               A&);\n+two   sink_4_1278(const          A&);\n+seven sink_4_1278(volatile       A&&);\n+eight sink_4_1278(const volatile A&&);\n+\n+int test4_1278()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1278(a))           == 1> t1;\n+    sa<sizeof(sink_4_1278(ca))          == 2> t2;\n+    sa<sizeof(sink_4_1278(va))          == 7> t3;\n+    sa<sizeof(sink_4_1278(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1278(source()))    == 7> t5;\n+    sa<sizeof(sink_4_1278(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1278(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_1278(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1345(               A&);\n+three sink_4_1345(volatile       A&);\n+four  sink_4_1345(const volatile A&);\n+five  sink_4_1345(               A&&);\n+\n+int test4_1345()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1345(a))           == 1> t1;\n+    sa<sizeof(sink_4_1345(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1345(va))          == 3> t3;\n+    sa<sizeof(sink_4_1345(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1345(source()))    == 5> t5;\n+    return 0;\n+}\n+\n+one   sink_4_1346(               A&);\n+three sink_4_1346(volatile       A&);\n+four  sink_4_1346(const volatile A&);\n+six   sink_4_1346(const          A&&);\n+\n+int test4_1346()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1346(a))           == 1> t1;\n+    sa<sizeof(sink_4_1346(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1346(va))          == 3> t3;\n+    sa<sizeof(sink_4_1346(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1346(source()))    == 6> t5;\n+    sa<sizeof(sink_4_1346(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_4_1347(               A&);\n+three sink_4_1347(volatile       A&);\n+four  sink_4_1347(const volatile A&);\n+seven sink_4_1347(volatile       A&&);\n+\n+int test4_1347()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1347(a))           == 1> t1;\n+    sa<sizeof(sink_4_1347(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1347(va))          == 3> t3;\n+    sa<sizeof(sink_4_1347(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1347(source()))    == 7> t5;\n+    sa<sizeof(sink_4_1347(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1348(               A&);\n+three sink_4_1348(volatile       A&);\n+four  sink_4_1348(const volatile A&);\n+eight sink_4_1348(const volatile A&&);\n+\n+int test4_1348()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1348(a))           == 1> t1;\n+    sa<sizeof(sink_4_1348(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1348(va))          == 3> t3;\n+    sa<sizeof(sink_4_1348(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1348(source()))    == 8> t5;\n+    sa<sizeof(sink_4_1348(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1348(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1348(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1356(               A&);\n+three sink_4_1356(volatile       A&);\n+five  sink_4_1356(               A&&);\n+six   sink_4_1356(const          A&&);\n+\n+int test4_1356()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1356(a))           == 1> t1;\n+    sa<sizeof(sink_4_1356(ca))          == 6> t2;\n+    sa<sizeof(sink_4_1356(va))          == 3> t3;\n+    sa<sizeof(sink_4_1356(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1356(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_4_1357(               A&);\n+three sink_4_1357(volatile       A&);\n+five  sink_4_1357(               A&&);\n+seven sink_4_1357(volatile       A&&);\n+\n+int test4_1357()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1357(a))           == 1> t1;\n+    sa<sizeof(sink_4_1357(va))          == 3> t3;\n+    sa<sizeof(sink_4_1357(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1357(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1358(               A&);\n+three sink_4_1358(volatile       A&);\n+five  sink_4_1358(               A&&);\n+eight sink_4_1358(const volatile A&&);\n+\n+int test4_1358()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1358(a))           == 1> t1;\n+    sa<sizeof(sink_4_1358(ca))          == 8> t2;\n+    sa<sizeof(sink_4_1358(va))          == 3> t3;\n+    sa<sizeof(sink_4_1358(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1358(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1358(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1358(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1358(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1367(               A&);\n+three sink_4_1367(volatile       A&);\n+six   sink_4_1367(const          A&&);\n+seven sink_4_1367(volatile       A&&);\n+\n+int test4_1367()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1367(a))           == 1> t1;\n+    sa<sizeof(sink_4_1367(ca))          == 6> t2;\n+    sa<sizeof(sink_4_1367(va))          == 3> t3;\n+    sa<sizeof(sink_4_1367(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_1367(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1368(               A&);\n+three sink_4_1368(volatile       A&);\n+six   sink_4_1368(const          A&&);\n+eight sink_4_1368(const volatile A&&);\n+\n+int test4_1368()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1368(a))           == 1> t1;\n+    sa<sizeof(sink_4_1368(ca))          == 6> t2;\n+    sa<sizeof(sink_4_1368(va))          == 3> t3;\n+    sa<sizeof(sink_4_1368(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1368(source()))    == 6> t5;\n+    sa<sizeof(sink_4_1368(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_1368(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1368(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1378(               A&);\n+three sink_4_1378(volatile       A&);\n+seven sink_4_1378(volatile       A&&);\n+eight sink_4_1378(const volatile A&&);\n+\n+int test4_1378()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1378(a))           == 1> t1;\n+    sa<sizeof(sink_4_1378(ca))          == 8> t2;\n+    sa<sizeof(sink_4_1378(va))          == 3> t3;\n+    sa<sizeof(sink_4_1378(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1378(source()))    == 7> t5;\n+    sa<sizeof(sink_4_1378(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1378(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_1378(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1456(               A&);\n+four  sink_4_1456(const volatile A&);\n+five  sink_4_1456(               A&&);\n+six   sink_4_1456(const          A&&);\n+\n+int test4_1456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1456(a))           == 1> t1;\n+    sa<sizeof(sink_4_1456(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1456(va))          == 4> t3;\n+    sa<sizeof(sink_4_1456(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1456(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1456(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_4_1457(               A&);\n+four  sink_4_1457(const volatile A&);\n+five  sink_4_1457(               A&&);\n+seven sink_4_1457(volatile       A&&);\n+\n+int test4_1457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1457(a))           == 1> t1;\n+    sa<sizeof(sink_4_1457(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1457(va))          == 4> t3;\n+    sa<sizeof(sink_4_1457(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1457(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1457(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1458(               A&);\n+four  sink_4_1458(const volatile A&);\n+five  sink_4_1458(               A&&);\n+eight sink_4_1458(const volatile A&&);\n+\n+int test4_1458()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1458(a))           == 1> t1;\n+    sa<sizeof(sink_4_1458(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1458(va))          == 4> t3;\n+    sa<sizeof(sink_4_1458(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1458(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1458(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1458(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1458(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1467(               A&);\n+four  sink_4_1467(const volatile A&);\n+six   sink_4_1467(const          A&&);\n+seven sink_4_1467(volatile       A&&);\n+\n+int test4_1467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1467(a))           == 1> t1;\n+    sa<sizeof(sink_4_1467(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1467(va))          == 4> t3;\n+    sa<sizeof(sink_4_1467(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1467(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_1467(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1468(               A&);\n+four  sink_4_1468(const volatile A&);\n+six   sink_4_1468(const          A&&);\n+eight sink_4_1468(const volatile A&&);\n+\n+int test4_1468()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1468(a))           == 1> t1;\n+    sa<sizeof(sink_4_1468(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1468(va))          == 4> t3;\n+    sa<sizeof(sink_4_1468(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1468(source()))    == 6> t5;\n+    sa<sizeof(sink_4_1468(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_1468(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1468(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1478(               A&);\n+four  sink_4_1478(const volatile A&);\n+seven sink_4_1478(volatile       A&&);\n+eight sink_4_1478(const volatile A&&);\n+\n+int test4_1478()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1478(a))           == 1> t1;\n+    sa<sizeof(sink_4_1478(ca))          == 4> t2;\n+    sa<sizeof(sink_4_1478(va))          == 4> t3;\n+    sa<sizeof(sink_4_1478(cva))         == 4> t4;\n+    sa<sizeof(sink_4_1478(source()))    == 7> t5;\n+    sa<sizeof(sink_4_1478(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1478(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_1478(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1567(               A&);\n+five  sink_4_1567(               A&&);\n+six   sink_4_1567(const          A&&);\n+seven sink_4_1567(volatile       A&&);\n+\n+int test4_1567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1567(a))           == 1> t1;\n+    sa<sizeof(sink_4_1567(ca))          == 6> t2;\n+    sa<sizeof(sink_4_1567(va))          == 7> t3;\n+    sa<sizeof(sink_4_1567(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_1567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_4_1568(               A&);\n+five  sink_4_1568(               A&&);\n+six   sink_4_1568(const          A&&);\n+eight sink_4_1568(const volatile A&&);\n+\n+int test4_1568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1568(a))           == 1> t1;\n+    sa<sizeof(sink_4_1568(ca))          == 6> t2;\n+    sa<sizeof(sink_4_1568(va))          == 8> t3;\n+    sa<sizeof(sink_4_1568(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1568(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_1568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_1568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1578(               A&);\n+five  sink_4_1578(               A&&);\n+seven sink_4_1578(volatile       A&&);\n+eight sink_4_1578(const volatile A&&);\n+\n+int test4_1578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1578(a))           == 1> t1;\n+    sa<sizeof(sink_4_1578(ca))          == 8> t2;\n+    sa<sizeof(sink_4_1578(va))          == 7> t3;\n+    sa<sizeof(sink_4_1578(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1578(source()))    == 5> t5;\n+    sa<sizeof(sink_4_1578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_1578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_1578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_4_1678(               A&);\n+six   sink_4_1678(const          A&&);\n+seven sink_4_1678(volatile       A&&);\n+eight sink_4_1678(const volatile A&&);\n+\n+int test4_1678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_1678(a))           == 1> t1;\n+    sa<sizeof(sink_4_1678(ca))          == 6> t2;\n+    sa<sizeof(sink_4_1678(va))          == 7> t3;\n+    sa<sizeof(sink_4_1678(cva))         == 8> t4;\n+    sa<sizeof(sink_4_1678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_1678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_1678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2345(const          A&);\n+three sink_4_2345(volatile       A&);\n+four  sink_4_2345(const volatile A&);\n+five  sink_4_2345(               A&&);\n+\n+int test4_2345()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2345(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2345(va))          == 3> t3;\n+    sa<sizeof(sink_4_2345(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2345(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2345(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+two   sink_4_2346(const          A&);\n+three sink_4_2346(volatile       A&);\n+four  sink_4_2346(const volatile A&);\n+six   sink_4_2346(const          A&&);\n+\n+int test4_2346()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2346(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2346(va))          == 3> t3;\n+    sa<sizeof(sink_4_2346(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2346(source()))    == 6> t5;\n+    sa<sizeof(sink_4_2346(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+two   sink_4_2347(const          A&);\n+three sink_4_2347(volatile       A&);\n+four  sink_4_2347(const volatile A&);\n+seven sink_4_2347(volatile       A&&);\n+\n+int test4_2347()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2347(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2347(va))          == 3> t3;\n+    sa<sizeof(sink_4_2347(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2347(source()))    == 7> t5;\n+    sa<sizeof(sink_4_2347(c_source()))  == 2> t6;\n+    sa<sizeof(sink_4_2347(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_4_2348(const          A&);\n+three sink_4_2348(volatile       A&);\n+four  sink_4_2348(const volatile A&);\n+eight sink_4_2348(const volatile A&&);\n+\n+int test4_2348()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2348(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2348(va))          == 3> t3;\n+    sa<sizeof(sink_4_2348(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2348(source()))    == 8> t5;\n+    sa<sizeof(sink_4_2348(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_2348(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_2348(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2356(const          A&);\n+three sink_4_2356(volatile       A&);\n+five  sink_4_2356(               A&&);\n+six   sink_4_2356(const          A&&);\n+\n+int test4_2356()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2356(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2356(va))          == 3> t3;\n+    sa<sizeof(sink_4_2356(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2356(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+two   sink_4_2357(const          A&);\n+three sink_4_2357(volatile       A&);\n+five  sink_4_2357(               A&&);\n+seven sink_4_2357(volatile       A&&);\n+\n+int test4_2357()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2357(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2357(va))          == 3> t3;\n+    sa<sizeof(sink_4_2357(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2357(c_source()))  == 2> t6;\n+    sa<sizeof(sink_4_2357(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_4_2358(const          A&);\n+three sink_4_2358(volatile       A&);\n+five  sink_4_2358(               A&&);\n+eight sink_4_2358(const volatile A&&);\n+\n+int test4_2358()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2358(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2358(va))          == 3> t3;\n+    sa<sizeof(sink_4_2358(cva))         == 8> t4;\n+    sa<sizeof(sink_4_2358(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2358(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_2358(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_2358(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2367(const          A&);\n+three sink_4_2367(volatile       A&);\n+six   sink_4_2367(const          A&&);\n+seven sink_4_2367(volatile       A&&);\n+\n+int test4_2367()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2367(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2367(va))          == 3> t3;\n+    sa<sizeof(sink_4_2367(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_2367(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_4_2368(const          A&);\n+three sink_4_2368(volatile       A&);\n+six   sink_4_2368(const          A&&);\n+eight sink_4_2368(const volatile A&&);\n+\n+int test4_2368()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2368(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2368(va))          == 3> t3;\n+    sa<sizeof(sink_4_2368(cva))         == 8> t4;\n+    sa<sizeof(sink_4_2368(source()))    == 6> t5;\n+    sa<sizeof(sink_4_2368(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_2368(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_2368(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2378(const          A&);\n+three sink_4_2378(volatile       A&);\n+seven sink_4_2378(volatile       A&&);\n+eight sink_4_2378(const volatile A&&);\n+\n+int test4_2378()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2378(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2378(va))          == 3> t3;\n+    sa<sizeof(sink_4_2378(cva))         == 8> t4;\n+    sa<sizeof(sink_4_2378(source()))    == 7> t5;\n+    sa<sizeof(sink_4_2378(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_2378(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_2378(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2456(const          A&);\n+four  sink_4_2456(const volatile A&);\n+five  sink_4_2456(               A&&);\n+six   sink_4_2456(const          A&&);\n+\n+int test4_2456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2456(a))           == 2> t1;\n+    sa<sizeof(sink_4_2456(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2456(va))          == 4> t3;\n+    sa<sizeof(sink_4_2456(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2456(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2456(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+two   sink_4_2457(const          A&);\n+four  sink_4_2457(const volatile A&);\n+five  sink_4_2457(               A&&);\n+seven sink_4_2457(volatile       A&&);\n+\n+int test4_2457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2457(a))           == 2> t1;\n+    sa<sizeof(sink_4_2457(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2457(va))          == 4> t3;\n+    sa<sizeof(sink_4_2457(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2457(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2457(c_source()))  == 2> t6;\n+    sa<sizeof(sink_4_2457(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_4_2458(const          A&);\n+four  sink_4_2458(const volatile A&);\n+five  sink_4_2458(               A&&);\n+eight sink_4_2458(const volatile A&&);\n+\n+int test4_2458()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2458(a))           == 2> t1;\n+    sa<sizeof(sink_4_2458(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2458(va))          == 4> t3;\n+    sa<sizeof(sink_4_2458(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2458(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2458(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_2458(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_2458(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2467(const          A&);\n+four  sink_4_2467(const volatile A&);\n+six   sink_4_2467(const          A&&);\n+seven sink_4_2467(volatile       A&&);\n+\n+int test4_2467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2467(a))           == 2> t1;\n+    sa<sizeof(sink_4_2467(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2467(va))          == 4> t3;\n+    sa<sizeof(sink_4_2467(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2467(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_2467(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_4_2468(const          A&);\n+four  sink_4_2468(const volatile A&);\n+six   sink_4_2468(const          A&&);\n+eight sink_4_2468(const volatile A&&);\n+\n+int test4_2468()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2468(a))           == 2> t1;\n+    sa<sizeof(sink_4_2468(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2468(va))          == 4> t3;\n+    sa<sizeof(sink_4_2468(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2468(source()))    == 6> t5;\n+    sa<sizeof(sink_4_2468(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_2468(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_2468(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2478(const          A&);\n+four  sink_4_2478(const volatile A&);\n+seven sink_4_2478(volatile       A&&);\n+eight sink_4_2478(const volatile A&&);\n+\n+int test4_2478()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2478(a))           == 2> t1;\n+    sa<sizeof(sink_4_2478(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2478(va))          == 4> t3;\n+    sa<sizeof(sink_4_2478(cva))         == 4> t4;\n+    sa<sizeof(sink_4_2478(source()))    == 7> t5;\n+    sa<sizeof(sink_4_2478(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_2478(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_2478(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2567(const          A&);\n+five  sink_4_2567(               A&&);\n+six   sink_4_2567(const          A&&);\n+seven sink_4_2567(volatile       A&&);\n+\n+int test4_2567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2567(a))           == 2> t1;\n+    sa<sizeof(sink_4_2567(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2567(va))          == 7> t3;\n+    sa<sizeof(sink_4_2567(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_2567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_4_2568(const          A&);\n+five  sink_4_2568(               A&&);\n+six   sink_4_2568(const          A&&);\n+eight sink_4_2568(const volatile A&&);\n+\n+int test4_2568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2568(a))           == 2> t1;\n+    sa<sizeof(sink_4_2568(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2568(va))          == 8> t3;\n+    sa<sizeof(sink_4_2568(cva))         == 8> t4;\n+    sa<sizeof(sink_4_2568(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_2568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_2568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2578(const          A&);\n+five  sink_4_2578(               A&&);\n+seven sink_4_2578(volatile       A&&);\n+eight sink_4_2578(const volatile A&&);\n+\n+int test4_2578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2578(a))           == 2> t1;\n+    sa<sizeof(sink_4_2578(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2578(va))          == 7> t3;\n+    sa<sizeof(sink_4_2578(cva))         == 8> t4;\n+    sa<sizeof(sink_4_2578(source()))    == 5> t5;\n+    sa<sizeof(sink_4_2578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_2578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_2578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_4_2678(const          A&);\n+six   sink_4_2678(const          A&&);\n+seven sink_4_2678(volatile       A&&);\n+eight sink_4_2678(const volatile A&&);\n+\n+int test4_2678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_2678(a))           == 2> t1;\n+    sa<sizeof(sink_4_2678(ca))          == 2> t2;\n+    sa<sizeof(sink_4_2678(va))          == 7> t3;\n+    sa<sizeof(sink_4_2678(cva))         == 8> t4;\n+    sa<sizeof(sink_4_2678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_2678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_2678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_4_3456(volatile       A&);\n+four  sink_4_3456(const volatile A&);\n+five  sink_4_3456(               A&&);\n+six   sink_4_3456(const          A&&);\n+\n+int test4_3456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3456(a))           == 3> t1;\n+    sa<sizeof(sink_4_3456(ca))          == 4> t2;\n+    sa<sizeof(sink_4_3456(va))          == 3> t3;\n+    sa<sizeof(sink_4_3456(cva))         == 4> t4;\n+    sa<sizeof(sink_4_3456(source()))    == 5> t5;\n+    sa<sizeof(sink_4_3456(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+three sink_4_3457(volatile       A&);\n+four  sink_4_3457(const volatile A&);\n+five  sink_4_3457(               A&&);\n+seven sink_4_3457(volatile       A&&);\n+\n+int test4_3457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3457(a))           == 3> t1;\n+    sa<sizeof(sink_4_3457(ca))          == 4> t2;\n+    sa<sizeof(sink_4_3457(va))          == 3> t3;\n+    sa<sizeof(sink_4_3457(cva))         == 4> t4;\n+    sa<sizeof(sink_4_3457(source()))    == 5> t5;\n+    sa<sizeof(sink_4_3457(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+three sink_4_3458(volatile       A&);\n+four  sink_4_3458(const volatile A&);\n+five  sink_4_3458(               A&&);\n+eight sink_4_3458(const volatile A&&);\n+\n+int test4_3458()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3458(a))           == 3> t1;\n+    sa<sizeof(sink_4_3458(ca))          == 4> t2;\n+    sa<sizeof(sink_4_3458(va))          == 3> t3;\n+    sa<sizeof(sink_4_3458(cva))         == 4> t4;\n+    sa<sizeof(sink_4_3458(source()))    == 5> t5;\n+    sa<sizeof(sink_4_3458(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_3458(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_3458(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_4_3467(volatile       A&);\n+four  sink_4_3467(const volatile A&);\n+six   sink_4_3467(const          A&&);\n+seven sink_4_3467(volatile       A&&);\n+\n+int test4_3467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3467(a))           == 3> t1;\n+    sa<sizeof(sink_4_3467(ca))          == 4> t2;\n+    sa<sizeof(sink_4_3467(va))          == 3> t3;\n+    sa<sizeof(sink_4_3467(cva))         == 4> t4;\n+    sa<sizeof(sink_4_3467(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_3467(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+three sink_4_3468(volatile       A&);\n+four  sink_4_3468(const volatile A&);\n+six   sink_4_3468(const          A&&);\n+eight sink_4_3468(const volatile A&&);\n+\n+int test4_3468()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3468(a))           == 3> t1;\n+    sa<sizeof(sink_4_3468(ca))          == 4> t2;\n+    sa<sizeof(sink_4_3468(va))          == 3> t3;\n+    sa<sizeof(sink_4_3468(cva))         == 4> t4;\n+    sa<sizeof(sink_4_3468(source()))    == 6> t5;\n+    sa<sizeof(sink_4_3468(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_3468(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_3468(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_4_3478(volatile       A&);\n+four  sink_4_3478(const volatile A&);\n+seven sink_4_3478(volatile       A&&);\n+eight sink_4_3478(const volatile A&&);\n+\n+int test4_3478()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3478(a))           == 3> t1;\n+    sa<sizeof(sink_4_3478(ca))          == 4> t2;\n+    sa<sizeof(sink_4_3478(va))          == 3> t3;\n+    sa<sizeof(sink_4_3478(cva))         == 4> t4;\n+    sa<sizeof(sink_4_3478(source()))    == 7> t5;\n+    sa<sizeof(sink_4_3478(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_3478(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_3478(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_4_3567(volatile       A&);\n+five  sink_4_3567(               A&&);\n+six   sink_4_3567(const          A&&);\n+seven sink_4_3567(volatile       A&&);\n+\n+int test4_3567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3567(a))           == 3> t1;\n+    sa<sizeof(sink_4_3567(ca))          == 6> t2;\n+    sa<sizeof(sink_4_3567(va))          == 3> t3;\n+    sa<sizeof(sink_4_3567(source()))    == 5> t5;\n+    sa<sizeof(sink_4_3567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_3567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+three sink_4_3568(volatile       A&);\n+five  sink_4_3568(               A&&);\n+six   sink_4_3568(const          A&&);\n+eight sink_4_3568(const volatile A&&);\n+\n+int test4_3568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3568(a))           == 3> t1;\n+    sa<sizeof(sink_4_3568(ca))          == 6> t2;\n+    sa<sizeof(sink_4_3568(va))          == 3> t3;\n+    sa<sizeof(sink_4_3568(cva))         == 8> t4;\n+    sa<sizeof(sink_4_3568(source()))    == 5> t5;\n+    sa<sizeof(sink_4_3568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_3568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_3568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_4_3578(volatile       A&);\n+five  sink_4_3578(               A&&);\n+seven sink_4_3578(volatile       A&&);\n+eight sink_4_3578(const volatile A&&);\n+\n+int test4_3578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3578(a))           == 3> t1;\n+    sa<sizeof(sink_4_3578(ca))          == 8> t2;\n+    sa<sizeof(sink_4_3578(va))          == 3> t3;\n+    sa<sizeof(sink_4_3578(cva))         == 8> t4;\n+    sa<sizeof(sink_4_3578(source()))    == 5> t5;\n+    sa<sizeof(sink_4_3578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_3578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_3578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_4_3678(volatile       A&);\n+six   sink_4_3678(const          A&&);\n+seven sink_4_3678(volatile       A&&);\n+eight sink_4_3678(const volatile A&&);\n+\n+int test4_3678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_3678(a))           == 3> t1;\n+    sa<sizeof(sink_4_3678(ca))          == 6> t2;\n+    sa<sizeof(sink_4_3678(va))          == 3> t3;\n+    sa<sizeof(sink_4_3678(cva))         == 8> t4;\n+    sa<sizeof(sink_4_3678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_3678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_3678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+four  sink_4_4567(const volatile A&);\n+five  sink_4_4567(               A&&);\n+six   sink_4_4567(const          A&&);\n+seven sink_4_4567(volatile       A&&);\n+\n+int test4_4567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_4567(a))           == 4> t1;\n+    sa<sizeof(sink_4_4567(ca))          == 4> t2;\n+    sa<sizeof(sink_4_4567(va))          == 4> t3;\n+    sa<sizeof(sink_4_4567(cva))         == 4> t4;\n+    sa<sizeof(sink_4_4567(source()))    == 5> t5;\n+    sa<sizeof(sink_4_4567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_4567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+four  sink_4_4568(const volatile A&);\n+five  sink_4_4568(               A&&);\n+six   sink_4_4568(const          A&&);\n+eight sink_4_4568(const volatile A&&);\n+\n+int test4_4568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_4568(a))           == 4> t1;\n+    sa<sizeof(sink_4_4568(ca))          == 4> t2;\n+    sa<sizeof(sink_4_4568(va))          == 4> t3;\n+    sa<sizeof(sink_4_4568(cva))         == 4> t4;\n+    sa<sizeof(sink_4_4568(source()))    == 5> t5;\n+    sa<sizeof(sink_4_4568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_4568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_4_4568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+four  sink_4_4578(const volatile A&);\n+five  sink_4_4578(               A&&);\n+seven sink_4_4578(volatile       A&&);\n+eight sink_4_4578(const volatile A&&);\n+\n+int test4_4578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_4578(a))           == 4> t1;\n+    sa<sizeof(sink_4_4578(ca))          == 4> t2;\n+    sa<sizeof(sink_4_4578(va))          == 4> t3;\n+    sa<sizeof(sink_4_4578(cva))         == 4> t4;\n+    sa<sizeof(sink_4_4578(source()))    == 5> t5;\n+    sa<sizeof(sink_4_4578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_4_4578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_4578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+four  sink_4_4678(const volatile A&);\n+six   sink_4_4678(const          A&&);\n+seven sink_4_4678(volatile       A&&);\n+eight sink_4_4678(const volatile A&&);\n+\n+int test4_4678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_4678(a))           == 4> t1;\n+    sa<sizeof(sink_4_4678(ca))          == 4> t2;\n+    sa<sizeof(sink_4_4678(va))          == 4> t3;\n+    sa<sizeof(sink_4_4678(cva))         == 4> t4;\n+    sa<sizeof(sink_4_4678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_4678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_4678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+five  sink_4_5678(               A&&);\n+six   sink_4_5678(const          A&&);\n+seven sink_4_5678(volatile       A&&);\n+eight sink_4_5678(const volatile A&&);\n+\n+int test4_5678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_4_5678(a))           == 5> t1;\n+    sa<sizeof(sink_4_5678(ca))          == 6> t2;\n+    sa<sizeof(sink_4_5678(va))          == 7> t3;\n+    sa<sizeof(sink_4_5678(cva))         == 8> t4;\n+    sa<sizeof(sink_4_5678(source()))    == 5> t5;\n+    sa<sizeof(sink_4_5678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_4_5678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_4_5678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test4_1234() + test4_1235() + test4_1236() + test4_1237() + test4_1238() +\n+           test4_1245() + test4_1246() + test4_1247() + test4_1248() + test4_1256() +\n+           test4_1257() + test4_1258() + test4_1267() + test4_1268() + test4_1278() +\n+           test4_1345() + test4_1346() + test4_1347() + test4_1348() + test4_1356() +\n+           test4_1357() + test4_1358() + test4_1367() + test4_1368() + test4_1378() +\n+           test4_1456() + test4_1457() + test4_1458() + test4_1467() + test4_1468() +\n+           test4_1478() + test4_1567() + test4_1568() + test4_1578() + test4_1678() +\n+           test4_2345() + test4_2346() + test4_2347() + test4_2348() + test4_2356() +\n+           test4_2357() + test4_2358() + test4_2367() + test4_2368() + test4_2378() +\n+           test4_2456() + test4_2457() + test4_2458() + test4_2467() + test4_2468() +\n+           test4_2478() + test4_2567() + test4_2568() + test4_2578() + test4_2678() +\n+           test4_3456() + test4_3457() + test4_3458() + test4_3467() + test4_3468() +\n+           test4_3478() + test4_3567() + test4_3568() + test4_3578() + test4_3678() +\n+           test4_4567() + test4_4568() + test4_4578() + test4_4678() + test4_5678();\n+}"}, {"sha": "715716e45ee0470467480a8dbc88e58124327ac6", "filename": "gcc/testsuite/g++.dg/cpp0x/rv5n.C", "status": "added", "additions": 575, "deletions": 0, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv5n.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv5n.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv5n.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,575 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 5 at a time\n+\n+one   sink_5_12345(               A&);  // { dg-error \"\" }\n+two   sink_5_12345(const          A&);  // { dg-error \"\" }\n+three sink_5_12345(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_12345(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_12345(               A&&);  // { dg-error \"\" }\n+\n+int test5_12345()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12345(v_source());   // { dg-error \"no match\" }\n+    sink_5_12345(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12346(               A&);  // { dg-error \"\" }\n+two   sink_5_12346(const          A&);  // { dg-error \"\" }\n+three sink_5_12346(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_12346(const volatile A&);  // { dg-error \"\" }\n+six   sink_5_12346(const          A&&);  // { dg-error \"\" }\n+\n+int test5_12346()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12346(v_source());   // { dg-error \"no match\" }\n+    sink_5_12346(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12347(               A&);  // { dg-error \"\" }\n+two   sink_5_12347(const          A&);  // { dg-error \"\" }\n+three sink_5_12347(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_12347(const volatile A&);  // { dg-error \"\" }\n+seven sink_5_12347(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_12347()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12347(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12356(               A&);  // { dg-error \"\" }\n+two   sink_5_12356(const          A&);  // { dg-error \"\" }\n+three sink_5_12356(volatile       A&);  // { dg-error \"\" }\n+five  sink_5_12356(               A&&);  // { dg-error \"\" }\n+six   sink_5_12356(const          A&&);  // { dg-error \"\" }\n+\n+int test5_12356()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12356(cva);          // { dg-error \"no match\" }\n+    sink_5_12356(v_source());   // { dg-error \"no match\" }\n+    sink_5_12356(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12357(               A&);  // { dg-error \"\" }\n+two   sink_5_12357(const          A&);  // { dg-error \"\" }\n+three sink_5_12357(volatile       A&);  // { dg-error \"\" }\n+five  sink_5_12357(               A&&);  // { dg-error \"\" }\n+seven sink_5_12357(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_12357()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12357(cva);          // { dg-error \"no match\" }\n+    sink_5_12357(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12367(               A&);  // { dg-error \"\" }\n+two   sink_5_12367(const          A&);  // { dg-error \"\" }\n+three sink_5_12367(volatile       A&);  // { dg-error \"\" }\n+six   sink_5_12367(const          A&&);  // { dg-error \"\" }\n+seven sink_5_12367(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_12367()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12367(cva);          // { dg-error \"no match\" }\n+    sink_5_12367(source());     // { dg-error \"ambiguous\" }\n+    sink_5_12367(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12456(               A&);  // { dg-error \"\" }\n+two   sink_5_12456(const          A&);  // { dg-error \"\" }\n+four  sink_5_12456(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_12456(               A&&);  // { dg-error \"\" }\n+six   sink_5_12456(const          A&&);  // { dg-error \"\" }\n+\n+int test5_12456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12456(v_source());   // { dg-error \"no match\" }\n+    sink_5_12456(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12457(               A&);  // { dg-error \"\" }\n+two   sink_5_12457(const          A&);  // { dg-error \"\" }\n+four  sink_5_12457(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_12457(               A&&);  // { dg-error \"\" }\n+seven sink_5_12457(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_12457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12457(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12467(               A&);  // { dg-error \"\" }\n+two   sink_5_12467(const          A&);  // { dg-error \"\" }\n+four  sink_5_12467(const volatile A&);  // { dg-error \"\" }\n+six   sink_5_12467(const          A&&);  // { dg-error \"\" }\n+seven sink_5_12467(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_12467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12467(source());     // { dg-error \"ambiguous\" }\n+    sink_5_12467(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12567(               A&);  // { dg-error \"\" }\n+two   sink_5_12567(const          A&);  // { dg-error \"\" }\n+five  sink_5_12567(               A&&);  // { dg-error \"\" }\n+six   sink_5_12567(const          A&&);  // { dg-error \"\" }\n+seven sink_5_12567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_12567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12567(cva);          // { dg-error \"no match\" }\n+    sink_5_12567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_12678(               A&);\n+two   sink_5_12678(const          A&);  // { dg-error \"\" }\n+six   sink_5_12678(const          A&&);  // { dg-error \"\" }\n+seven sink_5_12678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_5_12678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_12678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_12678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+one   sink_5_13456(               A&);  // { dg-error \"\" }\n+three sink_5_13456(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_13456(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_13456(               A&&);  // { dg-error \"\" }\n+six   sink_5_13456(const          A&&);  // { dg-error \"\" }\n+\n+int test5_13456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_13456(v_source());   // { dg-error \"no match\" }\n+    sink_5_13456(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_13457(               A&);  // { dg-error \"\" }\n+three sink_5_13457(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_13457(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_13457(               A&&);  // { dg-error \"\" }\n+seven sink_5_13457(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_13457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_13457(c_source());   // { dg-error \"no match\" }\n+    sink_5_13457(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_13467(               A&);  // { dg-error \"\" }\n+three sink_5_13467(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_13467(const volatile A&);  // { dg-error \"\" }\n+six   sink_5_13467(const          A&&);  // { dg-error \"\" }\n+seven sink_5_13467(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_13467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_13467(source());     // { dg-error \"ambiguous\" }\n+    sink_5_13467(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_13567(               A&);  // { dg-error \"\" }\n+three sink_5_13567(volatile       A&);  // { dg-error \"\" }\n+five  sink_5_13567(               A&&);  // { dg-error \"\" }\n+six   sink_5_13567(const          A&&);  // { dg-error \"\" }\n+seven sink_5_13567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_13567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_13567(cva);          // { dg-error \"no match\" }\n+    sink_5_13567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_13678(               A&);\n+three sink_5_13678(volatile       A&);\n+six   sink_5_13678(const          A&&);  // { dg-error \"\" }\n+seven sink_5_13678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_5_13678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_13678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_13678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+one   sink_5_14567(               A&);  // { dg-error \"\" }\n+four  sink_5_14567(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_14567(               A&&);  // { dg-error \"\" }\n+six   sink_5_14567(const          A&&);  // { dg-error \"\" }\n+seven sink_5_14567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_14567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_14567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_5_14678(               A&);\n+four  sink_5_14678(const volatile A&);\n+six   sink_5_14678(const          A&&);  // { dg-error \"\" }\n+seven sink_5_14678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_5_14678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_14678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_14678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_5_23456(const          A&);  // { dg-error \"\" }\n+three sink_5_23456(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_23456(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_23456(               A&&);  // { dg-error \"\" }\n+six   sink_5_23456(const          A&&);  // { dg-error \"\" }\n+\n+int test5_23456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23456(a);            // { dg-error \"ambiguous\" }\n+    sink_5_23456(v_source());   // { dg-error \"no match\" }\n+    sink_5_23456(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_5_23457(const          A&);  // { dg-error \"\" }\n+three sink_5_23457(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_23457(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_23457(               A&&);  // { dg-error \"\" }\n+seven sink_5_23457(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_23457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23457(a);            // { dg-error \"ambiguous\" }\n+    sink_5_23457(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_5_23458(const          A&);  // { dg-error \"\" }\n+three sink_5_23458(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_23458(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_23458(               A&&);  // { dg-error \"\" }\n+eight sink_5_23458(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_23458()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23458(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_5_23467(const          A&);  // { dg-error \"\" }\n+three sink_5_23467(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_23467(const volatile A&);  // { dg-error \"\" }\n+six   sink_5_23467(const          A&&);  // { dg-error \"\" }\n+seven sink_5_23467(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_23467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23467(a);            // { dg-error \"ambiguous\" }\n+    sink_5_23467(source());     // { dg-error \"ambiguous\" }\n+    sink_5_23467(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_5_23468(const          A&);  // { dg-error \"\" }\n+three sink_5_23468(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_23468(const volatile A&);  // { dg-error \"\" }\n+six   sink_5_23468(const          A&&);  // { dg-error \"\" }\n+eight sink_5_23468(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_23468()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23468(a);  // { dg-error \"ambiguous\" }\n+   return 0;\n+}\n+\n+two   sink_5_23478(const          A&);  // { dg-error \"\" }\n+three sink_5_23478(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_23478(const volatile A&);  // { dg-error \"\" }\n+seven sink_5_23478(volatile       A&&);  // { dg-error \"\" }\n+eight sink_5_23478(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_23478()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23478(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_5_23567(const          A&);  // { dg-error \"\" }\n+three sink_5_23567(volatile       A&);  // { dg-error \"\" }\n+five  sink_5_23567(               A&&);  // { dg-error \"\" }\n+six   sink_5_23567(const          A&&);  // { dg-error \"\" }\n+seven sink_5_23567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_23567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23567(a);            // { dg-error \"ambiguous\" }\n+    sink_5_23567(cva);          // { dg-error \"no match\" }\n+    sink_5_23567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_5_23568(const          A&);  // { dg-error \"\" }\n+three sink_5_23568(volatile       A&);  // { dg-error \"\" }\n+five  sink_5_23568(               A&&);  // { dg-error \"\" }\n+six   sink_5_23568(const          A&&);  // { dg-error \"\" }\n+eight sink_5_23568(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_23568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23568(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_5_23578(const          A&);  // { dg-error \"\" }\n+three sink_5_23578(volatile       A&);  // { dg-error \"\" }\n+five  sink_5_23578(               A&&);  // { dg-error \"\" }\n+seven sink_5_23578(volatile       A&&);  // { dg-error \"\" }\n+eight sink_5_23578(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_23578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23578(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_5_23678(const          A&);  // { dg-error \"\" }\n+three sink_5_23678(volatile       A&);  // { dg-error \"\" }\n+six   sink_5_23678(const          A&&);  // { dg-error \"\" }\n+seven sink_5_23678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_5_23678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_23678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_23678(a);         // { dg-error \"ambiguous\" }\n+    sink_5_23678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_5_24567(const          A&);  // { dg-error \"\" }\n+four  sink_5_24567(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_24567(               A&&);  // { dg-error \"\" }\n+six   sink_5_24567(const          A&&);  // { dg-error \"\" }\n+seven sink_5_24567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_24567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_24567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_5_24678(const          A&);  // { dg-error \"\" }\n+four  sink_5_24678(const volatile A&);\n+six   sink_5_24678(const          A&&);  // { dg-error \"\" }\n+seven sink_5_24678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_5_24678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_24678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_24678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+three sink_5_34567(volatile       A&);  // { dg-error \"\" }\n+four  sink_5_34567(const volatile A&);  // { dg-error \"\" }\n+five  sink_5_34567(               A&&);  // { dg-error \"\" }\n+six   sink_5_34567(const          A&&);  // { dg-error \"\" }\n+seven sink_5_34567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test5_34567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_34567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+three sink_5_34678(volatile       A&);\n+four  sink_5_34678(const volatile A&);\n+six   sink_5_34678(const          A&&);  // { dg-error \"\" }\n+seven sink_5_34678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_5_34678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test5_34678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_5_34678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test5_12356() + test5_12357() + test5_12367() + test5_12467() +\n+           test5_12567() + test5_12678() + test5_13467() + test5_13567() +\n+           test5_13678() + test5_13678() + test5_23456() + test5_23457() +\n+           test5_23458() + test5_23467() + test5_23468() + test5_23478() +\n+           test5_23567() + test5_23568() + test5_23578() + test5_23678() +\n+           test5_24678() + test5_34678();\n+}"}, {"sha": "a4d916714c3b40b46a692295d6d8fab587b0ecd0", "filename": "gcc/testsuite/g++.dg/cpp0x/rv5p.C", "status": "added", "additions": 1283, "deletions": 0, "changes": 1283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv5p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv5p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv5p.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,1283 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 5 at a time\n+\n+one   sink_5_12345(               A&);\n+two   sink_5_12345(const          A&);\n+three sink_5_12345(volatile       A&);\n+four  sink_5_12345(const volatile A&);\n+five  sink_5_12345(               A&&);\n+\n+int test5_12345()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12345(a))           == 1> t1;\n+    sa<sizeof(sink_5_12345(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12345(va))          == 3> t3;\n+    sa<sizeof(sink_5_12345(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12345(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12345(c_source()))  == 2> t6;\n+    return 0;\n+}\n+\n+one   sink_5_12346(               A&);\n+two   sink_5_12346(const          A&);\n+three sink_5_12346(volatile       A&);\n+four  sink_5_12346(const volatile A&);\n+six   sink_5_12346(const          A&&);\n+\n+int test5_12346()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12346(a))           == 1> t1;\n+    sa<sizeof(sink_5_12346(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12346(va))          == 3> t3;\n+    sa<sizeof(sink_5_12346(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12346(source()))    == 6> t5;\n+    sa<sizeof(sink_5_12346(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_5_12347(               A&);\n+two   sink_5_12347(const          A&);\n+three sink_5_12347(volatile       A&);\n+four  sink_5_12347(const volatile A&);\n+seven sink_5_12347(volatile       A&&);\n+\n+int test5_12347()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12347(a))           == 1> t1;\n+    sa<sizeof(sink_5_12347(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12347(va))          == 3> t3;\n+    sa<sizeof(sink_5_12347(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12347(source()))    == 7> t5;\n+    sa<sizeof(sink_5_12347(c_source()))  == 2> t6;\n+    sa<sizeof(sink_5_12347(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_12348(               A&);\n+two   sink_5_12348(const          A&);\n+three sink_5_12348(volatile       A&);\n+four  sink_5_12348(const volatile A&);\n+eight sink_5_12348(const volatile A&&);\n+\n+int test5_12348()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12348(a))           == 1> t1;\n+    sa<sizeof(sink_5_12348(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12348(va))          == 3> t3;\n+    sa<sizeof(sink_5_12348(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12348(source()))    == 8> t5;\n+    sa<sizeof(sink_5_12348(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_12348(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_12348(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_12356(               A&);\n+two   sink_5_12356(const          A&);\n+three sink_5_12356(volatile       A&);\n+five  sink_5_12356(               A&&);\n+six   sink_5_12356(const          A&&);\n+\n+int test5_12356()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12356(a))           == 1> t1;\n+    sa<sizeof(sink_5_12356(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12356(va))          == 3> t3;\n+    sa<sizeof(sink_5_12356(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12356(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_5_12357(               A&);\n+two   sink_5_12357(const          A&);\n+three sink_5_12357(volatile       A&);\n+five  sink_5_12357(               A&&);\n+seven sink_5_12357(volatile       A&&);\n+\n+int test5_12357()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12357(a))           == 1> t1;\n+    sa<sizeof(sink_5_12357(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12357(va))          == 3> t3;\n+    sa<sizeof(sink_5_12357(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12357(c_source()))  == 2> t6;\n+    sa<sizeof(sink_5_12357(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_12358(               A&);\n+two   sink_5_12358(const          A&);\n+three sink_5_12358(volatile       A&);\n+five  sink_5_12358(               A&&);\n+eight sink_5_12358(const volatile A&&);\n+\n+int test5_12358()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12358(a))           == 1> t1;\n+    sa<sizeof(sink_5_12358(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12358(va))          == 3> t3;\n+    sa<sizeof(sink_5_12358(cva))         == 8> t4;\n+    sa<sizeof(sink_5_12358(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12358(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_12358(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_12358(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_12367(               A&);\n+two   sink_5_12367(const          A&);\n+three sink_5_12367(volatile       A&);\n+six   sink_5_12367(const          A&&);\n+seven sink_5_12367(volatile       A&&);\n+\n+int test5_12367()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12367(a))           == 1> t1;\n+    sa<sizeof(sink_5_12367(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12367(va))          == 3> t3;\n+    sa<sizeof(sink_5_12367(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_12367(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_12368(               A&);\n+two   sink_5_12368(const          A&);\n+three sink_5_12368(volatile       A&);\n+six   sink_5_12368(const          A&&);\n+eight sink_5_12368(const volatile A&&);\n+\n+int test5_12368()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12368(a))           == 1> t1;\n+    sa<sizeof(sink_5_12368(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12368(va))          == 3> t3;\n+    sa<sizeof(sink_5_12368(cva))         == 8> t4;\n+    sa<sizeof(sink_5_12368(source()))    == 6> t5;\n+    sa<sizeof(sink_5_12368(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_12368(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_12368(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_12378(               A&);\n+two   sink_5_12378(const          A&);\n+three sink_5_12378(volatile       A&);\n+seven sink_5_12378(volatile       A&&);\n+eight sink_5_12378(const volatile A&&);\n+\n+int test5_12378()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12378(a))           == 1> t1;\n+    sa<sizeof(sink_5_12378(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12378(va))          == 3> t3;\n+    sa<sizeof(sink_5_12378(cva))         == 8> t4;\n+    sa<sizeof(sink_5_12378(source()))    == 7> t5;\n+    sa<sizeof(sink_5_12378(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_12378(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_12378(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_12456(               A&);\n+two   sink_5_12456(const          A&);\n+four  sink_5_12456(const volatile A&);\n+five  sink_5_12456(               A&&);\n+six   sink_5_12456(const          A&&);\n+\n+int test5_12456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12456(a))           == 1> t1;\n+    sa<sizeof(sink_5_12456(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12456(va))          == 4> t3;\n+    sa<sizeof(sink_5_12456(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12456(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12456(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_5_12457(               A&);\n+two   sink_5_12457(const          A&);\n+four  sink_5_12457(const volatile A&);\n+five  sink_5_12457(               A&&);\n+seven sink_5_12457(volatile       A&&);\n+\n+int test5_12457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12457(a))           == 1> t1;\n+    sa<sizeof(sink_5_12457(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12457(va))          == 4> t3;\n+    sa<sizeof(sink_5_12457(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12457(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12457(c_source()))  == 2> t6;\n+    sa<sizeof(sink_5_12457(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_12458(               A&);\n+two   sink_5_12458(const          A&);\n+four  sink_5_12458(const volatile A&);\n+five  sink_5_12458(               A&&);\n+eight sink_5_12458(const volatile A&&);\n+\n+int test5_12458()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12458(a))           == 1> t1;\n+    sa<sizeof(sink_5_12458(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12458(va))          == 4> t3;\n+    sa<sizeof(sink_5_12458(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12458(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12458(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_12458(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_12458(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_12467(               A&);\n+two   sink_5_12467(const          A&);\n+four  sink_5_12467(const volatile A&);\n+six   sink_5_12467(const          A&&);\n+seven sink_5_12467(volatile       A&&);\n+\n+int test5_12467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12467(a))           == 1> t1;\n+    sa<sizeof(sink_5_12467(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12467(va))          == 4> t3;\n+    sa<sizeof(sink_5_12467(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12467(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_12467(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_12468(               A&);\n+two   sink_5_12468(const          A&);\n+four  sink_5_12468(const volatile A&);\n+six   sink_5_12468(const          A&&);\n+eight sink_5_12468(const volatile A&&);\n+\n+int test5_12468()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12468(a))           == 1> t1;\n+    sa<sizeof(sink_5_12468(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12468(va))          == 4> t3;\n+    sa<sizeof(sink_5_12468(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12468(source()))    == 6> t5;\n+    sa<sizeof(sink_5_12468(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_12468(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_12468(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_12478(               A&);\n+two   sink_5_12478(const          A&);\n+four  sink_5_12478(const volatile A&);\n+seven sink_5_12478(volatile       A&&);\n+eight sink_5_12478(const volatile A&&);\n+\n+int test5_12478()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12478(a))           == 1> t1;\n+    sa<sizeof(sink_5_12478(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12478(va))          == 4> t3;\n+    sa<sizeof(sink_5_12478(cva))         == 4> t4;\n+    sa<sizeof(sink_5_12478(source()))    == 7> t5;\n+    sa<sizeof(sink_5_12478(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_12478(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_12478(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_12567(               A&);\n+two   sink_5_12567(const          A&);\n+five  sink_5_12567(               A&&);\n+six   sink_5_12567(const          A&&);\n+seven sink_5_12567(volatile       A&&);\n+\n+int test5_12567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12567(a))           == 1> t1;\n+    sa<sizeof(sink_5_12567(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12567(va))          == 7> t3;\n+    sa<sizeof(sink_5_12567(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_12567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_12568(               A&);\n+two   sink_5_12568(const          A&);\n+five  sink_5_12568(               A&&);\n+six   sink_5_12568(const          A&&);\n+eight sink_5_12568(const volatile A&&);\n+\n+int test5_12568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12568(a))           == 1> t1;\n+    sa<sizeof(sink_5_12568(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12568(va))          == 8> t3;\n+    sa<sizeof(sink_5_12568(cva))         == 8> t4;\n+    sa<sizeof(sink_5_12568(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_12568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_12568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_12578(               A&);\n+two   sink_5_12578(const          A&);\n+five  sink_5_12578(               A&&);\n+seven sink_5_12578(volatile       A&&);\n+eight sink_5_12578(const volatile A&&);\n+\n+int test5_12578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12578(a))           == 1> t1;\n+    sa<sizeof(sink_5_12578(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12578(va))          == 7> t3;\n+    sa<sizeof(sink_5_12578(cva))         == 8> t4;\n+    sa<sizeof(sink_5_12578(source()))    == 5> t5;\n+    sa<sizeof(sink_5_12578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_12578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_12578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_12678(               A&);\n+two   sink_5_12678(const          A&);\n+six   sink_5_12678(const          A&&);\n+seven sink_5_12678(volatile       A&&);\n+eight sink_5_12678(const volatile A&&);\n+\n+int test5_12678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_12678(a))           == 1> t1;\n+    sa<sizeof(sink_5_12678(ca))          == 2> t2;\n+    sa<sizeof(sink_5_12678(va))          == 7> t3;\n+    sa<sizeof(sink_5_12678(cva))         == 8> t4;\n+    sa<sizeof(sink_5_12678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_12678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_12678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_13456(               A&);\n+three sink_5_13456(volatile       A&);\n+four  sink_5_13456(const volatile A&);\n+five  sink_5_13456(               A&&);\n+six   sink_5_13456(const          A&&);\n+\n+int test5_13456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13456(a))           == 1> t1;\n+    sa<sizeof(sink_5_13456(ca))          == 4> t2;\n+    sa<sizeof(sink_5_13456(va))          == 3> t3;\n+    sa<sizeof(sink_5_13456(cva))         == 4> t4;\n+    sa<sizeof(sink_5_13456(source()))    == 5> t5;\n+    sa<sizeof(sink_5_13456(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_5_13457(               A&);\n+three sink_5_13457(volatile       A&);\n+four  sink_5_13457(const volatile A&);\n+five  sink_5_13457(               A&&);\n+seven sink_5_13457(volatile       A&&);\n+\n+int test5_13457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13457(a))           == 1> t1;\n+    sa<sizeof(sink_5_13457(ca))          == 4> t2;\n+    sa<sizeof(sink_5_13457(va))          == 3> t3;\n+    sa<sizeof(sink_5_13457(cva))         == 4> t4;\n+    sa<sizeof(sink_5_13457(source()))    == 5> t5;\n+    sa<sizeof(sink_5_13457(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_13458(               A&);\n+three sink_5_13458(volatile       A&);\n+four  sink_5_13458(const volatile A&);\n+five  sink_5_13458(               A&&);\n+eight sink_5_13458(const volatile A&&);\n+\n+int test5_13458()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13458(a))           == 1> t1;\n+    sa<sizeof(sink_5_13458(ca))          == 4> t2;\n+    sa<sizeof(sink_5_13458(va))          == 3> t3;\n+    sa<sizeof(sink_5_13458(cva))         == 4> t4;\n+    sa<sizeof(sink_5_13458(source()))    == 5> t5;\n+    sa<sizeof(sink_5_13458(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_13458(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_13458(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_13467(               A&);\n+three sink_5_13467(volatile       A&);\n+four  sink_5_13467(const volatile A&);\n+six   sink_5_13467(const          A&&);\n+seven sink_5_13467(volatile       A&&);\n+\n+int test5_13467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13467(a))           == 1> t1;\n+    sa<sizeof(sink_5_13467(ca))          == 4> t2;\n+    sa<sizeof(sink_5_13467(va))          == 3> t3;\n+    sa<sizeof(sink_5_13467(cva))         == 4> t4;\n+    sa<sizeof(sink_5_13467(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_13467(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_13468(               A&);\n+three sink_5_13468(volatile       A&);\n+four  sink_5_13468(const volatile A&);\n+six   sink_5_13468(const          A&&);\n+eight sink_5_13468(const volatile A&&);\n+\n+int test5_13468()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13468(a))           == 1> t1;\n+    sa<sizeof(sink_5_13468(ca))          == 4> t2;\n+    sa<sizeof(sink_5_13468(va))          == 3> t3;\n+    sa<sizeof(sink_5_13468(cva))         == 4> t4;\n+    sa<sizeof(sink_5_13468(source()))    == 6> t5;\n+    sa<sizeof(sink_5_13468(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_13468(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_13468(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_13478(               A&);\n+three sink_5_13478(volatile       A&);\n+four  sink_5_13478(const volatile A&);\n+seven sink_5_13478(volatile       A&&);\n+eight sink_5_13478(const volatile A&&);\n+\n+int test5_13478()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13478(a))           == 1> t1;\n+    sa<sizeof(sink_5_13478(ca))          == 4> t2;\n+    sa<sizeof(sink_5_13478(va))          == 3> t3;\n+    sa<sizeof(sink_5_13478(cva))         == 4> t4;\n+    sa<sizeof(sink_5_13478(source()))    == 7> t5;\n+    sa<sizeof(sink_5_13478(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_13478(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_13478(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_13567(               A&);\n+three sink_5_13567(volatile       A&);\n+five  sink_5_13567(               A&&);\n+six   sink_5_13567(const          A&&);\n+seven sink_5_13567(volatile       A&&);\n+\n+int test5_13567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13567(a))           == 1> t1;\n+    sa<sizeof(sink_5_13567(ca))          == 6> t2;\n+    sa<sizeof(sink_5_13567(va))          == 3> t3;\n+    sa<sizeof(sink_5_13567(source()))    == 5> t5;\n+    sa<sizeof(sink_5_13567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_13567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_13568(               A&);\n+three sink_5_13568(volatile       A&);\n+five  sink_5_13568(               A&&);\n+six   sink_5_13568(const          A&&);\n+eight sink_5_13568(const volatile A&&);\n+\n+int test5_13568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13568(a))           == 1> t1;\n+    sa<sizeof(sink_5_13568(ca))          == 6> t2;\n+    sa<sizeof(sink_5_13568(va))          == 3> t3;\n+    sa<sizeof(sink_5_13568(cva))         == 8> t4;\n+    sa<sizeof(sink_5_13568(source()))    == 5> t5;\n+    sa<sizeof(sink_5_13568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_13568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_13568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_13578(               A&);\n+three sink_5_13578(volatile       A&);\n+five  sink_5_13578(               A&&);\n+seven sink_5_13578(volatile       A&&);\n+eight sink_5_13578(const volatile A&&);\n+\n+int test5_13578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13578(a))           == 1> t1;\n+    sa<sizeof(sink_5_13578(ca))          == 8> t2;\n+    sa<sizeof(sink_5_13578(va))          == 3> t3;\n+    sa<sizeof(sink_5_13578(cva))         == 8> t4;\n+    sa<sizeof(sink_5_13578(source()))    == 5> t5;\n+    sa<sizeof(sink_5_13578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_13578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_13578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_13678(               A&);\n+three sink_5_13678(volatile       A&);\n+six   sink_5_13678(const          A&&);\n+seven sink_5_13678(volatile       A&&);\n+eight sink_5_13678(const volatile A&&);\n+\n+int test5_13678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_13678(a))           == 1> t1;\n+    sa<sizeof(sink_5_13678(ca))          == 6> t2;\n+    sa<sizeof(sink_5_13678(va))          == 3> t3;\n+    sa<sizeof(sink_5_13678(cva))         == 8> t4;\n+    sa<sizeof(sink_5_13678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_13678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_13678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_14567(               A&);\n+four  sink_5_14567(const volatile A&);\n+five  sink_5_14567(               A&&);\n+six   sink_5_14567(const          A&&);\n+seven sink_5_14567(volatile       A&&);\n+\n+int test5_14567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_14567(a))           == 1> t1;\n+    sa<sizeof(sink_5_14567(ca))          == 4> t2;\n+    sa<sizeof(sink_5_14567(va))          == 4> t3;\n+    sa<sizeof(sink_5_14567(cva))         == 4> t4;\n+    sa<sizeof(sink_5_14567(source()))    == 5> t5;\n+    sa<sizeof(sink_5_14567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_14567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_5_14568(               A&);\n+four  sink_5_14568(const volatile A&);\n+five  sink_5_14568(               A&&);\n+six   sink_5_14568(const          A&&);\n+eight sink_5_14568(const volatile A&&);\n+\n+int test5_14568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_14568(a))           == 1> t1;\n+    sa<sizeof(sink_5_14568(ca))          == 4> t2;\n+    sa<sizeof(sink_5_14568(va))          == 4> t3;\n+    sa<sizeof(sink_5_14568(cva))         == 4> t4;\n+    sa<sizeof(sink_5_14568(source()))    == 5> t5;\n+    sa<sizeof(sink_5_14568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_14568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_14568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_14578(               A&);\n+four  sink_5_14578(const volatile A&);\n+five  sink_5_14578(               A&&);\n+seven sink_5_14578(volatile       A&&);\n+eight sink_5_14578(const volatile A&&);\n+\n+int test5_14578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_14578(a))           == 1> t1;\n+    sa<sizeof(sink_5_14578(ca))          == 4> t2;\n+    sa<sizeof(sink_5_14578(va))          == 4> t3;\n+    sa<sizeof(sink_5_14578(cva))         == 4> t4;\n+    sa<sizeof(sink_5_14578(source()))    == 5> t5;\n+    sa<sizeof(sink_5_14578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_14578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_14578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_14678(               A&);\n+four  sink_5_14678(const volatile A&);\n+six   sink_5_14678(const          A&&);\n+seven sink_5_14678(volatile       A&&);\n+eight sink_5_14678(const volatile A&&);\n+\n+int test5_14678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_14678(a))           == 1> t1;\n+    sa<sizeof(sink_5_14678(ca))          == 4> t2;\n+    sa<sizeof(sink_5_14678(va))          == 4> t3;\n+    sa<sizeof(sink_5_14678(cva))         == 4> t4;\n+    sa<sizeof(sink_5_14678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_14678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_14678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_5_15678(               A&);\n+five  sink_5_15678(               A&&);\n+six   sink_5_15678(const          A&&);\n+seven sink_5_15678(volatile       A&&);\n+eight sink_5_15678(const volatile A&&);\n+\n+int test5_15678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_15678(a))           == 1> t1;\n+    sa<sizeof(sink_5_15678(ca))          == 6> t2;\n+    sa<sizeof(sink_5_15678(va))          == 7> t3;\n+    sa<sizeof(sink_5_15678(cva))         == 8> t4;\n+    sa<sizeof(sink_5_15678(source()))    == 5> t5;\n+    sa<sizeof(sink_5_15678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_15678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_15678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_23456(const          A&);\n+three sink_5_23456(volatile       A&);\n+four  sink_5_23456(const volatile A&);\n+five  sink_5_23456(               A&&);\n+six   sink_5_23456(const          A&&);\n+\n+int test5_23456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23456(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23456(va))          == 3> t3;\n+    sa<sizeof(sink_5_23456(cva))         == 4> t4;\n+    sa<sizeof(sink_5_23456(source()))    == 5> t5;\n+    sa<sizeof(sink_5_23456(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+two   sink_5_23457(const          A&);\n+three sink_5_23457(volatile       A&);\n+four  sink_5_23457(const volatile A&);\n+five  sink_5_23457(               A&&);\n+seven sink_5_23457(volatile       A&&);\n+\n+int test5_23457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23457(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23457(va))          == 3> t3;\n+    sa<sizeof(sink_5_23457(cva))         == 4> t4;\n+    sa<sizeof(sink_5_23457(source()))    == 5> t5;\n+    sa<sizeof(sink_5_23457(c_source()))  == 2> t6;\n+    sa<sizeof(sink_5_23457(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_5_23458(const          A&);\n+three sink_5_23458(volatile       A&);\n+four  sink_5_23458(const volatile A&);\n+five  sink_5_23458(               A&&);\n+eight sink_5_23458(const volatile A&&);\n+\n+int test5_23458()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23458(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23458(va))          == 3> t3;\n+    sa<sizeof(sink_5_23458(cva))         == 4> t4;\n+    sa<sizeof(sink_5_23458(source()))    == 5> t5;\n+    sa<sizeof(sink_5_23458(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_23458(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_23458(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_23467(const          A&);\n+three sink_5_23467(volatile       A&);\n+four  sink_5_23467(const volatile A&);\n+six   sink_5_23467(const          A&&);\n+seven sink_5_23467(volatile       A&&);\n+\n+int test5_23467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23467(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23467(va))          == 3> t3;\n+    sa<sizeof(sink_5_23467(cva))         == 4> t4;\n+    sa<sizeof(sink_5_23467(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_23467(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_5_23468(const          A&);\n+three sink_5_23468(volatile       A&);\n+four  sink_5_23468(const volatile A&);\n+six   sink_5_23468(const          A&&);\n+eight sink_5_23468(const volatile A&&);\n+\n+int test5_23468()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23468(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23468(va))          == 3> t3;\n+    sa<sizeof(sink_5_23468(cva))         == 4> t4;\n+    sa<sizeof(sink_5_23468(source()))    == 6> t5;\n+    sa<sizeof(sink_5_23468(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_23468(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_23468(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_23478(const          A&);\n+three sink_5_23478(volatile       A&);\n+four  sink_5_23478(const volatile A&);\n+seven sink_5_23478(volatile       A&&);\n+eight sink_5_23478(const volatile A&&);\n+\n+int test5_23478()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23478(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23478(va))          == 3> t3;\n+    sa<sizeof(sink_5_23478(cva))         == 4> t4;\n+    sa<sizeof(sink_5_23478(source()))    == 7> t5;\n+    sa<sizeof(sink_5_23478(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_23478(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_23478(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_23567(const          A&);\n+three sink_5_23567(volatile       A&);\n+five  sink_5_23567(               A&&);\n+six   sink_5_23567(const          A&&);\n+seven sink_5_23567(volatile       A&&);\n+\n+int test5_23567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23567(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23567(va))          == 3> t3;\n+    sa<sizeof(sink_5_23567(source()))    == 5> t5;\n+    sa<sizeof(sink_5_23567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_23567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_5_23568(const          A&);\n+three sink_5_23568(volatile       A&);\n+five  sink_5_23568(               A&&);\n+six   sink_5_23568(const          A&&);\n+eight sink_5_23568(const volatile A&&);\n+\n+int test5_23568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23568(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23568(va))          == 3> t3;\n+    sa<sizeof(sink_5_23568(cva))         == 8> t4;\n+    sa<sizeof(sink_5_23568(source()))    == 5> t5;\n+    sa<sizeof(sink_5_23568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_23568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_23568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_23578(const          A&);\n+three sink_5_23578(volatile       A&);\n+five  sink_5_23578(               A&&);\n+seven sink_5_23578(volatile       A&&);\n+eight sink_5_23578(const volatile A&&);\n+\n+int test5_23578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23578(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23578(va))          == 3> t3;\n+    sa<sizeof(sink_5_23578(cva))         == 8> t4;\n+    sa<sizeof(sink_5_23578(source()))    == 5> t5;\n+    sa<sizeof(sink_5_23578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_23578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_23578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_23678(const          A&);\n+three sink_5_23678(volatile       A&);\n+six   sink_5_23678(const          A&&);\n+seven sink_5_23678(volatile       A&&);\n+eight sink_5_23678(const volatile A&&);\n+\n+int test5_23678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_23678(ca))          == 2> t2;\n+    sa<sizeof(sink_5_23678(va))          == 3> t3;\n+    sa<sizeof(sink_5_23678(cva))         == 8> t4;\n+    sa<sizeof(sink_5_23678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_23678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_23678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_24567(const          A&);\n+four  sink_5_24567(const volatile A&);\n+five  sink_5_24567(               A&&);\n+six   sink_5_24567(const          A&&);\n+seven sink_5_24567(volatile       A&&);\n+\n+int test5_24567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_24567(a))           == 2> t1;\n+    sa<sizeof(sink_5_24567(ca))          == 2> t2;\n+    sa<sizeof(sink_5_24567(va))          == 4> t3;\n+    sa<sizeof(sink_5_24567(cva))         == 4> t4;\n+    sa<sizeof(sink_5_24567(source()))    == 5> t5;\n+    sa<sizeof(sink_5_24567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_24567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_5_24568(const          A&);\n+four  sink_5_24568(const volatile A&);\n+five  sink_5_24568(               A&&);\n+six   sink_5_24568(const          A&&);\n+eight sink_5_24568(const volatile A&&);\n+\n+int test5_24568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_24568(a))           == 2> t1;\n+    sa<sizeof(sink_5_24568(ca))          == 2> t2;\n+    sa<sizeof(sink_5_24568(va))          == 4> t3;\n+    sa<sizeof(sink_5_24568(cva))         == 4> t4;\n+    sa<sizeof(sink_5_24568(source()))    == 5> t5;\n+    sa<sizeof(sink_5_24568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_24568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_24568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_24578(const          A&);\n+four  sink_5_24578(const volatile A&);\n+five  sink_5_24578(               A&&);\n+seven sink_5_24578(volatile       A&&);\n+eight sink_5_24578(const volatile A&&);\n+\n+int test5_24578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_24578(a))           == 2> t1;\n+    sa<sizeof(sink_5_24578(ca))          == 2> t2;\n+    sa<sizeof(sink_5_24578(va))          == 4> t3;\n+    sa<sizeof(sink_5_24578(cva))         == 4> t4;\n+    sa<sizeof(sink_5_24578(source()))    == 5> t5;\n+    sa<sizeof(sink_5_24578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_24578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_24578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_24678(const          A&);\n+four  sink_5_24678(const volatile A&);\n+six   sink_5_24678(const          A&&);\n+seven sink_5_24678(volatile       A&&);\n+eight sink_5_24678(const volatile A&&);\n+\n+int test5_24678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_24678(a))           == 2> t1;\n+    sa<sizeof(sink_5_24678(ca))          == 2> t2;\n+    sa<sizeof(sink_5_24678(va))          == 4> t3;\n+    sa<sizeof(sink_5_24678(cva))         == 4> t4;\n+    sa<sizeof(sink_5_24678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_24678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_24678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_5_25678(const          A&);\n+five  sink_5_25678(               A&&);\n+six   sink_5_25678(const          A&&);\n+seven sink_5_25678(volatile       A&&);\n+eight sink_5_25678(const volatile A&&);\n+\n+int test5_25678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_25678(a))           == 2> t1;\n+    sa<sizeof(sink_5_25678(ca))          == 2> t2;\n+    sa<sizeof(sink_5_25678(va))          == 7> t3;\n+    sa<sizeof(sink_5_25678(cva))         == 8> t4;\n+    sa<sizeof(sink_5_25678(source()))    == 5> t5;\n+    sa<sizeof(sink_5_25678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_25678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_25678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_5_34567(volatile       A&);\n+four  sink_5_34567(const volatile A&);\n+five  sink_5_34567(               A&&);\n+six   sink_5_34567(const          A&&);\n+seven sink_5_34567(volatile       A&&);\n+\n+int test5_34567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_34567(a))           == 3> t1;\n+    sa<sizeof(sink_5_34567(ca))          == 4> t2;\n+    sa<sizeof(sink_5_34567(va))          == 3> t3;\n+    sa<sizeof(sink_5_34567(cva))         == 4> t4;\n+    sa<sizeof(sink_5_34567(source()))    == 5> t5;\n+    sa<sizeof(sink_5_34567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_34567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+three sink_5_34568(volatile       A&);\n+four  sink_5_34568(const volatile A&);\n+five  sink_5_34568(               A&&);\n+six   sink_5_34568(const          A&&);\n+eight sink_5_34568(const volatile A&&);\n+\n+int test5_34568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_34568(a))           == 3> t1;\n+    sa<sizeof(sink_5_34568(ca))          == 4> t2;\n+    sa<sizeof(sink_5_34568(va))          == 3> t3;\n+    sa<sizeof(sink_5_34568(cva))         == 4> t4;\n+    sa<sizeof(sink_5_34568(source()))    == 5> t5;\n+    sa<sizeof(sink_5_34568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_34568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_5_34568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_5_34578(volatile       A&);\n+four  sink_5_34578(const volatile A&);\n+five  sink_5_34578(               A&&);\n+seven sink_5_34578(volatile       A&&);\n+eight sink_5_34578(const volatile A&&);\n+\n+int test5_34578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_34578(a))           == 3> t1;\n+    sa<sizeof(sink_5_34578(ca))          == 4> t2;\n+    sa<sizeof(sink_5_34578(va))          == 3> t3;\n+    sa<sizeof(sink_5_34578(cva))         == 4> t4;\n+    sa<sizeof(sink_5_34578(source()))    == 5> t5;\n+    sa<sizeof(sink_5_34578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_5_34578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_34578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_5_34678(volatile       A&);\n+four  sink_5_34678(const volatile A&);\n+six   sink_5_34678(const          A&&);\n+seven sink_5_34678(volatile       A&&);\n+eight sink_5_34678(const volatile A&&);\n+\n+int test5_34678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_34678(a))           == 3> t1;\n+    sa<sizeof(sink_5_34678(ca))          == 4> t2;\n+    sa<sizeof(sink_5_34678(va))          == 3> t3;\n+    sa<sizeof(sink_5_34678(cva))         == 4> t4;\n+    sa<sizeof(sink_5_34678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_34678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_34678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_5_35678(volatile       A&);\n+five  sink_5_35678(               A&&);\n+six   sink_5_35678(const          A&&);\n+seven sink_5_35678(volatile       A&&);\n+eight sink_5_35678(const volatile A&&);\n+\n+int test5_35678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_35678(a))           == 3> t1;\n+    sa<sizeof(sink_5_35678(ca))          == 6> t2;\n+    sa<sizeof(sink_5_35678(va))          == 3> t3;\n+    sa<sizeof(sink_5_35678(cva))         == 8> t4;\n+    sa<sizeof(sink_5_35678(source()))    == 5> t5;\n+    sa<sizeof(sink_5_35678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_35678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_35678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+four  sink_5_45678(const volatile A&);\n+five  sink_5_45678(               A&&);\n+six   sink_5_45678(const          A&&);\n+seven sink_5_45678(volatile       A&&);\n+eight sink_5_45678(const volatile A&&);\n+\n+int test5_45678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_5_45678(a))           == 4> t1;\n+    sa<sizeof(sink_5_45678(ca))          == 4> t2;\n+    sa<sizeof(sink_5_45678(va))          == 4> t3;\n+    sa<sizeof(sink_5_45678(cva))         == 4> t4;\n+    sa<sizeof(sink_5_45678(source()))    == 5> t5;\n+    sa<sizeof(sink_5_45678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_5_45678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_5_45678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test5_12345() + test5_12346() + test5_12347() + test5_12348() +\n+           test5_12356() + test5_12357() + test5_12358() + test5_12367() +\n+           test5_12368() + test5_12378() + test5_12456() + test5_12457() +\n+           test5_12458() + test5_12467() + test5_12468() + test5_12478() +\n+           test5_12567() + test5_12568() + test5_12578() + test5_12678() +\n+           test5_13456() + test5_13457() + test5_13458() + test5_13467() +\n+           test5_13468() + test5_13478() + test5_13567() + test5_13568() +\n+           test5_13578() + test5_13678() + test5_14567() + test5_14568() +\n+           test5_14578() + test5_14678() + test5_15678() + test5_23456() +\n+           test5_23457() + test5_23458() + test5_23467() + test5_23468() +\n+           test5_23478() + test5_23567() + test5_23568() + test5_23578() +\n+           test5_23678() + test5_24567() + test5_24568() + test5_24578() +\n+           test5_24678() + test5_25678() + test5_34567() + test5_34568() +\n+           test5_34578() + test5_34678() + test5_35678() + test5_45678();\n+}"}, {"sha": "9a925ef0c61788f6fb77da776d748a023a66cc17", "filename": "gcc/testsuite/g++.dg/cpp0x/rv6n.C", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv6n.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv6n.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv6n.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,281 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 6 at a time\n+\n+one   sink_6_123456(               A&);  // { dg-error \"\" }\n+two   sink_6_123456(const          A&);  // { dg-error \"\" }\n+three sink_6_123456(volatile       A&);  // { dg-error \"\" }\n+four  sink_6_123456(const volatile A&);  // { dg-error \"\" }\n+five  sink_6_123456(               A&&);  // { dg-error \"\" }\n+six   sink_6_123456(const          A&&);  // { dg-error \"\" }\n+\n+int test6_123456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_123456(v_source());   // { dg-error \"no match\" }\n+    sink_6_123456(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_6_123457(               A&);  // { dg-error \"\" }\n+two   sink_6_123457(const          A&);  // { dg-error \"\" }\n+three sink_6_123457(volatile       A&);  // { dg-error \"\" }\n+four  sink_6_123457(const volatile A&);  // { dg-error \"\" }\n+five  sink_6_123457(               A&&);  // { dg-error \"\" }\n+seven sink_6_123457(volatile       A&&);  // { dg-error \"\" }\n+\n+int test6_123457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_123457(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_6_235678(const          A&);  // { dg-error \"\" }\n+three sink_6_235678(volatile       A&);  // { dg-error \"\" }\n+five  sink_6_235678(               A&&);  // { dg-error \"\" }\n+six   sink_6_235678(const          A&&);  // { dg-error \"\" }\n+seven sink_6_235678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_6_235678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test6_235678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_235678(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_6_234678(const          A&);  // { dg-error \"\" }\n+three sink_6_234678(volatile       A&);  // { dg-error \"\" }\n+four  sink_6_234678(const volatile A&);  // { dg-error \"\" }\n+six   sink_6_234678(const          A&&);  // { dg-error \"\" }\n+seven sink_6_234678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_6_234678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test6_234678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_234678(a);         // { dg-error \"ambiguous\" }\n+    sink_6_234678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_6_234578(const          A&);  // { dg-error \"\" }\n+three sink_6_234578(volatile       A&);  // { dg-error \"\" }\n+four  sink_6_234578(const volatile A&);  // { dg-error \"\" }\n+five  sink_6_234578(               A&&);  // { dg-error \"\" }\n+seven sink_6_234578(volatile       A&&);  // { dg-error \"\" }\n+eight sink_6_234578(const volatile A&&);  // { dg-error \"\" }\n+\n+int test6_234578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_234578(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_6_234568(const          A&);  // { dg-error \"\" }\n+three sink_6_234568(volatile       A&);  // { dg-error \"\" }\n+four  sink_6_234568(const volatile A&);  // { dg-error \"\" }\n+five  sink_6_234568(               A&&);  // { dg-error \"\" }\n+six   sink_6_234568(const          A&&);  // { dg-error \"\" }\n+eight sink_6_234568(const volatile A&&);  // { dg-error \"\" }\n+\n+int test6_234568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_234568(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+two   sink_6_234567(const          A&);  // { dg-error \"\" }\n+three sink_6_234567(volatile       A&);  // { dg-error \"\" }\n+four  sink_6_234567(const volatile A&);  // { dg-error \"\" }\n+five  sink_6_234567(               A&&);  // { dg-error \"\" }\n+six   sink_6_234567(const          A&&);  // { dg-error \"\" }\n+seven sink_6_234567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test6_234567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_234567(a);            // { dg-error \"ambiguous\" }\n+    sink_6_234567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_6_134678(               A&);\n+three sink_6_134678(volatile       A&);\n+four  sink_6_134678(const volatile A&);\n+six   sink_6_134678(const          A&&);  // { dg-error \"\" }\n+seven sink_6_134678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_6_134678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test6_134678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_134678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+one   sink_6_124678(               A&);\n+two   sink_6_124678(const          A&);  // { dg-error \"\" }\n+four  sink_6_124678(const volatile A&);\n+six   sink_6_124678(const          A&&);  // { dg-error \"\" }\n+seven sink_6_124678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_6_124678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test6_124678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_124678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+one   sink_6_123678(               A&);\n+two   sink_6_123678(const          A&);  // { dg-error \"\" }\n+three sink_6_123678(volatile       A&);\n+six   sink_6_123678(const          A&&);  // { dg-error \"\" }\n+seven sink_6_123678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_6_123678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test6_123678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_123678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+one   sink_6_123567(               A&);  // { dg-error \"\" }\n+two   sink_6_123567(const          A&);  // { dg-error \"\" }\n+three sink_6_123567(volatile       A&);  // { dg-error \"\" }\n+five  sink_6_123567(               A&&);  // { dg-error \"\" }\n+six   sink_6_123567(const          A&&);  // { dg-error \"\" }\n+seven sink_6_123567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test6_123567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_123567(cva);          // { dg-error \"no match\" }\n+    sink_6_123567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_6_123467(               A&);  // { dg-error \"\" }\n+two   sink_6_123467(const          A&);  // { dg-error \"\" }\n+three sink_6_123467(volatile       A&);  // { dg-error \"\" }\n+four  sink_6_123467(const volatile A&);  // { dg-error \"\" }\n+six   sink_6_123467(const          A&&);  // { dg-error \"\" }\n+seven sink_6_123467(volatile       A&&);  // { dg-error \"\" }\n+\n+int test6_123467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_123467(source());     // { dg-error \"ambiguous\" }\n+    sink_6_123467(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_6_124567(               A&);  // { dg-error \"\" }\n+two   sink_6_124567(const          A&);  // { dg-error \"\" }\n+four  sink_6_124567(const volatile A&);  // { dg-error \"\" }\n+five  sink_6_124567(               A&&);  // { dg-error \"\" }\n+six   sink_6_124567(const          A&&);  // { dg-error \"\" }\n+seven sink_6_124567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test6_124567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_124567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+one   sink_6_134567(               A&);  // { dg-error \"\" }\n+three sink_6_134567(volatile       A&);  // { dg-error \"\" }\n+four  sink_6_134567(const volatile A&);  // { dg-error \"\" }\n+five  sink_6_134567(               A&&);  // { dg-error \"\" }\n+six   sink_6_134567(const          A&&);  // { dg-error \"\" }\n+seven sink_6_134567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test6_134567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_6_134567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test6_235678() + test6_234678() + test6_234578() + test6_234568() +\n+           test6_234567() + test6_134678() + test6_124678() + test6_123678() +\n+           test6_123567();\n+}"}, {"sha": "a59958e37ef51e958535d9d01c4cb19cd187183d", "filename": "gcc/testsuite/g++.dg/cpp0x/rv6p.C", "status": "added", "additions": 695, "deletions": 0, "changes": 695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv6p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv6p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv6p.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,695 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 6 at a time\n+\n+one   sink_6_123456(               A&);\n+two   sink_6_123456(const          A&);\n+three sink_6_123456(volatile       A&);\n+four  sink_6_123456(const volatile A&);\n+five  sink_6_123456(               A&&);\n+six   sink_6_123456(const          A&&);\n+\n+int test6_123456()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123456(a))           == 1> t1;\n+    sa<sizeof(sink_6_123456(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123456(va))          == 3> t3;\n+    sa<sizeof(sink_6_123456(cva))         == 4> t4;\n+    sa<sizeof(sink_6_123456(source()))    == 5> t5;\n+    sa<sizeof(sink_6_123456(c_source()))  == 6> t6;\n+    return 0;\n+}\n+\n+one   sink_6_123457(               A&);\n+two   sink_6_123457(const          A&);\n+three sink_6_123457(volatile       A&);\n+four  sink_6_123457(const volatile A&);\n+five  sink_6_123457(               A&&);\n+seven sink_6_123457(volatile       A&&);\n+\n+int test6_123457()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123457(a))           == 1> t1;\n+    sa<sizeof(sink_6_123457(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123457(va))          == 3> t3;\n+    sa<sizeof(sink_6_123457(cva))         == 4> t4;\n+    sa<sizeof(sink_6_123457(source()))    == 5> t5;\n+    sa<sizeof(sink_6_123457(c_source()))  == 2> t6;\n+    sa<sizeof(sink_6_123457(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_6_123458(               A&);\n+two   sink_6_123458(const          A&);\n+three sink_6_123458(volatile       A&);\n+four  sink_6_123458(const volatile A&);\n+five  sink_6_123458(               A&&);\n+eight sink_6_123458(const volatile A&&);\n+\n+int test6_123458()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123458(a))           == 1> t1;\n+    sa<sizeof(sink_6_123458(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123458(va))          == 3> t3;\n+    sa<sizeof(sink_6_123458(cva))         == 4> t4;\n+    sa<sizeof(sink_6_123458(source()))    == 5> t5;\n+    sa<sizeof(sink_6_123458(c_source()))  == 8> t6;\n+    sa<sizeof(sink_6_123458(v_source()))  == 8> t7;\n+    sa<sizeof(sink_6_123458(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_123467(               A&);\n+two   sink_6_123467(const          A&);\n+three sink_6_123467(volatile       A&);\n+four  sink_6_123467(const volatile A&);\n+six   sink_6_123467(const          A&&);\n+seven sink_6_123467(volatile       A&&);\n+\n+int test6_123467()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123467(a))           == 1> t1;\n+    sa<sizeof(sink_6_123467(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123467(va))          == 3> t3;\n+    sa<sizeof(sink_6_123467(cva))         == 4> t4;\n+    sa<sizeof(sink_6_123467(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_123467(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_6_123468(               A&);\n+two   sink_6_123468(const          A&);\n+three sink_6_123468(volatile       A&);\n+four  sink_6_123468(const volatile A&);\n+six   sink_6_123468(const          A&&);\n+eight sink_6_123468(const volatile A&&);\n+\n+int test6_123468()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123468(a))           == 1> t1;\n+    sa<sizeof(sink_6_123468(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123468(va))          == 3> t3;\n+    sa<sizeof(sink_6_123468(cva))         == 4> t4;\n+    sa<sizeof(sink_6_123468(source()))    == 6> t5;\n+    sa<sizeof(sink_6_123468(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_123468(v_source()))  == 8> t7;\n+    sa<sizeof(sink_6_123468(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_123478(               A&);\n+two   sink_6_123478(const          A&);\n+three sink_6_123478(volatile       A&);\n+four  sink_6_123478(const volatile A&);\n+seven sink_6_123478(volatile       A&&);\n+eight sink_6_123478(const volatile A&&);\n+\n+int test6_123478()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123478(a))           == 1> t1;\n+    sa<sizeof(sink_6_123478(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123478(va))          == 3> t3;\n+    sa<sizeof(sink_6_123478(cva))         == 4> t4;\n+    sa<sizeof(sink_6_123478(source()))    == 7> t5;\n+    sa<sizeof(sink_6_123478(c_source()))  == 8> t6;\n+    sa<sizeof(sink_6_123478(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_123478(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_123567(               A&);\n+two   sink_6_123567(const          A&);\n+three sink_6_123567(volatile       A&);\n+five  sink_6_123567(               A&&);\n+six   sink_6_123567(const          A&&);\n+seven sink_6_123567(volatile       A&&);\n+\n+int test6_123567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123567(a))           == 1> t1;\n+    sa<sizeof(sink_6_123567(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123567(va))          == 3> t3;\n+    sa<sizeof(sink_6_123567(source()))    == 5> t5;\n+    sa<sizeof(sink_6_123567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_123567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_6_123568(               A&);\n+two   sink_6_123568(const          A&);\n+three sink_6_123568(volatile       A&);\n+five  sink_6_123568(               A&&);\n+six   sink_6_123568(const          A&&);\n+eight sink_6_123568(const volatile A&&);\n+\n+int test6_123568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123568(a))           == 1> t1;\n+    sa<sizeof(sink_6_123568(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123568(va))          == 3> t3;\n+    sa<sizeof(sink_6_123568(cva))         == 8> t4;\n+    sa<sizeof(sink_6_123568(source()))    == 5> t5;\n+    sa<sizeof(sink_6_123568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_123568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_6_123568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_123578(               A&);\n+two   sink_6_123578(const          A&);\n+three sink_6_123578(volatile       A&);\n+five  sink_6_123578(               A&&);\n+seven sink_6_123578(volatile       A&&);\n+eight sink_6_123578(const volatile A&&);\n+\n+int test6_123578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123578(a))           == 1> t1;\n+    sa<sizeof(sink_6_123578(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123578(va))          == 3> t3;\n+    sa<sizeof(sink_6_123578(cva))         == 8> t4;\n+    sa<sizeof(sink_6_123578(source()))    == 5> t5;\n+    sa<sizeof(sink_6_123578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_6_123578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_123578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_123678(               A&);\n+two   sink_6_123678(const          A&);\n+three sink_6_123678(volatile       A&);\n+six   sink_6_123678(const          A&&);\n+seven sink_6_123678(volatile       A&&);\n+eight sink_6_123678(const volatile A&&);\n+\n+int test6_123678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_123678(a))           == 1> t1;\n+    sa<sizeof(sink_6_123678(ca))          == 2> t2;\n+    sa<sizeof(sink_6_123678(va))          == 3> t3;\n+    sa<sizeof(sink_6_123678(cva))         == 8> t4;\n+    sa<sizeof(sink_6_123678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_123678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_123678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_124567(               A&);\n+two   sink_6_124567(const          A&);\n+four  sink_6_124567(const volatile A&);\n+five  sink_6_124567(               A&&);\n+six   sink_6_124567(const          A&&);\n+seven sink_6_124567(volatile       A&&);\n+\n+int test6_124567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_124567(a))           == 1> t1;\n+    sa<sizeof(sink_6_124567(ca))          == 2> t2;\n+    sa<sizeof(sink_6_124567(va))          == 4> t3;\n+    sa<sizeof(sink_6_124567(cva))         == 4> t4;\n+    sa<sizeof(sink_6_124567(source()))    == 5> t5;\n+    sa<sizeof(sink_6_124567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_124567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_6_124568(               A&);\n+two   sink_6_124568(const          A&);\n+four  sink_6_124568(const volatile A&);\n+five  sink_6_124568(               A&&);\n+six   sink_6_124568(const          A&&);\n+eight sink_6_124568(const volatile A&&);\n+\n+int test6_124568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_124568(a))           == 1> t1;\n+    sa<sizeof(sink_6_124568(ca))          == 2> t2;\n+    sa<sizeof(sink_6_124568(va))          == 4> t3;\n+    sa<sizeof(sink_6_124568(cva))         == 4> t4;\n+    sa<sizeof(sink_6_124568(source()))    == 5> t5;\n+    sa<sizeof(sink_6_124568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_124568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_6_124568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_124578(               A&);\n+two   sink_6_124578(const          A&);\n+four  sink_6_124578(const volatile A&);\n+five  sink_6_124578(               A&&);\n+seven sink_6_124578(volatile       A&&);\n+eight sink_6_124578(const volatile A&&);\n+\n+int test6_124578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_124578(a))           == 1> t1;\n+    sa<sizeof(sink_6_124578(ca))          == 2> t2;\n+    sa<sizeof(sink_6_124578(va))          == 4> t3;\n+    sa<sizeof(sink_6_124578(cva))         == 4> t4;\n+    sa<sizeof(sink_6_124578(source()))    == 5> t5;\n+    sa<sizeof(sink_6_124578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_6_124578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_124578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_124678(               A&);\n+two   sink_6_124678(const          A&);\n+four  sink_6_124678(const volatile A&);\n+six   sink_6_124678(const          A&&);\n+seven sink_6_124678(volatile       A&&);\n+eight sink_6_124678(const volatile A&&);\n+\n+int test6_124678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_124678(a))           == 1> t1;\n+    sa<sizeof(sink_6_124678(ca))          == 2> t2;\n+    sa<sizeof(sink_6_124678(va))          == 4> t3;\n+    sa<sizeof(sink_6_124678(cva))         == 4> t4;\n+    sa<sizeof(sink_6_124678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_124678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_124678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_125678(               A&);\n+two   sink_6_125678(const          A&);\n+five  sink_6_125678(               A&&);\n+six   sink_6_125678(const          A&&);\n+seven sink_6_125678(volatile       A&&);\n+eight sink_6_125678(const volatile A&&);\n+\n+int test6_125678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_125678(a))           == 1> t1;\n+    sa<sizeof(sink_6_125678(ca))          == 2> t2;\n+    sa<sizeof(sink_6_125678(va))          == 7> t3;\n+    sa<sizeof(sink_6_125678(cva))         == 8> t4;\n+    sa<sizeof(sink_6_125678(source()))    == 5> t5;\n+    sa<sizeof(sink_6_125678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_125678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_125678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_134567(               A&);\n+three sink_6_134567(volatile       A&);\n+four  sink_6_134567(const volatile A&);\n+five  sink_6_134567(               A&&);\n+six   sink_6_134567(const          A&&);\n+seven sink_6_134567(volatile       A&&);\n+\n+int test6_134567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_134567(a))           == 1> t1;\n+    sa<sizeof(sink_6_134567(ca))          == 4> t2;\n+    sa<sizeof(sink_6_134567(va))          == 3> t3;\n+    sa<sizeof(sink_6_134567(cva))         == 4> t4;\n+    sa<sizeof(sink_6_134567(source()))    == 5> t5;\n+    sa<sizeof(sink_6_134567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_134567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_6_134568(               A&);\n+three sink_6_134568(volatile       A&);\n+four  sink_6_134568(const volatile A&);\n+five  sink_6_134568(               A&&);\n+six   sink_6_134568(const          A&&);\n+eight sink_6_134568(const volatile A&&);\n+\n+int test6_134568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_134568(a))           == 1> t1;\n+    sa<sizeof(sink_6_134568(ca))          == 4> t2;\n+    sa<sizeof(sink_6_134568(va))          == 3> t3;\n+    sa<sizeof(sink_6_134568(cva))         == 4> t4;\n+    sa<sizeof(sink_6_134568(source()))    == 5> t5;\n+    sa<sizeof(sink_6_134568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_134568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_6_134568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_134578(               A&);\n+three sink_6_134578(volatile       A&);\n+four  sink_6_134578(const volatile A&);\n+five  sink_6_134578(               A&&);\n+seven sink_6_134578(volatile       A&&);\n+eight sink_6_134578(const volatile A&&);\n+\n+int test6_134578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_134578(a))           == 1> t1;\n+    sa<sizeof(sink_6_134578(ca))          == 4> t2;\n+    sa<sizeof(sink_6_134578(va))          == 3> t3;\n+    sa<sizeof(sink_6_134578(cva))         == 4> t4;\n+    sa<sizeof(sink_6_134578(source()))    == 5> t5;\n+    sa<sizeof(sink_6_134578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_6_134578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_134578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_134678(               A&);\n+three sink_6_134678(volatile       A&);\n+four  sink_6_134678(const volatile A&);\n+six   sink_6_134678(const          A&&);\n+seven sink_6_134678(volatile       A&&);\n+eight sink_6_134678(const volatile A&&);\n+\n+int test6_134678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_134678(a))           == 1> t1;\n+    sa<sizeof(sink_6_134678(ca))          == 4> t2;\n+    sa<sizeof(sink_6_134678(va))          == 3> t3;\n+    sa<sizeof(sink_6_134678(cva))         == 4> t4;\n+    sa<sizeof(sink_6_134678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_134678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_134678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_135678(               A&);\n+three sink_6_135678(volatile       A&);\n+five  sink_6_135678(               A&&);\n+six   sink_6_135678(const          A&&);\n+seven sink_6_135678(volatile       A&&);\n+eight sink_6_135678(const volatile A&&);\n+\n+int test6_135678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_135678(a))           == 1> t1;\n+    sa<sizeof(sink_6_135678(ca))          == 6> t2;\n+    sa<sizeof(sink_6_135678(va))          == 3> t3;\n+    sa<sizeof(sink_6_135678(cva))         == 8> t4;\n+    sa<sizeof(sink_6_135678(source()))    == 5> t5;\n+    sa<sizeof(sink_6_135678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_135678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_135678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_6_145678(               A&);\n+four  sink_6_145678(const volatile A&);\n+five  sink_6_145678(               A&&);\n+six   sink_6_145678(const          A&&);\n+seven sink_6_145678(volatile       A&&);\n+eight sink_6_145678(const volatile A&&);\n+\n+int test6_145678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_145678(a))           == 1> t1;\n+    sa<sizeof(sink_6_145678(ca))          == 4> t2;\n+    sa<sizeof(sink_6_145678(va))          == 4> t3;\n+    sa<sizeof(sink_6_145678(cva))         == 4> t4;\n+    sa<sizeof(sink_6_145678(source()))    == 5> t5;\n+    sa<sizeof(sink_6_145678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_145678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_145678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_6_234567(const          A&);\n+three sink_6_234567(volatile       A&);\n+four  sink_6_234567(const volatile A&);\n+five  sink_6_234567(               A&&);\n+six   sink_6_234567(const          A&&);\n+seven sink_6_234567(volatile       A&&);\n+\n+int test6_234567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_234567(ca))          == 2> t2;\n+    sa<sizeof(sink_6_234567(va))          == 3> t3;\n+    sa<sizeof(sink_6_234567(cva))         == 4> t4;\n+    sa<sizeof(sink_6_234567(source()))    == 5> t5;\n+    sa<sizeof(sink_6_234567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_234567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+two   sink_6_234568(const          A&);\n+three sink_6_234568(volatile       A&);\n+four  sink_6_234568(const volatile A&);\n+five  sink_6_234568(               A&&);\n+six   sink_6_234568(const          A&&);\n+eight sink_6_234568(const volatile A&&);\n+\n+int test6_234568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_234568(ca))          == 2> t2;\n+    sa<sizeof(sink_6_234568(va))          == 3> t3;\n+    sa<sizeof(sink_6_234568(cva))         == 4> t4;\n+    sa<sizeof(sink_6_234568(source()))    == 5> t5;\n+    sa<sizeof(sink_6_234568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_234568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_6_234568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_6_234578(const          A&);\n+three sink_6_234578(volatile       A&);\n+four  sink_6_234578(const volatile A&);\n+five  sink_6_234578(               A&&);\n+seven sink_6_234578(volatile       A&&);\n+eight sink_6_234578(const volatile A&&);\n+\n+int test6_234578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_234578(ca))          == 2> t2;\n+    sa<sizeof(sink_6_234578(va))          == 3> t3;\n+    sa<sizeof(sink_6_234578(cva))         == 4> t4;\n+    sa<sizeof(sink_6_234578(source()))    == 5> t5;\n+    sa<sizeof(sink_6_234578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_6_234578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_234578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_6_234678(const          A&);\n+three sink_6_234678(volatile       A&);\n+four  sink_6_234678(const volatile A&);\n+six   sink_6_234678(const          A&&);\n+seven sink_6_234678(volatile       A&&);\n+eight sink_6_234678(const volatile A&&);\n+\n+int test6_234678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_234678(ca))          == 2> t2;\n+    sa<sizeof(sink_6_234678(va))          == 3> t3;\n+    sa<sizeof(sink_6_234678(cva))         == 4> t4;\n+    sa<sizeof(sink_6_234678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_234678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_234678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_6_235678(const          A&);\n+three sink_6_235678(volatile       A&);\n+five  sink_6_235678(               A&&);\n+six   sink_6_235678(const          A&&);\n+seven sink_6_235678(volatile       A&&);\n+eight sink_6_235678(const volatile A&&);\n+\n+int test6_235678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_235678(ca))          == 2> t2;\n+    sa<sizeof(sink_6_235678(va))          == 3> t3;\n+    sa<sizeof(sink_6_235678(cva))         == 8> t4;\n+    sa<sizeof(sink_6_235678(source()))    == 5> t5;\n+    sa<sizeof(sink_6_235678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_235678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_235678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_6_245678(const          A&);\n+four  sink_6_245678(const volatile A&);\n+five  sink_6_245678(               A&&);\n+six   sink_6_245678(const          A&&);\n+seven sink_6_245678(volatile       A&&);\n+eight sink_6_245678(const volatile A&&);\n+\n+int test6_245678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_245678(a))           == 2> t1;\n+    sa<sizeof(sink_6_245678(ca))          == 2> t2;\n+    sa<sizeof(sink_6_245678(va))          == 4> t3;\n+    sa<sizeof(sink_6_245678(cva))         == 4> t4;\n+    sa<sizeof(sink_6_245678(source()))    == 5> t5;\n+    sa<sizeof(sink_6_245678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_245678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_245678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+three sink_6_345678(volatile       A&);\n+four  sink_6_345678(const volatile A&);\n+five  sink_6_345678(               A&&);\n+six   sink_6_345678(const          A&&);\n+seven sink_6_345678(volatile       A&&);\n+eight sink_6_345678(const volatile A&&);\n+\n+int test6_345678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_6_345678(a))           == 3> t1;\n+    sa<sizeof(sink_6_345678(ca))          == 4> t2;\n+    sa<sizeof(sink_6_345678(va))          == 3> t3;\n+    sa<sizeof(sink_6_345678(cva))         == 4> t4;\n+    sa<sizeof(sink_6_345678(source()))    == 5> t5;\n+    sa<sizeof(sink_6_345678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_6_345678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_6_345678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test6_123456() + test6_123457() + test6_123458() + test6_123467() +\n+           test6_123468() + test6_123478() + test6_123567() + test6_123568() +\n+           test6_123578() + test6_123678() + test6_124567() + test6_124568() +\n+           test6_124578() + test6_124678() + test6_125678() + test6_134567() +\n+           test6_134568() + test6_134578() + test6_134678() + test6_135678() +\n+           test6_145678() + test6_234567() + test6_234568() + test6_234578() +\n+           test6_234678() + test6_235678() + test6_245678() + test6_345678();\n+}"}, {"sha": "acd884bdde4cee4dea8dd1acb4d9a5689ae7da45", "filename": "gcc/testsuite/g++.dg/cpp0x/rv7n.C", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv7n.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv7n.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv7n.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,90 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 7 at a time\n+\n+one   sink_7_1234567(               A&);  // { dg-error \"\" }\n+two   sink_7_1234567(const          A&);  // { dg-error \"\" }\n+three sink_7_1234567(volatile       A&);  // { dg-error \"\" }\n+four  sink_7_1234567(const volatile A&);  // { dg-error \"\" }\n+five  sink_7_1234567(               A&&);  // { dg-error \"\" }\n+six   sink_7_1234567(const          A&&);  // { dg-error \"\" }\n+seven sink_7_1234567(volatile       A&&);  // { dg-error \"\" }\n+\n+int test7_1234567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_7_1234567(cv_source());  // { dg-error \"no match\" }\n+    return 0;\n+}\n+\n+two   sink_7_2345678(const          A&);  // { dg-error \"\" }\n+three sink_7_2345678(volatile       A&);  // { dg-error \"\" }\n+four  sink_7_2345678(const volatile A&);  // { dg-error \"\" }\n+five  sink_7_2345678(               A&&);  // { dg-error \"\" }\n+six   sink_7_2345678(const          A&&);  // { dg-error \"\" }\n+seven sink_7_2345678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_7_2345678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test7_2345678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_7_2345678(a);  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+one   sink_7_1234678(               A&);\n+two   sink_7_1234678(const          A&);  // { dg-error \"\" }\n+three sink_7_1234678(volatile       A&);\n+four  sink_7_1234678(const volatile A&);\n+six   sink_7_1234678(const          A&&);  // { dg-error \"\" }\n+seven sink_7_1234678(volatile       A&&);  // { dg-error \"\" }\n+eight sink_7_1234678(const volatile A&&);  // { dg-error \"\" }\n+\n+int test7_1234678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sink_7_1234678(source());  // { dg-error \"ambiguous\" }\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test7_2345678() + test7_1234678();\n+}"}, {"sha": "d3e1474ff1064f6e44977aff09aececad915593a", "filename": "gcc/testsuite/g++.dg/cpp0x/rv7p.C", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv7p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv7p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv7p.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,234 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 7 at a time\n+\n+one   sink_7_1234567(               A&);\n+two   sink_7_1234567(const          A&);\n+three sink_7_1234567(volatile       A&);\n+four  sink_7_1234567(const volatile A&);\n+five  sink_7_1234567(               A&&);\n+six   sink_7_1234567(const          A&&);\n+seven sink_7_1234567(volatile       A&&);\n+\n+int test7_1234567()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_7_1234567(a))           == 1> t1;\n+    sa<sizeof(sink_7_1234567(ca))          == 2> t2;\n+    sa<sizeof(sink_7_1234567(va))          == 3> t3;\n+    sa<sizeof(sink_7_1234567(cva))         == 4> t4;\n+    sa<sizeof(sink_7_1234567(source()))    == 5> t5;\n+    sa<sizeof(sink_7_1234567(c_source()))  == 6> t6;\n+    sa<sizeof(sink_7_1234567(v_source()))  == 7> t7;\n+    return 0;\n+}\n+\n+one   sink_7_1234568(               A&);\n+two   sink_7_1234568(const          A&);\n+three sink_7_1234568(volatile       A&);\n+four  sink_7_1234568(const volatile A&);\n+five  sink_7_1234568(               A&&);\n+six   sink_7_1234568(const          A&&);\n+eight sink_7_1234568(const volatile A&&);\n+\n+int test7_1234568()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_7_1234568(a))           == 1> t1;\n+    sa<sizeof(sink_7_1234568(ca))          == 2> t2;\n+    sa<sizeof(sink_7_1234568(va))          == 3> t3;\n+    sa<sizeof(sink_7_1234568(cva))         == 4> t4;\n+    sa<sizeof(sink_7_1234568(source()))    == 5> t5;\n+    sa<sizeof(sink_7_1234568(c_source()))  == 6> t6;\n+    sa<sizeof(sink_7_1234568(v_source()))  == 8> t7;\n+    sa<sizeof(sink_7_1234568(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_7_1234578(               A&);\n+two   sink_7_1234578(const          A&);\n+three sink_7_1234578(volatile       A&);\n+four  sink_7_1234578(const volatile A&);\n+five  sink_7_1234578(               A&&);\n+seven sink_7_1234578(volatile       A&&);\n+eight sink_7_1234578(const volatile A&&);\n+\n+int test7_1234578()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_7_1234578(a))           == 1> t1;\n+    sa<sizeof(sink_7_1234578(ca))          == 2> t2;\n+    sa<sizeof(sink_7_1234578(va))          == 3> t3;\n+    sa<sizeof(sink_7_1234578(cva))         == 4> t4;\n+    sa<sizeof(sink_7_1234578(source()))    == 5> t5;\n+    sa<sizeof(sink_7_1234578(c_source()))  == 8> t6;\n+    sa<sizeof(sink_7_1234578(v_source()))  == 7> t7;\n+    sa<sizeof(sink_7_1234578(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_7_1234678(               A&);\n+two   sink_7_1234678(const          A&);\n+three sink_7_1234678(volatile       A&);\n+four  sink_7_1234678(const volatile A&);\n+six   sink_7_1234678(const          A&&);\n+seven sink_7_1234678(volatile       A&&);\n+eight sink_7_1234678(const volatile A&&);\n+\n+int test7_1234678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_7_1234678(a))           == 1> t1;\n+    sa<sizeof(sink_7_1234678(ca))          == 2> t2;\n+    sa<sizeof(sink_7_1234678(va))          == 3> t3;\n+    sa<sizeof(sink_7_1234678(cva))         == 4> t4;\n+    sa<sizeof(sink_7_1234678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_7_1234678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_7_1234678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_7_1235678(               A&);\n+two   sink_7_1235678(const          A&);\n+three sink_7_1235678(volatile       A&);\n+five  sink_7_1235678(               A&&);\n+six   sink_7_1235678(const          A&&);\n+seven sink_7_1235678(volatile       A&&);\n+eight sink_7_1235678(const volatile A&&);\n+\n+int test7_1235678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_7_1235678(a))           == 1> t1;\n+    sa<sizeof(sink_7_1235678(ca))          == 2> t2;\n+    sa<sizeof(sink_7_1235678(va))          == 3> t3;\n+    sa<sizeof(sink_7_1235678(cva))         == 8> t4;\n+    sa<sizeof(sink_7_1235678(source()))    == 5> t5;\n+    sa<sizeof(sink_7_1235678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_7_1235678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_7_1235678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_7_1245678(               A&);\n+two   sink_7_1245678(const          A&);\n+four  sink_7_1245678(const volatile A&);\n+five  sink_7_1245678(               A&&);\n+six   sink_7_1245678(const          A&&);\n+seven sink_7_1245678(volatile       A&&);\n+eight sink_7_1245678(const volatile A&&);\n+\n+int test7_1245678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_7_1245678(a))           == 1> t1;\n+    sa<sizeof(sink_7_1245678(ca))          == 2> t2;\n+    sa<sizeof(sink_7_1245678(va))          == 4> t3;\n+    sa<sizeof(sink_7_1245678(cva))         == 4> t4;\n+    sa<sizeof(sink_7_1245678(source()))    == 5> t5;\n+    sa<sizeof(sink_7_1245678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_7_1245678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_7_1245678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+one   sink_7_1345678(               A&);\n+three sink_7_1345678(volatile       A&);\n+four  sink_7_1345678(const volatile A&);\n+five  sink_7_1345678(               A&&);\n+six   sink_7_1345678(const          A&&);\n+seven sink_7_1345678(volatile       A&&);\n+eight sink_7_1345678(const volatile A&&);\n+\n+int test7_1345678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_7_1345678(a))           == 1> t1;\n+    sa<sizeof(sink_7_1345678(ca))          == 4> t2;\n+    sa<sizeof(sink_7_1345678(va))          == 3> t3;\n+    sa<sizeof(sink_7_1345678(cva))         == 4> t4;\n+    sa<sizeof(sink_7_1345678(source()))    == 5> t5;\n+    sa<sizeof(sink_7_1345678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_7_1345678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_7_1345678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+two   sink_7_2345678(const          A&);\n+three sink_7_2345678(volatile       A&);\n+four  sink_7_2345678(const volatile A&);\n+five  sink_7_2345678(               A&&);\n+six   sink_7_2345678(const          A&&);\n+seven sink_7_2345678(volatile       A&&);\n+eight sink_7_2345678(const volatile A&&);\n+\n+int test7_2345678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_7_2345678(ca))          == 2> t2;\n+    sa<sizeof(sink_7_2345678(va))          == 3> t3;\n+    sa<sizeof(sink_7_2345678(cva))         == 4> t4;\n+    sa<sizeof(sink_7_2345678(source()))    == 5> t5;\n+    sa<sizeof(sink_7_2345678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_7_2345678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_7_2345678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test7_1234567() + test7_1234568() + test7_1234578() + test7_1234678() +\n+           test7_1235678() + test7_1245678() + test7_1345678() + test7_2345678();\n+}"}, {"sha": "95a72d5105b7c1c03789fcad40fe4ad24a5a5982", "filename": "gcc/testsuite/g++.dg/cpp0x/rv8p.C", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv8p.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv8p.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frv8p.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,62 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test overlaod resolution among referece types\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+struct three {char x[3];};\n+struct four  {char x[4];};\n+struct five  {char x[5];};\n+struct six   {char x[6];};\n+struct seven {char x[7];};\n+struct eight {char x[8];};\n+\n+struct A\n+{\n+    A();\n+    A(const volatile A&&);\n+};\n+\n+               A    source();\n+const          A  c_source();\n+      volatile A  v_source();\n+const volatile A cv_source();\n+\n+// 8 at a time\n+\n+one   sink_8_12345678(               A&);\n+two   sink_8_12345678(const          A&);\n+three sink_8_12345678(volatile       A&);\n+four  sink_8_12345678(const volatile A&);\n+five  sink_8_12345678(               A&&);\n+six   sink_8_12345678(const          A&&);\n+seven sink_8_12345678(volatile       A&&);\n+eight sink_8_12345678(const volatile A&&);\n+\n+int test8_12345678()\n+{\n+                   A a;\n+    const          A ca = a;\n+          volatile A va;\n+    const volatile A cva = a;\n+    sa<sizeof(sink_8_12345678(a))           == 1> t1;\n+    sa<sizeof(sink_8_12345678(ca))          == 2> t2;\n+    sa<sizeof(sink_8_12345678(va))          == 3> t3;\n+    sa<sizeof(sink_8_12345678(cva))         == 4> t4;\n+    sa<sizeof(sink_8_12345678(source()))    == 5> t5;\n+    sa<sizeof(sink_8_12345678(c_source()))  == 6> t6;\n+    sa<sizeof(sink_8_12345678(v_source()))  == 7> t7;\n+    sa<sizeof(sink_8_12345678(cv_source())) == 8> t8;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test8_12345678();\n+}"}, {"sha": "b52ce7495db3980c5cc5566cdff01a393b879e1d", "filename": "gcc/testsuite/g++.dg/cpp0x/rvo.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frvo.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frvo.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frvo.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do \"run\" }\n+// { dg-options \"-std=c++0x\" }\n+// Contributed by Sylvain Pion\n+static int rvalue_constructions = 0;\n+\n+struct A {\n+  A ()         { }\n+  A (const A&) { }\n+  A (A&&)      { ++rvalue_constructions; }\n+  ~A ()        { }\n+};\n+\n+A f() {  return A(); }\n+\n+extern \"C\" {\n+  void abort(void);\n+}\n+\n+int main()\n+{\n+  A c = f();\n+\n+  if (rvalue_constructions != 0)\n+    abort();\n+}"}, {"sha": "a06720702050790ffb4af3ac0f15e28b166a0d95", "filename": "gcc/testsuite/g++.dg/cpp0x/temp-constructor-bug.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp-constructor-bug.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp-constructor-bug.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp-constructor-bug.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"--std=c++0x\" }\n+\n+struct S { };\n+\n+struct T\n+{\n+  S s;\n+};\n+\n+void f(T const &);\n+\n+void g()\n+{\n+  f((T){S()});\n+}"}, {"sha": "5314b24d1e00a0d1d79dc87b4eb218d816834894", "filename": "gcc/testsuite/g++.dg/cpp0x/temp-va-arg-bug.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp-va-arg-bug.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp-va-arg-bug.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemp-va-arg-bug.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,10 @@\n+// { dg-options \"--std=c++0x\" }\n+#include <stdarg.h>\n+\n+struct S { };\n+void f(S const &);\n+\n+void g(va_list args)\n+{\n+  f(va_arg(args, S));\n+}"}, {"sha": "ee48fb305d03ad836939408c86dc08e792fffffa", "filename": "gcc/testsuite/g++.dg/cpp0x/template_deduction.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemplate_deduction.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemplate_deduction.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ftemplate_deduction.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,68 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test the \"Augmented\" template argument deduction when binding an lvalue to an rvalue reference.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+template <class T, T v>\n+struct integral_constant\n+{\n+\tstatic const T                  value = v;\n+\ttypedef T                       value_type;\n+\ttypedef integral_constant<T, v> type;\n+};\n+\n+typedef integral_constant<bool, true>  true_type;\n+typedef integral_constant<bool, false> false_type;\n+\n+template <class T> struct is_lvalue_reference     : public integral_constant<bool, false> {};\n+template <class T> struct is_lvalue_reference<T&> : public integral_constant<bool, true> {};\n+\n+template <class T> struct is_rvalue_reference      : public integral_constant<bool, false> {};\n+template <class T> struct is_rvalue_reference<T&&> : public integral_constant<bool, true> {};\n+\n+template <bool is_lvalue_ref, bool is_rvalue_ref, class T>\n+void\n+test1(T&&)\n+{\n+    sa<is_lvalue_reference<T&&>::value == is_lvalue_ref> t1;\n+    sa<is_rvalue_reference<T&&>::value == is_rvalue_ref> t2;\n+}\n+\n+template <bool is_lvalue_ref, bool is_rvalue_ref, class T>\n+void\n+test2(const T&&)\n+{\n+    sa<is_lvalue_reference<const T&&>::value == is_lvalue_ref> t1;\n+    sa<is_rvalue_reference<const T&&>::value == is_rvalue_ref> t2;\n+}\n+\n+template <bool is_lvalue_ref, bool is_rvalue_ref, class T>\n+void\n+test3(T*&&)\n+{\n+    sa<is_lvalue_reference<T*&&>::value == is_lvalue_ref> t1;\n+    sa<is_rvalue_reference<T*&&>::value == is_rvalue_ref> t2;\n+}\n+\n+struct A {};\n+\n+A a;\n+\n+A source() {return A();}\n+A* sourcep() {return 0;}\n+\n+int main()\n+{\n+    test1<true, false>(a);\n+    test1<false, true>(source());\n+    test2<false, true>(a);\n+    test2<false, true>(source());\n+    test3<false, true>(&a);\n+    test3<false, true>(sourcep());\n+    return 0;\n+}"}, {"sha": "06311856d69b27383b2d60f7d9e7941559b9d588", "filename": "gcc/testsuite/g++.dg/cpp0x/unnamed_refs.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funnamed_refs.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funnamed_refs.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Funnamed_refs.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -0,0 +1,30 @@\n+// I, Howard Hinnant, hereby place this code in the public domain.\n+\n+// Test: Unamed rvalue references are treated as lvalues.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+template <bool> struct sa;\n+template <> struct sa<true> {};\n+\n+struct one   {char x[1];};\n+struct two   {char x[2];};\n+\n+struct A {};\n+\n+one foo(const A&) {return one();}\n+two foo(A&&)      {return two();}\n+\n+A&& source() {static A a; return a;}\n+\n+int test1()\n+{\n+    sa<sizeof(foo(source())) == 2> t1;\n+    return 0;\n+}\n+\n+int main()\n+{\n+    return test1();\n+}"}, {"sha": "8c23c546d5d6088057354034daf4ff15a973bdcb", "filename": "gcc/testsuite/g++.dg/init/copy7.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy7.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -1,3 +1,4 @@\n+// { dg-options \"-std=c++98\" }\n // PR c++/12226\n \n class foo {"}, {"sha": "ba0f6f0781e64a2225fa85bd541e7ad47d8a235a", "filename": "gcc/testsuite/g++.dg/overload/arg1.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Farg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Farg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Farg1.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -1,3 +1,4 @@\n+// { dg-options \"-std=c++98\" }\n // { dg-do compile }\n \n // Copyright (C) 2004 Free Software Foundation, Inc."}, {"sha": "1461928958f22a982cb7f8e2d5324e48c35dbb10", "filename": "gcc/testsuite/g++.dg/overload/arg4.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Farg4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8af2fec40bfd6889ab47b47d0a9cfaa5102c2507/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Farg4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Farg4.C?ref=8af2fec40bfd6889ab47b47d0a9cfaa5102c2507", "patch": "@@ -1,3 +1,4 @@\n+// { dg-options \"-std=c++98\" }\n // { dg-do compile }\n \n // Copyright (C) 2004 Free Software Foundation, Inc."}]}