{"sha": "8b3057b30d78d0e30ec9f0db8806229bd8f28dfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIzMDU3YjMwZDc4ZDBlMzBlYzlmMGRiODgwNjIyOWJkOGYyOGRmYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-26T14:45:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-26T14:45:40Z"}, "message": "ipa-split-2.c: New testcase.\n\n\n\t* gcc.dg/tree-ssa/ipa-split-2.c: New testcase.\n\t* ipa-split.c (consider_split): PHI in entry block is OK as long as all\n\tedges comming from header are equivalent.\n\t(visit_bb): Handle PHIs correctly.\n\t* tree-inline.c (copy_phis_for_bb): Be able to copy\n\tPHI from entry edge.\n\t(copy_cfg_body): Produce edge from entry BB before copying\n\tPHIs.\n\nFrom-SVN: r161433", "tree": {"sha": "48fb4136d3d63a84f88676d81afbfd202920e87e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48fb4136d3d63a84f88676d81afbfd202920e87e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/comments", "author": null, "committer": null, "parents": [{"sha": "6bfd4302547d10962648eb1dddd4020cf8017ada", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bfd4302547d10962648eb1dddd4020cf8017ada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bfd4302547d10962648eb1dddd4020cf8017ada"}], "stats": {"total": 147, "additions": 120, "deletions": 27}, "files": [{"sha": "e0c312209cad2106a06565fd30f2029e13514647", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b3057b30d78d0e30ec9f0db8806229bd8f28dfc", "patch": "@@ -1,3 +1,13 @@\n+2010-06-26  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-split.c (consider_split): PHI in entry block is OK as long as all\n+\tedges comming from header are equivalent.\n+\t(visit_bb): Handle PHIs correctly.\n+\t* tree-inline.c (copy_phis_for_bb): Be able to copy\n+\tPHI from entry edge.\n+\t(copy_cfg_body): Produce edge from entry BB before copying\n+\tPHIs.\n+\n 2010-06-26  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/44674"}, {"sha": "1216b0f2c61e0199eb6019e4e4da6a5ddcd894f1", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=8b3057b30d78d0e30ec9f0db8806229bd8f28dfc", "patch": "@@ -171,17 +171,25 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n   unsigned int call_overhead;\n   edge e;\n   edge_iterator ei;\n+  gimple_stmt_iterator bsi;\n+  unsigned int i;\n+  int incomming_freq = 0;\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_split_point (dump_file, current);\n \n+  FOR_EACH_EDGE (e, ei, current->entry_bb->preds)\n+    if (!bitmap_bit_p (current->split_bbs, e->src->index))\n+      incomming_freq += EDGE_FREQUENCY (e);\n+\n   /* Do not split when we would end up calling function anyway.  */\n-  if (current->entry_bb->frequency\n+  if (incomming_freq\n       >= (ENTRY_BLOCK_PTR->frequency\n \t  * PARAM_VALUE (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY) / 100))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"  Refused: split BB frequency is too large.\\n\");\n+\t\t \"  Refused: incomming frequency is too large.\\n\");\n       return;\n     }\n \n@@ -193,14 +201,31 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n       return;\n     }\n \n-  /* FIXME: We can do better: if the split region start with a loop and there\n-     is only one entry point from outer wrold, we can update PHI.  */\n-  if (!gsi_end_p (gsi_start_phis (current->entry_bb)))\n+  /* Verify that PHI args on entry are either virutal or all their operands\n+     incomming from header are the same.  */\n+  for (bsi = gsi_start_phis (current->entry_bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"  Refused: entry BB has PHI\\n\");\n-      return;\n+      gimple stmt = gsi_stmt (bsi);\n+      tree val = NULL;\n+\n+      if (!is_gimple_reg (gimple_phi_result (stmt)))\n+\tcontinue;\n+      for (i = 0; i < gimple_phi_num_args (stmt); i++)\n+\t{\n+\t  edge e = gimple_phi_arg_edge (stmt, i);\n+\t  if (!bitmap_bit_p (current->split_bbs, e->src->index))\n+\t    {\n+\t      tree edge_val = gimple_phi_arg_def (stmt, i);\n+\t      if (val && edge_val != val)\n+\t        {\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"  Refused: entry BB has PHI with multiple variants\\n\");\n+\t\t  return;\n+\t        }\n+\t      val = edge_val;\n+\t    }\n+\t}\n     }\n \n \n@@ -256,6 +281,7 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n      we can pass more than that.  */\n   if (num_args != bitmap_count_bits (current->ssa_names_to_pass))\n     {\n+      \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"  Refused: need to pass non-param values\\n\");\n@@ -289,8 +315,6 @@ consider_split (struct split_point *current, bitmap non_ssa_vars,\n \t    }\n \t  for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n \t    {\n-\t      if (is_gimple_debug (gsi_stmt (bsi)))\n-\t\tcontinue;\n \t      if (walk_stmt_load_store_addr_ops\n \t\t  (gsi_stmt (bsi), non_ssa_vars, test_nonssa_use,\n \t\t   test_nonssa_use, test_nonssa_use))\n@@ -510,17 +534,20 @@ visit_bb (basic_block bb, basic_block return_bb,\n   for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n     {\n       gimple stmt = gsi_stmt (bsi);\n-      tree op;\n-      ssa_op_iter iter;\n+      unsigned int i;\n \n       if (is_gimple_debug (stmt))\n \tcontinue;\n       if (!is_gimple_reg (gimple_phi_result (stmt)))\n \tcontinue;\n-      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n-\tbitmap_set_bit (set_ssa_names, SSA_NAME_VERSION (op));\n-      FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n-\tbitmap_set_bit (used_ssa_names, SSA_NAME_VERSION (op));\n+      bitmap_set_bit (set_ssa_names,\n+\t\t      SSA_NAME_VERSION (gimple_phi_result (stmt)));\n+      for (i = 0; i < gimple_phi_num_args (stmt); i++)\n+\t{\n+\t  tree op = gimple_phi_arg_def (stmt, i);\n+\t  if (TREE_CODE (op) == SSA_NAME)\n+\t    bitmap_set_bit (used_ssa_names, SSA_NAME_VERSION (op));\n+\t}\n       can_split &= !walk_stmt_load_store_addr_ops (stmt, non_ssa_vars,\n \t\t\t\t\t\t   mark_nonssa_use,\n \t\t\t\t\t\t   mark_nonssa_use,"}, {"sha": "26d6cbc9a1cd87918fde5c48972b432c1a7e0134", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b3057b30d78d0e30ec9f0db8806229bd8f28dfc", "patch": "@@ -1,3 +1,7 @@\n+2010-06-26  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/ipa-split-2.c: New testcase.\n+\n 2010-06-26  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/44674"}, {"sha": "bbde73d6c7c378ea9326dddb03323f8719c3f494", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ipa-split-2.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fipa-split-2.c?ref=8b3057b30d78d0e30ec9f0db8806229bd8f28dfc", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-fnsplit\" } */\n+int b;\n+int c;\n+int d;\n+split_me(int a)\n+{\n+  int t = 0;\n+  if (d>4)\n+    return;\n+  do\n+   {\n+  long_function (t);\n+  long_function (t);\n+  long_function (t);\n+  long_function (t);\n+  long_function (t);\n+  long_function (t);\n+  make_me_irregular:\n+  long_function (t);\n+  long_function (t);\n+  long_function (t);\n+  long_function (t);\n+  long_function (t);\n+   t=b;\n+   }\n+  while (t);\n+  if (c)\n+    goto make_me_irregular;\n+}\n+\n+main()\n+{\n+  split_me (1);\n+  split_me (2);\n+  split_me (3);\n+  split_me (4);\n+  split_me (5);\n+}\n+/* { dg-final { scan-tree-dump-times \"Splitting function\" 1 \"fnsplit\"} } */\n+/* { dg-final { cleanup-tree-dump \"fnsplit\" } } */"}, {"sha": "a419c2612bfd1370e99531df6de25f48b92ddd25", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b3057b30d78d0e30ec9f0db8806229bd8f28dfc/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8b3057b30d78d0e30ec9f0db8806229bd8f28dfc", "patch": "@@ -1969,11 +1969,22 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n \t    = new_phi = create_phi_node (new_res, new_bb);\n \t  FOR_EACH_EDGE (new_edge, ei, new_bb->preds)\n \t    {\n-\t      edge const old_edge\n-\t\t= find_edge ((basic_block) new_edge->src->aux, bb);\n-\t      tree arg = PHI_ARG_DEF_FROM_EDGE (phi, old_edge);\n-\t      tree new_arg = arg;\n+\t      edge old_edge = find_edge ((basic_block) new_edge->src->aux, bb);\n+\t      tree arg;\n+\t      tree new_arg;\n \t      tree block = id->block;\n+\t      edge_iterator ei2;\n+\n+\t      /* When doing partial clonning, we allow PHIs on the entry block\n+\t\t as long as all the arguments are the same.  Find any input\n+\t\t edge to see argument to copy.  */\n+\t      if (!old_edge)\n+\t\tFOR_EACH_EDGE (old_edge, ei2, bb->preds)\n+\t\t  if (!old_edge->src->aux)\n+\t\t    break;\n+\n+\t      arg = PHI_ARG_DEF_FROM_EDGE (phi, old_edge);\n+\t      new_arg = arg;\n \t      id->block = NULL_TREE;\n \t      walk_tree (&new_arg, copy_tree_body_r, id, NULL);\n \t      id->block = block;\n@@ -2191,12 +2202,6 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n         || (bb->index > 0 && bitmap_bit_p (blocks_to_copy, bb->index)))\n       need_debug_cleanup |= copy_edges_for_bb (bb, count_scale, exit_block_map);\n \n-  if (gimple_in_ssa_p (cfun))\n-    FOR_ALL_BB_FN (bb, cfun_to_copy)\n-      if (!blocks_to_copy\n-\t  || (bb->index > 0 && bitmap_bit_p (blocks_to_copy, bb->index)))\n-\tcopy_phis_for_bb (bb, id);\n-\n   if (new_entry)\n     {\n       edge e;\n@@ -2205,6 +2210,12 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n       e->count = entry_block_map->count;\n     }\n \n+  if (gimple_in_ssa_p (cfun))\n+    FOR_ALL_BB_FN (bb, cfun_to_copy)\n+      if (!blocks_to_copy\n+\t  || (bb->index > 0 && bitmap_bit_p (blocks_to_copy, bb->index)))\n+\tcopy_phis_for_bb (bb, id);\n+\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n     if (bb->aux)\n       {"}]}