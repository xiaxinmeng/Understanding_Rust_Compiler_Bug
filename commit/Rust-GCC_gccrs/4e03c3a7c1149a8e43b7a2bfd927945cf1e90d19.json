{"sha": "4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGUwM2MzYTdjMTE0OWE4ZTQzYjdhMmJmZDkyNzk0NWNmMWU5MGQxOQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2019-11-14T03:49:43Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2019-11-14T03:49:43Z"}, "message": "Support C2x [[]] attributes for C.\n\nThis patch adds support for the C2x [[]] attribute syntax to the C\nfront end.  Support is only added for C at this point, not for\nObjective-C; I intend to add the unbounded lookahead required to\nsupport it for Objective-C in a followup patch, but maybe not in\ndevelopment stage 1.\n\nThe syntax is supported in all relevant places where the standard says\nit is supported, but support is not added for the individual\nattributes specified in C2x (all of which are optional to support).  I\nexpect to add support for some of them in followup patches; all except\nnodiscard can be mapped directly to the semantics of an existing GNU\nattribute (subject to extra checks for invalid usages such as the same\nattribute being used more than once inside a single [[]]), and the\nfallthrough attribute already works after this patch because of\nexisting special-case code handling it (but without some of the checks\nfor invalid usage being present).\n\nNote that the four functions c_token_starts_declspecs,\nc_token_starts_declaration, c_parser_next_token_starts_declspecs and\nc_parser_next_tokens_start_declaration do *not* accept \"[[\".  This is\nanalogous with the handling of __extension__: both cases have the\nproperty that they can start either a declaration or some other\nstatements and so need an unbounded number of tokens to be parsed in\nthe caller before it can find out what kind of syntactic construct\nfollows.  Note also that, while I updated all places calling those\nfunctions for standard C syntax to handle attributes if applicable, I\ndid not do anything regarding calls to such functions for OpenMP or\nOpenACC constructs.  Thus, if there are such constructs using such\nfunctions where \"[[\" *should* be accepted as a possible start to a\ndeclaration, the code for parsing those constructs should be updated\naccordingly.\n\nAlthough all cases of the syntax are handled, and attributes applied\nto the constructs the standard says they should be (with less laxity\nthan there is for GNU attributes to allow an attribute applied to one\nconstruct to be moved automatically to another one), there is a major\nlimitation in the existing language-independent code in attribs.c\npreventing most cases of type attributes from working.  The following\ncode has been present with minor changes since the first support for\n[[]] attributes for C++ was added:\n\n      if (TYPE_P (*node)\n          && cxx11_attr_p\n          && !(flags & ATTR_FLAG_TYPE_IN_PLACE))\n        {\n          /* This is a c++11 attribute that appertains to a\n             type-specifier, outside of the definition of, a class\n             type.  Ignore it.  */\n          auto_diagnostic_group d;\n          if (warning (OPT_Wattributes, \"attribute ignored\"))\n            inform (input_location,\n                    \"an attribute that appertains to a type-specifier \"\n                    \"is ignored\");\n          continue;\n        }\n\nI see no justification for this in general for either C or C++ and so\npropose to remove or restrict it in a followup bug-fix patch.  Both C\nand C++ are clear about attributes in certain places (at the end of\ndeclaration specifiers, or after function or array declarators)\nappertaining to a specific type (and explicitly say, in the case of\nattributes at the end of declaration specifiers, that they only apply\nfor that particular use of that type, not for subsequent uses of the\nsame type without the attributes).  Thus it seems clear to me that,\nfor example,\n\nint [[gnu::mode(DI)]] x;\n\nought to be accepted as an analogue in [[]] syntax for\n\nint __attribute__((mode(DI))) x;\n\n(or strictly as an analogue for a version of that with extra\nparentheses to make the GNU attribute bind properly to the type rather\nthan being automatically moved from the declaration to the type).\nThere are certain cases where an attribute *does* only make sense for\nthe definition of a type (e.g. \"packed\" on structure types), but those\nshould already be handled in the individual attribute handlers (such\nas handle_packed_attribute, which already has code to deal with that\nissue).  So my inclination is that the above-quoted check in attribs.c\nshould simply be removed, but failing that it should be restricted to\nstructure and union types (and such a change would be a bug-fix).\nThat would then allow various cases of [[]] attributes on types to\nwork properly.\n\nBootstrapped with no regressions on x86_64-pc-linux-gnu.\n\ngcc/c:\n\t* c-tree.h (enum c_typespec_kind): Add ctsk_tagref_attrs and\n\tctsk_tagfirstref_attrs.\n\t(struct c_declspecs): Update description of attrs.  Add\n\tpostfix_attrs and non_std_attrs_seen_p.  Increase size of\n\ttypespec_kind bit-field.\n\t(c_warn_unused_attributes): New declaration.\n\t(parser_xref_tag): Update prototype.\n\t* c-decl.c (c_warn_unused_attributes): New function.\n\t(shadow_tag_warned): Handle ctsk_tagfirstref_attrs and\n\tctsk_tagref_attrs.  Handle attribute declarations.\n\t(check_compound_literal_type): Handle ctsk_tagfirstref_attrs.\n\t(grokdeclarator): Handle standard attributes.\n\t(parser_xref_tag): Add arguments have_std_attrs and attrs.  Apply\n\tattributes to incomplete type reference.\n\t(xref_tag): Update call to parser_xref_tag.\n\t(declspecs_add_addrspace, declspecs_add_type)\n\t(declspecs_add_scspec, declspecs_add_attrs): Set\n\tnon_std_attrs_seen_p.\n\t(finish_declspecs): Apply postfix standard attributes to type.\n\t* c-parser.c (c_token_starts_declspecs)\n\t(c_token_starts_declaration, c_parser_next_token_starts_declspecs)\n\t(c_parser_next_tokens_start_declaration): Update comments.\n\t(c_parser_consume_token, c_parser_consume_pragma): Handle moving\n\tparser->tokens[2] to parser->tokens[1].\n\t(c_parser_nth_token_starts_std_attributes)\n\t(c_parser_std_attribute_specifier_sequence): New functions.\n\t(c_parser_declaration_or_fndef): Add arguments have_attrs and\n\tattrs.  All callers changed.  Handle standard attributes.\n\t(c_parser_parms_declarator, c_parser_parms_list_declarator)\n\t(c_parser_parameter_declaration): Add argument have_gnu_attrs.\n\tAll callers changed.\n\t(c_parser_declspecs): Add arguments start_std_attr_ok and\n\tend_std_attr_ok.  All callers changed.  Handle standard\n\tattributes.\n\t(c_parser_enum_specifier, c_parser_struct_or_union_specifier)\n\t(c_parser_direct_declarator, c_parser_direct_declarator_inner)\n\t(c_parser_compound_statement_nostart, c_parser_all_labels)\n\t(c_parser_label, c_parser_statement, c_parser_for_statement):\n\tHandle standard attributes.\n\t* c-parser.h (c_parser_declspecs): Update prototype.\n\t* gimple-parser.c (c_parser_gimple_declaration): Update call to\n\tc_parser_declspecs.\n\ngcc/testsuite:\n\t* gcc.dg/c2x-attr-fallthrough-1.c, gcc.dg/c2x-attr-syntax-1.c,\n\tgcc.dg/c2x-attr-syntax-2.c, gcc.dg/c2x-attr-syntax-3.c,\n\tgcc.dg/gnu2x-attr-syntax-1.c, gcc.dg/gnu2x-attr-syntax-2.c,\n\tgcc.dg/gnu2x-attrs-1.c: New tests.\n\nFrom-SVN: r278194", "tree": {"sha": "52ad5537d545cae2bfef8c73f76fee3ba758da47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52ad5537d545cae2bfef8c73f76fee3ba758da47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb270950acbae6f70e3487a6e63a26c1294656b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb270950acbae6f70e3487a6e63a26c1294656b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb270950acbae6f70e3487a6e63a26c1294656b3"}], "stats": {"total": 915, "additions": 792, "deletions": 123}, "files": [{"sha": "228ebd8b17e2ba0e5f7cd63067a4cda6a0c68ee9", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -1,3 +1,48 @@\n+2019-11-14  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-tree.h (enum c_typespec_kind): Add ctsk_tagref_attrs and\n+\tctsk_tagfirstref_attrs.\n+\t(struct c_declspecs): Update description of attrs.  Add\n+\tpostfix_attrs and non_std_attrs_seen_p.  Increase size of\n+\ttypespec_kind bit-field.\n+\t(c_warn_unused_attributes): New declaration.\n+\t(parser_xref_tag): Update prototype.\n+\t* c-decl.c (c_warn_unused_attributes): New function.\n+\t(shadow_tag_warned): Handle ctsk_tagfirstref_attrs and\n+\tctsk_tagref_attrs.  Handle attribute declarations.\n+\t(check_compound_literal_type): Handle ctsk_tagfirstref_attrs.\n+\t(grokdeclarator): Handle standard attributes.\n+\t(parser_xref_tag): Add arguments have_std_attrs and attrs.  Apply\n+\tattributes to incomplete type reference.\n+\t(xref_tag): Update call to parser_xref_tag.\n+\t(declspecs_add_addrspace, declspecs_add_type)\n+\t(declspecs_add_scspec, declspecs_add_attrs): Set\n+\tnon_std_attrs_seen_p.\n+\t(finish_declspecs): Apply postfix standard attributes to type.\n+\t* c-parser.c (c_token_starts_declspecs)\n+\t(c_token_starts_declaration, c_parser_next_token_starts_declspecs)\n+\t(c_parser_next_tokens_start_declaration): Update comments.\n+\t(c_parser_consume_token, c_parser_consume_pragma): Handle moving\n+\tparser->tokens[2] to parser->tokens[1].\n+\t(c_parser_nth_token_starts_std_attributes)\n+\t(c_parser_std_attribute_specifier_sequence): New functions.\n+\t(c_parser_declaration_or_fndef): Add arguments have_attrs and\n+\tattrs.  All callers changed.  Handle standard attributes.\n+\t(c_parser_parms_declarator, c_parser_parms_list_declarator)\n+\t(c_parser_parameter_declaration): Add argument have_gnu_attrs.\n+\tAll callers changed.\n+\t(c_parser_declspecs): Add arguments start_std_attr_ok and\n+\tend_std_attr_ok.  All callers changed.  Handle standard\n+\tattributes.\n+\t(c_parser_enum_specifier, c_parser_struct_or_union_specifier)\n+\t(c_parser_direct_declarator, c_parser_direct_declarator_inner)\n+\t(c_parser_compound_statement_nostart, c_parser_all_labels)\n+\t(c_parser_label, c_parser_statement, c_parser_for_statement):\n+\tHandle standard attributes.\n+\t* c-parser.h (c_parser_declspecs): Update prototype.\n+\t* gimple-parser.c (c_parser_gimple_declaration): Update call to\n+\tc_parser_declspecs.\n+\n 2019-11-12  Martin Liska  <mliska@suse.cz>\n \n \t* gimple-parser.c: Do not include params.h."}, {"sha": "f8090597cdfd5ebf3e414000381bee1b5a0bc0af", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 93, "deletions": 17, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -4491,6 +4491,18 @@ c_simulate_builtin_function_decl (tree decl)\n   C_DECL_BUILTIN_PROTOTYPE (decl) = prototype_p (type);\n   return pushdecl (decl);\n }\n+\n+/* Warn about attributes in a context where they are unused\n+   (attribute-declarations, except for the \"fallthrough\" case, and\n+   attributes on statements).  */\n+\n+void\n+c_warn_unused_attributes (tree attrs)\n+{\n+  for (tree t = attrs; t != NULL_TREE; t = TREE_CHAIN (t))\n+    warning (OPT_Wattributes, \"%qE attribute ignored\",\n+\t     get_attribute_name (t));\n+}\n \f\n /* Called when a declaration is seen that contains no names to declare.\n    If its type is a reference to a structure, union or enum inherited\n@@ -4545,6 +4557,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t    }\n \t  else if (declspecs->typespec_kind != ctsk_tagdef\n                    && declspecs->typespec_kind != ctsk_tagfirstref\n+\t\t   && declspecs->typespec_kind != ctsk_tagfirstref_attrs\n \t\t   && declspecs->storage_class != csc_none)\n \t    {\n \t      if (warned != 1)\n@@ -4556,6 +4569,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t    }\n \t  else if (declspecs->typespec_kind != ctsk_tagdef\n                    && declspecs->typespec_kind != ctsk_tagfirstref\n+                   && declspecs->typespec_kind != ctsk_tagfirstref_attrs\n \t\t   && (declspecs->const_p\n \t\t       || declspecs->volatile_p\n \t\t       || declspecs->atomic_p\n@@ -4571,6 +4585,7 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n \t    }\n \t  else if (declspecs->typespec_kind != ctsk_tagdef\n                    && declspecs->typespec_kind != ctsk_tagfirstref\n+                   && declspecs->typespec_kind != ctsk_tagfirstref_attrs\n \t\t   && declspecs->alignas_p)\n \t    {\n \t      if (warned != 1)\n@@ -4668,9 +4683,34 @@ shadow_tag_warned (const struct c_declspecs *declspecs, int warned)\n       warned = 2;\n     }\n \n+  if (found_tag\n+      && warned == 2\n+      && (declspecs->typespec_kind == ctsk_tagref_attrs\n+\t  || declspecs->typespec_kind == ctsk_tagfirstref_attrs))\n+    {\n+      /* Standard attributes after the \"struct\" or \"union\" keyword are\n+\t only permitted when the contents of the type are defined, or\n+\t in the form \"struct-or-union attribute-specifier-sequence\n+\t identifier;\".  If the ';' was not present, attributes were\n+\t diagnosed in the parser.  Here, ensure that any other useless\n+\t elements of the declaration result in a pedwarn, not just a\n+\t warning.  Forward declarations of enum types are not part of\n+\t standard C, but handle them the same.  */\n+      pedwarn (input_location, 0,\n+\t       \"invalid use of attributes in empty declaration\");\n+      warned = 1;\n+    }\n+\n   if (warned != 1)\n     {\n-      if (!found_tag)\n+      if (declspecs->declspecs_seen_p\n+\t  && !declspecs->non_std_attrs_seen_p)\n+\t/* An attribute declaration (but not a fallthrough attribute\n+\t   declaration, which was handled separately); warn if there\n+\t   are any attributes being ignored (but not if the attributes\n+\t   were empty).  */\n+\tc_warn_unused_attributes (declspecs->attrs);\n+      else if (!found_tag)\n \tpedwarn (input_location, 0, \"empty declaration\");\n     }\n }\n@@ -5605,7 +5645,8 @@ check_compound_literal_type (location_t loc, struct c_type_name *type_name)\n {\n   if (warn_cxx_compat\n       && (type_name->specs->typespec_kind == ctsk_tagdef\n-          || type_name->specs->typespec_kind == ctsk_tagfirstref))\n+          || type_name->specs->typespec_kind == ctsk_tagfirstref\n+\t  || type_name->specs->typespec_kind == ctsk_tagfirstref_attrs))\n     warning_at (loc, OPT_Wc___compat,\n \t\t\"defining a type in a compound literal is invalid in C++\");\n }\n@@ -6210,18 +6251,32 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    const struct c_declarator *inner_decl;\n \t    int attr_flags = 0;\n \t    declarator = declarator->declarator;\n+\t    /* Standard attribute syntax precisely defines what entity\n+\t       an attribute in each position appertains to, so only\n+\t       apply laxity about positioning to GNU attribute syntax.\n+\t       Standard attributes applied to a function or array\n+\t       declarator apply exactly to that type; standard\n+\t       attributes applied to the identifier apply to the\n+\t       declaration rather than to the type.  */\n \t    inner_decl = declarator;\n \t    while (inner_decl->kind == cdk_attrs)\n \t      inner_decl = inner_decl->declarator;\n-\t    if (inner_decl->kind == cdk_id)\n-\t      attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n-\t    else if (inner_decl->kind == cdk_function)\n-\t      attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;\n-\t    else if (inner_decl->kind == cdk_array)\n-\t      attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;\n-\t    returned_attrs = decl_attributes (&type,\n-\t\t\t\t\t      chainon (returned_attrs, attrs),\n-\t\t\t\t\t      attr_flags);\n+\t    if (!cxx11_attribute_p (attrs))\n+\t      {\n+\t\tif (inner_decl->kind == cdk_id)\n+\t\t  attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n+\t\telse if (inner_decl->kind == cdk_function)\n+\t\t  attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;\n+\t\telse if (inner_decl->kind == cdk_array)\n+\t\t  attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;\n+\t      }\n+\t    if (cxx11_attribute_p (attrs) && inner_decl->kind == cdk_id)\n+\t      returned_attrs = chainon (returned_attrs, attrs);\n+\t    else\n+\t      returned_attrs = decl_attributes (&type,\n+\t\t\t\t\t\tchainon (returned_attrs,\n+\t\t\t\t\t\t\t attrs),\n+\t\t\t\t\t\tattr_flags);\n \t    break;\n \t  }\n \tcase cdk_array:\n@@ -7686,11 +7741,14 @@ get_parm_info (bool ellipsis, tree expr)\n \f\n /* Get the struct, enum or union (CODE says which) with tag NAME.\n    Define the tag as a forward-reference with location LOC if it is\n-   not defined.  Return a c_typespec structure for the type\n-   specifier.  */\n+   not defined.  HAVE_STD_ATTRS says whether any standard attributes\n+   were present after the struct, union or enum keyword; ATTRS are the\n+   standard attributes present there.  Return a c_typespec structure\n+   for the type specifier.  */\n \n struct c_typespec\n-parser_xref_tag (location_t loc, enum tree_code code, tree name)\n+parser_xref_tag (location_t loc, enum tree_code code, tree name,\n+\t\t bool have_std_attrs, tree attrs)\n {\n   struct c_typespec ret;\n   tree ref;\n@@ -7714,9 +7772,12 @@ parser_xref_tag (location_t loc, enum tree_code code, tree name)\n      this would not work properly if we return the reference found.\n      (For example, with \"struct foo\" in an outer scope, \"union foo;\"\n      must shadow that tag with a new one of union type.)  */\n-  ret.kind = (ref ? ctsk_tagref : ctsk_tagfirstref);\n+  ret.kind = (ref\n+\t      ? (have_std_attrs ? ctsk_tagref_attrs : ctsk_tagref)\n+\t      : (have_std_attrs ? ctsk_tagfirstref_attrs : ctsk_tagfirstref));\n   if (ref && TREE_CODE (ref) == code)\n     {\n+      decl_attributes (&ref, attrs, (int) ATTR_FLAG_TYPE_IN_PLACE);\n       if (C_TYPE_DEFINED_IN_STRUCT (ref)\n \t  && loc != UNKNOWN_LOCATION\n \t  && warn_cxx_compat)\n@@ -7770,6 +7831,7 @@ parser_xref_tag (location_t loc, enum tree_code code, tree name)\n     }\n \n   pushtag (loc, name, ref);\n+  decl_attributes (&ref, attrs, (int) ATTR_FLAG_TYPE_IN_PLACE);\n \n   ret.spec = ref;\n   return ret;\n@@ -7782,7 +7844,7 @@ parser_xref_tag (location_t loc, enum tree_code code, tree name)\n tree\n xref_tag (enum tree_code code, tree name)\n {\n-  return parser_xref_tag (input_location, code, name).spec;\n+  return parser_xref_tag (input_location, code, name, false, NULL_TREE).spec;\n }\n \f\n /* Make sure that the tag NAME is defined *in the current scope*\n@@ -10214,6 +10276,7 @@ declspecs_add_addrspace (location_t location,\n {\n   specs->non_sc_seen_p = true;\n   specs->declspecs_seen_p = true;\n+  specs->non_std_attrs_seen_p = true;\n \n   if (!ADDR_SPACE_GENERIC_P (specs->address_space)\n       && specs->address_space != as)\n@@ -10239,6 +10302,7 @@ declspecs_add_qual (location_t loc,\n   bool dupe = false;\n   specs->non_sc_seen_p = true;\n   specs->declspecs_seen_p = true;\n+  specs->non_std_attrs_seen_p = true;\n   gcc_assert (TREE_CODE (qual) == IDENTIFIER_NODE\n \t      && C_IS_RESERVED_WORD (qual));\n   i = C_RID_CODE (qual);\n@@ -10297,6 +10361,7 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n   tree type = spec.spec;\n   specs->non_sc_seen_p = true;\n   specs->declspecs_seen_p = true;\n+  specs->non_std_attrs_seen_p = true;\n   specs->typespec_kind = spec.kind;\n   if (TREE_DEPRECATED (type))\n     specs->deprecated_p = true;\n@@ -11162,6 +11227,7 @@ declspecs_add_scspec (location_t loc,\n   enum c_storage_class n = csc_none;\n   bool dupe = false;\n   specs->declspecs_seen_p = true;\n+  specs->non_std_attrs_seen_p = true;\n   gcc_assert (TREE_CODE (scspec) == IDENTIFIER_NODE\n \t      && C_IS_RESERVED_WORD (scspec));\n   i = C_RID_CODE (scspec);\n@@ -11278,6 +11344,9 @@ declspecs_add_attrs (location_t loc, struct c_declspecs *specs, tree attrs)\n   specs->attrs = chainon (attrs, specs->attrs);\n   specs->locations[cdw_attributes] = loc;\n   specs->declspecs_seen_p = true;\n+  /* In the case of standard attributes at the start of the\n+     declaration, the caller will reset this.  */\n+  specs->non_std_attrs_seen_p = true;\n   return specs;\n }\n \n@@ -11306,7 +11375,7 @@ declspecs_add_alignas (location_t loc,\n    specifiers with any other type specifier to determine the resulting\n    type.  This is where ISO C checks on complex types are made, since\n    \"_Complex long\" is a prefix of the valid ISO C type \"_Complex long\n-   double\".  */\n+   double\".  Also apply postfix standard attributes to modify the type.  */\n \n struct c_declspecs *\n finish_declspecs (struct c_declspecs *specs)\n@@ -11376,6 +11445,8 @@ finish_declspecs (struct c_declspecs *specs)\n \t\t  && !specs->signed_p && !specs->unsigned_p\n \t\t  && !specs->complex_p);\n       /* Type to be filled in later.  */\n+      if (specs->postfix_attrs)\n+\terror (\"%<__auto_type%> followed by %<[[]]%> attributes\");\n       break;\n     case cts_void:\n       gcc_assert (!specs->long_p && !specs->short_p\n@@ -11581,6 +11652,11 @@ finish_declspecs (struct c_declspecs *specs)\n     default:\n       gcc_unreachable ();\n     }\n+  if (specs->type != NULL)\n+    {\n+      decl_attributes (&specs->type, specs->postfix_attrs, 0);\n+      specs->postfix_attrs = NULL_TREE;\n+    }\n \n   return specs;\n }"}, {"sha": "5f8695c9d4360cb1b9e6b2ed196dd0d1a5dfc683", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 328, "deletions": 99, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -633,8 +633,8 @@ c_parser_next_token_is_qualifier (c_parser *parser)\n   return c_token_is_qualifier (token);\n }\n \n-/* Return true if TOKEN can start declaration specifiers, false\n-   otherwise.  */\n+/* Return true if TOKEN can start declaration specifiers (not\n+   including standard attributes), false otherwise.  */\n static bool\n c_token_starts_declspecs (c_token *token)\n {\n@@ -713,8 +713,9 @@ c_token_starts_declspecs (c_token *token)\n }\n \n \n-/* Return true if TOKEN can start declaration specifiers or a static\n-   assertion, false otherwise.  */\n+/* Return true if TOKEN can start declaration specifiers (not\n+   including standard attributes) or a static assertion, false\n+   otherwise.  */\n static bool\n c_token_starts_declaration (c_token *token)\n {\n@@ -726,7 +727,8 @@ c_token_starts_declaration (c_token *token)\n }\n \n /* Return true if the next token from PARSER can start declaration\n-   specifiers, false otherwise.  */\n+   specifiers (not including standard attributes), false\n+   otherwise.  */\n bool\n c_parser_next_token_starts_declspecs (c_parser *parser)\n {\n@@ -748,7 +750,8 @@ c_parser_next_token_starts_declspecs (c_parser *parser)\n }\n \n /* Return true if the next tokens from PARSER can start declaration\n-   specifiers or a static assertion, false otherwise.  */\n+   specifiers (not including standard attributes) or a static\n+   assertion, false otherwise.  */\n bool\n c_parser_next_tokens_start_declaration (c_parser *parser)\n {\n@@ -787,8 +790,12 @@ c_parser_consume_token (c_parser *parser)\n   parser->last_token_location = parser->tokens[0].location;\n   if (parser->tokens != &parser->tokens_buf[0])\n     parser->tokens++;\n-  else if (parser->tokens_avail == 2)\n-    parser->tokens[0] = parser->tokens[1];\n+  else if (parser->tokens_avail >= 2)\n+    {\n+      parser->tokens[0] = parser->tokens[1];\n+      if (parser->tokens_avail >= 3)\n+\tparser->tokens[1] = parser->tokens[2];\n+    }\n   parser->tokens_avail--;\n }\n \n@@ -803,8 +810,12 @@ c_parser_consume_pragma (c_parser *parser)\n   gcc_assert (parser->tokens[0].type == CPP_PRAGMA);\n   if (parser->tokens != &parser->tokens_buf[0])\n     parser->tokens++;\n-  else if (parser->tokens_avail == 2)\n-    parser->tokens[0] = parser->tokens[1];\n+  else if (parser->tokens_avail >= 2)\n+    {\n+      parser->tokens[0] = parser->tokens[1];\n+      if (parser->tokens_avail >= 3)\n+\tparser->tokens[1] = parser->tokens[2];\n+    }\n   parser->tokens_avail--;\n   parser->in_pragma = true;\n }\n@@ -1384,10 +1395,15 @@ struct oacc_routine_data {\n   location_t loc;\n };\n \n+static bool c_parser_nth_token_starts_std_attributes (c_parser *,\n+\t\t\t\t\t\t      unsigned int);\n+static tree c_parser_std_attribute_specifier_sequence (c_parser *);\n static void c_parser_external_declaration (c_parser *);\n static void c_parser_asm_definition (c_parser *);\n static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n \t\t\t\t\t   bool, bool, tree *, vec<c_token>,\n+\t\t\t\t\t   bool have_attrs = false,\n+\t\t\t\t\t   tree attrs = NULL,\n \t\t\t\t\t   struct oacc_routine_data * = NULL,\n \t\t\t\t\t   bool * = NULL);\n static void c_parser_static_assert_declaration_no_semi (c_parser *);\n@@ -1402,10 +1418,11 @@ static struct c_declarator *c_parser_direct_declarator (c_parser *, bool,\n static struct c_declarator *c_parser_direct_declarator_inner (c_parser *,\n \t\t\t\t\t\t\t      bool,\n \t\t\t\t\t\t\t      struct c_declarator *);\n-static struct c_arg_info *c_parser_parms_declarator (c_parser *, bool, tree);\n+static struct c_arg_info *c_parser_parms_declarator (c_parser *, bool, tree,\n+\t\t\t\t\t\t     bool);\n static struct c_arg_info *c_parser_parms_list_declarator (c_parser *, tree,\n-\t\t\t\t\t\t\t  tree);\n-static struct c_parm *c_parser_parameter_declaration (c_parser *, tree);\n+\t\t\t\t\t\t\t  tree, bool);\n+static struct c_parm *c_parser_parameter_declaration (c_parser *, tree, bool);\n static tree c_parser_simple_asm_expr (c_parser *);\n static tree c_parser_gnu_attributes (c_parser *);\n static struct c_expr c_parser_initializer (c_parser *);\n@@ -1706,11 +1723,15 @@ add_debug_begin_stmt (location_t loc)\n    declarations are OK (subject to all other constraints); otherwise\n    (old-style parameter declarations) they are diagnosed.  If\n    START_ATTR_OK is true, the declaration specifiers may start with\n-   attributes; otherwise they may not.\n+   attributes (GNU or standard); otherwise they may not.\n    OBJC_FOREACH_OBJECT_DECLARATION can be used to get back the parsed\n    declaration when parsing an Objective-C foreach statement.\n    FALLTHRU_ATTR_P is used to signal whether this function parsed\n-   \"__attribute__((fallthrough));\".\n+   \"__attribute__((fallthrough));\".  ATTRS are any standard attributes\n+   parsed in the caller (in contexts where such attributes had to be\n+   parsed to determine whether what follows is a declaration or a\n+   statement); HAVE_ATTRS says whether there were any such attributes\n+   (even empty).\n \n    declaration:\n      declaration-specifiers init-declarator-list[opt] ;\n@@ -1784,6 +1805,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t       bool nested, bool start_attr_ok,\n \t\t\t       tree *objc_foreach_object_declaration,\n \t\t\t       vec<c_token> omp_declare_simd_clauses,\n+\t\t\t       bool have_attrs, tree attrs,\n \t\t\t       struct oacc_routine_data *oacc_routine_data,\n \t\t\t       bool *fallthru_attr_p)\n {\n@@ -1803,6 +1825,13 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n     }\n   specs = build_null_declspecs ();\n \n+  /* Handle any standard attributes parsed in the caller.  */\n+  if (have_attrs)\n+    {\n+      declspecs_add_attrs (here, specs, attrs);\n+      specs->non_std_attrs_seen_p = false;\n+    }\n+\n   /* Try to detect an unknown type name when we have \"A B\" or \"A *B\".  */\n   if (c_parser_peek_token (parser)->type == CPP_NAME\n       && c_parser_peek_token (parser)->id_kind == C_ID_ID\n@@ -1867,8 +1896,14 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       fndef_ok = !nested;\n     }\n \n+  /* When there are standard attributes at the start of the\n+     declaration (to apply to the entity being declared), an\n+     init-declarator-list or function definition must be present.  */\n+  if (c_parser_nth_token_starts_std_attributes (parser, 1))\n+    have_attrs = true;\n+\n   c_parser_declspecs (parser, specs, true, true, start_attr_ok,\n-\t\t      true, true, cla_nonabstract_decl);\n+\t\t      true, true, start_attr_ok, true, cla_nonabstract_decl);\n   if (parser->error)\n     {\n       c_parser_skip_to_end_of_block_or_statement (parser);\n@@ -1896,7 +1931,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t\t\t\t  void_type_node, 0);\n \t  add_stmt (fn);\n \t}\n-      else if (empty_ok)\n+      else if (empty_ok && !(have_attrs\n+\t\t\t     && specs->non_std_attrs_seen_p))\n \tshadow_tag (specs);\n       else\n \t{\n@@ -2556,7 +2592,14 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n    Storage class specifiers are accepted iff SCSPEC_OK; type\n    specifiers are accepted iff TYPESPEC_OK; alignment specifiers are\n    accepted iff ALIGNSPEC_OK; gnu-attributes are accepted at the start\n-   iff START_ATTR_OK; __auto_type is accepted iff AUTO_TYPE_OK.\n+   iff START_ATTR_OK; __auto_type is accepted iff AUTO_TYPE_OK.  In\n+   addition to the syntax shown, standard attributes are accepted at\n+   the start iff START_STD_ATTR_OK and at the end iff END_STD_ATTR_OK;\n+   unlike gnu-attributes, they are not accepted in the middle of the\n+   list.  (This combines various different syntax productions in the C\n+   standard, and in some cases gnu-attributes and standard attributes\n+   at the start may already have been parsed before this function is\n+   called.)\n \n    declaration-specifiers:\n      storage-class-specifier declaration-specifiers[opt]\n@@ -2664,6 +2707,7 @@ void\n c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t\t    bool scspec_ok, bool typespec_ok, bool start_attr_ok,\n \t\t    bool alignspec_ok, bool auto_type_ok,\n+\t\t    bool start_std_attr_ok, bool end_std_attr_ok,\n \t\t    enum c_lookahead_kind la)\n {\n   bool attrs_ok = start_attr_ok;\n@@ -2672,6 +2716,16 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n   if (!typespec_ok)\n     gcc_assert (la == cla_prefer_id);\n \n+  if (start_std_attr_ok\n+      && c_parser_nth_token_starts_std_attributes (parser, 1))\n+    {\n+      gcc_assert (!specs->non_std_attrs_seen_p);\n+      location_t loc = c_parser_peek_token (parser)->location;\n+      tree attrs = c_parser_std_attribute_specifier_sequence (parser);\n+      declspecs_add_attrs (loc, specs, attrs);\n+      specs->non_std_attrs_seen_p = false;\n+    }\n+\n   while (c_parser_next_token_is (parser, CPP_NAME)\n \t || c_parser_next_token_is (parser, CPP_KEYWORD)\n \t || (c_dialect_objc () && c_parser_next_token_is (parser, CPP_LESS)))\n@@ -2944,7 +2998,10 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t  goto out;\n \t}\n     }\n- out: ;\n+ out:\n+  if (end_std_attr_ok\n+      && c_parser_nth_token_starts_std_attributes (parser, 1))\n+    specs->postfix_attrs = c_parser_std_attribute_specifier_sequence (parser);\n }\n \n /* Parse an enum specifier (C90 6.5.2.2, C99 6.7.2.2, C11 6.7.2.2).\n@@ -2967,27 +3024,34 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n      enumerator-list , enumerator\n \n    enumerator:\n-     enumeration-constant\n-     enumeration-constant = constant-expression\n+     enumeration-constant attribute-specifier-sequence[opt]\n+     enumeration-constant attribute-specifier-sequence[opt]\n+       = constant-expression\n \n    GNU Extensions:\n \n    enumerator:\n-     enumeration-constant gnu-attributes[opt]\n-     enumeration-constant gnu-attributes[opt] = constant-expression\n+     enumeration-constant attribute-specifier-sequence[opt] gnu-attributes[opt]\n+     enumeration-constant attribute-specifier-sequence[opt] gnu-attributes[opt]\n+       = constant-expression\n \n */\n \n static struct c_typespec\n c_parser_enum_specifier (c_parser *parser)\n {\n   struct c_typespec ret;\n+  bool have_std_attrs;\n+  tree std_attrs = NULL_TREE;\n   tree attrs;\n   tree ident = NULL_TREE;\n   location_t enum_loc;\n   location_t ident_loc = UNKNOWN_LOCATION;  /* Quiet warning.  */\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ENUM));\n   c_parser_consume_token (parser);\n+  have_std_attrs = c_parser_nth_token_starts_std_attributes (parser, 1);\n+  if (have_std_attrs)\n+    std_attrs = c_parser_std_attribute_specifier_sequence (parser);\n   attrs = c_parser_gnu_attributes (parser);\n   enum_loc = c_parser_peek_token (parser)->location;\n   /* Set the location in case we create a decl now.  */\n@@ -3044,7 +3108,11 @@ c_parser_enum_specifier (c_parser *parser)\n \t  decl_loc = value_loc = token->location;\n \t  c_parser_consume_token (parser);\n \t  /* Parse any specified attributes.  */\n-\t  tree enum_attrs = c_parser_gnu_attributes (parser);\n+\t  tree std_attrs = NULL_TREE;\n+\t  if (c_parser_nth_token_starts_std_attributes (parser, 1))\n+\t    std_attrs = c_parser_std_attribute_specifier_sequence (parser);\n+\t  tree enum_attrs = chainon (std_attrs,\n+\t\t\t\t     c_parser_gnu_attributes (parser));\n \t  if (c_parser_next_token_is (parser, CPP_EQ))\n \t    {\n \t      c_parser_consume_token (parser);\n@@ -3084,7 +3152,8 @@ c_parser_enum_specifier (c_parser *parser)\n \t}\n       postfix_attrs = c_parser_gnu_attributes (parser);\n       ret.spec = finish_enum (type, nreverse (values),\n-\t\t\t      chainon (attrs, postfix_attrs));\n+\t\t\t      chainon (std_attrs,\n+\t\t\t\t       chainon (attrs, postfix_attrs)));\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n@@ -3100,7 +3169,14 @@ c_parser_enum_specifier (c_parser *parser)\n       ret.expr_const_operands = true;\n       return ret;\n     }\n-  ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident);\n+  /* Attributes may only appear when the members are defined or in\n+     certain forward declarations (treat enum forward declarations in\n+     GNU C analogously to struct and union forward declarations in\n+     standard C).  */\n+  if (have_std_attrs && c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n+    c_parser_error (parser, \"expected %<;%>\");\n+  ret = parser_xref_tag (ident_loc, ENUMERAL_TYPE, ident, have_std_attrs,\n+\t\t\t std_attrs);\n   /* In ISO C, enumerated types can be referred to only if already\n      defined.  */\n   if (pedantic && !COMPLETE_TYPE_P (ret.spec))\n@@ -3115,9 +3191,10 @@ c_parser_enum_specifier (c_parser *parser)\n /* Parse a struct or union specifier (C90 6.5.2.1, C99 6.7.2.1, C11 6.7.2.1).\n \n    struct-or-union-specifier:\n-     struct-or-union gnu-attributes[opt] identifier[opt]\n-       { struct-contents } gnu-attributes[opt]\n-     struct-or-union gnu-attributes[opt] identifier\n+     struct-or-union attribute-specifier-sequence[opt] gnu-attributes[opt]\n+       identifier[opt] { struct-contents } gnu-attributes[opt]\n+     struct-or-union attribute-specifier-sequence[opt] gnu-attributes[opt]\n+       identifier\n \n    struct-contents:\n      struct-declaration-list\n@@ -3155,6 +3232,8 @@ static struct c_typespec\n c_parser_struct_or_union_specifier (c_parser *parser)\n {\n   struct c_typespec ret;\n+  bool have_std_attrs;\n+  tree std_attrs = NULL_TREE;\n   tree attrs;\n   tree ident = NULL_TREE;\n   location_t struct_loc;\n@@ -3173,6 +3252,9 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n     }\n   struct_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n+  have_std_attrs = c_parser_nth_token_starts_std_attributes (parser, 1);\n+  if (have_std_attrs)\n+    std_attrs = c_parser_std_attribute_specifier_sequence (parser);\n   attrs = c_parser_gnu_attributes (parser);\n \n   /* Set the location in case we create a decl now.  */\n@@ -3291,7 +3373,9 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n \t}\n       postfix_attrs = c_parser_gnu_attributes (parser);\n       ret.spec = finish_struct (struct_loc, type, nreverse (contents),\n-\t\t\t\tchainon (attrs, postfix_attrs), struct_info);\n+\t\t\t\tchainon (std_attrs,\n+\t\t\t\t\t chainon (attrs, postfix_attrs)),\n+\t\t\t\tstruct_info);\n       ret.kind = ctsk_tagdef;\n       ret.expr = NULL_TREE;\n       ret.expr_const_operands = true;\n@@ -3307,15 +3391,22 @@ c_parser_struct_or_union_specifier (c_parser *parser)\n       ret.expr_const_operands = true;\n       return ret;\n     }\n-  ret = parser_xref_tag (ident_loc, code, ident);\n+  /* Attributes may only appear when the members are defined or in\n+     certain forward declarations.  */\n+  if (have_std_attrs && c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n+    c_parser_error (parser, \"expected %<;%>\");\n+  /* ??? Existing practice is that GNU attributes are ignored after\n+     the struct or union keyword when not defining the members.  */\n+  ret = parser_xref_tag (ident_loc, code, ident, have_std_attrs, std_attrs);\n   return ret;\n }\n \n /* Parse a struct-declaration (C90 6.5.2.1, C99 6.7.2.1, C11 6.7.2.1),\n    *without* the trailing semicolon.\n \n    struct-declaration:\n-     specifier-qualifier-list struct-declarator-list\n+     attribute-specifier-sequence[opt] specifier-qualifier-list\n+       attribute-specifier-sequence[opt] struct-declarator-list\n      static_assert-declaration-no-semi\n \n    specifier-qualifier-list:\n@@ -3375,7 +3466,7 @@ c_parser_struct_declaration (c_parser *parser)\n      of N1731.\n      <http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1731.pdf>  */\n   c_parser_declspecs (parser, specs, false, true, true,\n-\t\t      true, false, cla_nonabstract_decl);\n+\t\t      true, false, true, true, cla_nonabstract_decl);\n   if (parser->error)\n     return NULL_TREE;\n   if (!specs->declspecs_seen_p)\n@@ -3693,7 +3784,7 @@ c_parser_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n       struct c_declarator *inner;\n       c_parser_consume_token (parser);\n       c_parser_declspecs (parser, quals_attrs, false, false, true,\n-\t\t\t  false, false, cla_prefer_id);\n+\t\t\t  false, false, true, false, cla_prefer_id);\n       inner = c_parser_declarator (parser, type_seen_p, kind, seen_id);\n       if (inner == NULL)\n \treturn NULL;\n@@ -3718,14 +3809,15 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n      parenthesized declarator.  In an abstract declarator or parameter\n      declarator, they could start a parenthesized declarator or a\n      parameter list.  To tell which, the open parenthesis and any\n-     following gnu-attributes must be read.  If a declaration specifier\n-     follows, then it is a parameter list; if the specifier is a\n-     typedef name, there might be an ambiguity about redeclaring it,\n-     which is resolved in the direction of treating it as a typedef\n-     name.  If a close parenthesis follows, it is also an empty\n-     parameter list, as the syntax does not permit empty abstract\n-     declarators.  Otherwise, it is a parenthesized declarator (in\n-     which case the analysis may be repeated inside it, recursively).\n+     following gnu-attributes must be read.  If a declaration\n+     specifier or standard attributes follow, then it is a parameter\n+     list; if the specifier is a typedef name, there might be an\n+     ambiguity about redeclaring it, which is resolved in the\n+     direction of treating it as a typedef name.  If a close\n+     parenthesis follows, it is also an empty parameter list, as the\n+     syntax does not permit empty abstract declarators.  Otherwise, it\n+     is a parenthesized declarator (in which case the analysis may be\n+     repeated inside it, recursively).\n \n      ??? There is an ambiguity in a parameter declaration \"int\n      (__attribute__((foo)) x)\", where x is not a typedef name: it\n@@ -3758,11 +3850,18 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n       *seen_id = true;\n       inner->id_loc = c_parser_peek_token (parser)->location;\n       c_parser_consume_token (parser);\n+      if (c_parser_nth_token_starts_std_attributes (parser, 1))\n+\t{\n+\t  tree std_attrs = c_parser_std_attribute_specifier_sequence (parser);\n+\t  if (std_attrs)\n+\t    inner = build_attrs_declarator (std_attrs, inner);\n+\t}\n       return c_parser_direct_declarator_inner (parser, *seen_id, inner);\n     }\n \n   if (kind != C_DTR_NORMAL\n-      && c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n+      && c_parser_next_token_is (parser, CPP_OPEN_SQUARE)\n+      && !c_parser_nth_token_starts_std_attributes (parser, 1))\n     {\n       struct c_declarator *inner = build_id_declarator (NULL_TREE);\n       inner->id_loc = c_parser_peek_token (parser)->location;\n@@ -3777,21 +3876,35 @@ c_parser_direct_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n       tree attrs;\n       struct c_declarator *inner;\n       c_parser_consume_token (parser);\n+      bool have_gnu_attrs = c_parser_next_token_is_keyword (parser,\n+\t\t\t\t\t\t\t    RID_ATTRIBUTE);\n       attrs = c_parser_gnu_attributes (parser);\n       if (kind != C_DTR_NORMAL\n \t  && (c_parser_next_token_starts_declspecs (parser)\n+\t      || (!have_gnu_attrs\n+\t\t  && c_parser_nth_token_starts_std_attributes (parser, 1))\n \t      || c_parser_next_token_is (parser, CPP_CLOSE_PAREN)))\n \t{\n \t  struct c_arg_info *args\n \t    = c_parser_parms_declarator (parser, kind == C_DTR_NORMAL,\n-\t\t\t\t\t attrs);\n+\t\t\t\t\t attrs, have_gnu_attrs);\n \t  if (args == NULL)\n \t    return NULL;\n \t  else\n \t    {\n \t      inner\n \t\t= build_function_declarator (args,\n \t\t\t\t\t     build_id_declarator (NULL_TREE));\n+\t      if (!(args->types\n+\t\t    && args->types != error_mark_node\n+\t\t    && TREE_CODE (TREE_VALUE (args->types)) == IDENTIFIER_NODE)\n+\t\t  && c_parser_nth_token_starts_std_attributes (parser, 1))\n+\t\t{\n+\t\t  tree std_attrs\n+\t\t    = c_parser_std_attribute_specifier_sequence (parser);\n+\t\t  if (std_attrs)\n+\t\t    inner = build_attrs_declarator (std_attrs, inner);\n+\t\t}\n \t      return c_parser_direct_declarator_inner (parser, *seen_id,\n \t\t\t\t\t\t       inner);\n \t    }\n@@ -3837,7 +3950,8 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n \t\t\t\t  struct c_declarator *inner)\n {\n   /* Parse a sequence of array declarators and parameter lists.  */\n-  if (c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n+  if (c_parser_next_token_is (parser, CPP_OPEN_SQUARE)\n+      && !c_parser_nth_token_starts_std_attributes (parser, 1))\n     {\n       location_t brace_loc = c_parser_peek_token (parser)->location;\n       struct c_declarator *declarator;\n@@ -3850,13 +3964,13 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n       dimen.original_type = NULL_TREE;\n       c_parser_consume_token (parser);\n       c_parser_declspecs (parser, quals_attrs, false, false, true,\n-\t\t\t  false, false, cla_prefer_id);\n+\t\t\t  false, false, false, false, cla_prefer_id);\n       static_seen = c_parser_next_token_is_keyword (parser, RID_STATIC);\n       if (static_seen)\n \tc_parser_consume_token (parser);\n       if (static_seen && !quals_attrs->declspecs_seen_p)\n \tc_parser_declspecs (parser, quals_attrs, false, false, true,\n-\t\t\t    false, false, cla_prefer_id);\n+\t\t\t    false, false, false, false, cla_prefer_id);\n       if (!quals_attrs->declspecs_seen_p)\n \tquals_attrs = NULL;\n       /* If \"static\" is present, there must be an array dimension.\n@@ -3909,33 +4023,57 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n       if (declarator == NULL)\n \treturn NULL;\n       inner = set_array_declarator_inner (declarator, inner);\n+      if (c_parser_nth_token_starts_std_attributes (parser, 1))\n+\t{\n+\t  tree std_attrs\n+\t    = c_parser_std_attribute_specifier_sequence (parser);\n+\t  if (std_attrs)\n+\t    inner = build_attrs_declarator (std_attrs, inner);\n+\t}\n       return c_parser_direct_declarator_inner (parser, id_present, inner);\n     }\n   else if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n     {\n       tree attrs;\n       struct c_arg_info *args;\n       c_parser_consume_token (parser);\n+      bool have_gnu_attrs = c_parser_next_token_is_keyword (parser,\n+\t\t\t\t\t\t\t    RID_ATTRIBUTE);\n       attrs = c_parser_gnu_attributes (parser);\n-      args = c_parser_parms_declarator (parser, id_present, attrs);\n+      args = c_parser_parms_declarator (parser, id_present, attrs,\n+\t\t\t\t\thave_gnu_attrs);\n       if (args == NULL)\n \treturn NULL;\n       else\n \t{\n \t  inner = build_function_declarator (args, inner);\n+\t  if (!(args->types\n+\t\t&& args->types != error_mark_node\n+\t\t&& TREE_CODE (TREE_VALUE (args->types)) == IDENTIFIER_NODE)\n+\t      && c_parser_nth_token_starts_std_attributes (parser, 1))\n+\t    {\n+\t      tree std_attrs\n+\t\t= c_parser_std_attribute_specifier_sequence (parser);\n+\t      if (std_attrs)\n+\t\tinner = build_attrs_declarator (std_attrs, inner);\n+\t    }\n \t  return c_parser_direct_declarator_inner (parser, id_present, inner);\n \t}\n     }\n   return inner;\n }\n \n /* Parse a parameter list or identifier list, including the closing\n-   parenthesis but not the opening one.  ATTRS are the attributes at\n-   the start of the list.  ID_LIST_OK is true if an identifier list is\n-   acceptable; such a list must not have attributes at the start.  */\n+   parenthesis but not the opening one.  ATTRS are the gnu-attributes\n+   at the start of the list.  ID_LIST_OK is true if an identifier list\n+   is acceptable; such a list must not have attributes at the start.\n+   HAVE_GNU_ATTRS says whether any gnu-attributes (including empty\n+   attributes) were present (in which case standard attributes cannot\n+   occur).  */\n \n static struct c_arg_info *\n-c_parser_parms_declarator (c_parser *parser, bool id_list_ok, tree attrs)\n+c_parser_parms_declarator (c_parser *parser, bool id_list_ok, tree attrs,\n+\t\t\t   bool have_gnu_attrs)\n {\n   push_scope ();\n   declare_parm_level ();\n@@ -3988,28 +4126,31 @@ c_parser_parms_declarator (c_parser *parser, bool id_list_ok, tree attrs)\n     }\n   else\n     {\n-      struct c_arg_info *ret = c_parser_parms_list_declarator (parser, attrs,\n-\t\t\t\t\t\t\t       NULL);\n+      struct c_arg_info *ret\n+\t= c_parser_parms_list_declarator (parser, attrs, NULL, have_gnu_attrs);\n       pop_scope ();\n       return ret;\n     }\n }\n \n /* Parse a parameter list (possibly empty), including the closing\n-   parenthesis but not the opening one.  ATTRS are the attributes at\n-   the start of the list.  EXPR is NULL or an expression that needs to\n-   be evaluated for the side effects of array size expressions in the\n-   parameters.  */\n+   parenthesis but not the opening one.  ATTRS are the gnu-attributes\n+   at the start of the list; if HAVE_GNU_ATTRS, there were some such\n+   attributes (possibly empty, in which case ATTRS is NULL_TREE),\n+   which means standard attributes cannot start the list.  EXPR is\n+   NULL or an expression that needs to be evaluated for the side\n+   effects of array size expressions in the parameters.  */\n \n static struct c_arg_info *\n-c_parser_parms_list_declarator (c_parser *parser, tree attrs, tree expr)\n+c_parser_parms_list_declarator (c_parser *parser, tree attrs, tree expr,\n+\t\t\t\tbool have_gnu_attrs)\n {\n   bool bad_parm = false;\n \n   /* ??? Following the old parser, forward parameter declarations may\n      use abstract declarators, and if no real parameter declarations\n      follow the forward declarations then this is not diagnosed.  Also\n-     note as above that attributes are ignored as the only contents of\n+     note as above that gnu-attributes are ignored as the only contents of\n      the parentheses, or as the only contents after forward\n      declarations.  */\n   if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n@@ -4053,8 +4194,10 @@ c_parser_parms_list_declarator (c_parser *parser, tree attrs, tree expr)\n   while (true)\n     {\n       /* Parse a parameter.  */\n-      struct c_parm *parm = c_parser_parameter_declaration (parser, attrs);\n+      struct c_parm *parm = c_parser_parameter_declaration (parser, attrs,\n+\t\t\t\t\t\t\t    have_gnu_attrs);\n       attrs = NULL_TREE;\n+      have_gnu_attrs = false;\n       if (parm == NULL)\n \tbad_parm = true;\n       else\n@@ -4064,8 +4207,11 @@ c_parser_parms_list_declarator (c_parser *parser, tree attrs, tree expr)\n \t  tree new_attrs;\n \t  c_parser_consume_token (parser);\n \t  mark_forward_parm_decls ();\n+\t  bool new_have_gnu_attrs\n+\t    = c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE);\n \t  new_attrs = c_parser_gnu_attributes (parser);\n-\t  return c_parser_parms_list_declarator (parser, new_attrs, expr);\n+\t  return c_parser_parms_list_declarator (parser, new_attrs, expr,\n+\t\t\t\t\t\t new_have_gnu_attrs);\n \t}\n       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t{\n@@ -4103,11 +4249,14 @@ c_parser_parms_list_declarator (c_parser *parser, tree attrs, tree expr)\n     }\n }\n \n-/* Parse a parameter declaration.  ATTRS are the attributes at the\n-   start of the declaration if it is the first parameter.  */\n+/* Parse a parameter declaration.  ATTRS are the gnu-attributes at the\n+   start of the declaration if it is the first parameter;\n+   HAVE_GNU_ATTRS is true if there were any gnu-attributes there (even\n+   empty) there.  */\n \n static struct c_parm *\n-c_parser_parameter_declaration (c_parser *parser, tree attrs)\n+c_parser_parameter_declaration (c_parser *parser, tree attrs,\n+\t\t\t\tbool have_gnu_attrs)\n {\n   struct c_declspecs *specs;\n   struct c_declarator *declarator;\n@@ -4119,7 +4268,8 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n   while (c_parser_next_token_is (parser, CPP_PRAGMA))\n     c_parser_pragma (parser, pragma_param, NULL);\n \n-  if (!c_parser_next_token_starts_declspecs (parser))\n+  if (!c_parser_next_token_starts_declspecs (parser)\n+      && !c_parser_nth_token_starts_std_attributes (parser, 1))\n     {\n       c_token *token = c_parser_peek_token (parser);\n       if (parser->error)\n@@ -4161,7 +4311,7 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n       attrs = NULL_TREE;\n     }\n   c_parser_declspecs (parser, specs, true, true, true, true, false,\n-\t\t      cla_nonabstract_decl);\n+\t\t      !have_gnu_attrs, true, cla_nonabstract_decl);\n   finish_declspecs (specs);\n   pending_xref_error ();\n   prefix_attrs = specs->attrs;\n@@ -4733,6 +4883,33 @@ c_parser_std_attribute_specifier (c_parser *parser, bool for_tm)\n   return nreverse (attributes);\n }\n \n+/* Return whether standard attributes start with the Nth token.  */\n+\n+static bool\n+c_parser_nth_token_starts_std_attributes (c_parser *parser, unsigned int n)\n+{\n+  if (!(c_parser_peek_nth_token (parser, n)->type == CPP_OPEN_SQUARE\n+\t&& c_parser_peek_nth_token (parser, n + 1)->type == CPP_OPEN_SQUARE))\n+    return false;\n+  /* In C, '[[' must start attributes.  In Objective-C, identifying\n+     whether those tokens start attributes requires unbounded\n+     lookahead, which is not yet implemented.  */\n+  return !c_dialect_objc ();\n+}\n+\n+static tree\n+c_parser_std_attribute_specifier_sequence (c_parser *parser)\n+{\n+  tree attributes = NULL_TREE;\n+  do\n+    {\n+      tree attrs = c_parser_std_attribute_specifier (parser, false);\n+      attributes = chainon (attributes, attrs);\n+    }\n+  while (c_parser_nth_token_starts_std_attributes (parser, 1));\n+  return attributes;\n+}\n+\n /* Parse a type name (C90 6.5.5, C99 6.7.6, C11 6.7.7).  ALIGNAS_OK\n    says whether alignment specifiers are OK (only in cases that might\n    be the type name of a compound literal).\n@@ -4749,7 +4926,7 @@ c_parser_type_name (c_parser *parser, bool alignas_ok)\n   struct c_type_name *ret;\n   bool dummy = false;\n   c_parser_declspecs (parser, specs, false, true, true, alignas_ok, false,\n-\t\t      cla_prefer_type);\n+\t\t      false, true, cla_prefer_type);\n   if (!specs->declspecs_seen_p)\n     {\n       c_parser_error (parser, \"expected specifier-qualifier-list\");\n@@ -5281,11 +5458,18 @@ c_parser_compound_statement_nostart (c_parser *parser)\n     {\n       location_t loc = c_parser_peek_token (parser)->location;\n       loc = expansion_point_location_if_in_system_header (loc);\n+      /* Standard attributes may start a statement or a declaration.  */\n+      bool have_std_attrs\n+\t= c_parser_nth_token_starts_std_attributes (parser, 1);\n+      tree std_attrs = NULL_TREE;\n+      if (have_std_attrs)\n+\tstd_attrs = c_parser_std_attribute_specifier_sequence (parser);\n       if (c_parser_next_token_is_keyword (parser, RID_CASE)\n \t  || c_parser_next_token_is_keyword (parser, RID_DEFAULT)\n \t  || (c_parser_next_token_is (parser, CPP_NAME)\n \t      && c_parser_peek_2nd_token (parser)->type == CPP_COLON))\n \t{\n+\t  c_warn_unused_attributes (std_attrs);\n \t  if (c_parser_next_token_is_keyword (parser, RID_CASE))\n \t    label_loc = c_parser_peek_2nd_token (parser)->location;\n \t  else\n@@ -5296,14 +5480,17 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t  c_parser_label (parser);\n \t}\n       else if (!last_label\n-\t       && c_parser_next_tokens_start_declaration (parser))\n+\t       && (c_parser_next_tokens_start_declaration (parser)\n+\t\t   || (have_std_attrs\n+\t\t       && c_parser_next_token_is (parser, CPP_SEMICOLON))))\n \t{\n \t  last_label = false;\n \t  mark_valid_location_for_stdc_pragma (false);\n \t  bool fallthru_attr_p = false;\n-\t  c_parser_declaration_or_fndef (parser, true, true, true, true,\n-\t\t\t\t\t true, NULL, vNULL, NULL,\n-\t\t\t\t\t &fallthru_attr_p);\n+\t  c_parser_declaration_or_fndef (parser, true, !have_std_attrs,\n+\t\t\t\t\t true, true, true, NULL,\n+\t\t\t\t\t vNULL, have_std_attrs, std_attrs,\n+\t\t\t\t\t NULL, &fallthru_attr_p);\n \t  if (last_stmt && !fallthru_attr_p)\n \t    pedwarn_c90 (loc, OPT_Wdeclaration_after_statement,\n \t\t\t \"ISO C90 forbids mixed declarations and code\");\n@@ -5315,12 +5502,17 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t  /* __extension__ can start a declaration, but is also an\n \t     unary operator that can start an expression.  Consume all\n \t     but the last of a possible series of __extension__ to\n-\t     determine which.  */\n+\t     determine which.  If standard attributes have already\n+\t     been seen, it must start a statement, not a declaration,\n+\t     but standard attributes starting a declaration may appear\n+\t     after __extension__.  */\n \t  while (c_parser_peek_2nd_token (parser)->type == CPP_KEYWORD\n \t\t && (c_parser_peek_2nd_token (parser)->keyword\n \t\t     == RID_EXTENSION))\n \t    c_parser_consume_token (parser);\n-\t  if (c_token_starts_declaration (c_parser_peek_2nd_token (parser)))\n+\t  if (!have_std_attrs\n+\t      && (c_token_starts_declaration (c_parser_peek_2nd_token (parser))\n+\t\t  || c_parser_nth_token_starts_std_attributes (parser, 2)))\n \t    {\n \t      int ext;\n \t      ext = disable_extension_diagnostics ();\n@@ -5342,6 +5534,8 @@ c_parser_compound_statement_nostart (c_parser *parser)\n \t}\n       else if (c_parser_next_token_is (parser, CPP_PRAGMA))\n \t{\n+\t  if (have_std_attrs)\n+\t    c_parser_error (parser, \"expected declaration or statement\");\n \t  /* External pragmas, and some omp pragmas, are not associated\n \t     with regular c code, and so are not to be considered statements\n \t     syntactically.  This ensures that the user doesn't put them\n@@ -5376,6 +5570,7 @@ c_parser_compound_statement_nostart (c_parser *parser)\n       else\n \t{\n \tstatement:\n+\t  c_warn_unused_attributes (std_attrs);\n \t  last_label = false;\n \t  last_stmt = true;\n \t  mark_valid_location_for_stdc_pragma (false);\n@@ -5391,11 +5586,22 @@ c_parser_compound_statement_nostart (c_parser *parser)\n   mark_valid_location_for_stdc_pragma (save_valid_for_pragma);\n }\n \n-/* Parse all consecutive labels. */\n+/* Parse all consecutive labels, possibly preceded by standard\n+   attributes.  In this context, a statement is required, not a\n+   declaration, so attributes must be followed by a statement that is\n+   not just a semicolon.  */\n \n static void\n c_parser_all_labels (c_parser *parser)\n {\n+  if (c_parser_nth_token_starts_std_attributes (parser, 1))\n+    {\n+      tree std_attrs = c_parser_std_attribute_specifier_sequence (parser);\n+      if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n+\tc_parser_error (parser, \"expected statement\");\n+      else\n+\tc_warn_unused_attributes (std_attrs);\n+    }\n   while (c_parser_next_token_is_keyword (parser, RID_CASE)\n \t || c_parser_next_token_is_keyword (parser, RID_DEFAULT)\n \t || (c_parser_next_token_is (parser, CPP_NAME)\n@@ -5417,7 +5623,11 @@ c_parser_all_labels (c_parser *parser)\n \n    The use of gnu-attributes on labels is a GNU extension.  The syntax in\n    GNU C accepts any expressions without commas, non-constant\n-   expressions being rejected later.  */\n+   expressions being rejected later.  Any standard\n+   attribute-specifier-sequence before the first label has been parsed\n+   in the caller, to distinguish statements from declarations.  Any\n+   attribute-specifier-sequence after the label is parsed in this\n+   function.  */\n \n static void\n c_parser_label (c_parser *parser)\n@@ -5480,8 +5690,18 @@ c_parser_label (c_parser *parser)\n       else\n \tFALLTHROUGH_LABEL_P (CASE_LABEL (label)) = fallthrough_p;\n \n+      /* Standard attributes are only allowed here if they start a\n+\t statement, not a declaration (including the case of an\n+\t attribute-declaration with only attributes).  */\n+      bool have_std_attrs\n+\t= c_parser_nth_token_starts_std_attributes (parser, 1);\n+      tree std_attrs = NULL_TREE;\n+      if (have_std_attrs)\n+\tstd_attrs = c_parser_std_attribute_specifier_sequence (parser);\n+\n       /* Allow '__attribute__((fallthrough));'.  */\n-      if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n+      if (!have_std_attrs\n+\t  && c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n \t{\n \t  location_t loc = c_parser_peek_token (parser)->location;\n \t  tree attrs = c_parser_gnu_attributes (parser);\n@@ -5502,7 +5722,9 @@ c_parser_label (c_parser *parser)\n \t    warning_at (loc, OPT_Wattributes, \"only attribute %<fallthrough%>\"\n \t\t\t\" can be applied to a null statement\");\n \t}\n-      if (c_parser_next_tokens_start_declaration (parser))\n+      if (c_parser_next_tokens_start_declaration (parser)\n+\t  || (have_std_attrs\n+\t      && c_parser_next_token_is (parser, CPP_SEMICOLON)))\n \t{\n \t  error_at (c_parser_peek_token (parser)->location,\n \t\t    \"a label can only be part of a statement and \"\n@@ -5511,26 +5733,30 @@ c_parser_label (c_parser *parser)\n \t\t\t\t\t /*static_assert_ok*/ true,\n \t\t\t\t\t /*empty_ok*/ true, /*nested*/ true,\n \t\t\t\t\t /*start_attr_ok*/ true, NULL,\n-\t\t\t\t\t vNULL);\n+\t\t\t\t\t vNULL, have_std_attrs, std_attrs);\n \t}\n+      else if (std_attrs)\n+\t/* Nonempty attributes on the following statement are ignored.  */\n+\tc_warn_unused_attributes (std_attrs);\n     }\n }\n \n /* Parse a statement (C90 6.6, C99 6.8, C11 6.8).\n \n    statement:\n      labeled-statement\n-     compound-statement\n+     attribute-specifier-sequence[opt] compound-statement\n      expression-statement\n-     selection-statement\n-     iteration-statement\n-     jump-statement\n+     attribute-specifier-sequence[opt] selection-statement\n+     attribute-specifier-sequence[opt] iteration-statement\n+     attribute-specifier-sequence[opt] jump-statement\n \n    labeled-statement:\n-     label statement\n+     attribute-specifier-sequence[opt] label statement\n \n    expression-statement:\n      expression[opt] ;\n+     attribute-specifier-sequence expression ;\n \n    selection-statement:\n      if-statement\n@@ -5550,7 +5776,7 @@ c_parser_label (c_parser *parser)\n    GNU extensions:\n \n    statement:\n-     asm-statement\n+     attribute-specifier-sequence[opt] asm-statement\n \n    jump-statement:\n      goto * expression ;\n@@ -5561,9 +5787,9 @@ c_parser_label (c_parser *parser)\n    Objective-C:\n \n    statement:\n-     objc-throw-statement\n-     objc-try-catch-statement\n-     objc-synchronized-statement\n+     attribute-specifier-sequence[opt] objc-throw-statement\n+     attribute-specifier-sequence[opt] objc-try-catch-statement\n+     attribute-specifier-sequence[opt] objc-synchronized-statement\n \n    objc-throw-statement:\n      @throw expression ;\n@@ -5572,7 +5798,7 @@ c_parser_label (c_parser *parser)\n    OpenACC:\n \n    statement:\n-     openacc-construct\n+     attribute-specifier-sequence[opt] openacc-construct\n \n    openacc-construct:\n      parallel-construct\n@@ -5595,7 +5821,7 @@ c_parser_label (c_parser *parser)\n    OpenMP:\n \n    statement:\n-     openmp-construct\n+     attribute-specifier-sequence[opt] openmp-construct\n \n    openmp-construct:\n      parallel-construct\n@@ -5654,8 +5880,8 @@ c_parser_label (c_parser *parser)\n    Transactional Memory:\n \n    statement:\n-     transaction-statement\n-     transaction-cancel-statement\n+     attribute-specifier-sequence[opt] transaction-statement\n+     attribute-specifier-sequence[opt] transaction-cancel-statement\n \n    IF_P is used to track whether there's a (possibly labeled) if statement\n    which is not enclosed in braces and has an else clause.  This is used to\n@@ -5671,7 +5897,8 @@ c_parser_statement (c_parser *parser, bool *if_p, location_t *loc_after_labels)\n }\n \n /* Parse a statement, other than a labeled statement.  CHAIN is a vector\n-   of if-else-if conditions.\n+   of if-else-if conditions.  All labels and standard attributes have\n+   been parsed in the caller.\n \n    IF_P is used to track whether there's a (possibly labeled) if statement\n    which is not enclosed in braces and has an else clause.  This is used to\n@@ -6394,7 +6621,8 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t  c_parser_consume_token (parser);\n \t  c_finish_expr_stmt (loc, NULL_TREE);\n \t}\n-      else if (c_parser_next_tokens_start_declaration (parser))\n+      else if (c_parser_next_tokens_start_declaration (parser)\n+\t       || c_parser_nth_token_starts_std_attributes (parser, 1))\n \t{\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true, true, \n \t\t\t\t\t &object_expression, vNULL);\n@@ -6421,7 +6649,8 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t\t && (c_parser_peek_2nd_token (parser)->keyword\n \t\t     == RID_EXTENSION))\n \t    c_parser_consume_token (parser);\n-\t  if (c_token_starts_declaration (c_parser_peek_2nd_token (parser)))\n+\t  if (c_token_starts_declaration (c_parser_peek_2nd_token (parser))\n+\t      || c_parser_nth_token_starts_std_attributes (parser, 2))\n \t    {\n \t      int ext;\n \t      ext = disable_extension_diagnostics ();\n@@ -10983,7 +11212,7 @@ c_parser_objc_method_decl (c_parser *parser, bool is_class_method,\n \t\t\t\t\t\t(parser, attributes) ;\n \t      break;\n \t    }\n-\t  parm = c_parser_parameter_declaration (parser, NULL_TREE);\n+\t  parm = c_parser_parameter_declaration (parser, NULL_TREE, false);\n \t  if (parm == NULL)\n \t    break;\n \t  parms = chainon (parms,\n@@ -11148,7 +11377,7 @@ c_parser_objc_try_catch_finally_statement (c_parser *parser)\n \t{\n \t  /* We have \"@catch (NSException *exception)\" or something\n \t     like that.  Parse the parameter declaration.  */\n-\t  parm = c_parser_parameter_declaration (parser, NULL_TREE);\n+\t  parm = c_parser_parameter_declaration (parser, NULL_TREE, false);\n \t  if (parm == NULL)\n \t    parameter_declaration = error_mark_node;\n \t  else\n@@ -16490,12 +16719,12 @@ c_parser_oacc_routine (c_parser *parser, enum pragma_context context)\n \t  while (c_parser_next_token_is (parser, CPP_KEYWORD)\n \t\t && c_parser_peek_token (parser)->keyword == RID_EXTENSION);\n \t  c_parser_declaration_or_fndef (parser, true, true, true, false, true,\n-\t\t\t\t\t NULL, vNULL, &data);\n+\t\t\t\t\t NULL, vNULL, false, NULL, &data);\n \t  restore_extension_diagnostics (ext);\n \t}\n       else\n \tc_parser_declaration_or_fndef (parser, true, true, true, false, true,\n-\t\t\t\t       NULL, vNULL, &data);\n+\t\t\t\t       NULL, vNULL, false, NULL, &data);\n     }\n }\n "}, {"sha": "b32daabe25f031481d15409fe126361a5ee1a293", "filename": "gcc/c/c-parser.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fc-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fc-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.h?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -190,7 +190,8 @@ extern struct c_declarator *\n c_parser_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n \t\t     bool *seen_id);\n extern void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n-\t\t\t\tbool, bool, bool, enum c_lookahead_kind);\n+\t\t\t\tbool, bool, bool, bool, bool,\n+\t\t\t\tenum c_lookahead_kind);\n extern struct c_type_name *c_parser_type_name (c_parser *, bool = false);\n \n #endif"}, {"sha": "67c8f45af450db86a91d733d539b1ee38312e48f", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -186,9 +186,13 @@ enum c_typespec_kind {\n      kind of tag, in which case this is only valid if shadowing that\n      tag in an inner scope.  */\n   ctsk_tagref,\n+  /* Likewise, with standard attributes present in the reference.  */\n+  ctsk_tagref_attrs,\n   /* A reference to a tag, not previously declared in a visible\n      scope.  */\n   ctsk_tagfirstref,\n+  /* Likewise, with standard attributes present in the reference.  */\n+  ctsk_tagfirstref_attrs,\n   /* A definition of a tag such as \"struct foo { int a; }\".  */\n   ctsk_tagdef,\n   /* A typedef name.  */\n@@ -311,10 +315,15 @@ struct c_declspecs {\n   tree expr;\n   /* The attributes from a typedef decl.  */\n   tree decl_attr;\n-  /* When parsing, the attributes.  Outside the parser, this will be\n-     NULL; attributes (possibly from multiple lists) will be passed\n-     separately.  */\n+  /* When parsing, the GNU attributes and prefix standard attributes.\n+     Outside the parser, this will be NULL; attributes (possibly from\n+     multiple lists) will be passed separately.  */\n   tree attrs;\n+  /* When parsing, postfix standard attributes (which appertain to the\n+     type specified by the preceding declaration specifiers, unlike\n+     prefix standard attributes which appertain to the declaration or\n+     declarations as a whole).  */\n+  tree postfix_attrs;\n   /* The pass to start compiling a __GIMPLE or __RTL function with.  */\n   char *gimple_or_rtl_pass;\n   /* ENTRY BB count.  */\n@@ -335,13 +344,17 @@ struct c_declspecs {\n   ENUM_BITFIELD (c_typespec_keyword) typespec_word : 8;\n   /* The kind of type specifier if one has been seen, ctsk_none\n      otherwise.  */\n-  ENUM_BITFIELD (c_typespec_kind) typespec_kind : 3;\n+  ENUM_BITFIELD (c_typespec_kind) typespec_kind : 4;\n   ENUM_BITFIELD (c_declspec_il) declspec_il : 3;\n   /* Whether any expressions in typeof specifiers may appear in\n      constant expressions.  */\n   BOOL_BITFIELD expr_const_operands : 1;\n   /* Whether any declaration specifiers have been seen at all.  */\n   BOOL_BITFIELD declspecs_seen_p : 1;\n+  /* Whether any declaration specifiers other than standard attributes\n+     have been seen at all.  If only standard attributes have been\n+     seen, this is an attribute-declaration.  */\n+  BOOL_BITFIELD non_std_attrs_seen_p : 1;\n   /* Whether something other than a storage class specifier or\n      attribute has been seen.  This is used to warn for the\n      obsolescent usage of storage class specifiers other than at the\n@@ -582,6 +595,7 @@ extern struct c_declarator *set_array_declarator_inner (struct c_declarator *,\n extern tree c_builtin_function (tree);\n extern tree c_builtin_function_ext_scope (tree);\n extern tree c_simulate_builtin_function_decl (tree);\n+extern void c_warn_unused_attributes (tree);\n extern void shadow_tag (const struct c_declspecs *);\n extern void shadow_tag_warned (const struct c_declspecs *, int);\n extern tree start_enum (location_t, struct c_enum_contents *, tree);\n@@ -595,7 +609,8 @@ extern void store_parm_decls_from (struct c_arg_info *);\n extern void temp_store_parm_decls (tree, tree);\n extern void temp_pop_parm_decls (void);\n extern tree xref_tag (enum tree_code, tree);\n-extern struct c_typespec parser_xref_tag (location_t, enum tree_code, tree);\n+extern struct c_typespec parser_xref_tag (location_t, enum tree_code, tree,\n+\t\t\t\t\t  bool, tree);\n extern struct c_parm *build_c_parm (struct c_declspecs *, tree,\n \t\t\t\t    struct c_declarator *, location_t);\n extern struct c_declarator *build_attrs_declarator (tree,"}, {"sha": "6fdb83c1abe169dd85a540bbf99d71b2bfcb82c2", "filename": "gcc/c/gimple-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -2014,7 +2014,7 @@ c_parser_gimple_declaration (gimple_parser &parser)\n   struct c_declarator *declarator;\n   struct c_declspecs *specs = build_null_declspecs ();\n   c_parser_declspecs (parser, specs, true, true, true,\n-\t\t      true, true, cla_nonabstract_decl);\n+\t\t      true, true, true, true, cla_nonabstract_decl);\n   finish_declspecs (specs);\n \n   /* Provide better error recovery.  Note that a type name here is usually"}, {"sha": "1a03eec0e3bfa3b0c52bb66b63dd062bfd02f70a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -1,3 +1,10 @@\n+2019-11-14  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/c2x-attr-fallthrough-1.c, gcc.dg/c2x-attr-syntax-1.c,\n+\tgcc.dg/c2x-attr-syntax-2.c, gcc.dg/c2x-attr-syntax-3.c,\n+\tgcc.dg/gnu2x-attr-syntax-1.c, gcc.dg/gnu2x-attr-syntax-2.c,\n+\tgcc.dg/gnu2x-attrs-1.c: New tests.\n+\n 2019-11-14  Feng Xue  <fxue@os.amperecomputing.com>\n \n \tPR ipa/91682"}, {"sha": "ffa5226bf519a9d10477d275df4130094a2edad5", "filename": "gcc/testsuite/gcc.dg/c2x-attr-fallthrough-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-fallthrough-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-fallthrough-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-fallthrough-1.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -0,0 +1,21 @@\n+/* Test C2x attribute syntax.  Valid use of fallthrough attribute.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors -Wextra\" } */\n+\n+int\n+f (int a)\n+{\n+  int b = 2;\n+  switch (a)\n+    {\n+    case 1:\n+      b = 1; /* { dg-warning \"may fall through\" } */\n+    case 2:\n+      b = 2;\n+      [[fallthrough]];\n+    case 3:\n+      b += 7;\n+      break;\n+    }\n+  return b;\n+}"}, {"sha": "48e2591258206fa23d0cd8e23d2a415c5fb20db9", "filename": "gcc/testsuite/gcc.dg/c2x-attr-syntax-1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-syntax-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-syntax-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-syntax-1.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -0,0 +1,55 @@\n+/* Test C2x attribute syntax.  Basic tests of valid uses of empty\n+   attributes.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+[ [ ] ] [[]];\n+\n+[[]] int [[]] a [[]] = 123;\n+\n+int f([[]] int x [[]], [[]] long [[]], short [[]] *[[]] [3] [[]],\n+      int [[]] (int)[[]], int (*)(int)[[]]) [[]] [[]];\n+\n+int g [[]] [2] [[]] [3] [[]];\n+\n+int *[[]] const *[[]] volatile *[[]] *const p;\n+\n+int *[[]][[]] q = 0;\n+\n+struct [[]] s;\n+union [[]][[]] u;\n+\n+struct [[]] s2 { [[]] long [[]] *a[[]] [3] [[]] [4], b[[]]; };\n+\n+union [[]] u2 { [[]] long [[]] *a[[]] [3] [[]] [4]; };\n+\n+int z = sizeof (int [[]]);\n+\n+enum [[]] { E1 [[]][[]], E2[[]][[]] = 3 };\n+enum [[]] e { E3 = 4, E4 [[]] };\n+\n+void\n+func (void) [[]]\n+{\n+  [[]] int var;\n+  [[]] { }\n+  [[]] switch (a) { [[]] case 1: [[]] case 2: [[]] default: [[]] var = 3; }\n+  [[]] x : [[]] y: [[]] var = 1;\n+  [[]];\n+  int [[]] var2;\n+  [[]] if (a) [[]] (void) 0; else [[]] (void) 1;\n+  [[]] while (0) [[]] var = 2;\n+  [[]] do [[]] var = 3; while (0);\n+  for ([[]] int zz = 1; zz < 10; zz++)\n+    {\n+      [[]] var2 = 8;\n+      [[]] continue;\n+      [[]] break;\n+    }\n+  if (a) [[]] goto x;\n+  [[]] return;\n+}\n+\n+void func2 () [[]];\n+\n+void func3 () [[]] { }"}, {"sha": "ceca9501ac15d604fb3b13fd4f60786c193e9b36", "filename": "gcc/testsuite/gcc.dg/c2x-attr-syntax-2.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-syntax-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-syntax-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-syntax-2.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -0,0 +1,60 @@\n+/* Test C2x attribute syntax.  Test ignored attributes diagnosed.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* A GNU attribute that is valid in some contexts, but should be\n+   diagnosed in contexts where all attributes are ignored (attribute\n+   declarations, except for fallthrough attributes, and\n+   statements).  */\n+#define CTX [[gnu::const]]\n+\n+/* An attribute that is unknown, so ignored with a warning.  */\n+#define UNK [[gnu::no_such_attribute(![!(!)!]!,;;)]]\n+\n+CTX; /* { dg-warning \"ignored\" } */\n+UNK; /* { dg-warning \"ignored\" } */\n+\n+UNK extern int a; /* { dg-warning \"ignored\" } */\n+extern int UNK a; /* { dg-warning \"ignored\" } */\n+extern int a UNK; /* { dg-warning \"ignored\" } */\n+\n+int f () UNK; /* { dg-warning \"ignored\" } */\n+int f (void) UNK; /* { dg-warning \"ignored\" } */\n+int g (UNK int a); /* { dg-warning \"ignored\" } */\n+int g (int UNK a); /* { dg-warning \"ignored\" } */\n+int g (int a UNK); /* { dg-warning \"ignored\" } */\n+int g (UNK int); /* { dg-warning \"ignored\" } */\n+int g (int UNK); /* { dg-warning \"ignored\" } */\n+int g (int) UNK; /* { dg-warning \"ignored\" } */\n+\n+int *UNK p; /* { dg-warning \"ignored\" } */\n+int b[3] UNK; /* { dg-warning \"ignored\" } */\n+\n+int h (int () UNK); /* { dg-warning \"ignored\" } */\n+\n+struct UNK s; /* { dg-warning \"ignored\" } */\n+union UNK u; /* { dg-warning \"ignored\" } */\n+\n+struct UNK s2 { int a; }; /* { dg-warning \"ignored\" } */\n+union UNK u2 { int a; }; /* { dg-warning \"ignored\" } */\n+\n+struct s3 { UNK int a; }; /* { dg-warning \"ignored\" } */\n+struct s4 { int UNK a; }; /* { dg-warning \"ignored\" } */\n+union u3 { UNK int a; }; /* { dg-warning \"ignored\" } */\n+union u4 { int UNK a; }; /* { dg-warning \"ignored\" } */\n+\n+int z = sizeof (int UNK); /* { dg-warning \"ignored\" } */\n+\n+enum UNK { E1 }; /* { dg-warning \"ignored\" } */\n+enum { E2 UNK }; /* { dg-warning \"ignored\" } */\n+enum { E3 UNK = 4 }; /* { dg-warning \"ignored\" } */\n+\n+void\n+func (void) UNK { /* { dg-warning \"ignored\" } */\n+  UNK int var; /* { dg-warning \"ignored\" } */\n+  CTX { } /* { dg-warning \"ignored\" } */\n+  CTX; /* { dg-warning \"ignored\" } */\n+  CTX var = 1; /* { dg-warning \"ignored\" } */\n+  CTX x: var = 2; /* { dg-warning \"ignored\" } */\n+  for (UNK int zz = 1; zz < 10; zz++) ; /* { dg-warning \"ignored\" } */\n+}"}, {"sha": "1f883d825e026769c80bc554f27515b29de3f4aa", "filename": "gcc/testsuite/gcc.dg/c2x-attr-syntax-3.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-syntax-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-syntax-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-attr-syntax-3.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -0,0 +1,56 @@\n+/* Test C2x attribute syntax.  Invalid uses of attributes.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* Prefix attributes not allowed on declarations without declarators.  */\n+\n+[[]] struct s { int a; }; /* { dg-error \"empty declaration\" } */\n+\n+[[]] union u { int a; }; /* { dg-error \"empty declaration\" } */\n+\n+void\n+f1 (void)\n+{\n+  [[]] struct t { int a; }; /* { dg-error \"empty declaration\" } */\n+}\n+\n+/* Prefix attributes not allowed on _Static_assert.  */\n+\n+[[]] _Static_assert (1); /* { dg-error \"expected\" } */\n+\n+void\n+f2 (void)\n+{\n+  [[]] _Static_assert (1); /* { dg-error \"expected\" } */\n+}\n+\n+/* Declarations, including attribute declarations, cannot appear after\n+   labels.  */\n+\n+void\n+f3 (void)\n+{\n+ x: [[]];; /* { dg-error \"can only be part of a statement\" } */\n+}\n+\n+/* Prefix attributes cannot appear on type names.  */\n+\n+int z = sizeof ([[]] int); /* { dg-error \"expected\" } */\n+\n+/* Attributes are not allowed after struct, union or enum, except when\n+   the type contents are being defined or the declaration is just\n+   \"struct-or-union atribute-specifier-sequence identifier;\".  */\n+\n+const struct [[]] s2; /* { dg-warning \"useless type qualifier\" } */\n+/* { dg-error \"invalid use of attributes in empty declaration\" \"invalid\" { target *-*-* } .-1 } */\n+\n+const union [[]] u2; /* { dg-warning \"useless type qualifier\" } */\n+/* { dg-error \"invalid use of attributes in empty declaration\" \"invalid\" { target *-*-* } .-1 } */\n+\n+struct [[]] s3 *sv; /* { dg-error \"expected\" } */\n+\n+union [[]] u3 *uv; /* { dg-error \"expected\" } */\n+\n+enum e { E1 };\n+\n+enum [[]] e *ev; /* { dg-error \"expected\" } */"}, {"sha": "bd210864757dd609e22ccd86202753f81f81c9b2", "filename": "gcc/testsuite/gcc.dg/gnu2x-attr-syntax-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-attr-syntax-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-attr-syntax-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-attr-syntax-1.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -0,0 +1,16 @@\n+/* Test C2x attribute syntax.  Basic tests of valid uses of empty\n+   attributes with GNU C features.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x\" } */\n+\n+/* Attributes can be used in declarations after __extension__, and\n+   before asm statements.  */\n+\n+__extension__ [[]] int a;\n+\n+void\n+f (void)\n+{\n+  __extension__ [[]] int b;\n+  [[]] asm (\"\");\n+}"}, {"sha": "97d1654d9f6a02d507b0b7ee7a6ef1631dfa278d", "filename": "gcc/testsuite/gcc.dg/gnu2x-attr-syntax-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-attr-syntax-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-attr-syntax-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-attr-syntax-2.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -0,0 +1,16 @@\n+/* Test C2x attribute syntax.  Invalid uses of attributes with GNU C\n+   features.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x -w\" } */\n+\n+/* Attributes cannot be used as prefix attributes on old-style\n+   parameter declarations or on function declarators with identifier\n+   lists (removed from C2x).  */\n+\n+void (*f(a, b) [[]])() int a, b; { } /* { dg-error \"expected\" } */\n+\n+void f(x, y) int x; [[]] int y; { } /* { dg-error \"expected\" } */\n+\n+/* Nonempty attributes cannot be used as postfix attributes with\n+   __auto_type.  */\n+__auto_type [[gnu::no_such_attr]] x = 1; /* { dg-error \"'__auto_type' followed by\" } */"}, {"sha": "df22fb3d1b776d068da6755921c9b73ab20c3583", "filename": "gcc/testsuite/gcc.dg/gnu2x-attrs-1.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-attrs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-attrs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-attrs-1.c?ref=4e03c3a7c1149a8e43b7a2bfd927945cf1e90d19", "patch": "@@ -0,0 +1,72 @@\n+/* Test C2x attribute syntax.  Test GNU attributes appertain to\n+   appropriate constructs.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x\" } */\n+\n+void f (void) {};\n+\n+[[gnu::alias(\"f\")]] void g (void);\n+\n+void [[gnu::alias(\"f\")]] h (void); /* { dg-warning \"ignored\" } */\n+/* { dg-message \"that appertains to a type-specifier\" \"appertains\" { target *-*-* } .-1 } */\n+\n+struct [[gnu::packed]] s { int a; char b; };\n+_Static_assert (sizeof (struct s) == (sizeof (int) + sizeof (char)));\n+\n+int\n+f2 (void)\n+{\n+  [[gnu::deprecated]] int a = 1;\n+  return a; /* { dg-warning \"deprecated\" } */\n+}\n+\n+int\n+f3 (void)\n+{\n+  int a [[gnu::deprecated]] = 1;\n+  return a; /* { dg-warning \"deprecated\" } */\n+}\n+\n+struct s2 { [[gnu::deprecated]] int a; int b [[gnu::deprecated]]; } x;\n+\n+int\n+f4 (void)\n+{\n+  return x.a; /* { dg-warning \"deprecated\" } */\n+}\n+\n+int\n+f5 (void)\n+{\n+  return x.b; /* { dg-warning \"deprecated\" } */\n+}\n+\n+enum e { E1 [[gnu::deprecated]] };\n+\n+enum e\n+f6 (void)\n+{\n+  return E1; /* { dg-warning \"deprecated\" } */\n+}\n+\n+int\n+f7 ([[gnu::deprecated]] int y)\n+{\n+  return y; /* { dg-warning \"deprecated\" } */\n+}\n+\n+union [[gnu::deprecated]] u { int x; };\n+\n+void\n+f8 (void)\n+{\n+  union u var; /* { dg-warning \"deprecated\" } */\n+}\n+\n+enum [[gnu::deprecated]] edep { E2 };\n+\n+void\n+f9 (void)\n+{\n+  enum edep var; /* { dg-warning \"deprecated\" } */\n+}"}]}