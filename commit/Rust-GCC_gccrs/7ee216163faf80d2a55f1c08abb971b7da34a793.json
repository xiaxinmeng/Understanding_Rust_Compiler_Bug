{"sha": "7ee216163faf80d2a55f1c08abb971b7da34a793", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VlMjE2MTYzZmFmODBkMmE1NWYxYzA4YWJiOTcxYjdkYTM0YTc5Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-21T06:58:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-21T06:58:08Z"}, "message": "poly_int: reload1.c\n\nThis patch makes a few small poly_int64 changes to reload1.c,\nmostly related to eliminations.  Again, there's no real expectation\nthat reload will be used for targets that have polynomial-sized modes,\nbut it seemed easier to convert it anyway.\n\n2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* reload1.c (elim_table): Change initial_offset, offset and\n\tprevious_offset from HOST_WIDE_INT to poly_int64_pod.\n\t(offsets_at): Change the target array's element type from\n\tHOST_WIDE_INT to poly_int64_pod.\n\t(set_label_offsets, eliminate_regs_1, eliminate_regs_in_insn)\n\t(elimination_costs_in_insn, update_eliminable_offsets)\n\t(verify_initial_elim_offsets, set_offsets_for_label)\n\t(init_eliminable_invariants): Update after above changes.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255916", "tree": {"sha": "44cd2dc750abcdc111d0bb6a096c8b73d4af25f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44cd2dc750abcdc111d0bb6a096c8b73d4af25f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ee216163faf80d2a55f1c08abb971b7da34a793", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee216163faf80d2a55f1c08abb971b7da34a793", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ee216163faf80d2a55f1c08abb971b7da34a793", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ee216163faf80d2a55f1c08abb971b7da34a793/comments", "author": null, "committer": null, "parents": [{"sha": "0cb78959893b418d0e81d62b22e450a09a7ef958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cb78959893b418d0e81d62b22e450a09a7ef958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cb78959893b418d0e81d62b22e450a09a7ef958"}], "stats": {"total": 55, "additions": 35, "deletions": 20}, "files": [{"sha": "2d8d866e4fd948845240c272810524700df47290", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ee216163faf80d2a55f1c08abb971b7da34a793/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ee216163faf80d2a55f1c08abb971b7da34a793/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ee216163faf80d2a55f1c08abb971b7da34a793", "patch": "@@ -1,3 +1,16 @@\n+2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* reload1.c (elim_table): Change initial_offset, offset and\n+\tprevious_offset from HOST_WIDE_INT to poly_int64_pod.\n+\t(offsets_at): Change the target array's element type from\n+\tHOST_WIDE_INT to poly_int64_pod.\n+\t(set_label_offsets, eliminate_regs_1, eliminate_regs_in_insn)\n+\t(elimination_costs_in_insn, update_eliminable_offsets)\n+\t(verify_initial_elim_offsets, set_offsets_for_label)\n+\t(init_eliminable_invariants): Update after above changes.\n+\n 2017-12-21  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "0f90a4cb19ee7989108a63e8116a5391a16efdef", "filename": "gcc/reload1.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ee216163faf80d2a55f1c08abb971b7da34a793/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ee216163faf80d2a55f1c08abb971b7da34a793/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=7ee216163faf80d2a55f1c08abb971b7da34a793", "patch": "@@ -261,13 +261,13 @@ struct elim_table\n {\n   int from;\t\t\t/* Register number to be eliminated.  */\n   int to;\t\t\t/* Register number used as replacement.  */\n-  HOST_WIDE_INT initial_offset;\t/* Initial difference between values.  */\n+  poly_int64_pod initial_offset; /* Initial difference between values.  */\n   int can_eliminate;\t\t/* Nonzero if this elimination can be done.  */\n   int can_eliminate_previous;\t/* Value returned by TARGET_CAN_ELIMINATE\n \t\t\t\t   target hook in previous scan over insns\n \t\t\t\t   made by reload.  */\n-  HOST_WIDE_INT offset;\t\t/* Current offset between the two regs.  */\n-  HOST_WIDE_INT previous_offset;/* Offset at end of previous insn.  */\n+  poly_int64_pod offset;\t/* Current offset between the two regs.  */\n+  poly_int64_pod previous_offset; /* Offset at end of previous insn.  */\n   int ref_outside_mem;\t\t/* \"to\" has been referenced outside a MEM.  */\n   rtx from_rtx;\t\t\t/* REG rtx for the register to be eliminated.\n \t\t\t\t   We cannot simply compare the number since\n@@ -313,7 +313,7 @@ static int num_eliminable_invariants;\n \n static int first_label_num;\n static char *offsets_known_at;\n-static HOST_WIDE_INT (*offsets_at)[NUM_ELIMINABLE_REGS];\n+static poly_int64_pod (*offsets_at)[NUM_ELIMINABLE_REGS];\n \n vec<reg_equivs_t, va_gc> *reg_equivs;\n \n@@ -2351,9 +2351,9 @@ set_label_offsets (rtx x, rtx_insn *insn, int initial_p)\n \t   where the offsets disagree.  */\n \n \tfor (i = 0; i < NUM_ELIMINABLE_REGS; i++)\n-\t  if (offsets_at[CODE_LABEL_NUMBER (x) - first_label_num][i]\n-\t      != (initial_p ? reg_eliminate[i].initial_offset\n-\t\t  : reg_eliminate[i].offset))\n+\t  if (maybe_ne (offsets_at[CODE_LABEL_NUMBER (x) - first_label_num][i],\n+\t\t\t(initial_p ? reg_eliminate[i].initial_offset\n+\t\t\t : reg_eliminate[i].offset)))\n \t    reg_eliminate[i].can_eliminate = 0;\n \n       return;\n@@ -2436,7 +2436,7 @@ set_label_offsets (rtx x, rtx_insn *insn, int initial_p)\n       /* If we reach here, all eliminations must be at their initial\n \t offset because we are doing a jump to a variable address.  */\n       for (p = reg_eliminate; p < &reg_eliminate[NUM_ELIMINABLE_REGS]; p++)\n-\tif (p->offset != p->initial_offset)\n+\tif (maybe_ne (p->offset, p->initial_offset))\n \t  p->can_eliminate = 0;\n       break;\n \n@@ -2593,8 +2593,9 @@ eliminate_regs_1 (rtx x, machine_mode mem_mode, rtx insn,\n \t\t   We special-case the commonest situation in\n \t\t   eliminate_regs_in_insn, so just replace a PLUS with a\n \t\t   PLUS here, unless inside a MEM.  */\n-\t\tif (mem_mode != 0 && CONST_INT_P (XEXP (x, 1))\n-\t\t    && INTVAL (XEXP (x, 1)) == - ep->previous_offset)\n+\t\tif (mem_mode != 0\n+\t\t    && CONST_INT_P (XEXP (x, 1))\n+\t\t    && known_eq (INTVAL (XEXP (x, 1)), -ep->previous_offset))\n \t\t  return ep->to_rtx;\n \t\telse\n \t\t  return gen_rtx_PLUS (Pmode, ep->to_rtx,\n@@ -3344,7 +3345,7 @@ eliminate_regs_in_insn (rtx_insn *insn, int replace)\n   if (plus_cst_src)\n     {\n       rtx reg = XEXP (plus_cst_src, 0);\n-      HOST_WIDE_INT offset = INTVAL (XEXP (plus_cst_src, 1));\n+      poly_int64 offset = INTVAL (XEXP (plus_cst_src, 1));\n \n       if (GET_CODE (reg) == SUBREG)\n \treg = SUBREG_REG (reg);\n@@ -3364,7 +3365,7 @@ eliminate_regs_in_insn (rtx_insn *insn, int replace)\n \t       increase the cost of the insn by replacing a simple REG\n \t       with (plus (reg sp) CST).  So try only when we already\n \t       had a PLUS before.  */\n-\t    if (offset == 0 || plus_src)\n+\t    if (known_eq (offset, 0) || plus_src)\n \t      {\n \t\trtx new_src = plus_constant (GET_MODE (to_rtx),\n \t\t\t\t\t     to_rtx, offset);\n@@ -3562,12 +3563,12 @@ eliminate_regs_in_insn (rtx_insn *insn, int replace)\n \n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n-      if (ep->previous_offset != ep->offset && ep->ref_outside_mem)\n+      if (maybe_ne (ep->previous_offset, ep->offset) && ep->ref_outside_mem)\n \tep->can_eliminate = 0;\n \n       ep->ref_outside_mem = 0;\n \n-      if (ep->previous_offset != ep->offset)\n+      if (maybe_ne (ep->previous_offset, ep->offset))\n \tval = 1;\n     }\n \n@@ -3733,7 +3734,7 @@ elimination_costs_in_insn (rtx_insn *insn)\n \n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n-      if (ep->previous_offset != ep->offset && ep->ref_outside_mem)\n+      if (maybe_ne (ep->previous_offset, ep->offset) && ep->ref_outside_mem)\n \tep->can_eliminate = 0;\n \n       ep->ref_outside_mem = 0;\n@@ -3758,7 +3759,7 @@ update_eliminable_offsets (void)\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       ep->previous_offset = ep->offset;\n-      if (ep->can_eliminate && ep->offset != ep->initial_offset)\n+      if (ep->can_eliminate && maybe_ne (ep->offset, ep->initial_offset))\n \tnum_not_at_initial_offset++;\n     }\n }\n@@ -3812,7 +3813,7 @@ mark_not_eliminable (rtx dest, const_rtx x, void *data ATTRIBUTE_UNUSED)\n static bool\n verify_initial_elim_offsets (void)\n {\n-  HOST_WIDE_INT t;\n+  poly_int64 t;\n   struct elim_table *ep;\n \n   if (!num_eliminable)\n@@ -3822,7 +3823,7 @@ verify_initial_elim_offsets (void)\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, t);\n-      if (t != ep->initial_offset)\n+      if (maybe_ne (t, ep->initial_offset))\n \treturn false;\n     }\n \n@@ -3893,7 +3894,7 @@ set_offsets_for_label (rtx_insn *insn)\n     {\n       ep->offset = ep->previous_offset\n \t\t = offsets_at[label_nr - first_label_num][i];\n-      if (ep->can_eliminate && ep->offset != ep->initial_offset)\n+      if (ep->can_eliminate && maybe_ne (ep->offset, ep->initial_offset))\n \tnum_not_at_initial_offset++;\n     }\n }\n@@ -4095,7 +4096,8 @@ init_eliminable_invariants (rtx_insn *first, bool do_subregs)\n \n   /* Allocate the tables used to store offset information at labels.  */\n   offsets_known_at = XNEWVEC (char, num_labels);\n-  offsets_at = (HOST_WIDE_INT (*)[NUM_ELIMINABLE_REGS]) xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (HOST_WIDE_INT));\n+  offsets_at = (poly_int64_pod (*)[NUM_ELIMINABLE_REGS])\n+    xmalloc (num_labels * NUM_ELIMINABLE_REGS * sizeof (poly_int64));\n \n /* Look for REG_EQUIV notes; record what each pseudo is equivalent\n    to.  If DO_SUBREGS is true, also find all paradoxical subregs and"}]}