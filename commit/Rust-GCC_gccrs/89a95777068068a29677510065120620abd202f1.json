{"sha": "89a95777068068a29677510065120620abd202f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlhOTU3NzcwNjgwNjhhMjk2Nzc1MTAwNjUxMjA2MjBhYmQyMDJmMQ==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2007-06-19T19:04:52Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2007-06-19T19:04:52Z"}, "message": "df.h (DF_FIRST_OPTIONAL_PROBLEM): Removed.\n\n2007-06-15  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* df.h (DF_FIRST_OPTIONAL_PROBLEM): Removed.\n\t(struct df_problem.free_blocks_on_set_blocks): New field.\n\t(struct dataflow.optional_p): New field.\n\t(df_bb_regno_last_use_find, df_insn_regno_def_p): Removed.\n\t(df_live_set_all_dirty): New function.\n\t* df-scan.c (df_scan_alloc): Initialize optional_p.\n\t(problem_SCAN): Initialize free_blocks_on_set_blocks.\n\t* df-core.c (df_set_blocks): Removed use of\n\tDF_FIRST_OPTIONAL_PROBLEM.  Now uses\n\tdf_problem.free_blocks_on_set_blocks to determine which blocks are\n\trecycled.\n\t(df_remove_problem): Removed use of DF_FIRST_OPTIONAL_PROBLEM.\n\t(df_finish_pass): Removed use of DF_FIRST_OPTIONAL_PROBLEM.  Now\n\tuses dataflow.optional_p to determine if problem should be\n\tdeleted.\n\t(rest_of_handle_df_initialize): Only start live problem if \n\t-02 or above.\n\t(df_bb_regno_last_use_find, df_insn_regno_def_p): Removed.\n\t* df-problems.c (df_ru_alloc, df_rd_alloc, df_lr_alloc,\n\tdf_live_alloc, df_urec_alloc, df_note_alloc): set optional_p.\n\t(problem_RU, problem_RD, problem_LR, problem_UREC, problem_CHAIN,\n\tproblem_NOTE):  Initialize free_blocks_on_set_blocks.\n\t(df_lr_bb_local_compute): Recompute luids if df_live problem is\n\tnot active.\n\t(df_live_set_all_dirty, df_note_alloc): New function.\n\t* regrename.c (merge_overlapping_regs): Change DF_LIVE_* to\n\tdf_get_live_*.\n\t* sched_ebb.c (compute_jump_reg_dependencies): Ditto.\n\t* postreload.c (reload_combine): Ditto.\n\t* cse.c (cse_extended_basic_block): Ditto.\n\t* regmove.c (mark_flags_life_zones): Ditto.\n\t* rtlfactoring.c (split_blocks_after_seqs, split_pattern_seq,\n\terase_matching_seqs): Ditto.\n\t* bt-load.c (compute_defs_uses_and_gen): Ditto.\n\t* integrate (allocate_initial_values): Ditto.\n\t* combine.c (reg_dead_at_p): Ditto.\n\t* resource.c (mark_target_live_regs): Ditto.\n\t* sched-rgn.c (check_live_1, update_live_1): Ditto.\n\t* config/sh/sh.c (find_r0_life_regions): Ditto.\n\t* global.c (rest_of_handle_global_alloc): Only add back df_live\n\tfor -O > 1.\n\t* local-alloc.c (rest_of_handle_local_alloc): Only remove\n\tdf_live for -O > 1.\n\t* ifcvt.c (dead_or_predicable): Change DF_LIVE_* to\n\tdf_get_live_*.\n\t(if_convert): Make sure df_live is there at -O == 1.\n\t(pass_if_after_combine): Cleanup flags.\n\t* init-regs.c (initialize_uninitialized_regs): Make sure df_live\n\tis there at -O == 1.\n\nFrom-SVN: r125857", "tree": {"sha": "fa9997fc4e323fc1d4610bbda7d845966152ff14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa9997fc4e323fc1d4610bbda7d845966152ff14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89a95777068068a29677510065120620abd202f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89a95777068068a29677510065120620abd202f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89a95777068068a29677510065120620abd202f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89a95777068068a29677510065120620abd202f1/comments", "author": null, "committer": null, "parents": [{"sha": "a3a531ecfec77a9b0f30e1bce0c529c543aae332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3a531ecfec77a9b0f30e1bce0c529c543aae332", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3a531ecfec77a9b0f30e1bce0c529c543aae332"}], "stats": {"total": 355, "additions": 212, "deletions": 143}, "files": [{"sha": "2c19891b6ddb4d0bd15d0d0aab92ea46d0fce484", "filename": "gcc/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -1,3 +1,57 @@\n+<<<<<<< .mine\n+2007-06-15  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* df.h (DF_FIRST_OPTIONAL_PROBLEM): Removed.\n+\t(struct df_problem.free_blocks_on_set_blocks): New field.\n+\t(struct dataflow.optional_p): New field.\n+\t(df_bb_regno_last_use_find, df_insn_regno_def_p): Removed.\n+\t(df_live_set_all_dirty): New function.\n+\t* df-scan.c (df_scan_alloc): Initialize optional_p.\n+\t(problem_SCAN): Initialize free_blocks_on_set_blocks.\n+\t* df-core.c (df_set_blocks): Removed use of\n+\tDF_FIRST_OPTIONAL_PROBLEM.  Now uses\n+\tdf_problem.free_blocks_on_set_blocks to determine which blocks are\n+\trecycled.\n+\t(df_remove_problem): Removed use of DF_FIRST_OPTIONAL_PROBLEM.\n+\t(df_finish_pass): Removed use of DF_FIRST_OPTIONAL_PROBLEM.  Now\n+\tuses dataflow.optional_p to determine if problem should be\n+\tdeleted.\n+\t(rest_of_handle_df_initialize): Only start live problem if \n+\t-02 or above.\n+\t(df_bb_regno_last_use_find, df_insn_regno_def_p): Removed.\n+\t* df-problems.c (df_ru_alloc, df_rd_alloc, df_lr_alloc,\n+\tdf_live_alloc, df_urec_alloc, df_note_alloc): set optional_p.\n+\t(problem_RU, problem_RD, problem_LR, problem_UREC, problem_CHAIN,\n+\tproblem_NOTE):  Initialize free_blocks_on_set_blocks.\n+\t(df_lr_bb_local_compute): Recompute luids if df_live problem is\n+\tnot active.\n+\t(df_live_set_all_dirty, df_note_alloc): New function.\n+\t* regrename.c (merge_overlapping_regs): Change DF_LIVE_* to\n+\tdf_get_live_*.\n+\t* sched_ebb.c (compute_jump_reg_dependencies): Ditto.\n+\t* postreload.c (reload_combine): Ditto.\n+\t* cse.c (cse_extended_basic_block): Ditto.\n+\t* regmove.c (mark_flags_life_zones): Ditto.\n+\t* rtlfactoring.c (split_blocks_after_seqs, split_pattern_seq,\n+\terase_matching_seqs): Ditto.\n+\t* bt-load.c (compute_defs_uses_and_gen): Ditto.\n+\t* integrate (allocate_initial_values): Ditto.\n+\t* combine.c (reg_dead_at_p): Ditto.\n+\t* resource.c (mark_target_live_regs): Ditto.\n+\t* sched-rgn.c (check_live_1, update_live_1): Ditto.\n+\t* config/sh/sh.c (find_r0_life_regions): Ditto.\n+\t* global.c (rest_of_handle_global_alloc): Only add back df_live\n+\tfor -O > 1.\n+\t* local-alloc.c (rest_of_handle_local_alloc): Only remove\n+\tdf_live for -O > 1.\n+\t* ifcvt.c (dead_or_predicable): Change DF_LIVE_* to\n+\tdf_get_live_*.\n+\t(if_convert): Make sure df_live is there at -O == 1.\n+\t(pass_if_after_combine): Cleanup flags.\n+\t* init-regs.c (initialize_uninitialized_regs): Make sure df_live\n+\tis there at -O == 1.\n+\t\n+=======\n 2007-06-19  Seongbae Park  <seongbae.park@gmail.com>\n \n \t* config/arm/arm.c (arm_get_frame_offsets): Set\n@@ -44,6 +98,7 @@\n \t* config/frv/frv.c (frv_ifcvt_modify_tests): Dataflow merge fix.\n \t(frv_ifcvt_modify_insn): Likewise.\n \n+>>>>>>> .r125856\n 2007-06-19  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-structalias.c (handle_ptr_arith): Make sure to\n@@ -719,6 +774,7 @@\n \n        * df-scan.c (df_get_exit-block_use_set): Always add the stack pointer\n        to the exit block use set.\n+       (df_insn_delete, df_insn_rescan): Fixed spelling of \"deferring\". \n        * gcse.c (cpro_jump): Don't emit barrier in cfglayout mode.\n        * config/sparc/sparc.c (sparc_check_64): Check df != NULL.\n "}, {"sha": "fbb413561f332c6401fa05d05b7a94c352f140da", "filename": "gcc/bt-load.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -478,7 +478,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n       CLEAR_HARD_REG_SET (info.btrs_written_in_block);\n       for (reg = first_btr; reg <= last_btr; reg++)\n \tif (TEST_HARD_REG_BIT (all_btrs, reg)\n-\t    && REGNO_REG_SET_P (DF_LIVE_IN (bb), reg))\n+\t    && REGNO_REG_SET_P (df_get_live_in (bb), reg))\n \t  SET_HARD_REG_BIT (info.btrs_live_in_block, reg);\n \n       for (insn = BB_HEAD (bb), last = NEXT_INSN (BB_END (bb));\n@@ -579,7 +579,7 @@ compute_defs_uses_and_gen (fibheap_t all_btr_defs, btr_def *def_array,\n       COPY_HARD_REG_SET (btrs_live[i], info.btrs_live_in_block);\n       COPY_HARD_REG_SET (btrs_written[i], info.btrs_written_in_block);\n \n-      REG_SET_TO_HARD_REG_SET (btrs_live_at_end[i], DF_LIVE_OUT (bb));\n+      REG_SET_TO_HARD_REG_SET (btrs_live_at_end[i], df_get_live_out (bb));\n       /* If this block ends in a jump insn, add any uses or even clobbers\n \t of branch target registers that it might have.  */\n       for (insn = BB_END (bb); insn != BB_HEAD (bb) && ! INSN_P (insn); )"}, {"sha": "cb0d00f6f8234c2d8df1c64e94f734faebc9ded1", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -11835,7 +11835,7 @@ reg_dead_at_p (rtx reg, rtx insn)\n     }\n \n   for (i = reg_dead_regno; i < reg_dead_endregno; i++)\n-    if (REGNO_REG_SET_P (DF_LIVE_IN (block), i))\n+    if (REGNO_REG_SET_P (df_get_live_in (block), i))\n       return 0;\n \n   return 1;"}, {"sha": "60520f7871c2cb8d9dc0f7bed2d7c53a56090590", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -9159,7 +9159,7 @@ find_r0_life_regions (basic_block b)\n   int set;\n   int death = 0;\n \n-  if (REGNO_REG_SET_P (DF_LIVE_IN (b), R0_REG))\n+  if (REGNO_REG_SET_P (df_get_live_in (b), R0_REG))\n     {\n       set = 1;\n       live = 1;"}, {"sha": "431a4194bef0c6e54f87a35fa6c84324c8a99db8", "filename": "gcc/cse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -6001,8 +6001,8 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n   qty_table = XNEWVEC (struct qty_table_elem, max_qty);\n \n   new_basic_block ();\n-  cse_ebb_live_in = DF_LIVE_IN (ebb_data->path[0].bb);\n-  cse_ebb_live_out = DF_LIVE_OUT (ebb_data->path[path_size - 1].bb);\n+  cse_ebb_live_in = df_get_live_in (ebb_data->path[0].bb);\n+  cse_ebb_live_out = df_get_live_out (ebb_data->path[path_size - 1].bb);\n   for (path_entry = 0; path_entry < path_size; path_entry++)\n     {\n       basic_block bb;"}, {"sha": "deca87585309e37e624b87bc752eaf60912e8ae7", "filename": "gcc/df-core.c", "status": "modified", "additions": 37, "deletions": 92, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -506,15 +506,17 @@ df_set_blocks (bitmap blocks)\n \tbitmap_print (dump_file, blocks, \"setting blocks to analyze \", \"\\n\");\n       if (df->blocks_to_analyze)\n \t{\n+\t  /* This block is called to change the focus from one subset\n+\t     to another.  */\n \t  int p;\n \t  bitmap diff = BITMAP_ALLOC (&df_bitmap_obstack);\n \t  bitmap_and_compl (diff, df->blocks_to_analyze, blocks);\n-\t  for (p = df->num_problems_defined - 1; p >= DF_FIRST_OPTIONAL_PROBLEM ;p--)\n+\t  for (p = 0; p < df->num_problems_defined; p++)\n \t    {\n \t      struct dataflow *dflow = df->problems_in_order[p];\n-\t      if (dflow->problem->reset_fun)\n+\t      if (dflow->optional_p && dflow->problem->reset_fun)\n \t\tdflow->problem->reset_fun (df->blocks_to_analyze);\n-\t      else if (dflow->problem->free_bb_fun)\n+\t      else if (dflow->problem->free_blocks_on_set_blocks)\n \t\t{\n \t\t  bitmap_iterator bi;\n \t\t  unsigned int bb_index;\n@@ -539,42 +541,42 @@ df_set_blocks (bitmap blocks)\n \t}\n       else\n \t{\n-\t  /* If we have not actually run scanning before, do not try\n-\t     to clear anything.  */\n-\t  if (df_scan->problem_data)\n+\t  /* This block of code is executed to change the focus from\n+\t     the entire function to a subset.  */\n+\t  bitmap blocks_to_reset = NULL;\n+\t  int p;\n+\t  for (p = 0; p < df->num_problems_defined; p++)\n \t    {\n-\t      bitmap blocks_to_reset = NULL;\n-\t      int p;\n-\t      for (p = df->num_problems_defined - 1; p >= DF_FIRST_OPTIONAL_PROBLEM ;p--)\n+\t      struct dataflow *dflow = df->problems_in_order[p];\n+\t      if (dflow->optional_p && dflow->problem->reset_fun)\n \t\t{\n-\t\t  struct dataflow *dflow = df->problems_in_order[p];\n-\t\t  if (dflow->problem->reset_fun)\n+\t\t  if (!blocks_to_reset)\n \t\t    {\n-\t\t      if (!blocks_to_reset)\n+\t\t      basic_block bb;\n+\t\t      blocks_to_reset =\n+\t\t\tBITMAP_ALLOC (&df_bitmap_obstack);\n+\t\t      FOR_ALL_BB(bb)\n \t\t\t{\n-\t\t\t  basic_block bb;\n-\t\t\t  blocks_to_reset =\n-\t\t\t    BITMAP_ALLOC (&df_bitmap_obstack);\n-\t\t\t  FOR_ALL_BB(bb)\n-\t\t\t    {\n-\t\t\t      bitmap_set_bit (blocks_to_reset, bb->index); \n-\t\t\t    }\n+\t\t\t  bitmap_set_bit (blocks_to_reset, bb->index); \n \t\t\t}\n-\t\t      dflow->problem->reset_fun (blocks_to_reset);\n \t\t    }\n+\t\t  dflow->problem->reset_fun (blocks_to_reset);\n \t\t}\n-\t      if (blocks_to_reset)\n-\t\tBITMAP_FREE (blocks_to_reset);\n \t    }\n+\t  if (blocks_to_reset)\n+\t    BITMAP_FREE (blocks_to_reset);\n+\n \t  df->blocks_to_analyze = BITMAP_ALLOC (&df_bitmap_obstack);\n \t}\n       bitmap_copy (df->blocks_to_analyze, blocks);\n       df->analyze_subset = true;\n     }\n   else\n     {\n+      /* This block is executed to reset the focus to the entire\n+\t function.  */\n       if (dump_file)\n-\tfprintf (dump_file, \"clearing blocks to analyze\\n\");\n+\tfprintf (dump_file, \"clearing blocks_to_analyze\\n\");\n       if (df->blocks_to_analyze)\n \t{\n \t  BITMAP_FREE (df->blocks_to_analyze);\n@@ -599,26 +601,20 @@ df_remove_problem (struct dataflow *dflow)\n {\n   struct df_problem *problem;\n   int i;\n-  int start = 0;\n \n   if (!dflow)\n     return;\n \n   problem = dflow->problem;\n   gcc_assert (problem->remove_problem_fun);\n \n-  /* Normally only optional problems are removed, but during global,\n-     we remove ur and live and replace it with urec.  */\n-  if (problem->id >= DF_FIRST_OPTIONAL_PROBLEM)\n-    start = DF_FIRST_OPTIONAL_PROBLEM;\n-\n   /* Delete any problems that depended on this problem first.  */\n-  for (i = start; i < df->num_problems_defined; i++)\n+  for (i = 0; i < df->num_problems_defined; i++)\n     if (df->problems_in_order[i]->problem->dependent_problem == problem)\n       df_remove_problem (df->problems_in_order[i]);\n \n   /* Now remove this problem.  */\n-  for (i = start; i < df->num_problems_defined; i++)\n+  for (i = 0; i < df->num_problems_defined; i++)\n     if (df->problems_in_order[i] == dflow)\n       {\n \tint j;\n@@ -658,16 +654,19 @@ df_finish_pass (void)\n   saved_flags = df->changeable_flags;\n #endif\n \n-  for (i = DF_FIRST_OPTIONAL_PROBLEM; i < df->num_problems_defined; i++)\n+  for (i = 0; i < df->num_problems_defined; i++)\n     {\n       struct dataflow *dflow = df->problems_in_order[i];\n       struct df_problem *problem = dflow->problem;\n \n-      gcc_assert (problem->remove_problem_fun);\n-      (problem->remove_problem_fun) ();\n-      df->problems_in_order[i] = NULL;\n-      df->problems_by_index[problem->id] = NULL;\n-      removed++;\n+      if (dflow->optional_p)\n+\t{\n+\t  gcc_assert (problem->remove_problem_fun);\n+\t  (problem->remove_problem_fun) ();\n+\t  df->problems_in_order[i] = NULL;\n+\t  df->problems_by_index[problem->id] = NULL;\n+\t  removed++;\n+\t}\n     }\n   df->num_problems_defined -= removed;\n \n@@ -720,7 +719,7 @@ rest_of_handle_df_initialize (void)\n \n   /* These three problems are permanent.  */\n   df_lr_add_problem ();\n-  if (optimize)\n+  if (optimize > 1)\n     df_live_add_problem ();\n \n   df->postorder = XNEWVEC (int, last_basic_block);\n@@ -1600,40 +1599,6 @@ df_set_clean_cfg (void)\n ----------------------------------------------------------------------------*/\n \n \n-/* Return last use of REGNO within BB.  */\n-\n-struct df_ref *\n-df_bb_regno_last_use_find (basic_block bb, unsigned int regno)\n-{\n-  rtx insn;\n-  struct df_ref **use_rec;\n-  unsigned int uid;\n-\n-  FOR_BB_INSNS_REVERSE (bb, insn)\n-    {\n-      if (!INSN_P (insn))\n-\tcontinue;\n-\n-      uid = INSN_UID (insn);\n-      for (use_rec = DF_INSN_UID_USES (uid); *use_rec; use_rec++)\n-\t{\n-\t  struct df_ref *use = *use_rec;\n-\t  if (DF_REF_REGNO (use) == regno)\n-\t    return use;\n-\t}\n-\n-      if (df->changeable_flags & DF_EQ_NOTES)\n-\tfor (use_rec = DF_INSN_UID_EQ_USES (uid); *use_rec; use_rec++)\n-\t  {\n-\t    struct df_ref *use = *use_rec;\n-\t    if (DF_REF_REGNO (use) == regno)\n-\t      return use;\n-\t  }\n-    }\n-  return NULL;\n-}\n-\n-\n /* Return first def of REGNO within BB.  */\n \n struct df_ref *\n@@ -1686,26 +1651,6 @@ df_bb_regno_last_def_find (basic_block bb, unsigned int regno)\n   return NULL;\n }\n \n-/* Return true if INSN defines REGNO.  */\n-\n-bool\n-df_insn_regno_def_p (rtx insn, unsigned int regno)\n-{\n-  unsigned int uid;\n-  struct df_ref **def_rec;\n-\n-  uid = INSN_UID (insn);\n-  for (def_rec = DF_INSN_UID_DEFS (uid); *def_rec; def_rec++)\n-    {\n-      struct df_ref *def = *def_rec;\n-      if (DF_REF_REGNO (def) == regno)\n-\treturn true;\n-    }\n-  \n-  return false;\n-}\n-\n-\n /* Finds the reference corresponding to the definition of REG in INSN.\n    DF is the dataflow object.  */\n "}, {"sha": "101b46f58e32d14b9a559cc60e06403c11b30915", "filename": "gcc/df-problems.c", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -331,6 +331,7 @@ df_ru_alloc (bitmap all_blocks)\n \t  bb_info->out = BITMAP_ALLOC (&problem_data->ru_bitmaps);\n \t}\n     }\n+  df_ru->optional_p = true;\n }\n \n \n@@ -711,7 +712,8 @@ static struct df_problem problem_RU =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verfiy end.  */\n   NULL,                       /* Dependent problem.  */\n-  TV_DF_RU                    /* Timing variable.  */ \n+  TV_DF_RU,                   /* Timing variable.  */\n+  true                        /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n \n@@ -841,6 +843,7 @@ df_rd_alloc (bitmap all_blocks)\n \t  bb_info->out = BITMAP_ALLOC (&problem_data->rd_bitmaps);\n \t}\n     }\n+  df_rd->optional_p = true;\n }\n \n \n@@ -1207,7 +1210,8 @@ static struct df_problem problem_RD =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verfiy end.  */\n   NULL,                       /* Dependent problem.  */\n-  TV_DF_RD                    /* Timing variable.  */ \n+  TV_DF_RD,                   /* Timing variable.  */ \n+  true                        /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n \n@@ -1320,6 +1324,8 @@ df_lr_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n           bb_info->ause = NULL;\n \t}\n     }\n+\n+  df_lr->optional_p = false;\n }\n \n \n@@ -1478,6 +1484,13 @@ df_lr_bb_local_compute (unsigned int bb_index)\n \t}\n     }\n #endif\n+\n+  /* If the df_live problem is not defined, such as at -O0 and -O1, we\n+     still need to keep the luids up to date.  This is normally done\n+     in the df_live problem since this problem has a forwards\n+     scan.  */\n+  if (!df_live)\n+    df_recompute_luids (bb);\n }\n \n \n@@ -1818,7 +1831,8 @@ static struct df_problem problem_LR =\n   df_lr_verify_solution_start,/* Incremental solution verify start.  */\n   df_lr_verify_solution_end,  /* Incremental solution verify end.  */\n   NULL,                       /* Dependent problem.  */\n-  TV_DF_LR                    /* Timing variable.  */ \n+  TV_DF_LR,                   /* Timing variable.  */ \n+  false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n \n@@ -2016,6 +2030,7 @@ df_live_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n \t  bb_info->out = BITMAP_ALLOC (NULL);\n \t}\n     }\n+  df_live->optional_p = (optimize <= 1);\n }\n \n \n@@ -2368,7 +2383,8 @@ static struct df_problem problem_LIVE =\n   df_live_verify_solution_start,/* Incremental solution verify start.  */\n   df_live_verify_solution_end,  /* Incremental solution verify end.  */\n   &problem_LR,                  /* Dependent problem.  */\n-  TV_DF_LIVE                    /* Timing variable.  */ \n+  TV_DF_LIVE,                   /* Timing variable.  */\n+  false                         /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n \n@@ -2386,6 +2402,19 @@ df_live_add_problem (void)\n }\n \n \n+/* Set all of the blocks as dirty.  This needs to be done if this\n+   problem is added after all of the insns have been scanned.  */\n+\n+void\n+df_live_set_all_dirty (void)\n+{\n+  basic_block bb;\n+  FOR_ALL_BB (bb)\n+    bitmap_set_bit (df_live->out_of_date_transfer_functions, \n+\t\t    bb->index);\n+}\n+\n+\n /* Verify that all of the lr related info is consistent and\n    correct.  */\n \n@@ -2555,6 +2584,7 @@ df_urec_alloc (bitmap all_blocks)\n \t  bb_info->earlyclobber = BITMAP_ALLOC (NULL);\n \t}\n     }\n+  df_urec->optional_p = true;\n }\n \n \n@@ -3041,7 +3071,8 @@ static struct df_problem problem_UREC =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verfiy end.  */\n   &problem_LR,                /* Dependent problem.  */\n-  TV_DF_UREC                  /* Timing variable.  */ \n+  TV_DF_UREC,                 /* Timing variable.  */ \n+  false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n \n@@ -3213,6 +3244,7 @@ df_chain_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   df_chain_remove_problem ();\n   df_chain->block_pool = create_alloc_pool (\"df_chain_block pool\", \n \t\t\t\t\t sizeof (struct df_link), 50);\n+  df_chain->optional_p = true;\n }\n \n \n@@ -3520,7 +3552,8 @@ static struct df_problem problem_CHAIN =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verfiy end.  */\n   &problem_RD,                /* Dependent problem.  */\n-  TV_DF_CHAIN                 /* Timing variable.  */ \n+  TV_DF_CHAIN,                /* Timing variable.  */\n+  false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n \n@@ -3543,6 +3576,12 @@ df_chain_add_problem (enum df_chain_flags chain_flags)\n    This pass computes REG_DEAD and REG_UNUSED notes.\n    ----------------------------------------------------------------------------*/\n \n+static void \n+df_note_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n+{\n+  df_note->optional_p = true;\n+}\n+\n #ifdef REG_DEAD_DEBUGGING\n static void \n df_print_note (const char *prefix, rtx insn, rtx note)\n@@ -4077,7 +4116,7 @@ static struct df_problem problem_NOTE =\n {\n   DF_NOTE,                    /* Problem id.  */\n   DF_NONE,                    /* Direction.  */\n-  NULL,                       /* Allocate the problem specific data.  */\n+  df_note_alloc,              /* Allocate the problem specific data.  */\n   NULL,                       /* Reset global information.  */\n   NULL,                       /* Free basic block info.  */\n   df_note_compute,            /* Local compute function.  */\n@@ -4099,7 +4138,8 @@ static struct df_problem problem_NOTE =\n      but it will produce information if built one of uninitialized\n      register problems (UR, UREC) is also run.  */\n   &problem_LR,                /* Dependent problem.  */\n-  TV_DF_NOTE                  /* Timing variable.  */ \n+  TV_DF_NOTE,                 /* Timing variable.  */\n+  false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n "}, {"sha": "fff621f0261dc2f955be00cdb9297a4c3dc5e1fa", "filename": "gcc/df-scan.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -341,6 +341,7 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   df->insns_to_delete = BITMAP_ALLOC (&problem_data->insn_bitmaps);\n   df->insns_to_rescan = BITMAP_ALLOC (&problem_data->insn_bitmaps);\n   df->insns_to_notes_rescan = BITMAP_ALLOC (&problem_data->insn_bitmaps);\n+  df_scan->optional_p = false;\n }\n \n \n@@ -434,7 +435,8 @@ static struct df_problem problem_SCAN =\n   NULL,                       /* Incremental solution verify start.  */\n   NULL,                       /* Incremental solution verfiy end.  */\n   NULL,                       /* Dependent problem.  */\n-  TV_DF_SCAN                  /* Timing variable.  */\n+  TV_DF_SCAN,                 /* Timing variable.  */\n+  false                       /* Reset blocks on dropping out of blocks_to_analyze.  */\n };\n \n "}, {"sha": "5c510eec6f96c660d6bab2a7f33a876d94a8c41f", "filename": "gcc/df.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -52,7 +52,6 @@ struct df_link;\n #define DF_NOTE  7      /* REG_DEF and REG_UNUSED notes. */\n \n #define DF_LAST_PROBLEM_PLUS1 (DF_NOTE + 1)\n-#define DF_FIRST_OPTIONAL_PROBLEM DF_RU\n \n /* Dataflow direction.  */\n enum df_flow_dir\n@@ -249,8 +248,13 @@ struct df_problem {\n   df_verify_solution_start verify_start_fun;\n   df_verify_solution_end verify_end_fun;\n   struct df_problem *dependent_problem;\n+\n   /* The timevar id associated with this pass.  */\n   unsigned int tv_id;\n+\n+  /* True if the df_set_blocks should null out the basic block info if\n+     this block drops out of df->blocks_to_analyze.  */\n+  bool free_blocks_on_set_blocks;\n };\n \n \n@@ -293,6 +297,11 @@ struct dataflow\n      solutions.  Note that this bit is always true for all problems except \n      lr and live.  */\n   bool solutions_dirty;\n+\n+  /* If true, this pass is deleted by df_finish_pass.  This is never\n+     true for DF_SCAN and DF_LR.  It is true for DF_LIVE if optimize >\n+     1.  It is always true for the other problems.  */\n+  bool optional_p;\n };\n \n \n@@ -837,10 +846,8 @@ extern void df_verify (void);\n #ifdef DF_DEBUG_CFG\n extern void df_check_cfg_clean (void);\n #endif\n-extern struct df_ref *df_bb_regno_last_use_find (basic_block, unsigned int);\n extern struct df_ref *df_bb_regno_first_def_find (basic_block, unsigned int);\n extern struct df_ref *df_bb_regno_last_def_find (basic_block, unsigned int);\n-extern bool df_insn_regno_def_p (rtx, unsigned int);\n extern struct df_ref *df_find_def (rtx, rtx);\n extern bool df_reg_defined (rtx, rtx);\n extern struct df_ref *df_find_use (rtx, rtx);\n@@ -882,6 +889,7 @@ extern void df_lr_add_problem (void);\n extern void df_lr_verify_transfer_functions (void);\n extern void df_live_verify_transfer_functions (void);\n extern void df_live_add_problem (void);\n+extern void df_live_set_all_dirty (void);\n extern void df_urec_add_problem (void);\n extern void df_chain_add_problem (enum df_chain_flags);\n extern void df_note_add_problem (void);"}, {"sha": "62b7b6273e381ee94307b8569fff3432fb632e40", "filename": "gcc/global.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -2080,7 +2080,7 @@ rest_of_handle_global_alloc (void)\n      going to help here because it does not touch the artificial uses\n      and defs.  */\n   df_finish_pass ();\n-  if (optimize)\n+  if (optimize > 1)\n     df_live_add_problem ();\n   df_scan_alloc (NULL);\n   df_scan_blocks ();"}, {"sha": "dd7764b921f0ba4ebdce7659e8bb3b31da532307", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -3836,7 +3836,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n       \n       /* The loop below takes the set of live registers \n          after JUMP, and calculates the live set before EARLIEST. */\n-      bitmap_copy (test_live, DF_LIVE_IN (other_bb));\n+      bitmap_copy (test_live, df_get_live_in (other_bb));\n       df_simulate_artificial_refs_at_end (test_bb, test_live);\n       for (insn = jump; ; insn = prev)\n \t{\n@@ -3858,7 +3858,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n       if (bitmap_intersect_p (test_set, merge_set)\n \t  || bitmap_intersect_p (test_live, merge_set)\n-\t  || bitmap_intersect_p (test_set, DF_LIVE_IN (merge_bb)))\n+\t  || bitmap_intersect_p (test_set, df_get_live_in (merge_bb)))\n \tfail = 1;\n \n       BITMAP_FREE (merge_set);\n@@ -3958,6 +3958,12 @@ if_convert (bool recompute_dominance)\n   basic_block bb;\n   int pass;\n \n+  if (optimize == 1)\n+    {\n+      df_live_add_problem ();\n+      df_live_set_all_dirty ();\n+    }\n+\n   num_possible_if_blocks = 0;\n   num_updated_if_blocks = 0;\n   num_true_changes = 0;\n@@ -4039,6 +4045,9 @@ if_convert (bool recompute_dominance)\n \t       num_true_changes);\n     }\n \n+  if (optimize == 1)\n+    df_remove_problem (df_live);\n+\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n@@ -4125,14 +4134,13 @@ struct tree_opt_pass pass_if_after_combine =\n static bool\n gate_handle_if_after_reload (void)\n {\n-  return (optimize > 0);\n+  return (optimize > 0 && flag_if_conversion2);\n }\n \n static unsigned int\n rest_of_handle_if_after_reload (void)\n {\n-  if (flag_if_conversion2)\n-    if_convert (true);\n+  if_convert (true);\n   return 0;\n }\n "}, {"sha": "7e4d0565122e5ae48d59d465b6d9602e580aeb01", "filename": "gcc/init-regs.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Finit-regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Finit-regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finit-regs.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -53,6 +53,12 @@ initialize_uninitialized_regs (void)\n   basic_block bb;\n   bitmap already_genned = BITMAP_ALLOC (NULL);\n \n+  if (optimize == 1)\n+    {\n+      df_live_add_problem ();\n+      df_live_set_all_dirty ();\n+    }\n+\n   df_analyze ();\n \n   FOR_EACH_BB (bb)\n@@ -111,6 +117,9 @@ initialize_uninitialized_regs (void)\n \t}\n     }\n \n+  if (optimize == 1)\n+    df_remove_problem (df_live);\n+\n   BITMAP_FREE (already_genned);\n }\n "}, {"sha": "fb893ddb00ed460c84660e64b291684565c71699", "filename": "gcc/integrate.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -352,10 +352,10 @@ allocate_initial_values (rtx *reg_equiv_memory_loc)\n \t\t  /* Update global register liveness information.  */\n \t\t  FOR_EACH_BB (bb)\n \t\t    {\n-\t\t      if (REGNO_REG_SET_P(DF_LIVE_IN (bb), regno))\n-\t\t\tSET_REGNO_REG_SET (DF_LIVE_IN (bb), new_regno);\n-\t\t      if (REGNO_REG_SET_P(DF_LIVE_OUT (bb), regno))\n-\t\t\tSET_REGNO_REG_SET (DF_LIVE_OUT (bb), new_regno);\n+\t\t      if (REGNO_REG_SET_P(df_get_live_in (bb), regno))\n+\t\t\tSET_REGNO_REG_SET (df_get_live_in (bb), new_regno);\n+\t\t      if (REGNO_REG_SET_P(df_get_live_out (bb), regno))\n+\t\t\tSET_REGNO_REG_SET (df_get_live_out (bb), new_regno);\n \t\t    }\n \t\t}\n \t    }"}, {"sha": "59ee52fd3c0a150cf93186cb704a08ee2f09cdcc", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -2509,13 +2509,13 @@ rest_of_handle_local_alloc (void)\n   int max_regno = max_reg_num ();\n \n   df_note_add_problem ();\n+\n+  if (optimize > 1)\n+    df_remove_problem (df_live);\n+  /* Create a new version of df that has the special version of UR if\n+     we are doing optimization.  */\n   if (optimize)\n-    {\n-      /* Create a new version of df that has the special version of UR\n-\t if we are doing optimization.  */\n-      df_remove_problem (df_live);\n-      df_urec_add_problem ();\n-    }\n+    df_urec_add_problem ();\n   df_analyze ();\n   regstat_init_n_sets_and_refs ();\n   regstat_compute_ri ();"}, {"sha": "3894efaec8f03caf6498f60c443035d7a8f77a3d", "filename": "gcc/postreload.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -743,9 +743,10 @@ reload_combine (void)\n       if (LABEL_P (insn))\n \t{\n \t  HARD_REG_SET live;\n+\t  bitmap live_in = df_get_live_in (bb);\n \n-\t  REG_SET_TO_HARD_REG_SET (live, DF_LIVE_IN (bb));\n-\t  compute_use_by_pseudos (&live, DF_LIVE_IN (bb));\n+\t  REG_SET_TO_HARD_REG_SET (live, live_in);\n+\t  compute_use_by_pseudos (&live, live_in);\n \t  COPY_HARD_REG_SET (LABEL_LIVE (insn), live);\n \t  IOR_HARD_REG_SET (ever_live_at_start, live);\n \t}"}, {"sha": "067940f4b7c4df5c90018e30b3186ce57bde2444", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -325,7 +325,7 @@ mark_flags_life_zones (rtx flags)\n       {\n \tint i;\n \tfor (i = 0; i < flags_nregs; ++i)\n-\t  live |= REGNO_REG_SET_P (DF_LIVE_IN (block), flags_regno + i);\n+\t  live |= REGNO_REG_SET_P (df_get_live_in (block), flags_regno + i);\n       }\n #endif\n "}, {"sha": "8fdc74e92ab15c130c691a1a6335805a48415e03", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -139,7 +139,7 @@ merge_overlapping_regs (basic_block b, HARD_REG_SET *pset,\n   rtx insn;\n   HARD_REG_SET live;\n \n-  REG_SET_TO_HARD_REG_SET (live, DF_LIVE_IN (b));\n+  REG_SET_TO_HARD_REG_SET (live, df_get_live_in (b));\n   insn = BB_HEAD (b);\n   while (t)\n     {"}, {"sha": "6f9456f038306bf5a22f80eb6edf425f9b8ea804", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -957,7 +957,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n      TARGET.  Otherwise, we must assume everything is live.  */\n   if (b != -1)\n     {\n-      regset regs_live = DF_LIVE_IN (BASIC_BLOCK (b));\n+      regset regs_live = df_get_live_in (BASIC_BLOCK (b));\n       rtx start_insn, stop_insn;\n       reg_set_iterator rsi;\n "}, {"sha": "6e37df7bced7579951ced9947825c527a334ae1d", "filename": "gcc/rtl-factoring.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Frtl-factoring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Frtl-factoring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-factoring.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -978,8 +978,8 @@ split_blocks_after_seqs (void)\n       for (mseq = sb->matching_seqs; mseq; mseq = mseq->next_matching_seq)\n         {\n           block_label_after (mseq->insn);\n-          IOR_REG_SET (DF_LIVE_OUT (BLOCK_FOR_INSN (pattern_seqs->insn)),\n-                       DF_LIVE_OUT (BLOCK_FOR_INSN (mseq->insn)));\n+          IOR_REG_SET (df_get_live_out (BLOCK_FOR_INSN (pattern_seqs->insn)),\n+                       df_get_live_out (BLOCK_FOR_INSN (mseq->insn)));\n         }\n     }\n }\n@@ -1033,7 +1033,7 @@ split_pattern_seq (void)\n                               gen_symbol_ref_rtx_for_label\n                               (retlabel)), BB_END (bb));\n   /* Update liveness info.  */\n-  SET_REGNO_REG_SET (DF_LIVE_OUT (bb),\n+  SET_REGNO_REG_SET (df_get_live_out (bb),\n                      REGNO (pattern_seqs->link_reg));\n }\n \n@@ -1085,12 +1085,12 @@ erase_matching_seqs (void)\n           BB_END (bb) = callinsn;\n \n           /* Maintain control flow and liveness information.  */\n-          SET_REGNO_REG_SET (DF_LIVE_OUT (bb),\n+          SET_REGNO_REG_SET (df_get_live_out (bb),\n                              REGNO (pattern_seqs->link_reg));\n           emit_barrier_after (BB_END (bb));\n           make_single_succ_edge (bb, BLOCK_FOR_INSN (sb->label), 0);\n-          IOR_REG_SET (DF_LIVE_OUT (bb),\n-\t\t       DF_LIVE_IN (BLOCK_FOR_INSN (sb->label)));\n+          IOR_REG_SET (df_get_live_out (bb),\n+\t\t       df_get_live_in (BLOCK_FOR_INSN (sb->label)));\n \n           make_edge (BLOCK_FOR_INSN (seq_blocks->label),\n                      BLOCK_FOR_INSN (retlabel), EDGE_ABNORMAL);"}, {"sha": "b03655d889f71afe47e9604f6f5e968be519e28e", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -252,9 +252,9 @@ compute_jump_reg_dependencies (rtx insn, regset cond_set, regset used,\n \t it may guard the fallthrough block from using a value that has\n \t conditionally overwritten that of the main codepath.  So we\n \t consider that it restores the value of the main codepath.  */\n-      bitmap_and (set, DF_LIVE_IN (e->dest), cond_set);\n+      bitmap_and (set, df_get_live_in (e->dest), cond_set);\n     else\n-      bitmap_ior_into (used, DF_LIVE_IN (e->dest));\n+      bitmap_ior_into (used, df_get_live_in (e->dest));\n }\n \n /* Used in schedule_insns to initialize current_sched_info for scheduling"}, {"sha": "0bb69ee4cdc9207d581a5020ead91dcb68735959", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89a95777068068a29677510065120620abd202f1/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89a95777068068a29677510065120620abd202f1/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=89a95777068068a29677510065120620abd202f1", "patch": "@@ -1551,7 +1551,7 @@ check_live_1 (int src, rtx x)\n \t\t  gcc_assert (!t || (CONTAINING_RGN (b->index)\n \t\t\t\t     != CONTAINING_RGN (BB_TO_BLOCK (src))));\n \n-\t\t  if (t || REGNO_REG_SET_P (DF_LIVE_IN (b), regno + j))\n+\t\t  if (t || REGNO_REG_SET_P (df_get_live_in (b), regno + j))\n \t\t    return 0;\n \t\t}\n \t    }\n@@ -1567,7 +1567,7 @@ check_live_1 (int src, rtx x)\n \t      gcc_assert (!t || (CONTAINING_RGN (b->index)\n \t\t\t\t != CONTAINING_RGN (BB_TO_BLOCK (src))));\n \n-\t      if (t || REGNO_REG_SET_P (DF_LIVE_IN (b), regno))\n+\t      if (t || REGNO_REG_SET_P (df_get_live_in (b), regno))\n \t\treturn 0;\n \t    }\n \t}\n@@ -1624,7 +1624,7 @@ update_live_1 (int src, rtx x)\n \t\t{\n \t\t  basic_block b = candidate_table[src].update_bbs.first_member[i];\n \n-\t\t  SET_REGNO_REG_SET (DF_LIVE_IN (b), regno + j);\n+\t\t  SET_REGNO_REG_SET (df_get_live_in (b), regno + j);\n \t\t}\n \t    }\n \t}\n@@ -1634,7 +1634,7 @@ update_live_1 (int src, rtx x)\n \t    {\n \t      basic_block b = candidate_table[src].update_bbs.first_member[i];\n \n-\t      SET_REGNO_REG_SET (DF_LIVE_IN (b), regno);\n+\t      SET_REGNO_REG_SET (df_get_live_in (b), regno);\n \t    }\n \t}\n     }"}]}