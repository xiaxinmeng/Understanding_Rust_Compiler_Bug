{"sha": "8ccaff35d4219fa37ca83d9021710a5c4e532221", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNjYWZmMzVkNDIxOWZhMzdjYTgzZDkwMjE3MTBhNWM0ZTUzMjIyMQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-01T00:15:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-12-01T00:15:16Z"}, "message": "compiler: Fix bug converting unnamed types with placeholders.\n\nFrom-SVN: r194011", "tree": {"sha": "59495828e8a05f4e1adb622a228fcd3623f6acf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59495828e8a05f4e1adb622a228fcd3623f6acf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ccaff35d4219fa37ca83d9021710a5c4e532221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ccaff35d4219fa37ca83d9021710a5c4e532221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ccaff35d4219fa37ca83d9021710a5c4e532221", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ccaff35d4219fa37ca83d9021710a5c4e532221/comments", "author": null, "committer": null, "parents": [{"sha": "55ad8d77abea762498975abf81dc029a97957a6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55ad8d77abea762498975abf81dc029a97957a6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55ad8d77abea762498975abf81dc029a97957a6d"}], "stats": {"total": 155, "additions": 98, "deletions": 57}, "files": [{"sha": "c79181b7a60ca88ed2d66fdfb35d39fe2f00a764", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 86, "deletions": 50, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccaff35d4219fa37ca83d9021710a5c4e532221/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccaff35d4219fa37ca83d9021710a5c4e532221/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=8ccaff35d4219fa37ca83d9021710a5c4e532221", "patch": "@@ -45,8 +45,7 @@ get_backend_interface_fields(Gogo* gogo, Interface_type* type,\n // Class Type.\n \n Type::Type(Type_classification classification)\n-  : classification_(classification), btype_is_placeholder_(false),\n-    btype_(NULL), type_descriptor_var_(NULL)\n+  : classification_(classification), btype_(NULL), type_descriptor_var_(NULL)\n {\n }\n \n@@ -910,11 +909,7 @@ Btype*\n Type::get_backend(Gogo* gogo)\n {\n   if (this->btype_ != NULL)\n-    {\n-      if (this->btype_is_placeholder_ && gogo->named_types_are_converted())\n-\tthis->finish_backend(gogo);\n-      return this->btype_;\n-    }\n+    return this->btype_;\n \n   if (this->forward_declaration_type() != NULL\n       || this->named_type() != NULL)\n@@ -928,31 +923,46 @@ Type::get_backend(Gogo* gogo)\n   // that.  There is no need to use the hash table for named types, as\n   // named types are only identical to themselves.\n \n-  std::pair<Type*, Btype*> val(this, NULL);\n+  std::pair<Type*, Type_btype_entry> val;\n+  val.first = this;\n+  val.second.btype = NULL;\n+  val.second.is_placeholder = false;\n   std::pair<Type_btypes::iterator, bool> ins =\n     Type::type_btypes.insert(val);\n-  if (!ins.second && ins.first->second != NULL)\n+  if (!ins.second && ins.first->second.btype != NULL)\n     {\n-      if (gogo != NULL && gogo->named_types_are_converted())\n-\tthis->btype_ = ins.first->second;\n-      return ins.first->second;\n+      // Note that GOGO can be NULL here, but only when the GCC\n+      // middle-end is asking for a frontend type.  That will only\n+      // happen for simple types, which should never require\n+      // placeholders.\n+      if (!ins.first->second.is_placeholder)\n+\tthis->btype_ = ins.first->second.btype;\n+      else if (gogo->named_types_are_converted())\n+\t{\n+\t  this->finish_backend(gogo, ins.first->second.btype);\n+\t  ins.first->second.is_placeholder = false;\n+\t}\n+\n+      return ins.first->second.btype;\n     }\n \n   Btype* bt = this->get_btype_without_hash(gogo);\n \n-  if (ins.first->second == NULL)\n-    ins.first->second = bt;\n+  if (ins.first->second.btype == NULL)\n+    {\n+      ins.first->second.btype = bt;\n+      ins.first->second.is_placeholder = false;\n+    }\n   else\n     {\n       // We have already created a backend representation for this\n       // type.  This can happen when an unnamed type is defined using\n       // a named type which in turns uses an identical unnamed type.\n       // Use the tree we created earlier and ignore the one we just\n       // built.\n-      bt = ins.first->second;\n-      if (gogo == NULL || !gogo->named_types_are_converted())\n-\treturn bt;\n-      this->btype_ = bt;\n+      if (this->btype_ == bt)\n+\tthis->btype_ = ins.first->second.btype;\n+      bt = ins.first->second.btype;\n     }\n \n   return bt;\n@@ -1019,6 +1029,37 @@ Type::get_backend_placeholder(Gogo* gogo)\n       // These are simple types that can just be created directly.\n       return this->get_backend(gogo);\n \n+    case TYPE_MAP:\n+    case TYPE_CHANNEL:\n+      // All maps and channels have the same backend representation.\n+      return this->get_backend(gogo);\n+\n+    case TYPE_NAMED:\n+    case TYPE_FORWARD:\n+      // Named types keep track of their own dependencies and manage\n+      // their own placeholders.\n+      return this->get_backend(gogo);\n+\n+    case TYPE_INTERFACE:\n+      if (this->interface_type()->is_empty())\n+\treturn Interface_type::get_backend_empty_interface_type(gogo);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  std::pair<Type*, Type_btype_entry> val;\n+  val.first = this;\n+  val.second.btype = NULL;\n+  val.second.is_placeholder = false;\n+  std::pair<Type_btypes::iterator, bool> ins =\n+    Type::type_btypes.insert(val);\n+  if (!ins.second && ins.first->second.btype != NULL)\n+    return ins.first->second.btype;\n+\n+  switch (this->classification_)\n+    {\n     case TYPE_FUNCTION:\n       {\n \tLocation loc = this->function_type()->location();\n@@ -1061,50 +1102,45 @@ Type::get_backend_placeholder(Gogo* gogo)\n \t}\n       break;\n \t\n-    case TYPE_MAP:\n-    case TYPE_CHANNEL:\n-      // All maps and channels have the same backend representation.\n-      return this->get_backend(gogo);\n-\n     case TYPE_INTERFACE:\n-      if (this->interface_type()->is_empty())\n-\treturn Interface_type::get_backend_empty_interface_type(gogo);\n-      else\n-\t{\n-\t  std::vector<Backend::Btyped_identifier> bfields;\n-\t  get_backend_interface_fields(gogo, this->interface_type(), true,\n-\t\t\t\t       &bfields);\n-\t  bt = gogo->backend()->struct_type(bfields);\n-\t}\n+      {\n+\tgo_assert(!this->interface_type()->is_empty());\n+\tstd::vector<Backend::Btyped_identifier> bfields;\n+\tget_backend_interface_fields(gogo, this->interface_type(), true,\n+\t\t\t\t     &bfields);\n+\tbt = gogo->backend()->struct_type(bfields);\n+      }\n       break;\n \n-    case TYPE_NAMED:\n-    case TYPE_FORWARD:\n-      // Named types keep track of their own dependencies and manage\n-      // their own placeholders.\n-      return this->get_backend(gogo);\n-\n     case TYPE_SINK:\n     case TYPE_CALL_MULTIPLE_RESULT:\n+      /* Note that various classifications were handled in the earlier\n+\t switch.  */\n     default:\n       go_unreachable();\n     }\n \n-  this->btype_ = bt;\n-  this->btype_is_placeholder_ = true;\n+  if (ins.first->second.btype == NULL)\n+    {\n+      ins.first->second.btype = bt;\n+      ins.first->second.is_placeholder = true;\n+    }\n+  else\n+    {\n+      // A placeholder for this type got created along the way.  Use\n+      // that one and ignore the one we just built.\n+      bt = ins.first->second.btype;\n+    }\n+\n   return bt;\n }\n \n // Complete the backend representation.  This is called for a type\n // using a placeholder type.\n \n void\n-Type::finish_backend(Gogo* gogo)\n+Type::finish_backend(Gogo* gogo, Btype *placeholder)\n {\n-  go_assert(this->btype_ != NULL);\n-  if (!this->btype_is_placeholder_)\n-    return;\n-\n   switch (this->classification_)\n     {\n     case TYPE_ERROR:\n@@ -1120,15 +1156,15 @@ Type::finish_backend(Gogo* gogo)\n     case TYPE_FUNCTION:\n       {\n \tBtype* bt = this->do_get_backend(gogo);\n-\tif (!gogo->backend()->set_placeholder_function_type(this->btype_, bt))\n+\tif (!gogo->backend()->set_placeholder_function_type(placeholder, bt))\n \t  go_assert(saw_errors());\n       }\n       break;\n \n     case TYPE_POINTER:\n       {\n \tBtype* bt = this->do_get_backend(gogo);\n-\tif (!gogo->backend()->set_placeholder_pointer_type(this->btype_, bt))\n+\tif (!gogo->backend()->set_placeholder_pointer_type(placeholder, bt))\n \t  go_assert(saw_errors());\n       }\n       break;\n@@ -1165,7 +1201,7 @@ Type::finish_backend(Gogo* gogo)\n       go_unreachable();\n     }\n \n-  this->btype_is_placeholder_ = false;\n+  this->btype_ = placeholder;\n }\n \n // Return a pointer to the type descriptor for this type.\n@@ -2968,8 +3004,8 @@ String_type::do_get_backend(Gogo* gogo)\n       // backend representation, so force it to be finished now.\n       if (!gogo->named_types_are_converted())\n \t{\n-\t  pb->get_backend_placeholder(gogo);\n-\t  pb->finish_backend(gogo);\n+\t  Btype* bt = pb->get_backend_placeholder(gogo);\n+\t  pb->finish_backend(gogo, bt);\n \t}\n \n       fields[0].name = \"__data\";"}, {"sha": "fc84db039bbbffb70185b10274f05670a0192e54", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ccaff35d4219fa37ca83d9021710a5c4e532221/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ccaff35d4219fa37ca83d9021710a5c4e532221/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=8ccaff35d4219fa37ca83d9021710a5c4e532221", "patch": "@@ -888,7 +888,7 @@ class Type\n \n   // Finish the backend representation of a placeholder.\n   void\n-  finish_backend(Gogo*);\n+  finish_backend(Gogo*, Btype*);\n \n   // Build a type descriptor entry for this type.  Return a pointer to\n   // it.  The location is the location which causes us to need the\n@@ -1210,10 +1210,18 @@ class Type\n   Btype*\n   get_btype_without_hash(Gogo*);\n \n+  // A backend type that may be a placeholder.\n+  struct Type_btype_entry\n+  {\n+    Btype *btype;\n+    bool is_placeholder;\n+  };\n+\n   // A mapping from Type to Btype*, used to ensure that the backend\n-  // representation of identical types is identical.\n-  typedef Unordered_map_hash(const Type*, Btype*, Type_hash_identical,\n-\t\t\t     Type_identical) Type_btypes;\n+  // representation of identical types is identical.  This is only\n+  // used for unnamed types.\n+  typedef Unordered_map_hash(const Type*, Type_btype_entry,\n+\t\t\t     Type_hash_identical, Type_identical) Type_btypes;\n \n   static Type_btypes type_btypes;\n \n@@ -1230,9 +1238,6 @@ class Type\n \n   // The type classification.\n   Type_classification classification_;\n-  // Whether btype_ is a placeholder type used while named types are\n-  // being converted.\n-  bool btype_is_placeholder_;\n   // The backend representation of the type, once it has been\n   // determined.\n   Btype* btype_;"}]}