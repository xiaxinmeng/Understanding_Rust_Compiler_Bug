{"sha": "1e67793833846d12abe78f4291a07773d2f13a04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU2Nzc5MzgzMzg0NmQxMmFiZTc4ZjQyOTFhMDc3NzNkMmYxM2EwNA==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2015-07-01T16:10:30Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2015-07-01T16:10:30Z"}, "message": "re PR rtl-optimization/61047 (wrong code at -O1 on x86_64-linux)\n\ngcc/ChangeLog:\n2015-07-01  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        PR rtl-optimization/61047\n        * rtlanal.c (get_initial_register_offset): New function.\n        (rtx_addr_can_trap_p_1): Check offsets of stack references.\n\ntestsuite/ChangeLog:\n2015-07-01  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        PR rtl-optimization/61047\n        * gcc.c-torture/execute/20150611-1.c: New testcase.\n\nFrom-SVN: r225260", "tree": {"sha": "ad11a1fdf4189e71a1e3553b55648b9be30389dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad11a1fdf4189e71a1e3553b55648b9be30389dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e67793833846d12abe78f4291a07773d2f13a04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e67793833846d12abe78f4291a07773d2f13a04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e67793833846d12abe78f4291a07773d2f13a04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e67793833846d12abe78f4291a07773d2f13a04/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ee05f1e9be5f02d4c874262d27e1eff96a301f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ee05f1e9be5f02d4c874262d27e1eff96a301f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ee05f1e9be5f02d4c874262d27e1eff96a301f0"}], "stats": {"total": 276, "additions": 262, "deletions": 14}, "files": [{"sha": "48e91596a76bbbcff5180e10b7baf4bd37470b53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e67793833846d12abe78f4291a07773d2f13a04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e67793833846d12abe78f4291a07773d2f13a04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e67793833846d12abe78f4291a07773d2f13a04", "patch": "@@ -1,3 +1,9 @@\n+2015-07-01  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR rtl-optimization/61047\n+\t* rtlanal.c (get_initial_register_offset): New function.\n+\t(rtx_addr_can_trap_p_1): Check offsets of stack references.\n+\n 2015-07-01  Richard Biener  <rguenther@suse.de>\n \n \t* fold-const.c (fold_comparison): Move X - Y CMP 0 -> X CMP Y,"}, {"sha": "65962e8e331494c64c6340bd2408defc57384957", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 233, "deletions": 14, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e67793833846d12abe78f4291a07773d2f13a04/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e67793833846d12abe78f4291a07773d2f13a04/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=1e67793833846d12abe78f4291a07773d2f13a04", "patch": "@@ -345,6 +345,145 @@ rtx_varies_p (const_rtx x, bool for_alias)\n   return 0;\n }\n \n+/* Compute an approximation for the offset between the register\n+   FROM and TO for the current function, as it was at the start\n+   of the routine.  */\n+\n+static HOST_WIDE_INT\n+get_initial_register_offset (int from, int to)\n+{\n+#ifdef ELIMINABLE_REGS\n+  static const struct elim_table_t\n+  {\n+    const int from;\n+    const int to;\n+  } table[] = ELIMINABLE_REGS;\n+  HOST_WIDE_INT offset1, offset2;\n+  unsigned int i, j;\n+\n+  if (to == from)\n+    return 0;\n+\n+  /* It is not safe to call INITIAL_ELIMINATION_OFFSET\n+     before the reload pass.  We need to give at least\n+     an estimation for the resulting frame size.  */\n+  if (! reload_completed)\n+    {\n+      offset1 = crtl->outgoing_args_size + get_frame_size ();\n+#if !STACK_GROWS_DOWNWARD\n+      offset1 = - offset1;\n+#endif\n+      if (to == STACK_POINTER_REGNUM)\n+\treturn offset1;\n+      else if (from == STACK_POINTER_REGNUM)\n+\treturn - offset1;\n+      else\n+\treturn 0;\n+     }\n+\n+  for (i = 0; i < ARRAY_SIZE (table); i++)\n+      if (table[i].from == from)\n+\t{\n+\t  if (table[i].to == to)\n+\t    {\n+\t      INITIAL_ELIMINATION_OFFSET (table[i].from, table[i].to,\n+\t\t\t\t\t  offset1);\n+\t      return offset1;\n+\t    }\n+\t  for (j = 0; j < ARRAY_SIZE (table); j++)\n+\t    {\n+\t      if (table[j].to == to\n+\t\t  && table[j].from == table[i].to)\n+\t\t{\n+\t\t  INITIAL_ELIMINATION_OFFSET (table[i].from, table[i].to,\n+\t\t\t\t\t      offset1);\n+\t\t  INITIAL_ELIMINATION_OFFSET (table[j].from, table[j].to,\n+\t\t\t\t\t      offset2);\n+\t\t  return offset1 + offset2;\n+\t\t}\n+\t      if (table[j].from == to\n+\t\t  && table[j].to == table[i].to)\n+\t\t{\n+\t\t  INITIAL_ELIMINATION_OFFSET (table[i].from, table[i].to,\n+\t\t\t\t\t      offset1);\n+\t\t  INITIAL_ELIMINATION_OFFSET (table[j].from, table[j].to,\n+\t\t\t\t\t      offset2);\n+\t\t  return offset1 - offset2;\n+\t\t}\n+\t    }\n+\t}\n+      else if (table[i].to == from)\n+\t{\n+\t  if (table[i].from == to)\n+\t    {\n+\t      INITIAL_ELIMINATION_OFFSET (table[i].from, table[i].to,\n+\t\t\t\t\t  offset1);\n+\t      return - offset1;\n+\t    }\n+\t  for (j = 0; j < ARRAY_SIZE (table); j++)\n+\t    {\n+\t      if (table[j].to == to\n+\t\t  && table[j].from == table[i].from)\n+\t\t{\n+\t\t  INITIAL_ELIMINATION_OFFSET (table[i].from, table[i].to,\n+\t\t\t\t\t      offset1);\n+\t\t  INITIAL_ELIMINATION_OFFSET (table[j].from, table[j].to,\n+\t\t\t\t\t      offset2);\n+\t\t  return - offset1 + offset2;\n+\t\t}\n+\t      if (table[j].from == to\n+\t\t  && table[j].to == table[i].from)\n+\t\t{\n+\t\t  INITIAL_ELIMINATION_OFFSET (table[i].from, table[i].to,\n+\t\t\t\t\t      offset1);\n+\t\t  INITIAL_ELIMINATION_OFFSET (table[j].from, table[j].to,\n+\t\t\t\t\t      offset2);\n+\t\t  return - offset1 - offset2;\n+\t\t}\n+\t    }\n+\t}\n+\n+  /* If the requested register combination was not found,\n+     try a different more simple combination.  */\n+  if (from == ARG_POINTER_REGNUM)\n+    return get_initial_register_offset (HARD_FRAME_POINTER_REGNUM, to);\n+  else if (to == ARG_POINTER_REGNUM)\n+    return get_initial_register_offset (from, HARD_FRAME_POINTER_REGNUM);\n+  else if (from == HARD_FRAME_POINTER_REGNUM)\n+    return get_initial_register_offset (FRAME_POINTER_REGNUM, to);\n+  else if (to == HARD_FRAME_POINTER_REGNUM)\n+    return get_initial_register_offset (from, FRAME_POINTER_REGNUM);\n+  else\n+    return 0;\n+\n+#else\n+  HOST_WIDE_INT offset;\n+\n+  if (to == from)\n+    return 0;\n+\n+  if (reload_completed)\n+    {\n+      INITIAL_FRAME_POINTER_OFFSET (offset);\n+    }\n+  else\n+    {\n+      offset = crtl->outgoing_args_size + get_frame_size ();\n+#if !STACK_GROWS_DOWNWARD\n+      offset = - offset;\n+#endif\n+    }\n+\n+  if (to == STACK_POINTER_REGNUM)\n+    return offset;\n+  else if (from == STACK_POINTER_REGNUM)\n+    return - offset;\n+  else\n+    return 0;\n+\n+#endif\n+}\n+\n /* Return nonzero if the use of X+OFFSET as an address in a MEM with SIZE\n    bytes can cause a trap.  MODE is the mode of the MEM (not that of X) and\n    UNALIGNED_MEMS controls whether nonzero is returned for unaligned memory\n@@ -422,29 +561,109 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n     case REG:\n       /* Stack references are assumed not to trap, but we need to deal with\n \t nonsensical offsets.  */\n-      if (x == frame_pointer_rtx)\n+      if (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n+\t || x == stack_pointer_rtx\n+\t /* The arg pointer varies if it is not a fixed register.  */\n+\t || (x == arg_pointer_rtx && fixed_regs[ARG_POINTER_REGNUM]))\n \t{\n-\t  HOST_WIDE_INT adj_offset = offset - STARTING_FRAME_OFFSET;\n+#ifdef RED_ZONE_SIZE\n+\t  HOST_WIDE_INT red_zone_size = RED_ZONE_SIZE;\n+#else\n+\t  HOST_WIDE_INT red_zone_size = 0;\n+#endif\n+\t  HOST_WIDE_INT stack_boundary = PREFERRED_STACK_BOUNDARY\n+\t\t\t\t\t / BITS_PER_UNIT;\n+\t  HOST_WIDE_INT low_bound, high_bound;\n+\n \t  if (size == 0)\n \t    size = GET_MODE_SIZE (mode);\n-\t  if (FRAME_GROWS_DOWNWARD)\n+\n+\t  if (x == frame_pointer_rtx)\n \t    {\n-\t      if (adj_offset < frame_offset || adj_offset + size - 1 >= 0)\n-\t\treturn 1;\n+\t      if (FRAME_GROWS_DOWNWARD)\n+\t\t{\n+\t\t  high_bound = STARTING_FRAME_OFFSET;\n+\t\t  low_bound  = high_bound - get_frame_size ();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  low_bound  = STARTING_FRAME_OFFSET;\n+\t\t  high_bound = low_bound + get_frame_size ();\n+\t\t}\n+\t    }\n+\t  else if (x == hard_frame_pointer_rtx)\n+\t    {\n+\t      HOST_WIDE_INT sp_offset\n+\t\t= get_initial_register_offset (STACK_POINTER_REGNUM,\n+\t\t\t\t\t       HARD_FRAME_POINTER_REGNUM);\n+\t      HOST_WIDE_INT ap_offset\n+\t\t= get_initial_register_offset (ARG_POINTER_REGNUM,\n+\t\t\t\t\t       HARD_FRAME_POINTER_REGNUM);\n+\n+#if STACK_GROWS_DOWNWARD\n+\t      low_bound  = sp_offset - red_zone_size - stack_boundary;\n+\t      high_bound = ap_offset\n+\t\t\t   + FIRST_PARM_OFFSET (current_function_decl)\n+#if !ARGS_GROW_DOWNWARD\n+\t\t\t   + crtl->args.size\n+#endif\n+\t\t\t   + stack_boundary;\n+#else\n+\t      high_bound = sp_offset + red_zone_size + stack_boundary;\n+\t      low_bound  = ap_offset\n+\t\t\t   + FIRST_PARM_OFFSET (current_function_decl)\n+#if ARGS_GROW_DOWNWARD\n+\t\t\t   - crtl->args.size\n+#endif\n+\t\t\t   - stack_boundary;\n+#endif\n+\t    }\n+\t  else if (x == stack_pointer_rtx)\n+\t    {\n+\t      HOST_WIDE_INT ap_offset\n+\t\t= get_initial_register_offset (ARG_POINTER_REGNUM,\n+\t\t\t\t\t       STACK_POINTER_REGNUM);\n+\n+#if STACK_GROWS_DOWNWARD\n+\t      low_bound  = - red_zone_size - stack_boundary;\n+\t      high_bound = ap_offset\n+\t\t\t   + FIRST_PARM_OFFSET (current_function_decl)\n+#if !ARGS_GROW_DOWNWARD\n+\t\t\t   + crtl->args.size\n+#endif\n+\t\t\t   + stack_boundary;\n+#else\n+\t      high_bound = red_zone_size + stack_boundary;\n+\t      low_bound  = ap_offset\n+\t\t\t   + FIRST_PARM_OFFSET (current_function_decl)\n+#if ARGS_GROW_DOWNWARD\n+\t\t\t   - crtl->args.size\n+#endif\n+\t\t\t   - stack_boundary;\n+#endif\n \t    }\n \t  else\n \t    {\n-\t      if (adj_offset < 0 || adj_offset + size - 1 >= frame_offset)\n-\t\treturn 1;\n+\t      /* We assume that accesses are safe to at least the\n+\t\t next stack boundary.\n+\t\t Examples are varargs and __builtin_return_address.  */\n+#if ARGS_GROW_DOWNWARD\n+\t      high_bound = FIRST_PARM_OFFSET (current_function_decl)\n+\t\t\t   + stack_boundary;\n+\t      low_bound  = FIRST_PARM_OFFSET (current_function_decl)\n+\t\t\t   - crtl->args.size - stack_boundary;\n+#else\n+\t      low_bound  = FIRST_PARM_OFFSET (current_function_decl)\n+\t\t\t   - stack_boundary;\n+\t      high_bound = FIRST_PARM_OFFSET (current_function_decl)\n+\t\t\t   + crtl->args.size + stack_boundary;\n+#endif\n \t    }\n-\t  return 0;\n+\n+\t  if (offset >= low_bound && offset <= high_bound - size)\n+\t    return 0;\n+\t  return 1;\n \t}\n-      /* ??? Need to add a similar guard for nonsensical offsets.  */\n-      if (x == hard_frame_pointer_rtx\n-\t  || x == stack_pointer_rtx\n-\t  /* The arg pointer varies if it is not a fixed register.  */\n-\t  || (x == arg_pointer_rtx && fixed_regs[ARG_POINTER_REGNUM]))\n-\treturn 0;\n       /* All of the virtual frame registers are stack references.  */\n       if (REGNO (x) >= FIRST_VIRTUAL_REGISTER\n \t  && REGNO (x) <= LAST_VIRTUAL_REGISTER)"}, {"sha": "4dff233f93469dd0b2ec227c8c945bf06c7b4d21", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e67793833846d12abe78f4291a07773d2f13a04/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e67793833846d12abe78f4291a07773d2f13a04/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1e67793833846d12abe78f4291a07773d2f13a04", "patch": "@@ -1,3 +1,8 @@\n+2015-07-01  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\tPR rtl-optimization/61047\n+\t* gcc.c-torture/execute/20150611-1.c: New testcase.\n+\n 2015-07-01  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR jit/66700"}, {"sha": "ba34fa26b6b43138e8712d6dfc7d3f2e0ab631a6", "filename": "gcc/testsuite/gcc.c-torture/execute/20150611-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e67793833846d12abe78f4291a07773d2f13a04/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20150611-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e67793833846d12abe78f4291a07773d2f13a04/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20150611-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20150611-1.c?ref=1e67793833846d12abe78f4291a07773d2f13a04", "patch": "@@ -0,0 +1,18 @@\n+int a, c, d;\n+short b;\n+\n+int\n+main ()\n+{\n+  int e[1];\n+  for (; b < 2; b++)\n+    {\n+      a = 0;\n+      if (b == 28378)\n+        a = e[b];\n+      if (!(d || b))\n+        for (; c;)\n+          ;\n+    }\n+  return 0;\n+}"}]}