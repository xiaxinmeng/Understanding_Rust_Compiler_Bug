{"sha": "561af708f99565ea6974718b6748a3ef59e5c5ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYxYWY3MDhmOTk1NjVlYTY5NzQ3MThiNjc0OGEzZWY1OWU1YzVjYQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-08-09T00:31:24Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-08-09T00:31:24Z"}, "message": "pa.md (extzv, extv, insv): Fix operand limit checks.\n\n\t* pa.md (extzv, extv, insv): Fix operand limit checks.  Fail if\n\tsource/destination is not a register operand.\n\nFrom-SVN: r70267", "tree": {"sha": "afe8cb232e6a4064dd823df57b505637fc7ef585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afe8cb232e6a4064dd823df57b505637fc7ef585"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/561af708f99565ea6974718b6748a3ef59e5c5ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561af708f99565ea6974718b6748a3ef59e5c5ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561af708f99565ea6974718b6748a3ef59e5c5ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561af708f99565ea6974718b6748a3ef59e5c5ca/comments", "author": null, "committer": null, "parents": [{"sha": "9bea6f9863890313f78c4af8dfcd8a2b8f4baf98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bea6f9863890313f78c4af8dfcd8a2b8f4baf98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bea6f9863890313f78c4af8dfcd8a2b8f4baf98"}], "stats": {"total": 78, "additions": 52, "deletions": 26}, "files": [{"sha": "b0f4213ffd1edb97c843f0320d9745c10e59eb57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561af708f99565ea6974718b6748a3ef59e5c5ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561af708f99565ea6974718b6748a3ef59e5c5ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=561af708f99565ea6974718b6748a3ef59e5c5ca", "patch": "@@ -1,3 +1,8 @@\n+2003-08-08  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* pa.md (extzv, extv, insv): Fix operand limit checks.  Fail if\n+\tsource/destination is not a register operand.\n+\n 2003-08-08  Richard Henderson  <rth@redhat.com>\n \n         PR target/11535"}, {"sha": "bba626ecd7c6bf2e22cc72b1138b80a140f953e1", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561af708f99565ea6974718b6748a3ef59e5c5ca/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561af708f99565ea6974718b6748a3ef59e5c5ca/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=561af708f99565ea6974718b6748a3ef59e5c5ca", "patch": "@@ -7145,6 +7145,7 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n \n+;;; Operands 2 and 3 are assumed to be CONST_INTs.\n (define_expand \"extzv\"\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(zero_extract (match_operand 1 \"register_operand\" \"\")\n@@ -7153,21 +7154,26 @@\n   \"\"\n   \"\n {\n-  /* PA extraction insns don't support zero length bitfields.  */\n-  if (INTVAL (operands[2]) == 0)\n+  HOST_WIDE_INT len = INTVAL (operands[2]);\n+  HOST_WIDE_INT pos = INTVAL (operands[3]);\n+\n+  /* PA extraction insns don't support zero length bitfields or fields\n+     extending beyond the left or right-most bits.  Also, we reject lengths\n+     equal to a word as they are better handled by the move patterns.  */\n+  if (len <= 0 || len >= BITS_PER_WORD || pos < 0 || pos + len > BITS_PER_WORD)\n+    FAIL;\n+\n+  /* From mips.md: extract_bit_field doesn't verify that our source\n+     matches the predicate, so check it again here.  */\n+  if (!register_operand (operands[1], VOIDmode))\n     FAIL;\n \n   if (TARGET_64BIT)\n     emit_insn (gen_extzv_64 (operands[0], operands[1],\n \t\t\t     operands[2], operands[3]));\n   else\n-    {\n-      if (! uint5_operand (operands[2], SImode)\n-\t  || ! uint5_operand (operands[3], SImode))\n-\tFAIL;\n-      emit_insn (gen_extzv_32 (operands[0], operands[1],\n-\t\t\t       operands[2], operands[3]));\n-    }\n+    emit_insn (gen_extzv_32 (operands[0], operands[1],\n+\t\t\t     operands[2], operands[3]));\n   DONE;\n }\")\n \n@@ -7211,6 +7217,7 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n+;;; Operands 2 and 3 are assumed to be CONST_INTs.\n (define_expand \"extv\"\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(sign_extract (match_operand 1 \"register_operand\" \"\")\n@@ -7219,21 +7226,26 @@\n   \"\"\n   \"\n {\n-  /* PA extraction insns don't support zero length bitfields.  */\n-  if (INTVAL (operands[2]) == 0)\n+  HOST_WIDE_INT len = INTVAL (operands[2]);\n+  HOST_WIDE_INT pos = INTVAL (operands[3]);\n+\n+  /* PA extraction insns don't support zero length bitfields or fields\n+     extending beyond the left or right-most bits.  Also, we reject lengths\n+     equal to a word as they are better handled by the move patterns.  */\n+  if (len <= 0 || len >= BITS_PER_WORD || pos < 0 || pos + len > BITS_PER_WORD)\n+    FAIL;\n+\n+  /* From mips.md: extract_bit_field doesn't verify that our source\n+     matches the predicate, so check it again here.  */\n+  if (!register_operand (operands[1], VOIDmode))\n     FAIL;\n \n   if (TARGET_64BIT)\n     emit_insn (gen_extv_64 (operands[0], operands[1],\n \t\t\t    operands[2], operands[3]));\n   else\n-    {\n-      if (! uint5_operand (operands[2], SImode)\n-\t  || ! uint5_operand (operands[3], SImode))\n-\tFAIL;\n-      emit_insn (gen_extv_32 (operands[0], operands[1],\n-\t\t\t      operands[2], operands[3]));\n-    }\n+    emit_insn (gen_extv_32 (operands[0], operands[1],\n+\t\t\t    operands[2], operands[3]));\n   DONE;\n }\")\n \n@@ -7277,7 +7289,7 @@\n   [(set_attr \"type\" \"shift\")\n    (set_attr \"length\" \"4\")])\n \n-;; Only specify the mode operands 0, the rest are assumed to be word_mode.\n+;;; Operands 1 and 2 are assumed to be CONST_INTs.\n (define_expand \"insv\"\n   [(set (zero_extract (match_operand 0 \"register_operand\" \"\")\n                       (match_operand 1 \"uint32_operand\" \"\")\n@@ -7286,17 +7298,26 @@\n   \"\"\n   \"\n {\n+  HOST_WIDE_INT len = INTVAL (operands[1]);\n+  HOST_WIDE_INT pos = INTVAL (operands[2]);\n+\n+  /* PA insertion insns don't support zero length bitfields or fields\n+     extending beyond the left or right-most bits.  Also, we reject lengths\n+     equal to a word as they are better handled by the move patterns.  */\n+  if (len <= 0 || len >= BITS_PER_WORD || pos < 0 || pos + len > BITS_PER_WORD)\n+    FAIL;\n+\n+  /* From mips.md: insert_bit_field doesn't verify that our destination\n+     matches the predicate, so check it again here.  */\n+  if (!register_operand (operands[0], VOIDmode))\n+    FAIL;\n+\n   if (TARGET_64BIT)\n     emit_insn (gen_insv_64 (operands[0], operands[1],\n \t\t\t    operands[2], operands[3]));\n   else\n-    {\n-      if (! uint5_operand (operands[2], SImode)\n-\t  || ! uint5_operand (operands[3], SImode))\n-\tFAIL;\n-      emit_insn (gen_insv_32 (operands[0], operands[1],\n-\t\t\t      operands[2], operands[3]));\n-    }\n+    emit_insn (gen_insv_32 (operands[0], operands[1],\n+\t\t\t    operands[2], operands[3]));\n   DONE;\n }\")\n "}]}