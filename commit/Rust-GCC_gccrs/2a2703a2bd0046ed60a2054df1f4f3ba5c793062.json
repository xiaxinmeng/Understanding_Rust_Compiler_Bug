{"sha": "2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyNzAzYTJiZDAwNDZlZDYwYTIwNTRkZjFmNGYzYmE1Yzc5MzA2Mg==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2015-05-16T12:31:00Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2015-05-16T12:31:00Z"}, "message": "re PR fortran/44054 (Handle -Werror, -Werror=, -fdiagnostics-show-option, !GCC$ diagnostic (pragmas) and color)\n\ngcc/fortran/ChangeLog:\n\n2015-05-16  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR fortran/44054\n\n\tReplace all calls to gfc_notify_std_1 with gfc_notify_std and\n\tgfc_warning_1 with gfc_warning.\n\t* decl.c (gfc_verify_c_interop_param): Here.\n\t* resolve.c (resolve_branch): Here.\n\t(resolve_fl_derived): Here.\n\t* dependency.c (gfc_check_argument_var_dependency):\n\t* scanner.c (preprocessor_line): Use gfc_warning_now_at. Fix line\n\tcounter and locations before and after warning.\n\t* gfortran.h (gfc_warning_1, gfc_warning_now_1, gfc_notify_std_1):\n\tDelete.\n\t(gfc_warning_now_at): Declare.\n\t* error.c (gfc_warning_1): Delete.\n\t(gfc_notify_std_1): Delete.\n\t(gfc_warning_now_1): Delete.\n\t(gfc_format_decoder): Handle two locations.\n\t(gfc_diagnostic_build_prefix): Rename as\n\tgfc_diagnostic_build_kind_prefix.\n\t(gfc_diagnostic_build_locus_prefix): Take an expanded_location\n\tinstead of diagnostic_info.\n\t(gfc_diagnostic_build_locus_prefix): Add overload that takes two\n\texpanded_location.\n\t(gfc_diagnostic_starter): Handle two locations.\n\t(gfc_warning_now_at): New.\n\t(gfc_diagnostics_init): Initialize caret_chars array.\n\t(gfc_diagnostics_finish): Reset caret_chars array to default.\n\ngcc/cp/ChangeLog:\n\n2015-05-16  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR fortran/44054\n\t* error.c (cp_diagnostic_starter): Use diagnostic_location\n\tfunction.\n\t(cp_print_error_function): Likewise.\n\t(cp_printer): Replace locus pointer with accessor function.\n\ngcc/c/ChangeLog:\n\n2015-05-16  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR fortran/44054\n\t* c-objc-common.c (c_tree_printer): Replace locus pointer with\n\taccessor function.\n\ngcc/ChangeLog:\n\n2015-05-16  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR fortran/44054\n\t* tree-pretty-print.c (percent_K_format): Replace locus pointer\n\twith accessor function.\n\t* tree-diagnostic.c (diagnostic_report_current_function): Use\n\tdiagnostic_location function.\n\t(maybe_unwind_expanded_macro_loc): Likewise.\n\t(virt_loc_aware_diagnostic_finalizer): Likewise.\n\t(default_tree_printer): Replace locus pointer with accessor function.\n\t* diagnostic.c (diagnostic_initialize): Initialize caret_chars array.\n\t(diagnostic_set_info_translated): Initialize second location.\n\t(diagnostic_build_prefix): Use CARET_LINE_MARGIN.\n\t(diagnostic_show_locus): Handle two locations. Call\n\tdiagnostic_print_caret_line.\n\t(diagnostic_print_caret_line): New.\n\t(default_diagnostic_starter): Use diagnostic_location function.\n\t(diagnostic_report_diagnostic): Use diagnostic_location function.\n\t(verbatim): Do not set text.locus.\n\t* diagnostic.h (struct diagnostic_info): Remove location field.\n\t(struct diagnostic_context): Make caret_chars an array of two.\n\t(diagnostic_location): New inline.\n\t(diagnostic_expand_location): Handle two locations.\n\t(diagnostic_same_line): New inline.\n\t(diagnostic_print_caret_line): Declare.\n\t(CARET_LINE_MARGIN): New constant.\n\t* pretty-print.c (pp_printf): Do not set text.locus.\n\t(pp_verbatim): Do not set text.locus.\n\t* pretty-print.h (MAX_LOCATIONS_PER_MESSAGE): New constant.\n\t(struct text_info): Replace locus pointer with locations\n\tarray. Add accessor functions.\n\ngcc/testsuite/ChangeLog:\n\n2015-05-16  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR fortran/44054\n\t* lib/gfortran-dg.exp: Update regex to handle two locations for\n\tthe same diagnostic without caret.\n\t* gfortran.dg/badline.f: Test also that line numbers are correct\n\tbefore and after \"left but not entered\" warning.\n\nFrom-SVN: r223237", "tree": {"sha": "e38c12f0ed89361988c13ec74581d698238467a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e38c12f0ed89361988c13ec74581d698238467a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/comments", "author": null, "committer": null, "parents": [{"sha": "40de31cfe4e8959e5f92c82aa34550693897d29c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40de31cfe4e8959e5f92c82aa34550693897d29c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40de31cfe4e8959e5f92c82aa34550693897d29c"}], "stats": {"total": 633, "additions": 375, "deletions": 258}, "files": [{"sha": "2730565e94e7c9ca5e96b1a9e4d9a2763f342042", "filename": "gcc/c/c-objc-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -108,8 +108,8 @@ c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n   if (*spec != 'v')\n     {\n       t = va_arg (*text->args_ptr, tree);\n-      if (set_locus && text->locus)\n-\t*text->locus = DECL_SOURCE_LOCATION (t);\n+      if (set_locus)\n+\ttext->set_location (0, DECL_SOURCE_LOCATION (t));\n     }\n \n   switch (*spec)"}, {"sha": "ea03f7dc3a99e75917b7826a4d922eaadd23aea3", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -3104,7 +3104,7 @@ static void\n cp_diagnostic_starter (diagnostic_context *context,\n \t\t       diagnostic_info *diagnostic)\n {\n-  diagnostic_report_current_module (context, diagnostic->location);\n+  diagnostic_report_current_module (context, diagnostic_location (diagnostic));\n   cp_print_error_function (context, diagnostic);\n   maybe_print_instantiation_context (context);\n   maybe_print_constexpr_context (context);\n@@ -3125,7 +3125,7 @@ cp_print_error_function (diagnostic_context *context,\n   if (diagnostic_last_function_changed (context, diagnostic))\n     {\n       const char *old_prefix = context->printer->prefix;\n-      const char *file = LOCATION_FILE (diagnostic->location);\n+      const char *file = LOCATION_FILE (diagnostic_location (diagnostic));\n       tree abstract_origin = diagnostic_abstract_origin (diagnostic);\n       char *new_prefix = (file && abstract_origin == NULL)\n \t\t\t ? file_name_as_prefix (context, file) : NULL;\n@@ -3471,9 +3471,6 @@ cp_printer (pretty_printer *pp, text_info *text, const char *spec,\n   if (precision != 0 || wide)\n     return false;\n \n-  if (text->locus == NULL)\n-    set_locus = false;\n-\n   switch (*spec)\n     {\n     case 'A': result = args_to_string (next_tree, verbose);\tbreak;\n@@ -3515,7 +3512,7 @@ cp_printer (pretty_printer *pp, text_info *text, const char *spec,\n \n   pp_string (pp, result);\n   if (set_locus && t != NULL)\n-    *text->locus = location_of (t);\n+    text->set_location (0, location_of (t));\n   return true;\n #undef next_tree\n #undef next_tcode"}, {"sha": "54e3fcfa818908c610630ae592511d4e02ab768b", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 85, "deletions": 36, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -146,7 +146,8 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n     context->classify_diagnostic[i] = DK_UNSPECIFIED;\n   context->show_caret = false;\n   diagnostic_set_caret_max_width (context, pp_line_cutoff (context->printer));\n-  context->caret_char = '^';\n+  for (i = 0; i < MAX_LOCATIONS_PER_MESSAGE; i++)\n+    context->caret_chars[i] = '^';\n   context->show_option_requested = false;\n   context->abort_on_error = false;\n   context->show_column = false;\n@@ -241,7 +242,9 @@ diagnostic_set_info_translated (diagnostic_info *diagnostic, const char *msg,\n   diagnostic->message.err_no = errno;\n   diagnostic->message.args_ptr = args;\n   diagnostic->message.format_spec = msg;\n-  diagnostic->location = location;\n+  diagnostic->message.set_location (0, location);\n+  for (int i = 1; i < MAX_LOCATIONS_PER_MESSAGE; i++)\n+    diagnostic->message.set_location (i, UNKNOWN_LOCATION);\n   diagnostic->override_column = 0;\n   diagnostic->kind = kind;\n   diagnostic->option_index = 0;\n@@ -309,14 +312,14 @@ diagnostic_build_prefix (diagnostic_context *context,\n /* If LINE is longer than MAX_WIDTH, and COLUMN is not smaller than\n    MAX_WIDTH by some margin, then adjust the start of the line such\n    that the COLUMN is smaller than MAX_WIDTH minus the margin.  The\n-   margin is either 10 characters or the difference between the column\n-   and the length of the line, whatever is smaller.  The length of\n-   LINE is given by LINE_WIDTH.  */\n+   margin is either CARET_LINE_MARGIN characters or the difference\n+   between the column and the length of the line, whatever is smaller.\n+   The length of LINE is given by LINE_WIDTH.  */\n static const char *\n adjust_line (const char *line, int line_width,\n \t     int max_width, int *column_p)\n {\n-  int right_margin = 10;\n+  int right_margin = CARET_LINE_MARGIN;\n   int column = *column_p;\n \n   gcc_checking_assert (line_width >= column);\n@@ -331,35 +334,69 @@ adjust_line (const char *line, int line_width,\n }\n \n /* Print the physical source line corresponding to the location of\n-   this diagnostic, and a caret indicating the precise column.  */\n+   this diagnostic, and a caret indicating the precise column.  This\n+   function only prints two caret characters if the two locations\n+   given by DIAGNOSTIC are on the same line according to\n+   diagnostic_same_line().  */\n void\n diagnostic_show_locus (diagnostic_context * context,\n \t\t       const diagnostic_info *diagnostic)\n {\n-  const char *line;\n-  int line_width;\n-  char *buffer;\n-  expanded_location s;\n-  int max_width;\n-  const char *saved_prefix;\n-  const char *caret_cs, *caret_ce;\n-\n   if (!context->show_caret\n-      || diagnostic->location <= BUILTINS_LOCATION\n-      || diagnostic->location == context->last_location)\n+      || diagnostic_location (diagnostic, 0) <= BUILTINS_LOCATION\n+      || diagnostic_location (diagnostic, 0) == context->last_location)\n     return;\n \n-  context->last_location = diagnostic->location;\n-  s = diagnostic_expand_location (diagnostic);\n-  line = location_get_source_line (s, &line_width);\n-  if (line == NULL || s.column > line_width)\n-    return;\n+  context->last_location = diagnostic_location (diagnostic, 0);\n+  expanded_location s0 = diagnostic_expand_location (diagnostic, 0);\n+  expanded_location s1 = { }; \n+  /* Zero-initialized. This is checked later by diagnostic_print_caret_line.  */\n \n-  max_width = context->caret_max_width;\n-  line = adjust_line (line, line_width, max_width, &(s.column));\n+  if (diagnostic_location (diagnostic, 1) > BUILTINS_LOCATION)\n+    s1 = diagnostic_expand_location (diagnostic, 1);\n \n+  diagnostic_print_caret_line (context, s0, s1,\n+\t\t\t       context->caret_chars[0],\n+\t\t\t       context->caret_chars[1]);\n+}\n+\n+/* Print (part) of the source line given by xloc1 with caret1 pointing\n+   at the column.  If xloc2.column != 0 and it fits within the same\n+   line as xloc1 according to diagnostic_same_line (), then caret2 is\n+   printed at xloc2.colum.  Otherwise, the caller has to set up things\n+   to print a second caret line for xloc2.  */\n+void\n+diagnostic_print_caret_line (diagnostic_context * context,\n+\t\t\t     expanded_location xloc1,\n+\t\t\t     expanded_location xloc2,\n+\t\t\t     char caret1, char caret2)\n+{\n+  if (!diagnostic_same_line (context, xloc1, xloc2))\n+    /* This will mean ignore xloc2.  */\n+    xloc2.column = 0;\n+  else if (xloc1.column == xloc2.column)\n+    xloc2.column++;\n+  \n+  int cmax = MAX (xloc1.column, xloc2.column);\n+  int line_width;\n+  const char *line = location_get_source_line (xloc1, &line_width);\n+  if (line == NULL || cmax > line_width)\n+    return;\n+\n+  /* Center the interesting part of the source line to fit in\n+     max_width, and adjust all columns accordingly.  */\n+  int max_width = context->caret_max_width;\n+  int offset = (int) cmax;\n+  line = adjust_line (line, line_width, max_width, &offset);\n+  offset -= cmax;\n+  cmax += offset;\n+  xloc1.column += offset;\n+  if (xloc2.column)\n+    xloc2.column += offset;\n+\n+  /* Print the source line.  */\n   pp_newline (context->printer);\n-  saved_prefix = pp_get_prefix (context->printer);\n+  const char *saved_prefix = pp_get_prefix (context->printer);\n   pp_set_prefix (context->printer, NULL);\n   pp_space (context->printer);\n   while (max_width > 0 && line_width > 0)\n@@ -373,15 +410,28 @@ diagnostic_show_locus (diagnostic_context * context,\n       line++;\n     }\n   pp_newline (context->printer);\n+\n+  /* Print the caret under the line.  */\n+  const char *caret_cs, *caret_ce;\n   caret_cs = colorize_start (pp_show_color (context->printer), \"caret\");\n   caret_ce = colorize_stop (pp_show_color (context->printer));\n+  int cmin = xloc2.column \n+    ? MIN (xloc1.column, xloc2.column) : xloc1.column;\n+  int caret_min = cmin == xloc1.column ? caret1 : caret2;\n+  int caret_max = cmin == xloc1.column ? caret2 : caret1;\n \n-  /* pp_printf does not implement %*c.  */\n-  size_t len = s.column + 3 + strlen (caret_cs) + strlen (caret_ce);\n-  buffer = XALLOCAVEC (char, len);\n-  snprintf (buffer, len, \"%s %*c%s\", caret_cs, s.column, context->caret_char,\n-\t    caret_ce);\n-  pp_string (context->printer, buffer);\n+  pp_space (context->printer);\n+  int i;\n+  for (i = 0; i < cmin; i++)\n+    pp_space (context->printer);\n+  pp_printf (context->printer, \"%s%c%s\", caret_cs, caret_min, caret_ce);\n+\n+  if (xloc2.column)\n+    {\n+      for (i++; i < cmax; i++)\n+\tpp_space (context->printer);\n+      pp_printf (context->printer, \"%s%c%s\", caret_cs, caret_max, caret_ce);\n+    }\n   pp_set_prefix (context->printer, saved_prefix);\n   pp_needs_newline (context->printer) = true;\n }\n@@ -604,7 +654,7 @@ void\n default_diagnostic_starter (diagnostic_context *context,\n \t\t\t    diagnostic_info *diagnostic)\n {\n-  diagnostic_report_current_module (context, diagnostic->location);\n+  diagnostic_report_current_module (context, diagnostic_location (diagnostic));\n   pp_set_prefix (context->printer, diagnostic_build_prefix (context,\n \t\t\t\t\t\t\t    diagnostic));\n }\n@@ -716,7 +766,7 @@ bool\n diagnostic_report_diagnostic (diagnostic_context *context,\n \t\t\t      diagnostic_info *diagnostic)\n {\n-  location_t location = diagnostic->location;\n+  location_t location = diagnostic_location (diagnostic);\n   diagnostic_t orig_diag_kind = diagnostic->kind;\n   const char *saved_format_spec;\n \n@@ -825,7 +875,8 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \t   || diagnostic_kind_count (context, DK_SORRY) > 0)\n \t  && !context->abort_on_error)\n \t{\n-\t  expanded_location s = expand_location (diagnostic->location);\n+\t  expanded_location s \n+\t    = expand_location (diagnostic_location (diagnostic));\n \t  fnotice (stderr, \"%s:%d: confused by earlier errors, bailing out\\n\",\n \t\t   s.file, s.line);\n \t  exit (ICE_EXIT_CODE);\n@@ -859,7 +910,6 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \t  free (option_text);\n \t}\n     }\n-  diagnostic->message.locus = &diagnostic->location;\n   diagnostic->message.x_data = &diagnostic->x_data;\n   diagnostic->x_data = NULL;\n   pp_format (context->printer, &diagnostic->message);\n@@ -920,7 +970,6 @@ verbatim (const char *gmsgid, ...)\n   text.err_no = errno;\n   text.args_ptr = &ap;\n   text.format_spec = _(gmsgid);\n-  text.locus = NULL;\n   text.x_data = NULL;\n   pp_format_verbatim (global_dc->printer, &text);\n   pp_newline_and_flush (global_dc->printer);"}, {"sha": "1b9b7d42865d6f1555b9653afd6b79cd187af527", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -29,8 +29,9 @@ along with GCC; see the file COPYING3.  If not see\n    list in diagnostic.def.  */\n struct diagnostic_info\n {\n+  /* Text to be formatted. It also contains the location(s) for this\n+     diagnostic.  */\n   text_info message;\n-  location_t location;\n   unsigned int override_column;\n   /* Auxiliary data for client.  */\n   void *x_data;\n@@ -105,8 +106,8 @@ struct diagnostic_context\n   /* Maximum width of the source line printed.  */\n   int caret_max_width;\n \n-  /* Character used for caret diagnostics.  */\n-  char caret_char;\n+  /* Characters used for caret diagnostics.  */\n+  char caret_chars[MAX_LOCATIONS_PER_MESSAGE];\n \n   /* True if we should print the command line option which controls\n      each diagnostic, if known.  */\n@@ -300,18 +301,53 @@ void diagnostic_file_cache_fini (void);\n \n int get_terminal_width (void);\n \n-/* Expand the location of this diagnostic. Use this function for consistency. */\n+/* Return the location associated to this diagnostic. Parameter WHICH\n+   specifies which location. By default, expand the first one.  */\n+\n+static inline location_t\n+diagnostic_location (const diagnostic_info * diagnostic, int which = 0)\n+{\n+  return diagnostic->message.get_location (which);\n+}\n+\n+/* Expand the location of this diagnostic. Use this function for\n+   consistency.  Parameter WHICH specifies which location. By default,\n+   expand the first one.  */\n \n static inline expanded_location\n-diagnostic_expand_location (const diagnostic_info * diagnostic)\n+diagnostic_expand_location (const diagnostic_info * diagnostic, int which = 0)\n {\n   expanded_location s\n-    = expand_location_to_spelling_point (diagnostic->location);\n-  if (diagnostic->override_column)\n+    = expand_location_to_spelling_point (diagnostic_location (diagnostic,\n+\t\t\t\t\t\t\t      which));\n+  if (which == 0 && diagnostic->override_column)\n     s.column = diagnostic->override_column;\n   return s;\n }\n \n+/* This is somehow the right-side margin of a caret line, that is, we\n+   print at least these many characters after the position pointed at\n+   by the caret.  */\n+#define CARET_LINE_MARGIN 10\n+\n+/* Return true if the two locations can be represented within the same\n+   caret line.  This is used to build a prefix and also to determine\n+   whether to print one or two caret lines.  */\n+\n+static inline bool\n+diagnostic_same_line (const diagnostic_context *context,\n+\t\t       expanded_location s1, expanded_location s2)\n+{\n+  return s2.column && s1.line == s2.line \n+    && context->caret_max_width - CARET_LINE_MARGIN > abs (s1.column - s2.column);\n+}\n+\n+void\n+diagnostic_print_caret_line (diagnostic_context * context,\n+\t\t\t     expanded_location xloc1,\n+\t\t\t     expanded_location xloc2,\n+\t\t\t     char caret1, char caret2);\n+\n /* Pure text formatting support functions.  */\n extern char *file_name_as_prefix (diagnostic_context *, const char *);\n "}, {"sha": "13002d45a1f03475013c9fc4eeb1fa979103dae9", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -1126,7 +1126,7 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t     either assumed size or explicit shape. Deferred shape is already\n \t     covered by the pointer/allocatable attribute.  */\n \t  if (sym->as != NULL && sym->as->type == AS_ASSUMED_SHAPE\n-\t      && !gfc_notify_std_1 (GFC_STD_F2008_TS, \"Assumed-shape array '%s' \"\n+\t      && !gfc_notify_std (GFC_STD_F2008_TS, \"Assumed-shape array %qs \"\n \t\t\t\t  \"at %L as dummy argument to the BIND(C) \"\n \t\t\t\t  \"procedure '%s' at %L\", sym->name, \n \t\t\t\t  &(sym->declared_at), "}, {"sha": "8b07f59586a4872232639e2ed6fe125f49e16998", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -956,7 +956,7 @@ gfc_check_argument_var_dependency (gfc_expr *var, sym_intent intent,\n \t\t     If a dependency is found in the case\n \t\t     elemental == ELEM_CHECK_VARIABLE, we will generate\n \t\t     a temporary, so we don't need to bother the user.  */\n-\t\t  gfc_warning_1 (\"INTENT(%s) actual argument at %L might \"\n+\t\t  gfc_warning (0, \"INTENT(%s) actual argument at %L might \"\n \t\t\t       \"interfere with actual argument at %L.\",\n \t\t   \t       intent == INTENT_OUT ? \"OUT\" : \"INOUT\",\n \t\t   \t       &var->where, &expr->where);"}, {"sha": "23308b6544e3831916d0c1fddbbec6e9184d2263", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 182, "deletions": 181, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -807,37 +807,6 @@ gfc_clear_pp_buffer (output_buffer *this_buffer)\n }\n \n \n-/* Issue a warning.  */\n-/* Use gfc_warning instead, unless two locations are used in the same\n-   warning or for scanner.c, if the location is not properly set up.  */\n-\n-void\n-gfc_warning_1 (const char *gmsgid, ...)\n-{\n-  va_list argp;\n-\n-  if (inhibit_warnings)\n-    return;\n-\n-  warning_buffer.flag = 1;\n-  warning_buffer.index = 0;\n-  cur_error_buffer = &warning_buffer;\n-\n-  va_start (argp, gmsgid);\n-  error_print (_(\"Warning:\"), _(gmsgid), argp);\n-  va_end (argp);\n-\n-  error_char ('\\0');\n-\n-  if (!buffered_p)\n-  {\n-    warnings++;\n-    if (warnings_are_errors)\n-      gfc_increment_error_count();\n-  }\n-}\n-\n-\n /* This is just a helper function to avoid duplicating the logic of\n    gfc_warning.  */\n \n@@ -889,9 +858,6 @@ gfc_warning (int opt, const char *gmsgid, va_list ap)\n }\n \n /* Issue a warning.  */\n-/* This function uses the common diagnostics, but does not support\n-   two locations; when being used in scanner.c, ensure that the location\n-   is properly setup. Otherwise, use gfc_warning_1.   */\n \n bool\n gfc_warning (int opt, const char *gmsgid, ...)\n@@ -926,84 +892,6 @@ gfc_notification_std (int std)\n    standard does not contain the requested bits.  Return false if\n    an error is generated.  */\n \n-bool\n-gfc_notify_std_1 (int std, const char *gmsgid, ...)\n-{\n-  va_list argp;\n-  bool warning;\n-  const char *msg1, *msg2;\n-  char *buffer;\n-\n-  warning = ((gfc_option.warn_std & std) != 0) && !inhibit_warnings;\n-  if ((gfc_option.allow_std & std) != 0 && !warning)\n-    return true;\n-\n-  if (suppress_errors)\n-    return warning ? true : false;\n-\n-  cur_error_buffer = warning ? &warning_buffer : &error_buffer;\n-  cur_error_buffer->flag = 1;\n-  cur_error_buffer->index = 0;\n-\n-  if (warning)\n-    msg1 = _(\"Warning:\");\n-  else\n-    msg1 = _(\"Error:\");\n-  \n-  switch (std)\n-  {\n-    case GFC_STD_F2008_TS:\n-      msg2 = \"TS 29113/TS 18508:\";\n-      break;\n-    case GFC_STD_F2008_OBS:\n-      msg2 = _(\"Fortran 2008 obsolescent feature:\");\n-      break;\n-    case GFC_STD_F2008:\n-      msg2 = \"Fortran 2008:\";\n-      break;\n-    case GFC_STD_F2003:\n-      msg2 = \"Fortran 2003:\";\n-      break;\n-    case GFC_STD_GNU:\n-      msg2 = _(\"GNU Extension:\");\n-      break;\n-    case GFC_STD_LEGACY:\n-      msg2 = _(\"Legacy Extension:\");\n-      break;\n-    case GFC_STD_F95_OBS:\n-      msg2 = _(\"Obsolescent feature:\");\n-      break;\n-    case GFC_STD_F95_DEL:\n-      msg2 = _(\"Deleted feature:\");\n-      break;\n-    default:\n-      gcc_unreachable ();\n-  }\n-\n-  buffer = (char *) alloca (strlen (msg1) + strlen (msg2) + 2);\n-  strcpy (buffer, msg1);\n-  strcat (buffer, \" \");\n-  strcat (buffer, msg2);\n-\n-  va_start (argp, gmsgid);\n-  error_print (buffer, _(gmsgid), argp);\n-  va_end (argp);\n-\n-  error_char ('\\0');\n-\n-  if (!buffered_p)\n-    {\n-      if (warning && !warnings_are_errors)\n-\twarnings++;\n-      else\n-\tgfc_increment_error_count();\n-      cur_error_buffer->flag = 0;\n-    }\n-\n-  return (warning && !warnings_are_errors) ? true : false;\n-}\n-\n-\n bool\n gfc_notify_std (int std, const char *gmsgid, ...)\n {\n@@ -1066,35 +954,6 @@ gfc_notify_std (int std, const char *gmsgid, ...)\n }\n \n \n-/* Immediate warning (i.e. do not buffer the warning).  */\n-/* Use gfc_warning_now instead, unless two locations are used in the same\n-   warning or for scanner.c, if the location is not properly set up.  */\n-\n-void\n-gfc_warning_now_1 (const char *gmsgid, ...)\n-{\n-  va_list argp;\n-  bool buffered_p_saved;\n-\n-  if (inhibit_warnings)\n-    return;\n-\n-  buffered_p_saved = buffered_p;\n-  buffered_p = false;\n-  warnings++;\n-\n-  va_start (argp, gmsgid);\n-  error_print (_(\"Warning:\"), _(gmsgid), argp);\n-  va_end (argp);\n-\n-  error_char ('\\0');\n-\n-  if (warnings_are_errors)\n-    gfc_increment_error_count();\n-\n-  buffered_p = buffered_p_saved;\n-}\n-\n /* Called from output_format -- during diagnostic message processing\n    to handle Fortran specific format specifiers with the following meanings:\n \n@@ -1112,33 +971,34 @@ gfc_format_decoder (pretty_printer *pp,\n     case 'C':\n     case 'L':\n       {\n-\tstatic const char *result = \"(1)\";\n+\tstatic const char *result[2] = { \"(1)\", \"(2)\" };\n \tlocus *loc;\n \tif (*spec == 'C')\n \t  loc = &gfc_current_locus;\n \telse\n \t  loc = va_arg (*text->args_ptr, locus *);\n \tgcc_assert (loc->nextc - loc->lb->line >= 0);\n \tunsigned int offset = loc->nextc - loc->lb->line;\n-\tgcc_assert (text->locus);\n-\t*text->locus\n-\t  = linemap_position_for_loc_and_offset (line_table,\n-\t\t\t\t\t\t loc->lb->location,\n-\t\t\t\t\t\t offset);\n-\tglobal_dc->caret_char = '1';\n-\tpp_string (pp, result);\n+\t/* If location[0] != UNKNOWN_LOCATION means that we already\n+\t   processed one of %C/%L.  */\n+\tint loc_num = text->get_location (0) == UNKNOWN_LOCATION ? 0 : 1;\n+\ttext->set_location (loc_num,\n+\t\t\t    linemap_position_for_loc_and_offset (line_table,\n+\t\t\t\t\t\t\t\t loc->lb->location,\n+\t\t\t\t\t\t\t\t offset));\n+\tpp_string (pp, result[loc_num]);\n \treturn true;\n       }\n     default:\n       return false;\n     }\n }\n \n-/* Return a malloc'd string describing a location.  The caller is\n-   responsible for freeing the memory.  */\n+/* Return a malloc'd string describing the kind of diagnostic.  The\n+   caller is responsible for freeing the memory.  */\n static char *\n-gfc_diagnostic_build_prefix (diagnostic_context *context,\n-\t\t\t     const diagnostic_info *diagnostic)\n+gfc_diagnostic_build_kind_prefix (diagnostic_context *context,\n+\t\t\t\t  const diagnostic_info *diagnostic)\n {\n   static const char *const diagnostic_kind_text[] = {\n #define DEFINE_DIAGNOSTIC_KIND(K, T, C) (T),\n@@ -1170,12 +1030,11 @@ gfc_diagnostic_build_prefix (diagnostic_context *context,\n    responsible for freeing the memory.  */\n static char *\n gfc_diagnostic_build_locus_prefix (diagnostic_context *context,\n-\t\t\t\t   const diagnostic_info *diagnostic)\n+\t\t\t\t   expanded_location s)\n {\n   pretty_printer *pp = context->printer;\n   const char *locus_cs = colorize_start (pp_show_color (pp), \"locus\");\n   const char *locus_ce = colorize_stop (pp_show_color (pp));\n-  expanded_location s = diagnostic_expand_location (diagnostic);\n   return (s.file == NULL\n \t  ? build_message_string (\"%s%s:%s\", locus_cs, progname, locus_ce )\n \t  : !strcmp (s.file, N_(\"<built-in>\"))\n@@ -1186,35 +1045,160 @@ gfc_diagnostic_build_locus_prefix (diagnostic_context *context,\n \t  : build_message_string (\"%s%s:%d:%s\", locus_cs, s.file, s.line, locus_ce));\n }\n \n-static void\n+/* Return a malloc'd string describing two locations.  The caller is\n+   responsible for freeing the memory.  */\n+static char *\n+gfc_diagnostic_build_locus_prefix (diagnostic_context *context,\n+\t\t\t\t   expanded_location s, expanded_location s2)\n+{\n+  pretty_printer *pp = context->printer;\n+  const char *locus_cs = colorize_start (pp_show_color (pp), \"locus\");\n+  const char *locus_ce = colorize_stop (pp_show_color (pp));\n+\n+  return (s.file == NULL\n+\t  ? build_message_string (\"%s%s:%s\", locus_cs, progname, locus_ce )\n+\t  : !strcmp (s.file, N_(\"<built-in>\"))\n+\t  ? build_message_string (\"%s%s:%s\", locus_cs, s.file, locus_ce)\n+\t  : context->show_column\n+\t  ? build_message_string (\"%s%s:%d:%d-%d:%s\", locus_cs, s.file, s.line,\n+\t\t\t\t  MIN (s.column, s2.column),\n+\t\t\t\t  MAX (s.column, s2.column), locus_ce)\n+\t  : build_message_string (\"%s%s:%d:%s\", locus_cs, s.file, s.line,\n+\t\t\t\t  locus_ce));\n+}\n+\n+/* This function prints the locus (file:line:column), the diagnostic kind\n+   (Error, Warning) and (optionally) the caret line (a source line\n+   with '1' and/or '2' below it).\n+\n+   With -fdiagnostic-show-caret (the default) and for valid locations,\n+   it prints for one location:\n+\n+       [locus]:\n+       \n+          some code\n+                 1\n+       Error: Some error at (1)\n+        \n+   for two locations that fit in the same locus line:\n+\n+       [locus]:\n+       \n+         some code and some more code\n+                1       2\n+       Error: Some error at (1) and (2)\n+\n+   and for two locations that do not fit in the same locus line:\n+\n+       [locus]:\n+       \n+         some code\n+                1\n+       [locus2]:\n+       \n+         some other code\n+           2\n+       Error: Some error at (1) and (2)\n+       \n+  With -fno-diagnostic-show-caret or if one of the locations is not\n+  valid, it prints for one location (or for two locations that fit in\n+  the same locus line):\n+\n+       [locus]: Error: Some error at (1) and (2)\n+\n+   and for two locations that do not fit in the same locus line:\n+\n+       [name]:[locus]: Error: (1)\n+       [name]:[locus2]: Error: Some error at (1) and (2)\n+*/\n+static void \n gfc_diagnostic_starter (diagnostic_context *context,\n \t\t\tdiagnostic_info *diagnostic)\n {\n-  char * locus_prefix = gfc_diagnostic_build_locus_prefix (context, diagnostic);\n-  char * prefix = gfc_diagnostic_build_prefix (context, diagnostic);\n-  /* First we assume there is a caret line.  */\n-  pp_set_prefix (context->printer, NULL);\n-  if (pp_needs_newline (context->printer))\n-    pp_newline (context->printer);\n-  pp_verbatim (context->printer, locus_prefix);\n-  /* Fortran uses an empty line between locus and caret line.  */\n-  pp_newline (context->printer);\n-  diagnostic_show_locus (context, diagnostic);\n-  if (pp_needs_newline (context->printer))\n+  char * kind_prefix = gfc_diagnostic_build_kind_prefix (context, diagnostic);\n+\n+  expanded_location s1 = diagnostic_expand_location (diagnostic);\n+  expanded_location s2;\n+  bool one_locus = diagnostic_location (diagnostic, 1) == UNKNOWN_LOCATION;\n+  bool same_locus = false;\n+\n+  if (!one_locus) \n+    {\n+      s2 = diagnostic_expand_location (diagnostic, 1);\n+      same_locus = diagnostic_same_line (context, s1, s2);\n+    }\n+\n+  char * locus_prefix = (one_locus || !same_locus)\n+    ? gfc_diagnostic_build_locus_prefix (context, s1)\n+    : gfc_diagnostic_build_locus_prefix (context, s1, s2);\n+\n+  if (!context->show_caret\n+      || diagnostic_location (diagnostic, 0) <= BUILTINS_LOCATION\n+      || diagnostic_location (diagnostic, 0) == context->last_location)\n+    {\n+      pp_set_prefix (context->printer,\n+\t\t     concat (locus_prefix, \" \", kind_prefix, NULL));\n+      free (locus_prefix);\n+\n+      if (one_locus || same_locus)\n+\t{\n+\t  free (kind_prefix);\n+\t  return;\n+\t}\n+      /* In this case, we print the previous locus and prefix as:\n+\n+\t  [locus]:[prefix]: (1)\n+\n+\t and we flush with a new line before setting the new prefix.  */\n+      pp_string (context->printer, \"(1)\");\n+      pp_newline (context->printer);\n+      locus_prefix = gfc_diagnostic_build_locus_prefix (context, s2);\n+      pp_set_prefix (context->printer,\n+\t\t     concat (locus_prefix, \" \", kind_prefix, NULL));\n+      free (kind_prefix);\n+      free (locus_prefix);\n+    }\n+  else\n     {\n+      pp_verbatim (context->printer, locus_prefix);\n+      free (locus_prefix);\n+      /* Fortran uses an empty line between locus and caret line.  */\n+      pp_newline (context->printer);\n+      diagnostic_show_locus (context, diagnostic);\n       pp_newline (context->printer);\n       /* If the caret line was shown, the prefix does not contain the\n \t locus.  */\n-      pp_set_prefix (context->printer, prefix);\n-    }\n-  else \n-    {\n-      /* Otherwise, start again.  */\n-      pp_clear_output_area(context->printer);\n-      pp_set_prefix (context->printer, concat (locus_prefix, \" \", prefix, NULL));\n-      free (prefix);\n+      pp_set_prefix (context->printer, kind_prefix);\n+\n+      if (one_locus || same_locus)\n+\t  return;\n+\n+      locus_prefix = gfc_diagnostic_build_locus_prefix (context, s2);\n+      if (diagnostic_location (diagnostic, 1) <= BUILTINS_LOCATION)\n+\t{\n+\t  /* No caret line for the second location. Override the previous\n+\t     prefix with [locus2]:[prefix].  */\n+\t  pp_set_prefix (context->printer,\n+\t\t\t concat (locus_prefix, \" \", kind_prefix, NULL));\n+\t  free (kind_prefix);\n+\t  free (locus_prefix);\n+\t}\n+      else\n+\t{\n+\t  /* We print the caret for the second location.  */\n+\t  pp_verbatim (context->printer, locus_prefix);\n+\t  free (locus_prefix);\n+\t  /* Fortran uses an empty line between locus and caret line.  */\n+\t  pp_newline (context->printer);\n+\t  s1.column = 0; /* Print only a caret line for s2.  */\n+\t  diagnostic_print_caret_line (context, s2, s1,\n+\t\t\t\t       context->caret_chars[1], '\\0');\n+\t  pp_newline (context->printer);\n+\t  /* If the caret line was shown, the prefix does not contain the\n+\t     locus.  */\n+\t  pp_set_prefix (context->printer, kind_prefix);\n+\t}\n     }\n-  free (locus_prefix);\n }\n \n static void\n@@ -1225,10 +1209,25 @@ gfc_diagnostic_finalizer (diagnostic_context *context,\n   pp_newline_and_flush (context->printer);\n }\n \n+/* Immediate warning (i.e. do not buffer the warning) with an explicit\n+   location.  */\n+\n+bool\n+gfc_warning_now_at (location_t loc, int opt, const char *gmsgid, ...)\n+{\n+  va_list argp;\n+  diagnostic_info diagnostic;\n+  bool ret;\n+\n+  va_start (argp, gmsgid);\n+  diagnostic_set_info (&diagnostic, gmsgid, &argp, loc, DK_WARNING);\n+  diagnostic.option_index = opt;\n+  ret = report_diagnostic (&diagnostic);\n+  va_end (argp);\n+  return ret;\n+}\n+\n /* Immediate warning (i.e. do not buffer the warning).  */\n-/* This function uses the common diagnostics, but does not support\n-   two locations; when being used in scanner.c, ensure that the location\n-   is properly setup. Otherwise, use gfc_warning_now_1.   */\n \n bool\n gfc_warning_now (int opt, const char *gmsgid, ...)\n@@ -1639,7 +1638,8 @@ gfc_diagnostics_init (void)\n   diagnostic_starter (global_dc) = gfc_diagnostic_starter;\n   diagnostic_finalizer (global_dc) = gfc_diagnostic_finalizer;\n   diagnostic_format_decoder (global_dc) = gfc_format_decoder;\n-  global_dc->caret_char = '^';\n+  global_dc->caret_chars[0] = '1';\n+  global_dc->caret_chars[1] = '2';\n   pp_warning_buffer = new (XNEW (output_buffer)) output_buffer ();\n   pp_warning_buffer->flush_p = false;\n   pp_error_buffer = new (XNEW (output_buffer)) output_buffer ();\n@@ -1654,5 +1654,6 @@ gfc_diagnostics_finish (void)\n      defaults.  */\n   diagnostic_starter (global_dc) = gfc_diagnostic_starter;\n   diagnostic_finalizer (global_dc) = gfc_diagnostic_finalizer;\n-  global_dc->caret_char = '^';\n+  global_dc->caret_chars[0] = '^';\n+  global_dc->caret_chars[1] = '^';\n }"}, {"sha": "aaa4e8909797b53f2aa4502d29c31ff42f251a4c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -2660,10 +2660,10 @@ void gfc_buffer_error (bool);\n \n const char *gfc_print_wide_char (gfc_char_t);\n \n-void gfc_warning_1 (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n bool gfc_warning (int opt, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n-void gfc_warning_now_1 (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n bool gfc_warning_now (int opt, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n+bool gfc_warning_now_at (location_t loc, int opt, const char *gmsgid, ...)\n+  ATTRIBUTE_GCC_GFC(3,4);\n \n void gfc_clear_warning (void);\n void gfc_warning_check (void);\n@@ -2679,7 +2679,6 @@ bool gfc_error_check (void);\n bool gfc_error_flag_test (void);\n \n notification gfc_notification_std (int);\n-bool gfc_notify_std_1 (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n bool gfc_notify_std (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n \n /* A general purpose syntax error.  */"}, {"sha": "fbf260f5233d93218a33147c579ad568d4c94bcb", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -8779,7 +8779,7 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n   /* The label is not in an enclosing block, so illegal.  This was\n      allowed in Fortran 66, so we allow it as extension.  No\n      further checks are necessary in this case.  */\n-  gfc_notify_std_1 (GFC_STD_LEGACY, \"Label at %L is not in the same block \"\n+  gfc_notify_std (GFC_STD_LEGACY, \"Label at %L is not in the same block \"\n \t\t  \"as the GOTO statement at %L\", &label->where,\n \t\t  &code->loc);\n   return;\n@@ -12920,8 +12920,8 @@ resolve_fl_derived (gfc_symbol *sym)\n   if (gen_dt && gen_dt->generic && gen_dt->generic->next\n       && (!gen_dt->generic->sym->attr.use_assoc\n \t  || gen_dt->generic->sym->module != gen_dt->generic->next->sym->module)\n-      && !gfc_notify_std_1 (GFC_STD_F2003, \"Generic name '%s' of function \"\n-\t\t\t  \"'%s' at %L being the same name as derived \"\n+      && !gfc_notify_std (GFC_STD_F2003, \"Generic name %qs of function \"\n+\t\t\t  \"%qs at %L being the same name as derived \"\n \t\t\t  \"type at %L\", sym->name,\n \t\t\t  gen_dt->generic->sym == sym\n \t\t\t  ? gen_dt->generic->next->sym->name"}, {"sha": "55b36250cf5a25d9ba5a9cef97ca161a672692b7", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -2014,9 +2014,13 @@ preprocessor_line (gfc_char_t *c)\n       if (!current_file->up\n \t  || filename_cmp (current_file->up->filename, filename) != 0)\n \t{\n-\t  gfc_warning_now_1 (\"%s:%d: file %s left but not entered\",\n-\t\t\t     current_file->filename, current_file->line,\n-\t\t\t     filename);\n+\t  linemap_line_start (line_table, current_file->line, 80);\n+\t  /* ??? One could compute the exact column where the filename\n+\t     starts and compute the exact location here.  */\n+\t  gfc_warning_now_at (linemap_position_for_column (line_table, 1),\n+\t\t\t      0, \"file %qs left but not entered\",\n+\t\t\t      filename);\n+\t  current_file->line++;\n \t  if (unescape)\n \t    free (wide_filename);\n \t  free (filename);\n@@ -2048,8 +2052,11 @@ preprocessor_line (gfc_char_t *c)\n   return;\n \n  bad_cpp_line:\n-  gfc_warning_now_1 (\"%s:%d: Illegal preprocessor directive\",\n-\t\t   current_file->filename, current_file->line);\n+  linemap_line_start (line_table, current_file->line, 80);\n+  /* ??? One could compute the exact column where the directive\n+     starts and compute the exact location here.  */\n+  gfc_warning_now_at (linemap_position_for_column (line_table, 2), 0,\n+\t\t      \"Illegal preprocessor directive\");\n   current_file->line++;\n }\n "}, {"sha": "fdc7b4da34f79ea6b975b76da27f3966f1445bef", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -853,7 +853,6 @@ pp_printf (pretty_printer *pp, const char *msg, ...)\n   text.err_no = errno;\n   text.args_ptr = &ap;\n   text.format_spec = msg;\n-  text.locus = NULL;\n   pp_format (pp, &text);\n   pp_output_formatted_text (pp);\n   va_end (ap);\n@@ -871,7 +870,6 @@ pp_verbatim (pretty_printer *pp, const char *msg, ...)\n   text.err_no = errno;\n   text.args_ptr = &ap;\n   text.format_spec = msg;\n-  text.locus = NULL;\n   pp_format_verbatim (pp, &text);\n   va_end (ap);\n }"}, {"sha": "6143423ac6e8232074c8a370ca73bf32b60ff7fb", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -28,15 +28,34 @@ along with GCC; see the file COPYING3.  If not see\n /* Maximum number of format string arguments.  */\n #define PP_NL_ARGMAX   30\n \n+/* Maximum number of locations associated to each message.  If\n+   location 'i' is UNKNOWN_LOCATION, then location 'i+1' is not\n+   valid.  */\n+#define MAX_LOCATIONS_PER_MESSAGE 2\n+\n /* The type of a text to be formatted according a format specification\n    along with a list of things.  */\n struct text_info\n {\n   const char *format_spec;\n   va_list *args_ptr;\n   int err_no;  /* for %m */\n-  location_t *locus;\n   void **x_data;\n+\n+  inline void set_location (unsigned int index_of_location, location_t loc)\n+  {\n+    gcc_checking_assert (index_of_location < MAX_LOCATIONS_PER_MESSAGE);\n+    this->locations[index_of_location] = loc;\n+  }\n+\n+  inline location_t get_location (unsigned int index_of_location) const\n+  {\n+    gcc_checking_assert (index_of_location < MAX_LOCATIONS_PER_MESSAGE);\n+    return this->locations[index_of_location];\n+  }\n+\n+private:\n+  location_t locations[MAX_LOCATIONS_PER_MESSAGE];\n };\n \n /* How often diagnostics are prefixed by their locations:"}, {"sha": "250b06f675956354c437c50269ae2577156e7dea", "filename": "gcc/testsuite/gfortran.dg/badline.f", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ftestsuite%2Fgfortran.dg%2Fbadline.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ftestsuite%2Fgfortran.dg%2Fbadline.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbadline.f?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -1,4 +1,8 @@\n         subroutine foo \n+# illegal\n # 18 \"src/badline.F\" 2\n+# illegal\n         end\n-! { dg-warning \"left but not entered\" \"\" { target *-*-* } 2 }\n+! { dg-warning \"Illegal\" \"\" { target *-*-* } 2 }\n+! { dg-warning \"left but not entered\" \"\" { target *-*-* } 3 }\n+! { dg-warning \"Illegal\" \"\" { target *-*-* } 4 }"}, {"sha": "ddf8f2265964accb64b9bf9b5fb44457d120dc5e", "filename": "gcc/testsuite/lib/gfortran-dg.exp", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgfortran-dg.exp?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -51,6 +51,9 @@ proc gfortran-dg-test { prog do_what extra_tool_flags } {\n     #\n     # or\n     #     [name]:[locus]: Error: Some error\n+    # or\n+    #     [name]:[locus]: Error: (1)\n+    #     [name]:[locus2]: Error: Some error at (1) and (2)\n     #\n     # Where [locus] is either [line] or [line].[column] or\n     # [line].[column]-[column] .\n@@ -80,14 +83,19 @@ proc gfortran-dg-test { prog do_what extra_tool_flags } {\n     regsub -all $two_loci $comp_output \"\\\\1\\\\2:\\\\3: \\\\8\\n\\\\5\\:\\\\6: \\\\8\\n\" comp_output\n     verbose \"comput_output1:\\n$comp_output\"\n \n+    set locus_prefix \"(\\[^:\\n\\]+:\\[0-9\\]+:\\[0-9\\]+: )(Warning: |Error: )\"\n+    set two_loci2 \"(^|\\n)$locus_prefix\\\\(1\\\\)\\n$locus_prefix$diag_regexp\"\n+    regsub -all $two_loci2 $comp_output \"\\\\1\\\\2\\\\3\\\\6\\n\\\\4\\\\5\\\\6\\n\" comp_output\n+    verbose \"comput_output2:\\n$comp_output\"\n+\n     # 3. then with the form with only one locus line.\n     set single_locus \"(^|\\n)$locus_regexp$diag_regexp\"\n     regsub -all $single_locus $comp_output \"\\\\1\\\\2:\\\\3: \\\\5\\n\" comp_output\n-    verbose \"comput_output2:\\n$comp_output\"\n+    verbose \"comput_output3:\\n$comp_output\"\n \n     # 4. Add a line number if none exists\n     regsub -all \"(^|\\n)(Warning: |Error: )\" $comp_output \"\\\\1:0:0: \\\\2\" comp_output\n-    verbose \"comput_output3:\\n$comp_output\"\n+    verbose \"comput_output4:\\n$comp_output\"\n     return [list $comp_output $output_file]\n }\n "}, {"sha": "a3b73b24bdd39cb7199b23bbb2a3be2c08aba9d3", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -48,7 +48,7 @@ void\n diagnostic_report_current_function (diagnostic_context *context,\n \t\t\t\t    diagnostic_info *diagnostic)\n {\n-  diagnostic_report_current_module (context, diagnostic->location);\n+  diagnostic_report_current_module (context, diagnostic_location (diagnostic));\n   lang_hooks.print_error_function (context, LOCATION_FILE (input_location),\n \t\t\t\t   diagnostic);\n }\n@@ -153,7 +153,7 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n      first macro which expansion triggered this trace was expanded\n      inside a system header.  */\n   int saved_location_line =\n-    expand_location_to_spelling_point (diagnostic->location).line;\n+    expand_location_to_spelling_point (diagnostic_location (diagnostic)).line;\n \n   if (!LINEMAP_SYSP (map))\n     FOR_EACH_VEC_ELT (loc_vec, ix, iter)\n@@ -252,7 +252,7 @@ virt_loc_aware_diagnostic_finalizer (diagnostic_context *context,\n \t\t\t\t     diagnostic_info *diagnostic)\n {\n   maybe_unwind_expanded_macro_loc (context, diagnostic,\n-\t\t\t\t   diagnostic->location);\n+\t\t\t\t   diagnostic_location (diagnostic));\n }\n \n /* Default tree printer.   Handles declarations only.  */\n@@ -296,8 +296,8 @@ default_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n       return false;\n     }\n \n-  if (set_locus && text->locus)\n-    *text->locus = DECL_SOURCE_LOCATION (t);\n+  if (set_locus)\n+    text->set_location (0, DECL_SOURCE_LOCATION (t));\n \n   if (DECL_P (t))\n     {"}, {"sha": "cf875c88856f9aae69bc9233f66b5a63841c8f35", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2703a2bd0046ed60a2054df1f4f3ba5c793062/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=2a2703a2bd0046ed60a2054df1f4f3ba5c793062", "patch": "@@ -3620,8 +3620,7 @@ void\n percent_K_format (text_info *text)\n {\n   tree t = va_arg (*text->args_ptr, tree), block;\n-  gcc_assert (text->locus != NULL);\n-  *text->locus = EXPR_LOCATION (t);\n+  text->set_location (0, EXPR_LOCATION (t));\n   gcc_assert (pp_ti_abstract_origin (text) != NULL);\n   block = TREE_BLOCK (t);\n   *pp_ti_abstract_origin (text) = NULL;"}]}