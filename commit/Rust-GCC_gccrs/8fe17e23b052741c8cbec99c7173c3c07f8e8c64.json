{"sha": "8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZlMTdlMjNiMDUyNzQxYzhjYmVjOTljNzE3M2MzYzA3ZjhlOGM2NA==", "commit": {"author": {"name": "Ajit Agarwal", "email": "ajitkum@xilinx.com", "date": "2015-11-13T23:31:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-11-13T23:31:51Z"}, "message": "[Patch,tree-optimization]: Add new path Splitting pass on tree ssa\nrepresentation\n\n\t* Makefile.in (OBJS): Add gimple-ssa-split-paths.o\n\t* common.opt (-fsplit-paths): New flag controlling path splitting.\n\t* doc/invoke.texi (fsplit-paths): Document.\n\t* opts.c (default_options_table): Add -fsplit-paths to -O2.\n\t* passes.def: Add split_paths pass.\n\t* timevar.def (TV_SPLIT_PATHS): New timevar.\n\t* tracer.c: Include \"tracer.h\"\n\t(ignore_bb_p): No longer static.\n\t(transform_duplicate): New function, broken out of tail_duplicate.\n\t(tail_duplicate): Use transform_duplicate.\n\t* tracer.h (ignore_bb_p): Declare\n\t(transform_duplicate): Likewise.\n\t* tree-pass.h (make_pass_split_paths): Declare.\n\t* gimple-ssa-split-paths.c: New file.\n\n\t* gcc.dg/tree-ssa/split-path-1.c: New test.\n\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r230364", "tree": {"sha": "5b2631fd0e6dc942bbd89ba9465f3c9d6d96aaa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b2631fd0e6dc942bbd89ba9465f3c9d6d96aaa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/comments", "author": null, "committer": null, "parents": [{"sha": "269e63b735d6e4e18367e94e8417b5d5eb799960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269e63b735d6e4e18367e94e8417b5d5eb799960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/269e63b735d6e4e18367e94e8417b5d5eb799960"}], "stats": {"total": 444, "additions": 431, "deletions": 13}, "files": [{"sha": "a7abe379db80a54a37cc22b3ab4f09fb9e69bc26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -1,3 +1,21 @@\n+2015-11-13  Ajit Agarwal  <ajitkum@xilinx.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add gimple-ssa-split-paths.o\n+\t* common.opt (-fsplit-paths): New flag controlling path splitting.\n+\t* doc/invoke.texi (fsplit-paths): Document.\n+\t* opts.c (default_options_table): Add -fsplit-paths to -O2.\n+\t* passes.def: Add split_paths pass.\n+\t* timevar.def (TV_SPLIT_PATHS): New timevar.\n+\t* tracer.c: Include \"tracer.h\"\n+\t(ignore_bb_p): No longer static.\n+\t(transform_duplicate): New function, broken out of tail_duplicate.\n+\t(tail_duplicate): Use transform_duplicate.\n+\t* tracer.h (ignore_bb_p): Declare\n+\t(transform_duplicate): Likewise.\n+\t* tree-pass.h (make_pass_split_paths): Declare.\n+\t* gimple-ssa-split-paths.c: New file.\n+\n 2015-11-13  Kai Tietz  <ktietz70@googlemail.com>\n \t    Marek Polacek  <polacek@redhat.com>\n \t    Jason Merrill  <jason@redhat.com>"}, {"sha": "5c294df7b8a901c7dda9c86ff0985c66befed2b0", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -1277,6 +1277,7 @@ OBJS = \\\n \tgimple-pretty-print.o \\\n \tgimple-ssa-backprop.o \\\n \tgimple-ssa-isolate-paths.o \\\n+\tgimple-ssa-split-paths.o \\\n \tgimple-ssa-strength-reduction.o \\\n \tgimple-streamer-in.o \\\n \tgimple-streamer-out.o \\"}, {"sha": "3eb520eaef2e72c2fb67d1df75047cd6956b2f64", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -2403,6 +2403,10 @@ ftree-vrp\n Common Report Var(flag_tree_vrp) Init(0) Optimization\n Perform Value Range Propagation on trees.\n \n+fsplit-paths\n+Common Report Var(flag_split_paths) Init(0) Optimization\n+Split paths leading to loop backedges.\n+\n funit-at-a-time\n Common Report Var(flag_unit_at_a_time) Init(1)\n Compile whole compilation unit at a time."}, {"sha": "eeb79e65c0e259267c9f18b2911c54516a0d889e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -354,6 +354,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-tree-fre@r{[}-@var{n}@r{]} @gol\n -fdump-tree-vtable-verify @gol\n -fdump-tree-vrp@r{[}-@var{n}@r{]} @gol\n+-fdump-tree-split-paths@r{[}-@var{n}@r{]} @gol\n -fdump-tree-storeccp@r{[}-@var{n}@r{]} @gol\n -fdump-final-insns=@var{file} @gol\n -fcompare-debug@r{[}=@var{opts}@r{]}  -fcompare-debug-second @gol\n@@ -448,6 +449,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol\n -fsemantic-interposition -fshrink-wrap -fsignaling-nans @gol\n -fsingle-precision-constant -fsplit-ivs-in-unroller @gol\n+-fsplit-paths @gol\n -fsplit-wide-types -fssa-backprop -fssa-phiopt @gol\n -fstack-protector -fstack-protector-all -fstack-protector-strong @gol\n -fstack-protector-explicit -fstdarg-opt -fstrict-aliasing @gol\n@@ -7171,6 +7173,11 @@ output on to @file{stderr}. If two conflicting dump filenames are\n given for the same pass, then the latter option overrides the earlier\n one.\n \n+@item split-paths\n+@opindex fdump-tree-split-paths\n+Dump each function after splitting paths to loop backedges.  The file\n+name is made by appending @file{.split-paths} to the source file name.\n+\n @item all\n Turn on all options, except @option{raw}, @option{slim}, @option{verbose}\n and @option{lineno}.\n@@ -7808,6 +7815,7 @@ also turns on the following optimization flags:\n -frerun-cse-after-loop  @gol\n -fsched-interblock  -fsched-spec @gol\n -fschedule-insns  -fschedule-insns2 @gol\n+-fsplit-paths @gol\n -fstrict-aliasing -fstrict-overflow @gol\n -ftree-builtin-call-dce @gol\n -ftree-switch-conversion -ftree-tail-merge @gol\n@@ -8821,7 +8829,7 @@ currently enabled, but may be enabled by @option{-O2} in the future.\n \n @item -ftree-sink\n @opindex ftree-sink\n-Perform forward store motion  on trees.  This flag is\n+Perform forward store motion on trees.  This flag is\n enabled by default at @option{-O} and higher.\n \n @item -ftree-bit-ccp\n@@ -9127,6 +9135,12 @@ enabled by default at @option{-O2} and higher.  Null pointer check\n elimination is only done if @option{-fdelete-null-pointer-checks} is\n enabled.\n \n+@item -fsplit-paths\n+@opindex fsplit-paths\n+Split paths leading to loop backedges.  This can improve dead code\n+elimination and common subexpression elimination.  This is enabled by\n+default at @option{-O2} and above.\n+\n @item -fsplit-ivs-in-unroller\n @opindex fsplit-ivs-in-unroller\n Enables expression of values of induction variables in later iterations"}, {"sha": "602e916f88ede1a4dfa17a9761e99917d641a107", "filename": "gcc/gimple-ssa-split-paths.c", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fgimple-ssa-split-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fgimple-ssa-split-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-split-paths.c?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -0,0 +1,270 @@\n+/* Support routines for Splitting Paths to loop backedges\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+   Contributed by Ajit Kumar Agarwal <ajitkum@xilinx.com>.\n+\n+ This file is part of GCC.\n+\n+ GCC is free software; you can redistribute it and/or modify\n+ it under the terms of the GNU General Public License as published by\n+ the Free Software Foundation; either version 3, or (at your option)\n+ any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"cfganal.h\"\n+#include \"cfgloop.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tracer.h\"\n+\n+/* Given LATCH, the latch block in a loop, see if the shape of the\n+   path reaching LATCH is suitable for being split by duplication.\n+   If so, return the block that will be duplicated into its predecessor\n+   paths.  Else return NULL.  */\n+\n+static basic_block\n+find_block_to_duplicate_for_splitting_paths (basic_block latch)\n+{\n+  /* We should have simple latches at this point.  So the latch should\n+     have a single successor.  This implies the predecessor of the latch\n+     likely has the loop exit.  And it's that predecessor we're most\n+     interested in. To keep things simple, we're going to require that\n+     the latch have a single predecessor too.  */\n+  if (single_succ_p (latch) && single_pred_p (latch))\n+    {\n+      basic_block bb = get_immediate_dominator (CDI_DOMINATORS, latch);\n+      gcc_assert (single_pred_edge (latch)->src == bb);\n+\n+      /* If BB has been marked as not to be duplicated, then honor that\n+\t request.  */\n+      if (ignore_bb_p (bb))\n+\treturn NULL;\n+\n+      gimple *last = gsi_stmt (gsi_last_nondebug_bb (bb));\n+      /* The immediate dominator of the latch must end in a conditional.  */\n+      if (!last || gimple_code (last) != GIMPLE_COND)\n+\treturn NULL;\n+\n+      /* We're hoping that BB is a join point for an IF-THEN-ELSE diamond\n+\t region.  Verify that it is.\n+\n+\t First, verify that BB has two predecessors (each arm of the\n+\t IF-THEN-ELSE) and two successors (the latch and exit).  */\n+      if (EDGE_COUNT (bb->preds) == 2 && EDGE_COUNT (bb->succs) == 2)\n+\t{\n+\t  /* Now verify that BB's immediate dominator ends in a\n+\t     conditional as well.  */\n+\t  basic_block bb_idom = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\t  gimple *last = gsi_stmt (gsi_last_nondebug_bb (bb_idom));\n+\t  if (!last || gimple_code (last) != GIMPLE_COND)\n+\t    return NULL;\n+\n+\t  /* And that BB's immediate dominator's successors are the\n+\t     the predecessors of BB.  */\n+\t  if (!find_edge (bb_idom, EDGE_PRED (bb, 0)->src)\n+\t      || !find_edge (bb_idom, EDGE_PRED (bb, 1)->src))\n+\t    return NULL;\n+\n+\t  /* So at this point we have a simple diamond for an IF-THEN-ELSE\n+\t     construct starting at BB_IDOM, with a join point at BB.  BB\n+\t     pass control outside the loop or to the loop latch.\n+\n+\t     We're going to want to create two duplicates of BB, one for\n+\t     each successor of BB_IDOM.  */\n+\t  return bb;\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+/* Return TRUE if BB is a reasonable block to duplicate by examining\n+   its size, false otherwise.  BB will always be a loop latch block.\n+\n+   Should this use the same tests as we do for jump threading?  */\n+\n+static bool\n+is_feasible_trace (basic_block bb)\n+{\n+  int num_stmt = 0;\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (!is_gimple_debug (stmt))\n+\tnum_stmt++;\n+    }\n+\n+  /* We may want to limit how many statements we copy.  */\n+  if (num_stmt > 1)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* If the immediate dominator of the latch of the loop is\n+   block with conditional branch, then the loop latch  is\n+   duplicated to its predecessors path preserving the SSA\n+   semantics.\n+\n+   CFG before transformation.\n+\n+              2\n+              |\n+              |\n+        +---->3\n+        |    / \\\n+        |   /   \\\n+        |  4     5\n+        |   \\   /\n+        |    \\ /\n+        |     6\n+        |    / \\\n+        |   /   \\\n+        |  8     7\n+        |  |     |\n+        ---+     E\n+\n+\n+\n+    Block 8 is the latch.  We're going to make copies of block 6 (9 & 10)\n+    and wire things up so they look like this:\n+\n+              2\n+              |\n+              |\n+        +---->3\n+        |    / \\\n+        |   /   \\\n+        |  4     5\n+        |  |     |\n+        |  |     |\n+        |  9    10\n+        |  |\\   /|\n+        |  | \\ / |\n+        |  |  7  |\n+        |  |  |  |\n+        |  |  E  |\n+        |  |     |\n+        |   \\   /\n+        |    \\ /\n+        +-----8\n+\n+\n+    Blocks 9 and 10 will get merged into blocks 4 & 5 respectively which\n+    enables CSE, DCE and other optimizations to occur on a larger block\n+    of code.   */\n+\n+static bool\n+split_paths ()\n+{\n+  bool changed = false;\n+  loop_p loop;\n+\n+  loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n+  initialize_original_copy_tables ();\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n+    {\n+      /* See if there is a block that we can duplicate to split the\n+\t path to the loop latch.  */\n+      basic_block bb = find_block_to_duplicate_for_splitting_paths (loop->latch);\n+\n+      /* BB is the merge point for an IF-THEN-ELSE we want to transform.\n+\n+\t Essentially we want to create two duplicates of BB and append\n+\t a duplicate to the THEN and ELSE clauses.  This will split the\n+\t path leading to the latch.  BB will be unreachable and removed.  */\n+      if (bb && is_feasible_trace (bb))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Duplicating join block %d into predecessor paths\\n\",\n+\t\t     bb->index);\n+\t  basic_block pred0 = EDGE_PRED (bb, 0)->src;\n+\t  basic_block pred1 = EDGE_PRED (bb, 1)->src;\n+\t  transform_duplicate (pred0, bb);\n+\t  transform_duplicate (pred1, bb);\n+\t  changed = true;\n+\t}\n+    }\n+\n+  loop_optimizer_finalize ();\n+  free_original_copy_tables ();\n+  return changed;\n+}\n+\n+/* Main entry point for splitting paths.  Returns TODO_cleanup_cfg if any\n+   paths where split, otherwise return zero.  */\n+\n+static unsigned int\n+execute_split_paths ()\n+{\n+  /* If we don't have at least 2 real blocks and backedges in the\n+     CFG, then there's no point in trying to perform path splitting.  */\n+  if (n_basic_blocks_for_fn (cfun) <= NUM_FIXED_BLOCKS + 1\n+      || !mark_dfs_back_edges ())\n+    return 0;\n+\n+  bool changed = split_paths();\n+  if (changed)\n+    free_dominance_info (CDI_DOMINATORS);\n+\n+  return changed ? TODO_cleanup_cfg : 0;\n+}\n+\n+static bool\n+gate_split_paths ()\n+{\n+  return flag_split_paths;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_split_paths =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"split-paths\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_SPLIT_PATHS, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_update_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_split_paths : public gimple_opt_pass\n+{\n+   public:\n+    pass_split_paths (gcc::context *ctxt)\n+      : gimple_opt_pass (pass_data_split_paths, ctxt)\n+    {}\n+   /* opt_pass methods: */\n+   opt_pass * clone () { return new pass_split_paths (m_ctxt); }\n+   virtual bool gate (function *) { return gate_split_paths (); }\n+   virtual unsigned int execute (function *) { return execute_split_paths (); }\n+\n+}; // class pass_split_paths\n+\n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_split_paths (gcc::context *ctxt)\n+{\n+  return new pass_split_paths (ctxt);\n+}"}, {"sha": "be04cf5641266a83778eaa8ecd9eea91e10875ba", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -523,6 +523,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_fisolate_erroneous_paths_dereference, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fipa_ra, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_flra_remat, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_fsplit_paths, NULL, 1 },\n \n     /* -O3 optimizations.  */\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },"}, {"sha": "db822d335971a059bf4cc2c7fc41b1435ef50812", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -274,6 +274,7 @@ along with GCC; see the file COPYING3.  If not see\n       POP_INSERT_PASSES ()\n       NEXT_PASS (pass_simduid_cleanup);\n       NEXT_PASS (pass_lower_vector_ssa);\n+      NEXT_PASS (pass_split_paths);\n       NEXT_PASS (pass_cse_reciprocals);\n       NEXT_PASS (pass_reassoc);\n       NEXT_PASS (pass_strength_reduction);"}, {"sha": "ee92aaf3275f1b804583a7a961717b17f6a3e40f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -1,3 +1,8 @@\n+2015-11-13  Ajit Agarwal  <ajitkum@xilinx.com>\n+            Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/tree-ssa/split-path-1.c: New test.\n+\n 2015-11-13  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* c-c++-common/goacc/loop-auto-1.c: New."}, {"sha": "12398924dbab33a93fcecd2809eb13239b00e04d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/split-path-1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsplit-path-1.c?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-split-paths-details \" } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#define RGBMAX 255\n+\n+int\n+test()\n+{\n+  int i, Pels;\n+  unsigned char sum = 0;\n+  unsigned char xr, xg, xb;\n+  unsigned char xc, xm, xy, xk;\n+  unsigned char *ReadPtr, *EritePtr;\n+\n+  ReadPtr = ( unsigned char *) malloc (sizeof (unsigned char) * 100);\n+  EritePtr = ( unsigned char *) malloc (sizeof (unsigned char) * 100);\n+\n+  for (i = 0; i < 100;i++)\n+     {\n+       ReadPtr[i] = 100 - i;\n+     }\n+\n+  for (i = 0; i < 100; i++)\n+     {\n+       xr = *ReadPtr++;\n+       xg = *ReadPtr++;\n+       xb = *ReadPtr++;\n+\n+       xc = (unsigned char) (RGBMAX - xr);\n+       xm = (unsigned char) (RGBMAX - xg);\n+       xy = (unsigned char) (RGBMAX - xb);\n+\n+       if (xc < xm)\n+         {\n+           xk = (unsigned char) (xc < xy ? xc : xy);\n+         }\n+       else\n+        {\n+          xk = (unsigned char) (xm < xy ? xm : xy);\n+        }\n+\n+       xc = (unsigned char) (xc - xk);\n+       xm = (unsigned char) (xm - xk);\n+       xy = (unsigned char) (xy - xk);\n+\n+       *EritePtr++ = xc;\n+       *EritePtr++ = xm;\n+       *EritePtr++ = xy;\n+       *EritePtr++ = xk;\n+       sum += *EritePtr;\n+    }\n+  return sum;\n+}\n+\n+int\n+main()\n+{\n+  if (test() != 33)\n+    abort();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Duplicating join block\" \"split-paths\" } } */"}, {"sha": "45e3b709af1a58499f8e46fd676e94d2a742f8d3", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -252,6 +252,7 @@ DEFTIMEVAR (TV_GCSE_AFTER_RELOAD     , \"load CSE after reload\")\n DEFTIMEVAR (TV_REE\t\t     , \"ree\")\n DEFTIMEVAR (TV_THREAD_PROLOGUE_AND_EPILOGUE, \"thread pro- & epilogue\")\n DEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")\n+DEFTIMEVAR (TV_SPLIT_PATHS\t     , \"split paths\")\n DEFTIMEVAR (TV_COMBINE_STACK_ADJUST  , \"combine stack adjustments\")\n DEFTIMEVAR (TV_PEEPHOLE2             , \"peephole 2\")\n DEFTIMEVAR (TV_RENAME_REGISTERS      , \"rename registers\")"}, {"sha": "c2dba4c2503307ede20d9fe7f38ed36b5c5b271d", "filename": "gcc/tracer.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -51,9 +51,9 @@\n #include \"tree-inline.h\"\n #include \"cfgloop.h\"\n #include \"fibonacci_heap.h\"\n+#include \"tracer.h\"\n \n static int count_insns (basic_block);\n-static bool ignore_bb_p (const_basic_block);\n static bool better_p (const_edge, const_edge);\n static edge find_best_successor (basic_block);\n static edge find_best_predecessor (basic_block);\n@@ -85,7 +85,7 @@ bb_seen_p (basic_block bb)\n }\n \n /* Return true if we should ignore the basic block for purposes of tracing.  */\n-static bool\n+bool\n ignore_bb_p (const_basic_block bb)\n {\n   if (bb->index < NUM_FIXED_BLOCKS)\n@@ -226,6 +226,24 @@ find_trace (basic_block bb, basic_block *trace)\n   return i;\n }\n \n+/* Duplicate block BB2, placing it after BB in the CFG.  Return the\n+   newly created block.  */\n+basic_block\n+transform_duplicate (basic_block bb, basic_block bb2)\n+{\n+  edge e;\n+  basic_block copy;\n+\n+  e = find_edge (bb, bb2);\n+\n+  copy = duplicate_block (bb2, e, bb);\n+  flush_pending_stmts (e);\n+\n+  add_phi_args_after_copy (&copy, 1, NULL);\n+\n+  return (copy);\n+}\n+\n /* Look for basic blocks in frequency order, construct traces and tail duplicate\n    if profitable.  */\n \n@@ -321,17 +339,8 @@ tail_duplicate (void)\n \t\t entries or at least rotate the loop.  */\n \t      && bb2->loop_father->header != bb2)\n \t    {\n-\t      edge e;\n-\t      basic_block copy;\n-\n \t      nduplicated += counts [bb2->index];\n-\n-\t      e = find_edge (bb, bb2);\n-\n-\t      copy = duplicate_block (bb2, e, bb);\n-\t      flush_pending_stmts (e);\n-\n-\t      add_phi_args_after_copy (&copy, 1, NULL);\n+\t      basic_block copy = transform_duplicate (bb, bb2);\n \n \t      /* Reconsider the original copy of block we've duplicated.\n \t         Removing the most common predecessor may make it to be"}, {"sha": "cd1792a73fb98bf90b4cf6d90f4741d0122d9039", "filename": "gcc/tracer.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftracer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftracer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.h?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -0,0 +1,26 @@\n+/* Header file for Tracer.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_TRACER_H\n+#define GCC_TRACER_H\n+\n+extern basic_block transform_duplicate (basic_block bb, basic_block bb2);\n+extern bool ignore_bb_p (const_basic_block bb);\n+\n+#endif /* GCC_TRACER_H */"}, {"sha": "da67761782688e0135c5f6373c726b5a82bf7cab", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fe17e23b052741c8cbec99c7173c3c07f8e8c64/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=8fe17e23b052741c8cbec99c7173c3c07f8e8c64", "patch": "@@ -390,6 +390,7 @@ extern gimple_opt_pass *make_pass_tree_loop_done (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_ch (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_ch_vect (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_ccp (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_split_paths (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_phi_only_cprop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_build_ssa (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_build_alias (gcc::context *ctxt);"}]}