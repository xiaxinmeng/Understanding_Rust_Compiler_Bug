{"sha": "e035be33793fa4aef8cff3358c9670a648d5d273", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTAzNWJlMzM3OTNmYTRhZWY4Y2ZmMzM1OGM5NjcwYTY0OGQ1ZDI3Mw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2017-09-01T16:29:49Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2017-09-01T16:29:49Z"}, "message": "Fix excess precision handling of compound assignments (PR c/82071).\n\nPR c/82071 reports how compound assignment operators such as += handle\nexcess precision inconsistently with the same operation done with a\nplain assignment and binary operator.\n\nThere were (at least) two problems with how compound assignments\nhandled excess precision.  The EXCESS_PRECISION_EXPR for an argument\nwith excess precision was removed too early, resulting in\nbuild_binary_op being called with an rhs operand whose type reflected\nthe evaluation format, so not having sufficient information to achieve\nthe intended semantics in all cases, and then the code called\nc_fully_fold on the results of build_binary_op without allowing for\nthe possibility of an EXCESS_PRECISION_EXPR as the result, so leading\nto double rounding of the result (first to its semantic type, then to\nthe type of the LHS of the assignment) instead of the intended single\nrounding.\n\nThis patch fixes those problems by keeping EXCESS_PRECISION_EXPRs\nfurther through build_modify_expr (and build_atomic_assign which it\ncalls) and only removing them locally where appropriate.\n\nNote that while this patch should achieve *consistency*, that's\nconsistency with the understanding of C99 semantics that I originally\nintended to implement.  For the particular case in the testcase, C11\nsemantics (from N1531) differ from that understanding of C99\nsemantics, in that an implicit conversion of an integer to floating\npoint can have excess precision.  I intend to implement those C11\nsemantics separately (conditional on flag_isoc11) (which will also\nmean that building conditional expressions can produce a result with\nexcess precision even when the arguments lack excess precision, where\npreviously it could not), and not to close the bug until that is also\ndone.\n\nTested for x86_64-pc-linux-gnu.\n\n\tPR c/82071\ngcc/c:\n\t* c-typeck.c (build_atomic_assign): Handle argument with excess\n\tprecision.  Ensure any EXCESS_PRECISION_EXPR is present in\n\targument passed to build_binary_op and convert_for_assignment but\n\tnot for call to c_fully_fold.\n\t(build_modify_expr): Do not remove EXCESS_PRECISION_EXPR early.\n\tEnsure build_binary_op is called with argument with original\n\tsemantic type.  Avoid calling c_fully_fold with an\n\tEXCESS_PRECISION_EXPR from build_binary_op.\n\ngcc/testsuite:\n\t* gcc.target/i386/excess-precision-7.c: New test.\n\nFrom-SVN: r251603", "tree": {"sha": "11353534ef9b641985f5e08482bca67fd2f81dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11353534ef9b641985f5e08482bca67fd2f81dd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e035be33793fa4aef8cff3358c9670a648d5d273", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e035be33793fa4aef8cff3358c9670a648d5d273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e035be33793fa4aef8cff3358c9670a648d5d273", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e035be33793fa4aef8cff3358c9670a648d5d273/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ec399d8a6c9c26d69b73faf77c694fa3915dcec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec399d8a6c9c26d69b73faf77c694fa3915dcec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ec399d8a6c9c26d69b73faf77c694fa3915dcec"}], "stats": {"total": 110, "additions": 99, "deletions": 11}, "files": [{"sha": "2d25c4816c650c39d14ce11447ceefec275b6232", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e035be33793fa4aef8cff3358c9670a648d5d273/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e035be33793fa4aef8cff3358c9670a648d5d273/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=e035be33793fa4aef8cff3358c9670a648d5d273", "patch": "@@ -1,3 +1,15 @@\n+2017-09-01  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/82071\n+\t* c-typeck.c (build_atomic_assign): Handle argument with excess\n+\tprecision.  Ensure any EXCESS_PRECISION_EXPR is present in\n+\targument passed to build_binary_op and convert_for_assignment but\n+\tnot for call to c_fully_fold.\n+\t(build_modify_expr): Do not remove EXCESS_PRECISION_EXPR early.\n+\tEnsure build_binary_op is called with argument with original\n+\tsemantic type.  Avoid calling c_fully_fold with an\n+\tEXCESS_PRECISION_EXPR from build_binary_op.\n+\n 2017-09-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/81887"}, {"sha": "91996c95ed070c0b68f024a0df9aa054d2a84a93", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e035be33793fa4aef8cff3358c9670a648d5d273/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e035be33793fa4aef8cff3358c9670a648d5d273/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=e035be33793fa4aef8cff3358c9670a648d5d273", "patch": "@@ -3919,7 +3919,9 @@ build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n   tree lhs_type = TREE_TYPE (lhs);\n   tree lhs_addr = build_unary_op (loc, ADDR_EXPR, lhs, false);\n   tree seq_cst = build_int_cst (integer_type_node, MEMMODEL_SEQ_CST);\n-  tree rhs_type = TREE_TYPE (rhs);\n+  tree rhs_semantic_type = TREE_TYPE (rhs);\n+  tree nonatomic_rhs_semantic_type;\n+  tree rhs_type;\n \n   gcc_assert (TYPE_ATOMIC (lhs_type));\n \n@@ -3933,6 +3935,15 @@ build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n      with a loop.  */\n   compound_stmt = c_begin_compound_stmt (false);\n \n+  /* Remove any excess precision (which is only present here in the\n+     case of compound assignments).  */\n+  if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n+    {\n+      gcc_assert (modifycode != NOP_EXPR);\n+      rhs = TREE_OPERAND (rhs, 0);\n+    }\n+  rhs_type = TREE_TYPE (rhs);\n+\n   /* Fold the RHS if it hasn't already been folded.  */\n   if (modifycode != NOP_EXPR)\n     rhs = c_fully_fold (rhs, false, NULL);\n@@ -3941,6 +3952,8 @@ build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n      the VAL temp variable to hold the RHS.  */\n   nonatomic_lhs_type = build_qualified_type (lhs_type, TYPE_UNQUALIFIED);\n   nonatomic_rhs_type = build_qualified_type (rhs_type, TYPE_UNQUALIFIED);\n+  nonatomic_rhs_semantic_type = build_qualified_type (rhs_semantic_type,\n+\t\t\t\t\t\t      TYPE_UNQUALIFIED);\n   val = create_tmp_var_raw (nonatomic_rhs_type);\n   TREE_ADDRESSABLE (val) = 1;\n   TREE_NO_WARNING (val) = 1;\n@@ -4100,8 +4113,17 @@ build_atomic_assign (location_t loc, tree lhs, enum tree_code modifycode,\n   add_stmt (loop_label);\n \n   /* newval = old + val;  */\n+  if (rhs_type != rhs_semantic_type)\n+    val = build1 (EXCESS_PRECISION_EXPR, nonatomic_rhs_semantic_type, val);\n   rhs = build_binary_op (loc, modifycode, old, val, true);\n-  rhs = c_fully_fold (rhs, false, NULL);\n+  if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n+    {\n+      tree eptype = TREE_TYPE (rhs);\n+      rhs = c_fully_fold (TREE_OPERAND (rhs, 0), false, NULL);\n+      rhs = build1 (EXCESS_PRECISION_EXPR, eptype, rhs);\n+    }\n+  else\n+    rhs = c_fully_fold (rhs, false, NULL);\n   rhs = convert_for_assignment (loc, UNKNOWN_LOCATION, nonatomic_lhs_type,\n \t\t\t\trhs, NULL_TREE, ic_assign, false, NULL_TREE,\n \t\t\t\tNULL_TREE, 0);\n@@ -5727,7 +5749,6 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   tree result;\n   tree newrhs;\n   tree rhseval = NULL_TREE;\n-  tree rhs_semantic_type = NULL_TREE;\n   tree lhstype = TREE_TYPE (lhs);\n   tree olhstype = lhstype;\n   bool npc;\n@@ -5754,12 +5775,6 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n \n   is_atomic_op = really_atomic_lvalue (lhs);\n \n-  if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n-    {\n-      rhs_semantic_type = TREE_TYPE (rhs);\n-      rhs = TREE_OPERAND (rhs, 0);\n-    }\n-\n   newrhs = rhs;\n \n   if (TREE_CODE (lhs) == C_MAYBE_CONST_EXPR)\n@@ -5794,8 +5809,14 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n \t     that modify LHS.  */\n \t  if (TREE_SIDE_EFFECTS (rhs))\n \t    {\n-\t      newrhs = save_expr (rhs);\n+\t      if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n+\t\tnewrhs = save_expr (TREE_OPERAND (rhs, 0));\n+\t      else\n+\t\tnewrhs = save_expr (rhs);\n \t      rhseval = newrhs;\n+\t      if (TREE_CODE (rhs) == EXCESS_PRECISION_EXPR)\n+\t\tnewrhs = build1 (EXCESS_PRECISION_EXPR, TREE_TYPE (rhs),\n+\t\t\t\t newrhs);\n \t    }\n \t  newrhs = build_binary_op (location,\n \t\t\t\t    modifycode, lhs, newrhs, true);\n@@ -5810,7 +5831,10 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n     {\n       /* Check if we are modifying an Objective-C property reference;\n \t if so, we need to generate setter calls.  */\n-      result = objc_maybe_build_modify_expr (lhs, newrhs);\n+      if (TREE_CODE (newrhs) == EXCESS_PRECISION_EXPR)\n+\tresult = objc_maybe_build_modify_expr (lhs, TREE_OPERAND (newrhs, 0));\n+      else\n+\tresult = objc_maybe_build_modify_expr (lhs, newrhs);\n       if (result)\n \tgoto return_result;\n \n@@ -5887,6 +5911,12 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n \n   if (!(is_atomic_op && modifycode != NOP_EXPR))\n     {\n+      tree rhs_semantic_type = NULL_TREE;\n+      if (TREE_CODE (newrhs) == EXCESS_PRECISION_EXPR)\n+\t{\n+\t  rhs_semantic_type = TREE_TYPE (newrhs);\n+\t  newrhs = TREE_OPERAND (newrhs, 0);\n+\t}\n       npc = null_pointer_constant_p (newrhs);\n       newrhs = c_fully_fold (newrhs, false, NULL);\n       if (rhs_semantic_type)"}, {"sha": "20f579e391da6d0c3901aa3a7574dfb7d5b066c9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e035be33793fa4aef8cff3358c9670a648d5d273/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e035be33793fa4aef8cff3358c9670a648d5d273/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e035be33793fa4aef8cff3358c9670a648d5d273", "patch": "@@ -1,3 +1,8 @@\n+2017-09-01  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/82071\n+\t* gcc.target/i386/excess-precision-7.c: New test.\n+\n 2017-09-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \tPR target/82012"}, {"sha": "0cdd932ce7f07858cf20fd922d55d464bb4fb061", "filename": "gcc/testsuite/gcc.target/i386/excess-precision-7.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e035be33793fa4aef8cff3358c9670a648d5d273/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e035be33793fa4aef8cff3358c9670a648d5d273/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fexcess-precision-7.c?ref=e035be33793fa4aef8cff3358c9670a648d5d273", "patch": "@@ -0,0 +1,41 @@\n+/* Excess precision tests.  Test C99 semantics for conversions from\n+   integers to floating point: no excess precision for either explicit\n+   or implicit conversions.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c99 -mfpmath=387 -fexcess-precision=standard\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+int\n+main (void)\n+{\n+  float f = 1.0f;\n+  int i;\n+\n+  i = 0x10001234;\n+  if ((float) i != 0x10001240)\n+    abort ();\n+\n+  i = 0x10001234;\n+  i += f;\n+  if (i != 0x10001241)\n+    abort ();\n+\n+  i = 0x10001234;\n+  i += 1.0f;\n+  if (i != 0x10001241)\n+    abort ();\n+\n+  i = 0x10001234;\n+  i = i + f;\n+  if (i != 0x10001241)\n+    abort ();\n+\n+  i = 0x10001234;\n+  i = i + 1.0f;\n+  if (i != 0x10001241)\n+    abort ();\n+\n+  exit (0);\n+}"}]}