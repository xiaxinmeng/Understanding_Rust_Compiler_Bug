{"sha": "0a8cb79ede665d6903190b4d086bfe1fb592ec74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE4Y2I3OWVkZTY2NWQ2OTAzMTkwYjRkMDg2YmZlMWZiNTkyZWM3NA==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-13T13:34:16Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-13T13:34:16Z"}, "message": "* typeck2.c: Convert to ISO C.\n\nFrom-SVN: r67895", "tree": {"sha": "21144e876b5f5daa8b1d4a41432bf1bfab0be484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21144e876b5f5daa8b1d4a41432bf1bfab0be484"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a8cb79ede665d6903190b4d086bfe1fb592ec74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8cb79ede665d6903190b4d086bfe1fb592ec74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8cb79ede665d6903190b4d086bfe1fb592ec74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8cb79ede665d6903190b4d086bfe1fb592ec74/comments", "author": null, "committer": null, "parents": [{"sha": "c873e11f46a1fee89d9205052fc4455276ab723c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c873e11f46a1fee89d9205052fc4455276ab723c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c873e11f46a1fee89d9205052fc4455276ab723c"}], "stats": {"total": 70, "additions": 24, "deletions": 46}, "files": [{"sha": "f4b4f2e5bf8805fcf01aca4313a50aaceeb28ace", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8cb79ede665d6903190b4d086bfe1fb592ec74/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8cb79ede665d6903190b4d086bfe1fb592ec74/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0a8cb79ede665d6903190b4d086bfe1fb592ec74", "patch": "@@ -1,3 +1,7 @@\n+2003-06-13  Nathanael Nerode  <neroden@gcc.gnu.org>\n+\n+\t* typeck2.c: Convert to ISO C.\n+\n 2003-06-12  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/10635"}, {"sha": "0587816f3eecf1f620201eb4d92ae817f1406639", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 20, "deletions": 46, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a8cb79ede665d6903190b4d086bfe1fb592ec74/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a8cb79ede665d6903190b4d086bfe1fb592ec74/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=0a8cb79ede665d6903190b4d086bfe1fb592ec74", "patch": "@@ -42,14 +42,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"diagnostic.h\"\n \n-static tree process_init_constructor PARAMS ((tree, tree, tree *));\n+static tree process_init_constructor (tree, tree, tree *);\n \n /* Print an error message stemming from an attempt to use\n    BASETYPE as a base class for TYPE.  */\n \n tree\n-error_not_base_type (basetype, type)\n-     tree basetype, type;\n+error_not_base_type (tree basetype, tree type)\n {\n   if (TREE_CODE (basetype) == FUNCTION_DECL)\n     basetype = DECL_CONTEXT (basetype);\n@@ -58,8 +57,7 @@ error_not_base_type (basetype, type)\n }\n \n tree\n-binfo_or_else (base, type)\n-     tree base, type;\n+binfo_or_else (tree base, tree type)\n {\n   tree binfo = lookup_base (type, base, ba_ignore, NULL);\n \n@@ -76,13 +74,10 @@ binfo_or_else (base, type)\n    example, conversions to references.)  */\n \n void\n-readonly_error (arg, string, soft)\n-     tree arg;\n-     const char *string;\n-     int soft;\n+readonly_error (tree arg, const char* string, int soft)\n {\n   const char *fmt;\n-  void (*fn) PARAMS ((const char *, ...));\n+  void (*fn) (const char *, ...);\n \n   if (soft)\n     fn = pedwarn;\n@@ -128,9 +123,7 @@ readonly_error (arg, string, soft)\n    occurred; zero if all was well.  */\n \n int\n-abstract_virtuals_error (decl, type)\n-     tree decl;\n-     tree type;\n+abstract_virtuals_error (tree decl, tree type)\n {\n   tree u;\n   tree tu;\n@@ -194,14 +187,11 @@ abstract_virtuals_error (decl, type)\n    pedwarn.  */\n \n void\n-cxx_incomplete_type_diagnostic (value, type, diag_type)\n-     tree value;\n-     tree type;\n-     int diag_type;\n+cxx_incomplete_type_diagnostic (tree value, tree type, int diag_type)\n {\n   int decl = 0;\n-  void (*p_msg) PARAMS ((const char *, ...));\n-  void (*p_msg_at) PARAMS ((const char *, ...));\n+  void (*p_msg) (const char *, ...);\n+  void (*p_msg_at) (const char *, ...);\n \n   if (diag_type == 1)\n     {\n@@ -288,9 +278,7 @@ cxx_incomplete_type_diagnostic (value, type, diag_type)\n    required by ../tree.c.  */\n #undef cxx_incomplete_type_error\n void\n-cxx_incomplete_type_error (value, type)\n-     tree value;\n-     tree type;\n+cxx_incomplete_type_error (tree value, tree type)\n {\n   cxx_incomplete_type_diagnostic (value, type, 0);\n }\n@@ -316,8 +304,7 @@ cxx_incomplete_type_error (value, type)\n    the storing.  */\n \n tree\n-store_init_value (decl, init)\n-     tree decl, init;\n+store_init_value (tree decl, tree init)\n {\n   register tree value, type;\n \n@@ -409,8 +396,7 @@ store_init_value (decl, init)\n    TYPE is an aggregate and INIT is not a constructor.  */\n \n tree\n-digest_init (type, init, tail)\n-     tree type, init, *tail;\n+digest_init (tree type, tree init, tree* tail)\n {\n   enum tree_code code = TREE_CODE (type);\n   tree element = NULL_TREE;\n@@ -605,8 +591,7 @@ digest_init (type, init, tail)\n    constants that the assembler and linker can compute them.  */\n \n static tree\n-process_init_constructor (type, init, elts)\n-     tree type, init, *elts;\n+process_init_constructor (tree type, tree init, tree* elts)\n {\n   register tree tail;\n   /* List of the elements of the result constructor,\n@@ -964,10 +949,7 @@ process_init_constructor (type, init, elts)\n    binfo for the specific base subobject we want to convert to.  */\n \n tree\n-build_scoped_ref (datum, basetype, binfo_p)\n-     tree datum;\n-     tree basetype;\n-     tree *binfo_p;\n+build_scoped_ref (tree datum, tree basetype, tree* binfo_p)\n {\n   tree binfo;\n \n@@ -998,8 +980,7 @@ build_scoped_ref (datum, basetype, binfo_p)\n    delegation is detected.  */\n \n tree\n-build_x_arrow (datum)\n-     tree datum;\n+build_x_arrow (tree datum)\n {\n   tree types_memoized = NULL_TREE;\n   register tree rval = datum;\n@@ -1080,8 +1061,7 @@ build_x_arrow (datum)\n    routines will have to know how to deal with later.  */\n \n tree\n-build_m_component_ref (datum, component)\n-     tree datum, component;\n+build_m_component_ref (tree datum, tree component)\n {\n   tree type;\n   tree objtype;\n@@ -1161,9 +1141,7 @@ build_m_component_ref (datum, component)\n /* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */\n \n tree\n-build_functional_cast (exp, parms)\n-     tree exp;\n-     tree parms;\n+build_functional_cast (tree exp, tree parms)\n {\n   /* This is either a call to a constructor,\n      or a C cast in C++'s `functional' notation.  */\n@@ -1251,9 +1229,7 @@ build_functional_cast (exp, parms)\n    know what we're doing.  */\n \n tree\n-add_exception_specifier (list, spec, complain)\n-     tree list, spec;\n-     int complain;\n+add_exception_specifier (tree list, tree spec, int complain)\n {\n   int ok;\n   tree core = spec;\n@@ -1313,8 +1289,7 @@ add_exception_specifier (list, spec, complain)\n    their union.  */\n \n tree\n-merge_exception_specifiers (list, add)\n-     tree list, add;\n+merge_exception_specifiers (tree list, tree add)\n {\n   if (!list || !add)\n     return NULL_TREE;\n@@ -1352,8 +1327,7 @@ merge_exception_specifiers (list, add)\n    function is defined or called.  See also add_exception_specifier.  */\n \n void\n-require_complete_eh_spec_types (fntype, decl)\n-     tree fntype, decl;\n+require_complete_eh_spec_types (tree fntype, tree decl)\n {\n   tree raises;\n   /* Don't complain about calls to op new.  */"}]}