{"sha": "f12e8c3f66aa688af9dc5e5a185b6f238aee7926", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEyZThjM2Y2NmFhNjg4YWY5ZGM1ZTVhMTg1YjZmMjM4YWVlNzkyNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-08-02T16:27:17Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-08-02T16:27:17Z"}, "message": "compiler: only finalize embedded fields before finalizing methods\n    \n    When finalizing the methods of a named struct type, we used to\n    finalize all the field types first.  That can fail if the field types\n    refer indirectly to the named type.  Change it to just finalize the\n    embedded field types first, and the rest of the fields later.\n    \n    Fixes golang/go#21253\n    \n    Reviewed-on: https://go-review.googlesource.com/52570\n\nFrom-SVN: r250832", "tree": {"sha": "eb35b7e42661e0fd9a8672831a9fa0bd347f3afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb35b7e42661e0fd9a8672831a9fa0bd347f3afc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f12e8c3f66aa688af9dc5e5a185b6f238aee7926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f12e8c3f66aa688af9dc5e5a185b6f238aee7926", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f12e8c3f66aa688af9dc5e5a185b6f238aee7926", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f12e8c3f66aa688af9dc5e5a185b6f238aee7926/comments", "author": null, "committer": null, "parents": [{"sha": "893e8f7d87a6ace9a8bdedb5d18aab1f44fb11ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893e8f7d87a6ace9a8bdedb5d18aab1f44fb11ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/893e8f7d87a6ace9a8bdedb5d18aab1f44fb11ca"}], "stats": {"total": 43, "additions": 35, "deletions": 8}, "files": [{"sha": "7c96176261b05f675dce37507a9ecf46c4064beb", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12e8c3f66aa688af9dc5e5a185b6f238aee7926/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12e8c3f66aa688af9dc5e5a185b6f238aee7926/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f12e8c3f66aa688af9dc5e5a185b6f238aee7926", "patch": "@@ -1,4 +1,4 @@\n-f7c36b27a49131f60eedde260896d310d735d408\n+c1ac6bc99f988633c6bc68a5ca9ffad3487750ef\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "5dbe29da261a64ccc586172bd853daeacc9162ed", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12e8c3f66aa688af9dc5e5a185b6f238aee7926/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12e8c3f66aa688af9dc5e5a185b6f238aee7926/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f12e8c3f66aa688af9dc5e5a185b6f238aee7926", "patch": "@@ -3058,26 +3058,53 @@ Finalize_methods::type(Type* t)\n \n     case Type::TYPE_NAMED:\n       {\n-\t// We have to finalize the methods of the real type first.\n-\t// But if the real type is a struct type, then we only want to\n-\t// finalize the methods of the field types, not of the struct\n-\t// type itself.  We don't want to add methods to the struct,\n-\t// since it has a name.\n \tNamed_type* nt = t->named_type();\n \tType* rt = nt->real_type();\n \tif (rt->classification() != Type::TYPE_STRUCT)\n \t  {\n+\t    // Finalize the methods of the real type first.\n \t    if (Type::traverse(rt, this) == TRAVERSE_EXIT)\n \t      return TRAVERSE_EXIT;\n+\n+\t    // Finalize the methods of this type.\n+\t    nt->finalize_methods(this->gogo_);\n \t  }\n \telse\n \t  {\n+\t    // We don't want to finalize the methods of a named struct\n+\t    // type, as the methods should be attached to the named\n+\t    // type, not the struct type.  We just want to finalize\n+\t    // the field types.\n+\t    //\n+\t    // It is possible that a field type refers indirectly to\n+\t    // this type, such as via a field with function type with\n+\t    // an argument or result whose type is this type.  To\n+\t    // avoid the cycle, first finalize the methods of any\n+\t    // embedded types, which are the only types we need to\n+\t    // know to finalize the methods of this type.\n+\t    const Struct_field_list* fields = rt->struct_type()->fields();\n+\t    if (fields != NULL)\n+\t      {\n+\t\tfor (Struct_field_list::const_iterator pf = fields->begin();\n+\t\t     pf != fields->end();\n+\t\t     ++pf)\n+\t\t  {\n+\t\t    if (pf->is_anonymous())\n+\t\t      {\n+\t\t\tif (Type::traverse(pf->type(), this) == TRAVERSE_EXIT)\n+\t\t\t  return TRAVERSE_EXIT;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\n+\t    // Finalize the methods of this type.\n+\t    nt->finalize_methods(this->gogo_);\n+\n+\t    // Finalize all the struct fields.\n \t    if (rt->struct_type()->traverse_field_types(this) == TRAVERSE_EXIT)\n \t      return TRAVERSE_EXIT;\n \t  }\n \n-\tnt->finalize_methods(this->gogo_);\n-\n \t// If this type is defined in a different package, then finalize the\n \t// types of all the methods, since we won't see them otherwise.\n \tif (nt->named_object()->package() != NULL && nt->has_any_methods())"}]}