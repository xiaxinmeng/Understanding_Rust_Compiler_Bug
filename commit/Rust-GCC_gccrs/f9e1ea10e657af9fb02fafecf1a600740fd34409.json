{"sha": "f9e1ea10e657af9fb02fafecf1a600740fd34409", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjllMWVhMTBlNjU3YWY5ZmIwMmZhZmVjZjFhNjAwNzQwZmQzNDQwOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-04-30T08:47:15Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-04T12:14:36Z"}, "message": "tree-optimization/39612 - avoid issueing loads in SM when possible\n\nCurrently store-motion emits a load of the value in the loop\npreheader even when the original loop does not contain any read\nof the reference.  This avoids doing this.  In the conditional\nstore-motion case we need to mark the sunk stores with no-warning\nsince the control dependence is too tricky to figure out for\nthe uninit warning.\n\n2020-05-04  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/39612\n\t* tree-ssa-loop-im.c (im_mem_ref::loaded): New member.\n\t(set_ref_loaded_in_loop): New.\n\t(mark_ref_loaded): Likewise.\n\t(gather_mem_refs_stmt): Call mark_ref_loaded for loads.\n\t(execute_sm): Avoid issueing a load when it was not there.\n\t(execute_sm_if_changed): Avoid issueing warnings for the\n\tconditional store.\n\n\t* gcc.dg/tree-ssa/pr39612.c: New testcase.", "tree": {"sha": "3bbed9af6d91c30c5e64d64f17aa58214c377f97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bbed9af6d91c30c5e64d64f17aa58214c377f97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9e1ea10e657af9fb02fafecf1a600740fd34409", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e1ea10e657af9fb02fafecf1a600740fd34409", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9e1ea10e657af9fb02fafecf1a600740fd34409", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9e1ea10e657af9fb02fafecf1a600740fd34409/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "375a77925c320a273d3b1ef3182f29f31aaa8edf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/375a77925c320a273d3b1ef3182f29f31aaa8edf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/375a77925c320a273d3b1ef3182f29f31aaa8edf"}], "stats": {"total": 84, "additions": 76, "deletions": 8}, "files": [{"sha": "61d5ce5ae1f1df673ebcdbce2dac03ebf71a45cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e1ea10e657af9fb02fafecf1a600740fd34409/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e1ea10e657af9fb02fafecf1a600740fd34409/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9e1ea10e657af9fb02fafecf1a600740fd34409", "patch": "@@ -1,3 +1,14 @@\n+2020-05-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39612\n+\t* tree-ssa-loop-im.c (im_mem_ref::loaded): New member.\n+\t(set_ref_loaded_in_loop): New.\n+\t(mark_ref_loaded): Likewise.\n+\t(gather_mem_refs_stmt): Call mark_ref_loaded for loads.\n+\t(execute_sm): Avoid issueing a load when it was not there.\n+\t(execute_sm_if_changed): Avoid issueing warnings for the\n+\tconditional store.\n+\n 2020-05-04  Martin Jambor  <mjambor@suse.cz>\n \n \tPR ipa/93385"}, {"sha": "341b6741251554dbc432a5bb66a946fd126118ab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e1ea10e657af9fb02fafecf1a600740fd34409/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e1ea10e657af9fb02fafecf1a600740fd34409/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f9e1ea10e657af9fb02fafecf1a600740fd34409", "patch": "@@ -1,3 +1,8 @@\n+2020-05-04  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39612\n+\t* gcc.dg/tree-ssa/pr39612.c: New testcase.\n+\n 2020-05-04  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR target/94650"}, {"sha": "884f905148fa36bed754afce069d0a00ef02bb07", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr39612.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e1ea10e657af9fb02fafecf1a600740fd34409/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr39612.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e1ea10e657af9fb02fafecf1a600740fd34409/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr39612.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr39612.c?ref=f9e1ea10e657af9fb02fafecf1a600740fd34409", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim2-details -Wuninitialized\" } */\n+\n+void foo(int *);\n+void f2(int dst[3], int R)\n+{\n+  int i, inter[2];\n+\n+  for (i = 1; i < R; i++) {\n+    if (i & 8)\n+      {\n+\tinter[0] = 1;\n+\tinter[1] = 1;\n+      }\n+  }\n+\n+  foo(inter);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Executing store motion\" 2 \"lim2\" } } */\n+/* { dg-final { scan-tree-dump-not \" = inter\\\\\\[\\[0-1\\]\\\\\\];\" \"lim2\" } } */"}, {"sha": "18e5c18c17eb7472e96a9252d60b5a50698f8f1a", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9e1ea10e657af9fb02fafecf1a600740fd34409/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9e1ea10e657af9fb02fafecf1a600740fd34409/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=f9e1ea10e657af9fb02fafecf1a600740fd34409", "patch": "@@ -127,6 +127,8 @@ class im_mem_ref\n \n   bitmap stored;\t\t/* The set of loops in that this memory location\n \t\t\t\t   is stored to.  */\n+  bitmap loaded;\t\t/* The set of loops in that this memory location\n+\t\t\t\t   is loaded from.  */\n   vec<mem_ref_loc>\t\taccesses_in_loop;\n \t\t\t\t/* The locations of the accesses.  Vector\n \t\t\t\t   indexed by the loop number.  */\n@@ -1395,6 +1397,7 @@ mem_ref_alloc (ao_ref *mem, unsigned hash, unsigned id)\n   ref->ref_decomposed = false;\n   ref->hash = hash;\n   ref->stored = NULL;\n+  ref->loaded = NULL;\n   bitmap_initialize (&ref->indep_loop, &lim_bitmap_obstack);\n   bitmap_initialize (&ref->dep_loop, &lim_bitmap_obstack);\n   ref->accesses_in_loop.create (1);\n@@ -1435,6 +1438,27 @@ mark_ref_stored (im_mem_ref *ref, class loop *loop)\n     loop = loop_outer (loop);\n }\n \n+/* Set the LOOP bit in REF loaded bitmap and allocate that if\n+   necessary.  Return whether a bit was changed.  */\n+\n+static bool\n+set_ref_loaded_in_loop (im_mem_ref *ref, class loop *loop)\n+{\n+  if (!ref->loaded)\n+    ref->loaded = BITMAP_ALLOC (&lim_bitmap_obstack);\n+  return bitmap_set_bit (ref->loaded, loop->num);\n+}\n+\n+/* Marks reference REF as loaded in LOOP.  */\n+\n+static void\n+mark_ref_loaded (im_mem_ref *ref, class loop *loop)\n+{\n+  while (loop != current_loops->tree_root\n+\t && set_ref_loaded_in_loop (ref, loop))\n+    loop = loop_outer (loop);\n+}\n+\n /* Gathers memory references in statement STMT in LOOP, storing the\n    information about them in the memory_accesses structure.  Marks\n    the vops accessed through unrecognized statements there as\n@@ -1571,6 +1595,8 @@ gather_mem_refs_stmt (class loop *loop, gimple *stmt)\n       bitmap_set_bit (&memory_accesses.refs_stored_in_loop[loop->num], ref->id);\n       mark_ref_stored (ref, loop);\n     }\n+  else\n+    mark_ref_loaded (ref, loop);\n   init_lim_data (stmt)->ref = ref->id;\n   return;\n }\n@@ -1968,6 +1994,8 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n   gsi = gsi_start_bb (then_bb);\n   /* Insert actual store.  */\n   stmt = gimple_build_assign (unshare_expr (mem), tmp_var);\n+  /* Make sure to not warn about maybe-uninit uses of tmp_var here.  */\n+  gimple_set_no_warning (stmt, true);\n   gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n   edge e1 = single_succ_edge (new_bb);\n@@ -2115,14 +2143,17 @@ execute_sm (class loop *loop, vec<edge> exits, im_mem_ref *ref)\n      by move_computations after all dependencies.  */\n   gsi = gsi_for_stmt (first_mem_ref_loc (loop, ref)->stmt);\n \n-  /* FIXME/TODO: For the multi-threaded variant, we could avoid this\n-     load altogether, since the store is predicated by a flag.  We\n-     could, do the load only if it was originally in the loop.  */\n-  load = gimple_build_assign (tmp_var, unshare_expr (ref->mem.ref));\n-  lim_data = init_lim_data (load);\n-  lim_data->max_loop = loop;\n-  lim_data->tgt_loop = loop;\n-  gsi_insert_before (&gsi, load, GSI_SAME_STMT);\n+  /* Avoid doing a load if there was no load of the ref in the loop.\n+     Esp. when the ref is not always stored we cannot optimize it\n+     away later.  */\n+  if (ref->loaded && bitmap_bit_p (ref->loaded, loop->num))\n+    {\n+      load = gimple_build_assign (tmp_var, unshare_expr (ref->mem.ref));\n+      lim_data = init_lim_data (load);\n+      lim_data->max_loop = loop;\n+      lim_data->tgt_loop = loop;\n+      gsi_insert_before (&gsi, load, GSI_SAME_STMT);\n+    }\n \n   if (multi_threaded_model_p)\n     {"}]}