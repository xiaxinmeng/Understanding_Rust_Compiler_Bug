{"sha": "4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZiMGFiN2U2MzVjNjUzMThhYWRmOTU4ZTBlMTMwM2YzNDM1YzRlNQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-12-10T20:02:03Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-12-17T17:23:46Z"}, "message": "This sets up a name resolution framework trying to follow rust-dev guide\n\nWe can use the NodeId from the AST to generate apropriate mappings for all\nnames and types. Ribs are the scopes for names being instansiated, and\nreference to defintion tables allows all names to be resolved to NodeId's.\n\nLater on NodeIds will map over to HIR ids allowing for type resolution.", "tree": {"sha": "b1472ad8c7c1d23686231a1bf0a697db4c2aef92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1472ad8c7c1d23686231a1bf0a697db4c2aef92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cfc6276dadc54aea9f8ce2a8cfefaee456f380e"}], "stats": {"total": 1474, "additions": 1329, "deletions": 145}, "files": [{"sha": "aa81813fb3029876b67fbb64e6045a2a02cf7bf5", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -77,6 +77,7 @@ GRS_OBJS = \\\n     rust/rust-hir-full-test.o \\\n     rust/rust-hir-map.o \\\n     rust/rust-ast-lower.o \\\n+    rust/rust-ast-resolve.o \\\n     $(END)\n # removed object files from here\n \n@@ -229,7 +230,7 @@ RUST_INCLUDES = -I $(srcdir)/rust \\\n \t-I $(srcdir)/rust/expand \\\n \t-I $(srcdir)/rust/hir/tree \\\n \t-I $(srcdir)/rust/hir \\\n-\t-I $(srcdir)/rust/hir_resolve \\\n+\t-I $(srcdir)/rust/resolve \\\n \t-I $(srcdir)/rust/util\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n@@ -286,4 +287,8 @@ rust/%.o: rust/hir/tree/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n+# build rust/hir/tree files in rust folder\n+rust/%.o: rust/resolve/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n "}, {"sha": "b26c770191093ea8ad2a12849856960752658be5", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 23, "deletions": 88, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -266,91 +266,6 @@ struct Literal\n   bool is_error () const { return value_as_string == \"\"; }\n };\n \n-// A token tree with delimiters\n-class DelimTokenTree : public TokenTree, public AttrInput\n-{\n-  DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree> > token_trees;\n-  Location locus;\n-\n-protected:\n-  DelimTokenTree *clone_delim_tok_tree_impl () const\n-  {\n-    return new DelimTokenTree (*this);\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_attr_input_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-  /* Use covariance to implement clone function as returning a DelimTokenTree\n-   * object */\n-  DelimTokenTree *clone_token_tree_impl () const override\n-  {\n-    return clone_delim_tok_tree_impl ();\n-  }\n-\n-public:\n-  DelimTokenTree (DelimType delim_type,\n-\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n-\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n-\t\t  Location locus = Location ())\n-    : delim_type (delim_type), token_trees (std::move (token_trees)),\n-      locus (locus)\n-  {}\n-\n-  // Copy constructor with vector clone\n-  DelimTokenTree (DelimTokenTree const &other)\n-    : delim_type (other.delim_type), locus (other.locus)\n-  {\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-  }\n-\n-  // overloaded assignment operator with vector clone\n-  DelimTokenTree &operator= (DelimTokenTree const &other)\n-  {\n-    delim_type = other.delim_type;\n-    locus = other.locus;\n-\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  DelimTokenTree (DelimTokenTree &&other) = default;\n-  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n-\n-  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n-\n-  std::string as_string () const override;\n-\n-  void accept_vis (ASTVisitor &vis) override;\n-\n-  bool\n-  check_cfg_predicate (const Session &session ATTRIBUTE_UNUSED) const override\n-  {\n-    // this should never be called - should be converted first\n-    return false;\n-  }\n-\n-  AttrInput *parse_to_meta_item () const override;\n-\n-  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n-\n-  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n-  {\n-    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n-  }\n-};\n-\n /* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n  * be defined */\n class AttrInputLiteral;\n@@ -955,7 +870,7 @@ class Expr\n   virtual void mark_for_strip () = 0;\n   virtual bool is_marked_for_strip () const = 0;\n \n-  NodeId get_node_id () const { return node_id; }\n+  virtual NodeId get_node_id () const { return node_id; }\n \n protected:\n   // Constructor\n@@ -1090,9 +1005,15 @@ class Pattern\n    * methods. */\n   virtual Location get_locus_slow () const = 0;\n \n+  virtual NodeId get_node_id () const { return node_id; }\n+\n protected:\n   // Clone pattern implementation as pure virtual method\n   virtual Pattern *clone_pattern_impl () const = 0;\n+\n+  Pattern () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n+  NodeId node_id;\n };\n \n // forward decl for Type\n@@ -1127,9 +1048,15 @@ class Type\n \n   virtual Location get_locus_slow () const = 0;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n protected:\n+  Type () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n   // Clone function implementation as pure virtual method\n   virtual Type *clone_type_impl () const = 0;\n+\n+  NodeId node_id;\n };\n \n // A type without parentheses? - abstract\n@@ -1153,6 +1080,8 @@ class TypeNoBounds : public Type\n   {\n     return clone_type_no_bounds_impl ();\n   }\n+\n+  TypeNoBounds () : Type () {}\n };\n \n /* Abstract base class representing a type param bound - Lifetime and TraitBound\n@@ -1572,19 +1501,22 @@ struct Crate\n    * top-level one)? */\n   std::vector<std::unique_ptr<Item> > items;\n \n+  NodeId node_id;\n+\n public:\n   // Constructor\n   Crate (std::vector<std::unique_ptr<Item> > items,\n \t std::vector<Attribute> inner_attrs, bool has_utf8bom = false,\n \t bool has_shebang = false)\n     : has_utf8bom (has_utf8bom), has_shebang (has_shebang),\n-      inner_attrs (std::move (inner_attrs)), items (std::move (items))\n+      inner_attrs (std::move (inner_attrs)), items (std::move (items)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor with vector clone\n   Crate (Crate const &other)\n     : has_utf8bom (other.has_utf8bom), has_shebang (other.has_shebang),\n-      inner_attrs (other.inner_attrs)\n+      inner_attrs (other.inner_attrs), node_id (other.node_id)\n   {\n     items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n@@ -1599,6 +1531,7 @@ struct Crate\n     inner_attrs = other.inner_attrs;\n     has_shebang = other.has_shebang;\n     has_utf8bom = other.has_utf8bom;\n+    node_id = other.node_id;\n \n     items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n@@ -1624,6 +1557,8 @@ struct Crate\n     items.shrink_to_fit ();\n     // TODO: is this the best way to do this?\n   }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n // Base path expression AST node - abstract"}, {"sha": "de011c1b4aa41f9108df2161f391f4feea5516e2", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -2338,11 +2338,6 @@ class CallExpr : public ExprWithoutBlock\n       }\n   }\n \n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  CallExpr *clone_expr_impl () const override { return new CallExpr (*this); }\n-\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<std::unique_ptr<Expr> > &get_params () const\n   {"}, {"sha": "bd3b0f0610d5668af538bf2f4d7f074bb4c04169", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -296,6 +296,8 @@ class PathInExpression : public PathPattern, public PathExpr\n   bool has_opening_scope_resolution;\n   Location locus;\n \n+  NodeId _node_id;\n+\n public:\n   std::string as_string () const override;\n \n@@ -307,7 +309,8 @@ class PathInExpression : public PathPattern, public PathExpr\n \t\t    = std::vector<Attribute> ())\n     : PathPattern (std::move (path_segments)),\n       PathExpr (std::move (outer_attrs)),\n-      has_opening_scope_resolution (has_opening_scope_resolution), locus (locus)\n+      has_opening_scope_resolution (has_opening_scope_resolution),\n+      locus (locus), _node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Creates an error state path in expression.\n@@ -341,6 +344,8 @@ class PathInExpression : public PathPattern, public PathExpr\n   bool is_marked_for_strip () const override { return is_error (); }\n   bool opening_scope_resolution () { return has_opening_scope_resolution; }\n \n+  NodeId get_node_id () const override { return _node_id; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -654,7 +659,8 @@ class TypePath : public TypeNoBounds\n   // Constructor\n   TypePath (std::vector<std::unique_ptr<TypePathSegment> > segments,\n \t    Location locus, bool has_opening_scope_resolution = false)\n-    : has_opening_scope_resolution (has_opening_scope_resolution),\n+    : TypeNoBounds (),\n+      has_opening_scope_resolution (has_opening_scope_resolution),\n       segments (std::move (segments)), locus (locus)\n   {}\n "}, {"sha": "dc4d48c62fef9026d0918ceac913122cf2fccb03", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -69,16 +69,18 @@ class IdentifierPattern : public Pattern\n   IdentifierPattern (Identifier ident, Location locus, bool is_ref = false,\n \t\t     bool is_mut = false,\n \t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n-    : variable_ident (std::move (ident)), is_ref (is_ref), is_mut (is_mut),\n-      to_bind (std::move (to_bind)), locus (locus)\n+    : Pattern (), variable_ident (std::move (ident)), is_ref (is_ref),\n+      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n   IdentifierPattern (IdentifierPattern const &other)\n     : variable_ident (other.variable_ident), is_ref (other.is_ref),\n       is_mut (other.is_mut), locus (other.locus)\n   {\n-    // fix to prevent null pointer dereference\n+    node_id = other.node_id;\n+    // fix to get prevent null pointer dereference\n+\n     if (other.to_bind != nullptr)\n       to_bind = other.to_bind->clone_pattern ();\n   }\n@@ -90,6 +92,7 @@ class IdentifierPattern : public Pattern\n     is_ref = other.is_ref;\n     is_mut = other.is_mut;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     // fix to prevent null pointer dereference\n     if (other.to_bind != nullptr)\n@@ -118,6 +121,9 @@ class IdentifierPattern : public Pattern\n \n   Identifier get_ident () const { return variable_ident; }\n \n+  bool get_is_mut () const { return is_mut; }\n+  bool get_is_ref () const { return is_ref; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "50e67a81581558ec3ffef66e0ec5f20d37e55bba", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -70,9 +70,10 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::ReturnExpr &expr)\n   {\n-    HIR::Expr *return_expr = expr.has_return_expr ()\n-\t\t\t       ? ASTLoweringExpr::translate (expr.get_expr ())\n-\t\t\t       : nullptr;\n+    HIR::Expr *return_expr\n+      = expr.has_returned_expr ()\n+\t  ? ASTLoweringExpr::translate (expr.get_returned_expr ().get ())\n+\t  : nullptr;\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n@@ -86,7 +87,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n   void visit (AST::CallExpr &expr)\n   {\n     std::vector<HIR::Attribute> outer_attribs;\n-    HIR::Expr *func = ASTLoweringExpr::translate (expr.function.get ());\n+    HIR::Expr *func\n+      = ASTLoweringExpr::translate (expr.get_function_expr ().get ());\n     std::vector<std::unique_ptr<HIR::Expr> > params;\n     expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n       auto trans = ASTLoweringExpr::translate (p);\n@@ -107,8 +109,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n \n   void visit (AST::AssignmentExpr &expr)\n   {\n-    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_lhs ());\n-    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_rhs ());\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n@@ -211,9 +213,9 @@ class ASTLoweringExpr : public ASTLoweringBase\n \tbreak;\n       }\n \n-    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_lhs ());\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n     rust_assert (lhs != nullptr);\n-    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.right_expr.get ());\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n     rust_assert (rhs != nullptr);\n \n     auto crate_num = mappings->get_current_crate ();"}, {"sha": "71e465efe89e419a44eb1079f8f0ad113469c55e", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -53,21 +53,21 @@ class ASTLoweringItem : public ASTLoweringBase\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     // need\n-    Identifier function_name = function.function_name;\n+    Identifier function_name = function.get_function_name ();\n     Location locus = function.get_locus ();\n \n     std::unique_ptr<HIR::Type> return_type\n-      = function.has_function_return_type () ? std::unique_ptr<HIR::Type> (\n-\t  ASTLoweringType::translate (function.return_type.get ()))\n-\t\t\t\t\t     : nullptr;\n+      = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (function.get_return_type ().get ()))\n+\t\t\t\t    : nullptr;\n \n     std::vector<HIR::FunctionParam> function_params;\n-    for (auto &param : function.function_params)\n+    for (auto &param : function.get_function_params ())\n       {\n \tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n-\t  ASTLoweringPattern::translate (param.param_name.get ()));\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n \tauto translated_type = std::unique_ptr<HIR::Type> (\n-\t  ASTLoweringType::translate (param.type.get ()));\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n \n \tfunction_params.push_back (\n \t  HIR::FunctionParam (std::move (translated_pattern),\n@@ -76,7 +76,7 @@ class ASTLoweringItem : public ASTLoweringBase\n \n     std::unique_ptr<HIR::BlockExpr> function_body\n       = std::unique_ptr<HIR::BlockExpr> (\n-\ttranslate (function.function_body.get ()));\n+\ttranslate (function.get_definition ().get ()));\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, function.get_node_id (),"}, {"sha": "0d5ce0fb0f423607cc073b22e49256663cbe67bc", "filename": "gcc/rust/hir/rust-ast-lower-pattern.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -41,9 +41,9 @@ class ASTLoweringPattern : public ASTLoweringBase\n   {\n     std::unique_ptr<Pattern> to_bind;\n     translated\n-      = new HIR::IdentifierPattern (pattern.variable_ident,\n-\t\t\t\t    pattern.get_locus (), pattern.is_ref,\n-\t\t\t\t    pattern.is_mut, std::move (to_bind));\n+      = new HIR::IdentifierPattern (pattern.get_ident (), pattern.get_locus (),\n+\t\t\t\t    pattern.get_is_ref (),\n+\t\t\t\t    pattern.get_is_mut (), std::move (to_bind));\n   }\n \n private:"}, {"sha": "d18dc19bbdbcc4217d4629afc84e0e84ac431e65", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -48,7 +48,7 @@ class ASTLoweringStmt : public ASTLoweringBase\n \n   void visit (AST::ExprStmtWithoutBlock &stmt)\n   {\n-    HIR::Expr *expr = ASTLoweringExpr::translate (stmt.expr.get ());\n+    HIR::Expr *expr = ASTLoweringExpr::translate (stmt.get_expr ().get ());\n \n     auto crate_num = mappings->get_current_crate ();\n     Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n@@ -64,13 +64,13 @@ class ASTLoweringStmt : public ASTLoweringBase\n   {\n     std::vector<HIR::Attribute> outer_attrs;\n     HIR::Pattern *variables\n-      = ASTLoweringPattern::translate (stmt.variables_pattern.get ());\n+      = ASTLoweringPattern::translate (stmt.get_pattern ().get ());\n     HIR::Type *type = stmt.has_type ()\n-\t\t\t? ASTLoweringType::translate (stmt.type.get ())\n+\t\t\t? ASTLoweringType::translate (stmt.get_type ().get ())\n \t\t\t: nullptr;\n     HIR::Expr *init_expression\n       = stmt.has_init_expr ()\n-\t  ? ASTLoweringExpr::translate (stmt.init_expr.get ())\n+\t  ? ASTLoweringExpr::translate (stmt.get_init_expr ().get ())\n \t  : nullptr;\n \n     auto crate_num = mappings->get_current_crate ();"}, {"sha": "cc60055b8fdafc058b4f060457599de213d9bbe3", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,258 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_BASE_H\n+#define RUST_AST_RESOLVE_BASE_H\n+\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-name-resolver.h\"\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolverBase : public AST::ASTVisitor\n+{\n+public:\n+  virtual ~ResolverBase () {}\n+\n+  // visitor impl\n+  // rust-ast.h\n+  //  virtual void visit(AttrInput& attr_input);\n+  //  virtual void visit(TokenTree& token_tree);\n+  //  virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (AST::Token &tok) {}\n+  virtual void visit (AST::DelimTokenTree &delim_tok_tree) {}\n+  virtual void visit (AST::AttrInputMetaItemContainer &input) {}\n+  //  virtual void visit(MetaItem& meta_item) {}\n+  //  void vsit(Stmt& stmt) {}\n+  //  virtual void visit(Expr& expr) {}\n+  virtual void visit (AST::IdentifierExpr &ident_expr) {}\n+  //  virtual void visit(Pattern& pattern) {}\n+  //  virtual void visit(Type& type) {}\n+  //  virtual void visit(TypeParamBound& type_param_bound) {}\n+  virtual void visit (AST::Lifetime &lifetime) {}\n+  //  virtual void visit(GenericParam& generic_param) {}\n+  virtual void visit (AST::LifetimeParam &lifetime_param) {}\n+  //  virtual void visit(TraitItem& trait_item) {}\n+  //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n+  //  virtual void visit(TraitImplItem& trait_impl_item) {}\n+  virtual void visit (AST::MacroInvocationSemi &macro) {}\n+\n+  // rust-path.h\n+  virtual void visit (AST::PathInExpression &path) {}\n+  virtual void visit (AST::TypePathSegment &segment) {}\n+  virtual void visit (AST::TypePathSegmentGeneric &segment) {}\n+  virtual void visit (AST::TypePathSegmentFunction &segment) {}\n+  virtual void visit (AST::TypePath &path) {}\n+  virtual void visit (AST::QualifiedPathInExpression &path) {}\n+  virtual void visit (AST::QualifiedPathInType &path) {}\n+\n+  // rust-expr.h\n+  virtual void visit (AST::LiteralExpr &expr) {}\n+  virtual void visit (AST::AttrInputLiteral &attr_input) {}\n+  virtual void visit (AST::MetaItemLitExpr &meta_item) {}\n+  virtual void visit (AST::MetaItemPathLit &meta_item) {}\n+  virtual void visit (AST::BorrowExpr &expr) {}\n+  virtual void visit (AST::DereferenceExpr &expr) {}\n+  virtual void visit (AST::ErrorPropagationExpr &expr) {}\n+  virtual void visit (AST::NegationExpr &expr) {}\n+  virtual void visit (AST::ArithmeticOrLogicalExpr &expr) {}\n+  virtual void visit (AST::ComparisonExpr &expr) {}\n+  virtual void visit (AST::LazyBooleanExpr &expr) {}\n+  virtual void visit (AST::TypeCastExpr &expr) {}\n+  virtual void visit (AST::AssignmentExpr &expr) {}\n+  virtual void visit (AST::CompoundAssignmentExpr &expr) {}\n+  virtual void visit (AST::GroupedExpr &expr) {}\n+  //  virtual void visit(ArrayElems& elems) {}\n+  virtual void visit (AST::ArrayElemsValues &elems) {}\n+  virtual void visit (AST::ArrayElemsCopied &elems) {}\n+  virtual void visit (AST::ArrayExpr &expr) {}\n+  virtual void visit (AST::ArrayIndexExpr &expr) {}\n+  virtual void visit (AST::TupleExpr &expr) {}\n+  virtual void visit (AST::TupleIndexExpr &expr) {}\n+  virtual void visit (AST::StructExprStruct &expr) {}\n+  //  virtual void visit(StructExprField& field) {}\n+  virtual void visit (AST::StructExprFieldIdentifier &field) {}\n+  virtual void visit (AST::StructExprFieldIdentifierValue &field) {}\n+  virtual void visit (AST::StructExprFieldIndexValue &field) {}\n+  virtual void visit (AST::StructExprStructFields &expr) {}\n+  virtual void visit (AST::StructExprStructBase &expr) {}\n+  virtual void visit (AST::StructExprTuple &expr) {}\n+  virtual void visit (AST::StructExprUnit &expr) {}\n+  //  virtual void visit(EnumExprField& field) {}\n+  virtual void visit (AST::EnumExprFieldIdentifier &field) {}\n+  virtual void visit (AST::EnumExprFieldIdentifierValue &field) {}\n+  virtual void visit (AST::EnumExprFieldIndexValue &field) {}\n+  virtual void visit (AST::EnumExprStruct &expr) {}\n+  virtual void visit (AST::EnumExprTuple &expr) {}\n+  virtual void visit (AST::EnumExprFieldless &expr) {}\n+  virtual void visit (AST::CallExpr &expr) {}\n+  virtual void visit (AST::MethodCallExpr &expr) {}\n+  virtual void visit (AST::FieldAccessExpr &expr) {}\n+  virtual void visit (AST::ClosureExprInner &expr) {}\n+  virtual void visit (AST::BlockExpr &expr) {}\n+  virtual void visit (AST::ClosureExprInnerTyped &expr) {}\n+  virtual void visit (AST::ContinueExpr &expr) {}\n+  virtual void visit (AST::BreakExpr &expr) {}\n+  virtual void visit (AST::RangeFromToExpr &expr) {}\n+  virtual void visit (AST::RangeFromExpr &expr) {}\n+  virtual void visit (AST::RangeToExpr &expr) {}\n+  virtual void visit (AST::RangeFullExpr &expr) {}\n+  virtual void visit (AST::RangeFromToInclExpr &expr) {}\n+  virtual void visit (AST::RangeToInclExpr &expr) {}\n+  virtual void visit (AST::ReturnExpr &expr) {}\n+  virtual void visit (AST::UnsafeBlockExpr &expr) {}\n+  virtual void visit (AST::LoopExpr &expr) {}\n+  virtual void visit (AST::WhileLoopExpr &expr) {}\n+  virtual void visit (AST::WhileLetLoopExpr &expr) {}\n+  virtual void visit (AST::ForLoopExpr &expr) {}\n+  virtual void visit (AST::IfExpr &expr) {}\n+  virtual void visit (AST::IfExprConseqElse &expr) {}\n+  virtual void visit (AST::IfExprConseqIf &expr) {}\n+  virtual void visit (AST::IfExprConseqIfLet &expr) {}\n+  virtual void visit (AST::IfLetExpr &expr) {}\n+  virtual void visit (AST::IfLetExprConseqElse &expr) {}\n+  virtual void visit (AST::IfLetExprConseqIf &expr) {}\n+  virtual void visit (AST::IfLetExprConseqIfLet &expr) {}\n+  //  virtual void visit(MatchCase& match_case) {}\n+  // virtual void visit (AST::MatchCaseBlockExpr &match_case) {}\n+  // virtual void visit (AST::MatchCaseExpr &match_case) {}\n+  virtual void visit (AST::MatchExpr &expr) {}\n+  virtual void visit (AST::AwaitExpr &expr) {}\n+  virtual void visit (AST::AsyncBlockExpr &expr) {}\n+\n+  // rust-item.h\n+  virtual void visit (AST::TypeParam &param) {}\n+  //  virtual void visit(WhereClauseItem& item) {}\n+  virtual void visit (AST::LifetimeWhereClauseItem &item) {}\n+  virtual void visit (AST::TypeBoundWhereClauseItem &item) {}\n+  virtual void visit (AST::Method &method) {}\n+  virtual void visit (AST::ModuleBodied &module) {}\n+  virtual void visit (AST::ModuleNoBody &module) {}\n+  virtual void visit (AST::ExternCrate &crate) {}\n+  //  virtual void visit(UseTree& use_tree) {}\n+  virtual void visit (AST::UseTreeGlob &use_tree) {}\n+  virtual void visit (AST::UseTreeList &use_tree) {}\n+  virtual void visit (AST::UseTreeRebind &use_tree) {}\n+  virtual void visit (AST::UseDeclaration &use_decl) {}\n+  virtual void visit (AST::Function &function) {}\n+  virtual void visit (AST::TypeAlias &type_alias) {}\n+  virtual void visit (AST::StructStruct &struct_item) {}\n+  virtual void visit (AST::TupleStruct &tuple_struct) {}\n+  virtual void visit (AST::EnumItem &item) {}\n+  virtual void visit (AST::EnumItemTuple &item) {}\n+  virtual void visit (AST::EnumItemStruct &item) {}\n+  virtual void visit (AST::EnumItemDiscriminant &item) {}\n+  virtual void visit (AST::Enum &enum_item) {}\n+  virtual void visit (AST::Union &union_item) {}\n+  virtual void visit (AST::ConstantItem &const_item) {}\n+  virtual void visit (AST::StaticItem &static_item) {}\n+  virtual void visit (AST::TraitItemFunc &item) {}\n+  virtual void visit (AST::TraitItemMethod &item) {}\n+  virtual void visit (AST::TraitItemConst &item) {}\n+  virtual void visit (AST::TraitItemType &item) {}\n+  virtual void visit (AST::Trait &trait) {}\n+  virtual void visit (AST::InherentImpl &impl) {}\n+  virtual void visit (AST::TraitImpl &impl) {}\n+  //  virtual void visit(ExternalItem& item) {}\n+  virtual void visit (AST::ExternalStaticItem &item) {}\n+  virtual void visit (AST::ExternalFunctionItem &item) {}\n+  virtual void visit (AST::ExternBlock &block) {}\n+\n+  // rust-macro.h\n+  virtual void visit (AST::MacroMatchFragment &match) {}\n+  virtual void visit (AST::MacroMatchRepetition &match) {}\n+  virtual void visit (AST::MacroMatcher &matcher) {}\n+  virtual void visit (AST::MacroRulesDefinition &rules_def) {}\n+  virtual void visit (AST::MacroInvocation &macro_invoc) {}\n+  virtual void visit (AST::MetaItemPath &meta_item) {}\n+  virtual void visit (AST::MetaItemSeq &meta_item) {}\n+  virtual void visit (AST::MetaWord &meta_item) {}\n+  virtual void visit (AST::MetaNameValueStr &meta_item) {}\n+  virtual void visit (AST::MetaListPaths &meta_item) {}\n+  virtual void visit (AST::MetaListNameValueStr &meta_item) {}\n+\n+  // rust-pattern.h\n+  virtual void visit (AST::LiteralPattern &pattern) {}\n+  virtual void visit (AST::IdentifierPattern &pattern) {}\n+  virtual void visit (AST::WildcardPattern &pattern) {}\n+  //  virtual void visit(RangePatternBound& bound) {}\n+  virtual void visit (AST::RangePatternBoundLiteral &bound) {}\n+  virtual void visit (AST::RangePatternBoundPath &bound) {}\n+  virtual void visit (AST::RangePatternBoundQualPath &bound) {}\n+  virtual void visit (AST::RangePattern &pattern) {}\n+  virtual void visit (AST::ReferencePattern &pattern) {}\n+  //  virtual void visit(StructPatternField& field) {}\n+  virtual void visit (AST::StructPatternFieldTuplePat &field) {}\n+  virtual void visit (AST::StructPatternFieldIdentPat &field) {}\n+  virtual void visit (AST::StructPatternFieldIdent &field) {}\n+  virtual void visit (AST::StructPattern &pattern) {}\n+  //  virtual void visit(TupleStructItems& tuple_items) {}\n+  virtual void visit (AST::TupleStructItemsNoRange &tuple_items) {}\n+  virtual void visit (AST::TupleStructItemsRange &tuple_items) {}\n+  virtual void visit (AST::TupleStructPattern &pattern) {}\n+  //  virtual void visit(TuplePatternItems& tuple_items) {}\n+  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items) {}\n+  virtual void visit (AST::TuplePatternItemsRanged &tuple_items) {}\n+  virtual void visit (AST::TuplePattern &pattern) {}\n+  virtual void visit (AST::GroupedPattern &pattern) {}\n+  virtual void visit (AST::SlicePattern &pattern) {}\n+\n+  // rust-stmt.h\n+  virtual void visit (AST::EmptyStmt &stmt) {}\n+  virtual void visit (AST::LetStmt &stmt) {}\n+  virtual void visit (AST::ExprStmtWithoutBlock &stmt) {}\n+  virtual void visit (AST::ExprStmtWithBlock &stmt) {}\n+\n+  // rust-type.h\n+  virtual void visit (AST::TraitBound &bound) {}\n+  virtual void visit (AST::ImplTraitType &type) {}\n+  virtual void visit (AST::TraitObjectType &type) {}\n+  virtual void visit (AST::ParenthesisedType &type) {}\n+  virtual void visit (AST::ImplTraitTypeOneBound &type) {}\n+  virtual void visit (AST::TraitObjectTypeOneBound &type) {}\n+  virtual void visit (AST::TupleType &type) {}\n+  virtual void visit (AST::NeverType &type) {}\n+  virtual void visit (AST::RawPointerType &type) {}\n+  virtual void visit (AST::ReferenceType &type) {}\n+  virtual void visit (AST::ArrayType &type) {}\n+  virtual void visit (AST::SliceType &type) {}\n+  virtual void visit (AST::InferredType &type) {}\n+  virtual void visit (AST::BareFunctionType &type) {}\n+\n+protected:\n+  ResolverBase (NodeId parent)\n+    : resolver (Resolver::get ()), resolved_node (UNKNOWN_NODEID),\n+      parent (parent), locus (Location ())\n+  {}\n+\n+  bool resolved () const { return resolved_node != UNKNOWN_NODEID; }\n+\n+  Resolver *resolver;\n+  NodeId resolved_node;\n+  NodeId parent;\n+  Location locus;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_BASE_H"}, {"sha": "9ca763d3d44381d0143bcfeb30a3b5b43bc75acf", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,98 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_EXPR_H\n+#define RUST_AST_RESOLVE_EXPR_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveExpr : public ResolverBase\n+{\n+public:\n+  static void go (AST::Expr *expr, NodeId parent)\n+  {\n+    ResolveExpr resolver (parent);\n+    expr->accept_vis (resolver);\n+  };\n+\n+  ~ResolveExpr () {}\n+\n+  void visit (AST::PathInExpression &expr)\n+  {\n+    if (resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+      {\n+\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t\t Definition{expr.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+  }\n+\n+  void visit (AST::ReturnExpr &expr)\n+  {\n+    if (expr.has_return_expr ())\n+      ResolveExpr::go (expr.get_expr (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::CallExpr &expr)\n+  {\n+    ResolveExpr::go (expr.function.get (), expr.get_node_id ());\n+    expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n+      ResolveExpr::go (p, expr.get_node_id ());\n+      return true;\n+    });\n+  }\n+\n+  void visit (AST::AssignmentExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_lhs (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_rhs (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::IdentifierExpr &expr)\n+  {\n+    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+      {\n+\trust_error_at (expr.get_locus (), \"failed to find name: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+    resolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t     Definition{expr.get_node_id (), parent});\n+  }\n+\n+  void visit (AST::ArithmeticOrLogicalExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_lhs (), expr.get_node_id ());\n+    ResolveExpr::go (expr.right_expr.get (), expr.get_node_id ());\n+  }\n+\n+private:\n+  ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_EXPR_H"}, {"sha": "ea79fc034fb3e63e6ae24f9372b23436d3a04eb0", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_ITEM_H\n+#define RUST_AST_RESOLVE_ITEM_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveItem : public ResolverBase\n+{\n+public:\n+  static void go (AST::Item *item)\n+  {\n+    ResolveItem resolver;\n+    item->accept_vis (resolver);\n+  };\n+\n+  ~ResolveItem () {}\n+\n+  void visit (AST::Function &function)\n+  {\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (),\n+\t\t       function.get_node_id ());\n+\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+      }\n+\n+    function.get_definition ()->iterate_stmts (\n+      [&] (AST::Stmt *s) mutable -> bool {\n+\t// TODO\n+\treturn true;\n+      });\n+  }\n+\n+private:\n+  ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_ITEM_H"}, {"sha": "fc2da703e6cbebe76d15fbe95998c7b1bf521d61", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,97 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_PATTERN_H\n+#define RUST_AST_RESOLVE_PATTERN_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolvePattern : public ResolverBase\n+{\n+public:\n+  static void go (AST::Pattern *pattern, NodeId parent)\n+  {\n+    ResolvePattern resolver (parent);\n+\n+    pattern->accept_vis (resolver);\n+    if (resolver.resolved_node == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (resolver.locus, \"failed to resolve pattern %s\",\n+\t\t       pattern->as_string ().c_str ());\n+      }\n+  };\n+\n+  ~ResolvePattern () {}\n+\n+  void visit (AST::IdentifierPattern &pattern)\n+  {\n+    if (resolver->get_name_scope ().lookup (pattern.get_ident (),\n+\t\t\t\t\t    &resolved_node))\n+      {\n+\tresolver->insert_resolved_name (pattern.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (pattern.get_node_id (),\n+\t\t\t\t\t Definition{pattern.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+  }\n+\n+private:\n+  ResolvePattern (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+class PatternDeclaration : public ResolverBase\n+{\n+public:\n+  static void go (AST::Pattern *pattern, NodeId parent)\n+  {\n+    PatternDeclaration resolver (parent);\n+\n+    pattern->accept_vis (resolver);\n+    if (resolver.resolved_node != UNKNOWN_NODEID)\n+      {\n+\t// print both locations?!\n+\trust_error_at (resolver.locus, \"duplicate pattern %s\",\n+\t\t       pattern->as_string ().c_str ());\n+      }\n+  };\n+\n+  ~PatternDeclaration () {}\n+\n+  void visit (AST::IdentifierPattern &pattern)\n+  {\n+    // if we have a duplicate id this then allows for shadowing correctly\n+    // as new refs to this decl will match back here so it is ok to overwrite\n+    resolver->get_name_scope ().insert (pattern.get_ident (),\n+\t\t\t\t\tpattern.get_node_id ());\n+    resolver->insert_new_definition (pattern.get_node_id (),\n+\t\t\t\t     Definition{pattern.get_node_id (),\n+\t\t\t\t\t\tparent});\n+  }\n+\n+private:\n+  PatternDeclaration (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_PATTERN_H"}, {"sha": "42fb0977444ff8bc572476f2eaaff699d796855f", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_STMT_H\n+#define RUST_AST_RESOLVE_STMT_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveStmt : public ResolverBase\n+{\n+public:\n+  static void go (AST::Stmt *stmt, NodeId parent)\n+  {\n+    ResolveStmt resolver (parent);\n+    stmt->accept_vis (resolver);\n+  };\n+\n+  ~ResolveStmt () {}\n+\n+  void visit (AST::LetStmt &stmt)\n+  {\n+    PatternDeclaration::go (stmt.variables_pattern.get (), stmt.get_node_id ());\n+    if (stmt.has_type ())\n+      ResolveType::go (stmt.type.get (), stmt.get_node_id ());\n+\n+    if (stmt.has_init_expr ())\n+      ResolveExpr::go (stmt.init_expr.get (), stmt.get_node_id ());\n+  }\n+\n+private:\n+  ResolveStmt () : ResolverBase (UNKNOWN_NODEID) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_STMT_H"}, {"sha": "fcc9663f2d602dffbb446e3f24628907beeec3d0", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,54 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_TOPLEVEL_H\n+#define RUST_AST_RESOLVE_TOPLEVEL_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveTopLevel : public ResolverBase\n+{\n+public:\n+  static void go (AST::Item *item)\n+  {\n+    ResolveTopLevel resolver;\n+    item->accept_vis (resolver);\n+  };\n+\n+  ~ResolveTopLevel () {}\n+\n+  void visit (AST::Function &function)\n+  {\n+    // function_names are simple std::String identifiers so this can be a\n+    // NodeId mapping to the Function node\n+    resolver->get_name_scope ().insert (function.get_function_name (),\n+\t\t\t\t\tfunction.get_node_id ());\n+  }\n+\n+private:\n+  ResolveTopLevel () : ResolverBase (UNKNOWN_NODEID) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_TOPLEVEL_H"}, {"sha": "3cffa77d5b9e7243cc153ef3b99cd06c9e35c531", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_TYPE_H\n+#define RUST_AST_RESOLVE_TYPE_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveType : public ResolverBase\n+{\n+public:\n+  static void go (AST::Type *type, NodeId parent)\n+  {\n+    ResolveType resolver (parent);\n+\n+    type->accept_vis (resolver);\n+    if (resolver.resolved_node == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (resolver.locus, \"failed to resolve type %s\",\n+\t\t       type->as_string ().c_str ());\n+      }\n+  };\n+\n+  ~ResolveType () {}\n+\n+  virtual void visit (AST::TypePath &path)\n+  {\n+    // this will need changed to handle mod/crate/use globs and look\n+    // at the segments in granularity\n+    locus = path.get_locus ();\n+    if (resolver->get_type_scope ().lookup (path.as_string (), &resolved_node))\n+      {\n+\tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (path.get_node_id (),\n+\t\t\t\t\t Definition{path.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+  }\n+\n+private:\n+  ResolveType (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_TYPE_H"}, {"sha": "664af12701ac5f974fb64439aa5271e7ad0cc2e1", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,245 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve.h\"\n+#include \"rust-ast-resolve-toplevel.h\"\n+#include \"rust-ast-resolve-item.h\"\n+#include \"rust-ast-full.h\"\n+\n+#define MKBUILTIN_TYPE(_X, _R)                                                 \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      AST::PathIdentSegment seg (_X);                                          \\\n+      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n+\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n+\t\t\t\t  Linemap::predeclared_location ()));          \\\n+      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n+      segs.push_back (::std::move (typePath));                                 \\\n+      auto builtin_type                                                        \\\n+\t= new AST::TypePath (::std::move (segs),                               \\\n+\t\t\t     Linemap::predeclared_location (), false);         \\\n+      _R.push_back (builtin_type);                                             \\\n+    }                                                                          \\\n+  while (0)\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// Resolver\n+\n+Resolver::Resolver ()\n+  : mappings (Analysis::Mappings::get ()),\n+    name_scope (Scope (mappings->get_current_crate ())),\n+    type_scope (Scope (mappings->get_current_crate ()))\n+{\n+  generate_builtins ();\n+}\n+\n+Resolver *\n+Resolver::get ()\n+{\n+  static Resolver *instance;\n+  if (instance == nullptr)\n+    instance = new Resolver ();\n+\n+  return instance;\n+}\n+\n+void\n+Resolver::push_new_name_rib (Rib *r)\n+{\n+  rust_assert (name_ribs.find (r->get_node_id ()) == name_ribs.end ());\n+  name_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_type_rib (Rib *r)\n+{\n+  if (type_ribs.size () == 0)\n+    global_type_node_id = r->get_node_id ();\n+\n+  rust_assert (type_ribs.find (r->get_node_id ()) == type_ribs.end ());\n+  type_ribs[r->get_node_id ()] = r;\n+}\n+\n+bool\n+Resolver::find_name_rib (NodeId id, Rib **rib)\n+{\n+  auto it = name_ribs.find (id);\n+  if (it == name_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+bool\n+Resolver::find_type_rib (NodeId id, Rib **rib)\n+{\n+  auto it = type_ribs.find (id);\n+  if (it == type_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_builtin_types (Rib *r)\n+{\n+  auto builtins = get_builtin_types ();\n+  for (auto it = builtins.begin (); it != builtins.end (); it++)\n+    r->insert_name ((*it)->as_string (), (*it)->get_node_id ());\n+}\n+\n+std::vector<AST::TypePath *> &\n+Resolver::get_builtin_types ()\n+{\n+  return builtins;\n+}\n+\n+void\n+Resolver::generate_builtins ()\n+{\n+  MKBUILTIN_TYPE (\"u8\", builtins);\n+  MKBUILTIN_TYPE (\"u16\", builtins);\n+  MKBUILTIN_TYPE (\"u32\", builtins);\n+  MKBUILTIN_TYPE (\"u64\", builtins);\n+\n+  MKBUILTIN_TYPE (\"i8\", builtins);\n+  MKBUILTIN_TYPE (\"i16\", builtins);\n+  MKBUILTIN_TYPE (\"i32\", builtins);\n+  MKBUILTIN_TYPE (\"i64\", builtins);\n+\n+  MKBUILTIN_TYPE (\"f32\", builtins);\n+  MKBUILTIN_TYPE (\"f64\", builtins);\n+\n+  MKBUILTIN_TYPE (\"char\", builtins);\n+  MKBUILTIN_TYPE (\"str\", builtins);\n+  MKBUILTIN_TYPE (\"bool\", builtins);\n+}\n+\n+void\n+Resolver::insert_new_definition (NodeId id, Definition def)\n+{\n+  auto it = name_definitions.find (id);\n+  rust_assert (it == name_definitions.end ());\n+\n+  name_definitions[id] = def;\n+}\n+\n+bool\n+Resolver::lookup_definition (NodeId id, Definition *def)\n+{\n+  auto it = name_definitions.find (id);\n+  if (it == name_definitions.end ())\n+    return false;\n+\n+  *def = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_names.find (refId);\n+  rust_assert (it == resolved_names.end ());\n+\n+  resolved_names[refId] = defId;\n+}\n+\n+bool\n+Resolver::lookup_resolved_name (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_names.find (refId);\n+  if (it == resolved_names.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_types.find (refId);\n+  rust_assert (it == resolved_types.end ());\n+\n+  resolved_types[refId] = defId;\n+}\n+\n+bool\n+Resolver::lookup_resolved_type (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_types.find (refId);\n+  if (it == resolved_types.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+// NameResolution\n+\n+NameResolution *\n+NameResolution::get ()\n+{\n+  static NameResolution *instance;\n+  if (instance == nullptr)\n+    instance = new NameResolution ();\n+\n+  return instance;\n+}\n+\n+NameResolution::NameResolution ()\n+  : resolver (Resolver::get ()), mappings (Analysis::Mappings::get ())\n+{\n+  // these are global\n+  resolver->get_type_scope ().push (mappings->get_next_node_id ());\n+  resolver->insert_builtin_types (resolver->get_type_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+}\n+\n+void\n+NameResolution::Resolve (AST::Crate &crate)\n+{\n+  auto resolver = get ();\n+  resolver->go (crate);\n+}\n+\n+void\n+NameResolution::go (AST::Crate &crate)\n+{\n+  // setup parent scoping for names\n+  resolver->get_name_scope ().push (crate.get_node_id ());\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  // setup parent scoping for new types\n+  resolver->get_type_scope ().push (mappings->get_next_node_id ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  // first gather the top-level namespace names then we drill down\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    ResolveTopLevel::go (it->get ());\n+\n+  // next we can drill down into the items and their scopes\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    ResolveItem::go (it->get ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "29ae0ab8ab9fc9f2bc7da81b5c2cc4a30f32f34c", "filename": "gcc/rust/resolve/rust-ast-resolve.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-ast-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_H\n+#define RUST_AST_RESOLVE_H\n+\n+#include \"rust-name-resolver.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class NameResolution\n+{\n+public:\n+  static void Resolve (AST::Crate &crate);\n+\n+  static NameResolution *get ();\n+\n+  ~NameResolution () {}\n+\n+private:\n+  void go (AST::Crate &crate);\n+\n+  NameResolution ();\n+\n+  Resolver *resolver;\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_H"}, {"sha": "4aac7d5037db7fc4090f48b0813c4fe8ab46bd0e", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -0,0 +1,211 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_NAME_RESOLVER_H\n+#define RUST_NAME_RESOLVER_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class Rib\n+{\n+public:\n+  // Rusts uses local_def_ids assigned by def_collector on the AST\n+  // lets use NodeId instead\n+  Rib (CrateNum crateNum, NodeId node_id)\n+    : crate_num (crateNum), node_id (node_id)\n+  {}\n+\n+  ~Rib () {}\n+\n+  void insert_name (std::string ident, NodeId id)\n+  {\n+    mappings[ident] = id;\n+    decls_within_rib.insert (id);\n+  }\n+\n+  bool lookup_name (std::string ident, NodeId *id)\n+  {\n+    auto it = mappings.find (ident);\n+    if (it == mappings.end ())\n+      return false;\n+\n+    *id = it->second;\n+    return true;\n+  }\n+\n+  CrateNum get_crate_num () const { return crate_num; }\n+  NodeId get_node_id () const { return node_id; }\n+\n+private:\n+  CrateNum crate_num;\n+  NodeId node_id;\n+  std::map<std::string, NodeId> mappings;\n+  std::set<NodeId> decls_within_rib;\n+};\n+\n+class Scope\n+{\n+public:\n+  Scope (CrateNum crate_num) : crate_num (crate_num) {}\n+  ~Scope () {}\n+\n+  void insert (std::string ident, NodeId id)\n+  {\n+    peek ()->insert_name (ident, id);\n+  }\n+\n+  bool lookup (std::string ident, NodeId *id)\n+  {\n+    NodeId lookup = UNKNOWN_NODEID;\n+    iterate ([&] (Rib *r) mutable -> bool {\n+      if (r->lookup_name (ident, &lookup))\n+\treturn false;\n+      return true;\n+    });\n+\n+    *id = lookup;\n+    return lookup != UNKNOWN_NODEID;\n+  }\n+\n+  void iterate (std::function<bool (Rib *)> cb)\n+  {\n+    for (auto it = stack.rbegin (); it != stack.rend (); ++it)\n+      {\n+\tif (!cb (*it))\n+\t  return;\n+      }\n+  }\n+\n+  Rib *peek () { return stack.back (); }\n+\n+  void push (NodeId id) { stack.push_back (new Rib (get_crate_num (), id)); }\n+\n+  Rib *pop ()\n+  {\n+    Rib *r = peek ();\n+    stack.pop_back ();\n+    return r;\n+  }\n+\n+  CrateNum get_crate_num () const { return crate_num; }\n+\n+private:\n+  CrateNum crate_num;\n+  std::vector<Rib *> stack;\n+};\n+\n+// This can map simple NodeIds for names to their parent node\n+// for example:\n+//\n+// var x = y + 1;\n+//\n+// say y has node id=1 and the plus_expression has id=2\n+// then the Definition will have\n+// Definition { node=1, parent=2 }\n+// this will be used later to gather the ribs for the type inferences context\n+//\n+// if parent is UNKNOWN_NODEID then this is a root declaration\n+// say the var_decl hasa node_id=4;\n+// the parent could be a BLOCK_Expr node_id but lets make it UNKNOWN_NODE_ID so\n+// we know when it terminates\n+struct Definition\n+{\n+  NodeId node;\n+  NodeId parent;\n+  // add kind ?\n+};\n+\n+class Resolver\n+{\n+public:\n+  static Resolver *get ();\n+  ~Resolver () {}\n+\n+  // these builtin types\n+  void insert_builtin_types (Rib *r);\n+\n+  // these will be required for type resolution passes to\n+  // map back to tyty nodes\n+  std::vector<AST::TypePath *> &get_builtin_types ();\n+\n+  void push_new_name_rib (Rib *r);\n+  void push_new_type_rib (Rib *r);\n+\n+  bool find_name_rib (NodeId id, Rib **rib);\n+  bool find_type_rib (NodeId id, Rib **rib);\n+\n+  void insert_new_definition (NodeId id, Definition def);\n+  bool lookup_definition (NodeId id, Definition *def);\n+\n+  void insert_resolved_name (NodeId refId, NodeId defId);\n+  bool lookup_resolved_name (NodeId refId, NodeId *defId);\n+\n+  void insert_resolved_type (NodeId refId, NodeId defId);\n+  bool lookup_resolved_type (NodeId refId, NodeId *defId);\n+\n+  // proxy for scoping\n+  Scope &get_name_scope () { return name_scope; }\n+  Scope &get_type_scope () { return type_scope; }\n+\n+  NodeId get_global_type_node_id () { return global_type_node_id; }\n+\n+private:\n+  Resolver ();\n+\n+  void generate_builtins ();\n+\n+  Analysis::Mappings *mappings;\n+\n+  std::vector<AST::TypePath *> builtins;\n+\n+  Scope name_scope;\n+  Scope type_scope;\n+\n+  NodeId global_type_node_id;\n+\n+  // map a AST Node to a Rib\n+  std::map<NodeId, Rib *> name_ribs;\n+  std::map<NodeId, Rib *> type_ribs;\n+\n+  // map any Node to its Definition\n+  // ie any name or type usage\n+  std::map<NodeId, Definition> name_definitions;\n+\n+  // Rust uses DefIds to namespace these under a crate_num\n+  // but then it uses the def_collector to assign local_defids\n+  // to each ast node as well. not sure if this is going to fit\n+  // with gcc very well to compile a full crate in one go but we will\n+  // see.\n+\n+  // these are of the form ref->Def-NodeId\n+  // we need two namespaces one for names and ones for types\n+  std::map<NodeId, NodeId> resolved_names;\n+  std::map<NodeId, NodeId> resolved_types;\n+\n+  std::map<NodeId, std::set<NodeId> > nameDefNodeIdToRibs;\n+  std::map<NodeId, std::set<NodeId> > typeDefNodeIdToRibs;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_NAME_RESOLVER_H"}, {"sha": "3131af0918070b751932577648d88c7bf32995f7", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -29,14 +29,13 @@\n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n #include \"rust-scan.h\"\n-#include \"rust-name-resolution.h\"\n-#include \"rust-type-resolution.h\"\n #include \"rust-macro-expand.h\"\n #include \"rust-compile.h\"\n+#include \"rust-target.h\"\n \n // hir passes wip\n+#include \"rust-ast-resolve.h\"\n #include \"rust-ast-lower.h\"\n-#include \"rust-target.h\"\n \n extern Linemap *\n rust_get_linemap ();\n@@ -399,6 +398,10 @@ Session::enable_dump (std::string arg)\n       // return false;\n       options.dump_option = CompileOptions::TARGET_OPTION_DUMP;\n     }\n+  else if (arg == \"hir\")\n+    {\n+      options.dump_option = CompileOptions::HIR_DUMP;\n+    }\n   else if (arg == \"\")\n     {\n       rust_error_at (Location (), \"dump option was not given a name. choose \"\n@@ -527,6 +530,17 @@ Session::parse_file (const char *filename)\n       // TODO: what do I dump here? resolved names? AST with resolved names?\n     }\n \n+  // lower AST to HIR\n+  HIR::Crate hir = HIR::ASTLowering::Resolve (parsed_crate);\n+  if (options.dump_option == CompileOptions::HIR_DUMP)\n+    {\n+      fprintf (stderr, \"%s\", hir.as_string ().c_str ());\n+      return;\n+    }\n+\n+  // type resolve\n+  // TODO\n+\n   if (saw_errors ())\n     return;\n \n@@ -759,16 +773,7 @@ void\n Session::resolution (AST::Crate &crate)\n {\n   fprintf (stderr, \"started name resolution\\n\");\n-  Analysis::TopLevelScan toplevel (crate);\n-  // Name resolution must be in front of type resolution\n-  Analysis::NameResolution::Resolve (crate, toplevel);\n-  Analysis::TypeResolution::Resolve (crate, toplevel);\n-\n-  // inject hir passes\n-  HIR::Crate hir = HIR::ASTLowering::Resolve (crate);\n-  fprintf (stderr, \"HIR PASSES:\\n\");\n-  fprintf (stderr, \"%s\", hir.as_string ().c_str ());\n-  fprintf (stderr, \"HIR PASSES - DONE:\\n\");\n+  Resolver::NameResolution::Resolve (crate);\n   fprintf (stderr, \"finished name resolution\\n\");\n }\n "}, {"sha": "2bb1dfb63e9e3b6b8398371e6675a87a390be95f", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -1,6 +1,24 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+// #include \"rust-session-manager.h\"\n+\n #ifndef RUST_SESSION_MANAGER_H\n #define RUST_SESSION_MANAGER_H\n-// Session manager - controls compiler session.\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -11,12 +29,6 @@\n #include \"rust-linemap.h\"\n #include \"rust-backend.h\"\n \n-#include <string>\n-#include <unordered_map>\n-#include <unordered_set>\n-#include <vector>\n-#include <utility>\n-\n namespace Rust {\n // parser forward decl\n template <typename ManagedTokenSource> class Parser;\n@@ -32,7 +44,7 @@ struct TargetOptions\n {\n   /* TODO: maybe make private and access through helpers to allow changes to\n    * impl */\n-  std::unordered_map<std::string, std::unordered_set<std::string>> features;\n+  std::unordered_map<std::string, std::unordered_set<std::string> > features;\n \n public:\n   // Returns whether a key is defined in the feature set.\n@@ -160,6 +172,7 @@ struct CompileOptions\n     EXPANSION_DUMP,\n     RESOLUTION_DUMP,\n     TARGET_OPTION_DUMP,\n+    HIR_DUMP,\n     // TODO: add more?\n   } dump_option;\n "}, {"sha": "094d0e3e496a11872f5b5c5e4b114379a67fd0a8", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -63,11 +63,17 @@ NodeMapping::get_local_defid () const\n \n DefId\n NodeMapping::get_defid () const\n+{\n+  return get_defid (get_crate_num (), get_local_defid ());\n+}\n+\n+DefId\n+NodeMapping::get_defid (CrateNum crate_num, LocalDefId local_defid)\n {\n   DefId val = 0;\n-  val |= get_crate_num ();\n+  val |= crate_num;\n   val = val << sizeof (uint32_t);\n-  val |= get_local_defid ();\n+  val |= local_defid;\n   return val;\n }\n "}, {"sha": "8929ca4575eb0fa62abc5038f8a5eccbfc580963", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fb0ab7e635c65318aadf958e0e1303f3435c4e5/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=4fb0ab7e635c65318aadf958e0e1303f3435c4e5", "patch": "@@ -63,6 +63,8 @@ class NodeMapping\n   LocalDefId get_local_defid () const;\n   DefId get_defid () const;\n \n+  static DefId get_defid (CrateNum crate_num, LocalDefId local_defid);\n+\n   std::string as_string () const;\n \n private:\n@@ -126,6 +128,9 @@ class Mappings\n   std::map<CrateNum, std::map<LocalDefId, HIR::Item *> > localDefIdMappings;\n   std::map<CrateNum, std::map<HirId, HIR::Item *> > hirItemMappings;\n   std::map<CrateNum, std::map<HirId, HIR::Expr *> > hirExprMappings;\n+\n+  // reverse mappings\n+  std::map<CrateNum, std::map<NodeId, HirId> > nodeIdToHirMappings;\n };\n \n } // namespace Analysis"}]}