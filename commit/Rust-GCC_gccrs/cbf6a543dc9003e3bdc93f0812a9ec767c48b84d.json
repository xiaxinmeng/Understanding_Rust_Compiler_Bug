{"sha": "cbf6a543dc9003e3bdc93f0812a9ec767c48b84d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JmNmE1NDNkYzkwMDNlM2JkYzkzZjA4MTJhOWVjNzY3YzQ4Yjg0ZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-28T01:20:38Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-28T01:20:38Z"}, "message": "(simplify_*_operation, fold_rtx, record_jump_cond, cse_insn): Use\nINTEGRAL_MODE_P and FLOAT_MODE_P.\n\nFrom-SVN: r4780", "tree": {"sha": "7b7121c4d264fca1fe714372e808b2b2a7d71871", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b7121c4d264fca1fe714372e808b2b2a7d71871"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbf6a543dc9003e3bdc93f0812a9ec767c48b84d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf6a543dc9003e3bdc93f0812a9ec767c48b84d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbf6a543dc9003e3bdc93f0812a9ec767c48b84d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbf6a543dc9003e3bdc93f0812a9ec767c48b84d/comments", "author": null, "committer": null, "parents": [{"sha": "3ad2180a02e9351700c8d46402d420f040c3d616", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad2180a02e9351700c8d46402d420f040c3d616", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad2180a02e9351700c8d46402d420f040c3d616"}], "stats": {"total": 44, "additions": 19, "deletions": 25}, "files": [{"sha": "4f94923996118e5c9464245413881715dc2b4a53", "filename": "gcc/cse.c", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbf6a543dc9003e3bdc93f0812a9ec767c48b84d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbf6a543dc9003e3bdc93f0812a9ec767c48b84d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=cbf6a543dc9003e3bdc93f0812a9ec767c48b84d", "patch": "@@ -3435,7 +3435,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* In IEEE floating point, x+0 is not the same as x.  Similarly\n \t     for the other optimizations below.  */\n \t  if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-\t      && GET_MODE_CLASS (mode) != MODE_INT)\n+\t      && FLOAT_MODE_P (mode))\n \t    break;\n \n \t  if (op1 == CONST0_RTX (mode))\n@@ -3462,8 +3462,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t     The inaccuracy makes it nonassociative,\n \t     and subtle programs can break if operations are associated.  */\n \n-\t  if ((GET_MODE_CLASS (mode) == MODE_INT\n-\t       || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n+\t  if (INTEGRAL_MODE_P (mode)\n \t      && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n \t\t  || GET_CODE (op1) == PLUS || GET_CODE (op1) == MINUS)\n \t      && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n@@ -3479,7 +3478,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t     In IEEE floating point, x-0 is not the same as x.  */\n \n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || GET_MODE_CLASS (mode) == MODE_INT)\n+\t       || ! FLOAT_MODE_P (mode))\n \t      && op1 == CONST0_RTX (mode))\n \t    return op0;\n #else\n@@ -3491,15 +3490,13 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* None of these optimizations can be done for IEEE\n \t     floating point.  */\n \t  if (TARGET_FLOAT_FORMAT == IEEE_FLOAT_FORMAT\n-\t      && GET_MODE_CLASS (mode) != MODE_INT\n-\t      && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n+\t      && ! FLOAT_MODE_P (mode))\n \t    break;\n \n \t  /* We can't assume x-x is 0 even with non-IEEE floating point.  */\n \t  if (rtx_equal_p (op0, op1)\n \t      && ! side_effects_p (op0)\n-\t      && GET_MODE_CLASS (mode) != MODE_FLOAT\n-\t      && GET_MODE_CLASS (mode) != MODE_COMPLEX_FLOAT)\n+\t      && ! FLOAT_MODE_P (mode))\n \t    return const0_rtx;\n \n \t  /* Change subtraction from zero into negation.  */\n@@ -3524,8 +3521,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t     The inaccuracy makes it nonassociative,\n \t     and subtle programs can break if operations are associated.  */\n \n-\t  if ((GET_MODE_CLASS (mode) == MODE_INT\n-\t       || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n+\t  if (INTEGRAL_MODE_P (mode)\n \t      && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS\n \t\t  || GET_CODE (op1) == PLUS || GET_CODE (op1) == MINUS)\n \t      && (tem = simplify_plus_minus (code, mode, op0, op1)) != 0)\n@@ -3546,7 +3542,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t  /* In IEEE floating point, x*0 is not always 0.  */\n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || GET_MODE_CLASS (mode) == MODE_INT)\n+\t       && ! FLOAT_MODE_P (mode))\n \t      && op1 == CONST0_RTX (mode)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n@@ -3646,7 +3642,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t  /* In IEEE floating point, 0/x is not always 0.  */\n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t       || GET_MODE_CLASS (mode) == MODE_INT)\n+\t       || ! FLOAT_MODE_P (mode))\n \t      && op0 == CONST0_RTX (mode)\n \t      && ! side_effects_p (op1))\n \t    return op0;\n@@ -4182,7 +4178,7 @@ simplify_relational_operation (code, mode, op0, op1)\n \t the result.  */\n       if (rtx_equal_p (op0, op1)\n \t  && (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t      || GET_MODE_CLASS (GET_MODE (op0)) != MODE_FLOAT))\n+\t      || ! FLOAT_MODE_P (GET_MODE (op0))))\n \treturn (code == EQ || code == GE || code == LE || code == LEU\n \t\t|| code == GEU) ? const_true_rtx : const0_rtx;\n \n@@ -4307,14 +4303,12 @@ simplify_relational_operation (code, mode, op0, op1)\n \tcase GEU:\n \t  /* Unsigned values are never negative, but we must be sure we are\n \t     actually comparing a value, not a CC operand.  */\n-\t  if (op1 == const0_rtx\n-\t      && GET_MODE_CLASS (mode) == MODE_INT)\n+\t  if (op1 == const0_rtx && INTEGRAL_MODE_P (mode))\n \t    return const_true_rtx;\n \t  break;\n \n \tcase LTU:\n-\t  if (op1 == const0_rtx\n-\t      && GET_MODE_CLASS (mode) == MODE_INT)\n+\t  if (op1 == const0_rtx && INTEGRAL_MODE_P (mode))\n \t    return const0_rtx;\n \t  break;\n \n@@ -4323,14 +4317,14 @@ simplify_relational_operation (code, mode, op0, op1)\n \t     unsigned value.  */\n \t  if (GET_CODE (op1) == CONST_INT\n \t      && INTVAL (op1) == GET_MODE_MASK (mode)\n-\t      && GET_MODE_CLASS (mode) == MODE_INT)\n+\t      && INTEGRAL_MODE_P (mode))\n \t    return const_true_rtx;\n \t  break;\n \n \tcase GTU:\n \t  if (GET_CODE (op1) == CONST_INT\n \t      && INTVAL (op1) == GET_MODE_MASK (mode)\n-\t      && GET_MODE_CLASS (mode) == MODE_INT)\n+\t      && INTEGRAL_MODE_P (mode))\n \t    return const0_rtx;\n \t  break;\n \t}\n@@ -5088,7 +5082,7 @@ fold_rtx (x, insn)\n \t\t since x might be a NaN.  */\n \n \t      if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t\t   || GET_MODE_CLASS (mode_arg0) != MODE_FLOAT)\n+\t\t   || ! FLOAT_MODE_P (mode_arg0))\n \t\t  && (folded_arg0 == folded_arg1\n \t\t      || (GET_CODE (folded_arg0) == REG\n \t\t\t  && GET_CODE (folded_arg1) == REG\n@@ -5116,7 +5110,7 @@ fold_rtx (x, insn)\n \t\t      && (comparison_dominates_p (qty_comparison_code[qty], code)\n \t\t\t  || (comparison_dominates_p (qty_comparison_code[qty],\n \t\t\t\t\t\t      reverse_condition (code))\n-\t\t\t      && GET_MODE_CLASS (mode_arg0) == MODE_INT))\n+\t\t\t      && ! FLOAT_MODE_P (mode_arg0)))\n \t\t      && (rtx_equal_p (qty_comparison_const[qty], folded_arg1)\n \t\t\t  || (const_arg1\n \t\t\t      && rtx_equal_p (qty_comparison_const[qty],\n@@ -5588,7 +5582,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n      If we record the equality, we might inadvertently delete code\n      whose intent was to change -0 to +0.  */\n \n-  if (code != EQ || GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n+  if (code != EQ || FLOAT_MODE_P (GET_MODE (op0)))\n     {\n       /* If we reversed a floating-point comparison, if OP0 is not a\n \t register, or if OP1 is neither a register or constant, we can't\n@@ -5597,7 +5591,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n       if (GET_CODE (op1) != REG)\n \top1 = equiv_constant (op1);\n \n-      if ((reversed_nonequality && GET_MODE_CLASS (mode) != MODE_INT)\n+      if ((reversed_nonequality && FLOAT_MODE_P (mode))\n \t  || GET_CODE (op0) != REG || op1 == 0)\n \treturn;\n \n@@ -6695,7 +6689,7 @@ cse_insn (insn, in_libcall_block)\n \t{\n \t  this_insn_cc0 = src_const && mode != VOIDmode ? src_const : src;\n \t  this_insn_cc0_mode = mode;\n-\t  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t  if (FLOAT_MODE_P (mode))\n \t    this_insn_cc0 = gen_rtx (COMPARE, VOIDmode, this_insn_cc0,\n \t\t\t\t     CONST0_RTX (mode));\n \t}\n@@ -6861,7 +6855,7 @@ cse_insn (insn, in_libcall_block)\n \t   memory.  */\n \tif ((flag_float_store\n \t     && GET_CODE (dest) == MEM\n-\t     && GET_MODE_CLASS (GET_MODE (dest)) == MODE_FLOAT)\n+\t     && FLOAT_MODE_P (GET_MODE (dest)))\n \t    /* Don't record values of destinations set inside a libcall block\n \t       since we might delete the libcall.  Things should have been set\n \t       up so we won't want to reuse such a value, but we play it safe"}]}