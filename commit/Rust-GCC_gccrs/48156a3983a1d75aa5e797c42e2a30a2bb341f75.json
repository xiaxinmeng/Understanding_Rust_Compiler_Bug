{"sha": "48156a3983a1d75aa5e797c42e2a30a2bb341f75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgxNTZhMzk4M2ExZDc1YWE1ZTc5N2M0MmUyYTMwYTJiYjM0MWY3NQ==", "commit": {"author": {"name": "Nigel Stephens", "email": "nigel@mips.com", "date": "2007-07-20T15:41:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-07-20T15:41:29Z"}, "message": "mips.h (mips_dwarf_regno): Declare.\n\ngcc/\n2007-07-20  Nigel Stephens  <nigel@mips.com>\n\t    Richard Sandiford  <richard@codesourcery.com>\n\n\t* config/mips/mips.h (mips_dwarf_regno): Declare.\n\t(DBX_REGISTER_NUMBER): Remove redundant brackets.\n\t(HI_REGNUM, LO_REGNUM): Define in an endian-dependent way.\n\t(AC1HI_REGNUM, AC1LO_REGNUM, AC2HI_REGNUM, AC2LO_REGNUM)\n\t(AC3HI_REGNUM, AC3LO_REGNUM, ACC_HI_REG_P): Delete.\n\t(reg_class): Rename HI_REG to MD0_REG and LO_REG to MD1_REG.\n\t(REG_CLASS_NAMES): Update accordingly.\n\t* config/mips/mips.c (mips_dwarf_regno): New array.\n\t(mips_regno_to_class): Rename HI_REG to MD0_REG and LO_REG to MD1_REG.\n\t(mips_subword): Remove special handling for accumulator registers.\n\t(override_options): Initiailize mips_dwarf_regno.  Remove use\n\tof ACC_HI_REG_P.\n\t(mips_swap_registers): New function.\n\t(mips_conditional_register_usage): Swap accumulator registers\n\taround if TARGET_LITTLE_ENDIAN.\n\t(mips_cannot_change_mode_class): Remove special treatment of ACC_REGS.\n\t* config/mips/constraints.md (h, l): Use the endianness to choose\n\tbetween MD0_REG and MD1_REG.\n\t* config/mips/mips.md (*mfhilo_<mode>_macc): Use a fixed-string,\n\talternative-dependent template.\n\nCo-Authored-By: Richard Sandiford <richard@codesourcery.com>\n\nFrom-SVN: r126801", "tree": {"sha": "c9f674530498f77de7b6d6883767b9023b345c25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9f674530498f77de7b6d6883767b9023b345c25"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48156a3983a1d75aa5e797c42e2a30a2bb341f75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48156a3983a1d75aa5e797c42e2a30a2bb341f75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48156a3983a1d75aa5e797c42e2a30a2bb341f75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48156a3983a1d75aa5e797c42e2a30a2bb341f75/comments", "author": null, "committer": null, "parents": [{"sha": "b644e061999f6186d4f0474f3dc2da3370869986", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b644e061999f6186d4f0474f3dc2da3370869986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b644e061999f6186d4f0474f3dc2da3370869986"}], "stats": {"total": 144, "additions": 94, "deletions": 50}, "files": [{"sha": "ba96d763d9644b6958b4c596c39b3c542dea2c8b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48156a3983a1d75aa5e797c42e2a30a2bb341f75", "patch": "@@ -1,3 +1,27 @@\n+2007-07-20  Nigel Stephens  <nigel@mips.com>\n+\t    Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/mips/mips.h (mips_dwarf_regno): Declare.\n+\t(DBX_REGISTER_NUMBER): Remove redundant brackets.\n+\t(HI_REGNUM, LO_REGNUM): Define in an endian-dependent way.\n+\t(AC1HI_REGNUM, AC1LO_REGNUM, AC2HI_REGNUM, AC2LO_REGNUM)\n+\t(AC3HI_REGNUM, AC3LO_REGNUM, ACC_HI_REG_P): Delete.\n+\t(reg_class): Rename HI_REG to MD0_REG and LO_REG to MD1_REG.\n+\t(REG_CLASS_NAMES): Update accordingly.\n+\t* config/mips/mips.c (mips_dwarf_regno): New array.\n+\t(mips_regno_to_class): Rename HI_REG to MD0_REG and LO_REG to MD1_REG.\n+\t(mips_subword): Remove special handling for accumulator registers.\n+\t(override_options): Initiailize mips_dwarf_regno.  Remove use\n+\tof ACC_HI_REG_P.\n+\t(mips_swap_registers): New function.\n+\t(mips_conditional_register_usage): Swap accumulator registers\n+\taround if TARGET_LITTLE_ENDIAN.\n+\t(mips_cannot_change_mode_class): Remove special treatment of ACC_REGS.\n+\t* config/mips/constraints.md (h, l): Use the endianness to choose\n+\tbetween MD0_REG and MD1_REG.\n+\t* config/mips/mips.md (*mfhilo_<mode>_macc): Use a fixed-string,\n+\talternative-dependent template.\n+\n 2007-07-20  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/arm/arm.md (movsi): Use can_create_pseudo_p instead of"}, {"sha": "5b184e2b69a4f0d772ec9fc1f5b42907b9a38e57", "filename": "gcc/config/mips/constraints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2Fconfig%2Fmips%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2Fconfig%2Fmips%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fconstraints.md?ref=48156a3983a1d75aa5e797c42e2a30a2bb341f75", "patch": "@@ -30,10 +30,10 @@\n (define_register_constraint \"f\" \"TARGET_HARD_FLOAT ? FP_REGS : NO_REGS\"\n   \"A floating-point register (if available).\")\n \n-(define_register_constraint \"h\" \"HI_REG\"\n+(define_register_constraint \"h\" \"TARGET_BIG_ENDIAN ? MD0_REG : MD1_REG\"\n   \"The @code{hi} register.\")\n \n-(define_register_constraint \"l\" \"LO_REG\"\n+(define_register_constraint \"l\" \"TARGET_BIG_ENDIAN ? MD1_REG : MD0_REG\"\n   \"The @code{lo} register.\")\n \n (define_register_constraint \"x\" \"MD_REGS\""}, {"sha": "ef9a8c068ca870f6b32b1f29a57e983905128d60", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=48156a3983a1d75aa5e797c42e2a30a2bb341f75", "patch": "@@ -639,6 +639,7 @@ char mips_print_operand_punct[256];\n \n /* Map GCC register number to debugger register number.  */\n int mips_dbx_regno[FIRST_PSEUDO_REGISTER];\n+int mips_dwarf_regno[FIRST_PSEUDO_REGISTER];\n \n /* A copy of the original flag_delayed_branch: see override_options.  */\n static int mips_flag_delayed_branch;\n@@ -676,7 +677,7 @@ const enum reg_class mips_regno_to_class[] =\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n-  HI_REG,\tLO_REG,\t\tNO_REGS,\tST_REGS,\n+  MD0_REG,\tMD1_REG,\tNO_REGS,\tST_REGS,\n   ST_REGS,\tST_REGS,\tST_REGS,\tST_REGS,\n   ST_REGS,\tST_REGS,\tST_REGS,\tNO_REGS,\n   NO_REGS,\tALL_REGS,\tALL_REGS,\tNO_REGS,\n@@ -2991,13 +2992,8 @@ mips_subword (rtx op, int high_p)\n   else\n     byte = 0;\n \n-  if (REG_P (op))\n-    {\n-      if (FP_REG_P (REGNO (op)))\n-\treturn gen_rtx_REG (word_mode, high_p ? REGNO (op) + 1 : REGNO (op));\n-      if (ACC_HI_REG_P (REGNO (op)))\n-\treturn gen_rtx_REG (word_mode, high_p ? REGNO (op) : REGNO (op) + 1);\n-    }\n+  if (FP_REG_RTX_P (op))\n+    return gen_rtx_REG (word_mode, high_p ? REGNO (op) + 1 : REGNO (op));\n \n   if (MEM_P (op))\n     return mips_rewrite_small_data (adjust_address (op, word_mode, byte));\n@@ -5293,7 +5289,13 @@ override_options (void)\n      Ignore the special purpose register numbers.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    mips_dbx_regno[i] = -1;\n+    {\n+      mips_dbx_regno[i] = INVALID_REGNUM;\n+      if (GP_REG_P (i) || FP_REG_P (i) || ALL_COP_REG_P (i))\n+\tmips_dwarf_regno[i] = i;\n+      else\n+\tmips_dwarf_regno[i] = INVALID_REGNUM;\n+    }\n \n   start = GP_DBX_FIRST - GP_REG_FIRST;\n   for (i = GP_REG_FIRST; i <= GP_REG_LAST; i++)\n@@ -5303,8 +5305,16 @@ override_options (void)\n   for (i = FP_REG_FIRST; i <= FP_REG_LAST; i++)\n     mips_dbx_regno[i] = i + start;\n \n+  /* HI and LO debug registers use big-endian ordering.  */\n   mips_dbx_regno[HI_REGNUM] = MD_DBX_FIRST + 0;\n   mips_dbx_regno[LO_REGNUM] = MD_DBX_FIRST + 1;\n+  mips_dwarf_regno[HI_REGNUM] = MD_REG_FIRST + 0;\n+  mips_dwarf_regno[LO_REGNUM] = MD_REG_FIRST + 1;\n+  for (i = DSP_ACC_REG_FIRST; i <= DSP_ACC_REG_LAST; i += 2)\n+    {\n+      mips_dwarf_regno[i + TARGET_LITTLE_ENDIAN] = i;\n+      mips_dwarf_regno[i + TARGET_BIG_ENDIAN] = i + 1;\n+    }\n \n   /* Set up array giving whether a given register can hold a given mode.  */\n \n@@ -5362,9 +5372,11 @@ override_options (void)\n \n           else if (ACC_REG_P (regno))\n \t    temp = (INTEGRAL_MODE_P (mode)\n+\t\t    && size <= UNITS_PER_WORD * 2\n \t\t    && (size <= UNITS_PER_WORD\n-\t\t\t|| (ACC_HI_REG_P (regno)\n-\t\t\t    && size == 2 * UNITS_PER_WORD)));\n+\t\t\t|| regno == MD_REG_FIRST\n+\t\t\t|| (DSP_ACC_REG_P (regno)\n+\t\t\t    && ((regno - DSP_ACC_REG_FIRST) & 1) == 0)));\n \n \t  else if (ALL_COP_REG_P (regno))\n \t    temp = (class == MODE_INT && size <= UNITS_PER_WORD);\n@@ -5509,6 +5521,29 @@ override_options (void)\n     target_flags |= MASK_FIX_R4400;\n }\n \n+/* Swap the register information for registers I and I + 1, which\n+   currently have the wrong endianness.  Note that the registers'\n+   fixedness and call-clobberedness might have been set on the\n+   command line.  */\n+\n+static void\n+mips_swap_registers (unsigned int i)\n+{\n+  int tmpi;\n+  const char *tmps;\n+\n+#define SWAP_INT(X, Y) (tmpi = (X), (X) = (Y), (Y) = tmpi)\n+#define SWAP_STRING(X, Y) (tmps = (X), (X) = (Y), (Y) = tmps)\n+\n+  SWAP_INT (fixed_regs[i], fixed_regs[i + 1]);\n+  SWAP_INT (call_used_regs[i], call_used_regs[i + 1]);\n+  SWAP_INT (call_really_used_regs[i], call_really_used_regs[i + 1]);\n+  SWAP_STRING (reg_names[i], reg_names[i + 1]);\n+\n+#undef SWAP_STRING\n+#undef SWAP_INT\n+}\n+\n /* Implement CONDITIONAL_REGISTER_USAGE.  */\n \n void\n@@ -5570,6 +5605,15 @@ mips_conditional_register_usage (void)\n       for (regno = FP_REG_FIRST + 21; regno <= FP_REG_FIRST + 31; regno+=2)\n \tcall_really_used_regs[regno] = call_used_regs[regno] = 1;\n     }\n+  /* Make sure that double-register accumulator values are correctly\n+     ordered for the current endianness.  */\n+  if (TARGET_LITTLE_ENDIAN)\n+    {\n+      int regno;\n+      mips_swap_registers (MD_REG_FIRST);\n+      for (regno = DSP_ACC_REG_FIRST; regno <= DSP_ACC_REG_LAST; regno += 2)\n+\tmips_swap_registers (regno);\n+    }\n }\n \n /* Allocate a chunk of memory for per-function machine-dependent data.  */\n@@ -8485,17 +8529,6 @@ mips_cannot_change_mode_class (enum machine_mode from,\n \t  if (MAX_FPRS_PER_FMT > 1 && reg_classes_intersect_p (FP_REGS, class))\n \t    return true;\n \t}\n-      else\n-\t{\n-\t  /* LO_REGNO == HI_REGNO + 1, so if a multi-word value is stored\n-\t     in LO and HI, the high word always comes first.  We therefore\n-\t     can't allow values stored in HI to change between single-word\n-\t     and multi-word modes.\n-\t     This rule applies to both the original HI/LO pair and the new\n-\t     DSP accumulators.  */\n-\t  if (reg_classes_intersect_p (ACC_REGS, class))\n-\t    return true;\n-\t}\n     }\n \n   /* gcc assumes that each word of a multiword register can be accessed"}, {"sha": "46fa592ed8c30143cd56e17657258183892a006f", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=48156a3983a1d75aa5e797c42e2a30a2bb341f75", "patch": "@@ -126,7 +126,8 @@ extern int set_nomacro;\t\t\t/* # of nested .set nomacro's  */\n extern int set_noat;\t\t\t/* # of nested .set noat's  */\n extern int set_volatile;\t\t/* # of nested .set volatile's  */\n extern int mips_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n-extern int mips_dbx_regno[];\t\t/* Map register # to debug register # */\n+extern int mips_dbx_regno[];\n+extern int mips_dwarf_regno[];\n extern bool mips_split_p[];\n extern GTY(()) rtx cmp_operands[2];\n extern enum processor_type mips_arch;   /* which cpu to codegen for */\n@@ -1010,11 +1011,10 @@ extern const struct mips_rtx_cost_data *mips_cost;\n #define DBX_CONTIN_LENGTH 1500\n \n /* How to renumber registers for dbx and gdb.  */\n-#define DBX_REGISTER_NUMBER(REGNO) mips_dbx_regno[ (REGNO) ]\n+#define DBX_REGISTER_NUMBER(REGNO) mips_dbx_regno[REGNO]\n \n /* The mapping from gcc register number to DWARF 2 CFA column number.  */\n-#define DWARF_FRAME_REGNUM(REG) \\\n-  ((REG) == DWARF_ALT_FRAME_RETURN_COLUMN ? INVALID_REGNUM : (REG))\n+#define DWARF_FRAME_REGNUM(REGNO) mips_dwarf_regno[REGNO]\n \n /* The DWARF 2 CFA column which tracks the return address.  */\n #define DWARF_FRAME_RETURN_COLUMN (GP_REG_FIRST + 31)\n@@ -1393,14 +1393,8 @@ extern const struct mips_rtx_cost_data *mips_cost;\n #define DSP_ACC_REG_NUM (DSP_ACC_REG_LAST - DSP_ACC_REG_FIRST + 1)\n \n #define AT_REGNUM\t(GP_REG_FIRST + 1)\n-#define HI_REGNUM\t(MD_REG_FIRST + 0)\n-#define LO_REGNUM\t(MD_REG_FIRST + 1)\n-#define AC1HI_REGNUM\t(DSP_ACC_REG_FIRST + 0)\n-#define AC1LO_REGNUM\t(DSP_ACC_REG_FIRST + 1)\n-#define AC2HI_REGNUM\t(DSP_ACC_REG_FIRST + 2)\n-#define AC2LO_REGNUM\t(DSP_ACC_REG_FIRST + 3)\n-#define AC3HI_REGNUM\t(DSP_ACC_REG_FIRST + 4)\n-#define AC3LO_REGNUM\t(DSP_ACC_REG_FIRST + 5)\n+#define HI_REGNUM\t(TARGET_BIG_ENDIAN ? MD_REG_FIRST : MD_REG_FIRST + 1)\n+#define LO_REGNUM\t(TARGET_BIG_ENDIAN ? MD_REG_FIRST + 1 : MD_REG_FIRST)\n \n /* FPSW_REGNUM is the single condition code used if !ISA_HAS_8CC.\n    If ISA_HAS_8CC, it should not be used, and an arbitrary ST_REG\n@@ -1431,10 +1425,6 @@ extern const struct mips_rtx_cost_data *mips_cost;\n /* Test if REGNO is hi, lo, or one of the 6 new DSP accumulators.  */\n #define ACC_REG_P(REGNO) \\\n   (MD_REG_P (REGNO) || DSP_ACC_REG_P (REGNO))\n-/* Test if REGNO is HI or the first register of 3 new DSP accumulator pairs.  */\n-#define ACC_HI_REG_P(REGNO) \\\n-  ((REGNO) == HI_REGNUM || (REGNO) == AC1HI_REGNUM || (REGNO) == AC2HI_REGNUM \\\n-   || (REGNO) == AC3HI_REGNUM)\n \n #define FP_REG_RTX_P(X) (REG_P (X) && FP_REG_P (REGNO (X)))\n \n@@ -1562,8 +1552,8 @@ enum reg_class\n   LEA_REGS,\t\t\t/* Every GPR except $25 */\n   GR_REGS,\t\t\t/* integer registers */\n   FP_REGS,\t\t\t/* floating point registers */\n-  HI_REG,\t\t\t/* hi register */\n-  LO_REG,\t\t\t/* lo register */\n+  MD0_REG,\t\t\t/* first multiply/divide register */\n+  MD1_REG,\t\t\t/* second multiply/divide register */\n   MD_REGS,\t\t\t/* multiply/divide registers (hi/lo) */\n   COP0_REGS,\t\t\t/* generic coprocessor classes */\n   COP2_REGS,\n@@ -1603,8 +1593,8 @@ enum reg_class\n   \"LEA_REGS\",\t\t\t\t\t\t\t\t\\\n   \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n-  \"HI_REG\",\t\t\t\t\t\t\t\t\\\n-  \"LO_REG\",\t\t\t\t\t\t\t\t\\\n+  \"MD0_REG\",\t\t\t\t\t\t\t\t\\\n+  \"MD1_REG\",\t\t\t\t\t\t\t\t\\\n   \"MD_REGS\",\t\t\t\t\t\t\t\t\\\n   /* coprocessor registers */\t\t\t\t\t\t\\\n   \"COP0_REGS\",\t\t\t\t\t\t\t\t\\"}, {"sha": "0a060aa19cf8f68bc93071588e9142f7ffc54469", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48156a3983a1d75aa5e797c42e2a30a2bb341f75/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=48156a3983a1d75aa5e797c42e2a30a2bb341f75", "patch": "@@ -4059,12 +4059,9 @@\n \t\t     (match_operand:GPR 2 \"register_operand\" \"l,h\")]\n \t\t    UNSPEC_MFHILO))]\n   \"ISA_HAS_MACCHI\"\n-{\n-  if (REGNO (operands[1]) == HI_REGNUM)\n-    return \"<d>macchi\\t%0,%.,%.\";\n-  else\n-    return \"<d>macc\\t%0,%.,%.\";\n-}\n+  \"@\n+   <d>macchi\\t%0,%.,%.\n+   <d>macc\\t%0,%.,%.\"\n   [(set_attr \"type\" \"mfhilo\")\n    (set_attr \"mode\" \"<MODE>\")])\n "}]}