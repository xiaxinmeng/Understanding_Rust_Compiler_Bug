{"sha": "105d72c5950000e4215865bd2acef5e963a608dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA1ZDcyYzU5NTAwMDBlNDIxNTg2NWJkMmFjZWY1ZTk2M2E2MDhkYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-07-23T20:28:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-07-23T20:28:26Z"}, "message": "re PR c++/28025 (multiple template friend compile error)\n\n\tPR c++/28025\n\t* cp-tree.h (LOOKUP_HIDDEN): New macro.  Reformat comments.\n\t* name-lookup.c (unqualified_namespace_lookup): There is no way to\n\thave a hidden name in non-namespace scopes.\n\t* pt.c (tsubst_friend_class): Look for hidden names.\n\t* decl.c (lookup_and_check_tag): Fix typo in comment.\n\t* semantics.c (finish_compound_literal): Fix typo in comment.\n\tPR c++/28025\n\t* g++.dg/template/friend45.C: New test.\n\nFrom-SVN: r115687", "tree": {"sha": "6530c82a3bb6524b265d975b0455ba9de9f3d1af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6530c82a3bb6524b265d975b0455ba9de9f3d1af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/105d72c5950000e4215865bd2acef5e963a608dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105d72c5950000e4215865bd2acef5e963a608dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/105d72c5950000e4215865bd2acef5e963a608dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/105d72c5950000e4215865bd2acef5e963a608dc/comments", "author": null, "committer": null, "parents": [{"sha": "74e55d0f8f791d71aa4ac10215126e74277177d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74e55d0f8f791d71aa4ac10215126e74277177d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74e55d0f8f791d71aa4ac10215126e74277177d1"}], "stats": {"total": 127, "additions": 88, "deletions": 39}, "files": [{"sha": "a5848b82aa85bbad4705048d98dec5dc922950e7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=105d72c5950000e4215865bd2acef5e963a608dc", "patch": "@@ -1,3 +1,14 @@\n+2006-07-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/28025\n+\t* cp-tree.h (LOOKUP_HIDDEN): New macro.  Reformat comments.\n+\t* name-lookup.c (unqualified_namespace_lookup): There is no way to\n+\thave a hidden name in non-namespace scopes.\n+\t* pt.c (tsubst_friend_class): Look for hidden names.\n+\t* decl.c (lookup_and_check_tag): Fix typo in comment.\n+\n+\t* semantics.c (finish_compound_literal): Fix typo in comment.\n+\n 2006-07-21  Jason Merrill  <jason@redhat.com>\n \n \t* decl2.c (determine_visibility): Don't propagate visibility from"}, {"sha": "e02d3d7b5bb70138e6be19c703d6e9c2693bbc65", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=105d72c5950000e4215865bd2acef5e963a608dc", "patch": "@@ -3380,46 +3380,51 @@ extern GTY(()) tree static_dtors;\n \n enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n-/* These are uses as bits in flags passed to build_new_method_call\n-   to control its error reporting behavior.\n-\n-   LOOKUP_PROTECT means flag access violations.\n-   LOOKUP_COMPLAIN mean complain if no suitable member function\n-     matching the arguments is found.\n-   LOOKUP_NORMAL is just a combination of these two.\n-   LOOKUP_NONVIRTUAL means make a direct call to the member function found\n-   LOOKUP_ONLYCONVERTING means that non-conversion constructors are not tried.\n-   DIRECT_BIND means that if a temporary is created, it should be created so\n-     that it lives as long as the current variable bindings; otherwise it\n-     only lives until the end of the complete-expression.  It also forces\n-     direct-initialization in cases where other parts of the compiler have\n-     already generated a temporary, such as reference initialization and the\n-     catch parameter.\n-   LOOKUP_NO_CONVERSION means that user-defined conversions are not\n-     permitted.  Built-in conversions are permitted.\n-   LOOKUP_DESTRUCTOR means explicit call to destructor.\n-   LOOKUP_NO_TEMP_BIND means temporaries will not be bound to references.\n-\n-   These are used in global lookup to support elaborated types and\n-   qualifiers.\n-\n-   LOOKUP_PREFER_TYPES means not to accept objects, and possibly namespaces.\n-   LOOKUP_PREFER_NAMESPACES means not to accept objects, and possibly types.\n-   LOOKUP_PREFER_BOTH means class-or-namespace-name.  */\n-\n+/* These are uses as bits in flags passed to various functions to\n+   control their behavior.  Despite the LOOKUP_ prefix, many of these\n+   do not control name lookup.  ??? Functions using these flags should\n+   probably be modified to accept explicit boolean flags for the\n+   behaviors relevant to them.  */\n+/* Check for access violations.  */\n #define LOOKUP_PROTECT (1 << 0)\n+/* Complain if no suitable member function matching the arguments is\n+   found.  */\n #define LOOKUP_COMPLAIN (1 << 1)\n #define LOOKUP_NORMAL (LOOKUP_PROTECT | LOOKUP_COMPLAIN)\n+/* Even if the function found by lookup is a virtual function, it\n+   should be called directly.  */\n #define LOOKUP_NONVIRTUAL (1 << 2)\n+/* Non-converting (i.e., \"explicit\") constructors are not tried.  */\n #define LOOKUP_ONLYCONVERTING (1 << 3)\n+/* If a temporary is created, it should be created so that it lives\n+   as long as the current variable bindings; otherwise it only lives\n+   until the end of the complete-expression.  It also forces\n+   direct-initialization in cases where other parts of the compiler\n+   have already generated a temporary, such as reference\n+   initialization and the catch parameter.  */\n #define DIRECT_BIND (1 << 4)\n+/* User-defined conversions are not permitted.  (Built-in conversions\n+   are permitted.)  */\n #define LOOKUP_NO_CONVERSION (1 << 5)\n+/* The user has explicitly called a destructor.  (Therefore, we do\n+   not need to check that the object is non-NULL before calling the\n+   destructor.)  */\n #define LOOKUP_DESTRUCTOR (1 << 6)\n+/* Do not permit references to bind to temporaries.  */\n #define LOOKUP_NO_TEMP_BIND (1 << 7)\n+/* Do not accept objects, and possibly namespaces.  */\n #define LOOKUP_PREFER_TYPES (1 << 8)\n+/* Do not accept objects, and possibly types.   */\n #define LOOKUP_PREFER_NAMESPACES (1 << 9)\n+/* Accept types or namespaces.  */\n #define LOOKUP_PREFER_BOTH (LOOKUP_PREFER_TYPES | LOOKUP_PREFER_NAMESPACES)\n+/* We are checking that a constructor can be called -- but we do not\n+   actually plan to call it.  */\n #define LOOKUP_CONSTRUCTOR_CALLABLE (1 << 10)\n+/* Return friend decarations and un-declared builtin functions.\n+   (Normally, these entities are registered in the symbol table, but\n+   not found by lookup.)  */\n+#define LOOKUP_HIDDEN (LOOKUP_CONSTRUCTOR_CALLABLE << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))"}, {"sha": "14977496bab9f11e9e93c5da7a7a46f7a8389315", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=105d72c5950000e4215865bd2acef5e963a608dc", "patch": "@@ -9503,7 +9503,7 @@ lookup_and_check_tag (enum tag_types tag_code, tree name,\n       /* If that fails, the name will be placed in the smallest\n \t non-class, non-function-prototype scope according to 3.3.1/5.\n \t We may already have a hidden name declared as friend in this\n-\t scope.  So lookup again but not ignoring hidden name.\n+\t scope.  So lookup again but not ignoring hidden names.\n \t If we find one, that name will be made visible rather than\n \t creating a new tag.  */\n       if (!decl)"}, {"sha": "cdf9ccf1eac4d77fe7fe0fe70ee8bbe668a74b21", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=105d72c5950000e4215865bd2acef5e963a608dc", "patch": "@@ -3681,10 +3681,8 @@ unqualified_namespace_lookup (tree name, int flags)\n \n       if (b)\n \t{\n-\t  if (b->value && hidden_name_p (b->value))\n-\t    /* Ignore anticipated built-in functions and friends.  */\n-\t    ;\n-\t  else\n+\t  if (b->value\n+\t      && ((flags & LOOKUP_HIDDEN) || !hidden_name_p (b->value)))\n \t    binding.value = b->value;\n \t  binding.type = b->type;\n \t}\n@@ -3987,18 +3985,18 @@ lookup_name_real (tree name, int prefer_type, int nonclass, bool block_p,\n \t  continue;\n \n \t/* If this is the kind of thing we're looking for, we're done.  */\n-\tif (qualify_lookup (iter->value, flags)\n-\t    && !hidden_name_p (iter->value))\n+\tif (qualify_lookup (iter->value, flags))\n \t  binding = iter->value;\n \telse if ((flags & LOOKUP_PREFER_TYPES)\n-\t\t && qualify_lookup (iter->type, flags)\n-\t\t && !hidden_name_p (iter->type))\n+\t\t && qualify_lookup (iter->type, flags))\n \t  binding = iter->type;\n \telse\n \t  binding = NULL_TREE;\n \n \tif (binding)\n \t  {\n+\t    /* Only namespace-scope bindings can be hidden.  */\n+\t    gcc_assert (!hidden_name_p (binding));\n \t    val = binding;\n \t    break;\n \t  }"}, {"sha": "e76ad2db3462bb57830bb00937663d8a1ef151ff", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=105d72c5950000e4215865bd2acef5e963a608dc", "patch": "@@ -5408,8 +5408,21 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n \tpush_nested_class (tsubst (context, args, tf_none, NULL_TREE));\n     }\n \n-  /* First, we look for a class template.  */\n-  tmpl = lookup_name (DECL_NAME (friend_tmpl));\n+  /* Look for a class template declaration.  We look for hidden names\n+     because two friend declarations of the same template are the\n+     same.  For example, in:\n+\n+       struct A { \n+         template <typename> friend class F;\n+       };\n+       template <typename> struct B { \n+         template <typename> friend class F;\n+       };\n+\n+     both F templates are the same.  */\n+  tmpl = lookup_name_real (DECL_NAME (friend_tmpl), 0, 0,\n+\t\t\t   /*block_p=*/true, 0, \n+\t\t\t   LOOKUP_COMPLAIN | LOOKUP_HIDDEN);\n \n   /* But, if we don't find one, it might be because we're in a\n      situation like this:"}, {"sha": "e96ba68b0343107324fefcb704b80a5eac3c1224", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=105d72c5950000e4215865bd2acef5e963a608dc", "patch": "@@ -2058,7 +2058,7 @@ finish_compound_literal (tree type, VEC(constructor_elt,gc) *initializer_list)\n       DECL_NAME (var) = make_anon_name ();\n     }\n   /* We must call pushdecl, since the gimplifier complains if the\n-     variable hase been declared via a BIND_EXPR.  */\n+     variable has not been declared via a BIND_EXPR.  */\n   pushdecl (var);\n   /* Initialize the variable as we would any other variable with a\n      brace-enclosed initializer.  */"}, {"sha": "c1a42d65aa570bb3ff0b8083a4b757f7151f0f71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=105d72c5950000e4215865bd2acef5e963a608dc", "patch": "@@ -1,3 +1,8 @@\n+2006-07-23  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/28025\n+\t* g++.dg/template/friend45.C: New test.\n+\n 2006-07-21  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/28339"}, {"sha": "61c365617491e331b88b514365f5f75fd435c820", "filename": "gcc/testsuite/g++.dg/template/friend45.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend45.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/105d72c5950000e4215865bd2acef5e963a608dc/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend45.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend45.C?ref=105d72c5950000e4215865bd2acef5e963a608dc", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/28025\n+\n+class BaseSubmit\n+{\n+  template<class T> friend class PeriodicSubmit;\n+};\n+\n+template<class ID>\n+class ValuesSubmit \n+{\n+  template<class T> friend class PeriodicSubmit;\n+};\n+\n+class A;\n+class MultiSubmit : public ValuesSubmit<A>\n+{\n+};"}]}