{"sha": "ec6376abd7f23e0993138ed92c56552eea9cd5a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM2Mzc2YWJkN2YyM2UwOTkzMTM4ZWQ5MmM1NjU1MmVlYTljZDVhMg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2004-07-01T03:17:31Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-07-01T03:17:31Z"}, "message": "rs6000.c (rs6000_mixed_function_arg): Rewrite.\n\n\t* config/rs6000/rs6000.c (rs6000_mixed_function_arg): Rewrite.\n\t(function_arg): Use rs6000_arg_size rather than CLASS_MAX_NREGS in\n\tcalculating gpr size for altivec.  Simplify and correct\n\trs6000_mixed_function_arg calls.  Call rs6000_mixed_function_arg\n\tfor ABI_V4 gpr case too.  Fix off-by-one error in long double\n\treg test.  Generate the correct PARALLEL to handle long double\n\tfor ABI_AIX 32-bit.  Use this for -m32 -mpowerpc64 fpr case too.\n\t(function_arg_partial_nregs): Align before calculating regs left.\n\tDon't return info on partial fprs when we need info on gprs.\n\tCorrect long double fpr off-by-one error.\n\nFrom-SVN: r83951", "tree": {"sha": "5a669d81deb979bf17d21701d6b077a314514415", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a669d81deb979bf17d21701d6b077a314514415"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec6376abd7f23e0993138ed92c56552eea9cd5a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6376abd7f23e0993138ed92c56552eea9cd5a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec6376abd7f23e0993138ed92c56552eea9cd5a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec6376abd7f23e0993138ed92c56552eea9cd5a2/comments", "author": null, "committer": null, "parents": [{"sha": "cde0e59bf23f3b78e15ae96ceb04a32ad60a89e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cde0e59bf23f3b78e15ae96ceb04a32ad60a89e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cde0e59bf23f3b78e15ae96ceb04a32ad60a89e8"}], "stats": {"total": 316, "additions": 140, "deletions": 176}, "files": [{"sha": "31e9c5cc848392b7f7ab545c616ee1208fd82e2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6376abd7f23e0993138ed92c56552eea9cd5a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6376abd7f23e0993138ed92c56552eea9cd5a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec6376abd7f23e0993138ed92c56552eea9cd5a2", "patch": "@@ -1,3 +1,16 @@\n+2004-07-01  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000.c (rs6000_mixed_function_arg): Rewrite.\n+\t(function_arg): Use rs6000_arg_size rather than CLASS_MAX_NREGS in\n+\tcalculating gpr size for altivec.  Simplify and correct\n+\trs6000_mixed_function_arg calls.  Call rs6000_mixed_function_arg\n+\tfor ABI_V4 gpr case too.  Fix off-by-one error in long double\n+\treg test.  Generate the correct PARALLEL to handle long double\n+\tfor ABI_AIX 32-bit.  Use this for -m32 -mpowerpc64 fpr case too.\n+\t(function_arg_partial_nregs): Align before calculating regs left.\n+\tDon't return info on partial fprs when we need info on gprs.\n+\tCorrect long double fpr off-by-one error.\n+\n 2004-06-30  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa-protos.h (prefetch_operand): Add prototype."}, {"sha": "5b7cd3f1723bc7c373cb921585a6503d0ff7018e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 127, "deletions": 176, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec6376abd7f23e0993138ed92c56552eea9cd5a2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec6376abd7f23e0993138ed92c56552eea9cd5a2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ec6376abd7f23e0993138ed92c56552eea9cd5a2", "patch": "@@ -425,8 +425,7 @@ static int rs6000_get_some_local_dynamic_name_1 (rtx *, void *);\n static rtx rs6000_complex_function_value (enum machine_mode);\n static rtx rs6000_spe_function_arg (CUMULATIVE_ARGS *,\n \t\t\t\t    enum machine_mode, tree);\n-static rtx rs6000_mixed_function_arg (CUMULATIVE_ARGS *,\n-\t\t\t\t      enum machine_mode, tree, int);\n+static rtx rs6000_mixed_function_arg (enum machine_mode, tree, int);\n static void rs6000_move_block_from_reg (int regno, rtx x, int nregs);\n static void setup_incoming_varargs (CUMULATIVE_ARGS *,\n \t\t\t\t    enum machine_mode, tree,\n@@ -4424,124 +4423,49 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n /* Determine where to place an argument in 64-bit mode with 32-bit ABI.  */\n \n static rtx\n-rs6000_mixed_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n-\t\t\t   tree type, int align_words)\n-{\n-  if (mode == DFmode)\n-    {\n-      /* -mpowerpc64 with 32bit ABI splits up a DFmode argument\n-\t in vararg list into zero, one or two GPRs */\n-      if (align_words >= GP_ARG_NUM_REG)\n-\treturn gen_rtx_PARALLEL (DFmode,\n-\t\t gen_rtvec (2,\n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       NULL_RTX, const0_rtx), \n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_REG (mode,\n-\t\t\t\t\t\t\t    cum->fregno),\n-\t\t\t\t\t       const0_rtx)));\n-      else if (align_words + rs6000_arg_size (mode, type)\n-\t       > GP_ARG_NUM_REG)\n-\t/* If this is partially on the stack, then we only\n-\t   include the portion actually in registers here.  */\n-\treturn gen_rtx_PARALLEL (DFmode,\n-\t\t gen_rtvec (2,   \n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t    GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t    + align_words),\n-\t\t\t\t\t       const0_rtx),\n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_REG (mode,\n-\t\t\t\t\t\t\t    cum->fregno),\n-\t\t\t\t\t       const0_rtx)));\n-\n-      /* split a DFmode arg into two GPRs */\n-      return gen_rtx_PARALLEL (DFmode,\n-\t       gen_rtvec (3,\n-\t\t\t  gen_rtx_EXPR_LIST (VOIDmode,       \n-\t\t\t\t\t     gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t  GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t  + align_words),\n-\t\t\t\t\t     const0_rtx),\n-\t\t\t  gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t     gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t  GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t  + align_words + 1),\n-\t\t\t\t\t     GEN_INT (4)),\n-\t\t\t  gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t     gen_rtx_REG (mode, cum->fregno),\n-\t\t\t\t\t     const0_rtx)));\n-    }\n-  /* -mpowerpc64 with 32bit ABI splits up a DImode argument into one\n-     or two GPRs */\n-  else if (mode == DImode)\n+rs6000_mixed_function_arg (enum machine_mode mode, tree type, int align_words)\n+{\n+  int n_units;\n+  int i, k;\n+  rtx rvec[GP_ARG_NUM_REG + 1];\n+\n+  if (align_words >= GP_ARG_NUM_REG)\n+    return NULL_RTX;\n+\n+  n_units = rs6000_arg_size (mode, type);\n+\n+  /* Optimize the simple case where the arg fits in one gpr, except in\n+     the case of BLKmode due to assign_parms assuming that registers are\n+     BITS_PER_WORD wide.  */\n+  if (n_units == 0\n+      || (n_units == 1 && mode != BLKmode))\n+    return gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n+\n+  k = 0;\n+  if (align_words + n_units > GP_ARG_NUM_REG)\n+    /* Not all of the arg fits in gprs.  Say that it goes in memory too,\n+       using a magic NULL_RTX component.\n+       FIXME: This is not strictly correct.  Only some of the arg\n+       belongs in memory, not all of it.  However, there isn't any way\n+       to do this currently, apart from building rtx descriptions for\n+       the pieces of memory we want stored.  Due to bugs in the generic\n+       code we can't use the normal function_arg_partial_nregs scheme\n+       with the PARALLEL arg description we emit here.\n+       In any case, the code to store the whole arg to memory is often\n+       more efficient than code to store pieces, and we know that space\n+       is available in the right place for the whole arg.  */\n+    rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n+\n+  i = 0;\n+  do\n     {\n-      if (align_words < GP_ARG_NUM_REG - 1)\n-\treturn gen_rtx_PARALLEL (DImode,\n-\t\t gen_rtvec (2,\n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t    GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t    + align_words),\n-\t\t\t\t\t       const0_rtx),\n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t    GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t    + align_words + 1),\n-\t\t\t\t\t       GEN_INT (4))));\n-      else if (align_words == GP_ARG_NUM_REG - 1)\n-\t  return gen_rtx_PARALLEL (DImode,\n-\t\t   gen_rtvec (2,\n-\t\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t NULL_RTX, const0_rtx),\n-\t\t\t      gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t      GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t      + align_words),\n-\t\t\t\t\t\t const0_rtx)));\n-    }\n-  else if (ALTIVEC_VECTOR_MODE (mode) && align_words == GP_ARG_NUM_REG - 2)\n-    {\n-      /* Varargs vector regs must be saved in R9-R10.  */\n-      return gen_rtx_PARALLEL (mode,\n-\t   \t\t       gen_rtvec (3,\n-\t\t\t         gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t     NULL_RTX, const0_rtx),\n-\t\t\t         gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t    gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t         GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t         + align_words),\n-\t\t\t\t\t\t    const0_rtx),\n-\t\t\t         gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t\t    gen_rtx_REG (SImode,\n-\t\t\t\t\t\t\t         GP_ARG_MIN_REG\n-\t\t\t\t\t\t\t         + align_words + 1),\n-\t\t\t\t\t\t    GEN_INT (4))));\n-    }\n-  else if ((mode == BLKmode || ALTIVEC_VECTOR_MODE (mode))\n-           && align_words <= (GP_ARG_NUM_REG - 1))\n-    {\n-      /* AltiVec vector regs are saved in R5-R8. */\n-      int k;\n-      int size = int_size_in_bytes (type);\n-      int no_units = ((size - 1) / 4) + 1;\n-      int max_no_words = GP_ARG_NUM_REG - align_words;\n-      int rtlvec_len = no_units < max_no_words ? no_units : max_no_words;\n-      rtx *rtlvec = (rtx *) alloca (rtlvec_len * sizeof (rtx));\n-\n-      memset ((char *) rtlvec, 0, rtlvec_len * sizeof (rtx));\n-\n-      for (k=0; k < rtlvec_len; k++)\n-\trtlvec[k] = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t       gen_rtx_REG (SImode,\n-\t\t\t\t\t\t    GP_ARG_MIN_REG\n-\t\t\t\t\t\t    + align_words + k),\n-\t\t\t\t       k == 0 ? const0_rtx : GEN_INT (k*4));\n-\n-      return gen_rtx_PARALLEL (mode, gen_rtvec_v (k, rtlvec));\n+      rtx r = gen_rtx_REG (SImode, GP_ARG_MIN_REG + align_words);\n+      rtx off = GEN_INT (i++ * 4);\n+      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);\n     }\n-  return NULL_RTX;\n+  while (++align_words < GP_ARG_NUM_REG && --n_units != 0);\n+\n+  return gen_rtx_PARALLEL (mode, gen_rtvec_v (k, rvec));\n }\n \n /* Determine where to put an argument to a function.\n@@ -4636,8 +4560,8 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t{\n \t  /* Vector parameters to varargs functions under AIX or Darwin\n \t     get passed in memory and possibly also in GPRs.  */\n-\t  int align, align_words;\n-\t  enum machine_mode part_mode = mode;\n+\t  int align, align_words, n_words;\n+\t  enum machine_mode part_mode;\n \n \t  /* Vector parameters must be 16-byte aligned.  This places them at\n \t     2 mod 4 in terms of words in 32-bit mode, since the parameter\n@@ -4653,20 +4577,20 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  /* Out of registers?  Memory, then.  */\n \t  if (align_words >= GP_ARG_NUM_REG)\n \t    return NULL_RTX;\n-\t  \n+\n+\t  if (TARGET_32BIT && TARGET_POWERPC64)\n+\t    return rs6000_mixed_function_arg (mode, type, align_words);\n+\n \t  /* The vector value goes in GPRs.  Only the part of the\n \t     value in GPRs is reported here.  */\n-\t  if (align_words + CLASS_MAX_NREGS (mode, GENERAL_REGS)\n-\t      > GP_ARG_NUM_REG)\n+\t  part_mode = mode;\n+\t  n_words = rs6000_arg_size (mode, type);\n+\t  if (align_words + n_words > GP_ARG_NUM_REG)\n \t    /* Fortunately, there are only two possibilities, the value\n \t       is either wholly in GPRs or half in GPRs and half not.  */\n \t    part_mode = DImode;\n-\t  \n-\t  if (TARGET_32BIT\n-\t      && (TARGET_POWERPC64 || (align_words == GP_ARG_NUM_REG - 2)))\n-\t    return rs6000_mixed_function_arg (cum, part_mode, type, align_words);\n-\t  else\n-\t    return gen_rtx_REG (part_mode, GP_ARG_MIN_REG + align_words);\n+\n+\t  return gen_rtx_REG (part_mode, GP_ARG_MIN_REG + align_words);\n \t}\n     }\n   else if (TARGET_SPE_ABI && TARGET_SPE && SPE_VECTOR_MODE (mode))\n@@ -4693,10 +4617,13 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t    gregno += (1 - gregno) & 1;\n \n \t  /* Multi-reg args are not split between registers and stack.  */\n-\t  if (gregno + n_words - 1 <= GP_ARG_MAX_REG)\n-\t    return gen_rtx_REG (mode, gregno);\n-\t  else\n+\t  if (gregno + n_words - 1 > GP_ARG_MAX_REG)\n \t    return NULL_RTX;\n+\n+\t  if (TARGET_32BIT && TARGET_POWERPC64)\n+\t    return rs6000_mixed_function_arg (mode, type,\n+\t\t\t\t\t      gregno - GP_ARG_MIN_REG);\n+\t  return gen_rtx_REG (mode, gregno);\n \t}\n     }\n   else\n@@ -4706,25 +4633,23 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n       if (USE_FP_FOR_ARG_P (cum, mode, type))\n \t{\n-\t  rtx fpr[2];\n-\t  rtx *r;\n+\t  rtx rvec[GP_ARG_NUM_REG + 1];\n+\t  rtx r;\n+\t  int k;\n \t  bool needs_psave;\n \t  enum machine_mode fmode = mode;\n-\t  int n;\n \t  unsigned long n_fpreg = (GET_MODE_SIZE (mode) + 7) >> 3;\n \n \t  if (cum->fregno + n_fpreg > FP_ARG_MAX_REG + 1)\n \t    {\n-\t      /* Long double split over regs and memory.  */\n-\t      if (fmode == TFmode)\n-\t\tfmode = DFmode;\n-\n \t      /* Currently, we only ever need one reg here because complex\n \t\t doubles are split.  */\n-\t      if (cum->fregno != FP_ARG_MAX_REG - 1)\n+\t      if (cum->fregno != FP_ARG_MAX_REG || fmode != TFmode)\n \t\tabort ();\n+\n+\t      /* Long double split over regs and memory.  */\n+\t      fmode = DFmode;\n \t    }\n-\t  fpr[1] = gen_rtx_REG (fmode, cum->fregno);\n \n \t  /* Do we also need to pass this arg in the parameter save\n \t     area?  */\n@@ -4735,46 +4660,55 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t && align_words >= GP_ARG_NUM_REG)));\n \n \t  if (!needs_psave && mode == fmode)\n-\t    return fpr[1];\n-\n-          if (TARGET_32BIT && TARGET_POWERPC64\n-              && mode == DFmode && cum->stdarg)\n-            return rs6000_mixed_function_arg (cum, mode, type, align_words);\n-\n-\t  /* Describe where this piece goes.  */\n-\t  r = fpr + 1;\n-\t  *r = gen_rtx_EXPR_LIST (VOIDmode, *r, const0_rtx);\n-\t  n = 1;\n+\t    return gen_rtx_REG (fmode, cum->fregno);\n \n+\t  k = 0;\n \t  if (needs_psave)\n \t    {\n-\t      /* Now describe the part that goes in gprs or the stack.\n+\t      /* Describe the part that goes in gprs or the stack.\n \t\t This piece must come first, before the fprs.  */\n-\t      rtx reg = NULL_RTX;\n \t      if (align_words < GP_ARG_NUM_REG)\n \t\t{\n \t\t  unsigned long n_words = rs6000_arg_size (mode, type);\n-\t\t  enum machine_mode rmode = mode;\n-\n-\t\t  if (align_words + n_words > GP_ARG_NUM_REG)\n-\t\t    /* If this is partially on the stack, then we only\n-\t\t       include the portion actually in registers here.\n-\t\t       We know this can only be one register because\n-\t\t       complex doubles are splt.  */\n-\t\t    rmode = Pmode;\n-\t\t  reg = gen_rtx_REG (rmode, GP_ARG_MIN_REG + align_words);\n+\n+\t\t  if (align_words + n_words > GP_ARG_NUM_REG\n+\t\t      || (TARGET_32BIT && TARGET_POWERPC64))\n+\t\t    {\n+\t\t      /* If this is partially on the stack, then we only\n+\t\t\t include the portion actually in registers here.  */\n+\t\t      enum machine_mode rmode = TARGET_32BIT ? SImode : DImode;\n+\t\t      rtx off;\n+\t\t      do\n+\t\t\t{\n+\t\t\t  r = gen_rtx_REG (rmode,\n+\t\t\t\t\t   GP_ARG_MIN_REG + align_words);\n+\t\t\t  off = GEN_INT (k * GET_MODE_SIZE (rmode));\n+\t\t\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);\n+\t\t\t}\n+\t\t      while (++align_words < GP_ARG_NUM_REG && --n_words != 0);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* The whole arg fits in gprs.  */\n+\t\t      r = gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n+\t\t      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, const0_rtx);\n+\t\t    }\n \t\t}\n-\t      *--r = gen_rtx_EXPR_LIST (VOIDmode, reg, const0_rtx);\n-\t      ++n;\n+\t      else\n+\t\t/* It's entirely in memory.  */\n+\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n \t    }\n \n-\t  return gen_rtx_PARALLEL (mode, gen_rtvec_v (n, r));\n+\t  /* Describe where this piece goes in the fprs.  */\n+\t  r = gen_rtx_REG (fmode, cum->fregno);\n+\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, const0_rtx);\n+\n+\t  return gen_rtx_PARALLEL (mode, gen_rtvec_v (k, rvec));\n \t}\n       else if (align_words < GP_ARG_NUM_REG)\n \t{\n-\t  if (TARGET_32BIT && TARGET_POWERPC64\n-\t      && (mode == DImode || mode == BLKmode))\n-\t    return rs6000_mixed_function_arg (cum, mode, type, align_words);\n+\t  if (TARGET_32BIT && TARGET_POWERPC64)\n+\t    return rs6000_mixed_function_arg (mode, type, align_words);\n \n \t  return gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n \t}\n@@ -4783,15 +4717,20 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     }\n }\n \f\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n+/* For an arg passed partly in registers and partly in memory, this is\n+   the number of registers used.  For args passed entirely in registers\n+   or entirely in memory, zero.  When an arg is described by a PARALLEL,\n+   perhaps using more than one register type, this function returns the\n+   number of registers used by the first element of the PARALLEL.  */\n \n int\n function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode, \n \t\t\t    tree type, int named)\n {\n   int ret = 0;\n+  int align;\n+  int parm_offset;\n+  int align_words;\n \n   if (DEFAULT_ABI == ABI_V4)\n     return 0;\n@@ -4800,17 +4739,29 @@ function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       && cum->nargs_prototype >= 0)\n     return 0;\n \n-  if (USE_FP_FOR_ARG_P (cum, mode, type))\n+  align = function_arg_boundary (mode, type) / PARM_BOUNDARY - 1;\n+  parm_offset = TARGET_32BIT ? 2 : 0;\n+  align_words = cum->words + ((parm_offset - cum->words) & align);\n+\n+  if (USE_FP_FOR_ARG_P (cum, mode, type)\n+      /* If we are passing this arg in gprs as well, then this function\n+\t should return the number of gprs (or memory) partially passed,\n+\t *not* the number of fprs.  */\n+      && !(type\n+\t   && (cum->nargs_prototype <= 0\n+\t       || (DEFAULT_ABI == ABI_AIX\n+\t\t   && TARGET_XL_CALL\n+\t\t   && align_words >= GP_ARG_NUM_REG))))\n     {\n       if (cum->fregno + ((GET_MODE_SIZE (mode) + 7) >> 3) > FP_ARG_MAX_REG + 1)\n-\tret = FP_ARG_MAX_REG - cum->fregno;\n+\tret = FP_ARG_MAX_REG + 1 - cum->fregno;\n       else if (cum->nargs_prototype >= 0)\n \treturn 0;\n     }\n \n-  if (cum->words < GP_ARG_NUM_REG\n-      && GP_ARG_NUM_REG < cum->words + rs6000_arg_size (mode, type))\n-    ret = GP_ARG_NUM_REG - cum->words;\n+  if (align_words < GP_ARG_NUM_REG\n+      && GP_ARG_NUM_REG < align_words + rs6000_arg_size (mode, type))\n+    ret = GP_ARG_NUM_REG - align_words;\n \n   if (ret != 0 && TARGET_DEBUG_ARG)\n     fprintf (stderr, \"function_arg_partial_nregs: %d\\n\", ret);"}]}