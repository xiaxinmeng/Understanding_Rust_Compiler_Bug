{"sha": "17bf6d250c5f405a75ca3744074cb63386a3376d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdiZjZkMjUwYzVmNDA1YTc1Y2EzNzQ0MDc0Y2I2MzM4NmEzMzc2ZA==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2014-07-04T07:39:23Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2014-07-04T07:39:23Z"}, "message": "Move fp-as-gp optimization to nds32-fp-as-gp.c module.\n\ngcc/\n\t* config/nds32/nds32.c (nds32_have_prologue_p): Move to ...\n\t(nds32_symbol_load_store_p): Move to ...\n\t(nds32_fp_as_gp_check_available): Move to ...\n\t* config/nds32/nds32-fp-as-gp.c: ... here.\n\t* config/nds32/nds32-protos.h (nds32_symbol_load_store_p): Remove\n\textern declaration.\n\nCo-Authored-By: Kito Cheng <kito@0xlab.org>\nCo-Authored-By: Monk Chiang <sh.chiang04@gmail.com>\n\nFrom-SVN: r212288", "tree": {"sha": "73ceb920c41c79b172dfa461860816025910f038", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73ceb920c41c79b172dfa461860816025910f038"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17bf6d250c5f405a75ca3744074cb63386a3376d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17bf6d250c5f405a75ca3744074cb63386a3376d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17bf6d250c5f405a75ca3744074cb63386a3376d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17bf6d250c5f405a75ca3744074cb63386a3376d/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f1fac1bced2e9e3c5862edafb415bd527eb776f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1fac1bced2e9e3c5862edafb415bd527eb776f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1fac1bced2e9e3c5862edafb415bd527eb776f7"}], "stats": {"total": 373, "additions": 210, "deletions": 163}, "files": [{"sha": "3b0f8ef6bcd2be563803e3b70fe2033a4ed6e253", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bf6d250c5f405a75ca3744074cb63386a3376d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bf6d250c5f405a75ca3744074cb63386a3376d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17bf6d250c5f405a75ca3744074cb63386a3376d", "patch": "@@ -1,3 +1,14 @@\n+2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Kito Cheng  <kito@0xlab.org>\n+\t    Monk Chiang  <sh.chiang04@gmail.com>\n+\n+\t* config/nds32/nds32.c (nds32_have_prologue_p): Move to ...\n+\t(nds32_symbol_load_store_p): Move to ...\n+\t(nds32_fp_as_gp_check_available): Move to ...\n+\t* config/nds32/nds32-fp-as-gp.c: ... here.\n+\t* config/nds32/nds32-protos.h (nds32_symbol_load_store_p): Remove\n+\textern declaration.\n+\n 2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n \t    Kito Cheng  <kito@0xlab.org>\n \t    Monk Chiang  <sh.chiang04@gmail.com>"}, {"sha": "d7932678b84b3e5e838bb4827192d9ae7fd8c5ba", "filename": "gcc/config/nds32/nds32-fp-as-gp.c", "status": "modified", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bf6d250c5f405a75ca3744074cb63386a3376d/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bf6d250c5f405a75ca3744074cb63386a3376d/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-fp-as-gp.c?ref=17bf6d250c5f405a75ca3744074cb63386a3376d", "patch": "@@ -17,3 +17,202 @@\n    You should have received a copy of the GNU General Public License\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n+\n+/* ------------------------------------------------------------------------ */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stor-layout.h\"\n+#include \"varasm.h\"\n+#include \"calls.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\t/* Required by recog.h.  */\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\t\t/* For DFA state_t.  */\n+#include \"insn-codes.h\"\t\t/* For CODE_FOR_xxx.  */\n+#include \"reload.h\"\t\t/* For push_reload().  */\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+#include \"diagnostic-core.h\"\n+#include \"df.h\"\n+#include \"tm_p.h\"\n+#include \"tm-constrs.h\"\n+#include \"optabs.h\"\t\t/* For GEN_FCN.  */\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\t\t/* For add_builtin_function().  */\n+#include \"ggc.h\"\n+#include \"builtins.h\"\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* A helper function to check if this function should contain prologue.  */\n+static int\n+nds32_have_prologue_p (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 28; i++)\n+    if (NDS32_REQUIRED_CALLEE_SAVED_P (i))\n+      return 1;\n+\n+  return (flag_pic\n+\t  || NDS32_REQUIRED_CALLEE_SAVED_P (FP_REGNUM)\n+\t  || NDS32_REQUIRED_CALLEE_SAVED_P (LP_REGNUM));\n+}\n+\n+/* Return true if is load/store with SYMBOL_REF addressing mode\n+   and memory mode is SImode.  */\n+static bool\n+nds32_symbol_load_store_p (rtx insn)\n+{\n+  rtx mem_src = NULL_RTX;\n+\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_LOAD:\n+      mem_src = SET_SRC (PATTERN (insn));\n+      break;\n+    case TYPE_STORE:\n+      mem_src = SET_DEST (PATTERN (insn));\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  /* Find load/store insn with addressing mode is SYMBOL_REF.  */\n+  if (mem_src != NULL_RTX)\n+    {\n+      if ((GET_CODE (mem_src) == ZERO_EXTEND)\n+\t  || (GET_CODE (mem_src) == SIGN_EXTEND))\n+\tmem_src = XEXP (mem_src, 0);\n+\n+      if ((GET_CODE (XEXP (mem_src, 0)) == SYMBOL_REF)\n+\t   || (GET_CODE (XEXP (mem_src, 0)) == LO_SUM))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Function to determine whether it is worth to do fp_as_gp optimization.\n+   Return 0: It is NOT worth to do fp_as_gp optimization.\n+   Return 1: It is APPROXIMATELY worth to do fp_as_gp optimization.\n+   Note that if it is worth to do fp_as_gp optimization,\n+   we MUST set FP_REGNUM ever live in this function.  */\n+int\n+nds32_fp_as_gp_check_available (void)\n+{\n+  /* If there exists ANY of following conditions,\n+     we DO NOT perform fp_as_gp optimization:\n+       1. TARGET_FORBID_FP_AS_GP is set\n+          regardless of the TARGET_FORCE_FP_AS_GP.\n+       2. User explicitly uses 'naked' attribute.\n+       3. Not optimize for size.\n+       4. Need frame pointer.\n+       5. If $fp is already required to be saved,\n+          it means $fp is already choosen by register allocator.\n+          Thus we better not to use it for fp_as_gp optimization.\n+       6. This function is a vararg function.\n+          DO NOT apply fp_as_gp optimization on this function\n+          because it may change and break stack frame.\n+       7. The epilogue is empty.\n+          This happens when the function uses exit()\n+          or its attribute is no_return.\n+          In that case, compiler will not expand epilogue\n+          so that we have no chance to output .omit_fp_end directive.  */\n+  if (TARGET_FORBID_FP_AS_GP\n+      || lookup_attribute (\"naked\", DECL_ATTRIBUTES (current_function_decl))\n+      || !optimize_size\n+      || frame_pointer_needed\n+      || NDS32_REQUIRED_CALLEE_SAVED_P (FP_REGNUM)\n+      || (cfun->stdarg == 1)\n+      || (find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) == NULL))\n+    return 0;\n+\n+  /* Now we can check the possibility of using fp_as_gp optimization.  */\n+  if (TARGET_FORCE_FP_AS_GP)\n+    {\n+      /* User explicitly issues -mforce-fp-as-gp option.  */\n+      df_set_regs_ever_live (FP_REGNUM, 1);\n+      return 1;\n+    }\n+  else\n+    {\n+      /* In the following we are going to evaluate whether\n+         it is worth to do fp_as_gp optimization.  */\n+      int good_gain     = 0;\n+      int symbol_count  = 0;\n+\n+      int threshold;\n+      rtx insn;\n+\n+      /* We check if there already requires prologue.\n+         Note that $gp will be saved in prologue for PIC code generation.\n+         After that, we can set threshold by the existence of prologue.\n+         Each fp-implied instruction will gain 2-byte code size\n+         from gp-aware instruction, so we have following heuristics.  */\n+      if (flag_pic\n+\t  || nds32_have_prologue_p ())\n+\t{\n+\t  /* Have-prologue:\n+\t       Compiler already intends to generate prologue content,\n+\t       so the fp_as_gp optimization will only insert\n+\t       'la $fp,_FP_BASE_' instruction, which will be\n+\t       converted into 4-byte instruction at link time.\n+\t       The threshold is \"3\" symbol accesses, 2 + 2 + 2 > 4.  */\n+\t  threshold = 3;\n+\t}\n+      else\n+\t{\n+\t  /* None-prologue:\n+\t       Compiler originally does not generate prologue content,\n+\t       so the fp_as_gp optimization will NOT ONLY insert\n+\t       'la $fp,_FP_BASE' instruction, but also causes\n+\t       push/pop instructions.\n+\t       If we are using v3push (push25/pop25),\n+\t       the threshold is \"5\" symbol accesses, 5*2 > 4 + 2 + 2;\n+\t       If we are using normal push (smw/lmw),\n+\t       the threshold is \"5+2\" symbol accesses 7*2 > 4 + 4 + 4.  */\n+\t  threshold = 5 + (TARGET_V3PUSH ? 0 : 2);\n+\t}\n+\n+      /* We would like to traverse every instruction in this function.\n+         So we need to have push_topmost_sequence()/pop_topmost_sequence()\n+         surrounding our for-loop evaluation.  */\n+      push_topmost_sequence ();\n+      /* Counting the insn number which the addressing mode is symbol.  */\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (single_set (insn) && nds32_symbol_load_store_p (insn))\n+\t    symbol_count++;\n+\n+\t  if (symbol_count == threshold)\n+\t    {\n+\t      good_gain = 1;\n+\t      break;\n+\t    }\n+\t}\n+      pop_topmost_sequence ();\n+\n+      /* Enable fp_as_gp optimization when potential gain is good enough.  */\n+      if (good_gain)\n+\t{\n+\t  df_set_regs_ever_live (FP_REGNUM, 1);\n+\t  return 1;\n+\t}\n+    }\n+\n+  /* By default we return 0.  */\n+  return 0;\n+}\n+\n+/* ------------------------------------------------------------------------ */"}, {"sha": "307361bfc34bcbfecf45ff864f89008d4ecd31da", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bf6d250c5f405a75ca3744074cb63386a3376d/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bf6d250c5f405a75ca3744074cb63386a3376d/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=17bf6d250c5f405a75ca3744074cb63386a3376d", "patch": "@@ -96,7 +96,6 @@ extern int nds32_adjust_insn_length (rtx, int);\n \n /* Auxiliary functions for FP_AS_GP detection.  */\n \n-extern bool nds32_symbol_load_store_p (rtx);\n extern int nds32_fp_as_gp_check_available (void);\n \n /* Auxiliary functions for jump table generation.  */"}, {"sha": "8777e8b4295012ef02a8dba5dd289e2b7ab0a19b", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bf6d250c5f405a75ca3744074cb63386a3376d/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bf6d250c5f405a75ca3744074cb63386a3376d/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=17bf6d250c5f405a75ca3744074cb63386a3376d", "patch": "@@ -1106,21 +1106,6 @@ nds32_legitimate_index_p (enum machine_mode outer_mode,\n     }\n }\n \n-/* A helper function to check if this function should contain prologue.  */\n-static int\n-nds32_have_prologue_p (void)\n-{\n-  int i;\n-\n-  for (i = 0; i < 28; i++)\n-    if (NDS32_REQUIRED_CALLEE_SAVED_P (i))\n-      return 1;\n-\n-  return (flag_pic\n-\t  || NDS32_REQUIRED_CALLEE_SAVED_P (FP_REGNUM)\n-\t  || NDS32_REQUIRED_CALLEE_SAVED_P (LP_REGNUM));\n-}\n-\n /* ------------------------------------------------------------------------ */\n \n /* PART 3: Implement target hook stuff definitions.  */\n@@ -3164,153 +3149,6 @@ nds32_adjust_insn_length (rtx insn, int length)\n }\n \n \n-\n-/* Return true if is load/store with SYMBOL_REF addressing mode\n-   and memory mode is SImode.  */\n-bool\n-nds32_symbol_load_store_p (rtx insn)\n-{\n-  rtx mem_src = NULL_RTX;\n-\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_LOAD:\n-      mem_src = SET_SRC (PATTERN (insn));\n-      break;\n-    case TYPE_STORE:\n-      mem_src = SET_DEST (PATTERN (insn));\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  /* Find load/store insn with addressing mode is SYMBOL_REF.  */\n-  if (mem_src != NULL_RTX)\n-    {\n-      if ((GET_CODE (mem_src) == ZERO_EXTEND)\n-\t  || (GET_CODE (mem_src) == SIGN_EXTEND))\n-\tmem_src = XEXP (mem_src, 0);\n-\n-      if ((GET_CODE (XEXP (mem_src, 0)) == SYMBOL_REF)\n-\t   || (GET_CODE (XEXP (mem_src, 0)) == LO_SUM))\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Function to determine whether it is worth to do fp_as_gp optimization.\n-   Return 0: It is NOT worth to do fp_as_gp optimization.\n-   Return 1: It is APPROXIMATELY worth to do fp_as_gp optimization.\n-   Note that if it is worth to do fp_as_gp optimization,\n-   we MUST set FP_REGNUM ever live in this function.  */\n-int\n-nds32_fp_as_gp_check_available (void)\n-{\n-  /* If there exists ANY of following conditions,\n-     we DO NOT perform fp_as_gp optimization:\n-       1. TARGET_FORBID_FP_AS_GP is set\n-          regardless of the TARGET_FORCE_FP_AS_GP.\n-       2. User explicitly uses 'naked' attribute.\n-       3. Not optimize for size.\n-       4. Need frame pointer.\n-       5. If $fp is already required to be saved,\n-          it means $fp is already choosen by register allocator.\n-          Thus we better not to use it for fp_as_gp optimization.\n-       6. This function is a vararg function.\n-          DO NOT apply fp_as_gp optimization on this function\n-          because it may change and break stack frame.\n-       7. The epilogue is empty.\n-          This happens when the function uses exit()\n-          or its attribute is no_return.\n-          In that case, compiler will not expand epilogue\n-          so that we have no chance to output .omit_fp_end directive.  */\n-  if (TARGET_FORBID_FP_AS_GP\n-      || lookup_attribute (\"naked\", DECL_ATTRIBUTES (current_function_decl))\n-      || !optimize_size\n-      || frame_pointer_needed\n-      || NDS32_REQUIRED_CALLEE_SAVED_P (FP_REGNUM)\n-      || (cfun->stdarg == 1)\n-      || (find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds) == NULL))\n-    return 0;\n-\n-  /* Now we can check the possibility of using fp_as_gp optimization.  */\n-  if (TARGET_FORCE_FP_AS_GP)\n-    {\n-      /* User explicitly issues -mforce-fp-as-gp option.  */\n-      df_set_regs_ever_live (FP_REGNUM, 1);\n-      return 1;\n-    }\n-  else\n-    {\n-      /* In the following we are going to evaluate whether\n-         it is worth to do fp_as_gp optimization.  */\n-      int good_gain     = 0;\n-      int symbol_count  = 0;\n-\n-      int threshold;\n-      rtx insn;\n-\n-      /* We check if there already requires prologue.\n-         Note that $gp will be saved in prologue for PIC code generation.\n-         After that, we can set threshold by the existence of prologue.\n-         Each fp-implied instruction will gain 2-byte code size\n-         from gp-aware instruction, so we have following heuristics.  */\n-      if (flag_pic\n-\t  || nds32_have_prologue_p ())\n-\t{\n-\t  /* Have-prologue:\n-\t       Compiler already intends to generate prologue content,\n-\t       so the fp_as_gp optimization will only insert\n-\t       'la $fp,_FP_BASE_' instruction, which will be\n-\t       converted into 4-byte instruction at link time.\n-\t       The threshold is \"3\" symbol accesses, 2 + 2 + 2 > 4.  */\n-\t  threshold = 3;\n-\t}\n-      else\n-\t{\n-\t  /* None-prologue:\n-\t       Compiler originally does not generate prologue content,\n-\t       so the fp_as_gp optimization will NOT ONLY insert\n-\t       'la $fp,_FP_BASE' instruction, but also causes\n-\t       push/pop instructions.\n-\t       If we are using v3push (push25/pop25),\n-\t       the threshold is \"5\" symbol accesses, 5*2 > 4 + 2 + 2;\n-\t       If we are using normal push (smw/lmw),\n-\t       the threshold is \"5+2\" symbol accesses 7*2 > 4 + 4 + 4.  */\n-\t  threshold = 5 + (TARGET_V3PUSH ? 0 : 2);\n-\t}\n-\n-      /* We would like to traverse every instruction in this function.\n-         So we need to have push_topmost_sequence()/pop_topmost_sequence()\n-         surrounding our for-loop evaluation.  */\n-      push_topmost_sequence ();\n-      /* Counting the insn number which the addressing mode is symbol.  */\n-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (single_set (insn) && nds32_symbol_load_store_p (insn))\n-\t    symbol_count++;\n-\n-\t  if (symbol_count == threshold)\n-\t    {\n-\t      good_gain = 1;\n-\t      break;\n-\t    }\n-\t}\n-      pop_topmost_sequence ();\n-\n-      /* Enable fp_as_gp optimization when potential gain is good enough.  */\n-      if (good_gain)\n-\t{\n-\t  df_set_regs_ever_live (FP_REGNUM, 1);\n-\t  return 1;\n-\t}\n-    }\n-\n-  /* By default we return 0.  */\n-  return 0;\n-}\n-\n /* Return align 2 (log base 2) if the next instruction of LABEL is 4 byte.  */\n int\n nds32_target_alignment (rtx label)"}]}