{"sha": "7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "node_id": "C_kwDOANBUbNoAKDdmZDZlMzZlYTlhYTg1NzU4NDFmZjFkYTA4YjRhZWJjMDI5OGFiZTI", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-16T14:54:44Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-16T18:01:19Z"}, "message": "analyzer: early rejection of disabled warnings [PR104955]\n\nAvoid generating execution paths for warnings that are ultimately\nrejected due to -Wno-analyzer-* flags.\n\nThis improves the test case from taking at least several minutes\n(before I killed it) to taking under a second.\n\nThis doesn't fix the slowdown seen in PR analyzer/104955 with large\nnumbers of warnings when the warnings are still enabled.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/104955\n\t* diagnostic-manager.cc (get_emission_location): New.\n\t(diagnostic_manager::diagnostic_manager): Initialize\n\tm_num_disabled_diagnostics.\n\t(diagnostic_manager::add_diagnostic): Reject diagnostics that\n\twill eventually be rejected due to being disabled.\n\t(diagnostic_manager::emit_saved_diagnostics): Log the number\n\tof disabled diagnostics.\n\t(diagnostic_manager::emit_saved_diagnostic): Split out logic for\n\tdetermining emission location to get_emission_location.\n\t* diagnostic-manager.h\n\t(diagnostic_manager::m_num_disabled_diagnostics): New field.\n\t* engine.cc (stale_jmp_buf::get_controlling_option): New.\n\t(stale_jmp_buf::emit): Use it.\n\t* pending-diagnostic.h\n\t(pending_diagnostic::get_controlling_option): New vfunc.\n\t* region-model.cc\n\t(poisoned_value_diagnostic::get_controlling_option): New.\n\t(poisoned_value_diagnostic::emit): Use it.\n\t(shift_count_negative_diagnostic::get_controlling_option): New.\n\t(shift_count_negative_diagnostic::emit): Use it.\n\t(shift_count_overflow_diagnostic::get_controlling_option): New.\n\t(shift_count_overflow_diagnostic::emit): Use it.\n\t(dump_path_diagnostic::get_controlling_option): New.\n\t(dump_path_diagnostic::emit): Use it.\n\t(write_to_const_diagnostic::get_controlling_option): New.\n\t(write_to_const_diagnostic::emit): Use it.\n\t(write_to_string_literal_diagnostic::get_controlling_option): New.\n\t(write_to_string_literal_diagnostic::emit): Use it.\n\t* sm-file.cc (double_fclose::get_controlling_option): New.\n\t(double_fclose::emit): Use it.\n\t(file_leak::get_controlling_option): New.\n\t(file_leak::emit): Use it.\n\t* sm-malloc.cc (mismatching_deallocation::get_controlling_option):\n\tNew.\n\t(mismatching_deallocation::emit): Use it.\n\t(double_free::get_controlling_option): New.\n\t(double_free::emit): Use it.\n\t(possible_null_deref::get_controlling_option): New.\n\t(possible_null_deref::emit): Use it.\n\t(possible_null_arg::get_controlling_option): New.\n\t(possible_null_arg::emit): Use it.\n\t(null_deref::get_controlling_option): New.\n\t(null_deref::emit): Use it.\n\t(null_arg::get_controlling_option): New.\n\t(null_arg::emit): Use it.\n\t(use_after_free::get_controlling_option): New.\n\t(use_after_free::emit): Use it.\n\t(malloc_leak::get_controlling_option): New.\n\t(malloc_leak::emit): Use it.\n\t(free_of_non_heap::get_controlling_option): New.\n\t(free_of_non_heap::emit): Use it.\n\t* sm-pattern-test.cc (pattern_match::get_controlling_option): New.\n\t(pattern_match::emit): Use it.\n\t* sm-sensitive.cc\n\t(exposure_through_output_file::get_controlling_option): New.\n\t(exposure_through_output_file::emit): Use it.\n\t* sm-signal.cc (signal_unsafe_call::get_controlling_option): New.\n\t(signal_unsafe_call::emit): Use it.\n\t* sm-taint.cc (tainted_array_index::get_controlling_option): New.\n\t(tainted_array_index::emit): Use it.\n\t(tainted_offset::get_controlling_option): New.\n\t(tainted_offset::emit): Use it.\n\t(tainted_size::get_controlling_option): New.\n\t(tainted_size::emit): Use it.\n\t(tainted_divisor::get_controlling_option): New.\n\t(tainted_divisor::emit): Use it.\n\t(tainted_allocation_size::get_controlling_option): New.\n\t(tainted_allocation_size::emit): Use it.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/many-disabled-diagnostics.c: New test.\n\t* gcc.dg/plugin/analyzer_gil_plugin.c\n\t(gil_diagnostic::get_controlling_option): New.\n\t(double_save_thread::emit): Use it.\n\t(fncall_without_gil::emit): Likewise.\n\t(pyobject_usage_without_gil::emit): Likewise.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "311949c4814ad5d9639fc8c5158e683bf817b3e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/311949c4814ad5d9639fc8c5158e683bf817b3e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a4e208022e7047af3a15a3dedb715ad801db160", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a4e208022e7047af3a15a3dedb715ad801db160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a4e208022e7047af3a15a3dedb715ad801db160"}], "stats": {"total": 373, "additions": 300, "deletions": 73}, "files": [{"sha": "d5e5b6926cc1c0b0f66566354ed657c5f7546c43", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -849,13 +849,28 @@ class path_builder\n   const feasibility_problem *m_feasibility_problem;\n };\n \n+/* Determine the emission location for PD at STMT in FUN.  */\n+\n+static location_t\n+get_emission_location (const gimple *stmt, function *fun,\n+\t\t       const pending_diagnostic &pd)\n+{\n+  location_t loc = get_stmt_location (stmt, fun);\n+\n+  /* Allow the pending_diagnostic to fix up the location.  */\n+  loc = pd.fixup_location (loc);\n+\n+  return loc;\n+}\n+\n /* class diagnostic_manager.  */\n \n /* diagnostic_manager's ctor.  */\n \n diagnostic_manager::diagnostic_manager (logger *logger, engine *eng,\n \t\t\t\t\tint verbosity)\n-: log_user (logger), m_eng (eng), m_verbosity (verbosity)\n+: log_user (logger), m_eng (eng), m_verbosity (verbosity),\n+  m_num_disabled_diagnostics (0)\n {\n }\n \n@@ -877,6 +892,25 @@ diagnostic_manager::add_diagnostic (const state_machine *sm,\n      through the exploded_graph to the diagnostic.  */\n   gcc_assert (enode);\n \n+  /* If this warning is ultimately going to be rejected by a -Wno-analyzer-*\n+     flag, reject it now.\n+     We can only do this for diagnostics where we already know the stmt,\n+     and thus can determine the emission location.  */\n+  if (stmt)\n+    {\n+      location_t loc = get_emission_location (stmt, snode->m_fun, *d);\n+      int option = d->get_controlling_option ();\n+      if (!warning_enabled_at (loc, option))\n+\t{\n+\t  if (get_logger ())\n+\t    get_logger ()->log (\"rejecting disabled warning %qs\",\n+\t\t\t\td->get_kind ());\n+\t  delete d;\n+\t  m_num_disabled_diagnostics++;\n+\t  return;\n+\t}\n+    }\n+\n   saved_diagnostic *sd\n     = new saved_diagnostic (sm, enode, snode, stmt, finder, var, sval,\n \t\t\t    state, d, m_saved_diagnostics.length ());\n@@ -1186,6 +1220,7 @@ diagnostic_manager::emit_saved_diagnostics (const exploded_graph &eg)\n   LOG_SCOPE (get_logger ());\n   auto_timevar tv (TV_ANALYZER_DIAGNOSTICS);\n   log (\"# saved diagnostics: %i\", m_saved_diagnostics.length ());\n+  log (\"# disabled diagnostics: %i\", m_num_disabled_diagnostics);\n   if (get_logger ())\n     {\n       unsigned i;\n@@ -1265,11 +1300,10 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n \n   emission_path.prepare_for_emission (sd.m_d);\n \n-  location_t loc = get_stmt_location (sd.m_stmt, sd.m_snode->m_fun);\n+  location_t loc\n+    = get_emission_location (sd.m_stmt, sd.m_snode->m_fun, *sd.m_d);\n \n-  /* Allow the pending_diagnostic to fix up the primary location\n-     and any locations for events.  */\n-  loc = sd.m_d->fixup_location (loc);\n+  /* Allow the pending_diagnostic to fix up the locations of events.  */\n   emission_path.fixup_locations (sd.m_d);\n \n   gcc_rich_location rich_loc (loc);"}, {"sha": "34abf56d11faf87f3b487b7aca5d1c53bb0fdc9d", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -179,6 +179,7 @@ class diagnostic_manager : public log_user\n   engine *m_eng;\n   auto_delete_vec<saved_diagnostic> m_saved_diagnostics;\n   const int m_verbosity;\n+  int m_num_disabled_diagnostics;\n };\n \n } // namespace ana"}, {"sha": "3c5d3986352bec8a444e8edbb04e869aff5e7e11", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -1526,10 +1526,15 @@ class stale_jmp_buf : public pending_diagnostic_subclass<stale_jmp_buf>\n     m_setjmp_point (setjmp_point), m_stack_pop_event (NULL)\n   {}\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_stale_setjmp_buffer;\n+  }\n+\n   bool emit (rich_location *richloc) FINAL OVERRIDE\n   {\n     return warning_at\n-      (richloc, OPT_Wanalyzer_stale_setjmp_buffer,\n+      (richloc, get_controlling_option (),\n        \"%qs called after enclosing function of %qs has returned\",\n        get_user_facing_name (m_longjmp_call),\n        get_user_facing_name (m_setjmp_call));"}, {"sha": "51039ea1ba562b4dff5cb5a2afe511e9cd090588", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -162,6 +162,12 @@ class pending_diagnostic\n  public:\n   virtual ~pending_diagnostic () {}\n \n+  /* Vfunc to get the command-line option used when emitting the diagnostic,\n+     or zero if there is none.\n+     Used by diagnostic_manager for early rejection of diagnostics (to avoid\n+     having to generate feasible execution paths for them).  */\n+  virtual int get_controlling_option () const = 0;\n+\n   /* Vfunc for emitting the diagnostic.  The rich_location will have been\n      populated with a diagnostic_path.\n      Return true if a diagnostic is actually emitted.  */"}, {"sha": "1bc71c02849efb986878ad52de490875d5497e5a", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -479,6 +479,21 @@ class poisoned_value_diagnostic\n \t    && m_src_region == other.m_src_region);\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    switch (m_pkind)\n+      {\n+      default:\n+\tgcc_unreachable ();\n+      case POISON_KIND_UNINIT:\n+\treturn OPT_Wanalyzer_use_of_uninitialized_value;\n+      case POISON_KIND_FREED:\n+\treturn OPT_Wanalyzer_use_after_free;\n+      case POISON_KIND_POPPED_STACK:\n+\treturn OPT_Wanalyzer_use_of_pointer_in_stale_stack_frame;\n+      }\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     switch (m_pkind)\n@@ -489,8 +504,7 @@ class poisoned_value_diagnostic\n \t{\n \t  diagnostic_metadata m;\n \t  m.add_cwe (457); /* \"CWE-457: Use of Uninitialized Variable\".  */\n-\t  return warning_meta (rich_loc, m,\n-\t\t\t       OPT_Wanalyzer_use_of_uninitialized_value,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of uninitialized value %qE\",\n \t\t\t       m_expr);\n \t}\n@@ -499,8 +513,7 @@ class poisoned_value_diagnostic\n \t{\n \t  diagnostic_metadata m;\n \t  m.add_cwe (416); /* \"CWE-416: Use After Free\".  */\n-\t  return warning_meta (rich_loc, m,\n-\t\t\t       OPT_Wanalyzer_use_after_free,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use after %<free%> of %qE\",\n \t\t\t       m_expr);\n \t}\n@@ -509,8 +522,7 @@ class poisoned_value_diagnostic\n \t{\n \t  /* TODO: which CWE?  */\n \t  return warning_at\n-\t    (rich_loc,\n-\t     OPT_Wanalyzer_use_of_pointer_in_stale_stack_frame,\n+\t    (rich_loc, get_controlling_option (),\n \t     \"dereferencing pointer %qE to within stale stack frame\",\n \t     m_expr);\n \t}\n@@ -571,9 +583,14 @@ class shift_count_negative_diagnostic\n \t    && same_tree_p (m_count_cst, other.m_count_cst));\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_shift_count_negative;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n-    return warning_at (rich_loc, OPT_Wanalyzer_shift_count_negative,\n+    return warning_at (rich_loc, get_controlling_option (),\n \t\t       \"shift by negative count (%qE)\", m_count_cst);\n   }\n \n@@ -613,9 +630,14 @@ class shift_count_overflow_diagnostic\n \t    && same_tree_p (m_count_cst, other.m_count_cst));\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_shift_count_overflow;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n-    return warning_at (rich_loc, OPT_Wanalyzer_shift_count_overflow,\n+    return warning_at (rich_loc, get_controlling_option (),\n \t\t       \"shift by count (%qE) >= precision of type (%qi)\",\n \t\t       m_count_cst, m_operand_precision);\n   }\n@@ -1095,6 +1117,11 @@ class dump_path_diagnostic\n   : public pending_diagnostic_subclass<dump_path_diagnostic>\n {\n public:\n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return 0;\n+  }\n+\n   bool emit (rich_location *richloc) FINAL OVERRIDE\n   {\n     inform (richloc, \"path\");\n@@ -2534,22 +2561,27 @@ class write_to_const_diagnostic\n \t    && m_decl == other.m_decl);\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_write_to_const;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     auto_diagnostic_group d;\n     bool warned;\n     switch (m_reg->get_kind ())\n       {\n       default:\n-\twarned = warning_at (rich_loc, OPT_Wanalyzer_write_to_const,\n+\twarned = warning_at (rich_loc, get_controlling_option (),\n \t\t\t     \"write to %<const%> object %qE\", m_decl);\n \tbreak;\n       case RK_FUNCTION:\n-\twarned = warning_at (rich_loc, OPT_Wanalyzer_write_to_const,\n+\twarned = warning_at (rich_loc, get_controlling_option (),\n \t\t\t     \"write to function %qE\", m_decl);\n \tbreak;\n       case RK_LABEL:\n-\twarned = warning_at (rich_loc, OPT_Wanalyzer_write_to_const,\n+\twarned = warning_at (rich_loc, get_controlling_option (),\n \t\t\t     \"write to label %qE\", m_decl);\n \tbreak;\n       }\n@@ -2597,9 +2629,14 @@ class write_to_string_literal_diagnostic\n     return m_reg == other.m_reg;\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_write_to_string_literal;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n-    return warning_at (rich_loc, OPT_Wanalyzer_write_to_string_literal,\n+    return warning_at (rich_loc, get_controlling_option (),\n \t\t       \"write to string literal\");\n     /* Ideally we would show the location of the STRING_CST as well,\n        but it is not available at this point.  */"}, {"sha": "ffc2809dc57c217ae4c36200b1a1ea7a05785915", "filename": "gcc/analyzer/sm-file.cc", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-file.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-file.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-file.cc?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -157,9 +157,14 @@ class double_fclose : public file_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"double_fclose\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_double_fclose;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n-    return warning_at (rich_loc, OPT_Wanalyzer_double_fclose,\n+    return warning_at (rich_loc, get_controlling_option (),\n \t\t       \"double %<fclose%> of FILE %qE\",\n \t\t       m_arg);\n   }\n@@ -197,18 +202,23 @@ class file_leak : public file_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"file_leak\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_file_leak;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     diagnostic_metadata m;\n     /* CWE-775: \"Missing Release of File Descriptor or Handle after\n        Effective Lifetime\". */\n     m.add_cwe (775);\n     if (m_arg)\n-      return warning_meta (rich_loc, m, OPT_Wanalyzer_file_leak,\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t   \"leak of FILE %qE\",\n \t\t\t   m_arg);\n     else\n-      return warning_meta (rich_loc, m, OPT_Wanalyzer_file_leak,\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t   \"leak of FILE\");\n   }\n "}, {"sha": "4c030803e59819ad0fc01bb123dd2a98e7c06d6c", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -760,20 +760,25 @@ class mismatching_deallocation : public malloc_diagnostic\n     return \"mismatching_deallocation\";\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_mismatching_deallocation;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     auto_diagnostic_group d;\n     diagnostic_metadata m;\n     m.add_cwe (762); /* CWE-762: Mismatched Memory Management Routines.  */\n     if (const deallocator *expected_dealloc\n \t  = m_expected_deallocators->maybe_get_single ())\n-      return warning_meta (rich_loc, m, OPT_Wanalyzer_mismatching_deallocation,\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t   \"%qE should have been deallocated with %qs\"\n \t\t\t   \" but was deallocated with %qs\",\n \t\t\t   m_arg, expected_dealloc->m_name,\n \t\t\t   m_actual_dealloc->m_name);\n     else\n-      return warning_meta (rich_loc, m, OPT_Wanalyzer_mismatching_deallocation,\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t   \"%qs called on %qE returned from a mismatched\"\n \t\t\t   \" allocation function\",\n \t\t\t   m_actual_dealloc->m_name, m_arg);\n@@ -834,12 +839,17 @@ class double_free : public malloc_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"double_free\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_double_free;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     auto_diagnostic_group d;\n     diagnostic_metadata m;\n     m.add_cwe (415); /* CWE-415: Double Free.  */\n-    return warning_meta (rich_loc, m, OPT_Wanalyzer_double_free,\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t \"double-%qs of %qE\", m_funcname, m_arg);\n   }\n \n@@ -925,13 +935,17 @@ class possible_null_deref : public possible_null\n \n   const char *get_kind () const FINAL OVERRIDE { return \"possible_null_deref\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_possible_null_dereference;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     /* CWE-690: Unchecked Return Value to NULL Pointer Dereference.  */\n     diagnostic_metadata m;\n     m.add_cwe (690);\n-    return warning_meta (rich_loc, m,\n-\t\t\t OPT_Wanalyzer_possible_null_dereference,\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t \"dereference of possibly-NULL %qE\", m_arg);\n   }\n \n@@ -1010,6 +1024,10 @@ class possible_null_arg : public possible_null\n \t    && m_arg_idx == sub_other.m_arg_idx);\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_possible_null_argument;\n+  }\n \n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n@@ -1018,7 +1036,7 @@ class possible_null_arg : public possible_null\n     diagnostic_metadata m;\n     m.add_cwe (690);\n     bool warned\n-      = warning_meta (rich_loc, m, OPT_Wanalyzer_possible_null_argument,\n+      = warning_meta (rich_loc, m, get_controlling_option (),\n \t\t      \"use of possibly-NULL %qE where non-null expected\",\n \t\t      m_arg);\n     if (warned)\n@@ -1058,13 +1076,17 @@ class null_deref : public malloc_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"null_deref\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_null_dereference;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     /* CWE-476: NULL Pointer Dereference.  */\n     diagnostic_metadata m;\n     m.add_cwe (476);\n-    return warning_meta (rich_loc, m,\n-\t\t\t OPT_Wanalyzer_null_dereference,\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t \"dereference of NULL %qE\", m_arg);\n   }\n \n@@ -1106,6 +1128,11 @@ class null_arg : public malloc_diagnostic\n \t    && m_arg_idx == sub_other.m_arg_idx);\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_null_argument;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     /* CWE-476: NULL Pointer Dereference.  */\n@@ -1115,10 +1142,10 @@ class null_arg : public malloc_diagnostic\n \n     bool warned;\n     if (zerop (m_arg))\n-      warned = warning_meta (rich_loc, m, OPT_Wanalyzer_null_argument,\n+      warned = warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"use of NULL where non-null expected\");\n     else\n-      warned = warning_meta (rich_loc, m, OPT_Wanalyzer_null_argument,\n+      warned = warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"use of NULL %qE where non-null expected\",\n \t\t\t     m_arg);\n     if (warned)\n@@ -1159,12 +1186,17 @@ class use_after_free : public malloc_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"use_after_free\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_use_after_free;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     /* CWE-416: Use After Free.  */\n     diagnostic_metadata m;\n     m.add_cwe (416);\n-    return warning_meta (rich_loc, m, OPT_Wanalyzer_use_after_free,\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t \"use after %<%s%> of %qE\",\n \t\t\t m_deallocator->m_name, m_arg);\n   }\n@@ -1248,15 +1280,20 @@ class malloc_leak : public malloc_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"malloc_leak\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_malloc_leak;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     diagnostic_metadata m;\n     m.add_cwe (401);\n     if (m_arg)\n-      return warning_meta (rich_loc, m, OPT_Wanalyzer_malloc_leak,\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t   \"leak of %qE\", m_arg);\n     else\n-      return warning_meta (rich_loc, m, OPT_Wanalyzer_malloc_leak,\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t   \"leak of %qs\", \"<unknown>\");\n   }\n \n@@ -1316,6 +1353,11 @@ class free_of_non_heap : public malloc_diagnostic\n \t    && m_freed_reg == other.m_freed_reg);\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_free_of_non_heap;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     auto_diagnostic_group d;\n@@ -1330,13 +1372,13 @@ class free_of_non_heap : public malloc_diagnostic\n       case MEMSPACE_CODE:\n       case MEMSPACE_GLOBALS:\n       case MEMSPACE_READONLY_DATA:\n-\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_free_of_non_heap,\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"%<%s%> of %qE which points to memory\"\n \t\t\t     \" not on the heap\",\n \t\t\t     m_funcname, m_arg);\n \tbreak;\n       case MEMSPACE_STACK:\n-\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_free_of_non_heap,\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"%<%s%> of %qE which points to memory\"\n \t\t\t     \" on the stack\",\n \t\t\t     m_funcname, m_arg);"}, {"sha": "68b976aeb45e2cba752b112809c8f40b11bab758", "filename": "gcc/analyzer/sm-pattern-test.cc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-pattern-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-pattern-test.cc?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -89,9 +89,15 @@ class pattern_match : public pending_diagnostic_subclass<pattern_match>\n \t    && same_tree_p (m_rhs, other.m_rhs));\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return 0;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n-    return warning_at (rich_loc, 0, \"pattern match on %<%E %s %E%>\",\n+    return warning_at (rich_loc, get_controlling_option (),\n+\t\t       \"pattern match on %<%E %s %E%>\",\n \t\t       m_lhs, op_symbol_code (m_op), m_rhs);\n   }\n "}, {"sha": "f40f3e8eb2ff74e6a5613c60b469c40aea2b5ab8", "filename": "gcc/analyzer/sm-sensitive.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-sensitive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-sensitive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-sensitive.cc?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -91,13 +91,17 @@ class exposure_through_output_file\n     return same_tree_p (m_arg, other.m_arg);\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_exposure_through_output_file;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     diagnostic_metadata m;\n     /* CWE-532: Information Exposure Through Log Files */\n     m.add_cwe (532);\n-    return warning_meta (rich_loc, m,\n-\t\t\t OPT_Wanalyzer_exposure_through_output_file,\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t \"sensitive value %qE written to output file\",\n \t\t\t m_arg);\n   }"}, {"sha": "77044e10805d08b62e6760e9167410882b246577", "filename": "gcc/analyzer/sm-signal.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-signal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-signal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-signal.cc?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -113,14 +113,18 @@ class signal_unsafe_call\n     return m_unsafe_call == other.m_unsafe_call;\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_unsafe_call_within_signal_handler;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     auto_diagnostic_group d;\n     diagnostic_metadata m;\n     /* CWE-479: Signal Handler Use of a Non-reentrant Function.  */\n     m.add_cwe (479);\n-    if (warning_meta (rich_loc, m,\n-\t\t      OPT_Wanalyzer_unsafe_call_within_signal_handler,\n+    if (warning_meta (rich_loc, m, get_controlling_option (),\n \t\t      \"call to %qD from within signal handler\",\n \t\t      m_unsafe_fndecl))\n       {"}, {"sha": "e2c78cdd42b225d9f7c1ae7b289f6d0a2b39e674", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 45, "deletions": 26, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -180,6 +180,11 @@ class tainted_array_index : public taint_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"tainted_array_index\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_tainted_array_index;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     diagnostic_metadata m;\n@@ -190,19 +195,19 @@ class tainted_array_index : public taint_diagnostic\n       default:\n \tgcc_unreachable ();\n       case BOUNDS_NONE:\n-\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_array_index,\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"use of attacker-controlled value %qE\"\n \t\t\t     \" in array lookup without bounds checking\",\n \t\t\t     m_arg);\n \tbreak;\n       case BOUNDS_UPPER:\n-\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_array_index,\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"use of attacker-controlled value %qE\"\n \t\t\t     \" in array lookup without checking for negative\",\n \t\t\t     m_arg);\n \tbreak;\n       case BOUNDS_LOWER:\n-\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_array_index,\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"use of attacker-controlled value %qE\"\n \t\t\t     \" in array lookup without upper-bounds checking\",\n \t\t\t     m_arg);\n@@ -248,6 +253,11 @@ class tainted_offset : public taint_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"tainted_offset\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_tainted_offset;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     diagnostic_metadata m;\n@@ -259,19 +269,19 @@ class tainted_offset : public taint_diagnostic\n \tdefault:\n \t  gcc_unreachable ();\n \tcase BOUNDS_NONE:\n-\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value %qE as offset\"\n \t\t\t       \" without bounds checking\",\n \t\t\t       m_arg);\n \t  break;\n \tcase BOUNDS_UPPER:\n-\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value %qE as offset\"\n \t\t\t       \" without lower-bounds checking\",\n \t\t\t       m_arg);\n \t  break;\n \tcase BOUNDS_LOWER:\n-\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value %qE as offset\"\n \t\t\t       \" without upper-bounds checking\",\n \t\t\t       m_arg);\n@@ -283,17 +293,17 @@ class tainted_offset : public taint_diagnostic\n \tdefault:\n \t  gcc_unreachable ();\n \tcase BOUNDS_NONE:\n-\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value as offset\"\n \t\t\t       \" without bounds checking\");\n \t  break;\n \tcase BOUNDS_UPPER:\n-\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value as offset\"\n \t\t\t       \" without lower-bounds checking\");\n \t  break;\n \tcase BOUNDS_LOWER:\n-\t  return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_offset,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value as offset\"\n \t\t\t       \" without upper-bounds checking\");\n \t  break;\n@@ -353,6 +363,11 @@ class tainted_size : public taint_diagnostic\n \n   const char *get_kind () const OVERRIDE { return \"tainted_size\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_tainted_size;\n+  }\n+\n   bool emit (rich_location *rich_loc) OVERRIDE\n   {\n     diagnostic_metadata m;\n@@ -362,19 +377,19 @@ class tainted_size : public taint_diagnostic\n       default:\n \tgcc_unreachable ();\n       case BOUNDS_NONE:\n-\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_size,\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"use of attacker-controlled value %qE as size\"\n \t\t\t     \" without bounds checking\",\n \t\t\t     m_arg);\n \tbreak;\n       case BOUNDS_UPPER:\n-\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_size,\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"use of attacker-controlled value %qE as size\"\n \t\t\t     \" without lower-bounds checking\",\n \t\t\t     m_arg);\n \tbreak;\n       case BOUNDS_LOWER:\n-\treturn warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_size,\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t     \"use of attacker-controlled value %qE as size\"\n \t\t\t     \" without upper-bounds checking\",\n \t\t\t     m_arg);\n@@ -455,18 +470,23 @@ class tainted_divisor : public taint_diagnostic\n \n   const char *get_kind () const FINAL OVERRIDE { return \"tainted_divisor\"; }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_tainted_divisor;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     diagnostic_metadata m;\n     /* CWE-369: \"Divide By Zero\".  */\n     m.add_cwe (369);\n     if (m_arg)\n-      return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_divisor,\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t   \"use of attacker-controlled value %qE as divisor\"\n \t\t\t   \" without checking for zero\",\n \t\t\t   m_arg);\n     else\n-      return warning_meta (rich_loc, m, OPT_Wanalyzer_tainted_divisor,\n+      return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t   \"use of attacker-controlled value as divisor\"\n \t\t\t   \" without checking for zero\");\n   }\n@@ -503,6 +523,11 @@ class tainted_allocation_size : public taint_diagnostic\n     return \"tainted_allocation_size\";\n   }\n \n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return OPT_Wanalyzer_tainted_allocation_size;\n+  }\n+\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     diagnostic_metadata m;\n@@ -515,22 +540,19 @@ class tainted_allocation_size : public taint_diagnostic\n \tdefault:\n \t  gcc_unreachable ();\n \tcase BOUNDS_NONE:\n-\t  return warning_meta (rich_loc, m,\n-\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value %qE as\"\n \t\t\t       \" allocation size without bounds checking\",\n \t\t\t       m_arg);\n \t  break;\n \tcase BOUNDS_UPPER:\n-\t  return warning_meta (rich_loc, m,\n-\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value %qE as\"\n \t\t\t       \" allocation size without lower-bounds checking\",\n \t\t\t       m_arg);\n \t  break;\n \tcase BOUNDS_LOWER:\n-\t  return warning_meta (rich_loc, m,\n-\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value %qE as\"\n \t\t\t       \" allocation size without upper-bounds checking\",\n \t\t\t     m_arg);\n@@ -542,22 +564,19 @@ class tainted_allocation_size : public taint_diagnostic\n \tdefault:\n \t  gcc_unreachable ();\n \tcase BOUNDS_NONE:\n-\t  return warning_meta (rich_loc, m,\n-\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value as\"\n \t\t\t       \" allocation size without bounds\"\n \t\t\t       \" checking\");\n \t  break;\n \tcase BOUNDS_UPPER:\n-\t  return warning_meta (rich_loc, m,\n-\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value as\"\n \t\t\t       \" allocation size without lower-bounds\"\n \t\t\t       \" checking\");\n \t  break;\n \tcase BOUNDS_LOWER:\n-\t  return warning_meta (rich_loc, m,\n-\t\t\t       OPT_Wanalyzer_tainted_allocation_size,\n+\t  return warning_meta (rich_loc, m, get_controlling_option (),\n \t\t\t       \"use of attacker-controlled value as\"\n \t\t\t       \" allocation size without upper-bounds\"\n \t\t\t       \" checking\");"}, {"sha": "48d4023946a027f1d986081de2b748c683b49f1e", "filename": "gcc/testsuite/gcc.dg/analyzer/many-disabled-diagnostics.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmany-disabled-diagnostics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmany-disabled-diagnostics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmany-disabled-diagnostics.c?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-additional-options \"-Wno-analyzer-double-free\" } */\n+\n+#define DOUBLE_FREE()\t\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    void *p = __builtin_malloc (1024);\t\t\\\n+    __builtin_free (p);\t\t\t\t\\\n+    __builtin_free (p);\t\t\t\t\\\n+  } while (0)\n+\n+#define DOUBLE_FREE_x_10()\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+    DOUBLE_FREE();\t\t\t\t\\\n+  } while (0)\n+\n+#define DOUBLE_FREE_x_100()\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+    DOUBLE_FREE_x_10();\t\t\t\t\\\n+  } while (0)\n+\n+#define DOUBLE_FREE_x_1000()\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+    DOUBLE_FREE_x_100();\t\t\t\\\n+  } while (0)\n+\n+void test_1 (void)\n+{\n+  DOUBLE_FREE_x_1000 (); \n+}"}, {"sha": "12d1c8d0ba2a723606c4787fd8b333866a1e6c13", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_gil_plugin.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c?ref=7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "patch": "@@ -81,6 +81,12 @@ class gil_state_machine : public state_machine\n class gil_diagnostic : public pending_diagnostic\n {\n public:\n+  /* There isn't a warning ID for us to use.  */\n+  int get_controlling_option () const FINAL OVERRIDE\n+  {\n+    return 0;\n+  }\n+\n   location_t fixup_location (location_t loc) const FINAL OVERRIDE\n   {\n     /* Ideally we'd check for specific macros here, and only\n@@ -133,7 +139,7 @@ class double_save_thread : public gil_diagnostic\n \n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n-    return warning_at (rich_loc, 0,\n+    return warning_at (rich_loc, get_controlling_option (),\n \t\t       \"nested usage of %qs\", \"Py_BEGIN_ALLOW_THREADS\");\n   }\n \n@@ -173,14 +179,13 @@ class fncall_without_gil : public gil_diagnostic\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     auto_diagnostic_group d;\n-    /* There isn't a warning ID for use to use.  */\n     if (m_callee_fndecl)\n-      return warning_at (rich_loc, 0,\n+      return warning_at (rich_loc, get_controlling_option (),\n \t\t\t \"use of PyObject as argument %i of %qE\"\n \t\t\t \" without the GIL\",\n \t\t\t m_arg_idx + 1, m_callee_fndecl);\n     else\n-      return warning_at (rich_loc, 0,\n+      return warning_at (rich_loc, get_controlling_option (),\n \t\t\t \"use of PyObject as argument %i of call\"\n \t\t\t \" without the GIL\",\n \t\t\t m_arg_idx + 1, m_callee_fndecl);\n@@ -225,8 +230,7 @@ class pyobject_usage_without_gil : public gil_diagnostic\n   bool emit (rich_location *rich_loc) FINAL OVERRIDE\n   {\n     auto_diagnostic_group d;\n-    /* There isn't a warning ID for use to use.  */\n-    return warning_at (rich_loc, 0,\n+    return warning_at (rich_loc, get_controlling_option (),\n \t\t       \"use of PyObject %qE without the GIL\", m_expr);\n   }\n "}]}