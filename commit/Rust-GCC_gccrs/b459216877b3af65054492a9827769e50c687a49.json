{"sha": "b459216877b3af65054492a9827769e50c687a49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ1OTIxNjg3N2IzYWY2NTA1NDQ5MmE5ODI3NzY5ZTUwYzY4N2E0OQ==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2008-04-08T06:49:47Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:49:47Z"}, "message": "sem_cat.adb (Validate_RCI_Subprogram_Declaration): Add tests of Has_Stream_Attribute_ Definition when...\n\n2008-04-08  Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* sem_cat.adb (Validate_RCI_Subprogram_Declaration): Add tests of\n\tHas_Stream_Attribute_ Definition when checking for available stream\n\tattributes on parameters of a limited type in Ada 2005. Necessary for\n\tproper recognition of visible stream attribute clauses.\n\t(Has_Stream_Attribute_Definition): If the type is derived from a\n\tprivate type, then use the derived type's underlying type for checking\n\twhether it has stream attributes.\n\t(Validate_Object_Declaration): The check for a user-defined Initialize\n\tprocedure applies also to types with controlled components or a\n\tcontrolled ancestor.\n\tReject an object declaration in a preelaborated unit if the type is a\n\tcontrolled type with an overriding Initialize procedure.\n\t(Validate_Remote_Access_To_Class_Wide_Type): Return without further\n\tchecking when the parent of a dereference is a selected component and\n\tthe name has not been analyzed.\n\n\t* sem_ch4.adb (Analyze_Selected_Component): Add checking for selected\n\tprefixes that are invalid explicit dereferences of remote\n\taccess-to-class-wide values, first checking whether the selected\n\tcomponent is a prefixed form of call to a tagged operation.\n\t(Analyze_Call): Remove code that issues an error for limited function\n\tcalls in illegal contexts, as we now support all of the contexts that\n\twere forbidden here.\n\tAllow a function call that returns a task.and appears as the\n\tprefix of a selected component.\n\t(Analyze_Reference): Give error message if we try to make a 'Reference\n\tfor an object that is atomic/aliased without its type having the\n\tcorresponding attribute.\n\t(Analyze_Call): Remove condition checking for attributes to allow\n\tcalls to functions with inherently limited results as prefixes of\n\tattributes. Remove related comment about Class attributes.\n\t(Analyze_Selected_Component): If the prefix is a remote type, check\n\twhether this is a prefixed call before reporting an error.\n\t(Complete_Object_Operation): If the controlling formal is an access to\n\tvariable reject an actual that is a constant or an access to one.\n\t(Try_Object_Operation): If prefix is a tagged protected object,retrieve\n\tprimitive operations from base type.\n\n\t* exp_ch4.adb (Expand_N_Indexed_Component): Test for prefix that is a\n\tbuild-in-place\n\tfunction call and call Make_Build_In_Place_Call_In_Anonymous_Context.\n\t(Expand_N_Selected_Component): Test for prefix that is a build-in-place\n\tfunction call and call Make_Build_In_Place_Call_In_Anonymous_Context.\n\t(Expand_N_Slice): Test for prefix that is a build-in-place function call\n\tand call Make_Build_In_Place_Call_In_Anonymous_Context.\n\t(Analyze_Call): Remove code that issues an error for limited function\n\tcalls in illegal contexts, as we now support all of the contexts that\n\twere forbidden here.\n\tNew calling sequence for Get_Simple_Init_Val\n\t(Expand_Boolean_Operator): Add call to Silly_Boolean_Array_Xor_Test\n\t(Expand_N_Op_Not): Add call to Silly_Boolan_Array_Not_Test\n\nFrom-SVN: r134026", "tree": {"sha": "6a76fa59e98080c9d57ea5a8ca88283c11465754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a76fa59e98080c9d57ea5a8ca88283c11465754"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b459216877b3af65054492a9827769e50c687a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b459216877b3af65054492a9827769e50c687a49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b459216877b3af65054492a9827769e50c687a49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b459216877b3af65054492a9827769e50c687a49/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fc534c1c8033713fafc5caa06c095285826d35c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc534c1c8033713fafc5caa06c095285826d35c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc534c1c8033713fafc5caa06c095285826d35c4"}], "stats": {"total": 822, "additions": 497, "deletions": 325}, "files": [{"sha": "ee440f14424b8cc61105604160cdf71e53236e32", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 296, "deletions": 248, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b459216877b3af65054492a9827769e50c687a49/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b459216877b3af65054492a9827769e50c687a49/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=b459216877b3af65054492a9827769e50c687a49", "patch": "@@ -1852,6 +1852,10 @@ package body Exp_Ch4 is\n          Ensure_Defined (Etype (R), N);\n          Apply_Length_Check (R, Etype (L));\n \n+         if Nkind (N) = N_Op_Xor then\n+            Silly_Boolean_Array_Xor_Test (N, Etype (L));\n+         end if;\n+\n          if Nkind (Parent (N)) = N_Assignment_Statement\n            and then Safe_In_Place_Array_Op (Name (Parent (N)), L, R)\n          then\n@@ -1860,7 +1864,7 @@ package body Exp_Ch4 is\n          elsif Nkind (Parent (N)) = N_Op_Not\n            and then Nkind (N) = N_Op_And\n            and then\n-         Safe_In_Place_Array_Op (Name (Parent (Parent (N))), L, R)\n+             Safe_In_Place_Array_Op (Name (Parent (Parent (N))), L, R)\n          then\n             return;\n          else\n@@ -2812,7 +2816,7 @@ package body Exp_Ch4 is\n \n          function Needs_Initialization_Call (N : Node_Id) return Boolean;\n          --  Determine whether node N is a subtype indicator allocator which\n-         --  asts a coextension. Such coextensions need initialization.\n+         --  acts a coextension. Such coextensions need initialization.\n \n          -------------------------------\n          -- Inside_A_Return_Statement --\n@@ -2943,27 +2947,34 @@ package body Exp_Ch4 is\n                Ref := New_Copy_Tree (Coext);\n             end if;\n \n-            --  Generate:\n-            --    initialize (Ref)\n-            --    attach_to_final_list (Ref, Flist, 2)\n+            --  No initialization call if not allowed\n \n-            if Needs_Initialization_Call (Coext) then\n-               Insert_Actions (N,\n-                 Make_Init_Call (\n-                   Ref         => Ref,\n-                   Typ         => Etype (Coext),\n-                   Flist_Ref   => Flist,\n-                   With_Attach => Make_Integer_Literal (Loc, Uint_2)));\n+            Check_Restriction (No_Default_Initialization, N);\n \n-            --  Generate:\n-            --    attach_to_final_list (Ref, Flist, 2)\n+            if not Restriction_Active (No_Default_Initialization) then\n \n-            else\n-               Insert_Action (N,\n-                 Make_Attach_Call (\n-                   Obj_Ref     => Ref,\n-                   Flist_Ref   => New_Copy_Tree (Flist),\n-                   With_Attach => Make_Integer_Literal (Loc, Uint_2)));\n+               --  Generate:\n+               --    initialize (Ref)\n+               --    attach_to_final_list (Ref, Flist, 2)\n+\n+               if Needs_Initialization_Call (Coext) then\n+                  Insert_Actions (N,\n+                    Make_Init_Call (\n+                      Ref         => Ref,\n+                      Typ         => Etype (Coext),\n+                      Flist_Ref   => Flist,\n+                      With_Attach => Make_Integer_Literal (Loc, Uint_2)));\n+\n+               --  Generate:\n+               --    attach_to_final_list (Ref, Flist, 2)\n+\n+               else\n+                  Insert_Action (N,\n+                    Make_Attach_Call (\n+                      Obj_Ref     => Ref,\n+                      Flist_Ref   => New_Copy_Tree (Flist),\n+                      With_Attach => Make_Integer_Literal (Loc, Uint_2)));\n+               end if;\n             end if;\n \n             Next_Elmt (Coext_Elmt);\n@@ -3174,10 +3185,11 @@ package body Exp_Ch4 is\n             --  Case of simple initialization required\n \n             if Needs_Simple_Initialization (T) then\n+               Check_Restriction (No_Default_Initialization, N);\n                Rewrite (Expression (N),\n                  Make_Qualified_Expression (Loc,\n                    Subtype_Mark => New_Occurrence_Of (T, Loc),\n-                   Expression   => Get_Simple_Init_Val (T, Loc)));\n+                   Expression   => Get_Simple_Init_Val (T, N)));\n \n                Analyze_And_Resolve (Expression (Expression (N)), T);\n                Analyze_And_Resolve (Expression (N), T);\n@@ -3193,292 +3205,299 @@ package body Exp_Ch4 is\n          --  Case of initialization procedure present, must be called\n \n          else\n-            Init := Base_Init_Proc (T);\n-            Nod  := N;\n-            Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n-\n-            --  Construct argument list for the initialization routine call\n-\n-            Arg1 :=\n-              Make_Explicit_Dereference (Loc,\n-                Prefix => New_Reference_To (Temp, Loc));\n-            Set_Assignment_OK (Arg1);\n-            Temp_Type := PtrT;\n+            Check_Restriction (No_Default_Initialization, N);\n \n-            --  The initialization procedure expects a specific type. if the\n-            --  context is access to class wide, indicate that the object being\n-            --  allocated has the right specific type.\n+            if not Restriction_Active (No_Default_Initialization) then\n+               Init := Base_Init_Proc (T);\n+               Nod  := N;\n+               Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('P'));\n \n-            if Is_Class_Wide_Type (Dtyp) then\n-               Arg1 := Unchecked_Convert_To (T, Arg1);\n-            end if;\n-\n-            --  If designated type is a concurrent type or if it is private\n-            --  type whose definition is a concurrent type, the first argument\n-            --  in the Init routine has to be unchecked conversion to the\n-            --  corresponding record type. If the designated type is a derived\n-            --  type, we also convert the argument to its root type.\n-\n-            if Is_Concurrent_Type (T) then\n-               Arg1 :=\n-                 Unchecked_Convert_To (Corresponding_Record_Type (T), Arg1);\n+               --  Construct argument list for the initialization routine call\n \n-            elsif Is_Private_Type (T)\n-              and then Present (Full_View (T))\n-              and then Is_Concurrent_Type (Full_View (T))\n-            then\n                Arg1 :=\n-                 Unchecked_Convert_To\n-                   (Corresponding_Record_Type (Full_View (T)), Arg1);\n-\n-            elsif Etype (First_Formal (Init)) /= Base_Type (T) then\n-               declare\n-                  Ftyp : constant Entity_Id := Etype (First_Formal (Init));\n+                 Make_Explicit_Dereference (Loc,\n+                   Prefix => New_Reference_To (Temp, Loc));\n+               Set_Assignment_OK (Arg1);\n+               Temp_Type := PtrT;\n \n-               begin\n-                  Arg1 := OK_Convert_To (Etype (Ftyp), Arg1);\n-                  Set_Etype (Arg1, Ftyp);\n-               end;\n-            end if;\n+               --  The initialization procedure expects a specific type. if the\n+               --  context is access to class wide, indicate that the object\n+               --  being allocated has the right specific type.\n \n-            Args := New_List (Arg1);\n+               if Is_Class_Wide_Type (Dtyp) then\n+                  Arg1 := Unchecked_Convert_To (T, Arg1);\n+               end if;\n \n-            --  For the task case, pass the Master_Id of the access type as\n-            --  the value of the _Master parameter, and _Chain as the value\n-            --  of the _Chain parameter (_Chain will be defined as part of\n-            --  the generated code for the allocator).\n+               --  If designated type is a concurrent type or if it is private\n+               --  type whose definition is a concurrent type, the first\n+               --  argument in the Init routine has to be unchecked conversion\n+               --  to the corresponding record type. If the designated type is\n+               --  a derived type, we also convert the argument to its root\n+               --  type.\n \n-            --  In Ada 2005, the context may be a function that returns an\n-            --  anonymous access type. In that case the Master_Id has been\n-            --  created when expanding the function declaration.\n+               if Is_Concurrent_Type (T) then\n+                  Arg1 :=\n+                    Unchecked_Convert_To (Corresponding_Record_Type (T), Arg1);\n \n-            if Has_Task (T) then\n-               if No (Master_Id (Base_Type (PtrT))) then\n+               elsif Is_Private_Type (T)\n+                 and then Present (Full_View (T))\n+                 and then Is_Concurrent_Type (Full_View (T))\n+               then\n+                  Arg1 :=\n+                    Unchecked_Convert_To\n+                      (Corresponding_Record_Type (Full_View (T)), Arg1);\n \n-                  --  If we have a non-library level task with the restriction\n-                  --  No_Task_Hierarchy set, then no point in expanding.\n+               elsif Etype (First_Formal (Init)) /= Base_Type (T) then\n+                  declare\n+                     Ftyp : constant Entity_Id := Etype (First_Formal (Init));\n+                  begin\n+                     Arg1 := OK_Convert_To (Etype (Ftyp), Arg1);\n+                     Set_Etype (Arg1, Ftyp);\n+                  end;\n+               end if;\n \n-                  if not Is_Library_Level_Entity (T)\n-                    and then Restriction_Active (No_Task_Hierarchy)\n-                  then\n-                     return;\n-                  end if;\n+               Args := New_List (Arg1);\n \n-                  --  The designated type was an incomplete type, and the\n-                  --  access type did not get expanded. Salvage it now.\n+               --  For the task case, pass the Master_Id of the access type as\n+               --  the value of the _Master parameter, and _Chain as the value\n+               --  of the _Chain parameter (_Chain will be defined as part of\n+               --  the generated code for the allocator).\n \n-                  pragma Assert (Present (Parent (Base_Type (PtrT))));\n-                  Expand_N_Full_Type_Declaration (Parent (Base_Type (PtrT)));\n-               end if;\n+               --  In Ada 2005, the context may be a function that returns an\n+               --  anonymous access type. In that case the Master_Id has been\n+               --  created when expanding the function declaration.\n \n-               --  If the context of the allocator is a declaration or an\n-               --  assignment, we can generate a meaningful image for it,\n-               --  even though subsequent assignments might remove the\n-               --  connection between task and entity. We build this image\n-               --  when the left-hand side is a simple variable, a simple\n-               --  indexed assignment or a simple selected component.\n+               if Has_Task (T) then\n+                  if No (Master_Id (Base_Type (PtrT))) then\n \n-               if Nkind (Parent (N)) = N_Assignment_Statement then\n-                  declare\n-                     Nam : constant Node_Id := Name (Parent (N));\n+                     --  If we have a non-library level task with restriction\n+                     --  No_Task_Hierarchy set, then no point in expanding.\n \n-                  begin\n-                     if Is_Entity_Name (Nam) then\n-                        Decls :=\n-                          Build_Task_Image_Decls (\n-                            Loc,\n-                              New_Occurrence_Of\n-                                (Entity (Nam), Sloc (Nam)), T);\n-\n-                     elsif Nkind_In\n-                             (Nam, N_Indexed_Component, N_Selected_Component)\n-                       and then Is_Entity_Name (Prefix (Nam))\n+                     if not Is_Library_Level_Entity (T)\n+                       and then Restriction_Active (No_Task_Hierarchy)\n                      then\n-                        Decls :=\n-                          Build_Task_Image_Decls\n-                            (Loc, Nam, Etype (Prefix (Nam)));\n-                     else\n-                        Decls := Build_Task_Image_Decls (Loc, T, T);\n+                        return;\n                      end if;\n-                  end;\n \n-               elsif Nkind (Parent (N)) = N_Object_Declaration then\n-                  Decls :=\n-                    Build_Task_Image_Decls (\n-                       Loc, Defining_Identifier (Parent (N)), T);\n+                     --  The designated type was an incomplete type, and the\n+                     --  access type did not get expanded. Salvage it now.\n \n-               else\n-                  Decls := Build_Task_Image_Decls (Loc, T, T);\n-               end if;\n-\n-               Append_To (Args,\n-                 New_Reference_To\n-                   (Master_Id (Base_Type (Root_Type (PtrT))), Loc));\n-               Append_To (Args, Make_Identifier (Loc, Name_uChain));\n+                     pragma Assert (Present (Parent (Base_Type (PtrT))));\n+                     Expand_N_Full_Type_Declaration\n+                       (Parent (Base_Type (PtrT)));\n+                  end if;\n \n-               Decl := Last (Decls);\n-               Append_To (Args,\n-                 New_Occurrence_Of (Defining_Identifier (Decl), Loc));\n+                  --  If the context of the allocator is a declaration or an\n+                  --  assignment, we can generate a meaningful image for it,\n+                  --  even though subsequent assignments might remove the\n+                  --  connection between task and entity. We build this image\n+                  --  when the left-hand side is a simple variable, a simple\n+                  --  indexed assignment or a simple selected component.\n+\n+                  if Nkind (Parent (N)) = N_Assignment_Statement then\n+                     declare\n+                        Nam : constant Node_Id := Name (Parent (N));\n+\n+                     begin\n+                        if Is_Entity_Name (Nam) then\n+                           Decls :=\n+                             Build_Task_Image_Decls\n+                               (Loc,\n+                                New_Occurrence_Of\n+                                  (Entity (Nam), Sloc (Nam)), T);\n+\n+                        elsif Nkind_In\n+                          (Nam, N_Indexed_Component, N_Selected_Component)\n+                          and then Is_Entity_Name (Prefix (Nam))\n+                        then\n+                           Decls :=\n+                             Build_Task_Image_Decls\n+                               (Loc, Nam, Etype (Prefix (Nam)));\n+                        else\n+                           Decls := Build_Task_Image_Decls (Loc, T, T);\n+                        end if;\n+                     end;\n \n-            --  Has_Task is false, Decls not used\n+                  elsif Nkind (Parent (N)) = N_Object_Declaration then\n+                     Decls :=\n+                       Build_Task_Image_Decls\n+                         (Loc, Defining_Identifier (Parent (N)), T);\n \n-            else\n-               Decls := No_List;\n-            end if;\n+                  else\n+                     Decls := Build_Task_Image_Decls (Loc, T, T);\n+                  end if;\n \n-            --  Add discriminants if discriminated type\n+                  Append_To (Args,\n+                    New_Reference_To\n+                      (Master_Id (Base_Type (Root_Type (PtrT))), Loc));\n+                  Append_To (Args, Make_Identifier (Loc, Name_uChain));\n \n-            declare\n-               Dis : Boolean := False;\n-               Typ : Entity_Id;\n+                  Decl := Last (Decls);\n+                  Append_To (Args,\n+                    New_Occurrence_Of (Defining_Identifier (Decl), Loc));\n \n-            begin\n-               if Has_Discriminants (T) then\n-                  Dis := True;\n-                  Typ := T;\n+                  --  Has_Task is false, Decls not used\n \n-               elsif Is_Private_Type (T)\n-                 and then Present (Full_View (T))\n-                 and then Has_Discriminants (Full_View (T))\n-               then\n-                  Dis := True;\n-                  Typ := Full_View (T);\n+               else\n+                  Decls := No_List;\n                end if;\n \n-               if Dis then\n-                  --  If the allocated object will be constrained by the\n-                  --  default values for discriminants, then build a\n-                  --  subtype with those defaults, and change the allocated\n-                  --  subtype to that. Note that this happens in fewer\n-                  --  cases in Ada 2005 (AI-363).\n-\n-                  if not Is_Constrained (Typ)\n-                    and then Present (Discriminant_Default_Value\n-                                       (First_Discriminant (Typ)))\n-                    and then (Ada_Version < Ada_05\n-                               or else not Has_Constrained_Partial_View (Typ))\n+               --  Add discriminants if discriminated type\n+\n+               declare\n+                  Dis : Boolean := False;\n+                  Typ : Entity_Id;\n+\n+               begin\n+                  if Has_Discriminants (T) then\n+                     Dis := True;\n+                     Typ := T;\n+\n+                  elsif Is_Private_Type (T)\n+                    and then Present (Full_View (T))\n+                    and then Has_Discriminants (Full_View (T))\n                   then\n-                     Typ := Build_Default_Subtype (Typ, N);\n-                     Set_Expression (N, New_Reference_To (Typ, Loc));\n+                     Dis := True;\n+                     Typ := Full_View (T);\n                   end if;\n \n-                  Discr := First_Elmt (Discriminant_Constraint (Typ));\n-                  while Present (Discr) loop\n-                     Nod := Node (Discr);\n-                     Append (New_Copy_Tree (Node (Discr)), Args);\n+                  if Dis then\n \n-                     --  AI-416: when the discriminant constraint is an\n-                     --  anonymous access type make sure an accessibility\n-                     --  check is inserted if necessary (3.10.2(22.q/2))\n+                     --  If the allocated object will be constrained by the\n+                     --  default values for discriminants, then build a\n+                     --  subtype with those defaults, and change the allocated\n+                     --  subtype to that. Note that this happens in fewer\n+                     --  cases in Ada 2005 (AI-363).\n \n-                     if Ada_Version >= Ada_05\n-                       and then Ekind (Etype (Nod)) = E_Anonymous_Access_Type\n+                     if not Is_Constrained (Typ)\n+                       and then Present (Discriminant_Default_Value\n+                                         (First_Discriminant (Typ)))\n+                       and then (Ada_Version < Ada_05\n+                                  or else\n+                                    not Has_Constrained_Partial_View (Typ))\n                      then\n-                        Apply_Accessibility_Check (Nod, Typ);\n+                        Typ := Build_Default_Subtype (Typ, N);\n+                        Set_Expression (N, New_Reference_To (Typ, Loc));\n                      end if;\n \n-                     Next_Elmt (Discr);\n-                  end loop;\n-               end if;\n-            end;\n+                     Discr := First_Elmt (Discriminant_Constraint (Typ));\n+                     while Present (Discr) loop\n+                        Nod := Node (Discr);\n+                        Append (New_Copy_Tree (Node (Discr)), Args);\n \n-            --  We set the allocator as analyzed so that when we analyze the\n-            --  expression actions node, we do not get an unwanted recursive\n-            --  expansion of the allocator expression.\n+                        --  AI-416: when the discriminant constraint is an\n+                        --  anonymous access type make sure an accessibility\n+                        --  check is inserted if necessary (3.10.2(22.q/2))\n \n-            Set_Analyzed (N, True);\n-            Nod := Relocate_Node (N);\n+                        if Ada_Version >= Ada_05\n+                          and then\n+                            Ekind (Etype (Nod)) = E_Anonymous_Access_Type\n+                        then\n+                           Apply_Accessibility_Check (Nod, Typ);\n+                        end if;\n \n-            --  Here is the transformation:\n-            --    input:  new T\n-            --    output: Temp : constant ptr_T := new T;\n-            --            Init (Temp.all, ...);\n-            --    <CTRL>  Attach_To_Final_List (Finalizable (Temp.all));\n-            --    <CTRL>  Initialize (Finalizable (Temp.all));\n+                        Next_Elmt (Discr);\n+                     end loop;\n+                  end if;\n+               end;\n \n-            --  Here ptr_T is the pointer type for the allocator, and is the\n-            --  subtype of the allocator.\n+               --  We set the allocator as analyzed so that when we analyze the\n+               --  expression actions node, we do not get an unwanted recursive\n+               --  expansion of the allocator expression.\n \n-            Temp_Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Temp,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Reference_To (Temp_Type, Loc),\n-                Expression          => Nod);\n+               Set_Analyzed (N, True);\n+               Nod := Relocate_Node (N);\n \n-            Set_Assignment_OK (Temp_Decl);\n-            Insert_Action (N, Temp_Decl, Suppress => All_Checks);\n+               --  Here is the transformation:\n+               --    input:  new T\n+               --    output: Temp : constant ptr_T := new T;\n+               --            Init (Temp.all, ...);\n+               --    <CTRL>  Attach_To_Final_List (Finalizable (Temp.all));\n+               --    <CTRL>  Initialize (Finalizable (Temp.all));\n \n-            --  If the designated type is a task type or contains tasks,\n-            --  create block to activate created tasks, and insert\n-            --  declaration for Task_Image variable ahead of call.\n+               --  Here ptr_T is the pointer type for the allocator, and is the\n+               --  subtype of the allocator.\n \n-            if Has_Task (T) then\n-               declare\n-                  L   : constant List_Id := New_List;\n-                  Blk : Node_Id;\n+               Temp_Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Reference_To (Temp_Type, Loc),\n+                   Expression          => Nod);\n \n-               begin\n-                  Build_Task_Allocate_Block (L, Nod, Args);\n-                  Blk := Last (L);\n+               Set_Assignment_OK (Temp_Decl);\n+               Insert_Action (N, Temp_Decl, Suppress => All_Checks);\n \n-                  Insert_List_Before (First (Declarations (Blk)), Decls);\n-                  Insert_Actions (N, L);\n-               end;\n+               --  If the designated type is a task type or contains tasks,\n+               --  create block to activate created tasks, and insert\n+               --  declaration for Task_Image variable ahead of call.\n \n-            else\n-               Insert_Action (N,\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Reference_To (Init, Loc),\n-                   Parameter_Associations => Args));\n-            end if;\n+               if Has_Task (T) then\n+                  declare\n+                     L   : constant List_Id := New_List;\n+                     Blk : Node_Id;\n+                  begin\n+                     Build_Task_Allocate_Block (L, Nod, Args);\n+                     Blk := Last (L);\n+                     Insert_List_Before (First (Declarations (Blk)), Decls);\n+                     Insert_Actions (N, L);\n+                  end;\n \n-            if Controlled_Type (T) then\n+               else\n+                  Insert_Action (N,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name                   => New_Reference_To (Init, Loc),\n+                      Parameter_Associations => Args));\n+               end if;\n \n-               --  Postpone the generation of a finalization call for the\n-               --  current allocator if it acts as a coextension.\n+               if Controlled_Type (T) then\n \n-               if Is_Dynamic_Coextension (N) then\n-                  if No (Coextensions (N)) then\n-                     Set_Coextensions (N, New_Elmt_List);\n-                  end if;\n+                  --  Postpone the generation of a finalization call for the\n+                  --  current allocator if it acts as a coextension.\n \n-                  Append_Elmt (New_Copy_Tree (Arg1), Coextensions (N));\n+                  if Is_Dynamic_Coextension (N) then\n+                     if No (Coextensions (N)) then\n+                        Set_Coextensions (N, New_Elmt_List);\n+                     end if;\n \n-               else\n-                  Flist := Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n+                     Append_Elmt (New_Copy_Tree (Arg1), Coextensions (N));\n+\n+                  else\n+                     Flist :=\n+                       Get_Allocator_Final_List (N, Base_Type (T), PtrT);\n \n-                  --  Anonymous access types created for access parameters\n-                  --  are attached to an explicitly constructed controller,\n-                  --  which ensures that they can be finalized properly, even\n-                  --  if their deallocation might not happen. The list\n-                  --  associated with the controller is doubly-linked. For\n-                  --  other anonymous access types, the object may end up\n-                  --  on the global final list which is singly-linked.\n-                  --  Work needed for access discriminants in Ada 2005 ???\n+                     --  Anonymous access types created for access parameters\n+                     --  are attached to an explicitly constructed controller,\n+                     --  which ensures that they can be finalized properly,\n+                     --  even if their deallocation might not happen. The list\n+                     --  associated with the controller is doubly-linked. For\n+                     --  other anonymous access types, the object may end up\n+                     --  on the global final list which is singly-linked.\n+                     --  Work needed for access discriminants in Ada 2005 ???\n \n-                  if Ekind (PtrT) = E_Anonymous_Access_Type\n+                     if Ekind (PtrT) = E_Anonymous_Access_Type\n                        and then\n                          Nkind (Associated_Node_For_Itype (PtrT))\n-                           not in N_Subprogram_Specification\n-                  then\n-                     Attach_Level := Uint_1;\n-                  else\n-                     Attach_Level := Uint_2;\n-                  end if;\n+                     not in N_Subprogram_Specification\n+                     then\n+                        Attach_Level := Uint_1;\n+                     else\n+                        Attach_Level := Uint_2;\n+                     end if;\n \n-                  Insert_Actions (N,\n-                    Make_Init_Call (\n-                      Ref          => New_Copy_Tree (Arg1),\n-                      Typ          => T,\n-                      Flist_Ref    => Flist,\n-                      With_Attach  => Make_Integer_Literal\n-                                        (Loc, Attach_Level)));\n+                     Insert_Actions (N,\n+                       Make_Init_Call (\n+                         Ref          => New_Copy_Tree (Arg1),\n+                         Typ          => T,\n+                         Flist_Ref    => Flist,\n+                         With_Attach  => Make_Integer_Literal (Loc,\n+                                           Intval => Attach_Level)));\n+                  end if;\n                end if;\n-            end if;\n \n-            Rewrite (N, New_Reference_To (Temp, Loc));\n-            Analyze_And_Resolve (N, PtrT);\n+               Rewrite (N, New_Reference_To (Temp, Loc));\n+               Analyze_And_Resolve (N, PtrT);\n+            end if;\n          end if;\n       end;\n \n@@ -4110,6 +4129,15 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Ada 2005 (AI-318-02): If the prefix is a call to a build-in-place\n+      --  function, then additional actuals must be passed.\n+\n+      if Ada_Version >= Ada_05\n+        and then Is_Build_In_Place_Function_Call (P)\n+      then\n+         Make_Build_In_Place_Call_In_Anonymous_Context (P);\n+      end if;\n+\n       --  If the prefix is an access type, then we unconditionally rewrite\n       --  if as an explicit deference. This simplifies processing for several\n       --  cases, including packed array cases and certain cases in which\n@@ -6236,6 +6264,7 @@ package body Exp_Ch4 is\n       Convert_To_Actual_Subtype (Opnd);\n       Arr := Etype (Opnd);\n       Ensure_Defined (Arr, N);\n+      Silly_Boolean_Array_Not_Test (N, Arr);\n \n       if Nkind (Parent (N)) = N_Assignment_Statement then\n          if Safe_In_Place_Array_Op (Name (Parent (N)), N, Empty) then\n@@ -6758,6 +6787,15 @@ package body Exp_Ch4 is\n          Generate_Discriminant_Check (N);\n       end if;\n \n+      --  Ada 2005 (AI-318-02): If the prefix is a call to a build-in-place\n+      --  function, then additional actuals must be passed.\n+\n+      if Ada_Version >= Ada_05\n+        and then Is_Build_In_Place_Function_Call (P)\n+      then\n+         Make_Build_In_Place_Call_In_Anonymous_Context (P);\n+      end if;\n+\n       --  Gigi cannot handle unchecked conversions that are the prefix of a\n       --  selected component with discriminants. This must be checked during\n       --  expansion, because during analysis the type of the selector is not\n@@ -7025,6 +7063,15 @@ package body Exp_Ch4 is\n          Analyze_And_Resolve (Pfx, Ptp);\n       end if;\n \n+      --  Ada 2005 (AI-318-02): If the prefix is a call to a build-in-place\n+      --  function, then additional actuals must be passed.\n+\n+      if Ada_Version >= Ada_05\n+        and then Is_Build_In_Place_Function_Call (Pfx)\n+      then\n+         Make_Build_In_Place_Call_In_Anonymous_Context (Pfx);\n+      end if;\n+\n       --  Range checks are potentially also needed for cases involving\n       --  a slice indexed by a subtype indication, but Do_Range_Check\n       --  can currently only be set for expressions ???\n@@ -9072,7 +9119,8 @@ package body Exp_Ch4 is\n             --  configurable run time setting.\n \n             if not RTE_Available (RE_IW_Membership) then\n-               Error_Msg_CRT (\"abstract interface types\", N);\n+               Error_Msg_CRT\n+                 (\"dynamic membership test on interface types\", N);\n                return Empty;\n             end if;\n "}, {"sha": "e790e553d075529de9f490bc542a1fd4a996ebbb", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b459216877b3af65054492a9827769e50c687a49/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b459216877b3af65054492a9827769e50c687a49/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=b459216877b3af65054492a9827769e50c687a49", "patch": "@@ -219,7 +219,7 @@ package body Sem_Cat is\n             --  unit generating the message is an internal unit. This is the\n             --  situation in which such messages would be ignored in any case,\n             --  so it is convenient not to generate them (since it causes\n-            --  annoying inteference with debugging)\n+            --  annoying interference with debugging).\n \n             if Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit))\n               and then not Is_Internal_File_Name (Unit_File_Name (Main_Unit))\n@@ -332,16 +332,29 @@ package body Sem_Cat is\n       Nam          : TSS_Name_Type;\n       At_Any_Place : Boolean := False) return Boolean\n    is\n-      Rep_Item : Node_Id;\n+      Rep_Item  : Node_Id;\n+      Full_Type : Entity_Id := Typ;\n+\n    begin\n+      --  In the case of a type derived from a private view, any specified\n+      --  stream attributes will be attached to the derived type's underlying\n+      --  type rather the derived type entity itself (which is itself private).\n+\n+      if Is_Private_Type (Typ)\n+        and then Is_Derived_Type (Typ)\n+        and then Present (Full_View (Typ))\n+      then\n+         Full_Type := Underlying_Type (Typ);\n+      end if;\n+\n       --  We start from the declaration node and then loop until the end of\n       --  the list until we find the requested attribute definition clause.\n       --  In Ada 2005 mode, clauses are ignored if they are not currently\n       --  visible (this is tested using the corresponding Entity, which is\n       --  inserted by the expander at the point where the clause occurs),\n       --  unless At_Any_Place is true.\n \n-      Rep_Item := First_Rep_Item (Typ);\n+      Rep_Item := First_Rep_Item (Full_Type);\n       while Present (Rep_Item) loop\n          if Nkind (Rep_Item) = N_Attribute_Definition_Clause then\n             case Chars (Rep_Item) is\n@@ -1251,7 +1264,9 @@ package body Sem_Cat is\n             end;\n          end if;\n \n-         --  Non-static discriminant not allowed in preelaborayted unit\n+         --  Non-static discriminant not allowed in preelaborated unit\n+         --  Controlled object of a type with a user-defined Initialize\n+         --  is forbidden as well.\n \n          if Is_Record_Type (Etype (Id)) then\n             declare\n@@ -1274,7 +1289,14 @@ package body Sem_Cat is\n                         PEE);\n                   end if;\n                end if;\n+\n+               if Has_Overriding_Initialize (ET) then\n+                  Error_Msg_NE\n+                    (\"controlled type& does not have\"\n+                      & \" preelaborable initialization\", N, ET);\n+               end if;\n             end;\n+\n          end if;\n       end if;\n \n@@ -1552,9 +1574,9 @@ package body Sem_Cat is\n                       Error_Node);\n                end if;\n \n-            --  For limited private type parameter, we check only the private\n+            --  For a limited private type parameter, we check only the private\n             --  declaration and ignore full type declaration, unless this is\n-            --  the only declaration for the type, eg. as a limited record.\n+            --  the only declaration for the type, e.g., as a limited record.\n \n             elsif Is_Limited_Type (Param_Type)\n               and then (Nkind (Type_Decl) = N_Private_Type_Declaration\n@@ -1569,7 +1591,7 @@ package body Sem_Cat is\n                if No (Full_View (Param_Type))\n                  and then Ekind (Param_Type) /= E_Record_Type\n                then\n-                  --  Type does not have completion yet, so if declared in in\n+                  --  Type does not have completion yet, so if declared in\n                   --  the current RCI scope it is illegal, and will be flagged\n                   --  subsequently.\n \n@@ -1585,7 +1607,11 @@ package body Sem_Cat is\n                --  contract model for privacy, but we support both semantics\n                --  for now for compatibility (note that ACATS test BXE2009\n                --  checks a case that conforms to the Ada 95 rules but is\n-               --  illegal in Ada 2005).\n+               --  illegal in Ada 2005). In the Ada 2005 case we check for the\n+               --  possibilities of visible TSS stream subprograms or explicit\n+               --  stream attribute definitions because the TSS subprograms\n+               --  can be hidden in the private part while the attribute\n+               --  definitions are still be available from the visible part.\n \n                Base_Param_Type := Base_Type (Param_Type);\n                Base_Under_Type := Base_Type (Underlying_Type\n@@ -1609,7 +1635,13 @@ package body Sem_Cat is\n                            or else\n                          Is_Hidden (TSS (Base_Param_Type, TSS_Stream_Read))\n                            or else\n-                         Is_Hidden (TSS (Base_Param_Type, TSS_Stream_Write))))\n+                         Is_Hidden (TSS (Base_Param_Type, TSS_Stream_Write)))\n+                      and then\n+                        (not Has_Stream_Attribute_Definition\n+                               (Base_Param_Type, TSS_Stream_Read)\n+                           or else\n+                         not Has_Stream_Attribute_Definition\n+                               (Base_Param_Type, TSS_Stream_Write)))\n                then\n                   if K = N_Subprogram_Declaration then\n                      Error_Node := Param_Spec;\n@@ -1761,12 +1793,15 @@ package body Sem_Cat is\n \n       --  This subprogram also enforces the checks in E.2.2(13). A value of\n       --  such type must not be dereferenced unless as controlling operand of\n-      --  a dispatching call.\n+      --  a dispatching call. Explicit dereferences not coming from source are\n+      --  exempted from this checking because the expander produces them in\n+      --  some cases (such as for tag checks on dispatching calls with multiple\n+      --  controlling operands). However we do check in the case of an implicit\n+      --  dereference that is expanded to an explicit dereference (hence the\n+      --  test of whether Original_Node (N) comes from source).\n \n       elsif K = N_Explicit_Dereference\n-        and then (Comes_From_Source (N)\n-                    or else (Nkind (Original_Node (N)) = N_Selected_Component\n-                               and then Comes_From_Source (Original_Node (N))))\n+        and then Comes_From_Source (Original_Node (N))\n       then\n          E := Etype (Prefix (N));\n \n@@ -1788,9 +1823,12 @@ package body Sem_Cat is\n \n          --  If we are just within a procedure or function call and the\n          --  dereference has not been analyzed, return because this procedure\n-         --  will be called again from sem_res Resolve_Actuals.\n+         --  will be called again from sem_res Resolve_Actuals. The same can\n+         --  apply in the case of dereference that is the prefix of a selected\n+         --  component, which can be a call given in prefixed form.\n \n-         if Is_Actual_Parameter (N)\n+         if (Is_Actual_Parameter (N)\n+              or else PK = N_Selected_Component)\n            and then not Analyzed (N)\n          then\n             return;\n@@ -1806,25 +1844,8 @@ package body Sem_Cat is\n             return;\n          end if;\n \n-         --  The following code is needed for expansion of RACW Write\n-         --  attribute, since such expressions can appear in the expanded\n-         --  code.\n-\n-         if not Comes_From_Source (N)\n-           and then\n-           (PK = N_In\n-            or else PK = N_Attribute_Reference\n-            or else\n-              (PK = N_Type_Conversion\n-               and then Present (Parent (N))\n-               and then Present (Parent (Parent (N)))\n-               and then\n-                 Nkind (Parent (Parent (N))) = N_Selected_Component))\n-         then\n-            return;\n-         end if;\n-\n-         Error_Msg_N (\"incorrect dereference of remote type\", N);\n+         Error_Msg_N\n+           (\"invalid dereference of a remote access-to-class-wide value\", N);\n       end if;\n    end Validate_Remote_Access_To_Class_Wide_Type;\n "}, {"sha": "224639983b511454373f112303f4128d1f671e1d", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 146, "deletions": 43, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b459216877b3af65054492a9827769e50c687a49/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b459216877b3af65054492a9827769e50c687a49/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=b459216877b3af65054492a9827769e50c687a49", "patch": "@@ -73,7 +73,7 @@ package body Sem_Ch4 is\n    --  function, and if so must be converted into an explicit call node\n    --  and analyzed as such. This deproceduring must be done during the first\n    --  pass of overload resolution, because otherwise a procedure call with\n-   --  overloaded actuals may fail to resolve. See 4327-001 for an example.\n+   --  overloaded actuals may fail to resolve.\n \n    procedure Analyze_Operator_Call (N : Node_Id; Op_Id : Entity_Id);\n    --  Analyze a call of the form \"+\"(x, y), etc. The prefix of the call\n@@ -268,6 +268,11 @@ package body Sem_Ch4 is\n    function Try_Object_Operation (N : Node_Id) return Boolean;\n    --  Ada 2005 (AI-252): Support the object.operation notation\n \n+   procedure wpo (T : Entity_Id);\n+   pragma Warnings (Off, wpo);\n+   --  Used for debugging: obtain list of primitive operations even if\n+   --  type is not frozen and dispatch table is not built yet.\n+\n    ------------------------\n    -- Ambiguous_Operands --\n    ------------------------\n@@ -366,7 +371,6 @@ package body Sem_Ch4 is\n       if Nkind (E) = N_Qualified_Expression then\n          Acc_Type := Create_Itype (E_Allocator_Type, N);\n          Set_Etype (Acc_Type, Acc_Type);\n-         Init_Size_Align (Acc_Type);\n          Find_Type (Subtype_Mark (E));\n \n          --  Analyze the qualified expression, and apply the name resolution\n@@ -491,7 +495,6 @@ package body Sem_Ch4 is\n             Type_Id := Process_Subtype (E, N);\n             Acc_Type := Create_Itype (E_Allocator_Type, N);\n             Set_Etype                    (Acc_Type, Acc_Type);\n-            Init_Size_Align              (Acc_Type);\n             Set_Directly_Designated_Type (Acc_Type, Type_Id);\n             Check_Fully_Declared (Type_Id, N);\n \n@@ -971,26 +974,6 @@ package body Sem_Ch4 is\n \n          End_Interp_List;\n       end if;\n-\n-      --  Check for not-yet-implemented cases of AI-318. We only need to check\n-      --  for inherently limited types, because other limited types will be\n-      --  returned by copy, which works just fine.\n-      --  If the context is an attribute reference 'Class, this is really a\n-      --  type conversion, which is illegal, and will be caught elsewhere.\n-\n-      if Ada_Version >= Ada_05\n-        and then not Debug_Flag_Dot_L\n-        and then Is_Inherently_Limited_Type (Etype (N))\n-        and then (Nkind_In (Parent (N), N_Selected_Component,\n-                                        N_Indexed_Component,\n-                                        N_Slice)\n-                   or else\n-                    (Nkind (Parent (N)) = N_Attribute_Reference\n-                       and then Attribute_Name (Parent (N)) /= Name_Class))\n-      then\n-         Error_Msg_N (\"(Ada 2005) limited function call in this context\" &\n-                      \" is not yet implemented\", N);\n-      end if;\n    end Analyze_Call;\n \n    ---------------------------\n@@ -1444,7 +1427,6 @@ package body Sem_Ch4 is\n          --  where the prefix might include functions that return access to\n          --  subprograms and others that return a regular type. Disambiguation\n          --  of those has to take place in Resolve.\n-         --  See e.g. 7117-014 and E317-001.\n \n          New_N :=\n            Make_Function_Call (Loc,\n@@ -2716,7 +2698,10 @@ package body Sem_Ch4 is\n \n       procedure Check_Common_Type (T1, T2 : Entity_Id) is\n       begin\n-         if Covers (T1, T2) or else Covers (T2, T1) then\n+         if Covers (T1 => T1, T2 => T2)\n+              or else\n+            Covers (T1 => T2, T2 => T1)\n+         then\n             if T1 = Universal_Integer\n               or else T1 = Universal_Real\n               or else T1 = Any_Character\n@@ -2808,12 +2793,50 @@ package body Sem_Ch4 is\n \n    procedure Analyze_Reference (N : Node_Id) is\n       P        : constant Node_Id := Prefix (N);\n+      E        : Entity_Id;\n+      T        : Entity_Id;\n       Acc_Type : Entity_Id;\n+\n    begin\n       Analyze (P);\n+\n+      --  An interesting error check, if we take the 'Reference of an object\n+      --  for which a pragma Atomic or Volatile has been given, and the type\n+      --  of the object is not Atomic or Volatile, then we are in trouble. The\n+      --  problem is that no trace of the atomic/volatile status will remain\n+      --  for the backend to respect when it deals with the resulting pointer,\n+      --  since the pointer type will not be marked atomic (it is a pointer to\n+      --  the base type of the object).\n+\n+      --  It is not clear if that can ever occur, but in case it does, we will\n+      --  generate an error message. Not clear if this message can ever be\n+      --  generated, and pretty clear that it represents a bug if it is, still\n+      --  seems worth checking!\n+\n+      T := Etype (P);\n+\n+      if Is_Entity_Name (P)\n+        and then Is_Object_Reference (P)\n+      then\n+         E := Entity (P);\n+         T := Etype (P);\n+\n+         if (Has_Atomic_Components   (E)\n+               and then not Has_Atomic_Components   (T))\n+           or else\n+            (Has_Volatile_Components (E)\n+               and then not Has_Volatile_Components (T))\n+           or else (Is_Atomic   (E) and then not Is_Atomic   (T))\n+           or else (Is_Volatile (E) and then not Is_Volatile (T))\n+         then\n+            Error_Msg_N (\"cannot take reference to Atomic/Volatile object\", N);\n+         end if;\n+      end if;\n+\n+      --  Carry on with normal processing\n+\n       Acc_Type := Create_Itype (E_Allocator_Type, N);\n-      Set_Etype                    (Acc_Type,  Acc_Type);\n-      Init_Size_Align              (Acc_Type);\n+      Set_Etype (Acc_Type,  Acc_Type);\n       Set_Directly_Designated_Type (Acc_Type, Etype (P));\n       Set_Etype (N, Acc_Type);\n    end Analyze_Reference;\n@@ -2845,7 +2868,8 @@ package body Sem_Ch4 is\n       --  It is known that the parent of N denotes a subprogram call. Comp\n       --  is an overloadable component of the concurrent type of the prefix.\n       --  Determine whether all formals of the parent of N and Comp are mode\n-      --  conformant.\n+      --  conformant. If the parent node is not analyzed yet it may be an\n+      --  indexed component rather than a function call.\n \n       ------------------------------\n       -- Has_Mode_Conformant_Spec --\n@@ -2858,7 +2882,13 @@ package body Sem_Ch4 is\n \n       begin\n          Comp_Param := First_Formal (Comp);\n-         Param := First (Parameter_Associations (Parent (N)));\n+\n+         if Nkind (Parent (N)) = N_Indexed_Component then\n+            Param := First (Expressions (Parent (N)));\n+         else\n+            Param := First (Parameter_Associations (Parent (N)));\n+         end if;\n+\n          while Present (Comp_Param)\n            and then Present (Param)\n          loop\n@@ -2908,14 +2938,19 @@ package body Sem_Ch4 is\n          --  A RACW object can never be used as prefix of a selected\n          --  component since that means it is dereferenced without\n          --  being a controlling operand of a dispatching operation\n-         --  (RM E.2.2(15)).\n+         --  (RM E.2.2(16/1)). Before reporting an error, we must check\n+         --  whether this is actually a dispatching call in prefix form.\n \n          if Is_Remote_Access_To_Class_Wide_Type (Prefix_Type)\n            and then Comes_From_Source (N)\n          then\n-            Error_Msg_N\n-              (\"invalid dereference of a remote access to class-wide value\",\n-               N);\n+            if Try_Object_Operation (N) then\n+               return;\n+            else\n+               Error_Msg_N\n+                 (\"invalid dereference of a remote access-to-class-wide value\",\n+                  N);\n+            end if;\n \n          --  Normal case of selected component applied to access type\n \n@@ -2932,6 +2967,27 @@ package body Sem_Ch4 is\n \n             Prefix_Type := Process_Implicit_Dereference_Prefix (Pent, Name);\n          end if;\n+\n+      --  If we have an explicit dereference of a remote access-to-class-wide\n+      --  value, then issue an error (see RM-E.2.2(16/1)). However we first\n+      --  have to check for the case of a prefix that is a controlling operand\n+      --  of a prefixed dispatching call, as the dereference is legal in that\n+      --  case. Normally this condition is checked in Validate_Remote_Access_\n+      --  To_Class_Wide_Type, but we have to defer the checking for selected\n+      --  component prefixes because of the prefixed dispatching call case.\n+      --  Note that implicit dereferences are checked for this just above.\n+\n+      elsif Nkind (Name) = N_Explicit_Dereference\n+        and then Is_Remote_Access_To_Class_Wide_Type (Etype (Prefix (Name)))\n+        and then Comes_From_Source (N)\n+      then\n+         if Try_Object_Operation (N) then\n+            return;\n+         else\n+            Error_Msg_N\n+              (\"invalid dereference of a remote access-to-class-wide value\",\n+               N);\n+         end if;\n       end if;\n \n       --  (Ada 2005): if the prefix is the limited view of a type, and\n@@ -3256,7 +3312,8 @@ package body Sem_Ch4 is\n                   if Is_Tagged_Type (Prefix_Type)\n                     and then\n                       Nkind_In (Parent (N), N_Procedure_Call_Statement,\n-                                            N_Function_Call)\n+                                            N_Function_Call,\n+                                            N_Indexed_Component)\n                     and then Has_Mode_Conformant_Spec (Comp)\n                   then\n                      Has_Candidate := True;\n@@ -3322,6 +3379,7 @@ package body Sem_Ch4 is\n             --  the controlling formal is implicit ???\n \n             elsif Nkind (Parent (N)) /= N_Procedure_Call_Statement\n+              and then Nkind (Parent (N)) /= N_Indexed_Component\n               and then Try_Object_Operation (N)\n             then\n                return;\n@@ -3899,7 +3957,9 @@ package body Sem_Ch4 is\n \n          if Is_Numeric_Type (T1)\n            and then Is_Numeric_Type (T2)\n-           and then (Covers (T1, T2) or else Covers (T2, T1))\n+           and then (Covers (T1 => T1, T2 => T2)\n+                       or else\n+                     Covers (T1 => T2, T2 => T1))\n          then\n             Add_One_Interp (N, Op_Id, Specific_Type (T1, T2));\n          end if;\n@@ -3938,7 +3998,9 @@ package body Sem_Ch4 is\n \n          elsif Is_Numeric_Type (T1)\n            and then Is_Numeric_Type (T2)\n-           and then (Covers (T1, T2) or else Covers (T2, T1))\n+           and then (Covers (T1 => T1, T2 => T2)\n+                       or else\n+                     Covers (T1 => T2, T2 => T1))\n          then\n             Add_One_Interp (N, Op_Id, Specific_Type (T1, T2));\n \n@@ -3983,7 +4045,9 @@ package body Sem_Ch4 is\n          --  already set (case of operation constructed by Exp_Fixed).\n \n          if Is_Integer_Type (T1)\n-           and then (Covers (T1, T2) or else Covers (T2, T1))\n+           and then (Covers (T1 => T1, T2 => T2)\n+                       or else\n+                     Covers (T1 => T2, T2 => T1))\n          then\n             Add_One_Interp (N, Op_Id, Specific_Type (T1, T2));\n          end if;\n@@ -4414,7 +4478,7 @@ package body Sem_Ch4 is\n       if Nkind (L) = N_Aggregate\n         and then Nkind (R) /= N_Aggregate\n       then\n-         Find_Comparison_Types (R, L, Op_Id, N);\n+         Find_Comparison_Types (L => R, R => L, Op_Id => Op_Id, N => N);\n          return;\n       end if;\n \n@@ -4632,7 +4696,7 @@ package body Sem_Ch4 is\n       if Nkind (L) = N_Aggregate\n         and then Nkind (R) /= N_Aggregate\n       then\n-         Find_Equality_Types (R, L, Op_Id, N);\n+         Find_Equality_Types (L => R, R => L, Op_Id => Op_Id, N => N);\n          return;\n       end if;\n \n@@ -5653,8 +5717,8 @@ package body Sem_Ch4 is\n         (Call_Node       : Node_Id;\n          Node_To_Replace : Node_Id)\n       is\n-         Formal_Type  : constant Entity_Id :=\n-                          Etype (First_Formal (Entity (Subprog)));\n+         Control      : constant Entity_Id := First_Formal (Entity (Subprog));\n+         Formal_Type  : constant Entity_Id := Etype (Control);\n          First_Actual : Node_Id;\n \n       begin\n@@ -5716,6 +5780,19 @@ package body Sem_Ch4 is\n          elsif Is_Access_Type (Formal_Type)\n            and then not Is_Access_Type (Etype (Obj))\n          then\n+            --  A special case: A.all'access is illegal if A is an access to a\n+            --  constant and the context requires an access to a variable.\n+\n+            if not Is_Access_Constant (Formal_Type) then\n+               if (Nkind (Obj) = N_Explicit_Dereference\n+                    and then Is_Access_Constant (Etype (Prefix (Obj))))\n+                 or else not Is_Variable (Obj)\n+               then\n+                  Error_Msg_NE\n+                    (\"actual for& must be a variable\", Obj, Control);\n+               end if;\n+            end if;\n+\n             Rewrite (First_Actual,\n               Make_Attribute_Reference (Loc,\n                 Attribute_Name => Name_Access,\n@@ -6288,10 +6365,10 @@ package body Sem_Ch4 is\n          --  must be identical, and the kind of call indicates the expected\n          --  kind of operation (function or procedure). If the type is a\n          --  (tagged) synchronized type, the primitive ops are attached to the\n-         --  corresponding record type.\n+         --  corresponding record (base) type.\n \n          if Is_Concurrent_Type (Obj_Type) then\n-            Corr_Type := Corresponding_Record_Type (Obj_Type);\n+            Corr_Type := Base_Type (Corresponding_Record_Type (Obj_Type));\n             Elmt := First_Elmt (Primitive_Operations (Corr_Type));\n \n          elsif not Is_Generic_Type (Obj_Type) then\n@@ -6480,4 +6557,30 @@ package body Sem_Ch4 is\n       end if;\n    end Try_Object_Operation;\n \n+   ---------\n+   -- wpo --\n+   ---------\n+\n+   procedure wpo (T : Entity_Id) is\n+      Op : Entity_Id;\n+      E  : Elmt_Id;\n+\n+   begin\n+      if not Is_Tagged_Type (T) then\n+         return;\n+      end if;\n+\n+      E := First_Elmt (Primitive_Operations (Base_Type (T)));\n+      while Present (E) loop\n+         Op := Node (E);\n+         Write_Int (Int (Op));\n+         Write_Str (\" === \");\n+         Write_Name (Chars (Op));\n+         Write_Str (\" in \");\n+         Write_Name (Chars (Scope (Op)));\n+         Next_Elmt (E);\n+         Write_Eol;\n+      end loop;\n+   end wpo;\n+\n end Sem_Ch4;"}]}