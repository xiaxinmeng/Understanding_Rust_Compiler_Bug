{"sha": "55015e590fc5f020107c467ae62166f5ec10a52b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUwMTVlNTkwZmM1ZjAyMDEwN2M0NjdhZTYyMTY2ZjVlYzEwYTUyYg==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2015-10-27T14:29:31Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2015-10-27T14:29:31Z"}, "message": "Properly handle -fno-plt in ix86_expand_call\n\nprepare_call_address in calls.c is the wrong place to handle -fno-plt.\nWe shoudn't force function address into register and hope that load\nfunction address via GOT and indirect call via register will be folded\ninto indirect call via GOT, which doesn't always happen.  Also non-PIC\ncase can only be handled in backend.  Instead, backend should expand\nexternal function call into indirect call via GOT for -fno-plt.\n\nThis patch reverts -fno-plt in prepare_call_address and handles it in\nix86_expand_call.  Other backends may need similar changes to support\n-fno-plt.  Alternately, we can introduce a target hook to indicate\nwhether an external function should be called via register for -fno-plt\nso that i386 backend can disable it in prepare_call_address.\n\ngcc/\n\n\tPR target/67215\n\t* calls.c (prepare_call_address): Don't handle -fno-plt here.\n\t* config/i386/i386.c (ix86_expand_call): Generate indirect call\n\tvia GOT for -fno-plt.  Support indirect call via GOT for x32.\n\t* config/i386/predicates.md (sibcall_memory_operand): Allow\n\tGOT memory operand.\n\ngcc/testsuite/\n\n\tPR target/67215\n\t* gcc.target/i386/pr67215-1.c: New test.\n\t* gcc.target/i386/pr67215-2.c: Likewise.\n\t* gcc.target/i386/pr67215-3.c: Likewise.\n\nFrom-SVN: r229444", "tree": {"sha": "7857a8fb40fac9dc1241869f80d69f38b3cba602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7857a8fb40fac9dc1241869f80d69f38b3cba602"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55015e590fc5f020107c467ae62166f5ec10a52b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55015e590fc5f020107c467ae62166f5ec10a52b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55015e590fc5f020107c467ae62166f5ec10a52b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55015e590fc5f020107c467ae62166f5ec10a52b/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "23a372296360f366e385c187c70a34b97cede2ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23a372296360f366e385c187c70a34b97cede2ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23a372296360f366e385c187c70a34b97cede2ab"}], "stats": {"total": 159, "additions": 130, "deletions": 29}, "files": [{"sha": "2891da7e34a29e140be70b30482f6ba189b59c1e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55015e590fc5f020107c467ae62166f5ec10a52b", "patch": "@@ -1,3 +1,12 @@\n+2015-10-27  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/67215\n+\t* calls.c (prepare_call_address): Don't handle -fno-plt here.\n+\t* config/i386/i386.c (ix86_expand_call): Generate indirect call\n+\tvia GOT for -fno-plt.  Support indirect call via GOT for x32.\n+\t* config/i386/predicates.md (sibcall_memory_operand): Allow\n+\tGOT memory operand.\n+\n 2015-10-27  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68104"}, {"sha": "68c4eb56611be5b0ba64b1c03efd879109207b24", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=55015e590fc5f020107c467ae62166f5ec10a52b", "patch": "@@ -203,18 +203,6 @@ prepare_call_address (tree fndecl_or_type, rtx funexp, rtx static_chain_value,\n \t       && targetm.small_register_classes_for_mode_p (FUNCTION_MODE))\n \t      ? force_not_mem (memory_address (FUNCTION_MODE, funexp))\n \t      : memory_address (FUNCTION_MODE, funexp));\n-  else if (flag_pic\n-\t   && fndecl_or_type\n-\t   && TREE_CODE (fndecl_or_type) == FUNCTION_DECL\n-\t   && (!flag_plt\n-\t       || lookup_attribute (\"noplt\", DECL_ATTRIBUTES (fndecl_or_type)))\n-\t   && !targetm.binds_local_p (fndecl_or_type))\n-    {\n-      /* This is done only for PIC code.  There is no easy interface to force the\n-\t function address into GOT for non-PIC case.  non-PIC case needs to be\n-\t handled specially by the backend.  */\n-      funexp = force_reg (Pmode, funexp);\n-    }\n   else if (! sibcallp)\n     {\n       if (!NO_FUNCTION_CSE && optimize && ! flag_no_function_cse)"}, {"sha": "d05c8f8493a889e6d949a4ab50e73d188a9b253f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 55, "deletions": 16, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=55015e590fc5f020107c467ae62166f5ec10a52b", "patch": "@@ -26753,21 +26753,54 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       /* Static functions and indirect calls don't need the pic register.  Also,\n \t check if PLT was explicitly avoided via no-plt or \"noplt\" attribute, making\n \t it an indirect call.  */\n+      rtx addr = XEXP (fnaddr, 0);\n       if (flag_pic\n-\t  && (!TARGET_64BIT\n-\t      || (ix86_cmodel == CM_LARGE_PIC\n-\t\t  && DEFAULT_ABI != MS_ABI))\n-\t  && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n-\t  && !SYMBOL_REF_LOCAL_P (XEXP (fnaddr, 0))\n-\t  && flag_plt\n-\t  && (SYMBOL_REF_DECL ((XEXP (fnaddr, 0))) == NULL_TREE\n-\t      || !lookup_attribute (\"noplt\",\n-\t\t     DECL_ATTRIBUTES (SYMBOL_REF_DECL (XEXP (fnaddr, 0))))))\n+\t  && GET_CODE (addr) == SYMBOL_REF\n+\t  && !SYMBOL_REF_LOCAL_P (addr))\n \t{\n-\t  use_reg (&use, gen_rtx_REG (Pmode, REAL_PIC_OFFSET_TABLE_REGNUM));\n-\t  if (ix86_use_pseudo_pic_reg ())\n-\t    emit_move_insn (gen_rtx_REG (Pmode, REAL_PIC_OFFSET_TABLE_REGNUM),\n-\t\t\t    pic_offset_table_rtx);\n+\t  if (flag_plt\n+\t      && (SYMBOL_REF_DECL (addr) == NULL_TREE\n+\t\t  || !lookup_attribute (\"noplt\",\n+\t\t\t\t\tDECL_ATTRIBUTES (SYMBOL_REF_DECL (addr)))))\n+\t    {\n+\t      if (!TARGET_64BIT\n+\t\t  || (ix86_cmodel == CM_LARGE_PIC\n+\t\t      && DEFAULT_ABI != MS_ABI))\n+\t\t{\n+\t\t  use_reg (&use, gen_rtx_REG (Pmode,\n+\t\t\t\t\t      REAL_PIC_OFFSET_TABLE_REGNUM));\n+\t\t  if (ix86_use_pseudo_pic_reg ())\n+\t\t    emit_move_insn (gen_rtx_REG (Pmode,\n+\t\t\t\t\t\t REAL_PIC_OFFSET_TABLE_REGNUM),\n+\t\t\t\t    pic_offset_table_rtx);\n+\t\t}\n+\t    }\n+\t  else if (!TARGET_PECOFF && !TARGET_MACHO)\n+\t    {\n+\t      if (TARGET_64BIT)\n+\t\t{\n+\t\t  fnaddr = gen_rtx_UNSPEC (Pmode,\n+\t\t\t\t\t   gen_rtvec (1, addr),\n+\t\t\t\t\t   UNSPEC_GOTPCREL);\n+\t\t  fnaddr = gen_rtx_CONST (Pmode, fnaddr);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fnaddr = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr),\n+\t\t\t\t\t   UNSPEC_GOT);\n+\t\t  fnaddr = gen_rtx_CONST (Pmode, fnaddr);\n+\t\t  fnaddr = gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n+\t\t\t\t\t fnaddr);\n+\t\t}\n+\t      fnaddr = gen_const_mem (Pmode, fnaddr);\n+\t      /* Pmode may not be the same as word_mode for x32, which\n+\t\t doesn't support indirect branch via 32-bit memory slot.\n+\t\t Since x32 GOT slot is 64 bit with zero upper 32 bits,\n+\t\t indirect branch via x32 GOT slot is OK.  */\n+\t      if (GET_MODE (fnaddr) != word_mode)\n+\t\tfnaddr = gen_rtx_ZERO_EXTEND (word_mode, fnaddr);\n+\t      fnaddr = gen_rtx_MEM (QImode, fnaddr);\n+\t    }\n \t}\n     }\n \n@@ -26789,9 +26822,15 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       && GET_CODE (XEXP (fnaddr, 0)) == SYMBOL_REF\n       && !local_symbolic_operand (XEXP (fnaddr, 0), VOIDmode))\n     fnaddr = gen_rtx_MEM (QImode, construct_plt_address (XEXP (fnaddr, 0)));\n-  else if (sibcall\n-\t   ? !sibcall_insn_operand (XEXP (fnaddr, 0), word_mode)\n-\t   : !call_insn_operand (XEXP (fnaddr, 0), word_mode))\n+  /* Since x32 GOT slot is 64 bit with zero upper 32 bits, indirect\n+     branch via x32 GOT slot is OK.  */\n+  else if (!(TARGET_X32\n+\t     && MEM_P (fnaddr)\n+\t     && GET_CODE (XEXP (fnaddr, 0)) == ZERO_EXTEND\n+\t     && GOT_memory_operand (XEXP (XEXP (fnaddr, 0), 0), Pmode))\n+\t   && (sibcall\n+\t       ? !sibcall_insn_operand (XEXP (fnaddr, 0), word_mode)\n+\t       : !call_insn_operand (XEXP (fnaddr, 0), word_mode)))\n     {\n       fnaddr = convert_to_mode (word_mode, XEXP (fnaddr, 0), 1);\n       fnaddr = gen_rtx_MEM (QImode, copy_to_mode_reg (word_mode, fnaddr));"}, {"sha": "1595142255da8d264e1606503327cf72f5e70a8d", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=55015e590fc5f020107c467ae62166f5ec10a52b", "patch": "@@ -599,7 +599,12 @@\n ;; Return true if OP is a memory operands that can be used in sibcalls.\n (define_predicate \"sibcall_memory_operand\"\n   (and (match_operand 0 \"memory_operand\")\n-       (match_test \"CONSTANT_P (XEXP (op, 0))\")))\n+       (match_test \"CONSTANT_P (XEXP (op, 0))\n+\t\t    || (GET_CODE (XEXP (op, 0)) == PLUS\n+\t\t\t&& REG_P (XEXP (XEXP (op, 0), 0))\n+\t\t\t&& GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST\n+\t\t\t&& GET_CODE (XEXP (XEXP (XEXP (op, 0), 1), 0)) == UNSPEC\n+\t\t\t&& XINT (XEXP (XEXP (XEXP (op, 0), 1), 0), 1) == UNSPEC_GOT)\")))\n \n ;; Test for a valid operand for a call instruction.\n ;; Allow constant call address operands in Pmode only."}, {"sha": "e338762a5e6b61e816d51e0f3f6947876a19da39", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=55015e590fc5f020107c467ae62166f5ec10a52b", "patch": "@@ -1,3 +1,10 @@\n+2015-10-27  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/67215\n+\t* gcc.target/i386/pr67215-1.c: New test.\n+\t* gcc.target/i386/pr67215-2.c: Likewise.\n+\t* gcc.target/i386/pr67215-3.c: Likewise.\n+\n 2015-10-27  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68104"}, {"sha": "fd37f8e63db9858cad2e5c5e821a20e326b62f12", "filename": "gcc/testsuite/gcc.target/i386/pr67215-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67215-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67215-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67215-1.c?ref=55015e590fc5f020107c467ae62166f5ec10a52b", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpic -fno-plt\" } */\n+\n+extern char* bar (int);\n+extern char* arr[32];\n+\n+void\n+foo (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = bar (128);\n+}\n+\n+/* { dg-final { scan-assembler \"call\\[ \\t\\]*.bar@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"call\\[ \\t\\]*.bar@GOT\\\\(\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"mov(l|q)\\[ \\t\\]*.bar@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]*.bar@GOT\\\\(\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"call\\[ \\t\\]*.bar@PLT\" } } */"}, {"sha": "ebf2919078c4dab981a0ac1e046d4f4dd491f18a", "filename": "gcc/testsuite/gcc.target/i386/pr67215-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67215-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67215-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67215-2.c?ref=55015e590fc5f020107c467ae62166f5ec10a52b", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpic\" } */\n+\n+extern char* bar (int) __attribute__ ((noplt));\n+extern char* arr[32];\n+\n+void\n+foo (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 32; i++)\n+    arr[i] = bar (128);\n+}\n+\n+/* { dg-final { scan-assembler \"call\\[ \\t\\]*.bar@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"call\\[ \\t\\]*.bar@GOT\\\\(\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"mov(l|q)\\[ \\t\\]*.bar@GOTPCREL\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]*.bar@GOT\\\\(\" { target ia32 } } } */\n+/* { dg-final { scan-assembler-not \"call\\[ \\t\\]*.bar@PLT\" } } */"}, {"sha": "eb6bb395f10a14323be106e3dcd7f23cd735c37f", "filename": "gcc/testsuite/gcc.target/i386/pr67215-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67215-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55015e590fc5f020107c467ae62166f5ec10a52b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67215-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr67215-3.c?ref=55015e590fc5f020107c467ae62166f5ec10a52b", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fpic -fno-plt -fdump-rtl-expand\" } */\n+\n+extern int bar (void);\n+\n+int\n+foo (void)\n+{\n+  return bar ();\n+}\n+\n+/* { dg-final { scan-rtl-dump \"\\\\(call \\\\(mem:QI \\\\(mem/u/c:\" \"expand\" { target { ! x32 } } } } */\n+/* { dg-final { scan-rtl-dump \"\\\\(call \\\\(mem:QI \\\\(zero_extend:DI \\\\(mem/u/c:\" \"expand\" { target x32 } } } */"}]}