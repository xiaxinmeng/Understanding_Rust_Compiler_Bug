{"sha": "b38f3813f7ba380b33607e114a7efa9901191924", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM4ZjM4MTNmN2JhMzgwYjMzNjA3ZTExNGE3ZWZhOTkwMTE5MTkyNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-08-16T18:40:57Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-08-16T18:40:57Z"}, "message": "re PR middle-end/20548 (ACATS c52103x c52104x c52104y segfault)\n\n\tPR ada/20548\n\t* common.opt (-fstack-check): Do not declare the variable here.\n\t(-fstack-check=): New option variant.\n\t* doc/invoke.texi (Code Gen Options): Document it.\n\t* expr.h (STACK_OLD_CHECK_PROTECT): New macro.\n\t(STACK_CHECK_PROTECT): Bump to 3 pages if DWARF-2 EH is used.\n\t(STACK_CHECK_STATIC_BUILTIN): New macro.\n\t* doc/tm.texi (Stack Checking): Document STACK_CHECK_STATIC_BUILTIN.\n\t* opts.c: Include expr.h.\n\t(common_handle_option) <OPT_fold_stack_check_>: New case.\n\t<OPT_fstack_check>: Likewise.\n\t* calls.c (initialize_argument_information): Use TYPE_SIZE_UNIT\n\tconsistently in the test for variable-sized types.  Adjust for\n\tnew behaviour of flag_stack_check.\n\t* explow.c: Include except.h.\n\t(allocate_dynamic_stack_space): Do not take into account\n\tSTACK_CHECK_MAX_FRAME_SIZE for static builtin stack checking.\n\t* function.c (gimplify_parameters): Use DECL_SIZE_UNIT in the test\n\tfor variable-sized parameters.  Treat all parameters whose size is\n\tgreater than STACK_CHECK_MAX_VAR_SIZE as variable-sized if generic\n\tstack checking is enabled.\n\t* gimplify.c (gimplify_decl_expr): Treat non-static objects whose\n\tsize is greater than STACK_CHECK_MAX_VAR_SIZE as variable-sized\n\tif generic stack checking is enabled.\n\t(expand_function_end): Adjust for new behaviour of flag_stack_check.\n\t* reload1.c (reload): Likewise.\n\t* stmt.c (expand_decl): Assert that all automatic variables have\n\tfixed size at this point and remove dead code.\n\t* flags.h (stack_check_type): New enumeration type.\n\t(flag_stack_check): Declare.\n\t* toplev.c (flag_stack_check): New global variable.\n\t* Makefile.in (opts.o): Add dependency on EXPR_H.\n\t(explow.o): Add dependency on except.h.\nada/\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use DECL_SIZE_UNIT in the\n\tsetjmp test consistently.  Adjust for new behaviour of flag_stack_check.\n\t* gcc-interface/utils2.c (build_call_alloc_dealloc): Remove redundant\n\ttest of flag_stack_check.  Adjust for new behaviour of flag_stack_check.\n\nFrom-SVN: r139159", "tree": {"sha": "4ab818c332a67c5a5e24c9d78cedd1099ebc04e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ab818c332a67c5a5e24c9d78cedd1099ebc04e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b38f3813f7ba380b33607e114a7efa9901191924", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38f3813f7ba380b33607e114a7efa9901191924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38f3813f7ba380b33607e114a7efa9901191924", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38f3813f7ba380b33607e114a7efa9901191924/comments", "author": null, "committer": null, "parents": [{"sha": "6c397102b275823c0d8ffb02ab7d74bb38ede5a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c397102b275823c0d8ffb02ab7d74bb38ede5a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c397102b275823c0d8ffb02ab7d74bb38ede5a9"}], "stats": {"total": 328, "additions": 233, "deletions": 95}, "files": [{"sha": "faa92264ee7cc20c84dcf974fe56062e64036de6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -1,3 +1,39 @@\n+2008-08-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/20548\n+\t* common.opt (-fstack-check): Do not declare the variable here.\n+\t(-fstack-check=): New option variant.\n+\t* doc/invoke.texi (Code Gen Options): Document it.\n+\t* expr.h (STACK_OLD_CHECK_PROTECT): New macro.\n+\t(STACK_CHECK_PROTECT): Bump to 3 pages if DWARF-2 EH is used.\n+\t(STACK_CHECK_STATIC_BUILTIN): New macro.\n+\t* doc/tm.texi (Stack Checking): Document STACK_CHECK_STATIC_BUILTIN.\n+\t* opts.c: Include expr.h.\n+\t(common_handle_option) <OPT_fold_stack_check_>: New case.\n+\t<OPT_fstack_check>: Likewise.\n+\t* calls.c (initialize_argument_information): Use TYPE_SIZE_UNIT\n+\tconsistently in the test for variable-sized types.  Adjust for\n+\tnew behaviour of flag_stack_check.\n+\t* explow.c: Include except.h.\n+\t(allocate_dynamic_stack_space): Do not take into account\n+\tSTACK_CHECK_MAX_FRAME_SIZE for static builtin stack checking.\n+\t* function.c (gimplify_parameters): Use DECL_SIZE_UNIT in the test\n+\tfor variable-sized parameters.  Treat all parameters whose size is\n+\tgreater than STACK_CHECK_MAX_VAR_SIZE as variable-sized if generic\n+\tstack checking is enabled.\n+\t* gimplify.c (gimplify_decl_expr): Treat non-static objects whose\n+\tsize is greater than STACK_CHECK_MAX_VAR_SIZE as variable-sized\n+\tif generic stack checking is enabled.\n+\t(expand_function_end): Adjust for new behaviour of flag_stack_check.\n+\t* reload1.c (reload): Likewise.\n+\t* stmt.c (expand_decl): Assert that all automatic variables have\n+\tfixed size at this point and remove dead code.\n+\t* flags.h (stack_check_type): New enumeration type.\n+\t(flag_stack_check): Declare.\n+\t* toplev.c (flag_stack_check): New global variable.\n+\t* Makefile.in (opts.o): Add dependency on EXPR_H.\n+\t(explow.o): Add dependency on except.h.\n+\n 2008-08-16  Andy Hutchinson  <hutchinsonandy@aim.com>\n \n \t* config/avr/avr.c (avr_override_options): Reduce value of "}, {"sha": "3c6318ee69415c3766d0807164c3bbce478a45fe", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -2392,7 +2392,7 @@ diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) version.h $(TM_P_H) $(FLAGS_H) $(INPUT_H) $(TOPLEV_H) intl.h \\\n    $(DIAGNOSTIC_H) langhooks.h $(LANGHOOKS_DEF_H) diagnostic.def opts.h\n opts.o : opts.c opts.h options.h $(TOPLEV_H) $(CONFIG_H) $(SYSTEM_H) \\\n-   coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(RTL_H) \\\n+   coretypes.h $(TREE_H) $(TM_H) langhooks.h $(GGC_H) $(EXPR_H) $(RTL_H) \\\n    output.h $(DIAGNOSTIC_H) $(TM_P_H) $(INSN_ATTR_H) intl.h $(TARGET_H) \\\n    $(FLAGS_H) $(PARAMS_H) tree-pass.h $(DBGCNT_H) debug.h varray.h\n opts-common.o : opts-common.c opts.h $(CONFIG_H) $(SYSTEM_H) \\\n@@ -2495,7 +2495,7 @@ expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_\n    $(TOPLEV_H) $(TM_P_H) langhooks.h $(DF_H) $(TARGET_H)\n explow.o : explow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(FLAGS_H) hard-reg-set.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) \\\n-   $(TOPLEV_H) $(FUNCTION_H) $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h \\\n+   $(TOPLEV_H) except.h $(FUNCTION_H) $(GGC_H) $(TM_P_H) langhooks.h gt-explow.h \\\n    $(TARGET_H) output.h\n optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) insn-config.h $(EXPR_H) $(OPTABS_H) libfuncs.h \\"}, {"sha": "14abbe489aceea738d7fb8d4d1d6acb2bf74e9ce", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -1,3 +1,11 @@\n+2008-08-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/20548\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Use DECL_SIZE_UNIT in the\n+\tsetjmp test consistently.  Adjust for new behaviour of flag_stack_check.\n+\t* gcc-interface/utils2.c (build_call_alloc_dealloc): Remove redundant\n+\ttest of flag_stack_check.  Adjust for new behaviour of flag_stack_check.\n+\n 2008-08-13  Samuel Tardieu  <sam@rfc1149.net>\n \n \tPR ada/36777"}, {"sha": "65dd02e78349aaf9ce88923f0486d82e39c9a911", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -1303,12 +1303,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      }\n \t  }\n \n-\tif (definition && DECL_SIZE (gnu_decl)\n+\tif (definition && DECL_SIZE_UNIT (gnu_decl)\n \t    && get_block_jmpbuf_decl ()\n-\t    && (TREE_CODE (DECL_SIZE (gnu_decl)) != INTEGER_CST\n-\t\t|| (flag_stack_check && !STACK_CHECK_BUILTIN\n-\t\t    && 0 < compare_tree_int (DECL_SIZE_UNIT (gnu_decl),\n-\t\t\t\t\t     STACK_CHECK_MAX_VAR_SIZE))))\n+\t    && (TREE_CODE (DECL_SIZE_UNIT (gnu_decl)) != INTEGER_CST\n+\t\t|| (flag_stack_check == GENERIC_STACK_CHECK\n+\t\t    && compare_tree_int (DECL_SIZE_UNIT (gnu_decl),\n+\t\t\t\t\t STACK_CHECK_MAX_VAR_SIZE) > 0)))\n \t  add_stmt_with_node (build_call_1_expr\n \t\t\t      (update_setjmp_buf_decl,\n \t\t\t       build_unary_op (ADDR_EXPR, NULL_TREE,"}, {"sha": "5077e640121f34e154d5ebd31970525a9a445977", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -1920,11 +1920,11 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n   /* ??? For now, disable variable-sized allocators in the stack since\n      we can't yet gimplify an ALLOCATE_EXPR.  */\n   else if (gnat_pool == -1\n-\t   && TREE_CODE (gnu_size) == INTEGER_CST && !flag_stack_check)\n+\t   && TREE_CODE (gnu_size) == INTEGER_CST\n+\t   && flag_stack_check != GENERIC_STACK_CHECK)\n     {\n       /* If the size is a constant, we can put it in the fixed portion of\n \t the stack frame to avoid the need to adjust the stack pointer.  */\n-      if (TREE_CODE (gnu_size) == INTEGER_CST && !flag_stack_check)\n \t{\n \t  tree gnu_range\n \t    = build_range_type (NULL_TREE, size_one_node, gnu_size);\n@@ -1937,9 +1937,8 @@ build_call_alloc_dealloc (tree gnu_obj, tree gnu_size, unsigned align,\n \t  return convert (ptr_void_type_node,\n \t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE, gnu_decl));\n \t}\n-      else\n-\tgcc_unreachable ();\n #if 0\n+      else\n \treturn build2 (ALLOCATE_EXPR, ptr_void_type_node, gnu_size, gnu_align);\n #endif\n     }"}, {"sha": "3f3224455601a6eeeed93e1ffdaab2c8b811db53", "filename": "gcc/calls.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -1069,10 +1069,10 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t      rtx copy;\n \n \t      if (!COMPLETE_TYPE_P (type)\n-\t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST\n-\t\t  || (flag_stack_check && ! STACK_CHECK_BUILTIN\n-\t\t      && (0 < compare_tree_int (TYPE_SIZE_UNIT (type),\n-\t\t\t\t\t\tSTACK_CHECK_MAX_VAR_SIZE))))\n+\t\t  || TREE_CODE (TYPE_SIZE_UNIT (type)) != INTEGER_CST\n+\t\t  || (flag_stack_check == GENERIC_STACK_CHECK\n+\t\t      && compare_tree_int (TYPE_SIZE_UNIT (type),\n+\t\t\t\t\t   STACK_CHECK_MAX_VAR_SIZE) > 0))\n \t\t{\n \t\t  /* This is a variable-sized object.  Make space on the stack\n \t\t     for it.  */"}, {"sha": "bad670903e3f0c1ff8783c14abe83e535515b1df", "filename": "gcc/common.opt", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -992,11 +992,13 @@ fvariable-expansion-in-unroller\n Common Report Var(flag_variable_expansion_in_unroller) Optimization\n Apply variable expansion when loops are unrolled\n \n-; Emit code to probe the stack, to help detect stack overflow; also\n-; may cause large objects to be allocated dynamically.\n+fstack-check=\n+Common Report RejectNegative Joined\n+-fstack-check=[no|generic|specific]\tInsert stack checking code into the program\n+\n fstack-check\n-Common Report Var(flag_stack_check)\n-Insert stack checking code into the program\n+Common Report\n+Insert stack checking code into the program.  Same as -fstack-check=specific\n \n fstack-limit\n Common"}, {"sha": "40c3df16594ea50715997416f6167559632673d7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -15207,8 +15207,34 @@ a single-threaded environment since stack overflow is automatically\n detected on nearly all systems if there is only one stack.\n \n Note that this switch does not actually cause checking to be done; the\n-operating system must do that.  The switch causes generation of code\n-to ensure that the operating system sees the stack being extended.\n+operating system or the language runtime must do that.  The switch causes\n+generation of code to ensure that they see the stack being extended.\n+\n+You can additionally specify a string parameter: @code{no} means no\n+checking, @code{generic} means force the use of old-style checking,\n+@code{specific} means use the best checking method and is equivalent\n+to bare @option{-fstack-check}.\n+\n+Old-style checking is a generic mechanism that requires no specific\n+target support in the compiler but comes with the following drawbacks:\n+\n+@enumerate\n+@item\n+Modified allocation strategy for large objects: they will always be\n+allocated dynamically if their size exceeds a fixed threshold.\n+\n+@item\n+Fixed limit on the size of the static frame of functions: when it is\n+topped by a particular function, stack checking is not reliable and\n+a warning is issued by the compiler.\n+\n+@item\n+Inefficiency: because of both the modified allocation strategy and the\n+generic implementation, the performances of the code are hampered.\n+@end enumerate\n+\n+Note that old-style stack checking is also the fallback method for\n+@code{specific} if no target support has been added in the compiler.\n \n @item -fstack-limit-register=@var{reg}\n @itemx -fstack-limit-symbol=@var{sym}"}, {"sha": "9b4a921883f402a3e8d7e648d2fd93dea3b01805", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -3376,38 +3376,49 @@ linkage is necessary.  The default is @code{0}.\n @node Stack Checking\n @subsection Specifying How Stack Checking is Done\n \n-GCC will check that stack references are within the boundaries of\n-the stack, if the @option{-fstack-check} is specified, in one of three ways:\n+GCC will check that stack references are within the boundaries of the\n+stack, if the option @option{-fstack-check} is specified, in one of\n+three ways:\n \n @enumerate\n @item\n If the value of the @code{STACK_CHECK_BUILTIN} macro is nonzero, GCC\n-will assume that you have arranged for stack checking to be done at\n-appropriate places in the configuration files, e.g., in\n-@code{TARGET_ASM_FUNCTION_PROLOGUE}.  GCC will do not other special\n-processing.\n+will assume that you have arranged for full stack checking to be done\n+at appropriate places in the configuration files.  GCC will not do\n+other special processing.\n \n @item\n-If @code{STACK_CHECK_BUILTIN} is zero and you defined a named pattern\n-called @code{check_stack} in your @file{md} file, GCC will call that\n-pattern with one argument which is the address to compare the stack\n-value against.  You must arrange for this pattern to report an error if\n-the stack pointer is out of range.\n+If @code{STACK_CHECK_BUILTIN} is zero and the value of the\n+@code{STACK_CHECK_STATIC_BUILTIN} macro is nonzero, GCC will assume\n+that you have arranged for static stack checking (checking of the\n+static stack frame of functions) to be done at appropriate places\n+in the configuration files.  GCC will only emit code to do dynamic\n+stack checking (checking on dynamic stack allocations) using the third\n+approach below.\n \n @item\n If neither of the above are true, GCC will generate code to periodically\n ``probe'' the stack pointer using the values of the macros defined below.\n @end enumerate\n \n-Normally, you will use the default values of these macros, so GCC\n-will use the third approach.\n+If neither STACK_CHECK_BUILTIN nor STACK_CHECK_STATIC_BUILTIN is defined,\n+GCC will change its allocation strategy for large objects if the option\n+@option{-fstack-check} is specified: they will always be allocated\n+dynamically if their size exceeds @code{STACK_CHECK_MAX_VAR_SIZE} bytes.\n \n @defmac STACK_CHECK_BUILTIN\n A nonzero value if stack checking is done by the configuration files in a\n machine-dependent manner.  You should define this macro if stack checking\n-is require by the ABI of your machine or if you would like to have to stack\n-checking in some more efficient way than GCC's portable approach.\n-The default value of this macro is zero.\n+is require by the ABI of your machine or if you would like to do stack\n+checking in some more efficient way than the generic approach.  The default\n+value of this macro is zero.\n+@end defmac\n+\n+@defmac STACK_CHECK_STATIC_BUILTIN\n+A nonzero value if static stack checking is done by the configuration files\n+in a machine-dependent manner.  You should define this macro if you would\n+like to do static stack checking in some more efficient way than the generic\n+approach.  The default value of this macro is zero.\n @end defmac\n \n @defmac STACK_CHECK_PROBE_INTERVAL\n@@ -3418,7 +3429,7 @@ default value of 4096 is suitable for most systems.\n @end defmac\n \n @defmac STACK_CHECK_PROBE_LOAD\n-A integer which is nonzero if GCC should perform the stack probe\n+An integer which is nonzero if GCC should perform the stack probe\n as a load instruction and zero if GCC should use a store instruction.\n The default is zero, which is the most efficient choice on most systems.\n @end defmac\n@@ -3429,6 +3440,10 @@ for languages where such a recovery is supported.  The default value of\n 75 words should be adequate for most machines.\n @end defmac\n \n+The following macros are relevant only if neither STACK_CHECK_BUILTIN\n+nor STACK_CHECK_STATIC_BUILTIN is defined; you can omit them altogether\n+in the opposite case.\n+\n @defmac STACK_CHECK_MAX_FRAME_SIZE\n The maximum size of a stack frame, in bytes.  GCC will generate probe\n instructions in non-leaf functions to ensure at least this many bytes of"}, {"sha": "a1f76506023326ab6fcac8f4f04f7b2e578f4929", "filename": "gcc/explow.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree.h\"\n #include \"tm_p.h\"\n #include \"flags.h\"\n+#include \"except.h\"\n #include \"function.h\"\n #include \"expr.h\"\n #include \"optabs.h\"\n@@ -1190,10 +1191,13 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n   gcc_assert (!(stack_pointer_delta\n \t\t% (PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT)));\n \n-  /* If needed, check that we have the required amount of stack.  Take into\n-     account what has already been checked.  */\n-  if (flag_stack_check && ! STACK_CHECK_BUILTIN)\n-    probe_stack_range (STACK_CHECK_MAX_FRAME_SIZE + STACK_CHECK_PROTECT, size);\n+  /* If needed, check that we have the required amount of stack.\n+     Take into account what has already been checked.  */\n+  if (flag_stack_check == GENERIC_STACK_CHECK)\n+    probe_stack_range (STACK_OLD_CHECK_PROTECT + STACK_CHECK_MAX_FRAME_SIZE,\n+\t\t       size);\n+  else if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n+    probe_stack_range (STACK_CHECK_PROTECT, size);\n \n   /* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */\n   if (target == 0 || !REG_P (target)"}, {"sha": "29b1f3e931256b65279d1d836d40897d93c282c5", "filename": "gcc/expr.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -208,10 +208,16 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* Provide default values for the macros controlling stack checking.  */\n \n+/* The default is neither full builtin stack checking...  */\n #ifndef STACK_CHECK_BUILTIN\n #define STACK_CHECK_BUILTIN 0\n #endif\n \n+/* ...nor static builtin stack checking.  */\n+#ifndef STACK_CHECK_STATIC_BUILTIN\n+#define STACK_CHECK_STATIC_BUILTIN 0\n+#endif\n+\n /* The default interval is one page.  */\n #ifndef STACK_CHECK_PROBE_INTERVAL\n #define STACK_CHECK_PROBE_INTERVAL 4096\n@@ -222,9 +228,24 @@ do {\t\t\t\t\t\t\t\t\\\n #define STACK_CHECK_PROBE_LOAD 0\n #endif\n \n-/* This value is arbitrary, but should be sufficient for most machines.  */\n+/* This is a kludge to try to capture the discrepancy between the old\n+   mechanism (generic stack checking) and the new mechanism (static\n+   builtin stack checking).  STACK_CHECK_PROTECT needs to be bumped\n+   for the latter because part of the protection area is effectively\n+   included in STACK_CHECK_MAX_FRAME_SIZE for the former.  */\n+#ifdef STACK_CHECK_PROTECT\n+#define STACK_OLD_CHECK_PROTECT STACK_CHECK_PROTECT\n+#else\n+#define STACK_OLD_CHECK_PROTECT \\\n+ (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 8 * 1024)\n+#endif\n+\n+/* Minimum amount of stack required to recover from an anticipated stack\n+   overflow detection.  The default value conveys an estimate of the amount\n+   of stack required to propagate an exception.  */\n #ifndef STACK_CHECK_PROTECT\n-#define STACK_CHECK_PROTECT (75 * UNITS_PER_WORD)\n+#define STACK_CHECK_PROTECT \\\n+ (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 12 * 1024)\n #endif\n \n /* Make the maximum frame size be the largest we can and still only need"}, {"sha": "1de81f8e13b20d50b0b1061f1bc2aaff2c46093d", "filename": "gcc/flags.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -254,6 +254,27 @@ extern int flag_var_tracking;\n    warning message in case flag was set by -fprofile-{generate,use}.  */\n extern bool flag_speculative_prefetching_set;\n \n+/* Type of stack check.  */\n+enum stack_check_type\n+{\n+  /* Do not check the stack.  */\n+  NO_STACK_CHECK = 0,\n+\n+  /* Check the stack generically, i.e. assume no specific support\n+     from the target configuration files.  */\n+  GENERIC_STACK_CHECK,\n+\n+  /* Check the stack and rely on the target configuration files to\n+     check the static frame of functions, i.e. use the generic\n+     mechanism only for dynamic stack allocations.  */\n+  STATIC_BUILTIN_STACK_CHECK,\n+\n+  /* Check the stack and entirely rely on the target configuration\n+     files, i.e. do not use the generic mechanism at all.  */\n+  FULL_BUILTIN_STACK_CHECK\n+};\n+extern enum stack_check_type flag_stack_check;\n+\n /* Returns TRUE if generated code should match ABI version N or\n    greater is in use.  */\n "}, {"sha": "da26dc7d114ffb93113d3de111b002771e198c4c", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -3236,7 +3236,7 @@ gimplify_parameters (void)\n       walk_tree_without_duplicates (&data.passed_type,\n \t\t\t\t    gimplify_parm_type, &stmts);\n \n-      if (!TREE_CONSTANT (DECL_SIZE (parm)))\n+      if (TREE_CODE (DECL_SIZE_UNIT (parm)) != INTEGER_CST)\n \t{\n \t  gimplify_one_sizepos (&DECL_SIZE (parm), &stmts);\n \t  gimplify_one_sizepos (&DECL_SIZE_UNIT (parm), &stmts);\n@@ -3250,9 +3250,12 @@ gimplify_parameters (void)\n \t    {\n \t      tree local, t;\n \n-\t      /* For constant sized objects, this is trivial; for\n+\t      /* For constant-sized objects, this is trivial; for\n \t\t variable-sized objects, we have to play games.  */\n-\t      if (TREE_CONSTANT (DECL_SIZE (parm)))\n+\t      if (TREE_CODE (DECL_SIZE_UNIT (parm)) == INTEGER_CST\n+\t\t  && !(flag_stack_check == GENERIC_STACK_CHECK\n+\t\t       && compare_tree_int (DECL_SIZE_UNIT (parm),\n+\t\t\t\t\t    STACK_CHECK_MAX_VAR_SIZE) > 0))\n \t\t{\n \t\t  local = create_tmp_var (type, get_name (parm));\n \t\t  DECL_IGNORED_P (local) = 0;\n@@ -4480,18 +4483,18 @@ expand_function_end (void)\n   if (arg_pointer_save_area && ! crtl->arg_pointer_save_area_init)\n     get_arg_pointer_save_area ();\n \n-  /* If we are doing stack checking and this function makes calls,\n+  /* If we are doing generic stack checking and this function makes calls,\n      do a stack probe at the start of the function to ensure we have enough\n      space for another stack frame.  */\n-  if (flag_stack_check && ! STACK_CHECK_BUILTIN)\n+  if (flag_stack_check == GENERIC_STACK_CHECK)\n     {\n       rtx insn, seq;\n \n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \tif (CALL_P (insn))\n \t  {\n \t    start_sequence ();\n-\t    probe_stack_range (STACK_CHECK_PROTECT,\n+\t    probe_stack_range (STACK_OLD_CHECK_PROTECT,\n \t\t\t       GEN_INT (STACK_CHECK_MAX_FRAME_SIZE));\n \t    seq = get_insns ();\n \t    end_sequence ();"}, {"sha": "b0b5e78968de23812ff3ef4e432d523a28fa2b77", "filename": "gcc/gimplify.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -1447,7 +1447,11 @@ gimplify_decl_expr (tree *stmt_p, gimple_seq *seq_p)\n     {\n       tree init = DECL_INITIAL (decl);\n \n-      if (TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST)\n+      if (TREE_CODE (DECL_SIZE_UNIT (decl)) != INTEGER_CST\n+\t  || (!TREE_STATIC (decl)\n+\t      && flag_stack_check == GENERIC_STACK_CHECK\n+\t      && compare_tree_int (DECL_SIZE_UNIT (decl),\n+\t\t\t\t   STACK_CHECK_MAX_VAR_SIZE) > 0))\n \tgimplify_vla_decl (decl, seq_p);\n \n       if (init && init != error_mark_node)"}, {"sha": "7d582297eb6743ad8fcc2f0968521b465e70c623", "filename": "gcc/opts.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"expr.h\"\n #include \"ggc.h\"\n #include \"output.h\"\n #include \"langhooks.h\"\n@@ -1900,6 +1901,37 @@ common_handle_option (size_t scode, const char *arg, int value,\n       flag_sched_stalled_insns_dep = value;\n       break;\n \n+    case OPT_fstack_check_:\n+      if (!strcmp (arg, \"no\"))\n+\tflag_stack_check = NO_STACK_CHECK;\n+      else if (!strcmp (arg, \"generic\"))\n+\t/* This is the old stack checking method.  */\n+\tflag_stack_check = STACK_CHECK_BUILTIN\n+\t\t\t   ? FULL_BUILTIN_STACK_CHECK\n+\t\t\t   : GENERIC_STACK_CHECK;\n+      else if (!strcmp (arg, \"specific\"))\n+\t/* This is the new stack checking method.  */\n+\tflag_stack_check = STACK_CHECK_BUILTIN\n+\t\t\t   ? FULL_BUILTIN_STACK_CHECK\n+\t\t\t   : STACK_CHECK_STATIC_BUILTIN\n+\t\t\t     ? STATIC_BUILTIN_STACK_CHECK\n+\t\t\t     : GENERIC_STACK_CHECK;\n+      else\n+\twarning (0, \"unknown stack check parameter \\\"%s\\\"\", arg);\n+      break;\n+\n+    case OPT_fstack_check:\n+      /* This is the same as the \"specific\" mode above.  */\n+      if (value)\n+\tflag_stack_check = STACK_CHECK_BUILTIN\n+\t\t\t   ? FULL_BUILTIN_STACK_CHECK\n+\t\t\t   : STACK_CHECK_STATIC_BUILTIN\n+\t\t\t     ? STATIC_BUILTIN_STACK_CHECK\n+\t\t\t     : GENERIC_STACK_CHECK;\n+      else\n+\tflag_stack_check = NO_STACK_CHECK;\n+      break;\n+\n     case OPT_fstack_limit:\n       /* The real switch is -fno-stack-limit.  */\n       if (value)"}, {"sha": "3ee0fc37cfa95e31e011fe1f53407dd7e3ec289f", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -1301,9 +1301,9 @@ reload (rtx first, int global)\n \t  }\n       }\n \n-  /* If we are doing stack checking, give a warning if this function's\n-     frame size is larger than we expect.  */\n-  if (flag_stack_check && ! STACK_CHECK_BUILTIN)\n+  /* If we are doing generic stack checking, give a warning if this\n+     function's frame size is larger than we expect.  */\n+  if (flag_stack_check == GENERIC_STACK_CHECK)\n     {\n       HOST_WIDE_INT size = get_frame_size () + STACK_CHECK_FIXED_FRAME_SIZE;\n       static int verbose_warned = 0;"}, {"sha": "f05cd0956fcd8f087cc7e4dec826bf7be1085a43", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 41, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -1867,8 +1867,8 @@ expand_decl (tree decl)\n     SET_DECL_RTL (decl, gen_rtx_MEM (BLKmode, const0_rtx));\n \n   else if (DECL_SIZE (decl) == 0)\n-    /* Variable with incomplete type.  */\n     {\n+      /* Variable with incomplete type.  */\n       rtx x;\n       if (DECL_INITIAL (decl) == 0)\n \t/* Error message was already done; now avoid a crash.  */\n@@ -1899,16 +1899,15 @@ expand_decl (tree decl)\n \t\t\t  TYPE_ALIGN (TREE_TYPE (TREE_TYPE (decl))));\n     }\n \n-  else if (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST\n-\t   && ! (flag_stack_check && ! STACK_CHECK_BUILTIN\n-\t\t && 0 < compare_tree_int (DECL_SIZE_UNIT (decl),\n-\t\t\t\t\t  STACK_CHECK_MAX_VAR_SIZE)))\n+  else\n     {\n-      /* Variable of fixed size that goes on the stack.  */\n       rtx oldaddr = 0;\n       rtx addr;\n       rtx x;\n \n+      /* Variable-sized decls are dealt with in the gimplifier.  */\n+      gcc_assert (TREE_CODE (DECL_SIZE_UNIT (decl)) == INTEGER_CST);\n+\n       /* If we previously made RTL for this decl, it must be an array\n \t whose size was determined by the initializer.\n \t The old address was a register; set that register now\n@@ -1936,41 +1935,6 @@ expand_decl (tree decl)\n \t    emit_move_insn (oldaddr, addr);\n \t}\n     }\n-  else\n-    /* Dynamic-size object: must push space on the stack.  */\n-    {\n-      rtx address, size, x;\n-\n-      /* Record the stack pointer on entry to block, if have\n-\t not already done so.  */\n-      do_pending_stack_adjust ();\n-\n-      /* Compute the variable's size, in bytes.  This will expand any\n-\t needed SAVE_EXPRs for the first time.  */\n-      size = expand_normal (DECL_SIZE_UNIT (decl));\n-      free_temp_slots ();\n-\n-      /* Allocate space on the stack for the variable.  Note that\n-\t DECL_ALIGN says how the variable is to be aligned and we\n-\t cannot use it to conclude anything about the alignment of\n-\t the size.  */\n-      address = allocate_dynamic_stack_space (size, NULL_RTX,\n-\t\t\t\t\t      TYPE_ALIGN (TREE_TYPE (decl)));\n-\n-      /* Reference the variable indirect through that rtx.  */\n-      x = gen_rtx_MEM (DECL_MODE (decl), address);\n-      set_mem_attributes (x, decl, 1);\n-      SET_DECL_RTL (decl, x);\n-\n-\n-      /* Indicate the alignment we actually gave this variable.  */\n-#ifdef STACK_BOUNDARY\n-      DECL_ALIGN (decl) = STACK_BOUNDARY;\n-#else\n-      DECL_ALIGN (decl) = BIGGEST_ALIGNMENT;\n-#endif\n-      DECL_USER_ALIGN (decl) = 0;\n-    }\n }\n \f\n /* Emit code to save the current value of stack.  */"}, {"sha": "269086911c81759981e4a5315b154af960ecf0aa", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38f3813f7ba380b33607e114a7efa9901191924/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b38f3813f7ba380b33607e114a7efa9901191924", "patch": "@@ -306,6 +306,9 @@ rtx stack_limit_rtx;\n    to optimize, debug_info_level and debug_hooks in process_options ().  */\n int flag_var_tracking = AUTODETECT_VALUE;\n \n+/* Type of stack check.  */\n+enum stack_check_type flag_stack_check = NO_STACK_CHECK;\n+\n /* True if the user has tagged the function with the 'section'\n    attribute.  */\n "}]}