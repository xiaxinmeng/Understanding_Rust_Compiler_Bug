{"sha": "d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZlZDZiMDc0ZjcxZjQyM2UwZmZjNzMwNzIyOGE5OGQwZDE5NGI4YQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-05-04T08:57:23Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-05-04T08:57:23Z"}, "message": "PR libstdc++/85642 fix is_nothrow_default_constructible<optional<T>>\n\nAdd missing noexcept keyword to default constructor of each\n_Optional_payload specialization.\n\n\tPR libstdc++/85642 fix is_nothrow_default_constructible<optional<T>>\n\t* include/std/optional (_Optional_payload): Add noexcept to default\n\tconstructor. Re-indent.\n\t(_Optional_payload<_Tp, true, true, true>): Likewise. Add noexcept to\n\tconstructor for copying disengaged payloads.\n\t(_Optional_payload<_Tp, true, false, true>): Likewise.\n\t(_Optional_payload<_Tp, true, true, false>): Likewise.\n\t(_Optional_payload<_Tp, true, false, false>): Likewise.\n\t* testsuite/20_util/optional/cons/85642.cc: New.\n\t* testsuite/20_util/optional/cons/value_neg.cc: Adjust dg-error lines.\n\nFrom-SVN: r259928", "tree": {"sha": "689c9c3719d6f59a6de9e358558411f7b5459b07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/689c9c3719d6f59a6de9e358558411f7b5459b07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39bc9f83fece7a16836cb5b4869fe66b66a373a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39bc9f83fece7a16836cb5b4869fe66b66a373a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39bc9f83fece7a16836cb5b4869fe66b66a373a7"}], "stats": {"total": 483, "additions": 282, "deletions": 201}, "files": [{"sha": "93935ab9787870db7c538bee3a0c45d97469bfb4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -1,3 +1,16 @@\n+2018-05-04  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/85642 fix is_nothrow_default_constructible<optional<T>>\n+\t* include/std/optional (_Optional_payload): Add noexcept to default\n+\tconstructor. Re-indent.\n+\t(_Optional_payload<_Tp, true, true, true>): Likewise. Add noexcept to\n+\tconstructor for copying disengaged payloads.\n+\t(_Optional_payload<_Tp, true, false, true>): Likewise.\n+\t(_Optional_payload<_Tp, true, true, false>): Likewise.\n+\t(_Optional_payload<_Tp, true, false, false>): Likewise.\n+\t* testsuite/20_util/optional/cons/85642.cc: New.\n+\t* testsuite/20_util/optional/cons/value_neg.cc: Adjust dg-error lines.\n+\n 2018-05-03  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/82644"}, {"sha": "746ee2fd87e44719bbcd87c698af4c132941a365", "filename": "libstdc++-v3/include/std/optional", "status": "modified", "additions": 203, "deletions": 198, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -82,8 +82,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   {\n   public:\n     bad_optional_access() { }\n+\n     virtual const char* what() const noexcept override\n-    {return \"bad optional access\";}\n+    { return \"bad optional access\"; }\n \n     virtual ~bad_optional_access() noexcept = default;\n   };\n@@ -108,36 +109,40 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      is_trivially_move_assignable<_Tp>::value>\n     struct _Optional_payload\n     {\n-      constexpr _Optional_payload()\n-\t: _M_empty() {}\n+      constexpr _Optional_payload() noexcept : _M_empty() { }\n \n       template <typename... _Args>\n-      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n-\t: _M_payload(std::forward<_Args>(__args)...),\n-\t  _M_engaged(true) {}\n+\tconstexpr\n+\t_Optional_payload(in_place_t, _Args&&... __args)\n+\t: _M_payload(std::forward<_Args>(__args)...), _M_engaged(true) { }\n \n       template<typename _Up, typename... _Args>\n-      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t\t  _Args&&... __args)\n+\tconstexpr\n+\t_Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t  _Args&&... __args)\n \t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true) {}\n+\t  _M_engaged(true)\n+\t{ }\n+\n       constexpr\n       _Optional_payload(bool __engaged, const _Optional_payload& __other)\n-\t: _Optional_payload(__other)\n-      {}\n+      : _Optional_payload(__other)\n+      { }\n \n       constexpr\n       _Optional_payload(bool __engaged, _Optional_payload&& __other)\n-\t: _Optional_payload(std::move(__other))\n-      {}\n+      : _Optional_payload(std::move(__other))\n+      { }\n \n-      constexpr _Optional_payload(const _Optional_payload& __other)\n+      constexpr\n+      _Optional_payload(const _Optional_payload& __other)\n       {\n \tif (__other._M_engaged)\n \t  this->_M_construct(__other._M_payload);\n       }\n \n-      constexpr _Optional_payload(_Optional_payload&& __other)\n+      constexpr\n+      _Optional_payload(_Optional_payload&& __other)\n       {\n \tif (__other._M_engaged)\n \t  this->_M_construct(std::move(__other._M_payload));\n@@ -176,7 +181,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       using _Stored_type = remove_const_t<_Tp>;\n+\n       struct _Empty_byte { };\n+\n       union {\n           _Empty_byte _M_empty;\n           _Stored_type _M_payload;\n@@ -201,16 +208,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // The _M_get operations have _M_engaged as a precondition.\n       constexpr _Tp&\n-\t_M_get() noexcept\n-      {\n-\treturn this->_M_payload;\n-      }\n+      _M_get() noexcept\n+      { return this->_M_payload; }\n \n       constexpr const _Tp&\n-\t_M_get() const noexcept\n-      {\n-\treturn this->_M_payload;\n-      }\n+      _M_get() const noexcept\n+      { return this->_M_payload; }\n \n       // _M_reset is a 'safe' operation with no precondition.\n       void\n@@ -224,62 +227,64 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n-  // Payload for constexpr optionals.\n+  // Payload for potentially-constexpr optionals.\n   template <typename _Tp>\n     struct _Optional_payload<_Tp, true, true, true>\n     {\n-      constexpr _Optional_payload()\n-\t: _M_empty(), _M_engaged(false) {}\n+      constexpr _Optional_payload() noexcept\n+      : _M_empty(), _M_engaged(false) { }\n \n       template<typename... _Args>\n-      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n-\t: _M_payload(std::forward<_Args>(__args)...),\n-\t  _M_engaged(true)\n-      {}\n+\tconstexpr\n+\t_Optional_payload(in_place_t, _Args&&... __args)\n+\t: _M_payload(std::forward<_Args>(__args)...), _M_engaged(true)\n+\t{ }\n \n       template<typename _Up, typename... _Args>\n-      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t\t  _Args&&... __args)\n+\tconstexpr\n+\t_Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t  _Args&&... __args)\n \t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true) {}\n+\t  _M_engaged(true)\n+\t{ }\n \n       template <class _Up> struct __ctor_tag {};\n \n-      constexpr _Optional_payload(__ctor_tag<bool>,\n-\t\t\t\t  const _Tp& __other)\n-\t: _M_payload(__other),\n-\t  _M_engaged(true)\n-      {}\n+      constexpr\n+      _Optional_payload(__ctor_tag<bool>, const _Tp& __other)\n+      : _M_payload(__other), _M_engaged(true)\n+      { }\n \n-      constexpr _Optional_payload(__ctor_tag<void>)\n-\t: _M_empty(), _M_engaged(false)\n-      {}\n+      constexpr _Optional_payload(__ctor_tag<void>) noexcept\n+      : _M_empty(), _M_engaged(false)\n+      { }\n \n       constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n-\t: _M_payload(std::move(__other)),\n-\t  _M_engaged(true)\n-      {}\n-\n-      constexpr _Optional_payload(bool __engaged,\n-\t\t\t\t  const _Optional_payload& __other)\n-\t: _Optional_payload(__engaged ?\n-\t\t\t    _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t      __other._M_payload) :\n-\t\t\t    _Optional_payload(__ctor_tag<void>{}))\n-      {}\n-\n-      constexpr _Optional_payload(bool __engaged,\n-\t\t\t\t  _Optional_payload&& __other)\n-\t: _Optional_payload(__engaged\n-\t\t\t    ? _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t\tstd::move(__other._M_payload))\n-\t\t\t    : _Optional_payload(__ctor_tag<void>{}))\n-      {}\n+      : _M_payload(std::move(__other)), _M_engaged(true)\n+      { }\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n+      : _Optional_payload(__engaged ?\n+\t\t\t  _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t    __other._M_payload) :\n+\t\t\t  _Optional_payload(__ctor_tag<void>{}))\n+      { }\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n+      : _Optional_payload(__engaged\n+\t\t\t  ? _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t      std::move(__other._M_payload))\n+\t\t\t  : _Optional_payload(__ctor_tag<void>{}))\n+      { }\n \n       using _Stored_type = remove_const_t<_Tp>;\n+\n       struct _Empty_byte { };\n+\n       union {\n-          _Empty_byte _M_empty;\n+\t  _Empty_byte _M_empty;\n           _Stored_type _M_payload;\n       };\n       bool _M_engaged;\n@@ -289,53 +294,54 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template <typename _Tp>\n     struct _Optional_payload<_Tp, true, false, true>\n     {\n-      constexpr _Optional_payload()\n-\t: _M_empty(), _M_engaged(false) {}\n+      constexpr _Optional_payload() noexcept\n+      : _M_empty(), _M_engaged(false) { }\n \n       template<typename... _Args>\n-      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n-\t: _M_payload(std::forward<_Args>(__args)...),\n-\t  _M_engaged(true)\n-      {}\n+\tconstexpr\n+\t_Optional_payload(in_place_t, _Args&&... __args)\n+\t: _M_payload(std::forward<_Args>(__args)...), _M_engaged(true)\n+\t{ }\n \n       template<typename _Up, typename... _Args>\n-      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t\t  _Args&&... __args)\n+\tconstexpr\n+\t_Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t  _Args&&... __args)\n \t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true) {}\n+\t  _M_engaged(true)\n+\t{ }\n \n       template <class _Up> struct __ctor_tag {};\n \n-      constexpr _Optional_payload(__ctor_tag<bool>,\n-\t\t\t\t  const _Tp& __other)\n-\t: _M_payload(__other),\n-\t  _M_engaged(true)\n-      {}\n+      constexpr _Optional_payload(__ctor_tag<bool>, const _Tp& __other)\n+      : _M_payload(__other),\n+\t_M_engaged(true)\n+      { }\n \n-      constexpr _Optional_payload(__ctor_tag<void>)\n-\t: _M_empty(), _M_engaged(false)\n-      {}\n+      constexpr _Optional_payload(__ctor_tag<void>) noexcept\n+      : _M_empty(), _M_engaged(false)\n+      { }\n \n       constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n-\t: _M_payload(std::move(__other)),\n-\t  _M_engaged(true)\n-      {}\n-\n-      constexpr _Optional_payload(bool __engaged,\n-\t\t\t\t  const _Optional_payload& __other)\n-\t: _Optional_payload(__engaged ?\n-\t\t\t    _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t      __other._M_payload) :\n-\t\t\t    _Optional_payload(__ctor_tag<void>{}))\n-      {}\n-\n-      constexpr _Optional_payload(bool __engaged,\n-\t\t\t\t  _Optional_payload&& __other)\n-\t: _Optional_payload(__engaged\n-\t\t\t    ? _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t\tstd::move(__other._M_payload))\n-\t\t\t    : _Optional_payload(__ctor_tag<void>{}))\n-      {}\n+      : _M_payload(std::move(__other)),\n+\t_M_engaged(true)\n+      { }\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n+      : _Optional_payload(__engaged ?\n+\t\t\t  _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t    __other._M_payload) :\n+\t\t\t  _Optional_payload(__ctor_tag<void>{}))\n+      { }\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n+      : _Optional_payload(__engaged\n+\t\t\t  ? _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t      std::move(__other._M_payload))\n+\t\t\t  : _Optional_payload(__ctor_tag<void>{}))\n+      { }\n \n       _Optional_payload(const _Optional_payload&) = default;\n       _Optional_payload(_Optional_payload&&) = default;\n@@ -359,7 +365,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       operator=(_Optional_payload&& __other) = default;\n \n       using _Stored_type = remove_const_t<_Tp>;\n+\n       struct _Empty_byte { };\n+\n       union {\n           _Empty_byte _M_empty;\n           _Stored_type _M_payload;\n@@ -378,16 +386,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // The _M_get operations have _M_engaged as a precondition.\n       constexpr _Tp&\n-\t_M_get() noexcept\n-      {\n-\treturn this->_M_payload;\n-      }\n+      _M_get() noexcept\n+      { return this->_M_payload; }\n \n       constexpr const _Tp&\n-\t_M_get() const noexcept\n-      {\n-\treturn this->_M_payload;\n-      }\n+      _M_get() const noexcept\n+      { return this->_M_payload; }\n \n       // _M_reset is a 'safe' operation with no precondition.\n       void\n@@ -405,53 +409,56 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template <typename _Tp>\n     struct _Optional_payload<_Tp, true, true, false>\n     {\n-      constexpr _Optional_payload()\n-\t: _M_empty(), _M_engaged(false) {}\n+      constexpr _Optional_payload() noexcept\n+      : _M_empty(), _M_engaged(false) { }\n \n       template<typename... _Args>\n-      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n+\tconstexpr\n+\t_Optional_payload(in_place_t, _Args&&... __args)\n \t: _M_payload(std::forward<_Args>(__args)...),\n \t  _M_engaged(true)\n-      {}\n+\t{ }\n \n       template<typename _Up, typename... _Args>\n-      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t\t  _Args&&... __args)\n+\tconstexpr\n+\t_Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t  _Args&&... __args)\n \t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true) {}\n+\t  _M_engaged(true)\n+\t{ }\n \n       template <class _Up> struct __ctor_tag {};\n \n-      constexpr _Optional_payload(__ctor_tag<bool>,\n-\t\t\t\t  const _Tp& __other)\n-\t: _M_payload(__other),\n-\t  _M_engaged(true)\n-      {}\n+      constexpr\n+      _Optional_payload(__ctor_tag<bool>, const _Tp& __other)\n+      : _M_payload(__other),\n+\t_M_engaged(true)\n+      { }\n \n-      constexpr _Optional_payload(__ctor_tag<void>)\n-\t: _M_empty(), _M_engaged(false)\n-      {}\n+      constexpr _Optional_payload(__ctor_tag<void>) noexcept\n+      : _M_empty(), _M_engaged(false)\n+      { }\n \n       constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n-\t: _M_payload(std::move(__other)),\n-\t  _M_engaged(true)\n-      {}\n-\n-      constexpr _Optional_payload(bool __engaged,\n-\t\t\t\t  const _Optional_payload& __other)\n-\t: _Optional_payload(__engaged ?\n-\t\t\t    _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t      __other._M_payload) :\n-\t\t\t    _Optional_payload(__ctor_tag<void>{}))\n-      {}\n-\n-      constexpr _Optional_payload(bool __engaged,\n-\t\t\t\t  _Optional_payload&& __other)\n-\t: _Optional_payload(__engaged\n-\t\t\t    ? _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t\tstd::move(__other._M_payload))\n-\t\t\t    : _Optional_payload(__ctor_tag<void>{}))\n-      {}\n+      : _M_payload(std::move(__other)),\n+\t_M_engaged(true)\n+      { }\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n+      : _Optional_payload(__engaged ?\n+\t\t\t  _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t    __other._M_payload) :\n+\t\t\t  _Optional_payload(__ctor_tag<void>{}))\n+      { }\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n+      : _Optional_payload(__engaged\n+\t\t\t  ? _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t      std::move(__other._M_payload))\n+\t\t\t  : _Optional_payload(__ctor_tag<void>{}))\n+      { }\n \n       _Optional_payload(const _Optional_payload&) = default;\n       _Optional_payload(_Optional_payload&&) = default;\n@@ -477,7 +484,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       using _Stored_type = remove_const_t<_Tp>;\n+\n       struct _Empty_byte { };\n+\n       union {\n           _Empty_byte _M_empty;\n           _Stored_type _M_payload;\n@@ -496,16 +505,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // The _M_get operations have _M_engaged as a precondition.\n       constexpr _Tp&\n-\t_M_get() noexcept\n-      {\n-\treturn this->_M_payload;\n-      }\n+      _M_get() noexcept\n+      { return this->_M_payload; }\n \n       constexpr const _Tp&\n-\t_M_get() const noexcept\n-      {\n-\treturn this->_M_payload;\n-      }\n+      _M_get() const noexcept\n+      { return this->_M_payload; }\n \n       // _M_reset is a 'safe' operation with no precondition.\n       void\n@@ -523,53 +528,55 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template <typename _Tp>\n     struct _Optional_payload<_Tp, true, false, false>\n     {\n-      constexpr _Optional_payload()\n-\t: _M_empty(), _M_engaged(false) {}\n+      constexpr _Optional_payload() noexcept\n+      : _M_empty(), _M_engaged(false) {}\n \n       template<typename... _Args>\n-      constexpr _Optional_payload(in_place_t, _Args&&... __args)\n+\tconstexpr\n+\t_Optional_payload(in_place_t, _Args&&... __args)\n \t: _M_payload(std::forward<_Args>(__args)...),\n \t  _M_engaged(true)\n-      {}\n+\t{ }\n \n       template<typename _Up, typename... _Args>\n-      constexpr _Optional_payload(std::initializer_list<_Up> __il,\n-\t\t\t\t  _Args&&... __args)\n+\tconstexpr\n+\t_Optional_payload(std::initializer_list<_Up> __il,\n+\t\t\t  _Args&&... __args)\n \t: _M_payload(__il, std::forward<_Args>(__args)...),\n-\t  _M_engaged(true) {}\n+\t  _M_engaged(true)\n+\t{ }\n \n       template <class _Up> struct __ctor_tag {};\n \n-      constexpr _Optional_payload(__ctor_tag<bool>,\n-\t\t\t\t  const _Tp& __other)\n-\t: _M_payload(__other),\n-\t  _M_engaged(true)\n-      {}\n+      constexpr _Optional_payload(__ctor_tag<bool>, const _Tp& __other)\n+      : _M_payload(__other),\n+\t    _M_engaged(true)\n+      { }\n \n-      constexpr _Optional_payload(__ctor_tag<void>)\n-\t: _M_empty(), _M_engaged(false)\n-      {}\n+      constexpr _Optional_payload(__ctor_tag<void>) noexcept\n+      : _M_empty(), _M_engaged(false)\n+      { }\n \n       constexpr _Optional_payload(__ctor_tag<bool>, _Tp&& __other)\n-\t: _M_payload(std::move(__other)),\n-\t  _M_engaged(true)\n-      {}\n-\n-      constexpr _Optional_payload(bool __engaged,\n-\t\t\t\t  const _Optional_payload& __other)\n-\t: _Optional_payload(__engaged ?\n-\t\t\t    _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t      __other._M_payload) :\n-\t\t\t    _Optional_payload(__ctor_tag<void>{}))\n-      {}\n-\n-      constexpr _Optional_payload(bool __engaged,\n-\t\t\t\t  _Optional_payload&& __other)\n-\t: _Optional_payload(__engaged\n-\t\t\t    ? _Optional_payload(__ctor_tag<bool>{},\n-\t\t\t\t\t\tstd::move(__other._M_payload))\n-\t\t\t    : _Optional_payload(__ctor_tag<void>{}))\n-      {}\n+      : _M_payload(std::move(__other)),\n+\t_M_engaged(true)\n+      { }\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, const _Optional_payload& __other)\n+      : _Optional_payload(__engaged ?\n+\t\t\t  _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t    __other._M_payload) :\n+\t\t\t  _Optional_payload(__ctor_tag<void>{}))\n+      { }\n+\n+      constexpr\n+      _Optional_payload(bool __engaged, _Optional_payload&& __other)\n+      : _Optional_payload(__engaged\n+\t\t\t  ? _Optional_payload(__ctor_tag<bool>{},\n+\t\t\t\t\t      std::move(__other._M_payload))\n+\t\t\t  : _Optional_payload(__ctor_tag<void>{}))\n+      { }\n \n       _Optional_payload(const _Optional_payload&) = default;\n       _Optional_payload(_Optional_payload&&) = default;\n@@ -607,7 +614,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       using _Stored_type = remove_const_t<_Tp>;\n+\n       struct _Empty_byte { };\n+\n       union {\n           _Empty_byte _M_empty;\n           _Stored_type _M_payload;\n@@ -626,16 +635,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // The _M_get operations have _M_engaged as a precondition.\n       constexpr _Tp&\n-\t_M_get() noexcept\n-      {\n-\treturn this->_M_payload;\n-      }\n+      _M_get() noexcept\n+      { return this->_M_payload; }\n \n       constexpr const _Tp&\n-\t_M_get() const noexcept\n-      {\n-\treturn this->_M_payload;\n-      }\n+      _M_get() const noexcept\n+      { return this->_M_payload; }\n \n       // _M_reset is a 'safe' operation with no precondition.\n       void\n@@ -658,15 +663,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // The _M_construct operation has !_M_engaged as a precondition\n       // while _M_destruct has _M_engaged as a precondition.\n       template<typename... _Args>\n-      void\n-      _M_construct(_Args&&... __args)\n+\tvoid\n+\t_M_construct(_Args&&... __args)\n \tnoexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n-      {\n-\t::new\n-\t  (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))\n-\t  _Stored_type(std::forward<_Args>(__args)...);\n-\tstatic_cast<_Dp*>(this)->_M_payload._M_engaged = true;\n-      }\n+\t{\n+\t  ::new\n+\t    (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))\n+\t    _Stored_type(std::forward<_Args>(__args)...);\n+\t  static_cast<_Dp*>(this)->_M_payload._M_engaged = true;\n+\t}\n       \n       void\n       _M_destruct() noexcept\n@@ -700,8 +705,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : protected _Optional_base_impl<_Tp, _Optional_base<_Tp>>\n     {\n       friend class _Optional_base_impl<_Tp, _Optional_base<_Tp>>;\n-    public:\n \n+    public:\n       // Constructors for disengaged optionals.\n       constexpr _Optional_base() = default;\n "}, {"sha": "4d366f1d27c5ab8b21e4884f8732be44f3724636", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/85642.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2F85642.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2F85642.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2F85642.cc?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile { target c++17 } }\n+\n+#include <optional>\n+\n+struct NonTrivialDtor {\n+  ~NonTrivialDtor() { }\n+};\n+\n+struct NonTrivialCopyAssign {\n+  NonTrivialCopyAssign& operator=(const NonTrivialCopyAssign&) { return *this; }\n+  NonTrivialCopyAssign& operator=(NonTrivialCopyAssign&&) = default;\n+};\n+\n+struct NonTrivialMoveAssign {\n+  NonTrivialMoveAssign& operator=(const NonTrivialMoveAssign&) = default;\n+  NonTrivialMoveAssign& operator=(NonTrivialMoveAssign&&) { return *this; }\n+};\n+\n+struct NonTrivialAssign {\n+  NonTrivialAssign& operator=(const NonTrivialAssign&) { return *this; }\n+  NonTrivialAssign& operator=(NonTrivialAssign&&) { return *this; }\n+};\n+\n+struct NonTrivialAll {\n+  ~NonTrivialAll() { }\n+  NonTrivialAll& operator=(const NonTrivialAll&) { return *this; }\n+  NonTrivialAll& operator=(NonTrivialAll&&) { return *this; }\n+};\n+\n+struct ConstExpr { int i = 0; };\n+\n+struct Trivial { int i; };\n+\n+template<typename T>\n+  constexpr bool check\n+    = std::is_nothrow_default_constructible_v<std::optional<T>>;\n+\n+// PR libstdc++/85642\n+static_assert(check<NonTrivialDtor>);\n+static_assert(check<NonTrivialCopyAssign>);\n+static_assert(check<NonTrivialMoveAssign>);\n+static_assert(check<NonTrivialAssign>);\n+static_assert(check<NonTrivialAll>);\n+static_assert(check<ConstExpr>);\n+static_assert(check<Trivial>);"}, {"sha": "e9171ef7cc2a4ecd872574a0d1d6293a77da64f0", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/value_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed6b074f71f423e0ffc7307228a98d0d194b8a/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc?ref=d6ed6b074f71f423e0ffc7307228a98d0d194b8a", "patch": "@@ -37,8 +37,8 @@ int main()\n     std::optional<std::unique_ptr<int>> oup2 = new int;  // { dg-error \"conversion\" }\n     struct U { explicit U(std::in_place_t); };\n     std::optional<U> ou(std::in_place); // { dg-error \"no matching\" }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 1015 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 1025 }\n-    // { dg-error \"no type\" \"\" { target { *-*-* } } 1082 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 1020 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 1030 }\n+    // { dg-error \"no type\" \"\" { target { *-*-* } } 1087 }\n   }\n }"}]}