{"sha": "e40375e0e23145c3140d375d3cf8f164800983ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQwMzc1ZTBlMjMxNDVjMzE0MGQzNzVkM2NmOGYxNjQ4MDA5ODNlZQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2008-10-11T15:54:27Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2008-10-11T15:54:27Z"}, "message": "re PR middle-end/37608 (libgcc2.c:1981: ICE: vector VEC(m em_ref_p,base) index domain error, in create_vop_ref_mapping_loop at tree-ssa-lo op-im.c:1519)\n\n\tPR middle-end/37608\n\t* pa.md (call, call_value): Generate an rtx for register r4 and pass\n\tit to PIC call patterns.\n\t(call_symref_pic): Revise pattern to expose PIC register save.  Remove\n\tcode generation and attributes from pattern.  Change peephole2 to split\n\tfor noreturn case.  Revise split pattern for non noreturn case.\n\t(call_symref_64bit, call_reg_pic, call_reg_64bit, call_val_symref_pic,\n\tcall_val_symref_64bit, call_val_reg_pic, call_val_reg_64bit): Likewise.\n\t* pa.c (attr_length_call): Simplify extraction of call rtx.  Add some\n\tasserts.\n\nFrom-SVN: r141063", "tree": {"sha": "a4e93d66ea422b21cd664acd15b8fd5b210ef62e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4e93d66ea422b21cd664acd15b8fd5b210ef62e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e40375e0e23145c3140d375d3cf8f164800983ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e40375e0e23145c3140d375d3cf8f164800983ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e40375e0e23145c3140d375d3cf8f164800983ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e40375e0e23145c3140d375d3cf8f164800983ee/comments", "author": null, "committer": null, "parents": [{"sha": "e47911ce2145c3efd181bffc191cf38c7271177c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e47911ce2145c3efd181bffc191cf38c7271177c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e47911ce2145c3efd181bffc191cf38c7271177c"}], "stats": {"total": 583, "additions": 297, "deletions": 286}, "files": [{"sha": "675ae9458111f6414e0bdccd51099f31fa8eb593", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e40375e0e23145c3140d375d3cf8f164800983ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e40375e0e23145c3140d375d3cf8f164800983ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e40375e0e23145c3140d375d3cf8f164800983ee", "patch": "@@ -1,3 +1,16 @@\n+2008-10-11  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR middle-end/37608\n+\t* pa.md (call, call_value): Generate an rtx for register r4 and pass\n+\tit to PIC call patterns.\n+\t(call_symref_pic): Revise pattern to expose PIC register save.  Remove\n+\tcode generation and attributes from pattern.  Change peephole2 to split\n+\tfor noreturn case.  Revise split pattern for non noreturn case.\n+\t(call_symref_64bit, call_reg_pic, call_reg_64bit, call_val_symref_pic,\n+\tcall_val_symref_64bit, call_val_reg_pic, call_val_reg_64bit): Likewise.\n+\t* pa.c (attr_length_call): Simplify extraction of call rtx.  Add some\n+\tasserts.\n+\n 2008-10-11  David Edelsohn  <edelsohn@gnu.org>\n \n         * config/rs6000/rs6000.md (aux_truncdfsf2): Remove TARGET_SINGLE_FLOAT."}, {"sha": "3d3c96dc087313931e8cc3e42419eeaedfa8f235", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e40375e0e23145c3140d375d3cf8f164800983ee/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e40375e0e23145c3140d375d3cf8f164800983ee/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=e40375e0e23145c3140d375d3cf8f164800983ee", "patch": "@@ -7377,12 +7377,14 @@ int\n attr_length_call (rtx insn, int sibcall)\n {\n   int local_call;\n-  rtx call_dest;\n+  rtx call, call_dest;\n   tree call_decl;\n   int length = 0;\n   rtx pat = PATTERN (insn);\n   unsigned long distance = -1;\n \n+  gcc_assert (GET_CODE (insn) == CALL_INSN);\n+\n   if (INSN_ADDRESSES_SET_P ())\n     {\n       unsigned long total;\n@@ -7393,12 +7395,17 @@ attr_length_call (rtx insn, int sibcall)\n \tdistance = -1;\n     }\n \n-  /* Determine if this is a local call.  */\n-  if (GET_CODE (XVECEXP (pat, 0, 0)) == CALL)\n-    call_dest = XEXP (XEXP (XVECEXP (pat, 0, 0), 0), 0);\n-  else\n-    call_dest = XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0), 0);\n+  gcc_assert (GET_CODE (pat) == PARALLEL);\n \n+  /* Get the call rtx.  */\n+  call = XVECEXP (pat, 0, 0);\n+  if (GET_CODE (call) == SET)\n+    call = SET_SRC (call);\n+\n+  gcc_assert (GET_CODE (call) == CALL);\n+\n+  /* Determine if this is a local call.  */\n+  call_dest = XEXP (XEXP (call, 0), 0);\n   call_decl = SYMBOL_REF_DECL (call_dest);\n   local_call = call_decl && targetm.binds_local_p (call_decl);\n "}, {"sha": "b845182d5922448cd2cb4122eb6c8cc822f378f4", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 271, "deletions": 280, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e40375e0e23145c3140d375d3cf8f164800983ee/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e40375e0e23145c3140d375d3cf8f164800983ee/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=e40375e0e23145c3140d375d3cf8f164800983ee", "patch": "@@ -7669,37 +7669,43 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n      need to have a use of the PIC register in the return pattern and\n      the final save/restore operation is not needed.\n      \n-     I elected to just clobber %r4 in the PIC patterns and use it instead\n+     I elected to just use register %r4 in the PIC patterns instead\n      of trying to force hppa_pic_save_rtx () to a callee saved register.\n      This might have required a new register class and constraint.  It\n      was also simpler to just handle the restore from a register than a\n      generic pseudo.  */\n   if (TARGET_64BIT)\n     {\n+      rtx r4 = gen_rtx_REG (word_mode, 4);\n       if (GET_CODE (op) == SYMBOL_REF)\n-\tcall_insn = emit_call_insn (gen_call_symref_64bit (op, nb));\n+\tcall_insn = emit_call_insn (gen_call_symref_64bit (op, nb, r4));\n       else\n \t{\n \t  op = force_reg (word_mode, op);\n-\t  call_insn = emit_call_insn (gen_call_reg_64bit (op, nb));\n+\t  call_insn = emit_call_insn (gen_call_reg_64bit (op, nb, r4));\n \t}\n     }\n   else\n     {\n       if (GET_CODE (op) == SYMBOL_REF)\n \t{\n \t  if (flag_pic)\n-\t    call_insn = emit_call_insn (gen_call_symref_pic (op, nb));\n+\t    {\n+\t      rtx r4 = gen_rtx_REG (word_mode, 4);\n+\t      call_insn = emit_call_insn (gen_call_symref_pic (op, nb, r4));\n+\t    }\n \t  else\n \t    call_insn = emit_call_insn (gen_call_symref (op, nb));\n \t}\n       else\n \t{\n \t  rtx tmpreg = gen_rtx_REG (word_mode, 22);\n-\n \t  emit_move_insn (tmpreg, force_reg (word_mode, op));\n \t  if (flag_pic)\n-\t    call_insn = emit_call_insn (gen_call_reg_pic (nb));\n+\t    {\n+\t      rtx r4 = gen_rtx_REG (word_mode, 4);\n+\t      call_insn = emit_call_insn (gen_call_reg_pic (nb, r4));\n+\t    }\n \t  else\n \t    call_insn = emit_call_insn (gen_call_reg (nb));\n \t}\n@@ -7754,69 +7760,64 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n    (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n \n (define_insn \"call_symref_pic\"\n-  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+  [(set (match_operand:SI 2 \"register_operand\" \"=&r\") (reg:SI 19))\n+   (call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t (match_operand 1 \"\" \"i\"))\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n-   (clobber (reg:SI 4))\n+   (use (match_dup 2))\n    (use (reg:SI 19))\n    (use (const_int 0))]\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n-  \"*\n-{\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[0], 0);\n-}\"\n-  [(set_attr \"type\" \"call\")\n-   (set (attr \"length\")\n-\t(plus (symbol_ref \"attr_length_call (insn, 0)\")\n-\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n-\n-;; Split out the PIC register save and restore after reload.  This is\n-;; done only if the function returns.  As the split is done after reload,\n-;; there are some situations in which we unnecessarily save and restore\n-;; %r4.  This happens when there is a single call and the PIC register\n-;; is \"dead\" after the call.  This isn't easy to fix as the usage of\n-;; the PIC register isn't completely determined until the reload pass.\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n (define_split\n-  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+  [(parallel [(set (match_operand:SI 2 \"register_operand\" \"\") (reg:SI 19))\n+\t      (call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n-\t      (clobber (reg:SI 4))\n+\t      (use (match_dup 2))\n \t      (use (reg:SI 19))\n \t      (use (const_int 0))])]\n-  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\n-   && reload_completed\n-   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n-  [(set (reg:SI 4) (reg:SI 19))\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 2) (reg:SI 19))\n    (parallel [(call (mem:SI (match_dup 0))\n \t\t    (match_dup 1))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n \t      (use (reg:SI 19))\n-\t      (use (const_int 0))])\n-   (set (reg:SI 19) (reg:SI 4))]\n+\t      (use (const_int 0))])]\n   \"\")\n \n-;; Remove the clobber of register 4 when optimizing.  This has to be\n-;; done with a peephole optimization rather than a split because the\n-;; split sequence for a call must be longer than one instruction.\n-(define_peephole2\n-  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+(define_split\n+  [(parallel [(set (match_operand:SI 2 \"register_operand\" \"\") (reg:SI 19))\n+\t      (call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n-\t      (clobber (reg:SI 4))\n+\t      (use (match_dup 2))\n \t      (use (reg:SI 19))\n \t      (use (const_int 0))])]\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed\"\n-  [(parallel [(call (mem:SI (match_dup 0))\n+  [(set (match_dup 2) (reg:SI 19))\n+   (parallel [(call (mem:SI (match_dup 0))\n \t\t    (match_dup 1))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n \t      (use (reg:SI 19))\n-\t      (use (const_int 0))])]\n+\t      (use (const_int 0))])\n+   (set (reg:SI 19) (match_dup 2))]\n   \"\")\n \n (define_insn \"*call_symref_pic_post_reload\"\n@@ -7838,74 +7839,69 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n (define_insn \"call_symref_64bit\"\n-  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+  [(set (match_operand:DI 2 \"register_operand\" \"=&r\") (reg:DI 27))\n+   (call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t (match_operand 1 \"\" \"i\"))\n    (clobber (reg:DI 1))\n    (clobber (reg:DI 2))\n-   (clobber (reg:DI 4))\n+   (use (match_dup 2))\n    (use (reg:DI 27))\n    (use (reg:DI 29))\n    (use (const_int 0))]\n   \"TARGET_64BIT\"\n-  \"*\n-{\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[0], 0);\n-}\"\n-  [(set_attr \"type\" \"call\")\n-   (set (attr \"length\")\n-\t(plus (symbol_ref \"attr_length_call (insn, 0)\")\n-\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n-\n-;; Split out the PIC register save and restore after reload.  This is\n-;; done only if the function returns.  As the split is done after reload,\n-;; there are some situations in which we unnecessarily save and restore\n-;; %r4.  This happens when there is a single call and the PIC register\n-;; is \"dead\" after the call.  This isn't easy to fix as the usage of\n-;; the PIC register isn't completely determined until the reload pass.\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n (define_split\n-  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+  [(parallel [(set (match_operand:DI 2 \"register_operand\" \"\") (reg:DI 27))\n+\t      (call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n-\t      (clobber (reg:DI 4))\n+\t      (use (match_dup 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n \t      (use (const_int 0))])]\n-  \"TARGET_64BIT\n-   && reload_completed\n-   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n-  [(set (reg:DI 4) (reg:DI 27))\n+  \"TARGET_64BIT && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 2) (reg:DI 27))\n    (parallel [(call (mem:SI (match_dup 0))\n \t\t    (match_dup 1))\n \t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n-\t      (use (const_int 0))])\n-   (set (reg:DI 27) (reg:DI 4))]\n+\t      (use (const_int 0))])]\n   \"\")\n \n-;; Remove the clobber of register 4 when optimizing.  This has to be\n-;; done with a peephole optimization rather than a split because the\n-;; split sequence for a call must be longer than one instruction.\n-(define_peephole2\n-  [(parallel [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+(define_split\n+  [(parallel [(set (match_operand:DI 2 \"register_operand\" \"\") (reg:DI 27))\n+\t      (call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n \t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n-\t      (clobber (reg:DI 4))\n+\t      (use (match_dup 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n \t      (use (const_int 0))])]\n   \"TARGET_64BIT && reload_completed\"\n-  [(parallel [(call (mem:SI (match_dup 0))\n+  [(set (match_dup 2) (reg:DI 27))\n+   (parallel [(call (mem:SI (match_dup 0))\n \t\t    (match_dup 1))\n \t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n-\t      (use (const_int 0))])]\n+\t      (use (const_int 0))])\n+   (set (reg:DI 27) (match_dup 2))]\n   \"\")\n \n (define_insn \"*call_symref_64bit_post_reload\"\n@@ -7942,68 +7938,64 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n (define_insn \"call_reg_pic\"\n-  [(call (mem:SI (reg:SI 22))\n+  [(set (match_operand:SI 1 \"register_operand\" \"=&r\") (reg:SI 19))\n+   (call (mem:SI (reg:SI 22))\n \t (match_operand 0 \"\" \"i\"))\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n-   (clobber (reg:SI 4))\n+   (use (match_dup 1))\n    (use (reg:SI 19))\n    (use (const_int 1))]\n   \"!TARGET_64BIT\"\n-  \"*\n-{\n-  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n-}\"\n-  [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\")\n-\t(plus (symbol_ref \"attr_length_indirect_call (insn)\")\n-\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n-\n-;; Split out the PIC register save and restore after reload.  This is\n-;; done only if the function returns.  As the split is done after reload,\n-;; there are some situations in which we unnecessarily save and restore\n-;; %r4.  This happens when there is a single call and the PIC register\n-;; is \"dead\" after the call.  This isn't easy to fix as the usage of\n-;; the PIC register isn't completely determined until the reload pass.\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n (define_split\n-  [(parallel [(call (mem:SI (reg:SI 22))\n+  [(parallel [(set (match_operand:SI 1 \"register_operand\" \"\") (reg:SI 19))\n+\t      (call (mem:SI (reg:SI 22))\n \t\t    (match_operand 0 \"\" \"\"))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n-\t      (clobber (reg:SI 4))\n+\t      (use (match_dup 1))\n \t      (use (reg:SI 19))\n \t      (use (const_int 1))])]\n-  \"!TARGET_64BIT\n-   && reload_completed\n-   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n-  [(set (reg:SI 4) (reg:SI 19))\n+  \"!TARGET_64BIT && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 1) (reg:SI 19))\n    (parallel [(call (mem:SI (reg:SI 22))\n \t\t    (match_dup 0))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n \t      (use (reg:SI 19))\n-\t      (use (const_int 1))])\n-   (set (reg:SI 19) (reg:SI 4))]\n+\t      (use (const_int 1))])]\n   \"\")\n \n-;; Remove the clobber of register 4 when optimizing.  This has to be\n-;; done with a peephole optimization rather than a split because the\n-;; split sequence for a call must be longer than one instruction.\n-(define_peephole2\n-  [(parallel [(call (mem:SI (reg:SI 22))\n+(define_split\n+  [(parallel [(set (match_operand:SI 1 \"register_operand\" \"\") (reg:SI 19))\n+\t      (call (mem:SI (reg:SI 22))\n \t\t    (match_operand 0 \"\" \"\"))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n-\t      (clobber (reg:SI 4))\n+\t      (use (match_dup 1))\n \t      (use (reg:SI 19))\n \t      (use (const_int 1))])]\n   \"!TARGET_64BIT && reload_completed\"\n-  [(parallel [(call (mem:SI (reg:SI 22))\n+  [(set (match_dup 1) (reg:SI 19))\n+   (parallel [(call (mem:SI (reg:SI 22))\n \t\t    (match_dup 0))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n \t      (use (reg:SI 19))\n-\t      (use (const_int 1))])]\n+\t      (use (const_int 1))])\n+   (set (reg:SI 19) (match_dup 1))]\n   \"\")\n \n (define_insn \"*call_reg_pic_post_reload\"\n@@ -8024,73 +8016,75 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n (define_insn \"call_reg_64bit\"\n-  [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"r\"))\n+  [(set (match_operand:DI 2 \"register_operand\" \"=&r\") (reg:DI 27))\n+   (call (mem:SI (match_operand:DI 0 \"register_operand\" \"r\"))\n \t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:DI 1))\n    (clobber (reg:DI 2))\n-   (clobber (reg:DI 4))\n+   (use (match_dup 2))\n    (use (reg:DI 27))\n    (use (reg:DI 29))\n    (use (const_int 1))]\n   \"TARGET_64BIT\"\n-  \"*\n-{\n-  return output_indirect_call (insn, operands[0]);\n-}\"\n-  [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\")\n-\t(plus (symbol_ref \"attr_length_indirect_call (insn)\")\n-\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n-\n-;; Split out the PIC register save and restore after reload.  This is\n-;; done only if the function returns.  As the split is done after reload,\n-;; there are some situations in which we unnecessarily save and restore\n-;; %r4.  This happens when there is a single call and the PIC register\n-;; is \"dead\" after the call.  This isn't easy to fix as the usage of\n-;; the PIC register isn't completely determined until the reload pass.\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n (define_split\n-  [(parallel [(call (mem:SI (match_operand 0 \"register_operand\" \"\"))\n+  [(parallel [(set (match_operand:DI 2 \"register_operand\" \"\") (reg:DI 27))\n+\t      (call (mem:SI (match_operand 0 \"register_operand\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n-\t      (clobber (reg:DI 4))\n+\t      (use (match_dup 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n \t      (use (const_int 1))])]\n-  \"TARGET_64BIT\n-   && reload_completed\n-   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n-  [(set (reg:DI 4) (reg:DI 27))\n+  \"TARGET_64BIT && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 2) (reg:DI 27))\n    (parallel [(call (mem:SI (match_dup 0))\n \t\t    (match_dup 1))\n+\t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n-\t      (use (const_int 1))])\n-   (set (reg:DI 27) (reg:DI 4))]\n+\t      (use (const_int 1))])]\n   \"\")\n \n-;; Remove the clobber of register 4 when optimizing.  This has to be\n-;; done with a peephole optimization rather than a split because the\n-;; split sequence for a call must be longer than one instruction.\n-(define_peephole2\n-  [(parallel [(call (mem:SI (match_operand 0 \"register_operand\" \"\"))\n+(define_split\n+  [(parallel [(set (match_operand:DI 2 \"register_operand\" \"\") (reg:DI 27))\n+\t      (call (mem:SI (match_operand 0 \"register_operand\" \"\"))\n \t\t    (match_operand 1 \"\" \"\"))\n+\t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n-\t      (clobber (reg:DI 4))\n+\t      (use (match_dup 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n \t      (use (const_int 1))])]\n   \"TARGET_64BIT && reload_completed\"\n-  [(parallel [(call (mem:SI (match_dup 0))\n+  [(set (match_dup 2) (reg:DI 27))\n+   (parallel [(call (mem:SI (match_dup 0))\n \t\t    (match_dup 1))\n+\t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n-\t      (use (const_int 1))])]\n+\t      (use (const_int 1))])\n+   (set (reg:DI 27) (match_dup 2))]\n   \"\")\n \n (define_insn \"*call_reg_64bit_post_reload\"\n   [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"r\"))\n \t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:DI 1))\n    (clobber (reg:DI 2))\n    (use (reg:DI 27))\n    (use (reg:DI 29))\n@@ -8168,37 +8162,46 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n      need to have a use of the PIC register in the return pattern and\n      the final save/restore operation is not needed.\n      \n-     I elected to just clobber %r4 in the PIC patterns and use it instead\n+     I elected to just use register %r4 in the PIC patterns instead\n      of trying to force hppa_pic_save_rtx () to a callee saved register.\n      This might have required a new register class and constraint.  It\n      was also simpler to just handle the restore from a register than a\n      generic pseudo.  */\n   if (TARGET_64BIT)\n     {\n+      rtx r4 = gen_rtx_REG (word_mode, 4);\n       if (GET_CODE (op) == SYMBOL_REF)\n-\tcall_insn = emit_call_insn (gen_call_val_symref_64bit (dst, op, nb));\n+\tcall_insn\n+\t  = emit_call_insn (gen_call_val_symref_64bit (dst, op, nb, r4));\n       else\n \t{\n \t  op = force_reg (word_mode, op);\n-\t  call_insn = emit_call_insn (gen_call_val_reg_64bit (dst, op, nb));\n+\t  call_insn\n+\t    = emit_call_insn (gen_call_val_reg_64bit (dst, op, nb, r4));\n \t}\n     }\n   else\n     {\n       if (GET_CODE (op) == SYMBOL_REF)\n \t{\n \t  if (flag_pic)\n-\t    call_insn = emit_call_insn (gen_call_val_symref_pic (dst, op, nb));\n+\t    {\n+\t      rtx r4 = gen_rtx_REG (word_mode, 4);\n+\t      call_insn\n+\t\t= emit_call_insn (gen_call_val_symref_pic (dst, op, nb, r4));\n+\t    }\n \t  else\n \t    call_insn = emit_call_insn (gen_call_val_symref (dst, op, nb));\n \t}\n       else\n \t{\n \t  rtx tmpreg = gen_rtx_REG (word_mode, 22);\n-\n \t  emit_move_insn (tmpreg, force_reg (word_mode, op));\n \t  if (flag_pic)\n-\t    call_insn = emit_call_insn (gen_call_val_reg_pic (dst, nb));\n+\t    {\n+\t      rtx r4 = gen_rtx_REG (word_mode, 4);\n+\t      call_insn = emit_call_insn (gen_call_val_reg_pic (dst, nb, r4));\n+\t    }\n \t  else\n \t    call_insn = emit_call_insn (gen_call_val_reg (dst, nb));\n \t}\n@@ -8224,74 +8227,69 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n    (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n \n (define_insn \"call_val_symref_pic\"\n-  [(set (match_operand 0 \"\" \"\")\n+  [(set (match_operand:SI 3 \"register_operand\" \"=&r\") (reg:SI 19))\n+   (set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t      (match_operand 2 \"\" \"i\")))\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n-   (clobber (reg:SI 4))\n+   (use (match_dup 3))\n    (use (reg:SI 19))\n    (use (const_int 0))]\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n-  \"*\n-{\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[1], 0);\n-}\"\n-  [(set_attr \"type\" \"call\")\n-   (set (attr \"length\")\n-\t(plus (symbol_ref \"attr_length_call (insn, 0)\")\n-\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n-\n-;; Split out the PIC register save and restore after reload.  This is\n-;; done only if the function returns.  As the split is done after reload,\n-;; there are some situations in which we unnecessarily save and restore\n-;; %r4.  This happens when there is a single call and the PIC register\n-;; is \"dead\" after the call.  This isn't easy to fix as the usage of\n-;; the PIC register isn't completely determined until the reload pass.\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n (define_split\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n+  [(parallel [(set (match_operand:SI 3 \"register_operand\" \"\") (reg:SI 19))\n+\t      (set (match_operand 0 \"\" \"\")\n \t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t\t    (match_operand 2 \"\" \"\")))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n-\t      (clobber (reg:SI 4))\n+\t      (use (match_dup 3))\n \t      (use (reg:SI 19))\n \t      (use (const_int 0))])]\n-  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\n-   && reload_completed\n-   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n-  [(set (reg:SI 4) (reg:SI 19))\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 3) (reg:SI 19))\n    (parallel [(set (match_dup 0)\n \t      (call (mem:SI (match_dup 1))\n \t\t    (match_dup 2)))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n \t      (use (reg:SI 19))\n-\t      (use (const_int 0))])\n-   (set (reg:SI 19) (reg:SI 4))]\n+\t      (use (const_int 0))])]\n   \"\")\n \n-;; Remove the clobber of register 4 when optimizing.  This has to be\n-;; done with a peephole optimization rather than a split because the\n-;; split sequence for a call must be longer than one instruction.\n-(define_peephole2\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n+(define_split\n+  [(parallel [(set (match_operand:SI 3 \"register_operand\" \"\") (reg:SI 19))\n+\t      (set (match_operand 0 \"\" \"\")\n \t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t\t    (match_operand 2 \"\" \"\")))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n-\t      (clobber (reg:SI 4))\n+\t      (use (match_dup 3))\n \t      (use (reg:SI 19))\n \t      (use (const_int 0))])]\n   \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT && reload_completed\"\n-  [(parallel [(set (match_dup 0)\n+  [(set (match_dup 3) (reg:SI 19))\n+   (parallel [(set (match_dup 0)\n \t      (call (mem:SI (match_dup 1))\n \t\t    (match_dup 2)))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n \t      (use (reg:SI 19))\n-\t      (use (const_int 0))])]\n+\t      (use (const_int 0))])\n+   (set (reg:SI 19) (match_dup 3))]\n   \"\")\n \n (define_insn \"*call_val_symref_pic_post_reload\"\n@@ -8314,79 +8312,74 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n (define_insn \"call_val_symref_64bit\"\n-  [(set (match_operand 0 \"\" \"\")\n+  [(set (match_operand:DI 3 \"register_operand\" \"=&r\") (reg:DI 27))\n+   (set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t      (match_operand 2 \"\" \"i\")))\n    (clobber (reg:DI 1))\n    (clobber (reg:DI 2))\n-   (clobber (reg:DI 4))\n+   (use (match_dup 3))\n    (use (reg:DI 27))\n    (use (reg:DI 29))\n    (use (const_int 0))]\n   \"TARGET_64BIT\"\n-  \"*\n-{\n-  output_arg_descriptor (insn);\n-  return output_call (insn, operands[1], 0);\n-}\"\n-  [(set_attr \"type\" \"call\")\n-   (set (attr \"length\")\n-\t(plus (symbol_ref \"attr_length_call (insn, 0)\")\n-\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n-\n-;; Split out the PIC register save and restore after reload.  This is\n-;; done only if the function returns.  As the split is done after reload,\n-;; there are some situations in which we unnecessarily save and restore\n-;; %r4.  This happens when there is a single call and the PIC register\n-;; is \"dead\" after the call.  This isn't easy to fix as the usage of\n-;; the PIC register isn't completely determined until the reload pass.\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n (define_split\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n+  [(parallel [(set (match_operand:DI 3 \"register_operand\" \"\") (reg:DI 27))\n+\t      (set (match_operand 0 \"\" \"\")\n \t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t\t    (match_operand 2 \"\" \"\")))\n \t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n-\t      (clobber (reg:DI 4))\n+\t      (use (match_dup 3))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n \t      (use (const_int 0))])]\n-  \"TARGET_64BIT\n-   && reload_completed\n-   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n-  [(set (reg:DI 4) (reg:DI 27))\n+  \"TARGET_64BIT && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 3) (reg:DI 27))\n    (parallel [(set (match_dup 0)\n \t      (call (mem:SI (match_dup 1))\n \t\t    (match_dup 2)))\n \t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n-\t      (use (const_int 0))])\n-   (set (reg:DI 27) (reg:DI 4))]\n+\t      (use (const_int 0))])]\n   \"\")\n \n-;; Remove the clobber of register 4 when optimizing.  This has to be\n-;; done with a peephole optimization rather than a split because the\n-;; split sequence for a call must be longer than one instruction.\n-(define_peephole2\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n+(define_split\n+  [(parallel [(set (match_operand:DI 3 \"register_operand\" \"\") (reg:DI 27))\n+\t      (set (match_operand 0 \"\" \"\")\n \t      (call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t\t    (match_operand 2 \"\" \"\")))\n \t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n-\t      (clobber (reg:DI 4))\n+\t      (use (match_dup 3))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n \t      (use (const_int 0))])]\n   \"TARGET_64BIT && reload_completed\"\n-  [(parallel [(set (match_dup 0)\n+  [(set (match_dup 3) (reg:DI 27))\n+   (parallel [(set (match_dup 0)\n \t      (call (mem:SI (match_dup 1))\n \t\t    (match_dup 2)))\n \t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n-\t      (use (const_int 0))])]\n+\t      (use (const_int 0))])\n+   (set (reg:DI 27) (match_dup 3))]\n   \"\")\n \n (define_insn \"*call_val_symref_64bit_post_reload\"\n@@ -8425,73 +8418,69 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n (define_insn \"call_val_reg_pic\"\n-  [(set (match_operand 0 \"\" \"\")\n+  [(set (match_operand:SI 2 \"register_operand\" \"=&r\") (reg:SI 19))\n+   (set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (reg:SI 22))\n \t      (match_operand 1 \"\" \"i\")))\n    (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n-   (clobber (reg:SI 4))\n+   (use (match_dup 2))\n    (use (reg:SI 19))\n    (use (const_int 1))]\n   \"!TARGET_64BIT\"\n-  \"*\n-{\n-  return output_indirect_call (insn, gen_rtx_REG (word_mode, 22));\n-}\"\n-  [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\")\n-\t(plus (symbol_ref \"attr_length_indirect_call (insn)\")\n-\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n-\n-;; Split out the PIC register save and restore after reload.  This is\n-;; done only if the function returns.  As the split is done after reload,\n-;; there are some situations in which we unnecessarily save and restore\n-;; %r4.  This happens when there is a single call and the PIC register\n-;; is \"dead\" after the call.  This isn't easy to fix as the usage of\n-;; the PIC register isn't completely determined until the reload pass.\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n (define_split\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n+  [(parallel [(set (match_operand:SI 2 \"register_operand\" \"\") (reg:SI 19))\n+\t      (set (match_operand 0 \"\" \"\")\n \t\t   (call (mem:SI (reg:SI 22))\n \t\t\t (match_operand 1 \"\" \"\")))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n-\t      (clobber (reg:SI 4))\n+\t      (use (match_dup 2))\n \t      (use (reg:SI 19))\n \t      (use (const_int 1))])]\n-  \"!TARGET_64BIT\n-   && reload_completed\n-   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n-  [(set (reg:SI 4) (reg:SI 19))\n+  \"!TARGET_64BIT && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 2) (reg:SI 19))\n    (parallel [(set (match_dup 0)\n \t\t   (call (mem:SI (reg:SI 22))\n \t\t\t (match_dup 1)))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n \t      (use (reg:SI 19))\n-\t      (use (const_int 1))])\n-   (set (reg:SI 19) (reg:SI 4))]\n+\t      (use (const_int 1))])]\n   \"\")\n \n-;; Remove the clobber of register 4 when optimizing.  This has to be\n-;; done with a peephole optimization rather than a split because the\n-;; split sequence for a call must be longer than one instruction.\n-(define_peephole2\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n+(define_split\n+  [(parallel [(set (match_operand:SI 2 \"register_operand\" \"\") (reg:SI 19))\n+\t      (set (match_operand 0 \"\" \"\")\n \t\t   (call (mem:SI (reg:SI 22))\n \t\t\t (match_operand 1 \"\" \"\")))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n-\t      (clobber (reg:SI 4))\n+\t      (use (match_dup 2))\n \t      (use (reg:SI 19))\n \t      (use (const_int 1))])]\n   \"!TARGET_64BIT && reload_completed\"\n-  [(parallel [(set (match_dup 0)\n+  [(set (match_dup 2) (reg:SI 19))\n+   (parallel [(set (match_dup 0)\n \t\t   (call (mem:SI (reg:SI 22))\n \t\t\t (match_dup 1)))\n \t      (clobber (reg:SI 1))\n \t      (clobber (reg:SI 2))\n \t      (use (reg:SI 19))\n-\t      (use (const_int 1))])]\n+\t      (use (const_int 1))])\n+   (set (reg:SI 19) (match_dup 2))]\n   \"\")\n \n (define_insn \"*call_val_reg_pic_post_reload\"\n@@ -8513,79 +8502,81 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n ;; This pattern is split if it is necessary to save and restore the\n ;; PIC register.\n (define_insn \"call_val_reg_64bit\"\n-  [(set (match_operand 0 \"\" \"\")\n+  [(set (match_operand:DI 3 \"register_operand\" \"=&r\") (reg:DI 27))\n+   (set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:DI 1 \"register_operand\" \"r\"))\n \t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:DI 1))\n    (clobber (reg:DI 2))\n-   (clobber (reg:DI 4))\n+   (use (match_dup 3))\n    (use (reg:DI 27))\n    (use (reg:DI 29))\n    (use (const_int 1))]\n   \"TARGET_64BIT\"\n-  \"*\n-{\n-  return output_indirect_call (insn, operands[1]);\n-}\"\n-  [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\")\n-\t(plus (symbol_ref \"attr_length_indirect_call (insn)\")\n-\t      (symbol_ref \"attr_length_save_restore_dltp (insn)\")))])\n-\n-;; Split out the PIC register save and restore after reload.  This is\n-;; done only if the function returns.  As the split is done after reload,\n-;; there are some situations in which we unnecessarily save and restore\n-;; %r4.  This happens when there is a single call and the PIC register\n-;; is \"dead\" after the call.  This isn't easy to fix as the usage of\n-;; the PIC register isn't completely determined until the reload pass.\n+  \"#\")\n+\n+;; Split out the PIC register save and restore after reload.  As the\n+;; split is done after reload, there are some situations in which we\n+;; unnecessarily save and restore %r4.  This happens when there is a\n+;; single call and the PIC register is not used after the call.\n+;;\n+;; The split has to be done since call_from_call_insn () can't handle\n+;; the pattern as is.  Noreturn calls are special because they have to\n+;; terminate the basic block.  The split has to contain more than one\n+;; insn.\n (define_split\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n+  [(parallel [(set (match_operand:DI 3 \"register_operand\" \"\") (reg:DI 27))\n+\t      (set (match_operand 0 \"\" \"\")\n \t\t   (call (mem:SI (match_operand:DI 1 \"register_operand\" \"\"))\n \t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n-\t      (clobber (reg:DI 4))\n+\t      (use (match_dup 3))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n \t      (use (const_int 1))])]\n-  \"TARGET_64BIT\n-   && reload_completed\n-   && !find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n-  [(set (reg:DI 4) (reg:DI 27))\n+  \"TARGET_64BIT && reload_completed\n+   && find_reg_note (insn, REG_NORETURN, NULL_RTX)\"\n+  [(set (match_dup 3) (reg:DI 27))\n    (parallel [(set (match_dup 0)\n \t\t   (call (mem:SI (match_dup 1))\n \t\t\t (match_dup 2)))\n+\t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n-\t      (use (const_int 1))])\n-   (set (reg:DI 27) (reg:DI 4))]\n+\t      (use (const_int 1))])]\n   \"\")\n \n-;; Remove the clobber of register 4 when optimizing.  This has to be\n-;; done with a peephole optimization rather than a split because the\n-;; split sequence for a call must be longer than one instruction.\n-(define_peephole2\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n+(define_split\n+  [(parallel [(set (match_operand:DI 3 \"register_operand\" \"\") (reg:DI 27))\n+\t      (set (match_operand 0 \"\" \"\")\n \t\t   (call (mem:SI (match_operand:DI 1 \"register_operand\" \"\"))\n \t\t\t (match_operand 2 \"\" \"\")))\n+\t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n-\t      (clobber (reg:DI 4))\n+\t      (use (match_dup 3))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n \t      (use (const_int 1))])]\n   \"TARGET_64BIT && reload_completed\"\n-  [(parallel [(set (match_dup 0)\n+  [(set (match_dup 3) (reg:DI 27))\n+   (parallel [(set (match_dup 0)\n \t\t   (call (mem:SI (match_dup 1))\n \t\t\t (match_dup 2)))\n+\t      (clobber (reg:DI 1))\n \t      (clobber (reg:DI 2))\n \t      (use (reg:DI 27))\n \t      (use (reg:DI 29))\n-\t      (use (const_int 1))])]\n+\t      (use (const_int 1))])\n+   (set (reg:DI 27) (match_dup 3))]\n   \"\")\n \n (define_insn \"*call_val_reg_64bit_post_reload\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:SI (match_operand:DI 1 \"register_operand\" \"r\"))\n \t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:DI 1))\n    (clobber (reg:DI 2))\n    (use (reg:DI 27))\n    (use (reg:DI 29))"}]}