{"sha": "00f6de9c69119594f7dad3bd525937c94c8200d0", "node_id": "C_kwDOANBUbNoAKDAwZjZkZTljNjkxMTk1OTRmN2RhZDNiZDUyNTkzN2M5NGM4MjAwZDA", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-09-27T12:04:54Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-09-27T12:04:54Z"}, "message": "Fortran: Fix assumed-size to assumed-rank passing [PR94070]\n\nThis code inlines the size0 and size1 libgfortran calls, the former is still\nused by libgfortan itself (and by old code). Besides permitting more\noptimizations, it also permits to handle assumed-rank dummies better: If the\ndummy argument is a nonpointer/nonallocatable, an assumed-size actual arg is\nrepesented by having ubound == -1 for the last dimension. However, for\nallocatable/pointers, this value can also exist. Hence, the dummy arg attr\nhas to be honored.\n\nFor that reason, when calling an assumed-rank procedure with nonpointer,\nnonallocatable dummy arguments, the bounds have to be updated to avoid\nthe case ubound == -1 for the last dimension.\n\n\tPR fortran/94070\n\ngcc/fortran/ChangeLog:\n\n\t* trans-array.c (gfc_tree_array_size): New function to\n\tfind size inline (whole array or one dimension).\n\t(array_parameter_size): Use it, take stmt_block as arg.\n\t(gfc_conv_array_parameter): Update call.\n\t* trans-array.h (gfc_tree_array_size): Add prototype.\n\t* trans-decl.c (gfor_fndecl_size0, gfor_fndecl_size1): Remove\n\tthese global vars.\n\t(gfc_build_intrinsic_function_decls): Remove their initialization.\n\t* trans-expr.c (gfc_conv_procedure_call): Update\n\tbounds of pointer/allocatable actual args to nonallocatable/nonpointer\n\tdummies to be one based.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_shape): Fix case for\n\tassumed rank with allocatable/pointer dummy.\n\t(gfc_conv_intrinsic_size): Update to use inline function.\n\t* trans.h (gfor_fndecl_size0, gfor_fndecl_size1): Remove var decl.\n\nlibgfortran/ChangeLog:\n\n\t* intrinsics/size.c (size0, size1): Comment that now not\n\tused by newer compiler code.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.oacc-fortran/privatized-ref-2.f90: Update\n\texpected dg-note output.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/c-interop/cf-out-descriptor-6.f90: Remove xfail.\n\t* gfortran.dg/c-interop/size.f90: Remove xfail.\n\t* gfortran.dg/intrinsic_size_3.f90: Update scan-tree-dump-times.\n\t* gfortran.dg/transpose_optimization_2.f90: Likewise.\n\t* gfortran.dg/size_optional_dim_1.f90: Add scan-tree-dump-not.\n\t* gfortran.dg/assumed_rank_22.f90: New test.\n\t* gfortran.dg/assumed_rank_22_aux.c: New test.", "tree": {"sha": "5133e52eac80818ae2e4b4180af6e462af8b3571", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5133e52eac80818ae2e4b4180af6e462af8b3571"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00f6de9c69119594f7dad3bd525937c94c8200d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f6de9c69119594f7dad3bd525937c94c8200d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00f6de9c69119594f7dad3bd525937c94c8200d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00f6de9c69119594f7dad3bd525937c94c8200d0/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76773d3fea4daaaf5b0f6d79d9f48ffe6b3c97fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76773d3fea4daaaf5b0f6d79d9f48ffe6b3c97fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76773d3fea4daaaf5b0f6d79d9f48ffe6b3c97fd"}], "stats": {"total": 611, "additions": 482, "deletions": 129}, "files": [{"sha": "b8061f37772aaff070b752b6d045beef5a84cc48", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 139, "deletions": 26, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -7901,31 +7901,143 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n   gfc_cleanup_loop (&loop);\n }\n \n+\n+/* Calculate the array size (number of elements); if dim != NULL_TREE,\n+   return size for that dim (dim=0..rank-1; only for GFC_DESCRIPTOR_TYPE_P).  */\n+tree\n+gfc_tree_array_size (stmtblock_t *block, tree desc, gfc_expr *expr, tree dim)\n+{\n+  if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n+    {\n+      gcc_assert (dim == NULL_TREE);\n+      return GFC_TYPE_ARRAY_SIZE (TREE_TYPE (desc));\n+    }\n+  tree size, tmp, rank = NULL_TREE, cond = NULL_TREE;\n+  symbol_attribute attr = gfc_expr_attr (expr);\n+  gfc_array_spec *as = gfc_get_full_arrayspec_from_expr (expr);\n+  gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)));\n+  if ((!attr.pointer && !attr.allocatable && as && as->type == AS_ASSUMED_RANK)\n+       || !dim)\n+    {\n+      if (expr->rank < 0)\n+\trank = fold_convert (signed_char_type_node,\n+\t\t\t     gfc_conv_descriptor_rank (desc));\n+      else\n+\trank = build_int_cst (signed_char_type_node, expr->rank);\n+    }\n+\n+  if (dim || expr->rank == 1)\n+    {\n+      if (!dim)\n+\tdim = gfc_index_zero_node;\n+      tree ubound = gfc_conv_descriptor_ubound_get (desc, dim);\n+      tree lbound = gfc_conv_descriptor_lbound_get (desc, dim);\n+\n+      size = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t      gfc_array_index_type, ubound, lbound);\n+      size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      size, gfc_index_one_node);\n+      /* if (!allocatable && !pointer && assumed rank)\n+\t   size = (idx == rank && ubound[rank-1] == -1 ? -1 : size;\n+\t else\n+\t   size = max (0, size);  */\n+      size = fold_build2_loc (input_location, MAX_EXPR, gfc_array_index_type,\n+\t\t\t      size, gfc_index_zero_node);\n+      if (!attr.pointer && !attr.allocatable\n+\t  && as && as->type == AS_ASSUMED_RANK)\n+\t{\n+\t  tmp = fold_build2_loc (input_location, MINUS_EXPR, signed_char_type_node,\n+\t\t\t\t rank, build_int_cst (signed_char_type_node, 1));\n+\t  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t  fold_convert (signed_char_type_node, dim),\n+\t\t\t\t  tmp);\n+\t  tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t gfc_conv_descriptor_ubound_get (desc, dim),\n+\t\t\t\t build_int_cst (gfc_array_index_type, -1));\n+\t  cond = fold_build2_loc (input_location, TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t  cond, tmp);\n+\t  tmp = build_int_cst (gfc_array_index_type, -1);\n+\t  size = build3_loc (input_location, COND_EXPR, gfc_array_index_type,\n+\t\t\t     cond, tmp, size);\n+\t}\n+      return size;\n+    }\n+\n+  /* size = 1. */\n+  size = gfc_create_var (gfc_array_index_type, \"size\");\n+  gfc_add_modify (block, size, build_int_cst (TREE_TYPE (size), 1));\n+  tree extent = gfc_create_var (gfc_array_index_type, \"extent\");\n+\n+  stmtblock_t cond_block, loop_body;\n+  gfc_init_block (&cond_block);\n+  gfc_init_block (&loop_body);\n+\n+  /* Loop: for (i = 0; i < rank; ++i).  */\n+  tree idx = gfc_create_var (signed_char_type_node, \"idx\");\n+  /* Loop body.  */\n+  /* #if (assumed-rank + !allocatable && !pointer)\n+       if (idx == rank - 1 && dim[idx].ubound == -1)\n+\t extent = -1;\n+       else\n+     #endif\n+\t extent = gfc->dim[i].ubound - gfc->dim[i].lbound + 1\n+\t if (extent < 0)\n+\t   extent = 0\n+      size *= extent.  */\n+  cond = NULL_TREE;\n+  if (!attr.pointer && !attr.allocatable && as && as->type == AS_ASSUMED_RANK)\n+    {\n+      tmp = fold_build2_loc (input_location, MINUS_EXPR, signed_char_type_node,\n+\t\t\t     rank, build_int_cst (signed_char_type_node, 1));\n+      cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t\t  idx, tmp);\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t     gfc_conv_descriptor_ubound_get (desc, idx),\n+\t\t\t     build_int_cst (gfc_array_index_type, -1));\n+      cond = fold_build2_loc (input_location, TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t      cond, tmp);\n+    }\n+  tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t gfc_conv_descriptor_ubound_get (desc, idx),\n+\t\t\t gfc_conv_descriptor_lbound_get (desc, idx));\n+  tmp = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t tmp, gfc_index_one_node);\n+  gfc_add_modify (&cond_block, extent, tmp);\n+  tmp = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t extent, gfc_index_zero_node);\n+  tmp = build3_v (COND_EXPR, tmp,\n+\t\t  fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t   gfc_array_index_type,\n+\t\t\t\t   extent, gfc_index_zero_node),\n+\t\t  build_empty_stmt (input_location));\n+  gfc_add_expr_to_block (&cond_block, tmp);\n+  tmp = gfc_finish_block (&cond_block);\n+  if (cond)\n+    tmp = build3_v (COND_EXPR, cond,\n+\t\t    fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t     gfc_array_index_type, extent,\n+\t\t\t\t     build_int_cst (gfc_array_index_type, -1)),\n+\t\t    tmp);\n+   gfc_add_expr_to_block (&loop_body, tmp);\n+   /* size *= extent.  */\n+   gfc_add_modify (&loop_body, size,\n+\t\t   fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t    size, extent));\n+  /* Generate loop. */\n+  gfc_simple_for_loop (block, idx, build_int_cst (TREE_TYPE (idx), 0), rank, LT_EXPR,\n+\t\t       build_int_cst (TREE_TYPE (idx), 1),\n+\t\t       gfc_finish_block (&loop_body));\n+  return size;\n+}\n+\n /* Helper function for gfc_conv_array_parameter if array size needs to be\n    computed.  */\n \n static void\n-array_parameter_size (tree desc, gfc_expr *expr, tree *size)\n+array_parameter_size (stmtblock_t *block, tree desc, gfc_expr *expr, tree *size)\n {\n   tree elem;\n-  if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n-    *size = GFC_TYPE_ARRAY_SIZE (TREE_TYPE (desc));\n-  else if (expr->rank > 1)\n-    *size = build_call_expr_loc (input_location,\n-\t\t\t     gfor_fndecl_size0, 1,\n-\t\t\t     gfc_build_addr_expr (NULL, desc));\n-  else\n-    {\n-      tree ubound = gfc_conv_descriptor_ubound_get (desc, gfc_index_zero_node);\n-      tree lbound = gfc_conv_descriptor_lbound_get (desc, gfc_index_zero_node);\n-\n-      *size = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t       gfc_array_index_type, ubound, lbound);\n-      *size = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n-\t\t\t       *size, gfc_index_one_node);\n-      *size = fold_build2_loc (input_location, MAX_EXPR, gfc_array_index_type,\n-\t\t\t       *size, gfc_index_zero_node);\n-    }\n+  *size = gfc_tree_array_size (block, desc, expr, NULL);\n   elem = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (desc)));\n   *size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n \t\t\t   *size, fold_convert (gfc_array_index_type, elem));\n@@ -8035,7 +8147,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n           else\n \t    se->expr = gfc_build_addr_expr (NULL_TREE, tmp);\n \t  if (size)\n-\t    array_parameter_size (tmp, expr, size);\n+\t    array_parameter_size (&se->pre, tmp, expr, size);\n \t  return;\n         }\n \n@@ -8047,7 +8159,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n \t      tmp = se->expr;\n \t    }\n \t  if (size)\n-\t    array_parameter_size (tmp, expr, size);\n+\t    array_parameter_size (&se->pre, tmp, expr, size);\n \t  se->expr = gfc_conv_array_data (tmp);\n           return;\n         }\n@@ -8122,7 +8234,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n       if (expr->ts.type == BT_CHARACTER && expr->expr_type != EXPR_FUNCTION)\n \tse->string_length = expr->ts.u.cl->backend_decl;\n       if (size)\n-\tarray_parameter_size (se->expr, expr, size);\n+\tarray_parameter_size (&se->pre, se->expr, expr, size);\n       se->expr = gfc_conv_array_data (se->expr);\n       return;\n     }\n@@ -8132,7 +8244,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n       /* Result of the enclosing function.  */\n       gfc_conv_expr_descriptor (se, expr);\n       if (size)\n-\tarray_parameter_size (se->expr, expr, size);\n+\tarray_parameter_size (&se->pre, se->expr, expr, size);\n       se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n \n       if (g77 && TREE_TYPE (TREE_TYPE (se->expr)) != NULL_TREE\n@@ -8149,9 +8261,10 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n       gfc_conv_expr_descriptor (se, expr);\n \n       if (size)\n-\tarray_parameter_size (build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t       se->expr),\n-\t\t\t\t  expr, size);\n+\tarray_parameter_size (&se->pre,\n+\t\t\t      build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t\t    se->expr),\n+\t\t\t      expr, size);\n     }\n \n   /* Deallocate the allocatable components of structures that are"}, {"sha": "85ff2161191a32df466e0c83a3e621da73c3fcf2", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -39,6 +39,8 @@ void gfc_trans_dummy_array_bias (gfc_symbol *, tree, gfc_wrapped_block *);\n /* Generate entry and exit code for g77 calling convention arrays.  */\n void gfc_trans_g77_array (gfc_symbol *, gfc_wrapped_block *);\n \n+tree gfc_tree_array_size (stmtblock_t *, tree, gfc_expr *, tree);\n+\n tree gfc_full_array_size (stmtblock_t *, tree, int);\n \n tree gfc_duplicate_allocatable (tree, tree, tree, int, tree);"}, {"sha": "c758d26febf06af1a2aacd4a156352f026788adc", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -214,8 +214,6 @@ tree gfor_fndecl_convert_char4_to_char1;\n \n \n /* Other misc. runtime library functions.  */\n-tree gfor_fndecl_size0;\n-tree gfor_fndecl_size1;\n tree gfor_fndecl_iargc;\n tree gfor_fndecl_kill;\n tree gfor_fndecl_kill_sub;\n@@ -3692,18 +3690,6 @@ gfc_build_intrinsic_function_decls (void)\n   }\n \n   /* Other functions.  */\n-  gfor_fndecl_size0 = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"size0\")), \". R \",\n-\tgfc_array_index_type, 1, pvoid_type_node);\n-  DECL_PURE_P (gfor_fndecl_size0) = 1;\n-  TREE_NOTHROW (gfor_fndecl_size0) = 1;\n-\n-  gfor_fndecl_size1 = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"size1\")), \". R . \",\n-\tgfc_array_index_type, 2, pvoid_type_node, gfc_array_index_type);\n-  DECL_PURE_P (gfor_fndecl_size1) = 1;\n-  TREE_NOTHROW (gfor_fndecl_size1) = 1;\n-\n   gfor_fndecl_iargc = gfc_build_library_function_decl (\n \tget_identifier (PREFIX (\"iargc\")), gfc_int4_type_node, 0);\n   TREE_NOTHROW (gfor_fndecl_iargc) = 1;"}, {"sha": "1c24556c2993545c4ef48941f263dde7f149c0c6", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -6450,6 +6450,29 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t    parmse.force_tmp = 1;\n \t\t}\n \n+\t      /* Special case for assumed-rank arrays: when passing an\n+\t\t argument to a nonallocatable/nonpointer dummy, the bounds have\n+\t\t to be reset as otherwise a last-dim ubound of -1 is\n+\t\t indistinguishable from an assumed-size array in the callee.  */\n+\t      if (!sym->attr.is_bind_c && e && fsym && fsym->as\n+\t\t  && fsym->as->type == AS_ASSUMED_RANK\n+\t\t  && e->rank != -1\n+\t\t  && e->expr_type == EXPR_VARIABLE\n+\t\t  && ((fsym->ts.type == BT_CLASS\n+\t\t       && !CLASS_DATA (fsym)->attr.class_pointer\n+\t\t       && !CLASS_DATA (fsym)->attr.allocatable)\n+\t\t      || (fsym->ts.type != BT_CLASS\n+\t\t\t  && !fsym->attr.pointer && !fsym->attr.allocatable)))\n+\t\t{\n+\t\t  /* Change AR_FULL to a (:,:,:) ref to force bounds update. */\n+\t\t  gfc_ref *ref;\n+\t\t  for (ref = e->ref; ref->next; ref = ref->next)\n+\t\t    ;\n+\t\t  if (ref->u.ar.type == AR_FULL\n+\t\t      && ref->u.ar.as->type != AS_ASSUMED_SIZE)\n+\t\t    ref->u.ar.type = AR_SECTION;\n+\t\t}\n+\n \t      if (sym->attr.is_bind_c && e\n \t\t  && (is_CFI_desc (fsym, NULL) || assumed_length_string))\n \t\t/* Implement F2018, 18.3.6, list item (5), bullet point 2.  */\n@@ -6510,16 +6533,26 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\tgfc_conv_array_parameter (&parmse, e, nodesc_arg, fsym,\n \t\t\t\t\t  sym->name, NULL);\n \n-\t      /* Unallocated allocatable arrays and unassociated pointer arrays\n-\t\t need their dtype setting if they are argument associated with\n-\t\t assumed rank dummies, unless already assumed rank.  */\n+\t      /* Special case for assumed-rank arrays. */\n \t      if (!sym->attr.is_bind_c && e && fsym && fsym->as\n \t\t  && fsym->as->type == AS_ASSUMED_RANK\n \t\t  && e->rank != -1)\n \t\t{\n-\t\t  if (gfc_expr_attr (e).pointer\n+\t\t  if ((gfc_expr_attr (e).pointer\n \t\t      || gfc_expr_attr (e).allocatable)\n-\t\t    set_dtype_for_unallocated (&parmse, e);\n+\t\t      && ((fsym->ts.type == BT_CLASS\n+\t\t\t   && (CLASS_DATA (fsym)->attr.class_pointer\n+\t\t\t       || CLASS_DATA (fsym)->attr.allocatable))\n+\t\t\t  || (fsym->ts.type != BT_CLASS\n+\t\t\t      && (fsym->attr.pointer || fsym->attr.allocatable))))\n+\t\t    {\n+\t\t      /* Unallocated allocatable arrays and unassociated pointer\n+\t\t\t arrays need their dtype setting if they are argument\n+\t\t\t associated with assumed rank dummies. However, if the\n+\t\t\t dummy is nonallocate/nonpointer, the user may not\n+\t\t\t pass those. Hence, it can be skipped.  */\n+\t\t      set_dtype_for_unallocated (&parmse, e);\n+\t\t    }\n \t\t  else if (e->expr_type == EXPR_VARIABLE\n \t\t\t   && e->ref\n \t\t\t   && e->ref->u.ar.type == AR_FULL"}, {"sha": "900a1a2981799211f53c333c887aa0ed9fe6ea23", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 48, "deletions": 71, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -6697,6 +6697,8 @@ gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)\n   gfc_expr *e;\n   gfc_array_spec *as;\n   gfc_ss *ss;\n+  symbol_attribute attr;\n+  tree result_desc = se->expr;\n \n   /* Remove the KIND argument, if present. */\n   s = expr->value.function.actual;\n@@ -6707,17 +6709,25 @@ gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)\n \n   gfc_conv_intrinsic_funcall (se, expr);\n \n-  as = gfc_get_full_arrayspec_from_expr (s->expr);;\n-  ss = gfc_walk_expr (s->expr);\n-\n   /* According to F2018 16.9.172, para 5, an assumed rank entity, argument\n      associated with an assumed size array, has the ubound of the final\n      dimension set to -1 and SHAPE must return this.  */\n-  if (as && as->type == AS_ASSUMED_RANK\n-      && se->expr && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se->expr))\n-      && ss && ss->info->type == GFC_SS_SECTION)\n+\n+  as = gfc_get_full_arrayspec_from_expr (s->expr);\n+  if (!as || as->type != AS_ASSUMED_RANK)\n+    return;\n+  attr = gfc_expr_attr (s->expr);\n+  ss = gfc_walk_expr (s->expr);\n+  if (attr.pointer || attr.allocatable\n+      || !ss || ss->info->type != GFC_SS_SECTION)\n+    return;\n+  if (se->expr)\n+    result_desc = se->expr;\n+  if (POINTER_TYPE_P (TREE_TYPE (result_desc)))\n+    result_desc = build_fold_indirect_ref_loc (input_location, result_desc);\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (result_desc)))\n     {\n-      tree desc, rank, minus_one, cond, ubound, tmp;\n+      tree rank, minus_one, cond, ubound, tmp;\n       stmtblock_t block;\n       gfc_se ase;\n \n@@ -6745,8 +6755,7 @@ gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)\n \n       /* Obtain the last element of the result from the library shape\n \t intrinsic and set it to -1 if that is the value of ubound.  */\n-      desc = se->expr;\n-      tmp = gfc_conv_array_data (desc);\n+      tmp = gfc_conv_array_data (result_desc);\n       tmp = build_fold_indirect_ref_loc (input_location, tmp);\n       tmp = gfc_build_array_ref (tmp, rank, NULL, NULL);\n \n@@ -6758,7 +6767,6 @@ gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)\n \t\t       build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&se->pre, cond);\n     }\n-\n }\n \n static void\n@@ -7968,8 +7976,7 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n   gfc_actual_arglist *actual;\n   tree arg1;\n   tree type;\n-  tree fncall0;\n-  tree fncall1;\n+  tree size;\n   gfc_se argse;\n   gfc_expr *e;\n   gfc_symbol *sym = NULL;\n@@ -8046,97 +8053,67 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n       /* For functions that return a class array conv_expr_descriptor is not\n \t able to get the descriptor right.  Therefore this special case.  */\n       gfc_conv_expr_reference (&argse, e);\n-      argse.expr = gfc_build_addr_expr (NULL_TREE,\n-\t\t\t\t\tgfc_class_data_get (argse.expr));\n+      argse.expr = gfc_class_data_get (argse.expr);\n     }\n   else if (sym && sym->backend_decl)\n     {\n       gcc_assert (GFC_CLASS_TYPE_P (TREE_TYPE (sym->backend_decl)));\n-      argse.expr = sym->backend_decl;\n-      argse.expr = gfc_build_addr_expr (NULL_TREE,\n-\t\t\t\t\tgfc_class_data_get (argse.expr));\n+      argse.expr = gfc_class_data_get (sym->backend_decl);\n     }\n   else\n-    {\n-      argse.want_pointer = 1;\n-      gfc_conv_expr_descriptor (&argse, actual->expr);\n-    }\n+    gfc_conv_expr_descriptor (&argse, actual->expr);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n-  arg1 = gfc_evaluate_now (argse.expr, &se->pre);\n-\n-  /* Build the call to size0.  */\n-  fncall0 = build_call_expr_loc (input_location,\n-\t\t\t     gfor_fndecl_size0, 1, arg1);\n+  arg1 = argse.expr;\n \n   actual = actual->next;\n-\n   if (actual->expr)\n     {\n+      stmtblock_t block;\n+      gfc_init_block (&block);\n       gfc_init_se (&argse, NULL);\n       gfc_conv_expr_type (&argse, actual->expr,\n \t\t\t  gfc_array_index_type);\n-      gfc_add_block_to_block (&se->pre, &argse.pre);\n+      gfc_add_block_to_block (&block, &argse.pre);\n+      tree tmp = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t     argse.expr, gfc_index_one_node);\n+      size = gfc_tree_array_size (&block, arg1, e, tmp);\n \n       /* Unusually, for an intrinsic, size does not exclude\n \t an optional arg2, so we must test for it.  */\n       if (actual->expr->expr_type == EXPR_VARIABLE\n \t    && actual->expr->symtree->n.sym->attr.dummy\n \t    && actual->expr->symtree->n.sym->attr.optional)\n \t{\n-\t  tree tmp;\n-\t  /* Build the call to size1.  */\n-\t  fncall1 = build_call_expr_loc (input_location,\n-\t\t\t\t     gfor_fndecl_size1, 2,\n-\t\t\t\t     arg1, argse.expr);\n-\n+\t  tree cond;\n+\t  stmtblock_t block2;\n+\t  gfc_init_block (&block2);\n \t  gfc_init_se (&argse, NULL);\n \t  argse.want_pointer = 1;\n \t  argse.data_not_needed = 1;\n \t  gfc_conv_expr (&argse, actual->expr);\n \t  gfc_add_block_to_block (&se->pre, &argse.pre);\n-\t  tmp = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n-\t\t\t\t argse.expr, null_pointer_node);\n-\t  tmp = gfc_evaluate_now (tmp, &se->pre);\n-\t  se->expr = fold_build3_loc (input_location, COND_EXPR,\n-\t\t\t\t      pvoid_type_node, tmp, fncall1, fncall0);\n+\t  cond = fold_build2_loc (input_location, NE_EXPR, logical_type_node,\n+\t\t\t\t  argse.expr, null_pointer_node);\n+\t  cond = gfc_evaluate_now (cond, &se->pre);\n+\t  /* 'block2' contains the arg2 absent case, 'block' the arg2 present\n+\t      case; size_var can be used in both blocks. */\n+\t  tree size_var = gfc_tree_array_size (&block2, arg1, e, NULL_TREE);\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t\t TREE_TYPE (size_var), size_var, size);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t  tmp = build3_v (COND_EXPR, cond, gfc_finish_block (&block),\n+\t\t\t  gfc_finish_block (&block2));\n+\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\t  size = size_var;\n \t}\n       else\n-\t{\n-\t  se->expr = NULL_TREE;\n-\t  argse.expr = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t\tgfc_array_index_type,\n-\t\t\t\t\targse.expr, gfc_index_one_node);\n-\t}\n-    }\n-  else if (expr->value.function.actual->expr->rank == 1)\n-    {\n-      argse.expr = gfc_index_zero_node;\n-      se->expr = NULL_TREE;\n+\tgfc_add_block_to_block (&se->pre, &block);\n     }\n   else\n-    se->expr = fncall0;\n-\n-  if (se->expr == NULL_TREE)\n-    {\n-      tree ubound, lbound;\n-\n-      arg1 = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t      arg1);\n-      ubound = gfc_conv_descriptor_ubound_get (arg1, argse.expr);\n-      lbound = gfc_conv_descriptor_lbound_get (arg1, argse.expr);\n-      se->expr = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t  gfc_array_index_type, ubound, lbound);\n-      se->expr = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t  gfc_array_index_type,\n-\t\t\t\t  se->expr, gfc_index_one_node);\n-      se->expr = fold_build2_loc (input_location, MAX_EXPR,\n-\t\t\t\t  gfc_array_index_type, se->expr,\n-\t\t\t\t  gfc_index_zero_node);\n-    }\n-\n+    size = gfc_tree_array_size (&se->pre, arg1, e, NULL_TREE);\n   type = gfc_typenode_for_spec (&expr->ts);\n-  se->expr = convert (type, se->expr);\n+  se->expr = convert (type, size);\n }\n \n "}, {"sha": "53f0f86b265269d316fa33ae30cefacbc5be6dcb", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -960,8 +960,6 @@ extern GTY(()) tree gfor_fndecl_convert_char1_to_char4;\n extern GTY(()) tree gfor_fndecl_convert_char4_to_char1;\n \n /* Other misc. runtime library functions.  */\n-extern GTY(()) tree gfor_fndecl_size0;\n-extern GTY(()) tree gfor_fndecl_size1;\n extern GTY(()) tree gfor_fndecl_iargc;\n extern GTY(()) tree gfor_fndecl_kill;\n extern GTY(()) tree gfor_fndecl_kill_sub;"}, {"sha": "8be0c106da6ca18245a53b1b7362d73d282cde54", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_22.f90", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_22.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_22.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_22.f90?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -0,0 +1,169 @@\n+! { dg-do run }\n+! { dg-additional-sources assumed_rank_22_aux.c }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+!\n+! FIXME: wrong extend in array descriptor, see C file.\n+! { dg-output \"c_assumed - 40 - OK\" { xfail *-*-* } }\n+! { dg-output \"c_assumed - 100 - OK\" { xfail *-*-* } }\n+!\n+! PR fortran/94070\n+!\n+! Contributed by Tobias Burnus\n+! and Jos\u00e9 Rui Faustino de Sousa\n+!\n+program main\n+  implicit none\n+  integer :: A(5,4,2)\n+  integer, allocatable :: B(:,:,:)\n+  integer :: C(5,4,-2:-1)\n+\n+  interface\n+    subroutine c_assumed (x, num) bind(C)\n+      integer :: x(..)\n+      integer, value :: num\n+    end subroutine\n+    subroutine c_allocated (x) bind(C)\n+      integer, allocatable :: x(..)\n+    end subroutine\n+  end interface\n+\n+  allocate (B(-1:3,4,-1:-1))\n+\n+  call caller (a)          ! num=0: assumed-size\n+  call test (b, num=20)           ! full array\n+  call test (b(:,:,0:-1), num=40) ! zero-sized array\n+  call test (c, num=60)\n+  call test (c(:,:,:-1), num=80) ! full-size slice\n+  call test (c(:,:,1:-1), num=100) !zero-size array\n+\n+  call test_alloc(b)\n+\n+  call c_assumed (b, num=20)\n+  call c_assumed (b(:,:,0:-1), num=40)\n+  call c_assumed (c, num=60)\n+  call c_assumed (c(:,:,:-1), num=80)\n+  call c_assumed (c(:,:,1:-1), num=100)\n+\n+  call c_allocated (b)\n+contains\n+  subroutine caller(y)\n+    integer :: y(-1:3,4,*)\n+    call test(y, num=0)\n+    call c_assumed (y, num=0)\n+  end\n+  subroutine test (x, num)\n+    integer :: x(..), num\n+\n+    ! SIZE (x)\n+    if (num == 0) then\n+      if (size (x) /= -20) stop 1\n+    elseif (num == 20) then\n+      if (size (x) /= 20) stop 21\n+    elseif (num == 40) then\n+      if (size (x) /= 0) stop 41\n+    elseif (num == 60) then\n+      if (size (x) /= 40) stop 61\n+    elseif (num == 80) then\n+      if (size (x) /= 40) stop 81\n+    elseif (num == 100) then\n+      if (size (x) /= 0) stop 101\n+    else\n+      stop 99  ! Invalid num\n+    endif\n+\n+    ! SIZE (x, dim=...)\n+    if (size (x, dim=1) /= 5) stop num + 2\n+    if (size (x, dim=2) /= 4) stop num + 3\n+\n+    if (num == 0) then\n+      if (size (x, dim=3) /= -1) stop 4\n+    elseif (num == 20) then\n+      if (size (x, dim=3) /= 1) stop 24\n+    elseif (num == 40) then\n+      if (size (x, dim=3) /= 0) stop 44\n+    elseif (num == 60) then\n+      if (size (x, dim=3) /= 2) stop 64\n+    elseif (num == 80) then\n+      if (size (x, dim=3) /= 2) stop 84\n+    elseif (num == 100) then\n+      if (size (x, dim=3) /= 0) stop 104\n+    endif\n+\n+    ! SHAPE (x)\n+    if (num == 0) then\n+      if (any (shape (x) /= [5, 4, -1])) stop 5\n+    elseif (num == 20) then\n+      if (any (shape (x) /= [5, 4, 1])) stop 25\n+    elseif (num == 40) then\n+      if (any (shape (x) /= [5, 4, 0])) stop 45\n+    elseif (num == 60) then\n+      if (any (shape (x) /= [5, 4, 2])) stop 65\n+    elseif (num == 80) then\n+      if (any (shape (x) /= [5, 4, 2])) stop 85\n+    elseif (num == 100) then\n+      if (any (shape (x) /= [5, 4, 0])) stop 105\n+    endif\n+\n+    ! LBOUND (X)\n+    if (any (lbound (x) /= [1, 1, 1])) stop num + 6\n+\n+    ! LBOUND (X, dim=...)\n+    if (lbound (x, dim=1) /= 1) stop num + 7\n+    if (lbound (x, dim=2) /= 1) stop num + 8\n+    if (lbound (x, dim=3) /= 1) stop num + 9\n+\n+    ! UBOUND (X)\n+    if (num == 0) then\n+      if (any (ubound (x) /= [5, 4, -1])) stop 11\n+    elseif (num == 20) then\n+      if (any (ubound (x) /= [5, 4, 1])) stop 31\n+    elseif (num == 40) then\n+      if (any (ubound (x) /= [5, 4, 0])) stop 51\n+    elseif (num == 60) then\n+      if (any (ubound (x) /= [5, 4, 2])) stop 71\n+    elseif (num == 80) then\n+      if (any (ubound (x) /= [5, 4, 2])) stop 91\n+    elseif (num == 100) then\n+      if (any (ubound (x) /= [5, 4, 0])) stop 111\n+    endif\n+\n+    ! UBOUND (X, dim=...)\n+    if (ubound (x, dim=1) /= 5) stop num + 12\n+    if (ubound (x, dim=2) /= 4) stop num + 13\n+    if (num == 0) then\n+      if (ubound (x, dim=3) /= -1) stop 14\n+    elseif (num == 20) then\n+      if (ubound (x, dim=3) /= 1) stop 34\n+    elseif (num == 40) then\n+      if (ubound (x, dim=3) /= 0) stop 54\n+    elseif (num == 60) then\n+      if (ubound (x, dim=3) /= 2) stop 74\n+    elseif (num == 80) then\n+      if (ubound (x, dim=3) /= 2) stop 94\n+    elseif (num == 100) then\n+      if (ubound (x, dim=3) /= 0) stop 114\n+    endif\n+  end\n+\n+  subroutine test_alloc (x)\n+    integer, allocatable :: x(..)\n+\n+    if (size (x) /= 20) stop 61\n+    if (size (x, dim=1) /= 5) stop 62\n+    if (size (x, dim=2) /= 4) stop 63\n+    if (size (x, dim=3) /= 1) stop 64\n+\n+    if (any (shape (x) /= [5, 4, 1])) stop 65\n+\n+    if (any (lbound (x) /= [-1, 1, -1])) stop 66\n+    if (lbound (x, dim=1) /= -1) stop 77\n+    if (lbound (x, dim=2) /= 1) stop 78\n+    if (lbound (x, dim=3) /= -1) stop 79\n+\n+    if (any (ubound (x) /= [3, 4, -1])) stop 80\n+    if (ubound (x, dim=1) /= 3) stop 92\n+    if (ubound (x, dim=2) /= 4) stop 93\n+    if (ubound (x, dim=3) /= -1) stop 94\n+  end\n+end\n+! { dg-final { scan-tree-dump-not \"_gfortran_size\" \"original\" } } "}, {"sha": "2fbf83d649aa72185cbfee2da781adf60ac83032", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_22_aux.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_22_aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_22_aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_22_aux.c?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -0,0 +1,68 @@\n+/* Called by assumed_rank_22.f90.  */\n+\n+#include <ISO_Fortran_binding.h>\n+#include <assert.h>\n+\n+void\n+c_assumed (CFI_cdesc_t *x, int num)\n+{\n+  assert (num == 0 || num == 20 || num == 40 || num == 60 || num == 80\n+\t  || num == 100);\n+  assert (x->elem_len == sizeof (int));\n+  assert (x->rank == 3);\n+  assert (x->type == CFI_type_int32_t);\n+\n+  assert (x->attribute == CFI_attribute_other);\n+  assert (x->dim[0].lower_bound == 0);\n+  assert (x->dim[1].lower_bound == 0);\n+  assert (x->dim[2].lower_bound == 0);\n+  assert (x->dim[0].extent == 5);\n+  assert (x->dim[1].extent == 4);\n+  if (num == 0)\n+    assert (x->dim[2].extent == -1);\n+  else if (num == 20)\n+    assert (x->dim[2].extent == 1);\n+  else if (num == 40)\n+    {\n+      /* FIXME: - dg-output = 'c_assumed ... OK' checked in .f90 file. */\n+      /* assert (x->dim[2].extent == 0); */\n+      if (x->dim[2].extent == 0)\n+\t__builtin_printf (\"c_assumed - 40 - OK\\n\");\n+      else\n+\t__builtin_printf (\"ERROR: c_assumed num=%d: \"\n+\t\t      \"x->dim[2].extent = %d != 0\\n\",\n+\t\t      num, x->dim[2].extent);\n+    }\n+  else if (num == 60)\n+    assert (x->dim[2].extent == 2);\n+  else if (num == 80)\n+    assert (x->dim[2].extent == 2);\n+  else if (num == 100)\n+    {\n+      /* FIXME: - dg-output = 'c_assumed ... OK' checked in .f90 file. */\n+      /* assert (x->dim[2].extent == 0); */\n+      if (x->dim[2].extent == 0)\n+\t__builtin_printf (\"c_assumed - 100 - OK\\n\");\n+      else\n+\t__builtin_printf (\"ERROR: c_assumed num=%d: \"\n+\t\t      \"x->dim[2].extent = %d != 0\\n\",\n+\t\t      num, x->dim[2].extent);\n+    }\n+  else\n+    assert (0);\n+}\n+\n+void\n+c_allocated (CFI_cdesc_t *x)\n+{\n+  assert (x->elem_len == sizeof (int));\n+  assert (x->rank == 3);\n+  assert (x->type == CFI_type_int32_t);\n+  assert (x->attribute == CFI_attribute_allocatable);\n+  assert (x->dim[0].lower_bound == -1);\n+  assert (x->dim[1].lower_bound == 1);\n+  assert (x->dim[2].lower_bound == -1);\n+  assert (x->dim[0].extent == 5);\n+  assert (x->dim[1].extent == 4);\n+  assert (x->dim[2].extent == 1);\n+}"}, {"sha": "bc19a71efa76becd62ccd7718e69e4d394e8567c", "filename": "gcc/testsuite/gfortran.dg/c-interop/cf-out-descriptor-6.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fcf-out-descriptor-6.f90?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -1,5 +1,5 @@\n ! Reported as pr94070.\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n ! { dg-additional-sources \"cf-out-descriptor-6-c.c dump-descriptors.c\" }\n ! { dg-additional-options \"-g\" }\n !"}, {"sha": "58b32b0d5e7aff7076ba54b2f2af7f4d4b0b4b88", "filename": "gcc/testsuite/gfortran.dg/c-interop/size.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc-interop%2Fsize.f90?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -1,5 +1,5 @@\n ! Reported as pr94070.\n-! { dg-do run { xfail *-*-* } }\n+! { dg-do run }\n !\n ! TS 29113\n ! 6.4.2 SIZE"}, {"sha": "afdf9b34d4bc9417bbe2d29df4ce774e127f7d2a", "filename": "gcc/testsuite/gfortran.dg/intrinsic_size_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_size_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_size_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_size_3.f90?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -22,4 +22,4 @@ program bug\n   stop\n end program bug\n \n-! { dg-final { scan-tree-dump-times \"iszs = \\\\(integer\\\\(kind=2\\\\)\\\\) MAX_EXPR <\\\\(D.\\[0-9\\]+->dim.0..ubound - D.\\[0-9\\]+->dim.0..lbound\\\\) \\\\+ 1, 0>;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"iszs = \\\\(integer\\\\(kind=2\\\\)\\\\) MAX_EXPR <\\\\(a.dim.0..ubound - a.dim.0..lbound\\\\) \\\\+ 1, 0>;\" 1 \"original\" } }"}, {"sha": "cbf4aa4812ed696917e3b06034002f81397f3c75", "filename": "gcc/testsuite/gfortran.dg/size_optional_dim_1.f90", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fsize_optional_dim_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fsize_optional_dim_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsize_optional_dim_1.f90?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -1,4 +1,5 @@\n ! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n ! PR 30865 - passing a subroutine optional argument to size(dim=...)\n ! used to segfault.\n program main\n@@ -19,3 +20,6 @@ subroutine checkv(ires,a1,opt1)\n     ires = size (a1, dim=opt1)\n   end subroutine checkv\n end program main\n+\n+! Ensure inline code is generated, cf. PR fortran/94070\n+! { dg-final { scan-tree-dump-not \"_gfortran_size\" \"original\" } } "}, {"sha": "54271b12bfa559eb6e87f1988d73d5aa0cb2f896", "filename": "gcc/testsuite/gfortran.dg/transpose_optimization_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_2.f90?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -60,5 +60,5 @@ end subroutine pure_sub\n !\n ! The check below for temporaries gave 14 and 33 for \"parm\" and \"atmp\".\n !\n-! { dg-final { scan-tree-dump-times \"parm\" 72 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"parm\" 76 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"atmp\" 13 \"original\" } }"}, {"sha": "f1a60ba7209bd483ca742bbf0d39fe456c1b4fd0", "filename": "libgfortran/intrinsics/size.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/libgfortran%2Fintrinsics%2Fsize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/libgfortran%2Fintrinsics%2Fsize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fsize.c?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -25,6 +25,8 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"libgfortran.h\"\n \n+/* Note: This function is only used internally in libgfortran and old FE code,\n+   new code generates the code inline.  */\n index_type\n size0 (const array_t * array)\n {\n@@ -47,6 +49,8 @@ iexport(size0);\n extern index_type size1 (const array_t * array, index_type dim);\n export_proto(size1);\n \n+/* Note: This function it is unused in libgfortran itself and the FE no longer\n+   call it; however, old code might still call it. */\n index_type\n size1 (const array_t * array, index_type dim)\n {"}, {"sha": "2ff60226109b97428569852f66ff5e12285e3b77", "filename": "libgomp/testsuite/libgomp.oacc-fortran/privatized-ref-2.f90", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00f6de9c69119594f7dad3bd525937c94c8200d0/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivatized-ref-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00f6de9c69119594f7dad3bd525937c94c8200d0/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivatized-ref-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fprivatized-ref-2.f90?ref=00f6de9c69119594f7dad3bd525937c94c8200d0", "patch": "@@ -71,17 +71,16 @@ subroutine bar (array)\n     ! { dg-note {variable 'offset\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute }\n     ! { dg-note {variable 'S\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute }\n     ! { dg-note {variable 'test\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute }\n-    ! { dg-note {variable 'parm\\.[0-9]+' declared in block is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_compute$c_compute }\n-    ! { dg-note {variable 'parm\\.[0-9]+' ought to be adjusted for OpenACC privatization level: 'gang'} \"\" { target *-*-* } l_compute$c_compute }\n-    ! { dg-note {variable 'parm\\.[0-9]+' adjusted for OpenACC privatization level: 'gang'} \"\" { target { ! { openacc_host_selected || openacc_nvidia_accel_selected } } } l_compute$c_compute }\n+    ! { dg-note {variable 'parm\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_compute$c_compute }\n     ! { dg-note {variable 'A\\.[0-9]+' declared in block isn't candidate for adjusting OpenACC privatization level: static} \"\" { target *-*-* } l_compute$c_compute }\n     array = [(-2*i, i = 1, size(array))]\n     !$acc loop gang private(array) ! { dg-line l_loop[incr c_loop] }\n-    ! { dg-note {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n-    ! { dg-note {variable 'array\\.[0-9]+' in 'private' clause is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_loop$c_loop }\n-    ! { dg-note {variable 'array\\.[0-9]+' ought to be adjusted for OpenACC privatization level: 'gang'} \"\" { target *-*-* } l_loop$c_loop }\n-    ! { dg-note {variable 'array\\.[0-9]+' adjusted for OpenACC privatization level: 'gang'} \"\" { target { ! { openacc_host_selected || openacc_nvidia_accel_selected } } } l_loop$c_loop }\n+    ! { dg-message {variable 'i' in 'private' clause isn't candidate for adjusting OpenACC privatization level: not addressable} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-message {variable 'array\\.[0-9]+' in 'private' clause is candidate for adjusting OpenACC privatization level} \"\" { target *-*-* } l_loop$c_loop }\n+    ! { dg-message {variable 'array\\.[0-9]+' ought to be adjusted for OpenACC privatization level: 'gang'} \"\" { target *-*-* } l_loop$c_loop }\n+\n     ! { dg-message {sorry, unimplemented: target cannot support alloca} PR65181 { target openacc_nvidia_accel_selected } l_loop$c_loop }\n+\n     do i = 1, 10\n       array(i) = 9*i\n     end do"}]}