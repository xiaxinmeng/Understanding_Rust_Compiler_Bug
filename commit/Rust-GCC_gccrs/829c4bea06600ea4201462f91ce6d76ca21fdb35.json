{"sha": "829c4bea06600ea4201462f91ce6d76ca21fdb35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI5YzRiZWEwNjYwMGVhNDIwMTQ2MmY5MWNlNmQ3NmNhMjFmZGIzNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-13T10:14:14Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-13T10:16:48Z"}, "message": "ix86: Support V{2, 4}DImode arithmetic right shifts for SSE2+ [PR98856]\n\nAs mentioned in the PR, we don't support arithmetic right V2DImode or\nV4DImode on x86 without -mavx512vl or -mxop.  The ISAs indeed don't have\n{,v}psraq instructions until AVX512VL, but we actually can emulate it quite\neasily.\nOne case is arithmetic >> 63, we can just emit {,v}pxor; {,v}pcmpgt for\nthat for SSE4.2+, or for SSE2 psrad $31; pshufd $0xf5.\nThen arithmetic >> by constant > 32, that can be done with {,v}psrad $31\nand {,v}psrad $(cst-32) and two operand permutation,\narithmetic >> 32 can be done as {,v}psrad $31 and permutation of that\nand the original operand.  Arithmetic >> by constant < 32 can be done\nas {,v}psrad $cst and {,v}psrlq $cst and two operand permutation.\nAnd arithmetic >> by variable scalar amount can be done as\narithmetic >> 63, logical >> by the amount, << by (64 - amount of the\n>> 63 result; note that the vector << 64 result in 0) and oring together.\n\nI had to improve the permutation generation so that it actually handles\nthe needed permutations (or handles them better).\n\n2021-05-13  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/98856\n\t* config/i386/i386.c (ix86_shift_rotate_cost): Add CODE argument.\n\tExpect V2DI and V4DI arithmetic right shifts to be emulated.\n\t(ix86_rtx_costs, ix86_add_stmt_cost): Adjust ix86_shift_rotate_cost\n\tcaller.\n\t* config/i386/i386-expand.c (expand_vec_perm_2perm_interleave,\n\texpand_vec_perm_2perm_pblendv): New functions.\n\t(ix86_expand_vec_perm_const_1): Use them.\n\t* config/i386/sse.md (ashr<mode>3<mask_name>): Rename to ...\n\t(<mask_codefor>ashr<mode>3<mask_name>): ... this.\n\t(ashr<mode>3): New define_expand with VI248_AVX512BW iterator.\n\t(ashrv4di3): New define_expand.\n\t(ashrv2di3): Change condition to TARGET_SSE2, handle !TARGET_XOP\n\tand !TARGET_AVX512VL expansion.\n\n\t* gcc.target/i386/sse2-psraq-1.c: New test.\n\t* gcc.target/i386/sse4_2-psraq-1.c: New test.\n\t* gcc.target/i386/avx-psraq-1.c: New test.\n\t* gcc.target/i386/avx2-psraq-1.c: New test.\n\t* gcc.target/i386/avx-pr82370.c: Adjust expected number of vpsrad\n\tinstructions.\n\t* gcc.target/i386/avx2-pr82370.c: Likewise.\n\t* gcc.target/i386/avx512f-pr82370.c: Likewise.\n\t* gcc.target/i386/avx512bw-pr82370.c: Likewise.\n\t* gcc.dg/torture/vshuf-4.inc: Add two further permutations.\n\t* gcc.dg/torture/vshuf-8.inc: Likewise.", "tree": {"sha": "3070e0b55476fcec960b33c2bc3e68ae512853bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3070e0b55476fcec960b33c2bc3e68ae512853bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/829c4bea06600ea4201462f91ce6d76ca21fdb35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829c4bea06600ea4201462f91ce6d76ca21fdb35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/829c4bea06600ea4201462f91ce6d76ca21fdb35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/829c4bea06600ea4201462f91ce6d76ca21fdb35/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1693741cb2b2db519bb82155a3c0880fd820ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1693741cb2b2db519bb82155a3c0880fd820ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1693741cb2b2db519bb82155a3c0880fd820ea3"}], "stats": {"total": 675, "additions": 660, "deletions": 15}, "files": [{"sha": "0fa8d45a684ea21cb02fe7764673332f19b3c299", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -18662,6 +18662,242 @@ expand_vec_perm_vperm2f128_vblend (struct expand_vec_perm_d *d)\n   return true;\n }\n \n+/* A subroutine of ix86_expand_vec_perm_const_1.  Try to implement\n+   a two vector permutation using two single vector permutations and\n+   {,v}{,p}unpckl{ps,pd,bw,wd,dq}.  If two_insn, succeed only if one\n+   of dfirst or dsecond is identity permutation.  */\n+\n+static bool\n+expand_vec_perm_2perm_interleave (struct expand_vec_perm_d *d, bool two_insn)\n+{\n+  unsigned i, nelt = d->nelt, nelt2 = nelt / 2, lane = nelt;\n+  struct expand_vec_perm_d dfirst, dsecond, dfinal;\n+  bool ident1 = true, ident2 = true;\n+\n+  if (d->one_operand_p)\n+    return false;\n+\n+  if (GET_MODE_SIZE (d->vmode) == 16)\n+    {\n+      if (!TARGET_SSE)\n+\treturn false;\n+      if (d->vmode != V4SFmode && d->vmode != V2DFmode && !TARGET_SSE2)\n+\treturn false;\n+    }\n+  else if (GET_MODE_SIZE (d->vmode) == 32)\n+    {\n+      if (!TARGET_AVX)\n+\treturn false;\n+      if (d->vmode != V8SFmode && d->vmode != V4DFmode && !TARGET_AVX2)\n+\treturn false;\n+      lane = nelt2;\n+    }\n+  else\n+    return false;\n+\n+  for (i = 1; i < nelt; i++)\n+    if ((d->perm[i] >= nelt) != ((d->perm[0] >= nelt) ^ (i & 1)))\n+      return false;\n+\n+  dfirst = *d;\n+  dsecond = *d;\n+  dfinal = *d;\n+  dfirst.op1 = dfirst.op0;\n+  dfirst.one_operand_p = true;\n+  dsecond.op0 = dsecond.op1;\n+  dsecond.one_operand_p = true;\n+\n+  for (i = 0; i < nelt; i++)\n+    if (d->perm[i] >= nelt)\n+      {\n+\tdsecond.perm[i / 2 + (i >= lane ? lane / 2 : 0)] = d->perm[i] - nelt;\n+\tif (d->perm[i] - nelt != i / 2 + (i >= lane ? lane / 2 : 0))\n+\t  ident2 = false;\n+\tdsecond.perm[i / 2 + (i >= lane ? lane : lane / 2)]\n+\t  = d->perm[i] - nelt;\n+      }\n+    else\n+      {\n+\tdfirst.perm[i / 2 + (i >= lane ? lane / 2 : 0)] = d->perm[i];\n+\tif (d->perm[i] != i / 2 + (i >= lane ? lane / 2 : 0))\n+\t  ident1 = false;\n+\tdfirst.perm[i / 2 + (i >= lane ? lane : lane / 2)] = d->perm[i];\n+      }\n+\n+  if (two_insn && !ident1 && !ident2)\n+    return false;\n+\n+  if (!d->testing_p)\n+    {\n+      if (!ident1)\n+\tdfinal.op0 = dfirst.target = gen_reg_rtx (d->vmode);\n+      if (!ident2)\n+\tdfinal.op1 = dsecond.target = gen_reg_rtx (d->vmode);\n+      if (d->perm[0] >= nelt)\n+\tstd::swap (dfinal.op0, dfinal.op1);\n+    }\n+\n+  bool ok;\n+  rtx_insn *seq1 = NULL, *seq2 = NULL;\n+\n+  if (!ident1)\n+    {\n+      start_sequence ();\n+      ok = expand_vec_perm_1 (&dfirst);\n+      seq1 = get_insns ();\n+      end_sequence ();\n+\n+      if (!ok)\n+\treturn false;\n+    }\n+\n+  if (!ident2)\n+    {\n+      start_sequence ();\n+      ok = expand_vec_perm_1 (&dsecond);\n+      seq2 = get_insns ();\n+      end_sequence ();\n+\n+      if (!ok)\n+\treturn false;\n+    }\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  for (i = 0; i < nelt; i++)\n+    {\n+      dfinal.perm[i] = i / 2;\n+      if (i >= lane)\n+\tdfinal.perm[i] += lane / 2;\n+      if ((i & 1) != 0)\n+\tdfinal.perm[i] += nelt;\n+    }\n+  emit_insn (seq1);\n+  emit_insn (seq2);\n+  ok = expand_vselect_vconcat (dfinal.target, dfinal.op0, dfinal.op1,\n+\t\t\t       dfinal.perm, dfinal.nelt, false);\n+  gcc_assert (ok);\n+  return true;\n+}\n+\n+/* A subroutine of ix86_expand_vec_perm_const_1.  Try to simplify\n+   the permutation using two single vector permutations and the SSE4_1 pblendv\n+   instruction.  If two_insn, succeed only if one of dfirst or dsecond is\n+   identity permutation.  */\n+\n+static bool\n+expand_vec_perm_2perm_pblendv (struct expand_vec_perm_d *d, bool two_insn)\n+{\n+  unsigned i, nelt = d->nelt;\n+  struct expand_vec_perm_d dfirst, dsecond, dfinal;\n+  machine_mode vmode = d->vmode;\n+  bool ident1 = true, ident2 = true;\n+\n+  /* Use the same checks as in expand_vec_perm_blend.  */\n+  if (d->one_operand_p)\n+    return false;\n+  if (TARGET_AVX2 && GET_MODE_SIZE (vmode) == 32)\n+    ;\n+  else if (TARGET_AVX && (vmode == V4DFmode || vmode == V8SFmode))\n+    ;\n+  else if (TARGET_SSE4_1 && GET_MODE_SIZE (vmode) == 16)\n+    ;\n+  else\n+    return false;\n+\n+  dfirst = *d;\n+  dsecond = *d;\n+  dfinal = *d;\n+  dfirst.op1 = dfirst.op0;\n+  dfirst.one_operand_p = true;\n+  dsecond.op0 = dsecond.op1;\n+  dsecond.one_operand_p = true;\n+\n+  for (i = 0; i < nelt; ++i)\n+    if (d->perm[i] >= nelt)\n+      {\n+\tdfirst.perm[i] = 0xff;\n+\tdsecond.perm[i] = d->perm[i] - nelt;\n+\tif (d->perm[i] != i + nelt)\n+\t  ident2 = false;\n+      }\n+    else\n+      {\n+\tdsecond.perm[i] = 0xff;\n+\tdfirst.perm[i] = d->perm[i];\n+\tif (d->perm[i] != i)\n+\t  ident1 = false;\n+      }\n+\n+  if (two_insn && !ident1 && !ident2)\n+    return false;\n+\n+  /* For now.  Ideally treat 0xff as a wildcard.  */\n+  for (i = 0; i < nelt; ++i)\n+    if (dfirst.perm[i] == 0xff)\n+      {\n+\tif (GET_MODE_SIZE (vmode) == 32\n+\t    && dfirst.perm[i ^ (nelt / 2)] != 0xff)\n+\t  dfirst.perm[i] = dfirst.perm[i ^ (nelt / 2)] ^ (nelt / 2);\n+\telse\n+\t  dfirst.perm[i] = i;\n+      }\n+    else\n+      {\n+\tif (GET_MODE_SIZE (vmode) == 32\n+\t    && dsecond.perm[i ^ (nelt / 2)] != 0xff)\n+\t  dsecond.perm[i] = dsecond.perm[i ^ (nelt / 2)] ^ (nelt / 2);\n+\telse\n+\t  dsecond.perm[i] = i;\n+      }\n+\n+  if (!d->testing_p)\n+    {\n+      if (!ident1)\n+\tdfinal.op0 = dfirst.target = gen_reg_rtx (d->vmode);\n+      if (!ident2)\n+\tdfinal.op1 = dsecond.target = gen_reg_rtx (d->vmode);\n+    }\n+\n+  bool ok;\n+  rtx_insn *seq1 = NULL, *seq2 = NULL;\n+\n+  if (!ident1)\n+    {\n+      start_sequence ();\n+      ok = expand_vec_perm_1 (&dfirst);\n+      seq1 = get_insns ();\n+      end_sequence ();\n+\n+      if (!ok)\n+\treturn false;\n+    }\n+\n+  if (!ident2)\n+    {\n+      start_sequence ();\n+      ok = expand_vec_perm_1 (&dsecond);\n+      seq2 = get_insns ();\n+      end_sequence ();\n+\n+      if (!ok)\n+\treturn false;\n+    }\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  for (i = 0; i < nelt; ++i)\n+    dfinal.perm[i] = (d->perm[i] >= nelt ? i + nelt : i);\n+\n+  emit_insn (seq1);\n+  emit_insn (seq2);\n+  ok = expand_vec_perm_blend (&dfinal);\n+  gcc_assert (ok);\n+  return true;\n+}\n+\n /* A subroutine of ix86_expand_vec_perm_const_1.  Implement a V4DF\n    permutation using two vperm2f128, followed by a vshufpd insn blending\n    the two vectors together.  */\n@@ -19773,6 +20009,12 @@ ix86_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   if (expand_vec_perm_pblendv (d))\n     return true;\n \n+  if (expand_vec_perm_2perm_interleave (d, true))\n+    return true;\n+\n+  if (expand_vec_perm_2perm_pblendv (d, true))\n+    return true;\n+\n   /* Try sequences of three instructions.  */\n \n   if (expand_vec_perm_even_odd_pack (d))\n@@ -19790,6 +20032,12 @@ ix86_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n   if (expand_vec_perm_vperm2f128_vblend (d))\n     return true;\n \n+  if (expand_vec_perm_2perm_interleave (d, false))\n+    return true;\n+\n+  if (expand_vec_perm_2perm_pblendv (d, false))\n+    return true;\n+\n   /* Try sequences of four instructions.  */\n \n   if (expand_vec_perm_even_odd_trunc (d))"}, {"sha": "6a1f57460896d2f5bbd7048545873fa8cfcaa0f9", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -19732,6 +19732,7 @@ ix86_division_cost (const struct processor_costs *cost,\n \n static int\n ix86_shift_rotate_cost (const struct processor_costs *cost,\n+\t\t\tenum rtx_code code,\n \t\t\tenum machine_mode mode, bool constant_op1,\n \t\t\tHOST_WIDE_INT op1_val,\n \t\t\tbool speed,\n@@ -19770,6 +19771,19 @@ ix86_shift_rotate_cost (const struct processor_costs *cost,\n \t    count = 7;\n \t  return ix86_vec_cost (mode, cost->sse_op * count);\n \t}\n+      /* V*DImode arithmetic right shift is emulated.  */\n+      else if (code == ASHIFTRT\n+\t       && (mode == V2DImode || mode == V4DImode)\n+\t       && !TARGET_XOP\n+\t       && !TARGET_AVX512VL)\n+\t{\n+\t  int count = 4;\n+\t  if (constant_op1 && op1_val == 63 && TARGET_SSE4_2)\n+\t    count = 2;\n+\t  else if (constant_op1)\n+\t    count = 3;\n+\t  return ix86_vec_cost (mode, cost->sse_op * count);\n+\t}\n       else\n \treturn ix86_vec_cost (mode, cost->sse_op);\n     }\n@@ -19939,13 +19953,15 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n     case LSHIFTRT:\n     case ROTATERT:\n       bool skip_op0, skip_op1;\n-      *total = ix86_shift_rotate_cost (cost, mode, CONSTANT_P (XEXP (x, 1)),\n+      *total = ix86_shift_rotate_cost (cost, code, mode,\n+\t\t\t\t       CONSTANT_P (XEXP (x, 1)),\n \t\t\t\t       CONST_INT_P (XEXP (x, 1))\n \t\t\t\t\t ? INTVAL (XEXP (x, 1)) : -1,\n \t\t\t\t       speed,\n \t\t\t\t       GET_CODE (XEXP (x, 1)) == AND,\n \t\t\t\t       SUBREG_P (XEXP (x, 1))\n-\t\t\t\t       && GET_CODE (XEXP (XEXP (x, 1), 0)) == AND,\n+\t\t\t\t       && GET_CODE (XEXP (XEXP (x, 1),\n+\t\t\t\t\t\t\t  0)) == AND,\n \t\t\t\t       &skip_op0, &skip_op1);\n       if (skip_op0 || skip_op1)\n \t{\n@@ -22383,11 +22399,16 @@ ix86_add_stmt_cost (class vec_info *vinfo, void *data, int count,\n \tcase LROTATE_EXPR:\n \tcase RROTATE_EXPR:\n \t  {\n+\t    tree op1 = gimple_assign_rhs1 (stmt_info->stmt);\n \t    tree op2 = gimple_assign_rhs2 (stmt_info->stmt);\n \t    stmt_cost = ix86_shift_rotate_cost\n-\t\t\t   (ix86_cost, mode,\n+\t\t\t   (ix86_cost,\n+\t\t\t    (subcode == RSHIFT_EXPR\n+\t\t\t     && !TYPE_UNSIGNED (TREE_TYPE (op1)))\n+\t\t\t    ? ASHIFTRT : LSHIFTRT, mode,\n \t\t            TREE_CODE (op2) == INTEGER_CST,\n-\t\t\t    cst_and_fits_in_hwi (op2) ? int_cst_value (op2) : -1,\n+\t\t\t    cst_and_fits_in_hwi (op2)\n+\t\t\t    ? int_cst_value (op2) : -1,\n \t\t            true, false, false, NULL, NULL);\n \t  }\n \t  break;"}, {"sha": "62f4e15f58c5d55619c8289f7c77fa93f96fb7ee", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 244, "deletions": 2, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -12468,7 +12468,7 @@\n    (set_attr \"prefix\" \"orig,vex\")\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n-(define_insn \"ashr<mode>3<mask_name>\"\n+(define_insn \"<mask_codefor>ashr<mode>3<mask_name>\"\n   [(set (match_operand:VI248_AVX512BW_AVX512VL 0 \"register_operand\" \"=v,v\")\n \t(ashiftrt:VI248_AVX512BW_AVX512VL\n \t  (match_operand:VI248_AVX512BW_AVX512VL 1 \"nonimmediate_operand\" \"v,vm\")\n@@ -12482,6 +12482,126 @@\n        (const_string \"0\")))\n    (set_attr \"mode\" \"<sseinsnmode>\")])\n \n+(define_expand \"ashr<mode>3\"\n+  [(set (match_operand:VI248_AVX512BW 0 \"register_operand\")\n+\t(ashiftrt:VI248_AVX512BW\n+\t  (match_operand:VI248_AVX512BW 1 \"nonimmediate_operand\")\n+\t  (match_operand:DI 2 \"nonmemory_operand\")))]\n+  \"TARGET_AVX512F\")\n+\n+(define_expand \"ashrv4di3\"\n+  [(set (match_operand:V4DI 0 \"register_operand\")\n+\t(ashiftrt:V4DI\n+\t  (match_operand:V4DI 1 \"nonimmediate_operand\")\n+\t  (match_operand:DI 2 \"nonmemory_operand\")))]\n+  \"TARGET_AVX2\"\n+{\n+  if (!TARGET_AVX512VL)\n+    {\n+      if (CONST_INT_P (operands[2]) && UINTVAL (operands[2]) >= 63)\n+\t{\n+\t  rtx zero = force_reg (V4DImode, CONST0_RTX (V4DImode));\n+\t  emit_insn (gen_avx2_gtv4di3 (operands[0], zero, operands[1]));\n+\t  DONE;\n+\t}\n+      if (operands[2] == const0_rtx)\n+\t{\n+\t  emit_move_insn (operands[0], operands[1]);\n+\t  DONE;\n+\t}\n+      operands[1] = force_reg (V4DImode, operands[1]);\n+      if (CONST_INT_P (operands[2]))\n+\t{\n+\t  vec_perm_builder sel (8, 8, 1);\n+\t  sel.quick_grow (8);\n+\t  rtx arg0, arg1;\n+\t  rtx op1 = lowpart_subreg (V8SImode, operands[1], V4DImode);\n+\t  rtx target = gen_reg_rtx (V8SImode);\n+\t  if (INTVAL (operands[2]) > 32)\n+\t    {\n+\t      arg0 = gen_reg_rtx (V8SImode);\n+\t      arg1 = gen_reg_rtx (V8SImode);\n+\t      emit_insn (gen_ashrv8si3 (arg1, op1, GEN_INT (31)));\n+\t      emit_insn (gen_ashrv8si3 (arg0, op1,\n+\t\t\t\t\tGEN_INT (INTVAL (operands[2]) - 32)));\n+\t      sel[0] = 1;\n+\t      sel[1] = 9;\n+\t      sel[2] = 3;\n+\t      sel[3] = 11;\n+\t      sel[4] = 5;\n+\t      sel[5] = 13;\n+\t      sel[6] = 7;\n+\t      sel[7] = 15;\n+\t    }\n+\t  else if (INTVAL (operands[2]) == 32)\n+\t    {\n+\t      arg0 = op1;\n+\t      arg1 = gen_reg_rtx (V8SImode);\n+\t      emit_insn (gen_ashrv8si3 (arg1, op1, GEN_INT (31)));\n+\t      sel[0] = 1;\n+\t      sel[1] = 9;\n+\t      sel[2] = 3;\n+\t      sel[3] = 11;\n+\t      sel[4] = 5;\n+\t      sel[5] = 13;\n+\t      sel[6] = 7;\n+\t      sel[7] = 15;\n+\t    }\n+\t  else\n+\t    {\n+\t      arg0 = gen_reg_rtx (V4DImode);\n+\t      arg1 = gen_reg_rtx (V8SImode);\n+\t      emit_insn (gen_lshrv4di3 (arg0, operands[1], operands[2]));\n+\t      emit_insn (gen_ashrv8si3 (arg1, op1, operands[2]));\n+\t      arg0 = lowpart_subreg (V8SImode, arg0, V4DImode);\n+\t      sel[0] = 0;\n+\t      sel[1] = 9;\n+\t      sel[2] = 2;\n+\t      sel[3] = 11;\n+\t      sel[4] = 4;\n+\t      sel[5] = 13;\n+\t      sel[6] = 6;\n+\t      sel[7] = 15;\n+\t    }\n+\t  vec_perm_indices indices (sel, 2, 8);\n+\t  bool ok = targetm.vectorize.vec_perm_const (V8SImode, target,\n+\t\t\t\t\t\t      arg0, arg1, indices);\n+\t  gcc_assert (ok);\n+\t  emit_move_insn (operands[0],\n+\t\t\t  lowpart_subreg (V4DImode, target, V8SImode));\n+\t  DONE;\n+\t}\n+\n+      rtx zero = force_reg (V4DImode, CONST0_RTX (V4DImode));\n+      rtx zero_or_all_ones = gen_reg_rtx (V4DImode);\n+      emit_insn (gen_avx2_gtv4di3 (zero_or_all_ones, zero, operands[1]));\n+      rtx lshr_res = gen_reg_rtx (V4DImode);\n+      emit_insn (gen_lshrv4di3 (lshr_res, operands[1], operands[2]));\n+      rtx ashl_res = gen_reg_rtx (V4DImode);\n+      rtx amount;\n+      if (TARGET_64BIT)\n+\t{\n+\t  amount = gen_reg_rtx (DImode);\n+\t  emit_insn (gen_subdi3 (amount, force_reg (DImode, GEN_INT (64)),\n+\t\t\t\t operands[2]));\n+\t}\n+      else\n+\t{\n+\t  rtx temp = gen_reg_rtx (SImode);\n+\t  emit_insn (gen_subsi3 (temp, force_reg (SImode, GEN_INT (64)),\n+\t\t\t\t lowpart_subreg (SImode, operands[2],\n+\t\t\t\t\t\t DImode)));\n+\t  amount = gen_reg_rtx (V4SImode);\n+\t  emit_insn (gen_vec_setv4si_0 (amount, CONST0_RTX (V4SImode),\n+\t\t\t\t\ttemp));\n+\t}\n+      amount = lowpart_subreg (DImode, amount, GET_MODE (amount));\n+      emit_insn (gen_ashlv4di3 (ashl_res, zero_or_all_ones, amount));\n+      emit_insn (gen_iorv4di3 (operands[0], lshr_res, ashl_res));\n+      DONE;\n+    }\n+})\n+\n (define_insn \"<mask_codefor><insn><mode>3<mask_name>\"\n   [(set (match_operand:VI248_AVX512BW_2 0 \"register_operand\" \"=v,v\")\n \t(any_lshift:VI248_AVX512BW_2\n@@ -20329,10 +20449,132 @@\n \t(ashiftrt:V2DI\n \t  (match_operand:V2DI 1 \"register_operand\")\n \t  (match_operand:DI 2 \"nonmemory_operand\")))]\n-  \"TARGET_XOP || TARGET_AVX512VL\"\n+  \"TARGET_SSE2\"\n {\n   if (!TARGET_AVX512VL)\n     {\n+      if (TARGET_SSE4_2\n+\t  && CONST_INT_P (operands[2])\n+\t  && UINTVAL (operands[2]) >= 63)\n+\t{\n+\t  rtx zero = force_reg (V2DImode, CONST0_RTX (V2DImode));\n+\t  emit_insn (gen_sse4_2_gtv2di3 (operands[0], zero, operands[1]));\n+\t  DONE;\n+\t}\n+      if (operands[2] == const0_rtx)\n+\t{\n+\t  emit_move_insn (operands[0], operands[1]);\n+\t  DONE;\n+\t}\n+      if (CONST_INT_P (operands[2])\n+\t  && (!TARGET_XOP || UINTVAL (operands[2]) >= 63))\n+\t{\n+\t  vec_perm_builder sel (4, 4, 1);\n+\t  sel.quick_grow (4);\n+\t  rtx arg0, arg1;\n+\t  rtx op1 = lowpart_subreg (V4SImode, operands[1], V2DImode);\n+\t  rtx target = gen_reg_rtx (V4SImode);\n+\t  if (UINTVAL (operands[2]) >= 63)\n+\t    {\n+\t      arg0 = arg1 = gen_reg_rtx (V4SImode);\n+\t      emit_insn (gen_ashrv4si3 (arg0, op1, GEN_INT (31)));\n+\t      sel[0] = 1;\n+\t      sel[1] = 1;\n+\t      sel[2] = 3;\n+\t      sel[3] = 3;\n+\t    }\n+\t  else if (INTVAL (operands[2]) > 32)\n+\t    {\n+\t      arg0 = gen_reg_rtx (V4SImode);\n+\t      arg1 = gen_reg_rtx (V4SImode);\n+\t      emit_insn (gen_ashrv4si3 (arg1, op1, GEN_INT (31)));\n+\t      emit_insn (gen_ashrv4si3 (arg0, op1,\n+\t\t\t\t\tGEN_INT (INTVAL (operands[2]) - 32)));\n+\t      sel[0] = 1;\n+\t      sel[1] = 5;\n+\t      sel[2] = 3;\n+\t      sel[3] = 7;\n+\t    }\n+\t  else if (INTVAL (operands[2]) == 32)\n+\t    {\n+\t      arg0 = op1;\n+\t      arg1 = gen_reg_rtx (V4SImode);\n+\t      emit_insn (gen_ashrv4si3 (arg1, op1, GEN_INT (31)));\n+\t      sel[0] = 1;\n+\t      sel[1] = 5;\n+\t      sel[2] = 3;\n+\t      sel[3] = 7;\n+\t    }\n+\t  else\n+\t    {\n+\t      arg0 = gen_reg_rtx (V2DImode);\n+\t      arg1 = gen_reg_rtx (V4SImode);\n+\t      emit_insn (gen_lshrv2di3 (arg0, operands[1], operands[2]));\n+\t      emit_insn (gen_ashrv4si3 (arg1, op1, operands[2]));\n+\t      arg0 = lowpart_subreg (V4SImode, arg0, V2DImode);\n+\t      sel[0] = 0;\n+\t      sel[1] = 5;\n+\t      sel[2] = 2;\n+\t      sel[3] = 7;\n+\t    }\n+\t  vec_perm_indices indices (sel, arg0 != arg1 ? 2 : 1, 4);\n+\t  bool ok = targetm.vectorize.vec_perm_const (V4SImode, target,\n+\t\t\t\t\t\t      arg0, arg1, indices);\n+\t  gcc_assert (ok);\n+\t  emit_move_insn (operands[0],\n+\t\t\t  lowpart_subreg (V2DImode, target, V4SImode));\n+\t  DONE;\n+\t}\n+      if (!TARGET_XOP)\n+\t{\n+\t  rtx zero = force_reg (V2DImode, CONST0_RTX (V2DImode));\n+\t  rtx zero_or_all_ones;\n+\t  if (TARGET_SSE4_2)\n+\t    {\n+\t      zero_or_all_ones = gen_reg_rtx (V2DImode);\n+\t      emit_insn (gen_sse4_2_gtv2di3 (zero_or_all_ones, zero,\n+\t\t\t\t\t     operands[1]));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx temp = gen_reg_rtx (V4SImode);\n+\t      emit_insn (gen_ashrv4si3 (temp, lowpart_subreg (V4SImode,\n+\t\t\t\t\t\t\t      operands[1],\n+\t\t\t\t\t\t\t      V2DImode),\n+\t\t\t\t\tGEN_INT (31)));\n+\t      zero_or_all_ones = gen_reg_rtx (V4SImode);\n+\t      emit_insn (gen_sse2_pshufd_1 (zero_or_all_ones, temp,\n+\t\t\t\t\t    const1_rtx, const1_rtx,\n+\t\t\t\t\t    GEN_INT (3), GEN_INT (3)));\n+\t      zero_or_all_ones = lowpart_subreg (V2DImode, zero_or_all_ones,\n+\t\t\t\t\t\t V4SImode);\n+\t    }\n+\t  rtx lshr_res = gen_reg_rtx (V2DImode);\n+\t  emit_insn (gen_lshrv2di3 (lshr_res, operands[1], operands[2]));\n+\t  rtx ashl_res = gen_reg_rtx (V2DImode);\n+\t  rtx amount;\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      amount = gen_reg_rtx (DImode);\n+\t      emit_insn (gen_subdi3 (amount, force_reg (DImode, GEN_INT (64)),\n+\t\t\t\t     operands[2]));\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx temp = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_subsi3 (temp, force_reg (SImode, GEN_INT (64)),\n+\t\t\t\t     lowpart_subreg (SImode, operands[2],\n+\t\t\t\t\t\t     DImode)));\n+\t      amount = gen_reg_rtx (V4SImode);\n+\t      emit_insn (gen_vec_setv4si_0 (amount, CONST0_RTX (V4SImode),\n+\t\t\t\t\t    temp));\n+\t    }\n+\t  amount = lowpart_subreg (DImode, amount, GET_MODE (amount));\n+\t  emit_insn (gen_ashlv2di3 (ashl_res, zero_or_all_ones, amount));\n+\t  emit_insn (gen_iorv2di3 (operands[0], lshr_res, ashl_res));\n+\t  DONE;\n+\t}\n+\n       rtx reg = gen_reg_rtx (V2DImode);\n       rtx par;\n       bool negate = false;"}, {"sha": "fb35df809c89055580f0fd9317dbe6c90933a85a", "filename": "gcc/testsuite/gcc.dg/torture/vshuf-4.inc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fvshuf-4.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fvshuf-4.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fvshuf-4.inc?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -25,7 +25,9 @@ T (21,\t2, 6, 3, 7) \\\n T (22,\t1, 2, 3, 0) \\\n T (23,\t2, 1, 0, 3) \\\n T (24,\t2, 5, 6, 3) \\\n-T (25,\t0, 1, 4, 5)\n+T (25,\t0, 1, 4, 5) \\\n+T (26,\t1, 5, 3, 7) \\\n+T (27,\t0, 5, 2, 7)\n #define EXPTESTS \\\n T (116,\t1, 2, 4, 3) \\\n T (117,\t7, 3, 3, 0) \\"}, {"sha": "d628039d88e8bf29b91a45ef504233c2b947eb46", "filename": "gcc/testsuite/gcc.dg/torture/vshuf-8.inc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fvshuf-8.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fvshuf-8.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fvshuf-8.inc?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -27,7 +27,9 @@ T (23,\t6, 5, 4, 3, 2, 1, 0, 7) \\\n T (24,\t0, 1, 2, 3, 8, 9, 10, 11) \\\n T (25,\t0, 1, 2, 3, 12, 13, 14, 15) \\\n T (26,\t0, 1, 8, 9, 10, 11, 12, 13) \\\n-T (27,\t0, 8, 9, 10, 11, 12, 13, 14)\n+T (27,\t0, 8, 9, 10, 11, 12, 13, 14) \\\n+T (28,\t1, 9, 3, 11, 5, 13, 7, 15) \\\n+T (29,\t0, 9, 2, 11, 4, 13, 6, 15)\n #define EXPTESTS \\\n T (116,\t9, 3, 9, 4, 7, 0, 0, 6) \\\n T (117,\t4, 14, 12, 8, 9, 6, 0, 10) \\"}, {"sha": "dc12dbf1e783629b070f7a6ab287c3f5f59d84fa", "filename": "gcc/testsuite/gcc.target/i386/avx-pr82370.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr82370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr82370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-pr82370.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -4,7 +4,7 @@\n /* { dg-final { scan-assembler-times \"vpslld\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 3 } } */\n /* { dg-final { scan-assembler-times \"vpsllq\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 3 } } */\n /* { dg-final { scan-assembler-times \"vpsllw\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 3 } } */\n-/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 3 } } */\n+/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 6 } } */\n /* { dg-final { scan-assembler-times \"vpsraq\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 0 } } */\n /* { dg-final { scan-assembler-times \"vpsraw\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 3 } } */\n /* { dg-final { scan-assembler-times \"vpsrld\\[ \\t]\\+\\\\\\$5, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 3 } } */"}, {"sha": "27220888e0cdab97c5790c080e5bcbb3d3b300db", "filename": "gcc/testsuite/gcc.target/i386/avx-psraq-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-psraq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-psraq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-psraq-1.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx -mno-avx2\" } */\n+/* { dg-require-effective-target avx } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"avx-check.h\"\n+#endif\n+\n+#ifndef TEST\n+#define TEST avx_test\n+#endif\n+\n+#include \"sse2-psraq-1.c\""}, {"sha": "df3dfd8596f09dbde511e99d989276889b53d710", "filename": "gcc/testsuite/gcc.target/i386/avx2-pr82370.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr82370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr82370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-pr82370.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -4,7 +4,7 @@\n /* { dg-final { scan-assembler-times \"vpslld\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllq\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllw\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 2 } } */\n /* { dg-final { scan-assembler-times \"vpsraq\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 0 } } */\n /* { dg-final { scan-assembler-times \"vpsraw\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsrld\\[ \\t]\\+\\\\\\$5, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n@@ -13,7 +13,7 @@\n /* { dg-final { scan-assembler-times \"vpslld\\[ \\t]\\+\\\\\\$7, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllq\\[ \\t]\\+\\\\\\$7, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllw\\[ \\t]\\+\\\\\\$7, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 2 } } */\n /* { dg-final { scan-assembler-times \"vpsraq\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 0 } } */\n /* { dg-final { scan-assembler-times \"vpsraw\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsrld\\[ \\t]\\+\\\\\\$5, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */"}, {"sha": "e9051bf9fcbe63a5e1d7e7a7f2e523d99576662d", "filename": "gcc/testsuite/gcc.target/i386/avx2-psraq-1.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-psraq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-psraq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-psraq-1.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx2 -mno-avx512f\" } */\n+/* { dg-require-effective-target avx2 } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"avx2-check.h\"\n+#endif\n+\n+#ifndef TEST\n+#define TEST avx2_test\n+#endif\n+\n+#include CHECK_H\n+\n+typedef long long V __attribute__((vector_size (32)));\n+\n+#define TESTN(N) \\\n+static V\t\t\t\\\n+__attribute__((noipa))\t\t\\\n+test##N (V x)\t\t\t\\\n+{\t\t\t\t\\\n+  return x >> N;\t\t\\\n+}\n+\n+#define TESTS TESTN (63) TESTN (49) TESTN (32) TESTN (31) TESTN (18)\n+TESTS\n+\n+struct\n+{\n+  int n;\n+  V (*fn) (V);\n+} tests[] = {\n+#undef TESTN\n+#define TESTN(N) { N, test##N },\n+  TESTS\n+};\n+\n+static void\n+TEST (void)\n+{\n+  V a = (V) { 0xdeadbeefcafebabeULL, 0x123456789abcdef0ULL,\n+\t      0x173a74be8a95134cULL, 0x817bae35ac0ebf12ULL };\n+  int i;\n+  for (i = 0; tests[i].n; i++)\n+    {\n+      V c = tests[i].fn (a);\n+      if (c[0] != a[0] >> tests[i].n || c[1] != a[1] >> tests[i].n\n+\t  || c[2] != a[2] >> tests[i].n || c[3] != a[3] >> tests[i].n)\n+\tabort ();\n+    }\n+}"}, {"sha": "12c3b27cecdc3ba8a51dd0120cffa972e4f6e169", "filename": "gcc/testsuite/gcc.target/i386/avx512bw-pr82370.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512bw-pr82370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512bw-pr82370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512bw-pr82370.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -4,7 +4,7 @@\n /* { dg-final { scan-assembler-times \"vpslld\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllq\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllw\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 2 } } */\n /* { dg-final { scan-assembler-times \"vpsraq\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 0 } } */\n /* { dg-final { scan-assembler-times \"vpsraw\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsrld\\[ \\t]\\+\\\\\\$5, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n@@ -13,7 +13,7 @@\n /* { dg-final { scan-assembler-times \"vpslld\\[ \\t]\\+\\\\\\$7, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllq\\[ \\t]\\+\\\\\\$7, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllw\\[ \\t]\\+\\\\\\$7, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 2 } } */\n /* { dg-final { scan-assembler-times \"vpsraq\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 0 } } */\n /* { dg-final { scan-assembler-times \"vpsraw\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsrld\\[ \\t]\\+\\\\\\$5, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */"}, {"sha": "b179f9b901f2d77a6e181a3807975194c08bc686", "filename": "gcc/testsuite/gcc.target/i386/avx512f-pr82370.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr82370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr82370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512f-pr82370.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -4,7 +4,7 @@\n /* { dg-final { scan-assembler-times \"vpslld\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllq\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllw\\[ \\t]\\+\\\\\\$7, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 2 } } */\n /* { dg-final { scan-assembler-times \"vpsraq\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 0 } } */\n /* { dg-final { scan-assembler-times \"vpsraw\\[ \\t]\\+\\\\\\$3, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsrld\\[ \\t]\\+\\\\\\$5, %xmm\\[0-9]\\+, %xmm\\[0-9]\\+\" 1 } } */\n@@ -13,7 +13,7 @@\n /* { dg-final { scan-assembler-times \"vpslld\\[ \\t]\\+\\\\\\$7, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllq\\[ \\t]\\+\\\\\\$7, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n /* { dg-final { scan-assembler-times \"vpsllw\\[ \\t]\\+\\\\\\$7, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 3 } } */\n-/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"vpsrad\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 2 } } */\n /* { dg-final { scan-assembler-times \"vpsraq\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 0 } } */\n /* { dg-final { scan-assembler-times \"vpsraw\\[ \\t]\\+\\\\\\$3, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 3 } } */\n /* { dg-final { scan-assembler-times \"vpsrld\\[ \\t]\\+\\\\\\$5, %ymm\\[0-9]\\+, %ymm\\[0-9]\\+\" 1 } } */"}, {"sha": "9a08ee4f7fa54205d6e9e52219bb4978c2bbd4d3", "filename": "gcc/testsuite/gcc.target/i386/sse2-psraq-1.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-psraq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-psraq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-psraq-1.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -msse2 -mno-sse3\" } */\n+/* { dg-require-effective-target sse2 } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse2-check.h\"\n+#endif\n+\n+#ifndef TEST\n+#define TEST sse2_test\n+#endif\n+\n+#include CHECK_H\n+\n+typedef long long V __attribute__((vector_size (16)));\n+\n+#define TESTN(N) \\\n+static V\t\t\t\\\n+__attribute__((noipa))\t\t\\\n+test##N (V x)\t\t\t\\\n+{\t\t\t\t\\\n+  return x >> N;\t\t\\\n+}\n+\n+#define TESTS TESTN (63) TESTN (49) TESTN (32) TESTN (31) TESTN (18)\n+TESTS\n+\n+struct\n+{\n+  int n;\n+  V (*fn) (V);\n+} tests[] = {\n+#undef TESTN\n+#define TESTN(N) { N, test##N },\n+  TESTS\n+};\n+\n+static void\n+TEST (void)\n+{\n+  V a = (V) { 0xdeadbeefcafebabeULL, 0x123456789abcdef0ULL };\n+  V b = (V) { 0x173a74be8a95134cULL, 0x817bae35ac0ebf12ULL };\n+  int i;\n+  for (i = 0; tests[i].n; i++)\n+    {\n+      V c = tests[i].fn (a);\n+      if (c[0] != a[0] >> tests[i].n || c[1] != a[1] >> tests[i].n)\n+\tabort ();\n+      c = tests[i].fn (b);\n+      if (c[0] != b[0] >> tests[i].n || c[1] != b[1] >> tests[i].n)\n+\tabort ();\n+    }\n+}"}, {"sha": "947b623d1eb2b4b0ae31adf6fca5dda29f147d3d", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-psraq-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-psraq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/829c4bea06600ea4201462f91ce6d76ca21fdb35/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-psraq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-psraq-1.c?ref=829c4bea06600ea4201462f91ce6d76ca21fdb35", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -msse4.2 -mno-avx\" } */\n+/* { dg-require-effective-target sse4 } */\n+\n+#ifndef CHECK_H\n+#define CHECK_H \"sse4_2-check.h\"\n+#endif\n+\n+#ifndef TEST\n+#define TEST sse4_2_test\n+#endif\n+\n+#include \"sse2-psraq-1.c\""}]}