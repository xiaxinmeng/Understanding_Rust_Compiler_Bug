{"sha": "0c6826a52305c4dadad3da2882f708e80638f100", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM2ODI2YTUyMzA1YzRkYWRhZDNkYTI4ODJmNzA4ZTgwNjM4ZjEwMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-27T13:19:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-27T13:19:35Z"}, "message": "[multiple changes]\n\n2015-05-26  Robert Dewar  <dewar@adacore.com>\n\n\t* errout.ads, sem_ch4.adb, sem_ch6.adb: Minor reformatting.\n\n2015-05-26  Bob Duff  <duff@adacore.com>\n\n\t* sem_elab.adb (Check_A_Call): In the case where we're\n\tcalling something in an instance of a generic package that is\n\twithin this same unit (as the call), make sure we treat it\n\tas a call to an entity within the same unit. That is, call\n\tCheck_Internal_Call, rather than putting \"Elaborate_All(X)\"\n\ton X, which would necessarily result in an elaboration cycle in\n\tstatic-elaboration mode.\n\n2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* freeze.ads (Is_Atomic_VFA_Aggregate): Adjust profile.\n\t* freeze.adb (Is_Atomic_VFA_Aggregate): Change Entity\n\tparameter into Node parameter and remove Type parameter.\n\tLook at Is_Atomic_Or_VFA both on the type and on the object.\n\t(Freeze_Entity): Adjust call to Is_Atomic_VFA_Aggregate.\n\t* exp_aggr.adb (Expand_Record_Aggregate): Likewise.\n\t(Process_Atomic_Independent_Shared_Volatile): Remove code\n\tpropagating Atomic or VFA from object to locally-defined type.\n\n2015-05-26  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch7.adb: Minor comment fix.\n\nFrom-SVN: r223751", "tree": {"sha": "0960336918c6106d72f6f5e7ea2a310ab9c26532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0960336918c6106d72f6f5e7ea2a310ab9c26532"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c6826a52305c4dadad3da2882f708e80638f100", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c6826a52305c4dadad3da2882f708e80638f100", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c6826a52305c4dadad3da2882f708e80638f100", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c6826a52305c4dadad3da2882f708e80638f100/comments", "author": null, "committer": null, "parents": [{"sha": "faae53f8ca3766da999534c342e00e5eeadd9f9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/faae53f8ca3766da999534c342e00e5eeadd9f9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/faae53f8ca3766da999534c342e00e5eeadd9f9d"}], "stats": {"total": 790, "additions": 395, "deletions": 395}, "files": [{"sha": "0bce664d3d2549ef0576575520d11fd2482eb75e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -1,3 +1,32 @@\n+2015-05-26  Robert Dewar  <dewar@adacore.com>\n+\n+\t* errout.ads, sem_ch4.adb, sem_ch6.adb: Minor reformatting.\n+\n+2015-05-26  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elab.adb (Check_A_Call): In the case where we're\n+\tcalling something in an instance of a generic package that is\n+\twithin this same unit (as the call), make sure we treat it\n+\tas a call to an entity within the same unit. That is, call\n+\tCheck_Internal_Call, rather than putting \"Elaborate_All(X)\"\n+\ton X, which would necessarily result in an elaboration cycle in\n+\tstatic-elaboration mode.\n+\n+2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* freeze.ads (Is_Atomic_VFA_Aggregate): Adjust profile.\n+\t* freeze.adb (Is_Atomic_VFA_Aggregate): Change Entity\n+\tparameter into Node parameter and remove Type parameter.\n+\tLook at Is_Atomic_Or_VFA both on the type and on the object.\n+\t(Freeze_Entity): Adjust call to Is_Atomic_VFA_Aggregate.\n+\t* exp_aggr.adb (Expand_Record_Aggregate): Likewise.\n+\t(Process_Atomic_Independent_Shared_Volatile): Remove code\n+\tpropagating Atomic or VFA from object to locally-defined type.\n+\n+2015-05-26  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch7.adb: Minor comment fix.\n+\n 2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Min/Attr_Max>: Do not"}, {"sha": "1832b0d6359169dd926214cebcebadc0381d892d", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -24,7 +24,7 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routines to output error messages. They are\n---  basically system independent, however, in some environments, e.g. when the\n+--  basically system independent, however in some environments, e.g. when the\n --  parser is embedded into an editor, it may be appropriate to replace the\n --  implementation of this package.\n "}, {"sha": "6cdd290bd9ee837e11f29932ea05f7fe55aefebf", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -5950,10 +5950,7 @@ package body Exp_Aggr is\n       --  temporary instead, so that the back end can generate an atomic move\n       --  for it.\n \n-      if Is_Atomic_Or_VFA (Typ)\n-        and then Comes_From_Source (Parent (N))\n-        and then Is_Atomic_VFA_Aggregate (N, Typ)\n-      then\n+      if Is_Atomic_VFA_Aggregate (N) then\n          return;\n \n       --  No special management required for aggregates used to initialize"}, {"sha": "74854ba2da56b4be85fa3d778c374c46ae406186", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -129,7 +129,7 @@ package body Exp_Ch7 is\n \n    function Find_Node_To_Be_Wrapped (N : Node_Id) return Node_Id;\n    --  N is a node which may generate a transient scope. Loop over the parent\n-   --  pointers of N until it find the appropriate node to wrap. If it returns\n+   --  pointers of N until we find the appropriate node to wrap. If it returns\n    --  Empty, it means that no transient scope is needed in this context.\n \n    procedure Insert_Actions_In_Scope_Around"}, {"sha": "c7ad86c1d41b5efda83caf425d9940b6567fc0ed", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -1459,42 +1459,61 @@ package body Freeze is\n    -- Is_Atomic_VFA_Aggregate --\n    -----------------------------\n \n-   function Is_Atomic_VFA_Aggregate\n-     (E   : Entity_Id;\n-      Typ : Entity_Id) return Boolean\n-   is\n-      Loc   : constant Source_Ptr := Sloc (E);\n+   function Is_Atomic_VFA_Aggregate (N : Node_Id) return Boolean is\n+      Loc   : constant Source_Ptr := Sloc (N);\n       New_N : Node_Id;\n       Par   : Node_Id;\n       Temp  : Entity_Id;\n+      Typ   : Entity_Id;\n \n    begin\n-      Par := Parent (E);\n+      Par := Parent (N);\n \n       --  Array may be qualified, so find outer context\n \n       if Nkind (Par) = N_Qualified_Expression then\n          Par := Parent (Par);\n       end if;\n \n-      if Nkind_In (Par, N_Object_Declaration, N_Assignment_Statement)\n-        and then Comes_From_Source (Par)\n-      then\n-         Temp := Make_Temporary (Loc, 'T', E);\n-         New_N :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Temp,\n-             Object_Definition   => New_Occurrence_Of (Typ, Loc),\n-             Expression          => Relocate_Node (E));\n-         Insert_Before (Par, New_N);\n-         Analyze (New_N);\n-\n-         Set_Expression (Par, New_Occurrence_Of (Temp, Loc));\n-         return True;\n-\n-      else\n+      if not Comes_From_Source (Par) then\n          return False;\n       end if;\n+\n+      case Nkind (Par) is\n+         when N_Assignment_Statement =>\n+            Typ := Etype (Name (Par));\n+\n+            if not Is_Atomic_Or_VFA (Typ)\n+              and then not (Is_Entity_Name (Name (Par))\n+                             and then Is_Atomic_Or_VFA (Entity (Name (Par))))\n+            then\n+               return False;\n+            end if;\n+\n+         when N_Object_Declaration =>\n+            Typ := Etype (Defining_Identifier (Par));\n+\n+            if not Is_Atomic_Or_VFA (Typ)\n+              and then not Is_Atomic_Or_VFA (Defining_Identifier (Par))\n+            then\n+               return False;\n+            end if;\n+\n+         when others =>\n+            return False;\n+      end case;\n+\n+      Temp := Make_Temporary (Loc, 'T', N);\n+      New_N :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Temp,\n+          Object_Definition   => New_Occurrence_Of (Typ, Loc),\n+          Expression          => Relocate_Node (N));\n+      Insert_Before (Par, New_N);\n+      Analyze (New_N);\n+\n+      Set_Expression (Par, New_Occurrence_Of (Temp, Loc));\n+      return True;\n    end Is_Atomic_VFA_Aggregate;\n \n    -----------------------------------------------\n@@ -4821,8 +4840,7 @@ package body Freeze is\n            and then Nkind (Parent (E)) = N_Object_Declaration\n            and then Present (Expression (Parent (E)))\n            and then Nkind (Expression (Parent (E))) = N_Aggregate\n-           and then\n-             Is_Atomic_VFA_Aggregate (Expression (Parent (E)), Etype (E))\n+           and then Is_Atomic_VFA_Aggregate (Expression (Parent (E)))\n          then\n             null;\n          end if;"}, {"sha": "f11347d5ed0117a99384ea6e5b16f4b9d7bb670c", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -174,9 +174,7 @@ package Freeze is\n    --  do not allow a size clause if the size would not otherwise be known at\n    --  compile time in any case.\n \n-   function Is_Atomic_VFA_Aggregate\n-     (E   : Entity_Id;\n-      Typ : Entity_Id) return Boolean;\n+   function Is_Atomic_VFA_Aggregate (N : Node_Id) return Boolean;\n    --  If an atomic/VFA object is initialized with an aggregate or is assigned\n    --  an aggregate, we have to prevent a piecemeal access or assignment to the\n    --  object, even if the aggregate is to be expanded. We create a temporary"}, {"sha": "b525e90a098340c674777aba7733921707f76349", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -1968,10 +1968,10 @@ package body Sem_Ch4 is\n                end if;\n \n                --  An explicit dereference is a legal occurrence of an\n-               --  incomplete type imported through a limited_with clause,\n-               --  if the full view is visible, or if we are within an\n-               --  instance body, where the enclosing body has a regular\n-               --  with_clause on the unit.\n+               --  incomplete type imported through a limited_with clause, if\n+               --  the full view is visible, or if we are within an instance\n+               --  body, where the enclosing body has a regular with_clause\n+               --  on the unit.\n \n                if From_Limited_With (DT)\n                  and then not From_Limited_With (Scope (DT))\n@@ -2196,8 +2196,8 @@ package body Sem_Ch4 is\n             Get_First_Interp (Then_Expr, I, It);\n             while Present (It.Nam) loop\n \n-               --  Add possible intepretation of Then_Expr if no Else_Expr,\n-               --  or Else_Expr is present and has a compatible type.\n+               --  Add possible intepretation of Then_Expr if no Else_Expr, or\n+               --  Else_Expr is present and has a compatible type.\n \n                if No (Else_Expr)\n                  or else Has_Compatible_Type (Else_Expr, It.Typ)\n@@ -2224,8 +2224,8 @@ package body Sem_Ch4 is\n       U_N   : Entity_Id;\n \n       procedure Process_Function_Call;\n-      --  Prefix in indexed component form is an overloadable entity,\n-      --  so the node is a function call. Reformat it as such.\n+      --  Prefix in indexed component form is an overloadable entity, so the\n+      --  node is a function call. Reformat it as such.\n \n       procedure Process_Indexed_Component;\n       --  Prefix in indexed component form is actually an indexed component.\n@@ -2263,8 +2263,8 @@ package body Sem_Ch4 is\n \n             --  Move to next actual. Note that we use Next, not Next_Actual\n             --  here. The reason for this is a bit subtle. If a function call\n-            --  includes named associations, the parser recognizes the node as\n-            --  a call, and it is analyzed as such. If all associations are\n+            --  includes named associations, the parser recognizes the node\n+            --  as a call, and it is analyzed as such. If all associations are\n             --  positional, the parser builds an indexed_component node, and\n             --  it is only after analysis of the prefix that the construct\n             --  is recognized as a call, in which case Process_Function_Call\n@@ -2398,7 +2398,7 @@ package body Sem_Ch4 is\n                elsif Is_Entity_Name (P)\n                  and then Etype (P) = Standard_Void_Type\n                then\n-                  Error_Msg_NE (\"incorrect use of&\", P, Entity (P));\n+                  Error_Msg_NE (\"incorrect use of &\", P, Entity (P));\n \n                else\n                   Error_Msg_N (\"array type required in indexed component\", P);\n@@ -2447,10 +2447,10 @@ package body Sem_Ch4 is\n \n          Exp := First (Exprs);\n \n-         --  If one index is present, and it is a subtype name, then the\n-         --  node denotes a slice (note that the case of an explicit range\n-         --  for a slice was already built as an N_Slice node in the first\n-         --  place, so that case is not handled here).\n+         --  If one index is present, and it is a subtype name, then the node\n+         --  denotes a slice (note that the case of an explicit range for a\n+         --  slice was already built as an N_Slice node in the first place,\n+         --  so that case is not handled here).\n \n          --  We use a replace rather than a rewrite here because this is one\n          --  of the cases in which the tree built by the parser is plain wrong."}, {"sha": "43cbffce8be4ea0a191fe9f8ca6b8cf760a2c399", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -8297,7 +8297,7 @@ package body Sem_Ch6 is\n             then\n                Defn :=\n                  Type_Definition\n-                    (Original_Node (Parent (First_Subtype (F_Typ))));\n+                   (Original_Node (Parent (First_Subtype (F_Typ))));\n             else\n                Defn := Type_Definition (Original_Node (Parent (F_Typ)));\n             end if;\n@@ -8347,6 +8347,7 @@ package body Sem_Ch6 is\n          elsif not Is_Class_Wide_Type (New_Type) then\n             while Etype (New_Type) /= New_Type loop\n                New_Type := Etype (New_Type);\n+\n                if New_Type = Prev_Type then\n                   return True;\n                end if;"}, {"sha": "07517bbc467601e950e78d8e84af8201b0a31184", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 303, "deletions": 305, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -736,407 +736,405 @@ package body Sem_Elab is\n          return;\n       end if;\n \n-      --  Case of entity is not in current unit (i.e. with'ed unit case)\n-\n-      if E_Scope /= C_Scope then\n-\n-         --  We are only interested in such calls if the outer call was from\n-         --  elaboration code, or if we are in Dynamic_Elaboration_Checks mode.\n+      --  Find top level scope for called entity (not following renamings\n+      --  or derivations). This is where the Elaborate_All will go if it is\n+      --  needed. We start with the called entity, except in the case of an\n+      --  initialization procedure outside the current package, where the init\n+      --  proc is in the root package, and we start from the entity of the name\n+      --  in the call.\n \n-         if not From_Elab_Code and then not Dynamic_Elaboration_Checks then\n-            return;\n+      declare\n+         Ent : constant Entity_Id := Get_Referenced_Ent (N);\n+      begin\n+         if Is_Init_Proc (Ent)\n+           and then not In_Same_Extended_Unit (N, Ent)\n+         then\n+            W_Scope := Scope (Ent);\n+         else\n+            W_Scope := E;\n          end if;\n+      end;\n \n-         --  Nothing to do if some scope said that no checks were required\n+      --  Now loop through scopes to get to the enclosing compilation unit\n \n-         if Cunit_SC then\n-            return;\n-         end if;\n+      while not Is_Compilation_Unit (W_Scope) loop\n+         W_Scope := Scope (W_Scope);\n+      end loop;\n \n-         --  Nothing to do for a generic instance, because in this case the\n-         --  checking was at the point of instantiation of the generic However,\n-         --  this shortcut is only applicable in static mode.\n+      --  Case of entity is in same unit as call or instantiation. In the\n+      --  instantiation case, W_Scope may be different from E_Scope; we want\n+      --  the unit in which the instantiation occurs, since we're analyzing\n+      --  based on the expansion.\n \n-         if Is_Generic_Instance (Ent) and not Dynamic_Elaboration_Checks then\n-            return;\n+      if W_Scope = C_Scope then\n+         if not Inter_Unit_Only then\n+            Check_Internal_Call (N, Ent, Outer_Scope, E);\n          end if;\n \n-         --  Nothing to do if subprogram with no separate spec. However, a\n-         --  call to Deep_Initialize may result in a call to a user-defined\n-         --  Initialize procedure, which imposes a body dependency. This\n-         --  happens only if the type is controlled and the Initialize\n-         --  procedure is not inherited.\n+         return;\n+      end if;\n \n-         if Body_Acts_As_Spec then\n-            if Is_TSS (Ent, TSS_Deep_Initialize) then\n-               declare\n-                  Typ  : constant Entity_Id := Etype (First_Formal (Ent));\n-                  Init : Entity_Id;\n+      --  Case of entity is not in current unit (i.e. with'ed unit case)\n \n-               begin\n-                  if not Is_Controlled (Typ) then\n-                     return;\n-                  else\n-                     Init := Find_Prim_Op (Typ, Name_Initialize);\n+      --  We are only interested in such calls if the outer call was from\n+      --  elaboration code, or if we are in Dynamic_Elaboration_Checks mode.\n \n-                     if Comes_From_Source (Init) then\n-                        Ent := Init;\n-                     else\n-                        return;\n-                     end if;\n-                  end if;\n-               end;\n-\n-            else\n-               return;\n-            end if;\n-         end if;\n+      if not From_Elab_Code and then not Dynamic_Elaboration_Checks then\n+         return;\n+      end if;\n \n-         --  Check cases of internal units\n+      --  Nothing to do if some scope said that no checks were required\n \n-         Callee_Unit_Internal :=\n-           Is_Internal_File_Name\n-             (Unit_File_Name (Get_Source_Unit (E_Scope)));\n+      if Cunit_SC then\n+         return;\n+      end if;\n \n-         --  Do not give a warning if the with'ed unit is internal and this is\n-         --  the generic instantiation case (this saves a lot of hassle dealing\n-         --  with the Text_IO special child units)\n+      --  Nothing to do for a generic instance, because in this case the\n+      --  checking was at the point of instantiation of the generic However,\n+      --  this shortcut is only applicable in static mode.\n \n-         if Callee_Unit_Internal and Inst_Case then\n-            return;\n-         end if;\n+      if Is_Generic_Instance (Ent) and not Dynamic_Elaboration_Checks then\n+         return;\n+      end if;\n \n-         if C_Scope = Standard_Standard then\n-            Caller_Unit_Internal := False;\n-         else\n-            Caller_Unit_Internal :=\n-              Is_Internal_File_Name\n-                (Unit_File_Name (Get_Source_Unit (C_Scope)));\n-         end if;\n+      --  Nothing to do if subprogram with no separate spec. However, a call\n+      --  to Deep_Initialize may result in a call to a user-defined Initialize\n+      --  procedure, which imposes a body dependency. This happens only if the\n+      --  type is controlled and the Initialize procedure is not inherited.\n \n-         --  Do not give a warning if the with'ed unit is internal and the\n-         --  caller is not internal (since the binder always elaborates\n-         --  internal units first).\n+      if Body_Acts_As_Spec then\n+         if Is_TSS (Ent, TSS_Deep_Initialize) then\n+            declare\n+               Typ  : constant Entity_Id := Etype (First_Formal (Ent));\n+               Init : Entity_Id;\n \n-         if Callee_Unit_Internal and (not Caller_Unit_Internal) then\n-            return;\n-         end if;\n+            begin\n+               if not Is_Controlled (Typ) then\n+                  return;\n+               else\n+                  Init := Find_Prim_Op (Typ, Name_Initialize);\n \n-         --  For now, if debug flag -gnatdE is not set, do no checking for\n-         --  one internal unit withing another. This fixes the problem with\n-         --  the sgi build and storage errors. To be resolved later ???\n+                  if Comes_From_Source (Init) then\n+                     Ent := Init;\n+                  else\n+                     return;\n+                  end if;\n+               end if;\n+            end;\n \n-         if (Callee_Unit_Internal and Caller_Unit_Internal)\n-           and then not Debug_Flag_EE\n-         then\n+         else\n             return;\n          end if;\n+      end if;\n \n-         if Is_TSS (E, TSS_Deep_Initialize) then\n-            Ent := E;\n-         end if;\n-\n-         --  If the call is in an instance, and the called entity is not\n-         --  defined in the same instance, then the elaboration issue focuses\n-         --  around the unit containing the template, it is this unit which\n-         --  requires an Elaborate_All.\n+      --  Check cases of internal units\n \n-         --  However, if we are doing dynamic elaboration, we need to chase the\n-         --  call in the usual manner.\n+      Callee_Unit_Internal :=\n+        Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (E_Scope)));\n \n-         --  We also need to chase the call in the usual manner if it is a call\n-         --  to a generic formal parameter, since that case was not handled as\n-         --  part of the processing of the template.\n+      --  Do not give a warning if the with'ed unit is internal and this is\n+      --  the generic instantiation case (this saves a lot of hassle dealing\n+      --  with the Text_IO special child units)\n \n-         Inst_Caller := Instantiation (Get_Source_File_Index (Sloc (N)));\n-         Inst_Callee := Instantiation (Get_Source_File_Index (Sloc (Ent)));\n+      if Callee_Unit_Internal and Inst_Case then\n+         return;\n+      end if;\n \n-         if Inst_Caller = No_Location then\n-            Unit_Caller := No_Unit;\n-         else\n-            Unit_Caller := Get_Source_Unit (N);\n-         end if;\n+      if C_Scope = Standard_Standard then\n+         Caller_Unit_Internal := False;\n+      else\n+         Caller_Unit_Internal :=\n+           Is_Internal_File_Name (Unit_File_Name (Get_Source_Unit (C_Scope)));\n+      end if;\n \n-         if Inst_Callee = No_Location then\n-            Unit_Callee := No_Unit;\n-         else\n-            Unit_Callee := Get_Source_Unit (Ent);\n-         end if;\n+      --  Do not give a warning if the with'ed unit is internal and the\n+      --  caller is not internal (since the binder always elaborates\n+      --  internal units first).\n \n-         if Unit_Caller /= No_Unit\n-           and then Unit_Callee /= Unit_Caller\n-           and then not Dynamic_Elaboration_Checks\n-           and then not Is_Call_Of_Generic_Formal (N)\n-         then\n-            E_Scope := Spec_Entity (Cunit_Entity (Unit_Caller));\n+      if Callee_Unit_Internal and (not Caller_Unit_Internal) then\n+         return;\n+      end if;\n \n-            --  If we don't get a spec entity, just ignore call. Not quite\n-            --  clear why this check is necessary. ???\n+      --  For now, if debug flag -gnatdE is not set, do no checking for\n+      --  one internal unit withing another. This fixes the problem with\n+      --  the sgi build and storage errors. To be resolved later ???\n \n-            if No (E_Scope) then\n-               return;\n-            end if;\n+      if (Callee_Unit_Internal and Caller_Unit_Internal)\n+        and not Debug_Flag_EE\n+      then\n+         return;\n+      end if;\n \n-            --  Otherwise step to enclosing compilation unit\n+      if Is_TSS (E, TSS_Deep_Initialize) then\n+         Ent := E;\n+      end if;\n \n-            while not Is_Compilation_Unit (E_Scope) loop\n-               E_Scope := Scope (E_Scope);\n-            end loop;\n+      --  If the call is in an instance, and the called entity is not\n+      --  defined in the same instance, then the elaboration issue focuses\n+      --  around the unit containing the template, it is this unit which\n+      --  requires an Elaborate_All.\n \n-         --  For the case where N is not an instance, and is not a call within\n-         --  instance to other than a generic formal, we recompute E_Scope\n-         --  for the error message, since we do NOT want to go to the unit\n-         --  which has the ultimate declaration in the case of renaming and\n-         --  derivation and we also want to go to the generic unit in the\n-         --  case of an instance, and no further.\n+      --  However, if we are doing dynamic elaboration, we need to chase the\n+      --  call in the usual manner.\n \n-         else\n-            --  Loop to carefully follow renamings and derivations one step\n-            --  outside the current unit, but not further.\n+      --  We also need to chase the call in the usual manner if it is a call\n+      --  to a generic formal parameter, since that case was not handled as\n+      --  part of the processing of the template.\n \n-            if not (Inst_Case or Variable_Case)\n-              and then Present (Alias (Ent))\n-            then\n-               E_Scope := Alias (Ent);\n-            else\n-               E_Scope := Ent;\n-            end if;\n+      Inst_Caller := Instantiation (Get_Source_File_Index (Sloc (N)));\n+      Inst_Callee := Instantiation (Get_Source_File_Index (Sloc (Ent)));\n \n-            loop\n-               while not Is_Compilation_Unit (E_Scope) loop\n-                  E_Scope := Scope (E_Scope);\n-               end loop;\n+      if Inst_Caller = No_Location then\n+         Unit_Caller := No_Unit;\n+      else\n+         Unit_Caller := Get_Source_Unit (N);\n+      end if;\n \n-               --  If E_Scope is the same as C_Scope, it means that there\n-               --  definitely was a local renaming or derivation, and we\n-               --  are not yet out of the current unit.\n+      if Inst_Callee = No_Location then\n+         Unit_Callee := No_Unit;\n+      else\n+         Unit_Callee := Get_Source_Unit (Ent);\n+      end if;\n \n-               exit when E_Scope /= C_Scope;\n-               Ent := Alias (Ent);\n-               E_Scope := Ent;\n+      if Unit_Caller /= No_Unit\n+        and then Unit_Callee /= Unit_Caller\n+        and then not Dynamic_Elaboration_Checks\n+        and then not Is_Call_Of_Generic_Formal (N)\n+      then\n+         E_Scope := Spec_Entity (Cunit_Entity (Unit_Caller));\n \n-               --  If no alias, there is a previous error\n+         --  If we don't get a spec entity, just ignore call. Not quite\n+         --  clear why this check is necessary. ???\n \n-               if No (Ent) then\n-                  Check_Error_Detected;\n-                  return;\n-               end if;\n-            end loop;\n-         end if;\n-\n-         if Within_Elaborate_All (Current_Sem_Unit, E_Scope) then\n+         if No (E_Scope) then\n             return;\n          end if;\n \n-         --  Find top level scope for called entity (not following renamings\n-         --  or derivations). This is where the Elaborate_All will go if it\n-         --  is needed. We start with the called entity, except in the case\n-         --  of an initialization procedure outside the current package, where\n-         --  the init proc is in the root package, and we start from the entity\n-         --  of the name in the call.\n-\n-         declare\n-            Ent : constant Entity_Id := Get_Referenced_Ent (N);\n-         begin\n-            if Is_Init_Proc (Ent)\n-              and then not In_Same_Extended_Unit (N, Ent)\n-            then\n-               W_Scope := Scope (Ent);\n-            else\n-               W_Scope := E;\n-            end if;\n-         end;\n-\n-         --  Now loop through scopes to get to the enclosing compilation unit\n+         --  Otherwise step to enclosing compilation unit\n \n-         while not Is_Compilation_Unit (W_Scope) loop\n-            W_Scope := Scope (W_Scope);\n+         while not Is_Compilation_Unit (E_Scope) loop\n+            E_Scope := Scope (E_Scope);\n          end loop;\n \n-         --  Now check if an elaborate_all (or dynamic check) is needed\n+      --  For the case where N is not an instance, and is not a call within\n+      --  instance to other than a generic formal, we recompute E_Scope\n+      --  for the error message, since we do NOT want to go to the unit\n+      --  which has the ultimate declaration in the case of renaming and\n+      --  derivation and we also want to go to the generic unit in the\n+      --  case of an instance, and no further.\n \n-         if not Suppress_Elaboration_Warnings (Ent)\n-           and then not Elaboration_Checks_Suppressed (Ent)\n-           and then not Suppress_Elaboration_Warnings (E_Scope)\n-           and then not Elaboration_Checks_Suppressed (E_Scope)\n-           and then ((Elab_Warnings or Elab_Info_Messages)\n-                      or else SPARK_Mode = On)\n-           and then Generate_Warnings\n+      else\n+         --  Loop to carefully follow renamings and derivations one step\n+         --  outside the current unit, but not further.\n+\n+         if not (Inst_Case or Variable_Case)\n+           and then Present (Alias (Ent))\n          then\n-            --  Instantiation case\n+            E_Scope := Alias (Ent);\n+         else\n+            E_Scope := Ent;\n+         end if;\n \n-            if Inst_Case then\n-               if SPARK_Mode = On then\n-                  Error_Msg_NE\n-                    (\"instantiation of & during elaboration in SPARK\",\n-                     N, Ent);\n+         loop\n+            while not Is_Compilation_Unit (E_Scope) loop\n+               E_Scope := Scope (E_Scope);\n+            end loop;\n \n-               else\n-                  Elab_Warning\n-                    (\"instantiation of & may raise Program_Error?l?\",\n-                     \"info: instantiation of & during elaboration?$?\", Ent);\n-               end if;\n+            --  If E_Scope is the same as C_Scope, it means that there\n+            --  definitely was a local renaming or derivation, and we\n+            --  are not yet out of the current unit.\n \n-            --  Indirect call case, info message only in static elaboration\n-            --  case, because the attribute reference itself cannot raise an\n-            --  exception. Note that SPARK does not  permit indirect calls.\n+            exit when E_Scope /= C_Scope;\n+            Ent := Alias (Ent);\n+            E_Scope := Ent;\n \n-            elsif Access_Case then\n-               Elab_Warning\n-                 (\"\", \"info: access to & during elaboration?$?\", Ent);\n+            --  If no alias, there is a previous error\n \n-            --  Variable reference in SPARK mode\n+            if No (Ent) then\n+               Check_Error_Detected;\n+               return;\n+            end if;\n+         end loop;\n+      end if;\n \n-            elsif Variable_Case then\n-               Error_Msg_NE\n-                 (\"reference to & during elaboration in SPARK\", N, Ent);\n+      if Within_Elaborate_All (Current_Sem_Unit, E_Scope) then\n+         return;\n+      end if;\n \n-            --  Subprogram call case\n+      --  Now check if an Elaborate_All (or dynamic check) is needed\n \n-            else\n-               if Nkind (Name (N)) in N_Has_Entity\n-                 and then Is_Init_Proc (Entity (Name (N)))\n-                 and then Comes_From_Source (Ent)\n-               then\n-                  Elab_Warning\n-                    (\"implicit call to & may raise Program_Error?l?\",\n-                     \"info: implicit call to & during elaboration?$?\",\n-                     Ent);\n+      if not Suppress_Elaboration_Warnings (Ent)\n+        and then not Elaboration_Checks_Suppressed (Ent)\n+        and then not Suppress_Elaboration_Warnings (E_Scope)\n+        and then not Elaboration_Checks_Suppressed (E_Scope)\n+        and then ((Elab_Warnings or Elab_Info_Messages)\n+                    or else SPARK_Mode = On)\n+        and then Generate_Warnings\n+      then\n+         --  Instantiation case\n \n-               elsif SPARK_Mode = On then\n-                  Error_Msg_NE\n-                    (\"call to & during elaboration in SPARK\", N, Ent);\n+         if Inst_Case then\n+            if SPARK_Mode = On then\n+               Error_Msg_NE\n+                 (\"instantiation of & during elaboration in SPARK\", N, Ent);\n \n-               else\n-                  Elab_Warning\n-                    (\"call to & may raise Program_Error?l?\",\n-                     \"info: call to & during elaboration?$?\",\n-                     Ent);\n-               end if;\n+            else\n+               Elab_Warning\n+                 (\"instantiation of & may raise Program_Error?l?\",\n+                  \"info: instantiation of & during elaboration?$?\", Ent);\n             end if;\n \n-            Error_Msg_Qual_Level := Nat'Last;\n+         --  Indirect call case, info message only in static elaboration\n+         --  case, because the attribute reference itself cannot raise an\n+         --  exception. Note that SPARK does not  permit indirect calls.\n \n-            --  Case of Elaborate_All not present and required, for SPARK this\n-            --  is an error, so give an error message.\n+         elsif Access_Case then\n+            Elab_Warning (\"\", \"info: access to & during elaboration?$?\", Ent);\n \n-            if SPARK_Mode = On then\n-               Error_Msg_NE\n-                 (\"\\Elaborate_All pragma required for&\", N, W_Scope);\n+         --  Variable reference in SPARK mode\n+\n+         elsif Variable_Case then\n+            Error_Msg_NE\n+              (\"reference to & during elaboration in SPARK\", N, Ent);\n \n-            --  Otherwise we generate an implicit pragma. For a subprogram\n-            --  instantiation, Elaborate is good enough, since no transitive\n-            --  call is possible at elaboration time in this case.\n+         --  Subprogram call case\n \n-            elsif Nkind (N) in N_Subprogram_Instantiation then\n+         else\n+            if Nkind (Name (N)) in N_Has_Entity\n+              and then Is_Init_Proc (Entity (Name (N)))\n+              and then Comes_From_Source (Ent)\n+            then\n                Elab_Warning\n-                 (\"\\missing pragma Elaborate for&?l?\",\n-                  \"\\implicit pragma Elaborate for& generated?$?\",\n-                  W_Scope);\n+                 (\"implicit call to & may raise Program_Error?l?\",\n+                  \"info: implicit call to & during elaboration?$?\",\n+                  Ent);\n \n-            --  For all other cases, we need an implicit Elaborate_All\n+            elsif SPARK_Mode = On then\n+               Error_Msg_NE (\"call to & during elaboration in SPARK\", N, Ent);\n \n             else\n                Elab_Warning\n-                 (\"\\missing pragma Elaborate_All for&?l?\",\n-                  \"\\implicit pragma Elaborate_All for & generated?$?\",\n-                  W_Scope);\n+                 (\"call to & may raise Program_Error?l?\",\n+                  \"info: call to & during elaboration?$?\",\n+                  Ent);\n             end if;\n+         end if;\n \n-            Error_Msg_Qual_Level := 0;\n+         Error_Msg_Qual_Level := Nat'Last;\n \n-            --  Take into account the flags related to elaboration warning\n-            --  messages when enumerating the various calls involved. This\n-            --  ensures the proper pairing of the main warning and the\n-            --  clarification messages generated by Output_Calls.\n+         --  Case of Elaborate_All not present and required, for SPARK this\n+         --  is an error, so give an error message.\n \n-            Output_Calls (N, Check_Elab_Flag => True);\n+         if SPARK_Mode = On then\n+            Error_Msg_NE (\"\\Elaborate_All pragma required for&\", N, W_Scope);\n \n-            --  Set flag to prevent further warnings for same unit unless in\n-            --  All_Errors_Mode.\n+         --  Otherwise we generate an implicit pragma. For a subprogram\n+         --  instantiation, Elaborate is good enough, since no transitive\n+         --  call is possible at elaboration time in this case.\n \n-            if not All_Errors_Mode and not Dynamic_Elaboration_Checks then\n-               Set_Suppress_Elaboration_Warnings (W_Scope, True);\n-            end if;\n+         elsif Nkind (N) in N_Subprogram_Instantiation then\n+            Elab_Warning\n+              (\"\\missing pragma Elaborate for&?l?\",\n+               \"\\implicit pragma Elaborate for& generated?$?\",\n+               W_Scope);\n+\n+         --  For all other cases, we need an implicit Elaborate_All\n+\n+         else\n+            Elab_Warning\n+              (\"\\missing pragma Elaborate_All for&?l?\",\n+               \"\\implicit pragma Elaborate_All for & generated?$?\",\n+               W_Scope);\n          end if;\n \n-         --  Check for runtime elaboration check required\n+         Error_Msg_Qual_Level := 0;\n \n-         if Dynamic_Elaboration_Checks then\n-            if not Elaboration_Checks_Suppressed (Ent)\n-              and then not Elaboration_Checks_Suppressed (W_Scope)\n-              and then not Elaboration_Checks_Suppressed (E_Scope)\n-              and then not Cunit_SC\n-            then\n-               --  Runtime elaboration check required. Generate check of the\n-               --  elaboration Boolean for the unit containing the entity.\n+         --  Take into account the flags related to elaboration warning\n+         --  messages when enumerating the various calls involved. This\n+         --  ensures the proper pairing of the main warning and the\n+         --  clarification messages generated by Output_Calls.\n \n-               --  Note that for this case, we do check the real unit (the one\n-               --  from following renamings, since that is the issue).\n+         Output_Calls (N, Check_Elab_Flag => True);\n \n-               --  Could this possibly miss a useless but required PE???\n+         --  Set flag to prevent further warnings for same unit unless in\n+         --  All_Errors_Mode.\n \n-               Insert_Elab_Check (N,\n-                 Make_Attribute_Reference (Loc,\n-                   Attribute_Name => Name_Elaborated,\n-                   Prefix         =>\n-                     New_Occurrence_Of (Spec_Entity (E_Scope), Loc)));\n+         if not All_Errors_Mode and not Dynamic_Elaboration_Checks then\n+            Set_Suppress_Elaboration_Warnings (W_Scope, True);\n+         end if;\n+      end if;\n \n-               --  Prevent duplicate elaboration checks on the same call,\n-               --  which can happen if the body enclosing the call appears\n-               --  itself in a call whose elaboration check is delayed.\n+      --  Check for runtime elaboration check required\n \n-               if Nkind (N) in N_Subprogram_Call then\n-                  Set_No_Elaboration_Check (N);\n-               end if;\n-            end if;\n+      if Dynamic_Elaboration_Checks then\n+         if not Elaboration_Checks_Suppressed (Ent)\n+           and then not Elaboration_Checks_Suppressed (W_Scope)\n+           and then not Elaboration_Checks_Suppressed (E_Scope)\n+           and then not Cunit_SC\n+         then\n+            --  Runtime elaboration check required. Generate check of the\n+            --  elaboration Boolean for the unit containing the entity.\n \n-         --  Case of static elaboration model\n+            --  Note that for this case, we do check the real unit (the one\n+            --  from following renamings, since that is the issue).\n \n-         else\n-            --  Do not do anything if elaboration checks suppressed. Note that\n-            --  we check Ent here, not E, since we want the real entity for the\n-            --  body to see if checks are suppressed for it, not the dummy\n-            --  entry for renamings or derivations.\n-\n-            if Elaboration_Checks_Suppressed (Ent)\n-              or else Elaboration_Checks_Suppressed (E_Scope)\n-              or else Elaboration_Checks_Suppressed (W_Scope)\n-            then\n-               null;\n+            --  Could this possibly miss a useless but required PE???\n \n-            --  Do not generate an Elaborate_All for finalization routines\n-            --  which perform partial clean up as part of initialization.\n+            Insert_Elab_Check (N,\n+              Make_Attribute_Reference (Loc,\n+                Attribute_Name => Name_Elaborated,\n+                Prefix         =>\n+                  New_Occurrence_Of (Spec_Entity (E_Scope), Loc)));\n \n-            elsif In_Init_Proc and then Is_Finalization_Procedure (Ent) then\n-               null;\n+            --  Prevent duplicate elaboration checks on the same call,\n+            --  which can happen if the body enclosing the call appears\n+            --  itself in a call whose elaboration check is delayed.\n \n-            --  Here we need to generate an implicit elaborate all\n+            if Nkind (N) in N_Subprogram_Call then\n+               Set_No_Elaboration_Check (N);\n+            end if;\n+         end if;\n \n-            else\n-               --  Generate Elaborate_all warning unless suppressed\n+      --  Case of static elaboration model\n \n-               if (Elab_Info_Messages and Generate_Warnings and not Inst_Case)\n-                 and then not Suppress_Elaboration_Warnings (Ent)\n-                 and then not Suppress_Elaboration_Warnings (E_Scope)\n-                 and then not Suppress_Elaboration_Warnings (W_Scope)\n-               then\n-                  Error_Msg_Node_2 := W_Scope;\n-                  Error_Msg_NE\n-                    (\"info: call to& in elaboration code \" &\n-                     \"requires pragma Elaborate_All on&?$?\", N, E);\n-               end if;\n+      else\n+         --  Do not do anything if elaboration checks suppressed. Note that\n+         --  we check Ent here, not E, since we want the real entity for the\n+         --  body to see if checks are suppressed for it, not the dummy\n+         --  entry for renamings or derivations.\n+\n+         if Elaboration_Checks_Suppressed (Ent)\n+           or else Elaboration_Checks_Suppressed (E_Scope)\n+           or else Elaboration_Checks_Suppressed (W_Scope)\n+         then\n+            null;\n+\n+         --  Do not generate an Elaborate_All for finalization routines\n+         --  which perform partial clean up as part of initialization.\n \n-               --  Set indication for binder to generate Elaborate_All\n+         elsif In_Init_Proc and then Is_Finalization_Procedure (Ent) then\n+            null;\n+\n+         --  Here we need to generate an implicit elaborate all\n \n-               Set_Elaboration_Constraint (N, E, W_Scope);\n+         else\n+            --  Generate Elaborate_All warning unless suppressed\n+\n+            if (Elab_Info_Messages and Generate_Warnings and not Inst_Case)\n+              and then not Suppress_Elaboration_Warnings (Ent)\n+              and then not Suppress_Elaboration_Warnings (E_Scope)\n+              and then not Suppress_Elaboration_Warnings (W_Scope)\n+            then\n+               Error_Msg_Node_2 := W_Scope;\n+               Error_Msg_NE\n+                 (\"info: call to& in elaboration code \" &\n+                  \"requires pragma Elaborate_All on&?$?\", N, E);\n             end if;\n-         end if;\n \n-      --  Case of entity is in same unit as call or instantiation\n+            --  Set indication for binder to generate Elaborate_All\n \n-      elsif not Inter_Unit_Only then\n-         Check_Internal_Call (N, Ent, Outer_Scope, E);\n+            Set_Elaboration_Constraint (N, E, W_Scope);\n+         end if;\n       end if;\n    end Check_A_Call;\n "}, {"sha": "d516c23200acb7c10e55957c318c85fb40f36c22", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c6826a52305c4dadad3da2882f708e80638f100/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0c6826a52305c4dadad3da2882f708e80638f100", "patch": "@@ -5875,7 +5875,6 @@ package body Sem_Prag is\n          E    : Entity_Id;\n          E_Id : Node_Id;\n          K    : Node_Kind;\n-         Utyp : Entity_Id;\n \n          procedure Set_Atomic_VFA (E : Entity_Id);\n          --  Set given type as Is_Atomic or Is_Volatile_Full_Access. Also, if\n@@ -6053,46 +6052,6 @@ package body Sem_Prag is\n                then\n                   Set_Has_Delayed_Freeze (E);\n                end if;\n-\n-               --  An interesting improvement here. If an object of composite\n-               --  type X is declared atomic, and the type X isn't, that's a\n-               --  pity, since it may not have appropriate alignment etc. We\n-               --  can rescue this in the special case where the object and\n-               --  type are in the same unit by just setting the type as\n-               --  atomic, so that the back end will process it as atomic.\n-\n-               --  Note: we used to do this for elementary types as well,\n-               --  but that turns out to be a bad idea and can have unwanted\n-               --  effects, most notably if the type is elementary, the object\n-               --  a simple component within a record, and both are in a spec:\n-               --  every object of this type in the entire program will be\n-               --  treated as atomic, thus incurring a potentially costly\n-               --  synchronization operation for every access.\n-\n-               --  For Volatile_Full_Access we can do this for elementary types\n-               --  too, since there is no issue of atomic synchronization.\n-\n-               --  Of course it would be best if the back end could just adjust\n-               --  the alignment etc for the specific object, but that's not\n-               --  something we are capable of doing at this point.\n-\n-               Utyp := Underlying_Type (Etype (E));\n-\n-               if Present (Utyp)\n-                 and then (Is_Composite_Type (Utyp)\n-                            or else Prag_Id = Pragma_Volatile_Full_Access)\n-                 and then Sloc (E) > No_Location\n-                 and then Sloc (Utyp) > No_Location\n-                 and then\n-                   Get_Source_File_Index (Sloc (E)) =\n-                                            Get_Source_File_Index (Sloc (Utyp))\n-               then\n-                  if Prag_Id = Pragma_Volatile_Full_Access then\n-                     Set_Is_Volatile_Full_Access (Utyp);\n-                  else\n-                     Set_Is_Atomic (Utyp);\n-                  end if;\n-               end if;\n             end if;\n \n             --  Atomic/Shared/Volatile_Full_Access imply Independent"}]}