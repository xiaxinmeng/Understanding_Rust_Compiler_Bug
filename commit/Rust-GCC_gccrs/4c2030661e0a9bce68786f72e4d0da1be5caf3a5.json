{"sha": "4c2030661e0a9bce68786f72e4d0da1be5caf3a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMyMDMwNjYxZTBhOWJjZTY4Nzg2ZjcyZTRkMGRhMWJlNWNhZjNhNQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-11-02T15:22:52Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-11-02T15:22:52Z"}, "message": "re PR middle-end/46120 (g++.dg/ipa/ivinline-?.C)\n\n2010-11-02  Martin Jambor  <mjambor@suse.cz>\n\n\tPR middle-end/46120\n\t* tree.c (get_binfo_at_offset): Bail out on artificial\n\tfields. Identify primary bases according to their offsets.\n\n\t* testsuite/g++.dg/ipa/ivinline-9.C: New test.\n\nFrom-SVN: r166192", "tree": {"sha": "6b301cc7b78e84ad831cce83f66b80281b61bc17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b301cc7b78e84ad831cce83f66b80281b61bc17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c2030661e0a9bce68786f72e4d0da1be5caf3a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2030661e0a9bce68786f72e4d0da1be5caf3a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c2030661e0a9bce68786f72e4d0da1be5caf3a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c2030661e0a9bce68786f72e4d0da1be5caf3a5/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a2b3e20767d3d11776e4c5bbb12d751e7ba748f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a2b3e20767d3d11776e4c5bbb12d751e7ba748f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a2b3e20767d3d11776e4c5bbb12d751e7ba748f"}], "stats": {"total": 144, "additions": 125, "deletions": 19}, "files": [{"sha": "a347b05182c7a2b46c538774baa6e2ea777e2d3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2030661e0a9bce68786f72e4d0da1be5caf3a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2030661e0a9bce68786f72e4d0da1be5caf3a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c2030661e0a9bce68786f72e4d0da1be5caf3a5", "patch": "@@ -1,3 +1,9 @@\n+2010-11-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/46120\n+\t* tree.c (get_binfo_at_offset): Bail out on artificial\n+\tfields.  Identify primary bases according to their offsets.\n+\n 2010-11-02  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/45875"}, {"sha": "471b009da58309425c82581785c0dc1b05343106", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2030661e0a9bce68786f72e4d0da1be5caf3a5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2030661e0a9bce68786f72e4d0da1be5caf3a5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4c2030661e0a9bce68786f72e4d0da1be5caf3a5", "patch": "@@ -1,3 +1,8 @@\n+2010-11-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR middle-end/46120\n+\t* g++.dg/ipa/ivinline-9.C: New test.\n+\n 2010-11-02  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/45875"}, {"sha": "429b6f4f00c8dd56066b26d59524993f5c5ec474", "filename": "gcc/testsuite/g++.dg/ipa/ivinline-9.C", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2030661e0a9bce68786f72e4d0da1be5caf3a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2030661e0a9bce68786f72e4d0da1be5caf3a5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fivinline-9.C?ref=4c2030661e0a9bce68786f72e4d0da1be5caf3a5", "patch": "@@ -0,0 +1,93 @@\n+/* Verify that simple virtual calls are inlined even without early\n+   inlining, even when a typecast to an ancestor is involved along the\n+   way and that ancestor itself has an ancestor wich is not the\n+   primary base class.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fdump-ipa-inline -fno-early-inlining -fno-ipa-cp\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class Distraction\n+{\n+public:\n+  float f;\n+  double d;\n+  Distraction ()\n+  {\n+    f = 8.3;\n+    d = 10.2;\n+  }\n+  virtual float bar (float z);\n+};\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+/*\n+class D2\n+{\n+public:\n+  virtual float baz (float z)\n+  {\n+    abort();\n+  }\n+};\n+*/\n+class A2 : public Distraction, public A\n+{\n+  int i2;\n+};\n+\n+class B : public A2\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+float Distraction::bar (float z)\n+{\n+  f += z;\n+  return f/2;\n+}\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static int middleman_1 (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+static int middleman_2 (class B *obj, int i)\n+{\n+  return middleman_1 (obj, i);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+  int i;\n+\n+  for (i = 0; i < get_input (); i++)\n+    if (middleman_2 (&b, get_input ()) != 3)\n+      abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"B::foo\\[^\\\\n\\]*inline copy in int main\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}, {"sha": "1cc99f07c67a697fcecc3008cf19e1d5d403a3fd", "filename": "gcc/tree.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c2030661e0a9bce68786f72e4d0da1be5caf3a5/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c2030661e0a9bce68786f72e4d0da1be5caf3a5/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4c2030661e0a9bce68786f72e4d0da1be5caf3a5", "patch": "@@ -10906,16 +10906,17 @@ lhd_gcc_personality (void)\n tree\n get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n {\n-  tree type;\n+  tree type = TREE_TYPE (binfo);\n \n-  type = TREE_TYPE (binfo);\n-  while (offset > 0)\n+  while (true)\n     {\n-      tree base_binfo, found_binfo;\n       HOST_WIDE_INT pos, size;\n       tree fld;\n       int i;\n \n+      gcc_checking_assert (offset >= 0);\n+      if (type == expected_type)\n+\t  return binfo;\n       if (TREE_CODE (type) != RECORD_TYPE)\n \treturn NULL_TREE;\n \n@@ -10929,27 +10930,28 @@ get_binfo_at_offset (tree binfo, HOST_WIDE_INT offset, tree expected_type)\n \t  if (pos <= offset && (pos + size) > offset)\n \t    break;\n \t}\n-      if (!fld)\n+      if (!fld || !DECL_ARTIFICIAL (fld))\n \treturn NULL_TREE;\n \n-      found_binfo = NULL_TREE;\n-      for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-\tif (TREE_TYPE (base_binfo) == TREE_TYPE (fld))\n-\t  {\n-\t    found_binfo = base_binfo;\n-\t    break;\n-\t  }\n-\n-      if (!found_binfo)\n-\treturn NULL_TREE;\n+      /* Offset 0 indicates the primary base, whose vtable contents are\n+\t represented in the binfo for the derived class.  */\n+      if (offset != 0)\n+\t{\n+\t  tree base_binfo, found_binfo = NULL_TREE;\n+\t  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\t    if (TREE_TYPE (base_binfo) == TREE_TYPE (fld))\n+\t      {\n+\t\tfound_binfo = base_binfo;\n+\t\tbreak;\n+\t      }\n+\t  if (!found_binfo)\n+\t    return NULL_TREE;\n+\t  binfo = found_binfo;\n+\t}\n \n       type = TREE_TYPE (fld);\n-      binfo = found_binfo;\n       offset -= pos;\n     }\n-  if (type != expected_type)\n-    return NULL_TREE;\n-  return binfo;\n }\n \n /* Returns true if X is a typedef decl.  */"}]}