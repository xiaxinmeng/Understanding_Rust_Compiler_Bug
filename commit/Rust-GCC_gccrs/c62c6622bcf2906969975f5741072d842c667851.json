{"sha": "c62c6622bcf2906969975f5741072d842c667851", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYyYzY2MjJiY2YyOTA2OTY5OTc1ZjU3NDEwNzJkODQyYzY2Nzg1MQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-07-20T05:56:37Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-07-20T05:56:37Z"}, "message": "re PR fortran/48820 (TR 29113: Implement parts needed for MPI 3)\n\n2012-07-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/48820\n        * array.c (match_array_element_spec, gfc_match_array_spec,\n        spec_size, gfc_array_dimen_size): Add support for\n        assumed-rank arrays.\n        * check.c (dim_rank_check): Ditto.\n        * class.c (gfc_add_component_ref): Ditto.\n        (gfc_build_class_symbol): Regard assumed-rank arrays\n        as having GFC_MAX_DIMENSIONS. And build extra class\n        container for a scalar pointer class.\n        * decl.c (merge_array_spec): Add assert.\n        * dump-parse-tree.c (show_array_spec): Add support for\n        assumed-rank arrays.\n        * expr.c (gfc_is_simply_contiguous): Ditto.\n        * gfortran.h (array_type): Ditto.\n        (gfc_array_spec, gfc_expr): Add comment to \"rank\" field.\n        * interface.c (compare_type_rank, argument_rank_mismatch,\n        compare_parameter, gfc_procedure_use): Ditto.\n        (compare_actual_formal): Fix NULL() to optional-dummy\n        handling for polymorphic dummies.\n        * module.c (mio_typespec): Add support for\n        assumed-rank arrays.\n        * resolve.c (resolve_formal_arglist, resolve_actual_arglist,\n        resolve_elemental_actual, resolve_global_procedure,\n        expression_shape, resolve_variable, update_ppc_arglist,\n        check_typebound_baseobject, gfc_resolve_expr,\n        resolve_fl_var_and_proc, gfc_resolve_finalizers,\n        resolve_typebound_procedure, resolve_symbol): Ditto.\n        (assumed_type_expr_allowed): Remove static variable.\n        (actual_arg, first_actual_arg): New static variables.\n        * simplify.c (simplify_bound, gfc_simplify_range): Add\n        support for assumed-rank arrays.\n        * trans-array.c (gfc_conv_array_parameter): Ditto.\n        (gfc_get_descriptor_dimension): New function, which returns\n        the descriptor.\n        (gfc_conv_descriptor_dimension): Use it.\n        (gfc_conv_descriptor_stride_get, gfc_conv_array_parameter):\n        Handle GFC_ARRAY_ASSUMED_RANK_CONT and AS_ASSUMED_RANK.\n        * trans-array.h (gfc_get_descriptor_dimension): New prototype.\n        * trans-decl. (gfc_build_dummy_array_decl,\n        gfc_trans_deferred_vars, add_argument_checking): Add\n        support for assumed-rank arrays.\n        * trans-expr.c (gfc_conv_expr_present, gfc_conv_variable,\n        gfc_conv_procedure_call): Ditto.\n        (get_scalar_to_descriptor_type, class_array_data_assign,\n        conv_scalar_to_descriptor): New static functions.\n        (gfc_conv_derived_to_class, gfc_conv_class_to_class): Use\n        them.\n        * trans-intrinsic.c (get_rank_from_desc): New function.\n        (gfc_conv_intrinsic_rank, gfc_conv_associated): Use it.\n        * trans-types.c (gfc_array_descriptor_base_caf,\n        gfc_array_descriptor_base): Make space for scalar array.\n        (gfc_is_nodesc_array, gfc_is_nodesc_array,\n        gfc_build_array_type, gfc_get_array_descriptor_base): Add\n        support for assumed-rank arrays.\n        * trans.h (gfc_array_kind): Add GFC_ARRAY_ASSUMED_RANK and\n        GFC_ARRAY_ASSUMED_RANK_CONT.\n\n2012-07-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/48820\n        * gfortran.dg/assumed_type_3.f90: Update dg-error.\n        * gfortran.dg/assumed_rank_1.f90: New.\n        * gfortran.dg/assumed_rank_1_c.c: New.\n        * gfortran.dg/assumed_rank_2.f90: New.\n        * gfortran.dg/assumed_rank_4.f90: New.\n        * gfortran.dg/assumed_rank_5.f90: New.\n        * gfortran.dg/assumed_rank_6.f90: New.\n        * gfortran.dg/assumed_rank_7.f90: New.\n        * gfortran.dg/assumed_rank_8.f90: New.\n        * gfortran.dg/assumed_rank_8_c.c: New.\n        * gfortran.dg/assumed_rank_9.f90: New.\n        * gfortran.dg/assumed_rank_10.f90: New.\n        * gfortran.dg/assumed_rank_12.f90: New.\n\nFrom-SVN: r189700", "tree": {"sha": "09b3829b3012cefb99599fd8befc8055b9e1d6b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09b3829b3012cefb99599fd8befc8055b9e1d6b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c62c6622bcf2906969975f5741072d842c667851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c62c6622bcf2906969975f5741072d842c667851", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c62c6622bcf2906969975f5741072d842c667851", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c62c6622bcf2906969975f5741072d842c667851/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02fe175c38c7e2a6043548b6f1500c4cb2fa30e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02fe175c38c7e2a6043548b6f1500c4cb2fa30e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02fe175c38c7e2a6043548b6f1500c4cb2fa30e7"}], "stats": {"total": 1531, "additions": 1411, "deletions": 120}, "files": [{"sha": "0d8b4bacc272f77781bd1f43f1f95836447b2784", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -1,3 +1,62 @@\n+2012-07-20  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/48820\n+\t* array.c (match_array_element_spec, gfc_match_array_spec,\n+\tspec_size, gfc_array_dimen_size): Add support for\n+\tassumed-rank arrays.\n+\t* check.c (dim_rank_check): Ditto.\n+\t* class.c (gfc_add_component_ref): Ditto.\n+\t(gfc_build_class_symbol): Regard assumed-rank arrays\n+\tas having GFC_MAX_DIMENSIONS. And build extra class\n+\tcontainer for a scalar pointer class.\n+\t* decl.c (merge_array_spec): Add assert.\n+\t* dump-parse-tree.c (show_array_spec): Add support for\n+\tassumed-rank arrays.\n+\t* expr.c (gfc_is_simply_contiguous): Ditto.\n+\t* gfortran.h (array_type): Ditto.\n+\t(gfc_array_spec, gfc_expr): Add comment to \"rank\" field.\n+\t* interface.c (compare_type_rank, argument_rank_mismatch,\n+\tcompare_parameter, gfc_procedure_use): Ditto.\n+\t(compare_actual_formal): Fix NULL() to optional-dummy\n+\thandling for polymorphic dummies.\n+\t* module.c (mio_typespec): Add support for\n+\tassumed-rank arrays.\n+\t* resolve.c (resolve_formal_arglist, resolve_actual_arglist,\n+\tresolve_elemental_actual, resolve_global_procedure,\n+\texpression_shape, resolve_variable, update_ppc_arglist,\n+\tcheck_typebound_baseobject, gfc_resolve_expr,\n+\tresolve_fl_var_and_proc, gfc_resolve_finalizers,\n+\tresolve_typebound_procedure, resolve_symbol): Ditto.\n+\t(assumed_type_expr_allowed): Remove static variable.\n+\t(actual_arg, first_actual_arg): New static variables.\n+\t* simplify.c (simplify_bound, gfc_simplify_range): Add\n+\tsupport for assumed-rank arrays.\n+\t* trans-array.c (gfc_conv_array_parameter): Ditto.\n+\t(gfc_get_descriptor_dimension): New function, which returns\n+\tthe descriptor.\n+\t(gfc_conv_descriptor_dimension): Use it.\n+\t(gfc_conv_descriptor_stride_get, gfc_conv_array_parameter):\n+\tHandle GFC_ARRAY_ASSUMED_RANK_CONT and AS_ASSUMED_RANK.\n+\t* trans-array.h (gfc_get_descriptor_dimension): New prototype.\n+\t* trans-decl. (gfc_build_dummy_array_decl,\n+\tgfc_trans_deferred_vars, add_argument_checking): Add\n+\tsupport for assumed-rank arrays.\n+\t* trans-expr.c (gfc_conv_expr_present, gfc_conv_variable,\n+\tgfc_conv_procedure_call): Ditto.\n+\t(get_scalar_to_descriptor_type, class_array_data_assign,\n+\tconv_scalar_to_descriptor): New static functions.\n+\t(gfc_conv_derived_to_class, gfc_conv_class_to_class): Use\n+\tthem.\n+\t* trans-intrinsic.c (get_rank_from_desc): New function.\n+\t(gfc_conv_intrinsic_rank, gfc_conv_associated): Use it.\n+\t* trans-types.c (gfc_array_descriptor_base_caf,\n+\tgfc_array_descriptor_base): Make space for scalar array.\n+\t(gfc_is_nodesc_array, gfc_is_nodesc_array,\n+\tgfc_build_array_type, gfc_get_array_descriptor_base): Add\n+\tsupport for assumed-rank arrays.\n+\t* trans.h (gfc_array_kind): Add GFC_ARRAY_ASSUMED_RANK and\n+\tGFC_ARRAY_ASSUMED_RANK_CONT.\n+\n 2012-07-19  Tobias Burnus  <burnus@net-b.de>\n \n \t* trans-expr.c (gfc_conv_procedure_call): Fix handling"}, {"sha": "acae59fecaedf48c877b931b58826136244e38ec", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -390,9 +390,11 @@ match_array_element_spec (gfc_array_spec *as)\n {\n   gfc_expr **upper, **lower;\n   match m;\n+  int rank;\n \n-  lower = &as->lower[as->rank + as->corank - 1];\n-  upper = &as->upper[as->rank + as->corank - 1];\n+  rank = as->rank == -1 ? 0 : as->rank;\n+  lower = &as->lower[rank + as->corank - 1];\n+  upper = &as->upper[rank + as->corank - 1];\n \n   if (gfc_match_char ('*') == MATCH_YES)\n     {\n@@ -458,6 +460,20 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n       goto coarray;\n     }\n \n+  if (gfc_match (\" .. )\") == MATCH_YES)\n+    {\n+      as->type = AS_ASSUMED_RANK;\n+      as->rank = -1;\n+\n+      if (gfc_notify_std (GFC_STD_F2008_TS, \"Assumed-rank array at %C\")\n+\t  == FAILURE)\n+\tgoto cleanup;\n+\n+      if (!match_codim)\n+\tgoto done;\n+      goto coarray;\n+    }\n+\n   for (;;)\n     {\n       as->rank++;\n@@ -536,6 +552,9 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n \n \t    gfc_error (\"Bad specification for assumed size array at %C\");\n \t    goto cleanup;\n+\n+\t  case AS_ASSUMED_RANK:\n+\t    gcc_unreachable (); \n \t  }\n \n       if (gfc_match_char (')') == MATCH_YES)\n@@ -642,6 +661,9 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n \t    case AS_ASSUMED_SIZE:\n \t      gfc_error (\"Bad specification for assumed size array at %C\");\n \t      goto cleanup;\n+\n+\t    case AS_ASSUMED_RANK:\n+\t      gcc_unreachable (); \n \t  }\n \n       if (gfc_match_char (']') == MATCH_YES)\n@@ -1960,6 +1982,9 @@ spec_size (gfc_array_spec *as, mpz_t *result)\n   mpz_t size;\n   int d;\n \n+  if (as->type == AS_ASSUMED_RANK)\n+    return FAILURE;\n+\n   mpz_init_set_ui (*result, 1);\n \n   for (d = 0; d < as->rank; d++)\n@@ -2116,6 +2141,9 @@ gfc_array_dimen_size (gfc_expr *array, int dimen, mpz_t *result)\n   if (array->ts.type == BT_CLASS)\n     return FAILURE;\n \n+  if (array->rank == -1)\n+    return FAILURE;\n+\n   if (dimen < 0 || array == NULL || dimen > array->rank - 1)\n     gfc_internal_error (\"gfc_array_dimen_size(): Bad dimension\");\n "}, {"sha": "c5bf79b8fea1f793ebced17b2c4d5b36267a24ee", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -620,6 +620,10 @@ dim_rank_check (gfc_expr *dim, gfc_expr *array, int allow_assumed)\n   else\n     rank = array->rank;\n \n+  /* Assumed-rank array.  */\n+  if (rank == -1)\n+    rank = GFC_MAX_DIMENSIONS;\n+\n   if (array->expr_type == EXPR_VARIABLE)\n     {\n       ar = gfc_find_array_ref (array);"}, {"sha": "21a91baec20c26075cc117a137c08505de4bc837", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -220,7 +220,7 @@ gfc_add_component_ref (gfc_expr *e, const char *name)\n void\n gfc_add_class_array_ref (gfc_expr *e)\n {\n-  int rank =  CLASS_DATA (e)->as->rank;\n+  int rank = CLASS_DATA (e)->as->rank;\n   gfc_array_spec *as = CLASS_DATA (e)->as;\n   gfc_ref *ref = NULL;\n   gfc_add_component_ref (e, \"_data\");\n@@ -498,6 +498,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n   gfc_symbol *fclass;\n   gfc_symbol *vtab;\n   gfc_component *c;\n+  int rank;\n \n   if (as && *as && (*as)->type == AS_ASSUMED_SIZE)\n     {\n@@ -518,11 +519,14 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n     return SUCCESS;\n \n   /* Determine the name of the encapsulating type.  */\n+  rank = !(*as) || (*as)->rank == -1 ? GFC_MAX_DIMENSIONS : (*as)->rank;\n   get_unique_hashed_string (tname, ts->u.derived);\n   if ((*as) && attr->allocatable)\n-    sprintf (name, \"__class_%s_%d_%da\", tname, (*as)->rank, (*as)->corank);\n+    sprintf (name, \"__class_%s_%d_%da\", tname, rank, (*as)->corank);\n+  else if ((*as) && attr->pointer)\n+    sprintf (name, \"__class_%s_%d_%dp\", tname, rank, (*as)->corank);\n   else if ((*as))\n-    sprintf (name, \"__class_%s_%d_%d\", tname, (*as)->rank, (*as)->corank);\n+    sprintf (name, \"__class_%s_%d_%d\", tname, rank, (*as)->corank);\n   else if (attr->pointer)\n     sprintf (name, \"__class_%s_p\", tname);\n   else if (attr->allocatable)"}, {"sha": "66e2ca86c7ae9e778415c148d0725061e9bff9cc", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -594,6 +594,9 @@ merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)\n {\n   int i;\n \n+  gcc_assert (from->rank != -1 || to->corank == 0);\n+  gcc_assert (to->rank != -1 || from->corank == 0);\n+\n   if (to->rank == 0 && from->rank > 0)\n     {\n       to->rank = from->rank;"}, {"sha": "681dc8d43031d2c7d926b3909eea2dc201afef40", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -166,14 +166,15 @@ show_array_spec (gfc_array_spec *as)\n \n   fprintf (dumpfile, \"(%d [%d]\", as->rank, as->corank);\n \n-  if (as->rank + as->corank > 0)\n+  if (as->rank + as->corank > 0 || as->rank == -1)\n     {\n       switch (as->type)\n       {\n \tcase AS_EXPLICIT:      c = \"AS_EXPLICIT\";      break;\n \tcase AS_DEFERRED:      c = \"AS_DEFERRED\";      break;\n \tcase AS_ASSUMED_SIZE:  c = \"AS_ASSUMED_SIZE\";  break;\n \tcase AS_ASSUMED_SHAPE: c = \"AS_ASSUMED_SHAPE\"; break;\n+\tcase AS_ASSUMED_RANK:  c = \"AS_ASSUMED_RANK\";  break;\n \tdefault:\n \t  gfc_internal_error (\"show_array_spec(): Unhandled array shape \"\n \t\t\t      \"type.\");"}, {"sha": "610960704377de44734828be1824bc429af4c684", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -4443,7 +4443,8 @@ gfc_is_simply_contiguous (gfc_expr *expr, bool strict)\n \t    || (!part_ref\n \t\t&& !sym->attr.contiguous\n \t\t&& (sym->attr.pointer\n-\t\t      || sym->as->type == AS_ASSUMED_SHAPE))))\n+\t\t    || sym->as->type == AS_ASSUMED_RANK\n+\t\t    || sym->as->type == AS_ASSUMED_SHAPE))))\n     return false;\n \n   if (!ar || ar->type == AR_FULL)"}, {"sha": "98bfa8a9bbc6a008ddfc69399ab9387ceed8c8ed", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -135,7 +135,8 @@ expr_t;\n /* Array types.  */\n typedef enum\n { AS_EXPLICIT = 1, AS_ASSUMED_SHAPE, AS_DEFERRED,\n-  AS_ASSUMED_SIZE, AS_IMPLIED_SHAPE, AS_UNKNOWN\n+  AS_ASSUMED_SIZE, AS_IMPLIED_SHAPE, AS_ASSUMED_RANK,\n+  AS_UNKNOWN\n }\n array_type;\n \n@@ -917,7 +918,7 @@ gfc_typespec;\n /* Array specification.  */\n typedef struct\n {\n-  int rank;\t/* A rank of zero means that a variable is a scalar.  */\n+  int rank;\t/* A scalar has a rank of 0, an assumed-rank array has -1.  */\n   int corank;\n   array_type type, cotype;\n   struct gfc_expr *lower[GFC_MAX_DIMENSIONS], *upper[GFC_MAX_DIMENSIONS];\n@@ -1694,7 +1695,7 @@ typedef struct gfc_expr\n \n   gfc_typespec ts;\t/* These two refer to the overall expression */\n \n-  int rank;\n+  int rank;\t\t/* 0 indicates a scalar, -1 an assumed-rank array.  */\n   mpz_t *shape;\t\t/* Can be NULL if shape is unknown at compile time */\n \n   /* Nonnull for functions and structure constructors, may also used to hold the"}, {"sha": "7dd4b834d7c8c70e20d0d20aad29b4f6efc6ea71", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -512,7 +512,9 @@ compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n   r1 = (s1->as != NULL) ? s1->as->rank : 0;\n   r2 = (s2->as != NULL) ? s2->as->rank : 0;\n \n-  if (r1 != r2)\n+  if (r1 != r2\n+      && (!s1->as || s1->as->type != AS_ASSUMED_RANK)\n+      && (!s2->as || s2->as->type != AS_ASSUMED_RANK))\n     return 0;\t\t\t/* Ranks differ.  */\n \n   return gfc_compare_types (&s1->ts, &s2->ts)\n@@ -1635,7 +1637,14 @@ static void\n argument_rank_mismatch (const char *name, locus *where,\n \t\t\tint rank1, int rank2)\n {\n-  if (rank1 == 0)\n+\n+  /* TS 29113, C407b.  */\n+  if (rank2 == -1)\n+    {\n+      gfc_error (\"The assumed-rank array at %L requires that the dummy argument\"\n+\t\t \" '%s' has assumed-rank\", where, name);\n+    }\n+  else if (rank1 == 0)\n     {\n       gfc_error (\"Rank mismatch in argument '%s' at %L \"\n \t\t \"(scalar and rank-%d)\", name, where, rank2);\n@@ -1860,7 +1869,8 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t     \" is modified\",  &actual->where, formal->name);\n     }\n \n-  if (symbol_rank (formal) == actual->rank)\n+  /* If the rank is the same or the formal argument has assumed-rank.  */\n+  if (symbol_rank (formal) == actual->rank || symbol_rank (formal) == -1)\n     return 1;\n \n   if (actual->ts.type == BT_CLASS && CLASS_DATA (actual)->as\n@@ -3001,6 +3011,15 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n \t      gfc_error (\"MOLD argument to NULL required at %L\", &a->expr->where);\n \t      return;\n \t    }\n+\n+\t  /* TS 29113, C407b.  */\n+\t  if (a->expr && a->expr->expr_type == EXPR_VARIABLE\n+\t      && symbol_rank (a->expr->symtree->n.sym) == -1)\n+\t    {\n+\t      gfc_error (\"Assumed-rank argument requires an explicit interface \"\n+\t\t\t \"at %L\", &a->expr->where);\n+\t      return;\n+\t    }\n \t}\n \n       return;"}, {"sha": "a3b90885f7ccf843b7728ffdf3c4ed4f531d7414", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -2341,6 +2341,7 @@ mio_typespec (gfc_typespec *ts)\n \n static const mstring array_spec_types[] = {\n     minit (\"EXPLICIT\", AS_EXPLICIT),\n+    minit (\"ASSUMED_RANK\", AS_ASSUMED_RANK),\n     minit (\"ASSUMED_SHAPE\", AS_ASSUMED_SHAPE),\n     minit (\"DEFERRED\", AS_DEFERRED),\n     minit (\"ASSUMED_SIZE\", AS_ASSUMED_SIZE),"}, {"sha": "7e2d6217adc7a0a7dc19d45b73b34fb80589c913", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 169, "deletions": 46, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -64,7 +64,13 @@ static code_stack *cs_base = NULL;\n static int forall_flag;\n static int do_concurrent_flag;\n \n-static bool assumed_type_expr_allowed = false;\n+/* True when we are resolving an expression that is an actual argument to\n+   a procedure.  */\n+static bool actual_arg = false;\n+/* True when we are resolving an expression that is the first actual argument\n+   to a procedure.  */\n+static bool first_actual_arg = false;\n+\n \n /* Nonzero if we're inside a OpenMP WORKSHARE or PARALLEL WORKSHARE block.  */\n \n@@ -86,6 +92,7 @@ static bitmap_obstack labels_obstack;\n /* True when simplifying a EXPR_VARIABLE argument to an inquiry function.  */\n static bool inquiry_argument = false;\n \n+\n int\n gfc_is_formal_arg (void)\n {\n@@ -240,7 +247,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \n   if (gfc_elemental (proc)\n       || sym->attr.pointer || sym->attr.allocatable\n-      || (sym->as && sym->as->rank > 0))\n+      || (sym->as && sym->as->rank != 0))\n     {\n       proc->attr.always_explicit = 1;\n       sym->attr.always_explicit = 1;\n@@ -307,6 +314,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t}\n \n       if ((as && as->rank > 0 && as->type == AS_ASSUMED_SHAPE)\n+\t  || (as && as->type == AS_ASSUMED_RANK)\n \t  || sym->attr.pointer || sym->attr.allocatable || sym->attr.target\n \t  || (sym->ts.type == BT_CLASS && sym->attr.class_ok\n \t      && (CLASS_DATA (sym)->attr.class_pointer\n@@ -1610,8 +1618,11 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n   gfc_symtree *parent_st;\n   gfc_expr *e;\n   int save_need_full_assumed_size;\n+  gfc_try return_value = FAILURE;\n+  bool actual_arg_sav = actual_arg, first_actual_arg_sav = first_actual_arg;\n \n-  assumed_type_expr_allowed = true;\n+  actual_arg = true;\n+  first_actual_arg = true;\n \n   for (; arg; arg = arg->next)\n     {\n@@ -1625,25 +1636,26 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t\t{\n \t\t  gfc_error (\"Label %d referenced at %L is never defined\",\n \t\t\t     arg->label->value, &arg->label->where);\n-\t\t  return FAILURE;\n+\t\t  goto cleanup;\n \t\t}\n \t    }\n+\t  first_actual_arg = false;\n \t  continue;\n \t}\n \n       if (e->expr_type == EXPR_VARIABLE\n \t    && e->symtree->n.sym->attr.generic\n \t    && no_formal_args\n \t    && count_specific_procs (e) != 1)\n-\treturn FAILURE;\n+\tgoto cleanup;\n \n       if (e->ts.type != BT_PROCEDURE)\n \t{\n \t  save_need_full_assumed_size = need_full_assumed_size;\n \t  if (e->expr_type != EXPR_VARIABLE)\n \t    need_full_assumed_size = 0;\n \t  if (gfc_resolve_expr (e) != SUCCESS)\n-\t    return FAILURE;\n+\t    goto cleanup;\n \t  need_full_assumed_size = save_need_full_assumed_size;\n \t  goto argument_list;\n \t}\n@@ -1687,7 +1699,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t\t\t\t  \"Internal procedure '%s' is\"\n \t\t\t\t  \" used as actual argument at %L\",\n \t\t\t\t  sym->name, &e->where) == FAILURE)\n-\t\treturn FAILURE;\n+\t\tgoto cleanup;\n \t    }\n \n \t  if (sym->attr.elemental && !sym->attr.intrinsic)\n@@ -1700,8 +1712,8 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t  /* Check if a generic interface has a specific procedure\n \t    with the same name before emitting an error.  */\n \t  if (sym->attr.generic && count_specific_procs (e) != 1)\n-\t    return FAILURE;\n-\t  \n+\t    goto cleanup;\n+\n \t  /* Just in case a specific was found for the expression.  */\n \t  sym = e->symtree->n.sym;\n \n@@ -1722,15 +1734,15 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t\t  gfc_error (\"Unable to find a specific INTRINSIC procedure \"\n \t\t\t     \"for the reference '%s' at %L\", sym->name,\n \t\t\t     &e->where);\n-\t\t  return FAILURE;\n+\t\t  goto cleanup;\n \t\t}\n \t      sym->ts = isym->ts;\n \t      sym->attr.intrinsic = 1;\n \t      sym->attr.function = 1;\n \t    }\n \n \t  if (gfc_resolve_expr (e) == FAILURE)\n-\t    return FAILURE;\n+\t    goto cleanup;\n \t  goto argument_list;\n \t}\n \n@@ -1742,7 +1754,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n       if (gfc_find_sym_tree (sym->name, sym->ns->parent, 1, &parent_st))\n \t{\n \t  gfc_error (\"Symbol '%s' at %L is ambiguous\", sym->name, &e->where);\n-\t  return FAILURE;\n+\t  goto cleanup;\n \t}\n \n       if (parent_st == NULL)\n@@ -1756,7 +1768,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t  || sym->attr.external)\n \t{\n \t  if (gfc_resolve_expr (e) == FAILURE)\n-\t    return FAILURE;\n+\t    goto cleanup;\n \t  goto argument_list;\n \t}\n \n@@ -1784,7 +1796,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n       if (e->expr_type != EXPR_VARIABLE)\n \tneed_full_assumed_size = 0;\n       if (gfc_resolve_expr (e) != SUCCESS)\n-\treturn FAILURE;\n+\tgoto cleanup;\n       need_full_assumed_size = save_need_full_assumed_size;\n \n     argument_list:\n@@ -1798,14 +1810,14 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t\t{\n \t\t  gfc_error (\"By-value argument at %L is not of numeric \"\n \t\t\t     \"type\", &e->where);\n-\t\t  return FAILURE;\n+\t\t  goto cleanup;\n \t\t}\n \n \t      if (e->rank)\n \t\t{\n \t\t  gfc_error (\"By-value argument at %L cannot be an array or \"\n \t\t\t     \"an array section\", &e->where);\n-\t\treturn FAILURE;\n+\t\t  goto cleanup;\n \t\t}\n \n \t      /* Intrinsics are still PROC_UNKNOWN here.  However,\n@@ -1819,7 +1831,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t\t{\n \t\t  gfc_error (\"By-value argument at %L is not allowed \"\n \t\t\t     \"in this context\", &e->where);\n-\t\t  return FAILURE;\n+\t\t  goto cleanup;\n \t\t}\n \t    }\n \n@@ -1831,23 +1843,30 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t\t{\n \t\t  gfc_error (\"Passing internal procedure at %L by location \"\n \t\t\t     \"not allowed\", &e->where);\n-\t\t  return FAILURE;\n+\t\t  goto cleanup;\n \t\t}\n \t    }\n \t}\n \n       /* Fortran 2008, C1237.  */\n       if (e->expr_type == EXPR_VARIABLE && gfc_is_coindexed (e)\n-          && gfc_has_ultimate_pointer (e))\n-        {\n-          gfc_error (\"Coindexed actual argument at %L with ultimate pointer \"\n+\t  && gfc_has_ultimate_pointer (e))\n+\t{\n+\t  gfc_error (\"Coindexed actual argument at %L with ultimate pointer \"\n \t\t     \"component\", &e->where);\n-          return FAILURE;\n-        }\n+\t  goto cleanup;\n+\t}\n+\n+      first_actual_arg = false;\n     }\n-  assumed_type_expr_allowed = false;\n \n-  return SUCCESS;\n+  return_value = SUCCESS;\n+\n+cleanup:\n+  actual_arg = actual_arg_sav;\n+  first_actual_arg = first_actual_arg_sav;\n+\n+  return return_value;\n }\n \n \n@@ -1907,7 +1926,7 @@ resolve_elemental_actual (gfc_expr *expr, gfc_code *c)\n   /* The rank of an elemental is the rank of its array argument(s).  */\n   for (arg = arg0; arg; arg = arg->next)\n     {\n-      if (arg->expr != NULL && arg->expr->rank > 0)\n+      if (arg->expr != NULL && arg->expr->rank != 0)\n \t{\n \t  rank = arg->expr->rank;\n \t  if (arg->expr->expr_type == EXPR_VARIABLE\n@@ -2206,6 +2225,15 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,\n \t\t\t   sym->name, &sym->declared_at, arg->sym->name);\n \t\tbreak;\n \t      }\n+\t    /* TS 29113, 6.2.  */\n+\t    else if (arg->sym && arg->sym->as\n+\t\t     && arg->sym->as->type == AS_ASSUMED_RANK)\n+\t      {\n+\t\tgfc_error (\"Procedure '%s' at %L with assumed-rank dummy \"\n+\t\t\t   \"argument '%s' must have an explicit interface\",\n+\t\t\t   sym->name, &sym->declared_at, arg->sym->name);\n+\t\tbreak;\n+\t      }\n \t    /* F2008, 12.4.2.2 (2c)  */\n \t    else if (arg->sym->attr.codimension)\n \t      {\n@@ -2231,6 +2259,15 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,\n \t\t\t   sym->name, &sym->declared_at, arg->sym->name);\n \t\tbreak;\n \t      }\n+\t    /* As assumed-type is unlimited polymorphic (cf. above).\n+\t       See also  TS 29113, Note 6.1.  */\n+\t    else if (arg->sym->ts.type == BT_ASSUMED)\n+\t      {\n+\t\tgfc_error (\"Procedure '%s' at %L with assumed-type dummy \"\n+\t\t\t   \"argument '%s' must have an explicit interface\",\n+\t\t\t   sym->name, &sym->declared_at, arg->sym->name);\n+\t\tbreak;\n+\t      }\n \t}\n \n       if (def_sym->attr.function)\n@@ -4976,7 +5013,7 @@ expression_shape (gfc_expr *e)\n   mpz_t array[GFC_MAX_DIMENSIONS];\n   int i;\n \n-  if (e->rank == 0 || e->shape != NULL)\n+  if (e->rank <= 0 || e->shape != NULL)\n     return;\n \n   for (i = 0; i < e->rank; i++)\n@@ -5079,23 +5116,79 @@ resolve_variable (gfc_expr *e)\n   sym = e->symtree->n.sym;\n \n   /* TS 29113, 407b.  */\n-  if (e->ts.type == BT_ASSUMED && !assumed_type_expr_allowed)\n+  if (e->ts.type == BT_ASSUMED)\n     {\n-      gfc_error (\"Invalid expression with assumed-type variable %s at %L\",\n-\t\t sym->name, &e->where);\n-      return FAILURE;\n+      if (!actual_arg)\n+\t{\n+\t  gfc_error (\"Assumed-type variable %s at %L may only be used \"\n+\t\t     \"as actual argument\", sym->name, &e->where);\n+\t  return FAILURE;\n+\t}\n+      else if (inquiry_argument && !first_actual_arg)\n+\t{\n+\t  /* FIXME: It doesn't work reliably as inquiry_argument is not set\n+\t     for all inquiry functions in resolve_function; the reason is\n+\t     that the function-name resolution happens too late in that\n+\t     function.  */\n+\t  gfc_error (\"Assumed-type variable %s at %L as actual argument to \"\n+\t\t     \"an inquiry function shall be the first argument\",\n+\t\t     sym->name, &e->where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  /* TS 29113, C535b.  */\n+  if ((sym->ts.type == BT_CLASS && sym->attr.class_ok\n+\t&& CLASS_DATA (sym)->as\n+\t&& CLASS_DATA (sym)->as->type == AS_ASSUMED_RANK)\n+       || (sym->ts.type != BT_CLASS && sym->as\n+\t   && sym->as->type == AS_ASSUMED_RANK))\n+    {\n+      if (!actual_arg)\n+\t{\n+\t  gfc_error (\"Assumed-rank variable %s at %L may only be used as \"\n+\t\t     \"actual argument\", sym->name, &e->where);\n+\t  return FAILURE;\n+\t}\n+      else if (inquiry_argument && !first_actual_arg)\n+\t{\n+\t  /* FIXME: It doesn't work reliably as inquiry_argument is not set\n+\t     for all inquiry functions in resolve_function; the reason is\n+\t     that the function-name resolution happens too late in that\n+\t     function.  */\n+\t  gfc_error (\"Assumed-rank variable %s at %L as actual argument \"\n+\t\t     \"to an inquiry function shall be the first argument\",\n+\t\t     sym->name, &e->where);\n+\t  return FAILURE;\n+\t}\n     }\n \n   /* TS 29113, 407b.  */\n   if (e->ts.type == BT_ASSUMED && e->ref\n       && !(e->ref->type == REF_ARRAY && e->ref->u.ar.type == AR_FULL\n-           && e->ref->next == NULL))\n+\t   && e->ref->next == NULL))\n+    {\n+      gfc_error (\"Assumed-type variable %s at %L shall not have a subobject \"\n+\t\t \"reference\", sym->name, &e->ref->u.ar.where);\n+      return FAILURE;\n+    }\n+\n+  /* TS 29113, C535b.  */\n+  if (((sym->ts.type == BT_CLASS && sym->attr.class_ok\n+\t&& CLASS_DATA (sym)->as\n+\t&& CLASS_DATA (sym)->as->type == AS_ASSUMED_RANK)\n+       || (sym->ts.type != BT_CLASS && sym->as\n+\t   && sym->as->type == AS_ASSUMED_RANK))\n+      && e->ref\n+      && !(e->ref->type == REF_ARRAY && e->ref->u.ar.type == AR_FULL\n+\t   && e->ref->next == NULL))\n     {\n-      gfc_error (\"Assumed-type variable %s with designator at %L\",\n-                 sym->name, &e->ref->u.ar.where);\n+      gfc_error (\"Assumed-rank variable %s at %L shall not have a subobject \"\n+\t\t \"reference\", sym->name, &e->ref->u.ar.where);\n       return FAILURE;\n     }\n \n+\n   /* If this is an associate-name, it may be parsed with an array reference\n      in error even though the target is scalar.  Fail directly in this case.\n      TODO Understand why class scalar expressions must be excluded.  */\n@@ -5596,7 +5689,7 @@ update_ppc_arglist (gfc_expr* e)\n     return FAILURE;\n \n   /* F08:R739.  */\n-  if (po->rank > 0)\n+  if (po->rank != 0)\n     {\n       gfc_error (\"Passed-object at %L must be scalar\", &e->where);\n       return FAILURE;\n@@ -5644,7 +5737,7 @@ check_typebound_baseobject (gfc_expr* e)\n \n   /* F08:C1230. If the procedure called is NOPASS,\n      the base object must be scalar.  */\n-  if (e->value.compcall.tbp->nopass && base->rank > 0)\n+  if (e->value.compcall.tbp->nopass && base->rank != 0)\n     {\n       gfc_error (\"Base object for NOPASS type-bound procedure call at %L must\"\n \t\t \" be scalar\", &e->where);\n@@ -6306,15 +6399,22 @@ gfc_try\n gfc_resolve_expr (gfc_expr *e)\n {\n   gfc_try t;\n-  bool inquiry_save;\n+  bool inquiry_save, actual_arg_save, first_actual_arg_save;\n \n   if (e == NULL)\n     return SUCCESS;\n \n   /* inquiry_argument only applies to variables.  */\n   inquiry_save = inquiry_argument;\n+  actual_arg_save = actual_arg;\n+  first_actual_arg_save = first_actual_arg;\n+\n   if (e->expr_type != EXPR_VARIABLE)\n-    inquiry_argument = false;\n+    {\n+      inquiry_argument = false;\n+      actual_arg = false;\n+      first_actual_arg = false;\n+    }\n \n   switch (e->expr_type)\n     {\n@@ -6404,6 +6504,8 @@ gfc_resolve_expr (gfc_expr *e)\n     fixup_charlen (e);\n \n   inquiry_argument = inquiry_save;\n+  actual_arg = actual_arg_save;\n+  first_actual_arg = first_actual_arg_save;\n \n   return t;\n }\n@@ -10332,10 +10434,10 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \n       if (allocatable)\n \t{\n-\t  if (dimension)\n+\t  if (dimension && as->type != AS_ASSUMED_RANK)\n \t    {\n-\t      gfc_error (\"Allocatable array '%s' at %L must have \"\n-\t\t\t \"a deferred shape\", sym->name, &sym->declared_at);\n+\t      gfc_error (\"Allocatable array '%s' at %L must have a deferred \"\n+\t\t\t \"shape or assumed rank\", sym->name, &sym->declared_at);\n \t      return FAILURE;\n \t    }\n \t  else if (gfc_notify_std (GFC_STD_F2003, \"Scalar object \"\n@@ -10344,10 +10446,10 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n \t    return FAILURE;\n \t}\n \n-      if (pointer && dimension)\n+      if (pointer && dimension && as->type != AS_ASSUMED_RANK)\n \t{\n-\t  gfc_error (\"Array pointer '%s' at %L must have a deferred shape\",\n-\t\t     sym->name, &sym->declared_at);\n+\t  gfc_error (\"Array pointer '%s' at %L must have a deferred shape or \"\n+\t\t     \"assumed rank\", sym->name, &sym->declared_at);\n \t  return FAILURE;\n \t}\n     }\n@@ -10961,7 +11063,7 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n \t}\n \n       /* Warn if the procedure is non-scalar and not assumed shape.  */\n-      if (gfc_option.warn_surprising && arg->as && arg->as->rank > 0\n+      if (gfc_option.warn_surprising && arg->as && arg->as->rank != 0\n \t  && arg->as->type != AS_ASSUMED_SHAPE)\n \tgfc_warning (\"Non-scalar FINAL procedure at %L should have assumed\"\n \t\t     \" shape argument\", &arg->declared_at);\n@@ -11490,7 +11592,7 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t}\n   \n       gcc_assert (me_arg->ts.type == BT_CLASS);\n-      if (CLASS_DATA (me_arg)->as && CLASS_DATA (me_arg)->as->rank > 0)\n+      if (CLASS_DATA (me_arg)->as && CLASS_DATA (me_arg)->as->rank != 0)\n \t{\n \t  gfc_error (\"Passed-object dummy argument of '%s' at %L must be\"\n \t\t     \" scalar\", proc->name, &where);\n@@ -12504,6 +12606,20 @@ resolve_symbol (gfc_symbol *sym)\n \t\t       &sym->declared_at);\n \t  return;\n \t}\n+      /* TS 29113, C535a.  */\n+      if (as->type == AS_ASSUMED_RANK && !sym->attr.dummy)\n+\t{\n+\t  gfc_error (\"Assumed-rank array at %L must be a dummy argument\",\n+\t\t     &sym->declared_at);\n+\t  return;\n+\t}\n+      if (as->type == AS_ASSUMED_RANK\n+\t  && (sym->attr.codimension || sym->attr.value))\n+\t{\n+\t  gfc_error (\"Assumed-rank array at %L may not have the VALUE or \"\n+\t\t     \"CODIMENSION attribute\", &sym->declared_at);\n+\t  return;\n+\t}\n     }\n \n   /* Make sure symbols with known intent or optional are really dummy\n@@ -12576,6 +12692,13 @@ resolve_symbol (gfc_symbol *sym)\n \t\t     sym->name, &sym->declared_at);\n \t  return;\n \t}\n+      if (sym->attr.intent == INTENT_OUT)\n+    \t{\n+\t  gfc_error (\"Assumed-type variable %s at %L may not have the \"\n+\t\t     \"INTENT(OUT) attribute\",\n+\t\t     sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n       if (sym->attr.dimension && sym->as->type == AS_EXPLICIT)\n \t{\n \t  gfc_error (\"Assumed-type variable %s at %L shall not be an \""}, {"sha": "afc4bc4cc3e91bf5af27de781635c3876014a719", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -2935,7 +2935,6 @@ gfc_simplify_iparity (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n }\n \n \n-\n gfc_expr *\n gfc_simplify_is_iostat_end (gfc_expr *x)\n {\n@@ -3381,7 +3380,8 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \n  done:\n \n-  if (as && (as->type == AS_DEFERRED || as->type == AS_ASSUMED_SHAPE))\n+  if (as && (as->type == AS_DEFERRED || as->type == AS_ASSUMED_SHAPE\n+\t     || as->type == AS_ASSUMED_RANK))\n     return NULL;\n \n   if (dim == NULL)\n@@ -3443,13 +3443,16 @@ simplify_bound (gfc_expr *array, gfc_expr *dim, gfc_expr *kind, int upper)\n \n       d = mpz_get_si (dim->value.integer);\n \n-      if (d < 1 || d > array->rank\n+      if ((d < 1 || d > array->rank)\n \t  || (d == array->rank && as && as->type == AS_ASSUMED_SIZE && upper))\n \t{\n \t  gfc_error (\"DIM argument at %L is out of bounds\", &dim->where);\n \t  return &gfc_bad_expr;\n \t}\n \n+      if (as && as->type == AS_ASSUMED_RANK)\n+\treturn NULL;\n+\n       return simplify_bound_dim (array, kind, d, upper, as, ref, false);\n     }\n }\n@@ -4780,6 +4783,10 @@ gfc_simplify_range (gfc_expr *e)\n gfc_expr *\n gfc_simplify_rank (gfc_expr *e)\n {\n+  /* Assumed rank.  */\n+  if (e->rank == -1)\n+    return NULL;\n+\n   return gfc_get_int_expr (gfc_default_integer_kind, &e->where, e->rank);\n }\n "}, {"sha": "ba108dc7e75b54172e3099b0d4f843ba40d2471d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -81,7 +81,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n-#include \"gimple.h\"\n+#include \"gimple.h\"\t\t/* For create_tmp_var_name.  */\n #include \"diagnostic-core.h\"\t/* For internal_error/fatal_error.  */\n #include \"flags.h\"\n #include \"gfortran.h\"\n@@ -247,12 +247,11 @@ gfc_conv_descriptor_dtype (tree desc)\n \t\t\t  desc, field, NULL_TREE);\n }\n \n-static tree\n-gfc_conv_descriptor_dimension (tree desc, tree dim)\n+\n+tree\n+gfc_get_descriptor_dimension (tree desc)\n {\n-  tree field;\n-  tree type;\n-  tree tmp;\n+  tree type, field;\n \n   type = TREE_TYPE (desc);\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n@@ -262,10 +261,19 @@ gfc_conv_descriptor_dimension (tree desc, tree dim)\n \t  && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == RECORD_TYPE);\n \n-  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n-\t\t\t desc, field, NULL_TREE);\n-  tmp = gfc_build_array_ref (tmp, dim, NULL);\n-  return tmp;\n+  return fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t  desc, field, NULL_TREE);\n+}\n+\n+\n+static tree\n+gfc_conv_descriptor_dimension (tree desc, tree dim)\n+{\n+  tree tmp;\n+\n+  tmp = gfc_get_descriptor_dimension (desc);\n+\n+  return gfc_build_array_ref (tmp, dim, NULL);\n }\n \n \n@@ -311,6 +319,7 @@ gfc_conv_descriptor_stride_get (tree desc, tree dim)\n   if (integer_zerop (dim)\n       && (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE\n \t  ||GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE_CONT\n+\t  ||GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_RANK_CONT\n \t  ||GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER_CONT))\n     return gfc_index_one_node;\n \n@@ -6900,9 +6909,10 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \t}\n \n       if (!sym->attr.pointer\n-\t    && sym->as\n-\t    && sym->as->type != AS_ASSUMED_SHAPE \n-            && !sym->attr.allocatable)\n+\t  && sym->as\n+\t  && sym->as->type != AS_ASSUMED_SHAPE \n+\t  && sym->as->type != AS_ASSUMED_RANK \n+\t  && !sym->attr.allocatable)\n         {\n \t  /* Some variables are declared directly, others are declared as\n \t     pointers and allocated on the heap.  */\n@@ -6938,10 +6948,12 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n   no_pack = ((sym && sym->as\n \t\t  && !sym->attr.pointer\n \t\t  && sym->as->type != AS_DEFERRED\n+\t\t  && sym->as->type != AS_ASSUMED_RANK\n \t\t  && sym->as->type != AS_ASSUMED_SHAPE)\n \t\t      ||\n \t     (ref && ref->u.ar.as\n \t\t  && ref->u.ar.as->type != AS_DEFERRED\n+\t\t  && ref->u.ar.as->type != AS_ASSUMED_RANK\n \t\t  && ref->u.ar.as->type != AS_ASSUMED_SHAPE)\n \t\t      ||\n \t     gfc_is_simply_contiguous (expr, false));"}, {"sha": "b7ab806fd18f021c5d6561efca495ac8b2f0a158", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -154,6 +154,7 @@ tree gfc_conv_descriptor_data_get (tree);\n tree gfc_conv_descriptor_data_addr (tree);\n tree gfc_conv_descriptor_offset_get (tree);\n tree gfc_conv_descriptor_dtype (tree);\n+tree gfc_get_descriptor_dimension (tree);\n tree gfc_conv_descriptor_stride_get (tree, tree);\n tree gfc_conv_descriptor_lbound_get (tree, tree);\n tree gfc_conv_descriptor_ubound_get (tree, tree);"}, {"sha": "f1b7444cb14753bbb70f54d81723cf93505ea386", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -933,7 +933,8 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n   int n;\n   bool known_size;\n \n-  if (sym->attr.pointer || sym->attr.allocatable)\n+  if (sym->attr.pointer || sym->attr.allocatable\n+      || (sym->as && sym->as->type == AS_ASSUMED_RANK))\n     return dummy;\n \n   /* Add to list of variables if not a fake result variable.  */\n@@ -3669,6 +3670,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t      gfc_trans_dummy_array_bias (sym, sym->backend_decl, block);\n \t      break;\n \n+\t    case AS_ASSUMED_RANK:\n \t    case AS_DEFERRED:\n \t      seen_trans_deferred_array = true;\n \t      gfc_trans_deferred_array (sym, block);\n@@ -4782,7 +4784,8 @@ add_argument_checking (stmtblock_t *block, gfc_symbol *sym)\n \t   dummy argument is an array. (See \"Sequence association\" in\n \t   Section 12.4.1.4 for F95 and 12.4.1.5 for F2003.)  */\n \tif (fsym->attr.pointer || fsym->attr.allocatable\n-\t    || (fsym->as && fsym->as->type == AS_ASSUMED_SHAPE))\n+\t    || (fsym->as && (fsym->as->type == AS_ASSUMED_SHAPE\n+\t\t\t     || fsym->as->type == AS_ASSUMED_RANK)))\n \t  {\n \t    comparison = NE_EXPR;\n \t    message = _(\"Actual string length does not match the declared one\""}, {"sha": "f5ed4e3cf3dd3fa8ca37d394b9ceaa8e5f2da4ca", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 158, "deletions": 15, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -42,6 +42,48 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dependency.h\"\n \n \n+/* Convert a scalar to an array descriptor. To be used for assumed-rank\n+   arrays.  */\n+\n+static tree\n+get_scalar_to_descriptor_type (tree scalar, symbol_attribute attr)\n+{\n+  enum gfc_array_kind akind;\n+\n+  if (attr.pointer)\n+    akind = GFC_ARRAY_POINTER_CONT;\n+  else if (attr.allocatable)\n+    akind = GFC_ARRAY_ALLOCATABLE;\n+  else\n+    akind = GFC_ARRAY_ASSUMED_SHAPE_CONT;\n+\n+  return gfc_get_array_type_bounds (TREE_TYPE (scalar), 0, 0, NULL, NULL, 1,\n+\t\t\t\t    akind, !(attr.pointer || attr.target));\n+}\n+\n+static tree\n+conv_scalar_to_descriptor (gfc_se *se, tree scalar, symbol_attribute attr)\n+{\n+  tree desc, type;  \n+\n+  type = get_scalar_to_descriptor_type (scalar, attr);\n+  desc = gfc_create_var (type, \"desc\");\n+  DECL_ARTIFICIAL (desc) = 1;\n+  gfc_add_modify (&se->pre, gfc_conv_descriptor_dtype (desc),\n+\t\t  gfc_get_dtype (type));\n+  gfc_conv_descriptor_data_set (&se->pre, desc, scalar);\n+\n+  /* Copy pointer address back - but only if it could have changed and\n+     if the actual argument is a pointer and not, e.g., NULL().  */\n+  if ((attr.pointer || attr.allocatable)\n+       && attr.intent != INTENT_IN && POINTER_TYPE_P (TREE_TYPE (scalar)))\n+    gfc_add_modify (&se->post, scalar,\n+\t\t    fold_convert (TREE_TYPE (scalar),\n+\t\t\t\t  gfc_conv_descriptor_data_get (desc)));\n+  return desc;\n+}\n+\n+\n /* This is the seed for an eventual trans-class.c\n \n    The following parameters should not be used directly since they might\n@@ -158,7 +200,34 @@ gfc_get_vptr_from_expr (tree expr)\n   tmp = gfc_class_vptr_get (tmp);\n   return tmp;\n }\n- \n+\n+\n+static void\n+class_array_data_assign (stmtblock_t *block, tree lhs_desc, tree rhs_desc,\n+\t\t\t bool lhs_type)\n+{\n+  tree tmp, tmp2, type;\n+\n+  gfc_conv_descriptor_data_set (block, lhs_desc,\n+\t\t\t\tgfc_conv_descriptor_data_get (rhs_desc));\n+  gfc_conv_descriptor_offset_set (block, lhs_desc,\n+\t\t\t\t  gfc_conv_descriptor_offset_get (rhs_desc));\n+\n+  gfc_add_modify (block, gfc_conv_descriptor_dtype (lhs_desc),\n+\t\t  gfc_conv_descriptor_dtype (rhs_desc));\n+\n+  /* Assign the dimension as range-ref.  */\n+  tmp = gfc_get_descriptor_dimension (lhs_desc);\n+  tmp2 = gfc_get_descriptor_dimension (rhs_desc);\n+\n+  type = lhs_type ? TREE_TYPE (tmp) : TREE_TYPE (tmp2);\n+  tmp = build4_loc (input_location, ARRAY_RANGE_REF, type, tmp,\n+\t\t    gfc_index_zero_node, NULL_TREE, NULL_TREE);\n+  tmp2 = build4_loc (input_location, ARRAY_RANGE_REF, type, tmp2,\n+\t\t     gfc_index_zero_node, NULL_TREE, NULL_TREE);\n+  gfc_add_modify (block, tmp, tmp2);\n+}\n+\n \n /* Takes a derived type expression and returns the address of a temporary\n    class object of the 'declared' type.  If vptr is not NULL, this is\n@@ -215,14 +284,33 @@ gfc_conv_derived_to_class (gfc_se *parmse, gfc_expr *e,\n \t{\n \t  parmse->ss = NULL;\n \t  gfc_conv_expr_reference (parmse, e);\n-\t  tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n-\t  gfc_add_modify (&parmse->pre, ctree, tmp);\n+\n+\t  /* Scalar to an assumed-rank array.  */\n+\t  if (class_ts.u.derived->components->as)\n+\t    {\n+\t      tree type;\n+\t      type = get_scalar_to_descriptor_type (parmse->expr,\n+\t\t\t\t\t\t    gfc_expr_attr (e));\n+\t      gfc_add_modify (&parmse->pre, gfc_conv_descriptor_dtype (ctree),\n+\t\t\t      gfc_get_dtype (type));\n+\t      gfc_conv_descriptor_data_set (&parmse->pre, ctree, parmse->expr);\n+\t    }\n+          else\n+\t    {\n+\t      tmp = fold_convert (TREE_TYPE (ctree), parmse->expr);\n+\t      gfc_add_modify (&parmse->pre, ctree, tmp);\n+\t    }\n \t}\n       else\n \t{\n \t  parmse->ss = ss;\n \t  gfc_conv_expr_descriptor (parmse, e, ss);\n-\t  gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n+\n+\t  if (e->rank != class_ts.u.derived->components->as->rank)\n+\t    class_array_data_assign (&parmse->pre, ctree, parmse->expr,\n+\t\t\t\t     TREE_TYPE (parmse->expr));\n+\t  else\n+\t    gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n \t}\n     }\n \n@@ -260,7 +348,9 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n \tbreak;\n     }\n \n-  if (ref == NULL || class_ref == ref)\n+  if ((ref == NULL || class_ref == ref)\n+      && (!class_ts.u.derived->components->as\n+\t  || class_ts.u.derived->components->as->rank != -1))\n     return;\n \n   /* Test for FULL_ARRAY.  */\n@@ -273,13 +363,42 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e,\n \n   /* Set the data.  */\n   ctree = gfc_class_data_get (var);\n-  gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n+  if (class_ts.u.derived->components->as\n+      && e->rank != class_ts.u.derived->components->as->rank)\n+    {\n+      if (e->rank == 0)\n+\t{\n+\t  tree type = get_scalar_to_descriptor_type (parmse->expr,\n+\t\t\t\t\t\t     gfc_expr_attr (e));\n+\t  gfc_add_modify (&parmse->pre, gfc_conv_descriptor_dtype (ctree),\n+\t\t\t  gfc_get_dtype (type));\n+\t  gfc_conv_descriptor_data_set (&parmse->pre, ctree,\n+\t\t\t\t\tgfc_class_data_get (parmse->expr));\n+\n+\t}\n+      else\n+\tclass_array_data_assign (&parmse->pre, ctree, parmse->expr, false);\n+    }\n+  else\n+    gfc_add_modify (&parmse->pre, ctree, parmse->expr);\n \n   /* Return the data component, except in the case of scalarized array\n      references, where nullification of the cannot occur and so there\n      is no need.  */\n   if (!elemental && full_array)\n-    gfc_add_modify (&parmse->post, parmse->expr, ctree);\n+    {\n+      if (class_ts.u.derived->components->as\n+\t  && e->rank != class_ts.u.derived->components->as->rank)\n+\t{\n+\t  if (e->rank == 0)\n+\t    gfc_add_modify (&parmse->post, gfc_class_data_get (parmse->expr),\n+\t\t\t    gfc_conv_descriptor_data_get (ctree));\n+\t  else\n+\t    class_array_data_assign (&parmse->post, parmse->expr, ctree, true);\n+\t}\n+      else\n+\tgfc_add_modify (&parmse->post, parmse->expr, ctree);\n+    }\n \n   /* Set the vptr.  */\n   ctree = gfc_class_vptr_get (var);\n@@ -730,7 +849,8 @@ gfc_conv_expr_present (gfc_symbol * sym)\n      as actual argument to denote absent dummies. For array descriptors,\n      we thus also need to check the array descriptor.  */\n   if (!sym->attr.pointer && !sym->attr.allocatable\n-      && sym->as && sym->as->type == AS_ASSUMED_SHAPE\n+      && sym->as && (sym->as->type == AS_ASSUMED_SHAPE\n+\t\t     || sym->as->type == AS_ASSUMED_RANK)\n       && (gfc_option.allow_std & GFC_STD_F2008) != 0)\n     {\n       tree tmp;\n@@ -1325,7 +1445,8 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t  /* Dereference non-character pointer variables. \n \t     These must be dummies, results, or scalars.  */\n \t  if ((sym->attr.pointer || sym->attr.allocatable\n-\t       || gfc_is_associate_pointer (sym))\n+\t       || gfc_is_associate_pointer (sym)\n+\t       || (sym->as && sym->as->type == AS_ASSUMED_RANK))\n \t      && (sym->attr.dummy\n \t\t  || sym->attr.function\n \t\t  || sym->attr.result\n@@ -3769,7 +3890,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t     class object, if the formal argument is a class object.  */\n \t\t  if (fsym && fsym->ts.type == BT_CLASS\n \t\t\t&& e->ts.type == BT_CLASS\n-\t\t\t&& CLASS_DATA (e)->attr.dimension)\n+\t\t\t&& ((CLASS_DATA (fsym)->as\n+\t\t\t     && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)\n+\t\t\t    || CLASS_DATA (e)->attr.dimension))\n \t\t    gfc_conv_class_to_class (&parmse, e, fsym->ts, false);\n \n \t\t  if (fsym && (fsym->ts.type == BT_DERIVED\n@@ -3813,7 +3936,23 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t      gfc_add_expr_to_block (&se->pre, tmp);\n \t\t    }\n \n-\t\t  if (fsym && e->expr_type != EXPR_NULL\n+\t\t  /* Wrap scalar variable in a descriptor. We need to convert\n+\t\t     the address of a pointer back to the pointer itself before,\n+\t\t     we can assign it to the data field.  */\n+\n+\t\t  if (fsym && fsym->as && fsym->as->type == AS_ASSUMED_RANK\n+\t\t      && fsym->ts.type != BT_CLASS && e->expr_type != EXPR_NULL)\n+\t\t    {\n+\t\t      tmp = parmse.expr;\n+\t\t      if (TREE_CODE (tmp) == ADDR_EXPR\n+\t\t\t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (tmp, 0))))\n+\t\t\ttmp = TREE_OPERAND (tmp, 0);\n+\t\t      parmse.expr = conv_scalar_to_descriptor (&parmse, tmp,\n+\t\t\t\t\t\t\t       fsym->attr);\n+\t\t      parmse.expr = gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\t\t\t parmse.expr);\n+\t\t    }\n+\t\t  else if (fsym && e->expr_type != EXPR_NULL\n \t\t      && ((fsym->attr.pointer\n \t\t\t   && fsym->attr.flavor != FL_PROCEDURE)\n \t\t\t  || (fsym->attr.proc_pointer\n@@ -3855,7 +3994,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      bool f;\n \t      f = (fsym != NULL)\n \t\t  && !(fsym->attr.pointer || fsym->attr.allocatable)\n-\t\t  && fsym->as && fsym->as->type != AS_ASSUMED_SHAPE;\n+\t\t  && fsym->as && fsym->as->type != AS_ASSUMED_SHAPE\n+\t\t  && fsym->as->type != AS_ASSUMED_RANK;\n \t      if (comp)\n \t\tf = f || !comp->attr.always_explicit;\n \t      else\n@@ -3964,12 +4104,13 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t     but do not always set fsym.  */\n \t  if (e->expr_type == EXPR_VARIABLE\n \t      && e->symtree->n.sym->attr.optional\n-\t      && ((e->rank > 0 && sym->attr.elemental)\n+\t      && ((e->rank != 0 && sym->attr.elemental)\n \t\t  || e->representation.length || e->ts.type == BT_CHARACTER\n-\t\t  || (e->rank > 0\n+\t\t  || (e->rank != 0\n \t\t      && (fsym == NULL \n \t\t\t  || (fsym-> as\n \t\t\t      && (fsym->as->type == AS_ASSUMED_SHAPE\n+\t\t\t\t  || fsym->as->type == AS_ASSUMED_RANK\n \t\t\t      \t  || fsym->as->type == AS_DEFERRED))))))\n \t    gfc_conv_missing_dummy (&parmse, e, fsym ? fsym->ts : e->ts,\n \t\t\t\t    e->representation.length);\n@@ -4215,7 +4356,9 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      tmp = caf_decl;\n \t    }\n \n-          if (fsym->as->type == AS_ASSUMED_SHAPE)\n+          if (fsym->as->type == AS_ASSUMED_SHAPE\n+\t      || (fsym->as->type == AS_ASSUMED_RANK && !fsym->attr.pointer\n+\t\t  && !fsym->attr.allocatable))\n \t    {\n \t      gcc_assert (POINTER_TYPE_P (TREE_TYPE (parmse.expr)));\n \t      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE"}, {"sha": "be9421944e080033fd38948fc4c54804c76ed6c3", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -1315,29 +1315,37 @@ trans_num_images (gfc_se * se)\n }\n \n \n+static tree\n+get_rank_from_desc (tree desc)\n+{\n+  tree tmp;\n+  tree dtype;\n+\n+  dtype = gfc_conv_descriptor_dtype (desc);\n+  tmp = build_int_cst (TREE_TYPE (dtype), GFC_DTYPE_RANK_MASK);\n+  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, TREE_TYPE (dtype),\n+\t\t\t dtype, tmp);\n+  return fold_convert (gfc_get_int_type (gfc_default_integer_kind), tmp);\n+}\n+\n+\n static void\n gfc_conv_intrinsic_rank (gfc_se *se, gfc_expr *expr)\n {\n   gfc_se argse;\n   gfc_ss *ss;\n-  tree dtype, tmp;\n \n   ss = gfc_walk_expr (expr->value.function.actual->expr);\n   gcc_assert (ss != gfc_ss_terminator);\n   gfc_init_se (&argse, NULL);\n   argse.data_not_needed = 1;\n-  argse.want_pointer = 1;\n+  argse.descriptor_only = 1;\n \n   gfc_conv_expr_descriptor (&argse, expr->value.function.actual->expr, ss);\n   gfc_add_block_to_block (&se->pre, &argse.pre);\n   gfc_add_block_to_block (&se->post, &argse.post);\n-  argse.expr = build_fold_indirect_ref_loc (input_location, argse.expr);\n-  argse.expr = build_fold_indirect_ref_loc (input_location, argse.expr);\n-  dtype = gfc_conv_descriptor_dtype (argse.expr);\n-  tmp = build_int_cst (TREE_TYPE (dtype), GFC_DTYPE_RANK_MASK);\n-  tmp = fold_build2_loc (input_location, BIT_AND_EXPR, TREE_TYPE (dtype),\n-\t\t\t dtype, tmp);\n-  se->expr = fold_convert (gfc_get_int_type (gfc_default_integer_kind), tmp);\n+\n+  se->expr = get_rank_from_desc (argse.expr);\n }\n \n \n@@ -5855,8 +5863,15 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n \t     present.  */\n \t  arg1se.descriptor_only = 1;\n \t  gfc_conv_expr_lhs (&arg1se, arg1->expr);\n-\t  tmp = gfc_conv_descriptor_stride_get (arg1se.expr,\n-\t\t\t\t\t    gfc_rank_cst[arg1->expr->rank - 1]);\n+\t  if (arg1->expr->rank == -1)\n+\t    {\n+\t      tmp = get_rank_from_desc (arg1se.expr);\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     TREE_TYPE (tmp), tmp, gfc_index_one_node);\n+\t    }\n+\t  else\n+\t    tmp = gfc_rank_cst[arg1->expr->rank - 1];\n+\t  tmp = gfc_conv_descriptor_stride_get (arg1se.expr, tmp);\n \t  nonzero_arraylen = fold_build2_loc (input_location, NE_EXPR,\n \t\t\t\t\t      boolean_type_node, tmp,\n \t\t\t\t\t      build_int_cst (TREE_TYPE (tmp), 0));"}, {"sha": "d96f5e6e53057317bd6ae1ebe039557fa93221b1", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -80,8 +80,8 @@ bool gfc_real16_is_float128 = false;\n \n static GTY(()) tree gfc_desc_dim_type;\n static GTY(()) tree gfc_max_array_element_size;\n-static GTY(()) tree gfc_array_descriptor_base[2 * GFC_MAX_DIMENSIONS];\n-static GTY(()) tree gfc_array_descriptor_base_caf[2 * GFC_MAX_DIMENSIONS];\n+static GTY(()) tree gfc_array_descriptor_base[2 * (GFC_MAX_DIMENSIONS+1)];\n+static GTY(()) tree gfc_array_descriptor_base_caf[2 * (GFC_MAX_DIMENSIONS+1)];\n \n /* Arrays for all integral and real kinds.  We'll fill this in at runtime\n    after the target has a chance to process command-line options.  */\n@@ -1277,7 +1277,8 @@ gfc_is_nodesc_array (gfc_symbol * sym)\n     return 0;\n \n   if (sym->attr.dummy)\n-    return sym->as->type != AS_ASSUMED_SHAPE;\n+    return sym->as->type != AS_ASSUMED_SHAPE\n+\t   && sym->as->type != AS_ASSUMED_RANK;\n \n   if (sym->attr.result || sym->attr.function)\n     return 0;\n@@ -1299,6 +1300,13 @@ gfc_build_array_type (tree type, gfc_array_spec * as,\n   tree ubound[GFC_MAX_DIMENSIONS];\n   int n;\n \n+  if (as->type == AS_ASSUMED_RANK)\n+    for (n = 0; n < GFC_MAX_DIMENSIONS; n++)\n+      {\n+\tlbound[n] = NULL_TREE;\n+\tubound[n] = NULL_TREE;\n+      }\n+\n   for (n = 0; n < as->rank; n++)\n     {\n       /* Create expressions for the known bounds of the array.  */\n@@ -1323,7 +1331,12 @@ gfc_build_array_type (tree type, gfc_array_spec * as,\n   if (as->type == AS_ASSUMED_SHAPE)\n     akind = contiguous ? GFC_ARRAY_ASSUMED_SHAPE_CONT\n \t\t       : GFC_ARRAY_ASSUMED_SHAPE;\n-  return gfc_get_array_type_bounds (type, as->rank, as->corank, lbound,\n+  else if (as->type == AS_ASSUMED_RANK)\n+    akind = contiguous ? GFC_ARRAY_ASSUMED_RANK_CONT\n+\t\t       : GFC_ARRAY_ASSUMED_RANK;\n+  return gfc_get_array_type_bounds (type, as->rank == -1\n+\t\t\t\t\t  ? GFC_MAX_DIMENSIONS : as->rank,\n+\t\t\t\t    as->corank, lbound,\n \t\t\t\t    ubound, 0, akind, restricted);\n }\n \f\n@@ -1682,9 +1695,15 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n {\n   tree fat_type, decl, arraytype, *chain = NULL;\n   char name[16 + 2*GFC_RANK_DIGITS + 1 + 1];\n-  int idx = 2 * (codimen + dimen - 1) + restricted;\n+  int idx;\n+\n+  /* Assumed-rank array.  */\n+  if (dimen == -1)\n+    dimen = GFC_MAX_DIMENSIONS;\n+\n+  idx = 2 * (codimen + dimen) + restricted;\n \n-  gcc_assert (codimen + dimen >= 1 && codimen + dimen <= GFC_MAX_DIMENSIONS);\n+  gcc_assert (codimen + dimen >= 0 && codimen + dimen <= GFC_MAX_DIMENSIONS);\n \n   if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen)\n     {\n@@ -1721,16 +1740,18 @@ gfc_get_array_descriptor_base (int dimen, int codimen, bool restricted,\n   TREE_NO_WARNING (decl) = 1;\n \n   /* Build the array type for the stride and bound components.  */\n-  arraytype =\n-    build_array_type (gfc_get_desc_dim_type (),\n-\t\t      build_range_type (gfc_array_index_type,\n-\t\t\t\t\tgfc_index_zero_node,\n-\t\t\t\t\tgfc_rank_cst[codimen + dimen - 1]));\n+  if (dimen + codimen > 0)\n+    {\n+      arraytype =\n+\tbuild_array_type (gfc_get_desc_dim_type (),\n+\t\t\t  build_range_type (gfc_array_index_type,\n+\t\t\t\t\t    gfc_index_zero_node,\n+\t\t\t\t\t    gfc_rank_cst[codimen + dimen - 1]));\n \n-  decl = gfc_add_field_to_struct_1 (fat_type,\n-\t\t\t\t    get_identifier (\"dim\"),\n-\t\t\t\t    arraytype, &chain);\n-  TREE_NO_WARNING (decl) = 1;\n+      decl = gfc_add_field_to_struct_1 (fat_type, get_identifier (\"dim\"),\n+\t\t\t\t\tarraytype, &chain);\n+      TREE_NO_WARNING (decl) = 1;\n+    }\n \n   if (gfc_option.coarray == GFC_FCOARRAY_LIB && codimen\n       && akind == GFC_ARRAY_ALLOCATABLE)"}, {"sha": "d4092f7ff0be9adc4e6d844a25c11e7aef80dfcd", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -765,6 +765,8 @@ enum gfc_array_kind\n   GFC_ARRAY_UNKNOWN,\n   GFC_ARRAY_ASSUMED_SHAPE,\n   GFC_ARRAY_ASSUMED_SHAPE_CONT,\n+  GFC_ARRAY_ASSUMED_RANK,\n+  GFC_ARRAY_ASSUMED_RANK_CONT,\n   GFC_ARRAY_ALLOCATABLE,\n   GFC_ARRAY_POINTER,\n   GFC_ARRAY_POINTER_CONT"}, {"sha": "25891a8cf2740172ca3248ede39bca9f1ae1b820", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -1,3 +1,20 @@\n+2012-07-20  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/48820\n+\t* gfortran.dg/assumed_type_3.f90: Update dg-error.\n+\t* gfortran.dg/assumed_rank_1.f90: New.\n+\t* gfortran.dg/assumed_rank_1_c.c: New.\n+\t* gfortran.dg/assumed_rank_2.f90: New.\n+\t* gfortran.dg/assumed_rank_4.f90: New.\n+\t* gfortran.dg/assumed_rank_5.f90: New.\n+\t* gfortran.dg/assumed_rank_6.f90: New.\n+\t* gfortran.dg/assumed_rank_7.f90: New.\n+\t* gfortran.dg/assumed_rank_8.f90: New.\n+\t* gfortran.dg/assumed_rank_8_c.c: New.\n+\t* gfortran.dg/assumed_rank_9.f90: New.\n+\t* gfortran.dg/assumed_rank_10.f90: New.\n+\t* gfortran.dg/assumed_rank_12.f90: New.\n+\n 2012-07-19  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/opt25.adb: New test."}, {"sha": "d68f1f91565f3b2f4765635713010217df2967d0", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_1.f90", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_1.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,147 @@\n+! { dg-do run }\n+! { dg-additional-sources assumed_rank_1_c.c }\n+!\n+! PR fortran/48820\n+!\n+! Assumed-rank tests\n+!\n+! FIXME: The ubound/lbound checks have to be re-enabled when\n+! after they are supported\n+\n+implicit none\n+\n+interface\n+  subroutine check_value(b, n, val)\n+    integer :: b(..)\n+    integer, value :: n\n+    integer :: val(n)\n+  end subroutine\n+end interface\n+\n+integer, target :: x(2:5,4:7), y(-4:4)\n+integer, allocatable, target :: z(:,:,:,:)\n+integer, allocatable :: val(:)\n+integer :: i\n+\n+allocate(z(1:4, -2:5, 4, 10:11))\n+\n+if (rank(x) /= 2) call abort ()\n+val = [(2*i+3, i = 1, size(x))]\n+x = reshape (val, shape(x))\n+call foo(x, rank(x), lbound(x), ubound(x), val)\n+call foo2(x, rank(x), lbound(x), ubound(x), val)\n+call bar(x,x,.true.)\n+call bar(x,prsnt=.false.)\n+\n+if (rank(y) /= 1) call abort ()\n+val = [(2*i+7, i = 1, size(y))]\n+y = reshape (val, shape(y))\n+call foo(y, rank(y), lbound(y), ubound(y), val)\n+call foo2(y, rank(y), lbound(y), ubound(y), val)\n+call bar(y,y,.true.)\n+call bar(y,prsnt=.false.)\n+\n+if (rank(z) /= 4) call abort ()\n+val = [(2*i+5, i = 1, size(z))]\n+z(:,:,:,:) = reshape (val, shape(z))\n+call foo(z, rank(z), lbound(z), ubound(z), val)\n+call foo(z, rank(z), lbound(z), ubound(z), val)\n+call foo2(z, rank(z), lbound(z), ubound(z), val)\n+call bar(z,z,.true.)\n+call bar(z,prsnt=.false.)\n+\n+contains\n+  subroutine bar(a,b, prsnt)\n+    integer, pointer, optional, intent(in) :: a(..),b(..)\n+    logical, value :: prsnt\n+    ! The following is not valid, but it goes past the constraint check\n+    ! Technically, it could be allowed and might be in Fortran 2015:\n+    if (.not. associated(a)) call abort()\n+    if (present(b)) then\n+      if (.not. associated(a,b)) call abort()\n+    else\n+      if (.not. associated(a)) call abort()\n+    end if\n+    if (.not. present(a)) call abort()\n+    if (prsnt .neqv. present(b)) call abort()\n+  end subroutine\n+\n+  ! POINTER argument - bounds as specified before\n+  subroutine foo(a, rnk, low, high, val)\n+    integer,pointer, intent(in) :: a(..)\n+    integer, value :: rnk\n+    integer, intent(in) :: low(:), high(:), val(:)\n+    integer :: i\n+\n+\n+\n+    if (rank(a) /= rnk) call abort()\n+    if (size(low) /= rnk .or. size(high) /= rnk) call abort()\n+    if (size(a) /= product (high - low +1)) call abort()\n+\n+    if (rnk > 0) then\n+      if (low(1) /= lbound(a,1)) call abort()\n+      if (high(1) /= ubound(a,1)) call abort()\n+      if (size (a,1) /= high(1)-low(1)+1) call abort()\n+    end if\n+\n+    do i = 1, rnk\n+      if (low(i) /= lbound(a,i)) call abort()\n+      if (high(i) /= ubound(a,i)) call abort()\n+      if (size (a,i) /= high(i)-low(i)+1) call abort()\n+    end do\n+    call check_value (a, rnk, val)\n+    call foo2(a, rnk, low, high, val)\n+  end subroutine\n+\n+  ! Non-pointer, non-allocatable bounds. lbound == 1\n+  subroutine foo2(a, rnk, low, high, val)\n+    integer, intent(in) :: a(..)\n+    integer, value :: rnk\n+    integer, intent(in) :: low(:), high(:), val(:)\n+    integer :: i\n+\n+    if (rank(a) /= rnk) call abort()\n+    if (size(low) /= rnk .or. size(high) /= rnk) call abort()\n+    if (size(a) /= product (high - low +1)) call abort()\n+\n+    if (rnk > 0) then\n+!      if (1 /= lbound(a,1)) call abort()\n+!      if (high(1)-low(1)+1 /= ubound(a,1)) call abort()\n+      if (size (a,1) /= high(1)-low(1)+1) call abort()\n+    end if\n+\n+    do i = 1, rnk\n+!      if (1 /= lbound(a,i)) call abort()\n+!      if (high(i)-low(i)+1 /= ubound(a,i)) call abort()\n+      if (size (a,i) /= high(i)-low(i)+1) call abort()\n+    end do\n+    call check_value (a, rnk, val)\n+  end subroutine foo2\n+\n+  ! ALLOCATABLE argument - bounds as specified before\n+  subroutine foo3 (a, rnk, low, high, val)\n+    integer, allocatable, intent(in), target :: a(..)\n+    integer, value :: rnk\n+    integer, intent(in) :: low(:), high(:), val(:)\n+    integer :: i\n+\n+    if (rank(a) /= rnk) call abort()\n+    if (size(low) /= rnk .or. size(high) /= rnk) call abort()\n+    if (size(a) /= product (high - low +1)) call abort()\n+\n+    if (rnk > 0) then\n+!      if (low(1) /= lbound(a,1)) call abort()\n+!      if (high(1) /= ubound(a,1)) call abort()\n+      if (size (a,1) /= high(1)-low(1)+1) call abort()\n+    end if\n+\n+    do i = 1, rnk\n+!      if (low(i) /= lbound(a,i)) call abort()\n+!      if (high(i) /= ubound(a,i)) call abort()\n+      if (size (a,i) /= high(i)-low(i)+1) call abort()\n+    end do\n+    call check_value (a, rnk, val)\n+    call foo(a, rnk, low, high, val)\n+  end subroutine\n+end"}, {"sha": "ac28283949428f1a44ab227cad4e8eb68c7010ec", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_10.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_10.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,106 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/48820\n+!\n+! Ensure that the value of scalars to assumed-rank arrays is\n+! copied back, if and only its pointer address could have changed.\n+!\n+program test\n+ implicit none\n+ type t\n+   integer :: aa\n+ end type t\n+\n+ integer, allocatable :: iia\n+ integer, pointer     :: iip\n+\n+ type(t), allocatable :: jja\n+ type(t), pointer     :: jjp\n+\n+ logical :: is_present\n+\n+ is_present = .true.\n+\n+ allocate (iip, jjp)\n+\n+ iia = 7\n+ iip = 7\n+ jja = t(88)\n+ jjp = t(88)\n+\n+ call faa(iia, jja) ! Copy back\n+ if (iia /= 7 .and. jja%aa /= 88) call abort ()\n+ call fai(iia, jja) ! No copy back\n+ if (iia /= 7 .and. jja%aa /= 88) call abort ()\n+\n+ call fpa(iip, jjp) ! Copy back\n+ if (iip /= 7 .and. jjp%aa /= 88) call abort ()\n+ call fpi(iip, jjp) ! No copy back\n+ if (iip /= 7 .and. jjp%aa /= 88) call abort ()\n+\n+ call fnn(iia, jja) ! No copy back\n+ if (iia /= 7 .and. jja%aa /= 88) call abort ()\n+ call fno(iia, jja) ! No copy back\n+ if (iia /= 7 .and. jja%aa /= 88) call abort ()\n+ call fnn(iip, jjp) ! No copy back\n+ if (iip /= 7 .and. jjp%aa /= 88) call abort ()\n+ call fno(iip, jjp) ! No copy back\n+ if (iip /= 7 .and. jjp%aa /= 88) call abort ()\n+\n+ is_present = .false.\n+\n+ call fpa(null(), null()) ! No copy back\n+ call fpi(null(), null()) ! No copy back\n+ call fno(null(), null()) ! No copy back\n+\n+ call fno() ! No copy back\n+\n+contains\n+\n+  subroutine faa (xx1, yy1)\n+    integer, allocatable :: xx1(..)\n+    type(t), allocatable :: yy1(..)\n+    if (.not. allocated (xx1)) call abort ()\n+    if (.not. allocated (yy1)) call abort ()\n+  end subroutine faa\n+  subroutine fai (xx1, yy1)\n+    integer, allocatable, intent(in) :: xx1(..)\n+    type(t), allocatable, intent(in) :: yy1(..)\n+    if (.not. allocated (xx1)) call abort ()\n+    if (.not. allocated (yy1)) call abort ()\n+  end subroutine fai\n+  subroutine fpa (xx1, yy1)\n+    integer, pointer :: xx1(..)\n+    type(t), pointer :: yy1(..)\n+    if (is_present .neqv. associated (xx1)) call abort ()\n+    if (is_present .neqv. associated (yy1)) call abort ()\n+  end subroutine fpa\n+\n+  subroutine fpi (xx1, yy1)\n+    integer, pointer, intent(in) :: xx1(..)\n+    type(t), pointer, intent(in) :: yy1(..)\n+    if (is_present .neqv. associated (xx1)) call abort ()\n+    if (is_present .neqv. associated (yy1)) call abort ()\n+  end subroutine fpi\n+\n+  subroutine fnn(xx2,yy2)\n+    integer  :: xx2(..)\n+    type(t)  :: yy2(..)\n+  end subroutine fnn\n+\n+  subroutine fno(xx2,yy2)\n+    integer, optional  :: xx2(..)\n+    type(t), optional  :: yy2(..)\n+    if (is_present .neqv. present (xx2)) call abort ()\n+    if (is_present .neqv. present (yy2)) call abort ()\n+  end subroutine fno\n+end program test\n+\n+! We should have exactly one copy back per variable\n+!\n+! { dg-final { scan-tree-dump-times \"iip = .integer.kind=4. .. desc.\\[0-9\\]+.data;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"iia = .integer.kind=4. .. desc.\\[0-9\\]+.data;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"jjp = .struct t .. desc.\\[0-9\\]+.data;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"jja = .struct t .. desc.\\[0-9\\]+.data;\" 1 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "a2abcba1091e8ded3c8779f2ae1a8aa4019e0b84", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_12.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_12.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/48820\n+!\n+! Ensure that the value of scalars to assumed-rank arrays is\n+! copied back - and everything happens in the correct order.\n+\n+call sub(f())\n+contains\n+subroutine sub(x)\n+  integer, pointer :: x(..)\n+end subroutine sub\n+function f() result(res)\n+  integer, pointer :: res\n+end function f\n+end\n+\n+! { dg-final { scan-tree-dump \" = f \\\\(\\\\);.*desc.0.dtype = 600;.*desc.0.data = .void .. D.*;.*sub \\\\(&desc.0\\\\);.*D.*= .integer.kind=4. .. desc.0.data;\" \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }\n+"}, {"sha": "85dd72db10390f7ce7b8680001df7d34f18a10ab", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_1_c.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_1_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_1_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_1_c.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,16 @@\n+/* Called by assumed_rank_1.f90.  */\n+\n+#include <stdlib.h>  /* For abort().  */\n+\n+struct array {\n+  int *data;\n+};\n+\n+void check_value_ (struct array *b, int n, int val[])\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    if (b->data[i] != val[i])\n+      abort ();\n+}"}, {"sha": "981e5cc2f9233f046fc87c6d297d0bbb54f5e23c", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_2.f90", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_2.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,137 @@\n+! { dg-do run }\n+! { dg-options \"-fcheck=all\" }\n+!\n+! PR fortran/48820\n+!\n+! Assumed-rank tests - same as assumed_rank_1.f90,\n+! but with bounds checks and w/o call to C function\n+!\n+! FIXME: The ubound/lbound checks have to be re-enabled when\n+! after they are supported\n+\n+implicit none\n+\n+integer, target :: x(2:5,4:7), y(-4:4)\n+integer, allocatable, target :: z(:,:,:,:)\n+integer, allocatable :: val(:)\n+integer :: i\n+\n+allocate(z(1:4, -2:5, 4, 10:11))\n+\n+if (rank(x) /= 2) call abort ()\n+val = [(2*i+3, i = 1, size(x))]\n+x = reshape (val, shape(x))\n+call foo(x, rank(x), lbound(x), ubound(x), val)\n+call foo2(x, rank(x), lbound(x), ubound(x), val)\n+call bar(x,x,.true.)\n+call bar(x,prsnt=.false.)\n+\n+if (rank(y) /= 1) call abort ()\n+val = [(2*i+7, i = 1, size(y))]\n+y = reshape (val, shape(y))\n+call foo(y, rank(y), lbound(y), ubound(y), val)\n+call foo2(y, rank(y), lbound(y), ubound(y), val)\n+call bar(y,y,.true.)\n+call bar(y,prsnt=.false.)\n+\n+if (rank(z) /= 4) call abort ()\n+val = [(2*i+5, i = 1, size(z))]\n+z(:,:,:,:) = reshape (val, shape(z))\n+call foo(z, rank(z), lbound(z), ubound(z), val)\n+call foo(z, rank(z), lbound(z), ubound(z), val)\n+call foo2(z, rank(z), lbound(z), ubound(z), val)\n+call bar(z,z,.true.)\n+call bar(z,prsnt=.false.)\n+\n+contains\n+  subroutine bar(a,b, prsnt)\n+    integer, pointer, optional, intent(in) :: a(..),b(..)\n+    logical, value :: prsnt\n+    ! The following is not valid, but it goes past the constraint check\n+    ! Technically, it could be allowed and might be in Fortran 2015:\n+    if (.not. associated(a)) call abort()\n+    if (present(b)) then\n+      if (.not. associated(a,b)) call abort()\n+    else\n+      if (.not. associated(a)) call abort()\n+    end if\n+    if (.not. present(a)) call abort()\n+    if (prsnt .neqv. present(b)) call abort()\n+  end subroutine\n+\n+  ! POINTER argument - bounds as specified before\n+  subroutine foo(a, rnk, low, high, val)\n+    integer,pointer, intent(in) :: a(..)\n+    integer, value :: rnk\n+    integer, intent(in) :: low(:), high(:), val(:)\n+    integer :: i\n+\n+\n+\n+    if (rank(a) /= rnk) call abort()\n+    if (size(low) /= rnk .or. size(high) /= rnk) call abort()\n+    if (size(a) /= product (high - low +1)) call abort()\n+\n+    if (rnk > 0) then\n+!      if (low(1) /= lbound(a,1)) call abort()\n+!      if (high(1) /= ubound(a,1)) call abort()\n+      if (size (a,1) /= high(1)-low(1)+1) call abort()\n+    end if\n+\n+    do i = 1, rnk\n+!      if (low(i) /= lbound(a,i)) call abort()\n+!      if (high(i) /= ubound(a,i)) call abort()\n+      if (size (a,i) /= high(i)-low(i)+1) call abort()\n+    end do\n+    call foo2(a, rnk, low, high, val)\n+  end subroutine\n+\n+  ! Non-pointer, non-allocatable bounds. lbound == 1\n+  subroutine foo2(a, rnk, low, high, val)\n+    integer, intent(in) :: a(..)\n+    integer, value :: rnk\n+    integer, intent(in) :: low(:), high(:), val(:)\n+    integer :: i\n+\n+    if (rank(a) /= rnk) call abort()\n+    if (size(low) /= rnk .or. size(high) /= rnk) call abort()\n+    if (size(a) /= product (high - low +1)) call abort()\n+\n+    if (rnk > 0) then\n+!      if (1 /= lbound(a,1)) call abort()\n+!      if (high(1)-low(1)+1 /= ubound(a,1)) call abort()\n+      if (size (a,1) /= high(1)-low(1)+1) call abort()\n+    end if\n+\n+    do i = 1, rnk\n+!      if (1 /= lbound(a,i)) call abort()\n+!      if (high(i)-low(i)+1 /= ubound(a,i)) call abort()\n+      if (size (a,i) /= high(i)-low(i)+1) call abort()\n+    end do\n+  end subroutine foo2\n+\n+  ! ALLOCATABLE argument - bounds as specified before\n+  subroutine foo3 (a, rnk, low, high, val)\n+    integer, allocatable, intent(in), target :: a(..)\n+    integer, value :: rnk\n+    integer, intent(in) :: low(:), high(:), val(:)\n+    integer :: i\n+\n+    if (rank(a) /= rnk) call abort()\n+    if (size(low) /= rnk .or. size(high) /= rnk) call abort()\n+    if (size(a) /= product (high - low +1)) call abort()\n+\n+    if (rnk > 0) then\n+!      if (low(1) /= lbound(a,1)) call abort()\n+!      if (high(1) /= ubound(a,1)) call abort()\n+      if (size (a,1) /= high(1)-low(1)+1) call abort()\n+    end if\n+\n+    do i = 1, rnk\n+!      if (low(i) /= lbound(a,i)) call abort()\n+!      if (high(i) /= ubound(a,i)) call abort()\n+      if (size (a,i) /= high(i)-low(i)+1) call abort()\n+    end do\n+    call foo(a, rnk, low, high, val)\n+  end subroutine\n+end"}, {"sha": "3391fba882f599b23bd31a6105ef2ab3e9177503", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_4.f90", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_4.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,50 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008ts\" }\n+!\n+! PR fortran/48820\n+!\n+! Assumed-rank constraint checks and other diagnostics\n+!\n+\n+subroutine valid1a(x)\n+  integer, intent(in), pointer, contiguous :: x(..)\n+end subroutine valid1a\n+\n+subroutine valid1(x)\n+  integer, intent(in) :: x(..)\n+end subroutine valid1\n+\n+subroutine valid2(x)\n+ type(*) :: x\n+end subroutine valid2\n+\n+subroutine foo99(x)\n+  integer  x(99)\n+  call valid1(x) ! { dg-error \"Procedure 'valid1' at .1. with assumed-rank dummy argument 'x' must have an explicit interface\" }\n+  call valid2(x(1)) ! { dg-error \"Procedure 'valid2' at .1. with assumed-type dummy argument 'x' must have an explicit interface\" }\n+end subroutine foo99\n+\n+subroutine foo(x)\n+  integer :: x(..)\n+  print *, ubound(x,dim=2000) ! { dg-error \"is not a valid dimension index\" }\n+  call bar(x) ! { dg-error \"Assumed-rank argument requires an explicit interface\" }\n+  call intnl(x) ! { dg-error \"requires that the dummy argument 'x' has assumed-rank\" }\n+contains\n+  subroutine intnl(x)\n+    integer :: x(:)\n+  end subroutine intnl\n+end subroutine foo\n+\n+subroutine foo2(x)\n+  integer :: x(..)\n+  call valid3(x(:)) ! { dg-error \"Assumed-rank variable x at .1. shall not have a subobject reference\" }\n+  call valid3(x+1)  ! { dg-error \"Assumed-rank variable x at .1. may only be used as actual argument\" }\n+contains\n+  subroutine valid3(y)\n+    integer :: y(..)\n+  end subroutine\n+end subroutine\n+\n+subroutine foo3()\n+  integer :: x(..) ! { dg-error \"Assumed-rank array at .1. must be a dummy argument\" }\n+end subroutine"}, {"sha": "a7949969b901edcd9d53573ea281665bc7a7f0a9", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_5.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_5.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+!\n+! PR fortran/48820\n+!\n+!\n+subroutine foo(x)\n+  integer :: x(..)  ! { dg-error \"TS 29113: Assumed-rank array\" }\n+end subroutine foo"}, {"sha": "e5071bda9ed11b025e3ba953bfd7e04f34f70e65", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_6.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_6.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/48820\n+!\n+! Assumed-rank constraint checks and other diagnostics\n+!\n+\n+subroutine foo(x) ! { dg-error \"Assumed-type variable x at .1. may not have the INTENT.OUT. attribute\" }\n+  type(*), intent(out) :: x\n+end subroutine\n+\n+subroutine bar(x)\n+  integer, intent(out) :: x(..)\n+end subroutine bar\n+\n+subroutine foo3(y)\n+  integer :: y(..)\n+  y = 7           ! { dg-error \"Assumed-rank variable y at .1. may only be used as actual argument\" }\n+  print *, y + 10 ! { dg-error \"Assumed-rank variable y at .1. may only be used as actual argument\" }\n+  print *, y      ! { dg-error \"Assumed-rank variable y at .1. may only be used as actual argument\" }\n+end subroutine\n+\n+subroutine foo2(x, y)\n+  integer :: x(..), y(..)\n+  call valid3(x(:)) ! { dg-error \"Assumed-rank variable x at .1. shall not have a subobject reference\" }\n+contains\n+  subroutine valid3(y)\n+    integer :: y(..)\n+  end subroutine\n+end subroutine\n+\n+subroutine foo4(x) ! { dg-error \"may not have the VALUE or CODIMENSION attribute\" }\n+  integer, codimension[*] :: x(..)\n+end subroutine\n+\n+subroutine foo5(y) ! { dg-error \"may not have the VALUE or CODIMENSION attribute\" }\n+  integer :: y(..)[*]\n+end subroutine"}, {"sha": "96d4d8f386a06df5e1fb7a653a69c36ac7b513bd", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_7.f90", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_7.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do run }\n+!\n+! PR fortran/48820\n+!\n+! Handle type/class for assumed-rank arrays\n+!\n+! FIXME: The ubound/lbound checks have to be re-enabled when\n+! after they are supported.\n+! FIXME: Passing a CLASS to a CLASS has to be re-enabled.\n+implicit none\n+type t\n+  integer :: i\n+end type\n+\n+class(T), allocatable :: ac(:,:)\n+type(T), allocatable :: at(:,:)\n+integer :: i\n+\n+allocate(ac(2:3,2:4))\n+allocate(at(2:3,2:4))\n+\n+i = 0\n+call foo(ac)\n+call foo(at)\n+call bar(ac)\n+call bar(at)\n+if (i /= 12) call abort()\n+\n+contains\n+  subroutine bar(x)\n+    type(t) :: x(..)\n+!    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n+    if (size(x) /= 6) call abort()\n+    if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n+!    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n+    i = i + 1\n+    call foo(x)\n+    call bar2(x)\n+  end subroutine\n+  subroutine bar2(x)\n+    type(t) :: x(..)\n+!    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n+    if (size(x) /= 6) call abort()\n+    if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n+!    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n+    i = i + 1\n+  end subroutine\n+  subroutine foo(x)\n+    class(t) :: x(..)\n+!    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n+    if (size(x) /= 6) call abort()\n+    if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n+!    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n+    i = i + 1\n+    call foo2(x)\n+!    call bar2(x) ! Passing a CLASS to a TYPE does not yet work\n+  end subroutine\n+  subroutine foo2(x)\n+    class(t) :: x(..)\n+!    if (lbound(x,1) /= 1 .or. lbound(x,2) /= 1) call abort()\n+    if (size(x) /= 6) call abort()\n+    if (size(x,1) /= 2 .or. size(x,2) /= 3) call abort()\n+!    if (ubound(x,1) /= 2 .or. ubound(x,2) /= 3) call abort()\n+    i = i + 1\n+  end subroutine\n+end "}, {"sha": "b1ccab5322c2448894d6789fa146211b75168609", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_8.f90", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_8.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\n+! { dg-additional-sources assumed_rank_8_c.c }\n+!\n+! PR fortran/48820\n+!\n+! Scalars to assumed-rank tests\n+!\n+program main\n+  implicit none\n+\n+  interface\n+    subroutine check (x)\n+      integer :: x(..)\n+    end subroutine check\n+  end interface\n+\n+  integer, target :: ii, j\n+  integer, allocatable :: kk\n+  integer, pointer :: ll\n+  ii = 489\n+  j = 0\n+  call f (ii)\n+  call f (489)\n+  call f ()\n+  call f (null())\n+  call f (kk)\n+  if (j /= 2) call abort()\n+\n+  j = 0\n+  nullify (ll)\n+  call g (null())\n+  call g (ll)\n+  call g (ii)\n+  if (j /= 1) call abort()\n+\n+  j = 0\n+  call h (kk)\n+  kk = 489\n+  call h (kk)\n+  if (j /= 1) call abort()\n+\n+contains\n+\n+  subroutine f (x)\n+    integer, optional :: x(..)\n+\n+    if (.not. present (x)) return\n+    if (rank (x) /= 0) call abort\n+    call check (x)\n+    j = j + 1\n+  end subroutine\n+\n+  subroutine g (x)\n+    integer, pointer, intent(in) :: x(..)\n+\n+    if (.not. associated (x)) return\n+    if (rank (x) /= 0) call abort ()\n+    call check (x)\n+    j = j + 1\n+  end subroutine\n+\n+  subroutine h (x)\n+    integer, allocatable :: x(..)\n+\n+    if (.not. allocated (x)) return\n+    if (rank (x) /= 0) call abort\n+    call check (x)\n+    j = j + 1\n+  end subroutine\n+\n+end program main"}, {"sha": "3910d318e3c792281f4eb10c2d7337077be20631", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_8_c.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_8_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_8_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_8_c.c?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,25 @@\n+/* Called by assumed_rank_8.f90 and assumed_rank_9.f90.  */\n+\n+#include <stdlib.h>  /* For abort().  */\n+\n+struct a {\n+  int *dat;\n+};\n+\n+struct b {\n+  struct a _data;\n+};\n+\n+\n+void check_ (struct a *x)\n+{\n+  if (*x->dat != 489)\n+    abort ();\n+}\n+\n+\n+void check2_ (struct b *x)\n+{\n+  if (*x->_data.dat != 489)\n+    abort ();\n+}"}, {"sha": "39151f58789f97d923f335dee026892c279c9a57", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_9.f90", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_9.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -0,0 +1,139 @@\n+! { dg-do run }\n+! { dg-additional-sources assumed_rank_8_c.c }\n+!\n+! PR fortran/48820\n+!\n+! Scalars to assumed-rank tests\n+!\n+program main\n+  implicit none\n+\n+  type t\n+    integer :: i\n+  end type t\n+\n+  interface\n+    subroutine check (x)\n+      integer :: x(..)\n+    end subroutine check\n+    subroutine check2 (x)\n+      import t\n+      class(t) :: x(..)\n+    end subroutine check2\n+  end interface\n+\n+  integer :: j\n+\n+  type(t), target :: y\n+  class(t), allocatable, target :: yac\n+  \n+  y%i = 489\n+  allocate (yac)\n+  yac%i = 489\n+  j = 0\n+  call fc()\n+  call fc(null())\n+  call fc(y)\n+  call fc(yac)\n+  if (j /= 2) call abort ()\n+\n+  j = 0\n+  call gc(null())\n+  call gc(y)\n+  call gc(yac)\n+  deallocate (yac)\n+  call gc(yac)\n+  if (j /= 2) call abort ()\n+\n+  j = 0\n+  call hc(yac)\n+  allocate (yac)\n+  yac%i = 489\n+  call hc(yac)\n+  if (j /= 1) call abort ()\n+\n+  j = 0\n+  call ft()\n+  call ft(null())\n+  call ft(y)\n+  call ft(yac)\n+  if (j /= 2) call abort ()\n+\n+  j = 0\n+  call gt(null())\n+  call gt(y)\n+  call gt(yac)\n+  deallocate (yac)\n+  call gt(yac)\n+  if (j /= 2) call abort ()\n+\n+  j = 0\n+  call ht(yac)\n+  allocate (yac)\n+  yac%i = 489\n+  call ht(yac)\n+  if (j /= 1) call abort ()\n+\n+contains\n+\n+  subroutine fc (x)\n+    class(t), optional :: x(..)\n+\n+    if (.not. present (x)) return\n+    if (.not. SAME_TYPE_AS (x, yac)) call abort ()\n+    if (rank (x) /= 0) call abort\n+    call check2 (x)\n+    j = j + 1\n+  end subroutine\n+\n+  subroutine gc (x)\n+    class(t), pointer, intent(in) :: x(..)\n+\n+    if (.not. associated (x)) return\n+    if (.not. SAME_TYPE_AS (x, yac)) call abort ()\n+    if (rank (x) /= 0) call abort ()\n+    call check2 (x)\n+    j = j + 1\n+  end subroutine\n+\n+  subroutine hc (x)\n+    class(t), allocatable :: x(..)\n+\n+    if (.not. allocated (x)) return\n+    if (.not. SAME_TYPE_AS (x, yac)) call abort ()\n+    if (rank (x) /= 0) call abort\n+    call check2 (x)\n+    j = j + 1\n+  end subroutine\n+\n+  subroutine ft (x)\n+    type(t), optional :: x(..)\n+\n+    if (.not. present (x)) return\n+    if (.not. SAME_TYPE_AS (x, yac)) call abort ()\n+    if (rank (x) /= 0) call abort\n+    call check2 (x)\n+    j = j + 1\n+  end subroutine\n+\n+  subroutine gt (x)\n+    type(t), pointer, intent(in) :: x(..)\n+\n+    if (.not. associated (x)) return\n+    if (.not. SAME_TYPE_AS (x, yac)) call abort ()\n+    if (rank (x) /= 0) call abort ()\n+    call check2 (x)\n+    j = j + 1\n+  end subroutine\n+\n+  subroutine ht (x)\n+    type(t), allocatable :: x(..)\n+\n+    if (.not. allocated (x)) return\n+    if (.not. SAME_TYPE_AS (x, yac)) call abort ()\n+    if (rank (x) /= 0) call abort\n+    call check2 (x)\n+    j = j + 1\n+  end subroutine\n+\n+end program main"}, {"sha": "8d2be255b8c27b4075c58a1a67899849980923b9", "filename": "gcc/testsuite/gfortran.dg/assumed_type_3.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c62c6622bcf2906969975f5741072d842c667851/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_type_3.f90?ref=c62c6622bcf2906969975f5741072d842c667851", "patch": "@@ -31,7 +31,7 @@ end subroutine six\n \n subroutine seven(y)\n  type(*) :: y(:)\n- call a7(y(3:5)) ! { dg-error \"Assumed-type variable y with designator\" }\n+ call a7(y(3:5)) ! { dg-error \"Assumed-type variable y at .1. shall not have a subobject reference\" }\n contains\n  subroutine a7(x)\n    type(*) :: x(*)\n@@ -115,5 +115,5 @@ end subroutine thirteen\n \n subroutine fourteen(x)\n   type(*) :: x\n-  x = x ! { dg-error \"Invalid expression with assumed-type variable\" }\n+  x = x ! { dg-error \"Assumed-type variable x at .1. may only be used as actual argument\" }\n end subroutine fourteen"}]}