{"sha": "e1dfbb03f98d5a039c996adaf60c076979d61d18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFkZmJiMDNmOThkNWEwMzljOTk2YWRhZjYwYzA3Njk3OWQ2MWQxOA==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-02-25T23:38:05Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-06-17T14:32:15Z"}, "message": "[Ada] Casing on composite values\n\ngcc/ada/\n\n\t* exp_ch5.adb\n\t(Expand_N_Case_Statement.Expand_General_Case_Statement): New\n\tsubprogram.\n\t(Expand_N_Case_Statement): If extensions are allowed and the\n\tcase selector is not of a discrete type, then call\n\tExpand_General_Case_Statement to generate expansion instead of\n\tflagging the non-discrete selector as an error.\n\t* sem_case.ads (Is_Case_Choice_Pattern): New Boolean-valued\n\tfunction for testing whether a given expression occurs as part\n\tof a case choice pattern.\n\t* sem_case.adb (Composite_Case_Ops): New package providing\n\tsupport routines for the new form of case statements. This\n\tincludes a nested package, Composite_Case_Ops.Value_Sets, which\n\tencapsulates the \"representative values\" implementation of\n\tcomposite value sets.\n\t(Check_Choices.Check_Case_Pattern_Choices): New procedure for\n\tsemantic checking of non-discrete case choices. This includes\n\tthe checks pertaining to coverage and overlapping.\n\t(Check_Choices.Check_Composite_Case_Selector): New procedure for\n\tsemantic checking of non-discrete case selectors.\n\t(Check_Choices): If extensions are allowed then a non-discrete\n\tselector type no longer implies that an error must have been\n\tflagged earlier.  Instead of simply returning, call\n\tCheck_Composite_Case_Selector and Check_Case_Pattern_Choices.\n\t(Is_Case_Choice_Pattern): Body of new function declared in\n\tsem_case.ads .\n\t* sem_ch5.adb (Analyze_Case_Statement): If extensions are\n\tallowed, then we can't use RM 5.4's \"The selecting_expression is\n\texpected to be of any discrete type\" name resolution rule.\n\tHandle the case where the type of the selecting expression is\n\tnot discrete, as well as the new ambiguous-name-resolution error\n\tcases made possible by this change.\n\t* sem_res.adb (Resolve_Entity_Name): It is ok to treat the name\n\tof a type or subtype as an expression if it is part of a case\n\tchoice pattern, as in \"(Field1 => Positive, Field2 => <>)\".\n\t* exp_aggr.adb (Expand_Record_Aggregate): Do not expand case\n\tchoice aggregates.\n\t* gen_il-fields.ads: Define two new node attributes,\n\tBinding_Chars and Multidefined_Bindings.\n\t* gen_il-gen-gen_nodes.adb: The new Multidefined_Bindings\n\tattribute is Boolean-valued and may be set on\n\tN_Case_Statement_Alternative nodes. The new Binding_Chars\n\tattribute is Name_Id-valued and may be set on\n\tN_Component_Association nodes.\n\t* par-ch4.adb (P_Record_Or_Array_Component_Association): When\n\tparsing a component association, check for both new syntax forms\n\tused to specify a bound value in a case-choice aggregate.  In\n\tthe case of a box value, an identifier may occur within the box,\n\tas in \"Foo => <Abc>\" instead of \"Foo => <>\". In the more general\n\tcase, an expression (or a box) may be followed by \"is\n\t<identifier>\", as in\n\t\"Foo => Bar is Abc\" instead of just \"Foo => Bar\".\n\t* sem_aggr.adb (Resolve_Record_Aggregate): Do not transform box\n\tcomponent values in a case-choice aggregate.\n\t* sinfo.ads: Provide comments for the new attributes added in\n\tgen_il-fields.ads.\n\t* doc/gnat_rm/implementation_defined_pragmas.rst: Describe this\n\tnew feature in documentation for pragma Extensions_Allowed.\n\t* gnat_rm.texi: Regenerate.", "tree": {"sha": "946be4f656fe364dd06d6397e50ac3801af57158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/946be4f656fe364dd06d6397e50ac3801af57158"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1dfbb03f98d5a039c996adaf60c076979d61d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1dfbb03f98d5a039c996adaf60c076979d61d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1dfbb03f98d5a039c996adaf60c076979d61d18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1dfbb03f98d5a039c996adaf60c076979d61d18/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f900b589c83b789329a0e99ddbe627507703e5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f900b589c83b789329a0e99ddbe627507703e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f900b589c83b789329a0e99ddbe627507703e5e"}], "stats": {"total": 2294, "additions": 2283, "deletions": 11}, "files": [{"sha": "0d20496a46d6086dc6919fcc6527736869adf484", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -2235,6 +2235,92 @@ of GNAT specific extensions are recognized as follows:\n   This new aggregate syntax for arrays and containers is provided under -gnatX\n   to experiment and confirm this new language syntax.\n \n+* Casing on composite values\n+\n+  The selector for a case statement may be of a composite type, subject to\n+  some restrictions (described below). Aggregate syntax is used for choices\n+  of such a case statement; however, in cases where a \"normal\" aggregate would\n+  require a discrete value, a discrete subtype may be used instead; box\n+  notation can also be used to match all values (but currently only\n+  for discrete subcomponents).\n+\n+  Consider this example:\n+\n+   .. code-block:: ada\n+\n+      type Rec is record\n+         F1, F2 : Integer;\n+      end record;\n+\n+      procedure Caser_1 (X : Rec) is\n+      begin\n+         case X is\n+            when (F1 => Positive, F2 => Positive) =>\n+               Do_This;\n+            when (F1 => Natural, F2 => <>) | (F1 => <>, F2 => Natural) =>\n+               Do_That;\n+            when others =>\n+                Do_The_Other_Thing;\n+         end case;\n+      end Caser_1;\n+\n+  If Caser_1 is called and both components of X are positive, then\n+  Do_This will be called; otherwise, if either component is nonnegative\n+  then Do_That will be called; otherwise, Do_The_Other_Thing will be called.\n+\n+  If the set of values that match the choice(s) of an earlier alternative\n+  overlaps the corresponding set of a later alternative, then the first\n+  set shall be a proper subset of the second (and the later alternative\n+  will not be executed if the earlier alternative \"matches\"). All possible\n+  values of the composite type shall be covered. The composite type of the\n+  selector shall be a nonlimited untagged undiscriminated record type, all\n+  of whose subcomponent subtypes are either static discrete subtypes or\n+  record types that meet the same restrictions. Support for arrays is\n+  planned, but not yet implemented.\n+\n+  In addition, pattern bindings are supported. This is a mechanism\n+  for binding a name to a component of a matching value for use within\n+  an alternative of a case statement. For a component association\n+  that occurs within a case choice, the expression may be followed by\n+  \"is <identifier>\". In the special case of a \"box\" component association,\n+  the identifier may instead be provided within the box. Either of these\n+  indicates that the given identifer denotes (a constant view of) the matching\n+  subcomponent of the case selector.\n+\n+  Consider this example (which uses type Rec from the previous example):\n+\n+  .. code-block:: ada\n+\n+      procedure Caser_2 (X : Rec) is\n+      begin\n+         case X is\n+            when (F1 => Positive is Abc, F2 => Positive) =>\n+               Do_This (Abc)\n+            when (F1 => Natural is N1, F2 => <N2>) |\n+                 (F1 => <N2>, F2 => Natural is N1) =>\n+               Do_That (Param_1 => N1, Param_2 => N2);\n+            when others =>\n+               Do_The_Other_Thing;\n+         end case;\n+      end Caser_2;\n+\n+  This example is the same as the previous one with respect to\n+  determining whether Do_This, Do_That, or Do_The_Other_Thing will\n+  be called. But for this version, Do_This takes a parameter and Do_That\n+  takes two parameters. If Do_This is called, the actual parameter in the\n+  call will be X.F1.\n+\n+  If Do_That is called, the situation is more complex because there are two\n+  choices for that alternative. If Do_That is called because the first choice\n+  matched (i.e., because X.F1 is nonnegative and either X.F1 or X.F2 is zero\n+  or negative), then the actual parameters of the call will be (in order)\n+  X.F1 and X.F2. If Do_That is called because the second choice matched (and\n+  the first one did not), then the actual parameters will be reversed.\n+\n+  Within the choice list for single alternative, each choice must\n+  define the same set of bindings and the component subtypes for\n+  for a given identifer must all statically match. Currently, the case\n+  of a binding for a nondiscrete component is not implemented.\n \n .. _Pragma-Extensions_Visible:\n "}, {"sha": "8376ff712bc1c40ae5a4f68616f61e3927667038", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -54,6 +54,7 @@ with Ttypes;         use Ttypes;\n with Sem;            use Sem;\n with Sem_Aggr;       use Sem_Aggr;\n with Sem_Aux;        use Sem_Aux;\n+with Sem_Case;       use Sem_Case;\n with Sem_Ch3;        use Sem_Ch3;\n with Sem_Ch8;        use Sem_Ch8;\n with Sem_Ch13;       use Sem_Ch13;\n@@ -8515,6 +8516,11 @@ package body Exp_Aggr is\n \n       elsif Is_Static_Dispatch_Table_Aggregate (N) then\n          return;\n+\n+      --  Case pattern aggregates need to remain as aggregates\n+\n+      elsif Is_Case_Choice_Pattern (N) then\n+         return;\n       end if;\n \n       --  If the pragma Aggregate_Individually_Assign is set, always convert to"}, {"sha": "cd9ab29036646d3abac7eb7d2bd68bae3af54df5", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 411, "deletions": 1, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -31,6 +31,7 @@ with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n+with Errout;         use Errout;\n with Exp_Aggr;       use Exp_Aggr;\n with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch7;        use Exp_Ch7;\n@@ -39,6 +40,7 @@ with Exp_Dbug;       use Exp_Dbug;\n with Exp_Pakd;       use Exp_Pakd;\n with Exp_Tss;        use Exp_Tss;\n with Exp_Util;       use Exp_Util;\n+with Expander;       use Expander;\n with Inline;         use Inline;\n with Namet;          use Namet;\n with Nlists;         use Nlists;\n@@ -3031,7 +3033,415 @@ package body Exp_Ch5 is\n       Choice         : Node_Id;\n       Chlist         : List_Id;\n \n+      function Expand_General_Case_Statement return Node_Id;\n+      --  Expand a case statement whose selecting expression is not discrete\n+\n+      -----------------------------------\n+      -- Expand_General_Case_Statement --\n+      -----------------------------------\n+\n+      function Expand_General_Case_Statement return Node_Id is\n+         --  expand into a block statement\n+\n+         Selector : constant Entity_Id :=\n+           Make_Temporary (Loc, 'J');\n+\n+         function Selector_Subtype_Mark return Node_Id is\n+           (New_Occurrence_Of (Etype (Expr), Loc));\n+\n+         Renamed_Name : constant Node_Id :=\n+           (if Is_Name_Reference (Expr)\n+              then Expr\n+              else Make_Qualified_Expression (Loc,\n+                     Subtype_Mark => Selector_Subtype_Mark,\n+                     Expression   => Expr));\n+\n+         Selector_Decl : constant Node_Id :=\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Selector,\n+             Subtype_Mark        => Selector_Subtype_Mark,\n+             Name                => Renamed_Name);\n+\n+         First_Alt : constant Node_Id := First (Alternatives (N));\n+\n+         function Choice_Index_Decl_If_Needed return Node_Id;\n+         --  If we are going to need a choice index object (that is, if\n+         --  Multidefined_Bindings is true for at least one of the case\n+         --  alternatives), then create and return that object's declaration.\n+         --  Otherwise, return Empty; no need for a decl in that case because\n+         --  it would never be referenced.\n+\n+         ---------------------------------\n+         -- Choice_Index_Decl_If_Needed --\n+         ---------------------------------\n+\n+         function Choice_Index_Decl_If_Needed return Node_Id is\n+            Alt : Node_Id := First_Alt;\n+         begin\n+            while Present (Alt) loop\n+               if Multidefined_Bindings (Alt) then\n+                  return Make_Object_Declaration\n+                    (Sloc => Loc,\n+                     Defining_Identifier =>\n+                       Make_Temporary (Loc, 'K'),\n+                     Object_Definition =>\n+                       New_Occurrence_Of (Standard_Positive, Loc));\n+               end if;\n+\n+               Next (Alt);\n+            end loop;\n+            return Empty; -- decl not needed\n+         end Choice_Index_Decl_If_Needed;\n+\n+         Choice_Index_Decl : constant Node_Id := Choice_Index_Decl_If_Needed;\n+\n+         function Pattern_Match\n+           (Pattern      : Node_Id;\n+            Object       : Node_Id;\n+            Choice_Index : Natural;\n+            Alt          : Node_Id;\n+            Suppress_Choice_Index_Update : Boolean := False) return Node_Id;\n+         --  Returns a Boolean-valued expression indicating a pattern match\n+         --  for a given pattern and object. If Choice_Index is nonzero,\n+         --  then Choice_Index is assigned to Choice_Index_Decl (unless\n+         --  Suppress_Choice_Index_Update is specified, which should only\n+         --  be the case for a recursive call where the caller has already\n+         --  taken care of the update). Pattern occurs as a choice (or as a\n+         --  subexpression of a choice) of the case statement alternative Alt.\n+\n+         function Top_Level_Pattern_Match_Condition\n+           (Alt : Node_Id) return Node_Id;\n+         --  Returns a Boolean-valued expression indicating a pattern match\n+         --  for the given alternative's list of choices.\n+\n+         -------------------\n+         -- Pattern_Match --\n+         -------------------\n+\n+         function Pattern_Match\n+           (Pattern      : Node_Id;\n+            Object       : Node_Id;\n+            Choice_Index : Natural;\n+            Alt          : Node_Id;\n+            Suppress_Choice_Index_Update : Boolean := False) return Node_Id\n+         is\n+            function Update_Choice_Index return Node_Id is (\n+              Make_Assignment_Statement (Loc,\n+                Name       =>\n+                  New_Occurrence_Of\n+                    (Defining_Identifier (Choice_Index_Decl), Loc),\n+                Expression => Make_Integer_Literal (Loc, Pos (Choice_Index))));\n+\n+            function PM\n+              (Pattern      : Node_Id;\n+               Object       : Node_Id;\n+               Choice_Index : Natural := Pattern_Match.Choice_Index;\n+               Alt          : Node_Id := Pattern_Match.Alt;\n+               Suppress_Choice_Index_Update : Boolean :=\n+                 Pattern_Match.Suppress_Choice_Index_Update) return Node_Id\n+              renames Pattern_Match;\n+            --  convenient rename for recursive calls\n+\n+         begin\n+            if Choice_Index /= 0 and not Suppress_Choice_Index_Update then\n+               pragma Assert (Present (Choice_Index_Decl));\n+\n+               --  Add Choice_Index update as a side effect of evaluating\n+               --  this condition and try again, this time suppressing\n+               --  Choice_Index update.\n+\n+               return Make_Expression_With_Actions (Loc,\n+                        Actions => New_List (Update_Choice_Index),\n+                        Expression =>\n+                          PM (Pattern, Object,\n+                              Suppress_Choice_Index_Update => True));\n+            end if;\n+\n+            if Nkind (Pattern) in N_Has_Etype\n+              and then Is_Discrete_Type (Etype (Pattern))\n+              and then Compile_Time_Known_Value (Pattern)\n+            then\n+               return Make_Op_Eq (Loc,\n+                        Object,\n+                        Make_Integer_Literal (Loc, Expr_Value (Pattern)));\n+            end if;\n+\n+            case Nkind (Pattern) is\n+               when N_Aggregate =>\n+                  return Result : Node_Id :=\n+                    New_Occurrence_Of (Standard_True, Loc)\n+                  do\n+                     if Is_Array_Type (Etype (Pattern)) then\n+                        --  Calling Error_Msg_N during expansion is usually a\n+                        --  mistake but is ok for an \"unimplemented\" message.\n+                        Error_Msg_N\n+                          (\"array-valued case choices unimplemented\",\n+                          Pattern);\n+                        return;\n+                     end if;\n+\n+                     --  positional notation should have been normalized\n+                     pragma Assert (No (Expressions (Pattern)));\n+\n+                     declare\n+                        Component_Assoc : Node_Id\n+                          := First (Component_Associations (Pattern));\n+                        Choice : Node_Id;\n+\n+                        function Subobject return Node_Id is\n+                          (Make_Selected_Component (Loc,\n+                             Prefix => New_Copy_Tree (Object),\n+                             Selector_Name => New_Occurrence_Of\n+                                                (Entity (Choice), Loc)));\n+                     begin\n+                        while Present (Component_Assoc) loop\n+                           Choice := First (Choices (Component_Assoc));\n+                           while Present (Choice) loop\n+                              pragma Assert\n+                                (Is_Entity_Name (Choice)\n+                                   and then Ekind (Entity (Choice))\n+                                              in E_Discriminant | E_Component);\n+\n+                              if Box_Present (Component_Assoc) then\n+                                 --  Box matches anything\n+\n+                                 pragma Assert\n+                                   (No (Expression (Component_Assoc)));\n+                              else\n+                                 Result := Make_And_Then (Loc,\n+                                             Left_Opnd  => Result,\n+                                             Right_Opnd =>\n+                                               PM (Pattern =>\n+                                                     Expression\n+                                                       (Component_Assoc),\n+                                                   Object => Subobject));\n+                              end if;\n+\n+                              --  If this component association defines\n+                              --  (in the case where the pattern matches)\n+                              --  the value of a binding object, then\n+                              --  prepend to the statement list for this\n+                              --  alternative an assignment to the binding\n+                              --  object. This assignment will be conditional\n+                              --  if there is more than one choice.\n+\n+                              if Binding_Chars (Component_Assoc) /= No_Name\n+                              then\n+                                 declare\n+                                    Decl_Chars : constant Name_Id :=\n+                                      Binding_Chars (Component_Assoc);\n+\n+                                    Block_Stmt : constant Node_Id :=\n+                                      First (Statements (Alt));\n+                                    pragma Assert\n+                                      (Nkind (Block_Stmt) = N_Block_Statement);\n+                                    pragma Assert (No (Next (Block_Stmt)));\n+                                    Decl : Node_Id\n+                                      := First (Declarations (Block_Stmt));\n+                                    Def_Id : Node_Id := Empty;\n+\n+                                    Assignment_Stmt : Node_Id;\n+                                    Condition       : Node_Id;\n+                                    Prepended_Stmt  : Node_Id;\n+                                 begin\n+                                    --  find the variable to be modified\n+                                    while No (Def_Id) or else\n+                                      Chars (Def_Id) /= Decl_Chars\n+                                    loop\n+                                       Def_Id := Defining_Identifier (Decl);\n+                                       Next (Decl);\n+                                    end loop;\n+\n+                                    Assignment_Stmt :=\n+                                      Make_Assignment_Statement (Loc,\n+                                        Name       => New_Occurrence_Of\n+                                                        (Def_Id, Loc),\n+                                        Expression => Subobject);\n+\n+                                    --  conditional if multiple choices\n+\n+                                    if Present (Choice_Index_Decl) then\n+                                       Condition :=\n+                                         Make_Op_Eq (Loc,\n+                                           New_Occurrence_Of\n+                                             (Defining_Identifier\n+                                                (Choice_Index_Decl), Loc),\n+                                          Make_Integer_Literal\n+                                            (Loc, Int (Choice_Index)));\n+\n+                                       Prepended_Stmt :=\n+                                         Make_If_Statement (Loc,\n+                                           Condition       => Condition,\n+                                           Then_Statements =>\n+                                             New_List (Assignment_Stmt));\n+                                    else\n+                                       --  assignment is unconditional\n+                                       Prepended_Stmt := Assignment_Stmt;\n+                                    end if;\n+\n+                                    declare\n+                                       HSS : constant Node_Id :=\n+                                         Handled_Statement_Sequence\n+                                           (Block_Stmt);\n+                                    begin\n+                                       Prepend (Prepended_Stmt,\n+                                                Statements (HSS));\n+\n+                                       Set_Analyzed (Block_Stmt, False);\n+                                       Set_Analyzed (HSS, False);\n+                                    end;\n+                                 end;\n+                              end if;\n+\n+                              Next (Choice);\n+                           end loop;\n+\n+                           Next (Component_Assoc);\n+                        end loop;\n+                     end;\n+                  end return;\n+\n+               when N_Qualified_Expression =>\n+                  --  Make a copy for one of the two uses of Object; the choice\n+                  --  of where to use the original and where to use the copy\n+                  --  is arbitrary.\n+\n+                  return Make_And_Then (Loc,\n+                    Left_Opnd  => Make_In (Loc,\n+                      Left_Opnd  => New_Copy_Tree (Object),\n+                      Right_Opnd => New_Copy_Tree (Subtype_Mark (Pattern))),\n+                    Right_Opnd =>\n+                      PM (Pattern => Expression (Pattern),\n+                          Object  => Object));\n+\n+               when N_Identifier | N_Expanded_Name =>\n+                  if Is_Type (Entity (Pattern)) then\n+                     return Make_In (Loc,\n+                       Left_Opnd  => Object,\n+                       Right_Opnd => New_Occurrence_Of\n+                                       (Entity (Pattern), Loc));\n+                  end if;\n+\n+               when N_Others_Choice =>\n+                  return New_Occurrence_Of (Standard_True, Loc);\n+\n+               when N_Type_Conversion =>\n+                  --  aggregate expansion sometimes introduces conversions\n+                  if not Comes_From_Source (Pattern)\n+                    and then Base_Type (Etype (Pattern))\n+                           = Base_Type (Etype (Expression (Pattern)))\n+                  then\n+                     return PM (Expression (Pattern), Object);\n+                  end if;\n+\n+               when others =>\n+                  null;\n+            end case;\n+\n+            --  Avoid cascading errors\n+            pragma Assert (Serious_Errors_Detected > 0);\n+            return New_Occurrence_Of (Standard_True, Loc);\n+         end Pattern_Match;\n+\n+         ---------------------------------------\n+         -- Top_Level_Pattern_Match_Condition --\n+         ---------------------------------------\n+\n+         function Top_Level_Pattern_Match_Condition\n+           (Alt : Node_Id) return Node_Id\n+         is\n+            Top_Level_Object : constant Node_Id :=\n+              New_Occurrence_Of (Selector, Loc);\n+\n+            Choices : constant List_Id := Discrete_Choices (Alt);\n+\n+            First_Choice : constant Node_Id := First (Choices);\n+            Subsequent : Node_Id := Next (First_Choice);\n+\n+            Choice_Index : Natural := 0;\n+         begin\n+            if Multidefined_Bindings (Alt) then\n+               Choice_Index := 1;\n+            end if;\n+\n+            return Result : Node_Id :=\n+              Pattern_Match (Pattern      => First_Choice,\n+                             Object       => Top_Level_Object,\n+                             Choice_Index => Choice_Index,\n+                             Alt          => Alt)\n+            do\n+               while Present (Subsequent) loop\n+                  if Choice_Index /= 0 then\n+                     Choice_Index := Choice_Index + 1;\n+                  end if;\n+\n+                  Result := Make_Or_Else (Loc,\n+                    Left_Opnd  => Result,\n+                    Right_Opnd => Pattern_Match\n+                                    (Pattern      => Subsequent,\n+                                     Object       => Top_Level_Object,\n+                                     Choice_Index => Choice_Index,\n+                                     Alt          => Alt));\n+                  Subsequent := Next (Subsequent);\n+               end loop;\n+            end return;\n+         end Top_Level_Pattern_Match_Condition;\n+\n+         function Elsif_Parts return List_Id;\n+         --  Process subsequent alternatives\n+\n+         -----------------\n+         -- Elsif_Parts --\n+         -----------------\n+\n+         function Elsif_Parts return List_Id is\n+            Alt : Node_Id := First_Alt;\n+            Result : constant List_Id := New_List;\n+         begin\n+            loop\n+               Alt := Next (Alt);\n+               exit when No (Alt);\n+\n+               Append (Make_Elsif_Part (Loc,\n+                         Condition => Top_Level_Pattern_Match_Condition (Alt),\n+                         Then_Statements => Statements (Alt)),\n+                       Result);\n+            end loop;\n+            return Result;\n+         end Elsif_Parts;\n+\n+         If_Stmt : constant Node_Id :=\n+           Make_If_Statement (Loc,\n+              Condition       => Top_Level_Pattern_Match_Condition (First_Alt),\n+              Then_Statements => Statements (First_Alt),\n+              Elsif_Parts     => Elsif_Parts);\n+         --  Do we want an implicit \"else raise Program_Error\" here???\n+         --  Perhaps only if Exception-related restrictions are not in effect.\n+\n+         Declarations : constant List_Id := New_List (Selector_Decl);\n+\n+      begin\n+         if Present (Choice_Index_Decl) then\n+            Append_To (Declarations, Choice_Index_Decl);\n+         end if;\n+\n+         return Make_Block_Statement (Loc,\n+            Declarations => Declarations,\n+            Handled_Statement_Sequence =>\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => New_List (If_Stmt)));\n+      end Expand_General_Case_Statement;\n+\n+   --  Start of processing for Expand_N_Case_Statement\n+\n    begin\n+      if Extensions_Allowed and then not Is_Discrete_Type (Etype (Expr)) then\n+         Rewrite (N, Expand_General_Case_Statement);\n+         Analyze (N);\n+         Expand (N);\n+         return;\n+      end if;\n+\n       --  Check for the situation where we know at compile time which branch\n       --  will be taken.\n \n@@ -3557,7 +3967,7 @@ package body Exp_Ch5 is\n    ---------------------------\n \n    --  First we deal with the case of C and Fortran convention boolean values,\n-   --  with zero/non-zero semantics.\n+   --  with zero/nonzero semantics.\n \n    --  Second, we deal with the obvious rewriting for the cases where the\n    --  condition of the IF is known at compile time to be True or False."}, {"sha": "91a610addadaa8ab6bb083d42e287c9ca32de0e8", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -87,6 +87,7 @@ package Gen_IL.Fields is\n       Aux_Decls_Node,\n       Backwards_OK,\n       Bad_Is_Detected,\n+      Binding_Chars,\n       Body_Required,\n       Body_To_Inline,\n       Box_Present,\n@@ -306,6 +307,7 @@ package Gen_IL.Fields is\n       Low_Bound,\n       Mod_Clause,\n       More_Ids,\n+      Multidefined_Bindings,\n       Must_Be_Byte_Aligned,\n       Must_Not_Freeze,\n       Must_Not_Override,"}, {"sha": "13bdd71fb12d60d08672780e2b198c02104518e3", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -1213,7 +1213,8 @@ begin -- Gen_IL.Gen.Gen_Nodes\n    Cc (N_Case_Statement_Alternative, Node_Kind,\n        (Sy (Discrete_Choices, List_Id),\n         Sy (Statements, List_Id, Default_Empty_List),\n-        Sm (Has_SP_Choice, Flag)));\n+        Sm (Has_SP_Choice, Flag),\n+        Sm (Multidefined_Bindings, Flag)));\n \n    Cc (N_Compilation_Unit, Node_Kind,\n        (Sy (Context_Items, List_Id),\n@@ -1241,6 +1242,7 @@ begin -- Gen_IL.Gen.Gen_Nodes\n         Sy (Expression, Node_Id, Default_Empty),\n         Sy (Box_Present, Flag),\n         Sy (Inherited_Discriminant, Flag),\n+        Sy (Binding_Chars, Name_Id, Default_No_Name),\n         Sm (Loop_Actions, List_Id),\n         Sm (Was_Default_Init_Box_Association, Flag)));\n "}, {"sha": "38a56f7a356165af381238ea2666a2f349f0ef4a", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -3663,6 +3663,97 @@ now under -gnatX to confirm and potentially refine its usage and syntax.\n \n This new aggregate syntax for arrays and containers is provided under -gnatX\n to experiment and confirm this new language syntax.\n+\n+@item \n+Casing on composite values\n+\n+The selector for a case statement may be of a composite type, subject to\n+some restrictions (described below). Aggregate syntax is used for choices\n+of such a case statement; however, in cases where a \"normal\" aggregate would\n+require a discrete value, a discrete subtype may be used instead; box\n+notation can also be used to match all values (but currently only\n+for discrete subcomponents).\n+\n+Consider this example:\n+\n+@quotation\n+\n+@example\n+type Rec is record\n+   F1, F2 : Integer;\n+end record;\n+\n+procedure Caser_1 (X : Rec) is\n+begin\n+   case X is\n+      when (F1 => Positive, F2 => Positive) =>\n+         Do_This;\n+      when (F1 => Natural, F2 => <>) | (F1 => <>, F2 => Natural) =>\n+         Do_That;\n+      when others =>\n+          Do_The_Other_Thing;\n+   end case;\n+end Caser_1;\n+@end example\n+@end quotation\n+\n+If Caser_1 is called and both components of X are positive, then\n+Do_This will be called; otherwise, if either component is nonnegative\n+then Do_That will be called; otherwise, Do_The_Other_Thing will be called.\n+\n+If the set of values that match the choice(s) of an earlier alternative\n+overlaps the corresponding set of a later alternative, then the first\n+set shall be a proper subset of the second (and the later alternative\n+will not be executed if the earlier alternative \"matches\"). All possible\n+values of the composite type shall be covered. The composite type of the\n+selector shall be a nonlimited untagged undiscriminated record type, all\n+of whose subcomponent subtypes are either static discrete subtypes or\n+record types that meet the same restrictions. Support for arrays is\n+planned, but not yet implemented.\n+\n+In addition, pattern bindings are supported. This is a mechanism\n+for binding a name to a component of a matching value for use within\n+an alternative of a case statement. For a component association\n+that occurs within a case choice, the expression may be followed by\n+\"is <identifier>\". In the special case of a \"box\" component association,\n+the identifier may instead be provided within the box. Either of these\n+indicates that the given identifer denotes (a constant view of) the matching\n+subcomponent of the case selector.\n+\n+Consider this example (which uses type Rec from the previous example):\n+\n+@example\n+procedure Caser_2 (X : Rec) is\n+begin\n+   case X is\n+      when (F1 => Positive is Abc, F2 => Positive) =>\n+         Do_This (Abc)\n+      when (F1 => Natural is N1, F2 => <N2>) |\n+           (F1 => <N2>, F2 => Natural is N1) =>\n+         Do_That (Param_1 => N1, Param_2 => N2);\n+      when others =>\n+         Do_The_Other_Thing;\n+   end case;\n+end Caser_2;\n+@end example\n+\n+This example is the same as the previous one with respect to\n+determining whether Do_This, Do_That, or Do_The_Other_Thing will\n+be called. But for this version, Do_This takes a parameter and Do_That\n+takes two parameters. If Do_This is called, the actual parameter in the\n+call will be X.F1.\n+\n+If Do_That is called, the situation is more complex because there are two\n+choices for that alternative. If Do_That is called because the first choice\n+matched (i.e., because X.F1 is nonnegative and either X.F1 or X.F2 is zero\n+or negative), then the actual parameters of the call will be (in order)\n+X.F1 and X.F2. If Do_That is called because the second choice matched (and\n+the first one did not), then the actual parameters will be reversed.\n+\n+Within the choice list for single alternative, each choice must\n+define the same set of bindings and the component subtypes for\n+for a given identifer must all statically match. Currently, the case\n+of a binding for a nondiscrete component is not implemented.\n @end itemize\n \n @node Pragma Extensions_Visible,Pragma External,Pragma Extensions_Allowed,Implementation Defined Pragmas"}, {"sha": "20f8dd14eba608013d4d450f5c5a76b66c350301", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -1734,8 +1734,9 @@ package body Ch4 is\n    --        aggregates (AI-287)\n \n    function P_Record_Or_Array_Component_Association return Node_Id is\n-      Assoc_Node : Node_Id;\n-\n+      Assoc_Node                  : Node_Id;\n+      Box_Present                 : Boolean := False;\n+      Box_With_Identifier_Present : Boolean := False;\n    begin\n       --  A loop indicates an iterated_component_association\n \n@@ -1744,6 +1745,8 @@ package body Ch4 is\n       end if;\n \n       Assoc_Node := New_Node (N_Component_Association, Token_Ptr);\n+      Set_Binding_Chars (Assoc_Node, No_Name);\n+\n       Set_Choices (Assoc_Node, P_Discrete_Choice_List);\n       Set_Sloc (Assoc_Node, Token_Ptr);\n       TF_Arrow;\n@@ -1755,12 +1758,78 @@ package body Ch4 is\n \n          Error_Msg_Ada_2005_Extension (\"component association with '<'>\");\n \n+         Box_Present := True;\n          Set_Box_Present (Assoc_Node);\n-         Scan; -- Past box\n-      else\n+         Scan; -- past box\n+      elsif Token = Tok_Less then\n+         declare\n+            Scan_State : Saved_Scan_State;\n+            Id         : Node_Id;\n+         begin\n+            Save_Scan_State (Scan_State);\n+            Scan; -- past \"<\"\n+            if Token = Tok_Identifier then\n+               Id := P_Defining_Identifier;\n+               if Token = Tok_Greater then\n+                  if Extensions_Allowed then\n+                     Set_Box_Present (Assoc_Node);\n+                     Set_Binding_Chars (Assoc_Node, Chars (Id));\n+                     Box_Present := True;\n+                     Box_With_Identifier_Present := True;\n+                     Scan; -- past \">\"\n+                  else\n+                     Error_Msg\n+                       (\"Identifier within box only supported under -gnatX\",\n+                        Token_Ptr);\n+                     Box_Present := True;\n+                     --  Avoid cascading errors by ignoring the identifier\n+                  end if;\n+               end if;\n+            end if;\n+            if not Box_Present then\n+               --  it wasn't an \"is <identifier>\", so restore.\n+               Restore_Scan_State (Scan_State);\n+            end if;\n+         end;\n+      end if;\n+\n+      if not Box_Present then\n          Set_Expression (Assoc_Node, P_Expression);\n       end if;\n \n+      --  Check for \"is <identifier>\" for aggregate that is part of\n+      --  a pattern for a general case statement.\n+\n+      if Token = Tok_Is then\n+         declare\n+            Scan_State : Saved_Scan_State;\n+            Id         : Node_Id;\n+         begin\n+            Save_Scan_State (Scan_State);\n+            Scan; -- past \"is\"\n+            if Token = Tok_Identifier then\n+               Id := P_Defining_Identifier;\n+\n+               if not Extensions_Allowed then\n+                  Error_Msg\n+                    (\"IS following component association\"\n+                       & \" only supported under -gnatX\",\n+                     Token_Ptr);\n+               elsif Box_With_Identifier_Present then\n+                  Error_Msg\n+                    (\"Both identifier-in-box and trailing identifier\"\n+                       & \" specified for one component association\",\n+                     Token_Ptr);\n+               else\n+                  Set_Binding_Chars (Assoc_Node, Chars (Id));\n+               end if;\n+            else\n+               --  It wasn't an \"is <identifier>\", so restore.\n+               Restore_Scan_State (Scan_State);\n+            end if;\n+         end;\n+      end if;\n+\n       return Assoc_Node;\n    end P_Record_Or_Array_Component_Association;\n "}, {"sha": "d189ab7682dcbbc3eff997fc33adb76f56d50126", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -48,6 +48,7 @@ with Restrict;       use Restrict;\n with Rident;         use Rident;\n with Sem;            use Sem;\n with Sem_Aux;        use Sem_Aux;\n+with Sem_Case;       use Sem_Case;\n with Sem_Cat;        use Sem_Cat;\n with Sem_Ch3;        use Sem_Ch3;\n with Sem_Ch5;        use Sem_Ch5;\n@@ -5190,7 +5191,18 @@ package body Sem_Aggr is\n                --  replace the reference to the current instance by the target\n                --  object of the aggregate.\n \n-               if Present (Parent (Component))\n+               if Is_Case_Choice_Pattern (N) then\n+\n+                  --  Do not transform box component values in a case-choice\n+                  --  aggregate.\n+\n+                  Add_Association\n+                   (Component      => Component,\n+                    Expr       => Empty,\n+                    Assoc_List => New_Assoc_List,\n+                    Is_Box_Present => True);\n+\n+               elsif Present (Parent (Component))\n                  and then Nkind (Parent (Component)) = N_Component_Declaration\n                  and then Present (Expression (Parent (Component)))\n                then"}, {"sha": "36db9a7162d63922ed02533759ff95c55f7904b1", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 1522, "deletions": 0, "changes": 1522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -43,12 +43,14 @@ with Stand;          use Stand;\n with Sinfo;          use Sinfo;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n+with Table;\n with Tbuild;         use Tbuild;\n with Uintp;          use Uintp;\n \n with Ada.Unchecked_Deallocation;\n \n with GNAT.Heap_Sort_G;\n+with GNAT.Sets;\n \n package body Sem_Case is\n \n@@ -95,6 +97,114 @@ package body Sem_Case is\n    --  Given a Pos value of enumeration type Ctype, returns the name\n    --  ID of an appropriate string to be used in error message output.\n \n+   package Composite_Case_Ops is\n+\n+      function Scalar_Part_Count (Subtyp : Entity_Id) return Nat;\n+      --  Given the composite type Subtyp of a case selector, returns the\n+      --  number of scalar parts in an object of this type. This is the\n+      --  dimensionality of the associated Cartesian product space.\n+\n+      function Choice_Count (Alternatives : List_Id) return Nat;\n+      --  The sum of the number of choices for each alternative in the given\n+      --  list.\n+\n+      generic\n+         Case_Statement : Node_Id;\n+      package Choice_Analysis is\n+\n+         type Alternative_Id is\n+           new Int range 1 .. List_Length (Alternatives (Case_Statement));\n+         type Choice_Id is\n+           new Int range 1 .. Choice_Count (Alternatives (Case_Statement));\n+         type Part_Id is new Int range\n+           1 .. Scalar_Part_Count (Etype (Expression (Case_Statement)));\n+\n+         type Discrete_Range_Info is\n+           record\n+              Low, High : Uint;\n+           end record;\n+\n+         type Composite_Range_Info is array (Part_Id) of Discrete_Range_Info;\n+\n+         type Choice_Range_Info (Is_Others : Boolean := False) is\n+           record\n+              case Is_Others is\n+                 when False =>\n+                    Ranges : Composite_Range_Info;\n+                 when True =>\n+                    null;\n+              end case;\n+           end record;\n+\n+         type Choices_Range_Info is array (Choice_Id) of Choice_Range_Info;\n+\n+         package Value_Sets is\n+\n+            type Value_Set is private;\n+            --  A set of points in the Cartesian product space defined\n+            --  by the composite type of the case selector.\n+            --  Implemented as an access type.\n+\n+            type Set_Comparison is\n+              (Disjoint, Equal, Contains, Contained_By, Overlaps);\n+\n+            function Compare (S1, S2 : Value_Set) return Set_Comparison;\n+            --  If either argument (or both) is empty, result is Disjoint.\n+            --  Otherwise, result is Equal if the two sets are equal.\n+\n+            Empty : constant Value_Set;\n+\n+            function Matching_Values\n+              (Info : Composite_Range_Info) return Value_Set;\n+            --  The Cartesian product of the given array of ranges\n+            --  (excluding any values outside the Cartesian product of the\n+            --  component ranges).\n+\n+            procedure Union (Target : in out Value_Set; Source : Value_Set);\n+            --  Add elements of Source into Target\n+\n+            procedure Remove (Target : in out Value_Set; Source : Value_Set);\n+            --  Remove elements of Source from Target\n+\n+            function Complement_Is_Empty (Set : Value_Set) return Boolean;\n+            --  Return True iff the set is \"maximal\", in the sense that it\n+            --  includes every value in the Cartesian product of the\n+            --  component ranges.\n+\n+            procedure Free_Value_Sets;\n+            --  Reclaim storage associated with implementation of this package.\n+\n+         private\n+            type Value_Set is new Natural;\n+            --  An index for a table that will be declared in the package body.\n+\n+            Empty : constant Value_Set := 0;\n+\n+         end Value_Sets;\n+\n+         type Single_Choice_Info (Is_Others : Boolean := False) is\n+           record\n+              Alternative : Alternative_Id;\n+              case Is_Others is\n+                 when False =>\n+                    Matches : Value_Sets.Value_Set;\n+                 when True =>\n+                    null;\n+              end case;\n+           end record;\n+\n+         type Choices_Info is array (Choice_Id) of Single_Choice_Info;\n+\n+         function Analysis return Choices_Info;\n+         --  Parse the case choices in order to determine the set of\n+         --  matching values associated with each choice.\n+\n+         type Bound_Values is array (Positive range <>) of Node_Id;\n+\n+      end Choice_Analysis;\n+\n+   end Composite_Case_Ops;\n+\n    procedure Expand_Others_Choice\n      (Case_Table    : Choice_Table_Type;\n       Others_Choice : Node_Id;\n@@ -980,6 +1090,1179 @@ package body Sem_Case is\n       return Name_Find;\n    end Choice_Image;\n \n+   package body Composite_Case_Ops is\n+\n+      function Static_Array_Length (Subtyp : Entity_Id) return Nat;\n+      --  Given a one-dimensional constrained array subtype with\n+      --  statically known bounds, return its length.\n+\n+      -------------------------\n+      -- Static_Array_Length --\n+      -------------------------\n+\n+      function Static_Array_Length (Subtyp : Entity_Id) return Nat is\n+         pragma Assert (Is_Constrained (Subtyp));\n+         pragma Assert (Number_Dimensions (Subtyp) = 1);\n+         Index : constant Node_Id := First_Index (Subtyp);\n+         pragma Assert (Is_OK_Static_Range (Index));\n+         Lo  : constant Uint := Expr_Value (Low_Bound (Index));\n+         Hi  : constant Uint := Expr_Value (High_Bound (Index));\n+         Len : constant Uint := UI_Max (0, (Hi - Lo) + 1);\n+      begin\n+         return UI_To_Int (Len);\n+      end Static_Array_Length;\n+\n+      -----------------------\n+      -- Scalar_Part_Count --\n+      -----------------------\n+\n+      function Scalar_Part_Count (Subtyp : Entity_Id) return Nat is\n+      begin\n+         if Is_Scalar_Type (Subtyp) then\n+            return 1;\n+         elsif Is_Array_Type (Subtyp) then\n+            return Static_Array_Length (Subtyp)\n+              * Scalar_Part_Count (Component_Type (Subtyp));\n+         elsif Is_Record_Type (Subtyp) then\n+            pragma Assert (not Has_Discriminants (Subtyp));\n+            declare\n+               Result : Nat := 0;\n+               Comp : Entity_Id := First_Component (Subtyp);\n+            begin\n+               while Present (Comp) loop\n+                  Result := Result + Scalar_Part_Count (Etype (Comp));\n+                  Next_Component (Comp);\n+               end loop;\n+               return Result;\n+            end;\n+         else\n+            pragma Assert (False);\n+            raise Program_Error;\n+         end if;\n+      end Scalar_Part_Count;\n+\n+      ------------------\n+      -- Choice_Count --\n+      ------------------\n+\n+      function Choice_Count (Alternatives : List_Id) return Nat is\n+         Result : Nat := 0;\n+         Alt : Node_Id := First (Alternatives);\n+      begin\n+         while Present (Alt) loop\n+            Result := Result + List_Length (Discrete_Choices (Alt));\n+            Next (Alt);\n+         end loop;\n+         return Result;\n+      end Choice_Count;\n+\n+      package body Choice_Analysis is\n+\n+         function Component_Bounds_Info return Composite_Range_Info;\n+         --  Returns the (statically known) bounds for each component.\n+         --  The selector expression value (or any other value of the type\n+         --  of the selector expression) can be thought of as a point in the\n+         --  Cartesian product of these sets.\n+\n+         function Parse_Choice (Choice : Node_Id;\n+                                Alt    : Node_Id) return Choice_Range_Info;\n+         --  Extract Choice_Range_Info from a Choice node\n+\n+         ---------------------------\n+         -- Component_Bounds_Info --\n+         ---------------------------\n+\n+         function Component_Bounds_Info return Composite_Range_Info is\n+            Result : Composite_Range_Info;\n+            Next   : Part_Id := 1;\n+            Done   : Boolean := False;\n+\n+            procedure Update_Result (Info : Discrete_Range_Info);\n+            --  Initialize first remaining uninitialized element of Result.\n+            --  Also set Next and Done.\n+\n+            -------------------\n+            -- Update_Result --\n+            -------------------\n+\n+            procedure Update_Result (Info : Discrete_Range_Info) is\n+            begin\n+               Result (Next) := Info;\n+               if Next /= Part_Id'Last then\n+                  Next := Next + 1;\n+               else\n+                  pragma Assert (not Done);\n+                  Done := True;\n+               end if;\n+            end Update_Result;\n+\n+            procedure Traverse_Discrete_Parts (Subtyp : Entity_Id);\n+            --  Traverse the given subtype, looking for discrete parts.\n+            --  For an array subtype of length N, the element subtype\n+            --  is traversed N times. For a record subtype, traverse\n+            --  each component's subtype (once). When a discrete part is\n+            --  found, call Update_Result.\n+\n+            -----------------------------\n+            -- Traverse_Discrete_Parts --\n+            -----------------------------\n+\n+            procedure Traverse_Discrete_Parts (Subtyp : Entity_Id) is\n+            begin\n+               if Is_Discrete_Type (Subtyp) then\n+                  Update_Result\n+                    ((Low  => Expr_Value (Type_Low_Bound (Subtyp)),\n+                      High => Expr_Value (Type_High_Bound (Subtyp))));\n+               elsif Is_Array_Type (Subtyp) then\n+                  for I in 1 .. Static_Array_Length (Subtyp) loop\n+                     Traverse_Discrete_Parts (Component_Type (Subtyp));\n+                  end loop;\n+               elsif Is_Record_Type (Subtyp) then\n+                  pragma Assert (not Has_Discriminants (Subtyp));\n+                  declare\n+                     Comp : Entity_Id := First_Component (Subtyp);\n+                  begin\n+                     while Present (Comp) loop\n+                        Traverse_Discrete_Parts (Etype (Comp));\n+                        Next_Component (Comp);\n+                     end loop;\n+                  end;\n+               else\n+                  Error_Msg_N\n+                    (\"case selector type having a non-discrete non-record\"\n+                     & \"  non-array subcomponent type not implemented\",\n+                     Expression (Case_Statement));\n+               end if;\n+            end Traverse_Discrete_Parts;\n+         begin\n+            Traverse_Discrete_Parts (Etype (Expression (Case_Statement)));\n+            pragma Assert (Done or else Serious_Errors_Detected > 0);\n+            return Result;\n+         end Component_Bounds_Info;\n+\n+         Component_Bounds : constant Composite_Range_Info\n+           := Component_Bounds_Info;\n+\n+         package Case_Bindings is\n+\n+            procedure Note_Binding\n+              (Comp_Assoc : Node_Id;\n+               Choice     : Node_Id;\n+               Alt        : Node_Id);\n+            --  Note_Binding is called once for each component association\n+            --  that defines a binding (using either \"A => B is X\" or\n+            --  \"A => <X>\" syntax);\n+\n+            procedure Check_Bindings;\n+            --  After all calls to Note_Binding, check that bindings are\n+            --  ok (e.g., check consistency among different choices of\n+            --  one alternative).\n+\n+         end Case_Bindings;\n+\n+         procedure Refresh_Binding_Info (Aggr : Node_Id);\n+         --  The parser records binding-related info in the tree.\n+         --  The choice nodes that we see here might not be (will never be?)\n+         --  the original nodes that were produced by the parser. The info\n+         --  recorded by the parser is missing in that case, so this\n+         --  procedure recovers it.\n+         --\n+         --  There are bugs here. In some cases involving nested aggregates,\n+         --  the path back to the parser-created nodes is lost. In particular,\n+         --  we may fail to detect an illegal case like\n+         --   when (F1 | F2 => (Aa => Natural, Bb => Natural is X)) =>\n+         --  This should be rejected because it is binding X to both the\n+         --  F1.Bb and to the F2.Bb subcomponents of the case selector.\n+         --  It would be nice if the not-specific-to-pattern-matching\n+         --  aggregate-processing code could remain unaware of the existence\n+         --  of this binding-related info but perhaps that isn't possible.\n+\n+         --------------------------\n+         -- Refresh_Binding_Info --\n+         --------------------------\n+\n+         procedure Refresh_Binding_Info (Aggr : Node_Id) is\n+            Orig_Aggr : constant Node_Id := Original_Node (Aggr);\n+            Orig_Comp : Node_Id := First (Component_Associations (Orig_Aggr));\n+         begin\n+            if Aggr = Orig_Aggr then\n+               return;\n+            end if;\n+\n+            while Present (Orig_Comp) loop\n+               if Nkind (Orig_Comp) = N_Component_Association\n+                 and then Binding_Chars (Orig_Comp) /= No_Name\n+               then\n+                  if List_Length (Choices (Orig_Comp)) /= 1 then\n+                     --  Conceivably this could be checked during parsing,\n+                     --  but checking is easier here.\n+\n+                     Error_Msg_N\n+                       (\"binding shared by multiple components\", Orig_Comp);\n+                     return;\n+                  end if;\n+\n+                  declare\n+                     Orig_Name : constant Name_Id :=\n+                       Chars (First (Choices (Orig_Comp)));\n+                     Comp : Node_Id := First (Component_Associations (Aggr));\n+                     Matching_Comp : Node_Id := Empty;\n+                  begin\n+                     while Present (Comp) loop\n+                        if Chars (First (Choices (Comp))) = Orig_Name then\n+                           pragma Assert (not Present (Matching_Comp));\n+                           Matching_Comp := Comp;\n+                        end if;\n+\n+                        Next (Comp);\n+                     end loop;\n+\n+                     pragma Assert (Present (Matching_Comp));\n+\n+                     Set_Binding_Chars\n+                       (Matching_Comp,\n+                        Binding_Chars (Orig_Comp));\n+                  end;\n+               end if;\n+\n+               Next (Orig_Comp);\n+            end loop;\n+         end Refresh_Binding_Info;\n+\n+         ------------------\n+         -- Parse_Choice --\n+         ------------------\n+\n+         function Parse_Choice (Choice : Node_Id;\n+                                Alt    : Node_Id) return Choice_Range_Info\n+         is\n+            Result    : Choice_Range_Info (Is_Others => False);\n+            Ranges    : Composite_Range_Info renames Result.Ranges;\n+            Next_Part : Part_Id := 1;\n+            Done      : Boolean := False;\n+\n+            procedure Update_Result (Discrete_Range : Discrete_Range_Info);\n+            --  Initialize first remaining uninitialized element of Ranges.\n+            --  Also set Next_Part and Done.\n+\n+            -------------------\n+            -- Update_Result --\n+            -------------------\n+\n+            procedure Update_Result (Discrete_Range : Discrete_Range_Info) is\n+            begin\n+               pragma Assert (not Done);\n+               Ranges (Next_Part) := Discrete_Range;\n+               if Next_Part = Part_Id'Last then\n+                  Done := True;\n+               else\n+                  Next_Part := Next_Part + 1;\n+               end if;\n+            end Update_Result;\n+\n+            procedure Traverse_Choice (Expr : Node_Id);\n+            --  Traverse a legal choice expression, looking for\n+            --  values/ranges of discrete parts. Call Update_Result\n+            --  for each.\n+\n+            ---------------------\n+            -- Traverse_Choice --\n+            ---------------------\n+\n+            procedure Traverse_Choice (Expr : Node_Id) is\n+            begin\n+               if Nkind (Expr) = N_Qualified_Expression then\n+                  Traverse_Choice (Expression (Expr));\n+\n+               elsif Nkind (Expr) = N_Type_Conversion\n+                  and then not Comes_From_Source (Expr)\n+               then\n+                  if Expr /= Original_Node (Expr) then\n+                     Traverse_Choice (Original_Node (Expr));\n+                  else\n+                     Traverse_Choice (Expression (Expr));\n+                  end if;\n+\n+               elsif Nkind (Expr) = N_Aggregate then\n+                  if Is_Record_Type (Etype (Expr)) then\n+                     Refresh_Binding_Info (Aggr => Expr);\n+\n+                     declare\n+                        Comp : Node_Id :=\n+                          First (Component_Associations (Expr));\n+                        --  Ok to assume that components are in order here?\n+                     begin\n+                        while Present (Comp) loop\n+                           pragma Assert (List_Length (Choices (Comp)) = 1);\n+                           if Box_Present (Comp) then\n+                              declare\n+                                 Comp_Type : constant Entity_Id :=\n+                                   Etype (First (Choices (Comp)));\n+                              begin\n+                                 if Is_Discrete_Type (Comp_Type) then\n+                                    declare\n+                                       Low  : constant Node_Id :=\n+                                         Type_Low_Bound (Comp_Type);\n+                                       High : constant Node_Id :=\n+                                         Type_High_Bound (Comp_Type);\n+                                    begin\n+                                       Update_Result\n+                                         ((Low  => Expr_Value (Low),\n+                                           High => Expr_Value (High)));\n+                                    end;\n+                                 else\n+                                    --  Need to recursively traverse type\n+                                    --  here, calling Update_Result for\n+                                    --  each discrete subcomponent.\n+\n+                                    Error_Msg_N\n+                                      (\"box values for nondiscrete pattern \"\n+                                       & \"subcomponents unimplemented\", Comp);\n+                                 end if;\n+                              end;\n+                           else\n+                              Traverse_Choice (Expression (Comp));\n+                           end if;\n+\n+                           if Binding_Chars (Comp) /= No_Name\n+                           then\n+                              Case_Bindings.Note_Binding\n+                                (Comp_Assoc => Comp,\n+                                 Choice     => Choice,\n+                                 Alt        => Alt);\n+                           end if;\n+\n+                           Next (Comp);\n+                        end loop;\n+                     end;\n+                  elsif Is_Array_Type (Etype (Expr)) then\n+                     if Is_Non_Empty_List (Component_Associations (Expr)) then\n+                        Error_Msg_N\n+                          (\"non-positional array aggregate as/within case \"\n+                           & \"choice not implemented\", Expr);\n+                     end if;\n+\n+                     declare\n+                        Subexpr : Node_Id := First (Expressions (Expr));\n+                     begin\n+                        while Present (Subexpr) loop\n+                           Traverse_Choice (Subexpr);\n+                           Next (Subexpr);\n+                        end loop;\n+                     end;\n+                  else\n+                     raise Program_Error;\n+                  end if;\n+               elsif Is_Discrete_Type (Etype (Expr)) then\n+                  if Nkind (Expr) in N_Has_Entity and then\n+                    Is_Type (Entity (Expr))\n+                  then\n+                     declare\n+                        Low  : constant Node_Id :=\n+                          Type_Low_Bound (Entity (Expr));\n+                        High : constant Node_Id :=\n+                          Type_High_Bound (Entity (Expr));\n+                     begin\n+                        Update_Result ((Low  => Expr_Value (Low),\n+                                        High => Expr_Value (High)));\n+                     end;\n+                  else\n+                     pragma Assert (Compile_Time_Known_Value (Expr));\n+                     Update_Result ((Low | High => Expr_Value (Expr)));\n+                  end if;\n+               else\n+                  Error_Msg_N\n+                    (\"non-aggregate case choice subexpression which is not\"\n+                     & \" of a discrete type not implemented\", Expr);\n+               end if;\n+            end Traverse_Choice;\n+\n+         begin\n+            if Nkind (Choice) = N_Others_Choice then\n+               return (Is_Others => True);\n+            end if;\n+            Traverse_Choice (Choice);\n+\n+            --  Avoid returning uninitialized garbage in error case\n+            if not Done then\n+               pragma Assert (Serious_Errors_Detected > 0);\n+               Result.Ranges := (others => (Low => Uint_1, High => Uint_0));\n+            end if;\n+\n+            return Result;\n+         end Parse_Choice;\n+\n+         package body Case_Bindings is\n+\n+            type Binding is record\n+               Comp_Assoc : Node_Id;\n+               Choice     : Node_Id;\n+               Alt        : Node_Id;\n+            end record;\n+\n+            type Binding_Index is new Natural;\n+\n+            package Case_Bindings_Table is new Table.Table\n+              (Table_Component_Type => Binding,\n+               Table_Index_Type     => Binding_Index,\n+               Table_Low_Bound      => 1,\n+               Table_Initial        => 16,\n+               Table_Increment      => 64,\n+               Table_Name           => \"Composite_Case_Ops.Case_Bindings\");\n+\n+            ------------------\n+            -- Note_Binding --\n+            ------------------\n+\n+            procedure Note_Binding\n+              (Comp_Assoc : Node_Id;\n+               Choice     : Node_Id;\n+               Alt        : Node_Id)\n+            is\n+            begin\n+               Case_Bindings_Table.Append\n+                 ((Comp_Assoc => Comp_Assoc,\n+                   Choice     => Choice,\n+                   Alt        => Alt));\n+            end Note_Binding;\n+\n+            --------------------\n+            -- Check_Bindings --\n+            --------------------\n+\n+            procedure Check_Bindings\n+            is\n+               use Case_Bindings_Table;\n+            begin\n+               if Last = 0 then\n+                  --  no bindings to check\n+                  return;\n+               end if;\n+\n+               declare\n+                  Tab : Table_Type\n+                          renames Case_Bindings_Table.Table (1 .. Last);\n+\n+                  function Same_Id (Idx1, Idx2 : Binding_Index)\n+                    return Boolean is (\n+                    Binding_Chars (Tab (Idx1).Comp_Assoc) =\n+                    Binding_Chars (Tab (Idx2).Comp_Assoc));\n+\n+                  function Binding_Subtype (Idx : Binding_Index)\n+                    return Entity_Id is\n+                    (Etype (Nlists.First (Choices (Tab (Idx).Comp_Assoc))));\n+               begin\n+                  --  Verify that elements with given choice or alt value\n+                  --  are contiguous, and that elements with equal\n+                  --  choice values have same alt value.\n+\n+                  for Idx1 in 2 .. Tab'Last loop\n+                     if Tab (Idx1 - 1).Choice /= Tab (Idx1).Choice then\n+                        pragma Assert\n+                          (for all Idx2 in Idx1 + 1 .. Tab'Last =>\n+                             Tab (Idx2).Choice /= Tab (Idx1 - 1).Choice);\n+                     else\n+                        pragma Assert (Tab (Idx1 - 1).Alt = Tab (Idx1).Alt);\n+                     end if;\n+                     if Tab (Idx1 - 1).Alt /= Tab (Idx1).Alt then\n+                        pragma Assert\n+                          (for all Idx2 in Idx1 + 1 .. Tab'Last =>\n+                             Tab (Idx2).Alt /= Tab (Idx1 - 1).Alt);\n+                     end if;\n+                  end loop;\n+\n+                  --  Check for user errors:\n+                  --  1) Two choices for a given alternative shall define the\n+                  --     same set of names. Can't have\n+                  --        when (<X>, 0) | (0, <Y>) =>\n+                  --  2) A choice shall not define a name twice. Can't have\n+                  --        when (A => <X>, B => <X>, C => 0) =>\n+                  --  3) Two definitions of a name within one alternative\n+                  --     shall have statically matching component subtypes.\n+                  --     Can't have\n+                  --        type R is record Int : Integer;\n+                  --                         Nat : Natural; end record;\n+                  --        case R'(...) is\n+                  --          when (<X>, 1) | (1, <X>) =>\n+                  --  4) A given binding shall match only one value.\n+                  --     Can't have\n+                  --         (Fld1 | Fld2 => (Fld => <X>))\n+                  --     For now, this is enforced *very* conservatively\n+                  --     with respect to arrays - a binding cannot match\n+                  --     any part of an array. This is temporary.\n+\n+                  for Idx1 in Tab'Range loop\n+                     if Idx1 = 1\n+                       or else Tab (Idx1 - 1).Alt /= Tab (Idx1).Alt\n+                     then\n+                        --  Process one alternative\n+                        declare\n+                           Alt_Start : constant Binding_Index := Idx1;\n+                           Alt : constant Node_Id := Tab (Alt_Start).Alt;\n+\n+                           First_Choice : constant Node_Id :=\n+                             Nlists.First (Discrete_Choices (Alt));\n+                           First_Choice_Bindings : Natural := 0;\n+                        begin\n+                           --  Check for duplicates within one choice,\n+                           --  and for choices with no bindings.\n+\n+                           if First_Choice /= Tab (Alt_Start).Choice then\n+                              Error_Msg_N (\"binding(s) missing for choice\",\n+                                           First_Choice);\n+                              return;\n+                           end if;\n+\n+                           declare\n+                              Current_Choice : Node_Id := First_Choice;\n+                              Choice_Start : Binding_Index := Alt_Start;\n+                           begin\n+                              for Idx2 in Alt_Start .. Tab'Last loop\n+                                 exit when Tab (Idx2).Alt /= Alt;\n+                                 if Tab (Idx2).Choice = Current_Choice then\n+                                    for Idx3 in Choice_Start .. Idx2 - 1 loop\n+                                       if Same_Id (Idx2, Idx3)\n+                                       then\n+                                          Error_Msg_N\n+                                            (\"duplicate binding in choice\",\n+                                             Current_Choice);\n+                                          return;\n+                                       end if;\n+                                    end loop;\n+                                 else\n+                                    Next (Current_Choice);\n+                                    pragma Assert (Present (Current_Choice));\n+                                    Choice_Start := Idx2;\n+\n+                                    if Tab (Idx2).Choice /= Current_Choice\n+                                    then\n+                                       Error_Msg_N\n+                                         (\"binding(s) missing for choice\",\n+                                          Current_Choice);\n+                                       return;\n+                                    end if;\n+                                 end if;\n+                              end loop;\n+\n+                              --  If we made it through all the bindings\n+                              --  for this alternative but didn't make it\n+                              --  to the last choice, then bindings are\n+                              --  missing for all remaining choices.\n+                              --  We only complain about the first one.\n+\n+                              if Present (Next (Current_Choice)) then\n+                                 Error_Msg_N\n+                                   (\"binding(s) missing for choice\",\n+                                     Next (Current_Choice));\n+                                 return;\n+                              end if;\n+                           end;\n+\n+                           --  Count bindings for first choice of alternative\n+\n+                           for FC_Idx in Alt_Start .. Tab'Last loop\n+                              exit when Tab (FC_Idx).Choice /= First_Choice;\n+                              First_Choice_Bindings :=\n+                                First_Choice_Bindings + 1;\n+                           end loop;\n+\n+                           declare\n+                              Current_Choice : Node_Id := First_Choice;\n+                              Current_Choice_Bindings : Natural := 0;\n+                           begin\n+                              for Idx2 in Alt_Start .. Tab'Last loop\n+                                 exit when Tab (Idx2).Alt /= Alt;\n+\n+                                 --  If starting a new choice\n+\n+                                 if Tab (Idx2).Choice /= Current_Choice then\n+\n+                                    --  Check count for choice just finished\n+\n+                                    if Current_Choice_Bindings\n+                                      /= First_Choice_Bindings\n+                                    then\n+                                       Error_Msg_N\n+                                         (\"subsequent choice has different\"\n+                                          & \" number of bindings than first\"\n+                                          & \" choice\", Current_Choice);\n+                                    end if;\n+\n+                                    Current_Choice := Tab (Idx2).Choice;\n+                                    Current_Choice_Bindings := 1;\n+\n+                                    --  Remember that Alt has both one or more\n+                                    --  bindings and two or more choices; we'll\n+                                    --  need to know this during expansion.\n+\n+                                    Set_Multidefined_Bindings (Alt, True);\n+                                 else\n+                                    Current_Choice_Bindings :=\n+                                      Current_Choice_Bindings + 1;\n+                                 end if;\n+\n+                                 --  Check that first choice has binding with\n+                                 --  matching name; check subtype consistency.\n+\n+                                 declare\n+                                    Found : Boolean := False;\n+                                 begin\n+                                    for FC_Idx in\n+                                      Alt_Start ..\n+                                      Alt_Start + Binding_Index\n+                                                    (First_Choice_Bindings - 1)\n+                                    loop\n+                                       if Same_Id (Idx2, FC_Idx) then\n+                                          if not Subtypes_Statically_Match\n+                                            (Binding_Subtype (Idx2),\n+                                             Binding_Subtype (FC_Idx))\n+                                          then\n+                                             Error_Msg_N\n+                                               (\"subtype of binding in \"\n+                                                & \"subsequent choice does not \"\n+                                                & \"match that in first choice\",\n+                                                Tab (Idx2).Comp_Assoc);\n+                                          end if;\n+                                          Found := True;\n+                                          exit;\n+                                       end if;\n+                                    end loop;\n+\n+                                    if not Found then\n+                                       Error_Msg_N\n+                                         (\"binding defined in subsequent \"\n+                                          & \"choice not defined in first \"\n+                                          & \"choice\", Current_Choice);\n+                                    end if;\n+                                 end;\n+\n+                                 --  Check for illegal repeated binding\n+                                 --  via an enclosing aggregate, as in\n+                                 --  (F1 | F2 => (F3 => Natural is X,\n+                                 --               F4 => Natural))\n+                                 --  where the inner aggregate would be ok.\n+\n+                                 declare\n+                                    Rover : Node_Id := Tab (Idx2).Comp_Assoc;\n+                                 begin\n+                                    while Rover /= Tab (Idx2).Choice loop\n+                                       Rover :=\n+                                         (if Is_List_Member (Rover) then\n+                                            Parent (List_Containing (Rover))\n+                                          else Parent (Rover));\n+                                       pragma Assert (Present (Rover));\n+                                       if Nkind (Rover)\n+                                         = N_Component_Association\n+                                         and then List_Length (Choices (Rover))\n+                                         > 1\n+                                       then\n+                                          Error_Msg_N\n+                                            (\"binding shared by multiple \"\n+                                                & \"enclosing components\",\n+                                             Tab (Idx2).Comp_Assoc);\n+                                       end if;\n+                                    end loop;\n+                                 end;\n+                              end loop;\n+                           end;\n+\n+                           --  Construct the (unanalyzed) declarations for\n+                           --  the current alternative. Then analyze them.\n+\n+                           if First_Choice_Bindings > 0 then\n+                              declare\n+                                 Loc : constant Source_Ptr := Sloc (Alt);\n+                                 Declarations : constant List_Id := New_List;\n+                                 Decl         : Node_Id;\n+                              begin\n+                                 for FC_Idx in\n+                                   Alt_Start ..\n+                                   Alt_Start +\n+                                     Binding_Index (First_Choice_Bindings - 1)\n+                                 loop\n+                                    Decl := Make_Object_Declaration\n+                                      (Sloc => Loc,\n+                                       Defining_Identifier =>\n+                                         Make_Defining_Identifier\n+                                           (Loc,\n+                                            Binding_Chars\n+                                              (Tab (FC_Idx).Comp_Assoc)),\n+                                        Object_Definition =>\n+                                          New_Occurrence_Of\n+                                            (Binding_Subtype (FC_Idx), Loc));\n+\n+                                    Append_To (Declarations, Decl);\n+                                 end loop;\n+\n+                                 declare\n+                                    Old_Statements : constant List_Id :=\n+                                      Statements (Alt);\n+                                    New_Statements : constant List_Id :=\n+                                      New_List;\n+\n+                                    Block_Statement : constant Node_Id :=\n+                                      Make_Block_Statement (Sloc => Loc,\n+                                        Declarations => Declarations,\n+                                        Handled_Statement_Sequence =>\n+                                          Make_Handled_Sequence_Of_Statements\n+                                            (Loc, Old_Statements),\n+                                        Has_Created_Identifier => True);\n+                                 begin\n+                                    Append_To\n+                                      (New_Statements, Block_Statement);\n+\n+                                    Set_Statements (Alt, New_Statements);\n+                                 end;\n+                              end;\n+                           end if;\n+                        end;\n+                     end if;\n+                  end loop;\n+               end;\n+            end Check_Bindings;\n+         end Case_Bindings;\n+\n+         function Choice_Bounds_Info return Choices_Range_Info;\n+         --  Returns mapping from any given Choice_Id value to that choice's\n+         --  component-to-range map.\n+\n+         ------------------------\n+         -- Choice_Bounds_Info --\n+         ------------------------\n+\n+         function Choice_Bounds_Info return Choices_Range_Info is\n+            Result : Choices_Range_Info;\n+            Alt    : Node_Id := First (Alternatives (Case_Statement));\n+            C_Id   : Choice_Id := 1;\n+         begin\n+            while Present (Alt) loop\n+               declare\n+                  Choice : Node_Id := First (Discrete_Choices (Alt));\n+               begin\n+                  while Present (Choice) loop\n+                     Result (C_Id) := Parse_Choice (Choice, Alt => Alt);\n+\n+                     Next (Choice);\n+                     if C_Id /= Choice_Id'Last then\n+                        C_Id := C_Id + 1;\n+                     end if;\n+                  end loop;\n+               end;\n+               Next (Alt);\n+            end loop;\n+\n+            pragma Assert (C_Id = Choice_Id'Last);\n+\n+            --  No more calls to Note_Binding, so time for checks.\n+            Case_Bindings.Check_Bindings;\n+\n+            return Result;\n+         end Choice_Bounds_Info;\n+\n+         Choices_Bounds : constant Choices_Range_Info := Choice_Bounds_Info;\n+\n+         package body Value_Sets is\n+            use GNAT;\n+\n+            function Hash (Key : Uint) return Bucket_Range_Type is\n+              (Bucket_Range_Type\n+                 (UI_To_Int (Key mod (Uint_2 ** Uint_31))));\n+\n+            package Uint_Sets is new GNAT.Sets.Membership_Sets\n+              (Uint, \"=\", Hash);\n+\n+            type Representative_Values_Array is\n+              array (Part_Id) of Uint_Sets.Membership_Set;\n+\n+            function Representative_Values_Init\n+              return Representative_Values_Array;\n+            --  Select the representative values for each Part_Id value.\n+            --  This function is called exactly once, immediately after it\n+            --  is declared.\n+\n+            --------------------------------\n+            -- Representative_Values_Init --\n+            --------------------------------\n+\n+            function Representative_Values_Init\n+              return Representative_Values_Array\n+            is\n+               --  For each range of each choice (as well as the range for the\n+               --  component subtype, which is handled in the first loop),\n+               --  insert the low bound of the range and the successor of\n+               --  the high bound into the corresponding R_V element.\n+               --\n+               --  The idea we are trying to capture here is somewhat tricky.\n+               --  Given an arbitrary point P1 in the Cartesian product\n+               --  of the Component_Bounds sets, we want to be able\n+               --  to map that to a point P2 in the (smaller) Cartesian product\n+               --  of the Representative_Values sets that has the property\n+               --  that for every choice of the case statement, P1 matches\n+               --  the choice if and only if P2 also matches. Given that,\n+               --  we can implement the overlapping/containment/etc. rules\n+               --  safely by just looking at (using brute force enumeration)\n+               --  the (smaller) Cartesian product of the R_V sets.\n+               --  We are never going to actually perform this point-to-point\n+               --  mapping - just the fact that it exists is enough to ensure\n+               --  we can safely look at just the R_V sets.\n+               --\n+               --  The desired mapping can be implemented by mapping a point\n+               --  P1 to a point P2 by reducing each of P1's coordinates down\n+               --  to the largest element of the corresponding R_V set that is\n+               --  less than or equal to the original coordinate value (such\n+               --  an element Y will always exist because the R_V set for a\n+               --  given component always includes the low bound of the\n+               --  component subtype). It then suffices to show that every\n+               --  choice in the case statement yields the same Boolean result\n+               --  for P1 as for P2.\n+               --\n+               --  Suppose the contrary. Then there is some particular\n+               --  coordinate position X (i.e., a Part_Id value) and some\n+               --  choice C where exactly one of P1(X) and P2(X) belongs to\n+               --  the (contiguous) range associated with C(X); call that\n+               --  range L .. H. We know that P2(X) <= P1(X) because the\n+               --  mapping never increases coordinate values. Consider three\n+               --  cases: P1(X) lies within the L .. H range, or it is greater\n+               --  than H, or it is lower than L.\n+               --  The third case is impossible because reducing a value that\n+               --  is less than L can only produce another such value,\n+               --  violating the \"exactly one\" assumption. The second\n+               --  case is impossible because L belongs to the corresponding\n+               --  R_V set, so P2(X) >= L and both values belong to the\n+               --  range, again violating the \"exactly one\" assumption.\n+               --  Finally, the third case is impossible because H+1 belongs\n+               --  to the corresponding R_V set, so P2(X) > H, so neither\n+               --  value belongs to the range, again violating the \"exactly\n+               --  one\" assumption. So our initial supposition was wrong. QED.\n+\n+               use Uint_Sets;\n+\n+               Result : constant Representative_Values_Array\n+                 := (others => Uint_Sets.Create (Initial_Size => 32));\n+\n+               procedure Insert_Representative (Value : Uint; P : Part_Id);\n+               --  Insert the given Value into the representative values set\n+               --  for the given component if it belongs to the component's\n+               --  subtype. Otherwise, do nothing.\n+\n+               ---------------------------\n+               -- Insert_Representative --\n+               ---------------------------\n+\n+               procedure Insert_Representative (Value : Uint; P : Part_Id) is\n+               begin\n+                  if Value >= Component_Bounds (P).Low and\n+                    Value <= Component_Bounds (P).High\n+                  then\n+                     Insert (Result (P), Value);\n+                  end if;\n+               end Insert_Representative;\n+\n+            begin\n+               for P in Part_Id loop\n+                  Insert_Representative (Component_Bounds (P).Low, P);\n+               end loop;\n+               for C of Choices_Bounds loop\n+                  if not C.Is_Others then\n+                     for P in Part_Id loop\n+                        if C.Ranges (P).Low <= C.Ranges (P).High then\n+                           Insert_Representative (C.Ranges (P).Low, P);\n+                           Insert_Representative (C.Ranges (P).High + 1, P);\n+                        end if;\n+                     end loop;\n+                  end if;\n+               end loop;\n+               return Result;\n+            end Representative_Values_Init;\n+\n+            Representative_Values : constant Representative_Values_Array\n+              := Representative_Values_Init;\n+            --  We want to avoid looking at every point in the Cartesian\n+            --  product of all component values. Instead we select, for each\n+            --  component, a set of representative values and then look only\n+            --  at the Cartesian product of those sets. A single value can\n+            --  safely represent a larger enclosing interval if every choice\n+            --  for that component either completely includes or completely\n+            --  excludes the interval. The elements of this array will be\n+            --  populated by a call to Initialize_Representative_Values and\n+            --  will remain constant after that.\n+\n+            type Value_Index_Base is new Natural;\n+\n+            function Value_Index_Count return Value_Index_Base;\n+            --  Returns the product of the sizes of the Representative_Values\n+            --  sets (i.e., the size of the Cartesian product of the sets).\n+            --  May return zero if one of the sets is empty.\n+            --  This function is called exactly once, immediately after it\n+            --  is declared.\n+\n+            -----------------------\n+            -- Value_Index_Count --\n+            -----------------------\n+\n+            function Value_Index_Count return Value_Index_Base is\n+               Result : Value_Index_Base := 1;\n+            begin\n+               for Set of Representative_Values loop\n+                  Result := Result * Value_Index_Base (Uint_Sets.Size (Set));\n+               end loop;\n+               return Result;\n+            end Value_Index_Count;\n+\n+            Max_Value_Index : constant Value_Index_Base := Value_Index_Count;\n+\n+            subtype Value_Index is Value_Index_Base range 1 .. Max_Value_Index;\n+            type Value_Index_Set is array (Value_Index) of Boolean;\n+\n+            package Value_Index_Set_Table is new Table.Table\n+              (Table_Component_Type => Value_Index_Set,\n+               Table_Index_Type     => Value_Set,\n+               Table_Low_Bound      => 1,\n+               Table_Initial        => 16,\n+               Table_Increment      => 100,\n+               Table_Name           => \"Composite_Case_Ops.Value_Sets\");\n+            --  A nonzero Value_Set value is an index into this table.\n+\n+            function Indexed (Index : Value_Set) return Value_Index_Set\n+              is (Value_Index_Set_Table.Table.all (Index));\n+\n+            function Allocate_Table_Element (Initial_Value : Value_Index_Set)\n+              return Value_Set;\n+            --  Allocate and initialize a new table element; return its index.\n+\n+            ----------------------------\n+            -- Allocate_Table_Element --\n+            ----------------------------\n+\n+            function Allocate_Table_Element (Initial_Value : Value_Index_Set)\n+              return Value_Set\n+            is\n+               use Value_Index_Set_Table;\n+            begin\n+               Append (Initial_Value);\n+               return Last;\n+            end Allocate_Table_Element;\n+\n+            procedure Assign_Table_Element (Index : Value_Set;\n+                                            Value : Value_Index_Set);\n+            --  Assign specified value to specified table element.\n+\n+            --------------------------\n+            -- Assign_Table_Element --\n+            --------------------------\n+\n+            procedure Assign_Table_Element (Index : Value_Set;\n+                                            Value : Value_Index_Set)\n+            is\n+            begin\n+               Value_Index_Set_Table.Table.all (Index) := Value;\n+            end Assign_Table_Element;\n+\n+            -------------\n+            -- Compare --\n+            -------------\n+\n+            function Compare (S1, S2 : Value_Set) return Set_Comparison is\n+            begin\n+               if S1 = Empty or S2 = Empty then\n+                  return Disjoint;\n+               elsif Indexed (S1) = Indexed (S2) then\n+                  return Equal;\n+               else\n+                  declare\n+                     Intersection : constant Value_Index_Set\n+                       := Indexed (S1) and Indexed (S2);\n+                  begin\n+                     if (for all Flag of Intersection => not Flag) then\n+                        return Disjoint;\n+                     elsif Intersection = Indexed (S1) then\n+                        return Contained_By;\n+                     elsif Intersection = Indexed (S2) then\n+                        return Contains;\n+                     else\n+                        return Overlaps;\n+                     end if;\n+                  end;\n+               end if;\n+            end Compare;\n+\n+            -------------------------\n+            -- Complement_Is_Empty --\n+            -------------------------\n+\n+            function Complement_Is_Empty (Set : Value_Set) return Boolean\n+              is (Set /= Empty\n+                  and then (for all Flag of Indexed (Set) => Flag));\n+\n+            ---------------------\n+            -- Free_Value_Sets --\n+            ---------------------\n+            procedure Free_Value_Sets is\n+            begin\n+               Value_Index_Set_Table.Free;\n+            end Free_Value_Sets;\n+\n+            -----------\n+            -- Union --\n+            -----------\n+\n+            procedure Union (Target : in out Value_Set; Source : Value_Set) is\n+            begin\n+               if Source /= Empty then\n+                  if Target = Empty then\n+                     Target := Allocate_Table_Element (Indexed (Source));\n+                  else\n+                     Assign_Table_Element\n+                       (Target, Indexed (Target) or Indexed (Source));\n+                  end if;\n+               end if;\n+            end Union;\n+\n+            ------------\n+            -- Remove --\n+            ------------\n+\n+            procedure Remove (Target : in out Value_Set; Source : Value_Set) is\n+            begin\n+               if Source /= Empty and Target /= Empty then\n+                  Assign_Table_Element\n+                    (Target, Indexed (Target) and not Indexed (Source));\n+                  if (for all V of Indexed (Target) => not V) then\n+                     Target := Empty;\n+                  end if;\n+               end if;\n+            end Remove;\n+\n+            ---------------------\n+            -- Matching_Values --\n+            ---------------------\n+\n+            function Matching_Values\n+              (Info : Composite_Range_Info) return Value_Set\n+            is\n+               Matches    : Value_Index_Set;\n+               Next_Index : Value_Index := 1;\n+               Done       : Boolean := False;\n+               Point      : array (Part_Id) of Uint;\n+\n+               procedure Test_Point_For_Match;\n+               --  Point identifies a point in the Cartesian product of the\n+               --  representative value sets. Record whether that Point\n+               --  belongs to the product-of-ranges specified by Info.\n+\n+               --------------------------\n+               -- Test_Point_For_Match --\n+               --------------------------\n+\n+               procedure Test_Point_For_Match is\n+                  function In_Range (Val : Uint; Rang : Discrete_Range_Info)\n+                    return Boolean is\n+                    ((Rang.Low <= Val) and then (Val <= Rang.High));\n+               begin\n+                  pragma Assert (not Done);\n+                  Matches (Next_Index) :=\n+                    (for all P in Part_Id => In_Range (Point (P), Info (P)));\n+                  if Next_Index = Matches'Last then\n+                     Done := True;\n+                  else\n+                     Next_Index := Next_Index + 1;\n+                  end if;\n+               end Test_Point_For_Match;\n+\n+               procedure Test_Points (P : Part_Id);\n+               --  Iterate over the Cartesian product of the representative\n+               --  value sets, calling Test_Point_For_Match for each point.\n+\n+               -----------------\n+               -- Test_Points --\n+               -----------------\n+\n+               procedure Test_Points (P : Part_Id) is\n+                  use Uint_Sets;\n+                  Iter : Iterator := Iterate (Representative_Values (P));\n+               begin\n+                  --  We could traverse here in sorted order, as opposed to\n+                  --  whatever order the set iterator gives us.\n+                  --  No need for that as long as every iteration over\n+                  --  a given representative values set yields the same order.\n+                  --  Not sorting is more efficient, but it makes it harder to\n+                  --  interpret a Value_Index_Set bit vector when debugging.\n+\n+                  while Has_Next (Iter) loop\n+                     Next (Iter, Point (P));\n+\n+                     --  If we have finished building up a Point value, then\n+                     --  test it for matching. Otherwise, recurse to continue\n+                     --  building up a point value.\n+\n+                     if P = Part_Id'Last then\n+                        Test_Point_For_Match;\n+                     else\n+                        Test_Points (P + 1);\n+                     end if;\n+                  end loop;\n+               end Test_Points;\n+\n+            begin\n+               Test_Points (1);\n+               if (for all Flag of Matches => not Flag) then\n+                  return Empty;\n+               end if;\n+               return Allocate_Table_Element (Matches);\n+            end Matching_Values;\n+\n+         end Value_Sets;\n+\n+         --------------\n+         -- Analysis --\n+         --------------\n+\n+         function Analysis return Choices_Info is\n+            Result : Choices_Info;\n+            Alt    : Node_Id := First (Alternatives (Case_Statement));\n+            A_Id   : Alternative_Id := 1;\n+            C_Id   : Choice_Id := 1;\n+         begin\n+            while Present (Alt) loop\n+               declare\n+                  Choice : Node_Id := First (Discrete_Choices (Alt));\n+               begin\n+                  while Present (Choice) loop\n+                     if Nkind (Choice) = N_Others_Choice then\n+                        pragma Assert (Choices_Bounds (C_Id).Is_Others);\n+                        Result (C_Id) :=\n+                          (Alternative => A_Id,\n+                           Is_Others   => True);\n+                     else\n+                        Result (C_Id) :=\n+                          (Alternative => A_Id,\n+                           Is_Others   => False,\n+                           Matches     => Value_Sets.Matching_Values\n+                                            (Choices_Bounds (C_Id).Ranges));\n+                     end if;\n+                     Next (Choice);\n+                     if C_Id /= Choice_Id'Last then\n+                        C_Id := C_Id + 1;\n+                     end if;\n+                  end loop;\n+               end;\n+\n+               Next (Alt);\n+               if A_Id /= Alternative_Id'Last then\n+                  A_Id := A_Id + 1;\n+               end if;\n+            end loop;\n+\n+            pragma Assert (A_Id = Alternative_Id'Last);\n+            pragma Assert (C_Id = Choice_Id'Last);\n+\n+            return Result;\n+         end Analysis;\n+\n+      end Choice_Analysis;\n+\n+   end Composite_Case_Ops;\n+\n    --------------------------\n    -- Expand_Others_Choice --\n    --------------------------\n@@ -1379,6 +2662,15 @@ package body Sem_Case is\n          --  later entry into the choices table so that they can be sorted\n          --  later on.\n \n+         procedure Check_Case_Pattern_Choices;\n+         --  Check choices validity for the Ada extension case where the\n+         --  selecting expression is not of a discrete type and so the\n+         --  choices are patterns.\n+\n+         procedure Check_Composite_Case_Selector;\n+         --  Check that the (non-discrete) type of the expression being\n+         --  cased on is suitable.\n+\n          procedure Handle_Static_Predicate\n            (Typ : Entity_Id;\n             Lo  : Node_Id;\n@@ -1500,6 +2792,195 @@ package body Sem_Case is\n             Num_Choices := Num_Choices + 1;\n          end Check;\n \n+         --------------------------------\n+         -- Check_Case_Pattern_Choices --\n+         --------------------------------\n+\n+         procedure Check_Case_Pattern_Choices is\n+            --  ??? Need to Free/Finalize value sets allocated here.\n+\n+            package Ops is new Composite_Case_Ops.Choice_Analysis\n+              (Case_Statement => N);\n+            use Ops;\n+            use Ops.Value_Sets;\n+\n+            Empty : Value_Set renames Value_Sets.Empty;\n+            --  Cope with hiding due to multiple use clauses\n+\n+            Info        : constant Choices_Info := Analysis;\n+            Others_Seen : Boolean := False;\n+\n+         begin\n+            declare\n+               Matches : array (Alternative_Id) of Value_Sets.Value_Set :=\n+                 (others => Empty);\n+\n+               Flag_Overlapping_Within_One_Alternative : constant Boolean :=\n+                 False;\n+               --  We may want to flag overlapping (perhaps with only a\n+               --  warning) if the pattern binds an identifier, as in\n+               --    when (Positive, <X>) | (Integer, <X>) =>\n+\n+               Covered : Value_Set := Empty;\n+               --  The union of all alternatives seen so far\n+\n+            begin\n+               for Choice of Info loop\n+                  if Choice.Is_Others then\n+                     Others_Seen := True;\n+                  else\n+                     if Flag_Overlapping_Within_One_Alternative\n+                        and then (Compare (Matches (Choice.Alternative),\n+                                  Choice.Matches) /= Disjoint)\n+                     then\n+                        Error_Msg_N\n+                          (\"bad overlapping within one alternative\", N);\n+                     end if;\n+\n+                     Union (Target => Matches (Choice.Alternative),\n+                            Source => Choice.Matches);\n+                  end if;\n+               end loop;\n+\n+               for A1 in Alternative_Id loop\n+                  for A2 in Alternative_Id\n+                              range A1 + 1 .. Alternative_Id'Last\n+                  loop\n+                     case Compare (Matches (A1), Matches (A2)) is\n+                        when Disjoint | Contained_By =>\n+                           null; -- OK\n+                        when Overlaps =>\n+                           declare\n+                              Uncovered_1, Uncovered_2 : Value_Set := Empty;\n+                           begin\n+                              Union (Uncovered_1, Matches (A1));\n+                              Remove (Uncovered_1, Covered);\n+                              Union (Uncovered_2, Matches (A2));\n+                              Remove (Uncovered_2, Covered);\n+\n+                              --  Recheck for overlap after removing choices\n+                              --  covered by earlier alternatives.\n+\n+                              case Compare (Uncovered_1, Uncovered_2) is\n+                                 when Disjoint | Contained_By =>\n+                                    null;\n+                                 when Contains | Overlaps | Equal =>\n+                                    Error_Msg_N\n+                                      (\"bad alternative overlapping\", N);\n+                              end case;\n+                           end;\n+\n+                        when Equal =>\n+                           Error_Msg_N (\"alternatives match same values\", N);\n+                        when Contains =>\n+                           Error_Msg_N (\"alternatives in wrong order\", N);\n+                     end case;\n+                  end loop;\n+\n+                  Union (Target => Covered, Source => Matches (A1));\n+               end loop;\n+\n+               if (not Others_Seen) and then not Complement_Is_Empty (Covered)\n+               then\n+                  Error_Msg_N (\"not all values are covered\", N);\n+               end if;\n+            end;\n+\n+            Ops.Value_Sets.Free_Value_Sets;\n+         end Check_Case_Pattern_Choices;\n+\n+         -----------------------------------\n+         -- Check_Composite_Case_Selector --\n+         -----------------------------------\n+\n+         procedure Check_Composite_Case_Selector is\n+            --  Some of these restrictions will be relaxed eventually, but best\n+            --  to initially err in the direction of being too restrictive.\n+\n+            procedure Check_Component_Subtype (Subtyp : Entity_Id);\n+            --  Recursively traverse subcomponent types to perform checks.\n+\n+            -----------------------------\n+            -- Check_Component_Subtype --\n+            -----------------------------\n+\n+            procedure Check_Component_Subtype (Subtyp : Entity_Id) is\n+            begin\n+               if Has_Predicates (Subtyp) then\n+                  Error_Msg_N\n+                     (\"subtype of case selector (or subcomponent thereof)\" &\n+                      \"has predicate\", N);\n+               elsif Is_Discrete_Type (Subtyp) then\n+                  if not Is_Static_Subtype (Subtyp) then\n+                     Error_Msg_N\n+                       (\"discrete subtype of selector subcomponent is not \" &\n+                        \"a static subtype\", N);\n+                  elsif Is_Enumeration_Type (Subtyp)\n+                    and then Has_Enumeration_Rep_Clause (Subtyp)\n+                  then\n+                     Error_Msg_N\n+                       (\"enumeration type of selector subcomponent has \" &\n+                        \"an enumeration representation clause\", N);\n+                  end if;\n+               elsif Is_Array_Type (Subtyp) then\n+                  pragma Assert (Is_Constrained (Subtyp));\n+\n+                  if Number_Dimensions (Subtyp) /= 1 then\n+                     Error_Msg_N\n+                       (\"dimensionality of array type of case selector (or \" &\n+                        \"subcomponent thereof) is greater than 1\", N);\n+                  elsif not Is_OK_Static_Range (First_Index (Subtyp)) then\n+                     Error_Msg_N\n+                       (\"array subtype of case selector (or \" &\n+                        \"subcomponent thereof) has nonstatic constraint\", N);\n+                  end if;\n+                  Check_Component_Subtype (Component_Type (Subtyp));\n+               elsif Is_Record_Type (Subtyp) then\n+                  if Has_Discriminants (Subtyp) then\n+                     Error_Msg_N\n+                        (\"type of case selector (or subcomponent thereof)\" &\n+                         \"is discriminated\", N);\n+                  else\n+                     declare\n+                        Comp : Entity_Id := First_Component (Subtyp);\n+                     begin\n+                        while Present (Comp) loop\n+                           Check_Component_Subtype (Etype (Comp));\n+                           Next_Component (Comp);\n+                        end loop;\n+                     end;\n+                  end if;\n+               else\n+                  Error_Msg_N\n+                    (\"type of case selector (or subcomponent thereof) is \" &\n+                     \"not a discrete type, a record type, or an array type\",\n+                     N);\n+               end if;\n+            end Check_Component_Subtype;\n+\n+         begin\n+            if not Is_Composite_Type (Subtyp) then\n+               Error_Msg_N\n+                 (\"case selector type neither discrete nor composite\", N);\n+\n+            elsif Is_Limited_Type (Subtyp) then\n+               Error_Msg_N (\"case selector type is limited\", N);\n+\n+            elsif Is_Class_Wide_Type (Subtyp) then\n+               Error_Msg_N (\"case selector type is class-wide\", N);\n+\n+            elsif Needs_Finalization (Subtyp) then\n+               Error_Msg_N (\"case selector type requires finalization\", N);\n+\n+            elsif Is_Array_Type (Subtyp) and not Is_Constrained (Subtyp) then\n+               Error_Msg_N\n+                 (\"case selector subtype is unconstrained array subtype\", N);\n+\n+            else\n+               Check_Component_Subtype (Subtyp);\n+            end if;\n+         end Check_Composite_Case_Selector;\n+\n          -----------------------------\n          -- Handle_Static_Predicate --\n          -----------------------------\n@@ -1562,6 +3043,14 @@ package body Sem_Case is\n          --  a complete mess.\n \n          if not Is_Discrete_Type (Subtyp) or else Subtyp = Any_Type then\n+\n+            --  Hold on, maybe it isn't a complete mess after all.\n+\n+            if Extensions_Allowed and then Subtyp /= Any_Type then\n+               Check_Composite_Case_Selector;\n+               Check_Case_Pattern_Choices;\n+            end if;\n+\n             return;\n          end if;\n \n@@ -1809,4 +3298,37 @@ package body Sem_Case is\n \n    end Generic_Check_Choices;\n \n+   ----------------------------\n+   -- Is_Case_Choice_Pattern --\n+   ----------------------------\n+\n+   function Is_Case_Choice_Pattern (Expr : Node_Id) return Boolean is\n+      E : Node_Id := Expr;\n+   begin\n+      if not Extensions_Allowed then\n+         return False;\n+      end if;\n+\n+      loop\n+         case Nkind (E) is\n+            when N_Case_Statement_Alternative\n+               | N_Case_Expression_Alternative\n+            =>\n+               --  We could return False if selecting expression is discrete,\n+               --  but this doesn't seem to be worth the bother.\n+               return True;\n+\n+            when N_Empty\n+               | N_Statement_Other_Than_Procedure_Call\n+               | N_Procedure_Call_Statement\n+               | N_Declaration\n+            =>\n+               return False;\n+\n+            when others =>\n+               E := Parent (E);\n+         end case;\n+      end loop;\n+   end Is_Case_Choice_Pattern;\n+\n end Sem_Case;"}, {"sha": "3943cf253b44e041aeac45d01abc418cfd5ec5a0", "filename": "gcc/ada/sem_case.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_case.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_case.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.ads?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -147,4 +147,10 @@ package Sem_Case is\n       --  the parent node (N_Variant, N_Case_Expression/Statement_Alternative).\n \n    end Generic_Check_Choices;\n+\n+   function Is_Case_Choice_Pattern (Expr : Node_Id) return Boolean;\n+   --  GNAT language extensions allow casing on a non-discrete value, with\n+   --  patterns as case choices. Return True iff Expr is such a pattern, or\n+   --  a subexpression thereof.\n+\n end Sem_Case;"}, {"sha": "4574ef986b93580dbd5ed7e50c9aa9629234bbf2", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -1412,6 +1412,9 @@ package body Sem_Ch5 is\n       --  the case statement, and as a result it is not a good idea to output\n       --  warning messages about unreachable code.\n \n+      Is_General_Case_Statement : Boolean := False;\n+      --  Set True (later) if type of case expression is not discrete\n+\n       procedure Non_Static_Choice_Error (Choice : Node_Id);\n       --  Error routine invoked by the generic instantiation below when the\n       --  case statement has a non static choice.\n@@ -1453,6 +1456,12 @@ package body Sem_Ch5 is\n          Ent     : Entity_Id;\n \n       begin\n+         if Is_General_Case_Statement then\n+            return;\n+            --  Processing deferred in this case; decls associated with\n+            --  pattern match bindings don't exist yet.\n+         end if;\n+\n          Unblocked_Exit_Count := Unblocked_Exit_Count + 1;\n          Statements_Analyzed := True;\n \n@@ -1527,6 +1536,35 @@ package body Sem_Ch5 is\n          Resolve (Exp);\n          Exp_Type := Full_View (Etype (Exp));\n \n+      --  For Ada, overloading might be ok because subsequently filtering\n+      --  out non-discretes may resolve the ambiguity.\n+      --  But GNAT extensions allow casing on non-discretes.\n+\n+      elsif Extensions_Allowed and then Is_Overloaded (Exp) then\n+\n+         --  TBD: Generate better ambiguity diagnostics here.\n+         --  It would be nice if we could generate all the right error\n+         --  messages by calling \"Resolve (Exp, Any_Type);\" in the\n+         --  same way that they are generated a few lines below by the\n+         --  call \"Analyze_And_Resolve (Exp, Any_Discrete);\".\n+         --  Unfortunately, Any_Type and Any_Discrete are not treated\n+         --  consistently (specifically, by Sem_Type.Covers), so that\n+         --  doesn't work.\n+\n+         Error_Msg_N\n+           (\"selecting expression of general case statement is ambiguous\",\n+            Exp);\n+         return;\n+\n+      --  Check for a GNAT-extension \"general\" case statement (i.e., one where\n+      --  the type of the selecting expression is not discrete).\n+\n+      elsif Extensions_Allowed\n+         and then not Is_Discrete_Type (Etype (Exp))\n+      then\n+         Resolve (Exp, Etype (Exp));\n+         Exp_Type := Etype (Exp);\n+         Is_General_Case_Statement := True;\n       else\n          Analyze_And_Resolve (Exp, Any_Discrete);\n          Exp_Type := Etype (Exp);\n@@ -1579,6 +1617,21 @@ package body Sem_Ch5 is\n       Analyze_Choices (Alternatives (N), Exp_Type);\n       Check_Choices (N, Alternatives (N), Exp_Type, Others_Present);\n \n+      if Is_General_Case_Statement then\n+         --  Work normally done in Process_Statements was deferred; do that\n+         --  deferred work now that Check_Choices has had a chance to create\n+         --  any needed pattern-match-binding declarations.\n+         declare\n+            Alt : Node_Id := First (Alternatives (N));\n+         begin\n+            while Present (Alt) loop\n+               Unblocked_Exit_Count := Unblocked_Exit_Count + 1;\n+               Analyze_Statements (Statements (Alt));\n+               Next (Alt);\n+            end loop;\n+         end;\n+      end if;\n+\n       if Exp_Type = Universal_Integer and then not Others_Present then\n          Error_Msg_N (\"case on universal integer requires OTHERS choice\", Exp);\n       end if;"}, {"sha": "32e71cc24f9fbcaff8e0c2429fc130c898796cf8", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -57,6 +57,7 @@ with Sem;            use Sem;\n with Sem_Aggr;       use Sem_Aggr;\n with Sem_Attr;       use Sem_Attr;\n with Sem_Aux;        use Sem_Aux;\n+with Sem_Case;       use Sem_Case;\n with Sem_Cat;        use Sem_Cat;\n with Sem_Ch3;        use Sem_Ch3;\n with Sem_Ch4;        use Sem_Ch4;\n@@ -7768,10 +7769,12 @@ package body Sem_Res is\n \n       --  Case of (sub)type name appearing in a context where an expression\n       --  is expected. This is legal if occurrence is a current instance.\n-      --  See RM 8.6 (17/3).\n+      --  See RM 8.6 (17/3). It is also legal if the expression is\n+      --  part of a choice pattern for a case stmt/expr having a\n+      --  non-discrete selecting expression.\n \n       elsif Is_Type (E) then\n-         if Is_Current_Instance (N) then\n+         if Is_Current_Instance (N) or else Is_Case_Choice_Pattern (N) then\n             null;\n \n          --  Any other use is an error"}, {"sha": "5a4bb66044301008a1d829246692c1554ca4c1e0", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1dfbb03f98d5a039c996adaf60c076979d61d18/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=e1dfbb03f98d5a039c996adaf60c076979d61d18", "patch": "@@ -4114,14 +4114,19 @@ package Sinfo is\n       --  Loop_Actions\n       --  Box_Present\n       --  Inherited_Discriminant\n+      --  Binding_Chars\n \n       --  Note: this structure is used for both record component associations\n       --  and array component associations, since the two cases aren't always\n       --  separable by the parser. The choices list may represent either a\n       --  list of selector names in the record aggregate case, or a list of\n       --  discrete choices in the array aggregate case or an N_Others_Choice\n       --  node (which appears as a singleton list). Box_Present gives support\n-      --  to Ada 2005 (AI-287).\n+      --  to Ada 2005 (AI-287). Binding_Chars is only set if GNAT extensions\n+      --  are enabled and the given component association occurs within a\n+      --  choice_expression; in this case, it is the Name_Id, if any, specified\n+      --  via either of two syntactic forms: \"Foo => Bar is Abc\" or\n+      --  \"Foo => <Abc>\".\n \n       ----------------------------------\n       -- 4.3.1  Component Choice List --\n@@ -5013,11 +5018,16 @@ package Sinfo is\n       --  Discrete_Choices\n       --  Statements\n       --  Has_SP_Choice\n+      --  Multidefined_Bindings\n \n       --  Note: in the list of Discrete_Choices, the tree passed to the back\n       --  end does not have choice entries corresponding to names of statically\n       --  predicated subtypes. Such entries are always expanded out to the list\n-      --  of equivalent values or ranges.\n+      --  of equivalent values or ranges. Multidefined_Bindings is True iff\n+      --  more than one choice is present and each choice contains\n+      --  at least one component association having a non-null Binding_Chars\n+      --  attribute; this can only occur if GNAT extensions are enabled\n+      --  and the type of the case selector is composite.\n \n       -------------------------\n       -- 5.5  Loop Statement --"}]}