{"sha": "e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEwOWQxNmY4YzU2ZmE2MWY5YjRjMTVhMjQyNmFkMDdhYzg4Y2JkNg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-07-23T20:01:29Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-07-23T20:01:29Z"}, "message": "javaprims.h: Rebuilt class list.\n\n\t* gcj/javaprims.h: Rebuilt class list.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (core_java_source_files): Added VMClassLoader.\n\t* java/lang/VMClassLoader.java: New file.\n\t* java/lang/Boolean.java: Merged with Classpath.\n\t* java/lang/Byte.java: Merged with Classpath.\n\t* java/lang/Integer.java: Merged with Classpath.\n\t* java/lang/Long.java: Merged with Classpath.\n\t* java/lang/Number.java: Merged with Classpath.\n\t* java/lang/Short.java: Merged with Classpath.\n\nFrom-SVN: r44274", "tree": {"sha": "b78c8d040343fe28feb343232f40dc3553894b9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b78c8d040343fe28feb343232f40dc3553894b9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/comments", "author": null, "committer": null, "parents": [{"sha": "57de7530c4c6d768559b39634fadf5bf27475359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57de7530c4c6d768559b39634fadf5bf27475359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57de7530c4c6d768559b39634fadf5bf27475359"}], "stats": {"total": 2311, "additions": 1662, "deletions": 649}, "files": [{"sha": "56d89c8682911532ea36d7663f8f50f7bcdc62c4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -1,3 +1,16 @@\n+2001-07-23  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gcj/javaprims.h: Rebuilt class list.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (core_java_source_files): Added VMClassLoader.\n+\t* java/lang/VMClassLoader.java: New file.\n+\t* java/lang/Boolean.java: Merged with Classpath.\n+\t* java/lang/Byte.java: Merged with Classpath.\n+\t* java/lang/Integer.java: Merged with Classpath.\n+\t* java/lang/Long.java: Merged with Classpath.\n+\t* java/lang/Number.java: Merged with Classpath.\n+\t* java/lang/Short.java: Merged with Classpath.\n+\n 2001-07-22  Jeff Sturm  <jsturm@one-point.com>\n \n \t* configure.host: Enable hash synchronization for alpha*-*."}, {"sha": "debd21904f86a839c9ebb44711ddf40bf8eacf02", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -847,6 +847,7 @@ java/lang/UnsatisfiedLinkError.java \\\n java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n+java/lang/VMClassLoader.java \\\n java/lang/Void.java \\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\"}, {"sha": "f792edb126b6952e8d79dfdcb7381074c696ff94", "filename": "libjava/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -617,6 +617,7 @@ java/lang/UnsatisfiedLinkError.java \\\n java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n+java/lang/VMClassLoader.java \\\n java/lang/Void.java \\\n java/io/BufferedInputStream.java \\\n java/io/BufferedOutputStream.java \\\n@@ -1663,8 +1664,9 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/ThreadLocal.P .deps/java/lang/Throwable.P \\\n .deps/java/lang/UnknownError.P .deps/java/lang/UnsatisfiedLinkError.P \\\n .deps/java/lang/UnsupportedOperationException.P \\\n-.deps/java/lang/VerifyError.P .deps/java/lang/VirtualMachineError.P \\\n-.deps/java/lang/Void.P .deps/java/lang/dtoa.P .deps/java/lang/e_acos.P \\\n+.deps/java/lang/VMClassLoader.P .deps/java/lang/VerifyError.P \\\n+.deps/java/lang/VirtualMachineError.P .deps/java/lang/Void.P \\\n+.deps/java/lang/dtoa.P .deps/java/lang/e_acos.P \\\n .deps/java/lang/e_asin.P .deps/java/lang/e_atan2.P \\\n .deps/java/lang/e_exp.P .deps/java/lang/e_fmod.P \\\n .deps/java/lang/e_log.P .deps/java/lang/e_pow.P \\"}, {"sha": "6634da2a957a50cf7cc73fddceaccca48183a6cf", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -95,6 +95,7 @@ LIBGCJTESTSPEC = @LIBGCJTESTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n+LIBICONV = @LIBICONV@\n LIBLTDL = @LIBLTDL@\n LIBTOOL = @LIBTOOL@\n LN_S = @LN_S@"}, {"sha": "5608aed010fbd82dca766a65a9e1b76f71666ab6", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -197,10 +197,13 @@ extern \"Java\"\n       class Thread;\n       class ThreadDeath;\n       class ThreadGroup;\n+      class ThreadLocal;\n+      class ThreadLocal$Value;\n       class Throwable;\n       class UnknownError;\n       class UnsatisfiedLinkError;\n       class UnsupportedOperationException;\n+      class VMClassLoader;\n       class VerifyError;\n       class VirtualMachineError;\n       class Void;"}, {"sha": "91edeb92d7c05656f40fbd875190a12bf7b7b9ce", "filename": "libjava/java/lang/Boolean.java", "status": "modified", "additions": 166, "deletions": 89, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FBoolean.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FBoolean.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FBoolean.java?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -1,100 +1,177 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Boolean.java -- object wrapper for boolean\n+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n package java.lang;\n \n import java.io.Serializable;\n- \n+\n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 3, 1998.  \n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n- \n-public final class Boolean extends Object implements Serializable\n+ * Instances of class <code>Boolean</code> represent primitive \n+ * <code>boolean</code> values.\n+ *\n+ * @author Paul Fisher\n+ * @since JDK1.0\n+ */ \n+public final class Boolean implements Serializable\n {\n-  public static final Boolean FALSE = new Boolean(false);\n-  public static final Boolean TRUE = new Boolean(true);\n-\n-  // This initialization is seemingly circular, but it is accepted\n-  // by javac, and is handled specially by gcc.\n-  public static final Class TYPE = boolean.class;\n-\n-  /* The boolean value of the instance. */\n-  private boolean value;\n-\n-  private static final long serialVersionUID = -3665804199014368530L;\n-\n-  public Boolean(boolean boolVal)\n-  {\n-    value = boolVal;\n-  }\n-\n-  public Boolean(String strVal)\n-  {\n-    value = (strVal == null ? false : strVal.equalsIgnoreCase(\"true\"));\n-  }\n-\n-  public boolean booleanValue()\n-  {\n-    return value;\n-  }\n-\n-  public boolean equals(Object obj)\n-  {\n-    /* Don't need to compare obj to null as instanceof will do this. */\n-    if (obj instanceof Boolean)\n-      return value == ((Boolean) obj).value;\n-    return false;\n-  }\n-\n-  public static boolean getBoolean(String property)\n-  {\n-    /* TBD: If a security manager exists and it doesn't permit accessing\n-     * the property, it will throw an exception.  Should we catch it?\n+    static final long serialVersionUID = -3665804199014368530L;\n+    \n+    /**\n+     * This field is a <code>Boolean</code> object representing the\n+     * primitive value <code>true</code>. This instance is returned\n+     * by the static <code>valueOf()</code> methods if they return\n+     * a <code>Boolean</code> representing <code>true</code>.\n+     */\n+    public static final Boolean TRUE  = new Boolean(true);\n+    \n+    /**\n+     * This field is a <code>Boolean</code> object representing the \n+     * primitive value <code>false</code>. This instance is returned\n+     * by the static <code>valueOf()</code> methods if they return\n+     * a <code>Boolean</code> representing <code>false</code>.\n+     */\n+     public static final Boolean FALSE = new Boolean(false);\n+\n+    /**\n+     * The primitive type <code>boolean</code> is represented by this \n+     * <code>Class</code> object.\n+     */\n+    public static final Class TYPE = VMClassLoader.getPrimitiveClass(\"boolean\");\n+    \n+    /**\n+     * The immutable value of this Boolean.\n+     */\n+    private final boolean value;\n+    \n+    /**\n+     * Create a <code>Boolean</code> object representing the value of the \n+     * argument <code>value</code>. In general the use of the static\n+     * method <code>valueof(boolean)</code> is more efficient since it will\n+     * not create a new object.\n+     *\n+     * @param value the primitive value of this <code>Boolean</code>\n+     */    \n+    public Boolean(boolean value) {\n+\tthis.value = value;\n+    }\n+    \n+    /**\n+     * Creates a <code>Boolean</code> object representing the primitive \n+     * <code>true</code> if and only if <code>s</code> matches \n+     * the string \"true\" ignoring case, otherwise the object will represent \n+     * the primitive <code>false</code>. In general the use of the static\n+     * method <code>valueof(String)</code> is more efficient since it will\n+     * not create a new object.\n+     *\n+     * @param s the <code>String</code> representation of <code>true</code>\n+     *   or false\n      */\n-    try\n-      {\n-\tString val = System.getProperty(property);\n-\treturn val == null ? false : val.equalsIgnoreCase(\"true\");\n-      }\n-    catch (SecurityException e)\n-      {\n-        return false;\n-      }\n-  }\n-\n-  public int hashCode()\n-  {\n-    /* These values are from the Java Lang. Spec. (Sec 20.4.7).\n-     * TBD: They could be made private static final fields but they're only\n-     * used here (and shouldn't be used anywhere else), though it might be\n-     * useful to grep on something like JAVA_HASH_* values for us as\n-     * developers.\n+    public Boolean(String s) {\n+\tvalue = \"true\".equalsIgnoreCase(s);\n+    }\n+\n+    /**\n+     * Return the primitive <code>boolean</code> value of this \n+     * <code>Boolean</code> object.\n+     */\n+    public boolean booleanValue() {\n+\treturn value;\n+    }\n+\n+    /**\n+     * Returns the Boolean <code>TRUE</code> if the given boolean is\n+     * <code>true</code>, otherwise it will return the Boolean\n+     * <code>FALSE</code>.\n+     *\n+     * @since 1.4\n+     */\n+    public static Boolean valueOf(boolean b) {\n+    \treturn b ? TRUE : FALSE;\n+    }\n+\n+    /**\n+     * Returns the Boolean <code>TRUE</code> if and only if the given\n+     * String is equal, ignoring case, to the the String \"true\", otherwise\n+     * it will return the Boolean <code>FALSE</code>.\n+     */\n+    public static Boolean valueOf(String s) {\n+    \treturn \"true\".equalsIgnoreCase(s) ? TRUE : FALSE;\n+    }\n+\n+    /**\n+     * Returns the integer <code>1231</code> if this object represents \n+     * the primitive <code>true</code> and the integer <code>1237</code>\n+     * otherwise.\n+     */    \n+    public int hashCode() {\n+\treturn (value) ? 1231 : 1237;\n+    }\n+\n+    /**\n+     * If the <code>obj</code> is an instance of <code>Boolean</code> and\n+     * has the same primitive value as this object then <code>true</code>\n+     * is returned.  In all other cases, including if the <code>obj</code>\n+     * is <code>null</code>, <code>false</code> is returned.\n+     *\n+     * @param obj possibly an instance of any <code>Class</code>\n+     * @return <code>false</code> is <code>obj</code> is an instance of\n+     *   <code>Boolean</code> and has the same primitive value as this \n+     *   object.\n+     */    \n+    public boolean equals(Object obj) {\n+\treturn (obj instanceof Boolean && value == ((Boolean)obj).value);\n+    }\n+\n+    /**\n+     * If the value of the system property <code>name</code> matches\n+     * \"true\" ignoring case then the function returns <code>true</code>.\n+     */\n+    public static boolean getBoolean(String name) {\n+\tString val = System.getProperty(name);\n+\treturn (\"true\".equalsIgnoreCase(val));\n+    }\n+    \n+    /**\n+     * Returns \"true\" if the value of the give boolean is <code>true</code> and\n+     * returns \"false\" if the value of the given boolean is <code>false</code>.\n+     *\n+     * @since 1.4\n+     */\n+    public static String toString(boolean b)\n+    {\n+\treturn b ? \"true\" : \"false\";\n+    }\n+\n+    /**\n+     * Returns \"true\" if the value of this object is <code>true</code> and\n+     * returns \"false\" if the value of this object is <code>false</code>.\n      */\n-    return value ? 1231 : 1237;\n-  }\n-\n-  public String toString()\n-  {\n-    return value ? \"true\" : \"false\";\n-  }\n-\n-  public static Boolean valueOf(String str)\n-  {\n-    if (str == null)\n-      return FALSE;\n-    else\n-      /* This returns a Boolean (big B), not a boolean (little b). */\n-      return str.equalsIgnoreCase(\"true\") ? TRUE : FALSE;\n-  }\n+    public String toString()\n+    {\n+\treturn (value) ? \"true\" : \"false\";\n+    }   \n }"}, {"sha": "964e073b73516e3ef11f7b5b5269510caf6765dd", "filename": "libjava/java/lang/Byte.java", "status": "modified", "additions": 231, "deletions": 72, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FByte.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FByte.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FByte.java?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -1,144 +1,303 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* Byte.java -- object wrapper for byte\n+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.lang;\n \n /**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date April 17, 1998.  \n+ * Instances of class <code>Byte</code> represent primitive <code>byte</code>\n+ * values.\n+ *\n+ * Additionally, this class provides various helper functions and variables\n+ * useful to bytes.\n+ *\n+ * @author Paul Fisher\n+ * @author John Keiser\n+ * @author Per Bothner\n+ * @since JDK 1.0\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- *\t    Includes JDK 1.2 methods.\n- */\n-\n-public final class Byte extends Number implements Comparable\n+public final class Byte extends Number implements Comparable \n {\n-  byte value;\n+  static final long serialVersionUID = -7183698231559129828L;\n \n-  public final static byte MIN_VALUE = -128;\n-  public final static byte MAX_VALUE = 127;\n+  /**\n+   * The minimum value a <code>byte</code> can represent is -128.\n+   */\n+  public static final byte MIN_VALUE = -128;\n \n-  // This initialization is seemingly circular, but it is accepted\n-  // by javac, and is handled specially by gcc.\n-  public static final Class TYPE = byte.class;\n+  /**\n+   * The maximum value a <code>byte</code> can represent is 127.\n+   */\n+  public static final byte MAX_VALUE = 127;\n \n-  private static final long serialVersionUID = -7183698231559129828L;\n+  /**\n+   * The primitive type <code>byte</code> is represented by this \n+   * <code>Class</code> object.\n+   */\n+  public static final Class TYPE = VMClassLoader.getPrimitiveClass(\"byte\");\n \n-  public Byte(byte value)\n+  /**\n+   * The immutable value of this Byte.\n+   */\n+  private final byte value;\n+\n+  /**\n+   * Create a <code>Byte</code> object representing the value of the \n+   * <code>byte</code> argument.\n+   *\n+   * @param value the value to use\n+   */     \n+  public Byte(byte value) \n   {\n     this.value = value;\n   }\n \n-  public Byte(String str) \n-    throws NumberFormatException\n+  /**\n+   * Create a <code>Byte</code> object representing the value specified \n+   * by the <code>String</code> argument.\n+   *\n+   * @param s the string to convert.\n+   */\n+  public Byte(String s) throws NumberFormatException \n   {\n-    this.value = parseByte(str, 10);\n+    value = parseByte(s, 10);\n   }\n \n-  public byte byteValue()\n+  /**\n+   * Return a hashcode representing this Object.\n+   *\n+   * <code>Byte</code>'s hash code is calculated by simply returning its\n+   * value.\n+   *\n+   * @return this Object's hash code.\n+   */\n+  public int hashCode() \n   {\n     return value;\n   }\n \n-  public short shortValue()\n+  /**\n+   * Returns <code>true</code> if <code>obj</code> is an instance of\n+   * <code>Byte</code> and represents the same byte value.\n+   * @return whether these Objects are semantically equal.\n+   */    \n+  public boolean equals(Object obj) \n   {\n-    return value;\n+    return ((obj instanceof Byte) && (value == ((Byte)obj).byteValue()));\n   }\n \n-  public int intValue()\n+  /**\n+   * Converts the <code>byte</code> to a <code>String</code> and assumes\n+   * a radix of 10.\n+   * @param i the <code>byte</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */    \n+  public static String toString(byte i) \n   {\n-    return value;\n+    return Integer.toString ((int) i);\n   }\n \n-  public long longValue ()\n+  /**\n+   * Converts the <code>Byte</code> value to a <code>String</code> and\n+   * assumes a radix of 10.\n+   * @return the <code>String</code> representation of this <code>Byte</code>.\n+   */    \n+  public String toString() \n   {\n-    return value;\n+    return Integer.toString ((int) value);\n   }\n-\n-  public float floatValue ()\n+    \n+  /**\n+   * Creates a new <code>Byte</code> object using the <code>String</code>,\n+   * assuming a radix of 10.\n+   * @param s the <code>String</code> to convert.\n+   * @return the new <code>Byte</code>.\n+   * @see #Byte(java.lang.String)\n+   * @see #parseByte(java.lang.String)\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>byte</code>.\n+   */\n+  public static Byte valueOf(String s) throws NumberFormatException \n   {\n-    return (float) value;\n+    return new Byte(parseByte(s));\n   }\n \n-  public double doubleValue ()\n+  /**\n+   * Creates a new <code>Byte</code> object using the <code>String</code>\n+   * and specified radix (base).\n+   * @param s the <code>String</code> to convert.\n+   * @param radix the radix (base) to convert with.\n+   * @return the new <code>Byte</code>.\n+   * @see #parseByte(java.lang.String,int)\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>byte</code>.\n+   */\n+  public static Byte valueOf(String s, int radix) \n+    throws NumberFormatException \n   {\n-    return (double) value;\n+    return new Byte(parseByte(s, radix));\n   }\n \n-  public static Byte decode(String str)\n-    throws NumberFormatException\n+  /**\n+   * Converts the specified <code>String</code> into a <code>byte</code>.\n+   * This function assumes a radix of 10.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @return the <code>byte</code> value of the <code>String</code>\n+   *         argument.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>byte</code>.\n+   */\n+  public static byte parseByte(String s) throws NumberFormatException \n   {\n-    int i = (Integer.decode(str)).intValue();\n-    if (i < MIN_VALUE || i > MAX_VALUE)\n-      throw new NumberFormatException();\n-    return new Byte((byte) i);\n+    return parseByte(s, 10);\n   }\n \n-  public static byte parseByte(String str, int radix)\n-    throws NumberFormatException\n+  /**\n+   * Converts the specified <code>String</code> into a <code>byte</code>\n+   * using the specified radix (base).\n+   *\n+   * @param str the <code>String</code> to convert\n+   * @param radix the radix (base) to use in the conversion\n+   * @return the <code>String</code> argument converted to </code>byte</code>.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>byte</code>.    \n+   */\n+  public static byte parseByte(String str, int radix) \n+    throws NumberFormatException \n   {\n     int i = Integer.parseInt(str, radix);\n     if (i < MIN_VALUE || i > MAX_VALUE)\n       throw new NumberFormatException();\n     return (byte) i;\n   }\n \n-  public static byte parseByte(String str)\n-    throws NumberFormatException\n+  /**\n+   * Convert the specified <code>String</code> into a <code>Byte</code>.\n+   * The <code>String</code> may represent decimal, hexadecimal, or \n+   * octal numbers.\n+   *\n+   * The <code>String</code> argument is interpreted based on the leading\n+   * characters.  Depending on what the String begins with, the base will be\n+   * interpreted differently:\n+   *\n+   * <table>\n+   * <tr><th>Leading<br>Characters</th><th>Base</th></tr>\n+   * <tr><td>#</td><td>16</td></tr>\n+   * <tr><td>0x</td><td>16</td></tr>\n+   * <tr><td>0X</td><td>16</td></tr>\n+   * <tr><td>0</td><td>8</td></tr>\n+   * <tr><td>Anything<br>Else</td><td>10</td></tr>\n+   * </table>\n+   *\n+   * @param str the <code>String</code> to interpret.\n+   * @return the value of the String as a <code>Byte</code>.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>byte</code>.    \n+   */\n+  public static Byte decode(String str) throws NumberFormatException \n   {\n-    return parseByte(str, 10);\n+    int i = (Integer.decode(str)).intValue();\n+    if (i < MIN_VALUE || i > MAX_VALUE)\n+      throw new NumberFormatException();\n+    return new Byte((byte) i);\n   }\n-\n-  public static Byte valueOf(String str, int radix)\n-    throws NumberFormatException\n+    \n+  /** Return the value of this <code>Byte</code> as an <code>short</code>.\n+   ** @return the value of this <code>Byte</code> as an <code>short</code>.\n+   **/\n+  public byte byteValue()\n   {\n-    return new Byte(parseByte(str, radix));\n+    return value;\n   }\n \n-  public static Byte valueOf(String str)\n-    throws NumberFormatException\n+  /** Return the value of this <code>Byte</code> as an <code>short</code>.\n+   ** @return the value of this <code>Byte</code> as an <code>short</code>.\n+   **/\n+  public short shortValue()\n   {\n-    return valueOf(str, 10);\n+    return value;\n   }\n \n-  // Added in JDK 1.2\n-  public int compareTo(Byte anotherByte)\n+  /** Return the value of this <code>Byte</code> as an <code>int</code>.\n+   ** @return the value of this <code>Byte</code> as an <code>int</code>.\n+   **/\n+  public int intValue()\n   {\n-    return this.value - anotherByte.value;\n+    return value;\n   }\n \n-  // Added in JDK 1.2\n-  /** @throws ClassCastException */\n-  public int compareTo(Object o)\n+  /** Return the value of this <code>Byte</code> as a <code>long</code>.\n+   ** @return the value of this <code>Byte</code> as a <code>long</code>.\n+   **/\n+  public long longValue()\n   {\n-    return this.value - ((Byte) o).value;\n+    return value;\n   }\n \n-  public boolean equals(Object obj)\n+  /** Return the value of this <code>Byte</code> as a <code>float</code>.\n+   ** @return the value of this <code>Byte</code> as a <code>float</code>.\n+   **/\n+  public float floatValue()\n   {\n-    return (obj instanceof Byte) && ((Byte)obj).value == value;\n+    return value;\n   }\n \n-  // Verified that hashCode is returns plain value (see Boolean_1 test).\n-  public int hashCode()\n+  /** Return the value of this <code>Byte</code> as a <code>double</code>.\n+   ** @return the value of this <code>Byte</code> as a <code>double</code>.\n+   **/\n+  public double doubleValue()\n   {\n     return value;\n   }\n-\n-  public String toString()\n+    \n+  /**\n+   * Compare two Bytes numerically by comparing their\n+   * <code>byte</code> values.\n+   * @return a positive value if this <code>Byte</code> is greater\n+   * in value than the argument <code>Byte</code>; a negative value\n+   * if this <code>Byte</code> is smaller in value than the argument\n+   * <code>Byte</code>; and <code>0</code>, zero, if this\n+   * <code>Byte</code> is equal in value to the argument\n+   * <code>Byte</code>.  \n+   */\n+  public int compareTo(Byte b)\n   {\n-    return Integer.toString((int) value);\n+    return (int)(value - b.byteValue());\n   }\n-\n-  public static String toString(byte value)\n+    \n+  /**\n+   * Behaves like <code>compareTo(java.lang.Byte)</code> unless the Object\n+   * is not a <code>Byte</code>.  Then it throws a \n+   * <code>ClassCastException</code>.\n+   * @exception ClassCastException if the argument is not a\n+   * <code>Byte</code>.  \n+   */\n+  public int compareTo(Object o)\n   {\n-    return Integer.toString((int) value);\n+    return compareTo((Byte)o);\n   }\n }"}, {"sha": "414d93d43a85c4f61ca2a89669cc13ca513b83ac", "filename": "libjava/java/lang/Integer.java", "status": "modified", "additions": 427, "deletions": 180, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FInteger.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FInteger.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FInteger.java?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -1,182 +1,368 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* java.lang.Integer\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n package java.lang;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 11, 1998.  \n+ * Instances of class <code>Integer</code> represent primitive\n+ * <code>int</code> values.\n+ *\n+ * Additionally, this class provides various helper functions and variables\n+ * related to ints.\n+ *\n+ * @author Paul Fisher\n+ * @author John Keiser\n+ * @author Warren Levy\n+ * @since JDK 1.0\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n- \n public final class Integer extends Number implements Comparable\n {\n-  public static final int MAX_VALUE = 0x7FFFFFFF;\n-  public static final int MIN_VALUE = 0x80000000;\n-\n-  // This initialization is seemingly circular, but it is accepted\n-  // by javac, and is handled specially by gcc.\n-  public static final Class TYPE = int.class;\n-\n-  /* The int value of the instance. */\n-  private int value;\n-\n+  // compatible with JDK 1.0.2+\n   private static final long serialVersionUID = 1360826667806852920L;\n \n-  public Integer(int val)\n+  /**\n+   * The minimum value an <code>int</code> can represent is -2147483648.\n+   */\n+  public static final int MIN_VALUE = 0x80000000;\n+\n+  /**\n+   * The maximum value an <code>int</code> can represent is 2147483647.\n+   */\n+  public static final int MAX_VALUE = 0x7fffffff;\n+\n+  /**\n+   * The primitive type <code>int</code> is represented by this \n+   * <code>Class</code> object.\n+   */\n+  public static final Class TYPE = VMClassLoader.getPrimitiveClass (\"int\");\n+\n+  /**\n+   * The immutable value of this Integer.\n+   */\n+  private final int value;\n+\n+  /**\n+   * Create an <code>Integer</code> object representing the value of the \n+   * <code>int</code> argument.\n+   *\n+   * @param value the value to use\n+   */\n+  public Integer(int value)\n   {\n-    value = val;\n+    this.value = value;\n   }\n \n-  public Integer(String str) throws NumberFormatException\n+  /**\n+   * Create an <code>Integer</code> object representing the value of the \n+   * argument after conversion to an <code>int</code>.\n+   *\n+   * @param s the string to convert.\n+   */\n+  public Integer(String s) throws NumberFormatException\n   {\n-    value = parseInt(str, 10);\n+    value = parseInt(s, 10);\n   }\n \n-  public byte byteValue()\n+  /**\n+   * Return a hashcode representing this Object.\n+   *\n+   * <code>Integer</code>'s hash code is calculated by simply returning its\n+   * value.\n+   *\n+   * @return this Object's hash code.\n+   */\n+  public int hashCode()\n   {\n-    return (byte) value;\n+    return value;\n   }\n \n-  public double doubleValue()\n+  /**\n+   * If the <code>Object</code> is not <code>null</code>, is an\n+   * <code>instanceof</code> <code>Integer</code>, and represents\n+   * the same primitive <code>int</code> value return \n+   * <code>true</code>.  Otherwise <code>false</code> is returned.\n+   */\n+  public boolean equals(Object obj)\n   {\n-    return (double) value;\n+    return obj instanceof Integer && value == ((Integer)obj).value;\n   }\n \n-  public float floatValue()\n+  /**\n+   * Get the specified system property as an <code>Integer</code>.\n+   *\n+   * The <code>decode()</code> method will be used to interpret the value of\n+   * the property.\n+   * @param nm the name of the system property\n+   * @return the system property as an <code>Integer</code>, or\n+   *         <code>null</code> if the property is not found or cannot be\n+   *         decoded as an <code>Integer</code>.\n+   * @see java.lang.System#getProperty(java.lang.String)\n+   * @see #decode(int)\n+   */\n+  public static Integer getInteger(String nm)\n   {\n-    return (float) value;\n+    return getInteger(nm, null);\n   }\n \n-  public int intValue()\n+  /**\n+   * Get the specified system property as an <code>Integer</code>, or use a\n+   * default <code>int</code> value if the property is not found or is not\n+   * decodable.\n+   * \n+   * The <code>decode()</code> method will be used to interpret the value of\n+   * the property.\n+   *\n+   * @param nm the name of the system property\n+   * @param val the default value to use if the property is not found or not\n+   *        a number.\n+   * @return the system property as an <code>Integer</code>, or the default\n+   *         value if the property is not found or cannot be decoded as an\n+   *         <code>Integer</code>.\n+   * @see java.lang.System#getProperty(java.lang.String)\n+   * @see #decode(int)\n+   * @see #getInteger(java.lang.String,java.lang.Integer)\n+   */\n+  public static Integer getInteger(String nm, int val)\n   {\n-    return value;\n+    Integer result = getInteger(nm, null);\n+    return (result == null) ? new Integer(val) : result;\n   }\n \n-  public long longValue()\n+  /**\n+   * Get the specified system property as an <code>Integer</code>, or use a\n+   * default <code>Integer</code> value if the property is not found or is\n+   * not decodable.\n+   * \n+   * The <code>decode()</code> method will be used to interpret the value of\n+   * the property.\n+   *\n+   * @param nm the name of the system property\n+   * @param val the default value to use if the property is not found or not\n+   *        a number.\n+   * @return the system property as an <code>Integer</code>, or the default\n+   *         value if the property is not found or cannot be decoded as an\n+   *         <code>Integer</code>.\n+   * @see java.lang.System#getProperty(java.lang.String)\n+   * @see #decode(int)\n+   * @see #getInteger(java.lang.String,int)\n+   */\n+  public static Integer getInteger(String nm, Integer def)\n   {\n-    return value;\n+    String val = System.getProperty(nm);\n+    if (val == null) return def;\n+    try\n+      {\n+      return decode(nm);\n+      }\n+    catch (NumberFormatException e)\n+      {\n+\treturn def;\n+      }\n   }\n \n-  public short shortValue()\n+  private static String toUnsignedString(int num, int exp)\n   {\n-    return (short) value;\n+    // Use an array large enough for a binary number.\n+    int radix = 1 << exp;\n+    int mask = radix - 1;\n+    char[] buffer = new char[32];\n+    int i = 32;\n+    do\n+      {\n+        buffer[--i] = Character.forDigit(num & mask, radix);\n+        num = num >>> exp;\n+      }\n+    while (num != 0);\n+\n+    return String.valueOf(buffer, i, 32-i);\n   }\n \n-  // Added in JDK 1.2\n-  public int compareTo(Integer anotherInteger)\n+  /**\n+   * Converts the <code>int</code> to a <code>String</code> assuming it is\n+   * unsigned in base 16.\n+   * @param i the <code>int</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */\n+  public static String toHexString(int i)\n   {\n-    if (this.value == anotherInteger.value)\n-      return 0;\n+    return toUnsignedString(i, 4);\n+  }\n \n-    // Returns just -1 or 1 on inequality; doing math might overflow the int.\n-    if (this.value > anotherInteger.value)\n-      return 1;\n+  /**\n+   * Converts the <code>int</code> to a <code>String</code> assuming it is\n+   * unsigned in base 8.\n+   * @param i the <code>int</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */\n+  public static String toOctalString(int i)\n+  {\n+    return toUnsignedString(i, 3);\n+  }\n \n-    return -1;\n+  /**\n+   * Converts the <code>int</code> to a <code>String</code> assuming it is\n+   * unsigned in base 2.\n+   * @param i the <code>int</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */\n+  public static String toBinaryString(int i)\n+  {\n+    return toUnsignedString(i, 1);\n   }\n \n-  // Added in JDK 1.2\n-  /** @throws ClassCastException */\n-  public int compareTo(Object o)\n+  /**\n+   * Converts the <code>int</code> to a <code>String</code> and assumes\n+   * a radix of 10.\n+   * @param i the <code>int</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */\n+  public static String toString(int i)\n   {\n-    return this.compareTo((Integer) o);\n+    // This is tricky: in libgcj, String.valueOf(int) is a fast native\n+    // implementation.  In Classpath it just calls back to\n+    // Integer.toString(int,int).\n+    return String.valueOf (i);\n   }\n \n-  public static Integer decode(String str) throws NumberFormatException\n+  /**\n+   * Converts the <code>Integer</code> value to a <code>String</code> and\n+   * assumes a radix of 10.\n+   * @return the <code>String</code> representation of this <code>Integer</code>.\n+   */    \n+  public String toString()\n   {\n-    boolean isNeg = false;\n-    int index = 0;\n-    int radix = 10;\n-    final int len;\n+    return toString (value);\n+  }\n \n-    if ((len = str.length()) == 0)\n-      throw new NumberFormatException();\n+  /**\n+   * Converts the <code>int</code> to a <code>String</code> using\n+   * the specified radix (base).\n+   * @param i the <code>int</code> to convert to <code>String</code>.\n+   * @param radix the radix (base) to use in the conversion.\n+   * @return the <code>String</code> representation of the argument.\n+   */\n+  public static String toString(int num, int radix)\n+  {\n+    // Use optimized method for the typical case.\n+    if (radix == 10 ||\n+        radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n+      return toString(num);\n \n-    // Negative numbers are always radix 10.\n-    if (str.charAt(0) == '-')\n+    // For negative numbers, print out the absolute value w/ a leading '-'.\n+    // Use an array large enough for a binary number.\n+    char[] buffer = new char[33];\n+    int i = 33;\n+    boolean isNeg;\n+    if (num < 0)\n       {\n-        radix = 10;\n-        index++;\n         isNeg = true;\n-      }\n-    else if (str.charAt(index) == '#')\n-      {\n-        radix = 16;\n-        index++;\n-      }\n-    else if (str.charAt(index) == '0')\n-      {\n-        // Check if str is just \"0\"\n-        if (len == 1)\n-          return new Integer(0);\n+        num = -(num);\n \n-        index++;\n-        if (str.charAt(index) == 'x')\n+        // When the value is MIN_VALUE, it overflows when made positive\n+        if (num < 0)\n           {\n-            radix = 16;\n-            index++;\n+            buffer[--i] = Character.forDigit(-(num + radix) % radix, radix);\n+            num = -(num / radix);\n           }\n-        else\n-          radix = 8;\n       }\n+    else\n+      isNeg = false;\n \n-    if (index >= len)\n-      throw new NumberFormatException();\n-\n-    return new Integer(parseInt(str, index, len, isNeg, radix));\n-  }\n-\n-  public boolean equals(Object obj)\n-  {\n-    return (obj instanceof Integer && ((Integer) obj).value == value);\n-  }\n+    do\n+      {\n+        buffer[--i] = Character.forDigit(num % radix, radix);\n+        num /= radix;\n+      }\n+    while (num > 0);\n \n-  public static Integer getInteger(String prop)\n-  {\n-    return getInteger(prop, null);\n-  }\n+    if (isNeg)\n+      buffer[--i] = '-';\n \n-  public static Integer getInteger(String prop, int defval)\n-  {\n-    Integer val = getInteger(prop, null);\n-    return val == null ? new Integer(defval) : val;\n+    return String.valueOf(buffer, i, 33-i);\n   }\n \n-  public static Integer getInteger(String prop, Integer defobj)\n+  /**\n+   * Creates a new <code>Integer</code> object using the <code>String</code>,\n+   * assuming a radix of 10.\n+   * @param s the <code>String</code> to convert.\n+   * @return the new <code>Integer</code>.\n+   * @see #Integer(java.lang.String)\n+   * @see #parseInt(java.lang.String)\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as an <code>int</code>.\n+   */\n+  public static Integer valueOf(String s) throws NumberFormatException\n   {\n-    try\n-      {\n-        String val = System.getProperty(prop);\n-\tif (val != null)\n-\t  return decode(val);\n-      }\n-    catch (NumberFormatException ex)\n-      {\n-      }\n-    return defobj;\n+    return new Integer(parseInt(s));\n   }\n \n-  public int hashCode()\n+  /**\n+   * Creates a new <code>Integer</code> object using the <code>String</code>\n+   * and specified radix (base).\n+   * @param s the <code>String</code> to convert.\n+   * @param radix the radix (base) to convert with.\n+   * @return the new <code>Integer</code>.\n+   * @see #parseInt(java.lang.String,int)\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as an <code>int</code>.\n+   */\n+  public static Integer valueOf(String s, int radix)\n+    throws NumberFormatException\n   {\n-    return value;\n+    return new Integer(parseInt(s, radix));\n   }\n \n-  public static int parseInt(String str) throws NumberFormatException\n+  /**\n+   * Converts the specified <code>String</code> into an <code>int</code>.\n+   * This function assumes a radix of 10.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @return the <code>int</code> value of the <code>String</code>\n+   *         argument.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as an <code>int</code>.\n+   */\n+  public static int parseInt(String s) throws NumberFormatException\n   {\n-    return parseInt(str, 10);\n+    return parseInt(s, 10);\n   }\n \n-  public static int parseInt(String str, int radix) throws NumberFormatException\n+  /**\n+   * Converts the specified <code>String</code> into an <code>int</code>\n+   * using the specified radix (base).\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @param radix the radix (base) to use in the conversion\n+   * @return the <code>String</code> argument converted to </code>int</code>.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>int</code>.    \n+   */\n+  public static int parseInt(String str, int radix)\n+    throws NumberFormatException\n   {\n     final int len;\n \n@@ -199,7 +385,8 @@ public static int parseInt(String str, int radix) throws NumberFormatException\n   }\n \n   private static int parseInt(String str, int index, int len, boolean isNeg,\n-        \t\t\tint radix) throws NumberFormatException\n+\t\t\t      int radix)\n+    throws NumberFormatException\n   {\n     int val = 0;\n     int digval;\n@@ -228,96 +415,156 @@ private static int parseInt(String str, int index, int len, boolean isNeg,\n     return isNeg ? -(val) : val;\n   }\n \n-  public static String toBinaryString(int num)\n+  /**\n+   * Convert the specified <code>String</code> into an <code>Integer</code>.\n+   * The <code>String</code> may represent decimal, hexadecimal, or \n+   * octal numbers.\n+   *\n+   * The <code>String</code> argument is interpreted based on the leading\n+   * characters.  Depending on what the String begins with, the base will be\n+   * interpreted differently:\n+   *\n+   * <table border=1>\n+   * <tr><th>Leading<br>Characters</th><th>Base</th></tr>\n+   * <tr><td>#</td><td>16</td></tr>\n+   * <tr><td>0x</td><td>16</td></tr>\n+   * <tr><td>0X</td><td>16</td></tr>\n+   * <tr><td>0</td><td>8</td></tr>\n+   * <tr><td>Anything<br>Else</td><td>10</td></tr>\n+   * </table>\n+   *\n+   * @param str the <code>String</code> to interpret.\n+   * @return the value of the String as an <code>Integer</code>.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as an <code>int</code>.    \n+   */\n+  public static Integer decode(String str) throws NumberFormatException\n   {\n-    return toUnsignedString(num, 1);\n+    boolean isNeg = false;\n+    int index = 0;\n+    int radix = 10;\n+    final int len;\n+\n+    if (str == null || (len = str.length()) == 0)\n+      throw new NumberFormatException(\"string null or empty\");\n+\n+    // Negative numbers are always radix 10.\n+    if (str.charAt(index) == '-')\n+      {\n+        radix = 10;\n+        index++;\n+        isNeg = true;\n+      }\n+    else if (str.charAt(index) == '#')\n+      {\n+        radix = 16;\n+        index++;\n+      }\n+    else if (str.charAt(index) == '0')\n+      {\n+        // Check if str is just \"0\"\n+        if (len == 1)\n+          return new Integer(0);\n+\n+        index++;\n+        if (str.charAt(index) == 'x' || str.charAt(index) == 'X')\n+          {\n+            radix = 16;\n+            index++;\n+          }\n+        else\n+          radix = 8;\n+      }\n+\n+    if (index >= len)\n+      throw new NumberFormatException(\"empty value\");\n+\n+    return new Integer(parseInt(str, index, len, isNeg, radix));\n   }\n \n-  public static String toHexString(int num)\n+  /** Return the value of this <code>Integer</code> as a <code>byte</code>.\n+   ** @return the value of this <code>Integer</code> as a <code>byte</code>.\n+   **/\n+  public byte byteValue()\n   {\n-    return toUnsignedString(num, 4);\n+    return (byte) value;\n   }\n \n-  public static String toOctalString(int num)\n+  /** Return the value of this <code>Integer</code> as a <code>short</code>.\n+   ** @return the value of this <code>Integer</code> as a <code>short</code>.\n+   **/\n+  public short shortValue()\n   {\n-    return toUnsignedString(num, 3);\n+    return (short) value;\n   }\n \n-  private static String toUnsignedString(int num, int exp)\n+  /** Return the value of this <code>Integer</code> as an <code>int</code>.\n+   ** @return the value of this <code>Integer</code> as an <code>int</code>.\n+   **/\n+  public int intValue()\n   {\n-    // Use an array large enough for a binary number.\n-    int radix = 1 << exp;\n-    int mask = radix - 1;\n-    char[] buffer = new char[32];\n-    int i = 32;\n-    do\n-      {\n-        buffer[--i] = Character.forDigit(num & mask, radix);\n-        num = num >>> exp;\n-      }\n-    while (num != 0);\n-\n-    return String.valueOf(buffer, i, 32-i);\n+    return value;\n   }\n \n-  public String toString()\n+  /** Return the value of this <code>Integer</code> as a <code>long</code>.\n+   ** @return the value of this <code>Integer</code> as a <code>long</code>.\n+   **/\n+  public long longValue()\n   {\n-    return toString(this.value);\n+    return value;\n   }\n \n-  public static String toString(int num)\n+  /** Return the value of this <code>Integer</code> as a <code>float</code>.\n+   ** @return the value of this <code>Integer</code> as a <code>float</code>.\n+   **/\n+  public float floatValue()\n   {\n-    return String.valueOf (num);\n+    return value;\n   }\n \n-  public static String toString(int num, int radix)\n+  /** Return the value of this <code>Integer</code> as a <code>double</code>.\n+   ** @return the value of this <code>Integer</code> as a <code>double</code>.\n+   **/\n+  public double doubleValue()\n   {\n-    // Use optimized method for the typical case.\n-    if (radix == 10 ||\n-        radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n-      return toString(num);\n-\n-    // For negative numbers, print out the absolute value w/ a leading '-'.\n-    // Use an array large enough for a binary number.\n-    char[] buffer = new char[33];\n-    int i = 33;\n-    boolean isNeg;\n-    if (num < 0)\n-      {\n-        isNeg = true;\n-        num = -(num);\n-\n-        // When the value is MIN_VALUE, it overflows when made positive\n-        if (num < 0)\n-          {\n-            buffer[--i] = Character.forDigit(-(num + radix) % radix, radix);\n-            num = -(num / radix);\n-          }\n-      }\n-    else\n-      isNeg = false;\n-\n-    do\n-      {\n-        buffer[--i] = Character.forDigit(num % radix, radix);\n-        num /= radix;\n-      }\n-    while (num > 0);\n-\n-    if (isNeg)\n-      buffer[--i] = '-';\n-\n-    return String.valueOf(buffer, i, 33-i);\n+    return value;\n   }\n \n-  public static Integer valueOf(String str) throws NumberFormatException\n+  /**\n+   * Compare two Integers numerically by comparing their\n+   * <code>int</code> values.\n+   * @return a positive value if this <code>Integer</code> is greater\n+   * in value than the argument <code>Integer</code>; a negative value\n+   * if this <code>Integer</code> is smaller in value than the argument\n+   * <code>Integer</code>; and <code>0</code>, zero, if this\n+   * <code>Integer</code> is equal in value to the argument\n+   * <code>Integer</code>.  \n+   *\n+   * @since 1.2\n+   */\n+  public int compareTo(Integer i)\n   {\n-    return new Integer(parseInt(str, 10));\n+    if (this.value == i.value)\n+      return 0;\n+\n+    // Returns just -1 or 1 on inequality; doing math might overflow.\n+    if (this.value > i.value)\n+      return 1;\n+\n+    return -1;\n   }\n \n-  public static Integer valueOf(String str, int radix)\n-  \t\t\t\tthrows NumberFormatException\n+  /**\n+   * Behaves like <code>compareTo(java.lang.Integer)</code> unless the Object\n+   * is not a <code>Integer</code>.  Then it throws a \n+   * <code>ClassCastException</code>.\n+   * @exception ClassCastException if the argument is not a\n+   * <code>Integer</code>.\n+   *\n+   * @since 1.2\n+   */\n+  public int compareTo(Object o)\n   {\n-    return new Integer(parseInt(str, radix));\n+    return compareTo((Integer)o);\n   }\n }"}, {"sha": "addb7e9d83c457ff9979b7fedd23503799ca87df", "filename": "libjava/java/lang/Long.java", "status": "modified", "additions": 436, "deletions": 216, "changes": 652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FLong.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FLong.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FLong.java?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -1,184 +1,404 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* java.lang.Long\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n package java.lang;\n \n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 18, 1998.  \n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n+ * Instances of class <code>Double</code> represent primitive\n+ * <code>double</code> values.\n+ *\n+ * Additionally, this class provides various helper functions and variables\n+ * related to longs.\n+ *\n+ * @author Paul Fisher\n+ * @author John Keiser\n+ * @author Warren Levy\n+ * @since JDK 1.0\n  */\n- \n public final class Long extends Number implements Comparable\n {\n-  public static final long MAX_VALUE = 0x7FFFFFFFFFFFFFFFL;\n-  public static final long MIN_VALUE = 0x8000000000000000L;\n-\n-  // This initialization is seemingly circular, but it is accepted\n-  // by javac, and is handled specially by gcc.\n-  public static final Class TYPE = long.class;\n+  // compatible with JDK 1.0.2+\n+  static final long serialVersionUID = 4290774380558885855L;\n \n-  /* The long value of the instance. */\n-  private long value;\n-\n-  private static final long serialVersionUID = 4290774380558885855L;\n+  /**\n+   * The minimum value a <code>long</code> can represent is\n+   * -9223372036854775808.\n+   */\n+  public static final long MIN_VALUE = 0x8000000000000000L;\n \n-  public Long(long val)\n+  /**\n+   * The maximum value a <code>long</code> can represent is\n+   * 9223372036854775807.\n+   */\n+  public static final long MAX_VALUE = 0x7fffffffffffffffL;\n+\n+  /**\n+   * The primitive type <code>long</code> is represented by this \n+   * <code>Class</code> object.\n+   */\n+  public static final Class TYPE = VMClassLoader.getPrimitiveClass (\"long\");\n+\n+  /**\n+   * The immutable value of this Long.\n+   */\n+  private final long value;\n+\n+  /**\n+   * Create a <code>Long</code> object representing the value of the \n+   * <code>long</code> argument.\n+   *\n+   * @param value the value to use\n+   */\n+  public Long(long value)\n   {\n-    value = val;\n+    this.value = value;\n   }\n \n-  public Long(String str) throws NumberFormatException\n+  /**\n+   * Create a <code>Long</code> object representing the value of the \n+   * argument after conversion to a <code>long</code>.\n+   *\n+   * @param s the string to convert.\n+   */\n+  public Long(String s) throws NumberFormatException\n   {\n-    value = parseLong(str, 10);\n+    value = parseLong(s, 10);\n   }\n \n-  public byte byteValue()\n+  /**\n+   * If the <code>Object</code> is not <code>null</code>, is an\n+   * <code>instanceof</code> <code>Long</code>, and represents\n+   * the same primitive <code>long</code> value return \n+   * <code>true</code>.  Otherwise <code>false</code> is returned.\n+   */\n+  public boolean equals(Object obj)\n   {\n-    return (byte) value;\n+    return obj instanceof Long && ((Long)obj).value == value;\n   }\n \n-  public double doubleValue()\n+  /**\n+   * Return a hashcode representing this Object.\n+   *\n+   * <code>Long</code>'s hash code is calculated by simply returning its\n+   * value.\n+   *\n+   * @return this Object's hash code.\n+   */\n+  public int hashCode()\n   {\n-    return (double) value;\n+    return (int)(value^(value>>>32));\n   }\n \n-  public float floatValue()\n+  /**\n+   * Get the specified system property as a <code>Long</code>.\n+   *\n+   * A method similar to <code>Integer</code>'s <code>decode()</code> will be\n+   * used to interpret the value of the property.\n+   * \n+   * @param nm the name of the system property\n+   * @return the system property as an <code>Long</code>, or\n+   *         <code>null</code> if the property is not found or cannot be\n+   *         decoded as a <code>Long</code>.\n+   * @see java.lang.System#getProperty(java.lang.String)\n+   * @see java.lang.Integer#decode(int)\n+   */\n+  public static Long getLong(String nm)\n   {\n-    return (float) value;\n+    return getLong(nm, null);\n   }\n \n-  public int intValue()\n+  /**\n+   * Get the specified system property as an <code>Long</code>, or use a\n+   * default <code>long</code> value if the property is not found or is not\n+   * decodable.\n+   * \n+   * A method similar to <code>Integer</code>'s <code>decode()</code> will be\n+   * used to interpret the value of the property.\n+   * \n+   * @param nm the name of the system property\n+   * @param val the default value to use if the property is not found or not\n+   *        a number.\n+   * @return the system property as a <code>Long</code>, or the default\n+   *         value if the property is not found or cannot be decoded as a\n+   *         <code>Long</code>.\n+   * @see java.lang.System#getProperty(java.lang.String)\n+   * @see java.lang.Integer#decode(int)\n+   * @see #getLong(java.lang.String,java.lang.Long)\n+   */\n+  public static Long getLong(String nm, long val)\n   {\n-    return (int) value;\n+    Long result = getLong(nm, null);\n+    return (result == null) ? new Long(val) : result;\n   }\n \n-  public long longValue()\n+  /**\n+   * Get the specified system property as an <code>Long</code>, or use a\n+   * default <code>Long</code> value if the property is not found or is\n+   * not decodable.\n+   * \n+   * The <code>decode()</code> method will be used to interpret the value of\n+   * the property.\n+   *\n+   * @param nm the name of the system property\n+   * @param val the default value to use if the property is not found or not\n+   *        a number.\n+   * @return the system property as an <code>Long</code>, or the default\n+   *         value if the property is not found or cannot be decoded as an\n+   *         <code>Long</code>.\n+   * @see java.lang.System#getProperty(java.lang.String)\n+   * @see java.lang.Integer#decode(int)\n+   * @see #getLong(java.lang.String,long)\n+   */\n+  public static Long getLong(String nm, Long def)\n   {\n-    return value;\n+    String val = System.getProperty(nm);\n+    if (val == null)\n+      return def;\n+    try\n+      {\n+\treturn decode(nm);\n+      }\n+    catch (NumberFormatException e)\n+      {\n+\treturn def;\n+      }\n   }\n \n-  public short shortValue()\n+  private static String toUnsignedString(long num, int exp)\n   {\n-    return (short) value;\n+    // Use an array large enough for a binary number.\n+    int radix = 1 << exp;\n+    int mask = radix - 1;\n+    char[] buffer = new char[64];\n+    int i = 64;\n+    do\n+      {\n+        buffer[--i] = Character.forDigit((int) num & mask, radix);\n+        num = num >>> exp;\n+      }\n+    while (num != 0);\n+\n+    return String.valueOf(buffer, i, 64-i);\n   }\n \n-  // Added in JDK 1.2\n-  public int compareTo(Long anotherLong)\n+  /**\n+   * Converts the <code>long</code> to a <code>String</code> assuming it is\n+   * unsigned in base 16.\n+   * @param i the <code>long</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */\n+  public static String toHexString(long i)\n   {\n-    if (this.value == anotherLong.value)\n-      return 0;\n-\n-    // Returns just -1 or 1 on inequality; doing math might overflow the long.\n-    if (this.value > anotherLong.value)\n-      return 1;\n-\n-    return -1;\n+    return toUnsignedString(i, 4);\n   }\n \n-  // Added in JDK 1.2\n-  /** @throws ClassCastException */\n-  public int compareTo(Object o)\n+  /**\n+   * Converts the <code>long</code> to a <code>String</code> assuming it is\n+   * unsigned in base 8.\n+   * @param i the <code>long</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */\n+  public static String toOctalString(long i)\n   {\n-    return this.compareTo((Long) o);\n+    return toUnsignedString(i, 3);\n   }\n \n-  // Added in JDK 1.2\n-  public static Long decode(String str) throws NumberFormatException\n-  {\n-    boolean isNeg = false;\n-    int index = 0;\n-    int radix = 10;\n-    final int len;\n+  /**\n+   * Converts the <code>long</code> to a <code>String</code> assuming it is\n+   * unsigned in base 2.\n+   * @param i the <code>long</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */\n+  public static String toBinaryString(long i) {\n+    return toUnsignedString(i, 1);\n+  }\n \n-    if ((len = str.length()) == 0)\n-      throw new NumberFormatException();\n+  /**\n+   * Converts the <code>long</code> to a <code>String</code> and assumes\n+   * a radix of 10.\n+   * @param num the <code>long</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */    \n+  public static String toString(long num)\n+  {\n+    // Use the Integer toString for efficiency if possible.\n+    if (num <= Integer.MAX_VALUE && num >= Integer.MIN_VALUE)\n+      return Integer.toString((int) num);\n \n-    // Negative numbers are always radix 10.\n-    if (str.charAt(0) == '-')\n+    // Use an array large enough for \"-9223372036854775808\"; i.e. 20 chars.\n+    char[] buffer = new char[20];\n+    int i = 20;\n+    boolean isNeg;\n+    if (num < 0)\n       {\n-        radix = 10;\n-        index++;\n         isNeg = true;\n-      }\n-    else if (str.charAt(index) == '#')\n-      {\n-        radix = 16;\n-        index++;\n-      }\n-    else if (str.charAt(index) == '0')\n-      {\n-        // Check if str is just \"0\"\n-        if (len == 1)\n-          return new Long(0L);\n-\n-        index++;\n-        if (str.charAt(index) == 'x')\n+        num = -(num);\n+        if (num < 0)\n           {\n-            radix = 16;\n-            index++;\n+            // Must be MIN_VALUE, so handle this special case.\n+            buffer[--i] = '8';\n+            num = 922337203685477580L;\n           }\n-        else\n-          radix = 8;\n       }\n+    else\n+      isNeg = false;\n \n-    if (index >= len)\n-      throw new NumberFormatException();\n+    do\n+      {\n+        buffer[--i] = (char) ((int) '0' + (num % 10));\n+        num /= 10;\n+      }\n+    while (num > 0);\n \n-    return new Long(parseLong(str, index, len, isNeg, radix));\n-  }\n+    if (isNeg)\n+      buffer[--i] = '-';\n \n-  public boolean equals(Object obj)\n-  {\n-    return (obj instanceof Long && ((Long) obj).value == value);\n+    return String.valueOf(buffer, i, 20-i);\n   }\n \n-  public static Long getLong(String prop)\n+  /**\n+   * Converts the <code>Long</code> value to a <code>String</code> and\n+   * assumes a radix of 10.\n+   * @return the <code>String</code> representation of this <code>Long</code>.\n+   */    \n+  public String toString()\n   {\n-    return getLong(prop, null);\n+    return toString(value);\n   }\n-\n-  public static Long getLong(String prop, long defval)\n+  \n+  /**\n+   * Converts the <code>long</code> to a <code>String</code> using\n+   * the specified radix (base).\n+   * @param num the <code>long</code> to convert to <code>String</code>.\n+   * @param radix the radix (base) to use in the conversion.\n+   * @return the <code>String</code> representation of the argument.\n+   */\n+  public static String toString(long num, int radix)\n   {\n-    Long val = getLong(prop, null);\n-    return val == null ? new Long(defval) : val;\n-  }\n+    // Use optimized method for the typical case.\n+    if (radix == 10 ||\n+        radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n+      return toString(num);\n \n-  public static Long getLong(String prop, Long defobj)\n-  {\n-    try\n+    // Use the Integer toString for efficiency if possible.\n+    if (num <= Integer.MAX_VALUE && num >= Integer.MIN_VALUE)\n+      return Integer.toString((int) num, radix);\n+\n+    // For negative numbers, print out the absolute value w/ a leading '-'.\n+    // Use an array large enough for a binary number.\n+    char[] buffer = new char[65];\n+    int i = 65;\n+    boolean isNeg;\n+    if (num < 0)\n       {\n-        String val = System.getProperty(prop);\n-\tif (val != null)    \n-\t  return decode(val);\n+        isNeg = true;\n+        num = -(num);\n+\n+        // When the value is MIN_VALUE, it overflows when made positive\n+        if (num < 0)\n+          {\n+            buffer[--i] = Character.forDigit((int) (-(num + radix) % radix),\n+\t\t\t\t\t\tradix);\n+            num = -(num / radix);\n+          }\n       }\n-    catch (NumberFormatException ex)\n+    else\n+      isNeg = false;\n+\n+    do\n       {\n+        buffer[--i] = Character.forDigit((int) (num % radix), radix);\n+        num /= radix;\n       }\n-    return defobj;\n+    while (num > 0);\n+\n+    if (isNeg)\n+      buffer[--i] = '-';\n+\n+    return String.valueOf(buffer, i, 65-i);\n+  }\n+    \n+  /**\n+   * Creates a new <code>Long</code> object using the <code>String</code>,\n+   * assuming a radix of 10.\n+   * @param s the <code>String</code> to convert.\n+   * @return the new <code>Long</code>.\n+   * @see #Long(java.lang.String)\n+   * @see #parseLong(java.lang.String)\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>long</code>.\n+   */\n+  public static Long valueOf(String s) throws NumberFormatException\n+  {\n+    return new Long(parseLong(s));\n   }\n \n-  public int hashCode()\n+  /**\n+   * Creates a new <code>Long</code> object using the <code>String</code>\n+   * and specified radix (base).\n+   * @param s the <code>String</code> to convert.\n+   * @param radix the radix (base) to convert with.\n+   * @return the new <code>Long</code>.\n+   * @see #parseLong(java.lang.String,int)\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>long</code>.\n+   */\n+  public static Long valueOf(String s, int radix) throws NumberFormatException\n   {\n-    return (int)(this.longValue()^(this.longValue()>>>32));\n+    return new Long(parseLong(s, radix));\n   }\n \n-  public static long parseLong(String str) throws NumberFormatException\n+  /**\n+   * Converts the specified <code>String</code> into a <code>long</code>.\n+   * This function assumes a radix of 10.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @return the <code>long</code> value of the <code>String</code>\n+   *         argument.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>long</code>.\n+   */\n+  public static long parseLong(String s) throws NumberFormatException\n   {\n-    return parseLong(str, 10);\n+    return parseLong(s, 10);\n   }\n \n+  /**\n+   * Converts the specified <code>String</code> into a <code>long</code>\n+   * using the specified radix (base).\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @param radix the radix (base) to use in the conversion\n+   * @return the <code>String</code> argument converted to </code>long</code>.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>long</code>.    \n+   */\n   public static long parseLong(String str, int radix)\n-\t\t\tthrows NumberFormatException\n+    throws NumberFormatException\n   {\n     final int len;\n \n@@ -200,6 +420,50 @@ public static long parseLong(String str, int radix)\n     return parseLong(str, index, len, isNeg, radix);\n   }\n \n+  public static Long decode(String str) throws NumberFormatException\n+  {\n+    boolean isNeg = false;\n+    int index = 0;\n+    int radix = 10;\n+    final int len;\n+\n+    if ((len = str.length()) == 0)\n+      throw new NumberFormatException();\n+\n+    // Negative numbers are always radix 10.\n+    if (str.charAt(0) == '-')\n+      {\n+        radix = 10;\n+        index++;\n+        isNeg = true;\n+      }\n+    else if (str.charAt(index) == '#')\n+      {\n+        radix = 16;\n+        index++;\n+      }\n+    else if (str.charAt(index) == '0')\n+      {\n+        // Check if str is just \"0\"\n+        if (len == 1)\n+          return new Long(0L);\n+\n+        index++;\n+        if (str.charAt(index) == 'x')\n+          {\n+            radix = 16;\n+            index++;\n+          }\n+        else\n+          radix = 8;\n+      }\n+\n+    if (index >= len)\n+      throw new NumberFormatException();\n+\n+    return new Long(parseLong(str, index, len, isNeg, radix));\n+  }\n+\n   private static long parseLong(String str, int index, int len, boolean isNeg,\n         \t\t\tint radix) throws NumberFormatException\n   {\n@@ -230,133 +494,89 @@ private static long parseLong(String str, int index, int len, boolean isNeg,\n     return isNeg ? -(val) : val;\n   }\n \n-  public static String toBinaryString(long num)\n+  /** Return the value of this <code>Long</code> as an <code>short</code>.\n+   ** @return the value of this <code>Long</code> as an <code>short</code>.\n+   **/\n+  public byte byteValue()\n   {\n-    return toUnsignedString(num, 1);\n+    return (byte) value;\n   }\n \n-  public static String toHexString(long num)\n+  /** Return the value of this <code>Long</code> as an <code>short</code>.\n+   ** @return the value of this <code>Long</code> as an <code>short</code>.\n+   **/\n+  public short shortValue()\n   {\n-    return toUnsignedString(num, 4);\n+    return (short) value;\n   }\n \n-  public static String toOctalString(long num)\n+  /** Return the value of this <code>Long</code> as an <code>int</code>.\n+   ** @return the value of this <code>Long</code> as an <code>int</code>.\n+   **/\n+  public int intValue()\n   {\n-    return toUnsignedString(num, 3);\n+    return (int) value;\n   }\n \n-  private static String toUnsignedString(long num, int exp)\n+  /** Return the value of this <code>Long</code> as a <code>long</code>.\n+   ** @return the value of this <code>Long</code> as a <code>long</code>.\n+   **/\n+  public long longValue()\n   {\n-    // Use an array large enough for a binary number.\n-    int radix = 1 << exp;\n-    long mask = radix - 1;\n-    char[] buffer = new char[64];\n-    int i = 64;\n-    do\n-      {\n-        buffer[--i] = Character.forDigit((int) (num & mask), radix);\n-        num = num >>> exp;\n-      }\n-    while (num != 0);\n-\n-    return String.valueOf(buffer, i, 64-i);\n+    return value;\n   }\n \n-  public String toString()\n+  /** Return the value of this <code>Long</code> as a <code>float</code>.\n+   ** @return the value of this <code>Long</code> as a <code>float</code>.\n+   **/\n+  public float floatValue()\n   {\n-    return toString(this.value);\n+    return value;\n   }\n \n-  public static String toString(long num)\n+  /** Return the value of this <code>Long</code> as a <code>double</code>.\n+   ** @return the value of this <code>Long</code> as a <code>double</code>.\n+   **/\n+  public double doubleValue()\n   {\n-    // Use the Integer toString for efficiency if possible.\n-    if (num <= Integer.MAX_VALUE && num >= Integer.MIN_VALUE)\n-      return Integer.toString((int) num);\n-\n-    // Use an array large enough for \"-9223372036854775808\"; i.e. 20 chars.\n-    char[] buffer = new char[20];\n-    int i = 20;\n-    boolean isNeg;\n-    if (num < 0)\n-      {\n-        isNeg = true;\n-        num = -(num);\n-        if (num < 0)\n-          {\n-            // Must be MIN_VALUE, so handle this special case.\n-            buffer[--i] = '8';\n-            num = 922337203685477580L;\n-          }\n-      }\n-    else\n-      isNeg = false;\n-\n-    do\n-      {\n-        buffer[--i] = (char) ((int) '0' + (num % 10));\n-        num /= 10;\n-      }\n-    while (num > 0);\n-\n-    if (isNeg)\n-      buffer[--i] = '-';\n-\n-    return String.valueOf(buffer, i, 20-i);\n+    return value;\n   }\n \n-  public static String toString(long num, int radix)\n+  /**\n+   * Compare two Longs numerically by comparing their\n+   * <code>long</code> values.\n+   * @return a positive value if this <code>Long</code> is greater\n+   * in value than the argument <code>Long</code>; a negative value\n+   * if this <code>Long</code> is smaller in value than the argument\n+   * <code>Long</code>; and <code>0</code>, zero, if this\n+   * <code>Long</code> is equal in value to the argument\n+   * <code>Long</code>.  \n+   *\n+   * @since 1.2\n+   */\n+  public int compareTo(Long l)\n   {\n-    // Use optimized method for the typical case.\n-    if (radix == 10 ||\n-        radix < Character.MIN_RADIX || radix > Character.MAX_RADIX)\n-      return toString(num);\n-\n-    // Use the Integer toString for efficiency if possible.\n-    if (num <= Integer.MAX_VALUE && num >= Integer.MIN_VALUE)\n-      return Integer.toString((int) num, radix);\n-\n-    // For negative numbers, print out the absolute value w/ a leading '-'.\n-    // Use an array large enough for a binary number.\n-    char[] buffer = new char[65];\n-    int i = 65;\n-    boolean isNeg;\n-    if (num < 0)\n-      {\n-        isNeg = true;\n-        num = -(num);\n-\n-        // When the value is MIN_VALUE, it overflows when made positive\n-        if (num < 0)\n-          {\n-            buffer[--i] = Character.forDigit((int) (-(num + radix) % radix),\n-\t\t\t\t\t\tradix);\n-            num = -(num / radix);\n-          }\n-      }\n-    else\n-      isNeg = false;\n-\n-    do\n-      {\n-        buffer[--i] = Character.forDigit((int) (num % radix), radix);\n-        num /= radix;\n-      }\n-    while (num > 0);\n-\n-    if (isNeg)\n-      buffer[--i] = '-';\n+    if (this.value == l.value)\n+      return 0;\n \n-    return String.valueOf(buffer, i, 65-i);\n-  }\n+    // Returns just -1 or 1 on inequality; doing math might overflow the long.\n+    if (this.value > l.value)\n+      return 1;\n \n-  public static Long valueOf(String str) throws NumberFormatException\n-  {\n-    return new Long(parseLong(str, 10));\n+    return -1;\n   }\n-\n-  public static Long valueOf(String str, int radix)\n-  \t\t\t\tthrows NumberFormatException\n+    \n+  /**\n+   * Behaves like <code>compareTo(java.lang.Long)</code> unless the Object\n+   * is not a <code>Long</code>.  Then it throws a \n+   * <code>ClassCastException</code>.\n+   * @exception ClassCastException if the argument is not a\n+   * <code>Long</code>.\n+   *\n+   * @since 1.2\n+   */\n+  public int compareTo(Object o)\n   {\n-    return new Long(parseLong(str, radix));\n+    return compareTo((Long)o);\n   }\n }"}, {"sha": "7eb8bee22da577af23b7ac3cfe7c2acb3943754c", "filename": "libjava/java/lang/Number.java", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FNumber.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FNumber.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FNumber.java?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -1,41 +1,83 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* java.lang.Number\n+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n  \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+\n package java.lang;\n \n import java.io.Serializable;\n- \n+\n /**\n- * @author Warren Levy <warrenl@cygnus.com>\n- * @date September 2, 1998.  \n- */\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n- * \"The Java Language Specification\", ISBN 0-201-63451-1\n- * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- */\n- \n+ ** Number is a generic superclass of all the numeric classes, namely\n+ ** <code>Byte</code>, <code>Short</code>, <code>Integer</code>,\n+ ** <code>Long</code>, <code>Float</code>, and <code>Double</code>.\n+ **\n+ ** It provides ways to convert from any one value to any other.\n+ **\n+ ** @author Paul Fisher\n+ ** @author John Keiser\n+ ** @author Warren Levy\n+ ** @since JDK1.0\n+ **/\n public abstract class Number implements Serializable\n {\n-  public byte byteValue()\t// Became non-abstract in JDK 1.2\n+  /** Return the value of this <code>Number</code> as a <code>byte</code>.\n+   ** @return the value of this <code>Number</code> as a <code>byte</code>.\n+   **/\n+  public byte byteValue()\n   {\n     return (byte) intValue();\n   }\n \n-  public abstract double doubleValue();\n-  public abstract float floatValue();\n-  public abstract int intValue();\n-  public abstract long longValue();\n-\n-  public short shortValue()\t// Became non-abstract in JDK 1.2\n+  /** Return the value of this <code>Number</code> as a <code>short</code>.\n+   ** @return the value of this <code>Number</code> as a <code>short</code>.\n+   **/\n+  public short shortValue()\n   {\n     return (short) intValue();\n   }\n \n+  /** Return the value of this <code>Number</code> as an <code>int</code>.\n+   ** @return the value of this <code>Number</code> as an <code>int</code>.\n+   **/\n+  public abstract int intValue();\n+\n+  /** Return the value of this <code>Number</code> as a <code>long</code>.\n+   ** @return the value of this <code>Number</code> as a <code>long</code>.\n+   **/\n+  public abstract long longValue();\n+\n+  /** Return the value of this <code>Number</code> as a <code>float</code>.\n+   ** @return the value of this <code>Number</code> as a <code>float</code>.\n+   **/\n+  public abstract float floatValue();\n+\n+  /** Return the value of this <code>Number</code> as a <code>float</code>.\n+   ** @return the value of this <code>Number</code> as a <code>float</code>.\n+   **/\n+  public abstract double doubleValue();\n+\n   private static final long serialVersionUID = -8742448824652078965L;\n }"}, {"sha": "db3cac0f095ba9d29f717dbba7cd622b04ab1a6c", "filename": "libjava/java/lang/Short.java", "status": "modified", "additions": 231, "deletions": 68, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FShort.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FShort.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FShort.java?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -1,144 +1,307 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* java.lang.Short\n+   Copyright (C) 1998, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.lang;\n \n /**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date April 17, 1998.  \n+ * Instances of class <code>Short</code> represent primitive\n+ * <code>short</code> values.\n+ *\n+ * Additionally, this class provides various helper functions and variables\n+ * related to shorts.\n+ *\n+ * @author Paul Fisher\n+ * @author John Keiser\n+ * @since JDK 1.0\n  */\n-/* Written using \"Java Class Libraries\", 2nd edition, plus online\n- * API docs for JDK 1.2 beta from http://www.javasoft.com.\n- * Status:  Believed complete and correct.\n- *\t    Includes JDK 1.2 methods.\n- */\n-\n public final class Short extends Number implements Comparable\n {\n-  short value;\n+  static final long serialVersionUID = 7515723908773894738L;\n+\n+  /**\n+   * The minimum value a <code>short</code> can represent is -32768.\n+   */\n+  public static final short MIN_VALUE = -32768;\n \n-  public final static short MIN_VALUE = -32768;\n-  public final static short MAX_VALUE = 32767;\n+  /**\n+   * The minimum value a <code>short</code> can represent is 32767.\n+   */\n+  public static final short MAX_VALUE =  32767;\n \n-  // This initialization is seemingly circular, but it is accepted\n-  // by javac, and is handled specially by gcc.\n-  public static final Class TYPE = short.class;\n+  /**\n+   * The primitive type <code>short</code> is represented by this \n+   * <code>Class</code> object.\n+   */\n+  public static final Class TYPE = VMClassLoader.getPrimitiveClass(\"short\");\n \n-  private static final long serialVersionUID = 7515723908773894738L;\n+  /**\n+   * The immutable value of this Short.\n+   */\n+  private final short value;\n \n+  /**\n+   * Create a <code>Short</code> object representing the value of the \n+   * <code>short</code> argument.\n+   *\n+   * @param value the value to use\n+   */\n   public Short(short value)\n   {\n     this.value = value;\n   }\n \n-  public Short(String str) \n-    throws NumberFormatException\n+  /**\n+   * Create a <code>Short</code> object representing the value of the \n+   * argument after conversion to a <code>short</code>.\n+   *\n+   * @param s the string to convert.\n+   */\n+  public Short(String s) throws NumberFormatException\n   {\n-    this.value = parseShort(str, 10);\n+    value = parseShort(s, 10);\n   }\n \n-  public byte byteValue()\n+  /**\n+   * Return a hashcode representing this Object.\n+   *\n+   * <code>Short</code>'s hash code is calculated by simply returning its\n+   * value.\n+   *\n+   * @return this Object's hash code.\n+   */\n+  public int hashCode()\n   {\n-    return (byte) value;\n+    return value;\n   }\n \n-  public short shortValue()\n+  /**\n+   * If the <code>Object</code> is not <code>null</code>, is an\n+   * <code>instanceof</code> <code>Short</code>, and represents\n+   * the same primitive <code>short</code> value return \n+   * <code>true</code>.  Otherwise <code>false</code> is returned.\n+   */\n+  public boolean equals(Object obj)\n   {\n-    return value;\n+    return obj instanceof Short && ((Short)obj).value == value;\n   }\n \n-  public int intValue()\n+  /**\n+   * Converts the <code>short</code> to a <code>String</code> and assumes\n+   * a radix of 10.\n+   * @param i the <code>short</code> to convert to <code>String</code>\n+   * @return the <code>String</code> representation of the argument.\n+   */    \n+  public static String toString(short i)\n   {\n-    return value;\n+    return Integer.toString((int) i);\n   }\n \n-  public long longValue ()\n+  /**\n+   * Converts the <code>Short</code> value to a <code>String</code> and\n+   * assumes a radix of 10.\n+   * @return the <code>String</code> representation of this <code>Short</code>.\n+   */    \n+  public String toString()\n   {\n-    return value;\n+    return Integer.toString ((int) value);\n   }\n \n-  public float floatValue ()\n+  /**\n+   * Creates a new <code>Short</code> object using the <code>String</code>,\n+   * assuming a radix of 10.\n+   * @param s the <code>String</code> to convert.\n+   * @return the new <code>Short</code>.\n+   * @see #Short(java.lang.String)\n+   * @see #parseShort(java.lang.String)\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>short</code>.\n+   */\n+  public static Short valueOf(String s) throws NumberFormatException\n   {\n-    return (float) value;\n+    return new Short(parseShort(s));\n   }\n \n-  public double doubleValue ()\n+  /**\n+   * Creates a new <code>Short</code> object using the <code>String</code>\n+   * and specified radix (base).\n+   * @param s the <code>String</code> to convert.\n+   * @param radix the radix (base) to convert with.\n+   * @return the new <code>Short</code>.\n+   * @see #parseShort(java.lang.String,int)\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>short</code>.\n+   */\n+  public static Short valueOf(String s, int radix)\n+    throws NumberFormatException\n   {\n-    return (double) value;\n+    return new Short(parseShort(s, radix));\n   }\n \n-  public static Short decode(String str)\n-    throws NumberFormatException\n+  /**\n+   * Converts the specified <code>String</code> into a <code>short</code>.\n+   * This function assumes a radix of 10.\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @return the <code>short</code> value of the <code>String</code>\n+   *         argument.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>short</code>.\n+   */\n+  public static short parseShort(String s) throws NumberFormatException\n   {\n-    int i = (Integer.decode(str)).intValue();\n-    if (i < MIN_VALUE || i > MAX_VALUE)\n-      throw new NumberFormatException();\n-    return new Short((short) i);\n+    return parseShort(s, 10);\n   }\n \n-  public static short parseShort(String str, int radix)\n+  /**\n+   * Converts the specified <code>String</code> into a <code>short</code>\n+   * using the specified radix (base).\n+   *\n+   * @param s the <code>String</code> to convert\n+   * @param radix the radix (base) to use in the conversion\n+   * @return the <code>String</code> argument converted to </code>short</code>.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>short</code>.\n+   */\n+  public static short parseShort(String s, int radix) \n     throws NumberFormatException\n   {\n-    int i = Integer.parseInt(str, radix);\n+    int i = Integer.parseInt(s, radix);\n     if (i < MIN_VALUE || i > MAX_VALUE)\n       throw new NumberFormatException();\n     return (short) i;\n   }\n \n-  public static short parseShort(String str)\n-    throws NumberFormatException\n+  /**\n+   * Convert the specified <code>String</code> into a <code>Short</code>.\n+   * The <code>String</code> may represent decimal, hexadecimal, or \n+   * octal numbers.\n+   *\n+   * The <code>String</code> argument is interpreted based on the leading\n+   * characters.  Depending on what the String begins with, the base will be\n+   * interpreted differently:\n+   *\n+   * <table>\n+   * <tr><th>Leading<br>Characters</th><th>Base</th></tr>\n+   * <tr><td>#</td><td>16</td></tr>\n+   * <tr><td>0x</td><td>16</td></tr>\n+   * <tr><td>0X</td><td>16</td></tr>\n+   * <tr><td>0</td><td>8</td></tr>\n+   * <tr><td>Anything<br>Else</td><td>10</td></tr>\n+   * </table>\n+   *\n+   * @param s the <code>String</code> to interpret.\n+   * @return the value of the String as a <code>Short</code>.\n+   * @exception NumberFormatException thrown if the <code>String</code> \n+   * cannot be parsed as a <code>short</code>.    \n+   */\n+  public static Short decode(String s) throws NumberFormatException\n   {\n-    return parseShort(str, 10);\n+    int i = (Integer.decode(s)).intValue();\n+    if (i < MIN_VALUE || i > MAX_VALUE)\n+      throw new NumberFormatException();\n+    return new Short((short) i);\n   }\n \n-  public static Short valueOf(String str, int radix)\n-    throws NumberFormatException\n+  /** Return the value of this <code>Short</code> as an <code>short</code>.\n+   ** @return the value of this <code>Short</code> as an <code>short</code>.\n+   **/\n+  public byte byteValue()\n   {\n-    return new Short(parseShort(str, radix));\n+    return (byte) value;\n   }\n \n-  public static Short valueOf(String str)\n-    throws NumberFormatException\n+  /** Return the value of this <code>Short</code> as an <code>short</code>.\n+   ** @return the value of this <code>Short</code> as an <code>short</code>.\n+   **/\n+  public short shortValue()\n   {\n-    return valueOf(str, 10);\n+    return value;\n   }\n \n-  // Added in JDK 1.2\n-  public int compareTo(Short anotherShort)\n+  /** Return the value of this <code>Short</code> as an <code>int</code>.\n+   ** @return the value of this <code>Short</code> as an <code>int</code>.\n+   **/\n+  public int intValue()\n   {\n-    return this.value - anotherShort.value;\n+    return value;\n   }\n \n-  // Added in JDK 1.2\n-  /** @throws ClassCastException */\n-  public int compareTo(Object o)\n+  /** Return the value of this <code>Short</code> as a <code>long</code>.\n+   ** @return the value of this <code>Short</code> as a <code>long</code>.\n+   **/\n+  public long longValue()\n   {\n-    return this.value - ((Short) o).value;\n+    return value;\n   }\n \n-  public boolean equals(Object obj)\n+  /** Return the value of this <code>Short</code> as a <code>float</code>.\n+   ** @return the value of this <code>Short</code> as a <code>float</code>.\n+   **/\n+  public float floatValue()\n   {\n-    return (obj instanceof Short) && ((Short) obj).value == value;\n+    return value;\n   }\n \n-  // Verified that hashCode is returns plain value (see Short_1 test).\n-  public int hashCode()\n+  /** Return the value of this <code>Short</code> as a <code>double</code>.\n+   ** @return the value of this <code>Short</code> as a <code>double</code>.\n+   **/\n+  public double doubleValue()\n   {\n     return value;\n   }\n \n-  public String toString()\n+  /**\n+   * Compare two Shorts numerically by comparing their\n+   * <code>short</code> values.\n+   * @return a positive value if this <code>Short</code> is greater\n+   * in value than the argument <code>Short</code>; a negative value\n+   * if this <code>Short</code> is smaller in value than the argument\n+   * <code>Short</code>; and <code>0</code>, zero, if this\n+   * <code>Short</code> is equal in value to the argument\n+   * <code>Short</code>.  \n+   *\n+   * @since 1.2\n+   */\n+  public int compareTo(Short s)\n   {\n-    return Integer.toString((int) value);\n+    return value - s.value;\n   }\n-\n-  public static String toString(short value)\n+    \n+  /**\n+   * Behaves like <code>compareTo(java.lang.Short)</code> unless the Object\n+   * is not a <code>Short</code>.  Then it throws a \n+   * <code>ClassCastException</code>.\n+   * @exception ClassCastException if the argument is not a\n+   * <code>Short</code>.\n+   *\n+   * @since 1.2\n+   */\n+  public int compareTo(Object o)\n   {\n-    return Integer.toString((int) value);\n+    return compareTo((Short)o);\n   }\n }"}, {"sha": "de0db88743447b13768e253ea49d84b249960dd0", "filename": "libjava/java/lang/VMClassLoader.java", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6/libjava%2Fjava%2Flang%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMClassLoader.java?ref=e109d16f8c56fa61f9b4c15a2426ad07ac88cbd6", "patch": "@@ -0,0 +1,85 @@\n+/*\n+ * java.lang.ClassLoader: part of the Java Class Libraries project.\n+ * Copyright (C) 1998, 2001 Free Software Foundation\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Library General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public\n+ * License along with this library; if not, write to the\n+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+ * Boston, MA  02111-1307, USA.\n+ */\n+\n+package java.lang;\n+\n+/**\n+ * java.lang.VMClassLoader is a package-private helper for VMs to implement\n+ * on behalf of java.lang.ClassLoader.\n+ *\n+ * @author John Keiser\n+ * @version 1.1.0, Sep 22 1998\n+ * @since CP1.1\n+ */\n+\n+class VMClassLoader {\n+\n+    /** \n+     * Helper to define a class using a string of bytes.\n+     * \n+     * @param name the name to give the class.  null if unknown.\n+     * @param data the data representing the classfile, in classfile format.\n+     * @param offset the offset into the data where the classfile starts.\n+     * @param len the length of the classfile data in the array.\n+     * @return the class that was defined.\n+     * @exception ClassFormatError if the byte array is not in proper classfile format.\n+     */\n+  // Not yet needed for libgcj.\n+//      final static native Class defineClass(ClassLoader cl, String name, \n+//  \t     byte[] data, int offset, int len) throws ClassFormatError;\n+    \n+    /** \n+     * Helper to resolve all references to other classes from this class.\n+     * @param c the class to resolve.\n+     */\n+  // Not yet needed for libgcj.\n+  //    final static native void resolveClass(Class c);\n+\n+    /** \n+     * Helper for java.lang.Integer, Byte, etc. to get the TYPE class\n+     * at initialization time.  If there are multiple classloaders, this\n+     * method may be called once per ClassLoader per type.\n+     *\n+     * @param type name of the primitive type; i.e. \"int\", \"byte\", etc.\n+     * @return a \"bogus\" class representing the primitive type.\n+     */\n+  static final Class getPrimitiveClass(String type)\n+  {\n+    if (\"int\".equals (type))\n+      return int.class;\n+    else if (\"long\".equals (type))\n+      return int.class;\n+    else if (\"boolean\".equals (type))\n+      return int.class;\n+    else if (\"short\".equals (type))\n+      return int.class;\n+    else if (\"char\".equals (type))\n+      return int.class;\n+    else if (\"byte\".equals (type))\n+      return int.class;\n+    else if (\"float\".equals (type))\n+      return int.class;\n+    else if (\"double\".equals (type))\n+      return int.class;\n+    else if (\"void\".equals (type))\n+      return int.class;\n+    return null;\n+  }\n+}"}]}