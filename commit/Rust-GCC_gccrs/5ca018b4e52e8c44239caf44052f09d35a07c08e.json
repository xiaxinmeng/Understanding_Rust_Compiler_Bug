{"sha": "5ca018b4e52e8c44239caf44052f09d35a07c08e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNhMDE4YjRlNTJlOGM0NDIzOWNhZjQ0MDUyZjA5ZDM1YTA3YzA4ZQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-06-15T07:43:31Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1994-06-15T07:43:31Z"}, "message": "Add v9 support.\n\nFrom-SVN: r7483", "tree": {"sha": "f347e5cdf21ba7b943f75f0471c7fce9b541bee4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f347e5cdf21ba7b943f75f0471c7fce9b541bee4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ca018b4e52e8c44239caf44052f09d35a07c08e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca018b4e52e8c44239caf44052f09d35a07c08e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ca018b4e52e8c44239caf44052f09d35a07c08e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ca018b4e52e8c44239caf44052f09d35a07c08e/comments", "author": null, "committer": null, "parents": [{"sha": "4505c2363677092a5d45467ebff98d590d72fc50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4505c2363677092a5d45467ebff98d590d72fc50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4505c2363677092a5d45467ebff98d590d72fc50"}], "stats": {"total": 123, "additions": 118, "deletions": 5}, "files": [{"sha": "d75e1e8a7da9aa9ec62ef2008f1c7af0a60cb248", "filename": "gcc/ginclude/va-sparc.h", "status": "modified", "additions": 118, "deletions": 5, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ca018b4e52e8c44239caf44052f09d35a07c08e/gcc%2Fginclude%2Fva-sparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ca018b4e52e8c44239caf44052f09d35a07c08e/gcc%2Fginclude%2Fva-sparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-sparc.h?ref=5ca018b4e52e8c44239caf44052f09d35a07c08e", "patch": "@@ -6,6 +6,17 @@\n #ifndef __GNUC_VA_LIST\n #define __GNUC_VA_LIST\n \n+#ifdef __sparc_v9__\n+typedef long long __va_greg;\n+typedef double __va_freg;\n+typedef struct {\n+  __va_greg * __va_next_o;\t\t/* next available %o* register */\n+  __va_greg * __va_next_o_limit;\t/* past last available %o* register */\n+  __va_freg * __va_next_fp;\t\t/* next available %f* register */\n+  __va_freg * __va_next_fp_limit;\t/* last available %f* register */\n+  __va_greg * __va_next_stack;\t\t/* next extended word on stack */\n+} __gnuc_va_list;\n+#else\n #ifndef __svr4__\n /* This has to be a char * to be compatible with Sun.\n    i.e., we have to pass a `va_list' to vsprintf.  */\n@@ -15,6 +26,7 @@ typedef char * __gnuc_va_list;\n    i.e., we have to pass a `va_list' to vsprintf.  */\n typedef void * __gnuc_va_list;\n #endif\n+#endif /* not __sparc_v9__ */\n #endif /* not __GNUC_VA_LIST */\n \n /* If this is for internal libc use, don't define anything but\n@@ -23,6 +35,19 @@ typedef void * __gnuc_va_list;\n \n #ifdef _STDARG_H\n \n+#ifdef __sparc_v9__\n+#define va_start(AP, LASTARG) \\\n+__extension__ \\\n+  ({ \\\n+     AP.__va_next_o = (__va_greg *) __builtin_saveregs (); \\\n+     AP.__va_next_o_limit = (AP.__va_next_o + \\\n+\t\t\t     (__builtin_args_info (0) < 6 ? 6 - __builtin_args_info (0) : 0)); \\\n+     AP.__va_next_fp = (__va_freg *) AP.__va_next_o_limit; \\\n+     AP.__va_next_fp_limit = (AP.__va_next_fp + \\\n+\t\t\t      (__builtin_args_info (1) < 16 ? (16 - __builtin_args_info (1) + 1) / 2 : 0)); \\\n+     AP.__va_next_stack = (__va_greg *) __builtin_next_arg(); \\\n+  })\n+#else\n /* Call __builtin_next_arg even though we aren't using its value, so that\n    we can verify that LASTARG is correct.  */\n #ifdef __GCC_NEW_VARARGS__\n@@ -32,29 +57,67 @@ typedef void * __gnuc_va_list;\n #define va_start(AP, LASTARG)\t\t\t\t\t\\\n   (__builtin_saveregs (), AP = ((char *) __builtin_next_arg (LASTARG)))\n #endif\n+#endif /* not __sparc_v9__ */\n \n #else\n \n #define va_alist  __builtin_va_alist\n #define va_dcl    int __builtin_va_alist;...\n \n+#ifdef __sparc_v9__\n+#define va_start(AP) \\\n+__extension__ \\\n+  ({ \\\n+     AP.__va_next_o = (__va_greg *) __builtin_saveregs (); \\\n+     AP.__va_next_o_limit = (AP.__va_next_o + \\\n+\t\t\t     (__builtin_args_info (0) < 6 ? 6 - __builtin_args_info (0) : 0)); \\\n+     AP.__va_next_fp = (__va_freg *) AP.__va_next_o_limit; \\\n+     AP.__va_next_fp_limit = (AP.__va_next_fp + \\\n+\t\t\t      (__builtin_args_info (1) < 16 ? (16 - __builtin_args_info (1) + 1) / 2 : 0)); \\\n+     AP.__va_next_stack = (__va_greg *) __builtin_next_arg(); \\\n+  })\n+#else\n #ifdef __GCC_NEW_VARARGS__\n #define va_start(AP)\t\t((AP) = (char *) __builtin_saveregs ())\n #else\n #define va_start(AP) \t\t\t\t\t\t\\\n  (__builtin_saveregs (), (AP) = ((char *) &__builtin_va_alist))\n #endif\n+#endif /* not __sparc_v9__ */\n \n #endif\n \n #ifndef va_end\n void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n+\n+/* Values returned by __builtin_classify_type.  */\n+\n+enum __va_type_classes {\n+  __no_type_class = -1,\n+  __void_type_class,\n+  __integer_type_class,\n+  __char_type_class,\n+  __enumeral_type_class,\n+  __boolean_type_class,\n+  __pointer_type_class,\n+  __reference_type_class,\n+  __offset_type_class,\n+  __real_type_class,\n+  __complex_type_class,\n+  __function_type_class,\n+  __method_type_class,\n+  __record_type_class,\n+  __union_type_class,\n+  __array_type_class,\n+  __string_type_class,\n+  __set_type_class,\n+  __file_type_class,\n+  __lang_type_class\n+};\n+\n #endif\n #define va_end(pvar)\n \n-#define __va_rounded_size(TYPE)  \\\n-  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-\n /* Avoid errors if compiling GCC v2 with GCC v1.  */\n #if __GNUC__ == 1\n #define __extension__\n@@ -64,6 +127,56 @@ void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n    passed by invisible reference.  ??? RECORD_TYPE args passed\n    in the stack are made to be word-aligned; for an aggregate that is\n    not word-aligned, we advance the pointer to the first non-reg slot.  */\n+\n+#ifdef __sparc_v9__\n+\n+#define va_arg(pvar,TYPE)\t\t\t\t\t\\\n+__extension__\t\t\t\t\t\t\t\\\n+({int __type = __builtin_classify_type (* (TYPE *) 0);\t\t\\\n+  void * __result;\t\t\t\t\t\t\\\n+  if (__type == __real_type_class)\t\t/* float? */\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      __va_freg *__r;\t\t\t\t\t\t\\\n+      /* see PASS_IN_REG_P in sparc.h */\t\t\t\\\n+      if (pvar.__va_next_fp < pvar.__va_next_fp_limit\t\t\\\n+\t  && ((__r = (__va_freg *) (((__va_greg) pvar.__va_next_fp + sizeof (TYPE) - 1) & ~(__va_greg) (sizeof (TYPE) - 1))) \\\n+\t      < pvar.__va_next_fp_limit))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  pvar.__va_next_fp = __r + sizeof (TYPE) / 8;\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  __r = (__va_freg *) pvar.__va_next_stack;\t\t\\\n+\t  pvar.__va_next_stack += sizeof (TYPE) / 8;\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      __result = __r;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (__type < __record_type_class)\t/* integer? */\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      __va_greg *__r;\t\t\t\t\t\t\\\n+      if (pvar.__va_next_o < pvar.__va_next_o_limit)\t\t\\\n+\t__r = pvar.__va_next_o++;\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t__r = pvar.__va_next_stack++;\t\t\t\t\\\n+      /* adjust for 4 byte ints */\t\t\t\t\\\n+      __result = (char *) __r + 8 - sizeof (TYPE);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else /* aggregate object */\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      void **__r;\t\t\t\t\t\t\\\n+      if (pvar.__va_next_o < pvar.__va_next_o_limit)\t\t\\\n+\t__r = (void **) pvar.__va_next_o++;\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t__r = (void **) pvar.__va_next_stack++;\t\t\t\\\n+      __result = *__r;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  *(TYPE *) __result;})\n+\n+#else /* not __sparc_v9__ */\n+\n+#define __va_rounded_size(TYPE)  \\\n+  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n+\n /* We don't declare the union member `d' to have type TYPE\n    because that would lose in C++ if TYPE has a constructor.  */\n /* We cast to void * and then to TYPE * because this avoids\n@@ -72,7 +185,7 @@ void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n #define va_arg(pvar,TYPE)\t\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\\\n ({ TYPE __va_temp;\t\t\t\t\t\t\\\n-   ((__builtin_classify_type (__va_temp) >= 12)\t\t\t\\\n+   ((__builtin_classify_type (__va_temp) >= __record_type_class) \\\n     ? ((pvar) = (char *)(pvar) + __va_rounded_size (TYPE *),\t\\\n        **(TYPE **) (void *) ((char *)(pvar) - __va_rounded_size (TYPE *))) \\\n     : __va_rounded_size (TYPE) == 8\t\t\t\t\\\n@@ -83,6 +196,6 @@ __extension__\t\t\t\t\t\t\t\\\n \t *(TYPE *) (void *) __u.__d; })\t\t\t\t\\\n     : ((pvar) = (char *)(pvar) + __va_rounded_size (TYPE),\t\\\n        *((TYPE *) (void *) ((char *)(pvar) - __va_rounded_size (TYPE)))));})\n+#endif /* not __sparc_v9__ */\n \n #endif /* defined (_STDARG_H) || defined (_VARARGS_H) */\n-"}]}