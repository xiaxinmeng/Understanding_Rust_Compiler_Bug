{"sha": "c628a66a92f72add62608c2c24cf0ec4c5ae45af", "node_id": "C_kwDOANBUbNoAKGM2MjhhNjZhOTJmNzJhZGQ2MjYwOGMyYzI0Y2YwZWM0YzVhZTQ1YWY", "commit": {"author": {"name": "Faisal Abbas", "email": "90.abbasfaisal@gmail.com", "date": "2022-07-30T19:54:06Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-25T11:40:26Z"}, "message": "rust-constexpr.cc: port over more cases to eval_constant_expression().\nIts possible many of them are not useful for Rust so we can remove them\nin the clean up expected later.", "tree": {"sha": "6d9dbd42ab1dcbc9b5287a1800bbb075edeb829f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d9dbd42ab1dcbc9b5287a1800bbb075edeb829f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c628a66a92f72add62608c2c24cf0ec4c5ae45af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c628a66a92f72add62608c2c24cf0ec4c5ae45af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c628a66a92f72add62608c2c24cf0ec4c5ae45af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c628a66a92f72add62608c2c24cf0ec4c5ae45af/comments", "author": {"login": "abbasfaisal", "id": 9428333, "node_id": "MDQ6VXNlcjk0MjgzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/9428333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/abbasfaisal", "html_url": "https://github.com/abbasfaisal", "followers_url": "https://api.github.com/users/abbasfaisal/followers", "following_url": "https://api.github.com/users/abbasfaisal/following{/other_user}", "gists_url": "https://api.github.com/users/abbasfaisal/gists{/gist_id}", "starred_url": "https://api.github.com/users/abbasfaisal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/abbasfaisal/subscriptions", "organizations_url": "https://api.github.com/users/abbasfaisal/orgs", "repos_url": "https://api.github.com/users/abbasfaisal/repos", "events_url": "https://api.github.com/users/abbasfaisal/events{/privacy}", "received_events_url": "https://api.github.com/users/abbasfaisal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8e58d54db23acc03bba3bd9a89cfe35cf3c2ba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8e58d54db23acc03bba3bd9a89cfe35cf3c2ba3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8e58d54db23acc03bba3bd9a89cfe35cf3c2ba3"}], "stats": {"total": 116, "additions": 116, "deletions": 0}, "files": [{"sha": "3d7b8b0a73dfbba9f67ea0cb883b8f766a43c8db", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c628a66a92f72add62608c2c24cf0ec4c5ae45af/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c628a66a92f72add62608c2c24cf0ec4c5ae45af/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=c628a66a92f72add62608c2c24cf0ec4c5ae45af", "patch": "@@ -825,6 +825,8 @@ rs_fold_indirect_ref (const constexpr_ctx *ctx, location_t loc, tree type,\n   return NULL_TREE;\n }\n \n+// forked from gcc/cp/constexpr.cc cxx_eval_indirect_ref\n+\n static tree\n rs_eval_indirect_ref (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t      bool *non_constant_p, bool *overflow_p)\n@@ -935,6 +937,59 @@ eval_logical_expression (const constexpr_ctx *ctx, tree t, tree bailout_value,\n   return r;\n }\n \n+// forked from gcc/cp/constexp.rcc lookup_placeholder\n+\n+/* Find the object of TYPE under initialization in CTX.  */\n+\n+static tree\n+lookup_placeholder (const constexpr_ctx *ctx, bool lval, tree type)\n+{\n+  if (!ctx)\n+    return NULL_TREE;\n+\n+  /* Prefer the outermost matching object, but don't cross\n+     CONSTRUCTOR_PLACEHOLDER_BOUNDARY constructors.  */\n+  if (ctx->ctor && !CONSTRUCTOR_PLACEHOLDER_BOUNDARY (ctx->ctor))\n+    if (tree outer_ob = lookup_placeholder (ctx->parent, lval, type))\n+      return outer_ob;\n+\n+  /* We could use ctx->object unconditionally, but using ctx->ctor when we\n+     can is a minor optimization.  */\n+  if (!lval && ctx->ctor && same_type_p (TREE_TYPE (ctx->ctor), type))\n+    return ctx->ctor;\n+\n+  if (!ctx->object)\n+    return NULL_TREE;\n+\n+  /* Since an object cannot have a field of its own type, we can search outward\n+     from ctx->object to find the unique containing object of TYPE.  */\n+  tree ob = ctx->object;\n+  while (ob)\n+    {\n+      if (same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (ob), type))\n+\tbreak;\n+      if (handled_component_p (ob))\n+\tob = TREE_OPERAND (ob, 0);\n+      else\n+\tob = NULL_TREE;\n+    }\n+\n+  return ob;\n+}\n+\n+// forked from gcc/cp/constexp.rcc inline_asm_in_constexpr_error\n+\n+/* Complain about an attempt to evaluate inline assembly.  */\n+\n+static void\n+inline_asm_in_constexpr_error (location_t loc)\n+{\n+  auto_diagnostic_group d;\n+  error_at (loc, \"inline assembly is not a constant expression\");\n+  inform (loc, \"only unevaluated inline assembly is allowed in a \"\n+\t       \"%<constexpr%> function in C++20\");\n+}\n+\n static tree\n eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p,\n@@ -1096,6 +1151,14 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       r = rs_eval_indirect_ref (ctx, t, lval, non_constant_p, overflow_p);\n       break;\n \n+    case PAREN_EXPR:\n+      gcc_assert (!REF_PARENTHESIZED_P (t));\n+      /* A PAREN_EXPR resulting from __builtin_assoc_barrier has no effect in\n+\t constant expressions since it's unaffected by -fassociative-math.  */\n+      r = eval_constant_expression (ctx, TREE_OPERAND (t, 0), lval,\n+\t\t\t\t    non_constant_p, overflow_p);\n+      break;\n+\n     case NOP_EXPR:\n       if (REINTERPRET_CAST_P (t))\n \t{\n@@ -1151,6 +1214,25 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n \t}\n       break;\n \n+      case ADDR_EXPR: {\n+\ttree oldop = TREE_OPERAND (t, 0);\n+\ttree op = eval_constant_expression (ctx, oldop,\n+\t\t\t\t\t    /*lval*/ true, non_constant_p,\n+\t\t\t\t\t    overflow_p);\n+\t/* Don't VERIFY_CONSTANT here.  */\n+\tif (*non_constant_p)\n+\t  return t;\n+\tgcc_checking_assert (TREE_CODE (op) != CONSTRUCTOR);\n+\t/* This function does more aggressive folding than fold itself.  */\n+\tr = build_fold_addr_expr_with_type (op, TREE_TYPE (t));\n+\tif (TREE_CODE (r) == ADDR_EXPR && TREE_OPERAND (r, 0) == oldop)\n+\t  {\n+\t    ggc_free (r);\n+\t    return t;\n+\t  }\n+\tbreak;\n+      }\n+\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n       if (lval)\n@@ -1362,6 +1444,34 @@ eval_constant_expression (const constexpr_ctx *ctx, tree t, bool lval,\n       }\n       break;\n \n+    case PLACEHOLDER_EXPR:\n+      /* Use of the value or address of the current object.  */\n+      if (tree ctor = lookup_placeholder (ctx, lval, TREE_TYPE (t)))\n+\t{\n+\t  if (TREE_CODE (ctor) == CONSTRUCTOR)\n+\t    return ctor;\n+\t  else\n+\t    return eval_constant_expression (ctx, ctor, lval, non_constant_p,\n+\t\t\t\t\t     overflow_p);\n+\t}\n+      /* A placeholder without a referent.  We can get here when\n+\t checking whether NSDMIs are noexcept, or in massage_init_elt;\n+\t just say it's non-constant for now.  */\n+      gcc_assert (ctx->quiet);\n+      *non_constant_p = true;\n+      break;\n+\n+    case ANNOTATE_EXPR:\n+      r = eval_constant_expression (ctx, TREE_OPERAND (t, 0), lval,\n+\t\t\t\t    non_constant_p, overflow_p, jump_target);\n+      break;\n+\n+    case ASM_EXPR:\n+      if (!ctx->quiet)\n+\tinline_asm_in_constexpr_error (loc);\n+      *non_constant_p = true;\n+      return t;\n+\n     default:\n       break;\n     }"}, {"sha": "966dbebf30c98e94c05eab452667739bf14213df", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c628a66a92f72add62608c2c24cf0ec4c5ae45af/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c628a66a92f72add62608c2c24cf0ec4c5ae45af/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=c628a66a92f72add62608c2c24cf0ec4c5ae45af", "patch": "@@ -1263,6 +1263,12 @@ extern GTY (()) tree cp_global_trees[CPTI_MAX];\n    in ascending tree code order.  */\n #define TYPE_PTROB_P(NODE) (TYPE_PTR_P (NODE) && TYPE_OBJ_P (TREE_TYPE (NODE)))\n \n+/* True if this CONSTRUCTOR contains PLACEHOLDER_EXPRs referencing the\n+   CONSTRUCTOR's type not nested inside another CONSTRUCTOR marked with\n+   CONSTRUCTOR_PLACEHOLDER_BOUNDARY.  */\n+#define CONSTRUCTOR_PLACEHOLDER_BOUNDARY(NODE)                                 \\\n+  (TREE_LANG_FLAG_5 (CONSTRUCTOR_CHECK (NODE)))\n+\n #if defined ENABLE_TREE_CHECKING\n \n #define LANG_DECL_MIN_CHECK(NODE)                                              \\"}]}