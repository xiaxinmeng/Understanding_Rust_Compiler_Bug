{"sha": "36b505688d346254c6a9162e8016aec25cd31811", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZiNTA1Njg4ZDM0NjI1NGM2YTkxNjJlODAxNmFlYzI1Y2QzMTgxMQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-14T16:39:28Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-09-14T16:39:28Z"}, "message": "(find_dummy_reload): New args inmode, outmode.\n\n(find_reloads): Pass new args.\n(push_reload): Likewise.\n\nFrom-SVN: r5319", "tree": {"sha": "43f165cd30013321c6defa7a51a301adbcc4ff14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43f165cd30013321c6defa7a51a301adbcc4ff14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36b505688d346254c6a9162e8016aec25cd31811", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36b505688d346254c6a9162e8016aec25cd31811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36b505688d346254c6a9162e8016aec25cd31811", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36b505688d346254c6a9162e8016aec25cd31811/comments", "author": null, "committer": null, "parents": [{"sha": "da57b63af981a013f90a2e91b65766e55ab820c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da57b63af981a013f90a2e91b65766e55ab820c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da57b63af981a013f90a2e91b65766e55ab820c8"}], "stats": {"total": 30, "additions": 21, "deletions": 9}, "files": [{"sha": "588ef2af154e42af3c6d85fc9eae882e6f50eb4b", "filename": "gcc/reload.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36b505688d346254c6a9162e8016aec25cd31811/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36b505688d346254c6a9162e8016aec25cd31811/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=36b505688d346254c6a9162e8016aec25cd31811", "patch": "@@ -267,6 +267,7 @@ static int push_reload\t\tPROTO((rtx, rtx, rtx *, rtx *, enum reg_class,\n static void push_replacement\tPROTO((rtx *, int, enum machine_mode));\n static void combine_reloads\tPROTO((void));\n static rtx find_dummy_reload\tPROTO((rtx, rtx, rtx *, rtx *,\n+\t\t\t\t       enum machine_mode, enum machine_mode,\n \t\t\t\t       enum reg_class, int));\n static int hard_reg_set_here_p\tPROTO((int, int, rtx));\n static struct decomposition decompose PROTO((rtx));\n@@ -1294,6 +1295,7 @@ push_reload (in, out, inloc, outloc, class,\n   if (in != 0 && out != 0 && in != out && reload_reg_rtx[i] == 0)\n     {\n       reload_reg_rtx[i] = find_dummy_reload (in, out, inloc, outloc,\n+\t\t\t\t\t     inmode, outmode,\n \t\t\t\t\t     reload_reg_class[i], i);\n \n       /* If the outgoing register already contains the same value\n@@ -1591,9 +1593,11 @@ combine_reloads ()\n    is just to see if a register can be found, not to find and install it.  */\n \n static rtx\n-find_dummy_reload (real_in, real_out, inloc, outloc, class, for_real)\n+find_dummy_reload (real_in, real_out, inloc, outloc,\n+\t\t   inmode, outmode, class, for_real)\n      rtx real_in, real_out;\n      rtx *inloc, *outloc;\n+     enum machine_mode inmode, outmode;\n      enum reg_class class;\n      int for_real;\n {\n@@ -1605,9 +1609,9 @@ find_dummy_reload (real_in, real_out, inloc, outloc, class, for_real)\n \n   /* If operands exceed a word, we can't use either of them\n      unless they have the same size.  */\n-  if (GET_MODE_SIZE (GET_MODE (real_out)) != GET_MODE_SIZE (GET_MODE (real_in))\n-      && (GET_MODE_SIZE (GET_MODE (real_out)) > UNITS_PER_WORD\n-\t  || GET_MODE_SIZE (GET_MODE (real_in)) > UNITS_PER_WORD))\n+  if (GET_MODE_SIZE (outmode) != GET_MODE_SIZE (inmode)\n+      && (GET_MODE_SIZE (outmode) > UNITS_PER_WORD\n+\t  || GET_MODE_SIZE (inmode) > UNITS_PER_WORD))\n     return 0;\n \n   /* Find the inside of any subregs.  */\n@@ -1631,7 +1635,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc, class, for_real)\n       && REGNO (out) < FIRST_PSEUDO_REGISTER)\n     {\n       register int regno = REGNO (out) + out_offset;\n-      int nwords = HARD_REGNO_NREGS (regno, GET_MODE (real_out));\n+      int nwords = HARD_REGNO_NREGS (regno, outmode);\n       rtx saved_rtx;\n \n       /* When we consider whether the insn uses OUT,\n@@ -1666,7 +1670,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc, class, for_real)\n \t      if (GET_CODE (real_out) == REG)\n \t\tvalue = real_out;\n \t      else\n-\t\tvalue = gen_rtx (REG, GET_MODE (real_out), regno);\n+\t\tvalue = gen_rtx (REG, outmode, regno);\n \t    }\n \t}\n \n@@ -1685,10 +1689,16 @@ find_dummy_reload (real_in, real_out, inloc, outloc, class, for_real)\n \t  || find_reg_note (this_insn, REG_UNUSED, real_out))\n       && find_reg_note (this_insn, REG_DEAD, real_in)\n       && !fixed_regs[REGNO (in)]\n-      && HARD_REGNO_MODE_OK (REGNO (in), GET_MODE (out)))\n+      && HARD_REGNO_MODE_OK (REGNO (in),\n+\t\t\t     /* The only case where out and real_out might\n+\t\t\t\thave different modes is where real_out\n+\t\t\t\tis a subreg, and in that case, out\n+\t\t\t\thas a real mode.  */\n+\t\t\t     (GET_MODE (out) != VOIDmode\n+\t\t\t      ? GET_MODE (out) : outmode)))\n     {\n       register int regno = REGNO (in) + in_offset;\n-      int nwords = HARD_REGNO_NREGS (regno, GET_MODE (real_in));\n+      int nwords = HARD_REGNO_NREGS (regno, inmode);\n \n       if (! refers_to_regno_for_reload_p (regno, regno + nwords, out, NULL_PTR)\n \t  && ! hard_reg_set_here_p (regno, regno + nwords,\n@@ -1710,7 +1720,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc, class, for_real)\n \t      if (GET_CODE (real_in) == REG)\n \t\tvalue = real_in;\n \t      else\n-\t\tvalue = gen_rtx (REG, GET_MODE (real_in), regno);\n+\t\tvalue = gen_rtx (REG, inmode, regno);\n \t    }\n \t}\n     }\n@@ -2690,6 +2700,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t    value\n \t\t      = find_dummy_reload (recog_operand[i], recog_operand[c],\n \t\t\t\t\t   recog_operand_loc[i], recog_operand_loc[c],\n+\t\t\t\t\t   insn_operand_mode[insn_code_number][i],\n+\t\t\t\t\t   insn_operand_mode[insn_code_number][c],\n \t\t\t\t\t   this_alternative[c], -1);\n \n \t\t    if (value != 0)"}]}