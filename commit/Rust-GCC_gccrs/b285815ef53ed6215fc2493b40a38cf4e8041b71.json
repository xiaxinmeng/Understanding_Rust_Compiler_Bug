{"sha": "b285815ef53ed6215fc2493b40a38cf4e8041b71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI4NTgxNWVmNTNlZDYyMTVmYzI0OTNiNDBhMzhjZjRlODA0MWI3MQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2012-03-15T09:07:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-03-15T09:07:53Z"}, "message": "sem_prag.adb, [...]: Minor reformatting.\n\n2012-03-15  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb, sem_prag.ads, sem_util.ads, sem_attr.adb, sem_ch6.adb,\n\tsem_warn.adb: Minor reformatting.\n\nFrom-SVN: r185418", "tree": {"sha": "f08e18d678f1252132c0e9fe308b4ac8aa5036e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f08e18d678f1252132c0e9fe308b4ac8aa5036e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b285815ef53ed6215fc2493b40a38cf4e8041b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b285815ef53ed6215fc2493b40a38cf4e8041b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b285815ef53ed6215fc2493b40a38cf4e8041b71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b285815ef53ed6215fc2493b40a38cf4e8041b71/comments", "author": null, "committer": null, "parents": [{"sha": "22f46473c7f98a4f414db8728ba64a60a6e23a16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22f46473c7f98a4f414db8728ba64a60a6e23a16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22f46473c7f98a4f414db8728ba64a60a6e23a16"}], "stats": {"total": 612, "additions": 307, "deletions": 305}, "files": [{"sha": "c9063a650f0cca59f68127bc75b83a6bf9882045", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b285815ef53ed6215fc2493b40a38cf4e8041b71", "patch": "@@ -1,3 +1,8 @@\n+2012-03-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb, sem_prag.ads, sem_util.ads, sem_attr.adb, sem_ch6.adb,\n+\tsem_warn.adb: Minor reformatting.\n+\n 2012-03-15  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_util.adb (Initialized_By_Ctrl_Function): Do not loop over"}, {"sha": "d5164865df407acbfb6136ff63272c8d18e3f038", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=b285815ef53ed6215fc2493b40a38cf4e8041b71", "patch": "@@ -1122,9 +1122,7 @@ package body Sem_Attr is\n \n          --  Case of a subtype mark\n \n-         if Is_Entity_Name (P)\n-           and then Is_Type (Entity (P))\n-         then\n+         if Is_Entity_Name (P) and then Is_Type (Entity (P)) then\n             return;\n          end if;\n \n@@ -1134,13 +1132,13 @@ package body Sem_Attr is\n \n          if Is_Access_Type (P_Type) then\n \n-            --  If there is an implicit dereference, then we must freeze\n-            --  the designated type of the access type, since the type of\n-            --  the referenced array is this type (see AI95-00106).\n+            --  If there is an implicit dereference, then we must freeze the\n+            --  designated type of the access type, since the type of the\n+            --  referenced array is this type (see AI95-00106).\n \n             --  As done elsewhere, freezing must not happen when pre-analyzing\n-            --  a pre- or postcondition or a default value for an object or\n-            --  for a formal parameter.\n+            --  a pre- or postcondition or a default value for an object or for\n+            --  a formal parameter.\n \n             if not In_Spec_Expression then\n                Freeze_Before (N, Designated_Type (P_Type));\n@@ -4257,7 +4255,8 @@ package body Sem_Attr is\n                   P);\n \n             elsif Get_Pragma_Id (Prag) = Pragma_Contract_Case\n-              or else Get_Pragma_Id (Prag) = Pragma_Test_Case\n+                    or else\n+                  Get_Pragma_Id (Prag) = Pragma_Test_Case\n             then\n                declare\n                   Arg_Ens : constant Node_Id :="}, {"sha": "391ac8034e5813f5177b2662e0c7421ffc58eac3", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 48, "deletions": 52, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=b285815ef53ed6215fc2493b40a38cf4e8041b71", "patch": "@@ -7076,7 +7076,6 @@ package body Sem_Ch6 is\n \n       begin\n          Prag := Spec_CTC_List (Contract (Spec));\n-\n          loop\n             --  Retrieve the Ensures component of the contract-case, if any\n \n@@ -7130,19 +7129,15 @@ package body Sem_Ch6 is\n \n       begin\n          Prag := Spec_PPC_List (Contract (Spec));\n-\n          loop\n             Arg := First (Pragma_Argument_Associations (Prag));\n \n             if Pragma_Name (Prag) = Name_Postcondition then\n \n                --  Since pre- and post-conditions are listed in reverse order,\n-               --  the first postcondition in the list is the last in the\n-               --  source.\n+               --  the first postcondition in the list is last in the source.\n \n-               if not Class\n-                 and then No (Last_Postcondition)\n-               then\n+               if not Class and then No (Last_Postcondition) then\n                   Last_Postcondition := Prag;\n                end if;\n \n@@ -7161,8 +7156,8 @@ package body Sem_Ch6 is\n                   Ignored := Find_Post_State (Arg);\n \n                   if not Post_State_Mentioned then\n-                     Error_Msg_N (\"?postcondition refers only to pre-state\",\n-                                  Prag);\n+                     Error_Msg_N\n+                       (\"?postcondition refers only to pre-state\", Prag);\n                   end if;\n                end if;\n             end if;\n@@ -7208,7 +7203,7 @@ package body Sem_Ch6 is\n \n       if Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n         and then (Present (Last_Postcondition)\n-                    or else Present (Last_Contract_Case))\n+                   or else Present (Last_Contract_Case))\n         and then not Attribute_Result_Mentioned\n       then\n          if Present (Last_Postcondition) then\n@@ -11045,75 +11040,77 @@ package body Sem_Ch6 is\n       -------------\n \n       function Grab_CC return Node_Id is\n+         Loc  : constant Source_Ptr := Sloc (Prag);\n          CP   : Node_Id;\n          Req  : Node_Id;\n          Ens  : Node_Id;\n          Post : Node_Id;\n-         Loc  : constant Source_Ptr := Sloc (Prag);\n \n-         --  Similarly to postcondition, the string is \"failed xx from yy\"\n-         --  where xx is in all lower case. The reason for this different\n-         --  wording compared to other Check cases is that the failure is not\n-         --  at the point of occurrence of the pragma, unlike the other Check\n-         --  cases.\n+         --  As with postcondition, the string is \"failed xx from yy\" where\n+         --  xx is in all lower case. The reason for this different wording\n+         --  compared to other Check cases is that the failure is not at the\n+         --  point of occurrence of the pragma, unlike the other Check cases.\n \n          Msg  : constant String :=\n                   \"failed contract case from \" & Build_Location_String (Loc);\n \n       begin\n          --  Copy the Requires and Ensures expressions\n \n-         Req  := New_Copy_Tree (\n-                   Expression (Get_Requires_From_Case_Pragma (Prag)),\n-                   New_Scope => Current_Scope);\n+         Req  := New_Copy_Tree\n+                   (Expression (Get_Requires_From_Case_Pragma (Prag)),\n+                    New_Scope => Current_Scope);\n \n-         Ens  := New_Copy_Tree (\n-                   Expression (Get_Ensures_From_Case_Pragma (Prag)),\n-                   New_Scope => Current_Scope);\n+         Ens  := New_Copy_Tree\n+                   (Expression (Get_Ensures_From_Case_Pragma (Prag)),\n+                    New_Scope => Current_Scope);\n \n          --  Build the postcondition (not Requires'Old or else Ensures)\n \n-         Post := Make_Or_Else (Loc,\n-                   Left_Opnd  => Make_Op_Not (Loc,\n-                                   Make_Attribute_Reference (Loc,\n-                                     Prefix         => Req,\n-                                     Attribute_Name => Name_Old)),\n-                   Right_Opnd => Ens);\n+         Post :=\n+           Make_Or_Else (Loc,\n+             Left_Opnd  =>\n+               Make_Op_Not (Loc,\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => Req,\n+                   Attribute_Name => Name_Old)),\n+             Right_Opnd => Ens);\n \n          --  For a contract case pragma within a generic, generate a\n          --  postcondition pragma for later expansion. This is also used\n          --  when an error was detected, thus setting Expander_Active to False.\n \n          if not Expander_Active then\n-            CP := Make_Pragma (Loc,\n-                    Chars => Name_Postcondition,\n-                    Pragma_Argument_Associations => New_List (\n-                      Make_Pragma_Argument_Association (Loc,\n-                        Chars      => Name_Check,\n-                        Expression => Post),\n-\n-                      Make_Pragma_Argument_Association (Loc,\n-                        Chars      => Name_Message,\n-                        Expression => Make_String_Literal (Loc, Msg))));\n+            CP :=\n+              Make_Pragma (Loc,\n+                Chars => Name_Postcondition,\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Chars      => Name_Check,\n+                    Expression => Post),\n+\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Chars      => Name_Message,\n+                    Expression => Make_String_Literal (Loc, Msg))));\n \n          --  Otherwise, create the Check pragma\n \n          else\n-            CP := Make_Pragma (Loc,\n-                    Chars => Name_Check,\n-                    Pragma_Argument_Associations => New_List (\n-                      Make_Pragma_Argument_Association (Loc,\n-                        Chars      => Name_Name,\n-                        Expression =>\n-                          Make_Identifier (Loc, Name_Postcondition)),\n+            CP :=\n+              Make_Pragma (Loc,\n+                Chars                        => Name_Check,\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Chars      => Name_Name,\n+                    Expression => Make_Identifier (Loc, Name_Postcondition)),\n \n-                      Make_Pragma_Argument_Association (Loc,\n-                        Chars      => Name_Check,\n-                        Expression => Post),\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Chars      => Name_Check,\n+                    Expression => Post),\n \n-                      Make_Pragma_Argument_Association (Loc,\n-                        Chars      => Name_Message,\n-                        Expression => Make_String_Literal (Loc, Msg))));\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Chars      => Name_Message,\n+                    Expression => Make_String_Literal (Loc, Msg))));\n          end if;\n \n          --  Return the Postcondition or Check pragma\n@@ -11534,7 +11531,6 @@ package body Sem_Ch6 is\n                   Prag := Next_Pragma (Prag);\n                   exit when No (Prag);\n                end loop;\n-\n             end Process_Contract_Cases;\n \n             -----------------------------"}, {"sha": "51ca907a3817187604936a7222d5eb9da41f8004", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 235, "deletions": 235, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b285815ef53ed6215fc2493b40a38cf4e8041b71", "patch": "@@ -243,6 +243,32 @@ package body Sem_Prag is\n       end if;\n    end Adjust_External_Name_Case;\n \n+   ------------------------------\n+   -- Analyze_CTC_In_Decl_Part --\n+   ------------------------------\n+\n+   procedure Analyze_CTC_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n+   begin\n+      --  Install formals and push subprogram spec onto scope stack so that we\n+      --  can see the formals from the pragma.\n+\n+      Install_Formals (S);\n+      Push_Scope (S);\n+\n+      --  Preanalyze the boolean expressions, we treat these as spec\n+      --  expressions (i.e. similar to a default expression).\n+\n+      Preanalyze_CTC_Args\n+        (N,\n+         Get_Requires_From_Case_Pragma (N),\n+         Get_Ensures_From_Case_Pragma (N));\n+\n+      --  Remove the subprogram from the scope stack now that the pre-analysis\n+      --  of the expressions in the contract case or test case is done.\n+\n+      End_Scope;\n+   end Analyze_CTC_In_Decl_Part;\n+\n    ------------------------------\n    -- Analyze_PPC_In_Decl_Part --\n    ------------------------------\n@@ -532,6 +558,18 @@ package body Sem_Prag is\n       --  UU_Typ is the related Unchecked_Union type. Flag In_Variant_Part\n       --  should be set when Comp comes from a record variant.\n \n+      procedure Check_Contract_Or_Test_Case;\n+      --  Called to process a contract-case or test-case pragma. It\n+      --  starts with checking pragma arguments, and the rest of the\n+      --  treatment is similar to the one for pre- and postcondition in\n+      --  Check_Precondition_Postcondition, except the placement rules for the\n+      --  contract-case and test-case pragmas are stricter. These pragmas may\n+      --  only occur after a subprogram spec declared directly in a package\n+      --  spec unit. In this case, the pragma is chained to the subprogram in\n+      --  question (using Spec_CTC_List and Next_Pragma) and analysis of the\n+      --  pragma is delayed till the end of the spec. In all other cases, an\n+      --  error message for bad placement is given.\n+\n       procedure Check_Duplicate_Pragma (E : Entity_Id);\n       --  Check if a pragma of the same name as the current pragma is already\n       --  chained as a rep pragma to the given entity. If so give a message\n@@ -637,17 +675,6 @@ package body Sem_Prag is\n       --  that the constraint is static as required by the restrictions for\n       --  Unchecked_Union.\n \n-      procedure Check_Contract_Or_Test_Case;\n-      --  Called to process a contract-case or test-case pragma. The\n-      --  treatment is similar to the one for pre- and postcondition in\n-      --  Check_Precondition_Postcondition, except the placement rules for the\n-      --  contract-case and test-case pragmas are stricter. These pragmas may\n-      --  only occur after a subprogram spec declared directly in a package\n-      --  spec unit. In this case, the pragma is chained to the subprogram in\n-      --  question (using Spec_CTC_List and Next_Pragma) and analysis of the\n-      --  pragma is delayed till the end of the spec. In all other cases, an\n-      --  error message for bad placement is given.\n-\n       procedure Check_Valid_Configuration_Pragma;\n       --  Legality checks for placement of a configuration pragma\n \n@@ -1389,6 +1416,179 @@ package body Sem_Prag is\n          end if;\n       end Check_Component;\n \n+      ---------------------------------\n+      -- Check_Contract_Or_Test_Case --\n+      ---------------------------------\n+\n+      procedure Check_Contract_Or_Test_Case is\n+         P  : Node_Id;\n+         PO : Node_Id;\n+\n+         procedure Chain_CTC (PO : Node_Id);\n+         --  If PO is a [generic] subprogram declaration node, then the\n+         --  contract-case or test-case applies to this subprogram and the\n+         --  processing for the pragma is completed. Otherwise the pragma\n+         --  is misplaced.\n+\n+         ---------------\n+         -- Chain_CTC --\n+         ---------------\n+\n+         procedure Chain_CTC (PO : Node_Id) is\n+            S   : Entity_Id;\n+\n+         begin\n+            if Nkind (PO) = N_Abstract_Subprogram_Declaration then\n+               Error_Pragma\n+                 (\"pragma% cannot be applied to abstract subprogram\");\n+\n+            elsif Nkind (PO) = N_Entry_Declaration then\n+               Error_Pragma (\"pragma% cannot be applied to entry\");\n+\n+            elsif not Nkind_In (PO, N_Subprogram_Declaration,\n+                                    N_Generic_Subprogram_Declaration)\n+            then\n+               Pragma_Misplaced;\n+            end if;\n+\n+            --  Here if we have [generic] subprogram declaration\n+\n+            S := Defining_Unit_Name (Specification (PO));\n+\n+            --  Note: we do not analyze the pragma at this point. Instead we\n+            --  delay this analysis until the end of the declarative part in\n+            --  which the pragma appears. This implements the required delay\n+            --  in this analysis, allowing forward references. The analysis\n+            --  happens at the end of Analyze_Declarations.\n+\n+            --  There should not be another contract-case or test-case with the\n+            --  same name associated to this subprogram.\n+\n+            declare\n+               Name : constant String_Id := Get_Name_From_Case_Pragma (N);\n+               CTC  : Node_Id;\n+\n+            begin\n+               CTC := Spec_CTC_List (Contract (S));\n+               while Present (CTC) loop\n+                  if String_Equal (Name, Get_Name_From_Case_Pragma (CTC)) then\n+                     Error_Msg_Sloc := Sloc (CTC);\n+                     Error_Pragma (\"name for pragma% is already used#\");\n+                  end if;\n+\n+                  CTC := Next_Pragma (CTC);\n+               end loop;\n+            end;\n+\n+            --  Chain spec CTC pragma to list for subprogram\n+\n+            Set_Next_Pragma (N, Spec_CTC_List (Contract (S)));\n+            Set_Spec_CTC_List (Contract (S), N);\n+         end Chain_CTC;\n+\n+      --  Start of processing for Check_Contract_Or_Test_Case\n+\n+      begin\n+         --  First check pragma arguments\n+\n+         GNAT_Pragma;\n+         Check_At_Least_N_Arguments (2);\n+         Check_At_Most_N_Arguments (4);\n+         Check_Arg_Order\n+           ((Name_Name, Name_Mode, Name_Requires, Name_Ensures));\n+\n+         Check_Optional_Identifier (Arg1, Name_Name);\n+         Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+\n+         --  In ASIS mode, for a pragma generated from a source aspect, also\n+         --  analyze the original aspect expression.\n+\n+         if ASIS_Mode\n+           and then Present (Corresponding_Aspect (N))\n+         then\n+            Check_Expr_Is_Static_Expression\n+              (Original_Node (Get_Pragma_Arg (Arg1)), Standard_String);\n+         end if;\n+\n+         Check_Optional_Identifier (Arg2, Name_Mode);\n+         Check_Arg_Is_One_Of (Arg2, Name_Nominal, Name_Robustness);\n+\n+         if Arg_Count = 4 then\n+            Check_Identifier (Arg3, Name_Requires);\n+            Check_Identifier (Arg4, Name_Ensures);\n+\n+         elsif Arg_Count = 3 then\n+            Check_Identifier_Is_One_Of (Arg3, Name_Requires, Name_Ensures);\n+         end if;\n+\n+         --  Check pragma placement\n+\n+         if not Is_List_Member (N) then\n+            Pragma_Misplaced;\n+         end if;\n+\n+         --  Contract-case or test-case should only appear in package spec unit\n+\n+         if Get_Source_Unit (N) = No_Unit\n+           or else not Nkind_In (Sinfo.Unit (Cunit (Get_Source_Unit (N))),\n+                                 N_Package_Declaration,\n+                                 N_Generic_Package_Declaration)\n+         then\n+            Pragma_Misplaced;\n+         end if;\n+\n+         --  Search prior declarations\n+\n+         P := N;\n+         while Present (Prev (P)) loop\n+            P := Prev (P);\n+\n+            --  If the previous node is a generic subprogram, do not go to to\n+            --  the original node, which is the unanalyzed tree: we need to\n+            --  attach the contract-case or test-case to the analyzed version\n+            --  at this point. They get propagated to the original tree when\n+            --  analyzing the corresponding body.\n+\n+            if Nkind (P) not in N_Generic_Declaration then\n+               PO := Original_Node (P);\n+            else\n+               PO := P;\n+            end if;\n+\n+            --  Skip past prior pragma\n+\n+            if Nkind (PO) = N_Pragma then\n+               null;\n+\n+            --  Skip stuff not coming from source\n+\n+            elsif not Comes_From_Source (PO) then\n+               null;\n+\n+            --  Only remaining possibility is subprogram declaration. First\n+            --  check that it is declared directly in a package declaration.\n+            --  This may be either the package declaration for the current unit\n+            --  being defined or a local package declaration.\n+\n+            elsif not Present (Parent (Parent (PO)))\n+              or else not Present (Parent (Parent (Parent (PO))))\n+              or else not Nkind_In (Parent (Parent (PO)),\n+                                    N_Package_Declaration,\n+                                    N_Generic_Package_Declaration)\n+            then\n+               Pragma_Misplaced;\n+\n+            else\n+               Chain_CTC (PO);\n+               return;\n+            end if;\n+         end loop;\n+\n+         --  If we fall through, pragma was misplaced\n+\n+         Pragma_Misplaced;\n+      end Check_Contract_Or_Test_Case;\n+\n       ----------------------------\n       -- Check_Duplicate_Pragma --\n       ----------------------------\n@@ -2114,162 +2314,6 @@ package body Sem_Prag is\n          end case;\n       end Check_Static_Constraint;\n \n-      ---------------------------------\n-      -- Check_Contract_Or_Test_Case --\n-      ---------------------------------\n-\n-      procedure Check_Contract_Or_Test_Case is\n-         P  : Node_Id;\n-         PO : Node_Id;\n-\n-         procedure Chain_CTC (PO : Node_Id);\n-         --  If PO is a [generic] subprogram declaration node, then the\n-         --  contract-case or test-case applies to this subprogram and the\n-         --  processing for the pragma is completed. Otherwise the pragma\n-         --  is misplaced.\n-\n-         ---------------\n-         -- Chain_CTC --\n-         ---------------\n-\n-         procedure Chain_CTC (PO : Node_Id) is\n-            S   : Entity_Id;\n-\n-         begin\n-            if Nkind (PO) = N_Abstract_Subprogram_Declaration then\n-               if From_Aspect_Specification (N) then\n-                  Error_Pragma\n-                    (\"aspect% cannot be applied to abstract subprogram\");\n-               else\n-                  Error_Pragma\n-                    (\"pragma% cannot be applied to abstract subprogram\");\n-               end if;\n-\n-            elsif Nkind (PO) = N_Entry_Declaration then\n-               if From_Aspect_Specification (N) then\n-                  Error_Pragma (\"aspect% cannot be applied to entry\");\n-               else\n-                  Error_Pragma (\"pragma% cannot be applied to entry\");\n-               end if;\n-\n-            elsif not Nkind_In (PO, N_Subprogram_Declaration,\n-                                    N_Generic_Subprogram_Declaration)\n-            then\n-               Pragma_Misplaced;\n-            end if;\n-\n-            --  Here if we have [generic] subprogram declaration\n-\n-            S := Defining_Unit_Name (Specification (PO));\n-\n-            --  Note: we do not analyze the pragma at this point. Instead we\n-            --  delay this analysis until the end of the declarative part in\n-            --  which the pragma appears. This implements the required delay\n-            --  in this analysis, allowing forward references. The analysis\n-            --  happens at the end of Analyze_Declarations.\n-\n-            --  There should not be another contract-case or test-case with the\n-            --  same name associated to this subprogram.\n-\n-            declare\n-               Name : constant String_Id := Get_Name_From_Case_Pragma (N);\n-               CTC   : Node_Id;\n-\n-            begin\n-               CTC := Spec_CTC_List (Contract (S));\n-               while Present (CTC) loop\n-\n-                  if String_Equal\n-                    (Name, Get_Name_From_Case_Pragma (CTC))\n-                  then\n-                     Error_Msg_Sloc := Sloc (CTC);\n-\n-                     if From_Aspect_Specification (N) then\n-                        Error_Pragma (\"name for aspect% is already used#\");\n-                     else\n-                        Error_Pragma (\"name for pragma% is already used#\");\n-                     end if;\n-                  end if;\n-\n-                  CTC := Next_Pragma (CTC);\n-               end loop;\n-            end;\n-\n-            --  Chain spec CTC pragma to list for subprogram\n-\n-            Set_Next_Pragma (N, Spec_CTC_List (Contract (S)));\n-            Set_Spec_CTC_List (Contract (S), N);\n-         end Chain_CTC;\n-\n-      --  Start of processing for Check_Contract_Or_Test_Case\n-\n-      begin\n-         if not Is_List_Member (N) then\n-            Pragma_Misplaced;\n-         end if;\n-\n-         --  Contract-case or test-case should only appear in package spec unit\n-\n-         if Get_Source_Unit (N) = No_Unit\n-           or else not Nkind_In (Sinfo.Unit (Cunit (Get_Source_Unit (N))),\n-                                 N_Package_Declaration,\n-                                 N_Generic_Package_Declaration)\n-         then\n-            Pragma_Misplaced;\n-         end if;\n-\n-         --  Search prior declarations\n-\n-         P := N;\n-         while Present (Prev (P)) loop\n-            P := Prev (P);\n-\n-            --  If the previous node is a generic subprogram, do not go to to\n-            --  the original node, which is the unanalyzed tree: we need to\n-            --  attach the contract-case or test-case to the analyzed version\n-            --  at this point. They get propagated to the original tree when\n-            --  analyzing the corresponding body.\n-\n-            if Nkind (P) not in N_Generic_Declaration then\n-               PO := Original_Node (P);\n-            else\n-               PO := P;\n-            end if;\n-\n-            --  Skip past prior pragma\n-\n-            if Nkind (PO) = N_Pragma then\n-               null;\n-\n-            --  Skip stuff not coming from source\n-\n-            elsif not Comes_From_Source (PO) then\n-               null;\n-\n-            --  Only remaining possibility is subprogram declaration. First\n-            --  check that it is declared directly in a package declaration.\n-            --  This may be either the package declaration for the current unit\n-            --  being defined or a local package declaration.\n-\n-            elsif not Present (Parent (Parent (PO)))\n-              or else not Present (Parent (Parent (Parent (PO))))\n-              or else not Nkind_In (Parent (Parent (PO)),\n-                                    N_Package_Declaration,\n-                                    N_Generic_Package_Declaration)\n-            then\n-               Pragma_Misplaced;\n-\n-            else\n-               Chain_CTC (PO);\n-               return;\n-            end if;\n-         end loop;\n-\n-         --  If we fall through, pragma was misplaced\n-\n-         Pragma_Misplaced;\n-      end Check_Contract_Or_Test_Case;\n-\n       --------------------------------------\n       -- Check_Valid_Configuration_Pragma --\n       --------------------------------------\n@@ -7534,6 +7578,21 @@ package body Sem_Prag is\n             end if;\n          end Component_AlignmentP;\n \n+         -------------------\n+         -- Contract_Case --\n+         -------------------\n+\n+         --  pragma Contract_Case\n+         --    ([Name     =>] Static_String_EXPRESSION\n+         --    ,[Mode     =>] MODE_TYPE\n+         --   [, Requires =>  Boolean_EXPRESSION]\n+         --   [, Ensures  =>  Boolean_EXPRESSION]);\n+\n+         --  MODE_TYPE ::= Nominal | Robustness\n+\n+         when Pragma_Contract_Case =>\n+            Check_Contract_Or_Test_Case;\n+\n          ----------------\n          -- Controlled --\n          ----------------\n@@ -13906,54 +13965,20 @@ package body Sem_Prag is\n             end if;\n          end Task_Storage;\n \n-         -------------------------------\n-         -- Contract_Case | Test_Case --\n-         -------------------------------\n+         ---------------\n+         -- Test_Case --\n+         ---------------\n \n-         --  pragma (Contract_Case | Test_Case)\n-         --                   ([Name     =>] Static_String_EXPRESSION\n-         --                   ,[Mode     =>] MODE_TYPE\n-         --                  [, Requires =>  Boolean_EXPRESSION]\n-         --                  [, Ensures  =>  Boolean_EXPRESSION]);\n+         --  pragma Test_Case\n+         --    ([Name     =>] Static_String_EXPRESSION\n+         --    ,[Mode     =>] MODE_TYPE\n+         --   [, Requires =>  Boolean_EXPRESSION]\n+         --   [, Ensures  =>  Boolean_EXPRESSION]);\n \n          --  MODE_TYPE ::= Nominal | Robustness\n \n-         when Pragma_Contract_Case |\n-              Pragma_Test_Case =>\n-         Contract_Or_Test_Case : declare\n-         begin\n-            GNAT_Pragma;\n-            Check_At_Least_N_Arguments (2);\n-            Check_At_Most_N_Arguments (4);\n-            Check_Arg_Order\n-                 ((Name_Name, Name_Mode, Name_Requires, Name_Ensures));\n-\n-            Check_Optional_Identifier (Arg1, Name_Name);\n-            Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n-\n-            --  In ASIS mode, for a pragma generated from a source aspect, also\n-            --  analyze the original aspect expression.\n-\n-            if ASIS_Mode\n-              and then Present (Corresponding_Aspect (N))\n-            then\n-               Check_Expr_Is_Static_Expression\n-                 (Original_Node (Get_Pragma_Arg (Arg1)), Standard_String);\n-            end if;\n-\n-            Check_Optional_Identifier (Arg2, Name_Mode);\n-            Check_Arg_Is_One_Of (Arg2, Name_Nominal, Name_Robustness);\n-\n-            if Arg_Count = 4 then\n-               Check_Identifier (Arg3, Name_Requires);\n-               Check_Identifier (Arg4, Name_Ensures);\n-\n-            elsif Arg_Count = 3 then\n-               Check_Identifier_Is_One_Of (Arg3, Name_Requires, Name_Ensures);\n-            end if;\n-\n+         when Pragma_Test_Case =>\n             Check_Contract_Or_Test_Case;\n-         end Contract_Or_Test_Case;\n \n          --------------------------\n          -- Thread_Local_Storage --\n@@ -14824,31 +14849,6 @@ package body Sem_Prag is\n       when Pragma_Exit => null;\n    end Analyze_Pragma;\n \n-   ------------------------------\n-   -- Analyze_CTC_In_Decl_Part --\n-   ------------------------------\n-\n-   procedure Analyze_CTC_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n-   begin\n-      --  Install formals and push subprogram spec onto scope stack so that we\n-      --  can see the formals from the pragma.\n-\n-      Install_Formals (S);\n-      Push_Scope (S);\n-\n-      --  Preanalyze the boolean expressions, we treat these as spec\n-      --  expressions (i.e. similar to a default expression).\n-\n-      Preanalyze_CTC_Args (N,\n-                           Get_Requires_From_Case_Pragma (N),\n-                           Get_Ensures_From_Case_Pragma (N));\n-\n-      --  Remove the subprogram from the scope stack now that the pre-analysis\n-      --  of the expressions in the contract-case or test-case is done.\n-\n-      End_Scope;\n-   end Analyze_CTC_In_Decl_Part;\n-\n    --------------------\n    -- Check_Disabled --\n    --------------------"}, {"sha": "99711546cb5e6102ae0dca7e560b6a7aeb7823e2", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=b285815ef53ed6215fc2493b40a38cf4e8041b71", "patch": "@@ -35,14 +35,6 @@ package Sem_Prag is\n    -- Subprograms --\n    -----------------\n \n-   procedure Analyze_PPC_In_Decl_Part (N : Node_Id; S : Entity_Id);\n-   --  Special analyze routine for precondition/postcondition pragma that\n-   --  appears within a declarative part where the pragma is associated\n-   --  with a subprogram specification. N is the pragma node, and S is the\n-   --  entity for the related subprogram. This procedure does a preanalysis\n-   --  of the expressions in the pragma as \"spec expressions\" (see section\n-   --  in Sem \"Handling of Default and Per-Object Expressions...\").\n-\n    procedure Analyze_Pragma (N : Node_Id);\n    --  Analyze procedure for pragma reference node N\n \n@@ -54,6 +46,14 @@ package Sem_Prag is\n    --  expressions in the pragma as \"spec expressions\" (see section in Sem\n    --  \"Handling of Default and Per-Object Expressions...\").\n \n+   procedure Analyze_PPC_In_Decl_Part (N : Node_Id; S : Entity_Id);\n+   --  Special analyze routine for precondition/postcondition pragma that\n+   --  appears within a declarative part where the pragma is associated\n+   --  with a subprogram specification. N is the pragma node, and S is the\n+   --  entity for the related subprogram. This procedure does a preanalysis\n+   --  of the expressions in the pragma as \"spec expressions\" (see section\n+   --  in Sem \"Handling of Default and Per-Object Expressions...\").\n+\n    function Check_Disabled (Nam : Name_Id) return Boolean;\n    --  This function is used in connection with pragmas Assertion, Check,\n    --  Precondition, and Postcondition, to determine if Check pragmas (or"}, {"sha": "898222805b1fe7bcc28c80c9fd9361279bd458ea", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=b285815ef53ed6215fc2493b40a38cf4e8041b71", "patch": "@@ -575,6 +575,7 @@ package Sem_Util is\n \n    function Get_Name_From_Case_Pragma (N : Node_Id) return String_Id;\n    --  Return the Name component of Contract_Case or Test_Case pragma N\n+   --  Bad name, Case_Pragma is meaningless to me ???\n \n    function Get_Pragma_Id (N : Node_Id) return Pragma_Id;\n    pragma Inline (Get_Pragma_Id);"}, {"sha": "129eb35a9fb51dbd49a16f38b58754b081b26b22", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b285815ef53ed6215fc2493b40a38cf4e8041b71/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=b285815ef53ed6215fc2493b40a38cf4e8041b71", "patch": "@@ -1772,7 +1772,8 @@ package body Sem_Warn is\n                               if Nkind (P) = N_Pragma\n                                 and then\n                                   (Pragma_Name (P) = Name_Contract_Case\n-                                     or else Pragma_Name (P) = Name_Test_Case)\n+                                     or else\n+                                   Pragma_Name (P) = Name_Test_Case)\n                                 and then\n                                   Nod = Get_Ensures_From_Case_Pragma (P)\n                               then"}]}