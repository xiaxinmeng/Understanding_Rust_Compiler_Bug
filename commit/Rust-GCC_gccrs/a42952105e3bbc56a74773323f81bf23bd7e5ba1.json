{"sha": "a42952105e3bbc56a74773323f81bf23bd7e5ba1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQyOTUyMTA1ZTNiYmM1NmE3NDc3MzMyM2Y4MWJmMjNiZDdlNWJhMQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2004-01-20T22:20:07Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2004-01-20T22:20:07Z"}, "message": "pa-protos.h (compute_frame_size): Use HOST_WIDE_INT for frame sizes.\n\n\t* pa-protos.h (compute_frame_size): Use HOST_WIDE_INT for frame sizes.\n\t* pa.c (store_reg, store_reg_modify, load_reg, set_reg_plus_d):\n\tLikewise.  Handle frames larger than 0x7fffffff on 64-bit ports.\n\t(emit_move_sequence): Check scratch_reg first in various if statements.\n\tExtend source simplification to handle all 64-bit CONST_INTs.\n\t(pa_output_function_prologue): Use HOST_WIDE_INT_PRINT_DEC for printing\n\tframe size.\n\t(hppa_expand_prologue, hppa_expand_epilogue): Use HOST_WIDE_INT for\n\tframe offset calculations.\n\t* pa.h (NEW_HP_ASSEMBLER): Add comment.\n\t(MAX_LEGIT_64BIT_CONST_INT, MIN_LEGIT_64BIT_CONST_INT,\n\tLEGITIMATE_64BIT_CONST_INT_P): Define.\n\t(LEGITIMATE_CONSTANT_P): Use LEGITIMATE_64BIT_CONST_INT_P.  Treat\n\tany CONST_INT as legitimate during and after reload.\n\t(VAL_32_BITS_P, INT_32_BITS): Define.\n\t(LEGITIMIZE_RELOAD_ADDRESS): Handle large frame offsets.\n\nFrom-SVN: r76234", "tree": {"sha": "2044ee040dc7f65cb0a9dacb1c92212e777d264a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2044ee040dc7f65cb0a9dacb1c92212e777d264a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a42952105e3bbc56a74773323f81bf23bd7e5ba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42952105e3bbc56a74773323f81bf23bd7e5ba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a42952105e3bbc56a74773323f81bf23bd7e5ba1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a42952105e3bbc56a74773323f81bf23bd7e5ba1/comments", "author": null, "committer": null, "parents": [{"sha": "3e89ed8dd36d61b8ebb6dea3a21c55a56d1662ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e89ed8dd36d61b8ebb6dea3a21c55a56d1662ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e89ed8dd36d61b8ebb6dea3a21c55a56d1662ac"}], "stats": {"total": 293, "additions": 219, "deletions": 74}, "files": [{"sha": "b82d6fbf3891475dd83141a644c4c4269a1d585c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42952105e3bbc56a74773323f81bf23bd7e5ba1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42952105e3bbc56a74773323f81bf23bd7e5ba1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a42952105e3bbc56a74773323f81bf23bd7e5ba1", "patch": "@@ -1,3 +1,22 @@\n+2004-01-20  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* pa-protos.h (compute_frame_size): Use HOST_WIDE_INT for frame sizes.\n+\t* pa.c (store_reg, store_reg_modify, load_reg, set_reg_plus_d):\n+\tLikewise.  Handle frames larger than 0x7fffffff on 64-bit ports.\n+\t(emit_move_sequence): Check scratch_reg first in various if statements.\n+\tExtend source simplification to handle all 64-bit CONST_INTs.\n+\t(pa_output_function_prologue): Use HOST_WIDE_INT_PRINT_DEC for printing\n+\tframe size.\n+\t(hppa_expand_prologue, hppa_expand_epilogue): Use HOST_WIDE_INT for\n+\tframe offset calculations.\n+\t* pa.h (NEW_HP_ASSEMBLER): Add comment.\n+\t(MAX_LEGIT_64BIT_CONST_INT, MIN_LEGIT_64BIT_CONST_INT,\n+\tLEGITIMATE_64BIT_CONST_INT_P): Define.\n+\t(LEGITIMATE_CONSTANT_P): Use LEGITIMATE_64BIT_CONST_INT_P.  Treat\n+\tany CONST_INT as legitimate during and after reload.\n+\t(VAL_32_BITS_P, INT_32_BITS): Define.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): Handle large frame offsets.\n+\n 2004-01-20  Jan Hubicka  <jh@suse.cz>\n \n \t* emit-rtl.c (verify_rtx_sharing, copy_insn_1,"}, {"sha": "fd7636e3047e4f3e038c7f6f183817b838da6d34", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42952105e3bbc56a74773323f81bf23bd7e5ba1/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42952105e3bbc56a74773323f81bf23bd7e5ba1/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=a42952105e3bbc56a74773323f81bf23bd7e5ba1", "patch": "@@ -137,7 +137,7 @@ extern struct rtx_def *hppa_builtin_saveregs (void);\n \n extern void override_options (void);\n extern void output_ascii (FILE *, const char *, int);\n-extern int compute_frame_size (int, int *);\n+extern HOST_WIDE_INT compute_frame_size (HOST_WIDE_INT, int *);\n extern int and_mask_p (unsigned HOST_WIDE_INT);\n extern int cint_ok_for_move (HOST_WIDE_INT);\n extern void hppa_expand_prologue (void);"}, {"sha": "3d3b1ae0733a116a9c677c448d2e87fd8237f193", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 157, "deletions": 56, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42952105e3bbc56a74773323f81bf23bd7e5ba1/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42952105e3bbc56a74773323f81bf23bd7e5ba1/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a42952105e3bbc56a74773323f81bf23bd7e5ba1", "patch": "@@ -107,10 +107,10 @@ static int compute_movstr_length (rtx);\n static int compute_clrstr_length (rtx);\n static bool pa_assemble_integer (rtx, unsigned int, int);\n static void remove_useless_addtr_insns (int);\n-static void store_reg (int, int, int);\n-static void store_reg_modify (int, int, int);\n-static void load_reg (int, int, int);\n-static void set_reg_plus_d (int, int, int, int);\n+static void store_reg (int, HOST_WIDE_INT, int);\n+static void store_reg_modify (int, int, HOST_WIDE_INT);\n+static void load_reg (int, HOST_WIDE_INT, int);\n+static void set_reg_plus_d (int, int, HOST_WIDE_INT, int);\n static void pa_output_function_prologue (FILE *, HOST_WIDE_INT);\n static void update_total_code_bytes (int);\n static void pa_output_function_epilogue (FILE *, HOST_WIDE_INT);\n@@ -1552,13 +1552,13 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n   /* Handle secondary reloads for loads/stores of FP registers from\n      REG+D addresses where D does not fit in 5 bits, including\n      (subreg (mem (addr))) cases.  */\n-  if (fp_reg_operand (operand0, mode)\n+  if (scratch_reg\n+      && fp_reg_operand (operand0, mode)\n       && ((GET_CODE (operand1) == MEM\n \t   && !memory_address_p (DFmode, XEXP (operand1, 0)))\n \t  || ((GET_CODE (operand1) == SUBREG\n \t       && GET_CODE (XEXP (operand1, 0)) == MEM\n-\t       && !memory_address_p (DFmode, XEXP (XEXP (operand1, 0), 0)))))\n-      && scratch_reg)\n+\t       && !memory_address_p (DFmode, XEXP (XEXP (operand1, 0), 0))))))\n     {\n       if (GET_CODE (operand1) == SUBREG)\n \toperand1 = XEXP (operand1, 0);\n@@ -1585,14 +1585,14 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t\t\t      gen_rtx_MEM (mode, scratch_reg)));\n       return 1;\n     }\n-  else if (fp_reg_operand (operand1, mode)\n+  else if (scratch_reg\n+\t   && fp_reg_operand (operand1, mode)\n \t   && ((GET_CODE (operand0) == MEM\n \t\t&& ! memory_address_p (DFmode, XEXP (operand0, 0)))\n \t       || ((GET_CODE (operand0) == SUBREG)\n \t\t   && GET_CODE (XEXP (operand0, 0)) == MEM\n \t\t   && !memory_address_p (DFmode,\n-\t\t\t   \t\t XEXP (XEXP (operand0, 0), 0))))\n-\t   && scratch_reg)\n+\t\t\t   \t\t XEXP (XEXP (operand0, 0), 0)))))\n     {\n       if (GET_CODE (operand0) == SUBREG)\n \toperand0 = XEXP (operand0, 0);\n@@ -1623,15 +1623,15 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n   /* Handle secondary reloads for loads of FP registers from constant\n      expressions by forcing the constant into memory.\n \n-     use scratch_reg to hold the address of the memory location.\n+     Use scratch_reg to hold the address of the memory location.\n \n      The proper fix is to change PREFERRED_RELOAD_CLASS to return\n      NO_REGS when presented with a const_int and a register class\n      containing only FP registers.  Doing so unfortunately creates\n      more problems than it solves.   Fix this for 2.5.  */\n-  else if (fp_reg_operand (operand0, mode)\n+  else if (scratch_reg\n \t   && CONSTANT_P (operand1)\n-\t   && scratch_reg)\n+\t   && fp_reg_operand (operand0, mode))\n     {\n       rtx xoperands[2];\n \n@@ -1653,14 +1653,14 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n     }\n   /* Handle secondary reloads for SAR.  These occur when trying to load\n      the SAR from memory, FP register, or with a constant.  */\n-  else if (GET_CODE (operand0) == REG\n+  else if (scratch_reg\n+\t   && GET_CODE (operand0) == REG\n \t   && REGNO (operand0) < FIRST_PSEUDO_REGISTER\n \t   && REGNO_REG_CLASS (REGNO (operand0)) == SHIFT_REGS\n \t   && (GET_CODE (operand1) == MEM\n \t       || GET_CODE (operand1) == CONST_INT\n \t       || (GET_CODE (operand1) == REG\n-\t\t   && FP_REG_CLASS_P (REGNO_REG_CLASS (REGNO (operand1)))))\n-\t   && scratch_reg)\n+\t\t   && FP_REG_CLASS_P (REGNO_REG_CLASS (REGNO (operand1))))))\n     {\n       /* D might not fit in 14 bits either; for such cases load D into\n \t scratch reg.  */\n@@ -1971,52 +1971,57 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t  return 1;\n \t}\n       else if (GET_CODE (operand1) != CONST_INT\n-\t       || ! cint_ok_for_move (INTVAL (operand1)))\n+\t       || !cint_ok_for_move (INTVAL (operand1)))\n \t{\n-\t  rtx extend = NULL_RTX;\n-\t  rtx temp;\n+\t  rtx insn, temp;\n+\t  rtx op1 = operand1;\n+\t  HOST_WIDE_INT value = INTVAL (operand1);\n+\t  HOST_WIDE_INT insv = 0;\n+\t  int insert = 0;\n \n-\t  if (TARGET_64BIT && GET_CODE (operand1) == CONST_INT\n+\t  if (TARGET_64BIT\n+\t      && GET_CODE (operand1) == CONST_INT\n \t      && HOST_BITS_PER_WIDE_INT > 32\n \t      && GET_MODE_BITSIZE (GET_MODE (operand0)) > 32)\n \t    {\n-\t      HOST_WIDE_INT val = INTVAL (operand1);\n \t      HOST_WIDE_INT nval;\n \n \t      /* Extract the low order 32 bits of the value and sign extend.\n \t\t If the new value is the same as the original value, we can\n \t\t can use the original value as-is.  If the new value is\n \t\t different, we use it and insert the most-significant 32-bits\n \t\t of the original value into the final result.  */\n-\t      nval = ((val & (((HOST_WIDE_INT) 2 << 31) - 1))\n+\t      nval = ((value & (((HOST_WIDE_INT) 2 << 31) - 1))\n \t\t      ^ ((HOST_WIDE_INT) 1 << 31)) - ((HOST_WIDE_INT) 1 << 31);\n-\t      if (val != nval)\n+\t      if (value != nval)\n \t\t{\n #if HOST_BITS_PER_WIDE_INT > 32\n-\t\t  extend = GEN_INT (val >> 32);\n+\t\t  insv = value >= 0 ? value >> 32 : ~(~value >> 32);\n #endif\n+\t\t  insert = 1;\n+\t\t  value = nval;\n \t\t  operand1 = GEN_INT (nval);\n \t\t}\n \t    }\n \n \t  if (reload_in_progress || reload_completed)\n-\t    temp = operand0;\n+\t    temp = scratch_reg ? scratch_reg : operand0;\n \t  else\n \t    temp = gen_reg_rtx (mode);\n \n \t  /* We don't directly split DImode constants on 32-bit targets\n \t     because PLUS uses an 11-bit immediate and the insn sequence\n \t     generated is not as efficient as the one using HIGH/LO_SUM.  */\n \t  if (GET_CODE (operand1) == CONST_INT\n-\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+\t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t      && !insert)\n \t    {\n \t      /* Directly break constant into high and low parts.  This\n \t\t provides better optimization opportunities because various\n \t\t passes recognize constants split with PLUS but not LO_SUM.\n \t\t We use a 14-bit signed low part except when the addition\n \t\t of 0x4000 to the high part might change the sign of the\n \t\t high part.  */\n-\t      HOST_WIDE_INT value = INTVAL (operand1);\n \t      HOST_WIDE_INT low = value & 0x3fff;\n \t      HOST_WIDE_INT high = value & ~ 0x3fff;\n \n@@ -2040,11 +2045,60 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t      operands[1] = gen_rtx_LO_SUM (mode, temp, operand1);\n \t    }\n \n-\t  emit_move_insn (operands[0], operands[1]);\n+\t  insn = emit_move_insn (operands[0], operands[1]);\n+\n+\t  /* Now insert the most significant 32 bits of the value\n+\t     into the register.  When we don't have a second register\n+\t     available, it could take up to nine instructions to load\n+\t     a 64-bit integer constant.  Prior to reload, we force\n+\t     constants that would take more than three instructions\n+\t     to load to the constant pool.  During and after reload,\n+\t     we have to handle all possible values.  */\n+\t  if (insert)\n+\t    {\n+\t      /* Use a HIGH/LO_SUM/INSV sequence if we have a second\n+\t\t register and the value to be inserted is outside the\n+\t\t range that can be loaded with three depdi instructions.  */\n+\t      if (temp != operand0 && (insv >= 16384 || insv < -16384))\n+\t\t{\n+\t\t  operand1 = GEN_INT (insv);\n+\n+\t\t  emit_insn (gen_rtx_SET (VOIDmode, temp,\n+\t\t\t\t\t  gen_rtx_HIGH (mode, operand1)));\n+\t\t  emit_move_insn (temp, gen_rtx_LO_SUM (mode, temp, operand1));\n+\t\t  emit_insn (gen_insv (operand0, GEN_INT (32),\n+\t\t\t\t       const0_rtx, temp));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  int len = 5, pos = 27;\n+\n+\t\t  /* Insert the bits using the depdi instruction.  */\n+\t\t  while (pos >= 0)\n+\t\t    {\n+\t\t      HOST_WIDE_INT v5 = ((insv & 31) ^ 16) - 16;\n+\t\t      HOST_WIDE_INT sign = v5 < 0;\n+\n+\t\t      /* Left extend the insertion.  */\n+\t\t      insv = (insv >= 0 ? insv >> len : ~(~insv >> len));\n+\t\t      while (pos > 0 && (insv & 1) == sign)\n+\t\t\t{\n+\t\t\t  insv = (insv >= 0 ? insv >> 1 : ~(~insv >> 1));\n+\t\t\t  len += 1;\n+\t\t\t  pos -= 1;\n+\t\t\t}\n+\n+\t\t      emit_insn (gen_insv (operand0, GEN_INT (len),\n+\t\t\t\t\t   GEN_INT (pos), GEN_INT (v5)));\n+\n+\t\t      len = pos > 0 && pos < 5 ? pos : 5;\n+\t\t      pos -= len;\n+\t\t    }\n+\t\t}\n+\t    }\n \n-\t  if (extend != NULL_RTX)\n-\t    emit_insn (gen_insv (operands[0], GEN_INT (32), const0_rtx,\n-\t\t\t\t extend));\n+\t  REG_NOTES (insn)\n+\t    = gen_rtx_EXPR_LIST (REG_EQUAL, op1, REG_NOTES (insn));\n \n \t  return 1;\n \t}\n@@ -3334,8 +3388,8 @@ remove_useless_addtr_insns (int check_notes)\n /* Global variables set by output_function_prologue().  */\n /* Size of frame.  Need to know this to emit return insns from\n    leaf procedures.  */\n-static int actual_fsize;\n-static int local_fsize, save_fregs;\n+static HOST_WIDE_INT actual_fsize, local_fsize;\n+static int save_fregs;\n \n /* Emit RTL to store REG at the memory location specified by BASE+DISP.\n    Handle case where DISP > 8k by using the add_high_const patterns.\n@@ -3344,7 +3398,7 @@ static int local_fsize, save_fregs;\n    in %r1.  There is code in expand_hppa_{prologue,epilogue} that knows this.*/\n \n static void\n-store_reg (int reg, int disp, int base)\n+store_reg (int reg, HOST_WIDE_INT disp, int base)\n {\n   rtx insn, dest, src, basereg;\n \n@@ -3355,11 +3409,33 @@ store_reg (int reg, int disp, int base)\n       dest = gen_rtx_MEM (word_mode, plus_constant (basereg, disp));\n       insn = emit_move_insn (dest, src);\n     }\n+  else if (TARGET_64BIT && !VAL_32_BITS_P (disp))\n+    {\n+      rtx delta = GEN_INT (disp);\n+      rtx tmpreg = gen_rtx_REG (Pmode, 1);\n+\n+      emit_move_insn (tmpreg, delta);\n+      emit_move_insn (tmpreg, gen_rtx_PLUS (Pmode, tmpreg, basereg));\n+      dest = gen_rtx_MEM (word_mode, tmpreg);\n+      insn = emit_move_insn (dest, src);\n+      if (DO_FRAME_NOTES)\n+\t{\n+\t  REG_NOTES (insn)\n+\t    = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n+\t\tgen_rtx_SET (VOIDmode,\n+\t\t\t     gen_rtx_MEM (word_mode,\n+\t\t\t\t\t  gen_rtx_PLUS (word_mode, basereg,\n+\t\t\t\t\t\t\tdelta)),\n+                             src),\n+                REG_NOTES (insn));\n+\t}\n+    }\n   else\n     {\n       rtx delta = GEN_INT (disp);\n       rtx high = gen_rtx_PLUS (Pmode, basereg, gen_rtx_HIGH (Pmode, delta));\n       rtx tmpreg = gen_rtx_REG (Pmode, 1);\n+\n       emit_move_insn (tmpreg, high);\n       dest = gen_rtx_MEM (word_mode, gen_rtx_LO_SUM (Pmode, tmpreg, delta));\n       insn = emit_move_insn (dest, src);\n@@ -3384,11 +3460,11 @@ store_reg (int reg, int disp, int base)\n    add MOD to BASE.  MOD must be <= 8k.  */\n \n static void\n-store_reg_modify (int base, int reg, int mod)\n+store_reg_modify (int base, int reg, HOST_WIDE_INT mod)\n {\n   rtx insn, basereg, srcreg, delta;\n \n-  if (! VAL_14_BITS_P (mod))\n+  if (!VAL_14_BITS_P (mod))\n     abort ();\n \n   basereg = gen_rtx_REG (Pmode, base);\n@@ -3431,7 +3507,7 @@ store_reg_modify (int base, int reg, int mod)\n    There is code in expand_hppa_{prologue,epilogue} that knows about this.  */\n \n static void\n-set_reg_plus_d (int reg, int base, int disp, int note)\n+set_reg_plus_d (int reg, int base, HOST_WIDE_INT disp, int note)\n {\n   rtx insn;\n \n@@ -3440,25 +3516,35 @@ set_reg_plus_d (int reg, int base, int disp, int note)\n       insn = emit_move_insn (gen_rtx_REG (Pmode, reg),\n \t\t\t     plus_constant (gen_rtx_REG (Pmode, base), disp));\n     }\n+  else if (TARGET_64BIT && !VAL_32_BITS_P (disp))\n+    {\n+      rtx basereg = gen_rtx_REG (Pmode, base);\n+      rtx delta = GEN_INT (disp);\n+      rtx tmpreg = gen_rtx_REG (Pmode, 1);\n+\n+      emit_move_insn (tmpreg, delta);\n+      insn = emit_move_insn (gen_rtx_REG (Pmode, reg),\n+\t\t\t     gen_rtx_PLUS (Pmode, tmpreg, basereg));\n+    }\n   else\n     {\n       rtx basereg = gen_rtx_REG (Pmode, base);\n       rtx delta = GEN_INT (disp);\n+      rtx tmpreg = gen_rtx_REG (Pmode, 1);\n \n-      emit_move_insn (gen_rtx_REG (Pmode, 1),\n+      emit_move_insn (tmpreg,\n \t\t      gen_rtx_PLUS (Pmode, basereg,\n \t\t\t\t    gen_rtx_HIGH (Pmode, delta)));\n       insn = emit_move_insn (gen_rtx_REG (Pmode, reg),\n-\t\t\t     gen_rtx_LO_SUM (Pmode, gen_rtx_REG (Pmode, 1),\n-\t\t\t\t\t     delta));\n+\t\t\t     gen_rtx_LO_SUM (Pmode, tmpreg, delta));\n     }\n \n   if (DO_FRAME_NOTES && note)\n     RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n-int\n-compute_frame_size (int size, int *fregs_live)\n+HOST_WIDE_INT\n+compute_frame_size (HOST_WIDE_INT size, int *fregs_live)\n {\n   int freg_saved = 0;\n   int i, j;\n@@ -3562,7 +3648,7 @@ pa_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n   /* hppa_expand_prologue does the dirty work now.  We just need\n      to output the assembler directives which denote the start\n      of a function.  */\n-  fprintf (file, \"\\t.CALLINFO FRAME=%d\", actual_fsize);\n+  fprintf (file, \"\\t.CALLINFO FRAME=\" HOST_WIDE_INT_PRINT_DEC, actual_fsize);\n   if (regs_ever_live[2])\n     fputs (\",CALLS,SAVE_RP\", file);\n   else\n@@ -3603,8 +3689,9 @@ void\n hppa_expand_prologue (void)\n {\n   int merge_sp_adjust_with_store = 0;\n-  int size = get_frame_size ();\n-  int i, offset;\n+  HOST_WIDE_INT size = get_frame_size ();\n+  HOST_WIDE_INT offset;\n+  int i;\n   rtx insn, tmpreg;\n \n   gr_saved = 0;\n@@ -3668,8 +3755,8 @@ hppa_expand_prologue (void)\n \t\t So instead use stwm to store at *sp and post-increment the\n \t\t stack pointer as an atomic operation.  Then increment sp to\n \t\t finish allocating the new frame.  */\n-\t      int adjust1 = 8192 - 64;\n-\t      int adjust2 = actual_fsize - adjust1;\n+\t      HOST_WIDE_INT adjust1 = 8192 - 64;\n+\t      HOST_WIDE_INT adjust2 = actual_fsize - adjust1;\n \n \t      store_reg_modify (STACK_POINTER_REGNUM, 1, adjust1);\n \t      set_reg_plus_d (STACK_POINTER_REGNUM, STACK_POINTER_REGNUM,\n@@ -3901,26 +3988,39 @@ hppa_expand_prologue (void)\n    Handle case where DISP > 8k by using the add_high_const patterns.  */\n \n static void\n-load_reg (int reg, int disp, int base)\n+load_reg (int reg, HOST_WIDE_INT disp, int base)\n {\n-  rtx src, dest, basereg;\n+  rtx dest = gen_rtx_REG (word_mode, reg);\n+  rtx basereg = gen_rtx_REG (Pmode, base);\n+  rtx src;\n \n-  dest = gen_rtx_REG (word_mode, reg);\n-  basereg = gen_rtx_REG (Pmode, base);\n   if (VAL_14_BITS_P (disp))\n+    src = gen_rtx_MEM (word_mode, plus_constant (basereg, disp));\n+  else if (TARGET_64BIT && !VAL_32_BITS_P (disp))\n     {\n-      src = gen_rtx_MEM (word_mode, plus_constant (basereg, disp));\n-      emit_move_insn (dest, src);\n+      rtx delta = GEN_INT (disp);\n+      rtx tmpreg = gen_rtx_REG (Pmode, 1);\n+\n+      emit_move_insn (tmpreg, delta);\n+      if (TARGET_DISABLE_INDEXING)\n+\t{\n+\t  emit_move_insn (tmpreg, gen_rtx_PLUS (Pmode, tmpreg, basereg));\n+\t  src = gen_rtx_MEM (word_mode, tmpreg);\n+\t}\n+      else\n+\tsrc = gen_rtx_MEM (word_mode, gen_rtx_PLUS (Pmode, tmpreg, basereg));\n     }\n   else\n     {\n       rtx delta = GEN_INT (disp);\n       rtx high = gen_rtx_PLUS (Pmode, basereg, gen_rtx_HIGH (Pmode, delta));\n       rtx tmpreg = gen_rtx_REG (Pmode, 1);\n+\n       emit_move_insn (tmpreg, high);\n       src = gen_rtx_MEM (word_mode, gen_rtx_LO_SUM (Pmode, tmpreg, delta));\n-      emit_move_insn (dest, src);\n     }\n+\n+  emit_move_insn (dest, src);\n }\n \n /* Update the total code bytes output to the text section.  */\n@@ -4006,9 +4106,10 @@ void\n hppa_expand_epilogue (void)\n {\n   rtx tmpreg;\n-  int offset, i;\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT ret_off = 0;\n+  int i;\n   int merge_sp_adjust_with_load = 0;\n-  int ret_off = 0;\n \n   /* We will use this often.  */\n   tmpreg = gen_rtx_REG (word_mode, 1);"}, {"sha": "79e03d28db49c0baa8d1ca55d6f57026faf3adb8", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a42952105e3bbc56a74773323f81bf23bd7e5ba1/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a42952105e3bbc56a74773323f81bf23bd7e5ba1/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=a42952105e3bbc56a74773323f81bf23bd7e5ba1", "patch": "@@ -646,7 +646,6 @@ extern struct rtx_def *hppa_pic_save_rtx (void);\n    to IN.  If it can be done directly NO_REGS is returned. \n \n   Avoid doing any work for the common case calls.  */\n-\n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n   ((CLASS == BASE_REG_CLASS && GET_CODE (IN) == REG\t\t\\\n     && REGNO (IN) < FIRST_PSEUDO_REGISTER)\t\t\t\\\n@@ -1223,25 +1222,45 @@ extern int may_call_alloca;\n    || GET_CODE (X) == HIGH) \t\t\t\t\t\t\\\n    && (reload_in_progress || reload_completed || ! symbolic_expression_p (X)))\n \n-/* Include all constant integers and constant doubles, but not\n-   floating-point, except for floating-point zero.\n-\n-   Reject LABEL_REFs if we're not using gas or the new HP assembler. \n+/* A C expression that is nonzero if we are using the new HP assembler.  */\n \n-   ?!? For now also reject CONST_DOUBLES in 64bit mode.  This will need\n-   further work.  */\n #ifndef NEW_HP_ASSEMBLER\n #define NEW_HP_ASSEMBLER 0\n #endif\n+\n+/* The macros below define the immediate range for CONST_INTS on\n+   the 64-bit port.  Constants in this range can be loaded in three\n+   instructions using a ldil/ldo/depdi sequence.  Constants outside\n+   this range are forced to the constant pool prior to reload.  */\n+\n+#define MAX_LEGIT_64BIT_CONST_INT ((HOST_WIDE_INT) 32 << 31)\n+#define MIN_LEGIT_64BIT_CONST_INT ((HOST_WIDE_INT) -32 << 31)\n+#define LEGITIMATE_64BIT_CONST_INT_P(X) \\\n+  ((X) >= MIN_LEGIT_64BIT_CONST_INT && (X) < MAX_LEGIT_64BIT_CONST_INT)\n+\n+/* A C expression that is nonzero if X is a legitimate constant for an\n+   immediate operand.\n+\n+   We include all constant integers and constant doubles, but not\n+   floating-point, except for floating-point zero.  We reject LABEL_REFs\n+   if we're not using gas or the new HP assembler. \n+\n+   In 64-bit mode, we reject CONST_DOUBLES.  We also reject CONST_INTS\n+   that need more than three instructions to load prior to reload.  This\n+   limit is somewhat arbitrary.  It takes three instructions to load a\n+   CONST_INT from memory but two are memory accesses.  It may be better\n+   to increase the allowed range for CONST_INTS.  We may also be able\n+   to handle CONST_DOUBLES.  */\n+\n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n   ((GET_MODE_CLASS (GET_MODE (X)) != MODE_FLOAT\t\t\t\\\n     || (X) == CONST0_RTX (GET_MODE (X)))\t\t\t\\\n    && (NEW_HP_ASSEMBLER || TARGET_GAS || GET_CODE (X) != LABEL_REF)\t\\\n    && !(TARGET_64BIT && GET_CODE (X) == CONST_DOUBLE)\t\t\\\n    && !(TARGET_64BIT && GET_CODE (X) == CONST_INT\t\t\\\n \t&& !(HOST_BITS_PER_WIDE_INT <= 32\t\t\t\\\n-\t     || (INTVAL (X) >= (HOST_WIDE_INT) -32 << 31\t\\\n-\t\t && INTVAL (X) < (HOST_WIDE_INT) 32 << 31)\t\\\n+\t     || (reload_in_progress || reload_completed)\t\\\n+\t     || LEGITIMATE_64BIT_CONST_INT_P (INTVAL (X))\t\\\n \t     || cint_ok_for_move (INTVAL (X))))\t\t\t\\\n    && !function_label_operand (X, VOIDmode))\n \n@@ -1425,6 +1444,15 @@ extern int may_call_alloca;\n #define VAL_14_BITS_P(X) ((unsigned HOST_WIDE_INT)(X) + 0x2000 < 0x4000)\n #define INT_14_BITS(X) VAL_14_BITS_P (INTVAL (X))\n \n+#if HOST_BITS_PER_WIDE_INT > 32\n+#define VAL_32_BITS_P(X) \\\n+  ((unsigned HOST_WIDE_INT)(X) + ((unsigned HOST_WIDE_INT) 1 << 31)    \\\n+   < (unsigned HOST_WIDE_INT) 2 << 31)\n+#else\n+#define VAL_32_BITS_P(X) 1\n+#endif\n+#define INT_32_BITS(X) VAL_32_BITS_P (INTVAL (X))\n+\n /* These are the modes that we allow for scaled indexing.  */\n #define MODE_OK_FOR_SCALED_INDEXING_P(MODE) \\\n   ((TARGET_64BIT && (MODE) == DImode)\t\t\t\t\t\\\n@@ -1557,14 +1585,13 @@ extern int may_call_alloca;\n    There may be more opportunities to improve code with this hook.  */\n #define LEGITIMIZE_RELOAD_ADDRESS(AD, MODE, OPNUM, TYPE, IND, WIN) \t\\\n do { \t\t\t\t\t\t\t\t\t\\\n-  int offset, newoffset, mask;\t\t\t\t\t\t\\\n+  long offset, newoffset, mask;\t\t\t\t\t\t\\\n   rtx new, temp = NULL_RTX;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   mask = (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n \t  ? (TARGET_PA_20 && !TARGET_ELF32 ? 0x3fff : 0x1f) : 0x3fff);\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  if (optimize\t\t\t\t\t\t\t\t\\\n-      && GET_CODE (AD) == PLUS)\t\t\t\t\t\t\\\n+  if (optimize && GET_CODE (AD) == PLUS)\t\t\t\t\\\n     temp = simplify_binary_operation (PLUS, Pmode,\t\t\t\\\n \t\t\t\t      XEXP (AD, 0), XEXP (AD, 1));\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -1583,16 +1610,14 @@ do { \t\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \tnewoffset = offset & ~mask;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (newoffset != 0\t\t\t\t\t\t\\\n-\t  && VAL_14_BITS_P (newoffset))\t\t\t\t\t\\\n+      if (newoffset != 0 && VAL_14_BITS_P (newoffset))\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n \t  temp = gen_rtx_PLUS (Pmode, XEXP (new, 0),\t\t\t\\\n \t\t\t       GEN_INT (newoffset));\t\t\t\\\n \t  AD = gen_rtx_PLUS (Pmode, temp, GEN_INT (offset - newoffset));\\\n \t  push_reload (XEXP (AD, 0), 0, &XEXP (AD, 0), 0,\t\t\\\n-\t\t\t     BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\t\\\n-\t\t\t     (OPNUM), (TYPE));\t\t\t\t\\\n+\t\t       BASE_REG_CLASS, Pmode, VOIDmode, 0, 0,\t\t\\\n+\t\t       (OPNUM), (TYPE));\t\t\t\t\\\n \t  goto WIN;\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\"}]}