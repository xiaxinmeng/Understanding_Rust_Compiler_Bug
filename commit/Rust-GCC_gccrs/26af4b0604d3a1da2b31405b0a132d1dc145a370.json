{"sha": "26af4b0604d3a1da2b31405b0a132d1dc145a370", "node_id": "C_kwDOANBUbNoAKDI2YWY0YjA2MDRkM2ExZGEyYjMxNDA1YjBhMTMyZDFkYzE0NWEzNzA", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-01-16T17:08:14Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-04-06T08:47:20Z"}, "message": "gccrs: Refactor PathProbe into cc file\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-path-probe.cc (PathProbeType::PathProbeType): refactor\n\t(PathProbeType::Probe): likewise\n\t(PathProbeType::visit): likewise\n\t(PathProbeType::process_enum_item_for_candiates): likewise\n\t(PathProbeType::process_impl_items_for_candidates): likewise\n\t(PathProbeType::is_reciever_generic): likewise\n\t(PathProbeImplTrait::PathProbeImplTrait): likewise\n\t(PathProbeImplTrait::Probe): likewise\n\t(PathProbeImplTrait::process_trait_impl_items_for_candidates): likewise\n\t* typecheck/rust-hir-path-probe.h (struct PathProbeCandidate): likewise\n\t* typecheck/rust-hir-trait-resolve.cc\n\t(PathProbeImplTrait::process_trait_impl_items_for_candidates): likewise", "tree": {"sha": "f574340f346143a46eab984d72c7647d1bb85806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f574340f346143a46eab984d72c7647d1bb85806"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26af4b0604d3a1da2b31405b0a132d1dc145a370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26af4b0604d3a1da2b31405b0a132d1dc145a370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26af4b0604d3a1da2b31405b0a132d1dc145a370", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26af4b0604d3a1da2b31405b0a132d1dc145a370/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d73082efecec20789a837b691f45088ddf531a3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d73082efecec20789a837b691f45088ddf531a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d73082efecec20789a837b691f45088ddf531a3a"}], "stats": {"total": 668, "additions": 360, "deletions": 308}, "files": [{"sha": "06d8920d2eb199e7dc061b35f985d593591e38e0", "filename": "gcc/rust/typecheck/rust-hir-path-probe.cc", "status": "modified", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26af4b0604d3a1da2b31405b0a132d1dc145a370/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26af4b0604d3a1da2b31405b0a132d1dc145a370/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.cc?ref=26af4b0604d3a1da2b31405b0a132d1dc145a370", "patch": "@@ -18,10 +18,168 @@\n \n #include \"rust-hir-path-probe.h\"\n #include \"rust-hir-type-check-item.h\"\n+#include \"rust-hir-trait-resolve.h\"\n \n namespace Rust {\n namespace Resolver {\n \n+// PathProbeType\n+\n+PathProbeType::PathProbeType (const TyTy::BaseType *receiver,\n+\t\t\t      const HIR::PathIdentSegment &query,\n+\t\t\t      DefId specific_trait_id)\n+  : TypeCheckBase (), receiver (receiver), search (query),\n+    current_impl (nullptr), specific_trait_id (specific_trait_id)\n+{}\n+\n+std::set<PathProbeCandidate>\n+PathProbeType::Probe (const TyTy::BaseType *receiver,\n+\t\t      const HIR::PathIdentSegment &segment_name,\n+\t\t      bool probe_impls, bool probe_bounds,\n+\t\t      bool ignore_mandatory_trait_items,\n+\t\t      DefId specific_trait_id)\n+{\n+  PathProbeType probe (receiver, segment_name, specific_trait_id);\n+  if (probe_impls)\n+    {\n+      if (receiver->get_kind () == TyTy::TypeKind::ADT)\n+\t{\n+\t  const TyTy::ADTType *adt\n+\t    = static_cast<const TyTy::ADTType *> (receiver);\n+\t  if (adt->is_enum ())\n+\t    probe.process_enum_item_for_candiates (adt);\n+\t}\n+\n+      probe.process_impl_items_for_candidates ();\n+    }\n+\n+  if (!probe_bounds)\n+    return probe.candidates;\n+\n+  if (!probe.is_reciever_generic ())\n+    {\n+      std::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n+\t= TypeBoundsProbe::Probe (receiver);\n+      for (auto &candidate : probed_bounds)\n+\t{\n+\t  const TraitReference *trait_ref = candidate.first;\n+\t  if (specific_trait_id != UNKNOWN_DEFID)\n+\t    {\n+\t      if (trait_ref->get_mappings ().get_defid () != specific_trait_id)\n+\t\tcontinue;\n+\t    }\n+\n+\t  HIR::ImplBlock *impl = candidate.second;\n+\t  probe.process_associated_trait_for_candidates (\n+\t    trait_ref, impl, ignore_mandatory_trait_items);\n+\t}\n+    }\n+\n+  for (const TyTy::TypeBoundPredicate &predicate :\n+       receiver->get_specified_bounds ())\n+    {\n+      const TraitReference *trait_ref = predicate.get ();\n+      if (specific_trait_id != UNKNOWN_DEFID)\n+\t{\n+\t  if (trait_ref->get_mappings ().get_defid () != specific_trait_id)\n+\t    continue;\n+\t}\n+\n+      probe.process_predicate_for_candidates (predicate,\n+\t\t\t\t\t      ignore_mandatory_trait_items);\n+    }\n+\n+  return probe.candidates;\n+}\n+\n+void\n+PathProbeType::visit (HIR::TypeAlias &alias)\n+{\n+  Identifier name = alias.get_new_type_name ();\n+  if (search.as_string ().compare (name) == 0)\n+    {\n+      HirId tyid = alias.get_mappings ().get_hirid ();\n+      TyTy::BaseType *ty = nullptr;\n+      bool ok = query_type (tyid, &ty);\n+      rust_assert (ok);\n+\n+      PathProbeCandidate::ImplItemCandidate impl_item_candidate{&alias,\n+\t\t\t\t\t\t\t\tcurrent_impl};\n+      PathProbeCandidate candidate{\n+\tPathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, ty,\n+\talias.get_locus (), impl_item_candidate};\n+      candidates.insert (std::move (candidate));\n+    }\n+}\n+\n+void\n+PathProbeType::visit (HIR::ConstantItem &constant)\n+{\n+  Identifier name = constant.get_identifier ();\n+  if (search.as_string ().compare (name) == 0)\n+    {\n+      HirId tyid = constant.get_mappings ().get_hirid ();\n+      TyTy::BaseType *ty = nullptr;\n+      bool ok = query_type (tyid, &ty);\n+      rust_assert (ok);\n+\n+      PathProbeCandidate::ImplItemCandidate impl_item_candidate{&constant,\n+\t\t\t\t\t\t\t\tcurrent_impl};\n+      PathProbeCandidate candidate{\n+\tPathProbeCandidate::CandidateType::IMPL_CONST, ty,\n+\tconstant.get_locus (), impl_item_candidate};\n+      candidates.insert (std::move (candidate));\n+    }\n+}\n+\n+void\n+PathProbeType::visit (HIR::Function &function)\n+{\n+  Identifier name = function.get_function_name ();\n+  if (search.as_string ().compare (name) == 0)\n+    {\n+      HirId tyid = function.get_mappings ().get_hirid ();\n+      TyTy::BaseType *ty = nullptr;\n+      bool ok = query_type (tyid, &ty);\n+      rust_assert (ok);\n+\n+      PathProbeCandidate::ImplItemCandidate impl_item_candidate{&function,\n+\t\t\t\t\t\t\t\tcurrent_impl};\n+      PathProbeCandidate candidate{PathProbeCandidate::CandidateType::IMPL_FUNC,\n+\t\t\t\t   ty, function.get_locus (),\n+\t\t\t\t   impl_item_candidate};\n+      candidates.insert (std::move (candidate));\n+    }\n+}\n+\n+void\n+PathProbeType::process_enum_item_for_candiates (const TyTy::ADTType *adt)\n+{\n+  if (specific_trait_id != UNKNOWN_DEFID)\n+    return;\n+\n+  TyTy::VariantDef *v;\n+  if (!adt->lookup_variant (search.as_string (), &v))\n+    return;\n+\n+  PathProbeCandidate::EnumItemCandidate enum_item_candidate{adt, v};\n+  PathProbeCandidate candidate{PathProbeCandidate::CandidateType::ENUM_VARIANT,\n+\t\t\t       receiver->clone (),\n+\t\t\t       mappings->lookup_location (adt->get_ty_ref ()),\n+\t\t\t       enum_item_candidate};\n+  candidates.insert (std::move (candidate));\n+}\n+\n+void\n+PathProbeType::process_impl_items_for_candidates ()\n+{\n+  mappings->iterate_impl_items (\n+    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n+      process_impl_item_candidate (id, item, impl);\n+      return true;\n+    });\n+}\n+\n void\n PathProbeType::process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n \t\t\t\t\t    HIR::ImplBlock *impl)\n@@ -42,5 +200,191 @@ PathProbeType::process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n   item->accept_vis (*this);\n }\n \n+void\n+PathProbeType::process_associated_trait_for_candidates (\n+  const TraitReference *trait_ref, HIR::ImplBlock *impl,\n+  bool ignore_mandatory_trait_items)\n+{\n+  const TraitItemReference *trait_item_ref = nullptr;\n+  if (!trait_ref->lookup_trait_item (search.as_string (), &trait_item_ref))\n+    return;\n+\n+  bool trait_item_needs_implementation = !trait_item_ref->is_optional ();\n+  if (ignore_mandatory_trait_items && trait_item_needs_implementation)\n+    return;\n+\n+  PathProbeCandidate::CandidateType candidate_type;\n+  switch (trait_item_ref->get_trait_item_type ())\n+    {\n+    case TraitItemReference::TraitItemType::FN:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+      break;\n+    case TraitItemReference::TraitItemType::CONST:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+      break;\n+    case TraitItemReference::TraitItemType::TYPE:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+      break;\n+\n+    case TraitItemReference::TraitItemType::ERROR:\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n+\n+  // we can substitute the Self with the receiver here\n+  if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n+    {\n+      TyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n+      TyTy::SubstitutionParamMapping *param = nullptr;\n+      for (auto &param_mapping : fn->get_substs ())\n+\t{\n+\t  const HIR::TypeParam &type_param = param_mapping.get_generic_param ();\n+\t  if (type_param.get_type_representation ().compare (\"Self\") == 0)\n+\t    {\n+\t      param = &param_mapping;\n+\t      break;\n+\t    }\n+\t}\n+      rust_assert (param != nullptr);\n+\n+      std::vector<TyTy::SubstitutionArg> mappings;\n+      mappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n+\n+      Location locus; // FIXME\n+      TyTy::SubstitutionArgumentMappings args (std::move (mappings), {}, locus);\n+      trait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n+    }\n+\n+  PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t      trait_item_ref,\n+\t\t\t\t\t\t\t      impl};\n+\n+  PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n+\t\t\t       trait_item_ref->get_locus (),\n+\t\t\t       trait_item_candidate};\n+  candidates.insert (std::move (candidate));\n+}\n+\n+void\n+PathProbeType::process_predicate_for_candidates (\n+  const TyTy::TypeBoundPredicate &predicate, bool ignore_mandatory_trait_items)\n+{\n+  const TraitReference *trait_ref = predicate.get ();\n+\n+  TyTy::TypeBoundPredicateItem item\n+    = predicate.lookup_associated_item (search.as_string ());\n+  if (item.is_error ())\n+    return;\n+\n+  if (ignore_mandatory_trait_items && item.needs_implementation ())\n+    return;\n+\n+  const TraitItemReference *trait_item_ref = item.get_raw_item ();\n+  PathProbeCandidate::CandidateType candidate_type;\n+  switch (trait_item_ref->get_trait_item_type ())\n+    {\n+    case TraitItemReference::TraitItemType::FN:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n+      break;\n+    case TraitItemReference::TraitItemType::CONST:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n+      break;\n+    case TraitItemReference::TraitItemType::TYPE:\n+      candidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n+      break;\n+\n+    case TraitItemReference::TraitItemType::ERROR:\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  TyTy::BaseType *trait_item_tyty = item.get_tyty_for_receiver (receiver);\n+  PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n+\t\t\t\t\t\t\t      trait_item_ref,\n+\t\t\t\t\t\t\t      nullptr};\n+  PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n+\t\t\t       trait_item_ref->get_locus (),\n+\t\t\t       trait_item_candidate};\n+  candidates.insert (std::move (candidate));\n+}\n+\n+std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n+PathProbeType::union_bounds (\n+  const std::vector<std::pair</*const*/ TraitReference *, HIR::ImplBlock *>> a,\n+  const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> b)\n+  const\n+{\n+  std::map<DefId, std::pair<const TraitReference *, HIR::ImplBlock *>> mapper;\n+  for (auto &ref : a)\n+    {\n+      mapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n+    }\n+  for (auto &ref : b)\n+    {\n+      mapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n+    }\n+\n+  std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> union_set;\n+  for (auto it = mapper.begin (); it != mapper.end (); it++)\n+    {\n+      union_set.push_back ({it->second.first, it->second.second});\n+    }\n+  return union_set;\n+}\n+\n+bool\n+PathProbeType::is_reciever_generic () const\n+{\n+  const TyTy::BaseType *root = receiver->get_root ();\n+  bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n+  bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  return receiver_is_type_param || receiver_is_dyn;\n+}\n+\n+// PathProbImplTrait\n+\n+PathProbeImplTrait::PathProbeImplTrait (const TyTy::BaseType *receiver,\n+\t\t\t\t\tconst HIR::PathIdentSegment &query,\n+\t\t\t\t\tconst TraitReference *trait_reference)\n+  : PathProbeType (receiver, query, UNKNOWN_DEFID),\n+    trait_reference (trait_reference)\n+{}\n+\n+std::set<PathProbeCandidate>\n+PathProbeImplTrait::Probe (const TyTy::BaseType *receiver,\n+\t\t\t   const HIR::PathIdentSegment &segment_name,\n+\t\t\t   const TraitReference *trait_reference)\n+{\n+  PathProbeImplTrait probe (receiver, segment_name, trait_reference);\n+  // iterate all impls for this trait and receiver\n+  // then search for possible candidates using base class behaviours\n+  probe.process_trait_impl_items_for_candidates ();\n+  return probe.candidates;\n+}\n+\n+void\n+PathProbeImplTrait::process_trait_impl_items_for_candidates ()\n+{\n+  mappings->iterate_impl_items (\n+    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n+      // just need to check if this is an impl block for this trait the next\n+      // function checks the receiver\n+      if (!impl->has_trait_ref ())\n+\treturn true;\n+\n+      TraitReference *resolved\n+\t= TraitResolver::Lookup (*(impl->get_trait_ref ().get ()));\n+      if (!trait_reference->is_equal (*resolved))\n+\treturn true;\n+\n+      process_impl_item_candidate (id, item, impl);\n+      return true;\n+    });\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "783282a0dc9fd870bc889b9e43c77e00d515b6e8", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 16, "deletions": 286, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26af4b0604d3a1da2b31405b0a132d1dc145a370/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26af4b0604d3a1da2b31405b0a132d1dc145a370/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=26af4b0604d3a1da2b31405b0a132d1dc145a370", "patch": "@@ -152,7 +152,7 @@ struct PathProbeCandidate\n     return UNKNOWN_DEFID;\n   }\n \n-  bool operator< (const PathProbeCandidate &c) const\n+  bool operator<(const PathProbeCandidate &c) const\n   {\n     return get_defid () < c.get_defid ();\n   }\n@@ -165,301 +165,41 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n   Probe (const TyTy::BaseType *receiver,\n \t const HIR::PathIdentSegment &segment_name, bool probe_impls,\n \t bool probe_bounds, bool ignore_mandatory_trait_items,\n-\t DefId specific_trait_id = UNKNOWN_DEFID)\n-  {\n-    PathProbeType probe (receiver, segment_name, specific_trait_id);\n-    if (probe_impls)\n-      {\n-\tif (receiver->get_kind () == TyTy::TypeKind::ADT)\n-\t  {\n-\t    const TyTy::ADTType *adt\n-\t      = static_cast<const TyTy::ADTType *> (receiver);\n-\t    if (adt->is_enum ())\n-\t      probe.process_enum_item_for_candiates (adt);\n-\t  }\n-\n-\tprobe.process_impl_items_for_candidates ();\n-      }\n+\t DefId specific_trait_id = UNKNOWN_DEFID);\n \n-    if (!probe_bounds)\n-      return probe.candidates;\n-\n-    if (!probe.is_reciever_generic ())\n-      {\n-\tstd::vector<std::pair<TraitReference *, HIR::ImplBlock *>> probed_bounds\n-\t  = TypeBoundsProbe::Probe (receiver);\n-\tfor (auto &candidate : probed_bounds)\n-\t  {\n-\t    const TraitReference *trait_ref = candidate.first;\n-\t    if (specific_trait_id != UNKNOWN_DEFID)\n-\t      {\n-\t\tif (trait_ref->get_mappings ().get_defid ()\n-\t\t    != specific_trait_id)\n-\t\t  continue;\n-\t      }\n-\n-\t    HIR::ImplBlock *impl = candidate.second;\n-\t    probe.process_associated_trait_for_candidates (\n-\t      trait_ref, impl, ignore_mandatory_trait_items);\n-\t  }\n-      }\n-\n-    for (const TyTy::TypeBoundPredicate &predicate :\n-\t receiver->get_specified_bounds ())\n-      {\n-\tconst TraitReference *trait_ref = predicate.get ();\n-\tif (specific_trait_id != UNKNOWN_DEFID)\n-\t  {\n-\t    if (trait_ref->get_mappings ().get_defid () != specific_trait_id)\n-\t      continue;\n-\t  }\n-\n-\tprobe.process_predicate_for_candidates (predicate,\n-\t\t\t\t\t\tignore_mandatory_trait_items);\n-      }\n-\n-    return probe.candidates;\n-  }\n-\n-  void visit (HIR::TypeAlias &alias) override\n-  {\n-    Identifier name = alias.get_new_type_name ();\n-    if (search.as_string ().compare (name) == 0)\n-      {\n-\tHirId tyid = alias.get_mappings ().get_hirid ();\n-\tTyTy::BaseType *ty = nullptr;\n-\tbool ok = query_type (tyid, &ty);\n-\trust_assert (ok);\n-\n-\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&alias,\n-\t\t\t\t\t\t\t\t  current_impl};\n-\tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_TYPE_ALIAS, ty,\n-\t  alias.get_locus (), impl_item_candidate};\n-\tcandidates.insert (std::move (candidate));\n-      }\n-  }\n-\n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    Identifier name = constant.get_identifier ();\n-    if (search.as_string ().compare (name) == 0)\n-      {\n-\tHirId tyid = constant.get_mappings ().get_hirid ();\n-\tTyTy::BaseType *ty = nullptr;\n-\tbool ok = query_type (tyid, &ty);\n-\trust_assert (ok);\n-\n-\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&constant,\n-\t\t\t\t\t\t\t\t  current_impl};\n-\tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_CONST, ty,\n-\t  constant.get_locus (), impl_item_candidate};\n-\tcandidates.insert (std::move (candidate));\n-      }\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    Identifier name = function.get_function_name ();\n-    if (search.as_string ().compare (name) == 0)\n-      {\n-\tHirId tyid = function.get_mappings ().get_hirid ();\n-\tTyTy::BaseType *ty = nullptr;\n-\tbool ok = query_type (tyid, &ty);\n-\trust_assert (ok);\n-\n-\tPathProbeCandidate::ImplItemCandidate impl_item_candidate{&function,\n-\t\t\t\t\t\t\t\t  current_impl};\n-\tPathProbeCandidate candidate{\n-\t  PathProbeCandidate::CandidateType::IMPL_FUNC, ty,\n-\t  function.get_locus (), impl_item_candidate};\n-\tcandidates.insert (std::move (candidate));\n-      }\n-  }\n+  void visit (HIR::TypeAlias &alias) override;\n+  void visit (HIR::ConstantItem &constant) override;\n+  void visit (HIR::Function &function) override;\n \n protected:\n-  void process_enum_item_for_candiates (const TyTy::ADTType *adt)\n-  {\n-    if (specific_trait_id != UNKNOWN_DEFID)\n-      return;\n-\n-    TyTy::VariantDef *v;\n-    if (!adt->lookup_variant (search.as_string (), &v))\n-      return;\n-\n-    PathProbeCandidate::EnumItemCandidate enum_item_candidate{adt, v};\n-    PathProbeCandidate candidate{\n-      PathProbeCandidate::CandidateType::ENUM_VARIANT, receiver->clone (),\n-      mappings->lookup_location (adt->get_ty_ref ()), enum_item_candidate};\n-    candidates.insert (std::move (candidate));\n-  }\n+  void process_enum_item_for_candiates (const TyTy::ADTType *adt);\n \n-  void process_impl_items_for_candidates ()\n-  {\n-    mappings->iterate_impl_items ([&] (HirId id, HIR::ImplItem *item,\n-\t\t\t\t       HIR::ImplBlock *impl) mutable -> bool {\n-      process_impl_item_candidate (id, item, impl);\n-      return true;\n-    });\n-  }\n+  void process_impl_items_for_candidates ();\n \n   void process_impl_item_candidate (HirId id, HIR::ImplItem *item,\n \t\t\t\t    HIR::ImplBlock *impl);\n \n   void\n   process_associated_trait_for_candidates (const TraitReference *trait_ref,\n \t\t\t\t\t   HIR::ImplBlock *impl,\n-\t\t\t\t\t   bool ignore_mandatory_trait_items)\n-  {\n-    const TraitItemReference *trait_item_ref = nullptr;\n-    if (!trait_ref->lookup_trait_item (search.as_string (), &trait_item_ref))\n-      return;\n-\n-    bool trait_item_needs_implementation = !trait_item_ref->is_optional ();\n-    if (ignore_mandatory_trait_items && trait_item_needs_implementation)\n-      return;\n-\n-    PathProbeCandidate::CandidateType candidate_type;\n-    switch (trait_item_ref->get_trait_item_type ())\n-      {\n-      case TraitItemReference::TraitItemType::FN:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n-\tbreak;\n-      case TraitItemReference::TraitItemType::CONST:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n-\tbreak;\n-      case TraitItemReference::TraitItemType::TYPE:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n-\tbreak;\n-\n-      case TraitItemReference::TraitItemType::ERROR:\n-      default:\n-\tgcc_unreachable ();\n-\tbreak;\n-      }\n-\n-    TyTy::BaseType *trait_item_tyty = trait_item_ref->get_tyty ();\n-\n-    // we can substitute the Self with the receiver here\n-    if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n-      {\n-\tTyTy::FnType *fn = static_cast<TyTy::FnType *> (trait_item_tyty);\n-\tTyTy::SubstitutionParamMapping *param = nullptr;\n-\tfor (auto &param_mapping : fn->get_substs ())\n-\t  {\n-\t    const HIR::TypeParam &type_param\n-\t      = param_mapping.get_generic_param ();\n-\t    if (type_param.get_type_representation ().compare (\"Self\") == 0)\n-\t      {\n-\t\tparam = &param_mapping;\n-\t\tbreak;\n-\t      }\n-\t  }\n-\trust_assert (param != nullptr);\n-\n-\tstd::vector<TyTy::SubstitutionArg> mappings;\n-\tmappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n-\n-\tLocation locus; // FIXME\n-\tTyTy::SubstitutionArgumentMappings args (std::move (mappings), {},\n-\t\t\t\t\t\t locus);\n-\ttrait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n-      }\n-\n-    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n-\t\t\t\t\t\t\t\ttrait_item_ref,\n-\t\t\t\t\t\t\t\timpl};\n-\n-    PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n-\t\t\t\t trait_item_ref->get_locus (),\n-\t\t\t\t trait_item_candidate};\n-    candidates.insert (std::move (candidate));\n-  }\n+\t\t\t\t\t   bool ignore_mandatory_trait_items);\n \n   void\n   process_predicate_for_candidates (const TyTy::TypeBoundPredicate &predicate,\n-\t\t\t\t    bool ignore_mandatory_trait_items)\n-  {\n-    const TraitReference *trait_ref = predicate.get ();\n-\n-    TyTy::TypeBoundPredicateItem item\n-      = predicate.lookup_associated_item (search.as_string ());\n-    if (item.is_error ())\n-      return;\n-\n-    if (ignore_mandatory_trait_items && item.needs_implementation ())\n-      return;\n-\n-    const TraitItemReference *trait_item_ref = item.get_raw_item ();\n-    PathProbeCandidate::CandidateType candidate_type;\n-    switch (trait_item_ref->get_trait_item_type ())\n-      {\n-      case TraitItemReference::TraitItemType::FN:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_FUNC;\n-\tbreak;\n-      case TraitItemReference::TraitItemType::CONST:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_ITEM_CONST;\n-\tbreak;\n-      case TraitItemReference::TraitItemType::TYPE:\n-\tcandidate_type = PathProbeCandidate::CandidateType::TRAIT_TYPE_ALIAS;\n-\tbreak;\n-\n-      case TraitItemReference::TraitItemType::ERROR:\n-      default:\n-\tgcc_unreachable ();\n-\tbreak;\n-      }\n-\n-    TyTy::BaseType *trait_item_tyty = item.get_tyty_for_receiver (receiver);\n-    PathProbeCandidate::TraitItemCandidate trait_item_candidate{trait_ref,\n-\t\t\t\t\t\t\t\ttrait_item_ref,\n-\t\t\t\t\t\t\t\tnullptr};\n-    PathProbeCandidate candidate{candidate_type, trait_item_tyty,\n-\t\t\t\t trait_item_ref->get_locus (),\n-\t\t\t\t trait_item_candidate};\n-    candidates.insert (std::move (candidate));\n-  }\n+\t\t\t\t    bool ignore_mandatory_trait_items);\n \n protected:\n   PathProbeType (const TyTy::BaseType *receiver,\n-\t\t const HIR::PathIdentSegment &query, DefId specific_trait_id)\n-    : TypeCheckBase (), receiver (receiver), search (query),\n-      current_impl (nullptr), specific_trait_id (specific_trait_id)\n-  {}\n+\t\t const HIR::PathIdentSegment &query, DefId specific_trait_id);\n \n   std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n   union_bounds (\n     const std::vector<std::pair</*const*/ TraitReference *, HIR::ImplBlock *>>\n       a,\n     const std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> b)\n-    const\n-  {\n-    std::map<DefId, std::pair<const TraitReference *, HIR::ImplBlock *>> mapper;\n-    for (auto &ref : a)\n-      {\n-\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n-      }\n-    for (auto &ref : b)\n-      {\n-\tmapper.insert ({ref.first->get_mappings ().get_defid (), ref});\n-      }\n-\n-    std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>> union_set;\n-    for (auto it = mapper.begin (); it != mapper.end (); it++)\n-      {\n-\tunion_set.push_back ({it->second.first, it->second.second});\n-      }\n-    return union_set;\n-  }\n+    const;\n \n-  bool is_reciever_generic () const\n-  {\n-    const TyTy::BaseType *root = receiver->get_root ();\n-    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n-    bool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n-    return receiver_is_type_param || receiver_is_dyn;\n-  }\n+  bool is_reciever_generic () const;\n \n   const TyTy::BaseType *receiver;\n   const HIR::PathIdentSegment &search;\n@@ -489,24 +229,14 @@ class PathProbeImplTrait : public PathProbeType\n   static std::set<PathProbeCandidate>\n   Probe (const TyTy::BaseType *receiver,\n \t const HIR::PathIdentSegment &segment_name,\n-\t const TraitReference *trait_reference)\n-  {\n-    PathProbeImplTrait probe (receiver, segment_name, trait_reference);\n-    // iterate all impls for this trait and receiver\n-    // then search for possible candidates using base class behaviours\n-    probe.process_trait_impl_items_for_candidates ();\n-    return probe.candidates;\n-  }\n+\t const TraitReference *trait_reference);\n \n private:\n-  void process_trait_impl_items_for_candidates ();\n-\n   PathProbeImplTrait (const TyTy::BaseType *receiver,\n \t\t      const HIR::PathIdentSegment &query,\n-\t\t      const TraitReference *trait_reference)\n-    : PathProbeType (receiver, query, UNKNOWN_DEFID),\n-      trait_reference (trait_reference)\n-  {}\n+\t\t      const TraitReference *trait_reference);\n+\n+  void process_trait_impl_items_for_candidates ();\n \n   const TraitReference *trait_reference;\n };"}, {"sha": "19f95ca4488ba090fd07459ff3883023125c57aa", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26af4b0604d3a1da2b31405b0a132d1dc145a370/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26af4b0604d3a1da2b31405b0a132d1dc145a370/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=26af4b0604d3a1da2b31405b0a132d1dc145a370", "patch": "@@ -594,27 +594,5 @@ TraitItemReference::is_object_safe () const\n   return false;\n }\n \n-// rust-hir-path-probe.h\n-\n-void\n-PathProbeImplTrait::process_trait_impl_items_for_candidates ()\n-{\n-  mappings->iterate_impl_items (\n-    [&] (HirId id, HIR::ImplItem *item, HIR::ImplBlock *impl) mutable -> bool {\n-      // just need to check if this is an impl block for this trait the next\n-      // function checks the receiver\n-      if (!impl->has_trait_ref ())\n-\treturn true;\n-\n-      TraitReference *resolved\n-\t= TraitResolver::Lookup (*(impl->get_trait_ref ().get ()));\n-      if (!trait_reference->is_equal (*resolved))\n-\treturn true;\n-\n-      process_impl_item_candidate (id, item, impl);\n-      return true;\n-    });\n-}\n-\n } // namespace Resolver\n } // namespace Rust"}]}