{"sha": "fc06ae0d196a321425aefe9e2e262abfb10c0775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMwNmFlMGQxOTZhMzIxNDI1YWVmZTllMmUyNjJhYmZiMTBjMDc3NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-14T09:18:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-14T09:18:35Z"}, "message": "auto-profile.c (afdo_annotate_cfg): Use update_max_bb_count.\n\n\n\t* auto-profile.c (afdo_annotate_cfg): Use update_max_bb_count.\n\t* cgraphunit.c (cgraph_node::expand_thunk): Use update_max_bb_count.\n\t* ipa-utils.c (ipa_merge_profiles): Use update_max_bb_count.\n\t* lto-streamer-in.c (input_function): Use update_max_bb_count.\n\t* omp-expand.c (expand_omp_taskreg): Use update_max_bb_count.\n\t* predict.c (maybe_hot_frequency_p): Inline to ...\n\t(maybe_hot_count_p): ... here; rewrite to counts.\n\t(counts_to_freqs): Rename to ...\n\t(update_max_bb_count): ... this one.\n\t(expensive_function_p): Use counts.\n\t(estimate_bb_frequencies): Update.\n\t(rebuild_frequencies): Update.\n\t* predict.h (counts_to_freqs): Rename to ...\n\t(update_max_bb_count): ... this one.\n\t* profile.c (compute_branch_probabilities): Add debug info\n\t* tree-inline.c (expand_call_inline): Update debug info.\n\t(optimize_inline_calls): Use update_max_bb_count..\n\t(tree_function_versioning): Use update_max_bb_count..\n\t* value-prof.c (gimple_value_profile_transformations):\n\tDo not use update_max_bb_count.\n\nFrom-SVN: r254725", "tree": {"sha": "6785cead8fe96ac5a04c12298aa78b360382eb4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6785cead8fe96ac5a04c12298aa78b360382eb4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc06ae0d196a321425aefe9e2e262abfb10c0775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc06ae0d196a321425aefe9e2e262abfb10c0775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc06ae0d196a321425aefe9e2e262abfb10c0775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc06ae0d196a321425aefe9e2e262abfb10c0775/comments", "author": null, "committer": null, "parents": [{"sha": "0cea1d34f781ba9e08ffa82458f0410b398e9c93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cea1d34f781ba9e08ffa82458f0410b398e9c93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cea1d34f781ba9e08ffa82458f0410b398e9c93"}], "stats": {"total": 145, "additions": 85, "deletions": 60}, "files": [{"sha": "35cf703bd5199ee7b78be14ff0b8ced6733684d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -1,3 +1,26 @@\n+2017-11-13  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* auto-profile.c (afdo_annotate_cfg): Use update_max_bb_count.\n+\t* cgraphunit.c (cgraph_node::expand_thunk): Use update_max_bb_count.\n+\t* ipa-utils.c (ipa_merge_profiles): Use update_max_bb_count.\n+\t* lto-streamer-in.c (input_function): Use update_max_bb_count.\n+\t* omp-expand.c (expand_omp_taskreg): Use update_max_bb_count.\n+\t* predict.c (maybe_hot_frequency_p): Inline to ...\n+\t(maybe_hot_count_p): ... here; rewrite to counts.\n+\t(counts_to_freqs): Rename to ...\n+\t(update_max_bb_count): ... this one.\n+\t(expensive_function_p): Use counts.\n+\t(estimate_bb_frequencies): Update.\n+\t(rebuild_frequencies): Update.\n+\t* predict.h (counts_to_freqs): Rename to ...\n+\t(update_max_bb_count): ... this one.\n+\t* profile.c (compute_branch_probabilities): Add debug info\n+\t* tree-inline.c (expand_call_inline): Update debug info.\n+\t(optimize_inline_calls): Use update_max_bb_count..\n+\t(tree_function_versioning): Use update_max_bb_count..\n+\t* value-prof.c (gimple_value_profile_transformations):\n+\tDo not use update_max_bb_count.\n+\n 2017-11-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-inline.c (compute_uninlined_call_time, compute_inlined_call_time):"}, {"sha": "5134a7953314d1103c88ec6154c2285f0ae312f9", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -1571,7 +1571,7 @@ afdo_annotate_cfg (const stmt_set &promoted_stmts)\n   if (max_count > profile_count::zero ())\n     {\n       afdo_calculate_branch_prob (&annotated_bb, &annotated_edge);\n-      counts_to_freqs ();\n+      update_max_bb_count ();\n       profile_status_for_fn (cfun) = PROFILE_READ;\n     }\n   if (flag_value_profile_transformations)"}, {"sha": "dec5c8b5736447360966086c1e6446eb1f170704", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -2026,7 +2026,7 @@ cgraph_node::expand_thunk (bool output_asm_thunks, bool force_gimple_thunk)\n \t}\n \n       cfun->gimple_df->in_ssa_p = true;\n-      counts_to_freqs ();\n+      update_max_bb_count ();\n       profile_status_for_fn (cfun)\n         = cfg_count.initialized_p () && cfg_count.ipa_p ()\n \t  ? PROFILE_READ : PROFILE_GUESSED;"}, {"sha": "c991bddd7dd4f82c026335256a3317dae2161020", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -558,7 +558,7 @@ ipa_merge_profiles (struct cgraph_node *dst,\n \t    }\n \t}\n       push_cfun (dstcfun);\n-      counts_to_freqs ();\n+      update_max_bb_count ();\n       compute_function_frequency ();\n       pop_cfun ();\n       for (e = dst->callees; e; e = e->next_callee)"}, {"sha": "d852a3b38556bdf45efedf23aa0382541541e043", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -1192,7 +1192,7 @@ input_function (tree fn_decl, struct data_in *data_in,\n     gimple_set_body (fn_decl, bb_seq (ei_edge (ei)->dest));\n   }\n \n-  counts_to_freqs ();\n+  update_max_bb_count ();\n   fixup_call_stmt_edges (node, stmts);\n   execute_all_ipa_stmt_fixups (node, stmts);\n "}, {"sha": "46d0bea6d421e79eff33c0dd4165be7018548e42", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -1399,7 +1399,7 @@ expand_omp_taskreg (struct omp_region *region)\n \n       if (optimize)\n \toptimize_omp_library_calls (entry_stmt);\n-      counts_to_freqs ();\n+      update_max_bb_count ();\n       cgraph_edge::rebuild_edges ();\n \n       /* Some EH regions might become dead, see PR34608.  If"}, {"sha": "f490ec116ad4236340988cb8bdf2c93e4bf4f649", "filename": "gcc/predict.c", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -121,32 +121,6 @@ static const struct predictor_info predictor_info[]= {\n };\n #undef DEF_PREDICTOR\n \n-/* Return TRUE if frequency FREQ is considered to be hot.  */\n-\n-static inline bool\n-maybe_hot_frequency_p (struct function *fun, int freq)\n-{\n-  struct cgraph_node *node = cgraph_node::get (fun->decl);\n-  if (!profile_info || profile_status_for_fn (fun) != PROFILE_READ)\n-    {\n-      if (node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n-        return false;\n-      if (node->frequency == NODE_FREQUENCY_HOT)\n-        return true;\n-    }\n-  if (profile_status_for_fn (fun) == PROFILE_ABSENT)\n-    return true;\n-  if (node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n-      && freq < (ENTRY_BLOCK_PTR_FOR_FN (fun)->count.to_frequency (fun) * 2 / 3))\n-    return false;\n-  if (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION) == 0)\n-    return false;\n-  if (freq * PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION)\n-      < ENTRY_BLOCK_PTR_FOR_FN (fun)->count.to_frequency (fun))\n-    return false;\n-  return true;\n-}\n-\n static gcov_type min_count = -1;\n \n /* Determine the threshold for hot BB counts.  */\n@@ -179,10 +153,30 @@ maybe_hot_count_p (struct function *fun, profile_count count)\n {\n   if (!count.initialized_p ())\n     return true;\n-  if (!count.ipa_p ())\n-    return maybe_hot_frequency_p (fun, count.to_frequency (fun));\n   if (count.ipa () == profile_count::zero ())\n     return false;\n+  if (!count.ipa_p ())\n+    {\n+      struct cgraph_node *node = cgraph_node::get (fun->decl);\n+      if (!profile_info || profile_status_for_fn (fun) != PROFILE_READ)\n+\t{\n+\t  if (node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n+\t    return false;\n+\t  if (node->frequency == NODE_FREQUENCY_HOT)\n+\t    return true;\n+\t}\n+      if (profile_status_for_fn (fun) == PROFILE_ABSENT)\n+\treturn true;\n+      if (node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n+\t  && count < (ENTRY_BLOCK_PTR_FOR_FN (fun)->count.apply_scale (2, 3)))\n+\treturn false;\n+      if (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION) == 0)\n+\treturn false;\n+      if (count.apply_scale (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION), 1)\n+\t  < ENTRY_BLOCK_PTR_FOR_FN (fun)->count)\n+\treturn false;\n+      return true;\n+    }\n   /* Code executed at most once is not hot.  */\n   if (count <= MAX (profile_info ? profile_info->runs : 1, 1))\n     return false;\n@@ -3317,7 +3311,7 @@ handle_missing_profiles (void)\n    Return nonzero iff there was any nonzero execution count.  */\n \n bool\n-counts_to_freqs (void)\n+update_max_bb_count (void)\n {\n   profile_count true_count_max = profile_count::uninitialized ();\n   basic_block bb;\n@@ -3327,7 +3321,7 @@ counts_to_freqs (void)\n \n   cfun->cfg->count_max = true_count_max;\n \n-  return true_count_max.nonzero_p ();\n+  return true_count_max.ipa ().nonzero_p ();\n }\n \n /* Return true if function is likely to be expensive, so there is no point to\n@@ -3338,30 +3332,37 @@ counts_to_freqs (void)\n bool\n expensive_function_p (int threshold)\n {\n-  unsigned int sum = 0;\n   basic_block bb;\n-  unsigned int limit;\n \n   /* We can not compute accurately for large thresholds due to scaled\n      frequencies.  */\n   gcc_assert (threshold <= BB_FREQ_MAX);\n \n-  /* Frequencies are out of range.  This either means that function contains\n-     internal loop executing more than BB_FREQ_MAX times or profile feedback\n-     is available and function has not been executed at all.  */\n-  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun) == 0)\n+  /* If profile was scaled in a way entry block has count 0, then the function\n+     is deifnitly taking a lot of time.  */\n+  if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.nonzero_p ())\n     return true;\n \n   /* Maximally BB_FREQ_MAX^2 so overflow won't happen.  */\n-  limit = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.to_frequency (cfun) * threshold;\n+  profile_count limit = ENTRY_BLOCK_PTR_FOR_FN\n+\t\t\t   (cfun)->count.apply_scale (threshold, 1);\n+  profile_count sum = profile_count::zero ();\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       rtx_insn *insn;\n \n+      if (!bb->count.initialized_p ())\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Function is considered expensive because\"\n+\t\t     \" count of bb %i is not initialized\\n\", bb->index);\n+\t  return true;\n+\t}\n+\n       FOR_BB_INSNS (bb, insn)\n \tif (active_insn_p (insn))\n \t  {\n-\t    sum += bb->count.to_frequency (cfun);\n+\t    sum += bb->count;\n \t    if (sum > limit)\n \t      return true;\n \t}\n@@ -3521,7 +3522,7 @@ estimate_bb_frequencies (bool force)\n   determine_unlikely_bbs ();\n \n   if (force || profile_status_for_fn (cfun) != PROFILE_READ\n-      || !counts_to_freqs ())\n+      || !update_max_bb_count ())\n     {\n       static int real_values_initialized = 0;\n \n@@ -3873,7 +3874,7 @@ rebuild_frequencies (void)\n       loop_optimizer_finalize ();\n     }\n   else if (profile_status_for_fn (cfun) == PROFILE_READ)\n-    counts_to_freqs ();\n+    update_max_bb_count ();\n   else\n     gcc_unreachable ();\n   timevar_pop (TV_REBUILD_FREQUENCIES);"}, {"sha": "24c604f5abf1fcd414332622e46641950b5e5111", "filename": "gcc/predict.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -89,7 +89,7 @@ extern void guess_outgoing_edge_probabilities (basic_block);\n extern void tree_guess_outgoing_edge_probabilities (basic_block);\n extern void tree_estimate_probability (bool);\n extern void handle_missing_profiles (void);\n-extern bool counts_to_freqs (void);\n+extern bool update_max_bb_count (void);\n extern bool expensive_function_p (int);\n extern void estimate_bb_frequencies (bool);\n extern void compute_function_frequency (void);"}, {"sha": "11170066caea0247c76acc46b57294815c4ddfef", "filename": "gcc/profile.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -497,7 +497,11 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n \n   /* Very simple sanity checks so we catch bugs in our profiling code.  */\n   if (!profile_info)\n-    return;\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Profile info is missing; giving up\\n\");\n+      return;\n+    }\n \n   bb_gcov_counts.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   edge_gcov_counts = new hash_map<edge,gcov_type>;\n@@ -805,7 +809,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n   delete edge_gcov_counts;\n   edge_gcov_counts = NULL;\n \n-  counts_to_freqs ();\n+  update_max_bb_count ();\n \n   if (dump_file)\n     {"}, {"sha": "d4aa5bed739818527a1189ef56d0f80e5dd68b32", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-chkp.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"sreal.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */\n@@ -4670,11 +4671,12 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      fprintf (dump_file, \"Inlining \");\n-      print_generic_expr (dump_file, id->src_fn);\n-      fprintf (dump_file, \" to \");\n-      print_generic_expr (dump_file, id->dst_fn);\n-      fprintf (dump_file, \" with frequency %i\\n\", cg_edge->frequency ());\n+      fprintf (dump_file, \"Inlining %s to %s with frequency %4.2f\\n\",\n+\t       xstrdup_for_dump (id->src_node->dump_name ()),\n+\t       xstrdup_for_dump (id->dst_node->dump_name ()),\n+\t       cg_edge->sreal_frequency ().to_double ());\n+      id->src_node->dump (dump_file);\n+      id->dst_node->dump (dump_file);\n     }\n \n   /* This is it.  Duplicate the callee body.  Assume callee is\n@@ -5057,7 +5059,7 @@ optimize_inline_calls (tree fn)\n     }\n \n   /* Fold queued statements.  */\n-  counts_to_freqs ();\n+  update_max_bb_count ();\n   fold_marked_statements (last, id.statements_to_fold);\n   delete id.statements_to_fold;\n \n@@ -6034,7 +6036,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n \n-  counts_to_freqs ();\n+  update_max_bb_count ();\n   fold_marked_statements (0, id.statements_to_fold);\n   delete id.statements_to_fold;\n   delete_unreachable_blocks_update_callgraph (&id);"}, {"sha": "354279a6712be8e3fabd8b4dcce801ab7fd4ce69", "filename": "gcc/value-prof.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc06ae0d196a321425aefe9e2e262abfb10c0775/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=fc06ae0d196a321425aefe9e2e262abfb10c0775", "patch": "@@ -673,11 +673,6 @@ gimple_value_profile_transformations (void)\n         }\n     }\n \n-  if (changed)\n-    {\n-      counts_to_freqs ();\n-    }\n-\n   return changed;\n }\n "}]}