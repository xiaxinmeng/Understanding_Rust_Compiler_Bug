{"sha": "cd057e3af0627c7528c19625bf972acde2b207fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QwNTdlM2FmMDYyN2M3NTI4YzE5NjI1YmY5NzJhY2RlMmIyMDdmYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-08-25T03:30:11Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-08-25T03:30:11Z"}, "message": "PR c++/51213 (again)\n\n\tPR c++/51213 (again)\n\t* pt.c (deduction_tsubst_fntype): Remove.\n\t(fn_type_unification): Check deduction depth and call\n\tinstantiate_template here.  Handle default argument access checks.\n\t(determine_specialization): Suppress access control.\n\t(tsubst_decl): Check for excessive deduction depth.\n\t(recheck_decl_substitution): Make sure access control is on.\n\t(type_unification_real): Don't mess with access deferring here.\n\t(get_bindings): Adjust for fn_type_unification return type.\n\t* call.c (enum rejection_reason_code): Drop rr_template_instantiation.\n\t(template_instantiation_rejection): Remove.\n\t(struct rejection_reason): Change targs to num_targs.\n\t(template_unification_rejection, print_z_candidate): Adjust.\n\t(add_template_candidate_real): Adjust for fn_type_unification change.\n\t* class.c (resolve_address_of_overloaded_function): Likewise.\n\t* cp-tree.h: Adjust declaration.\n\nFrom-SVN: r190664", "tree": {"sha": "17fe7bac5c9426d507d0aa7ea093be49a6eb893d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17fe7bac5c9426d507d0aa7ea093be49a6eb893d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd057e3af0627c7528c19625bf972acde2b207fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd057e3af0627c7528c19625bf972acde2b207fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd057e3af0627c7528c19625bf972acde2b207fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd057e3af0627c7528c19625bf972acde2b207fa/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f581a987e3d60ad86aafa2a49b72e09b5f9cb356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f581a987e3d60ad86aafa2a49b72e09b5f9cb356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f581a987e3d60ad86aafa2a49b72e09b5f9cb356"}], "stats": {"total": 339, "additions": 185, "deletions": 154}, "files": [{"sha": "4cad303dc4482dc14d17db88d85291a6657d67b6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cd057e3af0627c7528c19625bf972acde2b207fa", "patch": "@@ -1,5 +1,22 @@\n 2012-08-24  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/51213 (again)\n+\t* pt.c (deduction_tsubst_fntype): Remove.\n+\t(fn_type_unification): Check deduction depth and call\n+\tinstantiate_template here.  Handle default argument access checks.\n+\t(determine_specialization): Suppress access control.\n+\t(tsubst_decl): Check for excessive deduction depth.\n+\t(recheck_decl_substitution): Make sure access control is on.\n+\t(type_unification_real): Don't mess with access deferring here.\n+\t(get_bindings): Adjust for fn_type_unification return type.\n+\t* call.c (enum rejection_reason_code): Drop rr_template_instantiation.\n+\t(template_instantiation_rejection): Remove.\n+\t(struct rejection_reason): Change targs to num_targs.\n+\t(template_unification_rejection, print_z_candidate): Adjust.\n+\t(add_template_candidate_real): Adjust for fn_type_unification change.\n+\t* class.c (resolve_address_of_overloaded_function): Likewise.\n+\t* cp-tree.h: Adjust declaration.\n+\n \t* pt.c (tsubst_default_argument): Indicate where the default\n \targument is being instantiated for.\n \t(tsubst_expr): Restore previous location."}, {"sha": "3915738e51629ea6381fce7acf9db9f91cd51a22", "filename": "gcc/cp/call.c", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cd057e3af0627c7528c19625bf972acde2b207fa", "patch": "@@ -451,7 +451,6 @@ enum rejection_reason_code {\n   rr_arg_conversion,\n   rr_bad_arg_conversion,\n   rr_template_unification,\n-  rr_template_instantiation,\n   rr_invalid_copy\n };\n \n@@ -485,7 +484,7 @@ struct rejection_reason {\n     struct {\n       tree tmpl;\n       tree explicit_targs;\n-      tree targs;\n+      int num_targs;\n       const tree *args;\n       unsigned int nargs;\n       tree return_type;\n@@ -688,7 +687,7 @@ template_unification_rejection (tree tmpl, tree explicit_targs, tree targs,\n   struct rejection_reason *r = alloc_rejection (rr_template_unification);\n   r->u.template_unification.tmpl = tmpl;\n   r->u.template_unification.explicit_targs = explicit_targs;\n-  r->u.template_unification.targs = targs;\n+  r->u.template_unification.num_targs = TREE_VEC_LENGTH (targs);\n   /* Copy args to our own storage.  */\n   memcpy (args1, args, args_n_bytes);\n   r->u.template_unification.args = args1;\n@@ -705,15 +704,6 @@ template_unification_error_rejection (void)\n   return alloc_rejection (rr_template_unification);\n }\n \n-static struct rejection_reason *\n-template_instantiation_rejection (tree tmpl, tree targs)\n-{\n-  struct rejection_reason *r = alloc_rejection (rr_template_instantiation);\n-  r->u.template_instantiation.tmpl = tmpl;\n-  r->u.template_instantiation.targs = targs;\n-  return r;\n-}\n-\n static struct rejection_reason *\n invalid_copy_with_fn_template_rejection (void)\n {\n@@ -2873,7 +2863,6 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n   unsigned int ia, ix;\n   tree arg;\n   struct z_candidate *cand;\n-  int i;\n   tree fn;\n   struct rejection_reason *reason = NULL;\n   int errs;\n@@ -2920,12 +2909,12 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n   gcc_assert (ia == nargs_without_in_chrg);\n \n   errs = errorcount+sorrycount;\n-  i = fn_type_unification (tmpl, explicit_targs, targs,\n-\t\t\t   args_without_in_chrg,\n-\t\t\t   nargs_without_in_chrg,\n-\t\t\t   return_type, strict, flags, false);\n+  fn = fn_type_unification (tmpl, explicit_targs, targs,\n+\t\t\t    args_without_in_chrg,\n+\t\t\t    nargs_without_in_chrg,\n+\t\t\t    return_type, strict, flags, false);\n \n-  if (i != 0)\n+  if (fn == error_mark_node)\n     {\n       /* Don't repeat unification later if it already resulted in errors.  */\n       if (errorcount+sorrycount == errs)\n@@ -2938,13 +2927,6 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,\n       goto fail;\n     }\n \n-  fn = instantiate_template (tmpl, targs, tf_none);\n-  if (fn == error_mark_node)\n-    {\n-      reason = template_instantiation_rejection (tmpl, targs);\n-      goto fail;\n-    }\n-\n   /* In [class.copy]:\n \n        A member function template is never instantiated to perform the\n@@ -3239,20 +3221,15 @@ print_z_candidate (location_t loc, const char *msgstr,\n \t  inform (cloc, \"  template argument deduction/substitution failed:\");\n \t  fn_type_unification (r->u.template_unification.tmpl,\n \t\t\t       r->u.template_unification.explicit_targs,\n-\t\t\t       r->u.template_unification.targs,\n+\t\t\t       (make_tree_vec\n+\t\t\t\t(r->u.template_unification.num_targs)),\n \t\t\t       r->u.template_unification.args,\n \t\t\t       r->u.template_unification.nargs,\n \t\t\t       r->u.template_unification.return_type,\n \t\t\t       r->u.template_unification.strict,\n \t\t\t       r->u.template_unification.flags,\n \t\t\t       true);\n \t  break;\n-\tcase rr_template_instantiation:\n-\t  /* Re-run template instantiation with diagnostics.  */\n-\t  instantiate_template (r->u.template_instantiation.tmpl,\n-\t\t\t\tr->u.template_instantiation.targs,\n-\t\t\t\ttf_warning_or_error);\n-\t  break;\n \tcase rr_invalid_copy:\n \t  inform (cloc,\n \t\t  \"  a constructor taking a single argument of its own \""}, {"sha": "3b1906ae64bb16d58cb1f64260b5621427a9b868", "filename": "gcc/cp/class.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cd057e3af0627c7528c19625bf972acde2b207fa", "patch": "@@ -7033,14 +7033,10 @@ resolve_address_of_overloaded_function (tree target_type,\n \n \t  /* Try to do argument deduction.  */\n \t  targs = make_tree_vec (DECL_NTPARMS (fn));\n-\t  if (fn_type_unification (fn, explicit_targs, targs, args, nargs,\n-\t\t\t\t   target_ret_type, DEDUCE_EXACT,\n-\t\t\t\t   LOOKUP_NORMAL, false))\n-\t    /* Argument deduction failed.  */\n-\t    continue;\n-\n-\t  /* Instantiate the template.  */\n-\t  instantiation = instantiate_template (fn, targs, flags);\n+\t  instantiation = fn_type_unification (fn, explicit_targs, targs, args,\n+\t\t\t\t\t      nargs, target_ret_type,\n+\t\t\t\t\t      DEDUCE_EXACT, LOOKUP_NORMAL,\n+\t\t\t\t\t       false);\n \t  if (instantiation == error_mark_node)\n \t    /* Instantiation failed.  */\n \t    continue;"}, {"sha": "7ffc929bc972d3b85aef3d34fc643c9ae23f687a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cd057e3af0627c7528c19625bf972acde2b207fa", "patch": "@@ -5340,7 +5340,7 @@ extern int uses_template_parms_level\t\t(tree, int);\n extern bool in_template_function\t\t(void);\n extern tree instantiate_class_template\t\t(tree);\n extern tree instantiate_template\t\t(tree, tree, tsubst_flags_t);\n-extern int fn_type_unification\t\t\t(tree, tree, tree,\n+extern tree fn_type_unification\t\t\t(tree, tree, tree,\n \t\t\t\t\t\t const tree *, unsigned int,\n \t\t\t\t\t\t tree, unification_kind_t, int,\n \t\t\t\t\t\t bool);"}, {"sha": "f8ff1dfeed6a9a0994f4b2252b9f38f6beb93096", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 128, "deletions": 113, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cd057e3af0627c7528c19625bf972acde2b207fa", "patch": "@@ -80,6 +80,9 @@ static tree cur_stmt_expr;\n    local variables.  */\n static struct pointer_map_t *local_specializations;\n \n+/* True if we've recursed into fn_type_unification too many times.  */\n+static bool excessive_deduction_depth;\n+\n typedef struct GTY(()) spec_entry\n {\n   tree tmpl;\n@@ -1920,8 +1923,12 @@ determine_specialization (tree template_id,\n \t    }\n \n \t  /* See whether this function might be a specialization of this\n-\t     template.  */\n+\t     template.  Suppress access control because we might be trying\n+\t     to make this specialization a friend, and we have already done\n+\t     access control for the declaration of the specialization.  */\n+\t  push_deferring_access_checks (dk_no_check);\n \t  targs = get_bindings (fn, decl, explicit_targs, /*check_ret=*/true);\n+\t  pop_deferring_access_checks ();\n \n \t  if (!targs)\n \t    /* We cannot deduce template arguments that when used to\n@@ -9963,6 +9970,11 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tif (type == error_mark_node)\n \t  RETURN (error_mark_node);\n \n+\t/* If we hit excessive deduction depth, the type is bogus even if\n+\t   it isn't error_mark_node, so don't build a decl.  */\n+\tif (excessive_deduction_depth)\n+\t  RETURN (error_mark_node);\n+\n \t/* We do NOT check for matching decls pushed separately at this\n \t   point, as they may not represent instantiations of this\n \t   template, and in any case are considered separate under the\n@@ -14260,66 +14272,6 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n   return result;\n }\n \n-/* In C++0x, it's possible to have a function template whose type depends\n-   on itself recursively.  This is most obvious with decltype, but can also\n-   occur with enumeration scope (c++/48969).  So we need to catch infinite\n-   recursion and reject the substitution at deduction time; this function\n-   will return error_mark_node for any repeated substitution.\n-\n-   This also catches excessive recursion such as when f<N> depends on\n-   f<N-1> across all integers, and returns error_mark_node for all the\n-   substitutions back up to the initial one.\n-\n-   This is, of course, not reentrant.  */\n-\n-static tree\n-deduction_tsubst_fntype (tree fn, tree targs, tsubst_flags_t complain)\n-{\n-  static bool excessive_deduction_depth;\n-  static int deduction_depth;\n-  struct pending_template *old_last_pend = last_pending_template;\n-  struct tinst_level *old_error_tinst = last_error_tinst_level;\n-\n-  tree fntype = TREE_TYPE (fn);\n-  tree tinst;\n-  tree r;\n-\n-  if (excessive_deduction_depth)\n-    return error_mark_node;\n-\n-  tinst = build_tree_list (fn, targs);\n-  if (!push_tinst_level (tinst))\n-    {\n-      excessive_deduction_depth = true;\n-      ggc_free (tinst);\n-      return error_mark_node;\n-    }\n-\n-  input_location = DECL_SOURCE_LOCATION (fn);\n-  ++deduction_depth;\n-  /* We will do access checks in instantiate_template.  */\n-  push_deferring_access_checks (dk_deferred);\n-  r = tsubst (fntype, targs, complain, NULL_TREE);\n-  pop_deferring_access_checks ();\n-  --deduction_depth;\n-\n-  if (excessive_deduction_depth)\n-    {\n-      r = error_mark_node;\n-      if (deduction_depth == 0)\n-\t/* Reset once we're all the way out.  */\n-\texcessive_deduction_depth = false;\n-    }\n-\n-  pop_tinst_level ();\n-  /* We can't free this if a pending_template entry or last_error_tinst_level\n-     is pointing at it.  */\n-  if (last_pending_template == old_last_pend\n-      && last_error_tinst_level == old_error_tinst)\n-    ggc_free (tinst);\n-  return r;\n-}\n-\n /* We're out of SFINAE context now, so generate diagnostics for the access\n    errors we saw earlier when instantiating D from TMPL and ARGS.  */\n \n@@ -14331,9 +14283,11 @@ recheck_decl_substitution (tree d, tree tmpl, tree args)\n   location_t loc = input_location;\n \n   push_access_scope (d);\n+  push_deferring_access_checks (dk_no_deferred);\n   input_location = DECL_SOURCE_LOCATION (pattern);\n   tsubst (type, args, tf_warning_or_error, d);\n   input_location = loc;\n+  pop_deferring_access_checks ();\n   pop_access_scope (d);\n }\n \n@@ -14547,7 +14501,7 @@ pack_deducible_p (tree parm, tree fn)\n      as in [temp.expl.spec], or when taking the address of a function\n      template, as in [temp.deduct.funcaddr].  */\n \n-int\n+tree\n fn_type_unification (tree fn,\n \t\t     tree explicit_targs,\n \t\t     tree targs,\n@@ -14560,7 +14514,38 @@ fn_type_unification (tree fn,\n {\n   tree parms;\n   tree fntype;\n-  int result;\n+  tree decl = NULL_TREE;\n+  tsubst_flags_t complain = (explain_p ? tf_warning_or_error : tf_none);\n+  bool ok;\n+  static int deduction_depth;\n+  struct pending_template *old_last_pend = last_pending_template;\n+  struct tinst_level *old_error_tinst = last_error_tinst_level;\n+  tree tinst;\n+  tree r = error_mark_node;\n+\n+  if (excessive_deduction_depth)\n+    return error_mark_node;\n+\n+  /* In C++0x, it's possible to have a function template whose type depends\n+     on itself recursively.  This is most obvious with decltype, but can also\n+     occur with enumeration scope (c++/48969).  So we need to catch infinite\n+     recursion and reject the substitution at deduction time; this function\n+     will return error_mark_node for any repeated substitution.\n+\n+     This also catches excessive recursion such as when f<N> depends on\n+     f<N-1> across all integers, and returns error_mark_node for all the\n+     substitutions back up to the initial one.\n+\n+     This is, of course, not reentrant.  */\n+  tinst = build_tree_list (fn, targs);\n+  if (!push_tinst_level (tinst))\n+    {\n+      excessive_deduction_depth = true;\n+      ggc_free (tinst);\n+      return error_mark_node;\n+    }\n+  ++deduction_depth;\n+  push_deferring_access_checks (dk_deferred);\n \n   gcc_assert (TREE_CODE (fn) == TEMPLATE_DECL);\n \n@@ -14586,21 +14571,20 @@ fn_type_unification (tree fn,\n \t template results in an invalid type, type deduction fails.  */\n       tree tparms = DECL_INNERMOST_TEMPLATE_PARMS (fn);\n       int i, len = TREE_VEC_LENGTH (tparms);\n+      location_t loc = input_location;\n       tree converted_args;\n       bool incomplete = false;\n \n       if (explicit_targs == error_mark_node)\n-\treturn unify_invalid (explain_p);\n+\tgoto fail;\n \n       converted_args\n \t= (coerce_template_parms (tparms, explicit_targs, NULL_TREE,\n-\t\t\t\t  (explain_p\n-\t\t\t\t   ? tf_warning_or_error\n-\t\t\t\t   : tf_none),\n+\t\t\t\t  complain,\n \t\t\t\t   /*require_all_args=*/false,\n \t\t\t\t   /*use_default_args=*/false));\n       if (converted_args == error_mark_node)\n-\treturn 1;\n+\tgoto fail;\n \n       /* Substitute the explicit args into the function type.  This is\n \t necessary so that, for instance, explicitly declared function\n@@ -14649,14 +14633,14 @@ fn_type_unification (tree fn,\n         }\n \n       processing_template_decl += incomplete;\n-      fntype = deduction_tsubst_fntype (fn, converted_args,\n-\t\t\t\t\t(explain_p\n-\t\t\t\t\t ? tf_warning_or_error\n-\t\t\t\t\t : tf_none) | tf_partial);\n+      input_location = DECL_SOURCE_LOCATION (fn);\n+      fntype = tsubst (TREE_TYPE (fn), converted_args,\n+\t\t       complain | tf_partial, NULL_TREE);\n+      input_location = loc;\n       processing_template_decl -= incomplete;\n \n       if (fntype == error_mark_node)\n-\treturn 1;\n+\tgoto fail;\n \n       /* Place the explicitly specified arguments in TARGS.  */\n       for (i = NUM_TMPL_ARGS (converted_args); i--;)\n@@ -14682,9 +14666,14 @@ fn_type_unification (tree fn,\n      because the standard doesn't seem to explicitly prohibit it.  Our\n      callers must be ready to deal with unification failures in any\n      event.  */\n-  result = type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n-\t\t\t\t  targs, parms, args, nargs, /*subr=*/0,\n-\t\t\t\t  strict, flags, explain_p);\n+\n+  pop_tinst_level ();\n+  ok = !type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n+\t\t\t       targs, parms, args, nargs, /*subr=*/0,\n+\t\t\t       strict, flags, explain_p);\n+  push_tinst_level (tinst);\n+  if (!ok)\n+    goto fail;\n \n   /* Now that we have bindings for all of the template arguments,\n      ensure that the arguments deduced for the template template\n@@ -14707,48 +14696,75 @@ fn_type_unification (tree fn,\n      parameter 'T', but 'C' is deduced to 'X' before 'T' is deduced to\n      'long'.  Thus, we can't check that 'C' cannot bind to 'X' at the\n      time that we deduce 'C'.  */\n-  if (result == 0\n-      && !template_template_parm_bindings_ok_p \n+  if (!template_template_parm_bindings_ok_p\n            (DECL_INNERMOST_TEMPLATE_PARMS (fn), targs))\n-    return unify_inconsistent_template_template_parameters (explain_p);\n+    {\n+      unify_inconsistent_template_template_parameters (explain_p);\n+      goto fail;\n+    }\n \n-  if (result == 0)\n-    /* All is well so far.  Now, check:\n+  /* All is well so far.  Now, check:\n \n-       [temp.deduct]\n+     [temp.deduct]\n \n-       When all template arguments have been deduced, all uses of\n-       template parameters in nondeduced contexts are replaced with\n-       the corresponding deduced argument values.  If the\n-       substitution results in an invalid type, as described above,\n-       type deduction fails.  */\n+     When all template arguments have been deduced, all uses of\n+     template parameters in nondeduced contexts are replaced with\n+     the corresponding deduced argument values.  If the\n+     substitution results in an invalid type, as described above,\n+     type deduction fails.  */\n+  decl = instantiate_template (fn, targs, complain);\n+  if (decl == error_mark_node)\n+    goto fail;\n+\n+  /* Now perform any access checks encountered during deduction, such as\n+     for default template arguments.  */\n+  push_access_scope (decl);\n+  ok = perform_deferred_access_checks (complain);\n+  pop_access_scope (decl);\n+  if (!ok)\n+    goto fail;\n+\n+  /* If we're looking for an exact match, check that what we got\n+     is indeed an exact match.  It might not be if some template\n+     parameters are used in non-deduced contexts.  */\n+  if (strict == DEDUCE_EXACT)\n     {\n-      tree substed = deduction_tsubst_fntype (fn, targs,\n-\t\t\t\t\t      (explain_p\n-\t\t\t\t\t       ? tf_warning_or_error\n-\t\t\t\t\t       : tf_none));\n-      if (substed == error_mark_node)\n-\treturn 1;\n+      tree substed = TREE_TYPE (decl);\n+      unsigned int i;\n \n-      /* If we're looking for an exact match, check that what we got\n-\t is indeed an exact match.  It might not be if some template\n-\t parameters are used in non-deduced contexts.  */\n-      if (strict == DEDUCE_EXACT)\n-\t{\n-\t  unsigned int i;\n-\n-\t  tree sarg\n-\t    = skip_artificial_parms_for (fn, TYPE_ARG_TYPES (substed));\n-\t  if (return_type)\n-\t    sarg = tree_cons (NULL_TREE, TREE_TYPE (substed), sarg);\n-\t  for (i = 0; i < nargs && sarg; ++i, sarg = TREE_CHAIN (sarg))\n-\t    if (!same_type_p (args[i], TREE_VALUE (sarg)))\n-\t      return unify_type_mismatch (explain_p, args[i],\n-\t\t\t\t\t  TREE_VALUE (sarg));\n-\t}\n+      tree sarg\n+\t= skip_artificial_parms_for (decl, TYPE_ARG_TYPES (substed));\n+      if (return_type)\n+\tsarg = tree_cons (NULL_TREE, TREE_TYPE (substed), sarg);\n+      for (i = 0; i < nargs && sarg; ++i, sarg = TREE_CHAIN (sarg))\n+\tif (!same_type_p (args[i], TREE_VALUE (sarg)))\n+\t  {\n+\t    unify_type_mismatch (explain_p, args[i],\n+\t\t\t\t TREE_VALUE (sarg));\n+\t    goto fail;\n+\t  }\n     }\n \n-  return result;\n+  r = decl;\n+\n+ fail:\n+  pop_deferring_access_checks ();\n+  --deduction_depth;\n+  if (excessive_deduction_depth)\n+    {\n+      if (deduction_depth == 0)\n+\t/* Reset once we're all the way out.  */\n+\texcessive_deduction_depth = false;\n+    }\n+\n+  pop_tinst_level ();\n+  /* We can't free this if a pending_template entry or last_error_tinst_level\n+     is pointing at it.  */\n+  if (last_pending_template == old_last_pend\n+      && last_error_tinst_level == old_error_tinst)\n+    ggc_free (tinst);\n+\n+  return r;\n }\n \n /* Adjust types before performing type deduction, as described in\n@@ -15159,11 +15175,9 @@ type_unification_real (tree tparms,\n \t      location_t save_loc = input_location;\n \t      if (DECL_P (parm))\n \t\tinput_location = DECL_SOURCE_LOCATION (parm);\n-\t      push_deferring_access_checks (dk_no_deferred);\n \t      arg = tsubst_template_arg (arg, targs, complain, NULL_TREE);\n \t      arg = convert_template_argument (parm, arg, targs, complain,\n \t\t\t\t\t       i, NULL_TREE);\n-\t      pop_deferring_access_checks ();\n \t      input_location = save_loc;\n \t      if (arg == error_mark_node)\n \t\treturn 1;\n@@ -17180,7 +17194,8 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n \t\t\t   args, ix,\n \t\t\t   (check_rettype || DECL_CONV_FN_P (fn)\n \t\t\t    ? TREE_TYPE (decl_type) : NULL_TREE),\n-\t\t\t   DEDUCE_EXACT, LOOKUP_NORMAL, /*explain_p=*/false))\n+\t\t\t   DEDUCE_EXACT, LOOKUP_NORMAL, /*explain_p=*/false)\n+      == error_mark_node)\n     return NULL_TREE;\n \n   return targs;"}, {"sha": "b664c8d0c6e0271b50fc28240ef7f1025d4e5326", "filename": "gcc/testsuite/g++.dg/cpp0x/fntmpdefarg3.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffntmpdefarg3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd057e3af0627c7528c19625bf972acde2b207fa/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffntmpdefarg3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Ffntmpdefarg3.C?ref=cd057e3af0627c7528c19625bf972acde2b207fa", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile { target c++11 } }\n+\n+template <class T, class = typename T::I> void f(T) {}\n+template <class T, class = typename T::I> void g(T) {}\n+// template <class T, class = typename T::I> void h(T) {}\n+// template <class T, class = typename T::I> void i(T) {}\n+template <class T, class = typename T::I> void j(T) {} // { dg-error \"this context\" }\n+\n+class A\n+{\n+  typedef int I;\t\t// { dg-error \"private\" }\n+  template <class T, class> friend void f(T);\n+  friend void g<A,I>(A);\n+  // friend void h<A>(A);\n+  // friend void i<>(A);\n+};\n+\n+int main()\n+{\n+  A a;\n+  f(a);\n+  g(a);\n+  // h(a);\n+  // i(a);\n+  j(a);\t\t\t\t// { dg-error \"no match\" }\n+}"}]}