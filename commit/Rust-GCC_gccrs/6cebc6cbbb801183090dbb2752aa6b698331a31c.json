{"sha": "6cebc6cbbb801183090dbb2752aa6b698331a31c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNlYmM2Y2JiYjgwMTE4MzA5MGRiYjI3NTJhYTZiNjk4MzMxYTMxYw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds_cb1@t-online.de", "date": "2019-11-25T12:31:16Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2019-11-25T12:31:16Z"}, "message": "Convert m68k to not use cc0\n\n\t* config/m68k/m68k.c (output_move_himode, output_move_qimode):\n\tReplace code for non-CONST_INT constants with gcc_unreachable.\n\t* config/m68k/m68k.md (cbranchdi): Don't generate individual\n\tcompare and test.\n\t(CMPMODE): New mode_iterator.\n\t(cbranchsi4, cbranchqi4, cbranchhi4): Replace expanders with\n\tcbranch<mode>4.\n\t(cstoresi4, cstoreqi4, cstorehi4): Replace expanders with\n\tcstore<mode>4.\n\t(cmp<mode>_68881): Remove 'F' constraint from first comparison\n\toperand.\n\t(bit test insns patterns): Use nonimmediate_operand, not\n\tregister_operand, for source operands that allow memory in\n\ttheir constraints.\n\t(divmodsi4, udivmodsi4, divmodhi4 and related unnamed patterns):\n\tUse register_operand, not nonimmediate_operand, for the\n\tdestinations.\n\t(DBCC): New mode_iterator.\n\t(dbcc peepholes): Use it to reduce duplication.\n\t(trap): Use const_true_rtx, not const1_rtx.\n\t* config/m68k/predicates.md (m68k_comparison_operand): Renamed\n\tfrom m68k_subword_comparison_operand and changed to handle\n\tSImode.\n\n\tPR target/91851\n\t* config/m68k/m68k-protos.h (output-dbcc_and_branch): Adjust\n\tdeclaration.\n\t(m68k_init_cc): New declaration.\n\t(m68k_output_compare_di, m68k_output_compare_si)\n\t(m68k_output_compare_hi, m68k_output_compare_qi)\n\t(m68k_output_compare_fp, m68k_output_btst, m68k_output_bftst)\n\t(m68k_find_flags_value, m68k_output_scc, m68k_output_scc_float)\n\t(m68k_output_branch_integer, m68k_output_branch_integer_rev.\n\tm68k_output_branch_float, m68k_output_branch_float_rev):\n\tLikewise.\n\t(valid_dbcc_comparison_p_2, flags_in_68881)\n\t(output_btst): Remove declaration.\n\t* config/m68k/m68k.c (INCLDUE_STRING): Define.\n\t(TARGET_ASM_FINAL_POSTSCAN_INSN): Define.\n\t(valid_dbcc_comparison_p_2, flags_in_68881): Delete functions.\n\t(flags_compare_op0, flags_compare_op1, flags_operand1,\n\tflags_operand2, flags_valid): New static variables.\n\t(m68k_find_flags_value, m68k_init_cc): New functions.\n\t(handle_flags_for_move, m68k_asm_final_postscan_insn,\n\tremember_compare_flags): New static functions.\n\t(output_dbcc_and_branch): New argument CODE.  Use it, and add\n\tPLUS and MINUS to the possible codes.  All callers changed.\n\t(m68k_output_btst): Renamed from output_btst.  Remove OPERANDS\n\tand INSN arguments, add CODE arg.  Return the comparison code\n\tto use.  All callers changed.  Use CODE instead of\n\tnext_insn_tests_no_inequality, and replace cc_status management\n\twith changing the return code.\n\t(m68k_rtx_costs): Instead of testing for COMPARE, test for\n\tRTX_COMPARE or RTX_COMM_COMPARE.\n\t(output_move_simode, output_move_qimode): Call\n\thandle_flags_for_move.\n\t(notice_update_cc): Delete function.\n\t(m68k_output_bftst, m68k_output_compare_di, m68k_output_compare_si,\n\tm68k_output_compare_hi, m68k_output_compare_qi,\n\tm68k_output_compare_fp, m68k_output_branch_integer,\n\tm68k_output_branch_integer_rev, m68k_output_scc,\n\tm68k_output_branch_float, m68k_output_branch_float_rev,\n\tm68k_output_scc_float): New functions.\n\t(output_andsi3, output_iorsi3, output_xorsi3): Call CC_STATUS_INIT\n\tonce at the start, and set flags_valid and flags_operand1 if the\n\tflags are usable.\n\t* config/m68k/m68k.h (CC_IN_68881, NOTICE_UPDATE_CC,\n\tCC_OVERFLOW_UNUSABLE, CC_NO_CARRY, OUTPUT_JUMP): Remove\n\tdefinitions.\n\t(CC_STATUS_INIT): Define.\n\t* config/m68k/m68k.md (flags_valid): New define_attr.\n\t(tstdi, tstsi_internal_68020_cf, tstsi_internal, tsthi_internal,\n\ttstqi_internal, tst<mode>_68881, tst<mode>_cf, cmpdi_internal,\n\tcmpdi, unnamed cmpsi/cmphi/cmpqi patterns, cmpsi_cf,\n\tcmp<mode>_68881, cmp<mode>_cf, unnamed btst patterns,\n\ttst_bftst_reg, tst_bftst_reg, unnamed scc patterns, scc,\n\tsls, sordered_1, sunordered_1, suneq_1, sunge_1, sungt_1,\n\tsunle_1, sunlt_1, sltgt_1, fsogt_1, fsoge_1, fsolt_1, fsole_1,\n\tbge0_di, blt0_di, beq, bne, bgt, bgtu, blt, bltu, bge, bgeu,\n\tble, bleu, bordered, bunordered, buneq, bunge, bungt, bunle,\n\tbunlt, bltgt, beq_rev, bne_rev, bgt_rev, bgtu_rev,\n\tblt_rev, bltu_rev, bge_rev, bgeu_rev, ble_rev, bleu_rev,\n\tbordered_rev, bunordered_rev, buneq_rev, bunge_rv, bungt_rev,\n\tbunle_rev, bunlt_rev, bltgt_rev, ctrapdi4, ctrapsi4, ctraphi4,\n\tctrapqi4, conditional_trap): Delete patterns.\n\t(cbranchdi4_insn): New pattern.\n\t(cbranchdi4): Don't generate cc0 patterns.  When testing LT or GE,\n\ttest high part only.  When testing EQ or NE, generate beq0_di\n\tand bne0_di patterns directly.\n\t(cstoredi4): When testing LT or GE, test high part only.\n\t(both sets of cbranch<mode>4, cstore<mode>4): Don't generate cc0\n\tpatterns.\n\t(scc0_constraints, cmp1_constraints, cmp2_constraints,\n\tscc0_cf_constraints, cmp1_cf_constraints, cmp2_cf_constraints,\n\tcmp2_cf_predicate): New define_mode_attrs.\n\t(cbranch<mode>4_insn, cbranch<mode>4_insn_rev,\n\tcbranch<mode>4_insn_cf, cbranch<mode>4_insn_cf_rev,\n\tcstore<mode>4_insn, cstore<mode>4_insn_cf for integer modes)\n\tNew patterns.\n\t(cbranch<mode>4_insn_68881, cbranch<mode>4_insn_rev_68881):\n\t(cbranch<mode>4_insn_cf, cbranch<mode>4_insn_rev_cf,\n\tcstore<mode>4_insn_68881, cstore<mode>4_insn_cf for FP):\n\tNew patterns.\n\t(cbranchsi4_btst_mem_insn, cbranchsi4_btst_reg_insn,\n\tcbranchsi4_btst_mem_insn_1, cbranchsi4_btst_reg_insn_1):\n\tLikewise.\n\t(BTST): New define_mode_iterator.\n\t(btst_predicate, btst_constraint, btst_range): New\n\tdefine_mode_attrs.\n\t(cbranch_bftst<mode>_insn, cstore_bftst<mode>_insn): New\n\tpatterns.\n\t(movsi_m68k_movsi_m68k2, movsi_cf, unnamed movstrict patterns,\n\tunnamed movhi and movqi patterns, unnamed movsf, movdf and movxf\n\tpatterns): Set attr \"flags_valid\".\n\t(truncsiqi2, trunchiqi2, truncsihi2): Remove manual CC_STATUS\n\tmanagement.  Set attr \"flags_valid\".\n\t(extendsidi2, extendplussidi, unnamed float_extendsfdf pattern,\n\textendsfdf2_cf, fix_truncdfsi2, fix_truncdfhi2, fix_truncdfqi2,\n\taddi_sexthishl32, adddi_dilshr32, adddi_dilshr32_cf,\n\taddi_dishl32, subdi_sexthishl32, subdi_dishl32, subdi3): Remove\n\tmanual CC_STATUS management.\n\t(addsi3_internal, addhi3, addqi3, subsi3, subhi3, subqi3,\n\tunnamed strict_lowpart subhi and subqi patterns): Set attr\n\t\"flags_valid\".\n\t(unnamed strict_lowpart addhi3 and addqi3 patterns): Likewise.\n\tRemove code to operate on address regs and assert the case\n\tdoes not occur.\n\t(unnamed mulsidi patterns, divmodhi4, udivmodhi4): Remove\n\tmanual CC_STATUS_INIT.\n\t(andsi3_internal, andhi3, andqi3, iorsi3_internal, iorhi3, iorqi3,\n\txorsi3_internal, xorhi3, xorqi3, negsi2_internal,\n\tnegsi2_5200, neghi2, negqi2, one_cmplsi2_internal, one_cmplhi2,\n\tone_cmplqi2, unnamed strict_lowpart patterns\n\tfor andhi, andqi, iorhi, iorqi, xorhi, xorqi, neghi, negqi,\n\tone_cmplhi and one_cmplqi): Set attr \"flags_valid\".\n\t(iorsi_zext_ashl16, iorsi_zext): Remove manual CC_STATUS_INIT.\n\t(ashldi_sexthi, ashlsi_16, ashlsi_17_24): Remove manual\n\tCC_STATUS_INIT.\n\t(ashlsi3, ashlhi3, ashlqi3, ashrsi3, ashrhi3, ashrqi3, lshrsi3,\n\tlshrhi3, shrqi3, rotlsi3, rotlhi3, rotlhi3_lowpart, rotlqi3,\n\trotlqi3_lowpart, rotrsi3, rotrhi3, rotrhi_lowpart, rotrqi3,\n\tunnamed strict_low_part patterns for HI and\n\tQI versions): Set attr \"flags_valid\".\n\t(bsetmemqi, bsetmemqi_ext, bsetdreg, bchgdreg, bclrdreg,\n\tbclrmemqi, extzv_8_16_reg, extzv_bfextu_mem, insv_bfchg_mem,\n\tinsv_bfclr_mem, insv_bfset_mem, extv_bfextu_reg,\n\tinsv_bfclr_reg, insv_bfset_reg, dbne_hi, dbne_si, dbge_hi,\n\tdbge_si, extendsfxf2, extenddfxf2, ): Remove manual cc_status management.\n\t(various unnamed peepholes): Adjust compare/branch sequences\n\tfor new cbranch patterns.\n\t(dbcc peepholes): Likewise, and output the comparison here\n\tas well.\n\t* config/m68k/predicates.md (valid_dbcc_comparison_p): Delete.\n\t(fp_src_operand): Allow constant zero.\n\t(address_reg_operand): New predicate.\n\n\t* rtl.h (inequality_comparisons_p): Remove declaration.\n\t* recog.h (next_insn_tests_no_inequality): Likewise.\n\t* rtlanal.c (inequality_comparisons_p): Delete function.\n\t* recog.c (next_insn_tests_no_inequality): Likewise.\n\nFrom-SVN: r278681", "tree": {"sha": "fca756e8522b7361502d0dc0728102c258745712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fca756e8522b7361502d0dc0728102c258745712"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cebc6cbbb801183090dbb2752aa6b698331a31c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cebc6cbbb801183090dbb2752aa6b698331a31c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cebc6cbbb801183090dbb2752aa6b698331a31c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cebc6cbbb801183090dbb2752aa6b698331a31c/comments", "author": {"login": "bernds", "id": 92527, "node_id": "MDQ6VXNlcjkyNTI3", "avatar_url": "https://avatars.githubusercontent.com/u/92527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernds", "html_url": "https://github.com/bernds", "followers_url": "https://api.github.com/users/bernds/followers", "following_url": "https://api.github.com/users/bernds/following{/other_user}", "gists_url": "https://api.github.com/users/bernds/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernds/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernds/subscriptions", "organizations_url": "https://api.github.com/users/bernds/orgs", "repos_url": "https://api.github.com/users/bernds/repos", "events_url": "https://api.github.com/users/bernds/events{/privacy}", "received_events_url": "https://api.github.com/users/bernds/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9daced36d53a316bb8ddeb1e0edcb7982bebeb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9daced36d53a316bb8ddeb1e0edcb7982bebeb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9daced36d53a316bb8ddeb1e0edcb7982bebeb9"}], "stats": {"total": 4015, "additions": 1801, "deletions": 2214}, "files": [{"sha": "b0957b0f9734fa9ec0f956e8f563226046307b16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c", "patch": "@@ -1,3 +1,166 @@\n+2019-11-25  Bernd Schmidt  <bernds_cb1@t-online.de>\n+\n+\t* config/m68k/m68k.c (output_move_himode, output_move_qimode):\n+\tReplace code for non-CONST_INT constants with gcc_unreachable.\n+\t* config/m68k/m68k.md (cbranchdi): Don't generate individual\n+\tcompare and test.\n+\t(CMPMODE): New mode_iterator.\n+\t(cbranchsi4, cbranchqi4, cbranchhi4): Replace expanders with\n+\tcbranch<mode>4.\n+\t(cstoresi4, cstoreqi4, cstorehi4): Replace expanders with\n+\tcstore<mode>4.\n+\t(cmp<mode>_68881): Remove 'F' constraint from first comparison\n+\toperand.\n+\t(bit test insns patterns): Use nonimmediate_operand, not\n+\tregister_operand, for source operands that allow memory in\n+\ttheir constraints.\n+\t(divmodsi4, udivmodsi4, divmodhi4 and related unnamed patterns):\n+\tUse register_operand, not nonimmediate_operand, for the\n+\tdestinations.\n+\t(DBCC): New mode_iterator.\n+\t(dbcc peepholes): Use it to reduce duplication.\n+\t(trap): Use const_true_rtx, not const1_rtx.\n+\t* config/m68k/predicates.md (m68k_comparison_operand): Renamed\n+\tfrom m68k_subword_comparison_operand and changed to handle\n+\tSImode.\n+\n+\tPR target/91851\n+\t* config/m68k/m68k-protos.h (output-dbcc_and_branch): Adjust\n+\tdeclaration.\n+\t(m68k_init_cc): New declaration.\n+\t(m68k_output_compare_di, m68k_output_compare_si)\n+\t(m68k_output_compare_hi, m68k_output_compare_qi)\n+\t(m68k_output_compare_fp, m68k_output_btst, m68k_output_bftst)\n+\t(m68k_find_flags_value, m68k_output_scc, m68k_output_scc_float)\n+\t(m68k_output_branch_integer, m68k_output_branch_integer_rev.\n+\tm68k_output_branch_float, m68k_output_branch_float_rev):\n+\tLikewise.\n+\t(valid_dbcc_comparison_p_2, flags_in_68881)\n+\t(output_btst): Remove declaration.\n+\t* config/m68k/m68k.c (INCLDUE_STRING): Define.\n+\t(TARGET_ASM_FINAL_POSTSCAN_INSN): Define.\n+\t(valid_dbcc_comparison_p_2, flags_in_68881): Delete functions.\n+\t(flags_compare_op0, flags_compare_op1, flags_operand1,\n+\tflags_operand2, flags_valid): New static variables.\n+\t(m68k_find_flags_value, m68k_init_cc): New functions.\n+\t(handle_flags_for_move, m68k_asm_final_postscan_insn,\n+\tremember_compare_flags): New static functions.\n+\t(output_dbcc_and_branch): New argument CODE.  Use it, and add\n+\tPLUS and MINUS to the possible codes.  All callers changed.\n+\t(m68k_output_btst): Renamed from output_btst.  Remove OPERANDS\n+\tand INSN arguments, add CODE arg.  Return the comparison code\n+\tto use.  All callers changed.  Use CODE instead of\n+\tnext_insn_tests_no_inequality, and replace cc_status management\n+\twith changing the return code.\n+\t(m68k_rtx_costs): Instead of testing for COMPARE, test for\n+\tRTX_COMPARE or RTX_COMM_COMPARE.\n+\t(output_move_simode, output_move_qimode): Call\n+\thandle_flags_for_move.\n+\t(notice_update_cc): Delete function.\n+\t(m68k_output_bftst, m68k_output_compare_di, m68k_output_compare_si,\n+\tm68k_output_compare_hi, m68k_output_compare_qi,\n+\tm68k_output_compare_fp, m68k_output_branch_integer,\n+\tm68k_output_branch_integer_rev, m68k_output_scc,\n+\tm68k_output_branch_float, m68k_output_branch_float_rev,\n+\tm68k_output_scc_float): New functions.\n+\t(output_andsi3, output_iorsi3, output_xorsi3): Call CC_STATUS_INIT\n+\tonce at the start, and set flags_valid and flags_operand1 if the\n+\tflags are usable.\n+\t* config/m68k/m68k.h (CC_IN_68881, NOTICE_UPDATE_CC,\n+\tCC_OVERFLOW_UNUSABLE, CC_NO_CARRY, OUTPUT_JUMP): Remove\n+\tdefinitions.\n+\t(CC_STATUS_INIT): Define.\n+\t* config/m68k/m68k.md (flags_valid): New define_attr.\n+\t(tstdi, tstsi_internal_68020_cf, tstsi_internal, tsthi_internal,\n+\ttstqi_internal, tst<mode>_68881, tst<mode>_cf, cmpdi_internal,\n+\tcmpdi, unnamed cmpsi/cmphi/cmpqi patterns, cmpsi_cf,\n+\tcmp<mode>_68881, cmp<mode>_cf, unnamed btst patterns,\n+\ttst_bftst_reg, tst_bftst_reg, unnamed scc patterns, scc,\n+\tsls, sordered_1, sunordered_1, suneq_1, sunge_1, sungt_1,\n+\tsunle_1, sunlt_1, sltgt_1, fsogt_1, fsoge_1, fsolt_1, fsole_1,\n+\tbge0_di, blt0_di, beq, bne, bgt, bgtu, blt, bltu, bge, bgeu,\n+\tble, bleu, bordered, bunordered, buneq, bunge, bungt, bunle,\n+\tbunlt, bltgt, beq_rev, bne_rev, bgt_rev, bgtu_rev,\n+\tblt_rev, bltu_rev, bge_rev, bgeu_rev, ble_rev, bleu_rev,\n+\tbordered_rev, bunordered_rev, buneq_rev, bunge_rv, bungt_rev,\n+\tbunle_rev, bunlt_rev, bltgt_rev, ctrapdi4, ctrapsi4, ctraphi4,\n+\tctrapqi4, conditional_trap): Delete patterns.\n+\t(cbranchdi4_insn): New pattern.\n+\t(cbranchdi4): Don't generate cc0 patterns.  When testing LT or GE,\n+\ttest high part only.  When testing EQ or NE, generate beq0_di\n+\tand bne0_di patterns directly.\n+\t(cstoredi4): When testing LT or GE, test high part only.\n+\t(both sets of cbranch<mode>4, cstore<mode>4): Don't generate cc0\n+\tpatterns.\n+\t(scc0_constraints, cmp1_constraints, cmp2_constraints,\n+\tscc0_cf_constraints, cmp1_cf_constraints, cmp2_cf_constraints,\n+\tcmp2_cf_predicate): New define_mode_attrs.\n+\t(cbranch<mode>4_insn, cbranch<mode>4_insn_rev,\n+\tcbranch<mode>4_insn_cf, cbranch<mode>4_insn_cf_rev,\n+\tcstore<mode>4_insn, cstore<mode>4_insn_cf for integer modes)\n+\tNew patterns.\n+\t(cbranch<mode>4_insn_68881, cbranch<mode>4_insn_rev_68881):\n+\t(cbranch<mode>4_insn_cf, cbranch<mode>4_insn_rev_cf,\n+\tcstore<mode>4_insn_68881, cstore<mode>4_insn_cf for FP):\n+\tNew patterns.\n+\t(cbranchsi4_btst_mem_insn, cbranchsi4_btst_reg_insn,\n+\tcbranchsi4_btst_mem_insn_1, cbranchsi4_btst_reg_insn_1):\n+\tLikewise.\n+\t(BTST): New define_mode_iterator.\n+\t(btst_predicate, btst_constraint, btst_range): New\n+\tdefine_mode_attrs.\n+\t(cbranch_bftst<mode>_insn, cstore_bftst<mode>_insn): New\n+\tpatterns.\n+\t(movsi_m68k_movsi_m68k2, movsi_cf, unnamed movstrict patterns,\n+\tunnamed movhi and movqi patterns, unnamed movsf, movdf and movxf\n+\tpatterns): Set attr \"flags_valid\".\n+\t(truncsiqi2, trunchiqi2, truncsihi2): Remove manual CC_STATUS\n+\tmanagement.  Set attr \"flags_valid\".\n+\t(extendsidi2, extendplussidi, unnamed float_extendsfdf pattern,\n+\textendsfdf2_cf, fix_truncdfsi2, fix_truncdfhi2, fix_truncdfqi2,\n+\taddi_sexthishl32, adddi_dilshr32, adddi_dilshr32_cf,\n+\taddi_dishl32, subdi_sexthishl32, subdi_dishl32, subdi3): Remove\n+\tmanual CC_STATUS management.\n+\t(addsi3_internal, addhi3, addqi3, subsi3, subhi3, subqi3,\n+\tunnamed strict_lowpart subhi and subqi patterns): Set attr\n+\t\"flags_valid\".\n+\t(unnamed strict_lowpart addhi3 and addqi3 patterns): Likewise.\n+\tRemove code to operate on address regs and assert the case\n+\tdoes not occur.\n+\t(unnamed mulsidi patterns, divmodhi4, udivmodhi4): Remove\n+\tmanual CC_STATUS_INIT.\n+\t(andsi3_internal, andhi3, andqi3, iorsi3_internal, iorhi3, iorqi3,\n+\txorsi3_internal, xorhi3, xorqi3, negsi2_internal,\n+\tnegsi2_5200, neghi2, negqi2, one_cmplsi2_internal, one_cmplhi2,\n+\tone_cmplqi2, unnamed strict_lowpart patterns\n+\tfor andhi, andqi, iorhi, iorqi, xorhi, xorqi, neghi, negqi,\n+\tone_cmplhi and one_cmplqi): Set attr \"flags_valid\".\n+\t(iorsi_zext_ashl16, iorsi_zext): Remove manual CC_STATUS_INIT.\n+\t(ashldi_sexthi, ashlsi_16, ashlsi_17_24): Remove manual\n+\tCC_STATUS_INIT.\n+\t(ashlsi3, ashlhi3, ashlqi3, ashrsi3, ashrhi3, ashrqi3, lshrsi3,\n+\tlshrhi3, shrqi3, rotlsi3, rotlhi3, rotlhi3_lowpart, rotlqi3,\n+\trotlqi3_lowpart, rotrsi3, rotrhi3, rotrhi_lowpart, rotrqi3,\n+\tunnamed strict_low_part patterns for HI and\n+\tQI versions): Set attr \"flags_valid\".\n+\t(bsetmemqi, bsetmemqi_ext, bsetdreg, bchgdreg, bclrdreg,\n+\tbclrmemqi, extzv_8_16_reg, extzv_bfextu_mem, insv_bfchg_mem,\n+\tinsv_bfclr_mem, insv_bfset_mem, extv_bfextu_reg,\n+\tinsv_bfclr_reg, insv_bfset_reg, dbne_hi, dbne_si, dbge_hi,\n+\tdbge_si, extendsfxf2, extenddfxf2, ): Remove manual cc_status management.\n+\t(various unnamed peepholes): Adjust compare/branch sequences\n+\tfor new cbranch patterns.\n+\t(dbcc peepholes): Likewise, and output the comparison here\n+\tas well.\n+\t* config/m68k/predicates.md (valid_dbcc_comparison_p): Delete.\n+\t(fp_src_operand): Allow constant zero.\n+\t(address_reg_operand): New predicate.\n+\n+\t* rtl.h (inequality_comparisons_p): Remove declaration.\n+\t* recog.h (next_insn_tests_no_inequality): Likewise.\n+\t* rtlanal.c (inequality_comparisons_p): Delete function.\n+\t* recog.c (next_insn_tests_no_inequality): Likewise.\n+\n 2019-11-25  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-slp.c (vect_detect_hybrid_slp_stmts): Add assertion."}, {"sha": "a88d90323476fcb37e3bf6b4b807cd05937be7b9", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c", "patch": "@@ -42,7 +42,23 @@ extern const char *output_iorsi3 (rtx *);\n extern const char *output_xorsi3 (rtx *);\n extern const char *output_call (rtx);\n extern const char *output_sibcall (rtx);\n-extern void output_dbcc_and_branch (rtx *);\n+extern void m68k_init_cc ();\n+extern void output_dbcc_and_branch (rtx *, rtx_code);\n+extern rtx_code m68k_output_compare_di (rtx, rtx, rtx, rtx, rtx_insn *, rtx_code);\n+extern rtx_code m68k_output_compare_si (rtx, rtx, rtx_code);\n+extern rtx_code m68k_output_compare_hi (rtx, rtx, rtx_code);\n+extern rtx_code m68k_output_compare_qi (rtx, rtx, rtx_code);\n+extern rtx_code m68k_output_compare_fp (rtx, rtx, rtx_code);\n+extern rtx_code m68k_output_btst (rtx, rtx, rtx_code, int);\n+extern rtx_code m68k_output_bftst (rtx, rtx, rtx, rtx_code);\n+extern rtx_code m68k_find_flags_value (rtx, rtx, rtx_code);\n+\n+extern const char *m68k_output_scc (rtx_code);\n+extern const char *m68k_output_scc_float (rtx_code);\n+extern const char *m68k_output_branch_integer (rtx_code);\n+extern const char *m68k_output_branch_integer_rev (rtx_code);\n+extern const char *m68k_output_branch_float (rtx_code);\n+extern const char *m68k_output_branch_float_rev (rtx_code);\n extern int floating_exact_log2 (rtx);\n extern bool strict_low_part_peephole_ok (machine_mode mode,\n \t\t\t\t\t rtx_insn *first_insn, rtx target);\n@@ -88,7 +104,6 @@ extern enum attr_op_mem m68k_sched_attr_op_mem (rtx_insn *);\n extern enum reg_class m68k_secondary_reload_class (enum reg_class,\n \t\t\t\t\t\t   machine_mode, rtx);\n extern enum reg_class m68k_preferred_reload_class (rtx, enum reg_class);\n-extern int flags_in_68881 (void);\n extern void m68k_expand_prologue (void);\n extern bool m68k_use_return_insn (void);\n extern void m68k_expand_epilogue (bool);"}, {"sha": "8d010ebe6e94c8f140503c6beb43280f540b45cc", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 696, "deletions": 193, "changes": 889, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n #define IN_TARGET_CODE 1\n \n #include \"config.h\"\n+#define INCLUDE_STRING\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n@@ -194,6 +195,7 @@ static bool m68k_hard_regno_mode_ok (unsigned int, machine_mode);\n static bool m68k_modes_tieable_p (machine_mode, machine_mode);\n static machine_mode m68k_promote_function_mode (const_tree, machine_mode,\n \t\t\t\t\t\tint *, const_tree, int);\n+static void m68k_asm_final_postscan_insn (FILE *, rtx_insn *insn, rtx [], int);\n \f\n /* Initialize the GCC target structure.  */\n \n@@ -355,6 +357,9 @@ static machine_mode m68k_promote_function_mode (const_tree, machine_mode,\n #undef  TARGET_HAVE_SPECULATION_SAFE_VALUE\n #define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed\n \n+#undef TARGET_ASM_FINAL_POSTSCAN_INSN\n+#define TARGET_ASM_FINAL_POSTSCAN_INSN m68k_asm_final_postscan_insn\n+\n static const struct attribute_spec m68k_attribute_table[] =\n {\n   /* { name, min_len, max_len, decl_req, type_req, fn_type_req,\n@@ -1356,40 +1361,6 @@ m68k_expand_epilogue (bool sibcall_p)\n     emit_jump_insn (ret_rtx);\n }\n \f\n-/* Return true if X is a valid comparison operator for the dbcc \n-   instruction.  \n-\n-   Note it rejects floating point comparison operators.\n-   (In the future we could use Fdbcc).\n-\n-   It also rejects some comparisons when CC_NO_OVERFLOW is set.  */\n-   \n-int\n-valid_dbcc_comparison_p_2 (rtx x, machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (x))\n-    {\n-      case EQ: case NE: case GTU: case LTU:\n-      case GEU: case LEU:\n-        return 1;\n-\n-      /* Reject some when CC_NO_OVERFLOW is set.  This may be over\n-         conservative */\n-      case GT: case LT: case GE: case LE:\n-        return ! (cc_prev_status.flags & CC_NO_OVERFLOW);\n-      default:\n-        return 0;\n-    }\n-}\n-\n-/* Return nonzero if flags are currently in the 68881 flag register.  */\n-int\n-flags_in_68881 (void)\n-{\n-  /* We could add support for these in the future */\n-  return cc_status.flags & CC_IN_68881;\n-}\n-\n /* Return true if PARALLEL contains register REGNO.  */\n static bool\n m68k_reg_present_p (const_rtx parallel, unsigned int regno)\n@@ -1580,18 +1551,186 @@ m68k_legitimize_address (rtx x, rtx oldx, machine_mode mode)\n \n   return x;\n }\n+\f\n+/* For eliding comparisons, we remember how the flags were set.\n+   FLAGS_COMPARE_OP0 and FLAGS_COMPARE_OP1 are remembered for a direct\n+   comparison, they take priority.  FLAGS_OPERAND1 and FLAGS_OPERAND2\n+   are used in more cases, they are a fallback for comparisons against\n+   zero after a move or arithmetic insn.\n+   FLAGS_VALID is set to FLAGS_VALID_NO if we should not use any of\n+   these values.  */\n+\n+static rtx flags_compare_op0, flags_compare_op1;\n+static rtx flags_operand1, flags_operand2;\n+static attr_flags_valid flags_valid = FLAGS_VALID_NO;\n+\n+/* Return a code other than UNKNOWN if we can elide a CODE comparison of\n+   OP0 with OP1.  */\n+\n+rtx_code\n+m68k_find_flags_value (rtx op0, rtx op1, rtx_code code)\n+{\n+  if (flags_compare_op0 != NULL_RTX)\n+    {\n+      if (rtx_equal_p (op0, flags_compare_op0)\n+\t  && rtx_equal_p (op1, flags_compare_op1))\n+\treturn code;\n+      if (rtx_equal_p (op0, flags_compare_op1)\n+\t  && rtx_equal_p (op1, flags_compare_op0))\n+\treturn swap_condition (code);\n+      return UNKNOWN;\n+    }\n+\n+  machine_mode mode = GET_MODE (op0);\n+  if (op1 != CONST0_RTX (mode))\n+    return UNKNOWN;\n+  /* Comparisons against 0 with these two should have been optimized out.  */\n+  gcc_assert (code != LTU && code != GEU);\n+  if (flags_valid == FLAGS_VALID_NOOV && (code == GT || code == LE))\n+    return UNKNOWN;\n+  if (rtx_equal_p (flags_operand1, op0) || rtx_equal_p (flags_operand2, op0))\n+    return (FLOAT_MODE_P (mode) ? code\n+\t    : code == GE ? PLUS : code == LT ? MINUS : code);\n+  /* See if we are testing whether the high part of a DImode value is\n+     positive or negative and we have the full value as a remembered\n+     operand.  */\n+  if (code != GE && code != LT)\n+    return UNKNOWN;\n+  if (mode == SImode\n+      && flags_operand1 != NULL_RTX && GET_MODE (flags_operand1) == DImode\n+      && REG_P (flags_operand1) && REG_P (op0)\n+      && hard_regno_nregs (REGNO (flags_operand1), DImode) == 2\n+      && REGNO (flags_operand1) == REGNO (op0))\n+    return code == GE ? PLUS : MINUS;\n+  if (mode == SImode\n+      && flags_operand2 != NULL_RTX && GET_MODE (flags_operand2) == DImode\n+      && REG_P (flags_operand2) && REG_P (op0)\n+      && hard_regno_nregs (REGNO (flags_operand2), DImode) == 2\n+      && REGNO (flags_operand2) == REGNO (op0))\n+    return code == GE ? PLUS : MINUS;\n+  return UNKNOWN;\n+}\n+\n+/* Called through CC_STATUS_INIT, which is invoked by final whenever a\n+   label is encountered.  */\n+\n+void\n+m68k_init_cc ()\n+{\n+  flags_compare_op0 = flags_compare_op1 = NULL_RTX;\n+  flags_operand1 = flags_operand2 = NULL_RTX;\n+  flags_valid = FLAGS_VALID_NO;\n+}\n+\n+/* Update flags for a move operation with OPERANDS.  Called for move\n+   operations where attr_flags_valid returns \"set\".  */\n+\n+static void\n+handle_flags_for_move (rtx *operands)\n+{\n+  flags_compare_op0 = flags_compare_op1 = NULL_RTX;\n+  if (!ADDRESS_REG_P (operands[0]))\n+    {\n+      flags_valid = FLAGS_VALID_MOVE;\n+      flags_operand1 = side_effects_p (operands[0]) ? NULL_RTX : operands[0];\n+      if (side_effects_p (operands[1])\n+\t  /* ??? For mem->mem moves, this can discard the source as a\n+\t     valid compare operand.  If you assume aligned moves, this\n+\t     is unnecessary, but in theory, we could have an unaligned\n+\t     move overwriting parts of its source.  */\n+\t  || modified_in_p (operands[1], current_output_insn))\n+\tflags_operand2 = NULL_RTX;\n+      else\n+\tflags_operand2 = operands[1];\n+      return;\n+    }\n+  if (flags_operand1 != NULL_RTX\n+      && modified_in_p (flags_operand1, current_output_insn))\n+    flags_operand1 = NULL_RTX;\n+  if (flags_operand2 != NULL_RTX\n+      && modified_in_p (flags_operand2, current_output_insn))\n+    flags_operand2 = NULL_RTX;\n+}\n+\n+/* Process INSN to remember flag operands if possible.  */\n+\n+static void\n+m68k_asm_final_postscan_insn (FILE *, rtx_insn *insn, rtx [], int)\n+{\n+  enum attr_flags_valid v = get_attr_flags_valid (insn);\n+  if (v == FLAGS_VALID_SET)\n+    return;\n+  /* Comparisons use FLAGS_VALID_SET, so we can be sure we need to clear these\n+     now.  */\n+  flags_compare_op0 = flags_compare_op1 = NULL_RTX;\n+\n+  if (v == FLAGS_VALID_NO)\n+    {\n+      flags_operand1 = flags_operand2 = NULL_RTX;\n+      return;\n+    }\n+  else if (v == FLAGS_VALID_UNCHANGED)\n+    {\n+      if (flags_operand1 != NULL_RTX && modified_in_p (flags_operand1, insn))\n+\tflags_operand1 = NULL_RTX;\n+      if (flags_operand2 != NULL_RTX && modified_in_p (flags_operand2, insn))\n+\tflags_operand2 = NULL_RTX;\n+      return;\n+    }\n+\n+  flags_valid = v;\n+  rtx set = single_set (insn);\n+  rtx dest = SET_DEST (set);\n+  rtx src = SET_SRC (set);\n+  if (side_effects_p (dest))\n+      dest = NULL_RTX;\n+\n+  switch (v)\n+    {\n+    case FLAGS_VALID_YES:\n+    case FLAGS_VALID_NOOV:\n+      flags_operand1 = dest;\n+      flags_operand2 = NULL_RTX;\n+      break;\n+    case FLAGS_VALID_MOVE:\n+      /* fmoves to memory or data registers do not set the condition\n+\t codes.  Normal moves _do_ set the condition codes, but not in\n+\t a way that is appropriate for comparison with 0, because -0.0\n+\t would be treated as a negative nonzero number.  Note that it\n+\t isn't appropriate to conditionalize this restriction on\n+\t HONOR_SIGNED_ZEROS because that macro merely indicates whether\n+\t we care about the difference between -0.0 and +0.0.  */\n+      if (dest != NULL_RTX\n+\t  && !FP_REG_P (dest)\n+\t  && (FP_REG_P (src)\n+\t      || GET_CODE (src) == FIX\n+\t      || FLOAT_MODE_P (GET_MODE (dest))))\n+\tflags_operand1 = flags_operand2 = NULL_RTX;\n+      else\n+\t{\n+\t  flags_operand1 = dest;\n+\t  if (GET_MODE (src) != VOIDmode && !side_effects_p (src)\n+\t      && !modified_in_p (src, insn))\n+\t    flags_operand2 = src;\n+\t  else\n+\t    flags_operand2 = NULL_RTX;\n+\t}\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return;\n+}\n \n- \n /* Output a dbCC; jCC sequence.  Note we do not handle the \n-   floating point version of this sequence (Fdbcc).  We also\n-   do not handle alternative conditions when CC_NO_OVERFLOW is\n-   set.  It is assumed that valid_dbcc_comparison_p and flags_in_68881 will\n-   kick those out before we get here.  */\n+   floating point version of this sequence (Fdbcc).\n+   OPERANDS are as in the two peepholes.  CODE is the code\n+   returned by m68k_output_branch_<mode>.  */\n \n void\n-output_dbcc_and_branch (rtx *operands)\n+output_dbcc_and_branch (rtx *operands, rtx_code code)\n {\n-  switch (GET_CODE (operands[3]))\n+  switch (code)\n     {\n       case EQ:\n \toutput_asm_insn (\"dbeq %0,%l1\\n\\tjeq %l2\", operands);\n@@ -1633,6 +1772,14 @@ output_dbcc_and_branch (rtx *operands)\n \toutput_asm_insn (\"dbls %0,%l1\\n\\tjls %l2\", operands);\n \tbreak;\n \n+      case PLUS:\n+\toutput_asm_insn (\"dbpl %0,%l1\\n\\tjle %l2\", operands);\n+\tbreak;\n+\n+      case MINUS:\n+\toutput_asm_insn (\"dbmi %0,%l1\\n\\tjle %l2\", operands);\n+\tbreak;\n+\n       default:\n \tgcc_unreachable ();\n     }\n@@ -1790,11 +1937,12 @@ output_scc_di (rtx op, rtx operand1, rtx operand2, rtx dest)\n   return \"\";\n }\n \n-const char *\n-output_btst (rtx *operands, rtx countop, rtx dataop, rtx_insn *insn, int signpos)\n+rtx_code\n+m68k_output_btst (rtx countop, rtx dataop, rtx_code code, int signpos)\n {\n-  operands[0] = countop;\n-  operands[1] = dataop;\n+  rtx ops[2];\n+  ops[0] = countop;\n+  ops[1] = dataop;\n \n   if (GET_CODE (countop) == CONST_INT)\n     {\n@@ -1805,40 +1953,41 @@ output_btst (rtx *operands, rtx countop, rtx dataop, rtx_insn *insn, int signpos\n \t{\n \t  int offset = (count & ~signpos) / 8;\n \t  count = count & signpos;\n-\t  operands[1] = dataop = adjust_address (dataop, QImode, offset);\n+\t  ops[1] = dataop = adjust_address (dataop, QImode, offset);\n+\t}\n+\n+      if (code == EQ || code == NE)\n+\t{\n+\t  if (count == 31)\n+\t    {\n+\t      output_asm_insn (\"tst%.l %1\", ops);\n+\t      return code == EQ ? PLUS : MINUS;\n+\t    }\n+\t  if (count == 15)\n+\t    {\n+\t      output_asm_insn (\"tst%.w %1\", ops);\n+\t      return code == EQ ? PLUS : MINUS;\n+\t    }\n+\t  if (count == 7)\n+\t    {\n+\t      output_asm_insn (\"tst%.b %1\", ops);\n+\t      return code == EQ ? PLUS : MINUS;\n+\t    }\n \t}\n-      if (count == signpos)\n-\tcc_status.flags = CC_NOT_POSITIVE | CC_Z_IN_NOT_N;\n-      else\n-\tcc_status.flags = CC_NOT_NEGATIVE | CC_Z_IN_NOT_N;\n-\n-      /* These three statements used to use next_insns_test_no...\n-\t but it appears that this should do the same job.  */\n-      if (count == 31\n-\t  && next_insn_tests_no_inequality (insn))\n-\treturn \"tst%.l %1\";\n-      if (count == 15\n-\t  && next_insn_tests_no_inequality (insn))\n-\treturn \"tst%.w %1\";\n-      if (count == 7\n-\t  && next_insn_tests_no_inequality (insn))\n-\treturn \"tst%.b %1\";\n       /* Try to use `movew to ccr' followed by the appropriate branch insn.\n          On some m68k variants unfortunately that's slower than btst.\n          On 68000 and higher, that should also work for all HImode operands. */\n       if (TUNE_CPU32 || TARGET_COLDFIRE || optimize_size)\n \t{\n-\t  if (count == 3 && DATA_REG_P (operands[1])\n-\t      && next_insn_tests_no_inequality (insn))\n+\t  if (count == 3 && DATA_REG_P (ops[1]) && (code == EQ || code == NE))\n \t    {\n-\t    cc_status.flags = CC_NOT_NEGATIVE | CC_Z_IN_NOT_N | CC_NO_OVERFLOW;\n-\t    return \"move%.w %1,%%ccr\";\n+\t      output_asm_insn (\"move%.w %1,%%ccr\", ops);\n+\t      return code == EQ ? PLUS : MINUS;\n \t    }\n-\t  if (count == 2 && DATA_REG_P (operands[1])\n-\t      && next_insn_tests_no_inequality (insn))\n+\t  if (count == 2 && DATA_REG_P (ops[1]) && (code == EQ || code == NE))\n \t    {\n-\t    cc_status.flags = CC_NOT_NEGATIVE | CC_INVERTED | CC_NO_OVERFLOW;\n-\t    return \"move%.w %1,%%ccr\";\n+\t      output_asm_insn (\"move%.w %1,%%ccr\", ops);\n+\t      return code == EQ ? NE : EQ;\n \t    }\n \t  /* count == 1 followed by bvc/bvs and\n \t     count == 0 followed by bcc/bcs are also possible, but need\n@@ -1847,7 +1996,28 @@ output_btst (rtx *operands, rtx countop, rtx dataop, rtx_insn *insn, int signpos\n \n       cc_status.flags = CC_NOT_NEGATIVE;\n     }\n-  return \"btst %0,%1\";\n+  output_asm_insn (\"btst %0,%1\", ops);\n+  return code;\n+}\n+\n+/* Output a bftst instruction for a zero_extract with ZXOP0, ZXOP1 and ZXOP2\n+   operands.  CODE is the code of the comparison, and we return the code to\n+   be actually used in the jump.  */\n+\n+rtx_code\n+m68k_output_bftst (rtx zxop0, rtx zxop1, rtx zxop2, rtx_code code)\n+{\n+  if (zxop1 == const1_rtx && GET_CODE (zxop2) == CONST_INT)\n+    {\n+      int width = GET_CODE (zxop0) == REG ? 31 : 7;\n+      /* Pass 1000 as SIGNPOS argument so that btst will\n+\t not think we are testing the sign bit for an `and'\n+\t and assume that nonzero implies a negative result.  */\n+      return m68k_output_btst (GEN_INT (width - INTVAL (zxop2)), zxop0, code, 1000);\n+    }\n+  rtx ops[3] = { zxop0, zxop1, zxop2 };\n+  output_asm_insn (\"bftst %0{%b2:%b1}\", ops);\n+  return code;\n }\n \f\n /* Return true if X is a legitimate base register.  STRICT_P says\n@@ -2839,7 +3009,8 @@ m68k_rtx_costs (rtx x, machine_mode mode, int outer_code,\n     case CONST_DOUBLE:\n       /* Make 0.0 cheaper than other floating constants to\n          encourage creating tstsf and tstdf insns.  */\n-      if (outer_code == COMPARE\n+      if ((GET_RTX_CLASS (outer_code) == RTX_COMPARE\n+\t   || GET_RTX_CLASS (outer_code) == RTX_COMM_COMPARE)\n           && (x == CONST0_RTX (SFmode) || x == CONST0_RTX (DFmode)))\n \t*total = 4;\n       else\n@@ -2953,7 +3124,8 @@ m68k_rtx_costs (rtx x, machine_mode mode, int outer_code,\n       return true;\n \n     case ZERO_EXTRACT:\n-      if (outer_code == COMPARE)\n+      if (GET_RTX_CLASS (outer_code) == RTX_COMPARE\n+\t  || GET_RTX_CLASS (outer_code) == RTX_COMM_COMPARE)\n         *total = 0;\n       return false;\n \n@@ -3056,6 +3228,8 @@ output_move_simode_const (rtx *operands)\n const char *\n output_move_simode (rtx *operands)\n {\n+  handle_flags_for_move (operands);\n+\n   if (GET_CODE (operands[1]) == CONST_INT)\n     return output_move_simode_const (operands);\n   else if ((GET_CODE (operands[1]) == SYMBOL_REF\n@@ -3072,7 +3246,7 @@ output_move_simode (rtx *operands)\n const char *\n output_move_himode (rtx *operands)\n {\n- if (GET_CODE (operands[1]) == CONST_INT)\n+  if (GET_CODE (operands[1]) == CONST_INT)\n     {\n       if (operands[1] == const0_rtx\n \t  && (DATA_REG_P (operands[0])\n@@ -3094,16 +3268,18 @@ output_move_himode (rtx *operands)\n \treturn \"move%.w %1,%0\";\n     }\n   else if (CONSTANT_P (operands[1]))\n-    return \"move%.l %1,%0\";\n+    gcc_unreachable ();\n   return \"move%.w %1,%0\";\n }\n \n const char *\n output_move_qimode (rtx *operands)\n {\n+  handle_flags_for_move (operands);\n+\n   /* 68k family always modifies the stack pointer by at least 2, even for\n      byte pushes.  The 5200 (ColdFire) does not do this.  */\n-  \n+\n   /* This case is generated by pushqi1 pattern now.  */\n   gcc_assert (!(GET_CODE (operands[0]) == MEM\n \t\t&& GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n@@ -3134,11 +3310,15 @@ output_move_qimode (rtx *operands)\n   if (operands[1] == const0_rtx && ADDRESS_REG_P (operands[0]))\n     return \"sub%.l %0,%0\";\n   if (GET_CODE (operands[1]) != CONST_INT && CONSTANT_P (operands[1]))\n-    return \"move%.l %1,%0\";\n+    gcc_unreachable ();\n   /* 68k family (including the 5200 ColdFire) does not support byte moves to\n      from address registers.  */\n   if (ADDRESS_REG_P (operands[0]) || ADDRESS_REG_P (operands[1]))\n-    return \"move%.w %1,%0\";\n+    {\n+      if (ADDRESS_REG_P (operands[1]))\n+\tCC_STATUS_INIT;\n+      return \"move%.w %1,%0\";\n+    }\n   return \"move%.b %1,%0\";\n }\n \n@@ -4136,125 +4316,440 @@ output_addsi3 (rtx *operands)\n     }\n   return \"add%.l %2,%0\";\n }\n-\f\n-/* Store in cc_status the expressions that the condition codes will\n-   describe after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-/* On the 68000, all the insns to store in an address register fail to\n-   set the cc's.  However, in some cases these instructions can make it\n-   possibly invalid to use the saved cc's.  In those cases we clear out\n-   some or all of the saved cc's so they won't be used.  */\n \n-void\n-notice_update_cc (rtx exp, rtx insn)\n+/* Emit a comparison between OP0 and OP1.  Return true iff the comparison\n+   was reversed.  SC1 is an SImode scratch reg, and SC2 a DImode scratch reg,\n+   as needed.  CODE is the code of the comparison, we return it unchanged or\n+   swapped, as necessary.  */\n+rtx_code\n+m68k_output_compare_di (rtx op0, rtx op1, rtx sc1, rtx sc2, rtx_insn *insn,\n+\t\t\trtx_code code)\n {\n-  if (GET_CODE (exp) == SET)\n+  rtx ops[4];\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  ops[2] = sc1;\n+  ops[3] = sc2;\n+  if (op1 == const0_rtx)\n     {\n-      if (GET_CODE (SET_SRC (exp)) == CALL)\n-\tCC_STATUS_INIT; \n-      else if (ADDRESS_REG_P (SET_DEST (exp)))\n+      if (!REG_P (op0) || ADDRESS_REG_P (op0))\n \t{\n-\t  if (cc_status.value1 && modified_in_p (cc_status.value1, insn))\n-\t    cc_status.value1 = 0;\n-\t  if (cc_status.value2 && modified_in_p (cc_status.value2, insn))\n-\t    cc_status.value2 = 0; \n+\t  rtx xoperands[2];\n+\n+\t  xoperands[0] = sc2;\n+\t  xoperands[1] = op0;\n+\t  output_move_double (xoperands);\n+\t  output_asm_insn (\"neg%.l %R0\\n\\tnegx%.l %0\", xoperands);\n+\t  return swap_condition (code);\n \t}\n-      /* fmoves to memory or data registers do not set the condition\n-\t codes.  Normal moves _do_ set the condition codes, but not in\n-\t a way that is appropriate for comparison with 0, because -0.0\n-\t would be treated as a negative nonzero number.  Note that it\n-\t isn't appropriate to conditionalize this restriction on\n-\t HONOR_SIGNED_ZEROS because that macro merely indicates whether\n-\t we care about the difference between -0.0 and +0.0.  */\n-      else if (!FP_REG_P (SET_DEST (exp))\n-\t       && SET_DEST (exp) != cc0_rtx\n-\t       && (FP_REG_P (SET_SRC (exp))\n-\t\t   || GET_CODE (SET_SRC (exp)) == FIX\n-\t\t   || FLOAT_MODE_P (GET_MODE (SET_DEST (exp)))))\n-\tCC_STATUS_INIT; \n-      /* A pair of move insns doesn't produce a useful overall cc.  */\n-      else if (!FP_REG_P (SET_DEST (exp))\n-\t       && !FP_REG_P (SET_SRC (exp))\n-\t       && GET_MODE_SIZE (GET_MODE (SET_SRC (exp))) > 4\n-\t       && (GET_CODE (SET_SRC (exp)) == REG\n-\t\t   || GET_CODE (SET_SRC (exp)) == MEM\n-\t\t   || GET_CODE (SET_SRC (exp)) == CONST_DOUBLE))\n-\tCC_STATUS_INIT; \n-      else if (SET_DEST (exp) != pc_rtx)\n+      if (find_reg_note (insn, REG_DEAD, op0))\n \t{\n-\t  cc_status.flags = 0;\n-\t  cc_status.value1 = SET_DEST (exp);\n-\t  cc_status.value2 = SET_SRC (exp);\n+\t  output_asm_insn (\"neg%.l %R0\\n\\tnegx%.l %0\", ops);\n+\t  return swap_condition (code);\n \t}\n-    }\n-  else if (GET_CODE (exp) == PARALLEL\n-\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n-    {\n-      rtx dest = SET_DEST (XVECEXP (exp, 0, 0));\n-      rtx src  = SET_SRC  (XVECEXP (exp, 0, 0));\n-\n-      if (ADDRESS_REG_P (dest))\n-\tCC_STATUS_INIT;\n-      else if (dest != pc_rtx)\n+      else\n \t{\n-\t  cc_status.flags = 0;\n-\t  cc_status.value1 = dest;\n-\t  cc_status.value2 = src;\n+\t  /* 'sub' clears %1, and also clears the X cc bit.\n+\t     'tst' sets the Z cc bit according to the low part of the DImode\n+\t     operand.\n+\t     'subx %1' (i.e. subx #0) acts as a (non-existent) tstx on the high\n+\t     part.  */\n+\t  output_asm_insn (\"sub%.l %2,%2\\n\\ttst%.l %R0\\n\\tsubx%.l %2,%0\", ops);\n+\t  return code;\n \t}\n     }\n+\n+  if (rtx_equal_p (sc2, op0))\n+    {\n+      output_asm_insn (\"sub%.l %R1,%R3\\n\\tsubx%.l %1,%3\", ops);\n+      return code;\n+    }\n   else\n+    {\n+      output_asm_insn (\"sub%.l %R0,%R3\\n\\tsubx%.l %0,%3\", ops);\n+      return swap_condition (code);\n+    }\n+}\n+\n+static void\n+remember_compare_flags (rtx op0, rtx op1)\n+{\n+  if (side_effects_p (op0) || side_effects_p (op1))\n     CC_STATUS_INIT;\n-  if (cc_status.value2 != 0\n-      && ADDRESS_REG_P (cc_status.value2)\n-      && GET_MODE (cc_status.value2) == QImode)\n-    CC_STATUS_INIT;\n-  if (cc_status.value2 != 0)\n-    switch (GET_CODE (cc_status.value2))\n-      {\n-      case ASHIFT: case ASHIFTRT: case LSHIFTRT:\n-      case ROTATE: case ROTATERT:\n-\t/* These instructions always clear the overflow bit, and set\n-\t   the carry to the bit shifted out.  */\n-\tcc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;\n-\tbreak;\n+  else\n+    {\n+      flags_compare_op0 = op0;\n+      flags_compare_op1 = op1;\n+      flags_operand1 = flags_operand2 = NULL_RTX;\n+      flags_valid = FLAGS_VALID_SET;\n+    }\n+}\n \n-      case PLUS: case MINUS: case MULT:\n-      case DIV: case UDIV: case MOD: case UMOD: case NEG:\n-\tif (GET_MODE (cc_status.value2) != VOIDmode)\n-\t  cc_status.flags |= CC_NO_OVERFLOW;\n-\tbreak;\n-      case ZERO_EXTEND:\n-\t/* (SET r1 (ZERO_EXTEND r2)) on this machine\n-\t   ends with a move insn moving r2 in r2's mode.\n-\t   Thus, the cc's are set for r2.\n-\t   This can set N bit spuriously.  */\n-\tcc_status.flags |= CC_NOT_NEGATIVE; \n+/* Emit a comparison between OP0 and OP1.  CODE is the code of the\n+   comparison.  It is returned, potentially modified if necessary.  */\n+rtx_code\n+m68k_output_compare_si (rtx op0, rtx op1, rtx_code code)\n+{\n+  rtx_code tmp = m68k_find_flags_value (op0, op1, code);\n+  if (tmp != UNKNOWN)\n+    return tmp;\n \n-      default:\n-\tbreak;\n-      }\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\n-      && cc_status.value2\n-      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n-    cc_status.value2 = 0;\n-  /* Check for PRE_DEC in dest modifying a register used in src.  */\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\n-      && GET_CODE (XEXP (cc_status.value1, 0)) == PRE_DEC\n-      && cc_status.value2\n-      && reg_overlap_mentioned_p (XEXP (XEXP (cc_status.value1, 0), 0),\n-\t\t\t\t  cc_status.value2))\n-    cc_status.value2 = 0;\n-  if (((cc_status.value1 && FP_REG_P (cc_status.value1))\n-       || (cc_status.value2 && FP_REG_P (cc_status.value2))))\n-    cc_status.flags = CC_IN_68881;\n-  if (cc_status.value2 && GET_CODE (cc_status.value2) == COMPARE\n-      && GET_MODE_CLASS (GET_MODE (XEXP (cc_status.value2, 0))) == MODE_FLOAT)\n-    {\n-      cc_status.flags = CC_IN_68881;\n-      if (!FP_REG_P (XEXP (cc_status.value2, 0))\n-\t  && FP_REG_P (XEXP (cc_status.value2, 1)))\n-\tcc_status.flags |= CC_REVERSED;\n+  remember_compare_flags (op0, op1);\n+\n+  rtx ops[2];\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  if (op1 == const0_rtx && (TARGET_68020 || TARGET_COLDFIRE || !ADDRESS_REG_P (op0)))\n+    output_asm_insn (\"tst%.l %0\", ops);\n+  else if (GET_CODE (op0) == MEM && GET_CODE (op1) == MEM)\n+    output_asm_insn (\"cmpm%.l %1,%0\", ops);\n+  else if (REG_P (op1)\n+      || (!REG_P (op0) && GET_CODE (op0) != MEM))\n+    {\n+      output_asm_insn (\"cmp%.l %d0,%d1\", ops);\n+      std::swap (flags_compare_op0, flags_compare_op1);\n+      return swap_condition (code);\n+    }\n+  else if (!TARGET_COLDFIRE\n+\t   && ADDRESS_REG_P (op0)\n+\t   && GET_CODE (op1) == CONST_INT\n+\t   && INTVAL (op1) < 0x8000\n+\t   && INTVAL (op1) >= -0x8000)\n+    output_asm_insn (\"cmp%.w %1,%0\", ops);\n+  else\n+    output_asm_insn (\"cmp%.l %d1,%d0\", ops);\n+  return code;\n+}\n+\n+/* Emit a comparison between OP0 and OP1.  CODE is the code of the\n+   comparison.  It is returned, potentially modified if necessary.  */\n+rtx_code\n+m68k_output_compare_hi (rtx op0, rtx op1, rtx_code code)\n+{\n+  rtx_code tmp = m68k_find_flags_value (op0, op1, code);\n+  if (tmp != UNKNOWN)\n+    return tmp;\n+\n+  remember_compare_flags (op0, op1);\n+\n+  rtx ops[2];\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  if (op1 == const0_rtx)\n+    output_asm_insn (\"tst%.w %d0\", ops);\n+  else if (GET_CODE (op0) == MEM && GET_CODE (op1) == MEM)\n+    output_asm_insn (\"cmpm%.w %1,%0\", ops);\n+  else if ((REG_P (op1) && !ADDRESS_REG_P (op1))\n+\t   || (!REG_P (op0) && GET_CODE (op0) != MEM))\n+    {\n+      output_asm_insn (\"cmp%.w %d0,%d1\", ops);\n+      std::swap (flags_compare_op0, flags_compare_op1);\n+      return swap_condition (code);\n+    }\n+  else\n+    output_asm_insn (\"cmp%.w %d1,%d0\", ops);\n+  return code;\n+}\n+\n+/* Emit a comparison between OP0 and OP1.  CODE is the code of the\n+   comparison.  It is returned, potentially modified if necessary.  */\n+rtx_code\n+m68k_output_compare_qi (rtx op0, rtx op1, rtx_code code)\n+{\n+  rtx_code tmp = m68k_find_flags_value (op0, op1, code);\n+  if (tmp != UNKNOWN)\n+    return tmp;\n+\n+  remember_compare_flags (op0, op1);\n+\n+  rtx ops[2];\n+  ops[0] = op0;\n+  ops[1] = op1;\n+  if (op1 == const0_rtx)\n+    output_asm_insn (\"tst%.b %d0\", ops);\n+  else if (GET_CODE (op0) == MEM && GET_CODE (op1) == MEM)\n+    output_asm_insn (\"cmpm%.b %1,%0\", ops);\n+  else if (REG_P (op1) || (!REG_P (op0) && GET_CODE (op0) != MEM))\n+    {\n+      output_asm_insn (\"cmp%.b %d0,%d1\", ops);\n+      std::swap (flags_compare_op0, flags_compare_op1);\n+      return swap_condition (code);\n+    }\n+  else\n+    output_asm_insn (\"cmp%.b %d1,%d0\", ops);\n+  return code;\n+}\n+\n+/* Emit a comparison between OP0 and OP1.  CODE is the code of the\n+   comparison.  It is returned, potentially modified if necessary.  */\n+rtx_code\n+m68k_output_compare_fp (rtx op0, rtx op1, rtx_code code)\n+{\n+  rtx_code tmp = m68k_find_flags_value (op0, op1, code);\n+  if (tmp != UNKNOWN)\n+    return tmp;\n+\n+  rtx ops[2];\n+  ops[0] = op0;\n+  ops[1] = op1;\n+\n+  remember_compare_flags (op0, op1);\n+\n+  machine_mode mode = GET_MODE (op0);\n+  std::string prec = mode == SFmode ? \"s\" : mode == DFmode ? \"d\" : \"x\";\n+\n+  if (op1 == CONST0_RTX (GET_MODE (op0)))\n+    {\n+      if (FP_REG_P (op0))\n+\toutput_asm_insn (\"ftst%.x %0\", ops);\n+      else\n+\toutput_asm_insn ((\"ftst%.\" + prec + \" %0\").c_str (), ops);\n+      return code;\n+    }\n+\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      output_asm_insn (\"fcmp%.x %1,%0\", ops);\n+      break;\n+    case 1:\n+      output_asm_insn ((\"fcmp%.\" + prec + \" %f1,%0\").c_str (), ops);\n+      break;\n+    case 2:\n+      output_asm_insn ((\"fcmp%.\" + prec + \" %0,%f1\").c_str (), ops);\n+      std::swap (flags_compare_op0, flags_compare_op1);\n+      return swap_condition (code);\n+    case 3:\n+      /* This is the ftst case, handled earlier.  */\n+      gcc_unreachable ();\n+    }\n+  return code;\n+}\n+\n+/* Return an output template for a branch with CODE.  */\n+const char *\n+m68k_output_branch_integer (rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      return \"jeq %l3\";\n+    case NE:\n+      return \"jne %l3\";\n+    case GT:\n+      return \"jgt %l3\";\n+    case GTU:\n+      return \"jhi %l3\";\n+    case LT:\n+      return \"jlt %l3\";\n+    case LTU:\n+      return \"jcs %l3\";\n+    case GE:\n+      return \"jge %l3\";\n+    case GEU:\n+      return \"jcc %l3\";\n+    case LE:\n+      return \"jle %l3\";\n+    case LEU:\n+      return \"jls %l3\";\n+    case PLUS:\n+      return \"jpl %l3\";\n+    case MINUS:\n+      return \"jmi %l3\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return an output template for a reversed branch with CODE.  */\n+const char *\n+m68k_output_branch_integer_rev (rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      return \"jne %l3\";\n+    case NE:\n+      return \"jeq %l3\";\n+    case GT:\n+      return \"jle %l3\";\n+    case GTU:\n+      return \"jls %l3\";\n+    case LT:\n+      return \"jge %l3\";\n+    case LTU:\n+      return \"jcc %l3\";\n+    case GE:\n+      return \"jlt %l3\";\n+    case GEU:\n+      return \"jcs %l3\";\n+    case LE:\n+      return \"jgt %l3\";\n+    case LEU:\n+      return \"jhi %l3\";\n+    case PLUS:\n+      return \"jmi %l3\";\n+    case MINUS:\n+      return \"jpl %l3\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return an output template for a scc instruction with CODE.  */\n+const char *\n+m68k_output_scc (rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      return \"seq %0\";\n+    case NE:\n+      return \"sne %0\";\n+    case GT:\n+      return \"sgt %0\";\n+    case GTU:\n+      return \"shi %0\";\n+    case LT:\n+      return \"slt %0\";\n+    case LTU:\n+      return \"scs %0\";\n+    case GE:\n+      return \"sge %0\";\n+    case GEU:\n+      return \"scc %0\";\n+    case LE:\n+      return \"sle %0\";\n+    case LEU:\n+      return \"sls %0\";\n+    case PLUS:\n+      return \"spl %0\";\n+    case MINUS:\n+      return \"smi %0\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return an output template for a floating point branch\n+   instruction with CODE.  */\n+const char *\n+m68k_output_branch_float (rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      return \"fjeq %l3\";\n+    case NE:\n+      return \"fjne %l3\";\n+    case GT:\n+      return \"fjgt %l3\";\n+    case LT:\n+      return \"fjlt %l3\";\n+    case GE:\n+      return \"fjge %l3\";\n+    case LE:\n+      return \"fjle %l3\";\n+    case ORDERED:\n+      return \"fjor %l3\";\n+    case UNORDERED:\n+      return \"fjun %l3\";\n+    case UNEQ:\n+      return \"fjueq %l3\";\n+    case UNGE:\n+      return \"fjuge %l3\";\n+    case UNGT:\n+      return \"fjugt %l3\";\n+    case UNLE:\n+      return \"fjule %l3\";\n+    case UNLT:\n+      return \"fjult %l3\";\n+    case LTGT:\n+      return \"fjogl %l3\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return an output template for a reversed floating point branch\n+   instruction with CODE.  */\n+const char *\n+m68k_output_branch_float_rev (rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      return \"fjne %l3\";\n+    case NE:\n+      return \"fjeq %l3\";\n+    case GT:\n+      return \"fjngt %l3\";\n+    case LT:\n+      return \"fjnlt %l3\";\n+    case GE:\n+      return \"fjnge %l3\";\n+    case LE:\n+      return \"fjnle %l3\";\n+    case ORDERED:\n+      return \"fjun %l3\";\n+    case UNORDERED:\n+      return \"fjor %l3\";\n+    case UNEQ:\n+      return \"fjogl %l3\";\n+    case UNGE:\n+      return \"fjolt %l3\";\n+    case UNGT:\n+      return \"fjole %l3\";\n+    case UNLE:\n+      return \"fjogt %l3\";\n+    case UNLT:\n+      return \"fjoge %l3\";\n+    case LTGT:\n+      return \"fjueq %l3\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return an output template for a floating point scc\n+   instruction with CODE.  */\n+const char *\n+m68k_output_scc_float (rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      return \"fseq %0\";\n+    case NE:\n+      return \"fsne %0\";\n+    case GT:\n+      return \"fsgt %0\";\n+    case GTU:\n+      return \"fshi %0\";\n+    case LT:\n+      return \"fslt %0\";\n+    case GE:\n+      return \"fsge %0\";\n+    case LE:\n+      return \"fsle %0\";\n+    case ORDERED:\n+      return \"fsor %0\";\n+    case UNORDERED:\n+      return \"fsun %0\";\n+    case UNEQ:\n+      return \"fsueq %0\";\n+    case UNGE:\n+      return \"fsuge %0\";\n+    case UNGT:\n+      return \"fsugt %0\";\n+    case UNLE:\n+      return \"fsule %0\";\n+    case UNLT:\n+      return \"fsult %0\";\n+    case LTGT:\n+      return \"fsogl %0\";\n+    default:\n+      gcc_unreachable ();\n     }\n }\n \f\n@@ -4932,6 +5427,7 @@ const char *\n output_andsi3 (rtx *operands)\n {\n   int logval;\n+  CC_STATUS_INIT;\n   if (GET_CODE (operands[2]) == CONST_INT\n       && (INTVAL (operands[2]) | 0xffff) == -1\n       && (DATA_REG_P (operands[0])\n@@ -4941,8 +5437,6 @@ output_andsi3 (rtx *operands)\n       if (GET_CODE (operands[0]) != REG)\n         operands[0] = adjust_address (operands[0], HImode, 2);\n       operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n       if (operands[2] == const0_rtx)\n         return \"clr%.w %0\";\n       return \"and%.w %2,%0\";\n@@ -4959,17 +5453,21 @@ output_andsi3 (rtx *operands)\n \t  operands[0] = adjust_address (operands[0], SImode, 3 - (logval / 8));\n \t  operands[1] = GEN_INT (logval % 8);\n         }\n-      /* This does not set condition codes in a standard way.  */\n-      CC_STATUS_INIT;\n       return \"bclr %1,%0\";\n     }\n+  /* Only a standard logical operation on the whole word sets the\n+     condition codes in a way we can use.  */\n+  if (!side_effects_p (operands[0]))\n+    flags_operand1 = operands[0];\n+  flags_valid = FLAGS_VALID_YES;\n   return \"and%.l %2,%0\";\n }\n \n const char *\n output_iorsi3 (rtx *operands)\n {\n   register int logval;\n+  CC_STATUS_INIT;\n   if (GET_CODE (operands[2]) == CONST_INT\n       && INTVAL (operands[2]) >> 16 == 0\n       && (DATA_REG_P (operands[0])\n@@ -4978,8 +5476,6 @@ output_iorsi3 (rtx *operands)\n     {\n       if (GET_CODE (operands[0]) != REG)\n         operands[0] = adjust_address (operands[0], HImode, 2);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n       if (INTVAL (operands[2]) == 0xffff)\n \treturn \"mov%.w %2,%0\";\n       return \"or%.w %2,%0\";\n@@ -4996,25 +5492,28 @@ output_iorsi3 (rtx *operands)\n \t  operands[0] = adjust_address (operands[0], SImode, 3 - (logval / 8));\n \t  operands[1] = GEN_INT (logval % 8);\n \t}\n-      CC_STATUS_INIT;\n       return \"bset %1,%0\";\n     }\n+  /* Only a standard logical operation on the whole word sets the\n+     condition codes in a way we can use.  */\n+  if (!side_effects_p (operands[0]))\n+    flags_operand1 = operands[0];\n+  flags_valid = FLAGS_VALID_YES;\n   return \"or%.l %2,%0\";\n }\n \n const char *\n output_xorsi3 (rtx *operands)\n {\n   register int logval;\n+  CC_STATUS_INIT;\n   if (GET_CODE (operands[2]) == CONST_INT\n       && INTVAL (operands[2]) >> 16 == 0\n       && (offsettable_memref_p (operands[0]) || DATA_REG_P (operands[0]))\n       && !TARGET_COLDFIRE)\n     {\n       if (! DATA_REG_P (operands[0]))\n \toperands[0] = adjust_address (operands[0], HImode, 2);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n       if (INTVAL (operands[2]) == 0xffff)\n \treturn \"not%.w %0\";\n       return \"eor%.w %2,%0\";\n@@ -5031,9 +5530,13 @@ output_xorsi3 (rtx *operands)\n \t  operands[0] = adjust_address (operands[0], SImode, 3 - (logval / 8));\n \t  operands[1] = GEN_INT (logval % 8);\n \t}\n-      CC_STATUS_INIT;\n       return \"bchg %1,%0\";\n     }\n+  /* Only a standard logical operation on the whole word sets the\n+     condition codes in a way we can use.  */\n+  if (!side_effects_p (operands[0]))\n+    flags_operand1 = operands[0];\n+  flags_valid = FLAGS_VALID_YES;\n   return \"eor%.l %2,%0\";\n }\n "}, {"sha": "39955b05f1d7ec1064a6aaacb876951874b0c54d", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c", "patch": "@@ -670,36 +670,6 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n #define Pmode SImode\n #define FUNCTION_MODE QImode\n \n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* Set if the cc value is actually in the 68881, so a floating point\n-   conditional branch must be output.  */\n-#define CC_IN_68881 04000\n-\n-/* On the 68000, all the insns to store in an address register fail to\n-   set the cc's.  However, in some cases these instructions can make it\n-   possibly invalid to use the saved cc's.  In those cases we clear out\n-   some or all of the saved cc's so they won't be used.  */\n-#define NOTICE_UPDATE_CC(EXP,INSN) notice_update_cc (EXP, INSN)\n-\n-/* The shift instructions always clear the overflow bit.  */\n-#define CC_OVERFLOW_UNUSABLE 01000\n-\n-/* The shift instructions use the carry bit in a way not compatible with\n-   conditional branches.  conditions.h uses CC_NO_OVERFLOW for this purpose.\n-   Rename it to something more understandable.  */\n-#define CC_NO_CARRY CC_NO_OVERFLOW\n-\n-#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)  \\\n-do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n-    return FLOAT;\t\t\t\t\t\t\\\n-  if (cc_prev_status.flags & CC_NO_OVERFLOW)\t\t\t\\\n-    return NO_OV;\t\t\t\t\t\t\\\n-  return NORMAL; } while (0)\n \f\n /* Control the assembler format that we output.  */\n \n@@ -900,6 +870,8 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n \n+#define CC_STATUS_INIT m68k_init_cc ()\n+\n #include \"config/m68k/m68k-opts.h\"\n \n enum fpu_type"}, {"sha": "25e0b73741f44fad6364d3277cef145c10521537", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 909, "deletions": 1894, "changes": 2803, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c"}, {"sha": "9e4c8ba864fe9806dd3d80eac41c69767127965d", "filename": "gcc/config/m68k/predicates.md", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpredicates.md?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c", "patch": "@@ -115,15 +115,6 @@\n \t  && (INTVAL (op) >= (-0x7fffffff - 1) && INTVAL (op) <= 0x7fffffff));\n })\n \n-;; Return true if X is a valid comparison operator for the dbcc\n-;; instruction.  Note it rejects floating point comparison\n-;; operators. (In the future we could use Fdbcc).  It also rejects\n-;; some comparisons when CC_NO_OVERFLOW is set.\n-\n-(define_predicate \"valid_dbcc_comparison_p\"\n-  (and (match_code \"eq,ne,gtu,ltu,geu,leu,gt,lt,ge,le\")\n-       (match_test \"valid_dbcc_comparison_p_2 (op, mode)\")))\n-\n (define_predicate \"m68k_cstore_comparison_operator\"\n   (if_then_else (match_test \"TARGET_68881\")\n \t        (match_operand 0 \"comparison_operator\")\n@@ -210,10 +201,10 @@\n   (and (match_code \"const_int\")\n        (match_test \"op == const1_rtx\")))\n \n-;; A valid operand for a HImode or QImode conditional operation.\n-;; ColdFire has tst patterns, but not cmp patterns.\n-(define_predicate \"m68k_subword_comparison_operand\"\n-  (if_then_else (match_test \"TARGET_COLDFIRE\")\n+;; A valid operand for a conditional operation.\n+;; ColdFire has tst patterns for HImode and QImode, but not cmp patterns.\n+(define_predicate \"m68k_comparison_operand\"\n+  (if_then_else (match_test \"TARGET_COLDFIRE && mode != SImode\")\n                 (and (match_code \"const_int\")\n \t\t     (match_test \"op == const0_rtx\"))\n \t\t(match_operand 0 \"general_src_operand\")))\n@@ -234,15 +225,17 @@\n \n ;; Special case of general_src_operand, which rejects a few fp\n ;; constants (which we prefer in registers) before reload.\n+;; Used only in comparisons, and we do want to allow zero.\n \n (define_predicate \"fp_src_operand\"\n   (match_operand 0 \"general_src_operand\")\n {\n-  return !CONSTANT_P (op)\n-\t || (TARGET_68881\n-\t     && (!standard_68881_constant_p (op)\n-\t\t || reload_in_progress\n-\t\t || reload_completed));\n+  return (!CONSTANT_P (op)\n+\t  || op == CONST0_RTX (mode)\n+\t  || (TARGET_68881\n+\t      && (!standard_68881_constant_p (op)\n+\t\t  || reload_in_progress\n+\t\t  || reload_completed)));\n })\n \n ;; Used to detect constants that are valid for addq/subq instructions\n@@ -282,3 +275,6 @@\n \n (define_predicate \"swap_peephole_relational_operator\"\n   (match_code \"gtu,leu,gt,le\"))\n+\n+(define_predicate \"address_reg_operand\"\n+  (match_test (\"ADDRESS_REG_P (op)\")))"}, {"sha": "0482818c4539c2e73b6e0e0357e05c2ca5db1037", "filename": "gcc/recog.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c", "patch": "@@ -923,23 +923,6 @@ validate_simplify_insn (rtx_insn *insn)\n   return ((num_changes_pending () > 0) && (apply_change_group () > 0));\n }\n \f\n-/* Return 1 if the insn using CC0 set by INSN does not contain\n-   any ordered tests applied to the condition codes.\n-   EQ and NE tests do not count.  */\n-\n-int\n-next_insn_tests_no_inequality (rtx_insn *insn)\n-{\n-  rtx_insn *next = next_cc0_user (insn);\n-\n-  /* If there is no next insn, we have to take the conservative choice.  */\n-  if (next == 0)\n-    return 0;\n-\n-  return (INSN_P (next)\n-\t  && ! inequality_comparisons_p (PATTERN (next)));\n-}\n-\f\n /* Return 1 if OP is a valid general operand for machine mode MODE.\n    This is either a register reference, a memory reference,\n    or a constant.  In the case of a memory reference, the address"}, {"sha": "69238cf16a6f876c8e96bc5fd1a1625e50dbe3ea", "filename": "gcc/recog.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c", "patch": "@@ -112,7 +112,6 @@ extern void validate_replace_rtx_group (rtx, rtx, rtx_insn *);\n extern void validate_replace_src_group (rtx, rtx, rtx_insn *);\n extern bool validate_simplify_insn (rtx_insn *insn);\n extern int num_changes_pending (void);\n-extern int next_insn_tests_no_inequality (rtx_insn *);\n extern bool reg_fits_class_p (const_rtx, reg_class_t, int, machine_mode);\n \n extern int offsettable_memref_p (rtx);"}, {"sha": "be27937f7f9812c147594f935376ecfc3099457a", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c", "patch": "@@ -3514,7 +3514,6 @@ extern bool insn_nothrow_p (const_rtx);\n extern bool can_nonlocal_goto (const rtx_insn *);\n extern void copy_reg_eh_region_note_forward (rtx, rtx_insn *, rtx);\n extern void copy_reg_eh_region_note_backward (rtx, rtx_insn *, rtx);\n-extern int inequality_comparisons_p (const_rtx);\n extern rtx replace_rtx (rtx, rtx, rtx, bool = false);\n extern void replace_label (rtx *, rtx, rtx, bool);\n extern void replace_label_in_insn (rtx_insn *, rtx_insn *, rtx_insn *, bool);"}, {"sha": "241a35b0e6caf9aedad97762bfd196104383250a", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cebc6cbbb801183090dbb2752aa6b698331a31c/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=6cebc6cbbb801183090dbb2752aa6b698331a31c", "patch": "@@ -3021,64 +3021,6 @@ may_trap_or_fault_p (const_rtx x)\n   return may_trap_p_1 (x, 1);\n }\n \f\n-/* Return nonzero if X contains a comparison that is not either EQ or NE,\n-   i.e., an inequality.  */\n-\n-int\n-inequality_comparisons_p (const_rtx x)\n-{\n-  const char *fmt;\n-  int len, i;\n-  const enum rtx_code code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case REG:\n-    case SCRATCH:\n-    case PC:\n-    case CC0:\n-    CASE_CONST_ANY:\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      return 0;\n-\n-    case LT:\n-    case LTU:\n-    case GT:\n-    case GTU:\n-    case LE:\n-    case LEU:\n-    case GE:\n-    case GEU:\n-      return 1;\n-\n-    default:\n-      break;\n-    }\n-\n-  len = GET_RTX_LENGTH (code);\n-  fmt = GET_RTX_FORMAT (code);\n-\n-  for (i = 0; i < len; i++)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  if (inequality_comparisons_p (XEXP (x, i)))\n-\t    return 1;\n-\t}\n-      else if (fmt[i] == 'E')\n-\t{\n-\t  int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    if (inequality_comparisons_p (XVECEXP (x, i, j)))\n-\t      return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\f\n /* Replace any occurrence of FROM in X with TO.  The function does\n    not enter into CONST_DOUBLE for the replace.\n "}]}