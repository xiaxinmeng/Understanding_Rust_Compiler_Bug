{"sha": "dbe3df294330ee9d910328cece3578589daf0972", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJlM2RmMjk0MzMwZWU5ZDkxMDMyOGNlY2UzNTc4NTg5ZGFmMDk3Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-10-19T23:27:43Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-10-19T23:27:43Z"}, "message": "(float{,uns}sidf2): Rewrite to break the conversion process into several general insns.\n\n(float{,uns}sidf2): Rewrite to break the conversion process into several\ngeneral insns.\n(move_to_float): New insns to move 2 integer regs into a float\nregister through memory, taking endianess into account.  Make sure\nthat the floating temporary is a valid address.  Use one temporary for\nall floats converted.\n(fix_truncdfsi2): Take endianess into account.\n\nFrom-SVN: r10480", "tree": {"sha": "cd35e9bb7a71f20da8ae0753e5130c513329a8c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd35e9bb7a71f20da8ae0753e5130c513329a8c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbe3df294330ee9d910328cece3578589daf0972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbe3df294330ee9d910328cece3578589daf0972", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbe3df294330ee9d910328cece3578589daf0972", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbe3df294330ee9d910328cece3578589daf0972/comments", "author": null, "committer": null, "parents": [{"sha": "39b751ce5a6d74289963d38d1cbe6f0e3b65ea11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39b751ce5a6d74289963d38d1cbe6f0e3b65ea11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39b751ce5a6d74289963d38d1cbe6f0e3b65ea11"}], "stats": {"total": 137, "additions": 64, "deletions": 73}, "files": [{"sha": "7851358e081c956653c6948223d3e3d2fa3998e4", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 64, "deletions": 73, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbe3df294330ee9d910328cece3578589daf0972/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbe3df294330ee9d910328cece3578589daf0972/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=dbe3df294330ee9d910328cece3578589daf0972", "patch": "@@ -3324,98 +3324,88 @@\n \f\n ;; Conversions to and from floating-point.\n (define_expand \"floatsidf2\"\n-  [(set (match_dup 2)\n-\t(plus:DI (zero_extend:DI\n-\t\t  (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_dup 3)))\n-\t\t (match_dup 4)))\n-   (set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(minus:DF (subreg:DF (match_dup 2) 0)\n-\t\t  (match_dup 5)))]\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n {\n-  operands[2] = gen_reg_rtx (DImode);\n-  operands[3] = gen_rtx (CONST_INT, VOIDmode, 0x80000000);\n-  operands[4] = rs6000_immed_double_const (0, 0x43300000, DImode);\n-  operands[5] = force_reg (DFmode, rs6000_float_const (\\\"4503601774854144\\\", DFmode));\n+  if (operands[0])\n+    {\t\t\t\t/* prevent unused warning messages */\n+      rtx high   = force_reg (SImode, GEN_INT (0x43300000));\n+      rtx low    = gen_reg_rtx (SImode);\n+      rtx df     = gen_reg_rtx (DFmode);\n+      rtx adjust = force_reg (DFmode, rs6000_float_const (\\\"4503601774854144\\\", DFmode));\n+\n+      emit_insn (gen_xorsi3 (low, operands[1], GEN_INT (0x80000000)));\n+      emit_insn (gen_move_to_float (df, low, high));\n+      emit_insn (gen_subdf3 (operands[0], df, adjust));\n+      DONE;\n+    }\n }\")\n \n (define_expand \"floatunssidf2\"\n-  [(set (match_dup 2)\n-\t(plus:DI (zero_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t (match_dup 3)))\n-   (set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(minus:DF (subreg:DF (match_dup 2) 0)\n-\t\t  (match_dup 4)))]\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n {\n-  operands[2] = gen_reg_rtx (DImode);\n-  operands[3] = rs6000_immed_double_const (0, 0x43300000, DImode);\n-  operands[4] = force_reg (DFmode, rs6000_float_const (\\\"4503599627370496\\\", DFmode));\n+  if (operands[0])\n+    {\t\t\t\t/* prevent unused warning messages */\n+      rtx high   = force_reg (SImode, GEN_INT (0x43300000));\n+      rtx df     = gen_reg_rtx (DFmode);\n+      rtx adjust = force_reg (DFmode, rs6000_float_const (\\\"4503599627370496\\\", DFmode));\n+\n+      emit_insn (gen_move_to_float (df, operands[1], high));\n+      emit_insn (gen_subdf3 (operands[0], df, adjust));\n+      DONE;\n+    }\n }\")\n \n-;; For the above two cases, we always split.\n-(define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(plus:DI (zero_extend:DI\n-\t\t  (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 2 \"logical_operand\" \"\")))\n-\t\t (match_operand:DI 3 \"low_32_bit_operand\" \"\")))]\n-  \"reload_completed\"\n-  [(set (match_dup 6) (xor:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 4) (match_dup 5))]\n+(define_expand \"move_to_float\"\n+  [(parallel [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t       (unspec [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+\t\t\t(match_operand:SI 2 \"gpc_reg_operand\" \"\")] 2))\n+\t      (clobber (match_dup 3))])]\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n-{ operands[4] = operand_subword (operands[0], 0, 0, DImode);\n-  operands[5] = operand_subword (operands[3], 0, 0, DImode);\n-  operands[6] = operand_subword (operands[0], 1, 0, DImode);\n-}\")\n+{\n+  if (float_conv_temp == NULL_RTX)\n+    {\n+      float_conv_temp = assign_stack_local (DFmode, 8, 0);\n+      if (!offsettable_mem_operand (float_conv_temp, DFmode))\n+\tXEXP (float_conv_temp, 0) = copy_addr_to_reg (XEXP (float_conv_temp, 0));\n+    }\n \n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(plus:DI (zero_extend:DI\n-\t\t  (xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r\")\n-\t\t\t  (match_operand:SI 2 \"logical_operand\" \"rKJ\")))\n-\t\t (match_operand:DI 3 \"low_32_bit_operand\" \"n\")))]\n-  \"\"\n-  \"#\"\n-  [(set_attr \"length\" \"8\")])\n+  operands[3] = float_conv_temp;\n+}\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=\")\n-\t(plus:DI (zero_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-\t\t (match_operand:DI 2 \"low_32_bit_operand\" \"\")))]\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(unspec [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"\")] 2))\n+   (clobber (match_operand:DF 3 \"offsettable_mem_operand\" \"\"))]\n   \"reload_completed\"\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 5) (match_dup 1))]\n+  [(set (match_dup 4) (match_dup 1))\n+   (set (match_dup 5) (match_dup 2))\n+   (set (match_dup 0) (match_dup 3))]\n   \"\n-{ operands[3] = operand_subword (operands[0], 0, 0, DImode);\n-  operands[4] = operand_subword (operands[2], 0, 0, DImode);\n-  operands[5] = operand_subword (operands[0], 1, 0, DImode);\n-\n-  if (rtx_equal_p (operands[1], operands[5]))\n-    {\n-      emit_move_insn (operands[3], operands[4]);\n-      DONE;\n-    }\n-\n-  if (rtx_equal_p (operands[1], operands[3]))\n-    {\n-      rtx temp;\n+{\n+  int little = (WORDS_BIG_ENDIAN == 0);\n+  operands[4] = operand_subword (operands[3], 1 - little, 0, DFmode);\n+  operands[5] = operand_subword (operands[3], little, 0, DFmode);\n \n-      temp = operands[3]; operands[3] = operands[5]; operands[5] = temp;\n-      temp = operands[4]; operands[4] = operands[1]; operands[1] = temp;\n-    }\n+  MEM_IN_STRUCT_P (operands[4]) = 1;\n+  MEM_IN_STRUCT_P (operands[5]) = 1;\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(plus:DI (zero_extend:DI (match_operand:SI 1 \"gpc_reg_operand\" \"r\"))\n-\t\t (match_operand:DI 2 \"low_32_bit_operand\" \"n\")))]\n-  \"\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+\t(unspec [(match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n+\t\t (match_operand:SI 2 \"gpc_reg_operand\" \"r\")] 2))\n+   (clobber (match_operand:DF 3 \"offsettable_mem_operand\" \"=o\"))]\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"#\"\n-  [(set_attr \"length\" \"8\")])\n+  [(set_attr \"length\" \"12\")])\n \n (define_expand \"fix_truncdfsi2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n@@ -3425,13 +3415,14 @@\n {\n   if (TARGET_POWER2 || TARGET_POWERPC)\n     {\n-      rtx stack_slot = assign_stack_temp (DImode, 8, 0),\n-\ttemp = gen_reg_rtx (DImode);\n+      int endian = (WORDS_BIG_ENDIAN == 0);\n+      rtx stack_slot = assign_stack_temp (DImode, 8, 0);\n+      rtx temp = gen_reg_rtx (DImode);\n \n       emit_insn (gen_fpcvtsi (temp, operands[1]));\n       emit_move_insn (stack_slot, temp);\n       emit_move_insn (operands[0],\n-\t\t      operand_subword (stack_slot, 1, 0, DImode));\n+\t\t      operand_subword (stack_slot, 1 - endian, 0, DImode));\n       DONE;\n     }\n   else"}]}