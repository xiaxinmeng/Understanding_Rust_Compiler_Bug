{"sha": "4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJjMTg5OWIyZTg4M2Y5MjZkYmRhMDJmNWI5YTJjMDZlYTMwMDkwZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-01-10T21:22:12Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2020-01-10T21:22:12Z"}, "message": "Add diagnostic paths\n\nThis patch adds support for associating a \"diagnostic_path\" with a\ndiagnostic: a sequence of events predicted by the compiler that leads to\nthe problem occurring, with their locations in the user's source,\ntext descriptions, and stack information (for handling interprocedural\npaths).\n\nFor example, the following (hypothetical) error has a 3-event\nintraprocedural path:\n\ntest.c: In function 'demo':\ntest.c:29:5: error: passing NULL as argument 1 to 'PyList_Append' which\n  requires a non-NULL parameter\n   29 |     PyList_Append(list, item);\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~\n  'demo': events 1-3\n     |\n     |   25 |   list = PyList_New(0);\n     |      |          ^~~~~~~~~~~~~\n     |      |          |\n     |      |          (1) when 'PyList_New' fails, returning NULL\n     |   26 |\n     |   27 |   for (i = 0; i < count; i++) {\n     |      |   ~~~\n     |      |   |\n     |      |   (2) when 'i < count'\n     |   28 |     item = PyLong_FromLong(random());\n     |   29 |     PyList_Append(list, item);\n     |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n     |      |     |\n     |      |     (3) when calling 'PyList_Append', passing NULL from (1) as argument 1\n     |\n\nThe patch adds a new \"%@\" format code for printing event IDs, so that\nin the above, the description of event (3) mentions event (1), showing\nthe user where the bogus NULL value comes from (the event IDs are\ncolorized to draw the user's attention to them).\n\nThere is a separation between data vs presentation: the above shows how\nthe diagnostic-printing code has consolidated the path into a single run\nof events, since all the events are near each other and within the same\nfunction; more complicated examples (such as interprocedural paths)\nmight be printed as multiple runs of events.\n\nExamples of how interprocedural paths are printed can be seen in the\ntest suite (which uses a plugin to exercise the code without relying\non specific warnings using this functionality).\n\nOther output formats include\n- JSON,\n- printing each event as a separate \"note\", and\n- to not emit paths.\n\ngcc/ChangeLog:\n\t* Makefile.in (OBJS): Add tree-diagnostic-path.o.\n\t* common.opt (fdiagnostics-path-format=): New option.\n\t(diagnostic_path_format): New enum.\n\t(fdiagnostics-show-path-depths): New option.\n\t* coretypes.h (diagnostic_event_id_t): New forward decl.\n\t* diagnostic-color.c (color_dict): Add \"path\".\n\t* diagnostic-event-id.h: New file.\n\t* diagnostic-format-json.cc (json_from_expanded_location): Make\n\tnon-static.\n\t(json_end_diagnostic): Call context->make_json_for_path if it\n\texists and the diagnostic has a path.\n\t(diagnostic_output_format_init): Clear context->print_path.\n\t* diagnostic-path.h: New file.\n\t* diagnostic-show-locus.c (colorizer::set_range): Special-case\n\twhen printing a run of events in a diagnostic_path so that they\n\tall get the same color.\n\t(layout::m_diagnostic_path_p): New field.\n\t(layout::layout): Initialize it.\n\t(layout::print_any_labels): Don't colorize the label text for an\n\tevent in a diagnostic_path.\n\t(gcc_rich_location::add_location_if_nearby): Add\n\t\"restrict_to_current_line_spans\" and \"label\" params.  Pass the\n\tformer to layout.maybe_add_location_range; pass the latter\n\twhen calling add_range.\n\t* diagnostic.c: Include \"diagnostic-path.h\".\n\t(diagnostic_initialize): Initialize context->path_format and\n\tcontext->show_path_depths.\n\t(diagnostic_show_any_path): New function.\n\t(diagnostic_path::interprocedural_p): New function.\n\t(diagnostic_report_diagnostic): Call diagnostic_show_any_path.\n\t(simple_diagnostic_path::num_events): New function.\n\t(simple_diagnostic_path::get_event): New function.\n\t(simple_diagnostic_path::add_event): New function.\n\t(simple_diagnostic_event::simple_diagnostic_event): New ctor.\n\t(simple_diagnostic_event::~simple_diagnostic_event): New dtor.\n\t(debug): New overload taking a diagnostic_path *.\n\t* diagnostic.def (DK_DIAGNOSTIC_PATH): New.\n\t* diagnostic.h (enum diagnostic_path_format): New enum.\n\t(json::value): New forward decl.\n\t(diagnostic_context::path_format): New field.\n\t(diagnostic_context::show_path_depths): New field.\n\t(diagnostic_context::print_path): New callback field.\n\t(diagnostic_context::make_json_for_path): New callback field.\n\t(diagnostic_show_any_path): New decl.\n\t(json_from_expanded_location): New decl.\n\t* doc/invoke.texi (-fdiagnostics-path-format=): New option.\n\t(-fdiagnostics-show-path-depths): New option.\n\t(-fdiagnostics-color): Add \"path\" to description of default\n\tGCC_COLORS; describe it.\n\t(-fdiagnostics-format=json): Document how diagnostic paths are\n\trepresented in the JSON output format.\n\t* gcc-rich-location.h (gcc_rich_location::add_location_if_nearby):\n\tAdd optional params \"restrict_to_current_line_spans\" and \"label\".\n\t* opts.c (common_handle_option): Handle\n\tOPT_fdiagnostics_path_format_ and\n\tOPT_fdiagnostics_show_path_depths.\n\t* pretty-print.c: Include \"diagnostic-event-id.h\".\n\t(pp_format): Implement \"%@\" format code for printing\n\tdiagnostic_event_id_t *.\n\t(selftest::test_pp_format): Add tests for \"%@\".\n\t* selftest-run-tests.c (selftest::run_tests): Call\n\tselftest::tree_diagnostic_path_cc_tests.\n\t* selftest.h (selftest::tree_diagnostic_path_cc_tests): New decl.\n\t* toplev.c (general_init): Initialize global_dc->path_format and\n\tglobal_dc->show_path_depths.\n\t* tree-diagnostic-path.cc: New file.\n\t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc): Make\n\tnon-static.  Drop \"diagnostic\" param in favor of storing the\n\toriginal value of \"where\" and re-using it.\n\t(virt_loc_aware_diagnostic_finalizer): Update for dropped param of\n\tmaybe_unwind_expanded_macro_loc.\n\t(tree_diagnostics_defaults): Initialize context->print_path and\n\tcontext->make_json_for_path.\n\t* tree-diagnostic.h (default_tree_diagnostic_path_printer): New\n\tdecl.\n\t(default_tree_make_json_for_path): New decl.\n\t(maybe_unwind_expanded_macro_loc): New decl.\n\ngcc/c-family/ChangeLog:\n\t* c-format.c (local_event_ptr_node): New.\n\t(PP_FORMAT_CHAR_TABLE): Add entry for \"%@\".\n\t(init_dynamic_diag_info): Initialize local_event_ptr_node.\n\t* c-format.h (T_EVENT_PTR): New define.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/format/gcc_diag-10.c (diagnostic_event_id_t): New\n\ttypedef.\n\t(test_diag): Add coverage of \"%@\".\n\t* gcc.dg/plugin/diagnostic-path-format-default.c: New test.\n\t* gcc.dg/plugin/diagnostic-path-format-inline-events-1.c: New test.\n\t* gcc.dg/plugin/diagnostic-path-format-inline-events-2.c: New test.\n\t* gcc.dg/plugin/diagnostic-path-format-inline-events-3.c: New test.\n\t* gcc.dg/plugin/diagnostic-path-format-none.c: New test.\n\t* gcc.dg/plugin/diagnostic-test-paths-1.c: New test.\n\t* gcc.dg/plugin/diagnostic-test-paths-2.c: New test.\n\t* gcc.dg/plugin/diagnostic-test-paths-3.c: New test.\n\t* gcc.dg/plugin/diagnostic-test-paths-4.c: New test.\n\t* gcc.dg/plugin/diagnostic_plugin_test_paths.c: New.\n\t* gcc.dg/plugin/plugin.exp: Add the new plugin and test cases.\n\nlibcpp/ChangeLog:\n\t* include/line-map.h (class diagnostic_path): New forward decl.\n\t(rich_location::get_path): New accessor.\n\t(rich_location::set_path): New function.\n\t(rich_location::m_path): New field.\n\t* line-map.c (rich_location::rich_location): Initialize m_path.\n\nFrom-SVN: r280142", "tree": {"sha": "aa499fa988bf6f1172f99666b74375a6647929d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa499fa988bf6f1172f99666b74375a6647929d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ea69031c5facc70e4a96df83cd58702900fd54b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea69031c5facc70e4a96df83cd58702900fd54b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea69031c5facc70e4a96df83cd58702900fd54b6"}], "stats": {"total": 2991, "additions": 2975, "deletions": 16}, "files": [{"sha": "9e9f8221af4fd57cd65a6b1e8f722e7dc317292b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -1,3 +1,83 @@\n+2020-01-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add tree-diagnostic-path.o.\n+\t* common.opt (fdiagnostics-path-format=): New option.\n+\t(diagnostic_path_format): New enum.\n+\t(fdiagnostics-show-path-depths): New option.\n+\t* coretypes.h (diagnostic_event_id_t): New forward decl.\n+\t* diagnostic-color.c (color_dict): Add \"path\".\n+\t* diagnostic-event-id.h: New file.\n+\t* diagnostic-format-json.cc (json_from_expanded_location): Make\n+\tnon-static.\n+\t(json_end_diagnostic): Call context->make_json_for_path if it\n+\texists and the diagnostic has a path.\n+\t(diagnostic_output_format_init): Clear context->print_path.\n+\t* diagnostic-path.h: New file.\n+\t* diagnostic-show-locus.c (colorizer::set_range): Special-case\n+\twhen printing a run of events in a diagnostic_path so that they\n+\tall get the same color.\n+\t(layout::m_diagnostic_path_p): New field.\n+\t(layout::layout): Initialize it.\n+\t(layout::print_any_labels): Don't colorize the label text for an\n+\tevent in a diagnostic_path.\n+\t(gcc_rich_location::add_location_if_nearby): Add\n+\t\"restrict_to_current_line_spans\" and \"label\" params.  Pass the\n+\tformer to layout.maybe_add_location_range; pass the latter\n+\twhen calling add_range.\n+\t* diagnostic.c: Include \"diagnostic-path.h\".\n+\t(diagnostic_initialize): Initialize context->path_format and\n+\tcontext->show_path_depths.\n+\t(diagnostic_show_any_path): New function.\n+\t(diagnostic_path::interprocedural_p): New function.\n+\t(diagnostic_report_diagnostic): Call diagnostic_show_any_path.\n+\t(simple_diagnostic_path::num_events): New function.\n+\t(simple_diagnostic_path::get_event): New function.\n+\t(simple_diagnostic_path::add_event): New function.\n+\t(simple_diagnostic_event::simple_diagnostic_event): New ctor.\n+\t(simple_diagnostic_event::~simple_diagnostic_event): New dtor.\n+\t(debug): New overload taking a diagnostic_path *.\n+\t* diagnostic.def (DK_DIAGNOSTIC_PATH): New.\n+\t* diagnostic.h (enum diagnostic_path_format): New enum.\n+\t(json::value): New forward decl.\n+\t(diagnostic_context::path_format): New field.\n+\t(diagnostic_context::show_path_depths): New field.\n+\t(diagnostic_context::print_path): New callback field.\n+\t(diagnostic_context::make_json_for_path): New callback field.\n+\t(diagnostic_show_any_path): New decl.\n+\t(json_from_expanded_location): New decl.\n+\t* doc/invoke.texi (-fdiagnostics-path-format=): New option.\n+\t(-fdiagnostics-show-path-depths): New option.\n+\t(-fdiagnostics-color): Add \"path\" to description of default\n+\tGCC_COLORS; describe it.\n+\t(-fdiagnostics-format=json): Document how diagnostic paths are\n+\trepresented in the JSON output format.\n+\t* gcc-rich-location.h (gcc_rich_location::add_location_if_nearby):\n+\tAdd optional params \"restrict_to_current_line_spans\" and \"label\".\n+\t* opts.c (common_handle_option): Handle\n+\tOPT_fdiagnostics_path_format_ and\n+\tOPT_fdiagnostics_show_path_depths.\n+\t* pretty-print.c: Include \"diagnostic-event-id.h\".\n+\t(pp_format): Implement \"%@\" format code for printing\n+\tdiagnostic_event_id_t *.\n+\t(selftest::test_pp_format): Add tests for \"%@\".\n+\t* selftest-run-tests.c (selftest::run_tests): Call\n+\tselftest::tree_diagnostic_path_cc_tests.\n+\t* selftest.h (selftest::tree_diagnostic_path_cc_tests): New decl.\n+\t* toplev.c (general_init): Initialize global_dc->path_format and\n+\tglobal_dc->show_path_depths.\n+\t* tree-diagnostic-path.cc: New file.\n+\t* tree-diagnostic.c (maybe_unwind_expanded_macro_loc): Make\n+\tnon-static.  Drop \"diagnostic\" param in favor of storing the\n+\toriginal value of \"where\" and re-using it.\n+\t(virt_loc_aware_diagnostic_finalizer): Update for dropped param of\n+\tmaybe_unwind_expanded_macro_loc.\n+\t(tree_diagnostics_defaults): Initialize context->print_path and\n+\tcontext->make_json_for_path.\n+\t* tree-diagnostic.h (default_tree_diagnostic_path_printer): New\n+\tdecl.\n+\t(default_tree_make_json_for_path): New decl.\n+\t(maybe_unwind_expanded_macro_loc): New decl.\n+\n 2020-01-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/93210"}, {"sha": "864f8e3ef2c0b725631c4a0bf4aec1ecce00a1bb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -1521,6 +1521,7 @@ OBJS = \\\n \ttree-data-ref.o \\\n \ttree-dfa.o \\\n \ttree-diagnostic.o \\\n+\ttree-diagnostic-path.o \\\n \ttree-dump.o \\\n \ttree-eh.o \\\n \ttree-emutls.o \\"}, {"sha": "f21142aa19e7e3b012593ee1707d740236b10b53", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -1,3 +1,10 @@\n+2020-01-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-format.c (local_event_ptr_node): New.\n+\t(PP_FORMAT_CHAR_TABLE): Add entry for \"%@\".\n+\t(init_dynamic_diag_info): Initialize local_event_ptr_node.\n+\t* c-format.h (T_EVENT_PTR): New define.\n+\n 2020-01-10  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/93132"}, {"sha": "487edc7a5d772b68a32475fe22e6582808dd3466", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -65,6 +65,7 @@ struct function_format_info\n \n /* Initialized in init_dynamic_diag_info.  */\n static GTY(()) tree local_tree_type_node;\n+static GTY(()) tree local_event_ptr_node;\n static GTY(()) tree local_gimple_ptr_node;\n static GTY(()) tree local_cgraph_node_ptr_node;\n static GTY(()) tree locus;\n@@ -752,6 +753,7 @@ static const format_char_info asm_fprintf_char_table[] =\n   { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\", NULL }, \\\n   { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\",  NULL }, \\\n   { \"r\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",    \"//cR\",   NULL }, \\\n+  { \"@\",   1, STD_C89, { T_EVENT_PTR,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\", \"\\\"\",   NULL }, \\\n   { \"<\",   0, STD_C89, NOARGUMENTS, \"\",      \"<\",   NULL }, \\\n   { \">\",   0, STD_C89, NOARGUMENTS, \"\",      \">\",   NULL }, \\\n   { \"'\" ,  0, STD_C89, NOARGUMENTS, \"\",      \"\",    NULL }, \\\n@@ -4988,6 +4990,11 @@ init_dynamic_diag_info (void)\n       || local_cgraph_node_ptr_node == void_type_node)\n     local_cgraph_node_ptr_node = get_named_type (\"cgraph_node\");\n \n+  /* Similar to the above but for diagnostic_event_id_t*.  */\n+  if (!local_event_ptr_node\n+      || local_event_ptr_node == void_type_node)\n+    local_event_ptr_node = get_named_type (\"diagnostic_event_id_t\");\n+\n   static tree hwi;\n \n   if (!hwi)"}, {"sha": "ff8a9f988c379f60d04e94eca05cc600ba22e69a", "filename": "gcc/c-family/c-format.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fc-family%2Fc-format.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fc-family%2Fc-format.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.h?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -303,6 +303,7 @@ struct format_kind_info\n #define T_V\t&void_type_node\n #define T89_G   { STD_C89, NULL, &local_gimple_ptr_node }\n #define T_CGRAPH_NODE   { STD_C89, NULL, &local_cgraph_node_ptr_node }\n+#define T_EVENT_PTR    { STD_C89, NULL, &local_event_ptr_node }\n #define T89_T   { STD_C89, NULL, &local_tree_type_node }\n #define T89_V\t{ STD_C89, NULL, T_V }\n #define T_W\t&wchar_type_node"}, {"sha": "e9b29fb4ee06028b5cccc0adb636821807a2981d", "filename": "gcc/common.opt", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -1338,6 +1338,26 @@ fdiagnostics-show-cwe\n Common Var(flag_diagnostics_show_cwe) Init(1)\n Print CWE identifiers for diagnostic messages, where available.\n \n+fdiagnostics-path-format=\n+Common Joined RejectNegative Var(flag_diagnostics_path_format) Enum(diagnostic_path_format) Init(DPF_INLINE_EVENTS)\n+Specify how to print any control-flow path associated with a diagnostic.\n+\n+Enum\n+Name(diagnostic_path_format) Type(int)\n+\n+EnumValue\n+Enum(diagnostic_path_format) String(none) Value(DPF_NONE)\n+\n+EnumValue\n+Enum(diagnostic_path_format) String(separate-events) Value(DPF_SEPARATE_EVENTS)\n+\n+EnumValue\n+Enum(diagnostic_path_format) String(inline-events) Value(DPF_INLINE_EVENTS)\n+\n+fdiagnostics-show-path-depths\n+Common Var(flag_diagnostics_show_path_depths) Init(0)\n+Show stack depths of events in paths.\n+\n fdiagnostics-minimum-margin-width=\n Common Joined UInteger Var(diagnostics_minimum_margin_width) Init(6)\n Set minimum width of left margin of source code when showing source."}, {"sha": "d8fd50d79a44b8841c79bb703487e32aa00ad908", "filename": "gcc/coretypes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -153,6 +153,7 @@ struct cl_decoded_option;\n struct cl_option_handlers;\n struct diagnostic_context;\n class pretty_printer;\n+class diagnostic_event_id_t;\n \n template<typename T> struct array_traits;\n "}, {"sha": "d55479529211ce85c6e1ffdaf7206f2559223d23", "filename": "gcc/diagnostic-color.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-color.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -90,6 +90,7 @@ static struct color_cap color_dict[] =\n   { \"range2\", SGR_SEQ (COLOR_FG_BLUE), 6, false },\n   { \"locus\", SGR_SEQ (COLOR_BOLD), 5, false },\n   { \"quote\", SGR_SEQ (COLOR_BOLD), 5, false },\n+  { \"path\", SGR_SEQ (COLOR_BOLD COLOR_SEPARATOR COLOR_FG_CYAN), 4, false },\n   { \"fixit-insert\", SGR_SEQ (COLOR_FG_GREEN), 12, false },\n   { \"fixit-delete\", SGR_SEQ (COLOR_FG_RED), 12, false },\n   { \"diff-filename\", SGR_SEQ (COLOR_BOLD), 13, false },\n@@ -126,7 +127,7 @@ colorize_stop (bool show_color)\n \n /* Parse GCC_COLORS.  The default would look like:\n    GCC_COLORS='error=01;31:warning=01;35:note=01;36:\\\n-   range1=32:range2=34:locus=01:quote=01:\\\n+   range1=32:range2=34:locus=01:quote=01:path=01;36:\\\n    fixit-insert=32:fixit-delete=31:'\\\n    diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32:\\\n    type-diff=01;32'"}, {"sha": "3c757fe8363d3c2ab4bf8bf2d2e4904e1860d4e1", "filename": "gcc/diagnostic-event-id.h", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-event-id.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-event-id.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-event-id.h?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,61 @@\n+/* A class for referring to events within a diagnostic_path.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_DIAGNOSTIC_EVENT_ID_H\n+#define GCC_DIAGNOSTIC_EVENT_ID_H\n+\n+/* A class for referring to events within a diagnostic_path.\n+\n+   They are stored as 0-based offsets into the events, but\n+   printed (e.g. via %@) as 1-based numbers.\n+\n+   For example, a 3-event path has event offsets 0, 1, and 2,\n+   which would be shown to the user as \"(1)\", \"(2)\" and \"(3)\".\n+\n+   This has its own header so that pretty-print.c can use this\n+   to implement \"%@\" without bringing in all of diagnostic_path\n+   (which e.g. refers to \"tree\").  */\n+\n+class diagnostic_event_id_t\n+{\n+ public:\n+  diagnostic_event_id_t () : m_index (UNKNOWN_EVENT_IDX) {}\n+  diagnostic_event_id_t (int zero_based_idx) : m_index (zero_based_idx) {}\n+\n+  bool known_p () const { return m_index != UNKNOWN_EVENT_IDX; }\n+\n+  int one_based () const\n+  {\n+    gcc_assert (known_p ());\n+    return m_index + 1;\n+  }\n+\n+ private:\n+  static const int UNKNOWN_EVENT_IDX = -1;\n+  int m_index; // zero-based\n+};\n+\n+/* A pointer to a diagnostic_event_id_t, for use with the \"%@\" format\n+   code, which will print a 1-based representation for it, with suitable\n+   colorization, e.g. \"(1)\".\n+   The %@ format code requires that known_p be true for the event ID. */\n+typedef diagnostic_event_id_t *diagnostic_event_id_ptr;\n+\n+#endif /* ! GCC_DIAGNOSTIC_EVENT_ID_H */"}, {"sha": "7bda5c4ba8344360ff02f56874a5f45ff1e6a6a0", "filename": "gcc/diagnostic-format-json.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-format-json.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-format-json.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-format-json.cc?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -42,7 +42,7 @@ static json::array *cur_children_array;\n \n /* Generate a JSON object for LOC.  */\n \n-static json::object *\n+json::value *\n json_from_expanded_location (location_t loc)\n {\n   expanded_location exploc = expand_location (loc);\n@@ -232,6 +232,13 @@ json_end_diagnostic (diagnostic_context *context, diagnostic_info *diagnostic,\n       json::object *metadata_obj = json_from_metadata (diagnostic->metadata);\n       diag_obj->set (\"metadata\", metadata_obj);\n     }\n+\n+  const diagnostic_path *path = richloc->get_path ();\n+  if (path && context->make_json_for_path)\n+    {\n+      json::value *path_value = context->make_json_for_path (context, path);\n+      diag_obj->set (\"path\", path_value);\n+    }\n }\n \n /* No-op implementation of \"begin_group_cb\" for JSON output.  */\n@@ -288,6 +295,7 @@ diagnostic_output_format_init (diagnostic_context *context,\n \tcontext->begin_group_cb = json_begin_group;\n \tcontext->end_group_cb =  json_end_group;\n \tcontext->final_cb =  json_final_cb;\n+\tcontext->print_path = NULL; /* handled in json_end_diagnostic.  */\n \n \t/* The metadata is handled in JSON format, rather than as text.  */\n \tcontext->show_cwe = false;"}, {"sha": "d005da351a702ae21c36c668dc8df622b3e2451b", "filename": "gcc/diagnostic-path.h", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-path.h?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,149 @@\n+/* Paths through the code associated with a diagnostic.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_DIAGNOSTIC_PATH_H\n+#define GCC_DIAGNOSTIC_PATH_H\n+\n+#include \"diagnostic.h\" /* for ATTRIBUTE_GCC_DIAG.  */\n+#include \"diagnostic-event-id.h\"\n+\n+/* A diagnostic_path is an optional additional piece of metadata associated\n+   with a diagnostic (via its rich_location).\n+\n+   It describes a sequence of events predicted by the compiler that\n+   lead to the problem occurring, with their locations in the user's source,\n+   and text descriptions.\n+\n+   For example, the following error has a 3-event path:\n+\n+     test.c: In function 'demo':\n+     test.c:29:5: error: passing NULL as argument 1 to 'PyList_Append' which\n+       requires a non-NULL parameter\n+        29 |     PyList_Append(list, item);\n+           |     ^~~~~~~~~~~~~~~~~~~~~~~~~\n+       'demo': events 1-3\n+          |\n+          |   25 |   list = PyList_New(0);\n+          |      |          ^~~~~~~~~~~~~\n+          |      |          |\n+          |      |          (1) when 'PyList_New' fails, returning NULL\n+          |   26 |\n+          |   27 |   for (i = 0; i < count; i++) {\n+          |      |   ~~~\n+          |      |   |\n+          |      |   (2) when 'i < count'\n+          |   28 |     item = PyLong_FromLong(random());\n+          |   29 |     PyList_Append(list, item);\n+          |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n+          |      |     |\n+          |      |     (3) when calling 'PyList_Append', passing NULL from (1) as argument 1\n+          |\n+\n+    The diagnostic-printing code has consolidated the path into a single\n+    run of events, since all the events are near each other and within the same\n+    function; more complicated examples (such as interprocedural paths)\n+    might be printed as multiple runs of events.  */\n+\n+/* Abstract base classes, describing events within a path, and the paths\n+   themselves.  */\n+\n+/* One event within a diagnostic_path.  */\n+\n+class diagnostic_event\n+{\n+ public:\n+  virtual ~diagnostic_event () {}\n+\n+  virtual location_t get_location () const = 0;\n+\n+  virtual tree get_fndecl () const = 0;\n+\n+  /* Stack depth, so that consumers can visualizes the interprocedural\n+     calls, returns, and frame nesting.  */\n+  virtual int get_stack_depth () const = 0;\n+\n+  /* Get a localized (and possibly colorized) description of this event.  */\n+  virtual label_text get_desc (bool can_colorize) const = 0;\n+};\n+\n+/* Abstract base class for getting at a sequence of events.  */\n+\n+class diagnostic_path\n+{\n+ public:\n+  virtual ~diagnostic_path () {}\n+  virtual unsigned num_events () const = 0;\n+  virtual const diagnostic_event & get_event (int idx) const = 0;\n+\n+  bool interprocedural_p () const;\n+};\n+\n+/* Concrete subclasses.  */\n+\n+/* A simple implementation of diagnostic_event.  */\n+\n+class simple_diagnostic_event : public diagnostic_event\n+{\n+ public:\n+  simple_diagnostic_event (location_t loc, tree fndecl, int depth,\n+\t\t\t   const char *desc);\n+  ~simple_diagnostic_event ();\n+\n+  location_t get_location () const FINAL OVERRIDE { return m_loc; }\n+  tree get_fndecl () const FINAL OVERRIDE { return m_fndecl; }\n+  int get_stack_depth () const FINAL OVERRIDE { return m_depth; }\n+  label_text get_desc (bool) const FINAL OVERRIDE\n+  {\n+    return label_text::borrow (m_desc);\n+  }\n+\n+ private:\n+  location_t m_loc;\n+  tree m_fndecl;\n+  int m_depth;\n+  char *m_desc; // has been i18n-ed and formatted\n+};\n+\n+/* A simple implementation of diagnostic_path, as a vector of\n+   simple_diagnostic_event instances.  */\n+\n+class simple_diagnostic_path : public diagnostic_path\n+{\n+ public:\n+  simple_diagnostic_path (pretty_printer *event_pp)\n+  : m_event_pp (event_pp) {}\n+\n+  unsigned num_events () const FINAL OVERRIDE;\n+  const diagnostic_event & get_event (int idx) const FINAL OVERRIDE;\n+\n+  diagnostic_event_id_t add_event (location_t loc, tree fndecl, int depth,\n+\t\t\t\t   const char *fmt, ...)\n+    ATTRIBUTE_GCC_DIAG(5,6);\n+\n+ private:\n+  auto_delete_vec<simple_diagnostic_event> m_events;\n+\n+  /* (for use by add_event).  */\n+  pretty_printer *m_event_pp;\n+};\n+\n+extern void debug (diagnostic_path *path);\n+\n+#endif /* ! GCC_DIAGNOSTIC_PATH_H */"}, {"sha": "4618b4edb7d19846e2ce74ad07fc26212d66e761", "filename": "gcc/diagnostic-show-locus.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-show-locus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic-show-locus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-show-locus.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -87,7 +87,17 @@ class colorizer\n \t     diagnostic_t diagnostic_kind);\n   ~colorizer ();\n \n-  void set_range (int range_idx) { set_state (range_idx); }\n+  void set_range (int range_idx)\n+  {\n+    /* Normally we emphasize the primary location, then alternate between\n+       two colors for the secondary locations.\n+       But if we're printing a run of events in a diagnostic path, that\n+       makes no sense, so print all of them with the same colorization.  */\n+    if (m_diagnostic_kind == DK_DIAGNOSTIC_PATH)\n+      set_state (0);\n+    else\n+      set_state (range_idx);\n+  }\n   void set_normal_text () { set_state (STATE_NORMAL_TEXT); }\n   void set_fixit_insert () { set_state (STATE_FIXIT_INSERT); }\n   void set_fixit_delete () { set_state (STATE_FIXIT_DELETE); }\n@@ -385,6 +395,7 @@ class layout\n   bool m_colorize_source_p;\n   bool m_show_labels_p;\n   bool m_show_line_numbers_p;\n+  bool m_diagnostic_path_p;\n   auto_vec <layout_range> m_layout_ranges;\n   auto_vec <const fixit_hint *> m_fixit_hints;\n   auto_vec <line_span> m_line_spans;\n@@ -958,6 +969,7 @@ layout::layout (diagnostic_context * context,\n   m_colorize_source_p (context->colorize_source_p),\n   m_show_labels_p (context->show_labels_p),\n   m_show_line_numbers_p (context->show_line_numbers_p),\n+  m_diagnostic_path_p (diagnostic_kind == DK_DIAGNOSTIC_PATH),\n   m_layout_ranges (richloc->get_num_locations ()),\n   m_fixit_hints (richloc->get_num_fixit_hints ()),\n   m_line_spans (1 + richloc->get_num_locations ()),\n@@ -1770,7 +1782,10 @@ layout::print_any_labels (linenum_type row)\n \t      {\n \t\tgcc_assert (column <= label->m_column);\n \t\tmove_to_column (&column, label->m_column, true);\n-\t\tm_colorizer.set_range (label->m_state_idx);\n+\t\t/* Colorize the text, unless it's for events in a\n+\t\t   diagnostic_path.  */\n+\t\tif (!m_diagnostic_path_p)\n+\t\t  m_colorizer.set_range (label->m_state_idx);\n \t\tpp_string (m_pp, label->m_text.m_buffer);\n \t\tm_colorizer.set_normal_text ();\n \t\tcolumn += label->m_display_width;\n@@ -2506,7 +2521,9 @@ layout::print_line (linenum_type row)\n    Otherwise return false.  */\n \n bool\n-gcc_rich_location::add_location_if_nearby (location_t loc)\n+gcc_rich_location::add_location_if_nearby (location_t loc,\n+\t\t\t\t\t   bool restrict_to_current_line_spans,\n+\t\t\t\t\t   const range_label *label)\n {\n   /* Use the layout location-handling logic to sanitize LOC,\n      filtering it to the current line spans within a temporary\n@@ -2515,10 +2532,11 @@ gcc_rich_location::add_location_if_nearby (location_t loc)\n   location_range loc_range;\n   loc_range.m_loc = loc;\n   loc_range.m_range_display_kind = SHOW_RANGE_WITHOUT_CARET;\n-  if (!layout.maybe_add_location_range (&loc_range, 0, true))\n+  if (!layout.maybe_add_location_range (&loc_range, 0,\n+\t\t\t\t\trestrict_to_current_line_spans))\n     return false;\n \n-  add_range (loc);\n+  add_range (loc, SHOW_RANGE_WITHOUT_CARET, label);\n   return true;\n }\n "}, {"sha": "72afd7c6adf08fcce462e851daafce69b935f17f", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-color.h\"\n #include \"diagnostic-url.h\"\n #include \"diagnostic-metadata.h\"\n+#include \"diagnostic-path.h\"\n #include \"edit-context.h\"\n #include \"selftest.h\"\n #include \"selftest-diagnostic.h\"\n@@ -187,6 +188,8 @@ diagnostic_initialize (diagnostic_context *context, int n_opts)\n   for (i = 0; i < rich_location::STATICALLY_ALLOCATED_RANGES; i++)\n     context->caret_chars[i] = '^';\n   context->show_cwe = false;\n+  context->path_format = DPF_NONE;\n+  context->show_path_depths = false;\n   context->show_option_requested = false;\n   context->abort_on_error = false;\n   context->show_column = false;\n@@ -658,6 +661,38 @@ diagnostic_report_current_module (diagnostic_context *context, location_t where)\n     }\n }\n \n+/* If DIAGNOSTIC has a diagnostic_path and CONTEXT supports printing paths,\n+   print the path.  */\n+\n+void\n+diagnostic_show_any_path (diagnostic_context *context,\n+\t\t\t  diagnostic_info *diagnostic)\n+{\n+  const diagnostic_path *path = diagnostic->richloc->get_path ();\n+  if (!path)\n+    return;\n+\n+  if (context->print_path)\n+    context->print_path (context, path);\n+}\n+\n+/* Return true if the events in this path involve more than one\n+   function, or false if it is purely intraprocedural.  */\n+\n+bool\n+diagnostic_path::interprocedural_p () const\n+{\n+  const unsigned num = num_events ();\n+  for (unsigned i = 0; i < num; i++)\n+    {\n+      if (get_event (i).get_fndecl () != get_event (0).get_fndecl ())\n+\treturn true;\n+      if (get_event (i).get_stack_depth () != get_event (0).get_stack_depth ())\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n void\n default_diagnostic_starter (diagnostic_context *context,\n \t\t\t    diagnostic_info *diagnostic)\n@@ -1123,6 +1158,8 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \n   context->lock--;\n \n+  diagnostic_show_any_path (context, diagnostic);\n+\n   return true;\n }\n \n@@ -1758,6 +1795,95 @@ auto_diagnostic_group::~auto_diagnostic_group ()\n     }\n }\n \n+/* Implementation of diagnostic_path::num_events vfunc for\n+   simple_diagnostic_path: simply get the number of events in the vec.  */\n+\n+unsigned\n+simple_diagnostic_path::num_events () const\n+{\n+  return m_events.length ();\n+}\n+\n+/* Implementation of diagnostic_path::get_event vfunc for\n+   simple_diagnostic_path: simply return the event in the vec.  */\n+\n+const diagnostic_event &\n+simple_diagnostic_path::get_event (int idx) const\n+{\n+  return *m_events[idx];\n+}\n+\n+/* Add an event to this path at LOC within function FNDECL at\n+   stack depth DEPTH.\n+\n+   Use m_context's printer to format FMT, as the text of the new\n+   event.\n+\n+   Return the id of the new event.  */\n+\n+diagnostic_event_id_t\n+simple_diagnostic_path::add_event (location_t loc, tree fndecl, int depth,\n+\t\t\t\t   const char *fmt, ...)\n+{\n+  pretty_printer *pp = m_event_pp;\n+  pp_clear_output_area (pp);\n+\n+  text_info ti;\n+  rich_location rich_loc (line_table, UNKNOWN_LOCATION);\n+\n+  va_list ap;\n+\n+  va_start (ap, fmt);\n+\n+  ti.format_spec = _(fmt);\n+  ti.args_ptr = &ap;\n+  ti.err_no = 0;\n+  ti.x_data = NULL;\n+  ti.m_richloc = &rich_loc;\n+\n+  pp_format (pp, &ti);\n+  pp_output_formatted_text (pp);\n+\n+  va_end (ap);\n+\n+  simple_diagnostic_event *new_event\n+    = new simple_diagnostic_event (loc, fndecl, depth, pp_formatted_text (pp));\n+  m_events.safe_push (new_event);\n+\n+  pp_clear_output_area (pp);\n+\n+  return diagnostic_event_id_t (m_events.length () - 1);\n+}\n+\n+/* struct simple_diagnostic_event.  */\n+\n+/* simple_diagnostic_event's ctor.  */\n+\n+simple_diagnostic_event::simple_diagnostic_event (location_t loc,\n+\t\t\t\t\t\t  tree fndecl,\n+\t\t\t\t\t\t  int depth,\n+\t\t\t\t\t\t  const char *desc)\n+: m_loc (loc), m_fndecl (fndecl), m_depth (depth), m_desc (xstrdup (desc))\n+{\n+}\n+\n+/* simple_diagnostic_event's dtor.  */\n+\n+simple_diagnostic_event::~simple_diagnostic_event ()\n+{\n+  free (m_desc);\n+}\n+\n+/* Print PATH by emitting a dummy \"note\" associated with it.  */\n+\n+DEBUG_FUNCTION\n+void debug (diagnostic_path *path)\n+{\n+  rich_location richloc (line_table, UNKNOWN_LOCATION);\n+  richloc.set_path (path);\n+  inform (&richloc, \"debug path\");\n+}\n+\n /* Really call the system 'abort'.  This has to go right at the end of\n    this file, so that there are no functions after it that call abort\n    and get the system abort instead of our macro.  */"}, {"sha": "0a1c57307d0c5ee9b03773ce2e2835bfc2b94eed", "filename": "gcc/diagnostic.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.def?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -38,6 +38,11 @@ DEFINE_DIAGNOSTIC_KIND (DK_WARNING, \"warning: \", \"warning\")\n DEFINE_DIAGNOSTIC_KIND (DK_ANACHRONISM, \"anachronism: \", \"warning\")\n DEFINE_DIAGNOSTIC_KIND (DK_NOTE, \"note: \", \"note\")\n DEFINE_DIAGNOSTIC_KIND (DK_DEBUG, \"debug: \", \"note\")\n+\n+/* For use when using the diagnostic_show_locus machinery to show\n+   a range of events within a path.  */\n+DEFINE_DIAGNOSTIC_KIND (DK_DIAGNOSTIC_PATH, \"path: \", \"path\")\n+\n /* These two would be re-classified as DK_WARNING or DK_ERROR, so the\n prefix does not matter.  */\n DEFINE_DIAGNOSTIC_KIND (DK_PEDWARN, \"pedwarn: \", NULL)"}, {"sha": "307dbcfb34a6f8257ce7d6b51903e75bff0bf131", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -35,6 +35,23 @@ enum diagnostics_output_format\n   DIAGNOSTICS_OUTPUT_FORMAT_JSON\n };\n \n+/* An enum for controlling how diagnostic_paths should be printed.  */\n+enum diagnostic_path_format\n+{\n+  /* Don't print diagnostic_paths.  */\n+  DPF_NONE,\n+\n+  /* Print diagnostic_paths by emitting a separate \"note\" for every event\n+     in the path.  */\n+  DPF_SEPARATE_EVENTS,\n+\n+  /* Print diagnostic_paths by consolidating events together where they\n+     are close enough, and printing such runs of events with multiple\n+     calls to diagnostic_show_locus, showing the individual events in\n+     each run via labels in the source.  */\n+  DPF_INLINE_EVENTS\n+};\n+\n /* A diagnostic is described by the MESSAGE to send, the FILE and LINE of\n    its context and its KIND (ice, error, warning, note, ...)  See complete\n    list in diagnostic.def.  */\n@@ -80,6 +97,7 @@ typedef void (*diagnostic_finalizer_fn) (diagnostic_context *,\n \t\t\t\t\t diagnostic_t);\n \n class edit_context;\n+namespace json { class value; }\n \n /* This data structure bundles altogether any information relevant to\n    the context of a diagnostic message.  */\n@@ -134,6 +152,12 @@ struct diagnostic_context\n      diagnostics.  */\n   bool show_cwe;\n \n+  /* How should diagnostic_path objects be printed.  */\n+  enum diagnostic_path_format path_format;\n+\n+  /* True if we should print stack depths when printing diagnostic paths.  */\n+  bool show_path_depths;\n+\n   /* True if we should print the command line option which controls\n      each diagnostic, if known.  */\n   bool show_option_requested;\n@@ -208,6 +232,9 @@ struct diagnostic_context\n      particular option.  */\n   char *(*get_option_url) (diagnostic_context *, int);\n \n+  void (*print_path) (diagnostic_context *, const diagnostic_path *);\n+  json::value *(*make_json_for_path) (diagnostic_context *, const diagnostic_path *);\n+\n   /* Auxiliary data for client.  */\n   void *x_data;\n \n@@ -351,6 +378,7 @@ extern void diagnostic_report_current_module (diagnostic_context *, location_t);\n extern void diagnostic_show_locus (diagnostic_context *,\n \t\t\t\t   rich_location *richloc,\n \t\t\t\t   diagnostic_t diagnostic_kind);\n+extern void diagnostic_show_any_path (diagnostic_context *, diagnostic_info *);\n \n /* Force diagnostics controlled by OPTIDX to be kind KIND.  */\n extern diagnostic_t diagnostic_classify_diagnostic (diagnostic_context *,\n@@ -442,4 +470,6 @@ extern void diagnostic_output_format_init (diagnostic_context *,\n /* Compute the number of digits in the decimal representation of an integer.  */\n extern int num_digits (int);\n \n+extern json::value *json_from_expanded_location (location_t loc);\n+\n #endif /* ! GCC_DIAGNOSTIC_H */"}, {"sha": "f2c805c0a64d7f5c78863fb1bbfb029fc7618313", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 164, "deletions": 1, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -281,6 +281,8 @@ Objective-C and Objective-C++ Dialects}.\n -fdiagnostics-minimum-margin-width=@var{width} @gol\n -fdiagnostics-parseable-fixits  -fdiagnostics-generate-patch @gol\n -fdiagnostics-show-template-tree  -fno-elide-type @gol\n+-fdiagnostics-path-format=@r{[}none@r{|}separate-events@r{|}inline-events@r{]} @gol\n+-fdiagnostics-show-path-depths @gol\n -fno-show-column}\n \n @item Warning Options\n@@ -3886,7 +3888,7 @@ for 88-color and 256-color modes background colors.\n The default @env{GCC_COLORS} is\n @smallexample\n error=01;31:warning=01;35:note=01;36:range1=32:range2=34:locus=01:\\\n-quote=01:fixit-insert=32:fixit-delete=31:\\\n+quote=01:path=01;36:fixit-insert=32:fixit-delete=31:\\\n diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32:\\\n type-diff=01;32\n @end smallexample\n@@ -3910,6 +3912,12 @@ SGR substring for warning: markers.\n @vindex note GCC_COLORS @r{capability}\n SGR substring for note: markers.\n \n+@item path=\n+@vindex path GCC_COLORS @r{capability}\n+SGR substring for colorizing paths of control-flow events as printed\n+via @option{-fdiagnostics-path-format=}, such as the identifiers of\n+individual events and lines indicating interprocedural calls and returns.\n+\n @item range1=\n @vindex range1 GCC_COLORS @r{capability}\n SGR substring for first additional range.\n@@ -4120,6 +4128,114 @@ Specifying the @option{-fno-elide-type} flag suppresses that behavior.\n This flag also affects the output of the\n @option{-fdiagnostics-show-template-tree} flag.\n \n+@item -fdiagnostics-path-format=@var{KIND}\n+@opindex fdiagnostics-path-format\n+Specify how to print paths of control-flow events for diagnostics that\n+have such a path associated with them.\n+\n+@var{KIND} is @samp{none}, @samp{separate-events}, or @samp{inline-events},\n+the default.\n+\n+@samp{none} means to not print diagnostic paths.\n+\n+@samp{separate-events} means to print a separate ``note'' diagnostic for\n+each event within the diagnostic.  For example:\n+\n+@smallexample\n+test.c:29:5: error: passing NULL as argument 1 to 'PyList_Append' which requires a non-NULL parameter\n+test.c:25:10: note: (1) when 'PyList_New' fails, returning NULL\n+test.c:27:3: note: (2) when 'i < count'\n+test.c:29:5: note: (3) when calling 'PyList_Append', passing NULL from (1) as argument 1\n+@end smallexample\n+\n+@samp{inline-events} means to print the events ``inline'' within the source\n+code.  This view attempts to consolidate the events into runs of\n+sufficiently-close events, printing them as labelled ranges within the source.\n+\n+For example, the same events as above might be printed as:\n+\n+@smallexample\n+  'test': events 1-3\n+    |\n+    |   25 |   list = PyList_New(0);\n+    |      |          ^~~~~~~~~~~~~\n+    |      |          |\n+    |      |          (1) when 'PyList_New' fails, returning NULL\n+    |   26 |\n+    |   27 |   for (i = 0; i < count; i++) @{\n+    |      |   ~~~\n+    |      |   |\n+    |      |   (2) when 'i < count'\n+    |   28 |     item = PyLong_FromLong(random());\n+    |   29 |     PyList_Append(list, item);\n+    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n+    |      |     |\n+    |      |     (3) when calling 'PyList_Append', passing NULL from (1) as argument 1\n+    |\n+@end smallexample\n+\n+Interprocedural control flow is shown by grouping the events by stack frame,\n+and using indentation to show how stack frames are nested, pushed, and popped.\n+\n+For example:\n+\n+@smallexample\n+  'test': events 1-2\n+    |\n+    |  133 | @{\n+    |      | ^\n+    |      | |\n+    |      | (1) entering 'test'\n+    |  134 |   boxed_int *obj = make_boxed_int (i);\n+    |      |                    ~~~~~~~~~~~~~~~~~~\n+    |      |                    |\n+    |      |                    (2) calling 'make_boxed_int'\n+    |\n+    +--> 'make_boxed_int': events 3-4\n+           |\n+           |  120 | @{\n+           |      | ^\n+           |      | |\n+           |      | (3) entering 'make_boxed_int'\n+           |  121 |   boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+           |      |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |      |                                    |\n+           |      |                                    (4) calling 'wrapped_malloc'\n+           |\n+           +--> 'wrapped_malloc': events 5-6\n+                  |\n+                  |    7 | @{\n+                  |      | ^\n+                  |      | |\n+                  |      | (5) entering 'wrapped_malloc'\n+                  |    8 |   return malloc (size);\n+                  |      |          ~~~~~~~~~~~~~\n+                  |      |          |\n+                  |      |          (6) calling 'malloc'\n+                  |\n+    <-------------+\n+    |\n+ 'test': event 7\n+    |\n+    |  138 |   free_boxed_int (obj);\n+    |      |   ^~~~~~~~~~~~~~~~~~~~\n+    |      |   |\n+    |      |   (7) calling 'free_boxed_int'\n+    |\n+(etc)\n+@end smallexample\n+\n+@item -fdiagnostics-show-path-depths\n+@opindex fdiagnostics-show-path-depths\n+This option provides additional information when printing control-flow paths\n+associated with a diagnostic.\n+\n+If this is option is provided then the stack depth will be printed for\n+each run of events within @option{-fdiagnostics-path-format=separate-events}.\n+\n+This is intended for use by GCC developers and plugin developers when\n+debugging diagnostics that report interprocedural control flow.\n+\n @item -fno-show-column\n @opindex fno-show-column\n @opindex fshow-column\n@@ -4315,6 +4431,53 @@ to but not including @code{next} with @code{string}'s value.  Deletions\n are expressed via an empty value for @code{string}, insertions by\n having @code{start} equal @code{next}.\n \n+If the diagnostic has a path of control-flow events associated with it,\n+it has a @code{path} array of objects representing the events.  Each\n+event object has a @code{description} string, a @code{location} object,\n+along with a @code{function} string and a @code{depth} number for\n+representing interprocedural paths.  The @code{function} represents the\n+current function at that event, and the @code{depth} represents the\n+stack depth relative to some baseline: the higher, the more frames are\n+within the stack.\n+\n+For example, the intraprocedural example shown for\n+@option{-fdiagnostics-path-format=} might have this JSON for its path:\n+\n+@smallexample\n+    \"path\": [\n+        @{\n+            \"depth\": 0,\n+            \"description\": \"when 'PyList_New' fails, returning NULL\",\n+            \"function\": \"test\",\n+            \"location\": @{\n+                \"column\": 10,\n+                \"file\": \"test.c\",\n+                \"line\": 25\n+            @}\n+        @},\n+        @{\n+            \"depth\": 0,\n+            \"description\": \"when 'i < count'\",\n+            \"function\": \"test\",\n+            \"location\": @{\n+                \"column\": 3,\n+                \"file\": \"test.c\",\n+                \"line\": 27\n+            @}\n+        @},\n+        @{\n+            \"depth\": 0,\n+            \"description\": \"when calling 'PyList_Append', passing NULL from (1) as argument 1\",\n+            \"function\": \"test\",\n+            \"location\": @{\n+                \"column\": 5,\n+                \"file\": \"test.c\",\n+                \"line\": 29\n+            @}\n+        @}\n+    ]\n+@end smallexample\n+\n @end table\n \n @node Warning Options"}, {"sha": "4119476e68c87e8ce21d4b29171934972fcd65cf", "filename": "gcc/gcc-rich-location.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fgcc-rich-location.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fgcc-rich-location.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-rich-location.h?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -62,7 +62,9 @@ class gcc_rich_location : public rich_location\n \n      Implemented in diagnostic-show-locus.c.  */\n \n-  bool add_location_if_nearby (location_t loc);\n+  bool add_location_if_nearby (location_t loc,\n+\t\t\t       bool restrict_to_current_line_spans = true,\n+\t\t\t       const range_label *label = NULL);\n \n   /* Add a fix-it hint suggesting the insertion of CONTENT before\n      INSERTION_POINT."}, {"sha": "fa4804c8d15edbde49df9ef19cb9be44b5cfe041", "filename": "gcc/opts.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -2411,6 +2411,14 @@ common_handle_option (struct gcc_options *opts,\n       dc->show_cwe = value;\n       break;\n \n+    case OPT_fdiagnostics_path_format_:\n+      dc->path_format = (enum diagnostic_path_format)value;\n+      break;\n+\n+    case OPT_fdiagnostics_show_path_depths:\n+      dc->show_path_depths = value;\n+      break;\n+\n     case OPT_fdiagnostics_show_option:\n       dc->show_option_requested = value;\n       break;"}, {"sha": "817c1059e08cbd3a13dfca129ea70163a4218db5", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"pretty-print.h\"\n #include \"diagnostic-color.h\"\n+#include \"diagnostic-event-id.h\"\n #include \"selftest.h\"\n \n #if HAVE_ICONV\n@@ -1039,6 +1040,7 @@ pp_indent (pretty_printer *pp)\n    %>: closing quote.\n    %': apostrophe (should only be used in untranslated messages;\n        translations should use appropriate punctuation directly).\n+   %@: diagnostic_event_id_ptr, for which event_id->known_p () must be true.\n    %.*s: a substring the length of which is specified by an argument\n \t integer.\n    %Ns: likewise, but length specified as constant in the format string.\n@@ -1428,6 +1430,21 @@ pp_format (pretty_printer *pp, text_info *text)\n \t  }\n \t  break;\n \n+\tcase '@':\n+\t  {\n+\t    /* diagnostic_event_id_t *.  */\n+\t    diagnostic_event_id_ptr event_id\n+\t      = va_arg (*text->args_ptr, diagnostic_event_id_ptr);\n+\t    gcc_assert (event_id->known_p ());\n+\n+\t    pp_string (pp, colorize_start (pp_show_color (pp), \"path\"));\n+\t    pp_character (pp, '(');\n+\t    pp_decimal_int (pp, event_id->one_based ());\n+\t    pp_character (pp, ')');\n+\t    pp_string (pp, colorize_stop (pp_show_color (pp)));\n+\t  }\n+\t  break;\n+\n \tdefault:\n \t  {\n \t    bool ok;\n@@ -2338,6 +2355,21 @@ test_pp_format ()\n   assert_pp_format_colored (SELFTEST_LOCATION,\n \t\t\t    \"`\\33[01m\\33[Kfoo\\33[m\\33[K' 12345678\", \"%qs %x\",\n \t\t\t    \"foo\", 0x12345678);\n+  /* Verify \"%@\".  */\n+  {\n+    diagnostic_event_id_t first (2);\n+    diagnostic_event_id_t second (7);\n+\n+    ASSERT_PP_FORMAT_2 (\"first `free' at (3); second `free' at (8)\",\n+\t\t\t\"first %<free%> at %@; second %<free%> at %@\",\n+\t\t\t&first, &second);\n+    assert_pp_format_colored\n+      (SELFTEST_LOCATION,\n+       \"first `\u001b[01m\u001b[Kfree\u001b[m\u001b[K' at \u001b[01;36m\u001b[K(3)\u001b[m\u001b[K;\"\n+       \" second `\u001b[01m\u001b[Kfree\u001b[m\u001b[K' at \u001b[01;36m\u001b[K(8)\u001b[m\u001b[K\",\n+       \"first %<free%> at %@; second %<free%> at %@\",\n+       &first, &second);\n+  }\n \n   /* Verify %Z.  */\n   int v[] = { 1, 2, 3 }; "}, {"sha": "f7f0bd34953566e189e9e345d904f918f9138705", "filename": "gcc/selftest-run-tests.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fselftest-run-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fselftest-run-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest-run-tests.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -96,6 +96,7 @@ selftest::run_tests ()\n   spellcheck_c_tests ();\n   spellcheck_tree_c_tests ();\n   tree_cfg_c_tests ();\n+  tree_diagnostic_path_cc_tests ();\n   attribute_c_tests ();\n \n   /* This one relies on most of the above.  */"}, {"sha": "140784d6c14ed6d8f91aea87ed16b2a8c63dfd6c", "filename": "gcc/selftest.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -256,6 +256,7 @@ extern void sreal_c_tests ();\n extern void store_merging_c_tests ();\n extern void tree_c_tests ();\n extern void tree_cfg_c_tests ();\n+extern void tree_diagnostic_path_cc_tests ();\n extern void typed_splay_tree_c_tests ();\n extern void unique_ptr_tests_cc_tests ();\n extern void vec_c_tests ();"}, {"sha": "6576aee81c81a154053a5be57df6ac2b21a16b92", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -19,6 +19,23 @@\n \tPR inline-asm/93027\n \t* gcc.target/i386/pr93207.c: Run it only for x86-64.\n \n+2020-01-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/format/gcc_diag-10.c (diagnostic_event_id_t): New\n+\ttypedef.\n+\t(test_diag): Add coverage of \"%@\".\n+\t* gcc.dg/plugin/diagnostic-path-format-default.c: New test.\n+\t* gcc.dg/plugin/diagnostic-path-format-inline-events-1.c: New test.\n+\t* gcc.dg/plugin/diagnostic-path-format-inline-events-2.c: New test.\n+\t* gcc.dg/plugin/diagnostic-path-format-inline-events-3.c: New test.\n+\t* gcc.dg/plugin/diagnostic-path-format-none.c: New test.\n+\t* gcc.dg/plugin/diagnostic-test-paths-1.c: New test.\n+\t* gcc.dg/plugin/diagnostic-test-paths-2.c: New test.\n+\t* gcc.dg/plugin/diagnostic-test-paths-3.c: New test.\n+\t* gcc.dg/plugin/diagnostic-test-paths-4.c: New test.\n+\t* gcc.dg/plugin/diagnostic_plugin_test_paths.c: New.\n+\t* gcc.dg/plugin/plugin.exp: Add the new plugin and test cases.\n+\n 2020-01-10  David Malcolm  <dmalcolm@redhat.com>\n \n \t* lib/gcc-dg.exp (cleanup-after-saved-dg-test): Reset global"}, {"sha": "a2f99feefc93ec8641490aa5b826d4285f0dcb37", "filename": "gcc/testsuite/gcc.dg/format/gcc_diag-10.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fgcc_diag-10.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -22,6 +22,9 @@ typedef struct gimple gimple;\n /* Likewise for gimple.  */\n typedef struct cgraph_node cgraph_node;\n \n+/* Likewise for diagnostic_event_id_t.  */\n+typedef struct diagnostic_event_id_t diagnostic_event_id_t;\n+\n #define FORMAT(kind) __attribute__ ((format (__gcc_## kind ##__, 1, 2)))\n \n void diag (const char*, ...) FORMAT (diag);\n@@ -30,14 +33,15 @@ void tdiag (const char*, ...) FORMAT (tdiag);\n void cxxdiag (const char*, ...) FORMAT (cxxdiag);\n void dump (const char*, ...) FORMAT (dump_printf);\n \n-void test_diag (tree t, gimple *gc)\n+void test_diag (tree t, gimple *gc, diagnostic_event_id_t *event_id_ptr)\n {\n   diag (\"%<\");   /* { dg-warning \"unterminated quoting directive\" } */\n   diag (\"%>\");   /* { dg-warning \"unmatched quoting directive \" } */\n   diag (\"%<foo%<bar%>%>\");   /* { dg-warning \"nested quoting directive\" } */\n \n   diag (\"%G\", gc); /* { dg-warning \"format\" } */\n   diag (\"%K\", t); /* { dg-warning \"format\" } */\n+  diag (\"%@\", event_id_ptr);\n \n   diag (\"%R\");       /* { dg-warning \"unmatched color reset directive\" } */\n   diag (\"%r\", \"\");   /* { dg-warning \"unterminated color directive\" } */"}, {"sha": "5712dbd647250850bf6aa81d916b6370ed81961f", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-path-format-default.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-default.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-default.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-default.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,142 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-show-caret\" } */\n+\n+#include <stdlib.h>\n+\n+void *wrapped_malloc (size_t size)\n+{\n+  return malloc (size);\n+}\n+\n+void wrapped_free (void *ptr)\n+{\n+  free (ptr); /* { dg-warning \"double-free of 'ptr' \\\\\\[CWE-415\\\\]\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   free (ptr);\n+   ^~~~~~~~~~\n+  'test': events 1-2\n+    |\n+    | {\n+    | ^\n+    | |\n+    | (1) entering 'test'\n+    |   boxed_int *obj = make_boxed_int (i);\n+    |                    ~~~~~~~~~~~~~~~~~~\n+    |                    |\n+    |                    (2) calling 'make_boxed_int'\n+    |\n+    +--> 'make_boxed_int': events 3-4\n+           |\n+           | {\n+           | ^\n+           | |\n+           | (3) entering 'make_boxed_int'\n+           |   boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+           |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |                                    |\n+           |                                    (4) calling 'wrapped_malloc'\n+           |\n+           +--> 'wrapped_malloc': events 5-6\n+                  |\n+                  | {\n+                  | ^\n+                  | |\n+                  | (5) entering 'wrapped_malloc'\n+                  |   return malloc (size);\n+                  |          ~~~~~~~~~~~~~\n+                  |          |\n+                  |          (6) calling 'malloc'\n+                  |\n+    <-------------+\n+    |\n+  'test': event 7\n+    |\n+    |   free_boxed_int (obj);\n+    |   ^~~~~~~~~~~~~~~~~~~~\n+    |   |\n+    |   (7) calling 'free_boxed_int'\n+    |\n+    +--> 'free_boxed_int': events 8-9\n+           |\n+           | {\n+           | ^\n+           | |\n+           | (8) entering 'free_boxed_int'\n+           |   wrapped_free (bi);\n+           |   ~~~~~~~~~~~~~~~~~\n+           |   |\n+           |   (9) calling 'wrapped_free'\n+           |\n+           +--> 'wrapped_free': events 10-11\n+                  |\n+                  | {\n+                  | ^\n+                  | |\n+                  | (10) entering 'wrapped_free'\n+                  |   free (ptr);\n+                  |   ~~~~~~~~~~\n+                  |   |\n+                  |   (11) calling 'free'\n+                  |\n+    <-------------+\n+    |\n+  'test': event 12\n+    |\n+    |   free_boxed_int (obj);\n+    |   ^~~~~~~~~~~~~~~~~~~~\n+    |   |\n+    |   (12) calling 'free_boxed_int'\n+    |\n+    +--> 'free_boxed_int': events 13-14\n+           |\n+           | {\n+           | ^\n+           | |\n+           | (13) entering 'free_boxed_int'\n+           |   wrapped_free (bi);\n+           |   ~~~~~~~~~~~~~~~~~\n+           |   |\n+           |   (14) calling 'wrapped_free'\n+           |\n+           +--> 'wrapped_free': events 15-16\n+                  |\n+                  | {\n+                  | ^\n+                  | |\n+                  | (15) entering 'wrapped_free'\n+                  |   free (ptr);\n+                  |   ~~~~~~~~~~\n+                  |   |\n+                  |   (16) calling 'free'\n+                  |\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+typedef struct boxed_int\n+{\n+  int i;\n+} boxed_int;\n+\n+boxed_int *\n+make_boxed_int (int i)\n+{\n+  boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+  result->i = i;\n+  return result;\n+}\n+\n+void\n+free_boxed_int (boxed_int *bi)\n+{\n+  wrapped_free (bi);\n+}\n+\n+void test (int i)\n+{\n+  boxed_int *obj = make_boxed_int (i);\n+\n+  free_boxed_int (obj);\n+\n+  free_boxed_int (obj);\n+}\n+"}, {"sha": "430d81737718b070280684c10faddbd437f55016", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-path-format-inline-events-1.c", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-inline-events-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-inline-events-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-inline-events-1.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,142 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-path-format=inline-events -fdiagnostics-show-caret\" } */\n+\n+#include <stdlib.h>\n+\n+void *wrapped_malloc (size_t size)\n+{\n+  return malloc (size);\n+}\n+\n+void wrapped_free (void *ptr)\n+{\n+  free (ptr); /* { dg-warning \"double-free of 'ptr' \\\\\\[CWE-415\\\\]\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   free (ptr);\n+   ^~~~~~~~~~\n+  'test': events 1-2\n+    |\n+    | {\n+    | ^\n+    | |\n+    | (1) entering 'test'\n+    |   boxed_int *obj = make_boxed_int (i);\n+    |                    ~~~~~~~~~~~~~~~~~~\n+    |                    |\n+    |                    (2) calling 'make_boxed_int'\n+    |\n+    +--> 'make_boxed_int': events 3-4\n+           |\n+           | {\n+           | ^\n+           | |\n+           | (3) entering 'make_boxed_int'\n+           |   boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+           |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |                                    |\n+           |                                    (4) calling 'wrapped_malloc'\n+           |\n+           +--> 'wrapped_malloc': events 5-6\n+                  |\n+                  | {\n+                  | ^\n+                  | |\n+                  | (5) entering 'wrapped_malloc'\n+                  |   return malloc (size);\n+                  |          ~~~~~~~~~~~~~\n+                  |          |\n+                  |          (6) calling 'malloc'\n+                  |\n+    <-------------+\n+    |\n+  'test': event 7\n+    |\n+    |   free_boxed_int (obj);\n+    |   ^~~~~~~~~~~~~~~~~~~~\n+    |   |\n+    |   (7) calling 'free_boxed_int'\n+    |\n+    +--> 'free_boxed_int': events 8-9\n+           |\n+           | {\n+           | ^\n+           | |\n+           | (8) entering 'free_boxed_int'\n+           |   wrapped_free (bi);\n+           |   ~~~~~~~~~~~~~~~~~\n+           |   |\n+           |   (9) calling 'wrapped_free'\n+           |\n+           +--> 'wrapped_free': events 10-11\n+                  |\n+                  | {\n+                  | ^\n+                  | |\n+                  | (10) entering 'wrapped_free'\n+                  |   free (ptr);\n+                  |   ~~~~~~~~~~\n+                  |   |\n+                  |   (11) calling 'free'\n+                  |\n+    <-------------+\n+    |\n+  'test': event 12\n+    |\n+    |   free_boxed_int (obj);\n+    |   ^~~~~~~~~~~~~~~~~~~~\n+    |   |\n+    |   (12) calling 'free_boxed_int'\n+    |\n+    +--> 'free_boxed_int': events 13-14\n+           |\n+           | {\n+           | ^\n+           | |\n+           | (13) entering 'free_boxed_int'\n+           |   wrapped_free (bi);\n+           |   ~~~~~~~~~~~~~~~~~\n+           |   |\n+           |   (14) calling 'wrapped_free'\n+           |\n+           +--> 'wrapped_free': events 15-16\n+                  |\n+                  | {\n+                  | ^\n+                  | |\n+                  | (15) entering 'wrapped_free'\n+                  |   free (ptr);\n+                  |   ~~~~~~~~~~\n+                  |   |\n+                  |   (16) calling 'free'\n+                  |\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+typedef struct boxed_int\n+{\n+  int i;\n+} boxed_int;\n+\n+boxed_int *\n+make_boxed_int (int i)\n+{\n+  boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+  result->i = i;\n+  return result;\n+}\n+\n+void\n+free_boxed_int (boxed_int *bi)\n+{\n+  wrapped_free (bi);\n+}\n+\n+void test (int i)\n+{\n+  boxed_int *obj = make_boxed_int (i);\n+\n+  free_boxed_int (obj);\n+\n+  free_boxed_int (obj);\n+}\n+"}, {"sha": "c2bfabec9101216669d7e893eb444f2c9e5bfde6", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-path-format-inline-events-2.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-inline-events-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-inline-events-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-inline-events-2.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,154 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-path-format=inline-events -fdiagnostics-show-caret\" } */\n+\n+/* Verify that 'inline-events' copes gracefully with events with an\n+   unknown location.  */\n+\n+#include <stdlib.h>\n+\n+extern void missing_location ();\n+\n+void *wrapped_malloc (size_t size)\n+{\n+  return malloc (size);\n+}\n+\n+void wrapped_free (void *ptr)\n+{\n+  free (ptr); /* { dg-warning \"double-free of 'ptr' \\\\\\[CWE-415\\\\]\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   free (ptr);\n+   ^~~~~~~~~~\n+  'test': events 1-2\n+    |\n+    | {\n+    | ^\n+    | |\n+    | (1) entering 'test'\n+    |   boxed_int *obj = make_boxed_int (i);\n+    |                    ~~~~~~~~~~~~~~~~~~\n+    |                    |\n+    |                    (2) calling 'make_boxed_int'\n+    |\n+    +--> 'make_boxed_int': events 3-4\n+           |\n+           | {\n+           | ^\n+           | |\n+           | (3) entering 'make_boxed_int'\n+           |   boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+           |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |                                    |\n+           |                                    (4) calling 'wrapped_malloc'\n+           |\n+           +--> 'wrapped_malloc': events 5-6\n+                  |\n+                  | {\n+                  | ^\n+                  | |\n+                  | (5) entering 'wrapped_malloc'\n+                  |   return malloc (size);\n+                  |          ~~~~~~~~~~~~~\n+                  |          |\n+                  |          (6) calling 'malloc'\n+                  |\n+    <-------------+\n+    |\n+  'test': event 7\n+    |\n+    |   free_boxed_int (obj);\n+    |   ^~~~~~~~~~~~~~~~~~~~\n+    |   |\n+    |   (7) calling 'free_boxed_int'\n+    |\n+    +--> 'free_boxed_int': events 8-9\n+           |\n+           | {\n+           | ^\n+           | |\n+           | (8) entering 'free_boxed_int'\n+           |   wrapped_free (bi);\n+           |   ~~~~~~~~~~~~~~~~~\n+           |   |\n+           |   (9) calling 'wrapped_free'\n+           |\n+           +--> 'wrapped_free': events 10-11\n+                  |\n+                  | {\n+                  | ^\n+                  | |\n+                  | (10) entering 'wrapped_free'\n+                  |   free (ptr);\n+                  |   ~~~~~~~~~~\n+                  |   |\n+                  |   (11) calling 'free'\n+                  |\n+    <-------------+\n+    |\n+  'test': event 12\n+    |\n+    |cc1:\n+    | (12): calling 'missing_location'\n+    |\n+  'test': event 13\n+    |\n+    |   free_boxed_int (obj);\n+    |   ^~~~~~~~~~~~~~~~~~~~\n+    |   |\n+    |   (13) calling 'free_boxed_int'\n+    |\n+    +--> 'free_boxed_int': events 14-15\n+           |\n+           | {\n+           | ^\n+           | |\n+           | (14) entering 'free_boxed_int'\n+           |   wrapped_free (bi);\n+           |   ~~~~~~~~~~~~~~~~~\n+           |   |\n+           |   (15) calling 'wrapped_free'\n+           |\n+           +--> 'wrapped_free': events 16-17\n+                  |\n+                  | {\n+                  | ^\n+                  | |\n+                  | (16) entering 'wrapped_free'\n+                  |   free (ptr);\n+                  |   ~~~~~~~~~~\n+                  |   |\n+                  |   (17) calling 'free'\n+                  |\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+typedef struct boxed_int\n+{\n+  int i;\n+} boxed_int;\n+\n+boxed_int *\n+make_boxed_int (int i)\n+{\n+  boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+  result->i = i;\n+  return result;\n+}\n+\n+void\n+free_boxed_int (boxed_int *bi)\n+{\n+  wrapped_free (bi);\n+}\n+\n+void test (int i)\n+{\n+  boxed_int *obj = make_boxed_int (i);\n+\n+  free_boxed_int (obj);\n+\n+  missing_location ();\n+\n+  free_boxed_int (obj);\n+}\n+"}, {"sha": "386cac91c41575fa708538fce8de6d5be1acf299", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-path-format-inline-events-3.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-inline-events-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-inline-events-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-inline-events-3.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,154 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-path-format=inline-events -fdiagnostics-show-line-numbers -fdiagnostics-show-caret\" } */\n+/* { dg-enable-nn-line-numbers \"\" } */\n+\n+/* Verify the interaction of inline-events with line numbers.  */\n+\n+#include <stdlib.h>\n+\n+extern void missing_location ();\n+\n+void *wrapped_malloc (size_t size)\n+{\n+  return malloc (size);\n+}\n+\n+void wrapped_free (void *ptr)\n+{\n+  free (ptr); /* { dg-warning \"double-free of 'ptr' \\\\\\[CWE-415\\\\]\" } */\n+  /* { dg-begin-multiline-output \"\" }\n+   NN |   free (ptr);\n+      |   ^~~~~~~~~~\n+  'test': events 1-2\n+    |\n+    |   NN | {\n+    |      | ^\n+    |      | |\n+    |      | (1) entering 'test'\n+    |   NN |   boxed_int *obj = make_boxed_int (i);\n+    |      |                    ~~~~~~~~~~~~~~~~~~\n+    |      |                    |\n+    |      |                    (2) calling 'make_boxed_int'\n+    |\n+    +--> 'make_boxed_int': events 3-4\n+           |\n+           |   NN | {\n+           |      | ^\n+           |      | |\n+           |      | (3) entering 'make_boxed_int'\n+           |   NN |   boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+           |      |                                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |      |                                    |\n+           |      |                                    (4) calling 'wrapped_malloc'\n+           |\n+           +--> 'wrapped_malloc': events 5-6\n+                  |\n+                  |   NN | {\n+                  |      | ^\n+                  |      | |\n+                  |      | (5) entering 'wrapped_malloc'\n+                  |   NN |   return malloc (size);\n+                  |      |          ~~~~~~~~~~~~~\n+                  |      |          |\n+                  |      |          (6) calling 'malloc'\n+                  |\n+    <-------------+\n+    |\n+  'test': event 7\n+    |\n+    |   NN |   free_boxed_int (obj);\n+    |      |   ^~~~~~~~~~~~~~~~~~~~\n+    |      |   |\n+    |      |   (7) calling 'free_boxed_int'\n+    |\n+    +--> 'free_boxed_int': events 8-9\n+           |\n+           |   NN | {\n+           |      | ^\n+           |      | |\n+           |      | (8) entering 'free_boxed_int'\n+           |   NN |   wrapped_free (bi);\n+           |      |   ~~~~~~~~~~~~~~~~~\n+           |      |   |\n+           |      |   (9) calling 'wrapped_free'\n+           |\n+           +--> 'wrapped_free': events 10-11\n+                  |\n+                  |   NN | {\n+                  |      | ^\n+                  |      | |\n+                  |      | (10) entering 'wrapped_free'\n+                  |   NN |   free (ptr);\n+                  |      |   ~~~~~~~~~~\n+                  |      |   |\n+                  |      |   (11) calling 'free'\n+                  |\n+    <-------------+\n+    |\n+  'test': event 12\n+    |\n+    |cc1:\n+    | (12): calling 'missing_location'\n+    |\n+  'test': event 13\n+    |\n+    |   NN |   free_boxed_int (obj);\n+    |      |   ^~~~~~~~~~~~~~~~~~~~\n+    |      |   |\n+    |      |   (13) calling 'free_boxed_int'\n+    |\n+    +--> 'free_boxed_int': events 14-15\n+           |\n+           |   NN | {\n+           |      | ^\n+           |      | |\n+           |      | (14) entering 'free_boxed_int'\n+           |   NN |   wrapped_free (bi);\n+           |      |   ~~~~~~~~~~~~~~~~~\n+           |      |   |\n+           |      |   (15) calling 'wrapped_free'\n+           |\n+           +--> 'wrapped_free': events 16-17\n+                  |\n+                  |   NN | {\n+                  |      | ^\n+                  |      | |\n+                  |      | (16) entering 'wrapped_free'\n+                  |   NN |   free (ptr);\n+                  |      |   ~~~~~~~~~~\n+                  |      |   |\n+                  |      |   (17) calling 'free'\n+                  |\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+typedef struct boxed_int\n+{\n+  int i;\n+} boxed_int;\n+\n+boxed_int *\n+make_boxed_int (int i)\n+{\n+  boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+  result->i = i;\n+  return result;\n+}\n+\n+void\n+free_boxed_int (boxed_int *bi)\n+{\n+  wrapped_free (bi);\n+}\n+\n+void test (int i)\n+{\n+  boxed_int *obj = make_boxed_int (i);\n+\n+  free_boxed_int (obj);\n+\n+  missing_location ();\n+\n+  free_boxed_int (obj);\n+}\n+"}, {"sha": "0a29f676cf70307a77ee236aa0b48e2021f2f479", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-path-format-none.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-none.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-path-format=none\" } */\n+\n+#include <stdlib.h>\n+\n+void *wrapped_malloc (size_t size)\n+{\n+  return malloc (size);\n+}\n+\n+void wrapped_free (void *ptr)\n+{\n+  free (ptr); /* { dg-warning \"double-free of 'ptr' \\\\\\[CWE-415\\\\]\" } */\n+}\n+\n+typedef struct boxed_int\n+{\n+  int i;\n+} boxed_int;\n+\n+boxed_int *\n+make_boxed_int (int i)\n+{\n+  boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+  result->i = i;\n+  return result;\n+}\n+\n+void\n+free_boxed_int (boxed_int *bi)\n+{\n+  wrapped_free (bi);\n+}\n+\n+void test (int i)\n+{\n+  boxed_int *obj = make_boxed_int (i);\n+\n+  free_boxed_int (obj);\n+\n+  free_boxed_int (obj);\n+}\n+"}, {"sha": "dcb72c0aacd6138963e9acd6abe0f3210f0d5674", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-path-format-separate-events.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-separate-events.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-separate-events.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-path-format-separate-events.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-path-format=separate-events\" } */\n+\n+#include <stdlib.h>\n+\n+void *wrapped_malloc (size_t size)\n+{\n+  return malloc (size);\n+}\n+\n+void wrapped_free (void *ptr)\n+{\n+  free (ptr); /* { dg-warning \"double-free of 'ptr' \\\\\\[CWE-415\\\\]\" } */\n+}\n+\n+typedef struct boxed_int\n+{\n+  int i;\n+} boxed_int;\n+\n+boxed_int *\n+make_boxed_int (int i)\n+{\n+  boxed_int *result = (boxed_int *)wrapped_malloc (sizeof (boxed_int));\n+  result->i = i;\n+  return result;\n+}\n+\n+void\n+free_boxed_int (boxed_int *bi)\n+{\n+  wrapped_free (bi);\n+}\n+\n+void test (int i)\n+{ /* { dg-message \"\\\\(1\\\\) entering 'test'\" } */\n+  boxed_int *obj = make_boxed_int (i); /* { dg-message \"\\\\(2\\\\) calling 'make_boxed_int'\" } */\n+  /* etc */\n+\n+  free_boxed_int (obj);\n+\n+  free_boxed_int (obj);\n+}\n+"}, {"sha": "7b11c908c7d2f172b289c00dd2edd999497b7f72", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-paths-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-1.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-path-format=separate-events\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+\n+/* Minimal reimplementation of cpython API.  */\n+typedef struct PyObject {} PyObject;\n+extern int PyArg_ParseTuple (PyObject *args, const char *fmt, ...);\n+extern PyObject *PyList_New (int);\n+extern PyObject *PyLong_FromLong(long);\n+extern void PyList_Append(PyObject *list, PyObject *item);\n+\n+PyObject *\n+make_a_list_of_random_ints_badly(PyObject *self,\n+\t\t\t\t PyObject *args)\n+{\n+  PyObject *list, *item;\n+  long count, i;\n+\n+  if (!PyArg_ParseTuple(args, \"i\", &count)) {\n+    return NULL;\n+  }\n+\n+  list = PyList_New(0); /* { dg-line PyList_New } */\n+\t\n+  for (i = 0; i < count; i++) { /* { dg-line for } */\n+    item = PyLong_FromLong(random());\n+    PyList_Append(list, item); /* { dg-line PyList_Append } */\n+  }\n+  \n+  return list;\n+\n+  /* { dg-error \"passing NULL as argument 1 to 'PyList_Append' which requires a non-NULL parameter\" \"\" { target *-*-* } PyList_Append } */\n+  /* { dg-message \"\\\\(1\\\\) when 'PyList_New' fails, returning NULL\" \"\" { target *-*-* } PyList_New } */\n+  /* { dg-message \"\\\\(2\\\\) when 'i < count'\" \"\" { target *-*-* } for } */\n+  /* { dg-message \"\\\\(3\\\\) when calling 'PyList_Append', passing NULL from \\\\(1\\\\) as argument 1\" \"\" { target *-*-* } PyList_Append } */\n+}"}, {"sha": "391aeb9ec30fde1f6bb5a8a53be6974da2248494", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-paths-2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-2.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-show-caret -fdiagnostics-show-line-numbers\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+\n+/* Minimal reimplementation of cpython API.  */\n+typedef struct PyObject {} PyObject;\n+extern int PyArg_ParseTuple (PyObject *args, const char *fmt, ...);\n+extern PyObject *PyList_New (int);\n+extern PyObject *PyLong_FromLong(long);\n+extern void PyList_Append(PyObject *list, PyObject *item);\n+\n+PyObject *\n+make_a_list_of_random_ints_badly(PyObject *self,\n+\t\t\t\t PyObject *args)\n+{\n+  PyObject *list, *item;\n+  long count, i;\n+\n+  if (!PyArg_ParseTuple(args, \"i\", &count)) {\n+    return NULL;\n+  }\n+\n+  list = PyList_New(0); /* { dg-line PyList_New } */\n+\t\n+  for (i = 0; i < count; i++) {\n+    item = PyLong_FromLong(random());\n+    PyList_Append(list, item); /* { dg-line PyList_Append } */\n+  }\n+  \n+  return list;\n+\n+  /* { dg-error \"passing NULL as argument 1 to 'PyList_Append' which requires a non-NULL parameter\" \"\" { target *-*-* } PyList_Append } */\n+  /* { dg-begin-multiline-output \"\" }\n+   29 |     PyList_Append(list, item);\n+      |     ^~~~~~~~~~~~~~~~~~~~~~~~~\n+  'make_a_list_of_random_ints_badly': events 1-3\n+    |\n+    |   25 |   list = PyList_New(0);\n+    |      |          ^~~~~~~~~~~~~\n+    |      |          |\n+    |      |          (1) when 'PyList_New' fails, returning NULL\n+    |   26 | \n+    |   27 |   for (i = 0; i < count; i++) {\n+    |      |   ~~~     \n+    |      |   |\n+    |      |   (2) when 'i < count'\n+    |   28 |     item = PyLong_FromLong(random());\n+    |   29 |     PyList_Append(list, item);\n+    |      |     ~~~~~~~~~~~~~~~~~~~~~~~~~\n+    |      |     |\n+    |      |     (3) when calling 'PyList_Append', passing NULL from (1) as argument 1\n+    |\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "6971d7cb38b63383162bb7a28b9ddfc985179e1e", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-paths-3.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-3.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-format=json\" } */\n+\n+#include <stddef.h>\n+#include <stdlib.h>\n+\n+/* Minimal reimplementation of cpython API.  */\n+typedef struct PyObject {} PyObject;\n+extern int PyArg_ParseTuple (PyObject *args, const char *fmt, ...);\n+extern PyObject *PyList_New (int);\n+extern PyObject *PyLong_FromLong(long);\n+extern void PyList_Append(PyObject *list, PyObject *item);\n+\n+PyObject *\n+make_a_list_of_random_ints_badly(PyObject *self,\n+\t\t\t\t PyObject *args)\n+{\n+  PyObject *list, *item;\n+  long count, i;\n+\n+  if (!PyArg_ParseTuple(args, \"i\", &count)) {\n+    return NULL;\n+  }\n+\n+  list = PyList_New(0);\n+\t\n+  for (i = 0; i < count; i++) {\n+    item = PyLong_FromLong(random());\n+    PyList_Append(list, item);\n+  }\n+  \n+  return list;\n+}\n+\n+/* FIXME: test the events within a path.  */\n+/* { dg-regexp \"\\\"kind\\\": \\\"error\\\"\" } */\n+/* { dg-regexp \"\\\"path\\\": \" } */\n+/* { dg-regexp \".*\" } */"}, {"sha": "847b6d423e40f032449e8ccbb91fe4deb09fb8e5", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic-test-paths-4.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic-test-paths-4.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fdiagnostics-path-format=inline-events -fdiagnostics-show-caret -fdiagnostics-show-line-numbers\" } */\n+/* { dg-enable-nn-line-numbers \"\" } */\n+\n+#include <stdio.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+\n+extern void body_of_program(void);\n+\n+void custom_logger(const char *msg)\n+{\n+  fprintf(stderr, \"LOG: %s\", msg); /* { dg-warning \"call to 'fprintf' from within signal handler\" } */\n+}\n+\n+static void int_handler(int signum)\n+{\n+  custom_logger(\"got signal\");\n+}\n+\n+static void register_handler ()\n+{\n+  signal(SIGINT, int_handler);\n+}\n+\n+void test (void)\n+{\n+  register_handler ();\n+  body_of_program();\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+   NN |   fprintf(stderr, \"LOG: %s\", msg);\n+      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+  'test': events 1-2\n+    |\n+    |   NN | {\n+    |      | ^\n+    |      | |\n+    |      | (1) entering 'test'\n+    |   NN |   register_handler ();\n+    |      |   ~~~~~~~~~~~~~~~~~~~\n+    |      |   |\n+    |      |   (2) calling 'register_handler'\n+    |\n+    +--> 'register_handler': events 3-4\n+           |\n+           |   NN | {\n+           |      | ^\n+           |      | |\n+           |      | (3) entering 'register_handler'\n+           |   NN |   signal(SIGINT, int_handler);\n+           |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |      |   |\n+           |      |   (4) registering 'int_handler' as signal handler\n+           |\n+  event 5\n+    |\n+    |cc1:\n+    | (5): later on, when the signal is delivered to the process\n+    |\n+    +--> 'int_handler': events 6-7\n+           |\n+           |   NN | {\n+           |      | ^\n+           |      | |\n+           |      | (6) entering 'int_handler'\n+           |   NN |   custom_logger(\"got signal\");\n+           |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |      |   |\n+           |      |   (7) calling 'custom_logger'\n+           |\n+           +--> 'custom_logger': events 8-9\n+                  |\n+                  |   NN | {\n+                  |      | ^\n+                  |      | |\n+                  |      | (8) entering 'custom_logger'\n+                  |   NN |   fprintf(stderr, \"LOG: %s\", msg);\n+                  |      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+                  |      |   |\n+                  |      |   (9) calling 'fprintf'\n+                  |\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "cf05ca3a5d325e6bbf15f678a7f24478b8f963d1", "filename": "gcc/testsuite/gcc.dg/plugin/diagnostic_plugin_test_paths.c", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fdiagnostic_plugin_test_paths.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,460 @@\n+/* { dg-options \"-O\" } */\n+\n+/* This plugin exercises the path-printing code.\n+\n+   The goal is to unit-test the path-printing code without needing any\n+   specific tests within the compiler's IR.  We can't use any real\n+   diagnostics for this, so we have to fake it, hence this plugin.  */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"toplev.h\"\n+#include \"basic-block.h\"\n+#include \"hash-table.h\"\n+#include \"vec.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-expr.h\"\n+#include \"is-a.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"tree.h\"\n+#include \"tree-pass.h\"\n+#include \"intl.h\"\n+#include \"plugin-version.h\"\n+#include \"diagnostic.h\"\n+#include \"diagnostic-path.h\"\n+#include \"diagnostic-metadata.h\"\n+#include \"context.h\"\n+#include \"print-tree.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"cgraph.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+const pass_data pass_data_test_show_path =\n+{\n+  IPA_PASS, /* type */\n+  \"test_show_path\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_test_show_path : public ipa_opt_pass_d\n+{\n+public:\n+  pass_test_show_path(gcc::context *ctxt)\n+    : ipa_opt_pass_d (pass_data_test_show_path, ctxt,\n+\t\t      NULL, /* generate_summary */\n+\t\t      NULL, /* write_summary */\n+\t\t      NULL, /* read_summary */\n+\t\t      NULL, /* write_optimization_summary */\n+\t\t      NULL, /* read_optimization_summary */\n+\t\t      NULL, /* stmt_fixup */\n+\t\t      0, /* function_transform_todo_flags_start */\n+\t\t      NULL, /* function_transform */\n+\t\t      NULL) /* variable_transform */\n+  {}\n+\n+  /* opt_pass methods: */\n+  bool gate (function *) { return true; }\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_test_show_path\n+\n+/* Determine if STMT is a call with NUM_ARGS arguments to a function\n+   named FUNCNAME.\n+   If so, return STMT as a gcall *.  Otherwise return NULL.  */\n+\n+static gcall *\n+check_for_named_call (gimple *stmt,\n+\t\t      const char *funcname, unsigned int num_args)\n+{\n+  gcc_assert (funcname);\n+\n+  gcall *call = dyn_cast <gcall *> (stmt);\n+  if (!call)\n+    return NULL;\n+\n+  tree fndecl = gimple_call_fndecl (call);\n+  if (!fndecl)\n+    return NULL;\n+\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), funcname))\n+    return NULL;\n+\n+  if (gimple_call_num_args (call) != num_args)\n+    {\n+      error_at (stmt->location, \"expected number of args: %i (got %i)\",\n+\t\tnum_args, gimple_call_num_args (call));\n+      return NULL;\n+    }\n+\n+  return call;\n+}\n+\n+/* Example 1: a purely intraprocedural path.  */\n+\n+static void\n+example_1 ()\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  gcall *call_to_PyList_Append = NULL;\n+  gcall *call_to_PyList_New = NULL;\n+  gcond *for_cond = NULL;\n+  function *example_a_fun = NULL;\n+\n+  cgraph_node *node;\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    {\n+      function *fun = node->get_fun ();\n+      FOR_EACH_BB_FN (bb, fun)\n+\t{\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (gcall *call = check_for_named_call (stmt, \"PyList_New\", 1))\n+\t\t{\n+\t\t  call_to_PyList_New = call;\n+\t\t  example_a_fun = fun;\n+\t\t}\n+\t      if (gcall *call = check_for_named_call (stmt, \"PyList_Append\", 2))\n+\t\tcall_to_PyList_Append = call;\n+\t      if (gcond *cond = dyn_cast <gcond *> (stmt))\n+\t\tfor_cond = cond;\n+\t    }\n+\t}\n+    }\n+\n+  if (call_to_PyList_New && for_cond && call_to_PyList_Append)\n+    {\n+      auto_diagnostic_group d;\n+      gcc_rich_location richloc (gimple_location (call_to_PyList_Append));\n+      simple_diagnostic_path path (global_dc->printer);\n+      diagnostic_event_id_t alloc_event_id\n+\t= path.add_event (gimple_location (call_to_PyList_New),\n+\t\t\t  example_a_fun->decl, 0,\n+\t\t\t  \"when %qs fails, returning NULL\",\n+\t\t\t  \"PyList_New\");\n+      path.add_event (gimple_location (for_cond),\n+\t\t      example_a_fun->decl, 0,\n+\t\t      \"when %qs\", \"i < count\");\n+      path.add_event (gimple_location (call_to_PyList_Append),\n+\t\t      example_a_fun->decl, 0,\n+\t\t      \"when calling %qs, passing NULL from %@ as argument %i\",\n+\t\t      \"PyList_Append\", &alloc_event_id, 1);\n+      richloc.set_path (&path);\n+      error_at (&richloc,\n+\t\t\"passing NULL as argument %i to %qs\"\n+\t\t\" which requires a non-NULL parameter\",\n+\t\t1, \"PyList_Append\");\n+    }\n+}\n+\n+/* A (function, location_t) pair.  */\n+\n+struct event_location_t\n+{\n+  event_location_t ()\n+  : m_fun (NULL), m_loc (UNKNOWN_LOCATION)\n+  {}\n+\n+  event_location_t (function *fun, location_t loc)\n+  : m_fun (fun), m_loc (loc)\n+  {}\n+\n+  void set (const gimple *stmt, function *fun)\n+  {\n+    m_fun = fun;\n+    m_loc = gimple_location (stmt);\n+  }\n+\n+  function *m_fun;\n+  location_t m_loc;\n+};\n+\n+/* If FUN's name matches FUNCNAME, write the function and its start location\n+   into *OUT_ENTRY.  */\n+\n+static void\n+check_for_named_function (function *fun, const char *funcname,\n+\t\t\t  event_location_t *out_entry)\n+{\n+  gcc_assert (fun);\n+  gcc_assert (funcname);\n+\n+  if (strcmp (IDENTIFIER_POINTER (DECL_NAME (fun->decl)), funcname))\n+    return;\n+\n+  *out_entry = event_location_t (fun, fun->function_start_locus);\n+}\n+\n+\n+/* Example 2: an interprocedural path.  */\n+\n+class test_diagnostic_path : public simple_diagnostic_path\n+{\n+ public:\n+  test_diagnostic_path (pretty_printer *event_pp)\n+  : simple_diagnostic_path (event_pp)\n+  {\n+  }\n+  void add_entry (event_location_t evloc, int stack_depth,\n+\t\t  const char *funcname)\n+  {\n+    gcc_assert (evloc.m_fun);\n+    add_event (evloc.m_loc, evloc.m_fun->decl, stack_depth,\n+\t       \"entering %qs\", funcname);\n+  }\n+\n+  void add_call (event_location_t call_evloc, int caller_stack_depth,\n+\t\t event_location_t callee_entry_evloc, const char *callee)\n+  {\n+    gcc_assert (call_evloc.m_fun);\n+    add_event (call_evloc.m_loc, call_evloc.m_fun->decl, caller_stack_depth,\n+\t       \"calling %qs\", callee);\n+    add_entry (callee_entry_evloc, caller_stack_depth + 1, callee);\n+  }\n+\n+  void add_leaf_call (event_location_t call_evloc, int caller_stack_depth,\n+\t\t      const char *callee)\n+  {\n+    gcc_assert (call_evloc.m_fun);\n+    add_event (call_evloc.m_loc, call_evloc.m_fun->decl, caller_stack_depth,\n+\t       \"calling %qs\", callee);\n+  }\n+};\n+\n+static void\n+example_2 ()\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  event_location_t entry_to_wrapped_malloc;\n+  event_location_t call_to_malloc;\n+\n+  event_location_t entry_to_wrapped_free;\n+  event_location_t call_to_free;\n+\n+  event_location_t entry_to_make_boxed_int;\n+  event_location_t call_to_wrapped_malloc;\n+\n+  event_location_t entry_to_free_boxed_int;\n+  event_location_t call_to_wrapped_free;\n+\n+  event_location_t entry_to_test;\n+  event_location_t call_to_make_boxed_int;\n+  event_location_t call_to_free_boxed_int;\n+\n+  event_location_t call_to_missing_location;\n+\n+  cgraph_node *node;\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    {\n+      function *fun = node->get_fun ();\n+      FOR_EACH_BB_FN (bb, fun)\n+\t{\n+\t  check_for_named_function (fun, \"wrapped_malloc\",\n+\t\t\t\t    &entry_to_wrapped_malloc);\n+\t  check_for_named_function (fun, \"wrapped_free\",\n+\t\t\t\t    &entry_to_wrapped_free);\n+\t  check_for_named_function (fun, \"make_boxed_int\",\n+\t\t\t\t    &entry_to_make_boxed_int);\n+\t  check_for_named_function (fun, \"free_boxed_int\",\n+\t\t\t\t    &entry_to_free_boxed_int);\n+\t  check_for_named_function (fun, \"test\",\n+\t\t\t\t    &entry_to_test);\n+\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (gcall *call = check_for_named_call (stmt, \"malloc\", 1))\n+\t\tcall_to_malloc.set (call, fun);\n+\t      if (gcall *call = check_for_named_call (stmt, \"free\", 1))\n+\t\tcall_to_free.set (call, fun);\n+\t      if (gcall *call = check_for_named_call (stmt, \"wrapped_malloc\", 1))\n+\t\tcall_to_wrapped_malloc.set (call, fun);\n+\t      if (gcall *call = check_for_named_call (stmt, \"wrapped_free\", 1))\n+\t\tcall_to_wrapped_free.set (call, fun);\n+\t      if (gcall *call = check_for_named_call (stmt, \"make_boxed_int\", 1))\n+\t\tcall_to_make_boxed_int.set (call, fun);\n+\t      if (gcall *call = check_for_named_call (stmt, \"free_boxed_int\", 1))\n+\t\tcall_to_free_boxed_int.set (call, fun);\n+\t      if (gcall *call = check_for_named_call (stmt, \"missing_location\", 0))\n+\t\t{\n+\t\t  call_to_missing_location.set (call, fun);\n+\t\t  /* Simulate an event that's missing a useful location_t.  */\n+\t\t  call_to_missing_location.m_loc = UNKNOWN_LOCATION;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  if (call_to_malloc.m_fun)\n+    {\n+      auto_diagnostic_group d;\n+\n+      gcc_rich_location richloc (call_to_free.m_loc);\n+      test_diagnostic_path path (global_dc->printer);\n+      path.add_entry (entry_to_test, 0, \"test\");\n+      path.add_call (call_to_make_boxed_int, 0,\n+\t\t     entry_to_make_boxed_int, \"make_boxed_int\");\n+      path.add_call (call_to_wrapped_malloc, 1,\n+\t\t     entry_to_wrapped_malloc, \"wrapped_malloc\");\n+      path.add_leaf_call (call_to_malloc, 2, \"malloc\");\n+\n+      for (int i = 0; i < 2; i++)\n+\t{\n+\t  path.add_call (call_to_free_boxed_int, 0,\n+\t\t\t entry_to_free_boxed_int, \"free_boxed_int\");\n+\t  path.add_call (call_to_wrapped_free, 1,\n+\t\t\t entry_to_wrapped_free, \"wrapped_free\");\n+\t  path.add_leaf_call (call_to_free, 2, \"free\");\n+\t  if (i == 0 && call_to_missing_location.m_fun)\n+\t    path.add_leaf_call (call_to_missing_location, 0, \"missing_location\");\n+\t}\n+\n+      richloc.set_path (&path);\n+\n+      diagnostic_metadata m;\n+      m.add_cwe (415); /* CWE-415: Double Free.  */\n+\n+      warning_at (&richloc, m, 0,\n+\t\t  \"double-free of %qs\", \"ptr\");\n+    }\n+}\n+\n+/* Example 3: an interprocedural path with a callback.  */\n+\n+static void\n+example_3 ()\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  event_location_t entry_to_custom_logger;\n+  event_location_t call_to_fprintf;\n+\n+  event_location_t entry_to_int_handler;\n+  event_location_t call_to_custom_logger;\n+\n+  event_location_t entry_to_register_handler;\n+  event_location_t call_to_signal;\n+\n+  event_location_t entry_to_test;\n+  event_location_t call_to_register_handler;\n+\n+  cgraph_node *node;\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+    {\n+      function *fun = node->get_fun ();\n+      FOR_EACH_BB_FN (bb, fun)\n+\t{\n+\t  check_for_named_function (fun, \"custom_logger\",\n+\t\t\t\t    &entry_to_custom_logger);\n+\t  check_for_named_function (fun, \"int_handler\",\n+\t\t\t\t    &entry_to_int_handler);\n+\t  check_for_named_function (fun, \"register_handler\",\n+\t\t\t\t    &entry_to_register_handler);\n+\t  check_for_named_function (fun, \"test\",\n+\t\t\t\t    &entry_to_test);\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (gcall *call = check_for_named_call (stmt, \"fprintf\", 3))\n+\t\tcall_to_fprintf.set (call, fun);\n+\t      if (gcall *call = check_for_named_call (stmt, \"custom_logger\", 1))\n+\t\tcall_to_custom_logger.set (call, fun);\n+\t      if (gcall *call = check_for_named_call (stmt, \"register_handler\",\n+\t\t\t\t\t\t      0))\n+\t\tcall_to_register_handler.set (call, fun);\n+\t      if (gcall *call = check_for_named_call (stmt, \"signal\", 2))\n+\t\tcall_to_signal.set (call, fun);\n+\t    }\n+\t}\n+    }\n+\n+  if (call_to_fprintf.m_fun)\n+    {\n+      auto_diagnostic_group d;\n+\n+      gcc_rich_location richloc (call_to_fprintf.m_loc);\n+      test_diagnostic_path path (global_dc->printer);\n+      path.add_entry (entry_to_test, 1, \"test\");\n+      path.add_call (call_to_register_handler, 1,\n+\t\t     entry_to_register_handler, \"register_handler\");\n+      path.add_event (call_to_signal.m_loc, call_to_signal.m_fun->decl,\n+\t\t      2, \"registering 'int_handler' as signal handler\");\n+      path.add_event (UNKNOWN_LOCATION, NULL_TREE, 0,\n+\t\t      \"later on, when the signal is delivered to the process\");\n+      path.add_entry (entry_to_int_handler, 1, \"int_handler\");\n+      path.add_call (call_to_custom_logger, 1,\n+\t\t     entry_to_custom_logger, \"custom_logger\");\n+      path.add_leaf_call (call_to_fprintf, 2, \"fprintf\");\n+\n+      richloc.set_path (&path);\n+\n+      diagnostic_metadata m;\n+      /* CWE-479: Signal Handler Use of a Non-reentrant Function.  */\n+      m.add_cwe (479);\n+\n+      warning_at (&richloc, m, 0,\n+\t\t  \"call to %qs from within signal handler\",\n+\t\t  \"fprintf\");\n+    }\n+}\n+\n+unsigned int\n+pass_test_show_path::execute (function *)\n+{\n+  example_1 ();\n+  example_2 ();\n+  example_3 ();\n+\n+  return 0;\n+}\n+\n+static opt_pass *\n+make_pass_test_show_path (gcc::context *ctxt)\n+{\n+  return new pass_test_show_path (ctxt);\n+}\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  struct register_pass_info pass_info;\n+  const char *plugin_name = plugin_info->base_name;\n+  int argc = plugin_info->argc;\n+  struct plugin_argument *argv = plugin_info->argv;\n+\n+  if (!plugin_default_version_check (version, &gcc_version))\n+    return 1;\n+\n+  pass_info.pass = make_pass_test_show_path (g);\n+  pass_info.reference_pass_name = \"whole-program\";\n+  pass_info.ref_pass_instance_number = 1;\n+  pass_info.pos_op = PASS_POS_INSERT_BEFORE;\n+  register_callback (plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL,\n+\t\t     &pass_info);\n+\n+  return 0;\n+}"}, {"sha": "c02b008271528262600bff74dbd08d3db74dfb08", "filename": "gcc/testsuite/gcc.dg/plugin/plugin.exp", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fplugin.exp?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -95,6 +95,17 @@ set plugin_test_list [list \\\n \t  diagnostic-test-inlining-3.c \\\n \t  diagnostic-test-inlining-4.c } \\\n     { diagnostic_plugin_test_metadata.c diagnostic-test-metadata.c } \\\n+    { diagnostic_plugin_test_paths.c \\\n+\t  diagnostic-test-paths-1.c \\\n+\t  diagnostic-test-paths-2.c \\\n+\t  diagnostic-test-paths-3.c \\\n+\t  diagnostic-test-paths-4.c \\\n+\t  diagnostic-path-format-default.c \\\n+\t  diagnostic-path-format-none.c \\\n+\t  diagnostic-path-format-separate-events.c \\\n+\t  diagnostic-path-format-inline-events-1.c \\\n+\t  diagnostic-path-format-inline-events-2.c \\\n+\t  diagnostic-path-format-inline-events-3.c } \\\n     { location_overflow_plugin.c \\\n \t  location-overflow-test-1.c \\\n \t  location-overflow-test-2.c \\"}, {"sha": "4c8be502c719b9242f757bfe740ff571dda84998", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -1181,6 +1181,10 @@ general_init (const char *argv0, bool init_signals)\n     = global_options_init.x_flag_diagnostics_show_line_numbers;\n   global_dc->show_cwe\n     = global_options_init.x_flag_diagnostics_show_cwe;\n+  global_dc->path_format\n+    = (enum diagnostic_path_format)global_options_init.x_flag_diagnostics_path_format;\n+  global_dc->show_path_depths\n+    = global_options_init.x_flag_diagnostics_show_path_depths;\n   global_dc->show_option_requested\n     = global_options_init.x_flag_diagnostics_show_option;\n   global_dc->min_margin_width"}, {"sha": "9e2ff1053b621d879e949285e483d9d3af487e4b", "filename": "gcc/tree-diagnostic-path.cc", "status": "added", "additions": 820, "deletions": 0, "changes": 820, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftree-diagnostic-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftree-diagnostic-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic-path.cc?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -0,0 +1,820 @@\n+/* Paths through the code associated with a diagnostic.\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"tree-diagnostic.h\"\n+#include \"langhooks.h\"\n+#include \"intl.h\"\n+#include \"diagnostic-path.h\"\n+#include \"json.h\"\n+#include \"gcc-rich-location.h\"\n+#include \"diagnostic-color.h\"\n+#include \"diagnostic-event-id.h\"\n+#include \"selftest.h\"\n+#include \"selftest-diagnostic.h\"\n+\n+/* Anonymous namespace for path-printing code.  */\n+\n+namespace {\n+\n+/* Subclass of range_label for showing a particular event\n+   when showing a consecutive run of events within a diagnostic_path as\n+   labelled ranges within one gcc_rich_location.  */\n+\n+class path_label : public range_label\n+{\n+ public:\n+  path_label (const diagnostic_path *path, unsigned start_idx)\n+  : m_path (path), m_start_idx (start_idx)\n+  {}\n+\n+  label_text get_text (unsigned range_idx) const FINAL OVERRIDE\n+  {\n+    unsigned event_idx = m_start_idx + range_idx;\n+    const diagnostic_event &event = m_path->get_event (event_idx);\n+\n+    /* Get the description of the event, perhaps with colorization:\n+       normally, we don't colorize within a range_label, but this\n+       is special-cased for diagnostic paths.  */\n+    bool colorize = pp_show_color (global_dc->printer);\n+    label_text event_text (event.get_desc (colorize));\n+    gcc_assert (event_text.m_buffer);\n+    pretty_printer pp;\n+    pp_show_color (&pp) = pp_show_color (global_dc->printer);\n+    diagnostic_event_id_t event_id (event_idx);\n+    pp_printf (&pp, \"%@ %s\", &event_id, event_text.m_buffer);\n+    event_text.maybe_free ();\n+    label_text result = label_text::take (xstrdup (pp_formatted_text (&pp)));\n+    return result;\n+  }\n+\n+ private:\n+  const diagnostic_path *m_path;\n+  unsigned m_start_idx;\n+};\n+\n+/* Return true if E1 and E2 can be consolidated into the same run of events\n+   when printing a diagnostic_path.  */\n+\n+static bool\n+can_consolidate_events (const diagnostic_event &e1,\n+\t\t\tconst diagnostic_event &e2,\n+\t\t\tbool check_locations)\n+{\n+  if (e1.get_fndecl () != e2.get_fndecl ())\n+    return false;\n+\n+  if (e1.get_stack_depth () != e2.get_stack_depth ())\n+    return false;\n+\n+  if (check_locations)\n+    {\n+      location_t loc1 = e1.get_location ();\n+      location_t loc2 = e2.get_location ();\n+\n+      if (loc1 < RESERVED_LOCATION_COUNT\n+\t  || loc2 < RESERVED_LOCATION_COUNT)\n+\treturn false;\n+\n+      /* Neither can be macro-based.  */\n+      if (linemap_location_from_macro_expansion_p (line_table, loc1))\n+\treturn false;\n+      if (linemap_location_from_macro_expansion_p (line_table, loc2))\n+\treturn false;\n+    }\n+\n+  /* Passed all the tests.  */\n+  return true;\n+}\n+\n+/* A class for grouing together the events in a diagnostic_path into\n+   ranges of events, partitioned by stack frame (i.e. by fndecl and\n+   stack depth).  */\n+\n+class path_summary\n+{\n+  /* A range of consecutive events within a diagnostic_path,\n+     all with the same fndecl and stack_depth, and which are suitable\n+     to print with a single call to diagnostic_show_locus.  */\n+  struct event_range\n+  {\n+    event_range (const diagnostic_path *path, unsigned start_idx,\n+\t\t const diagnostic_event &initial_event)\n+    : m_path (path),\n+      m_initial_event (initial_event),\n+      m_fndecl (initial_event.get_fndecl ()),\n+      m_stack_depth (initial_event.get_stack_depth ()),\n+      m_start_idx (start_idx), m_end_idx (start_idx),\n+      m_path_label (path, start_idx),\n+      m_richloc (initial_event.get_location (), &m_path_label)\n+    {}\n+\n+    bool maybe_add_event (const diagnostic_event &new_ev, unsigned idx,\n+\t\t\t  bool check_rich_locations)\n+    {\n+      if (!can_consolidate_events (m_initial_event, new_ev,\n+\t\t\t\t   check_rich_locations))\n+\treturn false;\n+      if (check_rich_locations)\n+\tif (!m_richloc.add_location_if_nearby (new_ev.get_location (),\n+\t\t\t\t\t       false, &m_path_label))\n+\t  return false;\n+      m_end_idx = idx;\n+      return true;\n+    }\n+\n+    /* Print the events in this range to DC, typically as a single\n+       call to the printer's diagnostic_show_locus.  */\n+\n+    void print (diagnostic_context *dc)\n+    {\n+      location_t initial_loc = m_initial_event.get_location ();\n+\n+      /* Emit a span indicating the filename (and line/column) if the\n+\t line has changed relative to the last call to\n+\t diagnostic_show_locus.  */\n+      if (dc->show_caret)\n+\t{\n+\t  expanded_location exploc\n+\t    = linemap_client_expand_location_to_spelling_point\n+\t    (initial_loc, LOCATION_ASPECT_CARET);\n+\t  if (exploc.file != LOCATION_FILE (dc->last_location))\n+\t    dc->start_span (dc, exploc);\n+\t}\n+\n+      /* If we have an UNKNOWN_LOCATION (or BUILTINS_LOCATION) as the\n+\t primary location for an event, diagnostic_show_locus won't print\n+\t anything.\n+\n+\t In particular the label for the event won't get printed.\n+\t Fail more gracefully in this case by showing the event\n+\t index and text, at no particular location.  */\n+      if (initial_loc <= BUILTINS_LOCATION)\n+\t{\n+\t  for (unsigned i = m_start_idx; i <= m_end_idx; i++)\n+\t    {\n+\t      const diagnostic_event &iter_event = m_path->get_event (i);\n+\t      diagnostic_event_id_t event_id (i);\n+\t      label_text event_text (iter_event.get_desc (true));\n+\t      pretty_printer *pp = dc->printer;\n+\t      pp_printf (pp, \" %@: %s\", &event_id, event_text.m_buffer);\n+\t      pp_newline (pp);\n+\t      event_text.maybe_free ();\n+\t    }\n+\t  return;\n+\t}\n+\n+      /* Call diagnostic_show_locus to show the events using labels.  */\n+      diagnostic_show_locus (dc, &m_richloc, DK_DIAGNOSTIC_PATH);\n+\n+      /* If we have a macro expansion, show the expansion to the user.  */\n+      if (linemap_location_from_macro_expansion_p (line_table, initial_loc))\n+\t{\n+\t  gcc_assert (m_start_idx == m_end_idx);\n+\t  maybe_unwind_expanded_macro_loc (dc, initial_loc);\n+\t}\n+    }\n+\n+    const diagnostic_path *m_path;\n+    const diagnostic_event &m_initial_event;\n+    tree m_fndecl;\n+    int m_stack_depth;\n+    unsigned m_start_idx;\n+    unsigned m_end_idx;\n+    path_label m_path_label;\n+    gcc_rich_location m_richloc;\n+  };\n+\n+ public:\n+  path_summary (const diagnostic_path &path, bool check_rich_locations);\n+\n+  void print (diagnostic_context *dc, bool show_depths) const;\n+\n+  unsigned get_num_ranges () const { return m_ranges.length (); }\n+\n+ private:\n+  auto_delete_vec <event_range> m_ranges;\n+};\n+\n+/* path_summary's ctor.  */\n+\n+path_summary::path_summary (const diagnostic_path &path,\n+\t\t\t    bool check_rich_locations)\n+{\n+  const unsigned num_events = path.num_events ();\n+\n+  event_range *cur_event_range = NULL;\n+  for (unsigned idx = 0; idx < num_events; idx++)\n+    {\n+      const diagnostic_event &event = path.get_event (idx);\n+      if (cur_event_range)\n+\tif (cur_event_range->maybe_add_event (event, idx, check_rich_locations))\n+\t  continue;\n+\n+      cur_event_range = new event_range (&path, idx, event);\n+      m_ranges.safe_push (cur_event_range);\n+    }\n+}\n+\n+/* Write SPACES to PP.  */\n+\n+static void\n+write_indent (pretty_printer *pp, int spaces)\n+{\n+  for (int i = 0; i < spaces; i++)\n+    pp_space (pp);\n+}\n+\n+/* Print FNDDECL to PP, quoting it if QUOTED is true.\n+\n+   We can't use \"%qE\" here since we can't guarantee the capabilities\n+   of PP.  */\n+\n+static void\n+print_fndecl (pretty_printer *pp, tree fndecl, bool quoted)\n+{\n+  const char *n = DECL_NAME (fndecl)\n+    ? identifier_to_locale (lang_hooks.decl_printable_name (fndecl, 2))\n+    : _(\"<anonymous>\");\n+  if (quoted)\n+    pp_printf (pp, \"%qs\", n);\n+  else\n+    pp_string (pp, n);\n+}\n+\n+/* Print this path_summary to DC, giving an overview of the interprocedural\n+   calls and returns.\n+\n+   Print the event descriptions in a nested form, printing the event\n+   descriptions within calls to diagnostic_show_locus, using labels to\n+   show the events:\n+\n+   'foo' (events 1-2)\n+     | NN |\n+     |    |\n+     +--> 'bar' (events 3-4)\n+            | NN |\n+            |    |\n+            +--> 'baz' (events 5-6)\n+                   | NN |\n+                   |    |\n+     <------------ +\n+     |\n+   'foo' (events 7-8)\n+     | NN |\n+     |    |\n+     +--> 'bar' (events 9-10)\n+            | NN |\n+            |    |\n+            +--> 'baz' (events 11-12)\n+                   | NN |\n+                   |    |\n+\n+   If SHOW_DEPTHS is true, append \" (depth N)\" to the header of each run\n+   of events.\n+\n+   For events with UNKNOWN_LOCATION, print a summary of each the event.  */\n+\n+void\n+path_summary::print (diagnostic_context *dc, bool show_depths) const\n+{\n+  pretty_printer *pp = dc->printer;\n+\n+  const int per_frame_indent = 2;\n+\n+  const char *const line_color = \"path\";\n+  const char *start_line_color\n+    = colorize_start (pp_show_color (pp), line_color);\n+  const char *end_line_color = colorize_stop (pp_show_color (pp));\n+\n+  /* Keep track of column numbers of existing '|' characters for\n+     stack depths we've already printed.  */\n+  const int EMPTY = -1;\n+  const int DELETED = -2;\n+  typedef int_hash <int, EMPTY, DELETED> vbar_hash;\n+  hash_map <vbar_hash, int> vbar_column_for_depth;\n+\n+  /* Print the ranges.  */\n+  const int base_indent = 2;\n+  int cur_indent = base_indent;\n+  unsigned i;\n+  event_range *range;\n+  FOR_EACH_VEC_ELT (m_ranges, i, range)\n+    {\n+      write_indent (pp, cur_indent);\n+      if (i > 0)\n+\t{\n+\t  const path_summary::event_range *prev_range\n+\t    = m_ranges[i - 1];\n+\t  if (range->m_stack_depth > prev_range->m_stack_depth)\n+\t    {\n+\t      /* Show pushed stack frame(s).  */\n+\t      const char *push_prefix = \"+--> \";\n+\t      pp_string (pp, start_line_color);\n+\t      pp_string (pp, push_prefix);\n+\t      pp_string (pp, end_line_color);\n+\t      cur_indent += strlen (push_prefix);\n+\t    }\n+\t}\n+      if (range->m_fndecl)\n+\t{\n+\t  print_fndecl (pp, range->m_fndecl, true);\n+\t  pp_string (pp, \": \");\n+\t}\n+      if (range->m_start_idx == range->m_end_idx)\n+\tpp_printf (pp, \"event %i\",\n+\t\t   range->m_start_idx + 1);\n+      else\n+\tpp_printf (pp, \"events %i-%i\",\n+\t\t   range->m_start_idx + 1, range->m_end_idx + 1);\n+      if (show_depths)\n+\tpp_printf (pp, \" (depth %i)\", range->m_stack_depth);\n+      pp_newline (pp);\n+\n+      /* Print a run of events.  */\n+      {\n+\twrite_indent (pp, cur_indent + per_frame_indent);\n+\tpp_string (pp, start_line_color);\n+\tpp_string (pp, \"|\");\n+\tpp_string (pp, end_line_color);\n+\tpp_newline (pp);\n+\n+\tchar *saved_prefix = pp_take_prefix (pp);\n+\tchar *prefix;\n+\t{\n+\t  pretty_printer tmp_pp;\n+\t  write_indent (&tmp_pp, cur_indent + per_frame_indent);\n+\t  pp_string (&tmp_pp, start_line_color);\n+\t  pp_string (&tmp_pp, \"|\");\n+\t  pp_string (&tmp_pp, end_line_color);\n+\t  prefix = xstrdup (pp_formatted_text (&tmp_pp));\n+\t}\n+\tpp_set_prefix (pp, prefix);\n+\tpp_prefixing_rule (pp) = DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE;\n+\trange->print (dc);\n+\tpp_set_prefix (pp, saved_prefix);\n+\n+\twrite_indent (pp, cur_indent + per_frame_indent);\n+\tpp_string (pp, start_line_color);\n+\tpp_string (pp, \"|\");\n+\tpp_string (pp, end_line_color);\n+\tpp_newline (pp);\n+      }\n+\n+      if (i < m_ranges.length () - 1)\n+\t{\n+\t  const path_summary::event_range *next_range\n+\t    = m_ranges[i + 1];\n+\n+\t  if (range->m_stack_depth > next_range->m_stack_depth)\n+\t    {\n+\t      if (vbar_column_for_depth.get (next_range->m_stack_depth))\n+\t\t{\n+\t\t  /* Show returning from stack frame(s), by printing\n+\t\t     something like:\n+\t\t     \"                   |\\n\"\n+\t\t     \"     <------------ +\\n\"\n+\t\t     \"     |\\n\".  */\n+\t\t  int vbar_for_next_frame\n+\t\t    = *vbar_column_for_depth.get (next_range->m_stack_depth);\n+\n+\t\t  int indent_for_next_frame\n+\t\t    = vbar_for_next_frame - per_frame_indent;\n+\t\t  write_indent (pp, vbar_for_next_frame);\n+\t\t  pp_string (pp, start_line_color);\n+\t\t  pp_character (pp, '<');\n+\t\t  for (int i = indent_for_next_frame + per_frame_indent;\n+\t\t       i < cur_indent + per_frame_indent - 1; i++)\n+\t\t    pp_character (pp, '-');\n+\t\t  pp_character (pp, '+');\n+\t\t  pp_string (pp, end_line_color);\n+\t\t  pp_newline (pp);\n+\t\t  cur_indent = indent_for_next_frame;\n+\n+\t\t  write_indent (pp, vbar_for_next_frame);\n+\t\t  pp_string (pp, start_line_color);\n+\t\t  pp_printf (pp, \"|\");\n+\t\t  pp_string (pp, end_line_color);\n+\t\t  pp_newline (pp);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Handle disjoint paths (e.g. a callback at some later\n+\t\t     time).  */\n+\t\t  cur_indent = base_indent;\n+\t\t}\n+\t    }\n+\t  else if (range->m_stack_depth < next_range->m_stack_depth)\n+\t    {\n+\t      /* Prepare to show pushed stack frame.  */\n+\t      gcc_assert (range->m_stack_depth != EMPTY);\n+\t      gcc_assert (range->m_stack_depth != DELETED);\n+\t      vbar_column_for_depth.put (range->m_stack_depth,\n+\t\t\t\t\t cur_indent + per_frame_indent);\n+\t      cur_indent += per_frame_indent;\n+\t    }\n+\n+\t}\n+    }\n+}\n+\n+} /* end of anonymous namespace for path-printing code.  */\n+\n+/* Print PATH to CONTEXT, according to CONTEXT's path_format.  */\n+\n+void\n+default_tree_diagnostic_path_printer (diagnostic_context *context,\n+\t\t\t\t      const diagnostic_path *path)\n+{\n+  gcc_assert (path);\n+\n+  const unsigned num_events = path->num_events ();\n+\n+  switch (context->path_format)\n+    {\n+    case DPF_NONE:\n+      /* Do nothing.  */\n+      return;\n+\n+    case DPF_SEPARATE_EVENTS:\n+      {\n+\t/* A note per event.  */\n+\tfor (unsigned i = 0; i < num_events; i++)\n+\t  {\n+\t    const diagnostic_event &event = path->get_event (i);\n+\t    label_text event_text (event.get_desc (false));\n+\t    gcc_assert (event_text.m_buffer);\n+\t    diagnostic_event_id_t event_id (i);\n+\t    inform (event.get_location (),\n+\t\t    \"%@ %s\", &event_id, event_text.m_buffer);\n+\t    event_text.maybe_free ();\n+\t  }\n+      }\n+      break;\n+\n+    case DPF_INLINE_EVENTS:\n+      {\n+\t/* Consolidate related events.  */\n+\tpath_summary summary (*path, true);\n+\tchar *saved_prefix = pp_take_prefix (context->printer);\n+\tpp_set_prefix (context->printer, NULL);\n+\tsummary.print (context, context->show_path_depths);\n+\tpp_flush (context->printer);\n+\tpp_set_prefix (context->printer, saved_prefix);\n+      }\n+    }\n+}\n+\n+/* This has to be here, rather than diagnostic-format-json.cc,\n+   since diagnostic-format-json.o is within OBJS-libcommon and thus\n+   doesn't have access to trees (for m_fndecl).  */\n+\n+json::value *\n+default_tree_make_json_for_path (diagnostic_context *,\n+\t\t\t\t const diagnostic_path *path)\n+{\n+  json::array *path_array = new json::array ();\n+  for (unsigned i = 0; i < path->num_events (); i++)\n+    {\n+      const diagnostic_event &event = path->get_event (i);\n+\n+      json::object *event_obj = new json::object ();\n+      if (event.get_location ())\n+\tevent_obj->set (\"location\",\n+\t\t\tjson_from_expanded_location (event.get_location ()));\n+      label_text event_text (event.get_desc (false));\n+      event_obj->set (\"description\", new json::string (event_text.m_buffer));\n+      event_text.maybe_free ();\n+      if (tree fndecl = event.get_fndecl ())\n+\t{\n+\t  const char *function\n+\t    = identifier_to_locale (lang_hooks.decl_printable_name (fndecl, 2));\n+\t  event_obj->set (\"function\", new json::string (function));\n+\t}\n+      event_obj->set (\"depth\",\n+\t\t      new json::integer_number (event.get_stack_depth ()));\n+      path_array->append (event_obj);\n+    }\n+  return path_array;\n+}\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+/* A subclass of simple_diagnostic_path that adds member functions\n+   for adding test events.  */\n+\n+class test_diagnostic_path : public simple_diagnostic_path\n+{\n+ public:\n+  test_diagnostic_path (pretty_printer *event_pp)\n+  : simple_diagnostic_path (event_pp)\n+  {\n+  }\n+\n+  void add_entry (tree fndecl, int stack_depth)\n+  {\n+    add_event (UNKNOWN_LOCATION, fndecl, stack_depth,\n+\t       \"entering %qE\", fndecl);\n+  }\n+\n+  void add_return (tree fndecl, int stack_depth)\n+  {\n+    add_event (UNKNOWN_LOCATION, fndecl, stack_depth,\n+\t       \"returning to %qE\", fndecl);\n+  }\n+\n+  void add_call (tree caller, int caller_stack_depth, tree callee)\n+  {\n+    add_event (UNKNOWN_LOCATION, caller, caller_stack_depth,\n+\t       \"calling %qE\", callee);\n+    add_entry (callee, caller_stack_depth + 1);\n+  }\n+};\n+\n+/* Verify that empty paths are handled gracefully.  */\n+\n+static void\n+test_empty_path (pretty_printer *event_pp)\n+{\n+  test_diagnostic_path path (event_pp);\n+  ASSERT_FALSE (path.interprocedural_p ());\n+\n+  path_summary summary (path, false);\n+  ASSERT_EQ (summary.get_num_ranges (), 0);\n+\n+  test_diagnostic_context dc;\n+  summary.print (&dc, true);\n+  ASSERT_STREQ (\"\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Verify that print_path_summary works on a purely intraprocedural path.  */\n+\n+static void\n+test_intraprocedural_path (pretty_printer *event_pp)\n+{\n+  tree fntype_void_void\n+    = build_function_type_array (void_type_node, 0, NULL);\n+  tree fndecl_foo = build_fn_decl (\"foo\", fntype_void_void);\n+\n+  test_diagnostic_path path (event_pp);\n+  path.add_event (UNKNOWN_LOCATION, fndecl_foo, 0, \"first %qs\", \"free\");\n+  path.add_event (UNKNOWN_LOCATION, fndecl_foo, 0, \"double %qs\", \"free\");\n+\n+  ASSERT_FALSE (path.interprocedural_p ());\n+\n+  path_summary summary (path, false);\n+  ASSERT_EQ (summary.get_num_ranges (), 1);\n+\n+  test_diagnostic_context dc;\n+  summary.print (&dc, true);\n+  ASSERT_STREQ (\"  `foo': events 1-2 (depth 0)\\n\"\n+\t\t\"    |\\n\"\n+\t\t\"    | (1): first `free'\\n\"\n+\t\t\"    | (2): double `free'\\n\"\n+\t\t\"    |\\n\",\n+\t\tpp_formatted_text (dc.printer));\n+}\n+\n+/* Verify that print_path_summary works on an interprocedural path.  */\n+\n+static void\n+test_interprocedural_path_1 (pretty_printer *event_pp)\n+{\n+  /* Build fndecls.  The types aren't quite right, but that\n+     doesn't matter for the purposes of this test.  */\n+  tree fntype_void_void\n+    = build_function_type_array (void_type_node, 0, NULL);\n+  tree fndecl_test = build_fn_decl (\"test\", fntype_void_void);\n+  tree fndecl_make_boxed_int\n+    = build_fn_decl (\"make_boxed_int\", fntype_void_void);\n+  tree fndecl_wrapped_malloc\n+    = build_fn_decl (\"wrapped_malloc\", fntype_void_void);\n+  tree fndecl_free_boxed_int\n+    = build_fn_decl (\"free_boxed_int\", fntype_void_void);\n+  tree fndecl_wrapped_free\n+    = build_fn_decl (\"wrapped_free\", fntype_void_void);\n+\n+  test_diagnostic_path path (event_pp);\n+  path.add_entry (fndecl_test, 0);\n+  path.add_call (fndecl_test, 0, fndecl_make_boxed_int);\n+  path.add_call (fndecl_make_boxed_int, 1, fndecl_wrapped_malloc);\n+  path.add_event (UNKNOWN_LOCATION, fndecl_wrapped_malloc, 2, \"calling malloc\");\n+  path.add_return (fndecl_test, 0);\n+  path.add_call (fndecl_test, 0, fndecl_free_boxed_int);\n+  path.add_call (fndecl_free_boxed_int, 1, fndecl_wrapped_free);\n+  path.add_event (UNKNOWN_LOCATION, fndecl_wrapped_free, 2, \"calling free\");\n+  path.add_return (fndecl_test, 0);\n+  path.add_call (fndecl_test, 0, fndecl_free_boxed_int);\n+  path.add_call (fndecl_free_boxed_int, 1, fndecl_wrapped_free);\n+  path.add_event (UNKNOWN_LOCATION, fndecl_wrapped_free, 2, \"calling free\");\n+  ASSERT_EQ (path.num_events (), 18);\n+\n+  ASSERT_TRUE (path.interprocedural_p ());\n+\n+  path_summary summary (path, false);\n+  ASSERT_EQ (summary.get_num_ranges (), 9);\n+\n+  test_diagnostic_context dc;\n+  summary.print (&dc, true);\n+  ASSERT_STREQ\n+    (\"  `test': events 1-2 (depth 0)\\n\"\n+     \"    |\\n\"\n+     \"    | (1): entering `test'\\n\"\n+     \"    | (2): calling `make_boxed_int'\\n\"\n+     \"    |\\n\"\n+     \"    +--> `make_boxed_int': events 3-4 (depth 1)\\n\"\n+     \"           |\\n\"\n+     \"           | (3): entering `make_boxed_int'\\n\"\n+     \"           | (4): calling `wrapped_malloc'\\n\"\n+     \"           |\\n\"\n+     \"           +--> `wrapped_malloc': events 5-6 (depth 2)\\n\"\n+     \"                  |\\n\"\n+     \"                  | (5): entering `wrapped_malloc'\\n\"\n+     \"                  | (6): calling malloc\\n\"\n+     \"                  |\\n\"\n+     \"    <-------------+\\n\"\n+     \"    |\\n\"\n+     \"  `test': events 7-8 (depth 0)\\n\"\n+     \"    |\\n\"\n+     \"    | (7): returning to `test'\\n\"\n+     \"    | (8): calling `free_boxed_int'\\n\"\n+     \"    |\\n\"\n+     \"    +--> `free_boxed_int': events 9-10 (depth 1)\\n\"\n+     \"           |\\n\"\n+     \"           | (9): entering `free_boxed_int'\\n\"\n+     \"           | (10): calling `wrapped_free'\\n\"\n+     \"           |\\n\"\n+     \"           +--> `wrapped_free': events 11-12 (depth 2)\\n\"\n+     \"                  |\\n\"\n+     \"                  | (11): entering `wrapped_free'\\n\"\n+     \"                  | (12): calling free\\n\"\n+     \"                  |\\n\"\n+     \"    <-------------+\\n\"\n+     \"    |\\n\"\n+     \"  `test': events 13-14 (depth 0)\\n\"\n+     \"    |\\n\"\n+     \"    | (13): returning to `test'\\n\"\n+     \"    | (14): calling `free_boxed_int'\\n\"\n+     \"    |\\n\"\n+     \"    +--> `free_boxed_int': events 15-16 (depth 1)\\n\"\n+     \"           |\\n\"\n+     \"           | (15): entering `free_boxed_int'\\n\"\n+     \"           | (16): calling `wrapped_free'\\n\"\n+     \"           |\\n\"\n+     \"           +--> `wrapped_free': events 17-18 (depth 2)\\n\"\n+     \"                  |\\n\"\n+     \"                  | (17): entering `wrapped_free'\\n\"\n+     \"                  | (18): calling free\\n\"\n+     \"                  |\\n\",\n+     pp_formatted_text (dc.printer));\n+}\n+\n+/* Example where we pop the stack to an intermediate frame, rather than the\n+   initial one.  */\n+\n+static void\n+test_interprocedural_path_2 (pretty_printer *event_pp)\n+{\n+  /* Build fndecls.  The types aren't quite right, but that\n+     doesn't matter for the purposes of this test.  */\n+  tree fntype_void_void\n+    = build_function_type_array (void_type_node, 0, NULL);\n+  tree fndecl_foo = build_fn_decl (\"foo\", fntype_void_void);\n+  tree fndecl_bar = build_fn_decl (\"bar\", fntype_void_void);\n+  tree fndecl_baz = build_fn_decl (\"baz\", fntype_void_void);\n+\n+  test_diagnostic_path path (event_pp);\n+  path.add_entry (fndecl_foo, 0);\n+  path.add_call (fndecl_foo, 0, fndecl_bar);\n+  path.add_call (fndecl_bar, 1, fndecl_baz);\n+  path.add_return (fndecl_bar, 1);\n+  path.add_call (fndecl_bar, 1, fndecl_baz);\n+  ASSERT_EQ (path.num_events (), 8);\n+\n+  ASSERT_TRUE (path.interprocedural_p ());\n+\n+  path_summary summary (path, false);\n+  ASSERT_EQ (summary.get_num_ranges (), 5);\n+\n+  test_diagnostic_context dc;\n+  summary.print (&dc, true);\n+  ASSERT_STREQ\n+    (\"  `foo': events 1-2 (depth 0)\\n\"\n+     \"    |\\n\"\n+     \"    | (1): entering `foo'\\n\"\n+     \"    | (2): calling `bar'\\n\"\n+     \"    |\\n\"\n+     \"    +--> `bar': events 3-4 (depth 1)\\n\"\n+     \"           |\\n\"\n+     \"           | (3): entering `bar'\\n\"\n+     \"           | (4): calling `baz'\\n\"\n+     \"           |\\n\"\n+     \"           +--> `baz': event 5 (depth 2)\\n\"\n+     \"                  |\\n\"\n+     \"                  | (5): entering `baz'\\n\"\n+     \"                  |\\n\"\n+     \"           <------+\\n\"\n+     \"           |\\n\"\n+     \"         `bar': events 6-7 (depth 1)\\n\"\n+     \"           |\\n\"\n+     \"           | (6): returning to `bar'\\n\"\n+     \"           | (7): calling `baz'\\n\"\n+     \"           |\\n\"\n+     \"           +--> `baz': event 8 (depth 2)\\n\"\n+     \"                  |\\n\"\n+     \"                  | (8): entering `baz'\\n\"\n+     \"                  |\\n\",\n+     pp_formatted_text (dc.printer));\n+}\n+\n+/* Verify that print_path_summary is sane in the face of a recursive\n+   diagnostic_path.  */\n+\n+static void\n+test_recursion (pretty_printer *event_pp)\n+{\n+  tree fntype_void_void\n+    = build_function_type_array (void_type_node, 0, NULL);\n+  tree fndecl_factorial = build_fn_decl (\"factorial\", fntype_void_void);\n+\n+ test_diagnostic_path path (event_pp);\n+  path.add_entry (fndecl_factorial, 0);\n+  for (int depth = 0; depth < 3; depth++)\n+    path.add_call (fndecl_factorial, depth, fndecl_factorial);\n+  ASSERT_EQ (path.num_events (), 7);\n+\n+  ASSERT_TRUE (path.interprocedural_p ());\n+\n+  path_summary summary (path, false);\n+  ASSERT_EQ (summary.get_num_ranges (), 4);\n+\n+  test_diagnostic_context dc;\n+  summary.print (&dc, true);\n+  ASSERT_STREQ\n+    (\"  `factorial': events 1-2 (depth 0)\\n\"\n+     \"    |\\n\"\n+     \"    | (1): entering `factorial'\\n\"\n+     \"    | (2): calling `factorial'\\n\"\n+     \"    |\\n\"\n+     \"    +--> `factorial': events 3-4 (depth 1)\\n\"\n+     \"           |\\n\"\n+     \"           | (3): entering `factorial'\\n\"\n+     \"           | (4): calling `factorial'\\n\"\n+     \"           |\\n\"\n+     \"           +--> `factorial': events 5-6 (depth 2)\\n\"\n+     \"                  |\\n\"\n+     \"                  | (5): entering `factorial'\\n\"\n+     \"                  | (6): calling `factorial'\\n\"\n+     \"                  |\\n\"\n+     \"                  +--> `factorial': event 7 (depth 3)\\n\"\n+     \"                         |\\n\"\n+     \"                         | (7): entering `factorial'\\n\"\n+     \"                         |\\n\",\n+     pp_formatted_text (dc.printer));\n+}\n+\n+/* Run all of the selftests within this file.  */\n+\n+void\n+tree_diagnostic_path_cc_tests ()\n+{\n+  auto_fix_quotes fix_quotes;\n+  pretty_printer *event_pp = global_dc->printer->clone ();\n+  pp_show_color (event_pp) = 0;\n+  test_empty_path (event_pp);\n+  test_intraprocedural_path (event_pp);\n+  test_interprocedural_path_1 (event_pp);\n+  test_interprocedural_path_2 (event_pp);\n+  test_recursion (event_pp);\n+  delete event_pp;\n+}\n+\n+} // namespace selftest\n+\n+#endif /* #if CHECKING_P */"}, {"sha": "8422714aecbc2de2dafad3f8776d4bfc8ccb26e3", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -96,16 +96,17 @@ struct loc_map_pair\n    unwound macro expansion trace.  That's the part generated by this\n    function.  */\n \n-static void\n+void\n maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n-                                 const diagnostic_info *diagnostic,\n                                  location_t where)\n {\n   const struct line_map *map;\n   auto_vec<loc_map_pair> loc_vec;\n   unsigned ix;\n   loc_map_pair loc, *iter;\n \n+  const location_t original_loc = where;\n+\n   map = linemap_lookup (line_table, where);\n   if (!linemap_macro_expansion_map_p (map))\n     return;\n@@ -142,7 +143,7 @@ maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n      first macro which expansion triggered this trace was expanded\n      inside a system header.  */\n   int saved_location_line =\n-    expand_location_to_spelling_point (diagnostic_location (diagnostic)).line;\n+    expand_location_to_spelling_point (original_loc).line;\n \n   if (!LINEMAP_SYSP (ord_map))\n     FOR_EACH_VEC_ELT (loc_vec, ix, iter)\n@@ -238,8 +239,7 @@ void\n virt_loc_aware_diagnostic_finalizer (diagnostic_context *context,\n \t\t\t\t     diagnostic_info *diagnostic)\n {\n-  maybe_unwind_expanded_macro_loc (context, diagnostic,\n-\t\t\t\t   diagnostic_location (diagnostic));\n+  maybe_unwind_expanded_macro_loc (context, diagnostic_location (diagnostic));\n }\n \n /* Default tree printer.   Handles declarations only.  */\n@@ -312,4 +312,6 @@ tree_diagnostics_defaults (diagnostic_context *context)\n   diagnostic_starter (context) = default_tree_diagnostic_starter;\n   diagnostic_finalizer (context) = default_diagnostic_finalizer;\n   diagnostic_format_decoder (context) = default_tree_printer;\n+  context->print_path = default_tree_diagnostic_path_printer;\n+  context->make_json_for_path = default_tree_make_json_for_path;\n }"}, {"sha": "40dc9fa0e8319600feb0e7e833ecd688b5d28574", "filename": "gcc/tree-diagnostic.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftree-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/gcc%2Ftree-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.h?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -57,4 +57,12 @@ void tree_diagnostics_defaults (diagnostic_context *context);\n bool default_tree_printer (pretty_printer *, text_info *, const char *,\n \t\t\t   int, bool, bool, bool, bool *, const char **);\n \n+extern void default_tree_diagnostic_path_printer (diagnostic_context *,\n+\t\t\t\t\t\t  const diagnostic_path *);\n+extern json::value *default_tree_make_json_for_path (diagnostic_context *,\n+\t\t\t\t\t\t     const diagnostic_path *);\n+\n+extern void maybe_unwind_expanded_macro_loc (diagnostic_context *context,\n+\t\t\t\t\t     location_t where);\n+\n #endif /* ! GCC_TREE_DIAGNOSTIC_H */"}, {"sha": "fc22011c7d22b1a9a6dd61324c5fc3b848618f7c", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -1,3 +1,11 @@\n+2020-01-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* include/line-map.h (class diagnostic_path): New forward decl.\n+\t(rich_location::get_path): New accessor.\n+\t(rich_location::set_path): New function.\n+\t(rich_location::m_path): New field.\n+\t* line-map.c (rich_location::rich_location): Initialize m_path.\n+\n 2020-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "dbbc13762e39dbcc9206eda5fe9dc27f18cf7145", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -1432,6 +1432,7 @@ semi_embedded_vec<T, NUM_EMBEDDED>::truncate (int len)\n }\n \n class fixit_hint;\n+class diagnostic_path;\n \n /* A \"rich\" source code location, for use when printing diagnostics.\n    A rich_location has one or more carets&ranges, where the carets\n@@ -1727,6 +1728,10 @@ class rich_location\n     return !m_fixits_cannot_be_auto_applied;\n   }\n \n+  /* An optional path through the code.  */\n+  const diagnostic_path *get_path () const { return m_path; }\n+  void set_path (const diagnostic_path *path) { m_path = path; }\n+\n private:\n   bool reject_impossible_fixit (location_t where);\n   void stop_supporting_fixits ();\n@@ -1751,6 +1756,8 @@ class rich_location\n \n   bool m_seen_impossible_fixit;\n   bool m_fixits_cannot_be_auto_applied;\n+\n+  const diagnostic_path *m_path;\n };\n \n /* A struct for the result of range_label::get_text: a NUL-terminated buffer"}, {"sha": "8a390d0857be2b43ba94b527079b3394a0bdffe1", "filename": "libcpp/line-map.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bc1899b2e883f926dbda02f5b9a2c06ea30090d/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=4bc1899b2e883f926dbda02f5b9a2c06ea30090d", "patch": "@@ -2006,7 +2006,8 @@ rich_location::rich_location (line_maps *set, location_t loc,\n   m_have_expanded_location (false),\n   m_fixit_hints (),\n   m_seen_impossible_fixit (false),\n-  m_fixits_cannot_be_auto_applied (false)\n+  m_fixits_cannot_be_auto_applied (false),\n+  m_path (NULL)\n {\n   add_range (loc, SHOW_RANGE_WITH_CARET, label);\n }"}]}