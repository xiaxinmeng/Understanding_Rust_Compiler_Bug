{"sha": "86fe05e0beee49c54406b267f7ffcaebaf3f6438", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZmZTA1ZTBiZWVlNDljNTQ0MDZiMjY3ZjdmZmNhZWJhZjNmNjQzOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-27T20:21:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-12-27T20:21:02Z"}, "message": "(regno_pointer_align): New variable.\n\n(gen_reg_rtx): Extend regno_pointer_align table.\nAllocate tables in saveable obstack.\n(mark_reg_pointer): New arg, ALIGN.\n(gen_inline_header): New args for reg info.\n(set_new_first_and_last_insn): Set cur_insn_uid.\n({save,restore}_emit_status): Save and restore regno_pointer_align.\n(restore_reg_data{,_1}): Deleted.\n(init_emit): Allocate register tables in saveable obstack.\nSet REGNO_POINTER_ALIGN for regs pointing into frame.\n\nFrom-SVN: r10865", "tree": {"sha": "e16ace481571066974b08dc5e530a9edd9d108ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e16ace481571066974b08dc5e530a9edd9d108ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86fe05e0beee49c54406b267f7ffcaebaf3f6438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fe05e0beee49c54406b267f7ffcaebaf3f6438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86fe05e0beee49c54406b267f7ffcaebaf3f6438", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fe05e0beee49c54406b267f7ffcaebaf3f6438/comments", "author": null, "committer": null, "parents": [{"sha": "ebedb4dd4988b5e225c5b39a039e2e43d8392e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebedb4dd4988b5e225c5b39a039e2e43d8392e36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebedb4dd4988b5e225c5b39a039e2e43d8392e36"}], "stats": {"total": 209, "additions": 61, "deletions": 148}, "files": [{"sha": "6b5732d7ed8d34d85d66012f4e4043a092fe9bdb", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 61, "deletions": 148, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fe05e0beee49c54406b267f7ffcaebaf3f6438/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fe05e0beee49c54406b267f7ffcaebaf3f6438/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=86fe05e0beee49c54406b267f7ffcaebaf3f6438", "patch": "@@ -212,6 +212,11 @@ static char *last_filename = 0;\n char *regno_pointer_flag;\n int regno_pointer_flag_length;\n \n+/* Indexed by pseudo register number, if nonzero gives the known alignment\n+   for that pseudo (if regno_pointer_flag is set).\n+   Allocated in parallel with regno_pointer_flag.  */\n+char *regno_pointer_align;\n+\n /* Indexed by pseudo register number, gives the rtx for that pseudo.\n    Allocated in parallel with regno_pointer_flag.  */\n \n@@ -506,12 +511,17 @@ gen_reg_rtx (mode)\n     {\n       rtx *new1;\n       char *new =\n-\t(char *) oballoc (regno_pointer_flag_length * 2);\n+\t(char *) savealloc (regno_pointer_flag_length * 2);\n       bcopy (regno_pointer_flag, new, regno_pointer_flag_length);\n       bzero (&new[regno_pointer_flag_length], regno_pointer_flag_length);\n       regno_pointer_flag = new;\n \n-      new1 = (rtx *) oballoc (regno_pointer_flag_length * 2 * sizeof (rtx));\n+      new = (char *) savealloc (regno_pointer_flag_length * 2);\n+      bcopy (regno_pointer_align, new, regno_pointer_flag_length);\n+      bzero (&new[regno_pointer_flag_length], regno_pointer_flag_length);\n+      regno_pointer_align = new;\n+\n+      new1 = (rtx *) savealloc (regno_pointer_flag_length * 2 * sizeof (rtx));\n       bcopy ((char *) regno_reg_rtx, (char *) new1,\n \t     regno_pointer_flag_length * sizeof (rtx));\n       bzero ((char *) &new1[regno_pointer_flag_length],\n@@ -526,13 +536,18 @@ gen_reg_rtx (mode)\n   return val;\n }\n \n-/* Identify REG as a probable pointer register.  */\n+/* Identify REG as a probable pointer register and show its alignment\n+   as ALIGN, if nonzero.  */\n \n void\n-mark_reg_pointer (reg)\n+mark_reg_pointer (reg, align)\n      rtx reg;\n+     int align;\n {\n   REGNO_POINTER_FLAG (REGNO (reg)) = 1;\n+\n+  if (align)\n+    REGNO_POINTER_ALIGN (REGNO (reg)) = align;\n }\n \n /* Return 1 plus largest pseudo reg number used in the current function.  */\n@@ -1355,7 +1370,8 @@ gen_inline_header_rtx (first_insn, first_parm_insn, first_labelno,\n \t\t       last_labelno, max_parm_regnum, max_regnum, args_size,\n \t\t       pops_args, stack_slots, forced_labels, function_flags,\n \t\t       outgoing_args_size, original_arg_vector,\n-\t\t       original_decl_initial)\n+\t\t       original_decl_initial, regno_rtx, regno_flag,\n+\t\t       regno_align)\n      rtx first_insn, first_parm_insn;\n      int first_labelno, last_labelno, max_parm_regnum, max_regnum, args_size;\n      int pops_args;\n@@ -1365,27 +1381,40 @@ gen_inline_header_rtx (first_insn, first_parm_insn, first_labelno,\n      int outgoing_args_size;\n      rtvec original_arg_vector;\n      rtx original_decl_initial;\n+     rtvec regno_rtx;\n+     char *regno_flag;\n+     char *regno_align;\n {\n   rtx header = gen_rtx (INLINE_HEADER, VOIDmode,\n \t\t\tcur_insn_uid++, NULL_RTX,\n \t\t\tfirst_insn, first_parm_insn,\n \t\t\tfirst_labelno, last_labelno,\n \t\t\tmax_parm_regnum, max_regnum, args_size, pops_args,\n \t\t\tstack_slots, forced_labels, function_flags,\n-\t\t\toutgoing_args_size,\n-\t\t\toriginal_arg_vector, original_decl_initial);\n+\t\t\toutgoing_args_size, original_arg_vector,\n+\t\t\toriginal_decl_initial,\n+\t\t\tregno_rtx, regno_flag, regno_align);\n   return header;\n }\n \n /* Install new pointers to the first and last insns in the chain.\n+   Also, set cur_insn_uid to one higher than the last in use.\n    Used for an inline-procedure after copying the insn chain.  */\n \n void\n set_new_first_and_last_insn (first, last)\n      rtx first, last;\n {\n+  rtx insn;\n+\n   first_insn = first;\n   last_insn = last;\n+  cur_insn_uid = 0;\n+\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    cur_insn_uid = MAX (cur_insn_uid, INSN_UID (insn));\n+\n+  cur_insn_uid++;\n }\n \n /* Set the range of label numbers found in the current function.\n@@ -1417,6 +1446,7 @@ save_emit_status (p)\n   p->last_linenum = last_linenum;\n   p->last_filename = last_filename;\n   p->regno_pointer_flag = regno_pointer_flag;\n+  p->regno_pointer_align = regno_pointer_align;\n   p->regno_pointer_flag_length = regno_pointer_flag_length;\n   p->regno_reg_rtx = regno_reg_rtx;\n }\n@@ -1441,6 +1471,7 @@ restore_emit_status (p)\n   last_linenum = p->last_linenum;\n   last_filename = p->last_filename;\n   regno_pointer_flag = p->regno_pointer_flag;\n+  regno_pointer_align = p->regno_pointer_align;\n   regno_pointer_flag_length = p->regno_pointer_flag_length;\n   regno_reg_rtx = p->regno_reg_rtx;\n \n@@ -3091,145 +3122,6 @@ gen_sequence ()\n   return result;\n }\n \f\n-/* Set up regno_reg_rtx, reg_rtx_no and regno_pointer_flag\n-   according to the chain of insns starting with FIRST.\n-\n-   Also set cur_insn_uid to exceed the largest uid in that chain.\n-\n-   This is used when an inline function's rtl is saved\n-   and passed to rest_of_compilation later.  */\n-\n-static void restore_reg_data_1 ();\n-\n-void\n-restore_reg_data (first)\n-     rtx first;\n-{\n-  register rtx insn;\n-  int i;\n-  register int max_uid = 0;\n-\n-  for (insn = first; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (INSN_UID (insn) >= max_uid)\n-\tmax_uid = INSN_UID (insn);\n-\n-      switch (GET_CODE (insn))\n-\t{\n-\tcase NOTE:\n-\tcase CODE_LABEL:\n-\tcase BARRIER:\n-\t  break;\n-\n-\tcase JUMP_INSN:\n-\tcase CALL_INSN:\n-\tcase INSN:\n-\t  restore_reg_data_1 (PATTERN (insn));\n-\t  break;\n-\t}\n-    }\n-\n-  /* Don't duplicate the uids already in use.  */\n-  cur_insn_uid = max_uid + 1;\n-\n-  /* If any regs are missing, make them up.  \n-\n-     ??? word_mode is not necessarily the right mode.  Most likely these REGs\n-     are never used.  At some point this should be checked.  */\n-\n-  for (i = FIRST_PSEUDO_REGISTER; i < reg_rtx_no; i++)\n-    if (regno_reg_rtx[i] == 0)\n-      regno_reg_rtx[i] = gen_rtx (REG, word_mode, i);\n-}\n-\n-static void\n-restore_reg_data_1 (orig)\n-     rtx orig;\n-{\n-  register rtx x = orig;\n-  register int i;\n-  register enum rtx_code code;\n-  register char *format_ptr;\n-\n-  code = GET_CODE (x);\n-\n-  switch (code)\n-    {\n-    case QUEUED:\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case SYMBOL_REF:\n-    case CODE_LABEL:\n-    case PC:\n-    case CC0:\n-    case LABEL_REF:\n-      return;\n-\n-    case REG:\n-      if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n-\t{\n-\t  /* Make sure regno_pointer_flag and regno_reg_rtx are large\n-\t     enough to have an element for this pseudo reg number.  */\n-\t  if (REGNO (x) >= reg_rtx_no)\n-\t    {\n-\t      reg_rtx_no = REGNO (x);\n-\n-\t      if (reg_rtx_no >= regno_pointer_flag_length)\n-\t\t{\n-\t\t  int newlen = MAX (regno_pointer_flag_length * 2,\n-\t\t\t\t    reg_rtx_no + 30);\n-\t\t  rtx *new1;\n-\t\t  char *new = (char *) oballoc (newlen);\n-\t\t  bzero (new, newlen);\n-\t\t  bcopy (regno_pointer_flag, new, regno_pointer_flag_length);\n-\n-\t\t  new1 = (rtx *) oballoc (newlen * sizeof (rtx));\n-\t\t  bzero ((char *) new1, newlen * sizeof (rtx));\n-\t\t  bcopy ((char *) regno_reg_rtx, (char *) new1,\n-\t\t\t regno_pointer_flag_length * sizeof (rtx));\n-\n-\t\t  regno_pointer_flag = new;\n-\t\t  regno_reg_rtx = new1;\n-\t\t  regno_pointer_flag_length = newlen;\n-\t\t}\n-\t      reg_rtx_no ++;\n-\t    }\n-\t  regno_reg_rtx[REGNO (x)] = x;\n-\t}\n-      return;\n-\n-    case MEM:\n-      if (GET_CODE (XEXP (x, 0)) == REG)\n-\tmark_reg_pointer (XEXP (x, 0));\n-      restore_reg_data_1 (XEXP (x, 0));\n-      return;\n-    }\n-\n-  /* Now scan the subexpressions recursively.  */\n-\n-  format_ptr = GET_RTX_FORMAT (code);\n-\n-  for (i = 0; i < GET_RTX_LENGTH (code); i++)\n-    {\n-      switch (*format_ptr++)\n-\t{\n-\tcase 'e':\n-\t  restore_reg_data_1 (XEXP (x, i));\n-\t  break;\n-\n-\tcase 'E':\n-\t  if (XVEC (x, i) != NULL)\n-\t    {\n-\t      register int j;\n-\n-\t      for (j = 0; j < XVECLEN (x, i); j++)\n-\t\trestore_reg_data_1 (XVECEXP (x, i, j));\n-\t    }\n-\t  break;\n-\t}\n-    }\n-}\n-\f\n /* Initialize data structures and variables in this file\n    before generating rtl for each function.  */\n \n@@ -3259,11 +3151,15 @@ init_emit ()\n   regno_pointer_flag_length = LAST_VIRTUAL_REGISTER + 101;\n \n   regno_pointer_flag \n-    = (char *) oballoc (regno_pointer_flag_length);\n+    = (char *) savealloc (regno_pointer_flag_length);\n   bzero (regno_pointer_flag, regno_pointer_flag_length);\n \n+  regno_pointer_align\n+    = (char *) savealloc (regno_pointer_flag_length);\n+  bzero (regno_pointer_align, regno_pointer_flag_length);\n+\n   regno_reg_rtx \n-    = (rtx *) oballoc (regno_pointer_flag_length * sizeof (rtx));\n+    = (rtx *) savealloc (regno_pointer_flag_length * sizeof (rtx));\n   bzero ((char *) regno_reg_rtx, regno_pointer_flag_length * sizeof (rtx));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n@@ -3284,6 +3180,23 @@ init_emit ()\n   REGNO_POINTER_FLAG (VIRTUAL_STACK_DYNAMIC_REGNUM) = 1;\n   REGNO_POINTER_FLAG (VIRTUAL_OUTGOING_ARGS_REGNUM) = 1;\n \n+#ifdef STACK_BOUNDARY\n+  REGNO_POINTER_ALIGN (STACK_POINTER_REGNUM) = STACK_BOUNDARY / BITS_PER_UNIT;\n+  REGNO_POINTER_ALIGN (FRAME_POINTER_REGNUM) = STACK_BOUNDARY / BITS_PER_UNIT;\n+  REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM)\n+    = STACK_BOUNDARY / BITS_PER_UNIT;\n+  REGNO_POINTER_ALIGN (ARG_POINTER_REGNUM) = STACK_BOUNDARY / BITS_PER_UNIT;\n+\n+  REGNO_POINTER_ALIGN (VIRTUAL_INCOMING_ARGS_REGNUM)\n+    = STACK_BOUNDARY / BITS_PER_UNIT;\n+  REGNO_POINTER_ALIGN (VIRTUAL_STACK_VARS_REGNUM)\n+    = STACK_BOUNDARY / BITS_PER_UNIT;\n+  REGNO_POINTER_ALIGN (VIRTUAL_STACK_DYNAMIC_REGNUM)\n+    = STACK_BOUNDARY / BITS_PER_UNIT;\n+  REGNO_POINTER_ALIGN (VIRTUAL_OUTGOING_ARGS_REGNUM)\n+    = STACK_BOUNDARY / BITS_PER_UNIT;\n+#endif\n+\n #ifdef INIT_EXPANDERS\n   INIT_EXPANDERS;\n #endif"}]}