{"sha": "d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBlYmRkOWZjZTAwZjVmYmZlYzYxNWQ3MmYxZGVkZjBjZDc3NjJhNg==", "commit": {"author": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2018-05-25T22:29:17Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2018-05-25T22:29:17Z"}, "message": "RISC-V: Add interrupt attribute support.\n\n\tgcc/\n\t* config/riscv/riscv-protos.h (riscv_epilogue_uses): New.\n\t* config/riscv/riscv.c (struct machine_function): Add\n\tinterrupt_handler_p and attribute_checked_p fields.\n\t(riscv_attribute_table): Add interrupt.\n\t(riscv_interrupt_type_p): New.\n\t(riscv_save_reg_p): Save extra regs for interrupt handler.\n\t(riscv_use_save_libcall): Return false  for interrupt handler.\n\t(riscv_first_stack_step): Add forward declaration.\n\t(riscv_compute_frame_info): New local interrupt_save_t1.  Set it\n\tfor interrupt handler with large frame.  Use it for saved reg list.\n\t(riscv_expand_prologue): Move flag_stack_usage_info support to\n\teliminate duplication.\n\t(riscv_expand_epilogue): Generate mret for interrupt handler.\n\t(riscv_epilogue_uses): New.\n\t(riscv_can_use_return_insn): Return false for interrupt handler.\n\t(riscv_function_ok_for_sibcall): Likewise.\n\t(riscv_set_current_function): Add interrupt handler support.\n\t* config/riscv/riscv.h (EPILOGUE_USES): Call riscv_epilogue_uses.\n\t* config/riscv/riscv.md (UNSPECV_MRET): New.\n\t(GP_REGNUM): New.\n\t(riscv_frflags, riscv_fsflags): Use tab after opcode.\n\t(riscv_mret): New.\n\t* doc/extend.texi (RISC-V Function Attributes) <interrupt>: New.\n\n\tgcc/testsuite/\n\t* gcc.target/riscv/interrupt-1.c: New.\n\t* gcc.target/riscv/interrupt-2.c: New.\n\t* gcc.target/riscv/interrupt-3.c: New.\n\t* gcc.target/riscv/interrupt-4.c: New.\n\t* gcc.target/riscv/interrupt-5.c: New.\n\nFrom-SVN: r260785", "tree": {"sha": "fd44a708cc3f3ebbd9eab6e79f8573f972a67663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd44a708cc3f3ebbd9eab6e79f8573f972a67663"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/comments", "author": null, "committer": null, "parents": [{"sha": "c0e8f02b27afc1a07f30a7597f8ae34094821f9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e8f02b27afc1a07f30a7597f8ae34094821f9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e8f02b27afc1a07f30a7597f8ae34094821f9d"}], "stats": {"total": 251, "additions": 233, "deletions": 18}, "files": [{"sha": "b6836872b0bb8088c18f508ddfee47a9940ade0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -1,3 +1,29 @@\n+2018-05-25  Jim Wilson  <jimw@sifive.com>\n+\n+\t* config/riscv/riscv-protos.h (riscv_epilogue_uses): New.\n+\t* config/riscv/riscv.c (struct machine_function): Add\n+\tinterrupt_handler_p and attribute_checked_p fields.\n+\t(riscv_attribute_table): Add interrupt.\n+\t(riscv_interrupt_type_p): New.\n+\t(riscv_save_reg_p): Save extra regs for interrupt handler.\n+\t(riscv_use_save_libcall): Return false  for interrupt handler.\n+\t(riscv_first_stack_step): Add forward declaration.\n+\t(riscv_compute_frame_info): New local interrupt_save_t1.  Set it\n+\tfor interrupt handler with large frame.  Use it for saved reg list.\n+\t(riscv_expand_prologue): Move flag_stack_usage_info support to\n+\teliminate duplication.\n+\t(riscv_expand_epilogue): Generate mret for interrupt handler.\n+\t(riscv_epilogue_uses): New.\n+\t(riscv_can_use_return_insn): Return false for interrupt handler.\n+\t(riscv_function_ok_for_sibcall): Likewise.\n+\t(riscv_set_current_function): Add interrupt handler support.\n+\t* config/riscv/riscv.h (EPILOGUE_USES): Call riscv_epilogue_uses.\n+\t* config/riscv/riscv.md (UNSPECV_MRET): New.\n+\t(GP_REGNUM): New.\n+\t(riscv_frflags, riscv_fsflags): Use tab after opcode.\n+\t(riscv_mret): New.\n+\t* doc/extend.texi (RISC-V Function Attributes) <interrupt>: New.\n+\n 2018-05-25  Bill Schmidt  <wschmidt@linux.ibm.com>\n \n \tPR tree-optimization/85712"}, {"sha": "a194b192a2b60c6937843a934eb17b74fa83d550", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -67,6 +67,7 @@ extern rtx riscv_return_addr (int, rtx);\n extern HOST_WIDE_INT riscv_initial_elimination_offset (int, int);\n extern void riscv_expand_prologue (void);\n extern void riscv_expand_epilogue (bool);\n+extern bool riscv_epilogue_uses (unsigned int);\n extern bool riscv_can_use_return_insn (void);\n extern rtx riscv_function_value (const_tree, const_tree, enum machine_mode);\n extern bool riscv_expand_block_move (rtx, rtx, rtx);"}, {"sha": "7ea2657d8c88070392d949fb947d2a3b0e754e6a", "filename": "gcc/config/riscv/riscv.c", "status": "modified", "additions": 112, "deletions": 15, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fconfig%2Friscv%2Friscv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fconfig%2Friscv%2Friscv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.c?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -130,6 +130,12 @@ struct GTY(())  machine_function {\n   /* True if current function is a naked function.  */\n   bool naked_p;\n \n+  /* True if current function is an interrupt function.  */\n+  bool interrupt_handler_p;\n+\n+  /* True if attributes on current function have been checked.  */\n+  bool attributes_checked_p;\n+\n   /* The current frame information, calculated by riscv_compute_frame_info.  */\n   struct riscv_frame_info frame;\n };\n@@ -287,6 +293,8 @@ static const struct attribute_spec riscv_attribute_table[] =\n   /* The attribute telling no prologue/epilogue.  */\n   { \"naked\",\t0,  0, true, false, false, false,\n     riscv_handle_fndecl_attribute, NULL },\n+  /* This attribute generates prologue/epilogue for interrupt handlers.  */\n+  { \"interrupt\", 0, 0, false, true, true, false, NULL, NULL },\n \n   /* The last attribute spec is set to be NULL.  */\n   { NULL,\t0,  0, false, false, false, false, NULL, NULL }\n@@ -2713,7 +2721,14 @@ riscv_handle_fndecl_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n-/* Return true if func is a naked function.  */\n+/* Return true if funcion TYPE is an interrupt function.  */\n+static bool\n+riscv_interrupt_type_p (tree type)\n+{\n+  return lookup_attribute (\"interrupt\", TYPE_ATTRIBUTES (type)) != NULL;\n+}\n+\n+/* Return true if FUNC is a naked function.  */\n static bool\n riscv_naked_function_p (tree func)\n {\n@@ -3219,14 +3234,37 @@ riscv_save_reg_p (unsigned int regno)\n   if (regno == RETURN_ADDR_REGNUM && crtl->calls_eh_return)\n     return true;\n \n+  /* If this is an interrupt handler, then must save extra registers.  */\n+  if (cfun->machine->interrupt_handler_p)\n+    {\n+      /* zero register is always zero.  */\n+      if (regno == GP_REG_FIRST)\n+\treturn false;\n+\n+      /* The function will return the stack pointer to its original value.  */\n+      if (regno == STACK_POINTER_REGNUM)\n+\treturn false;\n+\n+      /* By convention, we assume that gp and tp are safe.  */\n+      if (regno == GP_REGNUM || regno == THREAD_POINTER_REGNUM)\n+\treturn false;\n+\n+      /* We must save every register used in this function.  If this is not a\n+\t leaf function, then we must save all temporary registers.  */\n+      if (df_regs_ever_live_p (regno)\n+\t  || (!crtl->is_leaf && call_used_regs[regno]))\n+\treturn true;\n+    }\n+\n   return false;\n }\n \n /* Determine whether to call GPR save/restore routines.  */\n static bool\n riscv_use_save_libcall (const struct riscv_frame_info *frame)\n {\n-  if (!TARGET_SAVE_RESTORE || crtl->calls_eh_return || frame_pointer_needed)\n+  if (!TARGET_SAVE_RESTORE || crtl->calls_eh_return || frame_pointer_needed\n+      || cfun->machine->interrupt_handler_p)\n     return false;\n \n   return frame->save_libcall_adjustment != 0;\n@@ -3285,21 +3323,35 @@ riscv_save_libcall_count (unsigned mask)\n    They decrease stack_pointer_rtx but leave frame_pointer_rtx and\n    hard_frame_pointer_rtx unchanged.  */\n \n+static HOST_WIDE_INT riscv_first_stack_step (struct riscv_frame_info *frame);\n+\n static void\n riscv_compute_frame_info (void)\n {\n   struct riscv_frame_info *frame;\n   HOST_WIDE_INT offset;\n+  bool interrupt_save_t1 = false;\n   unsigned int regno, i, num_x_saved = 0, num_f_saved = 0;\n \n   frame = &cfun->machine->frame;\n+\n+  /* In an interrupt function, if we have a large frame, then we need to\n+     save/restore t1.  We check for this before clearing the frame struct.  */\n+  if (cfun->machine->interrupt_handler_p)\n+    {\n+      HOST_WIDE_INT step1 = riscv_first_stack_step (frame);\n+      if (! SMALL_OPERAND (frame->total_size - step1))\n+\tinterrupt_save_t1 = true;\n+    }\n+\n   memset (frame, 0, sizeof (*frame));\n \n   if (!cfun->machine->naked_p)\n     {\n       /* Find out which GPRs we need to save.  */\n       for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n-\tif (riscv_save_reg_p (regno))\n+\tif (riscv_save_reg_p (regno)\n+\t    || (interrupt_save_t1 && (regno == T1_REGNUM)))\n \t  frame->mask |= 1 << (regno - GP_REG_FIRST), num_x_saved++;\n \n       /* If this function calls eh_return, we must also save and restore the\n@@ -3612,17 +3664,12 @@ riscv_expand_prologue (void)\n   unsigned mask = frame->mask;\n   rtx insn;\n \n-  if (cfun->machine->naked_p)\n-    {\n-      if (flag_stack_usage_info)\n-\tcurrent_function_static_stack_size = 0;\n-\n-      return;\n-    }\n-\n   if (flag_stack_usage_info)\n     current_function_static_stack_size = size;\n \n+  if (cfun->machine->naked_p)\n+    return;\n+\n   /* When optimizing for size, call a subroutine to save the registers.  */\n   if (riscv_use_save_libcall (frame))\n     {\n@@ -3859,18 +3906,42 @@ riscv_expand_epilogue (bool sibcall_p)\n     emit_insn (gen_add3_insn (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t      EH_RETURN_STACKADJ_RTX));\n \n-  if (!sibcall_p)\n+  /* Return from interrupt.  */\n+  if (cfun->machine->interrupt_handler_p)\n+    emit_insn (gen_riscv_mret ());\n+  else if (!sibcall_p)\n     emit_jump_insn (gen_simple_return_internal (ra));\n }\n \n+/* Implement EPILOGUE_USES.  */\n+\n+bool\n+riscv_epilogue_uses (unsigned int regno)\n+{\n+  if (regno == RETURN_ADDR_REGNUM)\n+    return true;\n+\n+  if (epilogue_completed && cfun->machine->interrupt_handler_p)\n+    {\n+      /* An interrupt function restores temp regs, so we must indicate that\n+\t they are live at function end.  */\n+      if (df_regs_ever_live_p (regno)\n+\t    || (!crtl->is_leaf && call_used_regs[regno]))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Return nonzero if this function is known to have a null epilogue.\n    This allows the optimizer to omit jumps to jumps if no stack\n    was created.  */\n \n bool\n riscv_can_use_return_insn (void)\n {\n-  return reload_completed && cfun->machine->frame.total_size == 0;\n+  return (reload_completed && cfun->machine->frame.total_size == 0\n+\t  && ! cfun->machine->interrupt_handler_p);\n }\n \n /* Implement TARGET_SECONDARY_MEMORY_NEEDED.\n@@ -4366,10 +4437,14 @@ riscv_function_ok_for_sibcall (tree decl ATTRIBUTE_UNUSED,\n   if (TARGET_SAVE_RESTORE)\n     return false;\n \n-  /* Don't use sibcall for naked function.  */\n+  /* Don't use sibcall for naked functions.  */\n   if (cfun->machine->naked_p)\n     return false;\n \n+  /* Don't use sibcall for interrupt functions.  */\n+  if (cfun->machine->interrupt_handler_p)\n+    return false;\n+\n   return true;\n }\n \n@@ -4381,10 +4456,32 @@ riscv_set_current_function (tree decl)\n   if (decl == NULL_TREE\n       || current_function_decl == NULL_TREE\n       || current_function_decl == error_mark_node\n-      || !cfun->machine)\n+      || ! cfun->machine\n+      || cfun->machine->attributes_checked_p)\n     return;\n \n   cfun->machine->naked_p = riscv_naked_function_p (decl);\n+  cfun->machine->interrupt_handler_p\n+    = riscv_interrupt_type_p (TREE_TYPE (decl));\n+\n+  if (cfun->machine->naked_p && cfun->machine->interrupt_handler_p)\n+    error (\"function attributes %qs and %qs are mutually exclusive\",\n+\t   \"interrupt\", \"naked\");\n+\n+  if (cfun->machine->interrupt_handler_p)\n+    {\n+      tree args = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+      tree ret = TREE_TYPE (TREE_TYPE (decl));\n+\n+      if (TREE_CODE (ret) != VOID_TYPE)\n+\terror (\"%qs function cannot return a value\", \"interrupt\");\n+\n+      if (args && TREE_CODE (TREE_VALUE (args)) != VOID_TYPE)\n+\terror (\"%qs function cannot have arguments\", \"interrupt\");\n+    }\n+\n+  /* Don't print the above diagnostics more than once.  */\n+  cfun->machine->attributes_checked_p = 1;\n }\n \n /* Implement TARGET_CANNOT_COPY_INSN_P.  */"}, {"sha": "5651d1727f8f33c7ed4d2d381588a261d058451b", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -538,7 +538,7 @@ typedef struct {\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n   memset (&(CUM), 0, sizeof (CUM))\n \n-#define EPILOGUE_USES(REGNO)\t((REGNO) == RETURN_ADDR_REGNUM)\n+#define EPILOGUE_USES(REGNO)\triscv_epilogue_uses (REGNO)\n \n /* Align based on stack boundary, which might have been set by the user.  */\n #define RISCV_STACK_ALIGN(LOC) \\"}, {"sha": "fa681971c4c4ff042386c63d9f3bebee02316b7a", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -56,6 +56,9 @@\n   UNSPECV_FRFLAGS\n   UNSPECV_FSFLAGS\n \n+  ;; Interrupt handler instructions.\n+  UNSPECV_MRET\n+\n   ;; Blockage and synchronization.\n   UNSPECV_BLOCKAGE\n   UNSPECV_FENCE\n@@ -64,6 +67,7 @@\n \n (define_constants\n   [(RETURN_ADDR_REGNUM\t\t1)\n+   (GP_REGNUM \t\t\t3)\n    (T0_REGNUM\t\t\t5)\n    (T1_REGNUM\t\t\t6)\n    (S0_REGNUM\t\t\t8)\n@@ -2267,12 +2271,17 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(unspec_volatile [(const_int 0)] UNSPECV_FRFLAGS))]\n   \"TARGET_HARD_FLOAT\"\n-  \"frflags %0\")\n+  \"frflags\\t%0\")\n \n (define_insn \"riscv_fsflags\"\n   [(unspec_volatile [(match_operand:SI 0 \"csr_operand\" \"rK\")] UNSPECV_FSFLAGS)]\n   \"TARGET_HARD_FLOAT\"\n-  \"fsflags %0\")\n+  \"fsflags\\t%0\")\n+\n+(define_insn \"riscv_mret\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_MRET)]\n+  \"\"\n+  \"mret\")\n \n (define_insn \"stack_tie<mode>\"\n   [(set (mem:BLK (scratch))"}, {"sha": "c6d23b5b8e5553a7ff76cf4083cac2cd0a1894e7", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -5141,6 +5141,12 @@ prologue/epilogue sequences generated by the compiler. Only basic\n (@pxref{Basic Asm}). While using extended @code{asm} or a mixture of\n basic @code{asm} and C code may appear to work, they cannot be\n depended upon to work reliably and are not supported.\n+\n+@item interrupt\n+@cindex @code{interrupt} function attribute, RISC-V\n+Use this attribute to indicate that the specified function is an interrupt\n+handler.  The compiler generates function entry and exit sequences suitable\n+for use in an interrupt handler when this attribute is present.\n @end table\n \n @node RL78 Function Attributes"}, {"sha": "4f38b53b5892d9b451be7f360781f93b4c612d29", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -1,3 +1,11 @@\n+2018-05-25  Jim Wilson  <jimw@sifive.com>\n+\n+\t* gcc.target/riscv/interrupt-1.c: New.\n+\t* gcc.target/riscv/interrupt-2.c: New.\n+\t* gcc.target/riscv/interrupt-3.c: New.\n+\t* gcc.target/riscv/interrupt-4.c: New.\n+\t* gcc.target/riscv/interrupt-5.c: New.\n+\n 2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/85786"}, {"sha": "666b29a49bb8cd8989c1009ce81559afc118c95b", "filename": "gcc/testsuite/gcc.target/riscv/interrupt-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-1.c?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -0,0 +1,8 @@\n+/* Verify the return instruction is mret.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+void __attribute__ ((interrupt))\n+foo (void)\n+{\n+}\n+/* { dg-final { scan-assembler \"mret\" } } */"}, {"sha": "9559007e4aef96022fb2d1d92758cc59b158bf08", "filename": "gcc/testsuite/gcc.target/riscv/interrupt-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-2.c?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -0,0 +1,17 @@\n+/* Verify that arg regs used as temporaries get saved.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+void __attribute__ ((interrupt))\n+foo2 (void)\n+{\n+  extern volatile int INTERRUPT_FLAG;\n+  INTERRUPT_FLAG = 0;\n+\n+  extern volatile int COUNTER;\n+#ifdef __riscv_atomic\n+  __atomic_fetch_add (&COUNTER, 1, __ATOMIC_RELAXED);\n+#else\n+  COUNTER++;\n+#endif\n+}\n+/* { dg-final { scan-assembler-times \"s\\[wd\\]\\ta\\[0-7\\],\\[0-9\\]+\\\\(sp\\\\)\" 2 } } */"}, {"sha": "bc9e0c14f05f7eca7dc0dd01762105f75ae51e29", "filename": "gcc/testsuite/gcc.target/riscv/interrupt-3.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-3.c?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -0,0 +1,9 @@\n+/* Verify t1 is saved before use.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -fomit-frame-pointer\" } */\n+void __attribute__ ((interrupt))\n+foo (void)\n+{\n+  char array[4096];\n+}\n+/* { dg-final { scan-assembler \"s\\[wd\\]\\tt1\" } } */"}, {"sha": "b6fdd19095c082af900ec3f4153e67b72d713bfd", "filename": "gcc/testsuite/gcc.target/riscv/interrupt-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-4.c?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -0,0 +1,18 @@\n+/* Verify t1 is saved before use.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -fomit-frame-pointer\" } */\n+void __attribute__ ((interrupt))\n+foo2 (void)\n+{\n+  char array[4096];\n+  extern volatile int INTERRUPT_FLAG;\n+  INTERRUPT_FLAG = 0;\n+\n+  extern volatile int COUNTER;\n+#ifdef __riscv_atomic\n+  __atomic_fetch_add (&COUNTER, 1, __ATOMIC_RELAXED);\n+#else\n+  COUNTER++;\n+#endif\n+}\n+/* { dg-final { scan-assembler \"s\\[wd\\]\\tt1\" } } */"}, {"sha": "bf65e988c4e763d4a3220025f3e973c6890e9353", "filename": "gcc/testsuite/gcc.target/riscv/interrupt-5.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Finterrupt-5.c?ref=d0ebdd9fce00f5fbfec615d72f1dedf0cd7762a6", "patch": "@@ -0,0 +1,16 @@\n+/* Verify proper errors are generated for invalid code.  */\n+int __attribute__ ((interrupt))\n+sub0 (void)\n+{ /* { dg-error \"function cannot return a value\" } */\n+  return 10;\n+}\n+\n+void __attribute__ ((interrupt))\n+sub1 (int i)\n+{ /* { dg-error \"function cannot have arguments\" } */\n+}\n+\n+void __attribute__ ((interrupt, naked))\n+sub2 (void)\n+{ /* { dg-error \"are mutually exclusive\" } */\n+}"}]}