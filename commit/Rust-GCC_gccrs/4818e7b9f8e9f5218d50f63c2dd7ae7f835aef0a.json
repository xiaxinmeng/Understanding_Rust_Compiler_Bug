{"sha": "4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgxOGU3YjlmOGU5ZjUyMThkNTBmNjNjMmRkN2FlN2Y4MzVhZWYwYQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2010-10-21T10:33:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-21T10:33:36Z"}, "message": "einfo.ads, einfo.adb: Add handling of predicates.\n\n2010-10-21  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads, einfo.adb: Add handling of predicates.\n\tRework handling of invariants.\n\t* exp_ch3.adb, exp_ch4.adb, exp_util.adb, sem_ch6.adb: Minor changes to\n\thanding of invariants.\n\t* par-prag.adb: Add dummy entry for pragma Predicate\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing for\n\tPredicate aspects.\n\t* sem_prag.adb: Add implementation of pragma Predicate.\n\t* snames.ads-tmpl: Add entries for pragma Predicate.\n\n2010-10-21  Robert Dewar  <dewar@adacore.com>\n\n\t* elists.adb: Minor reformatting.\n\nFrom-SVN: r165764", "tree": {"sha": "863959b3591a8287474cac0afa935f60a6b29c92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/863959b3591a8287474cac0afa935f60a6b29c92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/comments", "author": null, "committer": null, "parents": [{"sha": "fd0ff1cf7e35b91797be21997ab3d75f3b980873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd0ff1cf7e35b91797be21997ab3d75f3b980873", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd0ff1cf7e35b91797be21997ab3d75f3b980873"}], "stats": {"total": 680, "additions": 594, "deletions": 86}, "files": [{"sha": "907bac8ff93f9e2c22d7981a8e7e2b6c9672f085", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -1,3 +1,21 @@\n+2010-10-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads, einfo.adb: Replace Predicate_Procedure by\n+\tPredicate_Functions.\n+\t* exp_ch4.adb (Expand_N_In): Handle predicates.\n+\t* exp_util.ads, exp_util.adb (Make_Predicate_Call): New function.\n+\t(Make_Predicate_Check): New function.\n+\t* freeze.adb (Freee_Entity): Build predicate function if needed.\n+\t* sem_ch13.adb (Build_Predicate_Function): New procedure.\n+\t(Analyze_Aspect_Specifications): No third argument for Predicate pragma\n+\tbuilt from Predicate aspect.\n+\t* sem_ch13.ads (Build_Predicate_Function): New procedure.\n+\t* sem_ch3.adb: Add handling for predicates.\n+\t* sem_eval.adb (Eval_Membership_Op): Never static if predicate\n+\tfunctions around.\n+\t* sem_prag.adb (Analye_Pragma, case Predicate): Does not take a third\n+\targument.\n+\n 2010-10-21  Robert Dewar  <dewar@adacore.com>\n \n \t* einfo.ads, einfo.adb: Add handling of predicates."}, {"sha": "d8e2a7a25c090dddd8fc58361f1947303ace28ba", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -1411,7 +1411,7 @@ package body Einfo is\n \n    function Has_Predicates (Id : E) return B is\n    begin\n-      pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Procedure);\n+      pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Function);\n       return Flag250 (Id);\n    end Has_Predicates;\n \n@@ -3864,7 +3864,7 @@ package body Einfo is\n    procedure Set_Has_Predicates (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id)\n-        or else Ekind (Id) = E_Procedure\n+        or else Ekind (Id) = E_Function\n         or else Ekind (Id) = E_Void);\n       Set_Flag250 (Id, V);\n    end Set_Has_Predicates;\n@@ -6265,15 +6265,15 @@ package body Einfo is\n         Ekind (Id) = E_Generic_Package;\n    end Is_Package_Or_Generic_Package;\n \n-   -------------------------\n-   -- Predicate_Procedure --\n-   -------------------------\n+   ------------------------\n+   -- Predicate_Function --\n+   ------------------------\n \n-   function Predicate_Procedure (Id : E) return E is\n+   function Predicate_Function (Id : E) return E is\n       S : Entity_Id;\n \n    begin\n-      pragma Assert (Is_Type (Id) and then Has_Predicates (Id));\n+      pragma Assert (Is_Type (Id));\n \n       if No (Subprograms_For_Type (Id)) then\n          return Empty;\n@@ -6290,7 +6290,7 @@ package body Einfo is\n \n          return Empty;\n       end if;\n-   end Predicate_Procedure;\n+   end Predicate_Function;\n \n    ---------------\n    -- Is_Prival --\n@@ -6860,11 +6860,11 @@ package body Einfo is\n       Set_Subprograms_For_Type (Id, V);\n    end Set_Invariant_Procedure;\n \n-   -----------------------------\n-   -- Set_Predicate_Procedure --\n-   -----------------------------\n+   ----------------------------\n+   -- Set_Predicate_Function --\n+   ----------------------------\n \n-   procedure Set_Predicate_Procedure (Id : E; V : E) is\n+   procedure Set_Predicate_Function (Id : E; V : E) is\n       S : Entity_Id;\n \n    begin\n@@ -6882,7 +6882,7 @@ package body Einfo is\n       end loop;\n \n       Set_Subprograms_For_Type (Id, V);\n-   end Set_Predicate_Procedure;\n+   end Set_Predicate_Function;\n \n    -----------------\n    -- Size_Clause --"}, {"sha": "189e1c5cbc01bb6d282205457a327a2cef455678", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -1677,7 +1677,7 @@ package Einfo is\n --       Present in type and subtype entities and in subprogram entities. Set\n --       if a pragma Predicate or Predicate aspect applies to the type, or if\n --       it inherits a Predicate aspect from its parent or progenitor types.\n---       Also set in the predicate procedure entity, to distinguish it among\n+--       Also set in the predicate function entity, to distinguish it among\n --       entries in the Subprograms_For_Type.\n \n --    Has_Primitive_Operations (Flag120) [base type only]\n@@ -3276,13 +3276,12 @@ package Einfo is\n --       Direct_Primitive_Operations of its CRT; otherwise returns No_Elist.\n --       For all the other types returns the Direct_Primitive_Operations.\n \n---    Predicate_Procedure (synthesized)\n+--    Predicate_Function (synthesized)\n --       Present in all types. Set for types for which (Has_Predicates is True)\n --       and for which a predicate procedure has been built that tests that the\n---       specified predicates are True. Contains the entity for the procedure\n---       which takes a single argument of the given type, and returns if the\n---       predicate holds, or raises exception Assertion_Error with an exception\n---       message if it does not hold.\n+--       specified predicates are True. Contains the entity for the function\n+--       which takes a single argument of the given type, and returns True if\n+--       the predicate holds and False if it does not.\n --\n --       Note: the reason this is marked as a synthesized attribute is that the\n --       way this is stored is as an element of the Subprograms_For_Type field.\n@@ -3662,7 +3661,7 @@ package Einfo is\n --       entity. Basically this is a way of multiplexing the single field to\n --       hold more than one entity (since we ran out of space in some type\n --       entities). This is currently used for Invariant_Procedure and also\n---       for Predicate_Procedure, and clients will always use the latter two\n+--       for Predicate_Function, and clients will always use the latter two\n --       names to access entries in this list.\n \n --    Suppress_Elaboration_Warnings (Flag148)\n@@ -4832,7 +4831,7 @@ package Einfo is\n    --    Implementation_Base_Type            (synth)\n    --    Invariant_Procedure                 (synth)\n    --    Is_Access_Protected_Subprogram_Type (synth)\n-   --    Predicate_Procedure                 (synth)\n+   --    Predicate_Function                  (synth)\n    --    Root_Type                           (synth)\n    --    Size_Clause                         (synth)\n \n@@ -6824,10 +6823,10 @@ package Einfo is\n    ---------------------------------------------------\n \n    function Invariant_Procedure                 (Id : E) return N;\n-   function Predicate_Procedure                 (Id : E) return N;\n+   function Predicate_Function                  (Id : E) return N;\n \n    procedure Set_Invariant_Procedure            (Id : E; V : E);\n-   procedure Set_Predicate_Procedure            (Id : E; V : E);\n+   procedure Set_Predicate_Function             (Id : E; V : E);\n \n    -----------------------------------\n    -- Field Initialization Routines --"}, {"sha": "7d914f56bad536f15484efc24b2e7c6b922c0602", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 61, "deletions": 32, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -4318,14 +4318,17 @@ package body Exp_Ch4 is\n \n    procedure Expand_N_In (N : Node_Id) is\n       Loc    : constant Source_Ptr := Sloc (N);\n-      Rtyp   : constant Entity_Id  := Etype (N);\n+      Restyp : constant Entity_Id  := Etype (N);\n       Lop    : constant Node_Id    := Left_Opnd (N);\n       Rop    : constant Node_Id    := Right_Opnd (N);\n       Static : constant Boolean    := Is_OK_Static_Expression (N);\n \n+      Ltyp  : Entity_Id;\n+      Rtyp  : Entity_Id;\n+\n       procedure Expand_Set_Membership;\n-      --  For each disjunct we create a simple equality or membership test.\n-      --  The whole membership is rewritten as a short-circuit disjunction.\n+      --  For each choice we create a simple equality or membership test.\n+      --  The whole membership is rewritten connecting these with OR ELSE.\n \n       ---------------------------\n       -- Expand_Set_Membership --\n@@ -4400,7 +4403,7 @@ package body Exp_Ch4 is\n              Prefix         => Relocate_Node (Lop),\n              Attribute_Name => Name_Valid));\n \n-         Analyze_And_Resolve (N, Rtyp);\n+         Analyze_And_Resolve (N, Restyp);\n \n          Error_Msg_N (\"?explicit membership test may be optimized away\", N);\n          Error_Msg_N -- CODEFIX\n@@ -4411,24 +4414,32 @@ package body Exp_Ch4 is\n    --  Start of processing for Expand_N_In\n \n    begin\n+      --  If set membersip case, expand with separate procedure\n+\n       if Present (Alternatives (N)) then\n          Remove_Side_Effects (Lop);\n          Expand_Set_Membership;\n          return;\n       end if;\n \n+      --  Not set membership, proceed with expansion\n+\n+      Ltyp := Etype (Left_Opnd  (N));\n+      Rtyp := Etype (Right_Opnd (N));\n+\n       --  Check case of explicit test for an expression in range of its\n       --  subtype. This is suspicious usage and we replace it with a 'Valid\n       --  test and give a warning. For floating point types however, this is a\n       --  standard way to check for finite numbers, and using 'Valid would\n       --  typically be a pessimization.\n \n-      if Is_Scalar_Type (Etype (Lop))\n-        and then not Is_Floating_Point_Type (Etype (Lop))\n+      if Is_Scalar_Type (Ltyp)\n+        and then not Is_Floating_Point_Type (Ltyp)\n         and then Nkind (Rop) in N_Has_Entity\n-        and then Etype (Lop) = Entity (Rop)\n+        and then Ltyp = Entity (Rop)\n         and then Comes_From_Source (N)\n         and then VM_Target = No_VM\n+        and then No (Predicate_Function (Rtyp))\n       then\n          Substitute_Valid_Check;\n          return;\n@@ -4448,8 +4459,6 @@ package body Exp_Ch4 is\n             Lo : constant Node_Id := Low_Bound (Rop);\n             Hi : constant Node_Id := High_Bound (Rop);\n \n-            Ltyp : constant Entity_Id := Etype (Lop);\n-\n             Lo_Orig : constant Node_Id := Original_Node (Lo);\n             Hi_Orig : constant Node_Id := Original_Node (Hi);\n \n@@ -4493,7 +4502,7 @@ package body Exp_Ch4 is\n               and then VM_Target = No_VM\n             then\n                Substitute_Valid_Check;\n-               return;\n+               goto Leave;\n             end if;\n \n             --  If bounds of type are known at compile time, and the end points\n@@ -4517,7 +4526,7 @@ package body Exp_Ch4 is\n               and then not In_Instance\n             then\n                Substitute_Valid_Check;\n-               return;\n+               goto Leave;\n             end if;\n \n             --  If we have an explicit range, do a bit of optimization based on\n@@ -4537,10 +4546,9 @@ package body Exp_Ch4 is\n                end if;\n \n                Rewrite (N, New_Reference_To (Standard_False, Loc));\n-               Analyze_And_Resolve (N, Rtyp);\n+               Analyze_And_Resolve (N, Restyp);\n                Set_Is_Static_Expression (N, Static);\n-\n-               return;\n+               goto Leave;\n \n             --  If both checks are known to succeed, replace result by True,\n             --  since we know we are in range.\n@@ -4552,10 +4560,9 @@ package body Exp_Ch4 is\n                end if;\n \n                Rewrite (N, New_Reference_To (Standard_True, Loc));\n-               Analyze_And_Resolve (N, Rtyp);\n+               Analyze_And_Resolve (N, Restyp);\n                Set_Is_Static_Expression (N, Static);\n-\n-               return;\n+               goto Leave;\n \n             --  If lower bound check succeeds and upper bound check is not\n             --  known to succeed or fail, then replace the range check with\n@@ -4571,9 +4578,8 @@ package body Exp_Ch4 is\n                  Make_Op_Le (Loc,\n                    Left_Opnd  => Lop,\n                    Right_Opnd => High_Bound (Rop)));\n-               Analyze_And_Resolve (N, Rtyp);\n-\n-               return;\n+               Analyze_And_Resolve (N, Restyp);\n+               goto Leave;\n \n             --  If upper bound check succeeds and lower bound check is not\n             --  known to succeed or fail, then replace the range check with\n@@ -4589,9 +4595,8 @@ package body Exp_Ch4 is\n                  Make_Op_Ge (Loc,\n                    Left_Opnd  => Lop,\n                    Right_Opnd => Low_Bound (Rop)));\n-               Analyze_And_Resolve (N, Rtyp);\n-\n-               return;\n+               Analyze_And_Resolve (N, Restyp);\n+               goto Leave;\n             end if;\n \n             --  We couldn't optimize away the range check, but there is one\n@@ -4632,7 +4637,7 @@ package body Exp_Ch4 is\n \n          --  For all other cases of an explicit range, nothing to be done\n \n-         return;\n+         goto Leave;\n \n       --  Here right operand is a subtype mark\n \n@@ -4660,7 +4665,7 @@ package body Exp_Ch4 is\n                if Tagged_Type_Expansion then\n                   Tagged_Membership (N, SCIL_Node, New_N);\n                   Rewrite (N, New_N);\n-                  Analyze_And_Resolve (N, Rtyp);\n+                  Analyze_And_Resolve (N, Restyp);\n \n                   --  Update decoration of relocated node referenced by the\n                   --  SCIL node.\n@@ -4670,7 +4675,7 @@ package body Exp_Ch4 is\n                   end if;\n                end if;\n \n-               return;\n+               goto Leave;\n \n             --  If type is scalar type, rewrite as x in t'First .. t'Last.\n             --  This reason we do this is that the bounds may have the wrong\n@@ -4689,8 +4694,8 @@ package body Exp_Ch4 is\n                      Make_Attribute_Reference (Loc,\n                        Attribute_Name => Name_Last,\n                        Prefix => New_Reference_To (Typ, Loc))));\n-               Analyze_And_Resolve (N, Rtyp);\n-               return;\n+               Analyze_And_Resolve (N, Restyp);\n+               goto Leave;\n \n             --  Ada 2005 (AI-216): Program_Error is raised when evaluating\n             --  a membership test if the subtype mark denotes a constrained\n@@ -4709,7 +4714,7 @@ package body Exp_Ch4 is\n                --  test as False.\n \n                Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n-               return;\n+               goto Leave;\n             end if;\n \n             --  Here we have a non-scalar type\n@@ -4720,7 +4725,7 @@ package body Exp_Ch4 is\n \n             if not Is_Constrained (Typ) then\n                Rewrite (N, New_Reference_To (Standard_True, Loc));\n-               Analyze_And_Resolve (N, Rtyp);\n+               Analyze_And_Resolve (N, Restyp);\n \n             --  For the constrained array case, we have to check the subscripts\n             --  for an exact match if the lengths are non-zero (the lengths\n@@ -4788,7 +4793,7 @@ package body Exp_Ch4 is\n                   end if;\n \n                   Rewrite (N, Cond);\n-                  Analyze_And_Resolve (N, Rtyp);\n+                  Analyze_And_Resolve (N, Restyp);\n                end Check_Subscripts;\n \n             --  These are the cases where constraint checks may be required,\n@@ -4819,10 +4824,34 @@ package body Exp_Ch4 is\n                end if;\n \n                Rewrite (N, Cond);\n-               Analyze_And_Resolve (N, Rtyp);\n+               Analyze_And_Resolve (N, Restyp);\n             end if;\n          end;\n       end if;\n+\n+   --  At this point, we have done the processing required for the basic\n+   --  membership test, but not yet dealt with the predicate.\n+\n+   <<Leave>>\n+\n+      --  If a predicate is present, then we do the predicate test\n+\n+      if Present (Predicate_Function (Rtyp)) then\n+         Rewrite (N,\n+           Make_And_Then (Loc,\n+             Left_Opnd  => Relocate_Node (N),\n+             Right_Opnd => Make_Predicate_Call (Rtyp, Lop)));\n+\n+         --  Analyze new expression, mark left operand as analyzed to\n+         --  avoid infinite recursion adding predicate calls.\n+\n+         Set_Analyzed (Left_Opnd (N));\n+         Analyze_And_Resolve (N, Standard_Boolean);\n+\n+         --  All done, skip attempt at compile time determination of result\n+\n+         return;\n+      end if;\n    end Expand_N_In;\n \n    --------------------------------"}, {"sha": "1ce017b280fb202cac5efb8eb98bc78e31e0ed9c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -4086,6 +4086,51 @@ package body Exp_Util is\n             Make_Integer_Literal (Loc, 0));\n    end Make_Non_Empty_Check;\n \n+   -------------------------\n+   -- Make_Predicate_Call --\n+   -------------------------\n+\n+   function Make_Predicate_Call\n+     (Typ  : Entity_Id;\n+      Expr : Node_Id) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (Expr);\n+\n+   begin\n+      pragma Assert (Present (Predicate_Function (Typ)));\n+\n+      return\n+        Make_Function_Call (Loc,\n+          Name                   =>\n+            New_Occurrence_Of (Predicate_Function (Typ), Loc),\n+          Parameter_Associations => New_List (Relocate_Node (Expr)));\n+   end Make_Predicate_Call;\n+\n+   --------------------------\n+   -- Make_Predicate_Check --\n+   --------------------------\n+\n+   function Make_Predicate_Check\n+     (Typ  : Entity_Id;\n+      Expr : Node_Id) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (Expr);\n+\n+   begin\n+      return\n+        Make_Pragma (Loc,\n+          Pragma_Identifier            =>\n+            Make_Identifier (Loc,\n+              Name_Check),\n+          Pragma_Argument_Associations => New_List (\n+            Make_Pragma_Argument_Association (Loc,\n+              Expression =>\n+                Make_Identifier (Loc,\n+                  Chars => Name_Predicate)),\n+            Make_Pragma_Argument_Association (Loc,\n+              Expression => Make_Predicate_Call (Typ, Expr))));\n+   end Make_Predicate_Check;\n+\n    ----------------------------\n    -- Make_Subtype_From_Expr --\n    ----------------------------"}, {"sha": "4dee22950f18617d1a874a2c906f466164eb3d53", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -566,7 +566,21 @@ package Exp_Util is\n    --  Expr is an object of a type which Has_Invariants set (and which thus\n    --  also has an Invariant_Procedure set). If invariants are enabled, this\n    --  function returns a call to the Invariant procedure passing Expr as the\n-   --  argument.\n+   --  argument, and returns it unanalyzed. If invariants are not enabled,\n+   --  returns a null statement.\n+\n+   function Make_Predicate_Call\n+     (Typ  : Entity_Id;\n+      Expr : Node_Id) return Node_Id;\n+   --  Typ is a type with Predicate_Function set. This routine builds a call to\n+   --  this function passing Expr as the argument, and returns it unanalyzed.\n+\n+   function Make_Predicate_Check\n+     (Typ  : Entity_Id;\n+      Expr : Node_Id) return Node_Id;\n+   --  Typ is a type with Predicate_Function set. This routine builds a Check\n+   --  pragma whose first argument is Predicate, and the second argument is a\n+   --  call to the this predicate function with Expr as the argument.\n \n    function Make_Subtype_From_Expr\n      (E       : Node_Id;"}, {"sha": "cfe322714bebb8cced365875b0a1f7f41557082b", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -3787,6 +3787,28 @@ package body Freeze is\n             end if;\n          end if;\n \n+         --  If we have predicates, then this is where we build the predicate\n+         --  function, and return the spec and body as freeze actions.\n+\n+         if Has_Predicates (E) then\n+            declare\n+               FDecl : Node_Id;\n+               FBody : Node_Id;\n+\n+            begin\n+               Build_Predicate_Function (E, FDecl, FBody);\n+\n+               if Present (FDecl) then\n+                  if No (Result) then\n+                     Result := Empty_List;\n+                  end if;\n+\n+                  Append_To (Result, FDecl);\n+                  Append_To (Result, FBody);\n+               end if;\n+            end;\n+         end if;\n+\n          --  Generic types are never seen by the back-end, and are also not\n          --  processed by the expander (since the expander is turned off for\n          --  generic processing), so we never need freeze nodes for them."}, {"sha": "3914337e7c6ea733a465de5a28ec22cea086c54f", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 324, "deletions": 13, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -1008,14 +1008,14 @@ package body Sem_Ch13 is\n                   goto Continue;\n                end;\n \n-               --  Invariant and Predicate aspects generate a corresponding\n-               --  pragma with a first argument that is the entity, and the\n-               --  second argument is the expression. This is inserted right\n-               --  after the declaration, to get the required pragma placement.\n-               --  The pragma processing takes care of the required delay.\n+               --  Invariant aspects generate a corresponding pragma with a\n+               --  first argument that is the entity, and the second argument\n+               --  is the expression and anthird argument with an appropriate\n+               --  message. This is inserted right after the declaration, to\n+               --  get the required pragma placement. The pragma processing\n+               --  takes care of the required delay.\n \n-               when Aspect_Invariant |\n-                    Aspect_Predicate =>\n+               when Aspect_Invariant =>\n \n                   --  Construct the pragma\n \n@@ -1025,14 +1025,14 @@ package body Sem_Ch13 is\n                         New_List (Ent, Relocate_Node (Expr)),\n                       Class_Present                => Class_Present (Aspect),\n                       Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Chars (Id)));\n+                        Make_Identifier (Sloc (Id), Name_Invariant));\n \n                   --  Add message unless exception messages are suppressed\n \n                   if not Opt.Exception_Locations_Suppressed then\n                      Append_To (Pragma_Argument_Associations (Aitem),\n                        Make_Pragma_Argument_Association (Eloc,\n-                         Chars     => Name_Message,\n+                         Chars      => Name_Message,\n                          Expression =>\n                            Make_String_Literal (Eloc,\n                              Strval => \"failed invariant from \"\n@@ -1041,10 +1041,36 @@ package body Sem_Ch13 is\n \n                   Set_From_Aspect_Specification (Aitem, True);\n \n-                  --  For Invariant and Predicate cases, insert immediately\n-                  --  after the entity declaration. We do not have to worry\n-                  --  about delay issues since the pragma processing takes\n-                  --  care of this.\n+                  --  For Invariant case, insert immediately after the entity\n+                  --  declaration. We do not have to worry about delay issues\n+                  --  since the pragma processing takes care of this.\n+\n+                  Insert_After (N, Aitem);\n+                  goto Continue;\n+\n+               --  Predicate aspects generate a corresponding pragma with a\n+               --  first argument that is the entity, and the second argument\n+               --  is the expression. This is inserted immediately after the\n+               --  declaration, to get the required pragma placement. The\n+               --  pragma processing takes care of the required delay.\n+\n+               when Aspect_Predicate =>\n+\n+                  --  Construct the pragma\n+\n+                  Aitem :=\n+                    Make_Pragma (Loc,\n+                      Pragma_Argument_Associations =>\n+                        New_List (Ent, Relocate_Node (Expr)),\n+                      Class_Present                => Class_Present (Aspect),\n+                      Pragma_Identifier            =>\n+                        Make_Identifier (Sloc (Id), Name_Predicate));\n+\n+                  Set_From_Aspect_Specification (Aitem, True);\n+\n+                  --  For Predicate case, insert immediately after the entity\n+                  --  declaration. We do not have to worry about delay issues\n+                  --  since the pragma processing takes care of this.\n \n                   Insert_After (N, Aitem);\n                   goto Continue;\n@@ -3730,6 +3756,291 @@ package body Sem_Ch13 is\n       end if;\n    end Build_Invariant_Procedure;\n \n+   ------------------------------\n+   -- Build_Predicate_Function --\n+   ------------------------------\n+\n+   --  The procedure that is constructed here has the form\n+\n+   --  function typPredicate (Ixxx : typ) return Boolean is\n+   --  begin\n+   --     return\n+   --        exp1 and then exp2 and then ...\n+   --        and then typ1Predicate (typ1 (Ixxx))\n+   --        and then typ2Predicate (typ2 (Ixxx))\n+   --        and then ...;\n+   --  end typPredicate;\n+\n+   --  Here exp1, and exp2 are expressions from Predicate pragmas. Note that\n+   --  this is the point at which these expressions get analyzed, providing the\n+   --  required delay, and typ1, typ2, are entities from which predicates are\n+   --  inherited. Note that we do NOT generate Check pragmas, that's because we\n+   --  use this function even if checks are off, e.g. for membership tests.\n+\n+   procedure Build_Predicate_Function\n+     (Typ   : Entity_Id;\n+      FDecl : out Node_Id;\n+      FBody : out Node_Id)\n+   is\n+      Loc  : constant Source_Ptr := Sloc (Typ);\n+      Spec : Node_Id;\n+      SId  : Entity_Id;\n+\n+      Expr : Node_Id;\n+      --  This is the expression for the return statement in the function. It\n+      --  is build by connecting the component predicates with AND THEN.\n+\n+      procedure Add_Call (T : Entity_Id);\n+      --  Includes a call statement to the predicate function for type T in\n+      --  Expr if T has predicates and Predicate_Function (T) is non-empty.\n+\n+      procedure Add_Predicates;\n+      --  Appends expressions for any Predicate pragmas in the rep item chain\n+      --  Typ to Expr. Note that we look only at items for this exact entity.\n+      --  Inheritance of predicates for the parent type is done by calling the\n+      --  Predicate_Function of the parent type, using Add_Call above.\n+\n+      Object_Name : constant Name_Id := New_Internal_Name ('I');\n+      --  Name for argument of Predicate procedure\n+\n+      --------------\n+      -- Add_Call --\n+      --------------\n+\n+      procedure Add_Call (T : Entity_Id) is\n+         Exp : Node_Id;\n+\n+      begin\n+         if Present (T)\n+           and then Present (Predicate_Function (T))\n+         then\n+            Exp :=\n+              Make_Predicate_Call\n+                (T,\n+                 Convert_To (T,\n+                   Make_Identifier (Loc,\n+                     Chars => Object_Name)));\n+\n+            if No (Expr) then\n+               Expr := Exp;\n+            else\n+               Expr :=\n+                 Make_And_Then (Loc,\n+                   Left_Opnd  => Relocate_Node (Expr),\n+                   Right_Opnd => Exp);\n+            end if;\n+         end if;\n+      end Add_Call;\n+\n+      --------------------\n+      -- Add_Predicates --\n+      --------------------\n+\n+      procedure Add_Predicates is\n+         Ritem : Node_Id;\n+         Arg1  : Node_Id;\n+         Arg2  : Node_Id;\n+\n+         function Replace_Node (N : Node_Id) return Traverse_Result;\n+         --  Process single node for traversal to replace type references\n+\n+         procedure Replace_Type is new Traverse_Proc (Replace_Node);\n+         --  Traverse an expression changing every occurrence of an entity\n+         --  reference to type T with a reference to the object argument.\n+\n+         ------------------\n+         -- Replace_Node --\n+         ------------------\n+\n+         function Replace_Node (N : Node_Id) return Traverse_Result is\n+         begin\n+            --  Case of entity name referencing the type\n+\n+            if Is_Entity_Name (N)\n+              and then Entity (N) = Typ\n+            then\n+               --  Replace with object\n+\n+               Rewrite (N,\n+                 Make_Identifier (Loc,\n+                   Chars => Object_Name));\n+\n+               --  All done with this node\n+\n+               return Skip;\n+\n+            --  Not an instance of the type entity, keep going\n+\n+            else\n+               return OK;\n+            end if;\n+         end Replace_Node;\n+\n+      begin\n+         Ritem := First_Rep_Item (Typ);\n+         while Present (Ritem) loop\n+            if Nkind (Ritem) = N_Pragma\n+              and then Pragma_Name (Ritem) = Name_Predicate\n+            then\n+               Arg1 := First (Pragma_Argument_Associations (Ritem));\n+               Arg2 := Next (Arg1);\n+\n+               Arg1 := Get_Pragma_Arg (Arg1);\n+               Arg2 := Get_Pragma_Arg (Arg2);\n+\n+               --  We need to replace any occurrences of the name of the type\n+               --  with references to the object. We do this by first doing a\n+               --  preanalysis, to identify all the entities, then we traverse\n+               --  looking for the type entity, doing the needed substitution.\n+               --  The preanalysis is done with the special OK_To_Reference\n+               --  flag set on the type, so that if we get an occurrence of\n+               --  this type, it will be reognized as legitimate.\n+\n+               Set_OK_To_Reference (Typ, True);\n+               Preanalyze_Spec_Expression (Arg2, Standard_Boolean);\n+               Set_OK_To_Reference (Typ, False);\n+               Replace_Type (Arg2);\n+\n+               --  See if this predicate pragma is for the current type\n+\n+               if Entity (Arg1) = Typ then\n+\n+                  --  We have a match, add the expression\n+\n+                  if No (Expr) then\n+                     Expr := Relocate_Node (Arg2);\n+                  else\n+                     Expr :=\n+                       Make_And_Then (Loc,\n+                         Left_Opnd  => Relocate_Node (Expr),\n+                         Right_Opnd => Relocate_Node (Arg2));\n+                  end if;\n+               end if;\n+            end if;\n+\n+            Next_Rep_Item (Ritem);\n+         end loop;\n+      end Add_Predicates;\n+\n+   --  Start of processing for Build_Predicate_Function\n+\n+   begin\n+      --  Initialize for construction of statement list\n+\n+      Expr := Empty;\n+      FDecl := Empty;\n+      FBody := Empty;\n+\n+      --  Return if already built or if type does not have predicates\n+\n+      if not Has_Predicates (Typ)\n+        or else Present (Predicate_Function (Typ))\n+      then\n+         return;\n+      end if;\n+\n+      --  Add Predicates for the current type\n+\n+      Add_Predicates;\n+\n+      --  Deal with ancestor subtype and parent type\n+\n+      declare\n+         Atyp : constant Entity_Id := Ancestor_Subtype (Typ);\n+\n+      begin\n+         --  If ancestor subtype present, add its predicates\n+\n+         if Present (Atyp) then\n+            Add_Call (Atyp);\n+\n+         --  Else if this is derived, add predicates of parent type\n+\n+         elsif Is_Derived_Type (Typ) then\n+            Add_Call (Etype (Base_Type (Typ)));\n+         end if;\n+      end;\n+\n+      --  Add predicates of any interfaces of a tagged type\n+\n+      if Is_Tagged_Type (Typ) then\n+         declare\n+            Iface_List : Elist_Id;\n+            Elmt       : Elmt_Id;\n+\n+         begin\n+            Collect_Interfaces (Typ, Iface_List);\n+\n+            if Present (Iface_List) then\n+               loop\n+                  Elmt := First_Elmt (Iface_List);\n+                  exit when No (Elmt);\n+                  Add_Call (Node (Elmt));\n+                  Remove_Elmt (Iface_List, Elmt);\n+               end loop;\n+            end if;\n+         end;\n+      end if;\n+\n+      if Present (Expr) then\n+\n+         --  Build function declaration\n+\n+         pragma Assert (Has_Predicates (Typ));\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+         Set_Has_Predicates (SId);\n+         Set_Predicate_Function (Typ, SId);\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc,\n+                     Chars => Object_Name),\n+                 Parameter_Type =>\n+                   New_Occurrence_Of (Typ, Loc))),\n+             Result_Definition        =>\n+               New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+         FDecl :=\n+           Make_Subprogram_Declaration (Loc,\n+             Specification => Spec);\n+\n+         --  Build function body\n+\n+         SId :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Chars (Typ), \"Predicate\"));\n+\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => SId,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                 Defining_Identifier =>\n+                   Make_Defining_Identifier (Loc,\n+                     Chars => Object_Name),\n+                 Parameter_Type =>\n+                   New_Occurrence_Of (Typ, Loc))),\n+             Result_Definition        =>\n+               New_Occurrence_Of (Standard_Boolean, Loc));\n+\n+         FBody :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              => Spec,\n+             Declarations               => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+                   Make_Simple_Return_Statement (Loc,\n+                     Expression => Expr))));\n+      end if;\n+   end Build_Predicate_Function;\n+\n    -----------------------------------\n    -- Check_Constant_Address_Clause --\n    -----------------------------------"}, {"sha": "46d6cb8a94ad57fdbf070caa2c3f289031e7ae5d", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -57,11 +57,25 @@ package Sem_Ch13 is\n       PDecl : out Node_Id;\n       PBody : out Node_Id);\n    --  If Typ has Invariants (indicated by Has_Invariants being set for Typ,\n-   --  indicating the presence of Pragma Invariant entries on the rep chain,\n+   --  indicating the presence of pragma Invariant entries on the rep chain,\n    --  note that Invariant aspects are converted to pragma Invariant), then\n    --  this procedure builds the spec and body for the corresponding Invariant\n-   --  procedure, returning themn in PDecl and PBody. In some error situations\n-   --  no procedure is built, in which case PDecl/PBody are empty on return.\n+   --  procedure, returning themn in PDecl and PBody. Invariant_Procedure is\n+   --  set for Typ. In some error situations no procedure is built, in which\n+   --  case PDecl/PBody are empty on return.\n+\n+   procedure Build_Predicate_Function\n+     (Typ   : Entity_Id;\n+      FDecl : out Node_Id;\n+      FBody : out Node_Id);\n+   --  If Typ has predicates (indicated by Has_Predicates being set for Typ,\n+   --  then either there are pragma Invariant entries on the rep chain for the\n+   --  type (note that Predicate aspects are converted to pragam Predicate), or\n+   --  there are inherited aspects from a parent type, or ancestor subtypes,\n+   --  or interfaces. This procedure builds the spec and body for the Predicate\n+   --  function that tests these predicates, returning them in PDecl and Pbody\n+   --  and setting Predicate_Procedure for Typ. In some error situations no\n+   --  procedure is built, in which case PDecl/PBody are empty on return.\n \n    procedure Check_Record_Representation_Clause (N : Node_Id);\n    --  This procedure completes the analysis of a record representation clause"}, {"sha": "e13e5c8f6adf024ba3934eea36321175c5a8c70f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -484,8 +484,8 @@ package body Sem_Ch3 is\n    --  operations of progenitors of Tagged_Type, and replace the subsidiary\n    --  subtypes with Tagged_Type, to build the specs of the inherited interface\n    --  primitives. The derived primitives are aliased to those of the\n-   --  interface. This routine takes care also of transferring to the full-view\n-   --  subprograms associated with the partial-view of Tagged_Type that cover\n+   --  interface. This routine takes care also of transferring to the full view\n+   --  subprograms associated with the partial view of Tagged_Type that cover\n    --  interface primitives.\n \n    procedure Derived_Standard_Character\n@@ -1359,6 +1359,12 @@ package body Sem_Ch3 is\n          pragma Assert (Is_Tagged_Type (Iface)\n            and then Is_Interface (Iface));\n \n+         --  This is a reasonable place to propagate predicates\n+\n+         if Has_Predicates (Iface) then\n+            Set_Has_Predicates (Typ);\n+         end if;\n+\n          Def :=\n            Make_Component_Definition (Loc,\n              Aliased_Present    => True,\n@@ -2300,7 +2306,7 @@ package body Sem_Ch3 is\n       end if;\n \n       if Etype (T) = Any_Type then\n-         goto Leave;\n+         return;\n       end if;\n \n       --  Some common processing for all types\n@@ -2395,8 +2401,9 @@ package body Sem_Ch3 is\n       Set_Optimize_Alignment_Flags (Def_Id);\n       Check_Eliminated (Def_Id);\n \n-      <<Leave>>\n+      if Nkind (N) = N_Full_Type_Declaration then\n          Analyze_Aspect_Specifications (N, Def_Id, Aspect_Specifications (N));\n+      end if;\n    end Analyze_Full_Type_Declaration;\n \n    ----------------------------------\n@@ -3835,6 +3842,7 @@ package body Sem_Ch3 is\n       Set_Is_Ada_2005_Only  (Id, Is_Ada_2005_Only  (T));\n       Set_Is_Ada_2012_Only  (Id, Is_Ada_2012_Only  (T));\n       Set_Convention        (Id, Convention        (T));\n+      Set_Has_Predicates    (Id, Has_Predicates    (T));\n \n       --  In the case where there is no constraint given in the subtype\n       --  indication, Process_Subtype just returns the Subtype_Mark, so its\n@@ -7668,6 +7676,12 @@ package body Sem_Ch3 is\n          Set_Has_Invariants (Derived_Type);\n       end if;\n \n+      --  We similarly inherit predicates\n+\n+      if Has_Predicates (Parent_Type) then\n+         Set_Has_Predicates (Derived_Type);\n+      end if;\n+\n       --  The derived type inherits the representation clauses of the parent.\n       --  However, for a private type that is completed by a derivation, there\n       --  may be operation attributes that have been specified already (stream\n@@ -17186,6 +17200,44 @@ package body Sem_Ch3 is\n                --  Copy Invariant procedure to private declaration\n \n                Set_Invariant_Procedure (Priv_T, Invariant_Procedure (Full_T));\n+               Set_Has_Invariants (Priv_T);\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Propagate predicates to full type, and also build the predicate\n+      --  procedure at this time, in the same way as we did for invariants.\n+\n+      if Has_Predicates (Priv_T) then\n+         declare\n+            FDecl : Entity_Id;\n+            FBody : Entity_Id;\n+            Packg : constant Node_Id := Declaration_Node (Scope (Priv_T));\n+\n+         begin\n+            Build_Predicate_Function (Full_T, FDecl, FBody);\n+\n+            --  Error defense, normally this should be set\n+\n+            if Present (FDecl) then\n+\n+               --  Spec goes at the end of the public part of the package.\n+               --  That's behind us, so we have to manually analyze the\n+               --  inserted spec.\n+\n+               Append_To (Visible_Declarations (Packg), FDecl);\n+               Analyze (FDecl);\n+\n+               --  Body goes at the end of the private part of the package.\n+               --  That's ahead of us so it will get analyzed later on when\n+               --  we come to it.\n+\n+               Append_To (Private_Declarations (Packg), FBody);\n+\n+               --  Copy Predicate procedure to private declaration\n+\n+               Set_Predicate_Function (Priv_T, Predicate_Function (Full_T));\n+               Set_Has_Predicates (Priv_T);\n             end if;\n          end;\n       end if;"}, {"sha": "6be84ca36612e0c2d0fe9414fbd16c9ec5d4987f", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -2282,6 +2282,15 @@ package body Sem_Eval is\n          return;\n       end if;\n \n+      --  Ignore if types involved have predicates\n+\n+      if Present (Predicate_Function (Etype (Left)))\n+           or else\n+         Present (Predicate_Function (Etype (Right)))\n+      then\n+         return;\n+      end if;\n+\n       --  Case of right operand is a subtype name\n \n       if Is_Entity_Name (Right) then"}, {"sha": "36038df6c654af78126c8d8a20a4e4297be31321", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=4818e7b9f8e9f5218d50f63c2dd7ae7f835aef0a", "patch": "@@ -11172,8 +11172,7 @@ package body Sem_Prag is\n \n          --  pragma Predicate\n          --    ([Entity =>]    type_LOCAL_NAME,\n-         --     [Check  =>]    EXPRESSION\n-         --     [,[Message =>] String_Expression]);\n+         --     [Check  =>]    EXPRESSION);\n \n          when Pragma_Predicate => Predicate : declare\n             Type_Id : Node_Id;\n@@ -11184,16 +11183,10 @@ package body Sem_Prag is\n \n          begin\n             GNAT_Pragma;\n-            Check_At_Least_N_Arguments (2);\n-            Check_At_Most_N_Arguments (3);\n+            Check_Arg_Count (2);\n             Check_Optional_Identifier (Arg1, Name_Entity);\n             Check_Optional_Identifier (Arg2, Name_Check);\n \n-            if Arg_Count = 3 then\n-               Check_Optional_Identifier (Arg3, Name_Message);\n-               Check_Arg_Is_Static_Expression (Arg3, Standard_String);\n-            end if;\n-\n             Check_Arg_Is_Local_Name (Arg1);\n \n             Type_Id := Get_Pragma_Arg (Arg1);\n@@ -11206,8 +11199,10 @@ package body Sem_Prag is\n \n             --  The remaining processing is simply to link the pragma on to\n             --  the rep item chain, for processing when the type is frozen.\n-            --  This is accomplished by a call to Rep_Item_Too_Late.\n+            --  This is accomplished by a call to Rep_Item_Too_Late. We also\n+            --  mark the type as having predicates.\n \n+            Set_Has_Predicates (Typ);\n             Discard := Rep_Item_Too_Late (Typ, N, FOnly => True);\n          end Predicate;\n "}]}