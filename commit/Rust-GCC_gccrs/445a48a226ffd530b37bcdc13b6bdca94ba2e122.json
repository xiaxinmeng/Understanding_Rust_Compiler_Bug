{"sha": "445a48a226ffd530b37bcdc13b6bdca94ba2e122", "node_id": "C_kwDOANBUbNoAKDQ0NWE0OGEyMjZmZmQ1MzBiMzdiY2RjMTNiNmJkY2E5NGJhMmUxMjI", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-01-11T08:32:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-01-11T10:53:12Z"}, "message": "tree-optimization/108353 - copyprop iteration order\n\nAfter recent improvements to copyprop to catch more constants\nit shows that the current iteration order prefering forward\nprogress over iterating doesn't make much sense for an SSA\npropagator.  The following instead first iterates cycles which\nmakes sure to not start with optimistically constant PHIs out\nof cycles that optimistically do not exit.\n\n\tPR tree-optimization/108353\n\t* tree-ssa-propagate.cc (cfg_blocks_back, ssa_edge_worklist_back):\n\tRemove.\n\t(add_ssa_edge): Simplify.\n\t(add_control_edge): Likewise.\n\t(ssa_prop_init): Likewise.\n\t(ssa_prop_fini): Likewise.\n\t(ssa_propagation_engine::ssa_propagate): Likewise.\n\n\t* gcc.dg/tree-ssa/ssa-copyprop-3.c: New testcase.", "tree": {"sha": "329c6bacb8d70606446b65986cef97573de4e502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/329c6bacb8d70606446b65986cef97573de4e502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/445a48a226ffd530b37bcdc13b6bdca94ba2e122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445a48a226ffd530b37bcdc13b6bdca94ba2e122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/445a48a226ffd530b37bcdc13b6bdca94ba2e122", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/445a48a226ffd530b37bcdc13b6bdca94ba2e122/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ce074a7f858a1cd30ff68ec636dad9be218e04b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce074a7f858a1cd30ff68ec636dad9be218e04b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ce074a7f858a1cd30ff68ec636dad9be218e04b"}], "stats": {"total": 73, "additions": 42, "deletions": 31}, "files": [{"sha": "d22b39294ab77ab6c1aca7cb5008e541bbb780dc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-copyprop-3.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445a48a226ffd530b37bcdc13b6bdca94ba2e122/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-copyprop-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445a48a226ffd530b37bcdc13b6bdca94ba2e122/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-copyprop-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-copyprop-3.c?ref=445a48a226ffd530b37bcdc13b6bdca94ba2e122", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target int32plus } */\n+/* { dg-options \"-O -fdump-tree-copyprop2\" } */\n+\n+#include <limits.h>\n+enum { a } b();\n+int d;\n+int e;\n+int f;\n+void foo();\n+[[gnu::noipa]]\n+void bar49_(void){}\n+[[gnu::noipa]]\n+void(c)(void){}\n+static short g(int h, int i) {\n+  int j = -1420678603, k = 1;\n+  if (h)\n+    for (; j < INT_MAX-18; j = j + 9) {\n+      f = 0;\n+      for (; f <= 1; c())\n+        k = 90;\n+    }\n+  i = k;\n+  for (; e; ++e) {\n+    if (i)\n+      continue;\n+    foo();\n+    i = b();\n+  }\n+  return 4;\n+}\n+int l() {\n+  bar49_();\n+  return 1;\n+}\n+int main() { d = d || g(d, l()); }\n+\n+/* { dg-final { scan-tree-dump-not \"foo\" \"copyprop2\" } } */"}, {"sha": "76708ca185f601d1297c163da905c8c6e69c7587", "filename": "gcc/tree-ssa-propagate.cc", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/445a48a226ffd530b37bcdc13b6bdca94ba2e122/gcc%2Ftree-ssa-propagate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/445a48a226ffd530b37bcdc13b6bdca94ba2e122/gcc%2Ftree-ssa-propagate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.cc?ref=445a48a226ffd530b37bcdc13b6bdca94ba2e122", "patch": "@@ -113,7 +113,6 @@\n    order by visiting in bit-order.  We use two worklists to\n    first make forward progress before iterating.  */\n static bitmap cfg_blocks;\n-static bitmap cfg_blocks_back;\n static int *bb_to_cfg_order;\n static int *cfg_order_to_bb;\n \n@@ -123,7 +122,6 @@ static int *cfg_order_to_bb;\n    UID in a bitmap.  UIDs order stmts in execution order.  We use\n    two worklists to first make forward progress before iterating.  */\n static bitmap ssa_edge_worklist;\n-static bitmap ssa_edge_worklist_back;\n static vec<gimple *> uid_to_stmt;\n \n /* Current RPO index in the iteration.  */\n@@ -159,12 +157,7 @@ add_ssa_edge (tree var)\n \t       & EDGE_EXECUTABLE))\n \tcontinue;\n \n-      bitmap worklist;\n-      if (bb_to_cfg_order[gimple_bb (use_stmt)->index] < curr_order)\n-\tworklist = ssa_edge_worklist_back;\n-      else\n-\tworklist = ssa_edge_worklist;\n-      if (bitmap_set_bit (worklist, gimple_uid (use_stmt)))\n+      if (bitmap_set_bit (ssa_edge_worklist, gimple_uid (use_stmt)))\n \t{\n \t  uid_to_stmt[gimple_uid (use_stmt)] = use_stmt;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -193,10 +186,7 @@ add_control_edge (edge e)\n   e->flags |= EDGE_EXECUTABLE;\n \n   int bb_order = bb_to_cfg_order[bb->index];\n-  if (bb_order < curr_order)\n-    bitmap_set_bit (cfg_blocks_back, bb_order);\n-  else\n-    bitmap_set_bit (cfg_blocks, bb_order);\n+  bitmap_set_bit (cfg_blocks, bb_order);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Adding destination of edge (%d -> %d) to worklist\\n\",\n@@ -380,9 +370,7 @@ ssa_prop_init (void)\n \n   /* Worklists of SSA edges.  */\n   ssa_edge_worklist = BITMAP_ALLOC (NULL);\n-  ssa_edge_worklist_back = BITMAP_ALLOC (NULL);\n   bitmap_tree_view (ssa_edge_worklist);\n-  bitmap_tree_view (ssa_edge_worklist_back);\n \n   /* Worklist of basic-blocks.  */\n   bb_to_cfg_order = XNEWVEC (int, last_basic_block_for_fn (cfun) + 1);\n@@ -392,7 +380,6 @@ ssa_prop_init (void)\n   for (int i = 0; i < n; ++i)\n     bb_to_cfg_order[cfg_order_to_bb[i]] = i;\n   cfg_blocks = BITMAP_ALLOC (NULL);\n-  cfg_blocks_back = BITMAP_ALLOC (NULL);\n \n   /* Initially assume that every edge in the CFG is not executable.\n      (including the edges coming out of the entry block).  Mark blocks\n@@ -430,11 +417,9 @@ static void\n ssa_prop_fini (void)\n {\n   BITMAP_FREE (cfg_blocks);\n-  BITMAP_FREE (cfg_blocks_back);\n   free (bb_to_cfg_order);\n   free (cfg_order_to_bb);\n   BITMAP_FREE (ssa_edge_worklist);\n-  BITMAP_FREE (ssa_edge_worklist_back);\n   uid_to_stmt.release ();\n }\n \n@@ -453,8 +438,7 @@ ssa_propagation_engine::ssa_propagate (void)\n   curr_order = 0;\n \n   /* Iterate until the worklists are empty.  We iterate both blocks\n-     and stmts in RPO order, using sets of two worklists to first\n-     complete the current iteration before iterating over backedges.\n+     and stmts in RPO order, prioritizing backedge processing.\n      Seed the algorithm by adding the successors of the entry block to the\n      edge worklist.  */\n   edge e;\n@@ -471,18 +455,7 @@ ssa_propagation_engine::ssa_propagate (void)\n       int next_stmt_uid = (bitmap_empty_p (ssa_edge_worklist)\n \t\t\t   ? -1 : bitmap_first_set_bit (ssa_edge_worklist));\n       if (next_block_order == -1 && next_stmt_uid == -1)\n-\t{\n-\t  if (bitmap_empty_p (cfg_blocks_back)\n-\t      && bitmap_empty_p (ssa_edge_worklist_back))\n-\t    break;\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"Regular worklists empty, now processing \"\n-\t\t     \"backedge destinations\\n\");\n-\t  std::swap (cfg_blocks, cfg_blocks_back);\n-\t  std::swap (ssa_edge_worklist, ssa_edge_worklist_back);\n-\t  continue;\n-\t}\n+\tbreak;\n \n       int next_stmt_bb_order = -1;\n       gimple *next_stmt = NULL;"}]}