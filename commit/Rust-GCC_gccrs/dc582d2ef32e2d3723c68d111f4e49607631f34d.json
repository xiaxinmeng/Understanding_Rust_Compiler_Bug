{"sha": "dc582d2ef32e2d3723c68d111f4e49607631f34d", "node_id": "C_kwDOANBUbNoAKGRjNTgyZDJlZjMyZTJkMzcyM2M2OGQxMTFmNGU0OTYwNzYzMWYzNGQ", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-12-12T15:16:50Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-12-12T15:17:24Z"}, "message": "middle-end: Add new tbranch optab to add support for bit-test-and-branch operations\n\nThis adds a new test-and-branch optab that can be used to do a conditional test\nof a bit and branch.   This is similar to the cbranch optab but instead can\ntest any arbitrary bit inside the register.\n\nThis patch recognizes boolean comparisons and single bit mask tests.\n\ngcc/ChangeLog:\n\n\t* dojump.cc (do_jump): Pass along value.\n\t(do_jump_by_parts_greater_rtx): Likewise.\n\t(do_jump_by_parts_zero_rtx): Likewise.\n\t(do_jump_by_parts_equality_rtx): Likewise.\n\t(do_compare_rtx_and_jump): Likewise.\n\t(do_compare_and_jump): Likewise.\n\t* dojump.h (do_compare_rtx_and_jump): New.\n\t* optabs.cc (emit_cmp_and_jump_insn_1): Refactor to take optab to check.\n\t(validate_test_and_branch): New.\n\t(emit_cmp_and_jump_insns): Optiobally take a value, and when value is\n\tsupplied then check if it's suitable for tbranch.\n\t* optabs.def (tbranch_eq$a4, tbranch_ne$a4): New.\n\t* doc/md.texi (tbranch_@var{op}@var{mode}4): Document it.\n\t* optabs.h (emit_cmp_and_jump_insns): New.\n\t* tree.h (tree_zero_one_valued_p): New.", "tree": {"sha": "47d533c626f633e61a78cdc46a2a4dbc59c42951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47d533c626f633e61a78cdc46a2a4dbc59c42951"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc582d2ef32e2d3723c68d111f4e49607631f34d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc582d2ef32e2d3723c68d111f4e49607631f34d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc582d2ef32e2d3723c68d111f4e49607631f34d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc582d2ef32e2d3723c68d111f4e49607631f34d/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cba118e538ba0b7582af7f9fb5ba2dfbb772f8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cba118e538ba0b7582af7f9fb5ba2dfbb772f8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cba118e538ba0b7582af7f9fb5ba2dfbb772f8e"}], "stats": {"total": 184, "additions": 159, "deletions": 25}, "files": [{"sha": "482e86f15d8b312c67d4962510ce879fb5cbc541", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=dc582d2ef32e2d3723c68d111f4e49607631f34d", "patch": "@@ -6964,6 +6964,13 @@ case, you can and should make operand 1's predicate reject some operators\n in the @samp{cstore@var{mode}4} pattern, or remove the pattern altogether\n from the machine description.\n \n+@cindex @code{tbranch_@var{op}@var{mode}3} instruction pattern\n+@item @samp{tbranch_@var{op}@var{mode}3}\n+Conditional branch instruction combined with a bit test-and-compare\n+instruction. Operand 0 is the operand of the comparison.  Operand 1 is the bit\n+position of Operand 1 to test.  Operand 3 is the @code{code_label} to jump to.\n+@var{op} is one of @var{eq} or @var{ne}.\n+\n @cindex @code{cbranch@var{mode}4} instruction pattern\n @item @samp{cbranch@var{mode}4}\n Conditional branch instruction combined with a compare instruction."}, {"sha": "190324f36f1a31990f8c49bc8c0f45c23da5c31e", "filename": "gcc/dojump.cc", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Fdojump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Fdojump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.cc?ref=dc582d2ef32e2d3723c68d111f4e49607631f34d", "patch": "@@ -619,7 +619,7 @@ do_jump (tree exp, rtx_code_label *if_false_label,\n \t}\n       do_compare_rtx_and_jump (temp, CONST0_RTX (GET_MODE (temp)),\n \t\t\t       NE, TYPE_UNSIGNED (TREE_TYPE (exp)),\n-\t\t\t       GET_MODE (temp), NULL_RTX,\n+\t\t\t       exp, GET_MODE (temp), NULL_RTX,\n \t\t\t       if_false_label, if_true_label, prob);\n     }\n \n@@ -687,16 +687,16 @@ do_jump_by_parts_greater_rtx (scalar_int_mode mode, int unsignedp, rtx op0,\n \n       /* All but high-order word must be compared as unsigned.  */\n       do_compare_rtx_and_jump (op0_word, op1_word, code, (unsignedp || i > 0),\n-\t\t\t       word_mode, NULL_RTX, NULL, if_true_label,\n+\t\t\t       NULL, word_mode, NULL_RTX, NULL, if_true_label,\n \t\t\t       prob);\n \n       /* Emit only one comparison for 0.  Do not emit the last cond jump.  */\n       if (op0 == const0_rtx || i == nwords - 1)\n \tbreak;\n \n       /* Consider lower words only if these are equal.  */\n-      do_compare_rtx_and_jump (op0_word, op1_word, NE, unsignedp, word_mode,\n-\t\t\t       NULL_RTX, NULL, if_false_label,\n+      do_compare_rtx_and_jump (op0_word, op1_word, NE, unsignedp, NULL,\n+\t\t\t       word_mode, NULL_RTX, NULL, if_false_label,\n \t\t\t       prob.invert ());\n     }\n \n@@ -755,7 +755,7 @@ do_jump_by_parts_zero_rtx (scalar_int_mode mode, rtx op0,\n \n   if (part != 0)\n     {\n-      do_compare_rtx_and_jump (part, const0_rtx, EQ, 1, word_mode,\n+      do_compare_rtx_and_jump (part, const0_rtx, EQ, 1, NULL, word_mode,\n \t\t\t       NULL_RTX, if_false_label, if_true_label, prob);\n       return;\n     }\n@@ -766,7 +766,7 @@ do_jump_by_parts_zero_rtx (scalar_int_mode mode, rtx op0,\n \n   for (i = 0; i < nwords; i++)\n     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n-                             const0_rtx, EQ, 1, word_mode, NULL_RTX,\n+\t\t\t     const0_rtx, EQ, 1, NULL, word_mode, NULL_RTX,\n \t\t\t     if_false_label, NULL, prob);\n \n   if (if_true_label)\n@@ -809,8 +809,8 @@ do_jump_by_parts_equality_rtx (scalar_int_mode mode, rtx op0, rtx op1,\n \n   for (i = 0; i < nwords; i++)\n     do_compare_rtx_and_jump (operand_subword_force (op0, i, mode),\n-                             operand_subword_force (op1, i, mode),\n-                             EQ, 0, word_mode, NULL_RTX,\n+\t\t\t     operand_subword_force (op1, i, mode),\n+\t\t\t     EQ, 0, NULL, word_mode, NULL_RTX,\n \t\t\t     if_false_label, NULL, prob);\n \n   if (if_true_label)\n@@ -962,6 +962,23 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t\t rtx_code_label *if_false_label,\n \t\t\t rtx_code_label *if_true_label,\n \t\t\t profile_probability prob)\n+{\n+  do_compare_rtx_and_jump (op0, op1, code, unsignedp, NULL, mode, size,\n+\t\t\t  if_false_label, if_true_label, prob);\n+}\n+\n+/* Like do_compare_and_jump but expects the values to compare as two rtx's.\n+   The decision as to signed or unsigned comparison must be made by the caller.\n+\n+   If MODE is BLKmode, SIZE is an RTX giving the size of the objects being\n+   compared.  */\n+\n+void\n+do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n+\t\t\t tree val, machine_mode mode, rtx size,\n+\t\t\t rtx_code_label *if_false_label,\n+\t\t\t rtx_code_label *if_true_label,\n+\t\t\t profile_probability prob)\n {\n   rtx tem;\n   rtx_code_label *dummy_label = NULL;\n@@ -1177,8 +1194,10 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t\t    }\n \t\t  else\n \t\t    dest_label = if_false_label;\n-                  do_compare_rtx_and_jump (op0, op1, first_code, unsignedp, mode,\n-\t\t\t\t\t   size, dest_label, NULL, first_prob);\n+\n+\t\t  do_compare_rtx_and_jump (op0, op1, first_code, unsignedp,\n+\t\t\t\t\t   val, mode, size, dest_label, NULL,\n+\t\t\t\t\t   first_prob);\n \t\t}\n \t      /* For !and_them we want to split:\n \t\t if (x) goto t; // prob;\n@@ -1192,8 +1211,9 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n               else\n \t\t{\n \t\t  profile_probability first_prob = prob.split (cprob);\n-\t\t  do_compare_rtx_and_jump (op0, op1, first_code, unsignedp, mode,\n-\t\t\t\t\t   size, NULL, if_true_label, first_prob);\n+\t\t  do_compare_rtx_and_jump (op0, op1, first_code, unsignedp,\n+\t\t\t\t\t   val, mode, size, NULL,\n+\t\t\t\t\t   if_true_label, first_prob);\n \t\t  if (orig_code == NE && can_compare_p (UNEQ, mode, ccp_jump))\n \t\t    {\n \t\t      /* x != y can be split into x unord y || x ltgt y\n@@ -1215,7 +1235,7 @@ do_compare_rtx_and_jump (rtx op0, rtx op1, enum rtx_code code, int unsignedp,\n \t    }\n \t}\n \n-      emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp,\n+      emit_cmp_and_jump_insns (op0, op1, code, size, mode, unsignedp, val,\n \t\t\t       if_true_label, prob);\n     }\n \n@@ -1289,9 +1309,9 @@ do_compare_and_jump (tree treeop0, tree treeop1, enum rtx_code signed_code,\n       op1 = new_op1;\n     }\n \n-  do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode,\n-                           ((mode == BLKmode)\n-                            ? expr_size (treeop0) : NULL_RTX),\n+  do_compare_rtx_and_jump (op0, op1, code, unsignedp, treeop0, mode,\n+\t\t\t   ((mode == BLKmode)\n+\t\t\t    ? expr_size (treeop0) : NULL_RTX),\n \t\t\t   if_false_label, if_true_label, prob);\n }\n "}, {"sha": "d1d79c490c420a805fe48d58740a79c1f25fb839", "filename": "gcc/dojump.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Fdojump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Fdojump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.h?ref=dc582d2ef32e2d3723c68d111f4e49607631f34d", "patch": "@@ -71,6 +71,10 @@ extern void jumpifnot (tree exp, rtx_code_label *label,\n extern void jumpifnot_1 (enum tree_code, tree, tree, rtx_code_label *,\n \t\t\t profile_probability);\n \n+extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int, tree,\n+\t\t\t\t     machine_mode, rtx, rtx_code_label *,\n+\t\t\t\t     rtx_code_label *, profile_probability);\n+\n extern void do_compare_rtx_and_jump (rtx, rtx, enum rtx_code, int,\n \t\t\t\t     machine_mode, rtx, rtx_code_label *,\n \t\t\t\t     rtx_code_label *, profile_probability);"}, {"sha": "262a37f9b3f05780ec2f26cafb0efd085e89e3d9", "filename": "gcc/optabs.cc", "status": "modified", "additions": 105, "deletions": 9, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Foptabs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Foptabs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.cc?ref=dc582d2ef32e2d3723c68d111f4e49607631f34d", "patch": "@@ -46,6 +46,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"libfuncs.h\"\n #include \"internal-fn.h\"\n #include \"langhooks.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n \n static void prepare_float_lib_cmp (rtx, rtx, enum rtx_code, rtx *,\n \t\t\t\t   machine_mode *);\n@@ -4623,7 +4625,8 @@ prepare_operand (enum insn_code icode, rtx x, int opnum, machine_mode mode,\n \n static void\n emit_cmp_and_jump_insn_1 (rtx test, machine_mode mode, rtx label,\n-\t\t\t  profile_probability prob)\n+\t\t\t  direct_optab cmp_optab, profile_probability prob,\n+\t\t\t  bool test_branch)\n {\n   machine_mode optab_mode;\n   enum mode_class mclass;\n@@ -4632,12 +4635,17 @@ emit_cmp_and_jump_insn_1 (rtx test, machine_mode mode, rtx label,\n \n   mclass = GET_MODE_CLASS (mode);\n   optab_mode = (mclass == MODE_CC) ? CCmode : mode;\n-  icode = optab_handler (cbranch_optab, optab_mode);\n+  icode = optab_handler (cmp_optab, optab_mode);\n \n   gcc_assert (icode != CODE_FOR_nothing);\n-  gcc_assert (insn_operand_matches (icode, 0, test));\n-  insn = emit_jump_insn (GEN_FCN (icode) (test, XEXP (test, 0),\n-                                          XEXP (test, 1), label));\n+  gcc_assert (test_branch || insn_operand_matches (icode, 0, test));\n+  if (test_branch)\n+    insn = emit_jump_insn (GEN_FCN (icode) (XEXP (test, 0),\n+\t\t\t\t\t    XEXP (test, 1), label));\n+  else\n+    insn = emit_jump_insn (GEN_FCN (icode) (test, XEXP (test, 0),\n+\t\t\t\t\t    XEXP (test, 1), label));\n+\n   if (prob.initialized_p ()\n       && profile_status_for_fn (cfun) != PROFILE_ABSENT\n       && insn\n@@ -4647,6 +4655,68 @@ emit_cmp_and_jump_insn_1 (rtx test, machine_mode mode, rtx label,\n     add_reg_br_prob_note (insn, prob);\n }\n \n+/* PTEST points to a comparison that compares its first operand with zero.\n+   Check to see if it can be performed as a bit-test-and-branch instead.\n+   On success, return the instruction that performs the bit-test-and-branch\n+   and replace the second operand of *PTEST with the bit number to test.\n+   On failure, return CODE_FOR_nothing and leave *PTEST unchanged.\n+\n+   Note that the comparison described by *PTEST should not be taken\n+   literally after a successful return.  *PTEST is just a convenient\n+   place to store the two operands of the bit-and-test.\n+\n+   VAL must contain the original tree expression for the first operand\n+   of *PTEST.  */\n+\n+static enum insn_code\n+validate_test_and_branch (tree val, rtx *ptest, machine_mode *pmode, optab *res)\n+{\n+  if (!val || TREE_CODE (val) != SSA_NAME)\n+    return CODE_FOR_nothing;\n+\n+  machine_mode mode = TYPE_MODE (TREE_TYPE (val));\n+  rtx test = *ptest;\n+  direct_optab optab;\n+\n+  if (GET_CODE (test) == EQ)\n+    optab = tbranch_eq_optab;\n+  else if (GET_CODE (test) == NE)\n+    optab = tbranch_ne_optab;\n+  else\n+    return CODE_FOR_nothing;\n+\n+  *res = optab;\n+\n+  /* If the target supports the testbit comparison directly, great.  */\n+  auto icode = direct_optab_handler (optab, mode);\n+  if (icode == CODE_FOR_nothing)\n+    return icode;\n+\n+  if (tree_zero_one_valued_p (val))\n+    {\n+      auto pos = BITS_BIG_ENDIAN ? GET_MODE_BITSIZE (mode) - 1 : 0;\n+      XEXP (test, 1) = gen_int_mode (pos, mode);\n+      *ptest = test;\n+      *pmode = mode;\n+      return icode;\n+    }\n+\n+  wide_int wcst = get_nonzero_bits (val);\n+  if (wcst == -1)\n+    return CODE_FOR_nothing;\n+\n+  int bitpos;\n+\n+  if ((bitpos = wi::exact_log2 (wcst)) == -1)\n+    return CODE_FOR_nothing;\n+\n+  auto pos = BITS_BIG_ENDIAN ? GET_MODE_BITSIZE (mode) - 1 - bitpos : bitpos;\n+  XEXP (test, 1) = gen_int_mode (pos, mode);\n+  *ptest = test;\n+  *pmode = mode;\n+  return icode;\n+}\n+\n /* Generate code to compare X with Y so that the condition codes are\n    set and to jump to LABEL if the condition is true.  If X is a\n    constant and Y is not a constant, then the comparison is swapped to\n@@ -4664,11 +4734,13 @@ emit_cmp_and_jump_insn_1 (rtx test, machine_mode mode, rtx label,\n    It will be potentially converted into an unsigned variant based on\n    UNSIGNEDP to select a proper jump instruction.\n    \n-   PROB is the probability of jumping to LABEL.  */\n+   PROB is the probability of jumping to LABEL.  If the comparison is against\n+   zero then VAL contains the expression from which the non-zero RTL is\n+   derived.  */\n \n void\n emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n-\t\t\t machine_mode mode, int unsignedp, rtx label,\n+\t\t\t machine_mode mode, int unsignedp, tree val, rtx label,\n                          profile_probability prob)\n {\n   rtx op0 = x, op1 = y;\n@@ -4693,10 +4765,34 @@ emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n \n   prepare_cmp_insn (op0, op1, comparison, size, unsignedp, OPTAB_LIB_WIDEN,\n \t\t    &test, &mode);\n-  emit_cmp_and_jump_insn_1 (test, mode, label, prob);\n+\n+  /* Check if we're comparing a truth type with 0, and if so check if\n+     the target supports tbranch.  */\n+  machine_mode tmode = mode;\n+  direct_optab optab;\n+  if (op1 == CONST0_RTX (GET_MODE (op1))\n+      && validate_test_and_branch (val, &test, &tmode,\n+\t\t\t\t   &optab) != CODE_FOR_nothing)\n+    {\n+      emit_cmp_and_jump_insn_1 (test, tmode, label, optab, prob, true);\n+      return;\n+    }\n+\n+  emit_cmp_and_jump_insn_1 (test, mode, label, cbranch_optab, prob, false);\n }\n \n-\f\n+/* Overloaded version of emit_cmp_and_jump_insns in which VAL is unknown.  */\n+\n+void\n+emit_cmp_and_jump_insns (rtx x, rtx y, enum rtx_code comparison, rtx size,\n+\t\t\t machine_mode mode, int unsignedp, rtx label,\n+\t\t\t profile_probability prob)\n+{\n+  emit_cmp_and_jump_insns (x, y, comparison, size, mode, unsignedp, NULL,\n+\t\t\t   label, prob);\n+}\n+\n+\n /* Emit a library call comparison between floating point X and Y.\n    COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).  */\n "}, {"sha": "5516a59c1250de57b3824862387bda8edf0b1f43", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=dc582d2ef32e2d3723c68d111f4e49607631f34d", "patch": "@@ -220,6 +220,8 @@ OPTAB_D (reload_in_optab, \"reload_in$a\")\n OPTAB_D (reload_out_optab, \"reload_out$a\")\n \n OPTAB_DC(cbranch_optab, \"cbranch$a4\", COMPARE)\n+OPTAB_D (tbranch_eq_optab, \"tbranch_eq$a3\")\n+OPTAB_D (tbranch_ne_optab, \"tbranch_ne$a3\")\n OPTAB_D (addcc_optab, \"add$acc\")\n OPTAB_D (negcc_optab, \"neg$acc\")\n OPTAB_D (notcc_optab, \"not$acc\")"}, {"sha": "cd55604bc3d452d7e28c5530bb4793d481766f4f", "filename": "gcc/optabs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=dc582d2ef32e2d3723c68d111f4e49607631f34d", "patch": "@@ -268,6 +268,10 @@ extern void emit_cmp_and_jump_insns (rtx, rtx, enum rtx_code, rtx,\n \t\t\t\t     machine_mode, int, rtx,\n \t\t\t\t     profile_probability prob\n \t\t\t\t\t= profile_probability::uninitialized ());\n+extern void emit_cmp_and_jump_insns (rtx, rtx, enum rtx_code, rtx,\n+\t\t\t\t     machine_mode, int, tree, rtx,\n+\t\t\t\t     profile_probability prob\n+\t\t\t\t\t= profile_probability::uninitialized ());\n \n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n extern void emit_indirect_jump (rtx);"}, {"sha": "31d0dcaf249efdf97ce12824bfd3ea50f67c2834", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc582d2ef32e2d3723c68d111f4e49607631f34d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=dc582d2ef32e2d3723c68d111f4e49607631f34d", "patch": "@@ -4722,6 +4722,7 @@ extern tree signed_or_unsigned_type_for (int, tree);\n extern tree signed_type_for (tree);\n extern tree unsigned_type_for (tree);\n extern bool is_truth_type_for (tree, tree);\n+extern bool tree_zero_one_valued_p (tree);\n extern tree truth_type_for (tree);\n extern tree build_pointer_type_for_mode (tree, machine_mode, bool);\n extern tree build_pointer_type (tree);"}]}