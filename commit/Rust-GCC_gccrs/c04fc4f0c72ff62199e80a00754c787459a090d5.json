{"sha": "c04fc4f0c72ff62199e80a00754c787459a090d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA0ZmM0ZjBjNzJmZjYyMTk5ZTgwYTAwNzU0Yzc4NzQ1OWEwOTBkNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-08-05T22:18:33Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-08-05T22:18:33Z"}, "message": "rtlanal.c (nonzero_bits1): Use unsigned HOST_WIDE_INT in all mask computations.\n\n\t* rtlanal.c (nonzero_bits1): Use unsigned HOST_WIDE_INT in all mask\n\tcomputations.  Fix formatting issues.\n\t(num_sign_bit_copies1): Likewise.\n\t(canonicalize_condition): Likewise.\n\nFrom-SVN: r162923", "tree": {"sha": "261a05fadc2cb2e675130ede44c82a9fcf824d44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/261a05fadc2cb2e675130ede44c82a9fcf824d44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c04fc4f0c72ff62199e80a00754c787459a090d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c04fc4f0c72ff62199e80a00754c787459a090d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c04fc4f0c72ff62199e80a00754c787459a090d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c04fc4f0c72ff62199e80a00754c787459a090d5/comments", "author": null, "committer": null, "parents": [{"sha": "bd95721f862876dac7d1560806b18015bb5bbeb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd95721f862876dac7d1560806b18015bb5bbeb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd95721f862876dac7d1560806b18015bb5bbeb6"}], "stats": {"total": 121, "additions": 68, "deletions": 53}, "files": [{"sha": "43a30e764e84a681c507caf50a0c9f40fb6122c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c04fc4f0c72ff62199e80a00754c787459a090d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c04fc4f0c72ff62199e80a00754c787459a090d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c04fc4f0c72ff62199e80a00754c787459a090d5", "patch": "@@ -1,3 +1,10 @@\n+2010-08-05  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* rtlanal.c (nonzero_bits1): Use unsigned HOST_WIDE_INT in all mask\n+\tcomputations.  Fix formatting issues.\n+\t(num_sign_bit_copies1): Likewise.\n+\t(canonicalize_condition): Likewise.\n+\n 2010-08-05  Richard Henderson  <rth@redhat.com>\n \n \t* toplev.h (ctz_hwi, clz_hwi, ffs_hwi): New."}, {"sha": "f9e687157e3d7d746f1d5650d31ca481cd439ded", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c04fc4f0c72ff62199e80a00754c787459a090d5/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c04fc4f0c72ff62199e80a00754c787459a090d5/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c04fc4f0c72ff62199e80a00754c787459a090d5", "patch": "@@ -3802,12 +3802,14 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n     case CONST_INT:\n #ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n       /* If X is negative in MODE, sign-extend the value.  */\n-      if (INTVAL (x) > 0 && mode_width < BITS_PER_WORD\n-\t  && 0 != (INTVAL (x) & ((HOST_WIDE_INT) 1 << (mode_width - 1))))\n-\treturn (INTVAL (x) | ((HOST_WIDE_INT) (-1) << mode_width));\n+      if (INTVAL (x) > 0\n+\t  && mode_width < BITS_PER_WORD\n+\t  && (UINTVAL (x) & ((unsigned HOST_WIDE_INT) 1 << (mode_width - 1)))\n+\t     != 0)\n+\treturn UINTVAL (x) | ((unsigned HOST_WIDE_INT) (-1) << mode_width);\n #endif\n \n-      return INTVAL (x);\n+      return UINTVAL (x);\n \n     case MEM:\n #ifdef LOAD_EXTEND_OP\n@@ -3884,7 +3886,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t{\n \t  inner_nz &= GET_MODE_MASK (GET_MODE (XEXP (x, 0)));\n \t  if (inner_nz\n-\t      & (((HOST_WIDE_INT) 1\n+\t      & (((unsigned HOST_WIDE_INT) 1\n \t\t  << (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1))))\n \t    inner_nz |= (GET_MODE_MASK (mode)\n \t\t\t & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0))));\n@@ -3903,9 +3905,9 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n     case XOR:   case IOR:\n     case UMIN:  case UMAX:  case SMIN:  case SMAX:\n       {\n-\tunsigned HOST_WIDE_INT nonzero0 =\n-\t  cached_nonzero_bits (XEXP (x, 0), mode,\n-\t\t\t       known_x, known_mode, known_ret);\n+\tunsigned HOST_WIDE_INT nonzero0\n+\t   = cached_nonzero_bits (XEXP (x, 0), mode,\n+\t\t\t\t  known_x, known_mode, known_ret);\n \n \t/* Don't call nonzero_bits for the second time if it cannot change\n \t   anything.  */\n@@ -3925,21 +3927,21 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t computing the width (position of the highest-order nonzero bit)\n \t and the number of low-order zero bits for each value.  */\n       {\n-\tunsigned HOST_WIDE_INT nz0 =\n-\t  cached_nonzero_bits (XEXP (x, 0), mode,\n-\t\t\t       known_x, known_mode, known_ret);\n-\tunsigned HOST_WIDE_INT nz1 =\n-\t  cached_nonzero_bits (XEXP (x, 1), mode,\n-\t\t\t       known_x, known_mode, known_ret);\n+\tunsigned HOST_WIDE_INT nz0\n+\t  = cached_nonzero_bits (XEXP (x, 0), mode,\n+\t\t\t\t known_x, known_mode, known_ret);\n+\tunsigned HOST_WIDE_INT nz1\n+\t  = cached_nonzero_bits (XEXP (x, 1), mode,\n+\t\t\t\t known_x, known_mode, known_ret);\n \tint sign_index = GET_MODE_BITSIZE (GET_MODE (x)) - 1;\n \tint width0 = floor_log2 (nz0) + 1;\n \tint width1 = floor_log2 (nz1) + 1;\n \tint low0 = floor_log2 (nz0 & -nz0);\n \tint low1 = floor_log2 (nz1 & -nz1);\n-\tHOST_WIDE_INT op0_maybe_minusp\n-\t  = (nz0 & ((HOST_WIDE_INT) 1 << sign_index));\n-\tHOST_WIDE_INT op1_maybe_minusp\n-\t  = (nz1 & ((HOST_WIDE_INT) 1 << sign_index));\n+\tunsigned HOST_WIDE_INT op0_maybe_minusp\n+\t  = nz0 & ((unsigned HOST_WIDE_INT) 1 << sign_index);\n+\tunsigned HOST_WIDE_INT op1_maybe_minusp\n+\t  = nz1 & ((unsigned HOST_WIDE_INT) 1 << sign_index);\n \tunsigned int result_width = mode_width;\n \tint result_low = 0;\n \n@@ -3959,7 +3961,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t  case DIV:\n \t    if (width1 == 0)\n \t      break;\n-\t    if (! op0_maybe_minusp && ! op1_maybe_minusp)\n+\t    if (!op0_maybe_minusp && !op1_maybe_minusp)\n \t      result_width = width0;\n \t    break;\n \t  case UDIV:\n@@ -3970,7 +3972,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t  case MOD:\n \t    if (width1 == 0)\n \t      break;\n-\t    if (! op0_maybe_minusp && ! op1_maybe_minusp)\n+\t    if (!op0_maybe_minusp && !op1_maybe_minusp)\n \t      result_width = MIN (width0, width1);\n \t    result_low = MIN (low0, low1);\n \t    break;\n@@ -3985,10 +3987,10 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t  }\n \n \tif (result_width < mode_width)\n-\t  nonzero &= ((HOST_WIDE_INT) 1 << result_width) - 1;\n+\t  nonzero &= ((unsigned HOST_WIDE_INT) 1 << result_width) - 1;\n \n \tif (result_low > 0)\n-\t  nonzero &= ~(((HOST_WIDE_INT) 1 << result_low) - 1);\n+\t  nonzero &= ~(((unsigned HOST_WIDE_INT) 1 << result_low) - 1);\n \n #ifdef POINTERS_EXTEND_UNSIGNED\n \t/* If pointers extend unsigned and this is an addition or subtraction\n@@ -4009,7 +4011,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n     case ZERO_EXTRACT:\n       if (CONST_INT_P (XEXP (x, 1))\n \t  && INTVAL (XEXP (x, 1)) < HOST_BITS_PER_WIDE_INT)\n-\tnonzero &= ((HOST_WIDE_INT) 1 << INTVAL (XEXP (x, 1))) - 1;\n+\tnonzero &= ((unsigned HOST_WIDE_INT) 1 << INTVAL (XEXP (x, 1))) - 1;\n       break;\n \n     case SUBREG:\n@@ -4074,9 +4076,9 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t  unsigned int width = GET_MODE_BITSIZE (inner_mode);\n \t  int count = INTVAL (XEXP (x, 1));\n \t  unsigned HOST_WIDE_INT mode_mask = GET_MODE_MASK (inner_mode);\n-\t  unsigned HOST_WIDE_INT op_nonzero =\n-\t    cached_nonzero_bits (XEXP (x, 0), mode,\n-\t\t\t\t known_x, known_mode, known_ret);\n+\t  unsigned HOST_WIDE_INT op_nonzero\n+\t    = cached_nonzero_bits (XEXP (x, 0), mode,\n+\t\t\t\t   known_x, known_mode, known_ret);\n \t  unsigned HOST_WIDE_INT inner = op_nonzero & mode_mask;\n \t  unsigned HOST_WIDE_INT outer = 0;\n \n@@ -4092,8 +4094,9 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t      /* If the sign bit may have been nonzero before the shift, we\n \t\t need to mark all the places it could have been copied to\n \t\t by the shift as possibly nonzero.  */\n-\t      if (inner & ((HOST_WIDE_INT) 1 << (width - 1 - count)))\n-\t\tinner |= (((HOST_WIDE_INT) 1 << count) - 1) << (width - count);\n+\t      if (inner & ((unsigned HOST_WIDE_INT) 1 << (width - 1 - count)))\n+\t\tinner |= (((unsigned HOST_WIDE_INT) 1 << count) - 1)\n+\t\t\t   << (width - count);\n \t    }\n \t  else if (code == ASHIFT)\n \t    inner <<= count;\n@@ -4108,14 +4111,15 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n     case FFS:\n     case POPCOUNT:\n       /* This is at most the number of bits in the mode.  */\n-      nonzero = ((HOST_WIDE_INT) 2 << (floor_log2 (mode_width))) - 1;\n+      nonzero = ((unsigned HOST_WIDE_INT) 2 << (floor_log2 (mode_width))) - 1;\n       break;\n \n     case CLZ:\n       /* If CLZ has a known value at zero, then the nonzero bits are\n \t that value, plus the number of bits in the mode minus one.  */\n       if (CLZ_DEFINED_VALUE_AT_ZERO (mode, nonzero))\n-\tnonzero |= ((HOST_WIDE_INT) 1 << (floor_log2 (mode_width))) - 1;\n+\tnonzero\n+\t  |= ((unsigned HOST_WIDE_INT) 1 << (floor_log2 (mode_width))) - 1;\n       else\n \tnonzero = -1;\n       break;\n@@ -4124,7 +4128,8 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       /* If CTZ has a known value at zero, then the nonzero bits are\n \t that value, plus the number of bits in the mode minus one.  */\n       if (CTZ_DEFINED_VALUE_AT_ZERO (mode, nonzero))\n-\tnonzero |= ((HOST_WIDE_INT) 1 << (floor_log2 (mode_width))) - 1;\n+\tnonzero\n+\t  |= ((unsigned HOST_WIDE_INT) 1 << (floor_log2 (mode_width))) - 1;\n       else\n \tnonzero = -1;\n       break;\n@@ -4135,9 +4140,9 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \n     case IF_THEN_ELSE:\n       {\n-\tunsigned HOST_WIDE_INT nonzero_true =\n-\t  cached_nonzero_bits (XEXP (x, 1), mode,\n-\t\t\t       known_x, known_mode, known_ret);\n+\tunsigned HOST_WIDE_INT nonzero_true\n+\t  = cached_nonzero_bits (XEXP (x, 1), mode,\n+\t\t\t\t known_x, known_mode, known_ret);\n \n \t/* Don't call nonzero_bits for the second time if it cannot change\n \t   anything.  */\n@@ -4310,9 +4315,9 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n     case CONST_INT:\n       /* If the constant is negative, take its 1's complement and remask.\n \t Then see how many zero bits we have.  */\n-      nonzero = INTVAL (x) & GET_MODE_MASK (mode);\n+      nonzero = UINTVAL (x) & GET_MODE_MASK (mode);\n       if (bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t  && (nonzero & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \tnonzero = (~nonzero) & GET_MODE_MASK (mode);\n \n       return (nonzero == 0 ? bitwidth : bitwidth - floor_log2 (nonzero) - 1);\n@@ -4414,7 +4419,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \treturn bitwidth;\n \n       if (num0 > 1\n-\t  && (((HOST_WIDE_INT) 1 << (bitwidth - 1)) & nonzero))\n+\t  && (((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1)) & nonzero))\n \tnum0--;\n \n       return num0;\n@@ -4435,15 +4440,17 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t  && num1 > 1\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n \t  && CONST_INT_P (XEXP (x, 1))\n-\t  && !(INTVAL (XEXP (x, 1)) & ((HOST_WIDE_INT) 1 << (bitwidth - 1))))\n+\t  && (UINTVAL (XEXP (x, 1))\n+\t      & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) == 0)\n \treturn num1;\n \n       /* Similarly for IOR when setting high-order bits.  */\n       if (code == IOR\n \t  && num1 > 1\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n \t  && CONST_INT_P (XEXP (x, 1))\n-\t  && (INTVAL (XEXP (x, 1)) & ((HOST_WIDE_INT) 1 << (bitwidth - 1))))\n+\t  && (UINTVAL (XEXP (x, 1))\n+\t      & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \treturn num1;\n \n       return MIN (num0, num1);\n@@ -4458,7 +4465,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t  && bitwidth <= HOST_BITS_PER_WIDE_INT)\n \t{\n \t  nonzero = nonzero_bits (XEXP (x, 0), mode);\n-\t  if ((((HOST_WIDE_INT) 1 << (bitwidth - 1)) & nonzero) == 0)\n+\t  if ((((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1)) & nonzero) == 0)\n \t    return (nonzero == 1 || nonzero == 0 ? bitwidth\n \t\t    : bitwidth - floor_log2 (nonzero) - 1);\n \t}\n@@ -4501,9 +4508,10 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       if (result > 0\n \t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n \t      || (((nonzero_bits (XEXP (x, 0), mode)\n-\t\t    & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t\t    & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \t\t  && ((nonzero_bits (XEXP (x, 1), mode)\n-\t\t       & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))))\n+\t\t       & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1)))\n+\t\t      != 0))))\n \tresult--;\n \n       return MAX (1, result);\n@@ -4515,7 +4523,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       if (bitwidth > HOST_BITS_PER_WIDE_INT)\n \treturn 1;\n       else if ((nonzero_bits (XEXP (x, 0), mode)\n-\t\t& ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t\t& ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \treturn 1;\n       else\n \treturn cached_num_sign_bit_copies (XEXP (x, 0), mode,\n@@ -4528,7 +4536,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       if (bitwidth > HOST_BITS_PER_WIDE_INT)\n \treturn 1;\n       else if ((nonzero_bits (XEXP (x, 1), mode)\n-\t\t& ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t\t& ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \treturn 1;\n       else\n \treturn cached_num_sign_bit_copies (XEXP (x, 1), mode,\n@@ -4543,7 +4551,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       if (result > 1\n \t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n \t      || (nonzero_bits (XEXP (x, 1), mode)\n-\t\t  & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))\n+\t\t  & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))\n \tresult--;\n \n       return result;\n@@ -4554,7 +4562,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       if (result > 1\n \t  && (bitwidth > HOST_BITS_PER_WIDE_INT\n \t      || (nonzero_bits (XEXP (x, 1), mode)\n-\t\t  & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))\n+\t\t  & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0))\n \tresult--;\n \n       return result;\n@@ -4598,7 +4606,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t Then see how many zero bits we have.  */\n       nonzero = STORE_FLAG_VALUE;\n       if (bitwidth <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n+\t  && (nonzero & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \tnonzero = (~nonzero) & GET_MODE_MASK (mode);\n \n       return (nonzero == 0 ? bitwidth : bitwidth - floor_log2 (nonzero) - 1);\n@@ -4617,7 +4625,7 @@ num_sign_bit_copies1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n     return 1;\n \n   nonzero = nonzero_bits (x, mode);\n-  return nonzero & ((HOST_WIDE_INT) 1 << (bitwidth - 1))\n+  return nonzero & ((unsigned HOST_WIDE_INT) 1 << (bitwidth - 1))\n \t ? 1 : bitwidth - floor_log2 (nonzero) - 1;\n }\n \n@@ -4803,7 +4811,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t\t\t && (GET_MODE_BITSIZE (inner_mode)\n \t\t\t     <= HOST_BITS_PER_WIDE_INT)\n \t\t\t && (STORE_FLAG_VALUE\n-\t\t\t     & ((HOST_WIDE_INT) 1\n+\t\t\t     & ((unsigned HOST_WIDE_INT) 1\n \t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t     || (code == LT\n@@ -4823,7 +4831,7 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t\t\t     <= HOST_BITS_PER_WIDE_INT)\n \t\t\t && GET_MODE_CLASS (inner_mode) == MODE_INT\n \t\t\t && (STORE_FLAG_VALUE\n-\t\t\t     & ((HOST_WIDE_INT) 1\n+\t\t\t     & ((unsigned HOST_WIDE_INT) 1\n \t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t     || (code == GE\n@@ -4906,9 +4914,9 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t/* When cross-compiling, const_val might be sign-extended from\n \t   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */\n \tcase GE:\n-\t  if ((HOST_WIDE_INT) (const_val & max_val)\n-\t      != (((HOST_WIDE_INT) 1\n-\t\t   << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1))))\n+\t  if ((const_val & max_val)\n+\t      != ((unsigned HOST_WIDE_INT) 1\n+\t\t  << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1)))\n \t    code = GT, op1 = gen_int_mode (const_val - 1, GET_MODE (op0));\n \t  break;\n "}]}