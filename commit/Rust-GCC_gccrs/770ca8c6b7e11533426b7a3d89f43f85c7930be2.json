{"sha": "770ca8c6b7e11533426b7a3d89f43f85c7930be2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcwY2E4YzZiN2UxMTUzMzQyNmI3YTNkODlmNDNmODVjNzkzMGJlMg==", "commit": {"author": {"name": "Jeffrey Oldham", "email": "oldham@codesourcery.com", "date": "2001-02-02T06:11:26Z"}, "committer": {"name": "Jeffrey D. Oldham", "email": "oldham@gcc.gnu.org", "date": "2001-02-02T06:11:26Z"}, "message": "dwarf2out.c: Added explanation of abbreviations.\n\n2001-02-01  Jeffrey Oldham  <oldham@codesourcery.com>\n\n\t* dwarf2out.c: Added explanation of abbreviations.\n\t(def_cfa_1): Added comments listing DWARF2 instructions.\n\t(cfa_temp_reg): Removed in favor of cfa_temp.\n\t(cfa_temp_value): Removed in favor of cfa_temp.\n\t(cfa_temp): New global variable.\n\t(dwarf2out_frame_debug_expr): Added extensive introductory\n\tcomments explaining the function's transformations.  Revised to\n\tuse cfa_temp.  Added some rtx checking.  Generalize IOR case.\n\t(dwarf2out_frame_debug): Revised to use cfa_temp.\n\t(output_aranges): Cast as \"unsigned\" to avoid warning.\n\t* rtl.texi (RTX_FRAME_RELATED_P): Revise entry to emphasize better\n\texplain which instructions must be marked.\n\nFrom-SVN: r39405", "tree": {"sha": "15995aff0502d1a28e4aba64804b5e5410d3ac7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15995aff0502d1a28e4aba64804b5e5410d3ac7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/770ca8c6b7e11533426b7a3d89f43f85c7930be2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770ca8c6b7e11533426b7a3d89f43f85c7930be2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/770ca8c6b7e11533426b7a3d89f43f85c7930be2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770ca8c6b7e11533426b7a3d89f43f85c7930be2/comments", "author": null, "committer": null, "parents": [{"sha": "cad33336eefc5d1cab42875de40c814685346265", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad33336eefc5d1cab42875de40c814685346265", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad33336eefc5d1cab42875de40c814685346265"}], "stats": {"total": 259, "additions": 230, "deletions": 29}, "files": [{"sha": "acf5120e56043acac80c55d325a9e751bd665f27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770ca8c6b7e11533426b7a3d89f43f85c7930be2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770ca8c6b7e11533426b7a3d89f43f85c7930be2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=770ca8c6b7e11533426b7a3d89f43f85c7930be2", "patch": "@@ -1,3 +1,18 @@\n+2001-02-01  Jeffrey Oldham  <oldham@codesourcery.com>\n+\n+\t* dwarf2out.c: Added explanation of abbreviations.\n+\t(def_cfa_1): Added comments listing DWARF2 instructions.\n+\t(cfa_temp_reg): Removed in favor of cfa_temp.\n+\t(cfa_temp_value): Removed in favor of cfa_temp.\n+\t(cfa_temp): New global variable.\n+\t(dwarf2out_frame_debug_expr): Added extensive introductory\n+\tcomments explaining the function's transformations.  Revised to\n+\tuse cfa_temp.  Added some rtx checking.  Generalize IOR case.\n+\t(dwarf2out_frame_debug): Revised to use cfa_temp.\n+\t(output_aranges): Cast as \"unsigned\" to avoid warning.\n+\t* rtl.texi (RTX_FRAME_RELATED_P): Revise entry to emphasize better\n+\texplain which instructions must be marked.\n+\n 2001-02-01  Richard Henderson  <rth@redhat.com>\n \n \t* local-alloc.c (update_equiv_regs): Copy INSN_CODE to the"}, {"sha": "04bfdbc8eab0791fa0b6aa8d7a59431a372cf552", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 192, "deletions": 25, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770ca8c6b7e11533426b7a3d89f43f85c7930be2/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770ca8c6b7e11533426b7a3d89f43f85c7930be2/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=770ca8c6b7e11533426b7a3d89f43f85c7930be2", "patch": "@@ -55,6 +55,24 @@ Boston, MA 02111-1307, USA.  */\n #include \"md5.h\"\n #include \"tm_p.h\"\n \n+/* DWARF2 Abbreviation Glossary:\n+   CFA = Canonical Frame Address\n+\t   stack address identifying a stack call frame; its value is\n+\t   the value of the stack pointer just before the call to the\n+\t   current function\n+   CFI = Canonical Frame Instruction\n+           information describing entries in a stack call frame, e.g.,\n+\t   CIE and FDE\n+   CIE = Common Information Entry\n+\t   information describing information common to one or more FDEs\n+   DIE = Debugging Information Entry\n+   FDE = Frame Description Entry\n+\t   information describing the stack call frame, in particular,\n+\t   how to restore registers\n+\n+   DW_CFA_... = DWARF2 CFA call frame instruction\n+   DW_TAG_... = DWARF2 DIE tag */\n+\n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n \n@@ -855,7 +873,7 @@ dwarf2out_def_cfa (label, reg, offset)\n   def_cfa_1 (label, &loc);\n }\n \n-/* This routine does the actual work. The CFA is now calculated from\n+/* This routine does the actual work.  The CFA is now calculated from\n    the dw_cfa_location structure.  */\n static void\n def_cfa_1 (label, loc_p)\n@@ -879,13 +897,18 @@ def_cfa_1 (label, loc_p)\n     {\n       if (loc.indirect == 0\n \t  || loc.base_offset == old_cfa.base_offset)\n+\t/* Nothing changed so no need to issue any call frame\n+           instructions.  */\n \treturn;\n     }\n \n   cfi = new_cfi ();\n \n   if (loc.reg == old_cfa.reg && !loc.indirect)\n     {\n+      /* Construct a \"DW_CFA_def_cfa_offset <offset>\" instruction,\n+\t indicating the CFA register did not change but the offset\n+\t did.  */\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_offset;\n       cfi->dw_cfi_oprnd1.dw_cfi_offset = loc.offset;\n     }\n@@ -894,19 +917,28 @@ def_cfa_1 (label, loc_p)\n   else if (loc.offset == old_cfa.offset && old_cfa.reg != (unsigned long) -1\n \t   && !loc.indirect)\n     {\n+      /* Construct a \"DW_CFA_def_cfa_register <register>\" instruction,\n+\t indicating the CFA register has changed to <register> but the\n+\t offset has not changed.  */\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_register;\n       cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n     }\n #endif\n \n   else if (loc.indirect == 0)\n     {\n+      /* Construct a \"DW_CFA_def_cfa <register> <offset>\" instruction,\n+\t indicating the CFA register has changed to <register> with\n+\t the specified offset.  */\n       cfi->dw_cfi_opc = DW_CFA_def_cfa;\n       cfi->dw_cfi_oprnd1.dw_cfi_reg_num = loc.reg;\n       cfi->dw_cfi_oprnd2.dw_cfi_offset = loc.offset;\n     }\n   else\n     {\n+      /* Construct a DW_CFA_def_cfa_expression instruction to\n+\t calculate the CFA using a full location expression since no\n+\t register-offset pair is available.  */\n       struct dw_loc_descr_struct *loc_list;\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_expression;\n       loc_list = build_cfa_loc (&loc);\n@@ -1237,15 +1269,132 @@ dwarf2out_stack_adjust (insn)\n   dwarf2out_args_size (label, args_size);\n }\n \n-/* A temporary register used in adjusting SP or setting up the store_reg.  */\n-static unsigned cfa_temp_reg;\n-\n-/* A temporary value used in adjusting SP or setting up the store_reg.  */\n-static long cfa_temp_value;\n-\n-/* Record call frame debugging information for an expression, which either\n-   sets SP or FP (adjusting how we calculate the frame address) or saves a\n-   register to the stack.  */\n+/* A temporary register holding an integral value used in adjusting SP\n+   or setting up the store_reg.  The \"offset\" field holds the integer\n+   value, not an offset.  */\n+dw_cfa_location cfa_temp;\n+\n+/* Record call frame debugging information for an expression EXPR,\n+   which either sets SP or FP (adjusting how we calculate the frame\n+   address) or saves a register to the stack.  LABEL indicates the\n+   address of EXPR.\n+\n+   This function encodes a state machine mapping rtxes to actions on\n+   cfa, cfa_store, and cfa_temp.reg.  We describe these rules so\n+   users need not read the source code.\n+\n+  Invariants / Summaries of Rules\n+\n+  cfa\t       current register used to calculate the DWARF2 canonical\n+\t       frame address register and offset\n+  cfa_store    register used by prologue code to save things to the stack\n+\t       cfa_store.offset is the offset from the value of\n+\t       cfa_store.reg to the actual CFA\n+  cfa_temp     register holding an integral value.  cfa_temp.offset\n+\t       stores the value, which will be used to adjust the\n+\t       stack pointer.\n+ \n+  Rules  1- 4: Setting a register's value to cfa.reg or an expression\n+  \t       with cfa.reg as the first operand changes the cfa.reg and its\n+\t       cfa.offset.\n+\t       (For an unknown reason, Rule 4 does not fully obey the\n+\t       invariant.)\n+\n+  Rules  6- 9: Set a non-cfa.reg register value to a constant or an\n+\t       expression yielding a constant.  This sets cfa_temp.reg\n+\t       and cfa_temp.offset.\n+\n+  Rule 5:      Create a new register cfa_store used to save items to the\n+\t       stack.\n+\n+  Rules 10-13: Save a register to the stack.  Record the location in\n+\t       cfa_store.offset.  Define offset as the difference of\n+\t       the original location and cfa_store's location.\n+\n+  The Rules\n+\n+  \"{a,b}\" indicates a choice of a xor b.\n+  \"<reg>:cfa.reg\" indicates that <reg> must equal cfa.reg.\n+\n+  Rule 1:\n+  (set <reg1> <reg2>:cfa.reg)\n+  effects: cfa.reg = <REG1>\n+           cfa.offset unchanged\n+\n+  Rule 2:\n+  (set sp ({minus,plus} {sp,fp}:cfa.reg {<const_int>,<reg>:cfa_temp.reg}))\n+  effects: cfa.reg = sp if fp used\n+ \t   cfa.offset += {+/- <const_int>, cfa_temp.offset} if cfa.reg==sp\n+\t   cfa_store.offset += {+/- <const_int>, cfa_temp.offset}\n+\t     if cfa_store.reg==sp\n+\n+  Rule 3:\n+  (set fp ({minus,plus} <reg>:cfa.reg <const_int>))\n+  effects: cfa.reg = fp\n+  \t   cfa_offset += +/- <const_int>\n+\n+  Rule 4:\n+  (set <reg1> (plus <reg2>:cfa.reg <const_int>))\n+  constraints: <reg1> != fp\n+  \t       <reg1> != sp\n+  effects: cfa.reg = <reg1>\n+  questions: Where is <const_int> used?\n+\t     Should cfa.offset be changed?\n+\n+  Rule 5:\n+  (set <reg1> (plus <reg2>:cfa_temp.reg sp:cfa.reg))\n+  constraints: <reg1> != fp\n+  \t       <reg1> != sp\n+  effects: cfa_store.reg = <reg1>\n+  \t   cfa_store.offset = cfa.offset - cfa_temp.offset\n+\n+  Rule 6:\n+  (set <reg> <const_int>)\n+  effects: cfa_temp.reg = <reg>\n+  \t   cfa_temp.offset = <const_int>\n+\n+  Rule 7:\n+  (set <reg1>:cfa_temp.reg (ior <reg2>:cfa_temp.reg <const_int>))\n+  effects: cfa_temp.reg = <reg1>\n+\t   cfa_temp.offset |= <const_int>\n+\n+  Rule 8:\n+  (set <reg> (high <exp>))\n+  effects: none\n+\n+  Rule 9:\n+  (set <reg> (lo_sum <exp> <const_int>))\n+  effects: cfa_temp.reg = <reg>\n+  \t   cfa_temp.offset = <const_int>\n+\n+  Rule 10:\n+  (set (mem (pre_modify sp:cfa_store (???? <reg1> <const_int>))) <reg2>)\n+  effects: cfa_store.offset -= <const_int>\n+\t   cfa.offset = cfa_store.offset if cfa.reg == sp\n+\t   offset = -cfa_store.offset\n+\t   cfa.reg = sp\n+\t   cfa.base_offset = offset\n+\n+  Rule 11:\n+  (set (mem ({pre_inc,pre_dec} sp:cfa_store.reg)) <reg>)\n+  effects: cfa_store.offset += -/+ mode_size(mem)\n+\t   cfa.offset = cfa_store.offset if cfa.reg == sp\n+\t   offset = -cfa_store.offset\n+\t   cfa.reg = sp\n+\t   cfa.base_offset = offset\n+\n+  Rule 12:\n+  (set (mem ({minus,plus} <reg1>:cfa_store <const_int>)) <reg2>)\n+  effects: cfa_store.offset += -/+ <const_int>\n+\t   offset = -cfa_store.offset\n+\t   cfa.reg = <reg1\n+\t   cfa.base_offset = offset\n+\n+  Rule 13:\n+  (set (mem <reg1>:cfa_store) <reg2>)\n+  effects: offset = -cfa_store.offset\n+\t   cfa.reg = <reg1>\n+\t   cfa.base_offset = offset */\n \n static void\n dwarf2out_frame_debug_expr (expr, label)\n@@ -1257,7 +1406,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \n   /* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of\n      the PARALLEL independently. The first element is always processed if\n-     it is a SET. This is for backward compatability.   Other elements\n+     it is a SET. This is for backward compatibility.   Other elements\n      are processed only if they are SETs and the RTX_FRAME_RELATED_P\n      flag is set in them.  */\n \n@@ -1287,6 +1436,7 @@ dwarf2out_frame_debug_expr (expr, label)\n   switch (GET_CODE (dest))\n     {\n     case REG:\n+      /* Rule 1 */\n       /* Update the CFA rule wrt SP or FP.  Make sure src is\n          relative to the current CFA register.  */\n       switch (GET_CODE (src))\n@@ -1310,16 +1460,17 @@ dwarf2out_frame_debug_expr (expr, label)\n \tcase MINUS:\n \t  if (dest == stack_pointer_rtx)\n \t    {\n+\t      /* Rule 2 */\n \t      /* Adjusting SP.  */\n \t      switch (GET_CODE (XEXP (src, 1)))\n \t\t{\n \t\tcase CONST_INT:\n \t\t  offset = INTVAL (XEXP (src, 1));\n \t\t  break;\n \t\tcase REG:\n-\t\t  if ((unsigned) REGNO (XEXP (src, 1)) != cfa_temp_reg)\n+\t\t  if ((unsigned) REGNO (XEXP (src, 1)) != cfa_temp.reg)\n \t\t    abort ();\n-\t\t  offset = cfa_temp_value;\n+\t\t  offset = cfa_temp.offset;\n \t\t  break;\n \t\tdefault:\n \t\t  abort ();\n@@ -1344,6 +1495,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \t    }\n \t  else if (dest == hard_frame_pointer_rtx)\n \t    {\n+\t      /* Rule 3 */\n \t      /* Either setting the FP from an offset of the SP,\n \t\t or adjusting the FP */\n \t      if (! frame_pointer_needed)\n@@ -1367,39 +1519,44 @@ dwarf2out_frame_debug_expr (expr, label)\n \t      if (GET_CODE (src) != PLUS)\n \t\tabort ();\n \n+\t      /* Rule 4 */\n \t      if (GET_CODE (XEXP (src, 0)) == REG\n \t\t  && REGNO (XEXP (src, 0)) == cfa.reg\n \t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT)\n \t\t/* Setting the FP (or a scratch that will be copied into the FP\n \t\t   later on) from SP + const.  */\n \t\tcfa.reg = REGNO (dest);\n+\t      /* Rule 5 */\n \t      else\n \t\t{\n \t\t  if (XEXP (src, 1) != stack_pointer_rtx)\n \t\t    abort ();\n \t\t  if (GET_CODE (XEXP (src, 0)) != REG\n-\t\t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg)\n+ \t\t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp.reg)\n \t\t    abort ();\n \t\t  if (cfa.reg != STACK_POINTER_REGNUM)\n \t\t    abort ();\n \t\t  cfa_store.reg = REGNO (dest);\n-\t\t  cfa_store.offset = cfa.offset - cfa_temp_value;\n+\t\t  cfa_store.offset = cfa.offset - cfa_temp.offset;\n \t\t}\n \t    }\n \t  break;\n \n+\t  /* Rule 6 */\n \tcase CONST_INT:\n-\t  cfa_temp_reg = REGNO (dest);\n-\t  cfa_temp_value = INTVAL (src);\n+\t  cfa_temp.reg = REGNO (dest);\n+\t  cfa_temp.offset = INTVAL (src);\n \t  break;\n \n+\t  /* Rule 7 */\n \tcase IOR:\n \t  if (GET_CODE (XEXP (src, 0)) != REG\n-\t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp_reg\n-\t      || (unsigned) REGNO (dest) != cfa_temp_reg\n+\t      || (unsigned) REGNO (XEXP (src, 0)) != cfa_temp.reg\n \t      || GET_CODE (XEXP (src, 1)) != CONST_INT)\n \t    abort ();\n-\t  cfa_temp_value |= INTVAL (XEXP (src, 1));\n+\t  if ((unsigned) REGNO (dest) != cfa_temp.reg)\n+\t    cfa_temp.reg = REGNO (dest);\n+\t  cfa_temp.offset |= INTVAL (XEXP (src, 1));\n \t  break;\n \n \tdefault:\n@@ -1410,12 +1567,16 @@ dwarf2out_frame_debug_expr (expr, label)\n \n       /* Skip over HIGH, assuming it will be followed by a LO_SUM, which\n \t will fill in all of the bits.  */\n+      /* Rule 8 */\n     case HIGH:\n       break;\n \n+      /* Rule 9 */\n     case LO_SUM:\n-      cfa_temp_reg = REGNO (dest);\n-      cfa_temp_value = INTVAL (XEXP (src, 1));\n+      if (GET_CODE (XEXP (src, 1)) != CONST_INT)\n+\tabort ();\n+      cfa_temp.reg = REGNO (dest);\n+      cfa_temp.offset = INTVAL (XEXP (src, 1));\n       break;\n \n     case MEM:\n@@ -1426,6 +1587,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \t CFA register.  */\n       switch (GET_CODE (XEXP (dest, 0)))\n \t{\n+\t  /* Rule 10 */\n \t  /* With a push.  */\n \tcase PRE_MODIFY:\n \t  /* We can't handle variable size modifications.  */\n@@ -1442,6 +1604,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \n \t  offset = -cfa_store.offset;\n \t  break;\n+\t  /* Rule 11 */\n \tcase PRE_INC:\n \tcase PRE_DEC:\n \t  offset = GET_MODE_SIZE (GET_MODE (dest));\n@@ -1458,9 +1621,12 @@ dwarf2out_frame_debug_expr (expr, label)\n \t  offset = -cfa_store.offset;\n \t  break;\n \n+\t  /* Rule 12 */\n \t  /* With an offset.  */\n \tcase PLUS:\n \tcase MINUS:\n+\t  if (GET_CODE (XEXP (XEXP (dest, 0), 1)) != CONST_INT)\n+\t    abort ();\n \t  offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n \t  if (GET_CODE (XEXP (dest, 0)) == MINUS)\n \t    offset = -offset;\n@@ -1470,6 +1636,7 @@ dwarf2out_frame_debug_expr (expr, label)\n \t  offset -= cfa_store.offset;\n \t  break;\n \n+\t  /* Rule 13 */\n \t  /* Without an offset.  */\n \tcase REG:\n \t  if (cfa_store.reg != (unsigned) REGNO (XEXP (dest, 0)))\n@@ -1543,8 +1710,8 @@ dwarf2out_frame_debug (insn)\n \tabort ();\n       cfa.reg = STACK_POINTER_REGNUM;\n       cfa_store = cfa;\n-      cfa_temp_reg = -1;\n-      cfa_temp_value = 0;\n+      cfa_temp.reg = -1;\n+      cfa_temp.offset = 0;\n       return;\n     }\n \n@@ -6356,7 +6523,7 @@ output_aranges ()\n       /* Pad using a 2 bytes word so that padding is correct\n          for any pointer size.  */\n       ASM_OUTPUT_DWARF_DATA2 (asm_out_file, 0);\n-      for (i = 2; i < DWARF_ARANGES_PAD_SIZE; i += 2)\n+      for (i = 2; i < (unsigned) DWARF_ARANGES_PAD_SIZE; i += 2)\n \tfprintf (asm_out_file, \",0\");\n       if (flag_debug_asm)\n \tfprintf (asm_out_file, \"\\t%s Pad to %d byte boundary\","}, {"sha": "f75ffcf1e72bcafc508700cbe9b6aee08fd4736e", "filename": "gcc/rtl.texi", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/770ca8c6b7e11533426b7a3d89f43f85c7930be2/gcc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/770ca8c6b7e11533426b7a3d89f43f85c7930be2/gcc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.texi?ref=770ca8c6b7e11533426b7a3d89f43f85c7930be2", "patch": "@@ -458,10 +458,29 @@ Stored in the @code{integrated} field and printed as @samp{/i}.\n \n @findex RTX_FRAME_RELATED_P\n @item RTX_FRAME_RELATED_P (@var{x})\n-Nonzero in an insn or expression which is part of a function\n-prologue and sets the stack pointer, sets the frame pointer, or saves a \n-register. This flag is required for exception handling support\n-on targets with RTL prologues.\n+Nonzero in an insn or expression which is part of a function prologue\n+and sets the stack pointer, sets the frame pointer, or saves a register.\n+This flag should also be set on an instruction that sets up a temporary\n+register to use in place of the frame pointer.\n+\n+In particular, on RISC targets where there are limits on the sizes of\n+immediate constants, it is sometimes impossible to reach the register\n+save area directly from the stack pointer.  In that case, a temporary\n+register is used that is near enough to the register save area, and the\n+Canonical Frame Address, i.e., DWARF2's logical frame pointer, register\n+must (temporarily) be changed to be this temporary register.  So, the\n+instruction that sets this temporary register must be marked as\n+@code{RTX_FRAME_RELATED_P}.\n+\n+If the marked instruction is overly complex (defined in terms of what\n+@code{dwarf2out_frame_debug_expr} can handle), you will also have to\n+create a @code{REG_FRAME_RELATED_EXPR} note and attach it to the\n+instruction.  This note should contain a simple expression of the\n+computation performed by this instruction, i.e., one that\n+@code{dwarf2out_frame_debug_expr} can handle.\n+\n+This flag is required for exception handling support on targets with RTL\n+prologues.\n \n @findex SYMBOL_REF_USED\n @cindex @code{used}, in @code{symbol_ref}"}]}