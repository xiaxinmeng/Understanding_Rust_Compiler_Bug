{"sha": "6ff31ac29db3bdc208083461e8b7a20f7128dd42", "node_id": "C_kwDOANBUbNoAKDZmZjMxYWMyOWRiM2JkYzIwODA4MzQ2MWU4YjdhMjBmNzEyOGRkNDI", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-05-08T13:10:57Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-05-09T16:22:28Z"}, "message": "gccrs: unify how we handle DST's\n\nDST's are not truely reference types they are \"unsized types\" so\nthe exact size of them is not known at compile time. We actually\nachieve this by pretending they are a reference but really its\nstruct we pass around.\n\nFixes #2180\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-expr.cc (CompileExpr::visit): refactr\n\t(CompileExpr::get_fn_addr_from_dyn): likewise\n\t(CompileExpr::get_receiver_from_dyn): likewise\n\t(CompileExpr::type_cast_expression): likewise\n\t* backend/rust-compile-type.cc (TyTyResolveCompile::visit): likewise\n\t(TyTyResolveCompile::create_dyn_obj_record): likewise\n\t(TyTyResolveCompile::create_slice_type_record): likewise\n\t(TyTyResolveCompile::create_str_type_record): likewise\n\t* backend/rust-compile-type.h: likewise\n\t* backend/rust-compile.cc (HIRCompileBase::coercion_site1): likewise\n\t(HIRCompileBase::coerce_to_dyn_object): refactor\n\t* backend/rust-tree.h (SLICE_FLAG): removed\n\t(SLICE_TYPE_P): removed\n\t(RS_DST_FLAG): new flag\n\t(RS_DST_FLAG_P): new predicate\n\t* typecheck/rust-tyty.cc (ReferenceType::is_dyn_object): new helper\n\t(ReferenceType::is_dyn_obj_type): likewise\n\t(PointerType::is_dyn_object): likewise\n\t(PointerType::is_dyn_obj_type): likewise\n\t* typecheck/rust-tyty.h (class DynamicObjectType): moved up\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/execute/torture/issue-2180.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "da9954785178bda4a3c8cb4e152b2d28effc8e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da9954785178bda4a3c8cb4e152b2d28effc8e96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ff31ac29db3bdc208083461e8b7a20f7128dd42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff31ac29db3bdc208083461e8b7a20f7128dd42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff31ac29db3bdc208083461e8b7a20f7128dd42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff31ac29db3bdc208083461e8b7a20f7128dd42/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af58bf3dd274f03235f934dc9d714d1901e66eb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af58bf3dd274f03235f934dc9d714d1901e66eb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af58bf3dd274f03235f934dc9d714d1901e66eb5"}], "stats": {"total": 219, "additions": 157, "deletions": 62}, "files": [{"sha": "8b1f37aea85c043f4d62dbdc46e86dcf9bce0e2f", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=6ff31ac29db3bdc208083461e8b7a20f7128dd42", "patch": "@@ -29,6 +29,7 @@\n #include \"fold-const.h\"\n #include \"realmpfr.h\"\n #include \"convert.h\"\n+#include \"print-tree.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -791,7 +792,7 @@ void\n CompileExpr::visit (HIR::BorrowExpr &expr)\n {\n   tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n-  if (SLICE_TYPE_P (TREE_TYPE (main_expr)))\n+  if (RS_DST_FLAG_P (TREE_TYPE (main_expr)))\n     {\n       translated = main_expr;\n       return;\n@@ -836,7 +837,7 @@ CompileExpr::visit (HIR::DereferenceExpr &expr)\n     }\n \n   tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n-  if (SLICE_TYPE_P (TREE_TYPE (main_expr)) && SLICE_TYPE_P (expected_type))\n+  if (RS_DST_FLAG_P (TREE_TYPE (main_expr)) && RS_DST_FLAG_P (expected_type))\n     {\n       translated = main_expr;\n       return;\n@@ -908,6 +909,10 @@ CompileExpr::visit (HIR::AssignmentExpr &expr)\n \t\t\t  expected, expr.get_lhs ()->get_locus (),\n \t\t\t  expr.get_rhs ()->get_locus ());\n \n+  // rust_debug_loc (expr.get_locus (), \"XXXXXX assignment\");\n+  // debug_tree (rvalue);\n+  // debug_tree (lvalue);\n+\n   tree assignment\n     = ctx->get_backend ()->assignment_statement (lvalue, rvalue,\n \t\t\t\t\t\t expr.get_locus ());\n@@ -1810,13 +1815,6 @@ CompileExpr::get_fn_addr_from_dyn (const TyTy::DynamicObjectType *dyn,\n   if (ref == nullptr)\n     return error_mark_node;\n \n-  // get any indirection sorted out\n-  if (receiver->get_kind () == TyTy::TypeKind::REF)\n-    {\n-      tree indirect = indirect_expression (receiver_ref, expr_locus);\n-      receiver_ref = indirect;\n-    }\n-\n   // cast it to the correct fntype\n   tree expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n   tree idx = build_int_cst (size_type_node, offs);\n@@ -1841,13 +1839,6 @@ CompileExpr::get_receiver_from_dyn (const TyTy::DynamicObjectType *dyn,\n \t\t\t\t    TyTy::FnType *fntype, tree receiver_ref,\n \t\t\t\t    Location expr_locus)\n {\n-  // get any indirection sorted out\n-  if (receiver->get_kind () == TyTy::TypeKind::REF)\n-    {\n-      tree indirect = indirect_expression (receiver_ref, expr_locus);\n-      receiver_ref = indirect;\n-    }\n-\n   // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n   return ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n \t\t\t\t\t\t       expr_locus);\n@@ -2130,7 +2121,7 @@ CompileExpr::type_cast_expression (tree type_to_cast_to, tree expr_tree,\n \t\t\t      type_to_cast_to, expr_tree);\n     }\n   else if (TREE_CODE (type_to_cast_to) == POINTER_TYPE\n-\t   && SLICE_TYPE_P (TREE_TYPE (expr_tree)))\n+\t   && RS_DST_FLAG (TREE_TYPE (expr_tree)))\n     {\n       // returning a raw cast using NOP_EXPR seems to resut in an ICE:\n       //\n@@ -2327,7 +2318,7 @@ HIRCompileBase::resolve_adjustements (\n \n \tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n \t  case Resolver::Adjustment::AdjustmentType::MUT_REF: {\n-\t    if (!SLICE_TYPE_P (TREE_TYPE (e)))\n+\t    if (!RS_DST_FLAG (TREE_TYPE (e)))\n \t      {\n \t\te = address_expression (e, locus);\n \t      }"}, {"sha": "02df5fb6355244f6c276ae076db990b259f4da5b", "filename": "gcc/rust/backend/rust-compile-type.cc", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-compile-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.cc?ref=6ff31ac29db3bdc208083461e8b7a20f7128dd42", "patch": "@@ -576,6 +576,7 @@ TyTyResolveCompile::visit (const TyTy::ReferenceType &type)\n {\n   const TyTy::SliceType *slice = nullptr;\n   const TyTy::StrType *str = nullptr;\n+  const TyTy::DynamicObjectType *dyn = nullptr;\n   if (type.is_dyn_slice_type (&slice))\n     {\n       tree type_record = create_slice_type_record (*slice);\n@@ -601,6 +602,18 @@ TyTyResolveCompile::visit (const TyTy::ReferenceType &type)\n \n       return;\n     }\n+  else if (type.is_dyn_obj_type (&dyn))\n+    {\n+      tree type_record = create_dyn_obj_record (*dyn);\n+      std::string dyn_str_type_str\n+\t= std::string (type.is_mutable () ? \"&mut \" : \"& \") + dyn->get_name ();\n+\n+      translated\n+\t= ctx->get_backend ()->named_type (dyn_str_type_str, type_record,\n+\t\t\t\t\t   dyn->get_locus ());\n+\n+      return;\n+    }\n \n   tree base_compiled_type\n     = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n@@ -620,6 +633,7 @@ TyTyResolveCompile::visit (const TyTy::PointerType &type)\n {\n   const TyTy::SliceType *slice = nullptr;\n   const TyTy::StrType *str = nullptr;\n+  const TyTy::DynamicObjectType *dyn = nullptr;\n   if (type.is_dyn_slice_type (&slice))\n     {\n       tree type_record = create_slice_type_record (*slice);\n@@ -645,6 +659,19 @@ TyTyResolveCompile::visit (const TyTy::PointerType &type)\n \n       return;\n     }\n+  else if (type.is_dyn_obj_type (&dyn))\n+    {\n+      tree type_record = create_dyn_obj_record (*dyn);\n+      std::string dyn_str_type_str\n+\t= std::string (type.is_mutable () ? \"*mut \" : \"*const \")\n+\t  + dyn->get_name ();\n+\n+      translated\n+\t= ctx->get_backend ()->named_type (dyn_str_type_str, type_record,\n+\t\t\t\t\t   dyn->get_locus ());\n+\n+      return;\n+    }\n \n   tree base_compiled_type\n     = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n@@ -684,6 +711,14 @@ TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n       return;\n     }\n \n+  tree type_record = create_dyn_obj_record (type);\n+  translated = ctx->get_backend ()->named_type (type.get_name (), type_record,\n+\t\t\t\t\t\ttype.get_ident ().locus);\n+}\n+\n+tree\n+TyTyResolveCompile::create_dyn_obj_record (const TyTy::DynamicObjectType &type)\n+{\n   // create implicit struct\n   auto items = type.get_object_items ();\n   std::vector<Backend::typed_identifier> fields;\n@@ -704,9 +739,11 @@ TyTyResolveCompile::visit (const TyTy::DynamicObjectType &type)\n \t\t\t\t   type.get_ty_ref ()));\n   fields.push_back (std::move (vtf));\n \n-  tree type_record = ctx->get_backend ()->struct_type (fields);\n-  translated = ctx->get_backend ()->named_type (type.get_name (), type_record,\n-\t\t\t\t\t\ttype.get_ident ().locus);\n+  tree record = ctx->get_backend ()->struct_type (fields);\n+  RS_DST_FLAG (record) = 1;\n+  TYPE_MAIN_VARIANT (record) = ctx->insert_main_variant (record);\n+\n+  return record;\n }\n \n tree\n@@ -727,7 +764,7 @@ TyTyResolveCompile::create_slice_type_record (const TyTy::SliceType &type)\n   Backend::typed_identifier len_field (\"len\", len_field_ty, type.get_locus ());\n \n   tree record = ctx->get_backend ()->struct_type ({data_field, len_field});\n-  SLICE_FLAG (record) = 1;\n+  RS_DST_FLAG (record) = 1;\n   TYPE_MAIN_VARIANT (record) = ctx->insert_main_variant (record);\n \n   return record;\n@@ -753,7 +790,7 @@ TyTyResolveCompile::create_str_type_record (const TyTy::StrType &type)\n   Backend::typed_identifier len_field (\"len\", len_field_ty, type.get_locus ());\n \n   tree record = ctx->get_backend ()->struct_type ({data_field, len_field});\n-  SLICE_FLAG (record) = 1;\n+  RS_DST_FLAG (record) = 1;\n   TYPE_MAIN_VARIANT (record) = ctx->insert_main_variant (record);\n \n   return record;"}, {"sha": "7f288f1cd6aecf3cf572398028e87e41f36a6286", "filename": "gcc/rust/backend/rust-compile-type.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-compile-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-type.h?ref=6ff31ac29db3bdc208083461e8b7a20f7128dd42", "patch": "@@ -65,6 +65,7 @@ class TyTyResolveCompile : protected TyTy::TyConstVisitor\n protected:\n   tree create_slice_type_record (const TyTy::SliceType &type);\n   tree create_str_type_record (const TyTy::StrType &type);\n+  tree create_dyn_obj_record (const TyTy::DynamicObjectType &type);\n \n private:\n   TyTyResolveCompile (Context *ctx, bool trait_object_mode);"}, {"sha": "e6408bc4d1a14752b36629052e6ee63a39085a5a", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=6ff31ac29db3bdc208083461e8b7a20f7128dd42", "patch": "@@ -78,7 +78,7 @@ HIRCompileBase::coercion_site1 (tree rvalue, TyTy::BaseType *rval,\n   if (expected->get_kind () == TyTy::TypeKind::REF)\n     {\n       // this is a dyn object\n-      if (SLICE_TYPE_P (TREE_TYPE (rvalue)))\n+      if (RS_DST_FLAG_P (TREE_TYPE (rvalue)))\n \t{\n \t  return rvalue;\n \t}\n@@ -96,15 +96,15 @@ HIRCompileBase::coercion_site1 (tree rvalue, TyTy::BaseType *rval,\n       tree coerced\n \t= coercion_site1 (deref_rvalue, act->get_base (), exp->get_base (),\n \t\t\t  lvalue_locus, rvalue_locus);\n-      if (exp->is_dyn_object () && SLICE_TYPE_P (TREE_TYPE (coerced)))\n+      if (exp->is_dyn_object () && RS_DST_FLAG_P (TREE_TYPE (coerced)))\n \treturn coerced;\n \n       return address_expression (coerced, rvalue_locus);\n     }\n   else if (expected->get_kind () == TyTy::TypeKind::POINTER)\n     {\n       // this is a dyn object\n-      if (SLICE_TYPE_P (TREE_TYPE (rvalue)))\n+      if (RS_DST_FLAG_P (TREE_TYPE (rvalue)))\n \t{\n \t  return rvalue;\n \t}\n@@ -140,7 +140,7 @@ HIRCompileBase::coercion_site1 (tree rvalue, TyTy::BaseType *rval,\n \t= coercion_site1 (deref_rvalue, actual_base, exp->get_base (),\n \t\t\t  lvalue_locus, rvalue_locus);\n \n-      if (exp->is_dyn_object () && SLICE_TYPE_P (TREE_TYPE (coerced)))\n+      if (exp->is_dyn_object () && RS_DST_FLAG_P (TREE_TYPE (coerced)))\n \treturn coerced;\n \n       return address_expression (coerced, rvalue_locus);\n@@ -183,7 +183,11 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n \t\t\t\t      const TyTy::DynamicObjectType *ty,\n \t\t\t\t      Location locus)\n {\n-  tree dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n+  // DST's get wrapped in a pseudo reference that doesnt exist...\n+  const TyTy::ReferenceType r (ctx->get_mappings ()->get_next_hir_id (),\n+\t\t\t       TyTy::TyVar (ty->get_ref ()), Mutability::Imm);\n+\n+  tree dynamic_object = TyTyResolveCompile::compile (ctx, &r);\n   tree dynamic_object_fields = TYPE_FIELDS (dynamic_object);\n   tree vtable_field = DECL_CHAIN (dynamic_object_fields);\n   rust_assert (TREE_CODE (TREE_TYPE (vtable_field)) == ARRAY_TYPE);"}, {"sha": "f896c05606db531c1a57489752aeb25eea051087", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=6ff31ac29db3bdc208083461e8b7a20f7128dd42", "patch": "@@ -78,8 +78,8 @@\n \n // this is a helper to differentiate RECORD types between actual records and\n // slices\n-#define SLICE_FLAG TREE_LANG_FLAG_0\n-#define SLICE_TYPE_P(TYPE)                                                     \\\n+#define RS_DST_FLAG TREE_LANG_FLAG_0\n+#define RS_DST_FLAG_P(TYPE)                                                    \\\n   (TREE_CODE (TYPE) == RECORD_TYPE && TREE_LANG_FLAG_0 (TYPE))\n \n // lambda?"}, {"sha": "0d89551a7661a6476afe596205f839eb81f58926", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=6ff31ac29db3bdc208083461e8b7a20f7128dd42", "patch": "@@ -2961,7 +2961,7 @@ ReferenceType::is_mutable () const\n bool\n ReferenceType::is_dyn_object () const\n {\n-  return is_dyn_slice_type () || is_dyn_str_type ();\n+  return is_dyn_slice_type () || is_dyn_str_type () || is_dyn_obj_type ();\n }\n \n bool\n@@ -2990,6 +2990,19 @@ ReferenceType::is_dyn_str_type (const TyTy::StrType **str) const\n   return true;\n }\n \n+bool\n+ReferenceType::is_dyn_obj_type (const TyTy::DynamicObjectType **dyn) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::DYNAMIC)\n+    return false;\n+  if (dyn == nullptr)\n+    return true;\n+\n+  *dyn = static_cast<const TyTy::DynamicObjectType *> (element);\n+  return true;\n+}\n+\n void\n ReferenceType::accept_vis (TyVisitor &vis)\n {\n@@ -3112,7 +3125,7 @@ PointerType::is_const () const\n bool\n PointerType::is_dyn_object () const\n {\n-  return is_dyn_slice_type () || is_dyn_str_type ();\n+  return is_dyn_slice_type () || is_dyn_str_type () || is_dyn_obj_type ();\n }\n \n bool\n@@ -3141,6 +3154,19 @@ PointerType::is_dyn_str_type (const TyTy::StrType **str) const\n   return true;\n }\n \n+bool\n+PointerType::is_dyn_obj_type (const TyTy::DynamicObjectType **dyn) const\n+{\n+  const TyTy::BaseType *element = get_base ()->destructure ();\n+  if (element->get_kind () != TyTy::TypeKind::DYNAMIC)\n+    return false;\n+  if (dyn == nullptr)\n+    return true;\n+\n+  *dyn = static_cast<const TyTy::DynamicObjectType *> (element);\n+  return true;\n+}\n+\n void\n PointerType::accept_vis (TyVisitor &vis)\n {"}, {"sha": "32d52c2efe117260c8eeb2562d53db865533fc62", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=6ff31ac29db3bdc208083461e8b7a20f7128dd42", "patch": "@@ -1147,6 +1147,36 @@ class StrType : public BaseType\n   BaseType *clone () const final override;\n };\n \n+class DynamicObjectType : public BaseType\n+{\n+public:\n+  DynamicObjectType (HirId ref, RustIdent ident,\n+\t\t     std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t     std::set<HirId> refs = std::set<HirId> ());\n+\n+  DynamicObjectType (HirId ref, HirId ty_ref, RustIdent ident,\n+\t\t     std::vector<TypeBoundPredicate> specified_bounds,\n+\t\t     std::set<HirId> refs = std::set<HirId> ());\n+\n+  void accept_vis (TyVisitor &vis) override;\n+  void accept_vis (TyConstVisitor &vis) const override;\n+\n+  std::string as_string () const override;\n+\n+  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+\n+  bool is_equal (const BaseType &other) const override;\n+\n+  BaseType *clone () const final override;\n+\n+  std::string get_name () const override final;\n+\n+  // this returns a flat list of items including super trait bounds\n+  const std::vector<\n+    std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n+  get_object_items () const;\n+};\n+\n class ReferenceType : public BaseType\n {\n public:\n@@ -1179,6 +1209,7 @@ class ReferenceType : public BaseType\n   bool is_dyn_object () const;\n   bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const;\n   bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const;\n+  bool is_dyn_obj_type (const TyTy::DynamicObjectType **dyn = nullptr) const;\n \n private:\n   TyVar base;\n@@ -1216,6 +1247,7 @@ class PointerType : public BaseType\n   bool is_dyn_object () const;\n   bool is_dyn_slice_type (const TyTy::SliceType **slice = nullptr) const;\n   bool is_dyn_str_type (const TyTy::StrType **str = nullptr) const;\n+  bool is_dyn_obj_type (const TyTy::DynamicObjectType **dyn = nullptr) const;\n \n private:\n   TyVar base;\n@@ -1328,36 +1360,6 @@ class ProjectionType : public BaseType, public SubstitutionRef\n   DefId item;\n };\n \n-class DynamicObjectType : public BaseType\n-{\n-public:\n-  DynamicObjectType (HirId ref, RustIdent ident,\n-\t\t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t\t     std::set<HirId> refs = std::set<HirId> ());\n-\n-  DynamicObjectType (HirId ref, HirId ty_ref, RustIdent ident,\n-\t\t     std::vector<TypeBoundPredicate> specified_bounds,\n-\t\t     std::set<HirId> refs = std::set<HirId> ());\n-\n-  void accept_vis (TyVisitor &vis) override;\n-  void accept_vis (TyConstVisitor &vis) const override;\n-\n-  std::string as_string () const override;\n-\n-  bool can_eq (const BaseType *other, bool emit_errors) const override final;\n-\n-  bool is_equal (const BaseType &other) const override;\n-\n-  BaseType *clone () const final override;\n-\n-  std::string get_name () const override final;\n-\n-  // this returns a flat list of items including super trait bounds\n-  const std::vector<\n-    std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n-  get_object_items () const;\n-};\n-\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "3a7ea1044724bb987786b4c70ae07d999e678007", "filename": "gcc/testsuite/rust/execute/torture/issue-2180.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-2180.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff31ac29db3bdc208083461e8b7a20f7128dd42/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-2180.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-2180.rs?ref=6ff31ac29db3bdc208083461e8b7a20f7128dd42", "patch": "@@ -0,0 +1,34 @@\n+// { dg-output \"123\\n\" }\n+trait A {\n+    fn get_int(&self) -> i32;\n+}\n+\n+impl A for i32 {\n+    fn get_int(&self) -> i32 {\n+        *self\n+    }\n+}\n+\n+fn get_dyn_a(x: &i32) -> &dyn A {\n+    x as &dyn A\n+}\n+\n+fn clobber_stack() {\n+    let _z: [usize; 8] = [1, 2, 3, 4, 5, 6, 7, 8];\n+}\n+\n+extern \"C\" {\n+    fn printf(s: *const i8, ...) -> i32;\n+}\n+\n+fn main() -> i32 {\n+    let x = 123;\n+    let y = get_dyn_a(&x);\n+    clobber_stack();\n+    let value = y.get_int();\n+    let fmt_string = \"%d\\n\\0\" as *const str as *const i8;\n+    unsafe {\n+        printf(fmt_string, value);\n+    }\n+    return 0;\n+}"}]}