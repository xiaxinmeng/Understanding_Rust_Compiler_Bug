{"sha": "e0ee10ed5af17d90ea7621d4270a50284ad76c45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBlZTEwZWQ1YWYxN2Q5MGVhNzYyMWQ0MjcwYTUwMjg0YWQ3NmM0NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-10-24T11:00:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-10-24T11:00:08Z"}, "message": "genmatch.c (expr::gen_transform): Use fold_buildN_loc and build_call_expr_loc.\n\n2014-10-24  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (expr::gen_transform): Use fold_buildN_loc\n\tand build_call_expr_loc.\n\t(dt_simplify::gen): Drop non_lvalue for GIMPLE, use\n\tnon_lvalue_loc to build it for GENERIC.\n\t(decision_tree::gen_generic): Add location argument to\n\tgeneric_simplify prototype.\n\t(capture_info): New class.\n\t(capture_info::capture_info): New constructor.\n\t(capture_info::walk_match): New method.\n\t(capture_info::walk_result): New method.\n\t(capture_info::walk_c_expr): New method.\n\t(dt_simplify::gen): Handle preserving side-effects for\n\tGENERIC code generation.\n\t(decision_tree::gen_generic): Do not reject operands\n\twith TREE_SIDE_EFFECTS.\n\t* generic-match.h: New file.\n\t* generic-match-head.c: Include generic-match.h, not gimple-match.h.\n\t* match.pd: Add some constant folding patterns from fold-const.c.\n\t* fold-const.c: Include generic-match.h.\n\t(fold_unary_loc): Dispatch to generic_simplify.\n\t(fold_ternary_loc): Likewise.\n\t(fold_binary_loc): Likewise.  Remove patterns now implemented\n\tby generic_simplify.\n\t* gimple-fold.c (replace_stmt_with_simplification): New function.\n\t(fold_stmt_1): Add valueize parameter, dispatch to gimple_simplify.\n\t(no_follow_ssa_edges): New function.\n\t(fold_stmt): New overload with valueization hook.  Use\n\tno_follow_ssa_edges for the overload without hook.\n\t(fold_stmt_inplace): Likewise.\n\t* gimple-fold.h (no_follow_ssa_edges): Declare.\n\nFrom-SVN: r216631", "tree": {"sha": "826b57b3cced839600a97bf9bbdd9105348dfd6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/826b57b3cced839600a97bf9bbdd9105348dfd6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0ee10ed5af17d90ea7621d4270a50284ad76c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ee10ed5af17d90ea7621d4270a50284ad76c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0ee10ed5af17d90ea7621d4270a50284ad76c45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0ee10ed5af17d90ea7621d4270a50284ad76c45/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "77efea31205aab4e4fa0d2760d2fa6108d4a56f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77efea31205aab4e4fa0d2760d2fa6108d4a56f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77efea31205aab4e4fa0d2760d2fa6108d4a56f3"}], "stats": {"total": 644, "additions": 552, "deletions": 92}, "files": [{"sha": "b72f4cb663d7d83e25f9847af3526f4c9a6857a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0ee10ed5af17d90ea7621d4270a50284ad76c45", "patch": "@@ -1,3 +1,36 @@\n+2014-10-24  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (expr::gen_transform): Use fold_buildN_loc\n+\tand build_call_expr_loc.\n+\t(dt_simplify::gen): Drop non_lvalue for GIMPLE, use\n+\tnon_lvalue_loc to build it for GENERIC.\n+\t(decision_tree::gen_generic): Add location argument to\n+\tgeneric_simplify prototype.\n+\t(capture_info): New class.\n+\t(capture_info::capture_info): New constructor.\n+\t(capture_info::walk_match): New method.\n+\t(capture_info::walk_result): New method.\n+\t(capture_info::walk_c_expr): New method.\n+\t(dt_simplify::gen): Handle preserving side-effects for\n+\tGENERIC code generation.\n+\t(decision_tree::gen_generic): Do not reject operands\n+\twith TREE_SIDE_EFFECTS.\n+\t* generic-match.h: New file.\n+\t* generic-match-head.c: Include generic-match.h, not gimple-match.h.\n+\t* match.pd: Add some constant folding patterns from fold-const.c.\n+\t* fold-const.c: Include generic-match.h.\n+\t(fold_unary_loc): Dispatch to generic_simplify.\n+\t(fold_ternary_loc): Likewise.\n+\t(fold_binary_loc): Likewise.  Remove patterns now implemented\n+\tby generic_simplify.\n+\t* gimple-fold.c (replace_stmt_with_simplification): New function.\n+\t(fold_stmt_1): Add valueize parameter, dispatch to gimple_simplify.\n+\t(no_follow_ssa_edges): New function.\n+\t(fold_stmt): New overload with valueization hook.  Use\n+\tno_follow_ssa_edges for the overload without hook.\n+\t(fold_stmt_inplace): Likewise.\n+\t* gimple-fold.h (no_follow_ssa_edges): Declare.\n+\n 2014-10-24  Felix Yang  <felix.yang@huawei.com>\n \tJiji Jiang  <jiangjiji@huawei.com>\n "}, {"sha": "8c4971cd47014ae6a2a9acd8ff07786594b40c9f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 13, "deletions": 50, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e0ee10ed5af17d90ea7621d4270a50284ad76c45", "patch": "@@ -70,6 +70,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hash-table.h\"  /* Required for ENABLE_FOLD_CHECKING.  */\n #include \"builtins.h\"\n #include \"cgraph.h\"\n+#include \"generic-match.h\"\n \n /* Nonzero if we are folding constants inside an initializer; zero\n    otherwise.  */\n@@ -7564,6 +7565,10 @@ fold_unary_loc (location_t loc, enum tree_code code, tree type, tree op0)\n   gcc_assert (IS_EXPR_CODE_CLASS (kind)\n \t      && TREE_CODE_LENGTH (code) == 1);\n \n+  tem = generic_simplify (loc, code, type, op0);\n+  if (tem)\n+    return tem;\n+\n   arg0 = op0;\n   if (arg0)\n     {\n@@ -9913,6 +9918,10 @@ fold_binary_loc (location_t loc,\n       && tree_swap_operands_p (arg0, arg1, true))\n     return fold_build2_loc (loc, swap_tree_comparison (code), type, op1, op0);\n \n+  tem = generic_simplify (loc, code, type, op0, op1);\n+  if (tem)\n+    return tem;\n+\n   /* ARG0 is the first operand of EXPR, and ARG1 is the second operand.\n \n      First check for cases where an arithmetic operation is applied to a\n@@ -10035,10 +10044,6 @@ fold_binary_loc (location_t loc,\n       if (integer_zerop (arg0))\n \treturn non_lvalue_loc (loc, fold_convert_loc (loc, type, arg1));\n \n-      /* PTR +p 0 -> PTR */\n-      if (integer_zerop (arg1))\n-\treturn non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n-\n       /* INT +p INT -> (PTR)(INT + INT).  Stripping types allows for this. */\n       if (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n \t   && INTEGRAL_TYPE_P (TREE_TYPE (arg0)))\n@@ -10159,9 +10164,6 @@ fold_binary_loc (location_t loc,\n \n       if (! FLOAT_TYPE_P (type))\n \t{\n-\t  if (integer_zerop (arg1))\n-\t    return non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n-\n \t  /* If we are adding two BIT_AND_EXPR's, both of which are and'ing\n \t     with a constant, and the two constants have no bits in common,\n \t     we should treat this as a BIT_IOR_EXPR since this may produce more\n@@ -10648,8 +10650,6 @@ fold_binary_loc (location_t loc,\n \t{\n \t  if (integer_zerop (arg0))\n \t    return negate_expr (fold_convert_loc (loc, type, arg1));\n-\t  if (integer_zerop (arg1))\n-\t    return non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n \n \t  /* Fold A - (A & B) into ~B & A.  */\n \t  if (!TREE_SIDE_EFFECTS (arg0)\n@@ -10742,16 +10742,6 @@ fold_binary_loc (location_t loc,\n \t    }\n \t}\n \n-      /* Fold &x - &x.  This can happen from &x.foo - &x.\n-\t This is unsafe for certain floats even in non-IEEE formats.\n-\t In IEEE, it is unsafe because it does wrong for NaNs.\n-\t Also note that operand_equal_p is always false if an operand\n-\t is volatile.  */\n-\n-      if ((!FLOAT_TYPE_P (type) || !HONOR_NANS (TYPE_MODE (type)))\n-\t  && operand_equal_p (arg0, arg1, 0))\n-\treturn omit_one_operand_loc (loc, type, build_zero_cst (type), arg0);\n-\n       /* A - B -> A + (-B) if B is easily negatable.  */\n       if (negate_expr_p (arg1)\n \t  && ((FLOAT_TYPE_P (type)\n@@ -10829,10 +10819,6 @@ fold_binary_loc (location_t loc,\n \n       if (! FLOAT_TYPE_P (type))\n \t{\n-\t  if (integer_zerop (arg1))\n-\t    return omit_one_operand_loc (loc, type, arg1, arg0);\n-\t  if (integer_onep (arg1))\n-\t    return non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n \t  /* Transform x * -1 into -x.  Make sure to do the negation\n \t     on the original operand with conversions not stripped\n \t     because we can only strip non-sign-changing conversions.  */\n@@ -11129,10 +11115,6 @@ fold_binary_loc (location_t loc,\n \n     case BIT_IOR_EXPR:\n     bit_ior:\n-      if (integer_all_onesp (arg1))\n-\treturn omit_one_operand_loc (loc, type, arg1, arg0);\n-      if (integer_zerop (arg1))\n-\treturn non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n \n@@ -11271,12 +11253,8 @@ fold_binary_loc (location_t loc,\n       goto bit_rotate;\n \n     case BIT_XOR_EXPR:\n-      if (integer_zerop (arg1))\n-\treturn non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n       if (integer_all_onesp (arg1))\n \treturn fold_build1_loc (loc, BIT_NOT_EXPR, type, op0);\n-      if (operand_equal_p (arg0, arg1, 0))\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n \n       /* ~X ^ X is -1.  */\n       if (TREE_CODE (arg0) == BIT_NOT_EXPR\n@@ -11434,8 +11412,6 @@ fold_binary_loc (location_t loc,\n     case BIT_AND_EXPR:\n       if (integer_all_onesp (arg1))\n \treturn non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n-      if (integer_zerop (arg1))\n-\treturn omit_one_operand_loc (loc, type, arg1, arg0);\n       if (operand_equal_p (arg0, arg1, 0))\n \treturn non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n \n@@ -12186,8 +12162,6 @@ fold_binary_loc (location_t loc,\n     case ROUND_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      if (integer_onep (arg1))\n-\treturn non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n       if (integer_zerop (arg1))\n \treturn NULL_TREE;\n       /* X / -1 is -X.  */\n@@ -12257,21 +12231,6 @@ fold_binary_loc (location_t loc,\n     case FLOOR_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n     case TRUNC_MOD_EXPR:\n-      /* X % 1 is always zero, but be sure to preserve any side\n-\t effects in X.  */\n-      if (integer_onep (arg1))\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n-\n-      /* X % 0, return X % 0 unchanged so that we can get the\n-\t proper warnings and errors.  */\n-      if (integer_zerop (arg1))\n-\treturn NULL_TREE;\n-\n-      /* 0 % X is always zero, but be sure to preserve any side\n-\t effects in X.  Place this after checking for X == 0.  */\n-      if (integer_zerop (arg0))\n-\treturn omit_one_operand_loc (loc, type, integer_zero_node, arg1);\n-\n       /* X % -1 is zero.  */\n       if (!TYPE_UNSIGNED (type)\n \t  && TREE_CODE (arg1) == INTEGER_CST\n@@ -13804,6 +13763,10 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n       && tree_swap_operands_p (op0, op1, true))\n     return fold_build3_loc (loc, code, type, op1, op0, op2);\n \n+  tem = generic_simplify (loc, code, type, op0, op1, op2);\n+  if (tem)\n+    return tem;\n+\n   /* Strip any conversions that don't change the mode.  This is safe\n      for every expression, except for a comparison expression because\n      its signedness is derived from its operands.  So, in the latter"}, {"sha": "0ed7e1d0c9923fff435824a7477e8fa0b357f63b", "filename": "gcc/generic-match-head.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgeneric-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgeneric-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match-head.c?ref=e0ee10ed5af17d90ea7621d4270a50284ad76c45", "patch": "@@ -43,6 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-phinodes.h\"\n #include \"ssa-iterators.h\"\n #include \"dumpfile.h\"\n-#include \"gimple-match.h\"\n+#include \"generic-match.h\"\n \n "}, {"sha": "180886068a96cac8e26878f9d95a7527574fe421", "filename": "gcc/generic-match.h", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgeneric-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgeneric-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgeneric-match.h?ref=e0ee10ed5af17d90ea7621d4270a50284ad76c45", "patch": "@@ -0,0 +1,33 @@\n+/* Generic simplify definitions.\n+\n+   Copyright (C) 2011-2014 Free Software Foundation, Inc.\n+   Contributed by Richard Guenther <rguenther@suse.de>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GENERIC_MATCH_H\n+#define GCC_GENERIC_MATCH_H\n+\n+/* Note the following functions are supposed to be only used from\n+   fold_unary_loc, fold_binary_loc and fold_ternary_loc respectively.\n+   They are not considered a public API.  */\n+\n+tree generic_simplify (location_t, enum tree_code, tree, tree);\n+tree generic_simplify (location_t, enum tree_code, tree, tree, tree);\n+tree generic_simplify (location_t, enum tree_code, tree, tree, tree, tree);\n+\n+#endif  /* GCC_GENERIC_MATCH_H */"}, {"sha": "ebdb7d35859c054bcbbbfb5baf04de985a79aef5", "filename": "gcc/genmatch.c", "status": "modified", "additions": 257, "deletions": 38, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=e0ee10ed5af17d90ea7621d4270a50284ad76c45", "patch": "@@ -1374,10 +1374,11 @@ expr::gen_transform (FILE *f, const char *dest, bool gimple, int depth,\n   else\n     {\n       if (operation->kind == id_base::CODE)\n-\tfprintf (f, \"  res = fold_build%d (%s, %s\",\n+\tfprintf (f, \"  res = fold_build%d_loc (loc, %s, %s\",\n \t\t ops.length(), operation->id, type);\n       else\n-\tfprintf (f, \"  res = build_call_expr (builtin_decl_implicit (%s), %d\",\n+\tfprintf (f, \"  res = build_call_expr_loc (loc, \"\n+\t\t \"builtin_decl_implicit (%s), %d\",\n \t\t operation->id, ops.length());\n       for (unsigned i = 0; i < ops.length (); ++i)\n \tfprintf (f, \", ops%d[%u]\", depth, i);\n@@ -1860,6 +1861,167 @@ dt_operand::gen (FILE *f, bool gimple)\n     fprintf (f, \"}\\n\");\n }\n \n+\n+/* For GENERIC we have to take care of wrapping multiple-used\n+   expressions with side-effects in save_expr and preserve side-effects\n+   of expressions with omit_one_operand.  Analyze captures in\n+   match, result and with expressions and perform early-outs\n+   on the outermost match expression operands for cases we cannot\n+   handle.  */\n+\n+struct capture_info\n+{\n+  capture_info (simplify *s);\n+  void walk_match (operand *o, unsigned toplevel_arg, bool);\n+  void walk_result (operand *o, bool);\n+  void walk_c_expr (c_expr *);\n+\n+  struct cinfo\n+    {\n+      bool expr_p;\n+      bool cse_p;\n+      bool force_no_side_effects_p;\n+      unsigned long toplevel_msk;\n+      int result_use_count;\n+    };\n+\n+  auto_vec<cinfo> info;\n+  unsigned long force_no_side_effects;\n+};\n+\n+/* Analyze captures in S.  */\n+\n+capture_info::capture_info (simplify *s)\n+{\n+  expr *e;\n+  if (!s->result\n+      || ((e = dyn_cast <expr *> (s->result))\n+\t  && is_a <predicate_id *> (e->operation)))\n+    {\n+      force_no_side_effects = -1;\n+      return;\n+    }\n+\n+  force_no_side_effects = 0;\n+  info.safe_grow_cleared (s->capture_max + 1);\n+  e = as_a <expr *> (s->match);\n+  for (unsigned i = 0; i < e->ops.length (); ++i)\n+    walk_match (e->ops[i], i, false);\n+\n+  walk_result (s->result, false);\n+\n+  for (unsigned i = 0; i < s->ifexpr_vec.length (); ++i)\n+    if (s->ifexpr_vec[i].is_with)\n+      walk_c_expr (as_a <c_expr *>(s->ifexpr_vec[i].cexpr));\n+}\n+\n+/* Analyze captures in the match expression piece O.  */\n+\n+void\n+capture_info::walk_match (operand *o, unsigned toplevel_arg, bool conditional_p)\n+{\n+  if (capture *c = dyn_cast <capture *> (o))\n+    {\n+      info[c->where].toplevel_msk |= 1 << toplevel_arg;\n+      info[c->where].force_no_side_effects_p |= conditional_p;\n+      /* Mark expr (non-leaf) captures and recurse.  */\n+      if (c->what\n+\t  && is_a <expr *> (c->what))\n+\t{\n+\t  info[c->where].expr_p = true;\n+\t  walk_match (c->what, toplevel_arg, conditional_p);\n+\t}\n+    }\n+  else if (expr *e = dyn_cast <expr *> (o))\n+    {\n+      for (unsigned i = 0; i < e->ops.length (); ++i)\n+\t{\n+\t  bool cond_p = conditional_p;\n+\t  if (i == 0\n+\t      && *e->operation == COND_EXPR)\n+\t    cond_p = true;\n+\t  else if (*e->operation == TRUTH_ANDIF_EXPR\n+\t\t   || *e->operation == TRUTH_ORIF_EXPR)\n+\t    cond_p = true;\n+\t  walk_match (e->ops[i], toplevel_arg, cond_p);\n+\t}\n+    }\n+  else if (is_a <predicate *> (o))\n+    {\n+      /* Mark non-captured leafs toplevel arg for checking.  */\n+      force_no_side_effects |= 1 << toplevel_arg;\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Analyze captures in the result expression piece O.  */\n+\n+void\n+capture_info::walk_result (operand *o, bool conditional_p)\n+{\n+  if (capture *c = dyn_cast <capture *> (o))\n+    {\n+      info[c->where].result_use_count++;\n+      /* If we substitute an expression capture we don't know\n+         which captures this will end up using (well, we don't\n+\t compute that).  Force the uses to be side-effect free\n+\t which means forcing the toplevels that reach the\n+\t expression side-effect free.  */\n+      if (info[c->where].expr_p)\n+\tforce_no_side_effects |= info[c->where].toplevel_msk;\n+      /* Mark CSE capture capture uses as forced to have\n+         no side-effects. */\n+      if (c->what\n+\t  && is_a <expr *> (c->what))\n+\t{\n+\t  info[c->where].cse_p = true;\n+\t  walk_result (c->what, true);\n+\t}\n+    }\n+  else if (expr *e = dyn_cast <expr *> (o))\n+    {\n+      for (unsigned i = 0; i < e->ops.length (); ++i)\n+\t{\n+\t  bool cond_p = conditional_p;\n+\t  if (i == 0\n+\t      && *e->operation == COND_EXPR)\n+\t    cond_p = true;\n+\t  else if (*e->operation == TRUTH_ANDIF_EXPR\n+\t\t   || *e->operation == TRUTH_ORIF_EXPR)\n+\t    cond_p = true;\n+\t  walk_result (e->ops[i], cond_p);\n+\t}\n+    }\n+  else if (c_expr *e = dyn_cast <c_expr *> (o))\n+    walk_c_expr (e);\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Look for captures in the C expr E.  */\n+\n+void\n+capture_info::walk_c_expr (c_expr *e)\n+{\n+  /* Give up for C exprs mentioning captures.  */\n+  for (unsigned i = 0; i < e->code.length (); ++i)\n+    if (e->code[i].type == CPP_ATSIGN\n+\t&& (e->code[i+1].type == CPP_NUMBER\n+\t    || e->code[i+1].type == CPP_NAME)\n+\t&& !(e->code[i+1].flags & PREV_WHITE))\n+      {\n+\tconst cpp_token *n = &e->code[i+1];\n+\tconst char *id;\n+\tif (n->type == CPP_NUMBER)\n+\t  id = (const char *)n->val.str.text;\n+\telse\n+\t  id = (const char *)CPP_HASHNODE (n->val.node.node)->ident.str;\n+\tinfo[(*e->capture_ids)[id]].force_no_side_effects_p = true;\n+      }\n+}\n+\n+\n /* Generate code for the '(if ...)', '(with ..)' and actual transform\n    step of a '(simplify ...)' or '(match ...)'.  This handles everything\n    that is not part of the decision tree (simplify->match).  */\n@@ -1928,21 +2090,54 @@ dt_simplify::gen (FILE *f, bool gimple)\n       n_braces++;\n     }\n \n+  /* Analyze captures and perform early-outs on the incoming arguments\n+     that cover cases we cannot handle.  */\n+  capture_info cinfo (s);\n+  expr *e;\n+  if (!gimple\n+      && s->result\n+      && !((e = dyn_cast <expr *> (s->result))\n+\t   && is_a <predicate_id *> (e->operation)))\n+    {\n+      for (unsigned i = 0; i < as_a <expr *> (s->match)->ops.length (); ++i)\n+\tif (cinfo.force_no_side_effects & (1 << i))\n+\t  fprintf (f, \"if (TREE_SIDE_EFFECTS (op%d)) return NULL_TREE;\\n\", i);\n+      for (int i = 0; i <= s->capture_max; ++i)\n+\tif (cinfo.info[i].cse_p)\n+\t  ;\n+\telse if (cinfo.info[i].force_no_side_effects_p\n+\t\t && (cinfo.info[i].toplevel_msk\n+\t\t     & cinfo.force_no_side_effects) == 0)\n+\t  fprintf (f, \"if (TREE_SIDE_EFFECTS (captures[%d])) \"\n+\t\t   \"return NULL_TREE;\\n\", i);\n+\telse if ((cinfo.info[i].toplevel_msk\n+\t\t  & cinfo.force_no_side_effects) != 0)\n+\t  /* Mark capture as having no side-effects if we had to verify\n+\t     that via forced toplevel operand checks.  */\n+\t  cinfo.info[i].force_no_side_effects_p = true;\n+    }\n+\n   fprintf (f, \"if (dump_file && (dump_flags & TDF_DETAILS)) \"\n \t   \"fprintf (dump_file, \\\"Applying pattern \");\n   output_line_directive (f, s->result_location, true);\n   fprintf (f, \", %%s:%%d\\\\n\\\", __FILE__, __LINE__);\\n\");\n \n-  if (!s->result)\n+  operand *result = s->result;\n+  if (!result)\n     {\n       /* If there is no result then this is a predicate implementation.  */\n       fprintf (f, \"return true;\\n\");\n     }\n   else if (gimple)\n     {\n-      if (s->result->type == operand::OP_EXPR)\n+      /* For GIMPLE simply drop NON_LVALUE_EXPR (which only appears\n+         in outermost position).  */\n+      if (result->type == operand::OP_EXPR\n+\t  && *as_a <expr *> (result)->operation == NON_LVALUE_EXPR)\n+\tresult = as_a <expr *> (result)->ops[0];\n+      if (result->type == operand::OP_EXPR)\n \t{\n-\t  expr *e = as_a <expr *> (s->result);\n+\t  expr *e = as_a <expr *> (result);\n \t  bool is_predicate = is_a <predicate_id *> (e->operation);\n \t  if (!is_predicate)\n \t    fprintf (f, \"*res_code = %s;\\n\", e->operation->id);\n@@ -1964,10 +2159,10 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t    fprintf (f, \"gimple_resimplify%d (seq, res_code, type, \"\n \t\t     \"res_ops, valueize);\\n\", e->ops.length ());\n \t}\n-      else if (s->result->type == operand::OP_CAPTURE\n-\t       || s->result->type == operand::OP_C_EXPR)\n+      else if (result->type == operand::OP_CAPTURE\n+\t       || result->type == operand::OP_C_EXPR)\n \t{\n-\t  s->result->gen_transform (f, \"res_ops[0]\", true, 1, \"type\", indexes);\n+\t  result->gen_transform (f, \"res_ops[0]\", true, 1, \"type\", indexes);\n \t  fprintf (f, \"*res_code = TREE_CODE (res_ops[0]);\\n\");\n \t}\n       else\n@@ -1976,10 +2171,22 @@ dt_simplify::gen (FILE *f, bool gimple)\n     }\n   else /* GENERIC */\n     {\n-      if (s->result->type == operand::OP_EXPR)\n+      bool is_predicate = false;\n+      if (result->type == operand::OP_EXPR)\n \t{\n-\t  expr *e = as_a <expr *> (s->result);\n-\t  bool is_predicate = is_a <predicate_id *> (e->operation);\n+\t  expr *e = as_a <expr *> (result);\n+\t  is_predicate = is_a <predicate_id *> (e->operation);\n+\t  /* Search for captures used multiple times in the result expression\n+\t     and dependent on TREE_SIDE_EFFECTS emit a SAVE_EXPR.  */\n+\t  if (!is_predicate)\n+\t    for (int i = 0; i < s->capture_max + 1; ++i)\n+\t      {\n+\t\tif (!cinfo.info[i].force_no_side_effects_p\n+\t\t    && cinfo.info[i].result_use_count > 1)\n+\t\t  fprintf (f, \"  if (TREE_SIDE_EFFECTS (captures[%d]))\\n\"\n+\t\t\t   \"    captures[%d] = save_expr (captures[%d]);\\n\",\n+\t\t\t   i, i, i);\n+\t      }\n \t  for (unsigned j = 0; j < e->ops.length (); ++j)\n \t    {\n \t      char dest[32];\n@@ -1997,32 +2204,56 @@ dt_simplify::gen (FILE *f, bool gimple)\n \t\t\t\t    ? NULL : \"TREE_TYPE (res_op0)\");\n \t      e->ops[j]->gen_transform (f, dest, false, 1, optype, indexes);\n \t    }\n-\t  if (is_a <predicate_id *> (e->operation))\n+\t  if (is_predicate)\n \t    fprintf (f, \"return true;\\n\");\n \t  else\n \t    {\n-\t      /* Re-fold the toplevel result.  */\n-\t      if (e->operation->kind == id_base::CODE)\n-\t\tfprintf (f, \"  return fold_build%d (%s, type\",\n-\t\t\t e->ops.length (), e->operation->id);\n+\t      fprintf (f, \"  tree res;\\n\");\n+\t      /* Re-fold the toplevel result.  Use non_lvalue to\n+\t         build NON_LVALUE_EXPRs so they get properly\n+\t\t ignored when in GIMPLE form.  */\n+\t      if (*e->operation == NON_LVALUE_EXPR)\n+\t\tfprintf (f, \"  res = non_lvalue_loc (loc, res_op0);\\n\");\n \t      else\n-\t\tfprintf (f, \"  return build_call_expr \"\n-\t\t\t \"(builtin_decl_implicit (%s), %d\",\n-\t\t\t e->operation->id, e->ops.length());\n-\t      for (unsigned j = 0; j < e->ops.length (); ++j)\n-\t\tfprintf (f, \", res_op%d\", j);\n-\t      fprintf (f, \");\\n\");\n+\t\t{\n+\t\t  if (e->operation->kind == id_base::CODE)\n+\t\t    fprintf (f, \"  res = fold_build%d_loc (loc, %s, type\",\n+\t\t\t     e->ops.length (), e->operation->id);\n+\t\t  else\n+\t\t    fprintf (f, \"  res = build_call_expr_loc \"\n+\t\t\t     \"(loc, builtin_decl_implicit (%s), %d\",\n+\t\t\t     e->operation->id, e->ops.length());\n+\t\t  for (unsigned j = 0; j < e->ops.length (); ++j)\n+\t\t    fprintf (f, \", res_op%d\", j);\n+\t\t  fprintf (f, \");\\n\");\n+\t\t}\n \t    }\n \t}\n-      else if (s->result->type == operand::OP_CAPTURE\n-\t       || s->result->type == operand::OP_C_EXPR)\n+      else if (result->type == operand::OP_CAPTURE\n+\t       || result->type == operand::OP_C_EXPR)\n+\n \t{\n \t  fprintf (f, \"  tree res;\\n\");\n \t  s->result->gen_transform (f, \" res\", false, 1, \"type\", indexes);\n-\t  fprintf (f, \"  return res;\\n\");\n \t}\n       else\n \tgcc_unreachable ();\n+      if (!is_predicate)\n+\t{\n+\t  /* Search for captures not used in the result expression and dependent\n+\t     on TREE_SIDE_EFFECTS emit omit_one_operand.  */\n+\t  for (int i = 0; i < s->capture_max + 1; ++i)\n+\t    {\n+\t      if (!cinfo.info[i].force_no_side_effects_p\n+\t\t  && !cinfo.info[i].expr_p\n+\t\t  && cinfo.info[i].result_use_count == 0)\n+\t\tfprintf (f, \"  if (TREE_SIDE_EFFECTS (captures[%d]))\\n\"\n+\t\t\t \"    res = build2_loc (loc, COMPOUND_EXPR, type,\"\n+\t\t\t \" fold_ignored_result (captures[%d]), res);\\n\",\n+\t\t\t i, i);\n+\t    }\n+\t  fprintf (f, \"  return res;\\n\");\n+\t}\n     }\n \n   for (unsigned i = 0; i < n_braces; ++i)\n@@ -2086,25 +2317,13 @@ decision_tree::gen_generic (FILE *f)\n   for (unsigned n = 1; n <= 3; ++n)\n     {\n       fprintf (f, \"\\ntree\\n\"\n-\t       \"generic_simplify (enum tree_code code, \"\n+\t       \"generic_simplify (location_t loc, enum tree_code code, \"\n \t       \"tree type ATTRIBUTE_UNUSED\");\n       for (unsigned i = 0; i < n; ++i)\n \tfprintf (f, \", tree op%d\", i);\n       fprintf (f, \")\\n\");\n       fprintf (f, \"{\\n\");\n \n-      /* ???  For now reject all simplifications on operands with\n-         side-effects as we are not prepared to properly wrap\n-\t omitted parts with omit_one_operand and friends.  In\n-\t principle we can do that automagically for a subset of\n-\t transforms (and only reject the remaining cases).\n-\t This fixes for example gcc.c-torture/execute/20050131-1.c.  */\n-      fprintf (f, \"if ((op0 && TREE_SIDE_EFFECTS (op0))\");\n-      for (unsigned i = 1; i < n; ++i)\n-\tfprintf (f, \"|| (op%d && TREE_SIDE_EFFECTS (op%d))\", i, i);\n-      fprintf (f, \")\\n\"\n-\t       \"  return NULL_TREE;\\n\");\n-\n       fprintf (f, \"switch (code)\\n\"\n \t       \"{\\n\");\n       for (unsigned i = 0; i < root->kids.length (); i++)"}, {"sha": "b2627197b448c633cfd30f0e78733b34061cb58b", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 153, "deletions": 3, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e0ee10ed5af17d90ea7621d4270a50284ad76c45", "patch": "@@ -61,6 +61,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"builtins.h\"\n #include \"output.h\"\n+#include \"tree-eh.h\"\n+#include \"gimple-match.h\"\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from.\n@@ -2792,6 +2794,121 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n   return changed;\n }\n \n+\n+/* Worker for fold_stmt_1 dispatch to pattern based folding with\n+   gimple_simplify.\n+\n+   Replaces *GSI with the simplification result in RCODE and OPS\n+   and the associated statements in *SEQ.  Does the replacement\n+   according to INPLACE and returns true if the operation succeeded.  */\n+\n+static bool\n+replace_stmt_with_simplification (gimple_stmt_iterator *gsi,\n+\t\t\t\t  code_helper rcode, tree *ops,\n+\t\t\t\t  gimple_seq *seq, bool inplace)\n+{\n+  gimple stmt = gsi_stmt (*gsi);\n+\n+  /* Play safe and do not allow abnormals to be mentioned in\n+     newly created statements.  See also maybe_push_res_to_seq.  */\n+  if ((TREE_CODE (ops[0]) == SSA_NAME\n+       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[0]))\n+      || (ops[1]\n+\t  && TREE_CODE (ops[1]) == SSA_NAME\n+\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[1]))\n+      || (ops[2]\n+\t  && TREE_CODE (ops[2]) == SSA_NAME\n+\t  && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ops[2])))\n+    return false;\n+\n+  if (gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      gcc_assert (rcode.is_tree_code ());\n+      if (TREE_CODE_CLASS ((enum tree_code)rcode) == tcc_comparison\n+\t  /* GIMPLE_CONDs condition may not throw.  */\n+\t  && (!flag_exceptions\n+\t      || !cfun->can_throw_non_call_exceptions\n+\t      || !operation_could_trap_p (rcode,\n+\t\t\t\t\t  FLOAT_TYPE_P (TREE_TYPE (ops[0])),\n+\t\t\t\t\t  false, NULL_TREE)))\n+\tgimple_cond_set_condition (stmt, rcode, ops[0], ops[1]);\n+      else if (rcode == SSA_NAME)\n+\tgimple_cond_set_condition (stmt, NE_EXPR, ops[0],\n+\t\t\t\t   build_zero_cst (TREE_TYPE (ops[0])));\n+      else if (rcode == INTEGER_CST)\n+\t{\n+\t  if (integer_zerop (ops[0]))\n+\t    gimple_cond_make_false (stmt);\n+\t  else\n+\t    gimple_cond_make_true (stmt);\n+\t}\n+      else if (!inplace)\n+\t{\n+\t  tree res = maybe_push_res_to_seq (rcode, boolean_type_node,\n+\t\t\t\t\t    ops, seq);\n+\t  if (!res)\n+\t    return false;\n+\t  gimple_cond_set_condition (stmt, NE_EXPR, res,\n+\t\t\t\t     build_zero_cst (TREE_TYPE (res)));\n+\t}\n+      else\n+\treturn false;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"gimple_simplified to \");\n+\t  if (!gimple_seq_empty_p (*seq))\n+\t    print_gimple_seq (dump_file, *seq, 0, TDF_SLIM);\n+\t  print_gimple_stmt (dump_file, gsi_stmt (*gsi),\n+\t\t\t     0, TDF_SLIM);\n+\t}\n+      gsi_insert_seq_before (gsi, *seq, GSI_SAME_STMT);\n+      return true;\n+    }\n+  else if (is_gimple_assign (stmt)\n+\t   && rcode.is_tree_code ())\n+    {\n+      if (!inplace\n+\t  || gimple_num_ops (stmt) <= get_gimple_rhs_num_ops (rcode))\n+\t{\n+\t  maybe_build_generic_op (rcode,\n+\t\t\t\t  TREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\t\t\t  &ops[0], ops[1], ops[2]);\n+\t  gimple_assign_set_rhs_with_ops_1 (gsi, rcode,\n+\t\t\t\t\t    ops[0], ops[1], ops[2]);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"gimple_simplified to \");\n+\t      if (!gimple_seq_empty_p (*seq))\n+\t\tprint_gimple_seq (dump_file, *seq, 0, TDF_SLIM);\n+\t      print_gimple_stmt (dump_file, gsi_stmt (*gsi),\n+\t\t\t\t 0, TDF_SLIM);\n+\t    }\n+\t  gsi_insert_seq_before (gsi, *seq, GSI_SAME_STMT);\n+\t  return true;\n+\t}\n+    }\n+  else if (!inplace)\n+    {\n+      if (gimple_has_lhs (stmt))\n+\t{\n+\t  tree lhs = gimple_get_lhs (stmt);\n+\t  maybe_push_res_to_seq (rcode, TREE_TYPE (lhs),\n+\t\t\t\t ops, seq, lhs);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"gimple_simplified to \");\n+\t      print_gimple_seq (dump_file, *seq, 0, TDF_SLIM);\n+\t    }\n+\t  gsi_replace_with_seq_vops (gsi, *seq);\n+\t  return true;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  return false;\n+}\n+\n /* Canonicalize MEM_REFs invariant address operand after propagation.  */\n \n static bool\n@@ -2878,7 +2995,7 @@ maybe_canonicalize_mem_ref_addr (tree *t)\n    distinguishes both cases.  */\n \n static bool\n-fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace)\n+fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n {\n   bool changed = false;\n   gimple stmt = gsi_stmt (*gsi);\n@@ -2956,6 +3073,25 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace)\n     default:;\n     }\n \n+  /* Dispatch to pattern-based folding.  */\n+  if (!inplace\n+      || is_gimple_assign (stmt)\n+      || gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      gimple_seq seq = NULL;\n+      code_helper rcode;\n+      tree ops[3] = {};\n+      if (gimple_simplify (stmt, &rcode, ops, inplace ? NULL : &seq, valueize))\n+\t{\n+\t  if (replace_stmt_with_simplification (gsi, rcode, ops, &seq, inplace))\n+\t    changed = true;\n+\t  else\n+\t    gimple_seq_discard (seq);\n+\t}\n+    }\n+\n+  stmt = gsi_stmt (*gsi);\n+\n   /* Fold the main computation performed by the statement.  */\n   switch (gimple_code (stmt))\n     {\n@@ -3095,6 +3231,14 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace)\n   return changed;\n }\n \n+/* Valueziation callback that ends up not following SSA edges.  */\n+\n+tree\n+no_follow_ssa_edges (tree)\n+{\n+  return NULL_TREE;\n+}\n+\n /* Fold the statement pointed to by GSI.  In some cases, this function may\n    replace the whole statement with a new one.  Returns true iff folding\n    makes any changes.\n@@ -3105,7 +3249,13 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace)\n bool\n fold_stmt (gimple_stmt_iterator *gsi)\n {\n-  return fold_stmt_1 (gsi, false);\n+  return fold_stmt_1 (gsi, false, no_follow_ssa_edges);\n+}\n+\n+bool\n+fold_stmt (gimple_stmt_iterator *gsi, tree (*valueize) (tree))\n+{\n+  return fold_stmt_1 (gsi, false, valueize);\n }\n \n /* Perform the minimal folding on statement *GSI.  Only operations like\n@@ -3120,7 +3270,7 @@ bool\n fold_stmt_inplace (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n-  bool changed = fold_stmt_1 (gsi, true);\n+  bool changed = fold_stmt_1 (gsi, true, no_follow_ssa_edges);\n   gcc_assert (gsi_stmt (*gsi) == stmt);\n   return changed;\n }"}, {"sha": "39c53ff3916f343130877d024a2baad0d15a85b8", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=e0ee10ed5af17d90ea7621d4270a50284ad76c45", "patch": "@@ -26,11 +26,13 @@ extern tree canonicalize_constructor_val (tree, tree);\n extern tree get_symbol_constant_value (tree);\n extern void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool fold_stmt (gimple_stmt_iterator *);\n+extern bool fold_stmt (gimple_stmt_iterator *, tree (*) (tree));\n extern bool fold_stmt_inplace (gimple_stmt_iterator *);\n extern tree maybe_fold_and_comparisons (enum tree_code, tree, tree, \n \t\t\t\t\tenum tree_code, tree, tree);\n extern tree maybe_fold_or_comparisons (enum tree_code, tree, tree,\n \t\t\t\t       enum tree_code, tree, tree);\n+extern tree no_follow_ssa_edges (tree);\n extern tree gimple_fold_stmt_to_constant_1 (gimple, tree (*) (tree));\n extern tree gimple_fold_stmt_to_constant (gimple, tree (*) (tree));\n extern tree fold_const_aggregate_ref_1 (tree, tree (*) (tree));"}, {"sha": "aa2afc267d7aa18ef8e11b5ecaeb5b5847624750", "filename": "gcc/match.pd", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0ee10ed5af17d90ea7621d4270a50284ad76c45/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=e0ee10ed5af17d90ea7621d4270a50284ad76c45", "patch": "@@ -28,3 +28,63 @@ along with GCC; see the file COPYING3.  If not see\n    integer_onep integer_zerop integer_all_onesp\n    real_zerop real_onep\n    CONSTANT_CLASS_P)\n+\n+\n+/* Simplifications of operations with one constant operand and\n+   simplifications to constants.  */\n+\n+(for op (plus pointer_plus minus bit_ior bit_xor)\n+  (simplify\n+    (op @0 integer_zerop)\n+    (non_lvalue @0)))\n+\n+/* Simplify x - x.\n+   This is unsafe for certain floats even in non-IEEE formats.\n+   In IEEE, it is unsafe because it does wrong for NaNs.\n+   Also note that operand_equal_p is always false if an operand\n+   is volatile.  */\n+(simplify\n+  (minus @0 @0)\n+  (if (!FLOAT_TYPE_P (type) || !HONOR_NANS (TYPE_MODE (type)))\n+   { build_zero_cst (type); }))\n+\n+(simplify\n+  (mult @0 integer_zerop@1)\n+  @1)\n+\n+/* Make sure to preserve divisions by zero.  This is the reason why\n+   we don't simplify x / x to 1 or 0 / x to 0.  */\n+(for op (mult trunc_div ceil_div floor_div round_div exact_div)\n+  (simplify\n+    (op @0 integer_onep)\n+    (non_lvalue @0)))\n+\n+/* Same applies to modulo operations, but fold is inconsistent here\n+   and simplifies 0 % x to 0, only preserving literal 0 % 0.  */\n+(for op (ceil_mod floor_mod round_mod trunc_mod)\n+ /* 0 % X is always zero.  */\n+ (simplify\n+  (trunc_mod integer_zerop@0 @1)\n+  /* But not for 0 % 0 so that we can get the proper warnings and errors.  */\n+  (if (!integer_zerop (@1))\n+   @0))\n+ /* X % 1 is always zero.  */\n+ (simplify\n+  (trunc_mod @0 integer_onep)\n+  { build_zero_cst (type); }))\n+\n+/* x | ~0 -> ~0  */\n+(simplify\n+  (bit_ior @0 integer_all_onesp@1)\n+  @1)\n+\n+/* x & 0 -> 0  */\n+(simplify\n+  (bit_and @0 integer_zerop@1)\n+  @1)\n+\n+/* x ^ x -> 0 */\n+(simplify\n+  (bit_xor @0 @0)\n+  { build_zero_cst (type); })\n+"}]}