{"sha": "8603f9c5b022356e3993539be8c70358d935c710", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYwM2Y5YzViMDIyMzU2ZTM5OTM1MzliZThjNzAzNThkOTM1YzcxMA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1998-10-22T12:06:05Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1998-10-22T12:06:05Z"}, "message": "jcf-io.c (find_class): Use saw_java_source to determine when to look for `.java' file.\n\n\t* jcf-io.c (find_class): Use saw_java_source to determine when to\n\tlook for `.java' file.\n\t* jcf-parse.c (saw_java_source): New global.\n\t(yyparse): Set it if `.java' file seen.\n\t* Make-lang.in (JAVA_SRCS): Added jcf-path.c.\n\t(GCJH_SOURCES): Likewise.\n\t* Makefile.in (datadir): New macro.\n\t(libjava_zip): Likewise.\n\t(JAVA_OBJS): Added jcf-path.o.\n\t(../jcf-dump$(exeext)): Depend on and link with jcf-depend.o.\n\t(../gcjh$(exeext)): Likewise.\n\t(jcf-path.o): New target.\n\t* java-tree.h (fix_classpath): Removed decl.\n\t* jcf-parse.c (fix_classpath): Removed.\n\t(load_class): Don't call fix_classpath.\n\t* parse.y (read_import_dir): Don't call fix_classpath.\n\t* lex.h: Don't mention classpath.\n\t* lex.c (java_init_lex): Don't initialize classpath.\n\t* jcf-io.c (classpath): Removed global.\n\t(find_class): Use jcf_path iteration functions.  Correctly search\n\tclass path for .java file.\n\t(open_in_zip): New argument `is_system'.\n\t* jcf-dump.c (main): Call jcf_path_init.  Recognize all new\n\tclasspath-related options.\n\t* lang.c (lang_decode_option): Handle -fclasspath, -fCLASSPATH,\n\tand -I.\n\t(lang_init): Call jcf_path_init.\n\t* lang-options.h: Mention -I, -fclasspath, and -fCLASSPATH.\n\t* lang-specs.h: Handle -I.  Minor cleanup to -M options.\n\tCorrectly put braces around second string in each entry.\n\t* gjavah.c (main): Call jcf_path_init.  Recognize all the new\n\tclasspath-related options.\n\t(help): Updated for new options.\n\t* jcf.h: Declare functions from jcf-path.c.  Don't mention\n\t`classpath' global.\n\t* jcf-path.c: New file.\n\t* jcf-depend.c: Include jcf.h.\n\t* jcf-write.c (localvar_alloc): Returns `void'.\n\t(localvar_free): Removed unused variable.\n\t* lang.c (OBJECT_SUFFIX): Define if not already defined.\n\t(init_parse): Use OBJECT_SUFFIX, not \".o\".\n\nFrom-SVN: r23219", "tree": {"sha": "9b6b5425af73b8159f8c9b6dcf195daebe2e6914", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b6b5425af73b8159f8c9b6dcf195daebe2e6914"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8603f9c5b022356e3993539be8c70358d935c710", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8603f9c5b022356e3993539be8c70358d935c710", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8603f9c5b022356e3993539be8c70358d935c710", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8603f9c5b022356e3993539be8c70358d935c710/comments", "author": null, "committer": null, "parents": [{"sha": "8a829fd982378e9ae9f603e2df8d157e1f7c3d83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a829fd982378e9ae9f603e2df8d157e1f7c3d83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a829fd982378e9ae9f603e2df8d157e1f7c3d83"}], "stats": {"total": 901, "additions": 672, "deletions": 229}, "files": [{"sha": "0d1665f0cf6a34749740f93e85ba2b18eea156c8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -1,3 +1,51 @@\n+1998-10-22  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* jcf-io.c (find_class): Use saw_java_source to determine when to\n+\tlook for `.java' file.\n+\t* jcf-parse.c (saw_java_source): New global.\n+\t(yyparse): Set it if `.java' file seen.\n+\n+\t* Make-lang.in (JAVA_SRCS): Added jcf-path.c.\n+\t(GCJH_SOURCES): Likewise.\n+\t* Makefile.in (datadir): New macro.\n+\t(libjava_zip): Likewise.\n+\t(JAVA_OBJS): Added jcf-path.o.\n+\t(../jcf-dump$(exeext)): Depend on and link with jcf-depend.o.\n+\t(../gcjh$(exeext)): Likewise.\n+\t(jcf-path.o): New target.\n+\t* java-tree.h (fix_classpath): Removed decl.\n+\t* jcf-parse.c (fix_classpath): Removed.\n+\t(load_class): Don't call fix_classpath.\n+\t* parse.y (read_import_dir): Don't call fix_classpath.\n+\t* lex.h: Don't mention classpath.\n+\t* lex.c (java_init_lex): Don't initialize classpath.\n+\t* jcf-io.c (classpath): Removed global.\n+\t(find_class): Use jcf_path iteration functions.  Correctly search\n+\tclass path for .java file.\n+\t(open_in_zip): New argument `is_system'.\n+\t* jcf-dump.c (main): Call jcf_path_init.  Recognize all new\n+\tclasspath-related options.\n+\t* lang.c (lang_decode_option): Handle -fclasspath, -fCLASSPATH,\n+\tand -I.\n+\t(lang_init): Call jcf_path_init.\n+\t* lang-options.h: Mention -I, -fclasspath, and -fCLASSPATH.\n+\t* lang-specs.h: Handle -I.  Minor cleanup to -M options.\n+\tCorrectly put braces around second string in each entry.\n+\t* gjavah.c (main): Call jcf_path_init.  Recognize all the new\n+\tclasspath-related options.\n+\t(help): Updated for new options.\n+\t* jcf.h: Declare functions from jcf-path.c.  Don't mention\n+\t`classpath' global.\n+\t* jcf-path.c: New file.\n+\n+\t* jcf-depend.c: Include jcf.h.\n+\n+\t* jcf-write.c (localvar_alloc): Returns `void'.\n+\t(localvar_free): Removed unused variable.\n+\n+\t* lang.c (OBJECT_SUFFIX): Define if not already defined.\n+\t(init_parse): Use OBJECT_SUFFIX, not \".o\".\n+\n Wed Oct 21 07:54:11 1998  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* class.c (emit_register_classes): Renamed from"}, {"sha": "0ec63d54144e99dfd690257aaf67df27bf8a1a36", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -74,7 +74,7 @@ JAVA_SRCS = $(srcdir)/java/parse.y $(srcdir)/java/class.c \\\n   $(srcdir)/java/verify.c $(srcdir)/java/zextract.c $(srcdir)/java/jcf-io.c \\\n   $(srcdir)/java/jcf-parse.c $(srcdir)/java/mangle.c \\\n   $(srcdir)/java/jcf-write.c $(srcdir)/java/buffer.c \\\n-  $(srcdir)/java/jcf-depend.c \n+  $(srcdir)/java/jcf-depend.c  $(srcdir)/java/jcf-path.c\n \n jc1$(exeext): $(P) $(JAVA_SRCS) $(LIBDEPS) stamp-objlist\n \tcd java; $(MAKE) $(FLAGS_TO_PASS) $(JAVA_FLAGS_TO_PASS) ../jc1$(exeext)\n@@ -119,7 +119,8 @@ jvgenmain$(exeext): $(srcdir)/java/jvgenmain.c $(srcdir)/java/mangle.c \\\n GCJH_SOURCES = $(srcdir)/java/gjavah.c $(srcdir)/java/jcf-io.c \\\n \t$(srcdir)/java/zextract.c $(srcdir)/java/jcf-reader.c \\\n \t$(srcdir)/java/jcf.h $(srcdir)/java/javaop.h \\\n-\t$(srcdir)/java/javaop.def $(srcdir)/java/jcf-depend.c\n+\t$(srcdir)/java/javaop.def $(srcdir)/java/jcf-depend.c \\\n+\t$(srcdir)/java/jcf-path.c\n \n gcjh$(exeext): $(GCJH_SOURCES)\n \tcd java && $(MAKE) $(FLAGS_TO_PASS) $(JAVA_FLAGS_TO_PASS) ../gcjh$(exeext)"}, {"sha": "217a5bea4d5aa0131cab1a256bf8841a857120a5", "filename": "gcc/java/Makefile.in", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMakefile.in?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -104,6 +104,10 @@ objdir = .\n srcdir = @srcdir@\n VPATH = @srcdir@\n \n+# Directory holding libjava.zip.\n+datadir = @datadir@\n+libjava_zip = $(datadir)/libjava.zip\n+\n # Additional system libraries to link with.\n CLIB=\n \n@@ -178,7 +182,7 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)\n #\n JAVA_OBJS = parse.o class.o decl.o expr.o constants.o lang.o typeck.o \\\n   except.o verify.o zextract.o jcf-io.o jcf-parse.o mangle.o jcf-write.o \\\n-  buffer.o jcf-depend.o\n+  buffer.o jcf-depend.o jcf-path.o\n \n JAVA_OBJS_LITE = parse-scan.o jv-scan.o\n \n@@ -198,15 +202,19 @@ compiler: ../jc1$(exeext) ../jv-scan$(exeext)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ \\\n \t      $(JAVA_OBJS_LITE) $(LIBS)\n \n-../jcf-dump$(exeext): jcf-dump.o jcf-io.o jcf-depend.o zextract.o\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ jcf-dump.o jcf-io.o jcf-depend.o zextract.o $(LIBS)\n+../jcf-dump$(exeext): jcf-dump.o jcf-io.o jcf-depend.o jcf-path.o \\\n+\t\tzextract.o\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ jcf-dump.o jcf-io.o \\\n+\t  jcf-depend.o jcf-path.o zextract.o\n \n # Dependencies here must be kept in sync with dependencies in Make-lang.in.\n ../jvgenmain$(exeext):  jvgenmain.o mangle.o\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ jvgenmain.o mangle.o ../obstack.o\n \n-../gcjh$(exeext): gjavah.o jcf-io.o jcf-depend.o zextract.o\n-\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gjavah.o jcf-io.o jcf-depend.o zextract.o $(LIBS)\n+../gcjh$(exeext): gjavah.o jcf-io.o jcf-depend.o jcf-path.o \\\n+\t\tzextract.o\n+\t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gjavah.o jcf-io.o \\\n+\t  jcf-depend.o jcf-path.o zextract.o\n \n Makefile: $(srcdir)/Makefile.in $(srcdir)/../configure\n \tcd ..; $(SHELL) config.status\n@@ -240,6 +248,10 @@ keyword.h: keyword.gperf\n \tgperf -L KR-C -F ', 0' -p -t -j1 -i 1 -g -o -N java_keyword -k1,3,$$ \\\n \tkeyword.gperf > keyword.h\n \n+jcf-path.o: jcf-path.c $(CONFIG_H) $(srcdir)/../system.h jcf.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n+\t  -DLIBJAVA_ZIP_FILE='\"$(libjava_zip)\"' $(srcdir)/jcf-path.c\n+\n # These exist for maintenance purposes.\n \n # Update the tags table.\n@@ -277,7 +289,7 @@ expr.o : expr.c $(CONFIG_H) $(JAVA_TREE_H) jcf.h $(srcdir)/../real.h \\\n   $(RTL_H) $(EXPR_H) javaop.h java-opcodes.h $(srcdir)/../except.h \\\n   java-except.h java-except.h parse.h $(srcdir)/../toplev.h \\\n   $(srcdir)/../system.h\n-jcf-depend.o: jcf-depend.c $(CONFIG_H) $(srcdir)/../system.h\n+jcf-depend.o: jcf-depend.c $(CONFIG_H) $(srcdir)/../system.h jcf.h\n jcf-io.o: jcf-io.c $(CONFIG_H) $(srcdir)/../system.h\n jcf-parse.o : jcf-parse.c $(CONFIG_H) $(JAVA_TREE_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../input.h java-except.h $(srcdir)/../system.h"}, {"sha": "c8a9facb19caff70be358acb2786c278281c1d2d", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -31,6 +31,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #endif\n #include <math.h>\n \n+#include <string.h>\n+\n /* The output file.  */\n FILE *out = NULL;\n \n@@ -877,6 +879,8 @@ help ()\n   printf (\"Usage: gcjh [OPTION]... CLASS...\\n\\n\");\n   printf (\"Generate C++ header files from .class files\\n\\n\");\n   printf (\"  --classpath PATH        Set path to find .class files\\n\");\n+  printf (\"  --CLASSPATH PATH        Set path to find .class files\\n\");\n+  printf (\"  -IDIR                   Append directory to class path\\n\");\n   printf (\"  -d DIRECTORY            Set output directory name\\n\");\n   printf (\"  --help                  Print this help, then exit\\n\");\n   printf (\"  -o FILE                 Set output file name\\n\");\n@@ -918,6 +922,8 @@ DEFUN(main, (argc, argv),\n   if (argc <= 1)\n     usage ();\n \n+  jcf_path_init ();\n+\n   for (argi = 1; argi < argc; argi++)\n     {\n       char *arg = argv[argi];\n@@ -997,10 +1003,19 @@ DEFUN(main, (argc, argv),\n       else if (strcmp (arg, \"-classpath\") == 0)\n \t{\n \t  if (argi + 1 < argc)\n-\t    classpath = argv[++argi];\n+\t    jcf_path_classpath_arg (argv[++argi]);\n \t  else\n \t    java_no_argument (argv[argi]);\n \t}\n+      else if (strcmp (arg, \"-CLASSPATH\") == 0)\n+\t{\n+\t  if (argi + 1 < argc)\n+\t    jcf_path_CLASSPATH_arg (argv[++argi]);\n+\t  else\n+\t    java_no_argument (argv[argi]);\n+\t}\n+      else if (strncmp (arg, \"-I\", 2) == 0)\n+\tjcf_path_include_arg (arg + 2);\n       else if (strcmp (arg, \"-verbose\") == 0 || strcmp (arg, \"-v\") == 0)\n \tverbose++;\n       else if (strcmp (arg, \"-stubs\") == 0)\n@@ -1046,19 +1061,14 @@ DEFUN(main, (argc, argv),\n   if (argi == argc)\n     usage ();\n \n+  jcf_path_seal ();\n+\n   if (output_file && emit_dependencies)\n     {\n       fprintf (stderr, \"gcjh: can't specify both -o and -MD\\n\");\n       exit (1);\n     }\n \n-  if (classpath == NULL)\n-    {\n-      classpath = (char *) getenv (\"CLASSPATH\");\n-      if (classpath == NULL)\n-\tclasspath = \"\";\n-    }\n-\n   for (; argi < argc; argi++)\n     {\n       char *classname = argv[argi];"}, {"sha": "666862fce2e470c161d47bb237d4bf9e9041148b", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -517,7 +517,6 @@ extern void set_super_info PROTO ((int, tree, tree, int));\n extern int get_access_flags_from_decl PROTO ((tree));\n extern int interface_of_p PROTO ((tree, tree));\n extern int inherits_from_p PROTO ((tree, tree));\n-extern void fix_classpath PROTO (());\n extern void complete_start_java_method PROTO ((tree));\n extern void emit_handlers PROTO (());\n extern void init_outgoing_cpool PROTO (());"}, {"sha": "9adbdb4eec025adb32cb084ba0e569dd961d5353", "filename": "gcc/java/jcf-depend.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-depend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-depend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-depend.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -28,6 +28,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n #include <assert.h>\n \n+#include \"jcf.h\"\n+\n \f\n \n /* We keep a linked list of all the files we've already read.  */\n@@ -95,8 +97,6 @@ add_entry (entp, name)\n void\n jcf_dependency_reset ()\n {\n-  struct entry *ent, *next;\n-\n   free_entry (&dependencies);\n   free_entry (&targets);\n \n@@ -139,11 +139,9 @@ jcf_dependency_set_dep_file (name)\n \n void\n jcf_dependency_add_file (filename, system_p)\n-     char *filename;\n+     const char *filename;\n      int system_p;\n {\n-  struct entry *ent;\n-\n   /* Just omit system files.  */\n   if (system_p && ! system_files)\n     return;\n@@ -253,7 +251,6 @@ void\n jcf_dependency_write ()\n {\n   int column = 0;\n-  struct entry *ent;\n \n   if (! dep_out)\n     return;"}, {"sha": "7ccb97cc6d9da49da1397ae48224102a98217ec8", "filename": "gcc/java/jcf-dump.c", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-dump.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -712,44 +712,37 @@ DEFUN(main, (argc, argv),\n   if (argc <= 1)\n     usage ();\n \n+  jcf_path_init ();\n+\n   for (argi = 1; argi < argc; argi++)\n     {\n       char *arg = argv[argi];\n+\n+      /* Just let all arguments be given in either \"-\" or \"--\" form.  */\n+      if (arg[0] != '-' || ! strcmp (arg, \"--\"))\n+\tbreak;\n+\n       if (arg[0] == '-')\n \t{\n \t  if (strcmp (arg, \"-o\") == 0 && argi + 1 < argc)\n \t    output_file = argv[++argi];\n-\t  else if (arg[1] == '-')\n-\t    {\n-\t      arg++;\n-\t      if (strcmp (arg, \"-classpath\") == 0 && argi + 1 < argc)\n-\t\tclasspath = argv[++argi];\n-\t      else if (strcmp (arg, \"-verbose\") == 0)\n-\t\tverbose++;\n-\t      else if (strcmp (arg, \"-print-main\") == 0)\n-\t\tflag_print_main++;\n-\t      else if (strcmp (arg, \"-javap\") == 0)\n-\t\t{\n-\t\t  flag_javap_compatible++;\n-\t\t  flag_print_constant_pool = 0;\n-\t\t}\n-\t      else if (arg[2] == '\\0')\n-\t\tbreak;\n-\t      else\n-\t\t{\n-\t\t  fprintf (stderr, \"%s: illegal argument\\n\", argv[argi]);\n-\t\t  exit (FATAL_EXIT_CODE);\n-\t\t}\n-\t      \n-\t    }\n \t  else if (strcmp (arg, \"-classpath\") == 0 && argi + 1 < argc)\n-\t    classpath = argv[++argi];\n+\t    jcf_path_classpath_arg (argv[++argi]);\n+\t  else if (strcmp (arg, \"-CLASSPATH\") == 0 && argi + 1 < argc)\n+\t    jcf_path_CLASSPATH_arg (argv[++argi]);\n+\t  else if (strncmp (arg, \"-I\", 2) == 0)\n+\t    jcf_path_include_arg (arg + 2);\n \t  else if (strcmp (arg, \"-verbose\") == 0)\n \t    verbose++;\n \t  else if (strcmp (arg, \"-print-main\") == 0)\n \t    flag_print_main++;\n \t  else if (strcmp (arg, \"-c\") == 0)\n \t    flag_disassemble_methods++;\n+\t  else if (strcmp (arg, \"-javap\") == 0)\n+\t    {\n+\t      flag_javap_compatible++;\n+\t      flag_print_constant_pool = 0;\n+\t    }\n \t  else\n \t    {\n \t      fprintf (stderr, \"%s: illegal argument\\n\", argv[argi]);\n@@ -759,8 +752,12 @@ DEFUN(main, (argc, argv),\n       else\n \tbreak;\n     }\n+\n   if (argi == argc)\n     usage ();\n+\n+  jcf_path_seal ();\n+\n   if (flag_print_main)\n     {\n       flag_print_fields = 0;\n@@ -770,13 +767,6 @@ DEFUN(main, (argc, argv),\n       flag_print_class_info = 0;\n     }\n \n-  if (classpath == NULL)\n-    {\n-      classpath = (char *) getenv (\"CLASSPATH\");\n-      if (classpath == NULL)\n-\tclasspath = \"\";\n-    }\n-\n   if (output_file)\n     {\n       out = fopen (output_file, \"w\");"}, {"sha": "666cda7bdaa35f449901cef68274d144705d07b3", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 144, "deletions": 131, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -25,8 +25,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"config.h\"\n #include \"system.h\"\n \n-#define ENABLE_UNZIP 1\n-\n #include \"jcf.h\"\n #include <sys/stat.h>\n #include <sys/wait.h>\n@@ -36,8 +34,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #define O_BINARY 0 /* MS-DOS brain-damage */\n #endif\n \n-char *classpath;\n-\n int\n DEFUN(jcf_unexpected_eof, (jcf, count),\n       JCF *jcf AND int count)\n@@ -89,15 +85,14 @@ DEFUN(jcf_filbuf_from_stdio, (jcf, count),\n   return 0;\n }\n \n-#if ENABLE_UNZIP\n #include \"zipfile.h\"\n \n struct ZipFileCache *SeenZipFiles = NULL;\n \n int\n-DEFUN(open_in_zip, (jcf, \n-zipfile, zipmember),\n-      JCF *jcf AND const char *zipfile AND const char *zipmember)\n+DEFUN(open_in_zip, (jcf, zipfile, zipmember),\n+      JCF *jcf AND const char *zipfile AND const char *zipmember\n+      AND int is_system)\n {\n   struct ZipFileCache* zipf;\n   ZipDirectory *zipd;\n@@ -108,7 +103,7 @@ zipfile, zipmember),\n \t{\n \t  char magic [4];\n \t  int fd = open (zipfile, O_RDONLY | O_BINARY);\n-\t  jcf_dependency_add_file (zipfile, 0);\t/* FIXME: system file? */\n+\t  jcf_dependency_add_file (zipfile, is_system);\n \t  if (read (fd, magic, 4) != 4 || GET_u4 (magic) != (JCF_u4)ZIPMAGIC)\n \t    return -1;\n \t  lseek (fd, 0L, SEEK_SET);\n@@ -165,7 +160,6 @@ zipfile, zipmember),\n     }\n   return -1;\n }\n-#endif /* ENABLE_UNZIP */\n \n #if JCF_USE_STDIO\n char*\n@@ -260,156 +254,175 @@ DEFUN(find_class, (classname, classname_length, jcf, do_class_file),\n #else\n   int fd;\n #endif\n-  int i, j, k, java, class;\n+  int i, k, java, class;\n   struct stat java_buf, class_buf;\n   char *dep_file;\n-\n-  /* A temporary buffer that we grow to be large enough to hold\n-     whatever class name we're working on.  */\n-  static int temp_len = 0;\n-  static char *temp_buffer = NULL;\n+  void *entry, *java_entry;\n+  char *java_buffer;\n \n   /* Allocate and zero out the buffer, since we don't explicitly put a\n      null pointer when we're copying it below.  */\n-  int buflen = strlen (classpath) + classname_length + 10;\n+  int buflen = jcf_path_max_len () + classname_length + 10;\n   char *buffer = (char *) ALLOC (buflen);\n   bzero (buffer, buflen);\n \n-  if (buflen > temp_len)\n-    {\n-      temp_len = buflen;\n-      if (temp_buffer == NULL)\n-\ttemp_buffer = (char *) ALLOC (temp_len);\n-      else\n-\ttemp_buffer = (char *) REALLOC (temp_buffer, temp_len);\n-    }\n+  java_buffer = (char *) alloca (buflen);\n \n   jcf->java_source = jcf->outofsynch = 0;\n-  for (j = 0; classpath[j] != '\\0'; )\n+\n+  for (entry = jcf_path_start (); entry != NULL; entry = jcf_path_next (entry))\n     {\n-      for (i = 0; classpath[j] != ':' && classpath[j] != '\\0'; i++, j++)\n-\tbuffer[i] = classpath[j];\n-      if (classpath[j] == ':')\n-\tj++;\n-      if (i > 0)  /* Empty directory is redundant */\n+      int dir_len;\n+\n+      strcpy (buffer, jcf_path_name (entry));\n+      i = strlen (buffer);\n+\n+      dir_len = i - 1;\n+\n+      for (k = 0; k < classname_length; k++, i++)\n \t{\n-\t  int dir_len;\n-\t  if (buffer[i-1] != '/')\n-\t    buffer[i++] = '/';\n-\t  dir_len = i-1;\n-\t  for (k = 0; k < classname_length; k++, i++)\n-\t    {\n-\t      char ch = classname[k];\n-\t      buffer[i] = ch == '.' ? '/' : ch;\n-\t    }\n+\t  char ch = classname[k];\n+\t  buffer[i] = ch == '.' ? '/' : ch;\n+\t}\n+      if (do_class_file)\n+\tstrcpy (buffer+i, \".class\");\n+\n+      if (jcf_path_is_zipfile (entry))\n+\t{\n+\t  int err_code;\n+\t  JCF _jcf;\n+\t  if (!do_class_file)\n+\t    strcpy (buffer+i, \"/\");\n+\t  buffer[dir_len] = '\\0';\n \t  if (do_class_file)\n-\t    strcpy (buffer+i, \".class\");\n-#if ENABLE_UNZIP\n-\t  if (dir_len > 4\n-\t      && buffer[dir_len-4] == '.' && buffer[dir_len-3] == 'z'\n-\t      && buffer[dir_len-2] == 'i' && buffer[dir_len-1] == 'p')\n+\t    SOURCE_FRONTEND_DEBUG \n+\t      ((\"Trying [...%s]:%s\", \n+\t\t&buffer[dir_len-(dir_len > 15 ? 15 : dir_len)], \n+\t\tbuffer+dir_len+1));\n+\t  if (jcf == NULL)\n+\t    jcf = &_jcf;\n+\t  err_code = open_in_zip (jcf, buffer, buffer+dir_len+1,\n+\t\t\t\t  jcf_path_is_system (entry));\n+\t  if (err_code == 0)\n \t    {\n-\t      int err_code;\n-\t      JCF _jcf;\n \t      if (!do_class_file)\n-\t\tstrcpy (buffer+i, \"/\");\n-\t      buffer[dir_len] = '\\0';\n-\t      if (do_class_file)\n-\t\tSOURCE_FRONTEND_DEBUG \n-\t\t  ((\"Trying [...%s]:%s\", \n-\t\t    &buffer[dir_len-(dir_len > 15 ? 15 : dir_len)], \n-\t\t    buffer+dir_len+1));\n-\t      if (jcf == NULL)\n-\t\tjcf = &_jcf;\n-\t      err_code = open_in_zip (jcf, buffer, buffer+dir_len+1);\n-\t      if (err_code == 0)\n-\t\t{\n-\t\t  if (!do_class_file)\n-\t\t    jcf->seen_in_zip = 1;\n-\t\t  else\n-\t\t    {\n-\t\t      buffer[dir_len] = '(';\n-\t\t      strcpy (buffer+i, \".class)\");\n-\t\t    }\n-\t\t  if (jcf == &_jcf)\n-\t\t    JCF_FINISH (jcf);\n-\t\t  return buffer;\n-\t\t}\n+\t\tjcf->seen_in_zip = 1;\n \t      else\n-\t\tcontinue;\n-\t    }\n-#endif\n-\t  /* If we do directories, do them here */\n-\t  if (!do_class_file)\n-\t    {\n-\t      struct stat dir_buff;\n-\t      int dir;\n-\t      buffer[i] = '\\0';\t/* Was previously unterminated here. */\n-\t      if (!(dir = stat (buffer, &dir_buff)))\n \t\t{\n-\t\t  jcf->seen_in_zip = 0;\n-\t\t  goto found;\n+\t\t  buffer[dir_len] = '(';\n+\t\t  strcpy (buffer+i, \".class)\");\n \t\t}\n+\t      if (jcf == &_jcf)\n+\t\tJCF_FINISH (jcf);\n+\t      return buffer;\n \t    }\n-\n-\t  /* Check for out of synch .class/.java files */\n-\t  class = stat (buffer, &class_buf);\n-\t  strcpy (buffer+i, \".java\");\n-\t  /* Stash the name of the .java file in the temp buffer.  */\n-\t  strcpy (temp_buffer, buffer);\n-\t  java = stat (buffer, &java_buf);\n-\t  if ((!java && !class) && java_buf.st_mtime >= class_buf.st_mtime)\n-\t    jcf->outofsynch = 1;\n-\n-\t  if (! java)\n-\t    dep_file = temp_buffer;\n \t  else\n-\t    dep_file = buffer;\n-#if JCF_USE_STDIO\n-\t  if (!class)\n+\t    continue;\n+\t}\n+\n+      /* If we do directories, do them here */\n+      if (!do_class_file)\n+\t{\n+\t  struct stat dir_buff;\n+\t  int dir;\n+\t  buffer[i] = '\\0';\t/* Was previously unterminated here. */\n+\t  if (!(dir = stat (buffer, &dir_buff)))\n \t    {\n-\t      strcpy (buffer+i, \".class\");\n-\t      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-\t      stream = fopen (buffer, \"rb\");\n-\t      if (stream)\n-\t\tgoto found;\n+\t      jcf->seen_in_zip = 0;\n+\t      goto found;\n \t    }\n-\t  /* Give .java a try, if necessary */\n-\t  if (!java)\n+\t}\n+\n+      class = stat (buffer, &class_buf);\n+      /* This is a little odd: if we didn't find the class file, we\n+\t can just skip to the next iteration.  However, if this is the\n+\t last iteration, then we want to search for the .java file as\n+\t well.  It was a little easier to implement this with two\n+\t loops, as opposed to checking for each type of file each time\n+\t through the loop.  */\n+      if (class && jcf_path_next (entry))\n+\tcontinue;\n+\n+      /* Check for out of synch .class/.java files.  */\n+      java = 1;\n+      for (java_entry = jcf_path_start ();\n+\t   java && java_entry != NULL;\n+\t   java_entry = jcf_path_next (java_entry))\n+\t{\n+\t  int m, l;\n+\t  extern int saw_java_source; /* FIXME: temporary.   */\n+\n+\t  if (jcf_path_is_zipfile (java_entry))\n+\t    continue;\n+\n+\t  /* Compute name of .java file.  */\n+\t  strcpy (java_buffer, jcf_path_name (java_entry));\n+\t  l = strlen (java_buffer);\n+\t  for (m = 0; m < classname_length; ++m)\n \t    {\n-\t      strcpy (buffer+i, \".java\");\n-\t      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-\t      stream = fopen (buffer, \"r\");\n-\t      if (stream)\n-\t\t{\n-\t\t  jcf->java_source = 1;\n-\t\t  goto found;\n-\t\t}\n+\t      java_buffer[m + l] = (classname[m] == '.'\n+\t\t\t\t    ? '/'\n+\t\t\t\t    : classname[m]);\n \t    }\n-#else\n-\t  if (!class)\n+\t  strcpy (java_buffer + m + l, \".java\");\n+\n+\t  /* FIXME: until the `.java' parser is fully working, we only\n+\t     look for a .java file when one was mentioned on the\n+\t     command line.  This lets us test the .java parser fairly\n+\t     easily, without compromising our ability to use the\n+\t     .class parser without fear.  */\n+\t  if (saw_java_source)\n+\t    java = stat (java_buffer, &java_buf);\n+\t}\n+\n+      if (! java && ! class && java_buf.st_mtime >= class_buf.st_mtime)\n+\tjcf->outofsynch = 1;\n+\n+      if (! java)\n+\tdep_file = java_buffer;\n+      else\n+\tdep_file = buffer;\n+#if JCF_USE_STDIO\n+      if (!class)\n+\t{\n+\t  SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+\t  stream = fopen (buffer, \"rb\");\n+\t  if (stream)\n+\t    goto found;\n+\t}\n+      /* Give .java a try, if necessary */\n+      if (!java)\n+\t{\n+\t  strcpy (buffer, java_buffer);\n+\t  SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+\t  stream = fopen (buffer, \"r\");\n+\t  if (stream)\n \t    {\n-\t      strcpy (buffer+i, \".class\");\n-\t      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-\t      fd = open (buffer, O_RDONLY | O_BINARY);\n-\t      if (fd >= 0)\n-\t\tgoto found;\n+\t      jcf->java_source = 1;\n+\t      goto found;\n \t    }\n-\t  /* Give .java a try, if necessary */\n-\t  if (!java)\n+\t}\n+#else\n+      if (!class)\n+\t{\n+\t  SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+\t  fd = open (buffer, O_RDONLY | O_BINARY);\n+\t  if (fd >= 0)\n+\t    goto found;\n+\t}\n+      /* Give .java a try, if necessary */\n+      if (!java)\n+\t{\n+\t  strcpy (buffer, java_buffer);\n+\t  SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n+\t  fd = open (buffer, O_RDONLY);\n+\t  if (fd >= 0)\n \t    {\n-\t      if (do_class_file)\n-\t\tstrcpy (buffer+i, \".java\");\n-\t      SOURCE_FRONTEND_DEBUG ((\"Trying %s\", buffer));\n-\t      fd = open (buffer, O_RDONLY | O_BINARY);\n-\t      if (fd >= 0)\n-\t\t{\n-\t\t  jcf->java_source = 1;\n-\t\t  goto found;\n-\t\t}\n+\t      jcf->java_source = 1;\n+\t      goto found;\n \t    }\n-#endif\n \t}\n+#endif\n     }\n   free (buffer);\n   return NULL;"}, {"sha": "81a1528e750a876f0431e90849defa46b85994f4", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -1,5 +1,5 @@\n /* Parser for Java(TM) .class files.\n-   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -61,6 +61,11 @@ tree current_class = NULL_TREE;\n /* The class we started with. */\n tree main_class = NULL_TREE;\n \n+/* This is true if the user specified a `.java' file on the command\n+   line.  Otherwise it is 0.  FIXME: this is temporary, until our\n+   .java parser is fully working.  */\n+int saw_java_source = 0;\n+\n /* The FIELD_DECL for the current field. */\n static tree current_field = NULL_TREE;\n \n@@ -412,22 +417,6 @@ get_class_constant (JCF *jcf , int i)\n   return type;\n }\n \n-void\n-fix_classpath ()\n-{\n-  static char default_path[] = DEFAULT_CLASS_PATH;\n-\n-  if (classpath == NULL)\n-    {\n-      classpath = (char *) getenv (\"CLASSPATH\");\n-      if (classpath == NULL)\n-\t{\n-\t  warning (\"CLASSPATH not set\");\n-\t  classpath = default_path;\n-\t}\n-    }\n-}\n-\n void\n DEFUN(jcf_out_of_synch, (jcf),\n       JCF *jcf)\n@@ -465,8 +454,6 @@ load_class (class_or_name, verbose)\n \n   push_obstacks (&permanent_obstack, &permanent_obstack);\n \n-  if (!classpath)\n-    fix_classpath ();\n   /* Search in current zip first.  */\n   if (find_in_current_zip (IDENTIFIER_POINTER (name),\n \t\t\t   IDENTIFIER_LENGTH (name), &jcf) == 0)\n@@ -475,11 +462,14 @@ load_class (class_or_name, verbose)\n       {\n \tif (verbose)\n \t  {\n-\t    error (\"Cannot find class file class %s.\", \n+\t    error (\"Cannot find class file for class %s.\",\n \t\t   IDENTIFIER_POINTER (name));\n \t    TYPE_SIZE (class_or_name) = error_mark_node;\n+#if 0\n+\t    /* FIXME: what to do here?  */\n \t    if (!strcmp (classpath, DEFAULT_CLASS_PATH))\n \t      fatal (\"giving up\");\n+#endif\n \t    pop_obstacks ();\t/* FIXME: one pop_obstack() per function */\n \t  }\n \treturn;\n@@ -730,12 +720,16 @@ yyparse ()\n \n       if (list[0]) \n \t{\n-\t  char *value;\n+\t  char *value, len;\n+\n+\t  len = strlen (list);\n+\t  if (len > 5 && ! strcmp (&list[len - 5], \".java\"))\n+\t    saw_java_source = 1;\n \n \t  if (*list != '/' && several_files)\n \t    obstack_grow (&temporary_obstack, \"./\", 2);\n-      \n-\t  obstack_grow0 (&temporary_obstack, list, strlen (list));\n+\n+\t  obstack_grow0 (&temporary_obstack, list, len);\n \t  value = obstack_finish (&temporary_obstack);\n \t  node = get_identifier (value);\n \t  IS_A_COMMAND_LINE_FILENAME_P (node) = 1;\n@@ -936,7 +930,8 @@ DEFUN(jcf_figure_file_type, (jcf),\n   if (magic == 0xcafebabe)\n     return JCF_CLASS;\n \n-  if (!open_in_zip (jcf, input_filename, NULL))\n+  /* FIXME: is it a system file?  */\n+  if (!open_in_zip (jcf, input_filename, NULL, 0))\n     {\n       localToFile = ALLOC (sizeof (struct ZipFileCache));\n       bcopy (SeenZipFiles, localToFile, sizeof (struct ZipFileCache));"}, {"sha": "6e88496b54916689a250c337a8707c0aa79d4899", "filename": "gcc/java/jcf-path.c", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-path.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-path.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-path.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -0,0 +1,341 @@\n+/* Handle CLASSPATH, -classpath, and path searching.\n+\n+   Copyright (C) 1998  Free Software Foundation, Inc.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  \n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Tom Tromey <tromey@cygnus.com>, October 1998.  */\n+\n+#include <config.h>\n+#include \"system.h\"\n+\n+#include \"jcf.h\"\n+\n+/* Some boilerplate that really belongs in a header.  */\n+\n+#ifndef GET_ENV_PATH_LIST\n+#define GET_ENV_PATH_LIST(VAR,NAME)\tdo { (VAR) = getenv (NAME); } while (0)\n+#endif\n+\n+/* By default, colon separates directories in a path.  */\n+#ifndef PATH_SEPARATOR\n+#define PATH_SEPARATOR ':'\n+#endif\n+\n+#ifndef DIR_SEPARATOR\n+#define DIR_SEPARATOR '/'\n+#endif\n+\n+\f\n+\n+/* Possible flag values.  */\n+#define FLAG_SYSTEM 1\n+#define FLAG_ZIP    2\n+\n+/* We keep linked lists of directory names.  A ``directory'' can be\n+   either an ordinary directory or a .zip file.  */\n+struct entry\n+{\n+  char *name;\n+  int flags;\n+  struct entry *next;\n+};\n+\n+/* We support several different ways to set the class path.\n+\n+   built-in system directory (only libjava.zip)\n+   CLASSPATH environment variable\n+   -CLASSPATH overrides CLASSPATH\n+   -classpath option - overrides CLASSPATH, -CLASSPATH, and built-in\n+   -I prepends path to list\n+\n+   We implement this by keeping several path lists, and then simply\n+   ignoring the ones which are not relevant.  */\n+\n+/* This holds all the -I directories.  */\n+static struct entry *include_dirs;\n+\n+/* This holds the CLASSPATH environment variable.  */\n+static struct entry *classpath_env;\n+\n+/* This holds the -CLASSPATH command-line option.  */\n+static struct entry *classpath_u;\n+\n+/* This holds the -classpath command-line option.  */\n+static struct entry *classpath_l;\n+\n+/* This holds the default directories.  Some of these will have the\n+   \"system\" flag set.  */\n+static struct entry *sys_dirs;\n+\n+/* This is the sealed list.  It is just a combination of other lists.  */\n+static struct entry *sealed;\n+\n+/* We keep track of the longest path we've seen.  */\n+static int longest_path = 0;\n+\n+\f\n+\n+static void\n+free_entry (entp)\n+     struct entry **entp;\n+{\n+  struct entry *e, *n;\n+\n+  for (e = *entp; e; e = n)\n+    {\n+      n = e->next;\n+      free (e->name);\n+      free (e);\n+    }\n+  *entp = NULL;\n+}\n+\n+static void\n+append_entry (entp, ent)\n+     struct entry **entp;\n+     struct entry *ent;\n+{\n+  /* It doesn't matter if this is slow, since it is run only at\n+     startup, and then infrequently.  */\n+  struct entry *e;\n+\n+  /* Find end of list.  */\n+  for (e = *entp; e && e->next; e = e->next)\n+    ;\n+\n+  if (e)\n+    e->next = ent;\n+  else\n+    *entp = ent;\n+}\n+\n+static void\n+add_entry (entp, filename, is_system)\n+     struct entry **entp;\n+     char *filename;\n+     int is_system;\n+{\n+  int len;\n+  struct entry *n;\n+\n+  n = (struct entry *) ALLOC (sizeof (struct entry));\n+  n->flags = is_system ? FLAG_SYSTEM : 0;\n+  n->next = NULL;\n+\n+  len = strlen (filename);\n+  if (len > 4 && ! strcmp (filename - 4, \".zip\"))\n+    {\n+      n->flags |= FLAG_ZIP;\n+      /* If the user uses -classpath then he'll have to include\n+\t libjava.zip in the value.  We check for this in a simplistic\n+\t way.  Symlinks will fool this test.  This is only used for\n+\t -MM and -MMD, so it probably isn't terribly important.  */\n+      if (! strcmp (filename, LIBJAVA_ZIP_FILE))\n+\tn->flags |= FLAG_SYSTEM;\n+    }\n+\n+  if (filename[len - 1] != '/' && filename[len - 1] != DIR_SEPARATOR)\n+    {\n+      char *f2 = (char *) alloca (len + 1);\n+      strcpy (f2, filename);\n+      f2[len] = DIR_SEPARATOR;\n+      f2[len + 1] = '\\0';\n+      n->name = strdup (f2);\n+      ++len;\n+    }\n+  else\n+    n->name = strdup (filename);\n+\n+  if (len > longest_path)\n+    longest_path = len;\n+\n+  append_entry (entp, n);\n+}\n+\n+static void\n+add_path (entp, cp, is_system)\n+     struct entry **entp;\n+     char *cp;\n+     int is_system;\n+{\n+  char *startp, *endp;\n+\n+  if (cp)\n+    {\n+      char *buf = (char *) alloca (strlen (cp) + 3);\n+      startp = endp = cp;\n+      while (1)\n+\t{\n+\t  if (! *endp || *endp == PATH_SEPARATOR)\n+\t    {\n+\t      strncpy (buf, startp, endp - startp);\n+\t      if (endp == startp)\n+\t\t{\n+\t\t  buf[0] = '.';\n+\t\t  buf[1] = DIR_SEPARATOR;\n+\t\t  buf[2] = '\\0';\n+\t\t}\n+\t      else if (endp[-1] != '/' && endp[1] != DIR_SEPARATOR)\n+\t\t{\n+\t\t  buf[endp - startp] = DIR_SEPARATOR;\n+\t\t  buf[endp - startp + 1] = '\\0';\n+\t\t}\n+\t      else\n+\t\tbuf[endp - startp] = '\\0';\n+\t      add_entry (entp, buf, is_system);\n+\t      if (! *endp)\n+\t\tbreak;\n+\t      ++endp;\n+\t      startp = endp;\n+\t    }\n+\t  else\n+\t    ++endp;\n+\t}\n+    }\n+}\n+\n+/* Initialize the path module.  */\n+void\n+jcf_path_init ()\n+{\n+  char *cp;\n+\n+  add_entry (&sys_dirs, \".\", 0);\n+  add_entry (&sys_dirs, LIBJAVA_ZIP_FILE, 1);\n+\n+  GET_ENV_PATH_LIST (cp, \"CLASSPATH\");\n+  add_path (&classpath_env, cp, 0);\n+}\n+\n+/* Call this when -classpath is seen on the command line.  */\n+void\n+jcf_path_classpath_arg (path)\n+     char *path;\n+{\n+  free_entry (&classpath_l);\n+  add_path (&classpath_l, path, 0);\n+}\n+\n+/* Call this when -CLASSPATH is seen on the command line.  */\n+void\n+jcf_path_CLASSPATH_arg (path)\n+     char *path;\n+{\n+  free_entry (&classpath_u);\n+  add_path (&classpath_u, path, 0);\n+}\n+\n+/* Call this when -I is seen on the command line.  */\n+void\n+jcf_path_include_arg (path)\n+     char *path;\n+{\n+  add_entry (&include_dirs, path, 0);\n+}\n+\n+/* We `seal' the path by linking everything into one big list.  Then\n+   we provide a way to iterate through the sealed list.  */\n+void\n+jcf_path_seal ()\n+{\n+  int do_system = 1;\n+  struct entry *secondary;\n+\n+  sealed = include_dirs;\n+  include_dirs = NULL;\n+\n+  if (classpath_l)\n+    {\n+      secondary = classpath_l;\n+      classpath_l = NULL;\n+      do_system = 0;\n+    }\n+  else if (classpath_u)\n+    {\n+      secondary = classpath_u;\n+      classpath_u = NULL;\n+    }\n+  else\n+    {\n+      secondary = classpath_env;\n+      classpath_env = NULL;\n+    }\n+\n+  free_entry (&classpath_l);\n+  free_entry (&classpath_u);\n+  free_entry (&classpath_env);\n+\n+  append_entry (&sealed, secondary);\n+\n+  if (do_system)\n+    {\n+      append_entry (&sealed, sys_dirs);\n+      sys_dirs = NULL;\n+    }\n+  else\n+    free_entry (&sys_dirs);\n+}\n+\n+void *\n+jcf_path_start ()\n+{\n+  return (void *) sealed;\n+}\n+\n+void *\n+jcf_path_next (x)\n+     void *x;\n+{\n+  struct entry *ent = (struct entry *) x;\n+  return (void *) ent->next;\n+}\n+\n+/* We guarantee that the return path will either be a zip file, or it\n+   will end with a directory separator.  */\n+char *\n+jcf_path_name (x)\n+     void *x;\n+{\n+  struct entry *ent = (struct entry *) x;\n+  return ent->name;\n+}\n+\n+int\n+jcf_path_is_zipfile (x)\n+     void *x;\n+{\n+  struct entry *ent = (struct entry *) x;\n+  return (ent->flags & FLAG_ZIP);\n+}\n+\n+int\n+jcf_path_is_system (x)\n+     void *x;\n+{\n+  struct entry *ent = (struct entry *) x;\n+  return (ent->flags & FLAG_SYSTEM);\n+}\n+\n+int\n+jcf_path_max_len ()\n+{\n+  return longest_path;\n+}"}, {"sha": "5d092c6ec3ab9687ff87a5d9d1d208b2b2aae043", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -347,7 +347,7 @@ struct localvar_info\n #define localvar_max \\\n   ((struct localvar_info**) state->localvars.ptr - localvar_buffer)\n \n-int\n+void\n localvar_alloc (decl, state)\n      tree decl;\n      struct jcf_partial *state;\n@@ -403,7 +403,6 @@ localvar_free (decl, state)\n   register struct localvar_info **ptr = &localvar_buffer [index];\n   register struct localvar_info *info = *ptr;\n   int wide = TYPE_IS_WIDE (TREE_TYPE (decl));\n-  int i;\n \n   info->end_label = end_label;\n "}, {"sha": "3f98814ea5a5aa95c9ef41c7f067779a0b3cfc3c", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -222,7 +222,6 @@ typedef struct JCF {\n #define CONSTANT_Utf8 1\n #define CONSTANT_Unicode 2\n \n-extern char *classpath;\n #define DEFAULT_CLASS_PATH \".\"\n \n extern char *find_class PROTO ((const char *, int, JCF*, int));\n@@ -261,9 +260,22 @@ extern int quiet_flag;\n extern void jcf_dependency_reset PROTO ((void));\n extern void jcf_dependency_set_target PROTO ((char *));\n extern void jcf_dependency_add_target PROTO ((char *));\n-extern void jcf_dependency_set_dep_file PROTO ((char *));\n+extern void jcf_dependency_set_dep_file PROTO ((const char *));\n extern void jcf_dependency_add_file PROTO ((const char *, int));\n extern void jcf_dependency_write PROTO ((void));\n extern void jcf_dependency_init PROTO ((int));\n \n+/* Declarations for path handling code.  */\n+extern void jcf_path_init PROTO ((void));\n+extern void jcf_path_classpath_arg PROTO ((char *));\n+extern void jcf_path_CLASSPATH_arg PROTO ((char *));\n+extern void jcf_path_include_arg PROTO ((char *));\n+extern void jcf_path_seal PROTO ((void));\n+extern void *jcf_path_start PROTO ((void));\n+extern void *jcf_path_next PROTO ((void *));\n+extern char *jcf_path_name PROTO ((void *));\n+extern int jcf_path_is_zipfile PROTO ((void *));\n+extern int jcf_path_is_system PROTO ((void *));\n+extern int jcf_path_max_len PROTO ((void));\n+\n #endif"}, {"sha": "0f0f74b581c7cdca555696679945dbb7db6d6704", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -37,3 +37,6 @@ DEFINE_LANG_NAME (\"Java\")\n   { \"-MMD\", \"Print dependencies to FILE.d\" },\n   { \"-M\", \"Print dependencies to stdout\" },\n   { \"-MM\", \"Print dependencies to stdout\" },\n+  { \"-fclasspath\", \"Set class path and suppress system path\" },\n+  { \"-fCLASSPATH\", \"Set class path\" },\n+  { \"-I\", \"Add directory to class path\" },"}, {"sha": "190a44ceeddc9431cc8127baa1c09417f169f489", "filename": "gcc/java/lang-specs.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-specs.h?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -24,16 +24,17 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n /* This is the contribution to the `default_compilers' array in gcc.c for\n    Java.  */\n \n-  {\".java\",   \"@java\" },\n-  {\".class\",  \"@java\" },\n+  {\".java\",   {\"@java\"} },\n+  {\".class\",  {\"@java\"} },\n   {\"@java\",\n-   \"%{!E:jc1 %i %1 %2 %{!Q:-quiet} %{d*} %{m*} %{a}\\\n+   {\"%{!E:jc1 %i %1 %2 %{!Q:-quiet} %{d*} %{m*} %{a}\\\n \t\t    %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi}\\\n \t\t    %{traditional} %{v:-version} %{pg:-p} %{p}\\\n \t\t    %{f*} %{+e*} %{aux-info*}\\\n-\t\t    %{MD:-MD} %{MMD:-MMD} %{M:-M} %{MM:-MM}\\\n+                    %{I*}\\\n+\t\t    %{MD} %{MMD} %{M} %{MM}\\\n \t\t    %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t\t    %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\\n             %{!S:as %a %Y\\\n \t\t    %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}\\\n-\t\t    %{!pipe:%g.s} %A\\n }}\"},\n+\t\t    %{!pipe:%g.s} %A\\n }}\"}},"}, {"sha": "b425b8b97c7856b6d890cb8514afcb472c9a4636", "filename": "gcc/java/lang.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -33,6 +33,10 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"toplev.h\"\n #include \"flags.h\"\n \n+#ifndef OBJECT_SUFFIX\n+# define OBJECT_SUFFIX \".o\"\n+#endif\n+\n /* Table indexed by tree code giving a string containing a character\n    classifying the tree code.  Possibilities are\n    t, d, s, c, r, <, 1 and 2.  See java/java-tree.def for details.  */\n@@ -179,6 +183,26 @@ lang_decode_option (argc, argv)\n       return 1;\n     }\n \n+#define CLARG \"-fclasspath=\"\n+  if (strncmp (p, CLARG, sizeof (CLARG) - 1) == 0)\n+    {\n+      jcf_path_classpath_arg (p + sizeof (CLARG));\n+      return 1;\n+    }\n+#undef CLARG\n+#define CLARG \"-fCLASSPATH=\"\n+  else if (strncmp (p, CLARG, sizeof (CLARG) - 1) == 0)\n+    {\n+      jcf_path_CLASSPATH_arg (p + sizeof (CLARG));\n+      return 1;\n+    }\n+#undef CLARG\n+  else if (strncmp (p, \"-I\", 2) == 0)\n+    {\n+      jcf_path_include_arg (p + 2);\n+      return 1;\n+    }\n+\n   return 0;\n }\n \n@@ -207,7 +231,8 @@ init_parse (filename)\n \t    error (\"couldn't determine target name for dependency tracking\");\n \t  else\n \t    {\n-\t      char *buf = (char *) xmalloc (dot - filename + 3);\n+\t      char *buf = (char *) xmalloc (dot - filename +\n+\t\t\t\t\t    3 + sizeof (OBJECT_SUFFIX));\n \t      strncpy (buf, filename, dot - filename);\n \n \t      /* If emitting class files, we might have multiple\n@@ -218,7 +243,7 @@ init_parse (filename)\n \t\tjcf_dependency_set_target (NULL);\n \t      else\n \t\t{\n-\t\t  strcpy (buf + (dot - filename), \".o\");\n+\t\t  strcpy (buf + (dot - filename), OBJECT_SUFFIX);\n \t\t  jcf_dependency_set_target (buf);\n \t\t}\n \n@@ -421,6 +446,9 @@ lang_init ()\n   flag_minimal_debug = 0;\n #endif\n \n+  jcf_path_init ();\n+  jcf_path_seal ();\n+\n   decl_printable_name = lang_printable_name;\n   print_error_function = lang_print_error;\n   lang_expand_expr = java_lang_expand_expr;"}, {"sha": "504c8414b31770541cfc8271145e1d6a624be39f", "filename": "gcc/java/lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -87,7 +87,6 @@ java_init_lex ()\n     ctxp->incomplete_class = NULL_TREE;\n   \n   bzero (ctxp->modifier_ctx, 11*sizeof (ctxp->modifier_ctx[0]));\n-  classpath = NULL;\n   bzero (current_jcf, sizeof (JCF));\n   ctxp->current_parsed_class = NULL;\n   ctxp->package = NULL_TREE;"}, {"sha": "b8dc5c2bebbe09af00320dfcfb0e2406c283bacc", "filename": "gcc/java/lex.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -31,7 +31,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n /* Extern global variables declarations  */\n extern FILE *finput;\n extern int   lineno;\n-extern char *classpath;\n \n /* A Unicode character, as read from the input file  */\n typedef unsigned short unicode_t;"}, {"sha": "0d0f964714de840f3bdb20f757b300cedc5d2c41", "filename": "gcc/java/parse.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -2068,7 +2068,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"bison.simple\"\n+#line 3 \"/x1/java-install/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2261,7 +2261,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"bison.simple\"\n+#line 196 \"/x1/java-install/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -4462,7 +4462,7 @@ case 492:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"bison.simple\"\n+#line 498 \"/x1/java-install/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -6928,8 +6928,6 @@ read_import_dir (wfl)\n   char *founddirname, *d_name;\n \n   jcf = &jcfr;\n-  if (!classpath)\n-    fix_classpath ();\n   if (!(founddirname = find_class (name, name_len, jcf, 0)))\n     fatal (\"Can't import `%s'\", name);\n   if (jcf->outofsynch)"}, {"sha": "84de8f71b9496768ce4084edfc4c9f9fa3f2c3e3", "filename": "gcc/java/parse.y", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8603f9c5b022356e3993539be8c70358d935c710/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=8603f9c5b022356e3993539be8c70358d935c710", "patch": "@@ -4322,8 +4322,6 @@ read_import_dir (wfl)\n   char *founddirname, *d_name;\n \n   jcf = &jcfr;\n-  if (!classpath)\n-    fix_classpath ();\n   if (!(founddirname = find_class (name, name_len, jcf, 0)))\n     fatal (\"Can't import `%s'\", name);\n   if (jcf->outofsynch)"}]}