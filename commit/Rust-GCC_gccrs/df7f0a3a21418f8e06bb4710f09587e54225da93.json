{"sha": "df7f0a3a21418f8e06bb4710f09587e54225da93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3ZjBhM2EyMTQxOGY4ZTA2YmI0NzEwZjA5NTg3ZTU0MjI1ZGE5Mw==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2020-07-28T02:29:49Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2020-10-22T08:02:44Z"}, "message": "RISC-V: Extend syntax for the multilib-generator\n\n - Support expansion operator (*) in the multilib config string.\n\n - Motivation of this patch is reduce the complexity when we deal multilib with\n   sub-extension, expand the combinations by hand would be very painful and\n   error prone, no one deserve to experience this[1] again!\n\n[1] https://github.com/sifive/freedom-tools/blob/f4d7facafb27d16125768c90ff1790c674e4be7a/Makefile#L348\n\ngcc/ChangeLog:\n\n\t* config/riscv/multilib-generator: Add TODO, import itertools\n\tand functools.reduce.\n\tHandle expantion operator.\n\t(LONG_EXT_PREFIXES): New.\n\t(arch_canonicalize): Update comment and improve python3\n\tdebuggability/compatibility.\n\t(add_underline_prefix): New.\n\t(_expand_combination): Ditto.\n\t(unique): Ditto.\n\t(expand_combination): Ditto.", "tree": {"sha": "8f0db46a2182ae8910b08af6cd8a5b4d70ad56cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f0db46a2182ae8910b08af6cd8a5b4d70ad56cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df7f0a3a21418f8e06bb4710f09587e54225da93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7f0a3a21418f8e06bb4710f09587e54225da93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df7f0a3a21418f8e06bb4710f09587e54225da93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df7f0a3a21418f8e06bb4710f09587e54225da93/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef2d3ec325b1b720df5da20784eba46249af2294", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef2d3ec325b1b720df5da20784eba46249af2294", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef2d3ec325b1b720df5da20784eba46249af2294"}], "stats": {"total": 109, "additions": 102, "deletions": 7}, "files": [{"sha": "57ee7c3a2eb4cb489ccc85cfec28845a1a5765ae", "filename": "gcc/config/riscv/multilib-generator", "status": "modified", "additions": 102, "deletions": 7, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df7f0a3a21418f8e06bb4710f09587e54225da93/gcc%2Fconfig%2Friscv%2Fmultilib-generator", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df7f0a3a21418f8e06bb4710f09587e54225da93/gcc%2Fconfig%2Friscv%2Fmultilib-generator", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fmultilib-generator?ref=df7f0a3a21418f8e06bb4710f09587e54225da93", "patch": "@@ -22,21 +22,34 @@\n \n # Each argument to this script is of the form\n #  <primary arch>-<abi>-<additional arches>-<extensions>\n-# For example,\n+# Example 1:\n #  rv32imafd-ilp32d-rv32g-c,v\n # means that, in addition to rv32imafd, these configurations can also use the\n # rv32imafd-ilp32d libraries: rv32imafdc, rv32imafdv, rv32g, rv32gc, rv32gv\n+#\n+# Example 2:\n+#  rv32imafd-ilp32d--c*b\n+# means that, in addition to rv32imafd, these configurations can also use the\n+# rv32imafd-ilp32d libraries: rv32imafdc-ilp32d, rv32imafdb-ilp32d,\n+#                             rv32imafdcb-ilp32d\n \n from __future__ import print_function\n import sys\n import collections\n+import itertools\n+from functools import reduce\n+\n+#\n+# TODO: Add test for this script.\n+#\n \n arches = collections.OrderedDict()\n abis = collections.OrderedDict()\n required = []\n reuse = []\n \n canonical_order = \"mafdgqlcbjtpvn\"\n+LONG_EXT_PREFIXES = ['z', 's', 'h', 'x']\n \n #\n # IMPLIED_EXT(ext) -> implied extension list.\n@@ -49,14 +62,13 @@ def arch_canonicalize(arch):\n   # TODO: Support extension version.\n   new_arch = \"\"\n   if arch[:5] in ['rv32e', 'rv32i', 'rv32g', 'rv64i', 'rv64g']:\n-    # TODO: We should expand g to imadzifencei once we support newer spec.\n+    # TODO: We should expand g to imad_zifencei once we support newer spec.\n     new_arch = arch[:5].replace(\"g\", \"imafd\")\n   else:\n     raise Exception(\"Unexpected arch: `%s`\" % arch[:5])\n \n   # Find any Z, S, H or X\n-  long_ext_prefixes = ['z', 's', 'h', 'x']\n-  long_ext_prefixes_idx = map(lambda x: arch.find(x), long_ext_prefixes)\n+  long_ext_prefixes_idx = map(lambda x: arch.find(x), LONG_EXT_PREFIXES)\n \n   # Filter out any non-existent index.\n   long_ext_prefixes_idx = list(filter(lambda x: x != -1, long_ext_prefixes_idx))\n@@ -83,7 +95,7 @@ def arch_canonicalize(arch):\n   std_exts += list(filter(lambda x:len(x) == 1, long_exts))\n \n   # Multi-letter extension must be in lexicographic order.\n-  long_exts = sorted(filter(lambda x:len(x) != 1, long_exts))\n+  long_exts = list(sorted(filter(lambda x:len(x) != 1, long_exts)))\n \n   # Put extensions in canonical order.\n   for ext in canonical_order:\n@@ -102,15 +114,98 @@ def arch_canonicalize(arch):\n     new_arch += \"_\" + \"_\".join(long_exts)\n   return new_arch\n \n+#\n+# add underline for each multi-char extensions.\n+# e.g. [\"a\", \"zfh\"] -> [\"a\", \"_zfh\"]\n+#\n+def add_underline_prefix(ext):\n+  for long_ext_prefix in LONG_EXT_PREFIXES:\n+    if ext.startswith(long_ext_prefix):\n+      return \"_\" + ext\n+\n+  return ext\n+\n+#\n+# Handle expansion operation.\n+#\n+# e.g. \"a*b\" -> [(\"a\",), (\"b\",), (\"a\", \"b\")]\n+#      \"a\"   -> [(\"a\",)]\n+#\n+def _expand_combination(ext):\n+  exts = list(ext.split(\"*\"))\n+\n+  # No need to expand if there is no `*`.\n+  if len(exts) == 1:\n+    return [(exts[0],)]\n+\n+  # Add underline to every extension.\n+  # e.g.\n+  #  _b * zvamo => _b * _zvamo\n+  exts = list(map(lambda x: '_' + x, exts))\n+\n+  # Generate combination!\n+  ext_combs = []\n+  for comb_len in range(1, len(exts)+1):\n+    for ext_comb in itertools.combinations(exts, comb_len):\n+      ext_combs.append(ext_comb)\n+\n+  return ext_combs\n+\n+#\n+# Input a list and drop duplicated entry.\n+# e.g.\n+#   [\"a\", \"b\", \"ab\", \"a\"] -> [\"a\", \"b\", \"ab\"]\n+#\n+def unique(x):\n+  #\n+  # Drop duplicated entry.\n+  # Convert list to set and then convert back to list.\n+  #\n+  # Add sorted to prevent non-deterministic results in different env.\n+  #\n+  return list(sorted(list(set(x))))\n+\n+#\n+# Expand EXT string if there is any expansion operator (*).\n+# e.g.\n+#   \"a*b,c\" -> [\"a\", \"b\", \"ab\", \"c\"]\n+#\n+def expand_combination(ext):\n+  ext = list(filter(None, ext.split(',')))\n+\n+  # Expand combination for EXT, got lots of list.\n+  # e.g.\n+  #   a * b => [[(\"a\",), (\"b\",)], [(\"a\", \"b\")]]\n+  ext_combs = list(map(_expand_combination, ext))\n+\n+  # Then fold to single list.\n+  # e.g.\n+  #   [[(\"a\",), (\"b\",)], [(\"a\", \"b\")]] => [(\"a\",), (\"b\",), (\"a\", \"b\")]\n+  ext = list(reduce(lambda x, y: x + y, ext_combs, []))\n+\n+  # Fold the tuple to string.\n+  # e.g.\n+  #   [(\"a\",), (\"b\",), (\"a\", \"b\")] => [\"a\", \"b\", \"ab\"]\n+  ext = map(lambda e : reduce(lambda x, y: x + y, e), ext)\n+\n+  # Drop duplicated entry.\n+  ext = unique(ext)\n+\n+  return ext\n+\n for cfg in sys.argv[1:]:\n   (arch, abi, extra, ext) = cfg.split('-')\n   arch = arch_canonicalize (arch)\n   arches[arch] = 1\n   abis[abi] = 1\n   extra = list(filter(None, extra.split(',')))\n-  ext = list(filter(None, ext.split(',')))\n-  alts = sum([[x] + [x + \"_\" + y for y in ext] for x in [arch] + extra], [])\n+  ext_combs = expand_combination(ext)\n+  alts = sum([[x] + [x + y for y in ext_combs] for x in [arch] + extra], [])\n   alts = list(map(arch_canonicalize, alts))\n+\n+  # Drop duplicated entry.\n+  alts = unique(alts)\n+\n   for alt in alts[1:]:\n     arches[alt] = 1\n     reuse.append('march.%s/mabi.%s=march.%s/mabi.%s' % (arch, abi, alt, abi))"}]}