{"sha": "3ccd94107b2bf56d54d62cefe515fd37584b1b25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NjZDk0MTA3YjJiZjU2ZDU0ZDYyY2VmZTUxNWZkMzc1ODRiMWIyNQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-12-13T10:32:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:32:01Z"}, "message": "sem_ch9.adb (Analyze_Requeue): Add a local flag to capture whether a requeue statement is dispatching.\n\n2007-12-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch9.adb (Analyze_Requeue): Add a local flag to capture whether a\n\trequeue statement is dispatching. Do not emit an error when the name is\n\tnot an entry and the context is a dispatching select. Add code to\n\tperform subtype conformance between the formals of the current entry\n\tand those of the target interface primitive.\n\t(Analyze_Asynchronous_Select, Analyze_Conditional_Entry_Call, Analyze_\n\tTimed_Entry_Call): Analyze the triggering statement as the first step of\n\tthe processing. If this is a dispatching select, postpone the analysis\n\tof all select statements until the Expander transforms the select. This\n\tapproach avoids generating duplicate identifiers after the Expander has\n\treplicated some of the select statements. In case the Expander is\n\tdisabled, perform regular analysis.\n\t(Check_Triggering_Statement): New routine.\n\t(Analyze_Requeue): Exclude any interpretations that are not entries when\n\tchecking overloaded names in a requeue. Also test type conformance for\n\tmatching interpretations rather than requiring subtype conformance at\n\tthat point to conform with the RM's resolution rule for requeues.\n\nFrom-SVN: r130855", "tree": {"sha": "9fc1b655ad4e6c49cac646cfcea848eb453c8ea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fc1b655ad4e6c49cac646cfcea848eb453c8ea8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ccd94107b2bf56d54d62cefe515fd37584b1b25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccd94107b2bf56d54d62cefe515fd37584b1b25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccd94107b2bf56d54d62cefe515fd37584b1b25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccd94107b2bf56d54d62cefe515fd37584b1b25/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "294ccb21c4d993c4fd9f4220e0ee8513a1666894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294ccb21c4d993c4fd9f4220e0ee8513a1666894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/294ccb21c4d993c4fd9f4220e0ee8513a1666894"}], "stats": {"total": 285, "additions": 216, "deletions": 69}, "files": [{"sha": "ec4ce80bff1469ffc00254ddeccf7f95e667bf91", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 216, "deletions": 69, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ccd94107b2bf56d54d62cefe515fd37584b1b25/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ccd94107b2bf56d54d62cefe515fd37584b1b25/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=3ccd94107b2bf56d54d62cefe515fd37584b1b25", "patch": "@@ -73,6 +73,15 @@ package body Sem_Ch9 is\n    --  N is an N_Protected_Type_Declaration or N_Task_Type_Declaration node.\n    --  Complete decoration of T and check legality of the covered interfaces.\n \n+   procedure Check_Triggering_Statement\n+     (Trigger        : Node_Id;\n+      Error_Node     : Node_Id;\n+      Is_Dispatching : out Boolean);\n+   --  Examine the triggering statement of a select statement, conditional or\n+   --  timed entry call. If Trigger is a dispatching call, return its status\n+   --  in Is_Dispatching and check whether the primitive belongs to a limited\n+   --  interface. If it does not, emit an error at Error_Node.\n+\n    function Find_Concurrent_Spec (Body_Id : Entity_Id) return Entity_Id;\n    --  Find entity in corresponding task or protected declaration. Use full\n    --  view if first declaration was for an incomplete type.\n@@ -166,6 +175,10 @@ package body Sem_Ch9 is\n       --  a new index type where a discriminant is replaced by the local\n       --  variable that renames it in the task body.\n \n+      -----------------------\n+      -- Actual_Index_Type --\n+      -----------------------\n+\n       function Actual_Index_Type (E : Entity_Id) return Entity_Id is\n          Typ   : constant Entity_Id := Entry_Index_Type (E);\n          Lo    : constant Node_Id   := Type_Low_Bound  (Typ);\n@@ -404,19 +417,20 @@ package body Sem_Ch9 is\n \n       --  Set Never_Set_In_Source and clear Is_True_Constant/Current_Value\n       --  fields on all entry formals (this loop ignores all other entities).\n-      --  Reset Referenced, Referenced_As_LHS and Has_Pragma_Unreferenced as\n+      --  Reset Referenced, Referenced_As_xxx and Has_Pragma_Unreferenced as\n       --  well, so that we can post accurate warnings on each accept statement\n       --  for the same entry.\n \n       E := First_Entity (Entry_Nam);\n       while Present (E) loop\n          if Is_Formal (E) then\n-            Set_Never_Set_In_Source     (E, True);\n-            Set_Is_True_Constant        (E, False);\n-            Set_Current_Value           (E, Empty);\n-            Set_Referenced              (E, False);\n-            Set_Referenced_As_LHS       (E, False);\n-            Set_Has_Pragma_Unreferenced (E, False);\n+            Set_Never_Set_In_Source         (E, True);\n+            Set_Is_True_Constant            (E, False);\n+            Set_Current_Value               (E, Empty);\n+            Set_Referenced                  (E, False);\n+            Set_Referenced_As_LHS           (E, False);\n+            Set_Referenced_As_Out_Parameter (E, False);\n+            Set_Has_Pragma_Unreferenced     (E, False);\n          end if;\n \n          Next_Entity (E);\n@@ -447,8 +461,8 @@ package body Sem_Ch9 is\n    ---------------------------------\n \n    procedure Analyze_Asynchronous_Select (N : Node_Id) is\n-      Param   : Node_Id;\n-      Trigger : Node_Id;\n+      Is_Disp_Select : Boolean := False;\n+      Trigger        : Node_Id;\n \n    begin\n       Tasking_Used := True;\n@@ -460,61 +474,76 @@ package body Sem_Ch9 is\n \n          Analyze (Trigger);\n \n-         --  The trigger is a dispatching procedure. Postpone the analysis of\n-         --  the triggering and abortable statements until the expansion of\n-         --  this asynchronous select in Expand_N_Asynchronous_Select. This\n-         --  action is required since otherwise we would get a gigi abort from\n-         --  the code replication in Expand_N_Asynchronous_Select of an already\n-         --  analyzed statement list.\n+         --  Ada 2005 (AI-345): Check for a potential dispatching select\n \n-         if Expander_Active\n-           and then Nkind (Trigger) = N_Procedure_Call_Statement\n-           and then Present (Parameter_Associations (Trigger))\n-         then\n-            Param := First (Parameter_Associations (Trigger));\n+         Check_Triggering_Statement (Trigger, N, Is_Disp_Select);\n+      end if;\n \n-            if Is_Controlling_Actual (Param)\n-              and then Is_Interface (Etype (Param))\n-            then\n-               if Is_Limited_Record (Etype (Param)) then\n-                  return;\n-               else\n-                  Error_Msg_N\n-                   (\"dispatching operation of limited or synchronized \" &\n-                    \"interface required (RM 9.7.2(3))!\", N);\n-               end if;\n-            end if;\n+      --  Ada 2005 (AI-345): The expansion of the dispatching asynchronous\n+      --  select will have to duplicate the triggering statements. Postpone\n+      --  the analysis of the statements till expansion. Analyze only if the\n+      --  expander is disabled in order to catch any semantic errors.\n+\n+      if Is_Disp_Select then\n+         if not Expander_Active then\n+            Analyze_Statements (Statements (Abortable_Part (N)));\n+            Analyze (Triggering_Alternative (N));\n          end if;\n-      end if;\n \n       --  Analyze the statements. We analyze statements in the abortable part,\n       --  because this is the section that is executed first, and that way our\n       --  remembering of saved values and checks is accurate.\n \n-      Analyze_Statements (Statements (Abortable_Part (N)));\n-      Analyze (Triggering_Alternative (N));\n+      else\n+         Analyze_Statements (Statements (Abortable_Part (N)));\n+         Analyze (Triggering_Alternative (N));\n+      end if;\n    end Analyze_Asynchronous_Select;\n \n    ------------------------------------\n    -- Analyze_Conditional_Entry_Call --\n    ------------------------------------\n \n    procedure Analyze_Conditional_Entry_Call (N : Node_Id) is\n+      Trigger        : constant Node_Id :=\n+                         Entry_Call_Statement (Entry_Call_Alternative (N));\n+      Is_Disp_Select : Boolean := False;\n+\n    begin\n       Check_Restriction (No_Select_Statements, N);\n       Tasking_Used := True;\n-      Analyze (Entry_Call_Alternative (N));\n+\n+      --  Ada 2005 (AI-345): The trigger may be a dispatching call\n+\n+      if Ada_Version >= Ada_05 then\n+         Analyze (Trigger);\n+         Check_Triggering_Statement (Trigger, N, Is_Disp_Select);\n+      end if;\n \n       if List_Length (Else_Statements (N)) = 1\n         and then Nkind (First (Else_Statements (N))) in N_Delay_Statement\n       then\n          Error_Msg_N\n-           (\"suspicious form of conditional entry call?\", N);\n+           (\"suspicious form of conditional entry call?!\", N);\n          Error_Msg_N\n-           (\"\\`SELECT OR` may be intended rather than `SELECT ELSE`\", N);\n+           (\"\\`SELECT OR` may be intended rather than `SELECT ELSE`!\", N);\n       end if;\n \n-      Analyze_Statements (Else_Statements (N));\n+      --  Postpone the analysis of the statements till expansion. Analyze only\n+      --  if the expander is disabled in order to catch any semantic errors.\n+\n+      if Is_Disp_Select then\n+         if not Expander_Active then\n+            Analyze (Entry_Call_Alternative (N));\n+            Analyze_Statements (Else_Statements (N));\n+         end if;\n+\n+      --  Regular select analysis\n+\n+      else\n+         Analyze (Entry_Call_Alternative (N));\n+         Analyze_Statements (Else_Statements (N));\n+      end if;\n    end Analyze_Conditional_Entry_Call;\n \n    --------------------------------\n@@ -533,9 +562,7 @@ package body Sem_Ch9 is\n          Analyze_List (Pragmas_Before (N));\n       end if;\n \n-      if Nkind (Parent (N)) = N_Selective_Accept\n-        or else Nkind (Parent (N)) = N_Timed_Entry_Call\n-      then\n+      if Nkind_In (Parent (N), N_Selective_Accept, N_Timed_Entry_Call) then\n          Expr := Expression (Delay_Statement (N));\n \n          --  Defer full analysis until the statement is expanded, to insure\n@@ -791,8 +818,7 @@ package body Sem_Ch9 is\n             end loop;\n \n             --  If no matching body entity, then we already had a detected\n-            --  error of some kind, so just forget about worrying about these\n-            --  warnings.\n+            --  error of some kind, so just don't worry about these warnings.\n \n             if No (E2) then\n                goto Continue;\n@@ -994,9 +1020,9 @@ package body Sem_Ch9 is\n \n       Ref_Id : Entity_Id;\n       --  This is the entity of the protected object or protected type\n-      --  involved, and is the entity used for cross-reference purposes\n-      --  (it differs from Spec_Id in the case of a single protected\n-      --  object, since Spec_Id is set to the protected type in this case).\n+      --  involved, and is the entity used for cross-reference purposes (it\n+      --  differs from Spec_Id in the case of a single protected object, since\n+      --  Spec_Id is set to the protected type in this case).\n \n    begin\n       Tasking_Used := True;\n@@ -1156,9 +1182,8 @@ package body Sem_Ch9 is\n \n       Set_Is_Constrained (T, not Has_Discriminants (T));\n \n-      --  Perform minimal expansion of the protected type while inside of a\n-      --  generic. The corresponding record is needed for various semantic\n-      --  checks.\n+      --  Perform minimal expansion of protected type while inside a generic.\n+      --  The corresponding record is needed for various semantic checks.\n \n       if Ada_Version >= Ada_05\n         and then Inside_A_Generic\n@@ -1231,15 +1256,16 @@ package body Sem_Ch9 is\n    ---------------------\n \n    procedure Analyze_Requeue (N : Node_Id) is\n-      Count      : Natural := 0;\n-      Entry_Name : Node_Id := Name (N);\n-      Entry_Id   : Entity_Id;\n-      I          : Interp_Index;\n-      It         : Interp;\n-      Enclosing  : Entity_Id;\n-      Target_Obj : Node_Id := Empty;\n-      Req_Scope  : Entity_Id;\n-      Outer_Ent  : Entity_Id;\n+      Count       : Natural := 0;\n+      Entry_Name  : Node_Id := Name (N);\n+      Entry_Id    : Entity_Id;\n+      I           : Interp_Index;\n+      Is_Disp_Req : Boolean;\n+      It          : Interp;\n+      Enclosing   : Entity_Id;\n+      Target_Obj  : Node_Id := Empty;\n+      Req_Scope   : Entity_Id;\n+      Outer_Ent   : Entity_Id;\n \n    begin\n       Check_Restriction (No_Requeue_Statements, N);\n@@ -1313,10 +1339,20 @@ package body Sem_Ch9 is\n       if Is_Overloaded (Entry_Name) then\n          Entry_Id := Empty;\n \n+         --  Loop over candidate interpretations and filter out any that are\n+         --  not parameterless, are not type conformant, are not entries, or\n+         --  do not come from source.\n+\n          Get_First_Interp (Entry_Name, I, It);\n          while Present (It.Nam) loop\n-            if No (First_Formal (It.Nam))\n-              or else Subtype_Conformant (Enclosing, It.Nam)\n+\n+            --  Note: we test type conformance here, not subtype conformance.\n+            --  Subtype conformance will be tested later on, but it is better\n+            --  for error output in some cases not to do that here.\n+\n+            if (No (First_Formal (It.Nam))\n+                 or else (Type_Conformant (Enclosing, It.Nam)))\n+              and then Ekind (It.Nam) = E_Entry\n             then\n                --  Ada 2005 (AI-345): Since protected and task types have\n                --  primitive entry wrappers, we only consider source entries.\n@@ -1384,11 +1420,28 @@ package body Sem_Ch9 is\n          Entry_Id := Entity (Entry_Name);\n       end if;\n \n+      --  Ada 2005 (AI05-0030): Potential dispatching requeue statement. The\n+      --  target type must be a concurrent interface class-wide type and the\n+      --  entry name must be a procedure, flagged by pragma Implemented_By_\n+      --  Entry.\n+\n+      Is_Disp_Req :=\n+        Ada_Version >= Ada_05\n+          and then Present (Target_Obj)\n+          and then Is_Class_Wide_Type (Etype (Target_Obj))\n+          and then Is_Concurrent_Interface (Etype (Target_Obj))\n+          and then Ekind (Entry_Id) = E_Procedure\n+          and then Implemented_By_Entry (Entry_Id);\n+\n       --  Resolve entry, and check that it is subtype conformant with the\n       --  enclosing construct if this construct has formals (RM 9.5.4(5)).\n+      --  Ada 2005 (AI05-0030): Do not emit an error for this specific case.\n \n-      if not Is_Entry (Entry_Id) then\n+      if not Is_Entry (Entry_Id)\n+        and then not Is_Disp_Req\n+      then\n          Error_Msg_N (\"expect entry name in requeue statement\", Name (N));\n+\n       elsif Ekind (Entry_Id) = E_Entry_Family\n         and then Nkind (Entry_Name) /= N_Indexed_Component\n       then\n@@ -1406,7 +1459,39 @@ package body Sem_Ch9 is\n                return;\n             end if;\n \n-            Check_Subtype_Conformant (Enclosing, Entry_Id, Name (N));\n+            --  Ada 2005 (AI05-0030): Perform type conformance after skipping\n+            --  the first parameter of Entry_Id since it is the interface\n+            --  controlling formal.\n+\n+            if Is_Disp_Req then\n+               declare\n+                  Enclosing_Formal : Entity_Id;\n+                  Target_Formal    : Entity_Id;\n+\n+               begin\n+                  Enclosing_Formal := First_Formal (Enclosing);\n+                  Target_Formal := Next_Formal (First_Formal (Entry_Id));\n+                  while Present (Enclosing_Formal)\n+                    and then Present (Target_Formal)\n+                  loop\n+                     if not Conforming_Types\n+                              (T1    => Etype (Enclosing_Formal),\n+                               T2    => Etype (Target_Formal),\n+                               Ctype => Subtype_Conformant)\n+                     then\n+                        Error_Msg_Node_2 := Target_Formal;\n+                        Error_Msg_NE\n+                          (\"formal & is not subtype conformant with &\" &\n+                           \"in dispatching requeue\", N, Enclosing_Formal);\n+                     end if;\n+\n+                     Next_Formal (Enclosing_Formal);\n+                     Next_Formal (Target_Formal);\n+                  end loop;\n+               end;\n+            else\n+               Check_Subtype_Conformant (Enclosing, Entry_Id, Name (N));\n+            end if;\n \n             --  Processing for parameters accessed by the requeue\n \n@@ -1887,7 +1972,7 @@ package body Sem_Ch9 is\n          if Has_Discriminants (T) then\n \n             --  Install discriminants. Also, verify conformance of\n-            --  discriminants of previous and current view.  ???\n+            --  discriminants of previous and current view. ???\n \n             Install_Declarations (T);\n          else\n@@ -1965,11 +2050,36 @@ package body Sem_Ch9 is\n    ------------------------------\n \n    procedure Analyze_Timed_Entry_Call (N : Node_Id) is\n+      Trigger        : constant Node_Id :=\n+                         Entry_Call_Statement (Entry_Call_Alternative (N));\n+      Is_Disp_Select : Boolean := False;\n+\n    begin\n       Check_Restriction (No_Select_Statements, N);\n       Tasking_Used := True;\n-      Analyze (Entry_Call_Alternative (N));\n-      Analyze (Delay_Alternative (N));\n+\n+      --  Ada 2005 (AI-345): The trigger may be a dispatching call\n+\n+      if Ada_Version >= Ada_05 then\n+         Analyze (Trigger);\n+         Check_Triggering_Statement (Trigger, N, Is_Disp_Select);\n+      end if;\n+\n+      --  Postpone the analysis of the statements till expansion. Analyze only\n+      --  if the expander is disabled in order to catch any semantic errors.\n+\n+      if Is_Disp_Select then\n+         if not Expander_Active then\n+            Analyze (Entry_Call_Alternative (N));\n+            Analyze (Delay_Alternative (N));\n+         end if;\n+\n+      --  Regular select analysis\n+\n+      else\n+         Analyze (Entry_Call_Alternative (N));\n+         Analyze (Delay_Alternative (N));\n+      end if;\n    end Analyze_Timed_Entry_Call;\n \n    ------------------------------------\n@@ -2113,8 +2223,8 @@ package body Sem_Ch9 is\n       Iface_Typ : Entity_Id;\n \n    begin\n-      pragma Assert (Nkind (N) = N_Protected_Type_Declaration\n-        or else Nkind (N) = N_Task_Type_Declaration);\n+      pragma Assert\n+        (Nkind_In (N, N_Protected_Type_Declaration, N_Task_Type_Declaration));\n \n       if Present (Interface_List (N)) then\n          Set_Is_Tagged_Type (T);\n@@ -2221,14 +2331,14 @@ package body Sem_Ch9 is\n             then\n                Error_Msg_N\n                  (\"(Ada 2005) full view must be a synchronized tagged \" &\n-                  \"type ('R'M 7.3 (7.2/2))\", Priv_T);\n+                  \"type (RM 7.3 (7.2/2))\", Priv_T);\n \n             elsif Is_Synchronized_Tagged_Type (T)\n               and then not Is_Synchronized_Tagged_Type (Priv_T)\n             then\n                Error_Msg_N\n                  (\"(Ada 2005) partial view must be a synchronized tagged \" &\n-                  \"type ('R'M 7.3 (7.2/2))\", T);\n+                  \"type (RM 7.3 (7.2/2))\", T);\n             end if;\n \n             --  RM 7.3 (7.3/2): The partial view shall be a descendant of an\n@@ -2267,6 +2377,43 @@ package body Sem_Ch9 is\n       end;\n    end Check_Interfaces;\n \n+   --------------------------------\n+   -- Check_Triggering_Statement --\n+   --------------------------------\n+\n+   procedure Check_Triggering_Statement\n+     (Trigger        : Node_Id;\n+      Error_Node     : Node_Id;\n+      Is_Dispatching : out Boolean)\n+   is\n+      Param : Node_Id;\n+\n+   begin\n+      Is_Dispatching := False;\n+\n+      --  It is not possible to have a dispatching trigger if we are not in\n+      --  Ada 2005 mode.\n+\n+      if Ada_Version >= Ada_05\n+        and then Nkind (Trigger) = N_Procedure_Call_Statement\n+        and then Present (Parameter_Associations (Trigger))\n+      then\n+         Param := First (Parameter_Associations (Trigger));\n+\n+         if Is_Controlling_Actual (Param)\n+           and then Is_Interface (Etype (Param))\n+         then\n+            if Is_Limited_Record (Etype (Param)) then\n+               Is_Dispatching := True;\n+            else\n+               Error_Msg_N\n+                 (\"dispatching operation of limited or synchronized \" &\n+                  \"interface required (RM 9.7.2(3))!\", Error_Node);\n+            end if;\n+         end if;\n+      end if;\n+   end Check_Triggering_Statement;\n+\n    --------------------------\n    -- Find_Concurrent_Spec --\n    --------------------------"}]}