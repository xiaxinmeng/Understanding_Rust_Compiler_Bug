{"sha": "e94710443aa0359d24db682ba8d856776c3dfa1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk0NzEwNDQzYWEwMzU5ZDI0ZGI2ODJiYThkODU2Nzc2YzNkZmExZg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-03-15T15:12:01Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2014-03-15T15:12:01Z"}, "message": "re PR fortran/58324 (Bogus END-of-line error with list-directed I/O of file without trailing sequential record marker)\n\n2014-03-15  Jerry DeLisle  <jvdelisle@gcc.gnu>\n\n\tPR libfortran/58324\n\t* io/list_read.c (finish_list_read): Read one character to check\n\tfor the end of the file.  If it is the end, then issue the file\n\tend error message.  If not, use eat_line to reach the end\n\twithout giving error.  The next attempt to read will then\n\tissue the error as described above.\n\nFrom-SVN: r208591", "tree": {"sha": "22ddb258738eb39ae5fa42da1db96e18c023eef8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22ddb258738eb39ae5fa42da1db96e18c023eef8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e94710443aa0359d24db682ba8d856776c3dfa1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e94710443aa0359d24db682ba8d856776c3dfa1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e94710443aa0359d24db682ba8d856776c3dfa1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e94710443aa0359d24db682ba8d856776c3dfa1f/comments", "author": null, "committer": null, "parents": [{"sha": "68a230443864dcefe9e368997d65e1d1777d6fc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68a230443864dcefe9e368997d65e1d1777d6fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68a230443864dcefe9e368997d65e1d1777d6fc8"}], "stats": {"total": 24, "additions": 19, "deletions": 5}, "files": [{"sha": "358a31cbe5ac346ae9b60cbb87dd185198c71c04", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e94710443aa0359d24db682ba8d856776c3dfa1f/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e94710443aa0359d24db682ba8d856776c3dfa1f/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=e94710443aa0359d24db682ba8d856776c3dfa1f", "patch": "@@ -1,3 +1,12 @@\n+2014-03-15  Jerry DeLisle  <jvdelisle@gcc.gnu>\n+\n+\tPR libfortran/58324\n+\t* io/list_read.c (finish_list_read): Read one character to check\n+\tfor the end of the file.  If it is the end, then issue the file\n+\tend error message.  If not, use eat_line to reach the end\n+\twithout giving error.  The next attempt to read will then\n+\tissue the error as described above.\n+\n 2014-03-12  Jerry DeLisle  <jvdelisle@gcc.gnu>\n \n \tPR libfortran/38199\n@@ -10,7 +19,7 @@\n \tformatted READ.\n \t* io/list_read.c (finish_list_read): Don't call eat_line for\n \tinternal units.\n-\t \n+\n 2014-03-08  Jerry DeLisle  <jvdelisle@gcc.gnu>\n \n \tPR libfortran/38199"}, {"sha": "caeb41b078275f6aa1203ac30384e86a081a78b1", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e94710443aa0359d24db682ba8d856776c3dfa1f/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e94710443aa0359d24db682ba8d856776c3dfa1f/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=e94710443aa0359d24db682ba8d856776c3dfa1f", "patch": "@@ -2092,8 +2092,6 @@ list_formatted_read (st_parameter_dt *dtp, bt type, void *p, int kind,\n void\n finish_list_read (st_parameter_dt *dtp)\n {\n-  int err;\n-\n   free_saved (dtp);\n \n   fbuf_flush (dtp->u.p.current_unit, dtp->u.p.mode);\n@@ -2106,13 +2104,20 @@ finish_list_read (st_parameter_dt *dtp)\n \n   if (!is_internal_unit (dtp))\n     {\n-      err = eat_line (dtp);\n-      if (err == LIBERROR_END)\n+      int c;\n+      c = next_char (dtp);\n+      if (c == EOF)\n \t{\n \t  free_line (dtp);\n \t  hit_eof (dtp);\n+\t  return;\n \t}\n+      if (c != '\\n')\n+\teat_line (dtp);\n     }\n+\n+  free_line (dtp);\n+\n }\n \n /*\t\t\tNAMELIST INPUT"}]}