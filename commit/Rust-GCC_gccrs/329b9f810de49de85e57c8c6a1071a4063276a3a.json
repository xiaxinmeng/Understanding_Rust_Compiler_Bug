{"sha": "329b9f810de49de85e57c8c6a1071a4063276a3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI5YjlmODEwZGU0OWRlODVlNTdjOGM2YTEwNzFhNDA2MzI3NmEzYQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T12:53:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T12:53:09Z"}, "message": "[multiple changes]\n\n2010-10-26  Bob Duff  <duff@adacore.com>\n\n\t* namet.adb: Improve hash function.\n\tIncrease the size from 2**12 to 2**16 buckets.\n\n2010-10-26  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_disp.adb: Minor reformatting.\n\nFrom-SVN: r165954", "tree": {"sha": "d0065243617f78b721d953e9c759ab00a551134f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0065243617f78b721d953e9c759ab00a551134f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/329b9f810de49de85e57c8c6a1071a4063276a3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/329b9f810de49de85e57c8c6a1071a4063276a3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/329b9f810de49de85e57c8c6a1071a4063276a3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/329b9f810de49de85e57c8c6a1071a4063276a3a/comments", "author": null, "committer": null, "parents": [{"sha": "878f708abab2dbb86733df58e80a34c10b5d885b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878f708abab2dbb86733df58e80a34c10b5d885b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878f708abab2dbb86733df58e80a34c10b5d885b"}], "stats": {"total": 203, "additions": 43, "deletions": 160}, "files": [{"sha": "cae15291b245ccaa3554cdddb79624145d5ff183", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/329b9f810de49de85e57c8c6a1071a4063276a3a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/329b9f810de49de85e57c8c6a1071a4063276a3a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=329b9f810de49de85e57c8c6a1071a4063276a3a", "patch": "@@ -1,3 +1,11 @@\n+2010-10-26  Bob Duff  <duff@adacore.com>\n+\n+\t* namet.adb: Improve hash function.\n+\n+2010-10-26  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_disp.adb: Minor reformatting.\n+\n 2010-10-26  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch3.adb, sem_ch4.adb, sem_disp.adb, switch-c.adb: Minor"}, {"sha": "63b7104501ec4867a5b4a33ec97182e2cc60fd3c", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 23, "deletions": 145, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/329b9f810de49de85e57c8c6a1071a4063276a3a/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/329b9f810de49de85e57c8c6a1071a4063276a3a/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=329b9f810de49de85e57c8c6a1071a4063276a3a", "patch": "@@ -39,6 +39,8 @@ with Output;   use Output;\n with Tree_IO;  use Tree_IO;\n with Widechar; use Widechar;\n \n+with Interfaces; use Interfaces;\n+\n package body Namet is\n \n    Name_Chars_Reserve   : constant := 5000;\n@@ -50,7 +52,7 @@ package body Namet is\n    --  reallocating during this second unlocked phase, we reserve a bit of\n    --  extra space before doing the release call.\n \n-   Hash_Num : constant Int := 2**12;\n+   Hash_Num : constant Int := 2**16;\n    --  Number of headers in the hash table. Current hash algorithm is closely\n    --  tailored to this choice, so it can only be changed if a corresponding\n    --  change is made to the hash algorithm.\n@@ -743,151 +745,27 @@ package body Namet is\n    ----------\n \n    function Hash return Hash_Index_Type is\n+\n+      --  This hash function looks at every character, in order to make it\n+      --  likely that similar strings get different hash values. The rotate by\n+      --  7 bits has been determined empirically to be good, and it doesn't\n+      --  lose bits like a shift would. The final conversion can't overflow,\n+      --  because the table is 2**16 in size. This function probably needs to\n+      --  be changed if the hash table size is changed.\n+\n+      --  Note that we could get some speed improvement by aligning the string\n+      --  to 32 or 64 bits, and doing word-wise xor's. We could also implement\n+      --  a growable table. It doesn't seem worth the trouble to do those\n+      --  things, for now.\n+\n+      Result : Unsigned_16 := 0;\n+\n    begin\n-      --  For the cases of 1-12 characters, all characters participate in the\n-      --  hash. The positioning is randomized, with the bias that characters\n-      --  later on participate fully (i.e. are added towards the right side).\n-\n-      case Name_Len is\n-\n-         when 0 =>\n-            return 0;\n-\n-         when 1 =>\n-            return\n-               Character'Pos (Name_Buffer (1));\n-\n-         when 2 =>\n-            return ((\n-              Character'Pos (Name_Buffer (1))) * 64 +\n-              Character'Pos (Name_Buffer (2))) mod Hash_Num;\n-\n-         when 3 =>\n-            return (((\n-              Character'Pos (Name_Buffer (1))) * 16 +\n-              Character'Pos (Name_Buffer (3))) * 16 +\n-              Character'Pos (Name_Buffer (2))) mod Hash_Num;\n-\n-         when 4 =>\n-            return ((((\n-              Character'Pos (Name_Buffer (1))) * 8 +\n-              Character'Pos (Name_Buffer (2))) * 8 +\n-              Character'Pos (Name_Buffer (3))) * 8 +\n-              Character'Pos (Name_Buffer (4))) mod Hash_Num;\n-\n-         when 5 =>\n-            return (((((\n-              Character'Pos (Name_Buffer (4))) * 8 +\n-              Character'Pos (Name_Buffer (1))) * 4 +\n-              Character'Pos (Name_Buffer (3))) * 4 +\n-              Character'Pos (Name_Buffer (5))) * 8 +\n-              Character'Pos (Name_Buffer (2))) mod Hash_Num;\n-\n-         when 6 =>\n-            return ((((((\n-              Character'Pos (Name_Buffer (5))) * 4 +\n-              Character'Pos (Name_Buffer (1))) * 4 +\n-              Character'Pos (Name_Buffer (4))) * 4 +\n-              Character'Pos (Name_Buffer (2))) * 4 +\n-              Character'Pos (Name_Buffer (6))) * 4 +\n-              Character'Pos (Name_Buffer (3))) mod Hash_Num;\n-\n-         when 7 =>\n-            return (((((((\n-              Character'Pos (Name_Buffer (4))) * 4 +\n-              Character'Pos (Name_Buffer (3))) * 4 +\n-              Character'Pos (Name_Buffer (1))) * 4 +\n-              Character'Pos (Name_Buffer (2))) * 2 +\n-              Character'Pos (Name_Buffer (5))) * 2 +\n-              Character'Pos (Name_Buffer (7))) * 2 +\n-              Character'Pos (Name_Buffer (6))) mod Hash_Num;\n-\n-         when 8 =>\n-            return ((((((((\n-              Character'Pos (Name_Buffer (2))) * 4 +\n-              Character'Pos (Name_Buffer (1))) * 4 +\n-              Character'Pos (Name_Buffer (3))) * 2 +\n-              Character'Pos (Name_Buffer (5))) * 2 +\n-              Character'Pos (Name_Buffer (7))) * 2 +\n-              Character'Pos (Name_Buffer (6))) * 2 +\n-              Character'Pos (Name_Buffer (4))) * 2 +\n-              Character'Pos (Name_Buffer (8))) mod Hash_Num;\n-\n-         when 9 =>\n-            return (((((((((\n-              Character'Pos (Name_Buffer (2))) * 4 +\n-              Character'Pos (Name_Buffer (1))) * 4 +\n-              Character'Pos (Name_Buffer (3))) * 4 +\n-              Character'Pos (Name_Buffer (4))) * 2 +\n-              Character'Pos (Name_Buffer (8))) * 2 +\n-              Character'Pos (Name_Buffer (7))) * 2 +\n-              Character'Pos (Name_Buffer (5))) * 2 +\n-              Character'Pos (Name_Buffer (6))) * 2 +\n-              Character'Pos (Name_Buffer (9))) mod Hash_Num;\n-\n-         when 10 =>\n-            return ((((((((((\n-              Character'Pos (Name_Buffer (01))) * 2 +\n-              Character'Pos (Name_Buffer (02))) * 2 +\n-              Character'Pos (Name_Buffer (08))) * 2 +\n-              Character'Pos (Name_Buffer (03))) * 2 +\n-              Character'Pos (Name_Buffer (04))) * 2 +\n-              Character'Pos (Name_Buffer (09))) * 2 +\n-              Character'Pos (Name_Buffer (06))) * 2 +\n-              Character'Pos (Name_Buffer (05))) * 2 +\n-              Character'Pos (Name_Buffer (07))) * 2 +\n-              Character'Pos (Name_Buffer (10))) mod Hash_Num;\n-\n-         when 11 =>\n-            return (((((((((((\n-              Character'Pos (Name_Buffer (05))) * 2 +\n-              Character'Pos (Name_Buffer (01))) * 2 +\n-              Character'Pos (Name_Buffer (06))) * 2 +\n-              Character'Pos (Name_Buffer (09))) * 2 +\n-              Character'Pos (Name_Buffer (07))) * 2 +\n-              Character'Pos (Name_Buffer (03))) * 2 +\n-              Character'Pos (Name_Buffer (08))) * 2 +\n-              Character'Pos (Name_Buffer (02))) * 2 +\n-              Character'Pos (Name_Buffer (10))) * 2 +\n-              Character'Pos (Name_Buffer (04))) * 2 +\n-              Character'Pos (Name_Buffer (11))) mod Hash_Num;\n-\n-         when 12 =>\n-            return ((((((((((((\n-              Character'Pos (Name_Buffer (03))) * 2 +\n-              Character'Pos (Name_Buffer (02))) * 2 +\n-              Character'Pos (Name_Buffer (05))) * 2 +\n-              Character'Pos (Name_Buffer (01))) * 2 +\n-              Character'Pos (Name_Buffer (06))) * 2 +\n-              Character'Pos (Name_Buffer (04))) * 2 +\n-              Character'Pos (Name_Buffer (08))) * 2 +\n-              Character'Pos (Name_Buffer (11))) * 2 +\n-              Character'Pos (Name_Buffer (07))) * 2 +\n-              Character'Pos (Name_Buffer (09))) * 2 +\n-              Character'Pos (Name_Buffer (10))) * 2 +\n-              Character'Pos (Name_Buffer (12))) mod Hash_Num;\n-\n-         --  Names longer than 12 characters are handled by taking the first\n-         --  6 odd numbered characters and the last 6 even numbered characters.\n-\n-         when others => declare\n-               Even_Name_Len : constant Integer := (Name_Len) / 2 * 2;\n-         begin\n-            return ((((((((((((\n-              Character'Pos (Name_Buffer (01))) * 2 +\n-              Character'Pos (Name_Buffer (Even_Name_Len - 10))) * 2 +\n-              Character'Pos (Name_Buffer (03))) * 2 +\n-              Character'Pos (Name_Buffer (Even_Name_Len - 08))) * 2 +\n-              Character'Pos (Name_Buffer (05))) * 2 +\n-              Character'Pos (Name_Buffer (Even_Name_Len - 06))) * 2 +\n-              Character'Pos (Name_Buffer (07))) * 2 +\n-              Character'Pos (Name_Buffer (Even_Name_Len - 04))) * 2 +\n-              Character'Pos (Name_Buffer (09))) * 2 +\n-              Character'Pos (Name_Buffer (Even_Name_Len - 02))) * 2 +\n-              Character'Pos (Name_Buffer (11))) * 2 +\n-              Character'Pos (Name_Buffer (Even_Name_Len))) mod Hash_Num;\n-         end;\n-      end case;\n+      for J in 1 .. Name_Len loop\n+         Result := Rotate_Left (Result, 7) xor Character'Pos (Name_Buffer (J));\n+      end loop;\n+\n+      return Hash_Index_Type (Result);\n    end Hash;\n \n    ----------------"}, {"sha": "25e4a6d3164d309b79f06e5cbfe0fb136afae847", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/329b9f810de49de85e57c8c6a1071a4063276a3a/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/329b9f810de49de85e57c8c6a1071a4063276a3a/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=329b9f810de49de85e57c8c6a1071a4063276a3a", "patch": "@@ -1686,7 +1686,7 @@ package body Sem_Disp is\n \n    begin\n       --  This Ada 2012 rule is valid only for type extensions or private\n-      --  extensions\n+      --  extensions.\n \n       if No (Tag_Typ)\n         or else not Is_Record_Type (Tag_Typ)\n@@ -1704,7 +1704,7 @@ package body Sem_Disp is\n          Prim := Node (Elmt);\n \n          --  Find an inherited hidden dispatching primitive with the name of S\n-         --  and a type-conformant profile\n+         --  and a type-conformant profile.\n \n          if Present (Alias (Prim))\n            and then Is_Hidden (Alias (Prim))\n@@ -1719,7 +1719,7 @@ package body Sem_Disp is\n             begin\n                --  The original corresponding operation of Prim must be an\n                --  operation of a visible ancestor of the dispatching type\n-               --  of S, and the original corresponding operation of S2 must\n+               --  S, and the original corresponding operation of S2 must\n                --  be visible.\n \n                Orig_Prim := Original_Corresponding_Operation (Prim);\n@@ -1728,15 +1728,13 @@ package body Sem_Disp is\n                  and then Is_Immediately_Visible (Orig_Prim)\n                then\n                   Vis_Ancestor := First_Elmt (Vis_List);\n-\n                   while Present (Vis_Ancestor) loop\n                      Elmt :=\n                        First_Elmt (Primitive_Operations (Node (Vis_Ancestor)));\n                      while Present (Elmt) loop\n                         if Node (Elmt) = Orig_Prim then\n                            Set_Overridden_Operation (S, Prim);\n                            Set_Alias (Prim, Orig_Prim);\n-\n                            return Prim;\n                         end if;\n \n@@ -1769,9 +1767,9 @@ package body Sem_Disp is\n    begin\n       pragma Assert (Is_Interface (Find_Dispatching_Type (Iface_Prim))\n         or else (Present (Alias (Iface_Prim))\n-                   and then\n-                     Is_Interface\n-                       (Find_Dispatching_Type (Ultimate_Alias (Iface_Prim)))));\n+                  and then\n+                    Is_Interface\n+                      (Find_Dispatching_Type (Ultimate_Alias (Iface_Prim)))));\n \n       --  Search in the homonym chain. Done to speed up locating visible\n       --  entities and required to catch primitives associated with the partial\n@@ -1825,7 +1823,7 @@ package body Sem_Disp is\n             end if;\n \n          --  Use the internal entity that links the interface primitive with\n-         --  the covering primitive to locate the entity\n+         --  the covering primitive to locate the entity.\n \n          elsif Interface_Alias (E) = Iface_Prim then\n             return Alias (E);\n@@ -2155,11 +2153,11 @@ package body Sem_Disp is\n \n          --  Make the overriding operation into an alias of the implicit one.\n          --  In this fashion a call from outside ends up calling the new body\n-         --  even if non-dispatching, and a call from inside calls the\n-         --  overriding operation because it hides the implicit one. To\n-         --  indicate that the body of Prev_Op is never called, set its\n-         --  dispatch table entity to Empty. If the overridden operation\n-         --  has a dispatching result, so does the overriding one.\n+         --  even if non-dispatching, and a call from inside calls the over-\n+         --  riding operation because it hides the implicit one. To indicate\n+         --  that the body of Prev_Op is never called, set its dispatch table\n+         --  entity to Empty. If the overridden operation has a dispatching\n+         --  result, so does the overriding one.\n \n          Set_Alias (Prev_Op, New_Op);\n          Set_DTC_Entity (Prev_Op, Empty);\n@@ -2214,7 +2212,6 @@ package body Sem_Disp is\n       end if;\n \n       Arg := First_Actual (Call_Node);\n-\n       while Present (Arg) loop\n          if Is_Tag_Indeterminate (Arg) then\n             Propagate_Tag (Control,  Arg);"}]}