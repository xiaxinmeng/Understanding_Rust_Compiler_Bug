{"sha": "1e30f9b4da5c6f2503d459b41e08db56fd7c6174", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUzMGY5YjRkYTVjNmYyNTAzZDQ1OWI0MWUwOGRiNTZmZDdjNjE3NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-03T21:34:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-03T21:34:04Z"}, "message": "class.c (check_bitfield_decl): New function, split out from finish_stuct_1.\n\n\t* class.c (check_bitfield_decl): New function, split out from\n\tfinish_stuct_1.\n\t(check_field_decl): Likewise.  Recursively examine members of\n\tanonymous structs.\n\t(finish_struct_1): Use them.\n\t* cp-tree.h (ANON_UNION_TYPE_P): New macro.\n\nFrom-SVN: r30381", "tree": {"sha": "3bb7cad6eec2fea3aa04b5db450f0990caa4566a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bb7cad6eec2fea3aa04b5db450f0990caa4566a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e30f9b4da5c6f2503d459b41e08db56fd7c6174", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e30f9b4da5c6f2503d459b41e08db56fd7c6174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e30f9b4da5c6f2503d459b41e08db56fd7c6174", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e30f9b4da5c6f2503d459b41e08db56fd7c6174/comments", "author": null, "committer": null, "parents": [{"sha": "4b66e1c09193e7606ebe6009a872bace584a0eb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b66e1c09193e7606ebe6009a872bace584a0eb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b66e1c09193e7606ebe6009a872bace584a0eb9"}], "stats": {"total": 391, "additions": 224, "deletions": 167}, "files": [{"sha": "228da4491451a61ce0bcc605f635ca87b65c2d7a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e30f9b4da5c6f2503d459b41e08db56fd7c6174/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e30f9b4da5c6f2503d459b41e08db56fd7c6174/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1e30f9b4da5c6f2503d459b41e08db56fd7c6174", "patch": "@@ -1,3 +1,12 @@\n+1999-11-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (check_bitfield_decl): New function, split out from\n+\tfinish_stuct_1.\n+\t(check_field_decl): Likewise.  Recursively examine members of\n+\tanonymous structs.\n+\t(finish_struct_1): Use them.\n+\t* cp-tree.h (ANON_UNION_TYPE_P): New macro.\n+\t\n 1999-11-02  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl.c (grokfndecl): Remove dead code."}, {"sha": "d7f0775a6d97c41431c841ea0068f9fc6810be58", "filename": "gcc/cp/class.c", "status": "modified", "additions": 197, "deletions": 167, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e30f9b4da5c6f2503d459b41e08db56fd7c6174/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e30f9b4da5c6f2503d459b41e08db56fd7c6174/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1e30f9b4da5c6f2503d459b41e08db56fd7c6174", "patch": "@@ -122,6 +122,8 @@ static tree build_vtable_entry_for_fn PROTO((tree, tree));\n static tree build_vtbl_initializer PROTO((tree));\n static int count_fields PROTO((tree));\n static int add_fields_to_vec PROTO((tree, tree, int));\n+static void check_bitfield_decl PROTO((tree));\n+static void check_field_decl PROTO((tree, tree, int *, int *, int *, int *));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -3156,6 +3158,194 @@ add_fields_to_vec (fields, field_vec, idx)\n   return idx;\n }\n \n+/* FIELD is a bit-field.  We are finishing the processing for its\n+   enclosing type.  Issue any appropriate messages and set appropriate\n+   flags.  */\n+\n+static void\n+check_bitfield_decl (field)\n+     tree field;\n+{\n+  tree type = TREE_TYPE (field);\n+\n+  /* Invalid bit-field size done by grokfield.  */\n+  /* Detect invalid bit-field type. Simply checking if TYPE is\n+     integral is insufficient, as that is the array core of the field\n+     type. If TREE_TYPE (field) is integral, then TYPE must be the same.  */\n+  if (DECL_INITIAL (field)\n+      && ! INTEGRAL_TYPE_P (TREE_TYPE (field)))\n+    {\n+      cp_error_at (\"bit-field `%#D' with non-integral type\", field);\n+      DECL_INITIAL (field) = NULL;\n+    }\n+\n+  /* Detect and ignore out of range field width.  */\n+  if (DECL_INITIAL (field))\n+    {\n+      tree w = DECL_INITIAL (field);\n+      register int width = 0;\n+\n+      /* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */\n+      STRIP_NOPS (w);\n+\n+      /* detect invalid field size.  */\n+      if (TREE_CODE (w) == CONST_DECL)\n+\tw = DECL_INITIAL (w);\n+      else if (TREE_READONLY_DECL_P (w))\n+\tw = decl_constant_value (w);\n+\n+      if (TREE_CODE (w) != INTEGER_CST)\n+\t{\n+\t  cp_error_at (\"bit-field `%D' width not an integer constant\",\n+\t\t       field);\n+\t  DECL_INITIAL (field) = NULL_TREE;\n+\t}\n+      else if (width = TREE_INT_CST_LOW (w),\n+\t       width < 0)\n+\t{\n+\t  DECL_INITIAL (field) = NULL;\n+\t  cp_error_at (\"negative width in bit-field `%D'\", field);\n+\t}\n+      else if (width == 0 && DECL_NAME (field) != 0)\n+\t{\n+\t  DECL_INITIAL (field) = NULL;\n+\t  cp_error_at (\"zero width for bit-field `%D'\", field);\n+\t}\n+      else if (width\n+\t       > TYPE_PRECISION (long_long_unsigned_type_node))\n+\t{\n+\t  /* The backend will dump if you try to use something too\n+\t     big; avoid that.  */\n+\t  DECL_INITIAL (field) = NULL;\n+\t  sorry (\"bit-fields larger than %d bits\",\n+\t\t TYPE_PRECISION (long_long_unsigned_type_node));\n+\t  cp_error_at (\"  in declaration of `%D'\", field);\n+\t}\n+      else if (width > TYPE_PRECISION (type)\n+\t       && TREE_CODE (type) != ENUMERAL_TYPE\n+\t       && TREE_CODE (type) != BOOLEAN_TYPE)\n+\tcp_warning_at (\"width of `%D' exceeds its type\", field);\n+      else if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t       && ((min_precision (TYPE_MIN_VALUE (type),\n+\t\t\t\t   TREE_UNSIGNED (type)) > width)\n+\t\t   || (min_precision (TYPE_MAX_VALUE (type),\n+\t\t\t\t      TREE_UNSIGNED (type)) > width)))\n+\tcp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n+\t\t       field, type);\n+\n+      if (DECL_INITIAL (field))\n+\t{\n+\t  DECL_INITIAL (field) = NULL_TREE;\n+\t  DECL_FIELD_SIZE (field) = width;\n+\t  DECL_BIT_FIELD (field) = 1;\n+\n+\t  if (width == 0)\n+\t    {\n+#ifdef EMPTY_FIELD_BOUNDARY\n+\t      DECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n+\t\t\t\t\tEMPTY_FIELD_BOUNDARY);\n+#endif\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+\t      if (PCC_BITFIELD_TYPE_MATTERS)\n+\t\tDECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n+\t\t\t\t\t  TYPE_ALIGN (type));\n+#endif\n+\t    }\n+\t}\n+    }\n+  else\n+    /* Non-bit-fields are aligned for their type.  */\n+    DECL_ALIGN (field) = MAX (DECL_ALIGN (field), TYPE_ALIGN (type));\n+}\n+\n+/* FIELD is a non bit-field.  We are finishing the processing for its\n+   enclosing type T.  Issue any appropriate messages and set appropriate\n+   flags.  */\n+\n+static void\n+check_field_decl (field, t, cant_have_const_ctor,\n+\t\t  cant_have_default_ctor, no_const_asn_ref,\n+\t\t  any_default_members)\n+     tree field;\n+     tree t;\n+     int *cant_have_const_ctor;\n+     int *cant_have_default_ctor;\n+     int *no_const_asn_ref;\n+     int *any_default_members;\n+{\n+  tree type = strip_array_types (TREE_TYPE (field));\n+\n+  /* An anonymous union cannot contain any fields which would change\n+     the settings of CANT_HAVE_CONST_CTOR and friends.  */\n+  if (ANON_UNION_TYPE_P (type))\n+    ;\n+  /* And, we don't set TYPE_HAS_CONST_INIT_REF, etc., for anonymous\n+     structs.  So, we recurse through their fields here.  */\n+  else if (ANON_AGGR_TYPE_P (type))\n+    {\n+      tree fields;\n+\n+      for (fields = TYPE_FIELDS (type); fields; fields = TREE_CHAIN (fields))\n+\tif (TREE_CODE (field) == FIELD_DECL && !DECL_C_BIT_FIELD (field))\n+\t  check_field_decl (fields, t, cant_have_const_ctor,\n+\t\t\t    cant_have_default_ctor, no_const_asn_ref,\n+\t\t\t    any_default_members);\n+    }\n+  /* Check members with class type for constructors, destructors,\n+     etc.  */\n+  else if (CLASS_TYPE_P (type))\n+    {\n+      /* Never let anything with uninheritable virtuals\n+\t make it through without complaint.  */\n+      abstract_virtuals_error (field, type);\n+\t\t      \n+      if (TREE_CODE (t) == UNION_TYPE)\n+\t{\n+\t  if (TYPE_NEEDS_CONSTRUCTING (type))\n+\t    cp_error_at (\"member `%#D' with constructor not allowed in union\",\n+\t\t\t field);\n+\t  if (TYPE_NEEDS_DESTRUCTOR (type))\n+\t    cp_error_at (\"member `%#D' with destructor not allowed in union\",\n+\t\t\t field);\n+\t  if (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n+\t    cp_error_at (\"member `%#D' with copy assignment operator not allowed in union\",\n+\t\t\t field);\n+\t}\n+      else\n+\t{\n+\t  TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (type);\n+\t  TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_NEEDS_DESTRUCTOR (type);\n+\t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n+\t  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n+\t}\n+\n+      if (!TYPE_HAS_CONST_INIT_REF (type))\n+\t*cant_have_const_ctor = 1;\n+\n+      if (!TYPE_HAS_CONST_ASSIGN_REF (type))\n+\t*no_const_asn_ref = 1;\n+\n+      if (TYPE_HAS_CONSTRUCTOR (type)\n+\t  && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n+\t*cant_have_default_ctor = 1;\n+    }\n+  if (DECL_INITIAL (field) != NULL_TREE)\n+    {\n+      /* `build_class_init_list' does not recognize\n+\t non-FIELD_DECLs.  */\n+      if (TREE_CODE (t) == UNION_TYPE && any_default_members != 0)\n+\tcp_error_at (\"multiple fields in union `%T' initialized\");\n+      *any_default_members = 1;\n+    }\n+\n+  /* Non-bit-fields are aligned for their type, except packed fields\n+     which require only BITS_PER_UNIT alignment.  */\n+  DECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n+\t\t\t    (DECL_PACKED (field) \n+\t\t\t     ? BITS_PER_UNIT\n+\t\t\t     : TYPE_ALIGN (TREE_TYPE (field))));\n+};\n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -3188,7 +3378,6 @@ finish_struct_1 (t)\n      tree t;\n {\n   int old;\n-  enum tree_code code = TREE_CODE (t);\n   tree fields = TYPE_FIELDS (t);\n   tree x, last_x, method_vec;\n   int has_virtual;\n@@ -3447,8 +3636,7 @@ finish_struct_1 (t)\n \t    }\n \t}\n \n-      while (TREE_CODE (type) == ARRAY_TYPE)\n-        type = TREE_TYPE (type);\n+      type = strip_array_types (type);\n       \n       if (TREE_CODE (type) == POINTER_TYPE)\n \thas_pointers = 1;\n@@ -3500,171 +3688,13 @@ finish_struct_1 (t)\n       /* We set DECL_C_BIT_FIELD in grokbitfield.\n \t If the type and width are valid, we'll also set DECL_BIT_FIELD.  */\n       if (DECL_C_BIT_FIELD (x))\n-\t{\n-\t  /* Invalid bit-field size done by grokfield.  */\n-\t  /* Detect invalid bit-field type. Simply checking if TYPE is\n-             integral is insufficient, as that is the array core of the\n-             field type. If TREE_TYPE (x) is integral, then TYPE must be\n-             the same.  */\n-\t  if (DECL_INITIAL (x)\n-\t      && ! INTEGRAL_TYPE_P (TREE_TYPE (x)))\n-\t    {\n-\t      cp_error_at (\"bit-field `%#D' with non-integral type\", x);\n-\t      DECL_INITIAL (x) = NULL;\n-\t    }\n-\n-\t  /* Detect and ignore out of range field width.  */\n-\t  if (DECL_INITIAL (x))\n-\t    {\n-\t      tree w = DECL_INITIAL (x);\n-\t      register int width = 0;\n-\n-\t      /* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */\n-\t      STRIP_NOPS (w);\n-\n-\t      /* detect invalid field size.  */\n-\t      if (TREE_CODE (w) == CONST_DECL)\n-\t\tw = DECL_INITIAL (w);\n-\t      else if (TREE_READONLY_DECL_P (w))\n-\t\tw = decl_constant_value (w);\n-\n-\t      if (TREE_CODE (w) != INTEGER_CST)\n-\t\t{\n-\t\t  cp_error_at (\"bit-field `%D' width not an integer constant\",\n-\t\t\t       x);\n-\t\t  DECL_INITIAL (x) = NULL_TREE;\n-\t\t}\n-\t      else if (width = TREE_INT_CST_LOW (w),\n-\t\t       width < 0)\n-\t\t{\n-\t\t  DECL_INITIAL (x) = NULL;\n-\t\t  cp_error_at (\"negative width in bit-field `%D'\", x);\n-\t\t}\n-\t      else if (width == 0 && DECL_NAME (x) != 0)\n-\t\t{\n-\t\t  DECL_INITIAL (x) = NULL;\n-\t\t  cp_error_at (\"zero width for bit-field `%D'\", x);\n-\t\t}\n-\t      else if (width\n-\t\t       > TYPE_PRECISION (long_long_unsigned_type_node))\n-\t\t{\n-\t\t  /* The backend will dump if you try to use something\n-\t\t     too big; avoid that.  */\n-\t\t  DECL_INITIAL (x) = NULL;\n-\t\t  sorry (\"bit-fields larger than %d bits\",\n-\t\t\t TYPE_PRECISION (long_long_unsigned_type_node));\n-\t\t  cp_error_at (\"  in declaration of `%D'\", x);\n-\t\t}\n-\t      else if (width > TYPE_PRECISION (type)\n-\t\t       && TREE_CODE (type) != ENUMERAL_TYPE\n-\t\t       && TREE_CODE (type) != BOOLEAN_TYPE)\n-\t\t{\n-\t\t  cp_warning_at (\"width of `%D' exceeds its type\", x);\n-\t\t}\n-\t      else if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t\t       && ((min_precision (TYPE_MIN_VALUE (type),\n-\t\t\t\t\t   TREE_UNSIGNED (type)) > width)\n-\t\t\t   || (min_precision (TYPE_MAX_VALUE (type),\n-\t\t\t\t\t      TREE_UNSIGNED (type)) > width)))\n-\t\t{\n-\t\t  cp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n-\t\t\t\t x, type);\n-\t\t}\n-\n-\t      if (DECL_INITIAL (x))\n-\t\t{\n-\t\t  DECL_INITIAL (x) = NULL_TREE;\n-\t\t  DECL_FIELD_SIZE (x) = width;\n-\t\t  DECL_BIT_FIELD (x) = 1;\n-\n-\t\t  if (width == 0)\n-\t\t    {\n-#ifdef EMPTY_FIELD_BOUNDARY\n-\t\t      DECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n-\t\t\t\t\t    EMPTY_FIELD_BOUNDARY);\n-#endif\n-#ifdef PCC_BITFIELD_TYPE_MATTERS\n-\t\t      if (PCC_BITFIELD_TYPE_MATTERS)\n-\t\t\tDECL_ALIGN (x) = MAX (DECL_ALIGN (x),\n-\t\t\t\t\t      TYPE_ALIGN (type));\n-#endif\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    /* Non-bit-fields are aligned for their type.  */\n-\t    DECL_ALIGN (x) = MAX (DECL_ALIGN (x), TYPE_ALIGN (type));\n-\t}\n+\tcheck_bitfield_decl (x);\n       else\n-\t{\n-\t  if (CLASS_TYPE_P (type) && ! ANON_AGGR_TYPE_P (type))\n-\t    {\n-\t      /* Never let anything with uninheritable virtuals\n-\t\t make it through without complaint.  */\n-\t      abstract_virtuals_error (x, type);\n-\t\t      \n-\t      if (code == UNION_TYPE)\n-\t\t{\n-\t\t  const char *fie = NULL;\n-\t\t  if (TYPE_NEEDS_CONSTRUCTING (type))\n-\t\t    fie = \"constructor\";\n-\t\t  else if (TYPE_NEEDS_DESTRUCTOR (type))\n-\t\t    fie = \"destructor\";\n-\t\t  else if (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n-\t\t    fie = \"copy assignment operator\";\n-\t\t  if (fie)\n-\t\t    cp_error_at (\"member `%#D' with %s not allowed in union\", x,\n-\t\t\t\t fie);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  TYPE_NEEDS_CONSTRUCTING (t) |= TYPE_NEEDS_CONSTRUCTING (type);\n-\t\t  TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_NEEDS_DESTRUCTOR (type);\n-\t\t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) |= TYPE_HAS_COMPLEX_ASSIGN_REF (type);\n-\t\t  TYPE_HAS_COMPLEX_INIT_REF (t) |= TYPE_HAS_COMPLEX_INIT_REF (type);\n-\t\t}\n-\n-\t      if (!TYPE_HAS_CONST_INIT_REF (type))\n-\t\tcant_have_const_ctor = 1;\n-\n-\t      if (!TYPE_HAS_CONST_ASSIGN_REF (type))\n-\t\tno_const_asn_ref = 1;\n-\n-\t      if (TYPE_HAS_CONSTRUCTOR (type)\n-\t\t  && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n-\t\t{\n-\t\t  cant_have_default_ctor = 1;\n-#if 0\n-\t\t  /* This is wrong for aggregates.  */\n-\t\t  if (! TYPE_HAS_CONSTRUCTOR (t))\n-\t\t    {\n-\t\t      if (DECL_NAME (x))\n-\t\t\tcp_pedwarn_at (\"member `%#D' with only non-default constructor\", x);\n-\t\t      else\n-\t\t\tcp_pedwarn_at (\"member with only non-default constructor\", x);\n-\t\t      cp_pedwarn_at (\"in class without a constructor\",\n-\t\t\t\t     x);\n-\t\t    }\n-#endif\n-\t\t}\n-\t    }\n-\t  if (DECL_INITIAL (x) != NULL_TREE)\n-\t    {\n-\t      /* `build_class_init_list' does not recognize\n-\t\t non-FIELD_DECLs.  */\n-\t      if (code == UNION_TYPE && any_default_members != 0)\n-\t\tcp_error_at (\"multiple fields in union `%T' initialized\");\n-\t      any_default_members = 1;\n-\t    }\n-\n-\t  {\n-\t    unsigned int min_align = (DECL_PACKED (x) ? BITS_PER_UNIT\n-\t\t\t\t      : TYPE_ALIGN (TREE_TYPE (x)));\n-\t    /* Non-bit-fields are aligned for their type, except packed\n-\t       fields which require only BITS_PER_UNIT alignment.  */\n-\t    DECL_ALIGN (x) = MAX (DECL_ALIGN (x), min_align);\n-\t  }\n-\t}\n+\tcheck_field_decl (x, t,\n+\t\t\t  &cant_have_const_ctor,\n+\t\t\t  &cant_have_default_ctor, \n+\t\t\t  &no_const_asn_ref,\n+\t\t\t  &any_default_members);\n     }\n \n   /* If this type has any constant members which did not come"}, {"sha": "882ca04c222c2d10e46bf465978d873117d9184a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e30f9b4da5c6f2503d459b41e08db56fd7c6174/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e30f9b4da5c6f2503d459b41e08db56fd7c6174/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1e30f9b4da5c6f2503d459b41e08db56fd7c6174", "patch": "@@ -2321,6 +2321,10 @@ extern int flag_new_for_scope;\n #define SET_ANON_AGGR_TYPE_P(NODE)\t\t\t\\\n   (TYPE_LANG_SPECIFIC (NODE)->anon_aggr = 1)\n \n+/* Nonzero if TYPE is an anonymous union type.  */\n+#define ANON_UNION_TYPE_P(NODE) \\\n+  (TREE_CODE (NODE) == UNION_TYPE && ANON_AGGR_TYPE_P (NODE))\n+\n /* For a VAR_DECL that is an anonymous union, these are the various\n    sub-variables that make up the anonymous union.  */\n #define DECL_ANON_UNION_ELEMS(NODE) DECL_ARGUMENTS ((NODE))"}, {"sha": "587427ab209be5ef872d5aec131536b9676c6ac0", "filename": "gcc/testsuite/g++.old-deja/g++.ext/anon2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e30f9b4da5c6f2503d459b41e08db56fd7c6174/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fanon2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e30f9b4da5c6f2503d459b41e08db56fd7c6174/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fanon2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fanon2.C?ref=1e30f9b4da5c6f2503d459b41e08db56fd7c6174", "patch": "@@ -0,0 +1,14 @@\n+// Build don't link:\n+// Special g++ Options:\n+\n+struct S \n+{\n+  S ();\n+};\n+\n+union U {\n+  struct { \n+    S s; // ERROR - struct with constructor in union\n+  };\n+};\n+"}]}