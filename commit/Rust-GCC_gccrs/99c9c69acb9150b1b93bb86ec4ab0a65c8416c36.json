{"sha": "99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTljOWM2OWFjYjkxNTBiMWI5M2JiODZlYzRhYjBhNjVjODQxNmMzNg==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-07-24T09:20:50Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-07-24T09:20:50Z"}, "message": "2007-07-24  Dorit Nuzman  <dorit@il.ibm.com>\n\n        * lib/target-support.exp (check_effective_target_natural_alignment):\n        (check_effective_target_vector_alignment_reachable): New.\n        * config/spu/spu.c (spu_vector_alignment_reachable): New.\n        (TARGET_VECTOR_ALIGNMENT_REACHABLE): Define.\n        * * gcc.dg/vect/pr25413a.c: Use vector_alignment_reachable target\n        check.\n        * gcc.dg/vect/pr25413.c: Likewise.\n        * gcc.dg/vect/pr31699.c: Likewise.\n\nFrom-SVN: r126872", "tree": {"sha": "c37de353896600006b68d9bf91aa18e9b5a747b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c37de353896600006b68d9bf91aa18e9b5a747b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/comments", "author": null, "committer": null, "parents": [{"sha": "376164b960bfada6a4251eeb9b631636bfd8c619", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/376164b960bfada6a4251eeb9b631636bfd8c619", "html_url": "https://github.com/Rust-GCC/gccrs/commit/376164b960bfada6a4251eeb9b631636bfd8c619"}], "stats": {"total": 86, "additions": 78, "deletions": 8}, "files": [{"sha": "53d0c46c399699653422d26d511667ead34b04a5", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "patch": "@@ -136,6 +136,7 @@ static tree spu_builtin_mul_widen_even (tree);\n static tree spu_builtin_mul_widen_odd (tree);\n static tree spu_builtin_mask_for_load (void);\n static int spu_builtin_vectorization_cost (bool);\n+static bool spu_vector_alignment_reachable (tree, bool);\n \n extern const char *reg_names[];\n rtx spu_compare_op0, spu_compare_op1;\n@@ -272,6 +273,9 @@ const struct attribute_spec spu_attribute_table[];\n #undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST spu_builtin_vectorization_cost\n \n+#undef TARGET_VECTOR_ALIGNMENT_REACHABLE\n+#define TARGET_VECTOR_ALIGNMENT_REACHABLE spu_vector_alignment_reachable\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n void\n@@ -5477,6 +5481,20 @@ spu_builtin_vectorization_cost (bool runtime_test)\n     return 0;\n }\n \n+/* Return true iff, data reference of TYPE can reach vector alignment (16)\n+   after applying N number of iterations.  This routine does not determine\n+   how may iterations are required to reach desired alignment.  */\n+\n+static bool\n+spu_vector_alignment_reachable (tree type ATTRIBUTE_UNUSED, bool is_packed)\n+{\n+  if (is_packed)\n+    return false;\n+\n+  /* All other types are naturally aligned.  */\n+  return true;\n+}\n+\n void\n spu_init_expanders (void)\n {   "}, {"sha": "486bc8849874a20b0eb1f29b56083fd077563499", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "patch": "@@ -1,3 +1,14 @@\n+2007-07-24  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* lib/target-support.exp (check_effective_target_natural_alignment): \n+\t(check_effective_target_vector_alignment_reachable): New.\n+\t* config/spu/spu.c (spu_vector_alignment_reachable): New.\n+\t(TARGET_VECTOR_ALIGNMENT_REACHABLE): Define.\n+\t* * gcc.dg/vect/pr25413a.c: Use vector_alignment_reachable target \n+\tcheck.\n+\t* gcc.dg/vect/pr25413.c: Likewise.\n+\t* gcc.dg/vect/pr31699.c: Likewise.\n+\n 2007-07-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/30814"}, {"sha": "e74093df15a95f47b18b51689d429f3dd4baf5c0", "filename": "gcc/testsuite/gcc.dg/vect/pr25413.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413.c?ref=99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "patch": "@@ -31,8 +31,8 @@ int main (void)\n   return 0;\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_aligned_arrays } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { target { ! vect_aligned_arrays } } } } */\n-/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" { target { ! vect_aligned_arrays } } } } */\n-/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 1 \"vect\" { target { ! vect_aligned_arrays } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vector_alignment_reachable } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" { target { ! vector_alignment_reachable } } } } */\n+/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n+/* { dg-final { scan-tree-dump-times \"not vectorized: unsupported unaligned store\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "b9bef5f5b7796c9e03433169d0a290807561937c", "filename": "gcc/testsuite/gcc.dg/vect/pr25413a.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr25413a.c?ref=99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "patch": "@@ -124,6 +124,6 @@ int main (void)\n } \n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" { target { ! vect_aligned_arrays  } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { ! vect_aligned_arrays } } } } */\n+/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" { target { ! vector_alignment_reachable  } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "cbc596d467f0467c6baeb0c69e5a5f2c6a683904", "filename": "gcc/testsuite/gcc.dg/vect/pr31699.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr31699.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr31699.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr31699.c?ref=99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "patch": "@@ -31,6 +31,6 @@ int main()\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { target vect_intfloat_cvt } } } */\n-/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" { target { ! vect_aligned_arrays } } } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { ! vect_aligned_arrays } } } } */\n+/* { dg-final { scan-tree-dump-times \"vector alignment may not be reachable\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using versioning\" 1 \"vect\" { target { ! vector_alignment_reachable } } } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "ea3ecc439c5124f1525e3257a2dddf2b9d11ae92", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c9c69acb9150b1b93bb86ec4ab0a65c8416c36/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=99c9c69acb9150b1b93bb86ec4ab0a65c8416c36", "patch": "@@ -2031,6 +2031,47 @@ proc check_effective_target_vect_aligned_arrays { } {\n     return $et_vect_aligned_arrays_saved\n }\n \n+# Return 1 if types are naturally aligned (aligned to their type-size),\n+# 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_natural_alignment { } {\n+    global et_natural_alignment\n+\n+    if [info exists et_natural_alignment_saved] {\n+        verbose \"check_effective_target_natural_alignment: using cached result\" 2\n+    } else {\n+        set et_natural_alignment_saved 0\n+        if { [istarget spu-*-*] } {\n+            set et_natural_alignment_saved 1\n+        }\n+    }\n+    verbose \"check_effective_target_natural_alignment: returning $et_natural_alignment_saved\" 2\n+    return $et_natural_alignment_saved\n+}\n+\n+# Return 1 if vector alignment is reachable, 0 otherwise.\n+#\n+# This won't change for different subtargets so cache the result.\n+\n+proc check_effective_target_vector_alignment_reachable { } {\n+    global et_vector_alignment_reachable\n+\n+    if [info exists et_vector_alignment_reachable_saved] {\n+        verbose \"check_effective_target_vector_alignment_reachable: using cached result\" 2\n+    } else {\n+        if { [check_effective_target_vect_aligned_arrays]\n+             || [check_effective_target_natural_alignment] } {\n+            set et_vector_alignment_reachable_saved 1\n+        } else {\n+            set et_vector_alignment_reachable_saved 0\n+        }\n+    }\n+    verbose \"check_effective_target_vector_alignment_reachable: returning $et_vector_alignment_reachable_saved\" 2\n+    return $et_vector_alignment_reachable_saved\n+}\n+\n # Return 1 if the target supports vector conditional operations, 0 otherwise.\n \n proc check_effective_target_vect_condition { } {"}]}