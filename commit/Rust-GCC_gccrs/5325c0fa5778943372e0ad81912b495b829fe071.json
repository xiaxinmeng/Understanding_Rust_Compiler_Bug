{"sha": "5325c0fa5778943372e0ad81912b495b829fe071", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMyNWMwZmE1Nzc4OTQzMzcyZTBhZDgxOTEyYjQ5NWI4MjlmZTA3MQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-07T20:18:43Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-07T20:18:43Z"}, "message": "Correct errors in comments.\n\n(calc_live_regs, expand_acall): Delete TARGET_SMALLCALL support.\n(need_slot): Add comment.  Delete test of INSN_ANNULLED_BRANCH_P.\n(print_operand_address): Delete '*', '^', '!' support.\n(synth_constant): Call zero_extend* instead of and*.  Call ashlsi3_k\ninstead of ashlsi3_n.\n(prepare_scc_operands): Abort for NE case.\n(output_move_double, output_far_jump, output_branch): Delete commented\nout code.  Don't output assembler comments.\n(gen_ashift): Don't call addsi3.\n(fixit): Delete redundant test for QImode constants.\n(hi_const): Delete TARGET_SHORTADDR support.\n(find_barrier): Don't put constant pool between mova and its label.\n(add_function, seen_function, bsr_operand, mac_operand,\nfake_shift): Delete.\n(sh_expand_prologue, expand_acall): Delete TARGET_BSR support.\n(general_movsrc_operand): Don't reject non-I CONST_INT.\n\nFrom-SVN: r8889", "tree": {"sha": "aba35c06407557cf5a519efabcf063bc43256d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aba35c06407557cf5a519efabcf063bc43256d80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5325c0fa5778943372e0ad81912b495b829fe071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5325c0fa5778943372e0ad81912b495b829fe071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5325c0fa5778943372e0ad81912b495b829fe071", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5325c0fa5778943372e0ad81912b495b829fe071/comments", "author": null, "committer": null, "parents": [{"sha": "51bd623f2bbfcc82d4448258b81508d3958fb109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51bd623f2bbfcc82d4448258b81508d3958fb109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51bd623f2bbfcc82d4448258b81508d3958fb109"}], "stats": {"total": 245, "additions": 60, "deletions": 185}, "files": [{"sha": "0fc3953dafe5ac4fddbc255d62526e9df0553228", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 60, "deletions": 185, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5325c0fa5778943372e0ad81912b495b829fe071/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5325c0fa5778943372e0ad81912b495b829fe071/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=5325c0fa5778943372e0ad81912b495b829fe071", "patch": "@@ -201,8 +201,8 @@ push_regs (mask)\n \n \n /* Print an instruction which would have gone into a delay slot after\n-   an instructiuon, but couldn't because the instruction expanded into a\n-   sequence where putting the slot insn at the end wouldn't work. */\n+   another instruction, but couldn't because the other instruction expanded\n+   into a sequence where putting the slot insn at the end wouldn't work. */\n \n static void\n print_slot (insn)\n@@ -248,13 +248,6 @@ calc_live_regs (count_ptr)\n \t      count++;\n \t    }\n \t}\n-      else if (TARGET_SMALLCALL)\n-\t{\n-\t  /* Don't need to push anthing, but count the regs which have\n-\t     been pushed by the wrapper */\n-\t  if (call_used_regs[reg])\n-\t    count++;\n-\t}\n       else\n \t{\n \t  /* Only push those regs which are used and need to be saved */\n@@ -271,12 +264,16 @@ calc_live_regs (count_ptr)\n   return live_regs_mask;\n }\n \f\n+/* This returns true if INSN is a conditional branch whose delay slot\n+   has been filled.  This indicates that it must be a bf.s/bt.s.\n+\n+   ??? This function could be eliminated.  */\n \n static int\n need_slot (insn)\n      rtx insn;\n {\n-  return (insn && !INSN_ANNULLED_BRANCH_P (XVECEXP (insn, 0, 0)));\n+  return insn;\n }\n \n /* Print the operand address in x to the stream */\n@@ -343,9 +340,6 @@ print_operand_address (stream, x)\n    according to modifier code.\n \n    '.'  print a .s if insn needs delay slot\n-   '*'  print a local label\n-   '^'  increment the local label number\n-   '!'  dump the constant table\n    '#'  output a nop if there is nothing to put in the delay slot\n    '@'  print rte or rts depending upon pragma interruptness\n    'R'  print the LSW of a dp value - changes if in little endian\n@@ -367,12 +361,6 @@ print_operand (stream, x, code)\n       if (need_slot (final_sequence))\n \tfprintf (stream, \".s\");\n       break;\n-    case '*':\n-      fprintf (stream, \"LF%d\", lf);\n-      break;\n-    case '^':\n-      lf++;\n-      break;\n     case '@':\n       if (pragma_interrupt)\n \tfprintf (stream, \"rte\");\n@@ -488,6 +476,9 @@ sextb (x)\n    00000000 00000000 00000000 1NNNNNNNN load and zero extend byte\n    00000000 00000000 11111111 1NNNNNNNN load and zero extend word\n \n+   ??? Can add cases using swap.b and swap.w.\n+   Can add cases using andi to get `1s 1s 1s 0NNNNNN1'.\n+   Can add many more cases for TARGET_CLEN3, but doubt their usefulness.\n \n */\n \n@@ -521,29 +512,29 @@ synth_constant (operands, mode)\n   if ((i & 0xffffff80) == 0x0000ff80)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i)));\n-      emit_insn (gen_and_ffff (dst, dst));\n+      emit_insn (gen_zero_extendhisi2 (dst, gen_lowpart (HImode, dst)));\n     }\n   /*    00000000 00000000 00000000 1NNNNNNNN load and zero extend byte */\n   else if ((i & 0xffffff80) == 0x00000080)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i)));\n-      emit_insn (gen_and_ff (dst, dst));\n+      emit_insn (gen_zero_extendqisi2 (dst, gen_lowpart (QImode, dst)));\n     }\n   /*   00000000 00000000 00000000 NNNNNNNN0 load and shift by 1\n        11111111 11111111 11111111 NNNNNNNN0 load and shift by 1 */\n   else if ((i & 0xffffff01) == 0\n \t   || (i & 0xffffff01) == 0xffffff00)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 1)));\n-      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (1)));\n+      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (1)));\n     }\n   /*   00000000 00000000 0000000N NNNNNNN00 load and shift by 2\n        11111111 11111111 1111111N NNNNNNN00 load and shift by 2*/\n   else if ((i & 0xfffffe03) == 0\n \t   || (i & 0xfffffe03) == 0xfffffe00)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 2)));\n-      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (2)));\n+      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (2)));\n     }\n   /*   00000000 00000000 0NNNNNNN 000000000 load and shift by 8\n        11111111 11111111 1NNNNNNN 000000000 load and shift by 8 */\n@@ -552,21 +543,21 @@ synth_constant (operands, mode)\n \t   || (i & 0xffff80ff) == 0xffff8000)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 8)));\n-      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (8)));\n+      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (8)));\n     }\n   /*     00000000 0NNNNNNN 00000000 000000000 load and shift by 16\n \t 11111111 1NNNNNNN 00000000 000000000 load and shift by 16 */\n   else if ((i & 0xff80ffff) == 0x00000000\n \t   || (i & 0xff80ffff) == 0xff800000)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 16)));\n-      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (16)));\n+      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (16)));\n     }\n   /*   00000000 00000000 0NNNNNNN 0NNNNNNNN load shift 8 and add */\n   else if ((i & 0xffff8080) == 0 && TARGET_CLEN3)\n     {\n       emit_move_insn (dst, GEN_INT (sextb (i >> 8)));\n-      emit_insn (gen_ashlsi3_n (dst, dst, GEN_INT (8)));\n+      emit_insn (gen_ashlsi3_k (dst, dst, GEN_INT (8)));\n       emit_insn (gen_addsi3 (dst, dst, GEN_INT (i & 0x7f)));\n     }\n   else\n@@ -808,8 +799,8 @@ prepare_scc_operands (code)\n       switch (code)\n \t{\n \tcase NE:\n-\t  newcode = EQ;\n-\t  break;\n+\t  /* It isn't possible to handle this case.  */\n+\t  abort ();\n \tcase LT:\n \t  newcode = GT;\n \t  break;\n@@ -861,8 +852,6 @@ output_movedouble (insn, operands, mode)\n   rtx dst = operands[0];\n   rtx src = operands[1];\n \n-/*   fprintf (asm_out_file, \"! move double \\n\");\n-  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);*/\n   if (GET_CODE (dst) == MEM\n       && GET_CODE (XEXP (dst, 0)) == POST_INC)\n     {\n@@ -881,9 +870,9 @@ output_movedouble (insn, operands, mode)\n        */\n \n       if (REGNO (src) + 1 == REGNO (dst))\n-\treturn \"mov\t%T1,%T0\\n\\tmov\t%1,%0 ! cra\";\n+\treturn \"mov\t%T1,%T0\\n\\tmov\t%1,%0\";\n       else\n-\treturn \"mov\t%1,%0\\n\\tmov\t%T1,%T0 ! crb\";\n+\treturn \"mov\t%1,%0\\n\\tmov\t%T1,%T0\";\n     }\n   else if (GET_CODE (src) == CONST_INT)\n     {\n@@ -929,7 +918,7 @@ output_movedouble (insn, operands, mode)\n \t}\n       else if (GET_CODE (inside) == POST_INC)\n \t{\n-\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1,%T0 !mdi\\n\";\n+\t  return \"mov.l\t%1,%0\\n\\tmov.l\t%1,%T0\";\n \t}\n       else\n \tabort ();\n@@ -942,7 +931,7 @@ output_movedouble (insn, operands, mode)\n \t{\n \t  /* This move clobbers both index registers,\n \t     calculate the sum in one register.  */\n-\t  fprintf (asm_out_file, \"\tadd\t%s,%s ! special fix\\n\",\n+\t  fprintf (asm_out_file, \"\tadd\t%s,%s\\n\",\n \t\t   reg_names[ptrreg2], reg_names[ptrreg1]);\n \n \t  if (dreg == ptrreg1)\n@@ -976,7 +965,7 @@ output_movedouble (insn, operands, mode)\n       if (dreg == ptrreg1)\n \t{\n \t  /* Copy into the second half first */\n-\t  return \"mov.l\t%T1,%T0\\n\\tmov.l\t%1,%0 ! cr\";\n+\t  return \"mov.l\t%T1,%T0\\n\\tmov.l\t%1,%0\";\n \t}\n     }\n \n@@ -1114,14 +1103,14 @@ output_far_jump (insn, op)\n       output_asm_insn (\"mov.l\t%1,@-r15\", vec);\n       output_asm_insn (\"mov.l\t%O0,%1\", vec);\n \n-      output_asm_insn (\"jmp\t@%1 ! 32 xcond\", vec);\n+      output_asm_insn (\"jmp\t@%1\", vec);\n       output_asm_insn (\"mov.l\t@r15+,%1\", vec);\n     }\n   else\n     {\n       output_asm_insn (\"mov.l\tr13,@-r15\", 0);\n       output_asm_insn (\"mov.l\t%O0,r13\", &thislab);\n-      output_asm_insn (\"jmp\t@r13 ! 32 zcond\", 0);\n+      output_asm_insn (\"jmp\t@r13\", 0);\n       output_asm_insn (\"mov.l\t@r15+,r13\", 0);\n     }\n \n@@ -1139,8 +1128,6 @@ output_branch (logic, insn)\n   extern rtx recog_operand[];\n   int label = lf++;\n \n-  /*  fprintf (asm_out_file, \"! pc %04x\\n\", insn_addresses[INSN_UID (insn)]);*/\n-\n   switch (get_attr_length (insn))\n     {\n     case 2:\n@@ -1172,7 +1159,7 @@ output_branch (logic, insn)\n \t  }\n \trecog_operand[0] = oldop;\n \n-\toutput_asm_insn (\"bra\t%l0\t! 12 bit cond \", recog_operand);\n+\toutput_asm_insn (\"bra\t%l0\", recog_operand);\n \tfprintf (asm_out_file, \"\\tor\tr0,r0\\n\");\n \tfprintf (asm_out_file, \"LF%d:\\n\", label);\n       }\n@@ -1330,11 +1317,6 @@ final_prescan_insn (insn, opvec, noperands)\n     }\n }\n \f\n-\n-\n-\n-/* Stuff taken from m88k.c */\n-\n /* Output to FILE the start of the assembler file.  */\n \n struct option\n@@ -1582,10 +1564,7 @@ gen_ashift (type, n, reg)\n       emit_insn (gen_lshrsi3_k (reg, reg, GEN_INT (n)));\n       break;\n     case ASHIFT:\n-      if (n == 1)\n-\temit_insn (gen_addsi3 (reg, reg, reg));\n-      else\n-\temit_insn (gen_ashlsi3_k (reg, reg, GEN_INT (n)));\n+      emit_insn (gen_ashlsi3_k (reg, reg, GEN_INT (n)));\n       break;\n     }\n }\n@@ -1809,15 +1788,9 @@ fixit (src, mode)\n       return 1;\n     }\n   if (GET_CODE (src) == LABEL_REF)\n-    {\n-      return 1;\n-    }\n+    return 1;\n   if (GET_CODE (src) == CONST_INT)\n     {\n-      /* All QI insns are ok */\n-      if (mode == QImode)\n-\treturn 1;\n-      /* The rest may need to be fixed */\n       return !CONST_OK_FOR_I (INTVAL (src));\n     }\n   return 0;\n@@ -1834,10 +1807,6 @@ hi_const (src)\n       && GET_CODE (XEXP (XEXP (src, 0), 0)) == SYMBOL_REF)\n     return 1;\n \n-  if (TARGET_SHORTADDR\n-      && GET_CODE (src) == SYMBOL_REF)\n-    return 1;\n-\n   return (GET_CODE (src) == CONST_INT\n \t  && INTVAL (src) >= -32768\n \t  && INTVAL (src) <= 32767);\n@@ -1846,6 +1815,14 @@ hi_const (src)\n /* Find the last barrier less than MAX_COUNT bytes from FROM, or create one.\n    If an HI move is found, then make sure that MAX_COUNT_HI isn't broken from that one. */\n \n+/* ??? It would be good to put constant pool tables between a case jump and\n+   the jump table.  This fails for two reasons.  First, there is no\n+   barrier after the case jump.  This is a bug in the casesi pattern.\n+   Second, inserting the table here may break the mova instruction that\n+   loads the jump table address, by moving the jump table too far away.\n+   We fix that problem by never outputting the constant pool between a mova\n+   and its label.  */\n+\n static\n rtx\n find_barrier (from)\n@@ -1856,6 +1833,7 @@ find_barrier (from)\n   int found_hi = 0;\n   int found_si = 0;\n   rtx found_barrier = 0;\n+  rtx found_mova = 0;\n   while (from\n \t && count_si < max_count_si\n \t && count_hi < max_count_hi)\n@@ -1885,13 +1863,30 @@ find_barrier (from)\n \t{\n \t  inc = get_attr_length (from);\n \t}\n+\n+      /* ??? This isn't correct anymore.  The mova RTL has changed.  */\n+      if (GET_CODE (from) == INSN\n+\t  && GET_CODE (PATTERN (from)) == SET\n+\t  && GET_CODE (SET_DEST (PATTERN (from))) == REG\n+\t  && GET_CODE (SET_SRC (PATTERN (from))) == LABEL_REF)\n+\tfound_mova = from;\n+      else if (GET_CODE (from) == JUMP_INSN\n+\t       && (GET_CODE (PATTERN (from)) == ADDR_VEC\n+\t\t   || GET_CODE (PATTERN (from)) == ADDR_DIFF_VEC))\n+\tfound_mova = 0;\n+\n       if (found_si)\n \tcount_si += inc;\n       if (found_hi)\n \tcount_hi += inc;\n       from = NEXT_INSN (from);\n     }\n \n+  /* Insert the constant pool table before the mova instruction, to prevent\n+     the mova label reference from going out of range.  */\n+  if (found_mova)\n+    from = found_mova;\n+\n   if (!found_barrier)\n     {\n       /* We didn't find a barrier in time to \n@@ -2036,41 +2031,6 @@ equality_operator (x, mode)\n   return (code == EQ || code == NE);\n }\n \n-\n-/* Add this function to the list of ones seen - temporary\n-   gross hack to try out bsrs. */\n-struct flist\n-{\n-  char *name;\n-  struct flist *next;\n-};\n-struct flist *head;\n-\n-static void\n-add_function (name)\n-     char *name;\n-{\n-  struct flist *n = (struct flist *) xmalloc (sizeof (struct flist));\n-  int l = strlen (name) + 1;\n-  n->name = xmalloc (l);\n-  memcpy (n->name, name, l);\n-  n->next = head;\n-  head = n;\n-}\n-\n-static int\n-seen_function (name)\n-     char *name;\n-{\n-  struct flist *p = head;\n-  for (p = head; p; p = p->next)\n-    {\n-      if (strcmp (p->name, name) == 0)\n-\treturn 1;\n-    }\n-  return 0;\n-}\n-\n  /* Framefull frame looks like:\n \n     arg-5\n@@ -2090,10 +2050,6 @@ seen_function (name)\n     local-1\n     local-0        <- fp points here\n \n-\n-    If TARGET_SMALLCALL, then the preserved registers are pushed by a\n-    wrapper before the routine is entered, so the regs are always pushed\n-    and there are two pr's on the stack - the caller and the wrapper.\n   */\n \n \n@@ -2137,10 +2093,6 @@ sh_expand_prologue ()\n     {\n       emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n     }\n-  if (TARGET_BSR)\n-    {\n-      add_function (IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n-    }\n \n   /* ??? Hack.  Clear out the table set up by gen_shifty_op since this\n      info does not apply to the next function.  */\n@@ -2245,10 +2197,7 @@ handle_pragma (file)\n \f\n /* insn expand helpers */\n \n-/* Emit insns to perform a call.\n-   If TARGET_SHORTADDR then use a bsr. If TARGET_SMALLCALL, then load the\n-   target address into r1 and call __saveargs, otherwise\n-   perform the standard call sequence */\n+/* Emit insns to perform a call.  */\n \n void\n expand_acall (isa_retval, operands)\n@@ -2260,29 +2209,13 @@ expand_acall (isa_retval, operands)\n   rtx call_target = operands[isa_retval + 0];\n   rtx numargs = operands[isa_retval + 1];\n \n-  if (TARGET_BSR && bsr_operand (call_target, VOIDmode))\n+  if (GET_CODE (call_target) == MEM)\n     {\n-      call = gen_rtx (CALL, VOIDmode, call_target, numargs);\n+      call_target = force_reg (Pmode, XEXP (call_target, 0));\n     }\n-  else\n-    {\n-      if (GET_CODE (call_target) == MEM)\n-\t{\n-\t  call_target = force_reg (Pmode,\n-\t\t\t\t   XEXP (call_target, 0));\n-\t}\n-      if (TARGET_SMALLCALL)\n-\t{\n-\t  rtx tmp = gen_reg_rtx (SImode);\n-\t  rtx r1 = gen_rtx (REG, SImode, 1);\n-\t  emit_move_insn (tmp, gen_rtx (SYMBOL_REF, SImode, \"__saveargs\"));\n-\t  emit_move_insn (r1, call_target);\n-\t  emit_insn (gen_rtx (USE, VOIDmode, r1));\n-\t  call_target = tmp;\n-\t}\n \n-      call = gen_rtx (CALL, VOIDmode, gen_rtx (MEM, SImode, call_target), numargs);\n-    }\n+  call = gen_rtx (CALL, VOIDmode, gen_rtx (MEM, SImode, call_target), numargs);\n+\n   if (isa_retval)\n     {\n       call = gen_rtx (SET, VOIDmode, ret, call);\n@@ -2345,11 +2278,6 @@ general_movsrc_operand (op, mode)\n \t  && system_reg_operand (XEXP (op, 0), mode)))\n     return 0;\n \n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      int i = INTVAL (op);\n-      return CONST_OK_FOR_I (i);\n-    }\n   return general_operand (op, mode);\n }\n \n@@ -2379,26 +2307,6 @@ general_movdst_operand (op, mode)\n \n \n \n-/* Returns 1 if OP is valid destination for a bsr.  */\n-\n-int\n-bsr_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (TARGET_BSR)\n-    {\n-      if (GET_CODE (op) == SYMBOL_REF)\n-\t{\n-\t  if (!strcmp (XSTR (op, 0),\n-\t\t      IDENTIFIER_POINTER (DECL_NAME (current_function_decl))))\n-\t    return 1;\n-\t  return (seen_function (XSTR (op, 0)));\n-\t}\n-    }\n-  return 0;\n-}\n-\n /* Returns 1 if OP is an immediate ok for a byte index.  */\n \n int\n@@ -2539,25 +2447,6 @@ logical_operand (op, mode)\n   return 0;\n }\n \n-/* Returns 1 if OP is a valid operand for a MAC instruction,\n-   either a register or indirect memory.  For now we don't\n-   try and recognise a mac insn */\n-\n-int\n-mac_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (arith_reg_operand (op, mode))\n-    return 1;\n-#if 0\n-  Turned off till mac is understood\n-  if (GET_CODE (op) == MEM)\n-    return 1;\n-#endif\n-  return 0;\n-}\n-\n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -2619,17 +2508,3 @@ sh_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n     }\n   return 0;\n }\n-\n-\n-\n-/* Turn this on to recognise shift insns which aren't supported in the\n-   hardware.  This will allow the combiner to notice more patterns,\n-   but the down side is that the asm outputter will have to emit\n-   several instructions for each shift which isn't possible in the\n-   hardware, this makes scheduling perform badly .*/ \n-\n-int fake_shift()\n-{\n-  return 0;\n-}\n-"}]}