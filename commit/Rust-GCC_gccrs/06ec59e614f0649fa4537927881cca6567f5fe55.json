{"sha": "06ec59e614f0649fa4537927881cca6567f5fe55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZlYzU5ZTYxNGYwNjQ5ZmE0NTM3OTI3ODgxY2NhNjU2N2Y1ZmU1NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-26T16:32:45Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-26T16:32:45Z"}, "message": "gimplify.c (gimplify_cond_expr): Use THEN_ and ELSE_ local variables.\n\n\t* gimplify.c (gimplify_cond_expr): Use THEN_ and ELSE_ local variables.\n\tUse VOID_TYPE_P for all void type tests.  Adjust TYPE variable instead\n\tof shadowing it.  Fix comments.\n\nFrom-SVN: r158737", "tree": {"sha": "7ef861be120439422a63b60f3bcdb67c22f7264b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ef861be120439422a63b60f3bcdb67c22f7264b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06ec59e614f0649fa4537927881cca6567f5fe55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ec59e614f0649fa4537927881cca6567f5fe55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ec59e614f0649fa4537927881cca6567f5fe55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ec59e614f0649fa4537927881cca6567f5fe55/comments", "author": null, "committer": null, "parents": [{"sha": "2b50b170d90098ec29674f23b18fd91fa67df39f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b50b170d90098ec29674f23b18fd91fa67df39f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b50b170d90098ec29674f23b18fd91fa67df39f"}], "stats": {"total": 84, "additions": 45, "deletions": 39}, "files": [{"sha": "7d15bf08a35ee98eb929ae70189f51ee18ac93b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec59e614f0649fa4537927881cca6567f5fe55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec59e614f0649fa4537927881cca6567f5fe55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06ec59e614f0649fa4537927881cca6567f5fe55", "patch": "@@ -1,3 +1,9 @@\n+2010-04-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gimplify.c (gimplify_cond_expr): Use THEN_ and ELSE_ local variables.\n+\tUse VOID_TYPE_P for all void type tests.  Adjust TYPE variable instead\n+\tof shadowing it.  Fix comments.\n+\n 2010-04-26  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_create_node): Set node frequency to normal.\n@@ -8,15 +14,19 @@\n \t* lto-cgraph.c (lto_output_node): Output node frequency.\n \t(input_overwrite_node): Input node frequency.\n \t* tre-ssa-loop-ivopts (computation_cost): Update.\n-\t* lto-streamer-out.c (output_function): Do not output function frequency.\n-\t* predict.c (maybe_hot_frequency_p): Update and handle functions executed once.\n+\t* lto-streamer-out.c (output_function): Do not output function\n+\tfrequency.\n+\t* predict.c (maybe_hot_frequency_p): Update and handle functions\n+\texecuted once.\n \t(cgraph_maybe_hot_edge_p): Likewise; use cgraph frequency instead of\n \tattribute lookup.\n \t(probably_never_executed_bb_p, optimize_function_for_size_p): Update.\n-\t(compute_function_frequency): Set noreturn functions to be executed once.\n+\t(compute_function_frequency): Set noreturn functions to be executed\n+\tonce.\n \t(choose_function_section): Update.\n \t* lto-streamer-in.c (input_function): Do not input function frequency.\n-\t* function.c (allocate_struct_function): Do not initialize function frequency.\n+\t* function.c (allocate_struct_function): Do not initialize function\n+\tfrequency.\n \t* function.h (function_frequency): Remove.\n \t(struct function): Remove function frequency.\n \t* ipa-profile.c (CGRAPH_NODE_FREQUENCY): Remove."}, {"sha": "2f4e12067e09897f03f00072a1011df09074a977", "filename": "gcc/gimplify.c", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ec59e614f0649fa4537927881cca6567f5fe55/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ec59e614f0649fa4537927881cca6567f5fe55/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=06ec59e614f0649fa4537927881cca6567f5fe55", "patch": "@@ -2867,71 +2867,67 @@ static enum gimplify_status\n gimplify_cond_expr (tree *expr_p, gimple_seq *pre_p, fallback_t fallback)\n {\n   tree expr = *expr_p;\n-  tree tmp, type, arm1, arm2;\n+  tree type = TREE_TYPE (expr);\n+  location_t loc = EXPR_LOCATION (expr);\n+  tree tmp, arm1, arm2;\n   enum gimplify_status ret;\n   tree label_true, label_false, label_cont;\n   bool have_then_clause_p, have_else_clause_p;\n   gimple gimple_cond;\n   enum tree_code pred_code;\n   gimple_seq seq = NULL;\n-  location_t loc = EXPR_LOCATION (*expr_p);\n-\n-  type = TREE_TYPE (expr);\n \n   /* If this COND_EXPR has a value, copy the values into a temporary within\n      the arms.  */\n-  if (! VOID_TYPE_P (type))\n+  if (!VOID_TYPE_P (type))\n     {\n+      tree then_ = TREE_OPERAND (expr, 1), else_ = TREE_OPERAND (expr, 2);\n       tree result;\n \n-      /* If an rvalue is ok or we do not require an lvalue, avoid creating\n-\t an addressable temporary.  */\n-      if (((fallback & fb_rvalue)\n-\t   || !(fallback & fb_lvalue))\n+      /* If either an rvalue is ok or we do not require an lvalue, create the\n+\t temporary.  But we cannot do that if the type is addressable.  */\n+      if (((fallback & fb_rvalue) || !(fallback & fb_lvalue))\n \t  && !TREE_ADDRESSABLE (type))\n \t{\n \t  if (gimplify_ctxp->allow_rhs_cond_expr\n \t      /* If either branch has side effects or could trap, it can't be\n \t\t evaluated unconditionally.  */\n-\t      && !TREE_SIDE_EFFECTS (TREE_OPERAND (*expr_p, 1))\n-\t      && !generic_expr_could_trap_p (TREE_OPERAND (*expr_p, 1))\n-\t      && !TREE_SIDE_EFFECTS (TREE_OPERAND (*expr_p, 2))\n-\t      && !generic_expr_could_trap_p (TREE_OPERAND (*expr_p, 2)))\n+\t      && !TREE_SIDE_EFFECTS (then_)\n+\t      && !generic_expr_could_trap_p (then_)\n+\t      && !TREE_SIDE_EFFECTS (else_)\n+\t      && !generic_expr_could_trap_p (else_))\n \t    return gimplify_pure_cond_expr (expr_p, pre_p);\n \n-\t  result = tmp = create_tmp_var (TREE_TYPE (expr), \"iftmp\");\n-\t  ret = GS_ALL_DONE;\n+\t  tmp = create_tmp_var (type, \"iftmp\");\n+\t  result = tmp;\n \t}\n+\n+      /* Otherwise, only create and copy references to the values.  */\n       else\n \t{\n-\t  tree type = build_pointer_type (TREE_TYPE (expr));\n+\t  type = build_pointer_type (type);\n \n-\t  if (TREE_TYPE (TREE_OPERAND (expr, 1)) != void_type_node)\n-\t    TREE_OPERAND (expr, 1) =\n-\t      build_fold_addr_expr_loc (loc, TREE_OPERAND (expr, 1));\n+\t  if (!VOID_TYPE_P (TREE_TYPE (then_)))\n+\t    then_ = build_fold_addr_expr_loc (loc, then_);\n \n-\t  if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n-\t    TREE_OPERAND (expr, 2) =\n-\t      build_fold_addr_expr_loc (loc, TREE_OPERAND (expr, 2));\n+\t  if (!VOID_TYPE_P (TREE_TYPE (else_)))\n+\t    else_ = build_fold_addr_expr_loc (loc, else_);\n+ \n+\t  expr\n+\t    = build3 (COND_EXPR, type, TREE_OPERAND (expr, 0), then_, else_);\n \n \t  tmp = create_tmp_var (type, \"iftmp\");\n-\n-\t  expr = build3 (COND_EXPR, void_type_node, TREE_OPERAND (expr, 0),\n-\t\t\t TREE_OPERAND (expr, 1), TREE_OPERAND (expr, 2));\n-\n \t  result = build_fold_indirect_ref_loc (loc, tmp);\n \t}\n \n-      /* Build the then clause, 't1 = a;'.  But don't build an assignment\n-\t if this branch is void; in C++ it can be, if it's a throw.  */\n-      if (TREE_TYPE (TREE_OPERAND (expr, 1)) != void_type_node)\n-\tTREE_OPERAND (expr, 1)\n-\t  = build2 (MODIFY_EXPR, TREE_TYPE (tmp), tmp, TREE_OPERAND (expr, 1));\n+      /* Build the new then clause, `tmp = then_;'.  But don't build the\n+\t assignment if the value is void; in C++ it can be if it's a throw.  */\n+      if (!VOID_TYPE_P (TREE_TYPE (then_)))\n+\tTREE_OPERAND (expr, 1) = build2 (MODIFY_EXPR, type, tmp, then_);\n \n-      /* Build the else clause, 't1 = b;'.  */\n-      if (TREE_TYPE (TREE_OPERAND (expr, 2)) != void_type_node)\n-\tTREE_OPERAND (expr, 2)\n-\t  = build2 (MODIFY_EXPR, TREE_TYPE (tmp), tmp, TREE_OPERAND (expr, 2));\n+      /* Similarly, build the new else clause, `tmp = else_;'.  */\n+      if (!VOID_TYPE_P (TREE_TYPE (else_)))\n+\tTREE_OPERAND (expr, 2) = build2 (MODIFY_EXPR, type, tmp, else_);\n \n       TREE_TYPE (expr) = void_type_node;\n       recalculate_side_effects (expr);"}]}