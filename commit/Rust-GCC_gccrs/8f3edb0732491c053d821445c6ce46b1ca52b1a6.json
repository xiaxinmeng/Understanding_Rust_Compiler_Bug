{"sha": "8f3edb0732491c053d821445c6ce46b1ca52b1a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYzZWRiMDczMjQ5MWMwNTNkODIxNDQ1YzZjZTQ2YjFjYTUyYjFhNg==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2016-10-10T13:45:17Z"}, "committer": {"name": "Jiong Wang", "email": "jiwang@gcc.gnu.org", "date": "2016-10-10T13:45:17Z"}, "message": "[2/4] ARMv8.2-A testsuite for new data movement intrinsics\n\ngcc/testsuite/\n\n\t* gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h (FP16_SUPPORTED):\n\tEnable AArch64.\n\t* gcc.target/aarch64/advsimd-intrinsics/vdup_lane.c: Add support for\n\tvdup*_laneq.\n\t* gcc.target/aarch64/advsimd-intrinsics/vduph_lane.c: New.\n\t* gcc.target/aarch64/advsimd-intrinsics/vtrn_half.c: New.\n\t* gcc.target/aarch64/advsimd-intrinsics/vuzp_half.c: New.\n\t* gcc.target/aarch64/advsimd-intrinsics/vzip_half.c: New.\n\nFrom-SVN: r240922", "tree": {"sha": "4db963b3951db231388e257fe93efc0cb68350a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db963b3951db231388e257fe93efc0cb68350a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f3edb0732491c053d821445c6ce46b1ca52b1a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f3edb0732491c053d821445c6ce46b1ca52b1a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f3edb0732491c053d821445c6ce46b1ca52b1a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f3edb0732491c053d821445c6ce46b1ca52b1a6/comments", "author": null, "committer": null, "parents": [{"sha": "6e49f922a6e75f37ea93a4592cc8f757b9650efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e49f922a6e75f37ea93a4592cc8f757b9650efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e49f922a6e75f37ea93a4592cc8f757b9650efb"}], "stats": {"total": 1068, "additions": 1053, "deletions": 15}, "files": [{"sha": "faa53e388efefe986bbc4bd26d7d49f7912a9bd4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f3edb0732491c053d821445c6ce46b1ca52b1a6", "patch": "@@ -1,3 +1,14 @@\n+2016-10-10  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h (FP16_SUPPORTED):\n+\tEnable AArch64.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vdup_lane.c: Add support for\n+\tvdup*_laneq.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vduph_lane.c: New.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vtrn_half.c: New.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vuzp_half.c: New.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vzip_half.c: New.\n+\n 2016-10-10  Matthew Wahab  <matthew.wahab@arm.com>\n \t    Jiong Wang  <jiong.wang@arm.com>\n "}, {"sha": "462141586b3db7c5256c74b08fa0449210634226", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Farm-neon-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Farm-neon-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Farm-neon-ref.h?ref=8f3edb0732491c053d821445c6ce46b1ca52b1a6", "patch": "@@ -17,9 +17,8 @@ extern void *memcpy(void *, const void *, size_t);\n extern size_t strlen(const char *);\n \n /* Helper macro to select FP16 tests.  */\n-#if (!defined (__aarch64__)\t\t\t\t\t\t\\\n-     && (defined (__ARM_FP16_FORMAT_IEEE)\t\t\t\t\\\n-\t || defined (__ARM_FP16_FORMAT_ALTERNATIVE)))\n+#if (defined (__ARM_FP16_FORMAT_IEEE) \\\n+     || defined (__ARM_FP16_FORMAT_ALTERNATIVE))\n #define FP16_SUPPORTED (1)\n #else\n #undef FP16_SUPPORTED\n@@ -520,17 +519,6 @@ static void clean_results (void)\n /* Helpers to initialize vectors.  */\n #define VDUP(VAR, Q, T1, T2, W, N, V)\t\t\t\\\n   VECT_VAR(VAR, T1, W, N) = vdup##Q##_n_##T2##W(V)\n-#if (defined (__aarch64__)\t\t\t\t\t\t\\\n-     && (defined (__ARM_FP16_FORMAT_IEEE)\t\t\t\t\\\n-\t || defined (__ARM_FP16_FORMAT_ALTERNATIVE)))\n-/* Work around that there is no vdup_n_f16 intrinsic.  */\n-#define vdup_n_f16(VAL)\t\t\\\n-  __extension__\t\t\t\\\n-    ({\t\t\t\t\\\n-      float16_t f = VAL;\t\\\n-      vld1_dup_f16(&f);\t\t\\\n-    })\n-#endif\n \n #define VSET_LANE(VAR, Q, T1, T2, W, N, L, V)\t\t\t\t\\\n   VECT_VAR(VAR, T1, W, N) = vset##Q##_lane_##T2##W(V,\t\t\t\\"}, {"sha": "5d0dba36e297ffa6bccc956d0bc9e0c8ca793626", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdup_lane.c", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvdup_lane.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvdup_lane.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvdup_lane.c?ref=8f3edb0732491c053d821445c6ce46b1ca52b1a6", "patch": "@@ -56,7 +56,7 @@ VECT_VAR_DECL (expected, hfloat, 16, 8) [] = { 0xca80, 0xca80,\n VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1700000, 0xc1700000,\n \t\t\t\t\t   0xc1700000, 0xc1700000 };\n \n-#define TEST_MSG \"VDUP_LANE/VDUP_LANEQ\"\n+#define TEST_MSG \"VDUP_LANE/VDUPQ_LANE\"\n void exec_vdup_lane (void)\n {\n   /* Basic test: vec1=vdup_lane(vec2, lane), then store the result.  */\n@@ -114,6 +114,123 @@ void exec_vdup_lane (void)\n #else\n   CHECK_RESULTS_NO_FP16 (TEST_MSG, \"\");\n #endif\n+\n+#if defined (__aarch64__)\n+\n+#undef TEST_MSG\n+#define TEST_MSG \"VDUP_LANEQ/VDUPQ_LANEQ\"\n+\n+  /* Expected results for vdup*_laneq tests.  */\n+VECT_VAR_DECL(expected2,int,8,8) [] = { 0xfd, 0xfd, 0xfd, 0xfd,\n+\t\t\t\t\t0xfd, 0xfd, 0xfd, 0xfd };\n+VECT_VAR_DECL(expected2,int,16,4) [] = { 0xfff2, 0xfff2, 0xfff2, 0xfff2 };\n+VECT_VAR_DECL(expected2,int,32,2) [] = { 0xfffffff1, 0xfffffff1 };\n+VECT_VAR_DECL(expected2,int,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected2,uint,8,8) [] = { 0xff, 0xff, 0xff, 0xff,\n+\t\t\t\t\t 0xff, 0xff, 0xff, 0xff };\n+VECT_VAR_DECL(expected2,uint,16,4) [] = { 0xfff3, 0xfff3, 0xfff3, 0xfff3 };\n+VECT_VAR_DECL(expected2,uint,32,2) [] = { 0xfffffff1, 0xfffffff1 };\n+VECT_VAR_DECL(expected2,uint,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected2,poly,8,8) [] = { 0xf7, 0xf7, 0xf7, 0xf7,\n+\t\t\t\t\t 0xf7, 0xf7, 0xf7, 0xf7 };\n+VECT_VAR_DECL(expected2,poly,16,4) [] = { 0xfff3, 0xfff3, 0xfff3, 0xfff3 };\n+VECT_VAR_DECL(expected2,hfloat,32,2) [] = { 0xc1700000, 0xc1700000 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected2, hfloat, 16, 4) [] = { 0xca80, 0xca80,\n+\t\t\t\t\t\t0xca80, 0xca80 };\n+#endif\n+VECT_VAR_DECL(expected2,int,8,16) [] = { 0xfb, 0xfb, 0xfb, 0xfb,\n+\t\t\t\t\t 0xfb, 0xfb, 0xfb, 0xfb,\n+\t\t\t\t\t 0xfb, 0xfb, 0xfb, 0xfb,\n+\t\t\t\t\t 0xfb, 0xfb, 0xfb, 0xfb };\n+VECT_VAR_DECL(expected2,int,16,8) [] = { 0xfff7, 0xfff7, 0xfff7, 0xfff7,\n+\t\t\t\t\t 0xfff7, 0xfff7, 0xfff7, 0xfff7 };\n+VECT_VAR_DECL(expected2,int,32,4) [] = { 0xfffffff1, 0xfffffff1,\n+\t\t\t\t\t 0xfffffff1, 0xfffffff1 };\n+VECT_VAR_DECL(expected2,int,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected2,uint,8,16) [] = { 0xf5, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t  0xf5, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t  0xf5, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t  0xf5, 0xf5, 0xf5, 0xf5 };\n+VECT_VAR_DECL(expected2,uint,16,8) [] = { 0xfff1, 0xfff1, 0xfff1, 0xfff1,\n+\t\t\t\t\t  0xfff1, 0xfff1, 0xfff1, 0xfff1 };\n+VECT_VAR_DECL(expected2,uint,32,4) [] = { 0xfffffff0, 0xfffffff0,\n+\t\t\t\t\t  0xfffffff0, 0xfffffff0 };\n+VECT_VAR_DECL(expected2,uint,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t  0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected2,poly,8,16) [] = { 0xf5, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t  0xf5, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t  0xf5, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t  0xf5, 0xf5, 0xf5, 0xf5 };\n+VECT_VAR_DECL(expected2,poly,16,8) [] = { 0xfff1, 0xfff1, 0xfff1, 0xfff1,\n+\t\t\t\t\t  0xfff1, 0xfff1, 0xfff1, 0xfff1 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected2, hfloat, 16, 8) [] = { 0xc880, 0xc880,\n+\t\t\t\t\t\t0xc880, 0xc880,\n+\t\t\t\t\t\t0xc880, 0xc880,\n+\t\t\t\t\t\t0xc880, 0xc880 };\n+#endif\n+VECT_VAR_DECL(expected2,hfloat,32,4) [] = { 0xc1700000, 0xc1700000,\n+\t\t\t\t\t    0xc1700000, 0xc1700000 };\n+\n+  /* Clean all results for vdup*_laneq tests.  */\n+  clean_results ();\n+  /* Basic test: vec1=vdup_lane(vec2, lane), then store the result.  */\n+#define TEST_VDUP_LANEQ(Q, T1, T2, W, N, N2, L)\t\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n+    vdup##Q##_laneq_##T2##W(VECT_VAR(vector, T1, W, N2), L);\t\t\\\n+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n+\n+  /* Input vector can only have 64 bits.  */\n+  DECL_VARIABLE_128BITS_VARIANTS(vector);\n+\n+  clean_results ();\n+\n+  TEST_MACRO_128BITS_VARIANTS_2_5(VLOAD, vector, buffer);\n+#if defined (FP16_SUPPORTED)\n+  VLOAD(vector, buffer, q, float, f, 16, 8);\n+#endif\n+  VLOAD(vector, buffer, q, float, f, 32, 4);\n+\n+  /* Choose lane arbitrarily.  */\n+  TEST_VDUP_LANEQ(, int, s, 8, 8, 16, 13);\n+  TEST_VDUP_LANEQ(, int, s, 16, 4, 8, 2);\n+  TEST_VDUP_LANEQ(, int, s, 32, 2, 4, 1);\n+  TEST_VDUP_LANEQ(, int, s, 64, 1, 2, 0);\n+  TEST_VDUP_LANEQ(, uint, u, 8, 8, 16, 15);\n+  TEST_VDUP_LANEQ(, uint, u, 16, 4, 8, 3);\n+  TEST_VDUP_LANEQ(, uint, u, 32, 2, 4, 1);\n+  TEST_VDUP_LANEQ(, uint, u, 64, 1, 2, 0);\n+  TEST_VDUP_LANEQ(, poly, p, 8, 8, 16, 7);\n+  TEST_VDUP_LANEQ(, poly, p, 16, 4, 8, 3);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VDUP_LANEQ(, float, f, 16, 4, 8, 3);\n+#endif\n+  TEST_VDUP_LANEQ(, float, f, 32, 2, 4, 1);\n+\n+  TEST_VDUP_LANEQ(q, int, s, 8, 16, 16, 11);\n+  TEST_VDUP_LANEQ(q, int, s, 16, 8, 8, 7);\n+  TEST_VDUP_LANEQ(q, int, s, 32, 4, 4, 1);\n+  TEST_VDUP_LANEQ(q, int, s, 64, 2, 2, 0);\n+  TEST_VDUP_LANEQ(q, uint, u, 8, 16, 16, 5);\n+  TEST_VDUP_LANEQ(q, uint, u, 16, 8, 8, 1);\n+  TEST_VDUP_LANEQ(q, uint, u, 32, 4, 4, 0);\n+  TEST_VDUP_LANEQ(q, uint, u, 64, 2, 2, 0);\n+  TEST_VDUP_LANEQ(q, poly, p, 8, 16, 16, 5);\n+  TEST_VDUP_LANEQ(q, poly, p, 16, 8, 8, 1);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VDUP_LANEQ(q, float, f, 16, 8, 8, 7);\n+#endif\n+  TEST_VDUP_LANEQ(q, float, f, 32, 4, 4, 1);\n+\n+  CHECK_RESULTS_NAMED (TEST_MSG, expected2, \"\");\n+#if defined (FP16_SUPPORTED)\n+  CHECK_FP(TEST_MSG, float, 16, 4, PRIx16, expected2, \"\");\n+  CHECK_FP(TEST_MSG, float, 16, 8, PRIx16, expected2, \"\");\n+#endif\n+\n+#endif /* __aarch64__.  */\n }\n \n int main (void)"}, {"sha": "c9d553ac5f7ce8d5d18af366f2ff32ac1533c7cf", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vduph_lane.c", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvduph_lane.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvduph_lane.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvduph_lane.c?ref=8f3edb0732491c053d821445c6ce46b1ca52b1a6", "patch": "@@ -0,0 +1,137 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { arm*-*-* } } */\n+\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+#define A -16\n+#define B -15\n+#define C -14\n+#define D -13\n+#define E -12\n+#define F -11\n+#define G -10\n+#define H -9\n+\n+#define F16_C(a) ((__fp16) a)\n+#define AF F16_C (A)\n+#define BF F16_C (B)\n+#define CF F16_C (C)\n+#define DF F16_C (D)\n+#define EF F16_C (E)\n+#define FF F16_C (F)\n+#define GF F16_C (G)\n+#define HF F16_C (H)\n+\n+#define S16_C(a) ((int16_t) a)\n+#define AS S16_C (A)\n+#define BS S16_C (B)\n+#define CS S16_C (C)\n+#define DS S16_C (D)\n+#define ES S16_C (E)\n+#define FS S16_C (F)\n+#define GS S16_C (G)\n+#define HS S16_C (H)\n+\n+#define U16_C(a) ((int16_t) a)\n+#define AU U16_C (A)\n+#define BU U16_C (B)\n+#define CU U16_C (C)\n+#define DU U16_C (D)\n+#define EU U16_C (E)\n+#define FU U16_C (F)\n+#define GU U16_C (G)\n+#define HU U16_C (H)\n+\n+#define P16_C(a) ((poly16_t) a)\n+#define AP P16_C (A)\n+#define BP P16_C (B)\n+#define CP P16_C (C)\n+#define DP P16_C (D)\n+#define EP P16_C (E)\n+#define FP P16_C (F)\n+#define GP P16_C (G)\n+#define HP P16_C (H)\n+\n+/* Expected results for vduph_lane.  */\n+float16_t expected_f16 = AF;\n+int16_t expected_s16 = DS;\n+uint16_t expected_u16 = BU;\n+poly16_t expected_p16 = CP;\n+\n+/* Expected results for vduph_laneq.  */\n+float16_t expected_q_f16 = EF;\n+int16_t expected_q_s16 = BS;\n+uint16_t expected_q_u16 = GU;\n+poly16_t expected_q_p16 = FP;\n+\n+void exec_vduph_lane_f16 (void)\n+{\n+  /* vduph_lane.  */\n+  DECL_VARIABLE(vsrc, float, 16, 4);\n+  DECL_VARIABLE(vsrc, int, 16, 4);\n+  DECL_VARIABLE(vsrc, uint, 16, 4);\n+  DECL_VARIABLE(vsrc, poly, 16, 4);\n+  VECT_VAR_DECL (buf_src, float, 16, 4) [] = {AF, BF, CF, DF};\n+  VECT_VAR_DECL (buf_src, int, 16, 4) [] = {AS, BS, CS, DS};\n+  VECT_VAR_DECL (buf_src, uint, 16, 4) [] = {AU, BU, CU, DU};\n+  VECT_VAR_DECL (buf_src, poly, 16, 4) [] = {AP, BP, CP, DP};\n+  VLOAD (vsrc, buf_src, , int, s, 16, 4);\n+  VLOAD (vsrc, buf_src, , float, f, 16, 4);\n+  VLOAD (vsrc, buf_src, , uint, u, 16, 4);\n+  VLOAD (vsrc, buf_src, , poly, p, 16, 4);\n+\n+  float16_t res_f = vduph_lane_f16 (VECT_VAR (vsrc, float, 16, 4), 0);\n+  if (* (unsigned short *) &res_f != * (unsigned short *) &expected_f16)\n+    abort ();\n+\n+  int16_t res_s = vduph_lane_s16 (VECT_VAR (vsrc, int, 16, 4), 3);\n+  if (* (unsigned short *) &res_s != * (unsigned short *) &expected_s16)\n+    abort ();\n+\n+  uint16_t res_u = vduph_lane_u16 (VECT_VAR (vsrc, uint, 16, 4), 1);\n+  if (* (unsigned short *) &res_u != * (unsigned short *) &expected_u16)\n+    abort ();\n+\n+  poly16_t res_p = vduph_lane_p16 (VECT_VAR (vsrc, poly, 16, 4), 2);\n+  if (* (unsigned short *) &res_p != * (unsigned short *) &expected_p16)\n+    abort ();\n+\n+  /* vduph_laneq.  */\n+  DECL_VARIABLE(vsrc, float, 16, 8);\n+  DECL_VARIABLE(vsrc, int, 16, 8);\n+  DECL_VARIABLE(vsrc, uint, 16, 8);\n+  DECL_VARIABLE(vsrc, poly, 16, 8);\n+  VECT_VAR_DECL (buf_src, float, 16, 8) [] = {AF, BF, CF, DF, EF, FF, GF, HF};\n+  VECT_VAR_DECL (buf_src, int, 16, 8) [] = {AS, BS, CS, DS, ES, FS, GS, HS};\n+  VECT_VAR_DECL (buf_src, uint, 16, 8) [] = {AU, BU, CU, DU, EU, FU, GU, HU};\n+  VECT_VAR_DECL (buf_src, poly, 16, 8) [] = {AP, BP, CP, DP, EP, FP, GP, HP};\n+  VLOAD (vsrc, buf_src, q, int, s, 16, 8);\n+  VLOAD (vsrc, buf_src, q, float, f, 16, 8);\n+  VLOAD (vsrc, buf_src, q, uint, u, 16, 8);\n+  VLOAD (vsrc, buf_src, q, poly, p, 16, 8);\n+\n+  res_f = vduph_laneq_f16 (VECT_VAR (vsrc, float, 16, 8), 4);\n+  if (* (unsigned short *) &res_f != * (unsigned short *) &expected_q_f16)\n+    abort ();\n+\n+  res_s = vduph_laneq_s16 (VECT_VAR (vsrc, int, 16, 8), 1);\n+  if (* (unsigned short *) &res_s != * (unsigned short *) &expected_q_s16)\n+    abort ();\n+\n+  res_u = vduph_laneq_u16 (VECT_VAR (vsrc, uint, 16, 8), 6);\n+  if (* (unsigned short *) &res_u != * (unsigned short *) &expected_q_u16)\n+    abort ();\n+\n+  res_p = vduph_laneq_p16 (VECT_VAR (vsrc, poly, 16, 8), 5);\n+  if (* (unsigned short *) &res_p != * (unsigned short *) &expected_q_p16)\n+    abort ();\n+}\n+\n+int\n+main (void)\n+{\n+  exec_vduph_lane_f16 ();\n+  return 0;\n+}"}, {"sha": "63f820fbf5a98561a5160465069ed0b54dda9b7a", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtrn_half.c", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvtrn_half.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvtrn_half.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvtrn_half.c?ref=8f3edb0732491c053d821445c6ce46b1ca52b1a6", "patch": "@@ -0,0 +1,263 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { arm*-*-* } } */\n+\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf0, 0x11, 0xf2, 0x11,\n+\t\t\t\t       0xf4, 0x11, 0xf6, 0x11 };\n+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff0, 0x22, 0xfff2, 0x22 };\n+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffff0, 0x33 };\n+VECT_VAR_DECL(expected,int,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xf0, 0x55, 0xf2, 0x55,\n+\t\t\t\t\t0xf4, 0x55, 0xf6, 0x55 };\n+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfff0, 0x66, 0xfff2, 0x66 };\n+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff0, 0x77 };\n+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf0, 0x55, 0xf2, 0x55,\n+\t\t\t\t\t0xf4, 0x55, 0xf6, 0x55 };\n+VECT_VAR_DECL(expected,poly,16,4) [] = { 0xfff0, 0x66, 0xfff2, 0x66 };\n+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1800000, 0x42066666 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected, hfloat, 16, 4) [] = { 0xcc00, 0x4b4d,\n+\t\t\t\t\t       0xcb00, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected,int,8,16) [] = { 0xf0, 0x11, 0xf2, 0x11,\n+\t\t\t\t\t0xf4, 0x11, 0xf6, 0x11,\n+\t\t\t\t\t0xf8, 0x11, 0xfa, 0x11,\n+\t\t\t\t\t0xfc, 0x11, 0xfe, 0x11 };\n+VECT_VAR_DECL(expected,int,16,8) [] = { 0xfff0, 0x22, 0xfff2, 0x22,\n+\t\t\t\t\t0xfff4, 0x22, 0xfff6, 0x22 };\n+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffff0, 0x33,\n+\t\t\t\t\t0xfffffff2, 0x33 };\n+VECT_VAR_DECL(expected,int,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t0x44 };\n+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xf0, 0x55, 0xf2, 0x55,\n+\t\t\t\t\t 0xf4, 0x55, 0xf6, 0x55,\n+\t\t\t\t\t 0xf8, 0x55, 0xfa, 0x55,\n+\t\t\t\t\t 0xfc, 0x55, 0xfe, 0x55 };\n+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfff0, 0x66, 0xfff2, 0x66,\n+\t\t\t\t\t 0xfff4, 0x66, 0xfff6, 0x66 };\n+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff0, 0x77,\n+\t\t\t\t\t 0xfffffff2, 0x77 };\n+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t 0x88 };\n+VECT_VAR_DECL(expected,poly,8,16) [] = { 0xf0, 0x55, 0xf2, 0x55,\n+\t\t\t\t\t 0xf4, 0x55, 0xf6, 0x55,\n+\t\t\t\t\t 0xf8, 0x55, 0xfa, 0x55,\n+\t\t\t\t\t 0xfc, 0x55, 0xfe, 0x55 };\n+VECT_VAR_DECL(expected,poly,16,8) [] = { 0xfff0, 0x66, 0xfff2, 0x66,\n+\t\t\t\t\t 0xfff4, 0x66, 0xfff6, 0x66 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected, hfloat, 16, 8) [] = { 0xcc00, 0x4b4d,\n+\t\t\t\t\t       0xcb00, 0x4b4d,\n+\t\t\t\t\t       0xca00, 0x4b4d,\n+\t\t\t\t\t       0xc900, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1800000, 0x42073333,\n+\t\t\t\t\t   0xc1600000, 0x42073333 };\n+\n+#define TEST_MSG \"VTRN1\"\n+void exec_vtrn_half (void)\n+{\n+#define TEST_VTRN(PART, Q, T1, T2, W, N)\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\\\n+    vtrn##PART##Q##_##T2##W(VECT_VAR(vector, T1, W, N),\t\\\n+\t\t       VECT_VAR(vector2, T1, W, N));\t\\\n+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n+\n+#define TEST_VTRN1(Q, T1, T2, W, N) TEST_VTRN(1, Q, T1, T2, W, N)\n+\n+  /* Input vector can only have 64 bits.  */\n+  DECL_VARIABLE_ALL_VARIANTS(vector);\n+  DECL_VARIABLE_ALL_VARIANTS(vector2);\n+  DECL_VARIABLE(vector, float, 64, 2);\n+  DECL_VARIABLE(vector2, float, 64, 2);\n+\n+  DECL_VARIABLE_ALL_VARIANTS(vector_res);\n+  DECL_VARIABLE(vector_res, float, 64, 2);\n+\n+  clean_results ();\n+  /* We don't have vtrn1_T64x1, so set expected to the clean value.  */\n+  CLEAN(expected, int, 64, 1);\n+  CLEAN(expected, uint, 64, 1);\n+\n+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);\n+#if defined (FP16_SUPPORTED)\n+  VLOAD(vector, buffer, , float, f, 16, 4);\n+  VLOAD(vector, buffer, q, float, f, 16, 8);\n+#endif\n+  VLOAD(vector, buffer, , float, f, 32, 2);\n+  VLOAD(vector, buffer, q, float, f, 32, 4);\n+  VLOAD(vector, buffer, q, float, f, 64, 2);\n+\n+  /* Choose arbitrary initialization values.  */\n+  VDUP(vector2, , int, s, 8, 8, 0x11);\n+  VDUP(vector2, , int, s, 16, 4, 0x22);\n+  VDUP(vector2, , int, s, 32, 2, 0x33);\n+  VDUP(vector2, , uint, u, 8, 8, 0x55);\n+  VDUP(vector2, , uint, u, 16, 4, 0x66);\n+  VDUP(vector2, , uint, u, 32, 2, 0x77);\n+  VDUP(vector2, , poly, p, 8, 8, 0x55);\n+  VDUP(vector2, , poly, p, 16, 4, 0x66);\n+#if defined (FP16_SUPPORTED)\n+  VDUP (vector2, , float, f, 16, 4, 14.6f);   /* 14.6f is 0x4b4d.  */\n+#endif\n+  VDUP(vector2, , float, f, 32, 2, 33.6f);\n+\n+  VDUP(vector2, q, int, s, 8, 16, 0x11);\n+  VDUP(vector2, q, int, s, 16, 8, 0x22);\n+  VDUP(vector2, q, int, s, 32, 4, 0x33);\n+  VDUP(vector2, q, int, s, 64, 2, 0x44);\n+  VDUP(vector2, q, uint, u, 8, 16, 0x55);\n+  VDUP(vector2, q, uint, u, 16, 8, 0x66);\n+  VDUP(vector2, q, uint, u, 32, 4, 0x77);\n+  VDUP(vector2, q, uint, u, 64, 2, 0x88);\n+  VDUP(vector2, q, poly, p, 8, 16, 0x55);\n+  VDUP(vector2, q, poly, p, 16, 8, 0x66);\n+#if defined (FP16_SUPPORTED)\n+  VDUP (vector2, q, float, f, 16, 8, 14.6f);\n+#endif\n+  VDUP(vector2, q, float, f, 32, 4, 33.8f);\n+  VDUP(vector2, q, float, f, 64, 2, 33.8f);\n+\n+  TEST_VTRN1(, int, s, 8, 8);\n+  TEST_VTRN1(, int, s, 16, 4);\n+  TEST_VTRN1(, int, s, 32, 2);\n+  TEST_VTRN1(, uint, u, 8, 8);\n+  TEST_VTRN1(, uint, u, 16, 4);\n+  TEST_VTRN1(, uint, u, 32, 2);\n+  TEST_VTRN1(, poly, p, 8, 8);\n+  TEST_VTRN1(, poly, p, 16, 4);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VTRN1(, float, f, 16, 4);\n+#endif\n+  TEST_VTRN1(, float, f, 32, 2);\n+\n+  TEST_VTRN1(q, int, s, 8, 16);\n+  TEST_VTRN1(q, int, s, 16, 8);\n+  TEST_VTRN1(q, int, s, 32, 4);\n+  TEST_VTRN1(q, int, s, 64, 2);\n+  TEST_VTRN1(q, uint, u, 8, 16);\n+  TEST_VTRN1(q, uint, u, 16, 8);\n+  TEST_VTRN1(q, uint, u, 32, 4);\n+  TEST_VTRN1(q, uint, u, 64, 2);\n+  TEST_VTRN1(q, poly, p, 8, 16);\n+  TEST_VTRN1(q, poly, p, 16, 8);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VTRN1(q, float, f, 16, 8);\n+#endif\n+  TEST_VTRN1(q, float, f, 32, 4);\n+  TEST_VTRN1(q, float, f, 64, 2);\n+\n+#if defined (FP16_SUPPORTED)\n+  CHECK_RESULTS (TEST_MSG, \"\");\n+#else\n+  CHECK_RESULTS_NO_FP16 (TEST_MSG, \"\");\n+#endif\n+\n+#undef TEST_MSG\n+#define TEST_MSG \"VTRN2\"\n+\n+#define TEST_VTRN2(Q, T1, T2, W, N) TEST_VTRN(2, Q, T1, T2, W, N)\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected2,int,8,8) [] = { 0xf1, 0x11, 0xf3, 0x11,\n+\t\t\t\t\t0xf5, 0x11, 0xf7, 0x11 };\n+VECT_VAR_DECL(expected2,int,16,4) [] = { 0xfff1, 0x22, 0xfff3, 0x22 };\n+VECT_VAR_DECL(expected2,int,32,2) [] = { 0xfffffff1, 0x33 };\n+VECT_VAR_DECL(expected2,int,64,1) [] = { 0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected2,uint,8,8) [] = { 0xf1, 0x55, 0xf3, 0x55,\n+\t\t\t\t\t 0xf5, 0x55, 0xf7, 0x55 };\n+VECT_VAR_DECL(expected2,uint,16,4) [] = { 0xfff1, 0x66, 0xfff3, 0x66 };\n+VECT_VAR_DECL(expected2,uint,32,2) [] = { 0xfffffff1, 0x77 };\n+VECT_VAR_DECL(expected2,uint,64,1) [] = { 0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected2,poly,8,8) [] = { 0xf1, 0x55, 0xf3, 0x55,\n+\t\t\t\t\t 0xf5, 0x55, 0xf7, 0x55 };\n+VECT_VAR_DECL(expected2,poly,16,4) [] = { 0xfff1, 0x66, 0xfff3, 0x66 };\n+VECT_VAR_DECL(expected2,hfloat,32,2) [] = { 0xc1700000, 0x42066666 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected2, hfloat, 16, 4) [] = { 0xcb80, 0x4b4d,\n+\t\t\t\t\t\t0xca80, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected2,int,8,16) [] = { 0xf1, 0x11, 0xf3, 0x11,\n+\t\t\t\t\t 0xf5, 0x11, 0xf7, 0x11,\n+\t\t\t\t\t 0xf9, 0x11, 0xfb, 0x11,\n+\t\t\t\t\t 0xfd, 0x11, 0xff, 0x11 };\n+VECT_VAR_DECL(expected2,int,16,8) [] = { 0xfff1, 0x22, 0xfff3, 0x22,\n+\t\t\t\t\t 0xfff5, 0x22, 0xfff7, 0x22 };\n+VECT_VAR_DECL(expected2,int,32,4) [] = { 0xfffffff1, 0x33,\n+\t\t\t\t\t 0xfffffff3, 0x33 };\n+VECT_VAR_DECL(expected2,int,64,2) [] = { 0xfffffffffffffff1,\n+\t\t\t\t\t 0x44 };\n+VECT_VAR_DECL(expected2,uint,8,16) [] = { 0xf1, 0x55, 0xf3, 0x55,\n+\t\t\t\t\t  0xf5, 0x55, 0xf7, 0x55,\n+\t\t\t\t\t  0xf9, 0x55, 0xfb, 0x55,\n+\t\t\t\t\t  0xfd, 0x55, 0xff, 0x55 };\n+VECT_VAR_DECL(expected2,uint,16,8) [] = { 0xfff1, 0x66, 0xfff3, 0x66,\n+\t\t\t\t\t  0xfff5, 0x66, 0xfff7, 0x66 };\n+VECT_VAR_DECL(expected2,uint,32,4) [] = { 0xfffffff1, 0x77,\n+\t\t\t\t\t  0xfffffff3, 0x77 };\n+VECT_VAR_DECL(expected2,uint,64,2) [] = { 0xfffffffffffffff1,\n+\t\t\t\t\t  0x88 };\n+VECT_VAR_DECL(expected2,poly,8,16) [] = { 0xf1, 0x55, 0xf3, 0x55,\n+\t\t\t\t\t  0xf5, 0x55, 0xf7, 0x55,\n+\t\t\t\t\t  0xf9, 0x55, 0xfb, 0x55,\n+\t\t\t\t\t  0xfd, 0x55, 0xff, 0x55 };\n+VECT_VAR_DECL(expected2,poly,16,8) [] = { 0xfff1, 0x66, 0xfff3, 0x66,\n+\t\t\t\t\t  0xfff5, 0x66, 0xfff7, 0x66 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected2, hfloat, 16, 8) [] = { 0xcb80, 0x4b4d,\n+\t\t\t\t\t\t0xca80, 0x4b4d,\n+\t\t\t\t\t\t0xc980, 0x4b4d,\n+\t\t\t\t\t\t0xc880, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected2,hfloat,32,4) [] = { 0xc1700000, 0x42073333,\n+\t\t\t\t\t    0xc1500000, 0x42073333 };\n+  clean_results ();\n+  CLEAN(expected2, int, 64, 1);\n+  CLEAN(expected2, uint, 64, 1);\n+\n+  TEST_VTRN2(, int, s, 8, 8);\n+  TEST_VTRN2(, int, s, 16, 4);\n+  TEST_VTRN2(, int, s, 32, 2);\n+  TEST_VTRN2(, uint, u, 8, 8);\n+  TEST_VTRN2(, uint, u, 16, 4);\n+  TEST_VTRN2(, uint, u, 32, 2);\n+  TEST_VTRN2(, poly, p, 8, 8);\n+  TEST_VTRN2(, poly, p, 16, 4);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VTRN2(, float, f, 16, 4);\n+#endif\n+  TEST_VTRN2(, float, f, 32, 2);\n+\n+  TEST_VTRN2(q, int, s, 8, 16);\n+  TEST_VTRN2(q, int, s, 16, 8);\n+  TEST_VTRN2(q, int, s, 32, 4);\n+  TEST_VTRN2(q, int, s, 64, 2);\n+  TEST_VTRN2(q, uint, u, 8, 16);\n+  TEST_VTRN2(q, uint, u, 16, 8);\n+  TEST_VTRN2(q, uint, u, 32, 4);\n+  TEST_VTRN2(q, uint, u, 64, 2);\n+  TEST_VTRN2(q, poly, p, 8, 16);\n+  TEST_VTRN2(q, poly, p, 16, 8);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VTRN2(q, float, f, 16, 8);\n+#endif\n+  TEST_VTRN2(q, float, f, 32, 4);\n+  TEST_VTRN2(q, float, f, 64, 2);\n+\n+  CHECK_RESULTS_NAMED (TEST_MSG, expected2, \"\");\n+#if defined (FP16_SUPPORTED)\n+  CHECK_FP(TEST_MSG, float, 16, 4, PRIx16, expected2, \"\");\n+  CHECK_FP(TEST_MSG, float, 16, 8, PRIx16, expected2, \"\");\n+#endif\n+}\n+\n+int main (void)\n+{\n+  exec_vtrn_half ();\n+  return 0;\n+}"}, {"sha": "8706f248591ab9c4a55546aafc7cbe61861f3b4d", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vuzp_half.c", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvuzp_half.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvuzp_half.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvuzp_half.c?ref=8f3edb0732491c053d821445c6ce46b1ca52b1a6", "patch": "@@ -0,0 +1,259 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { arm*-*-* } } */\n+\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf0, 0xf2, 0xf4, 0xf6,\n+\t\t\t\t       0x11, 0x11, 0x11, 0x11 };\n+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff0, 0xfff2, 0x22, 0x22 };\n+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffff0, 0x33 };\n+VECT_VAR_DECL(expected,int,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xf0, 0xf2, 0xf4, 0xf6,\n+\t\t\t\t\t0x55, 0x55, 0x55, 0x55 };\n+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfff0, 0xfff2, 0x66, 0x66 };\n+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff0, 0x77 };\n+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf0, 0xf2, 0xf4, 0xf6,\n+\t\t\t\t\t0x55, 0x55, 0x55, 0x55 };\n+VECT_VAR_DECL(expected,poly,16,4) [] = { 0xfff0, 0xfff2, 0x66, 0x66 };\n+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1800000, 0x42066666 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected, hfloat, 16, 4) [] = { 0xcc00, 0xcb00,\n+\t\t\t\t\t       0x4b4d, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected,int,8,16) [] = { 0xf0, 0xf2, 0xf4, 0xf6,\n+\t\t\t\t\t0xf8, 0xfa, 0xfc, 0xfe,\n+\t\t\t\t\t0x11, 0x11, 0x11, 0x11,\n+\t\t\t\t\t0x11, 0x11, 0x11, 0x11 };\n+VECT_VAR_DECL(expected,int,16,8) [] = { 0xfff0, 0xfff2, 0xfff4, 0xfff6,\n+\t\t\t\t\t0x22, 0x22, 0x22, 0x22 };\n+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffff0, 0xfffffff2,\n+\t\t\t\t\t0x33, 0x33 };\n+VECT_VAR_DECL(expected,int,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t0x44 };\n+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xf0, 0xf2, 0xf4, 0xf6,\n+\t\t\t\t\t 0xf8, 0xfa, 0xfc, 0xfe,\n+\t\t\t\t\t 0x55, 0x55, 0x55, 0x55,\n+\t\t\t\t\t 0x55, 0x55, 0x55, 0x55 };\n+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfff0, 0xfff2, 0xfff4, 0xfff6,\n+\t\t\t\t\t 0x66, 0x66, 0x66, 0x66 };\n+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff0, 0xfffffff2, 0x77, 0x77 };\n+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t 0x88 };\n+VECT_VAR_DECL(expected,poly,8,16) [] = { 0xf0, 0xf2, 0xf4, 0xf6,\n+\t\t\t\t\t 0xf8, 0xfa, 0xfc, 0xfe,\n+\t\t\t\t\t 0x55, 0x55, 0x55, 0x55,\n+\t\t\t\t\t 0x55, 0x55, 0x55, 0x55 };\n+VECT_VAR_DECL(expected,poly,16,8) [] = { 0xfff0, 0xfff2, 0xfff4, 0xfff6,\n+\t\t\t\t\t 0x66, 0x66, 0x66, 0x66 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected, hfloat, 16, 8) [] = { 0xcc00, 0xcb00, 0xca00, 0xc900,\n+\t\t\t\t\t       0x4b4d, 0x4b4d, 0x4b4d, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1800000, 0xc1600000,\n+\t\t\t\t\t   0x42073333, 0x42073333 };\n+\n+#define TEST_MSG \"VUZP1\"\n+void exec_vuzp_half (void)\n+{\n+#define TEST_VUZP(PART, Q, T1, T2, W, N)\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\\\n+    vuzp##PART##Q##_##T2##W(VECT_VAR(vector, T1, W, N),\t\\\n+\t\t       VECT_VAR(vector2, T1, W, N));\t\\\n+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n+\n+#define TEST_VUZP1(Q, T1, T2, W, N) TEST_VUZP(1, Q, T1, T2, W, N)\n+\n+  /* Input vector can only have 64 bits.  */\n+  DECL_VARIABLE_ALL_VARIANTS(vector);\n+  DECL_VARIABLE_ALL_VARIANTS(vector2);\n+  DECL_VARIABLE(vector, float, 64, 2);\n+  DECL_VARIABLE(vector2, float, 64, 2);\n+\n+  DECL_VARIABLE_ALL_VARIANTS(vector_res);\n+  DECL_VARIABLE(vector_res, float, 64, 2);\n+\n+  clean_results ();\n+  /* We don't have vuzp1_T64x1, so set expected to the clean value.  */\n+  CLEAN(expected, int, 64, 1);\n+  CLEAN(expected, uint, 64, 1);\n+\n+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);\n+#if defined (FP16_SUPPORTED)\n+  VLOAD(vector, buffer, , float, f, 16, 4);\n+  VLOAD(vector, buffer, q, float, f, 16, 8);\n+#endif\n+  VLOAD(vector, buffer, , float, f, 32, 2);\n+  VLOAD(vector, buffer, q, float, f, 32, 4);\n+  VLOAD(vector, buffer, q, float, f, 64, 2);\n+\n+  /* Choose arbitrary initialization values.  */\n+  VDUP(vector2, , int, s, 8, 8, 0x11);\n+  VDUP(vector2, , int, s, 16, 4, 0x22);\n+  VDUP(vector2, , int, s, 32, 2, 0x33);\n+  VDUP(vector2, , uint, u, 8, 8, 0x55);\n+  VDUP(vector2, , uint, u, 16, 4, 0x66);\n+  VDUP(vector2, , uint, u, 32, 2, 0x77);\n+  VDUP(vector2, , poly, p, 8, 8, 0x55);\n+  VDUP(vector2, , poly, p, 16, 4, 0x66);\n+#if defined (FP16_SUPPORTED)\n+  VDUP (vector2, , float, f, 16, 4, 14.6f);   /* 14.6f is 0x4b4d.  */\n+#endif\n+  VDUP(vector2, , float, f, 32, 2, 33.6f);\n+\n+  VDUP(vector2, q, int, s, 8, 16, 0x11);\n+  VDUP(vector2, q, int, s, 16, 8, 0x22);\n+  VDUP(vector2, q, int, s, 32, 4, 0x33);\n+  VDUP(vector2, q, int, s, 64, 2, 0x44);\n+  VDUP(vector2, q, uint, u, 8, 16, 0x55);\n+  VDUP(vector2, q, uint, u, 16, 8, 0x66);\n+  VDUP(vector2, q, uint, u, 32, 4, 0x77);\n+  VDUP(vector2, q, uint, u, 64, 2, 0x88);\n+  VDUP(vector2, q, poly, p, 8, 16, 0x55);\n+  VDUP(vector2, q, poly, p, 16, 8, 0x66);\n+#if defined (FP16_SUPPORTED)\n+  VDUP (vector2, q, float, f, 16, 8, 14.6f);\n+#endif\n+  VDUP(vector2, q, float, f, 32, 4, 33.8f);\n+  VDUP(vector2, q, float, f, 64, 2, 33.8f);\n+\n+  TEST_VUZP1(, int, s, 8, 8);\n+  TEST_VUZP1(, int, s, 16, 4);\n+  TEST_VUZP1(, int, s, 32, 2);\n+  TEST_VUZP1(, uint, u, 8, 8);\n+  TEST_VUZP1(, uint, u, 16, 4);\n+  TEST_VUZP1(, uint, u, 32, 2);\n+  TEST_VUZP1(, poly, p, 8, 8);\n+  TEST_VUZP1(, poly, p, 16, 4);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VUZP1(, float, f, 16, 4);\n+#endif\n+  TEST_VUZP1(, float, f, 32, 2);\n+\n+  TEST_VUZP1(q, int, s, 8, 16);\n+  TEST_VUZP1(q, int, s, 16, 8);\n+  TEST_VUZP1(q, int, s, 32, 4);\n+  TEST_VUZP1(q, int, s, 64, 2);\n+  TEST_VUZP1(q, uint, u, 8, 16);\n+  TEST_VUZP1(q, uint, u, 16, 8);\n+  TEST_VUZP1(q, uint, u, 32, 4);\n+  TEST_VUZP1(q, uint, u, 64, 2);\n+  TEST_VUZP1(q, poly, p, 8, 16);\n+  TEST_VUZP1(q, poly, p, 16, 8);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VUZP1(q, float, f, 16, 8);\n+#endif\n+  TEST_VUZP1(q, float, f, 32, 4);\n+  TEST_VUZP1(q, float, f, 64, 2);\n+\n+#if defined (FP16_SUPPORTED)\n+  CHECK_RESULTS (TEST_MSG, \"\");\n+#else\n+  CHECK_RESULTS_NO_FP16 (TEST_MSG, \"\");\n+#endif\n+\n+#undef TEST_MSG\n+#define TEST_MSG \"VUZP2\"\n+\n+#define TEST_VUZP2(Q, T1, T2, W, N) TEST_VUZP(2, Q, T1, T2, W, N)\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected2,int,8,8) [] = { 0xf1, 0xf3, 0xf5, 0xf7,\n+\t\t\t\t\t0x11, 0x11, 0x11, 0x11 };\n+VECT_VAR_DECL(expected2,int,16,4) [] = { 0xfff1, 0xfff3, 0x22, 0x22 };\n+VECT_VAR_DECL(expected2,int,32,2) [] = { 0xfffffff1, 0x33 };\n+VECT_VAR_DECL(expected2,int,64,1) [] = { 0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected2,uint,8,8) [] = { 0xf1, 0xf3, 0xf5, 0xf7,\n+\t\t\t\t\t 0x55, 0x55, 0x55, 0x55 };\n+VECT_VAR_DECL(expected2,uint,16,4) [] = { 0xfff1, 0xfff3, 0x66, 0x66 };\n+VECT_VAR_DECL(expected2,uint,32,2) [] = { 0xfffffff1, 0x77 };\n+VECT_VAR_DECL(expected2,uint,64,1) [] = { 0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected2,poly,8,8) [] = { 0xf1, 0xf3, 0xf5, 0xf7,\n+\t\t\t\t\t 0x55, 0x55, 0x55, 0x55 };\n+VECT_VAR_DECL(expected2,poly,16,4) [] = { 0xfff1, 0xfff3, 0x66, 0x66 };\n+VECT_VAR_DECL(expected2,hfloat,32,2) [] = { 0xc1700000, 0x42066666 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected2, hfloat, 16, 4) [] = { 0xcb80, 0xca80,\n+\t\t\t\t\t\t0x4b4d, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected2,int,8,16) [] = { 0xf1, 0xf3, 0xf5, 0xf7,\n+\t\t\t\t\t 0xf9, 0xfb, 0xfd, 0xff,\n+\t\t\t\t\t 0x11, 0x11, 0x11, 0x11,\n+\t\t\t\t\t 0x11, 0x11, 0x11, 0x11 };\n+VECT_VAR_DECL(expected2,int,16,8) [] = { 0xfff1, 0xfff3, 0xfff5, 0xfff7,\n+\t\t\t\t\t 0x22, 0x22, 0x22, 0x22 };\n+VECT_VAR_DECL(expected2,int,32,4) [] = { 0xfffffff1, 0xfffffff3,\n+\t\t\t\t\t 0x33, 0x33 };\n+VECT_VAR_DECL(expected2,int,64,2) [] = { 0xfffffffffffffff1,\n+\t\t\t\t\t 0x44 };\n+VECT_VAR_DECL(expected2,uint,8,16) [] = { 0xf1, 0xf3, 0xf5, 0xf7,\n+\t\t\t\t\t  0xf9, 0xfb, 0xfd, 0xff,\n+\t\t\t\t\t  0x55, 0x55, 0x55, 0x55,\n+\t\t\t\t\t  0x55, 0x55, 0x55, 0x55 };\n+VECT_VAR_DECL(expected2,uint,16,8) [] = { 0xfff1, 0xfff3, 0xfff5, 0xfff7,\n+\t\t\t\t\t  0x66, 0x66, 0x66, 0x66 };\n+VECT_VAR_DECL(expected2,uint,32,4) [] = { 0xfffffff1, 0xfffffff3, 0x77, 0x77 };\n+VECT_VAR_DECL(expected2,uint,64,2) [] = { 0xfffffffffffffff1,\n+\t\t\t\t\t  0x88 };\n+VECT_VAR_DECL(expected2,poly,8,16) [] = { 0xf1, 0xf3, 0xf5, 0xf7,\n+\t\t\t\t\t  0xf9, 0xfb, 0xfd, 0xff,\n+\t\t\t\t\t  0x55, 0x55, 0x55, 0x55,\n+\t\t\t\t\t  0x55, 0x55, 0x55, 0x55 };\n+VECT_VAR_DECL(expected2,poly,16,8) [] = { 0xfff1, 0xfff3, 0xfff5, 0xfff7,\n+\t\t\t\t\t  0x66, 0x66, 0x66, 0x66 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected2, hfloat, 16, 8) [] = { 0xcb80, 0xca80, 0xc980, 0xc880,\n+\t\t\t\t\t\t0x4b4d, 0x4b4d, 0x4b4d, 0x4b4d\n+\t\t\t\t\t      };\n+#endif\n+VECT_VAR_DECL(expected2,hfloat,32,4) [] = { 0xc1700000, 0xc1500000,\n+\t\t\t\t\t    0x42073333, 0x42073333 };\n+\n+  clean_results ();\n+  CLEAN(expected2, int, 64, 1);\n+  CLEAN(expected2, uint, 64, 1);\n+\n+  TEST_VUZP2(, int, s, 8, 8);\n+  TEST_VUZP2(, int, s, 16, 4);\n+  TEST_VUZP2(, int, s, 32, 2);\n+  TEST_VUZP2(, uint, u, 8, 8);\n+  TEST_VUZP2(, uint, u, 16, 4);\n+  TEST_VUZP2(, uint, u, 32, 2);\n+  TEST_VUZP2(, poly, p, 8, 8);\n+  TEST_VUZP2(, poly, p, 16, 4);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VUZP2(, float, f, 16, 4);\n+#endif\n+  TEST_VUZP2(, float, f, 32, 2);\n+\n+  TEST_VUZP2(q, int, s, 8, 16);\n+  TEST_VUZP2(q, int, s, 16, 8);\n+  TEST_VUZP2(q, int, s, 32, 4);\n+  TEST_VUZP2(q, int, s, 64, 2);\n+  TEST_VUZP2(q, uint, u, 8, 16);\n+  TEST_VUZP2(q, uint, u, 16, 8);\n+  TEST_VUZP2(q, uint, u, 32, 4);\n+  TEST_VUZP2(q, uint, u, 64, 2);\n+  TEST_VUZP2(q, poly, p, 8, 16);\n+  TEST_VUZP2(q, poly, p, 16, 8);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VUZP2(q, float, f, 16, 8);\n+#endif\n+  TEST_VUZP2(q, float, f, 32, 4);\n+  TEST_VUZP2(q, float, f, 64, 2);\n+\n+  CHECK_RESULTS_NAMED (TEST_MSG, expected2, \"\");\n+#if defined (FP16_SUPPORTED)\n+  CHECK_FP(TEST_MSG, float, 16, 4, PRIx16, expected2, \"\");\n+  CHECK_FP(TEST_MSG, float, 16, 8, PRIx16, expected2, \"\");\n+#endif\n+}\n+\n+int main (void)\n+{\n+  exec_vuzp_half ();\n+  return 0;\n+}"}, {"sha": "619d6b2e6ed3d4c9109aee4d02a38276ffff6a82", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vzip_half.c", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvzip_half.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f3edb0732491c053d821445c6ce46b1ca52b1a6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvzip_half.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvzip_half.c?ref=8f3edb0732491c053d821445c6ce46b1ca52b1a6", "patch": "@@ -0,0 +1,263 @@\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { arm*-*-* } } */\n+\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected,int,8,8) [] = { 0xf0, 0x11, 0xf1, 0x11,\n+\t\t\t\t       0xf2, 0x11, 0xf3, 0x11 };\n+VECT_VAR_DECL(expected,int,16,4) [] = { 0xfff0, 0x22, 0xfff1, 0x22 };\n+VECT_VAR_DECL(expected,int,32,2) [] = { 0xfffffff0, 0x33 };\n+VECT_VAR_DECL(expected,int,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected,uint,8,8) [] = { 0xf0, 0x55, 0xf1, 0x55,\n+\t\t\t\t\t0xf2, 0x55, 0xf3, 0x55 };\n+VECT_VAR_DECL(expected,uint,16,4) [] = { 0xfff0, 0x66, 0xfff1, 0x66 };\n+VECT_VAR_DECL(expected,uint,32,2) [] = { 0xfffffff0, 0x77 };\n+VECT_VAR_DECL(expected,uint,64,1) [] = { 0xfffffffffffffff0 };\n+VECT_VAR_DECL(expected,poly,8,8) [] = { 0xf0, 0x55, 0xf1, 0x55,\n+\t\t\t\t\t0xf2, 0x55, 0xf3, 0x55 };\n+VECT_VAR_DECL(expected,poly,16,4) [] = { 0xfff0, 0x66, 0xfff1, 0x66 };\n+VECT_VAR_DECL(expected,hfloat,32,2) [] = { 0xc1800000, 0x42066666 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected, hfloat, 16, 4) [] = { 0xcc00, 0x4b4d,\n+\t\t\t\t\t       0xcb80, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected,int,8,16) [] = { 0xf0, 0x11, 0xf1, 0x11,\n+\t\t\t\t\t0xf2, 0x11, 0xf3, 0x11,\n+\t\t\t\t\t0xf4, 0x11, 0xf5, 0x11,\n+\t\t\t\t\t0xf6, 0x11, 0xf7, 0x11 };\n+VECT_VAR_DECL(expected,int,16,8) [] = { 0xfff0, 0x22, 0xfff1, 0x22,\n+\t\t\t\t\t0xfff2, 0x22, 0xfff3, 0x22 };\n+VECT_VAR_DECL(expected,int,32,4) [] = { 0xfffffff0, 0x33,\n+\t\t\t\t\t0xfffffff1, 0x33 };\n+VECT_VAR_DECL(expected,int,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t0x44 };\n+VECT_VAR_DECL(expected,uint,8,16) [] = { 0xf0, 0x55, 0xf1, 0x55,\n+\t\t\t\t\t 0xf2, 0x55, 0xf3, 0x55,\n+\t\t\t\t\t 0xf4, 0x55, 0xf5, 0x55,\n+\t\t\t\t\t 0xf6, 0x55, 0xf7, 0x55 };\n+VECT_VAR_DECL(expected,uint,16,8) [] = { 0xfff0, 0x66, 0xfff1, 0x66,\n+\t\t\t\t\t 0xfff2, 0x66, 0xfff3, 0x66 };\n+VECT_VAR_DECL(expected,uint,32,4) [] = { 0xfffffff0, 0x77,\n+\t\t\t\t\t 0xfffffff1, 0x77 };\n+VECT_VAR_DECL(expected,uint,64,2) [] = { 0xfffffffffffffff0,\n+\t\t\t\t\t 0x88 };\n+VECT_VAR_DECL(expected,poly,8,16) [] = { 0xf0, 0x55, 0xf1, 0x55,\n+\t\t\t\t\t 0xf2, 0x55, 0xf3, 0x55,\n+\t\t\t\t\t 0xf4, 0x55, 0xf5, 0x55,\n+\t\t\t\t\t 0xf6, 0x55, 0xf7, 0x55 };\n+VECT_VAR_DECL(expected,poly,16,8) [] = { 0xfff0, 0x66, 0xfff1, 0x66,\n+\t\t\t\t\t 0xfff2, 0x66, 0xfff3, 0x66 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected, hfloat, 16, 8) [] = { 0xcc00, 0x4b4d,\n+\t\t\t\t\t       0xcb80, 0x4b4d,\n+\t\t\t\t\t       0xcb00, 0x4b4d,\n+\t\t\t\t\t       0xca80, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected,hfloat,32,4) [] = { 0xc1800000, 0x42073333,\n+\t\t\t\t\t   0xc1700000, 0x42073333 };\n+\n+#define TEST_MSG \"VZIP1\"\n+void exec_vzip_half (void)\n+{\n+#define TEST_VZIP(PART, Q, T1, T2, W, N)\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\\\n+    vzip##PART##Q##_##T2##W(VECT_VAR(vector, T1, W, N),\t\\\n+\t\t       VECT_VAR(vector2, T1, W, N));\t\\\n+  vst1##Q##_##T2##W(VECT_VAR(result, T1, W, N), VECT_VAR(vector_res, T1, W, N))\n+\n+#define TEST_VZIP1(Q, T1, T2, W, N) TEST_VZIP(1, Q, T1, T2, W, N)\n+\n+  /* Input vector can only have 64 bits.  */\n+  DECL_VARIABLE_ALL_VARIANTS(vector);\n+  DECL_VARIABLE_ALL_VARIANTS(vector2);\n+  DECL_VARIABLE(vector, float, 64, 2);\n+  DECL_VARIABLE(vector2, float, 64, 2);\n+\n+  DECL_VARIABLE_ALL_VARIANTS(vector_res);\n+  DECL_VARIABLE(vector_res, float, 64, 2);\n+\n+  clean_results ();\n+  /* We don't have vzip1_T64x1, so set expected to the clean value.  */\n+  CLEAN(expected, int, 64, 1);\n+  CLEAN(expected, uint, 64, 1);\n+\n+  TEST_MACRO_ALL_VARIANTS_2_5(VLOAD, vector, buffer);\n+#if defined (FP16_SUPPORTED)\n+  VLOAD(vector, buffer, , float, f, 16, 4);\n+  VLOAD(vector, buffer, q, float, f, 16, 8);\n+#endif\n+  VLOAD(vector, buffer, , float, f, 32, 2);\n+  VLOAD(vector, buffer, q, float, f, 32, 4);\n+  VLOAD(vector, buffer, q, float, f, 64, 2);\n+\n+  /* Choose arbitrary initialization values.  */\n+  VDUP(vector2, , int, s, 8, 8, 0x11);\n+  VDUP(vector2, , int, s, 16, 4, 0x22);\n+  VDUP(vector2, , int, s, 32, 2, 0x33);\n+  VDUP(vector2, , uint, u, 8, 8, 0x55);\n+  VDUP(vector2, , uint, u, 16, 4, 0x66);\n+  VDUP(vector2, , uint, u, 32, 2, 0x77);\n+  VDUP(vector2, , poly, p, 8, 8, 0x55);\n+  VDUP(vector2, , poly, p, 16, 4, 0x66);\n+#if defined (FP16_SUPPORTED)\n+  VDUP (vector2, , float, f, 16, 4, 14.6f);   /* 14.6f is 0x4b4d.  */\n+#endif\n+  VDUP(vector2, , float, f, 32, 2, 33.6f);\n+\n+  VDUP(vector2, q, int, s, 8, 16, 0x11);\n+  VDUP(vector2, q, int, s, 16, 8, 0x22);\n+  VDUP(vector2, q, int, s, 32, 4, 0x33);\n+  VDUP(vector2, q, int, s, 64, 2, 0x44);\n+  VDUP(vector2, q, uint, u, 8, 16, 0x55);\n+  VDUP(vector2, q, uint, u, 16, 8, 0x66);\n+  VDUP(vector2, q, uint, u, 32, 4, 0x77);\n+  VDUP(vector2, q, uint, u, 64, 2, 0x88);\n+  VDUP(vector2, q, poly, p, 8, 16, 0x55);\n+  VDUP(vector2, q, poly, p, 16, 8, 0x66);\n+#if defined (FP16_SUPPORTED)\n+  VDUP (vector2, q, float, f, 16, 8, 14.6f);\n+#endif\n+  VDUP(vector2, q, float, f, 32, 4, 33.8f);\n+  VDUP(vector2, q, float, f, 64, 2, 33.8f);\n+\n+  TEST_VZIP1(, int, s, 8, 8);\n+  TEST_VZIP1(, int, s, 16, 4);\n+  TEST_VZIP1(, int, s, 32, 2);\n+  TEST_VZIP1(, uint, u, 8, 8);\n+  TEST_VZIP1(, uint, u, 16, 4);\n+  TEST_VZIP1(, uint, u, 32, 2);\n+  TEST_VZIP1(, poly, p, 8, 8);\n+  TEST_VZIP1(, poly, p, 16, 4);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VZIP1(, float, f, 16, 4);\n+#endif\n+  TEST_VZIP1(, float, f, 32, 2);\n+\n+  TEST_VZIP1(q, int, s, 8, 16);\n+  TEST_VZIP1(q, int, s, 16, 8);\n+  TEST_VZIP1(q, int, s, 32, 4);\n+  TEST_VZIP1(q, int, s, 64, 2);\n+  TEST_VZIP1(q, uint, u, 8, 16);\n+  TEST_VZIP1(q, uint, u, 16, 8);\n+  TEST_VZIP1(q, uint, u, 32, 4);\n+  TEST_VZIP1(q, uint, u, 64, 2);\n+  TEST_VZIP1(q, poly, p, 8, 16);\n+  TEST_VZIP1(q, poly, p, 16, 8);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VZIP1(q, float, f, 16, 8);\n+#endif\n+  TEST_VZIP1(q, float, f, 32, 4);\n+  TEST_VZIP1(q, float, f, 64, 2);\n+\n+#if defined (FP16_SUPPORTED)\n+  CHECK_RESULTS (TEST_MSG, \"\");\n+#else\n+  CHECK_RESULTS_NO_FP16 (TEST_MSG, \"\");\n+#endif\n+\n+#undef TEST_MSG\n+#define TEST_MSG \"VZIP2\"\n+\n+#define TEST_VZIP2(Q, T1, T2, W, N) TEST_VZIP(2, Q, T1, T2, W, N)\n+\n+/* Expected results.  */\n+VECT_VAR_DECL(expected2,int,8,8) [] = { 0xf4, 0x11, 0xf5, 0x11,\n+\t\t\t\t\t0xf6, 0x11, 0xf7, 0x11 };\n+VECT_VAR_DECL(expected2,int,16,4) [] = { 0xfff2, 0x22, 0xfff3, 0x22 };\n+VECT_VAR_DECL(expected2,int,32,2) [] = { 0xfffffff1, 0x33 };\n+VECT_VAR_DECL(expected2,int,64,1) [] = { 0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected2,uint,8,8) [] = { 0xf4, 0x55, 0xf5, 0x55,\n+\t\t\t\t\t 0xf6, 0x55, 0xf7, 0x55 };\n+VECT_VAR_DECL(expected2,uint,16,4) [] = { 0xfff2, 0x66, 0xfff3, 0x66 };\n+VECT_VAR_DECL(expected2,uint,32,2) [] = { 0xfffffff1, 0x77 };\n+VECT_VAR_DECL(expected2,uint,64,1) [] = { 0xfffffffffffffff1 };\n+VECT_VAR_DECL(expected2,poly,8,8) [] = { 0xf4, 0x55, 0xf5, 0x55,\n+\t\t\t\t\t 0xf6, 0x55, 0xf7, 0x55 };\n+VECT_VAR_DECL(expected2,poly,16,4) [] = { 0xfff2, 0x66, 0xfff3, 0x66 };\n+VECT_VAR_DECL(expected2,hfloat,32,2) [] = { 0xc1700000, 0x42066666 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected2, hfloat, 16, 4) [] = { 0xcb00, 0x4b4d,\n+\t\t\t\t\t\t0xca80, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected2,int,8,16) [] = { 0xf8, 0x11, 0xf9, 0x11,\n+\t\t\t\t\t 0xfa, 0x11, 0xfb, 0x11,\n+\t\t\t\t\t 0xfc, 0x11, 0xfd, 0x11,\n+\t\t\t\t\t 0xfe, 0x11, 0xff, 0x11 };\n+VECT_VAR_DECL(expected2,int,16,8) [] = { 0xfff4, 0x22, 0xfff5, 0x22,\n+\t\t\t\t\t 0xfff6, 0x22, 0xfff7, 0x22 };\n+VECT_VAR_DECL(expected2,int,32,4) [] = { 0xfffffff2, 0x33,\n+\t\t\t\t\t 0xfffffff3, 0x33 };\n+VECT_VAR_DECL(expected2,int,64,2) [] = { 0xfffffffffffffff1,\n+\t\t\t\t\t 0x44 };\n+VECT_VAR_DECL(expected2,uint,8,16) [] = { 0xf8, 0x55, 0xf9, 0x55,\n+\t\t\t\t\t  0xfa, 0x55, 0xfb, 0x55,\n+\t\t\t\t\t  0xfc, 0x55, 0xfd, 0x55,\n+\t\t\t\t\t  0xfe, 0x55, 0xff, 0x55 };\n+VECT_VAR_DECL(expected2,uint,16,8) [] = { 0xfff4, 0x66, 0xfff5, 0x66,\n+\t\t\t\t\t  0xfff6, 0x66, 0xfff7, 0x66 };\n+VECT_VAR_DECL(expected2,uint,32,4) [] = { 0xfffffff2, 0x77,\n+\t\t\t\t\t  0xfffffff3, 0x77 };\n+VECT_VAR_DECL(expected2,uint,64,2) [] = { 0xfffffffffffffff1,\n+\t\t\t\t\t  0x88 };\n+VECT_VAR_DECL(expected2,poly,8,16) [] = { 0xf8, 0x55, 0xf9, 0x55,\n+\t\t\t\t\t  0xfa, 0x55, 0xfb, 0x55,\n+\t\t\t\t\t  0xfc, 0x55, 0xfd, 0x55,\n+\t\t\t\t\t  0xfe, 0x55, 0xff, 0x55 };\n+VECT_VAR_DECL(expected2,poly,16,8) [] = { 0xfff4, 0x66, 0xfff5, 0x66,\n+\t\t\t\t\t  0xfff6, 0x66, 0xfff7, 0x66 };\n+#if defined (FP16_SUPPORTED)\n+VECT_VAR_DECL (expected2, hfloat, 16, 8) [] = { 0xca00, 0x4b4d,\n+\t\t\t\t\t\t0xc980, 0x4b4d,\n+\t\t\t\t\t\t0xc900, 0x4b4d,\n+\t\t\t\t\t\t0xc880, 0x4b4d };\n+#endif\n+VECT_VAR_DECL(expected2,hfloat,32,4) [] = { 0xc1600000, 0x42073333,\n+\t\t\t\t\t    0xc1500000, 0x42073333 };\n+  clean_results ();\n+  CLEAN(expected2, int, 64, 1);\n+  CLEAN(expected2, uint, 64, 1);\n+\n+  TEST_VZIP2(, int, s, 8, 8);\n+  TEST_VZIP2(, int, s, 16, 4);\n+  TEST_VZIP2(, int, s, 32, 2);\n+  TEST_VZIP2(, uint, u, 8, 8);\n+  TEST_VZIP2(, uint, u, 16, 4);\n+  TEST_VZIP2(, uint, u, 32, 2);\n+  TEST_VZIP2(, poly, p, 8, 8);\n+  TEST_VZIP2(, poly, p, 16, 4);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VZIP2(, float, f, 16, 4);\n+#endif\n+  TEST_VZIP2(, float, f, 32, 2);\n+\n+  TEST_VZIP2(q, int, s, 8, 16);\n+  TEST_VZIP2(q, int, s, 16, 8);\n+  TEST_VZIP2(q, int, s, 32, 4);\n+  TEST_VZIP2(q, int, s, 64, 2);\n+  TEST_VZIP2(q, uint, u, 8, 16);\n+  TEST_VZIP2(q, uint, u, 16, 8);\n+  TEST_VZIP2(q, uint, u, 32, 4);\n+  TEST_VZIP2(q, uint, u, 64, 2);\n+  TEST_VZIP2(q, poly, p, 8, 16);\n+  TEST_VZIP2(q, poly, p, 16, 8);\n+#if defined (FP16_SUPPORTED)\n+  TEST_VZIP2(q, float, f, 16, 8);\n+#endif\n+  TEST_VZIP2(q, float, f, 32, 4);\n+  TEST_VZIP2(q, float, f, 64, 2);\n+\n+  CHECK_RESULTS_NAMED (TEST_MSG, expected2, \"\");\n+#if defined (FP16_SUPPORTED)\n+  CHECK_FP(TEST_MSG, float, 16, 4, PRIx16, expected2, \"\");\n+  CHECK_FP(TEST_MSG, float, 16, 8, PRIx16, expected2, \"\");\n+#endif\n+}\n+\n+int main (void)\n+{\n+  exec_vzip_half ();\n+  return 0;\n+}"}]}