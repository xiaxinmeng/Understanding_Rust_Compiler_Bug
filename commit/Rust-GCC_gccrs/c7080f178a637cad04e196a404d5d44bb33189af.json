{"sha": "c7080f178a637cad04e196a404d5d44bb33189af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzcwODBmMTc4YTYzN2NhZDA0ZTE5NmE0MDRkNWQ0NGJiMzMxODlhZg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-07T11:51:24Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:36Z"}, "message": "Added more cfg stripping code", "tree": {"sha": "a023eeee3f2c3ab85190e4967cfe0599b466843e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a023eeee3f2c3ab85190e4967cfe0599b466843e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7080f178a637cad04e196a404d5d44bb33189af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7080f178a637cad04e196a404d5d44bb33189af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7080f178a637cad04e196a404d5d44bb33189af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7080f178a637cad04e196a404d5d44bb33189af/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db39766514144dbbad34d9db3977c3a72d1216c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db39766514144dbbad34d9db3977c3a72d1216c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db39766514144dbbad34d9db3977c3a72d1216c3"}], "stats": {"total": 420, "additions": 336, "deletions": 84}, "files": [{"sha": "2c720c6f6d034b8e15fbcd75663da387d80d4194", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=c7080f178a637cad04e196a404d5d44bb33189af", "patch": "@@ -1038,7 +1038,7 @@ TypeResolution::visit (AST::LetStmt &stmt)\n \n   if (stmt.has_type () && stmt.has_init_expr ())\n     {\n-      if (!typesAreCompatible (stmt.type.get (), inferedType,\n+      if (!typesAreCompatible (stmt.get_type ().get (), inferedType,\n \t\t\t       stmt.get_init_expr ()->get_locus_slow ()))\n \t{\n \t  return;"}, {"sha": "455511c7e09b1261a7ffbd70caff2c96da7c2125", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=c7080f178a637cad04e196a404d5d44bb33189af", "patch": "@@ -90,8 +90,12 @@ class TypeParam : public GenericParam\n   TypeParam (TypeParam const &other)\n     : outer_attr (other.outer_attr),\n       type_representation (other.type_representation),\n-      type (other.type->clone_type ()), locus (other.locus)\n+      locus (other.locus)\n   {\n+    // guard to prevent null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n       type_param_bounds.push_back (e->clone_type_param_bound ());\n@@ -101,11 +105,15 @@ class TypeParam : public GenericParam\n   TypeParam &operator= (TypeParam const &other)\n   {\n     type_representation = other.type_representation;\n-    // type_param_bounds = other.type_param_bounds;\n-    type = other.type->clone_type ();\n     outer_attr = other.outer_attr;\n     locus = other.locus;\n \n+    // guard to prevent null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n       type_param_bounds.push_back (e->clone_type_param_bound ());\n@@ -453,7 +461,7 @@ struct FunctionQualifiers\n     if (!this->extern_abi.empty ())\n       {\n \t// having extern is required; not having it is an implementation error\n-\tgcc_assert (has_extern);\n+\trust_assert (has_extern);\n       }\n   }\n \n@@ -1101,7 +1109,7 @@ class UseTreeGlob : public UseTree\n       {\n \t// compiler implementation error if there is a path with a\n \t// non-path-prefixed use tree glob\n-\tgcc_assert (!has_path ());\n+\trust_assert (!has_path ());\n       }\n     // TODO: do path-prefixed paths also have to have a path? If so, have an\n     // assert for that too.\n@@ -1153,7 +1161,7 @@ class UseTreeList : public UseTree\n       {\n \t// compiler implementation error if there is a path with a\n \t// non-path-prefixed use tree glob\n-\tgcc_assert (!has_path ());\n+\trust_assert (!has_path ());\n       }\n     // TODO: do path-prefixed paths also have to have a path? If so, have an\n     // assert for that too."}, {"sha": "5ae68abf5c44d9284346d9d27f01a8321d249109", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=c7080f178a637cad04e196a404d5d44bb33189af", "patch": "@@ -223,6 +223,10 @@ class RangePatternBoundPath : public RangePatternBound\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems kinda dodgy\n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -251,6 +255,10 @@ class RangePatternBoundQualPath : public RangePatternBound\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems kinda dodgy\n+  QualifiedPathInExpression &get_qualified_path () { return path; }\n+  const QualifiedPathInExpression &get_qualified_path () const { return path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -310,6 +318,17 @@ class RangePattern : public Pattern\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: is this better? or is a \"vis_bound\" better?\n+  std::unique_ptr<RangePatternBound>& get_lower_bound () {\n+    rust_assert (lower != nullptr);\n+    return lower;\n+  }\n+\n+  std::unique_ptr<RangePatternBound>& get_upper_bound () {\n+    rust_assert (upper != nullptr);\n+    return upper;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -735,6 +754,9 @@ class StructPattern : public Pattern\n   StructPatternElements &get_struct_pattern_elems () { return elems; }\n   const StructPatternElements &get_struct_pattern_elems () const { return elems; }\n \n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -940,6 +962,9 @@ class TupleStructPattern : public Pattern\n     return items; \n   }\n \n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "88be2563344d13d5054223e0307fdf29cd138c51", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=c7080f178a637cad04e196a404d5d44bb33189af", "patch": "@@ -41,7 +41,6 @@ class LetStmt : public Stmt\n   // bool has_outer_attrs;\n   std::vector<Attribute> outer_attrs;\n \n-public:\n   std::unique_ptr<Pattern> variables_pattern;\n \n   // bool has_type;\n@@ -52,6 +51,7 @@ class LetStmt : public Stmt\n \n   Location locus;\n \n+public:\n   Type *inferedType;\n \n   // Returns whether let statement has outer attributes.\n@@ -140,6 +140,11 @@ class LetStmt : public Stmt\n     return variables_pattern;\n   }\n \n+  std::unique_ptr<Type> &get_type () {\n+    rust_assert (has_type ());\n+    return type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "ea9a89cc221ab60a748dd3610220bd2149ef8e04", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 100, "deletions": 8, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=c7080f178a637cad04e196a404d5d44bb33189af", "patch": "@@ -43,6 +43,10 @@ class TraitBound : public TypeParamBound\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems kinda dodgy\n+  TypePath &get_type_path () { return type_path; }\n+  const TypePath &get_type_path () const { return type_path; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -109,6 +113,10 @@ class ImplTraitType : public Type\n   Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n };\n \n // An opaque value of another type that implements a set of traits\n@@ -168,6 +176,10 @@ class TraitObjectType : public Type\n   Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () { return type_param_bounds; }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds () const { return type_param_bounds; }\n };\n \n // A type with parentheses around it, used to avoid ambiguity.\n@@ -226,6 +238,12 @@ class ParenthesisedType : public TypeNoBounds\n   Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_type_in_parens () { \n+    rust_assert (type_in_parens != nullptr);\n+    return type_in_parens; \n+  }\n };\n \n // Impl trait with a single bound? Poor reference material here.\n@@ -253,6 +271,12 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n   Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  TraitBound &get_trait_bound () { \n+    // TODO: check to ensure invariants are met?\n+    return trait_bound; \n+  }\n };\n \n /* A trait object with a single trait bound. The \"trait bound\" is really just\n@@ -292,6 +316,12 @@ class TraitObjectTypeOneBound : public TypeNoBounds\n   Location get_locus_slow () const final override { return get_locus (); }\n \n   void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  TraitBound &get_trait_bound () { \n+    // TODO: check to ensure invariants are met?\n+    return trait_bound; \n+  }\n };\n \n class TypePath; // definition moved to \"rust-path.h\"\n@@ -342,6 +372,10 @@ class TupleType : public TypeNoBounds\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<Type> > &get_elems () { return elems; }\n+  const std::vector<std::unique_ptr<Type> > &get_elems () const { return elems; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -429,6 +463,12 @@ class RawPointerType : public TypeNoBounds\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<TypeNoBounds> &get_type_pointed_to () { \n+    rust_assert (type != nullptr);\n+    return type; \n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -490,6 +530,12 @@ class ReferenceType : public TypeNoBounds\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<TypeNoBounds> &get_type_referenced () { \n+    rust_assert (type != nullptr);\n+    return type; \n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -539,6 +585,18 @@ class ArrayType : public TypeNoBounds\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_elem_type () { \n+    rust_assert (elem_type != nullptr);\n+    return elem_type; \n+  }\n+\n+  // TODO: would a \"vis_expr\" be better?\n+  std::unique_ptr<Expr> &get_size_expr () { \n+    rust_assert (size != nullptr);\n+    return size; \n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -586,6 +644,12 @@ class SliceType : public TypeNoBounds\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_elem_type () { \n+    rust_assert (elem_type != nullptr);\n+    return elem_type; \n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -635,6 +699,8 @@ struct MaybeNamedParam\n   };\n \n private:\n+  std::vector<Attribute> outer_attrs;\n+\n   std::unique_ptr<Type> param_type;\n \n   ParamKind param_kind;\n@@ -644,14 +710,14 @@ struct MaybeNamedParam\n \n public:\n   MaybeNamedParam (Identifier name, ParamKind param_kind,\n-\t\t   std::unique_ptr<Type> param_type, Location locus)\n-    : param_type (std::move (param_type)), param_kind (param_kind),\n+\t\t   std::unique_ptr<Type> param_type, std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), param_type (std::move (param_type)), param_kind (param_kind),\n       name (std::move (name)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n   MaybeNamedParam (MaybeNamedParam const &other)\n-    : param_kind (other.param_kind), name (other.name), locus (other.locus)\n+    : outer_attrs (other.outer_attrs), param_kind (other.param_kind), name (other.name), locus (other.locus)\n   {\n     // guard to prevent null dereference\n     if (other.param_type != nullptr)\n@@ -663,6 +729,7 @@ struct MaybeNamedParam\n   // Overloaded assignment operator with clone\n   MaybeNamedParam &operator= (MaybeNamedParam const &other)\n   {\n+    outer_attrs = other.outer_attrs;\n     name = other.name;\n     param_kind = other.param_kind;\n     locus = other.locus;\n@@ -688,10 +755,20 @@ struct MaybeNamedParam\n   // Creates an error state param.\n   static MaybeNamedParam create_error ()\n   {\n-    return MaybeNamedParam (\"\", UNNAMED, nullptr, Location ());\n+    return MaybeNamedParam (\"\", UNNAMED, nullptr, {}, Location ());\n   }\n \n   Location get_locus () const { return locus; }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_type () { \n+    rust_assert (param_type != nullptr);\n+    return param_type; \n+  }\n };\n \n /* A function pointer type - can be created via coercion from function items and\n@@ -705,6 +782,7 @@ class BareFunctionType : public TypeNoBounds\n   FunctionQualifiers function_qualifiers;\n   std::vector<MaybeNamedParam> params;\n   bool is_variadic;\n+  std::vector<Attribute> variadic_attrs;\n \n   // bool has_return_type;\n   // BareFunctionReturnType return_type;\n@@ -721,19 +799,22 @@ class BareFunctionType : public TypeNoBounds\n \n   BareFunctionType (std::vector<LifetimeParam> lifetime_params,\n \t\t    FunctionQualifiers qualifiers,\n-\t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n+\t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic, std::vector<Attribute> variadic_attrs,\n \t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n     : for_lifetimes (std::move (lifetime_params)),\n       function_qualifiers (std::move (qualifiers)),\n       params (std::move (named_params)), is_variadic (is_variadic),\n-      return_type (std::move (type)), locus (locus)\n-  {}\n+      variadic_attrs (std::move (variadic_attrs)), return_type (std::move (type)), locus (locus)\n+  {\n+    if (!variadic_attrs.empty())\n+      is_variadic = true;\n+  }\n \n   // Copy constructor with clone\n   BareFunctionType (BareFunctionType const &other)\n     : for_lifetimes (other.for_lifetimes),\n       function_qualifiers (other.function_qualifiers), params (other.params),\n-      is_variadic (other.is_variadic), locus (other.locus)\n+      is_variadic (other.is_variadic), variadic_attrs (other.variadic_attrs), locus (other.locus)\n   {\n     // guard to prevent null dereference\n     if (other.return_type != nullptr)\n@@ -747,6 +828,7 @@ class BareFunctionType : public TypeNoBounds\n     function_qualifiers = other.function_qualifiers;\n     params = other.params;\n     is_variadic = other.is_variadic;\n+    variadic_attrs = other.variadic_attrs;\n     locus = other.locus;\n \n     // guard to prevent null dereference\n@@ -769,6 +851,16 @@ class BareFunctionType : public TypeNoBounds\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  // TODO: this mutable getter seems kinda dodgy\n+  std::vector<MaybeNamedParam> &get_function_params () { return params; }\n+  const std::vector<MaybeNamedParam> &get_function_params () const { return params; }\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<TypeNoBounds> &get_return_type () { \n+    rust_assert (has_return_type ());\n+    return return_type; \n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "3691f9ea87abb86d62174ffd02ae4e9e71784d45", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=c7080f178a637cad04e196a404d5d44bb33189af", "patch": "@@ -88,21 +88,21 @@ bool\n Compilation::compileVarDecl (Bfunction *fndecl, AST::LetStmt *stmt,\n \t\t\t     std::vector<Bvariable *> &vars)\n {\n-  AST::Type *type = stmt->has_type () ? stmt->type.get () : stmt->inferedType;\n+  AST::Type *type = stmt->has_type () ? stmt->get_type ().get () : stmt->inferedType;\n   translatedType = NULL;\n   type->accept_vis (*this);\n   if (translatedType == NULL)\n     {\n-      rust_error_at (stmt->locus, \"failed to compile type for var decl\");\n+      rust_error_at (stmt->get_locus (), \"failed to compile type for var decl\");\n       return false;\n     }\n \n-  stmt->variables_pattern->accept_vis (*this);\n+  stmt->get_pattern ()->accept_vis (*this);\n   for (auto &pattern : patternBuffer)\n     {\n       auto var = backend->local_variable (fndecl, pattern.get_ident (),\n \t\t\t\t\t  translatedType, NULL /*decl_var*/,\n-\t\t\t\t\t  false /*address_taken*/, stmt->locus);\n+\t\t\t\t\t  false /*address_taken*/, stmt->get_locus ());\n       vars.push_back (var);\n       scope.InsertVar (pattern.get_ident (), var);\n     }\n@@ -1298,7 +1298,7 @@ Compilation::visit (AST::LetStmt &stmt)\n   if (!stmt.has_init_expr ())\n     return;\n \n-  stmt.variables_pattern->accept_vis (*this);\n+  stmt.get_pattern ()->accept_vis (*this);\n   for (auto &pattern : patternBuffer)\n     {\n       Bvariable *var = NULL;"}, {"sha": "95fb962c26d14e6a64e8b17e2e691b0e55a86bc7", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 147, "deletions": 20, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=c7080f178a637cad04e196a404d5d44bb33189af", "patch": "@@ -2349,6 +2349,7 @@ namespace Rust {\n             }\n         }\n \n+        // I don't think it would be possible to strip macros without expansion\n         void visit(AST::MacroMatchFragment& match) override {}\n         void visit(AST::MacroMatchRepetition& match) override {}\n         void visit(AST::MacroMatcher& matcher) override {}\n@@ -2401,13 +2402,23 @@ namespace Rust {\n             // not possible\n         }\n         void visit(AST::RangePatternBoundPath& bound) override {\n-            // TODO: maybe possible if path is possible\n+            // can expand path, but not strip it directly\n+            auto& path = bound.get_path();\n+            visit(path);\n+            if (path.is_marked_for_strip())\n+                rust_error_at(path.get_locus(), \"cannot strip path in this position\");\n         }\n         void visit(AST::RangePatternBoundQualPath& bound) override {\n-            // TODO: maybe possible if path is possible\n+            // can expand path, but not strip it directly\n+            auto& path = bound.get_qualified_path();\n+            visit(path);\n+            if (path.is_marked_for_strip())\n+                rust_error_at(path.get_locus(), \"cannot strip path in this position\");\n         }\n         void visit(AST::RangePattern& pattern) override {\n-            // TODO: possible if any bounds are possible\n+            // should have no capability to strip lower or upper bounds, only expand\n+            pattern.get_lower_bound()->accept_vis(*this);\n+            pattern.get_upper_bound()->accept_vis(*this);\n         }\n         void visit(AST::ReferencePattern& pattern) override {\n             auto& sub_pattern = pattern.get_referenced_pattern();\n@@ -2452,6 +2463,12 @@ namespace Rust {\n             }\n         }\n         void visit(AST::StructPattern& pattern) override {\n+            // expand (but don't strip) path\n+            auto& path = pattern.get_path();\n+            visit(path);\n+            if (path.is_marked_for_strip())\n+                rust_error_at(path.get_locus(), \"cannot strip path in this position\");\n+\n             // TODO: apparently struct pattern fields can have outer attrs. so can they be stripped?\n             if (!pattern.has_struct_pattern_elems())\n                 return;\n@@ -2506,7 +2523,11 @@ namespace Rust {\n             }\n         }\n         void visit(AST::TupleStructPattern& pattern) override {\n-            // TODO: stripping of path?\n+            // expand (but don't strip) path\n+            auto& path = pattern.get_path();\n+            visit(path);\n+            if (path.is_marked_for_strip())\n+                rust_error_at(path.get_locus(), \"cannot strip path in this position\");\n \n             if (pattern.has_items()) \n                 pattern.get_items()->accept_vis(*this);\n@@ -2578,6 +2599,14 @@ namespace Rust {\n             pattern->accept_vis(*this);\n             if (pattern->is_marked_for_strip())\n                 rust_error_at(pattern->get_locus_slow(), \"cannot strip pattern in this position\");\n+            \n+            // similar for type\n+            if (stmt.has_type()) {\n+                auto& type = stmt.get_type();\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n \n             /* strip any internal sub-expressions - expression itself isn't\n              * allowed to have external attributes in this position so can't be\n@@ -2621,25 +2650,123 @@ namespace Rust {\n             }\n         }\n \n-        // stripping shouldn't be required or possible for types\n-        void visit(AST::TraitBound& bound) override {}\n-        void visit(AST::ImplTraitType& type) override {}\n-        void visit(AST::TraitObjectType& type) override {}\n-        void visit(AST::ParenthesisedType& type) override {}\n-        void visit(AST::ImplTraitTypeOneBound& type) override {}\n-        void visit(AST::TraitObjectTypeOneBound& type) override {}\n-        void visit(AST::TupleType& type) override {}\n-        void visit(AST::NeverType& type) override {}\n-        void visit(AST::RawPointerType& type) override {}\n-        void visit(AST::ReferenceType& type) override {}\n+        void visit(AST::TraitBound& bound) override {\n+            // nothing in for lifetimes to strip\n+            \n+            // expand but don't strip type path\n+            auto& path = bound.get_type_path();\n+            visit(path);\n+            if (path.is_marked_for_strip())\n+                rust_error_at(path.get_locus(), \"cannot strip type path in this position\");\n+        }\n+        void visit(AST::ImplTraitType& type) override {\n+            // don't strip directly, only components of bounds\n+            for (auto& bound : type.get_type_param_bounds()) \n+                bound->accept_vis(*this);\n+        }\n+        void visit(AST::TraitObjectType& type) override {\n+            // don't strip directly, only components of bounds\n+            for (auto& bound : type.get_type_param_bounds()) \n+                bound->accept_vis(*this);\n+        }\n+        void visit(AST::ParenthesisedType& type) override {\n+            // expand but don't strip inner type\n+            auto& inner_type = type.get_type_in_parens();\n+            inner_type->accept_vis(*this);\n+            if (inner_type->is_marked_for_strip())\n+                rust_error_at(inner_type->get_locus_slow(), \"cannot strip type in this position\");\n+        }\n+        void visit(AST::ImplTraitTypeOneBound& type) override {\n+            // no stripping possible\n+            visit(type.get_trait_bound());\n+        }\n+        void visit(AST::TraitObjectTypeOneBound& type) override {\n+            // no stripping possible\n+            visit(type.get_trait_bound());\n+        }\n+        void visit(AST::TupleType& type) override {\n+            // TODO: assuming that types can't be stripped as types don't have outer attributes\n+            for (auto& elem_type : type.get_elems()) {\n+                elem_type->accept_vis(*this);\n+                if (elem_type->is_marked_for_strip())\n+                    rust_error_at(elem_type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+        }\n+        void visit(AST::NeverType& type) override {\n+            // no stripping possible\n+        }\n+        void visit(AST::RawPointerType& type) override {\n+            // expand but don't strip type pointed to\n+            auto& pointed_type = type.get_type_pointed_to();\n+            pointed_type->accept_vis(*this);\n+            if (pointed_type->is_marked_for_strip())\n+                rust_error_at(pointed_type->get_locus_slow(), \"cannot strip type in this position\");\n+        }\n+        void visit(AST::ReferenceType& type) override {\n+            // expand but don't strip type referenced\n+            auto& referenced_type = type.get_type_referenced();\n+            referenced_type->accept_vis(*this);\n+            if (referenced_type->is_marked_for_strip())\n+                rust_error_at(referenced_type->get_locus_slow(), \"cannot strip type in this position\");\n+        }\n         void visit(AST::ArrayType& type) override {\n-            // TODO: array type contains a \"constant expression\" - could this have strippable sub-exprs?\n+            // expand but don't strip type referenced\n+            auto& base_type = type.get_elem_type();\n+            base_type->accept_vis(*this);\n+            if (base_type->is_marked_for_strip())\n+                rust_error_at(base_type->get_locus_slow(), \"cannot strip type in this position\");\n+            \n+            // same for expression\n+            auto& size_expr = type.get_size_expr();\n+            size_expr->accept_vis(*this);\n+            if (size_expr->is_marked_for_strip())\n+                rust_error_at(size_expr->get_locus_slow(), \"cannot strip expression in this position\");\n+        }\n+        void visit(AST::SliceType& type) override {\n+            // expand but don't strip elem type\n+            auto& elem_type = type.get_elem_type();\n+            elem_type->accept_vis(*this);\n+            if (elem_type->is_marked_for_strip())\n+                rust_error_at(elem_type->get_locus_slow(), \"cannot strip type in this position\");\n+        }\n+        void visit(AST::InferredType& type) override {\n+            // none possible\n         }\n-        void visit(AST::SliceType& type) override {}\n-        void visit(AST::InferredType& type) override {}\n         void visit(AST::BareFunctionType& type) override {\n-            // TODO: bare function type contains \"maybe-named params\" that have outer attributes - could this be strippable?\n-            // apparently \"attribute rules are same as on regular function params\", so looks like a yes\n+            // seem to be no generics\n+\n+            // presumably function params can be stripped\n+            auto& params = type.get_function_params();\n+            for (int i = 0; i < params.size();) {\n+                auto& param = params[i];\n+\n+                auto& param_attrs = param.get_outer_attrs();\n+                expander.expand_cfg_attrs(param_attrs);\n+                if (expander.fails_cfg(param_attrs)) {\n+                    params.erase(params.begin() + i);\n+                    continue;\n+                }\n+\n+                auto& type = param.get_type();\n+                type->accept_vis(*this);\n+                if (type->is_marked_for_strip())\n+                    rust_error_at(type->get_locus_slow(), \"cannot strip type in this position\");\n+                \n+                // increment if nothing else happens\n+                i++;\n+            }\n+\n+            /* TODO: assuming that variadic nature cannot be stripped. If this\n+             * is not true, then have code here to do so. */\n+            \n+            if (type.has_return_type()) {\n+                auto& return_type = type.get_return_type();\n+                return_type->accept_vis(*this);\n+                if (return_type->is_marked_for_strip())\n+                    rust_error_at(return_type->get_locus_slow(), \"cannot strip type in this position\");\n+            }\n+            \n+            // no where clause, apparently\n         }\n     };\n "}, {"sha": "3315da3798b0edce49497600517d216762a94906", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=c7080f178a637cad04e196a404d5d44bb33189af", "patch": "@@ -9205,7 +9205,7 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n // Parses a maybe named param used in bare function types.\n template <typename ManagedTokenSource>\n AST::MaybeNamedParam\n-Parser<ManagedTokenSource>::parse_maybe_named_param ()\n+Parser<ManagedTokenSource>::parse_maybe_named_param (std::vector<AST::Attribute> outer_attrs)\n {\n   /* Basically guess that param is named if first token is identifier or\n    * underscore and second token is semicolon. This should probably have no\n@@ -9242,7 +9242,7 @@ Parser<ManagedTokenSource>::parse_maybe_named_param ()\n     }\n \n   return AST::MaybeNamedParam (std::move (name), kind, std::move (type),\n-\t\t\t       current->get_locus ());\n+\t\t\t       std::move (outer_attrs), current->get_locus ());\n }\n \n /* Parses a bare function type (with the given for lifetimes for convenience -\n@@ -9258,63 +9258,58 @@ Parser<ManagedTokenSource>::parse_bare_function_type (\n   AST::FunctionQualifiers qualifiers = parse_function_qualifiers ();\n \n   if (!skip_token (FN_TOK))\n-    {\n       return nullptr;\n-    }\n \n   if (!skip_token (LEFT_PAREN))\n-    {\n       return nullptr;\n-    }\n \n   // parse function params, if they exist\n   std::vector<AST::MaybeNamedParam> params;\n   bool is_variadic = false;\n-  const_TokenPtr t = lexer.peek_token ();\n-  while (t->get_id () != RIGHT_PAREN)\n-    {\n-      // handle ellipsis (only if next character is right paren)\n-      if (t->get_id () == ELLIPSIS)\n-\t{\n-\t  if (lexer.peek_token (1)->get_id () == RIGHT_PAREN)\n-\t    {\n-\t      lexer.skip_token ();\n-\t      is_variadic = true;\n-\t      break;\n-\t    }\n-\t  else\n-\t    {\n-\t      rust_error_at (t->get_locus (),\n-\t\t\t     \"ellipsis (for variadic) can only go at end of \"\n-\t\t\t     \"bare function type\");\n-\t      return nullptr;\n-\t    }\n-\t}\n+  std::vector<AST::Attribute> variadic_attrs;\n \n-      // parse required param\n-      AST::MaybeNamedParam param = parse_maybe_named_param ();\n-      if (param.is_error ())\n-\t{\n-\t  rust_error_at (\n-\t    t->get_locus (),\n-\t    \"failed to parse maybe named param in bare function type\");\n-\t  return nullptr;\n-\t}\n-      params.push_back (std::move (param));\n+  const_TokenPtr t = lexer.peek_token ();\n+  while (t->get_id () != RIGHT_PAREN) \n+  {\n+    std::vector<AST::Attribute> temp_attrs = parse_outer_attributes ();\n \n-      if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n+    if (lexer.peek_token ()->get_id () == ELLIPSIS) \n+    {\n       lexer.skip_token ();\n+      is_variadic = true;\n+      variadic_attrs = std::move (temp_attrs);\n \n       t = lexer.peek_token ();\n+\n+      if (t->get_id() != RIGHT_PAREN) \n+      {\n+          rust_error_at (t->get_locus (),\n+\t\t\t\t   \"expected right parentheses after variadic in maybe named function \"\n+           \"parameters, found %qs\",\n+\t\t\t\t   t->get_token_description ());\n+\t\t      return nullptr;\n+      }\n+\n+      break;\n     }\n \n-  if (!skip_token (RIGHT_PAREN))\n+    AST::MaybeNamedParam param = parse_maybe_named_param (std::move (temp_attrs));\n+    if (param.is_error ()) \n     {\n+      rust_error_at (lexer.peek_token ()->get_locus (), \"failed to parse maybe named param in bare function type\");\n       return nullptr;\n     }\n+    params.push_back (std::move (param));\n+\n+    if (lexer.peek_token ()->get_id () != COMMA)\n+\t    break;\n+\n+    lexer.skip_token ();\n+    t = lexer.peek_token ();\n+  }\n+\n+  if (!skip_token (RIGHT_PAREN))\n+      return nullptr;\n \n   // bare function return type, if exists\n   std::unique_ptr<AST::TypeNoBounds> return_type = nullptr;\n@@ -9335,7 +9330,7 @@ Parser<ManagedTokenSource>::parse_bare_function_type (\n \n   return std::unique_ptr<AST::BareFunctionType> (new AST::BareFunctionType (\n     std::move (for_lifetimes), std::move (qualifiers), std::move (params),\n-    is_variadic, std::move (return_type), best_try_locus));\n+    is_variadic, std::move (variadic_attrs), std::move (return_type), best_try_locus));\n }\n \n // Parses a reference type (mutable or immutable, with given lifetime)."}, {"sha": "7218ebc4a2aa66e4e288f8b4c856e020cd05aec4", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7080f178a637cad04e196a404d5d44bb33189af/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=c7080f178a637cad04e196a404d5d44bb33189af", "patch": "@@ -545,7 +545,7 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::Type> parse_paren_prefixed_type ();\n   std::unique_ptr<AST::TypeNoBounds> parse_paren_prefixed_type_no_bounds ();\n   std::unique_ptr<AST::Type> parse_for_prefixed_type ();\n-  AST::MaybeNamedParam parse_maybe_named_param ();\n+  AST::MaybeNamedParam parse_maybe_named_param (std::vector<AST::Attribute> outer_attrs);\n \n   // Statement-related\n   std::unique_ptr<AST::Stmt> parse_stmt ();"}]}