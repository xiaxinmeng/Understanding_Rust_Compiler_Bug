{"sha": "d8d262cf80dd8f7f2973eae13b641cb329d2315a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhkMjYyY2Y4MGRkOGY3ZjI5NzNlYWUxM2I2NDFjYjMyOWQyMzE1YQ==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2016-01-21T02:13:33Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2016-01-21T02:13:33Z"}, "message": "rewrite computation of iteration domains\n\n        * graphite-sese-to-poly.c (set_scop_parameter_dim): Remove.\n        (cleanup_loop_iter_dom): Remove.\n        (build_loop_iteration_domains): Remove.\n        (build_scop_context): Remove.\n        (build_scop_iteration_domain): Remove.\n        (add_loop_constraints): New.\n        (build_iteration_domains): New.\n        (build_poly_scop): Call build_iteration_domains.\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r232656", "tree": {"sha": "c20663e9f5339fdb1541147768112dc96875d863", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c20663e9f5339fdb1541147768112dc96875d863"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8d262cf80dd8f7f2973eae13b641cb329d2315a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8d262cf80dd8f7f2973eae13b641cb329d2315a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8d262cf80dd8f7f2973eae13b641cb329d2315a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8d262cf80dd8f7f2973eae13b641cb329d2315a/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaca025e57accd92cabab3eaf09d5a27e056d184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaca025e57accd92cabab3eaf09d5a27e056d184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaca025e57accd92cabab3eaf09d5a27e056d184"}], "stats": {"total": 419, "additions": 204, "deletions": 215}, "files": [{"sha": "4b593a8cc65fc651e89d46e397ab6c7eb5600c9c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8d262cf80dd8f7f2973eae13b641cb329d2315a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8d262cf80dd8f7f2973eae13b641cb329d2315a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8d262cf80dd8f7f2973eae13b641cb329d2315a", "patch": "@@ -1,3 +1,15 @@\n+2016-01-21  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+        * graphite-sese-to-poly.c (set_scop_parameter_dim): Remove.\n+        (cleanup_loop_iter_dom): Remove.\n+        (build_loop_iteration_domains): Remove.\n+        (build_scop_context): Remove.\n+        (build_scop_iteration_domain): Remove.\n+        (add_loop_constraints): New.\n+        (build_iteration_domains): New.\n+        (build_poly_scop): Call build_iteration_domains.\n+\n 2016-01-21  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "92ab2f97cff46daf60ce1f8c8d7182974457bde1", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 192, "deletions": 215, "changes": 407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8d262cf80dd8f7f2973eae13b641cb329d2315a/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8d262cf80dd8f7f2973eae13b641cb329d2315a/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=d8d262cf80dd8f7f2973eae13b641cb329d2315a", "patch": "@@ -431,159 +431,6 @@ extract_affine (scop_p s, tree e, __isl_take isl_space *space)\n   return res;\n }\n \n-/* Assign dimension for each parameter in SCOP.  */\n-\n-static void\n-set_scop_parameter_dim (scop_p scop)\n-{\n-  sese_info_p region = scop->scop_info;\n-  unsigned nbp = sese_nb_params (region);\n-  isl_space *space = isl_space_set_alloc (scop->isl_context, nbp, 0);\n-\n-  unsigned i;\n-  tree e;\n-  FOR_EACH_VEC_ELT (region->params, i, e)\n-    space = isl_space_set_dim_id (space, isl_dim_param, i,\n-                                  isl_id_for_ssa_name (scop, e));\n-\n-  scop->param_context = isl_set_universe (space);\n-}\n-\n-static inline bool\n-cleanup_loop_iter_dom (isl_set *inner, isl_set *outer, isl_space *space, mpz_t g)\n-{\n-  isl_set_free (inner);\n-  isl_set_free (outer);\n-  isl_space_free (space);\n-  mpz_clear (g);\n-  return false;\n-}\n-\n-/* Builds the constraint polyhedra for LOOP in SCOP.  OUTER_PH gives\n-   the constraints for the surrounding loops.  */\n-\n-static bool\n-build_loop_iteration_domains (scop_p scop, struct loop *loop,\n-                              int nb,\n-\t\t\t      isl_set *outer, isl_set **doms)\n-{\n-\n-  tree nb_iters = number_of_latch_executions (loop);\n-  const sese_l& region = scop->scop_info->region;\n-  gcc_assert (loop_in_sese_p (loop, region));\n-\n-  isl_set *inner = isl_set_copy (outer);\n-  int pos = isl_set_dim (outer, isl_dim_set);\n-  isl_val *v;\n-  mpz_t g;\n-\n-  mpz_init (g);\n-\n-  inner = isl_set_add_dims (inner, isl_dim_set, 1);\n-  isl_space *space = isl_set_get_space (inner);\n-\n-  /* 0 <= loop_i */\n-  isl_constraint *c = isl_inequality_alloc\n-      (isl_local_space_from_space (isl_space_copy (space)));\n-  c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, 1);\n-  inner = isl_set_coalesce (isl_set_add_constraint (inner, c));\n-\n-  /* loop_i <= cst_nb_iters */\n-  if (TREE_CODE (nb_iters) == INTEGER_CST)\n-    {\n-      c = isl_inequality_alloc\n-\t  (isl_local_space_from_space (isl_space_copy (space)));\n-      c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, -1);\n-      tree_int_to_gmp (nb_iters, g);\n-      v = isl_val_int_from_gmp (scop->isl_context, g);\n-      c = isl_constraint_set_constant_val (c, v);\n-      inner = isl_set_add_constraint (inner, c);\n-    }\n-\n-  /* loop_i <= expr_nb_iters */\n-  else if (!chrec_contains_undetermined (nb_iters))\n-    {\n-      isl_pw_aff *aff;\n-\n-      nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n-\n-      /* Bail out as we do not know the scev.  */\n-      if (chrec_contains_undetermined (nb_iters))\n-\treturn cleanup_loop_iter_dom (inner, outer, space, g);\n-\n-      aff = extract_affine (scop, nb_iters, isl_set_get_space (inner));\n-      isl_set *valid = isl_pw_aff_nonneg_set (isl_pw_aff_copy (aff));\n-      valid = isl_set_project_out (valid, isl_dim_set, 0,\n-\t\t\t\t   isl_set_dim (valid, isl_dim_set));\n-\n-      if (valid)\n-\tscop->param_context = isl_set_coalesce\n-\t  (isl_set_intersect (scop->param_context, valid));\n-\n-      isl_local_space *ls = isl_local_space_from_space (isl_space_copy (space));\n-      isl_aff *al = isl_aff_set_coefficient_si (isl_aff_zero_on_domain (ls),\n-\t\t\t\t\t\tisl_dim_in, pos, 1);\n-      isl_set *le = isl_pw_aff_le_set (isl_pw_aff_from_aff (al),\n-\t\t\t\t       isl_pw_aff_copy (aff));\n-      inner = isl_set_intersect (inner, le);\n-\n-      widest_int nit;\n-      if (max_stmt_executions (loop, &nit))\n-\t{\n-\t  /* Insert in the context the constraints from the\n-\t     estimation of the number of iterations NIT and the\n-\t     symbolic number of iterations (involving parameter\n-\t     names) NB_ITERS.  First, build the affine expression\n-\t     \"NIT - NB_ITERS\" and then say that it is positive,\n-\t     i.e., NIT approximates NB_ITERS: \"NIT >= NB_ITERS\".  */\n-\t  mpz_t g;\n-\t  mpz_init (g);\n-\t  wi::to_mpz (nit, g, SIGNED);\n-\t  mpz_sub_ui (g, g, 1);\n-\n-\t  isl_pw_aff *approx\n-\t    = extract_affine_gmp (g, isl_set_get_space (inner));\n-\t  isl_set *x = isl_pw_aff_ge_set (approx, aff);\n-\t  x = isl_set_project_out (x, isl_dim_set, 0,\n-\t\t\t\t   isl_set_dim (x, isl_dim_set));\n-\t  scop->param_context = isl_set_coalesce\n-\t    (isl_set_intersect (scop->param_context, x));\n-\n-\t  isl_constraint *c = isl_inequality_alloc\n-\t      (isl_local_space_from_space (isl_space_copy (space)));\n-\t  c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, -1);\n-\t  v = isl_val_int_from_gmp (scop->isl_context, g);\n-\t  mpz_clear (g);\n-\t  c = isl_constraint_set_constant_val (c, v);\n-\t  inner = isl_set_add_constraint (inner, c);\n-\t}\n-      else\n-\tisl_pw_aff_free (aff);\n-    }\n-  else\n-    gcc_unreachable ();\n-\n-  inner = isl_set_coalesce (inner);\n-  if (loop->inner\n-      && !build_loop_iteration_domains (scop, loop->inner, nb + 1,\n-\t\t\t\t\tisl_set_copy (inner), doms))\n-    return cleanup_loop_iter_dom (inner, outer, space, g);\n-\n-  if (nb != 0\n-      && loop->next\n-      && loop_in_sese_p (loop->next, region)\n-      && !build_loop_iteration_domains (scop, loop->next, nb,\n-\t\t\t\t\tisl_set_copy (outer), doms))\n-    return cleanup_loop_iter_dom (inner, outer, space, g);\n-\n-  doms[loop->num] = inner;\n-\n-  isl_set_free (outer);\n-  isl_space_free (space);\n-  mpz_clear (g);\n-  return true;\n-}\n-\n /* Returns a linear expression for tree T evaluated in PBB.  */\n \n static isl_pw_aff *\n@@ -781,64 +628,6 @@ add_param_constraints (scop_p scop, graphite_dim_t p)\n     }\n }\n \n-/* Build the context of the SCOP.  The context usually contains extra\n-   constraints that are added to the iteration domains that constrain\n-   some parameters.  */\n-\n-static void\n-build_scop_context (scop_p scop)\n-{\n-  graphite_dim_t p, n = scop_nb_params (scop);\n-\n-  for (p = 0; p < n; p++)\n-    add_param_constraints (scop, p);\n-}\n-\n-/* Build the iteration domains: the loops belonging to the current\n-   SCOP, and that vary for the execution of the current basic block.\n-   Returns false if there is no loop in SCOP.  */\n-\n-static bool\n-build_scop_iteration_domain (scop_p scop)\n-{\n-  sese_info_p region = scop->scop_info;\n-  int nb_loops = number_of_loops (cfun);\n-  isl_set **doms = XCNEWVEC (isl_set *, nb_loops);\n-  bool res = true;\n-  int i;\n-  struct loop *loop;\n-  FOR_EACH_VEC_ELT (region->loop_nest, i, loop)\n-    if (!loop_in_sese_p (loop_outer (loop), region->region)\n-\t&& !build_loop_iteration_domains (scop, loop, 0,\n-\t\t\t\t\t  isl_set_copy (scop->param_context), doms))\n-      {\n-\tres = false;\n-\tgoto cleanup;\n-      }\n-\n-  poly_bb_p pbb;\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    {\n-      loop = pbb_loop (pbb);\n-\n-      if (doms[loop->num])\n-\tpbb->domain = isl_set_copy (doms[loop->num]);\n-      else\n-\tpbb->domain = isl_set_copy (scop->param_context);\n-\n-      pbb->domain = isl_set_set_tuple_id (pbb->domain,\n-\t\t\t\t\t  isl_id_for_pbb (scop, pbb));\n-    }\n-\n- cleanup:\n-  for (int i = 0; i < nb_loops; i++)\n-    if (doms[i])\n-      isl_set_free (doms[i]);\n-\n-  free (doms);\n-  return res;\n-}\n-\n /* Add a constrain to the ACCESSES polyhedron for the alias set of\n    data reference DR.  ACCESSP_NB_DIMS is the dimension of the\n    ACCESSES polyhedron, DOM_NB_DIMS is the dimension of the iteration\n@@ -1109,17 +898,205 @@ build_scop_drs (scop_p scop)\n     build_poly_sr (pbb);\n }\n \n+/* Add constraints to DOMAIN for each loop from LOOP up to CONTEXT.  */\n+\n+static isl_set *\n+add_loop_constraints (scop_p scop, __isl_take isl_set *domain, loop_p loop,\n+\t\t      loop_p context)\n+{\n+  if (loop == context)\n+    return domain;\n+  const sese_l &region = scop->scop_info->region;\n+  if (!loop_in_sese_p (loop, region))\n+    return domain;\n+\n+  /* Recursion all the way up to the context loop.  */\n+  domain = add_loop_constraints (scop, domain, loop_outer (loop), context);\n+\n+  /* Then, build constraints over the loop in post-order: outer to inner.  */\n+\n+  int loop_index = isl_set_dim (domain, isl_dim_set);\n+  if (dump_file)\n+    fprintf (dump_file, \"[sese-to-poly] adding one extra dimension to the \"\n+\t     \"domain for loop_%d.\\n\", loop->num);\n+  domain = isl_set_add_dims (domain, isl_dim_set, 1);\n+  isl_space *space = isl_set_get_space (domain);\n+\n+  /* 0 <= loop_i */\n+  isl_local_space *ls = isl_local_space_from_space (isl_space_copy (space));\n+  isl_constraint *c = isl_inequality_alloc (ls);\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_set, loop_index, 1);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"[sese-to-poly] adding constraint to the domain: \");\n+      print_isl_constraint (dump_file, c);\n+    }\n+  domain = isl_set_add_constraint (domain, c);\n+\n+  tree nb_iters = number_of_latch_executions (loop);\n+  if (TREE_CODE (nb_iters) == INTEGER_CST)\n+    {\n+      /* loop_i <= cst_nb_iters */\n+      isl_local_space *ls = isl_local_space_from_space (space);\n+      isl_constraint *c = isl_inequality_alloc (ls);\n+      c = isl_constraint_set_coefficient_si (c, isl_dim_set, loop_index, -1);\n+      mpz_t g;\n+      mpz_init (g);\n+      tree_int_to_gmp (nb_iters, g);\n+      isl_val *v = isl_val_int_from_gmp (scop->isl_context, g);\n+      mpz_clear (g);\n+      c = isl_constraint_set_constant_val (c, v);\n+      return isl_set_add_constraint (domain, c);\n+    }\n+  /* loop_i <= expr_nb_iters */\n+  gcc_assert (!chrec_contains_undetermined (nb_iters));\n+  nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n+  gcc_assert (!chrec_contains_undetermined (nb_iters));\n+\n+  isl_pw_aff *aff_nb_iters = extract_affine (scop, nb_iters,\n+\t\t\t\t\t     isl_space_copy (space));\n+  isl_set *valid = isl_pw_aff_nonneg_set (isl_pw_aff_copy (aff_nb_iters));\n+  valid = isl_set_project_out (valid, isl_dim_set, 0,\n+\t\t\t       isl_set_dim (valid, isl_dim_set));\n+\n+  if (valid)\n+    scop->param_context = isl_set_intersect (scop->param_context, valid);\n+\n+  ls = isl_local_space_from_space (isl_space_copy (space));\n+  isl_aff *loop_i = isl_aff_set_coefficient_si (isl_aff_zero_on_domain (ls),\n+\t\t\t\t\t\tisl_dim_in, loop_index, 1);\n+  isl_set *le = isl_pw_aff_le_set (isl_pw_aff_from_aff (loop_i),\n+\t\t\t\t   isl_pw_aff_copy (aff_nb_iters));\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"[sese-to-poly] adding constraint to the domain: \");\n+      print_isl_set (dump_file, le);\n+    }\n+  domain = isl_set_intersect (domain, le);\n+\n+  widest_int nit;\n+  if (!max_stmt_executions (loop, &nit))\n+    {\n+      isl_pw_aff_free (aff_nb_iters);\n+      isl_space_free (space);\n+      return domain;\n+    }\n+\n+  /* NIT is an upper bound to NB_ITERS: \"NIT >= NB_ITERS\", although we\n+     do not know whether the loop executes at least once.  */\n+  mpz_t g;\n+  mpz_init (g);\n+  wi::to_mpz (nit, g, SIGNED);\n+  mpz_sub_ui (g, g, 1);\n+\n+  isl_pw_aff *approx = extract_affine_gmp (g, isl_space_copy (space));\n+  isl_set *x = isl_pw_aff_ge_set (approx, aff_nb_iters);\n+  x = isl_set_project_out (x, isl_dim_set, 0,\n+\t\t\t   isl_set_dim (x, isl_dim_set));\n+  scop->param_context = isl_set_intersect (scop->param_context, x);\n+\n+  ls = isl_local_space_from_space (space);\n+  c = isl_inequality_alloc (ls);\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_set, loop_index, -1);\n+  isl_val *v = isl_val_int_from_gmp (scop->isl_context, g);\n+  mpz_clear (g);\n+  c = isl_constraint_set_constant_val (c, v);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"[sese-to-poly] adding constraint to the domain: \");\n+      print_isl_constraint (dump_file, c);\n+    }\n+\n+  return isl_set_add_constraint (domain, c);\n+}\n+\n+/* Builds the original iteration domains for each pbb in the SCOP.  */\n+\n+static int\n+build_iteration_domains (scop_p scop, __isl_keep isl_set *context, int index,\n+\t\t\t loop_p context_loop)\n+{\n+  loop_p current = pbb_loop (scop->pbbs[index]);\n+  isl_set *domain = isl_set_copy (context);\n+  domain = add_loop_constraints (scop, domain, current, context_loop);\n+  const sese_l &region = scop->scop_info->region;\n+\n+  int i;\n+  poly_bb_p pbb;\n+  FOR_EACH_VEC_ELT_FROM (scop->pbbs, i, pbb, index)\n+    {\n+      loop_p loop = pbb_loop (pbb);\n+      if (current == loop)\n+\t{\n+\t  pbb->domain = isl_set_copy (domain);\n+\t  pbb->domain = isl_set_set_tuple_id (pbb->domain,\n+\t\t\t\t\t      isl_id_for_pbb (scop, pbb));\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"[sese-to-poly] set pbb_%d->domain: \",\n+\t\t       pbb_index (pbb));\n+\t      print_isl_set (dump_file, domain);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      while (loop_in_sese_p (loop, region)\n+\t     && current != loop)\n+\tloop = loop_outer (loop);\n+\n+      if (current != loop)\n+\t{\n+\t  /* A statement in a different loop nest than CURRENT loop.  */\n+\t  isl_set_free (domain);\n+\t  return i;\n+\t}\n+\n+      /* A statement nested in the CURRENT loop.  */\n+      i = build_iteration_domains (scop, domain, i, current);\n+      i--;\n+    }\n+\n+  isl_set_free (domain);\n+  return i;\n+}\n+\n+\n+/* Assign dimension for each parameter in SCOP and add constraints for the\n+   parameters.  */\n+\n+static void\n+build_scop_context (scop_p scop)\n+{\n+  sese_info_p region = scop->scop_info;\n+  unsigned nbp = sese_nb_params (region);\n+  isl_space *space = isl_space_set_alloc (scop->isl_context, nbp, 0);\n+\n+  unsigned i;\n+  tree e;\n+  FOR_EACH_VEC_ELT (region->params, i, e)\n+    space = isl_space_set_dim_id (space, isl_dim_param, i,\n+                                  isl_id_for_ssa_name (scop, e));\n+\n+  scop->param_context = isl_set_universe (space);\n+\n+  graphite_dim_t p;\n+  for (p = 0; p < nbp; p++)\n+    add_param_constraints (scop, p);\n+}\n+\n /* Builds the polyhedral representation for a SESE region.  */\n \n bool\n build_poly_scop (scop_p scop)\n {\n-  set_scop_parameter_dim (scop);\n-  if (!build_scop_iteration_domain (scop))\n-    return false;\n-\n   build_scop_context (scop);\n \n+  unsigned i = 0;\n+  unsigned n = scop->pbbs.length ();\n+  while (i < n)\n+    i = build_iteration_domains (scop, scop->param_context, i, NULL);\n+\n   if (!add_conditions_to_constraints (scop))\n     return false;\n "}]}