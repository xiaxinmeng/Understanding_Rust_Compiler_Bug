{"sha": "5629b16c018a9d6fec937f506f577c691a62fc44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYyOWIxNmMwMThhOWQ2ZmVjOTM3ZjUwNmY1NzdjNjkxYTYyZmM0NA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-12-06T04:19:20Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-12-06T04:19:20Z"}, "message": "loop.c (check_dbra_loop): New argument loop_info.\n\n        * loop.c (check_dbra_loop): New argument loop_info.  Update fields\n        as needed.\n\nFrom-SVN: r24131", "tree": {"sha": "5f0e818607ec9e05bbe0fa61694c620285e29e75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f0e818607ec9e05bbe0fa61694c620285e29e75"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5629b16c018a9d6fec937f506f577c691a62fc44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5629b16c018a9d6fec937f506f577c691a62fc44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5629b16c018a9d6fec937f506f577c691a62fc44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5629b16c018a9d6fec937f506f577c691a62fc44/comments", "author": null, "committer": null, "parents": [{"sha": "01bdf1bc986ced960799b5d6f99239fb5d7387dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01bdf1bc986ced960799b5d6f99239fb5d7387dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01bdf1bc986ced960799b5d6f99239fb5d7387dd"}], "stats": {"total": 21, "additions": 18, "deletions": 3}, "files": [{"sha": "ac6594f34f02da210bf1186f0f17b259c1f95595", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5629b16c018a9d6fec937f506f577c691a62fc44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5629b16c018a9d6fec937f506f577c691a62fc44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5629b16c018a9d6fec937f506f577c691a62fc44", "patch": "@@ -1,3 +1,8 @@\n+Sun Dec  6 05:16:16 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* loop.c (check_dbra_loop): New argument loop_info.  Update fields\n+\tas needed.\n+\n Sun Dec 6 03:40:13 PST 1998 Jeff Law  (law@cygnus.com)\n \n \t* version.c: Bump for snapshot."}, {"sha": "959c4e6698423ca8b1d8d5ea9691bc823b5ba3c0", "filename": "gcc/loop.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5629b16c018a9d6fec937f506f577c691a62fc44/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5629b16c018a9d6fec937f506f577c691a62fc44/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=5629b16c018a9d6fec937f506f577c691a62fc44", "patch": "@@ -312,7 +312,7 @@ static int basic_induction_var PROTO((rtx, enum machine_mode, rtx, rtx, rtx *, r\n static rtx simplify_giv_expr PROTO((rtx, int *));\n static int general_induction_var PROTO((rtx, rtx *, rtx *, rtx *, int, int *));\n static int consec_sets_giv PROTO((int, rtx, rtx, rtx, rtx *, rtx *));\n-static int check_dbra_loop PROTO((rtx, int, rtx));\n+static int check_dbra_loop PROTO((rtx, int, rtx, struct loop_info *));\n static rtx express_from_1 PROTO((rtx, rtx, rtx));\n static rtx express_from PROTO((struct induction *, struct induction *));\n static rtx combine_givs_p PROTO((struct induction *, struct induction *));\n@@ -4041,7 +4041,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   /* Try to prove that the loop counter variable (if any) is always\n      nonnegative; if so, record that fact with a REG_NONNEG note\n      so that \"decrement and branch until zero\" insn can be used.  */\n-  check_dbra_loop (loop_end, insn_count, loop_start);\n+  check_dbra_loop (loop_end, insn_count, loop_start, loop_info);\n \n   /* Create reg_map to hold substitutions for replaceable giv regs.  */\n   reg_map = (rtx *) alloca (max_reg_before_loop * sizeof (rtx));\n@@ -6634,10 +6634,11 @@ product_cheap_p (a, b)\n    final_[bg]iv_value.  */\n \n static int\n-check_dbra_loop (loop_end, insn_count, loop_start)\n+check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n      rtx loop_end;\n      int insn_count;\n      rtx loop_start;\n+     struct loop_info *loop_info;\n {\n   struct iv_class *bl;\n   rtx reg;\n@@ -7065,6 +7066,15 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t      bl->initial_value = start_value;\n \t      bl->biv->add_val = new_add_val;\n \n+\t      /* Update loop info.  */\n+\t      loop_info->initial_value = bl->initial_value;\n+\t      loop_info->initial_equiv_value = bl->initial_value;\n+\t      loop_info->final_value = const0_rtx;\n+\t      loop_info->final_equiv_value = const0_rtx;\n+\t      loop_info->comparison_value = const0_rtx;\n+\t      loop_info->comparison_code = cmp_code;\n+\t      loop_info->increment = new_add_val;\n+\n \t      /* Inc LABEL_NUSES so that delete_insn will\n \t\t not delete the label.  */\n \t      LABEL_NUSES (XEXP (jump_label, 0)) ++;"}]}