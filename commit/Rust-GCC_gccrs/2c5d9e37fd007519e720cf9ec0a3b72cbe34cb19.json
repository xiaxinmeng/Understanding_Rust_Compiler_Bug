{"sha": "2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM1ZDllMzdmZDAwNzUxOWU3MjBjZjllYzBhM2I3MmNiZTM0Y2IxOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-01T23:53:22Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-01T23:53:22Z"}, "message": "(reg_allocno): Declare.\n\n(order_regs_for_reload): New arg, GLOBAL.\nBias against regs allocated in local-alloc.\n(reload): Pass new parm to order_regs_for_reload.\n\nFrom-SVN: r10932", "tree": {"sha": "7d8fbee62445950b7b7269107b0f03d11e242e44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d8fbee62445950b7b7269107b0f03d11e242e44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19/comments", "author": null, "committer": null, "parents": [{"sha": "f7627ef46dd4024a551493e12a6a65ea2b97c16d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7627ef46dd4024a551493e12a6a65ea2b97c16d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7627ef46dd4024a551493e12a6a65ea2b97c16d"}], "stats": {"total": 24, "additions": 18, "deletions": 6}, "files": [{"sha": "3f5403c320c8db008a8d1c0696ea9ab3517e2811", "filename": "gcc/reload1.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2c5d9e37fd007519e720cf9ec0a3b72cbe34cb19", "patch": "@@ -1,5 +1,5 @@\n /* Reload pseudo regs into hard regs for insns that require hard regs.\n-   Copyright (C) 1987, 88, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 89, 92-5, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -270,6 +270,9 @@ char *reload_firstobj;\n \n /* List of labels that must never be deleted.  */\n extern rtx forced_labels;\n+\n+/* Allocation number table from global register allocation.  */\n+extern int *reg_allocno;\n \f\n /* This structure is used to record information about register eliminations.\n    Each array entry describes one possible way of eliminating a register\n@@ -351,7 +354,7 @@ static int spill_hard_reg\t\tPROTO((int, int, FILE *, int));\n static void scan_paradoxical_subregs\tPROTO((rtx));\n static int hard_reg_use_compare\t\tPROTO((struct hard_reg_n_uses *,\n \t\t\t\t\t       struct hard_reg_n_uses *));\n-static void order_regs_for_reload\tPROTO((void));\n+static void order_regs_for_reload\tPROTO((int));\n static int compare_spill_regs\t\tPROTO((short *, short *));\n static void reload_as_needed\t\tPROTO((rtx, int));\n static void forget_old_reloads_1\tPROTO((rtx, rtx));\n@@ -691,7 +694,7 @@ reload (first, global, dumpfile)\n   /* Compute the order of preference for hard registers to spill.\n      Store them by decreasing preference in potential_reload_regs.  */\n \n-  order_regs_for_reload ();\n+  order_regs_for_reload (global);\n \n   /* So far, no hard regs have been spilled.  */\n   n_spills = 0;\n@@ -3494,7 +3497,7 @@ spill_hard_reg (regno, global, dumpfile, cant_eliminate)\n \t/* We will need to scan everything again.  */\n \tsomething_changed = 1;\n \tif (global)\n-\t    retry_global_alloc (i, forbidden_regs);\n+\t  retry_global_alloc (i, forbidden_regs);\n \n \talter_reg (i, regno);\n \tif (dumpfile)\n@@ -3603,7 +3606,8 @@ hard_reg_use_compare (p1, p2)\n    Store them in order of decreasing preference in potential_reload_regs.  */\n \n static void\n-order_regs_for_reload ()\n+order_regs_for_reload (global)\n+     int global;\n {\n   register int i;\n   register int o = 0;\n@@ -3632,7 +3636,15 @@ order_regs_for_reload ()\n \t{\n \t  int lim = regno + HARD_REGNO_NREGS (regno, PSEUDO_REGNO_MODE (i));\n \t  while (regno < lim)\n-\t    hard_reg_n_uses[regno++].uses += reg_n_refs[i];\n+\t    {\n+\t      /* If allocated by local-alloc, show more uses since\n+\t\t we're not going to be able to reallocate it, but\n+\t\t we might if allocated by global alloc.  */\n+\t      if (global && reg_allocno[i] < 0)\n+\t\thard_reg_n_uses[regno].uses += (reg_n_refs[i] + 1) / 2;\n+\n+\t      hard_reg_n_uses[regno++].uses += reg_n_refs[i];\n+\t    }\n \t}\n       large += reg_n_refs[i];\n     }"}]}