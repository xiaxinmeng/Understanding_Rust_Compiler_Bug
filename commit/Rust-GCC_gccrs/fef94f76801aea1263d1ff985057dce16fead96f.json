{"sha": "fef94f76801aea1263d1ff985057dce16fead96f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVmOTRmNzY4MDFhZWExMjYzZDFmZjk4NTA1N2RjZTE2ZmVhZDk2Zg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-09-02T17:52:18Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-09-02T17:52:18Z"}, "message": "tree-sra.c (struct access): New field grp_hint.\n\n2009-09-02  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (struct access): New field grp_hint.\n\t(dump_access): Dump grp_hint.\n\t(sort_and_splice_var_accesses): Set grp_hint if a group is read\n\tmultiple times.\n\t(analyze_access_subtree): Only scalarize accesses with grp_hint set or\n\tthose which have been specifically read and somehow written to.\n\t(propagate_subacesses_accross_link): Set grp_hint of right child and\n\talso possibly of the left child.\n\n\t* testsuite/gcc.dg/tree-ssa/sra-8.c: New testcase.\n\t* testsuite/gcc.dg/memcpy-1.c: Add . to match pattern.\n\t* testsuite/gcc.dg/uninit-I.c: XFAIL warning test.\n\t* testsuite/g++.dg/warn/unit-1.C: XFAIL warning test.\n\nFrom-SVN: r151345", "tree": {"sha": "98148830f4cfbf1657daafe9c739844729ce140b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98148830f4cfbf1657daafe9c739844729ce140b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fef94f76801aea1263d1ff985057dce16fead96f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef94f76801aea1263d1ff985057dce16fead96f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef94f76801aea1263d1ff985057dce16fead96f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef94f76801aea1263d1ff985057dce16fead96f/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd2ab214c53f39a2fb68d3b394103db62af78c50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2ab214c53f39a2fb68d3b394103db62af78c50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd2ab214c53f39a2fb68d3b394103db62af78c50"}], "stats": {"total": 110, "additions": 93, "deletions": 17}, "files": [{"sha": "6cb7e9c7c334c78be399e3ce2062b29b886f4876", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fef94f76801aea1263d1ff985057dce16fead96f", "patch": "@@ -1,3 +1,14 @@\n+2009-09-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (struct access): New field grp_hint.\n+\t(dump_access): Dump grp_hint.\n+\t(sort_and_splice_var_accesses): Set grp_hint if a group is read\n+\tmultiple times.\n+\t(analyze_access_subtree): Only scalarize accesses with grp_hint set or\n+\tthose which have been specifically read and somehow written to.\n+\t(propagate_subacesses_accross_link): Set grp_hint of right child and\n+\talso possibly of the left child.\n+\n 2009-09-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-object-size.c (addr_object_size): Always use object_size_type"}, {"sha": "de4a9665194a179c0db69f25f508bab1d009b5f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fef94f76801aea1263d1ff985057dce16fead96f", "patch": "@@ -1,3 +1,10 @@\n+2009-09-02  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/sra-8.c: New testcase.\n+\t* gcc.dg/memcpy-1.c: Add . to match pattern.\n+\t* gcc.dg/uninit-I.c: XFAIL warning test.\n+\t* g++.dg/warn/unit-1.C: XFAIL warning test.\n+\t\n 2009-09-02  Ian Lance Taylor  <iant@google.com>\n \n \t* gcc.dg/20090902-1.c: New test."}, {"sha": "9c09d3f53cb4e526c04536acb95a7513f1db2333", "filename": "gcc/testsuite/g++.dg/warn/unit-1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funit-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funit-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funit-1.C?ref=fef94f76801aea1263d1ff985057dce16fead96f", "patch": "@@ -4,7 +4,7 @@\n struct a { int mode; };\n int sys_msgctl (void)\n {\n-  struct a setbuf;  /* { dg-warning \"'setbuf\\.a::mode' is used\" } */\n+  struct a setbuf;  /* { dg-warning \"'setbuf\\.a::mode' is used\" \"\" { xfail *-*-* } } */\n   return setbuf.mode;\n }\n "}, {"sha": "0952a261ad0c0265d278b454766aad2ec0d1472f", "filename": "gcc/testsuite/gcc.dg/memcpy-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcpy-1.c?ref=fef94f76801aea1263d1ff985057dce16fead96f", "patch": "@@ -1,7 +1,7 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-optimized\" } */\n /* PR36598 AVR fail maybe due to cost metrics */\n-/* { dg-final { scan-tree-dump-times \"nasty_local\" 0 \"optimized\" { xfail { \"avr-*-*\" } } } } */\n+/* { dg-final { scan-tree-dump-times \"nasty_local\\\\.\" 0 \"optimized\" { xfail { \"avr-*-*\" } } } } */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */\n struct a {int a,b,c;} a;\n int test(struct a a)"}, {"sha": "d43bbe0d8a3b6d66a5241d4262ef0d5038fd83c8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-8.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-8.c?ref=fef94f76801aea1263d1ff985057dce16fead96f", "patch": "@@ -0,0 +1,35 @@\n+/* A testcase for PR 40744.  We do not want to create replacements for object\n+   that are dead or have only a single use, whenever it can be avoided\n+   simply. */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-esra-details\" } */\n+\n+struct X { int i; int j; };\n+\n+void foo(void)\n+{\n+  struct X x;\n+  x.i = 1;\n+  x.j = 2;\n+}\n+\n+\n+int bar(struct X x)\n+{\n+  return x.i;\n+}\n+\n+\n+extern void do_something (struct X);\n+\n+void bar2(int i, int j)\n+{\n+  struct X x;\n+\n+  x.i = i;\n+  x.j = j;\n+  do_something (x);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Created a replacement\" 0 \"esra\"} } */\n+/* { dg-final { cleanup-tree-dump \"esra\" } } */"}, {"sha": "064e42d55d08fe3ea5bb23a70f06539eef6cbff4", "filename": "gcc/testsuite/gcc.dg/uninit-I.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-I.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-I.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-I.c?ref=fef94f76801aea1263d1ff985057dce16fead96f", "patch": "@@ -3,6 +3,6 @@\n \n int sys_msgctl (void)\n {\n-  struct { int mode; } setbuf;  /* { dg-warning \"'setbuf\\.mode' is used\" } */\n+  struct { int mode; } setbuf;  /* { dg-warning \"'setbuf\\.mode' is used\" \"\" { xfail *-*-* } } */\n   return setbuf.mode;\n }"}, {"sha": "8d4dc90d1799ba306b432520e40a1e70e9bcee12", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef94f76801aea1263d1ff985057dce16fead96f/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fef94f76801aea1263d1ff985057dce16fead96f", "patch": "@@ -165,6 +165,10 @@ struct access\n   /* Does this group contain a read access?  This flag is propagated down the\n      access tree.  */\n   unsigned grp_read : 1;\n+  /* Other passes of the analysis use this bit to make function\n+     analyze_access_subtree create scalar replacements for this group if\n+     possible.  */\n+  unsigned grp_hint : 1;\n   /* Is the subtree rooted in this access fully covered by scalar\n      replacements?  */\n   unsigned grp_covered : 1;\n@@ -261,12 +265,14 @@ dump_access (FILE *f, struct access *access, bool grp)\n   fprintf (f, \", type = \");\n   print_generic_expr (f, access->type, 0);\n   if (grp)\n-    fprintf (f, \", grp_write = %d, grp_read = %d, grp_covered = %d, \"\n-\t     \"grp_unscalarizable_region = %d, grp_unscalarized_data = %d, \"\n-\t     \"grp_partial_lhs = %d, grp_to_be_replaced = %d\\n\",\n-\t     access->grp_write, access->grp_read, access->grp_covered,\n-\t     access->grp_unscalarizable_region, access->grp_unscalarized_data,\n-\t     access->grp_partial_lhs, access->grp_to_be_replaced);\n+    fprintf (f, \", grp_write = %d, grp_read = %d, grp_hint = %d, \"\n+\t     \"grp_covered = %d, grp_unscalarizable_region = %d, \"\n+\t     \"grp_unscalarized_data = %d, grp_partial_lhs = %d, \"\n+\t     \"grp_to_be_replaced = %d\\n\",\n+\t     access->grp_write, access->grp_read, access->grp_hint,\n+\t     access->grp_covered, access->grp_unscalarizable_region,\n+\t     access->grp_unscalarized_data, access->grp_partial_lhs,\n+\t     access->grp_to_be_replaced);\n   else\n     fprintf (f, \", write = %d, grp_partial_lhs = %d\\n\", access->write,\n \t     access->grp_partial_lhs);\n@@ -1203,8 +1209,9 @@ sort_and_splice_var_accesses (tree var)\n   while (i < access_count)\n     {\n       struct access *access = VEC_index (access_p, access_vec, i);\n-      bool modification = access->write;\n+      bool grp_write = access->write;\n       bool grp_read = !access->write;\n+      bool multiple_reads = false;\n       bool grp_partial_lhs = access->grp_partial_lhs;\n       bool first_scalar = is_gimple_reg_type (access->type);\n       bool unscalarizable_region = access->grp_unscalarizable_region;\n@@ -1227,8 +1234,15 @@ sort_and_splice_var_accesses (tree var)\n \t  struct access *ac2 = VEC_index (access_p, access_vec, j);\n \t  if (ac2->offset != access->offset || ac2->size != access->size)\n \t    break;\n-\t  modification |= ac2->write;\n-\t  grp_read |= !ac2->write;\n+\t  if (ac2->write)\n+\t    grp_write = true;\n+\t  else\n+\t    {\n+\t      if (grp_read)\n+\t\tmultiple_reads = true;\n+\t      else\n+\t\tgrp_read = true;\n+\t    }\n \t  grp_partial_lhs |= ac2->grp_partial_lhs;\n \t  unscalarizable_region |= ac2->grp_unscalarizable_region;\n \t  relink_to_new_repr (access, ac2);\n@@ -1244,8 +1258,9 @@ sort_and_splice_var_accesses (tree var)\n       i = j;\n \n       access->group_representative = access;\n-      access->grp_write = modification;\n+      access->grp_write = grp_write;\n       access->grp_read = grp_read;\n+      access->grp_hint = multiple_reads;\n       access->grp_partial_lhs = grp_partial_lhs;\n       access->grp_unscalarizable_region = unscalarizable_region;\n       if (access->first_link)\n@@ -1377,6 +1392,7 @@ analyze_access_subtree (struct access *root, bool allow_replacements,\n   HOST_WIDE_INT covered_to = root->offset;\n   bool scalar = is_gimple_reg_type (root->type);\n   bool hole = false, sth_created = false;\n+  bool direct_read = root->grp_read;\n \n   if (mark_read)\n     root->grp_read = true;\n@@ -1405,7 +1421,9 @@ analyze_access_subtree (struct access *root, bool allow_replacements,\n       hole |= !child->grp_covered;\n     }\n \n-  if (allow_replacements && scalar && !root->first_child)\n+  if (allow_replacements && scalar && !root->first_child\n+      && (root->grp_hint\n+\t  || (direct_read && root->grp_write)))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -1543,7 +1561,6 @@ propagate_subacesses_accross_link (struct access *lacc, struct access *racc)\n {\n   struct access *rchild;\n   HOST_WIDE_INT norm_delta = lacc->offset - racc->offset;\n-\n   bool ret = false;\n \n   if (is_gimple_reg_type (lacc->type)\n@@ -1570,8 +1587,13 @@ propagate_subacesses_accross_link (struct access *lacc, struct access *racc)\n       if (child_would_conflict_in_lacc (lacc, norm_offset, rchild->size,\n \t\t\t\t\t&new_acc))\n \t{\n-\t  if (new_acc && rchild->first_child)\n-\t    ret |= propagate_subacesses_accross_link (new_acc, rchild);\n+\t  if (new_acc)\n+\t    {\n+\t      rchild->grp_hint = 1;\n+\t      new_acc->grp_hint |= new_acc->grp_read;\n+\t      if (rchild->first_child)\n+\t\tret |= propagate_subacesses_accross_link (new_acc, rchild);\n+\t    }\n \t  continue;\n \t}\n \n@@ -1582,6 +1604,7 @@ propagate_subacesses_accross_link (struct access *lacc, struct access *racc)\n \t\t\t\t rchild->type, false))\n \tcontinue;\n \n+      rchild->grp_hint = 1;\n       new_acc = create_artificial_child_access (lacc, rchild, norm_offset);\n       if (racc->first_child)\n \tpropagate_subacesses_accross_link (new_acc, rchild);"}]}