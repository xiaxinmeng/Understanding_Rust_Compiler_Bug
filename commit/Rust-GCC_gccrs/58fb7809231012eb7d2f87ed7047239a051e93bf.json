{"sha": "58fb7809231012eb7d2f87ed7047239a051e93bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThmYjc4MDkyMzEwMTJlYjdkMmY4N2VkNzA0NzIzOWEwNTFlOTNiZg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2003-01-28T17:12:06Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2003-01-28T17:12:06Z"}, "message": "haifa-sched.c (schedule_insn): Return necessary cycle advance after issuing the insn.\n\n2003-01-28  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* haifa-sched.c (schedule_insn): Return necessary cycle advance\n\tafter issuing the insn.\n\t(rank_for_schedule): Make a insn with /S the highest priority\n\tinsn.\n\t(move_insn): Ignore schedule groups.  Clear SCHED_GROUP_P.\n\t(choose_ready): Check SCHED_GROUP_P.\n\t(schedule_block): Advance cycle after issuing insn if it is\n\tnecessary.  Don't reorder insns if there is an insn with /S.\n\t(set_priorities): Ignore schedule groups.\n\n\t* sched-deps.c (remove_dependence, group_leader): Remove the\n\tfunctions.\n\t(add_dependence): Ignore schedule groups.\n\t(set_sched_group_p): Don't make copy of dependencies from previous\n\tinsn of the schedule group.  Add anti-dependency to the previous\n\tinsn of the schedule group.\n\t(compute_forward_dependences): Ignore schedule groups.\n\n\t* sched-ebb.c (init_ready_list): Ignore schedule groups.\n\n\t* sched-rgn.c (init_ready_list): Ditto.\n\t(can_schedule_ready_p): Ditto.\n\nFrom-SVN: r61983", "tree": {"sha": "8180fc6a14989f4e80977340fde69e75dc5fec16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8180fc6a14989f4e80977340fde69e75dc5fec16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58fb7809231012eb7d2f87ed7047239a051e93bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58fb7809231012eb7d2f87ed7047239a051e93bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58fb7809231012eb7d2f87ed7047239a051e93bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58fb7809231012eb7d2f87ed7047239a051e93bf/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5db544e164f495bf4e1b98aa843df938bca92668", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5db544e164f495bf4e1b98aa843df938bca92668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5db544e164f495bf4e1b98aa843df938bca92668"}], "stats": {"total": 337, "additions": 99, "deletions": 238}, "files": [{"sha": "d2673bba0186cfcea011c221cb6a8f2da89cb174", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58fb7809231012eb7d2f87ed7047239a051e93bf", "patch": "@@ -1,3 +1,28 @@\n+2003-01-28  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* haifa-sched.c (schedule_insn): Return necessary cycle advance\n+\tafter issuing the insn.\n+\t(rank_for_schedule): Make a insn with /S the highest priority\n+\tinsn.\n+\t(move_insn): Ignore schedule groups.  Clear SCHED_GROUP_P.\n+\t(choose_ready): Check SCHED_GROUP_P.\n+\t(schedule_block): Advance cycle after issuing insn if it is\n+\tnecessary.  Don't reorder insns if there is an insn with /S.\n+\t(set_priorities): Ignore schedule groups.\n+\n+\t* sched-deps.c (remove_dependence, group_leader): Remove the\n+\tfunctions.\n+\t(add_dependence): Ignore schedule groups.\n+\t(set_sched_group_p): Don't make copy of dependencies from previous\n+\tinsn of the schedule group.  Add anti-dependency to the previous\n+\tinsn of the schedule group.\n+\t(compute_forward_dependences): Ignore schedule groups.\n+\n+\t* sched-ebb.c (init_ready_list): Ignore schedule groups.\n+\n+\t* sched-rgn.c (init_ready_list): Ditto.\n+\t(can_schedule_ready_p): Ditto.\n+\t\n 2003-01-28  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* config/i386/i386.md (*movsi_1): Use movdqa to move one xmm"}, {"sha": "ef4ec0a0786ec1e828e1a60f685d2b9f2984c268", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 60, "deletions": 52, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=58fb7809231012eb7d2f87ed7047239a051e93bf", "patch": "@@ -319,7 +319,7 @@ static int priority PARAMS ((rtx));\n static int rank_for_schedule PARAMS ((const PTR, const PTR));\n static void swap_sort PARAMS ((rtx *, int));\n static void queue_insn PARAMS ((rtx, int));\n-static void schedule_insn PARAMS ((rtx, struct ready_list *, int));\n+static int schedule_insn PARAMS ((rtx, struct ready_list *, int));\n static int find_set_reg_weight PARAMS ((rtx));\n static void find_insn_reg_weight PARAMS ((int));\n static void adjust_priority PARAMS ((rtx));\n@@ -852,6 +852,10 @@ rank_for_schedule (x, y)\n   int tmp_class, tmp2_class, depend_count1, depend_count2;\n   int val, priority_val, weight_val, info_val;\n \n+  /* The insn in a schedule group should be issued the first.  */\n+  if (SCHED_GROUP_P (tmp) != SCHED_GROUP_P (tmp2))\n+    return SCHED_GROUP_P (tmp2) ? 1 : -1;\n+\n   /* Prefer insn with higher priority.  */\n   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);\n \n@@ -1105,16 +1109,18 @@ static int last_clock_var;\n \n /* INSN is the \"currently executing insn\".  Launch each insn which was\n    waiting on INSN.  READY is the ready list which contains the insns\n-   that are ready to fire.  CLOCK is the current cycle.\n-   */\n+   that are ready to fire.  CLOCK is the current cycle.  The function\n+   returns necessary cycle advance after issuing the insn (it is not\n+   zero for insns in a schedule group).  */\n \n-static void\n+static int\n schedule_insn (insn, ready, clock)\n      rtx insn;\n      struct ready_list *ready;\n      int clock;\n {\n   rtx link;\n+  int advance = 0;\n   int unit = 0;\n \n   if (!targetm.sched.use_dfa_pipeline_interface\n@@ -1156,7 +1162,7 @@ schedule_insn (insn, ready, clock)\n \tschedule_unit (unit, insn, clock);\n       \n       if (INSN_DEPEND (insn) == 0)\n-\treturn;\n+\treturn 0;\n     }\n \n   for (link = INSN_DEPEND (insn); link != 0; link = XEXP (link, 1))\n@@ -1181,7 +1187,8 @@ schedule_insn (insn, ready, clock)\n \t      if (effective_cost < 1)\n \t\tfprintf (sched_dump, \"into ready\\n\");\n \t      else\n-\t\tfprintf (sched_dump, \"into queue with cost=%d\\n\", effective_cost);\n+\t\tfprintf (sched_dump, \"into queue with cost=%d\\n\",\n+\t\t\t effective_cost);\n \t    }\n \n \t  /* Adjust the priority of NEXT and either put it on the ready\n@@ -1190,7 +1197,12 @@ schedule_insn (insn, ready, clock)\n \t  if (effective_cost < 1)\n \t    ready_add (ready, next);\n \t  else\n-\t    queue_insn (next, effective_cost);\n+\t    {\n+\t      queue_insn (next, effective_cost);\n+\n+\t      if (SCHED_GROUP_P (next) && advance < effective_cost)\n+\t\tadvance = effective_cost;\n+\t    }\n \t}\n     }\n \n@@ -1207,6 +1219,7 @@ schedule_insn (insn, ready, clock)\n \tPUT_MODE (insn, clock > last_clock_var ? TImode : VOIDmode);\n       last_clock_var = clock;\n     }\n+  return advance;\n }\n \n /* Functions for handling of notes.  */\n@@ -1757,8 +1770,7 @@ reemit_notes (insn, last)\n   return retval;\n }\n \n-/* Move INSN, and all insns which should be issued before it,\n-   due to SCHED_GROUP_P flag.  Reemit notes if needed.\n+/* Move INSN.  Reemit notes if needed.\n \n    Return the last insn emitted by the scheduler, which is the\n    return value from the first call to reemit_notes.  */\n@@ -1769,26 +1781,6 @@ move_insn (insn, last)\n {\n   rtx retval = NULL;\n \n-  /* If INSN has SCHED_GROUP_P set, then issue it and any other\n-     insns with SCHED_GROUP_P set first.  */\n-  while (SCHED_GROUP_P (insn))\n-    {\n-      rtx prev = PREV_INSN (insn);\n-      \n-      /* Move a SCHED_GROUP_P insn.  */\n-      move_insn1 (insn, last);\n-      /* If this is the first call to reemit_notes, then record\n-\t its return value.  */\n-      if (retval == NULL_RTX)\n-\tretval = reemit_notes (insn, insn);\n-      else\n-\treemit_notes (insn, insn);\n-      /* Consume SCHED_GROUP_P flag.  */\n-      SCHED_GROUP_P (insn) = 0;\n-      insn = prev;\n-    }\n-\n-  /* Now move the first non SCHED_GROUP_P insn.  */\n   move_insn1 (insn, last);\n \n   /* If this is the first call to reemit_notes, then record\n@@ -1798,6 +1790,8 @@ move_insn (insn, last)\n   else\n     reemit_notes (insn, insn);\n \n+  SCHED_GROUP_P (insn) = 0;\n+\n   return retval;\n }\n \n@@ -1911,7 +1905,8 @@ choose_ready (ready)\n      struct ready_list *ready;\n {\n   if (!targetm.sched.first_cycle_multipass_dfa_lookahead\n-      || (*targetm.sched.first_cycle_multipass_dfa_lookahead) () <= 0)\n+      || (*targetm.sched.first_cycle_multipass_dfa_lookahead) () <= 0\n+      || SCHED_GROUP_P (ready_element (ready, 0)))\n     return ready_remove_first (ready);\n   else\n     {\n@@ -1961,7 +1956,7 @@ schedule_block (b, rgn_n_insns)\n   int i, first_cycle_insn_p;\n   int can_issue_more;\n   state_t temp_state = NULL;  /* It is used for multipass scheduling.  */\n-  int sort_p;\n+  int sort_p, advance, start_clock_var;\n \n   /* Head/tail info for this block.  */\n   rtx prev_head = current_sched_info->prev_head;\n@@ -2045,29 +2040,37 @@ schedule_block (b, rgn_n_insns)\n \n   /* Start just before the beginning of time.  */\n   clock_var = -1;\n+  advance = 0;\n \n   sort_p = TRUE;\n   /* Loop until all the insns in BB are scheduled.  */\n   while ((*current_sched_info->schedule_more_p) ())\n     {\n-      clock_var++;\n-\n-      advance_one_cycle ();\n-\n-      /* Add to the ready list all pending insns that can be issued now.\n-         If there are no ready insns, increment clock until one\n-         is ready and add all pending insns at that point to the ready\n-         list.  */\n-      queue_to_ready (&ready);\n-\n-      if (ready.n_ready == 0)\n-\tabort ();\n-\n-      if (sched_verbose >= 2)\n+      do\n \t{\n-\t  fprintf (sched_dump, \";;\\t\\tReady list after queue_to_ready:  \");\n-\t  debug_ready_list (&ready);\n+\t  start_clock_var = clock_var;\n+\n+\t  clock_var++;\n+\t  \n+\t  advance_one_cycle ();\n+\t  \n+\t  /* Add to the ready list all pending insns that can be issued now.\n+\t     If there are no ready insns, increment clock until one\n+\t     is ready and add all pending insns at that point to the ready\n+\t     list.  */\n+\t  queue_to_ready (&ready);\n+\t  \n+\t  if (ready.n_ready == 0)\n+\t    abort ();\n+\t  \n+\t  if (sched_verbose >= 2)\n+\t    {\n+\t      fprintf (sched_dump, \";;\\t\\tReady list after queue_to_ready:  \");\n+\t      debug_ready_list (&ready);\n+\t    }\n+\t  advance -= clock_var - start_clock_var;\n \t}\n+      while (advance > 0);\n \n       if (sort_p)\n \t{\n@@ -2083,7 +2086,9 @@ schedule_block (b, rgn_n_insns)\n \n       /* Allow the target to reorder the list, typically for\n \t better instruction bundling.  */\n-      if (targetm.sched.reorder)\n+      if (targetm.sched.reorder\n+\t  && (ready.n_ready == 0\n+\t      || !SCHED_GROUP_P (ready_element (&ready, 0))))\n \tcan_issue_more =\n \t  (*targetm.sched.reorder) (sched_dump, sched_verbose,\n \t\t\t\t    ready_lastpos (&ready),\n@@ -2256,7 +2261,9 @@ schedule_block (b, rgn_n_insns)\n \t\t   && GET_CODE (PATTERN (insn)) != CLOBBER)\n \t    can_issue_more--;\n \n-\t  schedule_insn (insn, &ready, clock_var);\n+\t  advance = schedule_insn (insn, &ready, clock_var);\n+\t  if (advance != 0)\n+\t    break;\n \n \tnext:\n \t  first_cycle_insn_p = 0;\n@@ -2267,7 +2274,9 @@ schedule_block (b, rgn_n_insns)\n \t  if (ready.n_ready > 0)\n \t    ready_sort (&ready);\n \n-\t  if (targetm.sched.reorder2)\n+\t  if (targetm.sched.reorder2\n+\t      && (ready.n_ready == 0\n+\t\t  || !SCHED_GROUP_P (ready_element (&ready, 0))))\n \t    {\n \t      can_issue_more =\n \t\t(*targetm.sched.reorder2) (sched_dump, sched_verbose,\n@@ -2393,8 +2402,7 @@ set_priorities (head, tail)\n       if (GET_CODE (insn) == NOTE)\n \tcontinue;\n \n-      if (! SCHED_GROUP_P (insn))\n-\tn_insn++;\n+      n_insn++;\n       (void) priority (insn);\n     }\n "}, {"sha": "fc9d4d857db8eac0b03c46176ca71db3b3f59fd5", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 4, "deletions": 124, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=58fb7809231012eb7d2f87ed7047239a051e93bf", "patch": "@@ -83,14 +83,12 @@ static sbitmap *forward_dependency_cache;\n static int deps_may_trap_p PARAMS ((rtx));\n static void add_dependence_list PARAMS ((rtx, rtx, enum reg_note));\n static void add_dependence_list_and_free PARAMS ((rtx, rtx *, enum reg_note));\n-static void remove_dependence PARAMS ((rtx, rtx));\n static void set_sched_group_p PARAMS ((rtx));\n \n static void flush_pending_lists PARAMS ((struct deps *, rtx, int, int));\n static void sched_analyze_1 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_2 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_insn PARAMS ((struct deps *, rtx, rtx, rtx));\n-static rtx group_leader PARAMS ((rtx));\n \n static rtx get_condition PARAMS ((rtx));\n static int conditions_mutex_p PARAMS ((rtx, rtx));\n@@ -184,7 +182,7 @@ add_dependence (insn, elem, dep_type)\n      rtx elem;\n      enum reg_note dep_type;\n {\n-  rtx link, next;\n+  rtx link;\n   int present_p;\n   rtx cond1, cond2;\n \n@@ -218,38 +216,6 @@ add_dependence (insn, elem, dep_type)\n \treturn;\n     }\n \n-  /* If elem is part of a sequence that must be scheduled together, then\n-     make the dependence point to the last insn of the sequence.\n-     When HAVE_cc0, it is possible for NOTEs to exist between users and\n-     setters of the condition codes, so we must skip past notes here.\n-     Otherwise, NOTEs are impossible here.  */\n-  next = next_nonnote_insn (elem);\n-  if (next && INSN_P (next) && SCHED_GROUP_P (next))\n-    {\n-      /* Notes will never intervene here though, so don't bother checking\n-         for them.  */\n-      /* Hah!  Wrong.  */\n-      /* We must reject CODE_LABELs, so that we don't get confused by one\n-         that has LABEL_PRESERVE_P set, which is represented by the same\n-         bit in the rtl as SCHED_GROUP_P.  A CODE_LABEL can never be\n-         SCHED_GROUP_P.  */\n-\n-      rtx nnext;\n-      while ((nnext = next_nonnote_insn (next)) != NULL\n-\t     && INSN_P (nnext)\n-\t     && SCHED_GROUP_P (nnext))\n-\tnext = nnext;\n-\n-      /* Again, don't depend an insn on itself.  */\n-      if (insn == next)\n-\treturn;\n-\n-      /* Make the dependence to NEXT, the last insn of the group,\n-\t instead of the original ELEM.  */\n-      elem = next;\n-    }\n-\n-\n   present_p = 1;\n #ifdef INSN_SCHEDULING\n   /* ??? No good way to tell from here whether we're doing interblock\n@@ -385,103 +351,19 @@ add_dependence_list_and_free (insn, listp, dep_type)\n     }\n }\n \n-/* Remove ELEM wrapped in an INSN_LIST from the LOG_LINKS\n-   of INSN.  Abort if not found.  */\n-\n-static void\n-remove_dependence (insn, elem)\n-     rtx insn;\n-     rtx elem;\n-{\n-  rtx prev, link, next;\n-  int found = 0;\n-\n-  for (prev = 0, link = LOG_LINKS (insn); link; link = next)\n-    {\n-      next = XEXP (link, 1);\n-      if (XEXP (link, 0) == elem)\n-\t{\n-\t  if (prev)\n-\t    XEXP (prev, 1) = next;\n-\t  else\n-\t    LOG_LINKS (insn) = next;\n-\n-#ifdef INSN_SCHEDULING\n-\t  /* If we are removing a dependency from the LOG_LINKS list,\n-\t     make sure to remove it from the cache too.  */\n-\t  if (true_dependency_cache != NULL)\n-\t    {\n-\t      if (REG_NOTE_KIND (link) == 0)\n-\t\tRESET_BIT (true_dependency_cache[INSN_LUID (insn)],\n-\t\t\t   INSN_LUID (elem));\n-\t      else if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n-\t\tRESET_BIT (anti_dependency_cache[INSN_LUID (insn)],\n-\t\t\t   INSN_LUID (elem));\n-\t      else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n-\t\tRESET_BIT (output_dependency_cache[INSN_LUID (insn)],\n-\t\t\t   INSN_LUID (elem));\n-\t    }\n-#endif\n-\n-\t  free_INSN_LIST_node (link);\n-\n-\t  found = 1;\n-\t}\n-      else\n-\tprev = link;\n-    }\n-\n-  if (!found)\n-    abort ();\n-  return;\n-}\n-\n-/* Return an insn which represents a SCHED_GROUP, which is\n-   the last insn in the group.  */\n-\n-static rtx\n-group_leader (insn)\n-     rtx insn;\n-{\n-  rtx prev;\n-\n-  do\n-    {\n-      prev = insn;\n-      insn = next_nonnote_insn (insn);\n-    }\n-  while (insn && INSN_P (insn) && SCHED_GROUP_P (insn));\n-\n-  return prev;\n-}\n-\n /* Set SCHED_GROUP_P and care for the rest of the bookkeeping that\n    goes along with that.  */\n \n static void\n set_sched_group_p (insn)\n      rtx insn;\n {\n-  rtx link, prev;\n+  rtx prev;\n \n   SCHED_GROUP_P (insn) = 1;\n \n-  /* There may be a note before this insn now, but all notes will\n-     be removed before we actually try to schedule the insns, so\n-     it won't cause a problem later.  We must avoid it here\n-     though.  */\n   prev = prev_nonnote_insn (insn);\n-  \n-  /* Make a copy of all dependencies on the immediately previous\n-     insn, and add to this insn.  This is so that all the\n-     dependencies will apply to the group.  Remove an explicit\n-     dependence on this insn as SCHED_GROUP_P now represents it.  */\n-  \n-  if (find_insn_list (prev, LOG_LINKS (insn)))\n-    remove_dependence (insn, prev);\n-  \n-  for (link = LOG_LINKS (prev); link; link = XEXP (link, 1))\n-    add_dependence (insn, XEXP (link, 0), REG_NOTE_KIND (link));\n+  add_dependence (insn, prev, REG_DEP_ANTI);\n }\n \f\n /* Process an insn's memory dependencies.  There are four kinds of\n@@ -1446,11 +1328,9 @@ compute_forward_dependences (head, tail)\n       if (! INSN_P (insn))\n \tcontinue;\n \n-      insn = group_leader (insn);\n-      \n       for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n \t{\n-\t  rtx x = group_leader (XEXP (link, 0));\n+\t  rtx x = XEXP (link, 0);\n \t  rtx new_link;\n \n \t  if (x != XEXP (link, 0))"}, {"sha": "5fa64f1f62346f0f0e43b7c2e409c9adc7aa4007", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=58fb7809231012eb7d2f87ed7047239a051e93bf", "patch": "@@ -90,17 +90,9 @@ init_ready_list (ready)\n      Count number of insns in the target block being scheduled.  */\n   for (insn = NEXT_INSN (prev_head); insn != next_tail; insn = NEXT_INSN (insn))\n     {\n-      rtx next;\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-      next = NEXT_INSN (insn);\n-\n-      if (INSN_DEP_COUNT (insn) == 0\n-\t  && (! INSN_P (next) || SCHED_GROUP_P (next) == 0))\n+      if (INSN_DEP_COUNT (insn) == 0)\n \tready_add (ready, insn);\n-      if (! SCHED_GROUP_P (insn))\n-\ttarget_n_insns++;\n+      target_n_insns++;\n     }\n }\n "}, {"sha": "36a53f73c26162bc35f7f299dcfb5395b59791ba", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 8, "deletions": 52, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fb7809231012eb7d2f87ed7047239a051e93bf/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=58fb7809231012eb7d2f87ed7047239a051e93bf", "patch": "@@ -2023,17 +2023,9 @@ init_ready_list (ready)\n      Count number of insns in the target block being scheduled.  */\n   for (insn = NEXT_INSN (prev_head); insn != next_tail; insn = NEXT_INSN (insn))\n     {\n-      rtx next;\n-\n-      if (! INSN_P (insn))\n-\tcontinue;\n-      next = NEXT_INSN (insn);\n-\n-      if (INSN_DEP_COUNT (insn) == 0\n-\t  && (! INSN_P (next) || SCHED_GROUP_P (next) == 0))\n+      if (INSN_DEP_COUNT (insn) == 0)\n \tready_add (ready, insn);\n-      if (! SCHED_GROUP_P (insn))\n-\ttarget_n_insns++;\n+      target_n_insns++;\n     }\n \n   /* Add to ready list all 'ready' insns in valid source blocks.\n@@ -2067,19 +2059,8 @@ init_ready_list (ready)\n \t\t\t\t\t\t\t     insn, insn) <= 3)))\n \t\t\t&& check_live (insn, bb_src)\n \t\t\t&& is_exception_free (insn, bb_src, target_bb))))\n-\t      {\n-\t\trtx next;\n-\n-\t\t/* Note that we haven't squirreled away the notes for\n-\t\t   blocks other than the current.  So if this is a\n-\t\t   speculative insn, NEXT might otherwise be a note.  */\n-\t\tnext = next_nonnote_insn (insn);\n-\t\tif (INSN_DEP_COUNT (insn) == 0\n-\t\t    && (! next\n-\t\t\t|| ! INSN_P (next)\n-\t\t\t|| SCHED_GROUP_P (next) == 0))\n-\t\t  ready_add (ready, insn);\n-\t      }\n+\t      if (INSN_DEP_COUNT (insn) == 0)\n+\t\tready_add (ready, insn);\n \t  }\n       }\n }\n@@ -2097,7 +2078,6 @@ can_schedule_ready_p (insn)\n   /* An interblock motion?  */\n   if (INSN_BB (insn) != target_bb)\n     {\n-      rtx temp;\n       basic_block b1;\n \n       if (IS_SPECULATIVE_INSN (insn))\n@@ -2114,18 +2094,9 @@ can_schedule_ready_p (insn)\n \t}\n       nr_inter++;\n \n-      /* Find the beginning of the scheduling group.  */\n-      /* ??? Ought to update basic block here, but later bits of\n-\t schedule_block assumes the original insn block is\n-\t still intact.  */\n-\n-      temp = insn;\n-      while (SCHED_GROUP_P (temp))\n-\ttemp = PREV_INSN (temp);\n-\n       /* Update source block boundaries.  */\n-      b1 = BLOCK_FOR_INSN (temp);\n-      if (temp == b1->head && temp == b1->end)\n+      b1 = BLOCK_FOR_INSN (insn);\n+      if (insn == b1->head && insn == b1->end)\n \t{\n \t  /* We moved all the insns in the basic block.\n \t     Emit a note after the last insn and update the\n@@ -2139,9 +2110,9 @@ can_schedule_ready_p (insn)\n \t  /* We took insns from the end of the basic block,\n \t     so update the end of block boundary so that it\n \t     points to the first insn we did not move.  */\n-\t  b1->end = PREV_INSN (temp);\n+\t  b1->end = PREV_INSN (insn);\n \t}\n-      else if (temp == b1->head)\n+      else if (insn == b1->head)\n \t{\n \t  /* We took insns from the start of the basic block,\n \t     so update the start of block boundary so that\n@@ -2361,17 +2332,6 @@ add_branch_dependences (head, tail)\n \t  CANT_MOVE (insn) = 1;\n \n \t  last = insn;\n-\t  /* Skip over insns that are part of a group.\n-\t     Make each insn explicitly depend on the previous insn.\n-\t     This ensures that only the group header will ever enter\n-\t     the ready queue (and, when scheduled, will automatically\n-\t     schedule the SCHED_GROUP_P block).  */\n-\t  while (SCHED_GROUP_P (insn))\n-\t    {\n-\t      rtx temp = prev_nonnote_insn (insn);\n-\t      add_dependence (insn, temp, REG_DEP_ANTI);\n-\t      insn = temp;\n-\t    }\n \t}\n \n       /* Don't overrun the bounds of the basic block.  */\n@@ -2393,10 +2353,6 @@ add_branch_dependences (head, tail)\n \n \tadd_dependence (last, insn, REG_DEP_ANTI);\n \tINSN_REF_COUNT (insn) = 1;\n-\t\n-\t/* Skip over insns that are part of a group.  */\n-\twhile (SCHED_GROUP_P (insn))\n-\t  insn = prev_nonnote_insn (insn);\n       }\n }\n "}]}