{"sha": "340c79045e35c6bceeb60afb30b1001c238c93b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQwYzc5MDQ1ZTM1YzZiY2VlYjYwYWZiMzBiMTAwMWMyMzhjOTNiNg==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim.kuvyrkov@linaro.org", "date": "2015-01-17T01:06:43Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2015-01-17T01:06:43Z"}, "message": "Model cache auto-prefetcher in scheduler\n\n\t* config/arm/arm-protos.h (struct tune_params): New field\n\tsched_autopref_queue_depth.\n\t* config/arm/arm.c (sched-int.h): Include header.\n\t(arm_first_cycle_multipass_dfa_lookahead_guard,)\n\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD): Define hook.\n\t(arm_slowmul_tune, arm_fastmul_tune, arm_strongarm_tune,)\n\t(arm_xscale_tune, arm_9e_tune, arm_v6t2_tune, arm_cortex_tune,)\n\t(arm_cortex_a8_tune, arm_cortex_a7_tune, arm_cortex_a15_tune,)\n\t(arm_cortex_a53_tune, arm_cortex_a57_tune, arm_xgene1_tune,)\n\t(arm_cortex_a5_tune, arm_cortex_a9_tune, arm_cortex_a12_tune,)\n\t(arm_v7m_tune, arm_cortex_m7_tune, arm_v6m_tune, arm_fa726te_tune):\n\tSpecify sched_autopref_queue_depth value.  Enabled for A15 and A57.\n\t* config/arm/t-arm (arm.o): Update.\n\t* haifa-sched.c (update_insn_after_change): Update.\n\t(rank_for_schedule): Use auto-prefetcher model, if requested.\n\t(autopref_multipass_init): New static function.\n\t(autopref_rank_for_schedule): New rank_for_schedule heuristic.\n\t(autopref_multipass_dfa_lookahead_guard_started_dump_p): New static\n\tvariable for debug dumps.\n\t(autopref_multipass_dfa_lookahead_guard_1): New static helper function.\n\t(autopref_multipass_dfa_lookahead_guard): New global function that\n\timplements TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD hook.\n\t(init_h_i_d): Update.\n\t* params.def (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH): New tuning knob.\n\t* sched-int.h (enum autopref_multipass_data_status): New const enum.\n\t(autopref_multipass_data_): Structure for auto-prefetcher data.\n\t(autopref_multipass_data_def, autopref_multipass_data_t): New typedefs.\n\t(struct _haifa_insn_data:autopref_multipass_data): New field.\n\t(INSN_AUTOPREF_MULTIPASS_DATA): New access macro.\n\t(autopref_multipass_dfa_lookahead_guard): Declare.\n\nFrom-SVN: r219789", "tree": {"sha": "b58630fa9c7bde3cf786f46d244c041a2357c3bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b58630fa9c7bde3cf786f46d244c041a2357c3bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/340c79045e35c6bceeb60afb30b1001c238c93b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/340c79045e35c6bceeb60afb30b1001c238c93b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/340c79045e35c6bceeb60afb30b1001c238c93b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/340c79045e35c6bceeb60afb30b1001c238c93b6/comments", "author": {"login": "maxim-kuvyrkov", "id": 12545699, "node_id": "MDQ6VXNlcjEyNTQ1Njk5", "avatar_url": "https://avatars.githubusercontent.com/u/12545699?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maxim-kuvyrkov", "html_url": "https://github.com/maxim-kuvyrkov", "followers_url": "https://api.github.com/users/maxim-kuvyrkov/followers", "following_url": "https://api.github.com/users/maxim-kuvyrkov/following{/other_user}", "gists_url": "https://api.github.com/users/maxim-kuvyrkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/maxim-kuvyrkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maxim-kuvyrkov/subscriptions", "organizations_url": "https://api.github.com/users/maxim-kuvyrkov/orgs", "repos_url": "https://api.github.com/users/maxim-kuvyrkov/repos", "events_url": "https://api.github.com/users/maxim-kuvyrkov/events{/privacy}", "received_events_url": "https://api.github.com/users/maxim-kuvyrkov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "71acd4776fee1ef3dfd961dd49967d00f11de7c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71acd4776fee1ef3dfd961dd49967d00f11de7c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71acd4776fee1ef3dfd961dd49967d00f11de7c5"}], "stats": {"total": 410, "additions": 389, "deletions": 21}, "files": [{"sha": "4f0414a6b1651f10b9891b26c2f2c03996c87805", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=340c79045e35c6bceeb60afb30b1001c238c93b6", "patch": "@@ -1,3 +1,36 @@\n+2015-01-17  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n+\n+\t* config/arm/arm-protos.h (struct tune_params): New field\n+\tsched_autopref_queue_depth.\n+\t* config/arm/arm.c (sched-int.h): Include header.\n+\t(arm_first_cycle_multipass_dfa_lookahead_guard,)\n+\t(TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD): Define hook.\n+\t(arm_slowmul_tune, arm_fastmul_tune, arm_strongarm_tune,)\n+\t(arm_xscale_tune, arm_9e_tune, arm_v6t2_tune, arm_cortex_tune,)\n+\t(arm_cortex_a8_tune, arm_cortex_a7_tune, arm_cortex_a15_tune,)\n+\t(arm_cortex_a53_tune, arm_cortex_a57_tune, arm_xgene1_tune,)\n+\t(arm_cortex_a5_tune, arm_cortex_a9_tune, arm_cortex_a12_tune,)\n+\t(arm_v7m_tune, arm_cortex_m7_tune, arm_v6m_tune, arm_fa726te_tune):\n+\tSpecify sched_autopref_queue_depth value.  Enabled for A15 and A57.\n+\t* config/arm/t-arm (arm.o): Update.\n+\t* haifa-sched.c (update_insn_after_change): Update.\n+\t(rank_for_schedule): Use auto-prefetcher model, if requested.\n+\t(autopref_multipass_init): New static function.\n+\t(autopref_rank_for_schedule): New rank_for_schedule heuristic.\n+\t(autopref_multipass_dfa_lookahead_guard_started_dump_p): New static\n+\tvariable for debug dumps.\n+\t(autopref_multipass_dfa_lookahead_guard_1): New static helper function.\n+\t(autopref_multipass_dfa_lookahead_guard): New global function that\n+\timplements TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD hook.\n+\t(init_h_i_d): Update.\n+\t* params.def (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH): New tuning knob.\n+\t* sched-int.h (enum autopref_multipass_data_status): New const enum.\n+\t(autopref_multipass_data_): Structure for auto-prefetcher data.\n+\t(autopref_multipass_data_def, autopref_multipass_data_t): New typedefs.\n+\t(struct _haifa_insn_data:autopref_multipass_data): New field.\n+\t(INSN_AUTOPREF_MULTIPASS_DATA): New access macro.\n+\t(autopref_multipass_dfa_lookahead_guard): Declare.\n+\n 2015-01-17  Maxim Kuvyrkov  <maxim.kuvyrkov@linaro.org>\n \n \t* rtlanal.c (get_base_term): Handle SCRATCH."}, {"sha": "3db7e1695f8faa4ffdf944a8d65f136d86e40335", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=340c79045e35c6bceeb60afb30b1001c238c93b6", "patch": "@@ -291,6 +291,8 @@ struct tune_params\n   int max_insns_inline_memset;\n   /* Bitfield encoding the fuseable pairs of instructions.  */\n   unsigned int fuseable_ops;\n+  /* Depth of scheduling queue to check for L2 autoprefetcher.  */\n+  int sched_autopref_queue_depth;\n };\n \n extern const struct tune_params *current_tune;"}, {"sha": "fddd770897235db8a407816599b9c4e8620493af", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=340c79045e35c6bceeb60afb30b1001c238c93b6", "patch": "@@ -97,6 +97,7 @@\n #include \"builtins.h\"\n #include \"tm-constrs.h\"\n #include \"rtl-iter.h\"\n+#include \"sched-int.h\"\n \n /* Forward definitions of types.  */\n typedef struct minipool_node    Mnode;\n@@ -269,6 +270,7 @@ static bool arm_macro_fusion_p (void);\n static bool arm_cannot_copy_insn_p (rtx_insn *);\n static int arm_issue_rate (void);\n static int arm_first_cycle_multipass_dfa_lookahead (void);\n+static int arm_first_cycle_multipass_dfa_lookahead_guard (rtx_insn *, int);\n static void arm_output_dwarf_dtprel (FILE *, int, rtx) ATTRIBUTE_UNUSED;\n static bool arm_output_addr_const_extra (FILE *, rtx);\n static bool arm_allocate_stack_slots_for_args (void);\n@@ -629,6 +631,10 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD \\\n   arm_first_cycle_multipass_dfa_lookahead\n \n+#undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD\n+#define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD \\\n+  arm_first_cycle_multipass_dfa_lookahead_guard\n+\n #undef TARGET_MANGLE_TYPE\n #define TARGET_MANGLE_TYPE arm_mangle_type\n \n@@ -1690,7 +1696,8 @@ const struct tune_params arm_slowmul_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_fastmul_tune =\n@@ -1710,7 +1717,8 @@ const struct tune_params arm_fastmul_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n /* StrongARM has early execution of branches, so a sequence that is worth\n@@ -1733,7 +1741,8 @@ const struct tune_params arm_strongarm_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_xscale_tune =\n@@ -1753,7 +1762,8 @@ const struct tune_params arm_xscale_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_9e_tune =\n@@ -1773,7 +1783,8 @@ const struct tune_params arm_9e_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_v6t2_tune =\n@@ -1793,7 +1804,8 @@ const struct tune_params arm_v6t2_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n /* Generic Cortex tuning.  Use more specific tunings if appropriate.  */\n@@ -1814,7 +1826,8 @@ const struct tune_params arm_cortex_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_cortex_a8_tune =\n@@ -1834,7 +1847,8 @@ const struct tune_params arm_cortex_a8_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_cortex_a7_tune =\n@@ -1854,7 +1868,8 @@ const struct tune_params arm_cortex_a7_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_cortex_a15_tune =\n@@ -1874,7 +1889,8 @@ const struct tune_params arm_cortex_a15_tune =\n   true, true,                                   /* Prefer 32-bit encodings.  */\n   true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  max_insn_queue_index + 1\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_cortex_a53_tune =\n@@ -1894,7 +1910,8 @@ const struct tune_params arm_cortex_a53_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_MOVW_MOVT\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_MOVW_MOVT,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_cortex_a57_tune =\n@@ -1914,7 +1931,8 @@ const struct tune_params arm_cortex_a57_tune =\n   true, true,                                  /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_MOVW_MOVT\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_MOVW_MOVT,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  max_insn_queue_index + 1\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_xgene1_tune =\n@@ -1934,7 +1952,8 @@ const struct tune_params arm_xgene1_tune =\n   true, true,                                  /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t       /* Prefer Neon for stringops.  */\n   32,\t\t\t\t\t       /* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n /* Branches can be dual-issued on Cortex-A5, so conditional execution is\n@@ -1957,7 +1976,8 @@ const struct tune_params arm_cortex_a5_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_cortex_a9_tune =\n@@ -1977,7 +1997,8 @@ const struct tune_params arm_cortex_a9_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_cortex_a12_tune =\n@@ -1997,7 +2018,8 @@ const struct tune_params arm_cortex_a12_tune =\n   true, true,                                   /* Prefer 32-bit encodings.  */\n   true,\t\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_MOVW_MOVT\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_MOVW_MOVT,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n /* armv7m tuning.  On Cortex-M4 cores for example, MOVW/MOVT take a single\n@@ -2024,7 +2046,8 @@ const struct tune_params arm_v7m_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n /* Cortex-M7 tuning.  */\n@@ -2046,7 +2069,8 @@ const struct tune_params arm_cortex_m7_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n /* The arm_v6m_tune is duplicated from arm_cortex_tune, rather than\n@@ -2068,7 +2092,8 @@ const struct tune_params arm_v6m_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n const struct tune_params arm_fa726te_tune =\n@@ -2088,7 +2113,8 @@ const struct tune_params arm_fa726te_tune =\n   false, false,                                 /* Prefer 32-bit encodings.  */\n   false,\t\t\t\t\t/* Prefer Neon for stringops.  */\n   8,\t\t\t\t\t\t/* Maximum insns to inline memset.  */\n-  ARM_FUSE_NOTHING\t\t\t\t/* Fuseable pairs of instructions.  */\n+  ARM_FUSE_NOTHING,\t\t\t\t/* Fuseable pairs of instructions.  */\n+  -1\t\t\t\t\t\t/* Sched L2 autopref depth.  */\n };\n \n \n@@ -3144,6 +3170,13 @@ arm_option_override (void)\n                          global_options.x_param_values,\n                          global_options_set.x_param_values);\n \n+  /* Look through ready list and all of queue for instructions\n+     relevant for L2 auto-prefetcher.  */\n+  maybe_set_param_value (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH,\n+\t\t\t current_tune->sched_autopref_queue_depth,\n+                         global_options.x_param_values,\n+                         global_options_set.x_param_values);\n+\n   /* Disable shrink-wrap when optimizing function for size, since it tends to\n      generate additional returns.  */\n   if (optimize_function_for_size_p (cfun) && TARGET_THUMB2)\n@@ -27153,6 +27186,13 @@ arm_first_cycle_multipass_dfa_lookahead (void)\n   return issue_rate > 1 && !sched_fusion ? issue_rate : 0;\n }\n \n+/* Enable modeling of L2 auto-prefetcher.  */\n+static int\n+arm_first_cycle_multipass_dfa_lookahead_guard (rtx_insn *insn, int ready_index)\n+{\n+  return autopref_multipass_dfa_lookahead_guard (insn, ready_index);\n+}\n+\n const char *\n arm_mangle_type (const_tree type)\n {"}, {"sha": "ab5b6e7d598ec2776ac28f50fa148c31fdc3b291", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=340c79045e35c6bceeb60afb30b1001c238c93b6", "patch": "@@ -91,7 +91,8 @@ arm.o: $(srcdir)/config/arm/arm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n   $(EXPR_H) $(OPTABS_H) $(RECOG_H) $(CGRAPH_H) \\\n   $(GGC_H) except.h $(C_PRAGMA_H) $(TM_P_H) \\\n   $(TARGET_H) $(TARGET_DEF_H) debug.h langhooks.h $(DF_H) \\\n-  intl.h libfuncs.h $(PARAMS_H) $(OPTS_H) $(srcdir)/config/arm/arm-cores.def \\\n+  intl.h libfuncs.h $(PARAMS_H) $(OPTS_H) sched-int.h \\\n+  $(srcdir)/config/arm/arm-cores.def \\\n   $(srcdir)/config/arm/arm-arches.def $(srcdir)/config/arm/arm-fpus.def \\\n   $(srcdir)/config/arm/arm-protos.h \\\n   $(srcdir)/config/arm/arm_neon_builtins.def"}, {"sha": "795ff79e8985c736a9346a912e2c2359375bf329", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=340c79045e35c6bceeb60afb30b1001c238c93b6", "patch": "@@ -841,6 +841,7 @@ add_delay_dependencies (rtx_insn *insn)\n /* Forward declarations.  */\n \n static int priority (rtx_insn *);\n+static int autopref_rank_for_schedule (const rtx_insn *, const rtx_insn *);\n static int rank_for_schedule (const void *, const void *);\n static void swap_sort (rtx_insn **, int);\n static void queue_insn (rtx_insn *, int, const char *);\n@@ -1184,6 +1185,12 @@ update_insn_after_change (rtx_insn *insn)\n   INSN_COST (insn) = -1;\n   /* Invalidate INSN_TICK, so it'll be recalculated.  */\n   INSN_TICK (insn) = INVALID_TICK;\n+\n+  /* Invalidate autoprefetch data entry.  */\n+  INSN_AUTOPREF_MULTIPASS_DATA (insn)[0].status\n+    = AUTOPREF_MULTIPASS_DATA_UNINITIALIZED;\n+  INSN_AUTOPREF_MULTIPASS_DATA (insn)[1].status\n+    = AUTOPREF_MULTIPASS_DATA_UNINITIALIZED;\n }\n \n \n@@ -2724,6 +2731,13 @@ rank_for_schedule (const void *x, const void *y)\n   if (flag_sched_critical_path_heuristic && priority_val)\n     return rfs_result (RFS_PRIORITY, priority_val, tmp, tmp2);\n \n+  if (PARAM_VALUE (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH) >= 0)\n+    {\n+      int autopref = autopref_rank_for_schedule (tmp, tmp2);\n+      if (autopref != 0)\n+\treturn autopref;\n+    }\n+\n   /* Prefer speculative insn with greater dependencies weakness.  */\n   if (flag_sched_spec_insn_heuristic && spec_info)\n     {\n@@ -5500,6 +5514,241 @@ insn_finishes_cycle_p (rtx_insn *insn)\n   return false;\n }\n \n+/* Functions to model cache auto-prefetcher.\n+\n+   Some of the CPUs have cache auto-prefetcher, which /seems/ to initiate\n+   memory prefetches if it sees instructions with consequitive memory accesses\n+   in the instruction stream.  Details of such hardware units are not published,\n+   so we can only guess what exactly is going on there.\n+   In the scheduler, we model abstract auto-prefetcher.  If there are memory\n+   insns in the ready list (or the queue) that have same memory base, but\n+   different offsets, then we delay the insns with larger offsets until insns\n+   with smaller offsets get scheduled.  If PARAM_SCHED_AUTOPREF_QUEUE_DEPTH\n+   is \"1\", then we look at the ready list; if it is N>1, then we also look\n+   through N-1 queue entries.\n+   If the param is N>=0, then rank_for_schedule will consider auto-prefetching\n+   among its heuristics.\n+   Param value of \"-1\" disables modelling of the auto-prefetcher.  */\n+\n+/* Initialize autoprefetcher model data for INSN.  */\n+static void\n+autopref_multipass_init (const rtx_insn *insn, int write)\n+{\n+  autopref_multipass_data_t data = &INSN_AUTOPREF_MULTIPASS_DATA (insn)[write];\n+\n+  gcc_assert (data->status == AUTOPREF_MULTIPASS_DATA_UNINITIALIZED);\n+  data->base = NULL_RTX;\n+  data->offset = 0;\n+  /* Set insn entry initialized, but not relevant for auto-prefetcher.  */\n+  data->status = AUTOPREF_MULTIPASS_DATA_IRRELEVANT;\n+\n+  rtx set = single_set (insn);\n+  if (set == NULL_RTX)\n+    return;\n+\n+  rtx mem = write ? SET_DEST (set) : SET_SRC (set);\n+  if (!MEM_P (mem))\n+    return;\n+\n+  struct address_info info;\n+  decompose_mem_address (&info, mem);\n+\n+  /* TODO: Currently only (base+const) addressing is supported.  */\n+  if (info.base == NULL || !REG_P (*info.base)\n+      || (info.disp != NULL && !CONST_INT_P (*info.disp)))\n+    return;\n+\n+  /* This insn is relevant for auto-prefetcher.  */\n+  data->base = *info.base;\n+  data->offset = info.disp ? INTVAL (*info.disp) : 0;\n+  data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;\n+}\n+\n+/* Helper function for rank_for_schedule sorting.  */\n+static int\n+autopref_rank_for_schedule (const rtx_insn *insn1, const rtx_insn *insn2)\n+{\n+  for (int write = 0; write < 2; ++write)\n+    {\n+      autopref_multipass_data_t data1\n+\t= &INSN_AUTOPREF_MULTIPASS_DATA (insn1)[write];\n+      autopref_multipass_data_t data2\n+\t= &INSN_AUTOPREF_MULTIPASS_DATA (insn2)[write];\n+\n+      if (data1->status == AUTOPREF_MULTIPASS_DATA_UNINITIALIZED)\n+\tautopref_multipass_init (insn1, write);\n+      if (data1->status == AUTOPREF_MULTIPASS_DATA_IRRELEVANT)\n+\tcontinue;\n+\n+      if (data2->status == AUTOPREF_MULTIPASS_DATA_UNINITIALIZED)\n+\tautopref_multipass_init (insn2, write);\n+      if (data2->status == AUTOPREF_MULTIPASS_DATA_IRRELEVANT)\n+\tcontinue;\n+\n+      if (!rtx_equal_p (data1->base, data2->base))\n+\tcontinue;\n+\n+      return data1->offset - data2->offset;\n+    }\n+\n+  return 0;\n+}\n+\n+/* True if header of debug dump was printed.  */\n+static bool autopref_multipass_dfa_lookahead_guard_started_dump_p;\n+\n+/* Helper for autopref_multipass_dfa_lookahead_guard.\n+   Return \"1\" if INSN1 should be delayed in favor of INSN2.  */\n+static int\n+autopref_multipass_dfa_lookahead_guard_1 (const rtx_insn *insn1,\n+\t\t\t\t\t  const rtx_insn *insn2, int write)\n+{\n+  autopref_multipass_data_t data1\n+    = &INSN_AUTOPREF_MULTIPASS_DATA (insn1)[write];\n+  autopref_multipass_data_t data2\n+    = &INSN_AUTOPREF_MULTIPASS_DATA (insn2)[write];\n+\n+  if (data2->status == AUTOPREF_MULTIPASS_DATA_UNINITIALIZED)\n+    autopref_multipass_init (insn2, write);\n+  if (data2->status == AUTOPREF_MULTIPASS_DATA_IRRELEVANT)\n+    return 0;\n+\n+  if (rtx_equal_p (data1->base, data2->base)\n+      && data1->offset > data2->offset)\n+    {\n+      if (sched_verbose >= 2)\n+\t{\n+          if (!autopref_multipass_dfa_lookahead_guard_started_dump_p)\n+\t    {\n+\t      fprintf (sched_dump,\n+\t\t       \";;\\t\\tnot trying in max_issue due to autoprefetch \"\n+\t\t       \"model: \");\n+\t      autopref_multipass_dfa_lookahead_guard_started_dump_p = true;\n+\t    }\n+\n+\t  fprintf (sched_dump, \" %d(%d)\", INSN_UID (insn1), INSN_UID (insn2));\n+\t}\n+\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* General note:\n+\n+   We could have also hooked autoprefetcher model into\n+   first_cycle_multipass_backtrack / first_cycle_multipass_issue hooks\n+   to enable intelligent selection of \"[r1+0]=r2; [r1+4]=r3\" on the same cycle\n+   (e.g., once \"[r1+0]=r2\" is issued in max_issue(), \"[r1+4]=r3\" gets\n+   unblocked).  We don't bother about this yet because target of interest\n+   (ARM Cortex-A15) can issue only 1 memory operation per cycle.  */\n+\n+/* Implementation of first_cycle_multipass_dfa_lookahead_guard hook.\n+   Return \"1\" if INSN1 should not be considered in max_issue due to\n+   auto-prefetcher considerations.  */\n+int\n+autopref_multipass_dfa_lookahead_guard (rtx_insn *insn1, int ready_index)\n+{\n+  int r = 0;\n+\n+  if (PARAM_VALUE (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH) <= 0)\n+    return 0;\n+\n+  if (sched_verbose >= 2 && ready_index == 0)\n+    autopref_multipass_dfa_lookahead_guard_started_dump_p = false;\n+\n+  for (int write = 0; write < 2; ++write)\n+    {\n+      autopref_multipass_data_t data1\n+\t= &INSN_AUTOPREF_MULTIPASS_DATA (insn1)[write];\n+\n+      if (data1->status == AUTOPREF_MULTIPASS_DATA_UNINITIALIZED)\n+\tautopref_multipass_init (insn1, write);\n+      if (data1->status == AUTOPREF_MULTIPASS_DATA_IRRELEVANT)\n+\tcontinue;\n+\n+      if (ready_index == 0\n+\t  && data1->status == AUTOPREF_MULTIPASS_DATA_DONT_DELAY)\n+\t/* We allow only a single delay on priviledged instructions.\n+\t   Doing otherwise would cause infinite loop.  */\n+\t{\n+\t  if (sched_verbose >= 2)\n+\t    {\n+\t      if (!autopref_multipass_dfa_lookahead_guard_started_dump_p)\n+\t\t{\n+\t\t  fprintf (sched_dump,\n+\t\t\t   \";;\\t\\tnot trying in max_issue due to autoprefetch \"\n+\t\t\t   \"model: \");\n+\t\t  autopref_multipass_dfa_lookahead_guard_started_dump_p = true;\n+\t\t}\n+\n+\t      fprintf (sched_dump, \" *%d*\", INSN_UID (insn1));\n+\t    }\n+\t  continue;\n+\t}\n+\n+      for (int i2 = 0; i2 < ready.n_ready; ++i2)\n+\t{\n+\t  rtx_insn *insn2 = get_ready_element (i2);\n+\t  if (insn1 == insn2)\n+\t    continue;\n+\t  r = autopref_multipass_dfa_lookahead_guard_1 (insn1, insn2, write);\n+\t  if (r)\n+\t    {\n+\t      if (ready_index == 0)\n+\t\t{\n+\t\t  r = -1;\n+\t\t  data1->status = AUTOPREF_MULTIPASS_DATA_DONT_DELAY;\n+\t\t}\n+\t      goto finish;\n+\t    }\n+\t}\n+\n+      if (PARAM_VALUE (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH) == 1)\n+\tcontinue;\n+\n+      /* Everything from the current queue slot should have been moved to\n+\t the ready list.  */\n+      gcc_assert (insn_queue[NEXT_Q_AFTER (q_ptr, 0)] == NULL_RTX);\n+\n+      int n_stalls = PARAM_VALUE (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH) - 1;\n+      if (n_stalls > max_insn_queue_index)\n+\tn_stalls = max_insn_queue_index;\n+\n+      for (int stalls = 1; stalls <= n_stalls; ++stalls)\n+\t{\n+\t  for (rtx_insn_list *link = insn_queue[NEXT_Q_AFTER (q_ptr, stalls)];\n+\t       link != NULL_RTX;\n+\t       link = link->next ())\n+\t    {\n+\t      rtx_insn *insn2 = link->insn ();\n+\t      r = autopref_multipass_dfa_lookahead_guard_1 (insn1, insn2,\n+\t\t\t\t\t\t\t    write);\n+\t      if (r)\n+\t\t{\n+\t\t  /* Queue INSN1 until INSN2 can issue.  */\n+\t\t  r = -stalls;\n+\t\t  if (ready_index == 0)\n+\t\t    data1->status = AUTOPREF_MULTIPASS_DATA_DONT_DELAY;\n+\t\t  goto finish;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    finish:\n+  if (sched_verbose >= 2\n+      && autopref_multipass_dfa_lookahead_guard_started_dump_p\n+      && (ready_index == ready.n_ready - 1 || r < 0))\n+    /* This does not /always/ trigger.  We don't output EOL if the last\n+       insn is not recognized (INSN_CODE < 0) and lookahead_guard is not\n+       called.  We can live with this.  */\n+    fprintf (sched_dump, \"\\n\");\n+\n+  return r;\n+}\n+\n /* Define type for target data used in multipass scheduling.  */\n #ifndef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T\n # define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T int\n@@ -8710,6 +8959,10 @@ init_h_i_d (rtx_insn *insn)\n       INSN_EXACT_TICK (insn) = INVALID_TICK;\n       INTER_TICK (insn) = INVALID_TICK;\n       TODO_SPEC (insn) = HARD_DEP;\n+      INSN_AUTOPREF_MULTIPASS_DATA (insn)[0].status\n+\t= AUTOPREF_MULTIPASS_DATA_UNINITIALIZED;\n+      INSN_AUTOPREF_MULTIPASS_DATA (insn)[1].status\n+\t= AUTOPREF_MULTIPASS_DATA_UNINITIALIZED;\n     }\n }\n "}, {"sha": "192c1e021c2a910c6836c3fa60a0e12e8169e7b0", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=340c79045e35c6bceeb60afb30b1001c238c93b6", "patch": "@@ -668,6 +668,11 @@ DEFPARAM (PARAM_SCHED_MEM_TRUE_DEP_COST,\n \t  \"Minimal distance between possibly conflicting store and load\",\n \t  1, 0, 0)\n \n+DEFPARAM (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH,\n+\t  \"sched-autopref-queue-depth\",\n+\t  \"Hardware autoprefetcher scheduler model control flag.  Number of lookahead cycles the model looks into; at '0' only enable instruction sorting heuristic.  Disabled by default.\",\n+\t  -1, 0, 0)\n+\n DEFPARAM(PARAM_MAX_LAST_VALUE_RTL,\n \t \"max-last-value-rtl\",\n \t \"The maximum number of RTL nodes that can be recorded as combiner's last value\","}, {"sha": "28e95ea97b6e7c5051e21ac915618327cbfe4f7e", "filename": "gcc/sched-int.h", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/340c79045e35c6bceeb60afb30b1001c238c93b6/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=340c79045e35c6bceeb60afb30b1001c238c93b6", "patch": "@@ -793,6 +793,32 @@ struct reg_set_data\n   struct reg_set_data *next_insn_set;\n };\n \n+enum autopref_multipass_data_status {\n+  /* Entry is irrelevant for auto-prefetcher.  */\n+  AUTOPREF_MULTIPASS_DATA_IRRELEVANT = -2,\n+  /* Entry is uninitialized.  */\n+  AUTOPREF_MULTIPASS_DATA_UNINITIALIZED = -1,\n+  /* Entry is relevant for auto-prefetcher and insn can be delayed\n+     to allow another insn through.  */\n+  AUTOPREF_MULTIPASS_DATA_NORMAL = 0,\n+  /* Entry is relevant for auto-prefetcher, but insn should not be\n+     delayed as that will break scheduling.  */\n+  AUTOPREF_MULTIPASS_DATA_DONT_DELAY = 1\n+};\n+\n+/* Data for modeling cache auto-prefetcher.  */\n+struct autopref_multipass_data_\n+{\n+  /* Base part of memory address.  */\n+  rtx base;\n+  /* Memory offset.  */\n+  int offset;\n+  /* Entry status.  */\n+  enum autopref_multipass_data_status status;\n+};\n+typedef struct autopref_multipass_data_ autopref_multipass_data_def;\n+typedef autopref_multipass_data_def *autopref_multipass_data_t;\n+\n struct _haifa_insn_data\n {\n   /* We can't place 'struct _deps_list' into h_i_d instead of deps_list_t\n@@ -893,6 +919,10 @@ struct _haifa_insn_data\n \n   /* The deciding reason for INSN's place in the ready list.  */\n   int last_rfs_win;\n+\n+  /* Two entries for cache auto-prefetcher model: one for mem reads,\n+     and one for mem writes.  */\n+  autopref_multipass_data_def autopref_multipass_data[2];\n };\n \n typedef struct _haifa_insn_data haifa_insn_data_def;\n@@ -915,6 +945,8 @@ extern vec<haifa_insn_data_def> h_i_d;\n   (HID (INSN)->reg_pressure_excess_cost_change)\n #define INSN_PRIORITY_STATUS(INSN) (HID (INSN)->priority_status)\n #define INSN_MODEL_INDEX(INSN) (HID (INSN)->model_index)\n+#define INSN_AUTOPREF_MULTIPASS_DATA(INSN) \\\n+  (HID (INSN)->autopref_multipass_data)\n \n typedef struct _haifa_deps_insn_data haifa_deps_insn_data_def;\n typedef haifa_deps_insn_data_def *haifa_deps_insn_data_t;\n@@ -1363,6 +1395,8 @@ extern int cycle_issued_insns;\n extern int issue_rate;\n extern int dfa_lookahead;\n \n+extern int autopref_multipass_dfa_lookahead_guard (rtx_insn *, int);\n+\n extern void ready_sort (struct ready_list *);\n extern rtx_insn *ready_element (struct ready_list *, int);\n extern rtx_insn **ready_lastpos (struct ready_list *);"}]}