{"sha": "bf6b72928e7a8d1734e14ef075dc9c985a4902fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY2YjcyOTI4ZTdhOGQxNzM0ZTE0ZWYwNzVkYzljOTg1YTQ5MDJmZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-02-24T10:00:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-02-24T10:00:04Z"}, "message": "misc.c (gnat_type_max_size): Try to return a meaningful value for array types with TYPE_INDEX_TYPE set on...\n\n\t* gcc-interface/misc.c (gnat_type_max_size): Try to return a meaningful\n\tvalue for array types with TYPE_INDEX_TYPE set on their domain type.\n\t* gcc-interface/utils.c (max_size): For operations and expressions, do\n\tnot build a new node if the operands have not changed or are missing.\n\nFrom-SVN: r245698", "tree": {"sha": "e5293e4d0a31ed5753df85e0cae454a18c38ed30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5293e4d0a31ed5753df85e0cae454a18c38ed30"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf6b72928e7a8d1734e14ef075dc9c985a4902fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6b72928e7a8d1734e14ef075dc9c985a4902fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf6b72928e7a8d1734e14ef075dc9c985a4902fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6b72928e7a8d1734e14ef075dc9c985a4902fe/comments", "author": null, "committer": null, "parents": [{"sha": "4af362a9571170538b66411d9cf7b6dc87745854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af362a9571170538b66411d9cf7b6dc87745854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4af362a9571170538b66411d9cf7b6dc87745854"}], "stats": {"total": 120, "additions": 91, "deletions": 29}, "files": [{"sha": "cdabfec09d41258467c8d64554043d85a390ea7f", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6b72928e7a8d1734e14ef075dc9c985a4902fe/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6b72928e7a8d1734e14ef075dc9c985a4902fe/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=bf6b72928e7a8d1734e14ef075dc9c985a4902fe", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                           C Implementation File                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2017, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -736,22 +736,59 @@ gnat_type_max_size (const_tree gnu_type)\n      elaborated and possibly replaced by a VAR_DECL.  */\n   tree max_unitsize = max_size (TYPE_SIZE_UNIT (gnu_type), true);\n \n-  /* If we don't have a constant, see what we can get from TYPE_ADA_SIZE,\n-     which should stay untouched.  */\n-  if (!tree_fits_uhwi_p (max_unitsize)\n-      && RECORD_OR_UNION_TYPE_P (gnu_type)\n-      && !TYPE_FAT_POINTER_P (gnu_type)\n-      && TYPE_ADA_SIZE (gnu_type))\n+  /* If we don't have a constant, try to look at attributes which should have\n+     stayed untouched.  */\n+  if (!tree_fits_uhwi_p (max_unitsize))\n     {\n-      tree max_adasize = max_size (TYPE_ADA_SIZE (gnu_type), true);\n-\n-      /* If we have succeeded in finding a constant, round it up to the\n-\t type's alignment and return the result in units.  */\n-      if (tree_fits_uhwi_p (max_adasize))\n-\tmax_unitsize\n-\t  = size_binop (CEIL_DIV_EXPR,\n-\t\t\tround_up (max_adasize, TYPE_ALIGN (gnu_type)),\n-\t\t\tbitsize_unit_node);\n+      /* For record types, see what we can get from TYPE_ADA_SIZE.  */\n+      if (RECORD_OR_UNION_TYPE_P (gnu_type)\n+\t  && !TYPE_FAT_POINTER_P (gnu_type)\n+\t  && TYPE_ADA_SIZE (gnu_type))\n+\t{\n+\t  tree max_adasize = max_size (TYPE_ADA_SIZE (gnu_type), true);\n+\n+\t  /* If we have succeeded in finding a constant, round it up to the\n+\t     type's alignment and return the result in units.  */\n+\t  if (tree_fits_uhwi_p (max_adasize))\n+\t    max_unitsize\n+\t      = size_binop (CEIL_DIV_EXPR,\n+\t\t\t    round_up (max_adasize, TYPE_ALIGN (gnu_type)),\n+\t\t\t    bitsize_unit_node);\n+\t}\n+\n+      /* For array types, see what we can get from TYPE_INDEX_TYPE.  */\n+      else if (TREE_CODE (gnu_type) == ARRAY_TYPE\n+\t       && TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))\n+\t       && tree_fits_uhwi_p (TYPE_SIZE_UNIT (TREE_TYPE (gnu_type))))\n+\t{\n+\t  tree lb = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)));\n+\t  tree hb = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)));\n+\t  if (TREE_CODE (lb) != INTEGER_CST\n+\t      && TYPE_RM_SIZE (TREE_TYPE (lb))\n+\t      && compare_tree_int (TYPE_RM_SIZE (TREE_TYPE (lb)), 16) <= 0)\n+\t    lb = TYPE_MIN_VALUE (TREE_TYPE (lb));\n+\t  if (TREE_CODE (hb) != INTEGER_CST\n+\t      && TYPE_RM_SIZE (TREE_TYPE (hb))\n+\t      && compare_tree_int (TYPE_RM_SIZE (TREE_TYPE (hb)), 16) <= 0)\n+\t    hb = TYPE_MAX_VALUE (TREE_TYPE (hb));\n+\t  if (TREE_CODE (lb) == INTEGER_CST && TREE_CODE (hb) == INTEGER_CST)\n+\t    {\n+\t      tree ctype = get_base_type (TREE_TYPE (lb));\n+\t      lb = fold_convert (ctype, lb);\n+\t      hb = fold_convert (ctype, hb);\n+\t      if (tree_int_cst_le (lb, hb))\n+\t\t{\n+\t\t  tree length\n+\t\t    = fold_build2 (PLUS_EXPR, ctype,\n+\t\t\t\t   fold_build2 (MINUS_EXPR, ctype, hb, lb),\n+\t\t\t\t   build_int_cst (ctype, 1));\n+\t\t  max_unitsize\n+\t\t    = fold_build2 (MULT_EXPR, sizetype,\n+\t\t\t\t   fold_convert (sizetype, length),\n+\t\t\t\t   TYPE_SIZE_UNIT (TREE_TYPE (gnu_type)));\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   return max_unitsize;"}, {"sha": "0f4d8a4b2e63e5316648ac17cd3a743269a2f022", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6b72928e7a8d1734e14ef075dc9c985a4902fe/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6b72928e7a8d1734e14ef075dc9c985a4902fe/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=bf6b72928e7a8d1734e14ef075dc9c985a4902fe", "patch": "@@ -3534,6 +3534,7 @@ max_size (tree exp, bool max_p)\n {\n   enum tree_code code = TREE_CODE (exp);\n   tree type = TREE_TYPE (exp);\n+  tree op0, op1, op2;\n \n   switch (TREE_CODE_CLASS (code))\n     {\n@@ -3575,15 +3576,19 @@ max_size (tree exp, bool max_p)\n       return exp;\n \n     case tcc_comparison:\n-      return max_p ? size_one_node : size_zero_node;\n+      return build_int_cst (type, max_p ? 1 : 0);\n \n     case tcc_unary:\n       if (code == NON_LVALUE_EXPR)\n \treturn max_size (TREE_OPERAND (exp, 0), max_p);\n \n-      return fold_build1 (code, type,\n-\t\t\t  max_size (TREE_OPERAND (exp, 0),\n-\t\t\t\t    code == NEGATE_EXPR ? !max_p : max_p));\n+      op0 = max_size (TREE_OPERAND (exp, 0),\n+\t\t      code == NEGATE_EXPR ? !max_p : max_p);\n+\n+      if (op0 == TREE_OPERAND (exp, 0))\n+\treturn exp;\n+\n+      return fold_build1 (code, type, op0);\n \n     case tcc_binary:\n       {\n@@ -3623,6 +3628,9 @@ max_size (tree exp, bool max_p)\n \t    code = PLUS_EXPR;\n \t  }\n \n+\tif (lhs == TREE_OPERAND (exp, 0) && rhs == TREE_OPERAND (exp, 1))\n+\t  return exp;\n+\n \t/* We need to detect overflows so we call size_binop here.  */\n \treturn size_binop (code, lhs, rhs);\n       }\n@@ -3634,23 +3642,40 @@ max_size (tree exp, bool max_p)\n \t  if (code == SAVE_EXPR)\n \t    return exp;\n \n-\t  return fold_build1 (code, type,\n-\t\t\t      max_size (TREE_OPERAND (exp, 0),\n-\t\t\t      code == TRUTH_NOT_EXPR ? !max_p : max_p));\n+\t  op0 = max_size (TREE_OPERAND (exp, 0),\n+\t\t\t  code == TRUTH_NOT_EXPR ? !max_p : max_p);\n+\n+\t  if (op0 == TREE_OPERAND (exp, 0))\n+\t    return exp;\n+\n+\t  return fold_build1 (code, type, op0);\n \n \tcase 2:\n \t  if (code == COMPOUND_EXPR)\n \t    return max_size (TREE_OPERAND (exp, 1), max_p);\n \n-\t  return fold_build2 (code, type,\n-\t\t\t      max_size (TREE_OPERAND (exp, 0), max_p),\n-\t\t\t      max_size (TREE_OPERAND (exp, 1), max_p));\n+\t  op0 = max_size (TREE_OPERAND (exp, 0), max_p);\n+\t  op1 = max_size (TREE_OPERAND (exp, 1), max_p);\n+\n+\t  if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\t    return exp;\n+\n+\t  return fold_build2 (code, type, op0, op1);\n \n \tcase 3:\n \t  if (code == COND_EXPR)\n-\t    return fold_build2 (max_p ? MAX_EXPR : MIN_EXPR, type,\n-\t\t\t\tmax_size (TREE_OPERAND (exp, 1), max_p),\n-\t\t\t\tmax_size (TREE_OPERAND (exp, 2), max_p));\n+\t    {\n+\t      op1 = TREE_OPERAND (exp, 1);\n+\t      op2 = TREE_OPERAND (exp, 2);\n+\n+\t      if (!op1 || !op2)\n+\t\treturn exp;\n+\n+\t      return\n+\t\tfold_build2 (max_p ? MAX_EXPR : MIN_EXPR, type,\n+\t\t\t     max_size (op1, max_p), max_size (op2, max_p));\n+\t    }\n+\t  break;\n \n \tdefault:\n \t  break;"}]}