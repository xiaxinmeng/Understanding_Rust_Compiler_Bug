{"sha": "cce3c9db9e6ffad764504134336c714a90416e8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NlM2M5ZGI5ZTZmZmFkNzY0NTA0MTM0MzM2YzcxNGE5MDQxNmU4ZA==", "commit": {"author": {"name": "Andrew Sutton", "email": "asutton@lock3software.com", "date": "2019-11-19T15:18:50Z"}, "committer": {"name": "Andrew Sutton", "email": "asutton@gcc.gnu.org", "date": "2019-11-19T15:18:50Z"}, "message": "re PR c++/92078 (error: 'struct std::ptr<Iter>' redeclared with different access)\n\nPR c++/92078\n\ngcc/cp/\n\t* pt.c (maybe_new_partial_specialization): Apply access to newly\n\tcreated partial specializations. Update comment style.\n\ngcc/testsuite/\n\t* g++.dg/cpp2a/concepts-pr92078.C: New.\n  * g++.dg/cpp2a/concepts-requires18.C: Update diagnostics.\n\nFrom-SVN: r278450", "tree": {"sha": "52263d6890f1c2ba154074c7465dc27b9f8599c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52263d6890f1c2ba154074c7465dc27b9f8599c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cce3c9db9e6ffad764504134336c714a90416e8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce3c9db9e6ffad764504134336c714a90416e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cce3c9db9e6ffad764504134336c714a90416e8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce3c9db9e6ffad764504134336c714a90416e8d/comments", "author": {"login": "asutton", "id": 570796, "node_id": "MDQ6VXNlcjU3MDc5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/570796?v=4", "gravatar_id": "", "url": "https://api.github.com/users/asutton", "html_url": "https://github.com/asutton", "followers_url": "https://api.github.com/users/asutton/followers", "following_url": "https://api.github.com/users/asutton/following{/other_user}", "gists_url": "https://api.github.com/users/asutton/gists{/gist_id}", "starred_url": "https://api.github.com/users/asutton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/asutton/subscriptions", "organizations_url": "https://api.github.com/users/asutton/orgs", "repos_url": "https://api.github.com/users/asutton/repos", "events_url": "https://api.github.com/users/asutton/events{/privacy}", "received_events_url": "https://api.github.com/users/asutton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7aabd67f18fb1e0ef4c9981667284c2e57816e01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aabd67f18fb1e0ef4c9981667284c2e57816e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aabd67f18fb1e0ef4c9981667284c2e57816e01"}], "stats": {"total": 134, "additions": 93, "deletions": 41}, "files": [{"sha": "08b44c57b33bab990cf7d3781534168641b43ca9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cce3c9db9e6ffad764504134336c714a90416e8d", "patch": "@@ -1,3 +1,9 @@\n+2019-11-19  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tPR c++/92078\n+\t* pt.c (maybe_new_partial_specialization): Apply access to newly\n+\tcreated partial specializations. Update comment style.\n+\n 2019-11-19  Andrew Sutton  <asutton@lock3software.com>\n \n \tPR c++/92403"}, {"sha": "59f9d03a4bca8ec148dd527e3525d8d122729639", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cce3c9db9e6ffad764504134336c714a90416e8d", "patch": "@@ -848,58 +848,59 @@ check_explicit_instantiation_namespace (tree spec)\n \t       spec, current_namespace, ns);\n }\n \n-// Returns the type of a template specialization only if that\n-// specialization needs to be defined. Otherwise (e.g., if the type has\n-// already been defined), the function returns NULL_TREE.\n+/* Returns the type of a template specialization only if that\n+   specialization needs to be defined. Otherwise (e.g., if the type has\n+   already been defined), the function returns NULL_TREE.  */\n+\n static tree\n maybe_new_partial_specialization (tree type)\n {\n-  // An implicit instantiation of an incomplete type implies\n-  // the definition of a new class template.\n-  //\n-  //    template<typename T>\n-  //      struct S;\n-  //\n-  //    template<typename T>\n-  //      struct S<T*>;\n-  //\n-  // Here, S<T*> is an implicit instantiation of S whose type\n-  // is incomplete.\n+  /* An implicit instantiation of an incomplete type implies\n+     the definition of a new class template.\n+\n+\ttemplate<typename T>\n+\t  struct S;\n+\n+\ttemplate<typename T>\n+\t  struct S<T*>;\n+\n+     Here, S<T*> is an implicit instantiation of S whose type\n+     is incomplete.  */\n   if (CLASSTYPE_IMPLICIT_INSTANTIATION (type) && !COMPLETE_TYPE_P (type))\n     return type;\n \n-  // It can also be the case that TYPE is a completed specialization.\n-  // Continuing the previous example, suppose we also declare:\n-  //\n-  //    template<typename T>\n-  //      requires Integral<T>\n-  //        struct S<T*>;\n-  //\n-  // Here, S<T*> refers to the specialization S<T*> defined\n-  // above. However, we need to differentiate definitions because\n-  // we intend to define a new partial specialization. In this case,\n-  // we rely on the fact that the constraints are different for\n-  // this declaration than that above.\n-  //\n-  // Note that we also get here for injected class names and\n-  // late-parsed template definitions. We must ensure that we\n-  // do not create new type declarations for those cases.\n+  /* It can also be the case that TYPE is a completed specialization.\n+     Continuing the previous example, suppose we also declare:\n+\n+\ttemplate<typename T>\n+\t  requires Integral<T>\n+\t    struct S<T*>;\n+\n+     Here, S<T*> refers to the specialization S<T*> defined\n+     above. However, we need to differentiate definitions because\n+     we intend to define a new partial specialization. In this case,\n+     we rely on the fact that the constraints are different for\n+     this declaration than that above.\n+\n+     Note that we also get here for injected class names and\n+     late-parsed template definitions. We must ensure that we\n+     do not create new type declarations for those cases.  */\n   if (flag_concepts && CLASSTYPE_TEMPLATE_SPECIALIZATION (type))\n     {\n       tree tmpl = CLASSTYPE_TI_TEMPLATE (type);\n       tree args = CLASSTYPE_TI_ARGS (type);\n \n-      // If there are no template parameters, this cannot be a new\n-      // partial template specializtion?\n+      /* If there are no template parameters, this cannot be a new\n+\t partial template specialization?  */\n       if (!current_template_parms)\n         return NULL_TREE;\n \n-      // The injected-class-name is not a new partial specialization.\n+      /* The injected-class-name is not a new partial specialization.  */\n       if (DECL_SELF_REFERENCE_P (TYPE_NAME (type)))\n \treturn NULL_TREE;\n \n-      // If the constraints are not the same as those of the primary\n-      // then, we can probably create a new specialization.\n+      /* If the constraints are not the same as those of the primary\n+\t then, we can probably create a new specialization.  */\n       tree type_constr = current_template_constraints ();\n \n       if (type == TREE_TYPE (tmpl))\n@@ -909,8 +910,8 @@ maybe_new_partial_specialization (tree type)\n \t    return NULL_TREE;\n \t}\n \n-      // Also, if there's a pre-existing specialization with matching\n-      // constraints, then this also isn't new.\n+      /* Also, if there's a pre-existing specialization with matching\n+\t constraints, then this also isn't new.  */\n       tree specs = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n       while (specs)\n         {\n@@ -923,8 +924,8 @@ maybe_new_partial_specialization (tree type)\n           specs = TREE_CHAIN (specs);\n         }\n \n-      // Create a new type node (and corresponding type decl)\n-      // for the newly declared specialization.\n+      /* Create a new type node (and corresponding type decl)\n+\t for the newly declared specialization.  */\n       tree t = make_class_type (TREE_CODE (type));\n       CLASSTYPE_DECLARED_CLASS (t) = CLASSTYPE_DECLARED_CLASS (type);\n       SET_TYPE_TEMPLATE_INFO (t, build_template_info (tmpl, args));\n@@ -934,10 +935,12 @@ maybe_new_partial_specialization (tree type)\n \t equivalent.  So keep TYPE_CANONICAL the same.  */\n       TYPE_CANONICAL (t) = TYPE_CANONICAL (type);\n \n-      // Build the corresponding type decl.\n+      /* Build the corresponding type decl.  */\n       tree d = create_implicit_typedef (DECL_NAME (tmpl), t);\n       DECL_CONTEXT (d) = TYPE_CONTEXT (t);\n       DECL_SOURCE_LOCATION (d) = input_location;\n+      TREE_PRIVATE (d) = (current_access_specifier == access_private_node);\n+      TREE_PROTECTED (d) = (current_access_specifier == access_protected_node);\n \n       return t;\n     }"}, {"sha": "edbf126e1378c7fd247d902fa2cc62f944cd32a6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cce3c9db9e6ffad764504134336c714a90416e8d", "patch": "@@ -1,3 +1,9 @@\n+2019-11-19  Andrew Sutton  <asutton@lock3software.com>\n+\n+\tPR c++/92078\n+\t* g++.dg/cpp2a/concepts-pr92078.C: New.\n+\t* g++.dg/cpp2a/concepts-requires18.C: Update diagnostics.\n+\n 2019-11-19  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* gcc.dg/tree-ssa/loop-1.c: Change amdgcn assembler scan."}, {"sha": "9bfb896cc78dbc49f162110cf54b27f373075362", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-pr92078.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr92078.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr92078.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-pr92078.C?ref=cce3c9db9e6ffad764504134336c714a90416e8d", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile { target c++2a } }\n+\n+template<typename I>\n+struct iterator_traits\n+{\n+private:\n+  template<typename Iter>\n+  struct ptr\n+  { };\n+\n+  template<typename J>\n+    requires requires { typename J::X; }\n+  struct ptr<J>\n+  { };\n+\n+  template<typename J>\n+    requires (!requires { typename J::X; } && requires { typename J::Y; })\n+  struct ptr<J>\n+  { };\n+};"}, {"sha": "c76b12c6414681334d2890ae38f3d5da1ac97876", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-requires18.C", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cce3c9db9e6ffad764504134336c714a90416e8d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-requires18.C?ref=cce3c9db9e6ffad764504134336c714a90416e8d", "patch": "@@ -44,13 +44,25 @@ struct data\n   template<typename U>\n   constexpr bool test()\n   {\n-    if constexpr (requires { requires subst<U&>; }) // { dg-error \"forming reference\" }\n+    if constexpr (requires { requires subst<U&>; })\n       return true;\n     else\n       return false;\n   }\n };\n \n+template<typename T>\n+constexpr bool check_for_resize(T &v, unsigned const n)\n+{\n+  if constexpr (requires { v.resize(n); })\n+    return true;\n+  else\n+    return false;\n+}\n+\n+struct array { };\n+struct vector { void resize(int n); };\n+\n void test()\n {\n   f1<int>();\n@@ -74,4 +86,9 @@ void test()\n   data<int> t;\n   static_assert(t.test<int>());\n   static_assert(t.test<void>()); // { dg-error \"static assertion failed\" }\n+\n+  vector v;\n+  static_assert(check_for_resize(v, 10));\n+  array a;\n+  static_assert(!check_for_resize(a, 10));\n }"}]}