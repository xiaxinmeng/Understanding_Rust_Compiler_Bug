{"sha": "d7386a7a07949458aad3cfe7fdeb4a6b9024b11c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDczODZhN2EwNzk0OTQ1OGFhZDNjZmU3ZmRlYjRhNmI5MDI0YjExYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-01T13:52:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-01T13:52:39Z"}, "message": "[multiple changes]\n\n2011-09-01  Romain Berrendonner  <berrendo@adacore.com>\n\n\t* gnatls.adb: Display simple message instead of content of\n\tgnatlic.adl.\n\n2011-09-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch3.adb: (Build_Derived_Record_Type) Remove the kludgy update of\n\taccess discriminant and anonymous access component scopes.\n\t(Inherit_Component): Reuse the itype of an access discriminant\n\tor anonymous access component by copying it in order to set the proper\n\tscope. This is done only when the parent and the derived type\n\tare in different scopes.\n\t(Set_Anonymous_Etype): New routine.\n\n2011-09-01  Robert Dewar  <dewar@adacore.com>\n\n\t* a-convec.adb: Minor reformatting throughout.\n\nFrom-SVN: r178417", "tree": {"sha": "67e372db00f7d16c6474758c8ec60c8b54d9c52e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67e372db00f7d16c6474758c8ec60c8b54d9c52e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c/comments", "author": null, "committer": null, "parents": [{"sha": "9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1e0e72dbd7a6cd71bd18adeb8d4c8e5cd2d86f"}], "stats": {"total": 301, "additions": 180, "deletions": 121}, "files": [{"sha": "2383b6b93c12baaa0f6330c3a3aabf02985b9be5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d7386a7a07949458aad3cfe7fdeb4a6b9024b11c", "patch": "@@ -1,3 +1,22 @@\n+2011-09-01  Romain Berrendonner  <berrendo@adacore.com>\n+\n+\t* gnatls.adb: Display simple message instead of content of\n+\tgnatlic.adl.\n+\n+2011-09-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch3.adb: (Build_Derived_Record_Type) Remove the kludgy update of\n+\taccess discriminant and anonymous access component scopes.\n+\t(Inherit_Component): Reuse the itype of an access discriminant\n+\tor anonymous access component by copying it in order to set the proper\n+\tscope. This is done only when the parent and the derived type\n+\tare in different scopes.\n+\t(Set_Anonymous_Etype): New routine.\n+\n+2011-09-01  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-convec.adb: Minor reformatting throughout.\n+\n 2011-09-01  Jose Ruiz  <ruiz@adacore.com>\n \n \t* adaint.c, adaint.h (__gnat_cpu_alloc, __gnat_cpu_alloc_size,"}, {"sha": "00a5404c2ba5460f5c10e8f1731dc09dfad2b444", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 97, "deletions": 57, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=d7386a7a07949458aad3cfe7fdeb4a6b9024b11c", "patch": "@@ -37,18 +37,20 @@ package body Ada.Containers.Vectors is\n    procedure Free is\n      new Ada.Unchecked_Deallocation (Elements_Type, Elements_Access);\n \n-   type Iterator is new\n-     Vector_Iterator_Interfaces.Reversible_Iterator with record\n+   type Iterator is new Vector_Iterator_Interfaces.Reversible_Iterator with\n+   record\n       Container : Vector_Access;\n       Index     : Index_Type;\n    end record;\n \n    overriding function First (Object : Iterator) return Cursor;\n    overriding function Last  (Object : Iterator) return Cursor;\n-   overriding function Next  (Object : Iterator; Position : Cursor)\n-     return Cursor;\n-   overriding function Previous (Object : Iterator; Position : Cursor)\n-     return Cursor;\n+   overriding function Next\n+     (Object : Iterator;\n+      Position : Cursor) return Cursor;\n+   overriding function Previous\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n \n    ---------\n    -- \"&\" --\n@@ -125,6 +127,7 @@ package body Ada.Containers.Vectors is\n       --  Count_Type'Base as the type for intermediate values.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n          --  determine whether it lies in the range of the index (sub)type.\n@@ -153,6 +156,7 @@ package body Ada.Containers.Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  Here we can compute Last directly, in the normal way. We know that\n          --  No_Index is less than 0, so there is no danger of overflow when\n          --  adding the (positive) value of length.\n@@ -209,8 +213,7 @@ package body Ada.Containers.Vectors is\n       --  basis for knowing how much larger, so we just allocate the minimum\n       --  amount of storage.\n \n-      --  Here we handle the easy case first, when the vector parameter (Left)\n-      --  is empty.\n+      --  Handle easy case first, when the vector parameter (Left) is empty\n \n       if Left.Is_Empty then\n          declare\n@@ -245,9 +248,7 @@ package body Ada.Containers.Vectors is\n            Left.Elements.EA (Index_Type'First .. Left.Last);\n \n          Elements : constant Elements_Access :=\n-           new Elements_Type'\n-                 (Last => Last,\n-                  EA   => LE & Right);\n+                      new Elements_Type'(Last => Last, EA => LE & Right);\n \n       begin\n          return (Controlled with Elements, Last, 0, 0);\n@@ -261,8 +262,7 @@ package body Ada.Containers.Vectors is\n       --  basis for knowing how much larger, so we just allocate the minimum\n       --  amount of storage.\n \n-      --  Here we handle the easy case first, when the vector parameter (Right)\n-      --  is empty.\n+      --  Handle easy case first, when the vector parameter (Right) is empty\n \n       if Right.Is_Empty then\n          declare\n@@ -440,9 +440,9 @@ package body Ada.Containers.Vectors is\n    begin\n       if Container.Elements = null then\n          return 0;\n+      else\n+         return Container.Elements.EA'Length;\n       end if;\n-\n-      return Container.Elements.EA'Length;\n    end Capacity;\n \n    -----------\n@@ -454,9 +454,9 @@ package body Ada.Containers.Vectors is\n       if Container.Busy > 0 then\n          raise Program_Error with\n            \"attempt to tamper with cursors (vector is busy)\";\n+      else\n+         Container.Last := No_Index;\n       end if;\n-\n-      Container.Last := No_Index;\n    end Clear;\n \n    --------------\n@@ -711,13 +711,11 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      if Position.Index > Position.Container.Last then\n+      elsif Position.Index > Position.Container.Last then\n          raise Constraint_Error with \"Position cursor is out of range\";\n+      else\n+         return Position.Container.Elements.EA (Position.Index);\n       end if;\n-\n-      return Position.Container.Elements.EA (Position.Index);\n    end Element;\n \n    --------------\n@@ -794,18 +792,18 @@ package body Ada.Containers.Vectors is\n    begin\n       if Is_Empty (Container) then\n          return No_Element;\n+      else\n+         return (Container'Unchecked_Access, Index_Type'First);\n       end if;\n-\n-      return (Container'Unchecked_Access, Index_Type'First);\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n    begin\n       if Is_Empty (Object.Container.all) then\n          return No_Element;\n+      else\n+         return Cursor'(Object.Container, Index_Type'First);\n       end if;\n-\n-      return Cursor'(Object.Container, Index_Type'First);\n    end First;\n \n    -------------------\n@@ -816,9 +814,9 @@ package body Ada.Containers.Vectors is\n    begin\n       if Container.Last = No_Index then\n          raise Constraint_Error with \"Container is empty\";\n+      else\n+         return Container.Elements.EA (Index_Type'First);\n       end if;\n-\n-      return Container.Elements.EA (Index_Type'First);\n    end First_Element;\n \n    -----------------\n@@ -850,8 +848,8 @@ package body Ada.Containers.Vectors is\n          declare\n             EA : Elements_Array renames Container.Elements.EA;\n          begin\n-            for I in Index_Type'First .. Container.Last - 1 loop\n-               if EA (I + 1) < EA (I) then\n+            for J in Index_Type'First .. Container.Last - 1 loop\n+               if EA (J + 1) < EA (J) then\n                   return False;\n                end if;\n             end loop;\n@@ -1044,17 +1042,20 @@ package body Ada.Containers.Vectors is\n       --  acceptable, then we compute the new last index from that.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n \n          if Index_Type'First <= 0 then\n+\n             --  We know that No_Index (the same as Index_Type'First - 1) is\n             --  less than 0, so it is safe to compute the following sum without\n             --  fear of overflow.\n \n             Index := No_Index + Index_Type'Base (Count_Type'Last);\n \n             if Index <= Index_Type'Last then\n+\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -1079,13 +1080,15 @@ package body Ada.Containers.Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  We know that No_Index (the same as Index_Type'First - 1) is less\n          --  than 0, so it is safe to compute the following sum without fear of\n          --  overflow.\n \n          J := Count_Type'Base (No_Index) + Count_Type'Last;\n \n          if J <= Count_Type'Base (Index_Type'Last) then\n+\n             --  We have determined that range of Index_Type has at least as\n             --  many values as in Count_Type, so Count_Type'Last is the maximum\n             --  number of items that are allowed.\n@@ -1172,6 +1175,7 @@ package body Ada.Containers.Vectors is\n       --  whether there is enough unused storage for the new items.\n \n       if New_Length <= Container.Elements.EA'Length then\n+\n          --  In this case, we're inserting elements into a vector that has\n          --  already allocated an internal array, and the existing array has\n          --  enough unused storage for the new items.\n@@ -1181,6 +1185,7 @@ package body Ada.Containers.Vectors is\n \n          begin\n             if Before > Container.Last then\n+\n                --  The new items are being appended to the vector, so no\n                --  sliding of existing elements is required.\n \n@@ -1228,6 +1233,7 @@ package body Ada.Containers.Vectors is\n       end loop;\n \n       if New_Capacity > Max_Length then\n+\n          --  We have reached the limit of capacity, so no further expansion\n          --  will occur. (This is not a problem, as there is never a need to\n          --  have more capacity than the maximum container length.)\n@@ -1282,6 +1288,7 @@ package body Ada.Containers.Vectors is\n             DA (Before .. Index - 1) := (others => New_Item);\n             DA (Index .. New_Last) := SA (Before .. Container.Last);\n          end if;\n+\n       exception\n          when others =>\n             Free (Dst);\n@@ -1324,6 +1331,7 @@ package body Ada.Containers.Vectors is\n       Insert_Space (Container, Before, Count => N);\n \n       if N = 0 then\n+\n          --  There's nothing else to do here (vetting of parameters was\n          --  performed already in Insert_Space), so we simply return.\n \n@@ -1341,6 +1349,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Container'Address /= New_Item'Address then\n+\n          --  This is the simple case.  New_Item denotes an object different\n          --  from Container, so there's nothing special we need to do to copy\n          --  the source items to their destination, because all of the source\n@@ -1386,6 +1395,7 @@ package body Ada.Containers.Vectors is\n          Container.Elements.EA (Before .. K) := Src;\n \n          if Src'Length = N then\n+\n             --  The new items were effectively appended to the container, so we\n             --  have already copied all of the items that need to be copied.\n             --  We return early here, even though the source slice below is\n@@ -1536,10 +1546,10 @@ package body Ada.Containers.Vectors is\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n+         else\n+            Index := Container.Last + 1;\n          end if;\n \n-         Index := Container.Last + 1;\n-\n       else\n          Index := Before.Index;\n       end if;\n@@ -1700,17 +1710,20 @@ package body Ada.Containers.Vectors is\n       --  acceptable, then we compute the new last index from that.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We have to handle the case when there might be more values in the\n          --  range of Index_Type than in the range of Count_Type.\n \n          if Index_Type'First <= 0 then\n+\n             --  We know that No_Index (the same as Index_Type'First - 1) is\n             --  less than 0, so it is safe to compute the following sum without\n             --  fear of overflow.\n \n             Index := No_Index + Index_Type'Base (Count_Type'Last);\n \n             if Index <= Index_Type'Last then\n+\n                --  We have determined that range of Index_Type has at least as\n                --  many values as in Count_Type, so Count_Type'Last is the\n                --  maximum number of items that are allowed.\n@@ -1735,13 +1748,15 @@ package body Ada.Containers.Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  We know that No_Index (the same as Index_Type'First - 1) is less\n          --  than 0, so it is safe to compute the following sum without fear of\n          --  overflow.\n \n          J := Count_Type'Base (No_Index) + Count_Type'Last;\n \n          if J <= Count_Type'Base (Index_Type'Last) then\n+\n             --  We have determined that range of Index_Type has at least as\n             --  many values as in Count_Type, so Count_Type'Last is the maximum\n             --  number of items that are allowed.\n@@ -1827,6 +1842,7 @@ package body Ada.Containers.Vectors is\n       --  whether there is enough unused storage for the new items.\n \n       if New_Last <= Container.Elements.Last then\n+\n          --  In this case, we're inserting space into a vector that has already\n          --  allocated an internal array, and the existing array has enough\n          --  unused storage for the new items.\n@@ -1836,6 +1852,7 @@ package body Ada.Containers.Vectors is\n \n          begin\n             if Before <= Container.Last then\n+\n                --  The space is being inserted before some existing elements,\n                --  so we must slide the existing elements up to their new\n                --  home. We use the wider of Index_Type'Base and\n@@ -1876,6 +1893,7 @@ package body Ada.Containers.Vectors is\n       end loop;\n \n       if New_Capacity > Max_Length then\n+\n          --  We have reached the limit of capacity, so no further expansion\n          --  will occur. (This is not a problem, as there is never a need to\n          --  have more capacity than the maximum container length.)\n@@ -1914,6 +1932,7 @@ package body Ada.Containers.Vectors is\n            SA (Index_Type'First .. Before - 1);\n \n          if Before <= Container.Last then\n+\n             --  The space is being inserted before some existing elements, so\n             --  we must slide the existing elements up to their new home.\n \n@@ -1926,6 +1945,7 @@ package body Ada.Containers.Vectors is\n \n             DA (Index .. New_Last) := SA (Before .. Container.Last);\n          end if;\n+\n       exception\n          when others =>\n             Free (Dst);\n@@ -1938,6 +1958,7 @@ package body Ada.Containers.Vectors is\n \n       declare\n          X : Elements_Access := Container.Elements;\n+\n       begin\n          --  We first isolate the old internal array, removing it from the\n          --  container and replacing it with the new internal array, before we\n@@ -1987,10 +2008,10 @@ package body Ada.Containers.Vectors is\n          if Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n+         else\n+            Index := Container.Last + 1;\n          end if;\n \n-         Index := Container.Last + 1;\n-\n       else\n          Index := Before.Index;\n       end if;\n@@ -2036,15 +2057,18 @@ package body Ada.Containers.Vectors is\n       B := B - 1;\n    end Iterate;\n \n-   function Iterate (Container : Vector)\n+   function Iterate\n+     (Container : Vector)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       It : constant Iterator := (Container'Unchecked_Access, Index_Type'First);\n    begin\n       return It;\n    end Iterate;\n \n-   function Iterate (Container : Vector; Start : Cursor)\n+   function Iterate\n+     (Container : Vector;\n+      Start     : Cursor)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'class\n    is\n       It : constant Iterator := (Container'Unchecked_Access, Start.Index);\n@@ -2060,18 +2084,18 @@ package body Ada.Containers.Vectors is\n    begin\n       if Is_Empty (Container) then\n          return No_Element;\n+      else\n+         return (Container'Unchecked_Access, Container.Last);\n       end if;\n-\n-      return (Container'Unchecked_Access, Container.Last);\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n       if Is_Empty (Object.Container.all) then\n          return No_Element;\n+      else\n+         return Cursor'(Object.Container, Object.Container.Last);\n       end if;\n-\n-      return Cursor'(Object.Container, Object.Container.Last);\n    end Last;\n \n    ------------------\n@@ -2082,9 +2106,9 @@ package body Ada.Containers.Vectors is\n    begin\n       if Container.Last = No_Index then\n          raise Constraint_Error with \"Container is empty\";\n+      else\n+         return Container.Elements.EA (Container.Last);\n       end if;\n-\n-      return Container.Elements.EA (Container.Last);\n    end Last_Element;\n \n    ----------------\n@@ -2172,13 +2196,11 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      end if;\n-\n-      if Position.Index < Position.Container.Last then\n+      elsif Position.Index < Position.Container.Last then\n          return (Position.Container, Position.Index + 1);\n+      else\n+         return No_Element;\n       end if;\n-\n-      return No_Element;\n    end Next;\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n@@ -2369,8 +2391,10 @@ package body Ada.Containers.Vectors is\n    ---------------\n \n    function Constant_Reference\n-     (Container : Vector; Position : Cursor)    --  SHOULD BE ALIASED\n-   return Constant_Reference_Type is\n+     (Container : Vector;\n+      Position  : Cursor)    --  SHOULD BE ALIASED\n+      return Constant_Reference_Type\n+   is\n    begin\n       pragma Unreferenced (Container);\n \n@@ -2388,14 +2412,16 @@ package body Ada.Containers.Vectors is\n    end Constant_Reference;\n \n    function Constant_Reference\n-     (Container : Vector; Position : Index_Type)\n-   return Constant_Reference_Type is\n+     (Container : Vector;\n+      Position  : Index_Type)\n+      return Constant_Reference_Type\n+   is\n    begin\n       if (Position) > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n+      else\n+         return (Element => Container.Elements.EA (Position)'Access);\n       end if;\n-\n-      return (Element => Container.Elements.EA (Position)'Access);\n    end Constant_Reference;\n \n    function Reference (Container : Vector; Position : Cursor)\n@@ -2420,9 +2446,9 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n+      else\n+         return (Element => Container.Elements.EA (Position)'Access);\n       end if;\n-\n-      return (Element => Container.Elements.EA (Position)'Access);\n    end Reference;\n \n    ---------------------\n@@ -2496,17 +2522,20 @@ package body Ada.Containers.Vectors is\n       --  container length.\n \n       if Capacity = 0 then\n+\n          --  This is a request to trim back storage, to the minimum amount\n          --  possible given the current state of the container.\n \n          if N = 0 then\n+\n             --  The container is empty, so in this unique case we can\n             --  deallocate the entire internal array. Note that an empty\n             --  container can never be busy, so there's no need to check the\n             --  tampering bits.\n \n             declare\n                X : Elements_Access := Container.Elements;\n+\n             begin\n                --  First we remove the internal array from the container, to\n                --  handle the case when the deallocation raises an exception.\n@@ -2520,6 +2549,7 @@ package body Ada.Containers.Vectors is\n             end;\n \n          elsif N < Container.Elements.EA'Length then\n+\n             --  The container is not empty, and the current length is less than\n             --  the current capacity, so there's storage available to trim. In\n             --  this case, we allocate a new internal array having a length\n@@ -2576,6 +2606,7 @@ package body Ada.Containers.Vectors is\n       --  any possibility of overflow.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n          --  determine whether it lies in the range of the index (sub)type.\n@@ -2604,6 +2635,7 @@ package body Ada.Containers.Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  Here we can compute Last directly, in the normal way. We know that\n          --  No_Index is less than 0, so there is no danger of overflow when\n          --  adding the (positive) value of Capacity.\n@@ -2642,6 +2674,7 @@ package body Ada.Containers.Vectors is\n       --  this is a request for expansion or contraction of storage.\n \n       if Container.Elements = null then\n+\n          --  The container is empty (it doesn't even have an internal array),\n          --  so this represents a request to allocate (expand) storage having\n          --  the given capacity.\n@@ -2651,11 +2684,13 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Capacity <= N then\n+\n          --  This is a request to trim back storage, but only to the limit of\n          --  what's already in the container. (Reserve_Capacity never deletes\n          --  active elements, it only reclaims excess storage.)\n \n          if N < Container.Elements.EA'Length then\n+\n             --  The container is not empty (because the requested capacity is\n             --  positive, and less than or equal to the container length), and\n             --  the current length is less than the current capacity, so\n@@ -2708,6 +2743,7 @@ package body Ada.Containers.Vectors is\n       --  current capacity is.\n \n       if Capacity = Container.Elements.EA'Length then\n+\n          --  The requested capacity matches the existing capacity, so there's\n          --  nothing to do here. We treat this case as a no-op, and simply\n          --  return without checking the busy bit.\n@@ -2761,6 +2797,7 @@ package body Ada.Containers.Vectors is\n \n          declare\n             X : Elements_Access := Container.Elements;\n+\n          begin\n             --  First we isolate the old internal array, and replace it in the\n             --  container with the new internal array.\n@@ -2982,9 +3019,9 @@ package body Ada.Containers.Vectors is\n    begin\n       if Index not in Index_Type'First .. Container.Last then\n          return No_Element;\n+      else\n+         return Cursor'(Container'Unchecked_Access, Index);\n       end if;\n-\n-      return Cursor'(Container'Unchecked_Access, Index);\n    end To_Cursor;\n \n    --------------\n@@ -3026,6 +3063,7 @@ package body Ada.Containers.Vectors is\n       --  create a Last index value greater than Index_Type'Last.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n          --  determine whether it lies in the range of the index (sub)type.\n@@ -3054,6 +3092,7 @@ package body Ada.Containers.Vectors is\n          end if;\n \n       elsif Index_Type'First <= 0 then\n+\n          --  Here we can compute Last directly, in the normal way. We know that\n          --  No_Index is less than 0, so there is no danger of overflow when\n          --  adding the (positive) value of Length.\n@@ -3114,6 +3153,7 @@ package body Ada.Containers.Vectors is\n       --  create a Last index value greater than Index_Type'Last.\n \n       if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n+\n          --  We perform a two-part test. First we determine whether the\n          --  computed Last value lies in the base range of the type, and then\n          --  determine whether it lies in the range of the index (sub)type."}, {"sha": "4bf9c1268e4654415d75f42139b5ca6a434c599a", "filename": "gcc/ada/gnatls.adb", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c/gcc%2Fada%2Fgnatls.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c/gcc%2Fada%2Fgnatls.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatls.adb?ref=d7386a7a07949458aad3cfe7fdeb4a6b9024b11c", "patch": "@@ -822,41 +822,18 @@ procedure Gnatls is\n    --------------------------------\n \n    procedure Output_License_Information is\n-      Params_File_Name : constant String := \"gnatlic.adl\";\n-      --  Name of license file\n-\n-      Lo   : constant Source_Ptr := 1;\n-      Hi   : Source_Ptr;\n-      Text : Source_Buffer_Ptr;\n-\n    begin\n-      Name_Len := 0;\n-      Add_Str_To_Name_Buffer (Params_File_Name);\n-      Read_Source_File (Name_Find, Lo, Hi, Text);\n-\n-      if Text /= null then\n-\n-         --  Omit last character (end-of-file marker) in output\n-\n-         Write_Str (String (Text (Lo .. Hi - 1)));\n-         Write_Eol;\n-\n-         --  The following condition is determined at compile time: disable\n-         --  \"condition is always true/false\" warning.\n-\n-         pragma Warnings (Off);\n-      elsif Build_Type /= GPL and then Build_Type /= FSF then\n-         pragma Warnings (On);\n-\n-         Write_Str (\"License file missing, please contact AdaCore.\");\n-         Write_Eol;\n-\n-      else\n-         Write_Str (\"Please refer to file COPYING in your distribution\"\n-                  & \" for license terms.\");\n-         Write_Eol;\n-\n-      end if;\n+      case Build_Type is\n+         when Gnatpro =>\n+            Write_Str (\"Please refer to the section \"\"Software License\"\" on\"\n+                     & \" GNAT Tracker at http://www.adacore.com/\"\n+                     & \" for license terms.\");\n+            Write_Eol;\n+         when others =>\n+            Write_Str (\"Please refer to file COPYING in your distribution\"\n+                     & \" for license terms.\");\n+            Write_Eol;\n+      end case;\n \n       Exit_Program (E_Success);\n    end Output_License_Information;"}, {"sha": "2533be2776d215507b52506f97b3c64db645e436", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 53, "deletions": 30, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7386a7a07949458aad3cfe7fdeb4a6b9024b11c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d7386a7a07949458aad3cfe7fdeb4a6b9024b11c", "patch": "@@ -7980,28 +7980,6 @@ package body Sem_Ch3 is\n          Set_Last_Entity\n            (Class_Wide_Type (Derived_Type), Last_Entity (Derived_Type));\n       end if;\n-\n-      --  Update the scope of anonymous access types of discriminants and other\n-      --  components, to prevent scope anomalies in gigi, when the derivation\n-      --  appears in a scope nested within that of the parent.\n-\n-      declare\n-         D : Entity_Id;\n-\n-      begin\n-         D := First_Entity (Derived_Type);\n-         while Present (D) loop\n-            if Ekind_In (D, E_Discriminant, E_Component) then\n-               if Is_Itype (Etype (D))\n-                  and then Ekind (Etype (D)) = E_Anonymous_Access_Type\n-               then\n-                  Set_Scope (Etype (D), Current_Scope);\n-               end if;\n-            end if;\n-\n-            Next_Entity (D);\n-         end loop;\n-      end;\n    end Build_Derived_Record_Type;\n \n    ------------------------\n@@ -15702,10 +15680,42 @@ package body Sem_Ch3 is\n          Plain_Discrim  : Boolean := False;\n          Stored_Discrim : Boolean := False)\n       is\n+         procedure Set_Anonymous_Type (Id : Entity_Id);\n+         --  Id denotes the entity of an access discriminant or anonymous\n+         --  access component. Set the type of Id to either the same type of\n+         --  Old_C or create a new one depending on whether the parent and\n+         --  the child types are in the same scope.\n+\n+         ------------------------\n+         -- Set_Anonymous_Type --\n+         ------------------------\n+\n+         procedure Set_Anonymous_Type (Id : Entity_Id) is\n+            Typ : constant Entity_Id := Etype (Old_C);\n+\n+         begin\n+            if Scope (Parent_Base) = Scope (Derived_Base) then\n+               Set_Etype (Id, Typ);\n+\n+            --  The parent and the derived type are in two different scopes.\n+            --  Reuse the type of the original discriminant / component by\n+            --  copying it in order to preserve all attributes and update the\n+            --  scope.\n+\n+            else\n+               Set_Etype (Id, New_Copy (Typ));\n+               Set_Scope (Etype (Id), Current_Scope);\n+            end if;\n+         end Set_Anonymous_Type;\n+\n+         --  Local variables and constants\n+\n          New_C : constant Entity_Id := New_Copy (Old_C);\n \n-         Discrim      : Entity_Id;\n          Corr_Discrim : Entity_Id;\n+         Discrim      : Entity_Id;\n+\n+      --  Start of processing for Inherit_Component\n \n       begin\n          pragma Assert (not Is_Tagged or else not Stored_Discrim);\n@@ -15727,6 +15737,14 @@ package body Sem_Ch3 is\n             Set_Original_Record_Component (New_C, New_C);\n          end if;\n \n+         --  Set the proper type of an access discriminant\n+\n+         if Ekind (New_C) = E_Discriminant\n+           and then Ekind (Etype (New_C)) = E_Anonymous_Access_Type\n+         then\n+            Set_Anonymous_Type (New_C);\n+         end if;\n+\n          --  If we have inherited a component then see if its Etype contains\n          --  references to Parent_Base discriminants. In this case, replace\n          --  these references with the constraints given in Discs. We do not\n@@ -15736,10 +15754,16 @@ package body Sem_Ch3 is\n          --  transformation in some error situations.\n \n          if Ekind (New_C) = E_Component then\n-            if (Is_Private_Type (Derived_Base)\n-                 and then not Is_Generic_Type (Derived_Base))\n+\n+            --  Set the proper type of an anonymous access component\n+\n+            if Ekind (Etype (New_C)) = E_Anonymous_Access_Type then\n+               Set_Anonymous_Type (New_C);\n+\n+            elsif (Is_Private_Type (Derived_Base)\n+                     and then not Is_Generic_Type (Derived_Base))\n               or else (Is_Empty_Elmt_List (Discs)\n-                        and then  not Expander_Active)\n+                         and then not Expander_Active)\n             then\n                Set_Etype (New_C, Etype (Old_C));\n \n@@ -15760,10 +15784,9 @@ package body Sem_Ch3 is\n                --        type T_2 is new Pack_1.T_1 with ...;\n                --     end Pack_2;\n \n-               Set_Etype\n-                 (New_C,\n-                  Constrain_Component_Type\n-                  (Old_C, Derived_Base, N, Parent_Base, Discs));\n+               Set_Etype (New_C,\n+                 Constrain_Component_Type\n+                   (Old_C, Derived_Base, N, Parent_Base, Discs));\n             end if;\n          end if;\n "}]}