{"sha": "f01cf809285f7d659f1b4ae1541041a0257df0bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxY2Y4MDkyODVmN2Q2NTlmMWI0YWUxNTQxMDQxYTAyNTdkZjBiYg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2005-12-09T11:20:40Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-12-09T11:20:40Z"}, "message": "re PR target/25311 (ICE in reload_cse_simplify_operands, at postreload.c:393)\n\n\tPR target/25311\n\t* config/s390/s390.c (struct s390_address): New field literal_pool.\n\t(s390_decompose_address): Compute literal_pool field.  Do not \n\tassume register %r13 is always (and solely) used as pool base.\n\t(s390_extra_constraint_str): Use literal_pool field.\n\n\tPR target/25311\n\t* gcc.c-torture/compile/pr25311.c: New test.\n\nFrom-SVN: r108278", "tree": {"sha": "f9cafa8fc0adff924abf2d60a4dc5b4314d35e82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9cafa8fc0adff924abf2d60a4dc5b4314d35e82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f01cf809285f7d659f1b4ae1541041a0257df0bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f01cf809285f7d659f1b4ae1541041a0257df0bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f01cf809285f7d659f1b4ae1541041a0257df0bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f01cf809285f7d659f1b4ae1541041a0257df0bb/comments", "author": null, "committer": null, "parents": [{"sha": "fb2d50f586c7a830d5a40e0f77fbdbba3ca10849", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb2d50f586c7a830d5a40e0f77fbdbba3ca10849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb2d50f586c7a830d5a40e0f77fbdbba3ca10849"}], "stats": {"total": 106, "additions": 93, "deletions": 13}, "files": [{"sha": "e189251071ce3886e25efd5d0b17b3bd29f050cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01cf809285f7d659f1b4ae1541041a0257df0bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01cf809285f7d659f1b4ae1541041a0257df0bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f01cf809285f7d659f1b4ae1541041a0257df0bb", "patch": "@@ -1,3 +1,11 @@\n+2005-12-09  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\tPR target/25311\n+\t* config/s390/s390.c (struct s390_address): New field literal_pool.\n+\t(s390_decompose_address): Compute literal_pool field.  Do not \n+\tassume register %r13 is always (and solely) used as pool base.\n+\t(s390_extra_constraint_str): Use literal_pool field.\n+\n 2005-12-09  Thiemo Seufer  <ths@networkno.de>\n \n \t* config/mips/mips.c (override_options): Don't allow too small"}, {"sha": "02174ff1bd3fa8f95f58ba412d958a4463a07f3f", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01cf809285f7d659f1b4ae1541041a0257df0bb/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01cf809285f7d659f1b4ae1541041a0257df0bb/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f01cf809285f7d659f1b4ae1541041a0257df0bb", "patch": "@@ -209,6 +209,7 @@ struct s390_address\n   rtx indx;\n   rtx disp;\n   bool pointer;\n+  bool literal_pool;\n };\n \n /* Which cpu are we tuning for.  */\n@@ -1473,6 +1474,14 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n   bool pointer = false;\n   bool base_ptr = false;\n   bool indx_ptr = false;\n+  bool literal_pool = false;\n+\n+  /* We may need to substitute the literal pool base register into the address\n+     below.  However, at this point we do not know which register is going to\n+     be used as base, so we substitute the arg pointer register.  This is going\n+     to be treated as holding a pointer below -- it shouldn't be used for any\n+     other purpose.  */\n+  rtx fake_pool_base = gen_rtx_REG (Pmode, ARG_POINTER_REGNUM);\n \n   /* Decompose address into base + index + displacement.  */\n \n@@ -1545,9 +1554,9 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n     {\n       /* Either base or index must be free to hold the base register.  */\n       if (!base)\n-        base = gen_rtx_REG (Pmode, BASE_REGNUM);\n+        base = fake_pool_base, literal_pool = true;\n       else if (!indx)\n-        indx = gen_rtx_REG (Pmode, BASE_REGNUM);\n+        indx = fake_pool_base, literal_pool = true;\n       else\n         return false;\n \n@@ -1570,11 +1579,14 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t    else\n \t      return false;\n \n-\t    base = gen_rtx_REG (Pmode, BASE_REGNUM);\n+\t    base = XVECEXP (base, 0, 1);\n \t    break;\n \n \t  case UNSPEC_LTREL_BASE:\n-\t    base = gen_rtx_REG (Pmode, BASE_REGNUM);\n+\t    if (XVECLEN (base, 0) == 1)\n+\t      base = fake_pool_base, literal_pool = true;\n+\t    else\n+\t      base = XVECEXP (base, 0, 1);\n \t    break;\n \n \t  default:\n@@ -1584,8 +1596,7 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n       if (GET_CODE (base) != REG || GET_MODE (base) != Pmode)\n \treturn false;\n \n-      if (REGNO (base) == BASE_REGNUM\n-\t  || REGNO (base) == STACK_POINTER_REGNUM\n+      if (REGNO (base) == STACK_POINTER_REGNUM\n \t  || REGNO (base) == FRAME_POINTER_REGNUM\n \t  || ((reload_completed || reload_in_progress)\n \t      && frame_pointer_needed\n@@ -1594,6 +1605,10 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n           || (flag_pic\n               && REGNO (base) == PIC_OFFSET_TABLE_REGNUM))\n         pointer = base_ptr = true;\n+\n+      if ((reload_completed || reload_in_progress)\n+\t  && base == cfun->machine->base_reg)\n+        pointer = base_ptr = literal_pool = true;\n     }\n \n   /* Validate index register.  */\n@@ -1610,11 +1625,14 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n \t    else\n \t      return false;\n \n-\t    indx = gen_rtx_REG (Pmode, BASE_REGNUM);\n+\t    indx = XVECEXP (indx, 0, 1);\n \t    break;\n \n \t  case UNSPEC_LTREL_BASE:\n-\t    indx = gen_rtx_REG (Pmode, BASE_REGNUM);\n+\t    if (XVECLEN (indx, 0) == 1)\n+\t      indx = fake_pool_base, literal_pool = true;\n+\t    else\n+\t      indx = XVECEXP (indx, 0, 1);\n \t    break;\n \n \t  default:\n@@ -1624,8 +1642,7 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n       if (GET_CODE (indx) != REG || GET_MODE (indx) != Pmode)\n \treturn false;\n \n-      if (REGNO (indx) == BASE_REGNUM\n-\t  || REGNO (indx) == STACK_POINTER_REGNUM\n+      if (REGNO (indx) == STACK_POINTER_REGNUM\n \t  || REGNO (indx) == FRAME_POINTER_REGNUM\n \t  || ((reload_completed || reload_in_progress)\n \t      && frame_pointer_needed\n@@ -1634,6 +1651,10 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n           || (flag_pic\n               && REGNO (indx) == PIC_OFFSET_TABLE_REGNUM))\n         pointer = indx_ptr = true;\n+\n+      if ((reload_completed || reload_in_progress)\n+\t  && indx == cfun->machine->base_reg)\n+        pointer = indx_ptr = literal_pool = true;\n     }\n \n   /* Prefer to use pointer as base, not index.  */\n@@ -1721,6 +1742,7 @@ s390_decompose_address (rtx addr, struct s390_address *out)\n       out->indx = indx;\n       out->disp = orig_disp;\n       out->pointer = pointer;\n+      out->literal_pool = literal_pool;\n     }\n \n   return true;\n@@ -1809,9 +1831,7 @@ s390_extra_constraint_str (rtx op, int c, const char * str)\n \treturn 0;\n       if (!s390_decompose_address (XEXP (op, 0), &addr))\n \treturn 0;\n-      if (addr.base && REG_P (addr.base) && REGNO (addr.base) == BASE_REGNUM)\n-\treturn 0;\n-      if (addr.indx && REG_P (addr.indx) && REGNO (addr.indx) == BASE_REGNUM)\n+      if (addr.literal_pool)\n \treturn 0;\n \n       c = str[1];"}, {"sha": "15da2cf92ce864271b8bbbcfc35d150e2fcd1226", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01cf809285f7d659f1b4ae1541041a0257df0bb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01cf809285f7d659f1b4ae1541041a0257df0bb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f01cf809285f7d659f1b4ae1541041a0257df0bb", "patch": "@@ -1,3 +1,8 @@\n+2005-12-09  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\tPR target/25311\n+\t* gcc.c-torture/compile/pr25311.c: New test.\n+\n 2005-12-08  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/25039"}, {"sha": "26c5bc37b831da305cf50bb8eef25a8a04ea4578", "filename": "gcc/testsuite/gcc.c-torture/compile/pr25311.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f01cf809285f7d659f1b4ae1541041a0257df0bb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr25311.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f01cf809285f7d659f1b4ae1541041a0257df0bb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr25311.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr25311.c?ref=f01cf809285f7d659f1b4ae1541041a0257df0bb", "patch": "@@ -0,0 +1,47 @@\n+\n+struct w\n+{\n+  int top;\n+  int left;\n+  int height;\n+  int width;\n+  struct w *next;\n+  struct w *parent;\n+  struct w *child;\n+};\n+\n+extern struct w *Qnil;\n+\n+void\n+set_size (struct w *w, int new_size, int nodelete, int set_height)\n+{\n+  int old_size = set_height? w->height : w->width;\n+\n+  if (nodelete || w->parent == Qnil)\n+    {\n+      int last_pos, last_old_pos, pos, old_pos, first;\n+      int div_val = old_size << 1;\n+      struct w *c;\n+\n+      last_pos = first = set_height? w->top : w->left;\n+      last_old_pos = 0;\n+\n+      for (c = w->child; c != Qnil; c = c->next)\n+\t{\n+\t  if (set_height)\n+\t    old_pos = last_old_pos + c->height;\n+\t  else\n+\t    old_pos = last_old_pos + c->width;\n+\n+\t  pos = (((old_pos * new_size) << 1) + old_size) / div_val;\n+\t  set_size (c, pos + first - last_pos, 1, set_height);\n+\t  last_pos = pos + first;\n+\t  last_old_pos = old_pos;\n+\t}\n+\n+      if (!nodelete)\n+\tfor (c = w->child; c != Qnil; c = c->next)\n+\t  use (c);\n+    }\n+}\n+"}]}