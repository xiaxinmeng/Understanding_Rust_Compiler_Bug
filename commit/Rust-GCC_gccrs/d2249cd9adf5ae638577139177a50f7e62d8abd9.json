{"sha": "d2249cd9adf5ae638577139177a50f7e62d8abd9", "node_id": "C_kwDOANBUbNoAKGQyMjQ5Y2Q5YWRmNWFlNjM4NTc3MTM5MTc3YTUwZjdlNjJkOGFiZDk", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-10-14T14:05:57Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-10-26T19:13:04Z"}, "message": "c++: Implement -Wdangling-reference [PR106393]\n\nThis patch implements a new experimental warning (enabled by -Wall) to\ndetect references bound to temporaries whose lifetime has ended.  The\nprimary motivation is the Note in\n<https://en.cppreference.com/w/cpp/algorithm/max>:\n\n  Capturing the result of std::max by reference produces a dangling reference\n  if one of the parameters is a temporary and that parameter is returned:\n\n  int n = 1;\n  const int& r = std::max(n-1, n+1); // r is dangling\n\nThat's because both temporaries for n-1 and n+1 are destroyed at the end\nof the full expression.  With this warning enabled, you'll get:\n\ng.C:3:12: warning: possibly dangling reference to a temporary [-Wdangling-reference]\n    3 | const int& r = std::max(n-1, n+1);\n      |            ^\ng.C:3:24: note: the temporary was destroyed at the end of the full expression 'std::max<int>((n - 1), (n + 1))'\n    3 | const int& r = std::max(n-1, n+1);\n      |                ~~~~~~~~^~~~~~~~~~\n\nThe warning works by checking if a reference is initialized with a function\nthat returns a reference, and at least one parameter of the function is\na reference that is bound to a temporary.  It assumes that such a function\nactually returns one of its arguments!  (I added code to check_return_expr\nto suppress the warning when we've seen the definition of the function\nand we can say that it can return a variable with static storage\nduration.)\n\nIt warns when the function in question is a member function, but only if\nthe function is invoked on a temporary object, otherwise the warning\nwould emit loads of warnings for valid code like obj.emplace<T>({0}, 0).\nIt does detect the dangling reference in:\n\n  struct S {\n    const S& self () { return *this; }\n  };\n  const S& s = S().self();\n\nIt warns in member initializer lists as well:\n\n  const int& f(const int& i) { return i; }\n  struct S {\n    const int &r;\n    S() : r(f(10)) { }\n  };\n\nI've run the testsuite/bootstrap with the warning enabled by default.\nThere were just a few FAILs, all of which look like genuine bugs.\nA bootstrap with the warning enabled by default passed as well.\n\nWhen testing a previous version of the patch, there were many FAILs in\nlibstdc++'s 22_locale/; all of them because the warning triggered on\n\n  const test_type& obj = std::use_facet<test_type>(std::locale());\n\nbut this code looks valid -- std::use_facet doesn't return a reference\nto its parameter.  Therefore I added a #pragma and code to suppress the\nwarning.\n\n\tPR c++/106393\n\ngcc/c-family/ChangeLog:\n\n\t* c.opt (Wdangling-reference): New.\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (expr_represents_temporary_p): New, factored out of...\n\t(conv_binds_ref_to_temporary): ...here.  Don't return false just\n\tbecause a ck_base is missing.  Use expr_represents_temporary_p.\n\t(do_warn_dangling_reference): New.\n\t(maybe_warn_dangling_reference): New.\n\t(extend_ref_init_temps): Call maybe_warn_dangling_reference.\n\t* cp-tree.h: Adjust comment.\n\t* typeck.cc (check_return_expr): Suppress -Wdangling-reference\n\twarnings.\n\ngcc/ChangeLog:\n\n\t* doc/invoke.texi: Document -Wdangling-reference.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/locale_classes.tcc: Add #pragma to disable\n\t-Wdangling-reference with std::use_facet.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp23/elision4.C: Use -Wdangling-reference, add dg-warning.\n\t* g++.dg/cpp23/elision7.C: Likewise.\n\t* g++.dg/warn/Wdangling-pointer-2.C: Use -Wno-dangling-reference.\n\t* g++.dg/warn/Wdangling-reference1.C: New test.\n\t* g++.dg/warn/Wdangling-reference2.C: New test.\n\t* g++.dg/warn/Wdangling-reference3.C: New test.", "tree": {"sha": "646929046e4c2d8962270cc50acc17c6bad9f869", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/646929046e4c2d8962270cc50acc17c6bad9f869"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2249cd9adf5ae638577139177a50f7e62d8abd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2249cd9adf5ae638577139177a50f7e62d8abd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2249cd9adf5ae638577139177a50f7e62d8abd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2249cd9adf5ae638577139177a50f7e62d8abd9/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f896c13489d22b30d01257bc8316ab97b3359d1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f896c13489d22b30d01257bc8316ab97b3359d1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f896c13489d22b30d01257bc8316ab97b3359d1c"}], "stats": {"total": 427, "additions": 409, "deletions": 18}, "files": [{"sha": "070f85c81d2646ca5d9bf8ce67b794bd6c9137f3", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -555,6 +555,10 @@ Wdangling-pointer=\n C ObjC C++ ObjC++ Joined RejectNegative UInteger Var(warn_dangling_pointer) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall, 2, 0) IntegerRange(0, 2)\n Warn for uses of pointers to auto variables whose lifetime has ended.\n \n+Wdangling-reference\n+C++ ObjC++ Var(warn_dangling_reference) Warning LangEnabledBy(C++ ObjC++, Wall)\n+Warn when a reference is bound to a temporary whose lifetime has ended.\n+\n Wdate-time\n C ObjC C++ ObjC++ CPP(warn_date_time) CppReason(CPP_W_DATE_TIME) Var(cpp_warn_date_time) Init(0) Warning\n Warn about __TIME__, __DATE__ and __TIMESTAMP__ usage."}, {"sha": "951b9fd2a88dea0aa66d73762d979c63cf65aeff", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 136, "deletions": 12, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -9313,6 +9313,16 @@ conv_binds_ref_to_prvalue (conversion *c)\n   return conv_is_prvalue (next_conversion (c));\n }\n \n+/* True iff EXPR represents a (subobject of a) temporary.  */\n+\n+static bool\n+expr_represents_temporary_p (tree expr)\n+{\n+  while (handled_component_p (expr))\n+    expr = TREE_OPERAND (expr, 0);\n+  return TREE_CODE (expr) == TARGET_EXPR;\n+}\n+\n /* True iff C is a conversion that binds a reference to a temporary.\n    This is a superset of conv_binds_ref_to_prvalue: here we're also\n    interested in xvalues.  */\n@@ -9330,18 +9340,14 @@ conv_binds_ref_to_temporary (conversion *c)\n        struct Derived : Base {};\n        const Base& b(Derived{});\n      where we bind 'b' to the Base subobject of a temporary object of type\n-     Derived.  The subobject is an xvalue; the whole object is a prvalue.  */\n-  if (c->kind != ck_base)\n-    return false;\n-  c = next_conversion (c);\n-  if (c->kind == ck_identity && c->u.expr)\n-    {\n-      tree expr = c->u.expr;\n-      while (handled_component_p (expr))\n-\texpr = TREE_OPERAND (expr, 0);\n-      if (TREE_CODE (expr) == TARGET_EXPR)\n-\treturn true;\n-    }\n+     Derived.  The subobject is an xvalue; the whole object is a prvalue.\n+\n+     The ck_base doesn't have to be present for cases like X{}.m.  */\n+  if (c->kind == ck_base)\n+    c = next_conversion (c);\n+  if (c->kind == ck_identity && c->u.expr\n+      && expr_represents_temporary_p (c->u.expr))\n+    return true;\n   return false;\n }\n \n@@ -13428,6 +13434,121 @@ initialize_reference (tree type, tree expr,\n   return expr;\n }\n \n+/* Helper for maybe_warn_dangling_reference to find a problematic CALL_EXPR\n+   that initializes the LHS (and at least one of its arguments represents\n+   a temporary, as outlined in maybe_warn_dangling_reference), or NULL_TREE\n+   if none found.  For instance:\n+\n+     const S& s = S().self(); // S::self (&TARGET_EXPR <...>)\n+     const int& r = (42, f(1)); // f(1)\n+     const int& t = b ? f(1) : f(2); // f(1)\n+     const int& u = b ? f(1) : f(g); // f(1)\n+     const int& v = b ? f(g) : f(2); // f(2)\n+     const int& w = b ? f(g) : f(g); // NULL_TREE\n+     const int& y = (f(1), 42); // NULL_TREE\n+     const int& z = f(f(1)); // f(f(1))\n+\n+   EXPR is the initializer.  */\n+\n+static tree\n+do_warn_dangling_reference (tree expr)\n+{\n+  STRIP_NOPS (expr);\n+  switch (TREE_CODE (expr))\n+    {\n+    case CALL_EXPR:\n+      {\n+\ttree fndecl = cp_get_callee_fndecl_nofold (expr);\n+\tif (!fndecl\n+\t    || warning_suppressed_p (fndecl, OPT_Wdangling_reference)\n+\t    || !warning_enabled_at (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\t\t    OPT_Wdangling_reference)\n+\t    /* If the function doesn't return a reference, don't warn.  This\n+\t       can be e.g.\n+\t\t const int& z = std::min({1, 2, 3, 4, 5, 6, 7});\n+\t       which doesn't dangle: std::min here returns an int.  */\n+\t    || !TYPE_REF_OBJ_P (TREE_TYPE (TREE_TYPE (fndecl))))\n+\t  return NULL_TREE;\n+\n+\t/* Here we're looking to see if any of the arguments is a temporary\n+\t   initializing a reference parameter.  */\n+\tfor (int i = 0; i < call_expr_nargs (expr); ++i)\n+\t  {\n+\t    tree arg = CALL_EXPR_ARG (expr, i);\n+\t    /* Check that this argument initializes a reference, except for\n+\t       the argument initializing the object of a member function.  */\n+\t    if (!DECL_NONSTATIC_MEMBER_FUNCTION_P (fndecl)\n+\t\t&& !TYPE_REF_P (TREE_TYPE (arg)))\n+\t      continue;\n+\t    /* It could also be another call taking a temporary and returning\n+\t       it and initializing this reference parameter.  */\n+\t    if (do_warn_dangling_reference (arg))\n+\t      return expr;\n+\t    STRIP_NOPS (arg);\n+\t    if (TREE_CODE (arg) == ADDR_EXPR)\n+\t      arg = TREE_OPERAND (arg, 0);\n+\t    if (expr_represents_temporary_p (arg))\n+\t      return expr;\n+\t  /* Don't warn about member function like:\n+\t      std::any a(...);\n+\t      S& s = a.emplace<S>({0}, 0);\n+\t     which constructs a new object and returns a reference to it, but\n+\t     we still want to detect:\n+\t       struct S { const S& self () { return *this; } };\n+\t       const S& s = S().self();\n+\t     where 's' dangles.  If we've gotten here, the object this function\n+\t     is invoked on is not a temporary.  */\n+\t    if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fndecl))\n+\t      break;\n+\t  }\n+\treturn NULL_TREE;\n+      }\n+    case COMPOUND_EXPR:\n+      return do_warn_dangling_reference (TREE_OPERAND (expr, 1));\n+    case COND_EXPR:\n+      if (tree t = do_warn_dangling_reference (TREE_OPERAND (expr, 1)))\n+\treturn t;\n+      return do_warn_dangling_reference (TREE_OPERAND (expr, 2));\n+    case PAREN_EXPR:\n+      return do_warn_dangling_reference (TREE_OPERAND (expr, 0));\n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+/* Implement -Wdangling-reference, to detect cases like\n+\n+     int n = 1;\n+     const int& r = std::max(n - 1, n + 1); // r is dangling\n+\n+   This creates temporaries from the arguments, returns a reference to\n+   one of the temporaries, but both temporaries are destroyed at the end\n+   of the full expression.\n+\n+   This works by checking if a reference is initialized with a function\n+   that returns a reference, and at least one parameter of the function\n+   is a reference that is bound to a temporary.  It assumes that such a\n+   function actually returns one of its arguments.\n+\n+   DECL is the reference being initialized, INIT is the initializer.  */\n+\n+static void\n+maybe_warn_dangling_reference (const_tree decl, tree init)\n+{\n+  if (!warn_dangling_reference)\n+    return;\n+  if (!TYPE_REF_P (TREE_TYPE (decl)))\n+    return;\n+  if (tree call = do_warn_dangling_reference (init))\n+    {\n+      auto_diagnostic_group d;\n+      if (warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wdangling_reference,\n+\t\t      \"possibly dangling reference to a temporary\"))\n+\tinform (EXPR_LOCATION (call), \"the temporary was destroyed at \"\n+\t\t\"the end of the full expression %qE\", call);\n+    }\n+}\n+\n /* If *P is an xvalue expression, prevent temporary lifetime extension if it\n    gets used to initialize a reference.  */\n \n@@ -13525,6 +13646,9 @@ extend_ref_init_temps (tree decl, tree init, vec<tree, va_gc> **cleanups,\n   tree type = TREE_TYPE (init);\n   if (processing_template_decl)\n     return init;\n+\n+  maybe_warn_dangling_reference (decl, init);\n+\n   if (TYPE_REF_P (type))\n     init = extend_ref_init_temps_1 (decl, init, cleanups, cond_guard);\n   else"}, {"sha": "40f5bf802c3c4a654d7a61b6a792c40a12a1083c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -459,7 +459,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n       DELETE_EXPR_USE_VEC (in DELETE_EXPR).\n-      (TREE_CALLS_NEW) (in _EXPR or _REF) (commented-out).\n       ICS_ELLIPSIS_FLAG (in _CONV)\n       DECL_INITIALIZED_P (in VAR_DECL)\n       TYPENAME_IS_CLASS_P (in TYPENAME_TYPE)\n@@ -4567,6 +4566,9 @@ get_vec_init_expr (tree t)\n    When appearing in a CONSTRUCTOR, the expression is an unconverted\n    compound literal.\n \n+   When appearing in a CALL_EXPR, it means that it is a call to\n+   a constructor.\n+\n    When appearing in a FIELD_DECL, it means that this field\n    has been duly initialized in its constructor.  */\n #define TREE_HAS_CONSTRUCTOR(NODE) (TREE_LANG_FLAG_4 (NODE))"}, {"sha": "4605f734e2d90901ed04faa54f61d150d5af5542", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -11246,6 +11246,17 @@ check_return_expr (tree retval, bool *no_warning)\n   if (processing_template_decl)\n     return saved_retval;\n \n+  /* A naive attempt to reduce the number of -Wdangling-reference false\n+     positives: if we know that this function can return a variable with\n+     static storage duration rather than one of its parameters, suppress\n+     the warning.  */\n+  if (warn_dangling_reference\n+      && TYPE_REF_P (functype)\n+      && bare_retval\n+      && VAR_P (bare_retval)\n+      && TREE_STATIC (bare_retval))\n+    suppress_warning (current_function_decl, OPT_Wdangling_reference);\n+\n   /* Actually copy the value returned into the appropriate location.  */\n   if (retval && retval != result)\n     retval = cp_build_init_expr (result, retval);"}, {"sha": "9f0e5460861b08757176bef34033a550cd88a953", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -249,7 +249,8 @@ in the following sections.\n -Wno-class-conversion  -Wclass-memaccess @gol\n -Wcomma-subscript  -Wconditionally-supported @gol\n -Wno-conversion-null  -Wctad-maybe-unsupported @gol\n--Wctor-dtor-privacy  -Wno-delete-incomplete @gol\n+-Wctor-dtor-privacy  -Wdangling-reference @gol\n+-Wno-delete-incomplete @gol\n -Wdelete-non-virtual-dtor  -Wno-deprecated-array-compare @gol\n -Wdeprecated-copy -Wdeprecated-copy-dtor @gol\n -Wno-deprecated-enum-enum-conversion -Wno-deprecated-enum-float-conversion @gol\n@@ -3627,6 +3628,54 @@ public static member functions.  Also warn if there are no non-private\n methods, and there's at least one private member function that isn't\n a constructor or destructor.\n \n+@item -Wdangling-reference @r{(C++ and Objective-C++ only)}\n+@opindex Wdangling-reference\n+@opindex Wno-dangling-reference\n+Warn when a reference is bound to a temporary whose lifetime has ended.\n+For example:\n+\n+@smallexample\n+int n = 1;\n+const int& r = std::max(n - 1, n + 1); // r is dangling\n+@end smallexample\n+\n+In the example above, two temporaries are created, one for each\n+argument, and a reference to one of the temporaries is returned.\n+However, both temporaries are destroyed at the end of the full\n+expression, so the reference @code{r} is dangling.  This warning\n+also detects dangling references in member initializer lists:\n+\n+@smallexample\n+const int& f(const int& i) @{ return i; @}\n+struct S @{\n+  const int &r; // r is dangling\n+  S() : r(f(10)) @{ @}\n+@};\n+@end smallexample\n+\n+Member functions are checked as well, but only their object argument:\n+\n+@smallexample\n+struct S @{\n+   const S& self () @{ return *this; @}\n+@};\n+const S& s = S().self(); // s is dangling\n+@end smallexample\n+\n+Certain functions are safe in this respect, for example @code{std::use_facet}:\n+they take and return a reference, but they don't return one of its arguments,\n+which can fool the warning.  Such functions can be excluded from the warning\n+by wrapping them in a @code{#pragma}:\n+\n+@smallexample\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wdangling-reference\"\n+const T& foo (const T&) @{ @dots{} @}\n+#pragma GCC diagnostic pop\n+@end smallexample\n+\n+This warning is enabled by @option{-Wall}.\n+\n @item -Wdelete-non-virtual-dtor @r{(C++ and Objective-C++ only)}\n @opindex Wdelete-non-virtual-dtor\n @opindex Wno-delete-non-virtual-dtor"}, {"sha": "d39053ad741b6908bf1b85a477f60501eb9e5eea", "filename": "gcc/testsuite/g++.dg/cpp23/elision4.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision4.C?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -1,5 +1,6 @@\n // PR c++/101165 - P2266R1 - Simpler implicit move\n // { dg-do compile { target c++23 } }\n+// { dg-options \"-Wdangling-reference\" }\n // Test from P2266R1, $ 5.2. LibreOffice OString constructor.\n \n struct X {\n@@ -33,6 +34,6 @@ T& temporary2(T&& x) { return static_cast<T&>(x); }\n void\n test ()\n {\n-  int& r1 = temporary1 (42);\n-  int& r2 = temporary2 (42);\n+  int& r1 = temporary1 (42); // { dg-warning \"dangling reference\" }\n+  int& r2 = temporary2 (42); // { dg-warning \"dangling reference\" }\n }"}, {"sha": "0045842b34fb18ecc865efd8078c0c7139f43609", "filename": "gcc/testsuite/g++.dg/cpp23/elision7.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision7.C?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -1,5 +1,6 @@\n // PR c++/101165 - P2266R1 - Simpler implicit move\n // { dg-do compile { target c++23 } }\n+// { dg-options \"-Wdangling-reference\" }\n \n struct X {\n   X ();\n@@ -68,5 +69,5 @@ f7 (T &&t)\n void\n do_f7 ()\n {\n-  const int &x = f7 (0);\n+  const int &x = f7 (0); // { dg-warning \"dangling reference\" }\n }"}, {"sha": "802ac9cd954a4a80be56c4b7a0c9799be1fb5263", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-pointer-2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-pointer-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-pointer-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-pointer-2.C?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile }\n-   { dg-options \"-O1 -Wall -Wno-class-memaccess\" } */\n+   { dg-options \"-O1 -Wall -Wno-class-memaccess -Wno-dangling-reference\" } */\n \n struct A { A (); };\n "}, {"sha": "97c81ee716c9d2ea9a01406adbf70ef7fe121f1b", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-reference1.C", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference1.C?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -0,0 +1,144 @@\n+// PR c++/106393\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wdangling-reference\" }\n+\n+const int& f(const int& i) { return i; }\n+const int& f_(const int& i) { return i; }\n+const int& h(int);\n+const int& rp(const int *);\n+int g;\n+const int& globref(const int&) { return g; }\n+struct X {\n+  int* i;\n+  operator const int&() const { return *i; }\n+};\n+X x{&g};\n+\n+const int& r1 = f(10); // { dg-warning \"dangling reference\" }\n+// r2 = _ZGR2r2_ = (int) *f ((const int &) &TARGET_EXPR <D.2429, 10>) + 1; (const int &) &_ZGR2r2_\n+const int& r2 = f(10) + 1;\n+// Don't warn here, we have\n+//   r3 = f (X::operator const int& (&x))\n+const int& r3 = f(x);\n+// Don't warn here, because we've seen the definition of globref\n+// and could figure out that it may not return one of its parms.\n+// Questionable -- it can also hide bugs --, but it helps here.\n+const int& r4 = globref(1);\n+const int& r5 = (42, f(10)); // { dg-warning \"dangling reference\" }\n+const int& r6 = (f(10), 42);\n+const int& r7 = (f(10)); // { dg-warning \"dangling reference\" }\n+const int& r8 = g ? f(10) : f(9); // { dg-warning \"dangling reference\" }\n+const int& r9 = (42, g ? f(10) : f(9)); // { dg-warning \"dangling reference\" }\n+const int& r10 = (g ? f(10) : f(9), 42);\n+// Binds to a reference temporary for r11.  No dangling reference.\n+const int& r11 = g ? f(10) : 9;\n+const int& r12 = g ? 9 : f(10);\n+// r12 = f (f ((const int &) &TARGET_EXPR <D.2459, 1>))\n+const int& r13 = f(f(1)); // { dg-warning \"dangling reference\" }\n+const int& r14 = f(f_(1)); // { dg-warning \"dangling reference\" }\n+const int& r15 = f(g ? f(1) : f(2)); // { dg-warning \"dangling reference\" }\n+const int& r16 = f(*&f(1)); // { dg-warning \"dangling reference\" }\n+const int& r17 = rp(&f(1));\n+const int& r18 = rp(&f(g));\n+const int& r19 = h(f(1));\n+// Other forms of initializers.\n+const int& r20(f(10)); // { dg-warning \"dangling reference\" }\n+const int& r21(f(10)); // { dg-warning \"dangling reference\" }\n+// Returns a ref, but doesn't have a parameter of reference type.\n+const int& r22 = h(10);\n+const int& r23 = g ? h(10) : f(10); // { dg-warning \"dangling reference\" }\n+const int& r24 = g ? f(10) : h(10); // { dg-warning \"dangling reference\" }\n+const int& r25 = g ? h(10) : (1, f(10)); // { dg-warning \"dangling reference\" }\n+const int& r26 = g ? (1, f(10)) : h(10); // { dg-warning \"dangling reference\" }\n+const int& r29 = f((f_(1), 1)); // { dg-warning \"dangling reference\" }\n+const int& r30 = f((f_(1), g));\n+\n+struct Z {\n+  operator int() { return 42; }\n+};\n+\n+const int& r27 = f(Z()); // { dg-warning \"dangling reference\" }\n+const int& r28 = f(true ? Z() : Z()); // { dg-warning \"dangling reference\" }\n+\n+const int& operator|(const int &, Z);\n+const int& r31 = 1 | Z(); // { dg-warning \"dangling reference\" }\n+\n+// OK: the reference is bound to the 10 so still valid at the point\n+// where it's copied into i1.\n+int i1 = f(10);\n+\n+int\n+test1 ()\n+{\n+  const int &lr = f(10); // { dg-warning \"dangling reference\" }\n+  int i2 = f(10);\n+  return lr;\n+}\n+\n+struct B { };\n+struct D : B { };\n+struct C {\n+  D d;\n+};\n+\n+C c;\n+D d;\n+\n+using U = D[3];\n+\n+const B& frotz(const D&);\n+const B& b1 = frotz(C{}.d); // { dg-warning \"dangling reference\" }\n+const B& b2 = frotz(D{}); // { dg-warning \"dangling reference\" }\n+const B& b3 = frotz(c.d);\n+const B& b4 = frotz(d);\n+const B& b5 = frotz(U{}[0]); // { dg-warning \"dangling reference\" }\n+\n+// Try returning a subobject.\n+const B& bar (const D& d) { return d; }\n+const B& b6 = bar (D{}); // { dg-warning \"dangling reference\" }\n+const B& baz (const C& c) { return c.d; }\n+const B& b7 = baz (C{}); // { dg-warning \"dangling reference\" }\n+const D& qux (const C& c) { return c.d; }\n+const D& d1 = qux (C{}); // { dg-warning \"dangling reference\" }\n+\n+struct E {\n+  E(int);\n+};\n+const E& operator*(const E&);\n+const E& b8 = *E(1); // { dg-warning \"dangling reference\" }\n+\n+struct F : virtual B { };\n+struct G : virtual B { };\n+struct H : F, G { };\n+const B& yum (const F& f) { return f; }\n+const B& b9 = yum (F{}); // { dg-warning \"dangling reference\" }\n+const B& lox (const H& h) { return h; }\n+const B& b10 = lox (H{}); // { dg-warning \"dangling reference\" }\n+\n+struct S {\n+  const int &r; // { dg-warning \"dangling reference\" }\n+  S() : r(f(10)) { } // { dg-message \"destroyed\" }\n+};\n+\n+// From cppreference.\n+template<class T>\n+const T& max(const T& a, const T& b)\n+{\n+    return (a < b) ? b : a;\n+}\n+\n+int n = 1;\n+const int& refmax = max(n - 1, n + 1); // { dg-warning \"dangling reference\" }\n+\n+struct Y {\n+  operator int&();\n+  operator int&&();\n+  const int& foo(const int&);\n+};\n+\n+// x1 = Y::operator int&& (&TARGET_EXPR <D.2410, {}>)\n+int&& x1 = Y(); // { dg-warning \"dangling reference\" }\n+int&& x2 = Y{}; // { dg-warning \"dangling reference\" }\n+int& x3 = Y(); // { dg-warning \"dangling reference\" }\n+int& x4 = Y{}; // { dg-warning \"dangling reference\" }\n+const int& t1 = Y().foo(10); // { dg-warning \"dangling reference\" }"}, {"sha": "dafdb43f1b931abb02ae59ff40466aa12d7fd2c0", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-reference2.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference2.C?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -0,0 +1,28 @@\n+// PR c++/106393\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wdangling-reference\" }\n+\n+namespace std {\n+struct any {};\n+template <typename _ValueType> _ValueType any_cast(any &&);\n+template <typename _Tp> struct remove_reference { using type = _Tp; };\n+template <typename _Tp> _Tp forward(typename remove_reference<_Tp>::type);\n+template <typename _Tp> typename remove_reference<_Tp>::type move(_Tp);\n+} // namespace std\n+\n+const int &r = std::any_cast<int&>(std::any()); // { dg-warning \"dangling reference\" }\n+\n+template <class T> struct C {\n+  T t_; // { dg-warning \"dangling reference\" }\n+  C(T);\n+  template <class U> C(U c) : t_(std::forward<T>(c.t_)) {}\n+};\n+struct A {};\n+struct B {\n+  B(A);\n+};\n+int main() {\n+  A a;\n+  C<A> ca(a);\n+  C<B &&>(std::move(ca));\n+}"}, {"sha": "4bc20c13b3f714efe2039747877d8c7ee1c219f6", "filename": "gcc/testsuite/g++.dg/warn/Wdangling-reference3.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdangling-reference3.C?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/106393\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"-Wdangling-reference\" }\n+\n+struct A {\n+   int ar[4];\n+   int& operator[](int i) { return ar[i]; }\n+};\n+const int &r = A()[2]; // { dg-warning \"dangling reference\" }\n+\n+struct S {\n+  const S& self () { return *this; }\n+};\n+const S& s = S().self(); // { dg-warning \"dangling reference\" }\n+\n+struct G {\n+  const G& g() { return *this; }\n+};\n+\n+struct F {\n+  G& f();\n+};\n+\n+const G& g = F().f().g(); // { dg-warning \"dangling reference\" }"}, {"sha": "9cc4f238ee768c1a36ca0f6fdabeee9eb22be519", "filename": "libstdc++-v3/include/bits/locale_classes.tcc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2249cd9adf5ae638577139177a50f7e62d8abd9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2249cd9adf5ae638577139177a50f7e62d8abd9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_classes.tcc?ref=d2249cd9adf5ae638577139177a50f7e62d8abd9", "patch": "@@ -127,6 +127,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  @return  Reference to facet of type Facet.\n    *  @throw  std::bad_cast if @p __loc doesn't contain a facet of type _Facet.\n   */\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wdangling-reference\"\n   template<typename _Facet>\n     const _Facet&\n     use_facet(const locale& __loc)\n@@ -141,6 +143,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return static_cast<const _Facet&>(*__facets[__i]);\n #endif\n     }\n+#pragma GCC diagnostic pop\n \n \n   // Generic version does nothing."}]}