{"sha": "2c826217f4703c5d4f7b5739607743f693e92842", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4MjYyMTdmNDcwM2M1ZDRmN2I1NzM5NjA3NzQzZjY5M2U5Mjg0Mg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.columbia.edu", "date": "1999-05-10T15:24:36Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1999-05-10T15:24:36Z"}, "message": "cppfiles.c (initialize_input_buffer): New function.\n\n1999-05-10 18:21 -0400  Zack Weinberg  <zack@rabi.columbia.edu>\n\t* cppfiles.c (initialize_input_buffer): New function.\n\t(finclude): Call it, if pfile->input_buffer is NULL.  Accept\n\tany character device as an input file.\n\t(read_and_prescan): Use pfile->input_buffer and\n\tpfile->input_speccase.\n\t* cppinit.c (cpp_cleanup): Free pfile->input_buffer and\n\tpfile->input_speccase.\n\t* cpplib.h (cpp_reader): Add input_buffer, input_speccase, and\n\tinput_buffer_len members.  Use memcpy in CPP_PUTS_Q.\n\t* cppmain.c: Buffer output in the token_buffer; throttle\n\tnumber of calls to fwrite; check for errors from fwrite.\n\nFrom-SVN: r26869", "tree": {"sha": "82da63a000e57cc2f3aa9bf724d12d755a4e166f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82da63a000e57cc2f3aa9bf724d12d755a4e166f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c826217f4703c5d4f7b5739607743f693e92842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c826217f4703c5d4f7b5739607743f693e92842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c826217f4703c5d4f7b5739607743f693e92842", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c826217f4703c5d4f7b5739607743f693e92842/comments", "author": null, "committer": null, "parents": [{"sha": "4338f578a7e549d521d9f8b80a8f0eaca39d1fee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4338f578a7e549d521d9f8b80a8f0eaca39d1fee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4338f578a7e549d521d9f8b80a8f0eaca39d1fee"}], "stats": {"total": 183, "additions": 128, "deletions": 55}, "files": [{"sha": "a63d7e5bd698aded5b7063a64c1eeafb29085a68", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 93, "deletions": 45, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c826217f4703c5d4f7b5739607743f693e92842/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c826217f4703c5d4f7b5739607743f693e92842/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=2c826217f4703c5d4f7b5739607743f693e92842", "patch": "@@ -45,6 +45,9 @@ static long read_and_prescan\t\tPROTO ((cpp_reader *, cpp_buffer *,\n \t\t\t\t\t\tint, size_t));\n static struct file_name_list *actual_directory PROTO ((cpp_reader *, char *));\n \n+static void initialize_input_buffer\tPROTO ((cpp_reader *, int,\n+\t\t\t\t\t\tstruct stat *));\n+\n #if 0\n static void hack_vms_include_specification PROTO ((char *));\n #endif\n@@ -648,10 +651,12 @@ finclude (pfile, fd, ihash)\n \t}\n     }\n   else if (S_ISFIFO (st.st_mode) || S_ISSOCK (st.st_mode)\n+\t   /* Permit any kind of character device: the sensible ones are\n+\t      ttys and /dev/null, but weeding out the others is too hard.  */\n+\t   || S_ISCHR (st.st_mode)\n \t   /* Some 4.x (x<4) derivatives have a bug that makes fstat() of a\n \t      socket or pipe return a stat struct with most fields zeroed.  */\n-\t   || (st.st_mode == 0 && st.st_nlink == 0 && st.st_size == 0)\n-\t   || (S_ISCHR (st.st_mode) && isatty (fd)))\n+\t   || (st.st_mode == 0 && st.st_nlink == 0 && st.st_size == 0))\n     {\n       /* Cannot get its file size before reading.  4k is a decent\n          first guess. */\n@@ -663,6 +668,9 @@ finclude (pfile, fd, ihash)\n       goto fail;\n     }\n \n+  if (pfile->input_buffer == NULL)\n+    initialize_input_buffer (pfile, fd, &st);\n+\n   /* Read the file, converting end-of-line characters and trigraphs\n      (if enabled). */\n   fp->ihash = ihash;\n@@ -758,8 +766,7 @@ actual_directory (pfile, fname)\n   return x;\n }\n \n-/* Almost but not quite the same as adjust_position in cpplib.c.\n-   Used only by read_and_prescan. */\n+/* Determine the current line and column.  Used only by read_and_prescan. */\n static void\n find_position (start, limit, linep, colp)\n      U_CHAR *start;\n@@ -804,9 +811,14 @@ find_position (start, limit, linep, colp)\n    If your file has more than one kind of end-of-line marker, you\n    will get messed-up line numbering.  */\n \n-#ifndef PIPE_BUF\n-#define PIPE_BUF 4096\n-#endif\n+/* Table of characters that can't be handled in the inner loop.\n+   Keep these contiguous to optimize the performance of the code generated\n+   for the switch that uses them.  */\n+#define SPECCASE_EMPTY     0\n+#define SPECCASE_NUL       1\n+#define SPECCASE_CR        2\n+#define SPECCASE_BACKSLASH 3\n+#define SPECCASE_QUESTION  4\n \n static long\n read_and_prescan (pfile, fp, desc, len)\n@@ -818,53 +830,32 @@ read_and_prescan (pfile, fp, desc, len)\n   U_CHAR *buf = (U_CHAR *) xmalloc (len);\n   U_CHAR *ip, *op, *line_base;\n   U_CHAR *ibase;\n+  U_CHAR *speccase = pfile->input_speccase;\n   unsigned long line;\n   unsigned int deferred_newlines;\n   int count;\n   size_t offset;\n-  /* PIPE_BUF bytes of buffer proper, 2 to detect running off the end\n-     without address arithmetic all the time, and 2 for pushback in\n-     the case there's a potential trigraph or end-of-line digraph at\n-     the end of a block. */\n-  U_CHAR intermed[PIPE_BUF + 2 + 2];\n-\n-  /* Table of characters that can't be handled in the inner loop.\n-     Keep these contiguous to optimize the performance of the code generated\n-     for the switch that uses them.  */\n-#define SPECCASE_EMPTY     0\n-#define SPECCASE_NUL       1\n-#define SPECCASE_CR        2\n-#define SPECCASE_BACKSLASH 3\n-#define SPECCASE_QUESTION  4\n-  U_CHAR speccase[256];\n \n   offset = 0;\n   op = buf;\n   line_base = buf;\n   line = 1;\n-  ibase = intermed + 2;\n+  ibase = pfile->input_buffer + 2;\n   deferred_newlines = 0;\n \n-  memset (speccase, SPECCASE_EMPTY, sizeof (speccase));\n-  speccase['\\0'] = SPECCASE_NUL;\n-  speccase['\\r'] = SPECCASE_CR;\n-  speccase['\\\\'] = SPECCASE_BACKSLASH;\n-  if (CPP_OPTIONS (pfile)->trigraphs || CPP_OPTIONS (pfile)->warn_trigraphs)\n-    speccase['?'] = SPECCASE_QUESTION;\n-\n   for (;;)\n     {\n     read_next:\n \n-      count = read (desc, intermed + 2, PIPE_BUF);\n+      count = read (desc, pfile->input_buffer + 2, pfile->input_buffer_len);\n       if (count < 0)\n \tgoto error;\n       else if (count == 0)\n \tbreak;\n \n       offset += count;\n       ip = ibase;\n-      ibase = intermed + 2;\n+      ibase = pfile->input_buffer + 2;\n       ibase[count] = ibase[count+1] = '\\0';\n \n       if (offset > len)\n@@ -924,8 +915,7 @@ read_and_prescan (pfile, fp, desc, len)\n \t\tip++;\n \t      else if (*ip == '\\0')\n \t\t{\n-\t\t  --ibase;\n-\t\t  intermed[1] = '\\r';\n+\t\t  *--ibase = '\\r';\n \t\t  goto read_next;\n \t\t}\n \t      else if (ip[-2] == '\\n')\n@@ -941,8 +931,7 @@ read_and_prescan (pfile, fp, desc, len)\n \t\t and come back next pass. */\n \t      if (*ip == '\\0')\n \t\t{\n-\t\t  --ibase;\n-\t\t  intermed[1] = '\\\\';\n+\t\t  *--ibase = '\\\\';\n \t\t  goto read_next;\n \t\t}\n \t      else if (*ip == '\\n')\n@@ -965,9 +954,8 @@ read_and_prescan (pfile, fp, desc, len)\n \t\t  if (*ip == '\\n') ip++;\n \t\t  else if (*ip == '\\0')\n \t\t    {\n-\t\t      ibase -= 2;\n-\t\t      intermed[0] = '\\\\';\n-\t\t      intermed[1] = '\\r';\n+\t\t      *--ibase = '\\r';\n+\t\t      *--ibase = '\\\\';\n \t\t      goto read_next;\n \t\t    }\n \t\t  else if (*ip == '\\r' || *ip == '\\t' || *ip == ' ')\n@@ -991,8 +979,7 @@ read_and_prescan (pfile, fp, desc, len)\n \t\td = ip[0];\n \t\tif (d == '\\0')\n \t\t  {\n-\t\t    --ibase;\n-\t\t    intermed[1] = '?';\n+\t\t    *--ibase = '?';\n \t\t    goto read_next;\n \t\t  }\n \t\tif (d != '?')\n@@ -1003,8 +990,8 @@ read_and_prescan (pfile, fp, desc, len)\n \t\td = ip[1];\n \t\tif (d == '\\0')\n \t\t  {\n-\t\t    ibase -= 2;\n-\t\t    intermed[0] = intermed[1] = '?';\n+\t\t    *--ibase = '?';\n+\t\t    *--ibase = '?';\n \t\t    goto read_next;\n \t\t  }\n \t\tif (!trigraph_table[d])\n@@ -1047,7 +1034,7 @@ read_and_prescan (pfile, fp, desc, len)\n      This may be any of:  ?? ? \\ \\r \\n \\\\r \\\\n.\n      \\r must become \\n, \\\\r or \\\\n must become \\r.\n      We know we have space already. */\n-  if (ibase == intermed)\n+  if (ibase == pfile->input_buffer)\n     {\n       if (*ibase == '?')\n \t{\n@@ -1057,7 +1044,7 @@ read_and_prescan (pfile, fp, desc, len)\n       else\n \t*op++ = '\\r';\n     }\n-  else if (ibase == intermed + 1)\n+  else if (ibase == pfile->input_buffer + 1)\n     {\n       if (*ibase == '\\r')\n \t*op++ = '\\n';\n@@ -1095,6 +1082,67 @@ read_and_prescan (pfile, fp, desc, len)\n   return -1;\n }\n \n+/* Initialize the `input_buffer' and `input_speccase' tables.\n+   These are only used by read_and_prescan, but they're large and\n+   somewhat expensive to set up, so we want them allocated once for\n+   the duration of the cpp run.  */\n+\n+static void\n+initialize_input_buffer (pfile, fd, st)\n+     cpp_reader *pfile;\n+     int fd;\n+     struct stat *st;\n+{\n+  long pipe_buf;\n+  U_CHAR *tmp;\n+\n+  /* Table of characters that cannot be handled by the\n+     read_and_prescan inner loop.  The number of non-EMPTY entries\n+     should be as small as humanly possible.  */\n+\n+  tmp = xmalloc (1 << CHAR_BIT);\n+  memset (tmp, SPECCASE_EMPTY, 1 << CHAR_BIT);\n+  tmp['\\0'] = SPECCASE_NUL;\n+  tmp['\\r'] = SPECCASE_CR;\n+  tmp['\\\\'] = SPECCASE_BACKSLASH;\n+  if (CPP_OPTIONS (pfile)->trigraphs || CPP_OPTIONS (pfile)->warn_trigraphs)\n+    tmp['?'] = SPECCASE_QUESTION;\n+\n+  pfile->input_speccase = tmp;\n+\n+  /* Determine the appropriate size for the input buffer.  Normal C\n+     source files are smaller than eight K.  If we are reading a pipe,\n+     we want to make sure the input buffer is bigger than the kernel's\n+     pipe buffer.  */\n+  pipe_buf = -1;\n+\n+  if (! S_ISREG (st->st_mode))\n+    {\n+#ifdef _PC_PIPE_BUF\n+      pipe_buf = fpathconf (fd, _PC_PIPE_BUF);\n+#endif\n+      if (pipe_buf == -1)\n+\t{\n+#ifdef PIPE_BUF\n+\t  pipe_buf = PIPE_BUF;\n+#else\n+\t  pipe_buf = 8192;\n+#endif\n+\t}\n+    }\n+\n+  if (pipe_buf < 8192)\n+    pipe_buf = 8192;\n+  /* PIPE_BUF bytes of buffer proper, 2 to detect running off the end\n+     without address arithmetic all the time, and 2 for pushback in\n+     the case there's a potential trigraph or end-of-line digraph at\n+     the end of a block. */\n+\n+  tmp = xmalloc (pipe_buf + 2 + 2);\n+  pfile->input_buffer = tmp;\n+  pfile->input_buffer_len = pipe_buf;\n+}\n+\n /* Add output to `deps_buffer' for the -M switch.\n    STRING points to the text to be output.\n    SPACER is ':' for targets, ' ' for dependencies, zero for text"}, {"sha": "f9bc306bd52fcf7101353ee849f09a80c8734224", "filename": "gcc/cppinit.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c826217f4703c5d4f7b5739607743f693e92842/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c826217f4703c5d4f7b5739607743f693e92842/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=2c826217f4703c5d4f7b5739607743f693e92842", "patch": "@@ -569,6 +569,14 @@ cpp_cleanup (pfile)\n       pfile->deps_allocated_size = 0;\n     }\n \n+  if (pfile->input_buffer)\n+    {\n+      free (pfile->input_buffer);\n+      free (pfile->input_speccase);\n+      pfile->input_buffer = pfile->input_speccase = NULL;\n+      pfile->input_buffer_len = 0;\n+    }\n+\n   while (pfile->if_stack)\n     {\n       IF_STACK_FRAME *temp = pfile->if_stack;"}, {"sha": "aadec44eb8657bd7444f0dcfc756147a901db1b4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c826217f4703c5d4f7b5739607743f693e92842/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c826217f4703c5d4f7b5739607743f693e92842/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=2c826217f4703c5d4f7b5739607743f693e92842", "patch": "@@ -241,6 +241,13 @@ struct cpp_reader\n \n   /* Number of bytes since the last newline.  */\n   int deps_column;\n+\n+  /* A buffer and a table, used only by read_and_prescan (in cppfiles.c)\n+     which are allocated once per cpp_reader object to keep them off the\n+     stack and avoid setup costs.  */\n+  U_CHAR *input_buffer;\n+  U_CHAR *input_speccase;\n+  size_t input_buffer_len;\n };\n \n #define CPP_FATAL_LIMIT 1000\n@@ -269,7 +276,7 @@ struct cpp_reader\n /* Append string STR (of length N) to PFILE's output buffer.\n    Assume there is enough space. */\n #define CPP_PUTS_Q(PFILE, STR, N) \\\n-  (bcopy (STR, (PFILE)->limit, (N)), (PFILE)->limit += (N))\n+  (memcpy ((PFILE)->limit, STR, (N)), (PFILE)->limit += (N))\n /* Append string STR (of length N) to PFILE's output buffer.  Make space. */\n #define CPP_PUTS(PFILE, STR, N) CPP_RESERVE(PFILE, N), CPP_PUTS_Q(PFILE, STR,N)\n /* Append character CH to PFILE's output buffer.  Assume sufficient space. */"}, {"sha": "0d891f809809ddb2fa03755189fcc69e9a9994e8", "filename": "gcc/cppmain.c", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c826217f4703c5d4f7b5739607743f693e92842/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c826217f4703c5d4f7b5739607743f693e92842/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=2c826217f4703c5d4f7b5739607743f693e92842", "patch": "@@ -46,6 +46,7 @@ main (argc, argv)\n   char *p;\n   int argi = 1;  /* Next argument to handle.  */\n   struct cpp_options *opts = &options;\n+  enum cpp_token kind;\n \n   p = argv[0] + strlen (argv[0]);\n   while (p != argv[0] && p[-1] != '/') --p;\n@@ -80,21 +81,30 @@ main (argc, argv)\n   else if (! freopen (opts->out_fname, \"w\", stdout))\n     cpp_pfatal_with_name (&parse_in, opts->out_fname);\n \n-  for (;;)\n+  do\n     {\n-      enum cpp_token kind;\n-      if (! opts->no_output)\n+      kind = cpp_get_token (&parse_in);\n+      if (CPP_WRITTEN (&parse_in) >= BUFSIZ || kind == CPP_EOF)\n \t{\n-\t  fwrite (parse_in.token_buffer, 1, CPP_WRITTEN (&parse_in), stdout);\n+\t  if (! opts->no_output)\n+\t    {\n+\t      size_t rem, count = CPP_WRITTEN (&parse_in);\n+\n+\t      rem = fwrite (parse_in.token_buffer, 1, count, stdout);\n+\t      if (rem < count)\n+\t\t/* Write error. */\n+\t\tcpp_pfatal_with_name (&parse_in, opts->out_fname);\n+\t    }\n+\n+\t  CPP_SET_WRITTEN (&parse_in, 0);\n \t}\n-      CPP_SET_WRITTEN (&parse_in, 0);\n-      kind = cpp_get_token (&parse_in);\n-      if (kind == CPP_EOF)\n-\tbreak;\n     }\n+  while (kind != CPP_EOF);\n \n   cpp_finish (&parse_in);\n-  fwrite (parse_in.token_buffer, 1, CPP_WRITTEN (&parse_in), stdout);\n+  if (fwrite (parse_in.token_buffer, 1, CPP_WRITTEN (&parse_in), stdout)\n+      < CPP_WRITTEN (&parse_in))\n+    cpp_pfatal_with_name (&parse_in, opts->out_fname);\n \n   if (parse_in.errors)\n     exit (FATAL_EXIT_CODE);"}]}