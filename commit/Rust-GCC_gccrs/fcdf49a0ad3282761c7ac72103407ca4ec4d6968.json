{"sha": "fcdf49a0ad3282761c7ac72103407ca4ec4d6968", "node_id": "C_kwDOANBUbNoAKGZjZGY0OWEwYWQzMjgyNzYxYzdhYzcyMTAzNDA3Y2E0ZWM0ZDY5Njg", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-15T08:56:56Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-15T12:16:57Z"}, "message": "Fix PHI ordering problems in the path solver.\n\nAfter auditing the PHI range calculations, I'm not convinced we've\ncaught all the corner cases.  They haven't shown up in the wild (yet),\nbut better safe than sorry.\n\nWe shouldn't write anything to the cache or trigger additional\nlookups while calculating a PHI, as this may cause ordering problems.\nWe should resolve the PHI with either the cache as it stands, or by\nasking for ranges on entry to the path.  I've documented this.\n\nThere was one dubious case where we called fold_range in\nssa_range_in_phi, which mostly by luck wasn't triggering lookups,\nbecause fold_range solves a PHI by calling range_on_edge, which is set\nto pick up global ranges by default in path_range_query.  This is\nfragile, so I've rewritten the call to explicitly use cached or global\nranges.\n\nAlso, the cache should be avoided in ssa_range_in_phi when the arg is\ndefined in the PHI's block, as not doing so could create an ordering\nproblem.  We have a similar check when calculating relations in PHIs.\n\nTested on x86-64 & ppc64le Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-path.cc (path_range_query::internal_range_of_expr):\n\tRemove useless code.\n\t(path_range_query::ssa_defined_in_bb): New.\n\t(path_range_query::ssa_range_in_phi): Avoid fold_range call that\n\tcould trigger additional lookups.\n\tDo not use the cache for ARGs defined in this block.\n\t(path_range_query::compute_ranges_in_block): Use ssa_defined_in_bb.\n\t(path_range_query::maybe_register_phi_relation): Same.\n\t(path_range_query::range_of_stmt): Adjust comment.\n\t* gimple-range-path.h (ssa_defined_in_bb): New.", "tree": {"sha": "6328aae9664a7f2f481be0fac5fc35371cb5061d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6328aae9664a7f2f481be0fac5fc35371cb5061d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcdf49a0ad3282761c7ac72103407ca4ec4d6968", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcdf49a0ad3282761c7ac72103407ca4ec4d6968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcdf49a0ad3282761c7ac72103407ca4ec4d6968", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcdf49a0ad3282761c7ac72103407ca4ec4d6968/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "540d92ae9b629eb40dc45a5d76b0f0d0222bf4e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/540d92ae9b629eb40dc45a5d76b0f0d0222bf4e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/540d92ae9b629eb40dc45a5d76b0f0d0222bf4e0"}], "stats": {"total": 62, "additions": 42, "deletions": 20}, "files": [{"sha": "4aa666d2c8b51474722a7e20835d27be3d49de90", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdf49a0ad3282761c7ac72103407ca4ec4d6968/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdf49a0ad3282761c7ac72103407ca4ec4d6968/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=fcdf49a0ad3282761c7ac72103407ca4ec4d6968", "patch": "@@ -202,8 +202,8 @@ path_range_query::internal_range_of_expr (irange &r, tree name, gimple *stmt)\n       return true;\n     }\n \n-  basic_block bb = stmt ? gimple_bb (stmt) : exit_bb ();\n-  if (stmt && range_defined_in_block (r, name, bb))\n+  if (stmt\n+      && range_defined_in_block (r, name, gimple_bb (stmt)))\n     {\n       if (TREE_CODE (name) == SSA_NAME)\n \tr.intersect (gimple_range_global (name));\n@@ -250,36 +250,62 @@ path_range_query::set_path (const vec<basic_block> &path)\n   bitmap_clear (m_has_cache_entry);\n }\n \n+bool\n+path_range_query::ssa_defined_in_bb (tree name, basic_block bb)\n+{\n+  return (TREE_CODE (name) == SSA_NAME\n+\t  && SSA_NAME_DEF_STMT (name)\n+\t  && gimple_bb (SSA_NAME_DEF_STMT (name)) == bb);\n+}\n+\n // Return the range of the result of PHI in R.\n+//\n+// Since PHIs are calculated in parallel at the beginning of the\n+// block, we must be careful to never save anything to the cache here.\n+// It is the caller's responsibility to adjust the cache.  Also,\n+// calculating the PHI's range must not trigger additional lookups.\n \n void\n path_range_query::ssa_range_in_phi (irange &r, gphi *phi)\n {\n   tree name = gimple_phi_result (phi);\n   basic_block bb = gimple_bb (phi);\n+  unsigned nargs = gimple_phi_num_args (phi);\n \n   if (at_entry ())\n     {\n       if (m_resolve && m_ranger->range_of_expr (r, name, phi))\n \treturn;\n \n-      // Try fold just in case we can resolve simple things like PHI <5(99), 6(88)>.\n-      if (!fold_range (r, phi, this))\n-\tr.set_varying (TREE_TYPE (name));\n-\n+      // Try to fold the phi exclusively with global or cached values.\n+      // This will get things like PHI <5(99), 6(88)>.  We do this by\n+      // calling range_of_expr with no context.\n+      int_range_max arg_range;\n+      r.set_undefined ();\n+      for (size_t i = 0; i < nargs; ++i)\n+\t{\n+\t  tree arg = gimple_phi_arg_def (phi, i);\n+\t  if (range_of_expr (arg_range, arg, /*stmt=*/NULL))\n+\t    r.union_ (arg_range);\n+\t  else\n+\t    {\n+\t      r.set_varying (TREE_TYPE (name));\n+\t      return;\n+\t    }\n+\t}\n       return;\n     }\n \n   basic_block prev = prev_bb ();\n   edge e_in = find_edge (prev, bb);\n-  unsigned nargs = gimple_phi_num_args (phi);\n \n   for (size_t i = 0; i < nargs; ++i)\n     if (e_in == gimple_phi_arg_edge (phi, i))\n       {\n \ttree arg = gimple_phi_arg_def (phi, i);\n-\n-\tif (!get_cache (r, arg))\n+\t// Avoid using the cache for ARGs defined in this block, as\n+\t// that could create an ordering problem.\n+\tif (ssa_defined_in_bb (arg, bb) || !get_cache (r, arg))\n \t  {\n \t    if (m_resolve)\n \t      {\n@@ -393,10 +419,7 @@ path_range_query::compute_ranges_in_block (basic_block bb)\n   EXECUTE_IF_SET_IN_BITMAP (m_imports, 0, i, bi)\n     {\n       tree name = ssa_name (i);\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n-      basic_block def_bb = gimple_bb (def_stmt);\n-\n-      if (def_bb == bb)\n+      if (ssa_defined_in_bb (name, bb))\n \tclear_cache (name);\n     }\n \n@@ -705,17 +728,16 @@ path_range_query::range_of_stmt (irange &r, gimple *stmt, tree)\n   if (!irange::supports_type_p (type))\n     return false;\n \n-  // If resolving unknowns, fold the statement as it would have\n-  // appeared at the end of the path.\n+  // If resolving unknowns, fold the statement making use of any\n+  // relations along the path.\n   if (m_resolve)\n     {\n       fold_using_range f;\n       jt_fur_source src (stmt, this, &m_ranger->gori (), m_path);\n       if (!f.fold_stmt (r, stmt, src))\n \tr.set_varying (type);\n     }\n-  // Otherwise, use the global ranger to fold it as it would appear in\n-  // the original IL.  This is more conservative, but faster.\n+  // Otherwise, fold without relations.\n   else if (!fold_range (r, stmt, this))\n     r.set_varying (type);\n \n@@ -727,11 +749,10 @@ path_range_query::maybe_register_phi_relation (gphi *phi, tree arg)\n {\n   basic_block bb = gimple_bb (phi);\n   tree result = gimple_phi_result (phi);\n-  gimple *def = SSA_NAME_DEF_STMT (arg);\n \n   // Avoid recording the equivalence if the arg is defined in this\n-  // block, as that would create an ordering problem.\n-  if (def && gimple_bb (def) == bb)\n+  // block, as that could create an ordering problem.\n+  if (ssa_defined_in_bb (arg, bb))\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "57a9ae9bdcd86192d180abd3fd74583330cfe1dd", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcdf49a0ad3282761c7ac72103407ca4ec4d6968/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcdf49a0ad3282761c7ac72103407ca4ec4d6968/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=fcdf49a0ad3282761c7ac72103407ca4ec4d6968", "patch": "@@ -66,6 +66,7 @@ class path_range_query : public range_query\n   void maybe_register_phi_relation (gphi *, tree arg);\n   bool add_to_imports (tree name, bitmap imports);\n   bool import_p (tree name);\n+  bool ssa_defined_in_bb (tree name, basic_block bb);\n \n   // Path navigation.\n   void set_path (const vec<basic_block> &);"}]}