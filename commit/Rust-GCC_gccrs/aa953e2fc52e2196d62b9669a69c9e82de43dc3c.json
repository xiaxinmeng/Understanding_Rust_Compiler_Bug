{"sha": "aa953e2fc52e2196d62b9669a69c9e82de43dc3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE5NTNlMmZjNTJlMjE5NmQ2MmI5NjY5YTY5YzllODJkZTQzZGMzYw==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2015-05-13T05:39:14Z"}, "committer": {"name": "Thomas Preud'homme", "email": "thopre01@gcc.gnu.org", "date": "2015-05-13T05:39:14Z"}, "message": "re PR rtl-optimization/64616 (Redundant ldr when accessing var inside and outside a loop)\n\n2015-05-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n    gcc/\n    PR rtl-optimization/64616\n    * loop-invariant.c (can_move_invariant_reg): New.\n    (move_invariant_reg): Call above new function to decide whether\n    instruction can just be moved, skipping creation of temporary\n    register.\n\n    gcc/testsuite/\n    PR rtl-optimization/64616\n    * gcc.dg/loop-8.c: New test.\n    * gcc.dg/loop-9.c: New test.\n\nFrom-SVN: r223113", "tree": {"sha": "0763b13038e3d6e66aad049afe6d0efe654fe586", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0763b13038e3d6e66aad049afe6d0efe654fe586"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa953e2fc52e2196d62b9669a69c9e82de43dc3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa953e2fc52e2196d62b9669a69c9e82de43dc3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa953e2fc52e2196d62b9669a69c9e82de43dc3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e66fc62389b36c6f544d9960dc0acf08f9c55b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e66fc62389b36c6f544d9960dc0acf08f9c55b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e66fc62389b36c6f544d9960dc0acf08f9c55b37"}], "stats": {"total": 158, "additions": 144, "deletions": 14}, "files": [{"sha": "5d03f432abfa2ae7761738af6dd881d23309f05a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa953e2fc52e2196d62b9669a69c9e82de43dc3c", "patch": "@@ -1,3 +1,11 @@\n+2015-05-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR rtl-optimization/64616\n+\t* loop-invariant.c (can_move_invariant_reg): New.\n+\t(move_invariant_reg): Call above new function to decide whether\n+\tinstruction can just be moved, skipping creation of temporary\n+\tregister.\n+\n 2015-05-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR target/pr66047.c"}, {"sha": "76a009f8c2c86d1fb1315fde8b1767192d52ee0a", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 90, "deletions": 14, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=aa953e2fc52e2196d62b9669a69c9e82de43dc3c", "patch": "@@ -1511,6 +1511,79 @@ replace_uses (struct invariant *inv, rtx reg, bool in_group)\n   return 1;\n }\n \n+/* Whether invariant INV setting REG can be moved out of LOOP, at the end of\n+   the block preceding its header.  */\n+\n+static bool\n+can_move_invariant_reg (struct loop *loop, struct invariant *inv, rtx reg)\n+{\n+  df_ref def, use;\n+  unsigned int dest_regno, defs_in_loop_count = 0;\n+  rtx_insn *insn = inv->insn;\n+  basic_block bb = BLOCK_FOR_INSN (inv->insn);\n+\n+  /* We ignore hard register and memory access for cost and complexity reasons.\n+     Hard register are few at this stage and expensive to consider as they\n+     require building a separate data flow.  Memory access would require using\n+     df_simulate_* and can_move_insns_across functions and is more complex.  */\n+  if (!REG_P (reg) || HARD_REGISTER_P (reg))\n+    return false;\n+\n+  /* Check whether the set is always executed.  We could omit this condition if\n+     we know that the register is unused outside of the loop, but it does not\n+     seem worth finding out.  */\n+  if (!inv->always_executed)\n+    return false;\n+\n+  /* Check that all uses that would be dominated by def are already dominated\n+     by it.  */\n+  dest_regno = REGNO (reg);\n+  for (use = DF_REG_USE_CHAIN (dest_regno); use; use = DF_REF_NEXT_REG (use))\n+    {\n+      rtx_insn *use_insn;\n+      basic_block use_bb;\n+\n+      use_insn = DF_REF_INSN (use);\n+      use_bb = BLOCK_FOR_INSN (use_insn);\n+\n+      /* Ignore instruction considered for moving.  */\n+      if (use_insn == insn)\n+\tcontinue;\n+\n+      /* Don't consider uses outside loop.  */\n+      if (!flow_bb_inside_loop_p (loop, use_bb))\n+\tcontinue;\n+\n+      /* Don't move if a use is not dominated by def in insn.  */\n+      if (use_bb == bb && DF_INSN_LUID (insn) >= DF_INSN_LUID (use_insn))\n+\treturn false;\n+      if (!dominated_by_p (CDI_DOMINATORS, use_bb, bb))\n+\treturn false;\n+    }\n+\n+  /* Check for other defs.  Any other def in the loop might reach a use\n+     currently reached by the def in insn.  */\n+  for (def = DF_REG_DEF_CHAIN (dest_regno); def; def = DF_REF_NEXT_REG (def))\n+    {\n+      basic_block def_bb = DF_REF_BB (def);\n+\n+      /* Defs in exit block cannot reach a use they weren't already.  */\n+      if (single_succ_p (def_bb))\n+\t{\n+\t  basic_block def_bb_succ;\n+\n+\t  def_bb_succ = single_succ (def_bb);\n+\t  if (!flow_bb_inside_loop_p (loop, def_bb_succ))\n+\t    continue;\n+\t}\n+\n+      if (++defs_in_loop_count > 1)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n /* Move invariant INVNO out of the LOOP.  Returns true if this succeeds, false\n    otherwise.  */\n \n@@ -1544,31 +1617,34 @@ move_invariant_reg (struct loop *loop, unsigned invno)\n \t    }\n \t}\n \n-      /* Move the set out of the loop.  If the set is always executed (we could\n-\t omit this condition if we know that the register is unused outside of\n-\t the loop, but it does not seem worth finding out) and it has no uses\n-\t that would not be dominated by it, we may just move it (TODO).\n-\t Otherwise we need to create a temporary register.  */\n+      /* If possible, just move the set out of the loop.  Otherwise, we\n+\t need to create a temporary register.  */\n       set = single_set (inv->insn);\n       reg = dest = SET_DEST (set);\n       if (GET_CODE (reg) == SUBREG)\n \treg = SUBREG_REG (reg);\n       if (REG_P (reg))\n \tregno = REGNO (reg);\n \n-      reg = gen_reg_rtx_and_attrs (dest);\n+      if (!can_move_invariant_reg (loop, inv, reg))\n+\t{\n+\t  reg = gen_reg_rtx_and_attrs (dest);\n \n-      /* Try replacing the destination by a new pseudoregister.  */\n-      validate_change (inv->insn, &SET_DEST (set), reg, true);\n+\t  /* Try replacing the destination by a new pseudoregister.  */\n+\t  validate_change (inv->insn, &SET_DEST (set), reg, true);\n \n-      /* As well as all the dominated uses.  */\n-      replace_uses (inv, reg, true);\n+\t  /* As well as all the dominated uses.  */\n+\t  replace_uses (inv, reg, true);\n \n-      /* And validate all the changes.  */\n-      if (!apply_change_group ())\n-\tgoto fail;\n+\t  /* And validate all the changes.  */\n+\t  if (!apply_change_group ())\n+\t    goto fail;\n \n-      emit_insn_after (gen_move_insn (dest, reg), inv->insn);\n+\t  emit_insn_after (gen_move_insn (dest, reg), inv->insn);\n+\t}\n+      else if (dump_file)\n+\tfprintf (dump_file, \"Invariant %d moved without introducing a new \"\n+\t\t\t    \"temporary register\\n\", invno);\n       reorder_insns (inv->insn, inv->insn, BB_END (preheader));\n \n       /* If there is a REG_EQUAL note on the insn we just moved, and the"}, {"sha": "0a7064872bbd6924b9b9370c8117ce113b8e372c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa953e2fc52e2196d62b9669a69c9e82de43dc3c", "patch": "@@ -1,3 +1,9 @@\n+2015-05-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\tPR rtl-optimization/64616\n+\t* gcc.dg/loop-8.c: New test.\n+\t* gcc.dg/loop-9.c: New test.\n+\n 2015-05-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR target/pr66047.c"}, {"sha": "592e54cf41742f3be493ef4f33470a24b963da6c", "filename": "gcc/testsuite/gcc.dg/loop-8.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2Ftestsuite%2Fgcc.dg%2Floop-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2Ftestsuite%2Fgcc.dg%2Floop-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-8.c?ref=aa953e2fc52e2196d62b9669a69c9e82de43dc3c", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-rtl-loop2_invariant\" } */\n+\n+void\n+f (int *a, int *b)\n+{\n+  int i;\n+\n+  for (i = 0; i < 100; i++)\n+    {\n+      int d = 42;\n+\n+      a[i] = d;\n+      if (i % 2)\n+\td = i;\n+      b[i] = d;\n+    }\n+}\n+\n+/* Load of 42 is moved out of the loop, introducing a new pseudo register.  */\n+/* { dg-final { scan-rtl-dump-times \"Decided\" 1 \"loop2_invariant\" } } */\n+/* { dg-final { scan-rtl-dump-not \"without introducing a new temporary register\" \"loop2_invariant\" } } */\n+/* { dg-final { cleanup-rtl-dump \"loop2_invariant\" } } */\n+"}, {"sha": "96412ed2d07010aa06764b7dc295dfc7183a76ed", "filename": "gcc/testsuite/gcc.dg/loop-9.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2Ftestsuite%2Fgcc.dg%2Floop-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa953e2fc52e2196d62b9669a69c9e82de43dc3c/gcc%2Ftestsuite%2Fgcc.dg%2Floop-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-9.c?ref=aa953e2fc52e2196d62b9669a69c9e82de43dc3c", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-rtl-loop2_invariant\" } */\n+\n+void\n+f (double *a)\n+{\n+  int i;\n+  for (i = 0; i < 100; i++)\n+    a[i] = 18.4242;\n+}\n+\n+/* Load of x is moved out of the loop.  */\n+/* { dg-final { scan-rtl-dump \"Decided\" \"loop2_invariant\" } } */\n+/* { dg-final { scan-rtl-dump \"without introducing a new temporary register\" \"loop2_invariant\" } } */\n+/* { dg-final { cleanup-rtl-dump \"loop2_invariant\" } } */\n+"}]}