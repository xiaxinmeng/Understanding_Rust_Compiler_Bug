{"sha": "c605a8bf92708e81d771426a87b3baddc32082dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYwNWE4YmY5MjcwOGU4MWQ3NzE0MjZhODdiM2JhZGRjMzIwODJkZA==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@orcam.me.uk", "date": "2021-04-21T21:33:25Z"}, "committer": {"name": "Maciej W. Rozycki", "email": "macro@orcam.me.uk", "date": "2021-04-27T18:02:06Z"}, "message": "VAX: Accept ASHIFT in address expressions\n\nFix regressions:\n\nFAIL: gcc.c-torture/execute/20090113-2.c   -O1  (internal compiler error)\nFAIL: gcc.c-torture/execute/20090113-2.c   -O1  (test for excess errors)\nFAIL: gcc.c-torture/execute/20090113-3.c   -O1  (internal compiler error)\nFAIL: gcc.c-torture/execute/20090113-3.c   -O1  (test for excess errors)\n\ntriggering if LRA is used rather than old reload and caused by:\n\n(plus:SI (plus:SI (mult:SI (reg:SI 30 [ _10 ])\n            (const_int 4 [0x4]))\n        (reg/f:SI 26 [ _6 ]))\n    (const_int 12 [0xc]))\n\ncoming from:\n\n(insn 58 57 59 10 (set (reg:SI 33 [ _13 ])\n        (zero_extract:SI (mem:SI (plus:SI (plus:SI (mult:SI (reg:SI 30 [ _10 ])\n                            (const_int 4 [0x4]))\n                        (reg/f:SI 26 [ _6 ]))\n                    (const_int 12 [0xc])) [4 _6->bits[_10]+0 S4 A32])\n            (reg:QI 56)\n            (reg:SI 53)))\n\".../gcc/testsuite/gcc.c-torture/execute/20090113-2.c\":64:12 490 {*extzv_non_const}\n     (expr_list:REG_DEAD (reg:QI 56)\n        (expr_list:REG_DEAD (reg:SI 53)\n            (expr_list:REG_DEAD (reg:SI 30 [ _10 ])\n                (expr_list:REG_DEAD (reg/f:SI 26 [ _6 ])\n                    (nil))))))\n\nbeing converted into:\n\n(plus:SI (plus:SI (ashift:SI (reg:SI 30 [ _10 ])\n            (const_int 2 [0x2]))\n        (reg/f:SI 26 [ _6 ]))\n    (const_int 12 [0xc]))\n\nwhich is an rtx the VAX backend currently does not recognize as a valid\nmachine address, although apparently it is only inside MEM rtx's that\nindexed addressing is supposed to be canonicalized to a MULT rather than\nASHIFT form.  Handle the ASHIFT form too throughout the backend then.\n\nThe change appears to also improve code generation with old reload and\ncode size stats are as follows, collected from 18153 executables built\nin `check-c' GCC testing:\n\n              samples average  median\n--------------------------------------\nregressions        47  0.702%  0.521%\nunchanged       17503  0.000%  0.000%\nprogressions      603 -0.920% -0.403%\n--------------------------------------\ntotal           18153 -0.029%  0.000%\n\nwith a small number of outliers (over 5% size change):\n\nold     new     change  %change filename\n----------------------------------------------------\n1885    1645    -240   -12.7320 pr53505.exe\n1331    1221    -110    -8.2644 pr89634.exe\n1553    1473    -80     -5.1513 stdatomic-vm.exe\n1413    1341    -72     -5.0955 pr45830.exe\n1415    1343    -72     -5.0883 stdatomic-vm.exe\n25765   24463   -1302   -5.0533 strlen-5.exe\n25765   24463   -1302   -5.0533 strlen-5.exe\n25765   24463   -1302   -5.0533 strlen-5.exe\n1191    1131    -60     -5.0377 20050527-1.exe\n\n(all changes on the expansion side are below 5%).\n\n\tgcc/\n\t* config/vax/vax.c (print_operand_address, vax_address_cost_1)\n\t(index_term_p): Handle ASHIFT too.", "tree": {"sha": "36db3154cf76a963eb4fc8f92247e48b8fce11f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36db3154cf76a963eb4fc8f92247e48b8fce11f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c605a8bf92708e81d771426a87b3baddc32082dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c605a8bf92708e81d771426a87b3baddc32082dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c605a8bf92708e81d771426a87b3baddc32082dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c605a8bf92708e81d771426a87b3baddc32082dd/comments", "author": null, "committer": null, "parents": [{"sha": "f3bfed3381be2e616599679b2a093b0ac8f1c5f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3bfed3381be2e616599679b2a093b0ac8f1c5f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3bfed3381be2e616599679b2a093b0ac8f1c5f7"}], "stats": {"total": 34, "additions": 21, "deletions": 13}, "files": [{"sha": "96a792593a3e2a9560ede6c44cdaf0c64d33087a", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c605a8bf92708e81d771426a87b3baddc32082dd/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c605a8bf92708e81d771426a87b3baddc32082dd/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=c605a8bf92708e81d771426a87b3baddc32082dd", "patch": "@@ -333,12 +333,12 @@ print_operand_address (FILE * file, rtx addr)\n \n     case PLUS:\n       /* There can be either two or three things added here.  One must be a\n-\t REG.  One can be either a REG or a MULT of a REG and an appropriate\n-\t constant, and the third can only be a constant or a MEM.\n+\t REG.  One can be either a REG or a MULT/ASHIFT of a REG and an\n+\t appropriate constant, and the third can only be a constant or a MEM.\n \n \t We get these two or three things and put the constant or MEM in\n-\t OFFSET, the MULT or REG in IREG, and the REG in BREG.  If we have\n-\t a register and can't tell yet if it is a base or index register,\n+\t OFFSET, the MULT/ASHIFT or REG in IREG, and the REG in BREG.  If we\n+\t have a register and can't tell yet if it is a base or index register,\n \t put it into REG1.  */\n \n       reg1 = 0; ireg = 0; breg = 0; offset = 0;\n@@ -355,12 +355,14 @@ print_operand_address (FILE * file, rtx addr)\n \t  offset = XEXP (addr, 1);\n \t  addr = XEXP (addr, 0);\n \t}\n-      else if (GET_CODE (XEXP (addr, 1)) == MULT)\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT\n+\t       || GET_CODE (XEXP (addr, 1)) == ASHIFT)\n \t{\n \t  ireg = XEXP (addr, 1);\n \t  addr = XEXP (addr, 0);\n \t}\n-      else if (GET_CODE (XEXP (addr, 0)) == MULT)\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT\n+\t       || GET_CODE (XEXP (addr, 0)) == ASHIFT)\n \t{\n \t  ireg = XEXP (addr, 0);\n \t  addr = XEXP (addr, 1);\n@@ -385,7 +387,7 @@ print_operand_address (FILE * file, rtx addr)\n \t  else\n \t    reg1 = addr;\n \t}\n-      else if (GET_CODE (addr) == MULT)\n+      else if (GET_CODE (addr) == MULT || GET_CODE (addr) == ASHIFT)\n \tireg = addr;\n       else\n \t{\n@@ -416,7 +418,8 @@ print_operand_address (FILE * file, rtx addr)\n \t    }\n \t  else\n \t    {\n-\t      gcc_assert (GET_CODE (XEXP (addr, 0)) == MULT);\n+\t      gcc_assert (GET_CODE (XEXP (addr, 0)) == MULT\n+\t\t\t  || GET_CODE (XEXP (addr, 0)) == ASHIFT);\n \t      gcc_assert (!ireg);\n \t      ireg = XEXP (addr, 0);\n \t    }\n@@ -447,7 +450,8 @@ print_operand_address (FILE * file, rtx addr)\n \t    }\n \t  else\n \t    {\n-\t      gcc_assert (GET_CODE (XEXP (addr, 1)) == MULT);\n+\t      gcc_assert (GET_CODE (XEXP (addr, 1)) == MULT\n+\t\t\t  || GET_CODE (XEXP (addr, 1)) == ASHIFT);\n \t      gcc_assert (!ireg);\n \t      ireg = XEXP (addr, 1);\n \t    }\n@@ -506,7 +510,7 @@ print_operand_address (FILE * file, rtx addr)\n \n       if (ireg != 0)\n \t{\n-\t  if (GET_CODE (ireg) == MULT)\n+\t  if (GET_CODE (ireg) == MULT || GET_CODE (ireg) == ASHIFT)\n \t    ireg = XEXP (ireg, 0);\n \t  gcc_assert (REG_P (ireg));\n \t  fprintf (file, \"[%s]\", reg_names[REGNO (ireg)]);\n@@ -707,6 +711,7 @@ vax_address_cost_1 (rtx addr)\n       reg = 1;\n       break;\n     case MULT:\n+    case ASHIFT:\n       indexed = 1;\t/* 2 on VAX 2 */\n       break;\n     case CONST_INT:\n@@ -1824,23 +1829,26 @@ static bool\n index_term_p (rtx prod, machine_mode mode, bool strict)\n {\n   rtx xfoo0, xfoo1;\n+  bool log_p;\n \n   if (GET_MODE_SIZE (mode) == 1)\n     return BASE_REGISTER_P (prod, strict);\n \n-  if (GET_CODE (prod) != MULT || GET_MODE_SIZE (mode) > 8)\n+  if ((GET_CODE (prod) != MULT && GET_CODE (prod) != ASHIFT)\n+      || GET_MODE_SIZE (mode) > 8)\n     return false;\n \n+  log_p = GET_CODE (prod) == ASHIFT;\n   xfoo0 = XEXP (prod, 0);\n   xfoo1 = XEXP (prod, 1);\n \n   if (CONST_INT_P (xfoo0)\n-      && INTVAL (xfoo0) == (int)GET_MODE_SIZE (mode)\n+      && GET_MODE_SIZE (mode) == (log_p ? 1 << INTVAL (xfoo0) : INTVAL (xfoo0))\n       && INDEX_REGISTER_P (xfoo1, strict))\n     return true;\n \n   if (CONST_INT_P (xfoo1)\n-      && INTVAL (xfoo1) == (int)GET_MODE_SIZE (mode)\n+      && GET_MODE_SIZE (mode) == (log_p ? 1 << INTVAL (xfoo1) : INTVAL (xfoo1))\n       && INDEX_REGISTER_P (xfoo0, strict))\n     return true;\n "}]}