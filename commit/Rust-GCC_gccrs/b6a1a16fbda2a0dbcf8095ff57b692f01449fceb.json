{"sha": "b6a1a16fbda2a0dbcf8095ff57b692f01449fceb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZhMWExNmZiZGEyYTBkYmNmODA5NWZmNTdiNjkyZjAxNDQ5ZmNlYg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-04-06T09:26:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:26:37Z"}, "message": "sem_ch5.adb (Analyze_Assignment): Reject a right-hand side that is a tag-indeterminate call to an abstract...\n\n2007-04-06  Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Assignment): Reject a right-hand side that is a\n\ttag-indeterminate call to an abstract function, when the left-hand side\n\tis not classwide.\n\t(Analyze_Loop_Statement): Improve detection of infinite loops\n\nFrom-SVN: r123595", "tree": {"sha": "e68a992d16170470590ecdf2f793dd94256a4d44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e68a992d16170470590ecdf2f793dd94256a4d44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6a1a16fbda2a0dbcf8095ff57b692f01449fceb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a1a16fbda2a0dbcf8095ff57b692f01449fceb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6a1a16fbda2a0dbcf8095ff57b692f01449fceb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a1a16fbda2a0dbcf8095ff57b692f01449fceb/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aab883ecd1e8d05346815ae041e7c9c9e1cb7431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab883ecd1e8d05346815ae041e7c9c9e1cb7431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aab883ecd1e8d05346815ae041e7c9c9e1cb7431"}], "stats": {"total": 219, "additions": 174, "deletions": 45}, "files": [{"sha": "d95634f27efb20f1c6a0e7b4a6f772280b64644c", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 174, "deletions": 45, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a1a16fbda2a0dbcf8095ff57b692f01449fceb/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a1a16fbda2a0dbcf8095ff57b692f01449fceb/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=b6a1a16fbda2a0dbcf8095ff57b692f01449fceb", "patch": "@@ -517,10 +517,27 @@ package body Sem_Ch5 is\n       --  Propagate the tag from a class-wide target to the rhs when the rhs\n       --  is a tag-indeterminate call.\n \n-      if Is_Class_Wide_Type (T1)\n-        and then Is_Tag_Indeterminate (Rhs)\n-      then\n-         Propagate_Tag (Lhs, Rhs);\n+      if Is_Tag_Indeterminate (Rhs) then\n+         if Is_Class_Wide_Type (T1) then\n+            Propagate_Tag (Lhs, Rhs);\n+\n+         elsif Nkind (Rhs) = N_Function_Call\n+              and then Is_Entity_Name (Name (Rhs))\n+              and then Is_Abstract_Subprogram (Entity (Name (Rhs)))\n+         then\n+            Error_Msg_N\n+              (\"call to abstract function must be dispatching\", Name (Rhs));\n+\n+         elsif Nkind (Rhs) = N_Qualified_Expression\n+           and then Nkind (Expression (Rhs)) = N_Function_Call\n+              and then Is_Entity_Name (Name (Expression (Rhs)))\n+              and then\n+                Is_Abstract_Subprogram (Entity (Name (Expression (Rhs))))\n+         then\n+            Error_Msg_N\n+              (\"call to abstract function must be dispatching\",\n+                Name (Expression (Rhs)));\n+         end if;\n       end if;\n \n       --  Ada 2005 (AI-230 and AI-385): When the lhs type is an anonymous\n@@ -1117,25 +1134,38 @@ package body Sem_Ch5 is\n       Label       : constant Node_Id := Name (N);\n       Scope_Id    : Entity_Id;\n       Label_Scope : Entity_Id;\n+      Label_Ent   : Entity_Id;\n \n    begin\n       Check_Unreachable_Code (N);\n \n       Analyze (Label);\n+      Label_Ent := Entity (Label);\n+\n+      --  Ignore previous error\n \n-      if Entity (Label) = Any_Id then\n+      if Label_Ent = Any_Id then\n          return;\n \n-      elsif Ekind (Entity (Label)) /= E_Label then\n+      --  We just have a label as the target of a goto\n+\n+      elsif Ekind (Label_Ent) /= E_Label then\n          Error_Msg_N (\"target of goto statement must be a label\", Label);\n          return;\n \n-      elsif not Reachable (Entity (Label)) then\n+      --  Check that the target of the goto is reachable according to Ada\n+      --  scoping rules. Note: the special gotos we generate for optimizing\n+      --  local handling of exceptions would violate these rules, but we mark\n+      --  such gotos as analyzed when built, so this code is never entered.\n+\n+      elsif not Reachable (Label_Ent) then\n          Error_Msg_N (\"target of goto statement is not reachable\", Label);\n          return;\n       end if;\n \n-      Label_Scope := Enclosing_Scope (Entity (Label));\n+      --  Here if goto passes initial validity checks\n+\n+      Label_Scope := Enclosing_Scope (Label_Ent);\n \n       for J in reverse 0 .. Scope_Stack.Last loop\n          Scope_Id := Scope_Stack.Table (J).Entity;\n@@ -1873,65 +1903,162 @@ package body Sem_Ch5 is\n       --  Initial conditions met, see if condition is of right form\n \n       declare\n-         Cond : constant Node_Id := Condition (Iter);\n-         Var  : Entity_Id;\n-         Loc  : Node_Id;\n+         Loc  : Node_Id := Empty;\n+         Var  : Entity_Id := Empty;\n \n-      begin\n-         --  Condition is a direct variable reference\n+         function Has_Indirection (T : Entity_Id) return Boolean;\n+         --  If the controlling variable is an access type, or is a record type\n+         --  with access components, assume that it is changed indirectly and\n+         --  suppress the warning. As a concession to low-level programming, in\n+         --  particular within Declib, we also suppress warnings on a record\n+         --  type that contains components of type Address or Short_Address.\n \n-         if Is_Entity_Name (Cond)\n-           and then not Is_Library_Level_Entity (Entity (Cond))\n-         then\n-            Loc := Cond;\n+         procedure Find_Var (N : Node_Id);\n+         --  Find whether the condition in a while-loop can be reduced to\n+         --  a test on a single variable. Recurse if condition is negation.\n \n-         --  Case of condition is a comparison with compile time known value\n+         ---------------------\n+         -- Has_Indirection --\n+         ---------------------\n \n-         elsif Nkind (Cond) in N_Op_Compare then\n-            if Is_Entity_Name (Left_Opnd (Cond))\n-              and then Compile_Time_Known_Value (Right_Opnd (Cond))\n-            then\n-               Loc := Left_Opnd (Cond);\n+         function Has_Indirection (T : Entity_Id) return Boolean is\n+            Comp : Entity_Id;\n+            Rec  : Entity_Id;\n+\n+         begin\n+            if Is_Access_Type (T) then\n+               return True;\n \n-            elsif Is_Entity_Name (Right_Opnd (Cond))\n-              and then Compile_Time_Known_Value (Left_Opnd (Cond))\n+            elsif Is_Private_Type (T)\n+              and then Present (Full_View (T))\n+              and then Is_Access_Type (Full_View (T))\n             then\n-               Loc := Right_Opnd (Cond);\n+               return True;\n+\n+            elsif Is_Record_Type (T) then\n+               Rec := T;\n \n+            elsif Is_Private_Type (T)\n+              and then Present (Full_View (T))\n+              and then Is_Record_Type (Full_View (T))\n+            then\n+               Rec := Full_View (T);\n             else\n-               return;\n+               return False;\n             end if;\n \n-         --  Case of condition is function call with one parameter\n+            Comp := First_Component (Rec);\n+            while Present (Comp) loop\n+               if Is_Access_Type (Etype (Comp))\n+                 or else Is_Descendent_Of_Address (Etype (Comp))\n+               then\n+                  return True;\n+               end if;\n \n-         elsif Nkind (Cond) = N_Function_Call then\n-            declare\n-               PA : constant List_Id := Parameter_Associations (Cond);\n-            begin\n-               if Present (PA)\n-                 and then List_Length (PA) = 1\n-                 and then Is_Entity_Name (First (PA))\n+               Next_Component (Comp);\n+            end loop;\n+\n+            return False;\n+         end Has_Indirection;\n+\n+         --------------\n+         -- Find_Var --\n+         --------------\n+\n+         procedure Find_Var (N : Node_Id) is\n+         begin\n+            --  Condition is a direct variable reference\n+\n+            if Is_Entity_Name (N)\n+              and then not Is_Library_Level_Entity (Entity (N))\n+            then\n+               Loc := N;\n+\n+            --  Case of condition is a comparison with compile time known value\n+\n+            elsif Nkind (N) in N_Op_Compare then\n+               if Is_Entity_Name (Left_Opnd (N))\n+                 and then Compile_Time_Known_Value (Right_Opnd (N))\n+               then\n+                  Loc := Left_Opnd (N);\n+\n+               elsif Is_Entity_Name (Right_Opnd (N))\n+                 and then Compile_Time_Known_Value (Left_Opnd (N))\n                then\n-                  Loc := First (PA);\n+                  Loc :=  Right_Opnd (N);\n+\n                else\n                   return;\n                end if;\n-            end;\n \n-         else\n-            return;\n-         end if;\n+            --  If condition is a negation, check whether the operand has the\n+            --  proper form.\n \n-         --  If we fall through Loc is set to the node that is an entity ref\n+            elsif Nkind (N) = N_Op_Not then\n+               Find_Var (Right_Opnd (N));\n \n-         Var := Entity (Loc);\n+            --  Case of condition is function call with one parameter\n+\n+            elsif Nkind (N) = N_Function_Call then\n+               declare\n+                  PA : constant List_Id := Parameter_Associations (N);\n+               begin\n+                  if Present (PA)\n+                    and then List_Length (PA) = 1\n+                    and then Is_Entity_Name (First (PA))\n+                  then\n+                     Loc := First (PA);\n+                  else\n+                     return;\n+                  end if;\n+               end;\n+\n+            else\n+               return;\n+            end if;\n+         end Find_Var;\n+\n+      begin\n+         Find_Var (Condition (Iter));\n+\n+         if Present (Loc) then\n+            Var := Entity (Loc);\n+         end if;\n \n          if Present (Var)\n            and then Ekind (Var) = E_Variable\n            and then not Is_Library_Level_Entity (Var)\n            and then Comes_From_Source (Var)\n          then\n-            null;\n+            if Has_Indirection (Etype (Var)) then\n+\n+               --  Assume that the designated object is modified in some\n+               --  other way, to avoid false positives.\n+\n+               return;\n+\n+            elsif Is_Volatile (Var) then\n+\n+               --  If the variable is marked as volatile, we assume that\n+               --  the condition may be affected by other tasks.\n+\n+               return;\n+\n+            elsif Nkind (Original_Node (First (Statements (N))))\n+                 = N_Delay_Relative_Statement\n+              or else Nkind (Original_Node (First (Statements (N))))\n+                 = N_Delay_Until_Statement\n+            then\n+\n+               --  Assume that this is a multitasking program, and the\n+               --  condition is affected by other threads.\n+\n+               return;\n+\n+            end if;\n+\n+         --  There no identifiable single variable in the condition\n+\n          else\n             return;\n          end if;\n@@ -1979,13 +2106,15 @@ package body Sem_Ch5 is\n                then\n                   return Abandon;\n \n-               --  Check for call to other than library level subprogram\n+               --  Calls to subprograms are OK, unless the subprogram is\n+               --  within the scope of the entity in question and could\n+               --  therefore possibly modify it\n \n                elsif Nkind (N) = N_Procedure_Call_Statement\n                  or else Nkind (N) = N_Function_Call\n                then\n                   if not Is_Entity_Name (Name (N))\n-                    or else not Is_Library_Level_Entity (Entity (Name (N)))\n+                    or else Scope_Within (Entity (Name (N)), Scope (Var))\n                   then\n                      return Abandon;\n                   end if;"}]}