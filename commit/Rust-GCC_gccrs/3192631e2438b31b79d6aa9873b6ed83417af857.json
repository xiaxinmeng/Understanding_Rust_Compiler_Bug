{"sha": "3192631e2438b31b79d6aa9873b6ed83417af857", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE5MjYzMWUyNDM4YjMxYjc5ZDZhYTk4NzNiNmVkODM0MTdhZjg1Nw==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2007-10-15T13:54:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-10-15T13:54:33Z"}, "message": "exp_attr.adb (Expand_N_Attribute_Reference): Case Access, Unchecked_Access, and Unrestricted_Access.\n\n2007-10-15  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Case Access,\n\tUnchecked_Access, and Unrestricted_Access. Cleanup code that takes\n\tcare of access to class-wide interface types plus removal of bizarre\n\tconversion of tagged object to access type (reported by Gary\n\tDismukes). After this patch there is no need to perform any\n\tadditional management on these nodes in Expand_Interface_Actuals.\n\n\t* exp_disp.adb (Expand_Interface_Actuals): Code cleanup. Remove code\n\tthat handles use of 'Access and 'Unchecked_Access applied to\n\tactuals covering interface types. Such code is now\n\tcentralized in Expand_N_Attribute_Reference.\n\nFrom-SVN: r129322", "tree": {"sha": "fb3a6d59691d6a973613b8dc96d68d7f6b924971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb3a6d59691d6a973613b8dc96d68d7f6b924971"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3192631e2438b31b79d6aa9873b6ed83417af857", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3192631e2438b31b79d6aa9873b6ed83417af857", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3192631e2438b31b79d6aa9873b6ed83417af857", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3192631e2438b31b79d6aa9873b6ed83417af857/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a8ee464537c3a5e4ec0c4e15fed38edb9cd567e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ee464537c3a5e4ec0c4e15fed38edb9cd567e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ee464537c3a5e4ec0c4e15fed38edb9cd567e6"}], "stats": {"total": 271, "additions": 132, "deletions": 139}, "files": [{"sha": "4bb8d197a5aa80e208467cb4fb28c231eb88400a", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 126, "deletions": 126, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3192631e2438b31b79d6aa9873b6ed83417af857/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3192631e2438b31b79d6aa9873b6ed83417af857/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=3192631e2438b31b79d6aa9873b6ed83417af857", "patch": "@@ -606,155 +606,155 @@ package body Exp_Attr is\n            Attribute_Unchecked_Access    |\n            Attribute_Unrestricted_Access =>\n \n-         if Is_Access_Protected_Subprogram_Type (Btyp) then\n-            Expand_Access_To_Protected_Op (N, Pref, Typ);\n+         Access_Cases : declare\n+            Btyp_DDT   : constant Entity_Id := Directly_Designated_Type (Btyp);\n+            Ref_Object : constant Node_Id := Get_Referenced_Object (Pref);\n \n-         --  If the prefix is a type name, this is a reference to the current\n-         --  instance of the type, within its initialization procedure.\n-\n-         elsif Is_Entity_Name (Pref)\n-           and then Is_Type (Entity (Pref))\n-         then\n-            declare\n-               Par    : Node_Id;\n-               Formal : Entity_Id;\n-\n-            begin\n-               --  If the current instance name denotes a task type, then the\n-               --  access attribute is rewritten to be the name of the \"_task\"\n-               --  parameter associated with the task type's task procedure.\n-               --  An unchecked conversion is applied to ensure a type match in\n-               --  cases of expander-generated calls (e.g., init procs).\n-\n-               if Is_Task_Type (Entity (Pref)) then\n-                  Formal :=\n-                    First_Entity (Get_Task_Body_Procedure (Entity (Pref)));\n-                  while Present (Formal) loop\n-                     exit when Chars (Formal) = Name_uTask;\n-                     Next_Entity (Formal);\n-                  end loop;\n-\n-                  pragma Assert (Present (Formal));\n-\n-                  Rewrite (N,\n-                    Unchecked_Convert_To (Typ,\n-                      New_Occurrence_Of (Formal, Loc)));\n-                  Set_Etype (N, Typ);\n+         begin\n+            if Is_Access_Protected_Subprogram_Type (Btyp) then\n+               Expand_Access_To_Protected_Op (N, Pref, Typ);\n \n-               --  The expression must appear in a default expression, (which\n-               --  in the initialization procedure is the right-hand side of an\n-               --  assignment), and not in a discriminant constraint.\n+            --  If prefix is a type name, this is a reference to the current\n+            --  instance of the type, within its initialization procedure.\n \n-               else\n-                  Par := Parent (N);\n-                  while Present (Par) loop\n-                     exit when Nkind (Par) = N_Assignment_Statement;\n+            elsif Is_Entity_Name (Pref)\n+              and then Is_Type (Entity (Pref))\n+            then\n+               declare\n+                  Par    : Node_Id;\n+                  Formal : Entity_Id;\n \n-                     if Nkind (Par) = N_Component_Declaration then\n-                        return;\n-                     end if;\n+               begin\n+                  --  If the current instance name denotes a task type, then\n+                  --  the access attribute is rewritten to be the name of the\n+                  --  \"_task\" parameter associated with the task type's task\n+                  --  procedure. An unchecked conversion is applied to ensure\n+                  --  a type match in cases of expander-generated calls (e.g.\n+                  --  init procs).\n+\n+                  if Is_Task_Type (Entity (Pref)) then\n+                     Formal :=\n+                       First_Entity (Get_Task_Body_Procedure (Entity (Pref)));\n+                     while Present (Formal) loop\n+                        exit when Chars (Formal) = Name_uTask;\n+                        Next_Entity (Formal);\n+                     end loop;\n \n-                     Par := Parent (Par);\n-                  end loop;\n+                     pragma Assert (Present (Formal));\n \n-                  if Present (Par) then\n                      Rewrite (N,\n-                       Make_Attribute_Reference (Loc,\n-                         Prefix => Make_Identifier (Loc, Name_uInit),\n-                         Attribute_Name  => Attribute_Name (N)));\n+                       Unchecked_Convert_To (Typ,\n+                         New_Occurrence_Of (Formal, Loc)));\n+                     Set_Etype (N, Typ);\n \n-                     Analyze_And_Resolve (N, Typ);\n-                  end if;\n-               end if;\n-            end;\n+                     --  The expression must appear in a default expression,\n+                     --  (which in the initialization procedure is the\n+                     --  right-hand side of an assignment), and not in a\n+                     --  discriminant constraint.\n \n-         --  The following handles cases involving interfaces and when the\n-         --  prefix of an access attribute is an explicit dereference. In the\n-         --  case where the access attribute is specifically Attribute_Access,\n-         --  we only do this when the context type is E_General_Access_Type,\n-         --  and not for anonymous access types. It seems that this code should\n-         --  be used for anonymous contexts as well, but that causes various\n-         --  regressions, such as on prefix-notation calls to dispatching\n-         --  operations and back-end errors on access type conversions. ???\n-\n-         elsif Id /= Attribute_Access\n-           or else Ekind (Btyp) = E_General_Access_Type\n-         then\n-            declare\n-               Ref_Object : constant Node_Id := Get_Referenced_Object (Pref);\n-               Parm_Ent   : Entity_Id;\n-               Conversion : Node_Id;\n+                  else\n+                     Par := Parent (N);\n+                     while Present (Par) loop\n+                        exit when Nkind (Par) = N_Assignment_Statement;\n \n-            begin\n-               --  If the prefix of an Access attribute is a dereference of an\n-               --  access parameter (or a renaming of such a dereference) and\n-               --  the context is a general access type (but not an anonymous\n-               --  access type), then rewrite the attribute as a conversion of\n-               --  the access parameter to the context access type. This will\n-               --  result in an accessibility check being performed, if needed.\n-\n-               --    (X.all'Access => Acc_Type (X))\n-\n-               --  Note: Limit the expansion of an attribute applied to a\n-               --  dereference of an access parameter so that it's only done\n-               --  for 'Access. This fixes a problem with 'Unrestricted_Access\n-               --  that leads to errors in the case where the attribute type\n-               --  is access-to-variable and the access parameter is\n-               --  access-to-constant. The conversion is only done to get\n-               --  accessibility checks, so it makes sense to limit it to\n-               --  'Access (and consistent with existing comment).\n-\n-               if Nkind (Ref_Object) = N_Explicit_Dereference\n-                 and then Is_Entity_Name (Prefix (Ref_Object))\n-                 and then Id = Attribute_Access\n-               then\n-                  Parm_Ent := Entity (Prefix (Ref_Object));\n+                        if Nkind (Par) = N_Component_Declaration then\n+                           return;\n+                        end if;\n \n-                  if Ekind (Parm_Ent) in Formal_Kind\n-                    and then Ekind (Etype (Parm_Ent)) = E_Anonymous_Access_Type\n-                    and then Present (Extra_Accessibility (Parm_Ent))\n-                  then\n-                     Conversion :=\n-                       Convert_To (Typ, New_Copy_Tree (Prefix (Ref_Object)));\n+                        Par := Parent (Par);\n+                     end loop;\n \n-                     Rewrite (N, Conversion);\n-                     Analyze_And_Resolve (N, Typ);\n+                     if Present (Par) then\n+                        Rewrite (N,\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix => Make_Identifier (Loc, Name_uInit),\n+                            Attribute_Name  => Attribute_Name (N)));\n \n-                     return;\n+                        Analyze_And_Resolve (N, Typ);\n+                     end if;\n                   end if;\n-               end if;\n+               end;\n \n-               --  Ada 2005 (AI-251): If the designated type is an interface,\n-               --  then rewrite the referenced object as a conversion, to force\n-               --  the displacement of the pointer to the secondary dispatch\n-               --  table.\n+            --  If the prefix of an Access attribute is a dereference of an\n+            --  access parameter (or a renaming of such a dereference) and\n+            --  the context is a general access type (but not an anonymous\n+            --  access type), then rewrite the attribute as a conversion of\n+            --  the access parameter to the context access type. This will\n+            --  result in an accessibility check being performed, if needed.\n+\n+            --    (X.all'Access => Acc_Type (X))\n+\n+            --  Note: Limit the expansion of an attribute applied to a\n+            --  dereference of an access parameter so that it's only done\n+            --  for 'Access. This fixes a problem with 'Unrestricted_Access\n+            --  that leads to errors in the case where the attribute type\n+            --  is access-to-variable and the access parameter is\n+            --  access-to-constant. The conversion is only done to get\n+            --  accessibility checks, so it makes sense to limit it to\n+            --  'Access.\n+\n+            elsif Nkind (Ref_Object) = N_Explicit_Dereference\n+              and then Is_Entity_Name (Prefix (Ref_Object))\n+              and then Ekind (Btyp) = E_General_Access_Type\n+              and then Ekind (Entity (Prefix (Ref_Object))) in Formal_Kind\n+              and then Ekind (Etype (Entity (Prefix (Ref_Object))))\n+                         = E_Anonymous_Access_Type\n+              and then Present (Extra_Accessibility\n+                                (Entity (Prefix (Ref_Object))))\n+            then\n+               Rewrite (N,\n+                 Convert_To (Typ, New_Copy_Tree (Prefix (Ref_Object))));\n+               Analyze_And_Resolve (N, Typ);\n \n-               if Is_Interface (Directly_Designated_Type (Btyp)) then\n+            --  Ada 2005 (AI-251): If the designated type is an interface we\n+            --  add an implicit conversion to force the displacement of the\n+            --  pointer to reference the secondary dispatch table.\n \n-                  --  When the object is an explicit dereference, just convert\n-                  --  the dereference's prefix.\n+            elsif Is_Interface (Btyp_DDT)\n+              and then (Comes_From_Source (N)\n+                         or else Comes_From_Source (Ref_Object)\n+                         or else (Nkind (Ref_Object) in N_Has_Chars\n+                                   and then Chars (Ref_Object) = Name_uInit))\n+            then\n+               if Nkind (Ref_Object) /= N_Explicit_Dereference then\n \n-                  if Nkind (Ref_Object) = N_Explicit_Dereference then\n-                     Conversion :=\n-                       Convert_To (Typ, New_Copy_Tree (Prefix (Ref_Object)));\n+                  --  No implicit conversion required if types match\n \n-                  --  It seems rather bizarre that we generate a conversion of\n-                  --  a tagged object to an access type, since such conversions\n-                  --  are not normally permitted, but Expand_N_Type_Conversion\n-                  --  (actually Expand_Interface_Conversion) is designed to\n-                  --  handle them in the interface case. Do we really want to\n-                  --  create such odd conversions???\n+                  if Btyp_DDT /= Etype (Ref_Object) then\n+                     Rewrite (Prefix (N),\n+                       Convert_To (Directly_Designated_Type (Typ),\n+                         New_Copy_Tree (Prefix (N))));\n \n-                  else\n-                     Conversion :=\n-                       Convert_To (Typ, New_Copy_Tree (Ref_Object));\n+                     Analyze_And_Resolve (Prefix (N),\n+                                          Directly_Designated_Type (Typ));\n                   end if;\n \n-                  Rewrite (N, Conversion);\n-                  Analyze_And_Resolve (N, Typ);\n+               --  When the object is an explicit dereference, convert the\n+               --  dereference's prefix.\n+\n+               else\n+                  declare\n+                     Obj_DDT : constant Entity_Id :=\n+                                 Base_Type\n+                                   (Directly_Designated_Type\n+                                     (Etype (Prefix (Ref_Object))));\n+                  begin\n+                     --  No implicit conversion required if designated types\n+                     --  match.\n+\n+                     if Obj_DDT /= Btyp_DDT\n+                       and then not (Is_Class_Wide_Type (Obj_DDT)\n+                                       and then Etype (Obj_DDT) = Btyp_DDT)\n+                     then\n+                        Rewrite (N,\n+                          Convert_To (Typ,\n+                            New_Copy_Tree (Prefix (Ref_Object))));\n+                        Analyze_And_Resolve (N, Typ);\n+                     end if;\n+                  end;\n                end if;\n-            end;\n-         end if;\n+            end if;\n+         end Access_Cases;\n \n       --------------\n       -- Adjacent --"}, {"sha": "20cf387d08921c854b77ddd1f5de9ab5936a9d5c", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3192631e2438b31b79d6aa9873b6ed83417af857/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3192631e2438b31b79d6aa9873b6ed83417af857/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=3192631e2438b31b79d6aa9873b6ed83417af857", "patch": "@@ -1011,7 +1011,6 @@ package body Exp_Disp is\n    ------------------------------\n \n    procedure Expand_Interface_Actuals (Call_Node : Node_Id) is\n-      Loc        : constant Source_Ptr := Sloc (Call_Node);\n       Actual     : Node_Id;\n       Actual_Dup : Node_Id;\n       Actual_Typ : Entity_Id;\n@@ -1020,7 +1019,6 @@ package body Exp_Disp is\n       Formal     : Entity_Id;\n       Formal_Typ : Entity_Id;\n       Subp       : Entity_Id;\n-      Nam        : Name_Id;\n       Formal_DDT : Entity_Id;\n       Actual_DDT : Entity_Id;\n \n@@ -1106,18 +1104,13 @@ package body Exp_Disp is\n                (Attribute_Name (Actual) = Name_Access\n                  or else Attribute_Name (Actual) = Name_Unchecked_Access)\n             then\n-               Nam := Attribute_Name (Actual);\n+               --  This case must have been handled by the analysis and\n+               --  expansion of 'Access. The only exception is when types\n+               --  match and no further expansion is required.\n \n-               Conversion := Convert_To (Formal_DDT, Prefix (Actual));\n-               Rewrite (Actual, Conversion);\n-               Analyze_And_Resolve (Actual, Formal_DDT);\n-\n-               Rewrite (Actual,\n-                 Unchecked_Convert_To (Formal_Typ,\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix => Relocate_Node (Actual),\n-                     Attribute_Name => Nam)));\n-               Analyze_And_Resolve (Actual, Formal_Typ);\n+               pragma Assert (Base_Type (Etype (Prefix (Actual)))\n+                               = Base_Type (Formal_DDT));\n+               null;\n \n             --  No need to displace the pointer if the type of the actual\n             --  coincides with the type of the formal."}]}