{"sha": "95161faf6d635df17a7792840aa73600624b11fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTUxNjFmYWY2ZDYzNWRmMTdhNzc5Mjg0MGFhNzM2MDA2MjRiMTFmYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2007-03-26T20:55:10Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2007-03-26T20:55:10Z"}, "message": "gengtype.h (struct type): Replace 'sc' with boolean, scalar_is_char.\n\n\t* gengtype.h (struct type): Replace 'sc' with boolean, scalar_is_char.\n\t(string_type): Don't declare.\n\t(do_scalar_typedef): Declare.\n\t(create_scalar_type): Update prototype.\n\t* gengtype.c (string_type): Make static.\n\t(scalar_nonchar, scalar_char): New.\n\t(do_scalar_typedef): Export.  Always use scalar_nonchar for the type.\n\t(resolve_typedef): Use scalar_nonchar for error recovery.\n\t(create_scalar_type): Remove name_len field.  Return scalar_char\n\tor scalar_nonchar as appropriate.\n\t(adjust_field_type): Look at scalar_is_char boolean to decide whether\n\tto use string_type.\n\t(throughout): Use scalar_nonchar instead of calling create_scalar_type,\n\twhenever possible.\n\t(main): Initialize scalar_char and scalar_nonchar before calling\n\tgen_rtx_next.\n\t* gengtype-lex.l: Adjust for removal of second argument to\n\tcreate_scalar_type.  Use yylval.s instead of yylval.t when\n\treturning SCALAR.\n\t* gengtype-yacc.y: Type of SCALAR is string.  Call\n\tcreate_scalar_type from type:SCALAR rule.  Adjust for removal of\n\tsecond argument to create_scalar_type.\n\nFrom-SVN: r123231", "tree": {"sha": "70749f6a010e63bca65e3197ff3b0ff5b77be848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70749f6a010e63bca65e3197ff3b0ff5b77be848"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95161faf6d635df17a7792840aa73600624b11fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95161faf6d635df17a7792840aa73600624b11fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95161faf6d635df17a7792840aa73600624b11fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95161faf6d635df17a7792840aa73600624b11fb/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a399aef3a4ddd508c25f73320646d03dfc08660", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a399aef3a4ddd508c25f73320646d03dfc08660", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a399aef3a4ddd508c25f73320646d03dfc08660"}], "stats": {"total": 119, "additions": 73, "deletions": 46}, "files": [{"sha": "5bc2cad05d881d2f7d52d1fbc82866ea43d6449a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95161faf6d635df17a7792840aa73600624b11fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95161faf6d635df17a7792840aa73600624b11fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=95161faf6d635df17a7792840aa73600624b11fb", "patch": "@@ -1,5 +1,28 @@\n 2007-03-26  Zack Weinberg  <zackw@panix.com>\n \n+\t* gengtype.h (struct type): Replace 'sc' with boolean, scalar_is_char.\n+\t(string_type): Don't declare.\n+\t(do_scalar_typedef): Declare.\n+\t(create_scalar_type): Update prototype.\n+\t* gengtype.c (string_type): Make static.\n+\t(scalar_nonchar, scalar_char): New.\n+\t(do_scalar_typedef): Export.  Always use scalar_nonchar for the type.\n+\t(resolve_typedef): Use scalar_nonchar for error recovery.\n+\t(create_scalar_type): Remove name_len field.  Return scalar_char\n+\tor scalar_nonchar as appropriate.\n+\t(adjust_field_type): Look at scalar_is_char boolean to decide whether\n+\tto use string_type.\n+\t(throughout): Use scalar_nonchar instead of calling create_scalar_type,\n+\twhenever possible.\n+\t(main): Initialize scalar_char and scalar_nonchar before calling\n+\tgen_rtx_next.\n+\t* gengtype-lex.l: Adjust for removal of second argument to\n+\tcreate_scalar_type.  Use yylval.s instead of yylval.t when\n+\treturning SCALAR.\n+\t* gengtype-yacc.y: Type of SCALAR is string.  Call\n+\tcreate_scalar_type from type:SCALAR rule.  Adjust for removal of\n+\tsecond argument to create_scalar_type.\n+\n \t* vec.h: Remove all #if IN_GENGTYPE blocks.\n \tAdd comment saying that changes may require adjustments to gengtype.\n \t* gengtype.c: Don't include coretypes.h or tm.h."}, {"sha": "1d136251e1049f01442c67dfb3aaaf37d3645e3c", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95161faf6d635df17a7792840aa73600624b11fb/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95161faf6d635df17a7792840aa73600624b11fb/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=95161faf6d635df17a7792840aa73600624b11fb", "patch": "@@ -95,7 +95,6 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n \n   char *namestart;\n   size_t namelen;\n-  struct type *t;\n   char *typestart;\n   size_t typelen;\n \n@@ -112,44 +111,41 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n        ISSPACE (typestart[typelen-1]);\n        typelen--)\n     ;\n+  typestart[typelen] = '\\0';\n \n-  t = create_scalar_type (typestart, typelen);\n-  do_typedef ((const char *) xmemdup (namestart, namelen, namelen+1), t,\n+  do_typedef ((const char *) xmemdup (namestart, namelen, namelen+1),\n+  \t      create_scalar_type (typestart),\n \t      &lexer_line);\n   update_lineno (yytext, yyleng);\n }\n \n [^[:alnum:]_]typedef{WS}{ID}{WS}{ID}{WS}\"(\" {\n   char *namestart;\n   size_t namelen;\n-  struct type *t;\n \n   for (namestart = yytext + yyleng - 2; ISSPACE (*namestart); namestart--)\n     ;\n   for (namelen = 1; !ISSPACE (namestart[-namelen]); namelen++)\n     ;\n   namestart -= namelen - 1;\n \n-  t = create_scalar_type (\"function type\", sizeof (\"function type\")-1);\n-  do_typedef ((const char *) xmemdup (namestart, namelen, namelen+1), t,\n-\t      &lexer_line);\n+  do_scalar_typedef ((const char *) xmemdup (namestart, namelen, namelen+1),\n+  \t\t     &lexer_line);\n   update_lineno (yytext, yyleng);\n }\n \n [^[:alnum:]_]typedef{WS}{ID}{WS}?\"*\"?{WS}?\"(\"{WS}?\"*\"{WS}?{ID}{WS}?\")\"{WS}?\"(\" {\n   char *namestart;\n   size_t namelen;\n-  struct type *t;\n \n   for (namestart = yytext + yyleng - 2; !ISIDNUM (*namestart); namestart--)\n     ;\n   for (namelen = 1; ISIDNUM (namestart[-namelen]); namelen++)\n     ;\n   namestart -= namelen - 1;\n \n-  t = create_scalar_type (\"function type\", sizeof (\"function type\")-1);\n-  do_typedef ((const char *) xmemdup (namestart, namelen, namelen+1), t,\n-\t      &lexer_line);\n+  do_scalar_typedef ((const char *) xmemdup (namestart, namelen, namelen+1),\n+  \t\t     &lexer_line);\n   update_lineno (yytext, yyleng);\n }\n \n@@ -270,7 +266,7 @@ ITYPE\t{IWORD}({WS}{IWORD})*\n   for (len = yyleng; ISSPACE (yytext[len-1]); len--)\n     ;\n \n-  yylval.t = create_scalar_type (yytext, len);\n+  yylval.s = (const char *) xmemdup (yytext, len, len+1);\n   update_lineno (yytext, yyleng);\n   return SCALAR;\n }"}, {"sha": "40c22efbd333dd518cf01e757a45771b25b096a4", "filename": "gcc/gengtype-yacc.y", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95161faf6d635df17a7792840aa73600624b11fb/gcc%2Fgengtype-yacc.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95161faf6d635df17a7792840aa73600624b11fb/gcc%2Fgengtype-yacc.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-yacc.y?ref=95161faf6d635df17a7792840aa73600624b11fb", "patch": "@@ -47,7 +47,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n %token NESTED_PTR\n %token <s>PARAM_IS\n %token NUM\n-%token <t>SCALAR\n+%token <s>SCALAR\n %token <s>ID\n %token <s>STRING\n %token <s>ARRAY\n@@ -158,7 +158,7 @@ bitfieldlen: NUM | ID\n \t     ;\n \n type: SCALAR\n-         { $$ = $1; }\n+         { $$ = create_scalar_type ($1); }\n       | ID\n          { $$ = resolve_typedef ($1, &lexer_line); }\n       | VEC_TOKEN '(' ID ',' ID ')'\n@@ -175,9 +175,9 @@ type: SCALAR\n       | UNION ID\n          { $$ = find_structure ($2, 1); }\n       | ENUM ID\n-         { $$ = create_scalar_type ($2, strlen ($2)); }\n+         { $$ = create_scalar_type ($2); }\n       | ENUM ID '{' enum_items '}'\n-         { $$ = create_scalar_type ($2, strlen ($2)); }\n+         { $$ = create_scalar_type ($2); }\n       ;\n \n enum_items: /* empty */"}, {"sha": "6e9383593ecf26f3f6fe2b3808fba66e300819fb", "filename": "gcc/gengtype.c", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95161faf6d635df17a7792840aa73600624b11fb/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95161faf6d635df17a7792840aa73600624b11fb/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=95161faf6d635df17a7792840aa73600624b11fb", "patch": "@@ -78,8 +78,18 @@ xasprintf (const char *format, ...)\n \n /* The one and only TYPE_STRING.  */\n \n-struct type string_type = {\n-  TYPE_STRING, NULL, NULL, GC_USED, {0}\n+static struct type string_type = {\n+  TYPE_STRING, 0, 0, GC_USED, {0}\n+};\n+\n+/* The two and only TYPE_SCALARs.  Their u.scalar_is_char flags are\n+   set to appropriate values at the beginning of main.  */\n+\n+static struct type scalar_nonchar = {\n+  TYPE_SCALAR, 0, 0, GC_USED, {0}\n+};\n+static struct type scalar_char = {\n+  TYPE_SCALAR, 0, 0, GC_USED, {0}\n };\n \n /* Lists of various things.  */\n@@ -89,7 +99,6 @@ static type_p structures;\n static type_p param_structs;\n static pair_p variables;\n \n-static void do_scalar_typedef (const char *, struct fileloc *);\n static type_p find_param_structure\n   (type_p t, type_p param[NUM_PARAM]);\n static type_p adjust_field_tree_exp (type_p t, options_p opt);\n@@ -121,12 +130,14 @@ do_typedef (const char *s, type_p t, struct fileloc *pos)\n   typedefs = p;\n }\n \n-/* Define S as a typename of a scalar.  */\n+/* Define S as a typename of a scalar.  Cannot be used to define\n+   typedefs of 'char'.  Note: is also used for pointer-to-function\n+   typedefs (which are therefore not treated as pointers).  */\n \n-static void\n+void\n do_scalar_typedef (const char *s, struct fileloc *pos)\n {\n-  do_typedef (s, create_scalar_type (s, strlen (s)), pos);\n+  do_typedef (s, &scalar_nonchar, pos);\n }\n \n /* Return the type previously defined for S.  Use POS to report errors.  */\n@@ -139,7 +150,7 @@ resolve_typedef (const char *s, struct fileloc *pos)\n     if (strcmp (p->name, s) == 0)\n       return p->type;\n   error_at_line (pos, \"unidentified type `%s'\", s);\n-  return create_scalar_type (\"char\", 4);\n+  return &scalar_nonchar;  /* treat as \"int\" */\n }\n \n /* Create and return a new structure with tag NAME (or a union iff\n@@ -269,12 +280,12 @@ find_param_structure (type_p t, type_p param[NUM_PARAM])\n /* Return a scalar type with name NAME.  */\n \n type_p\n-create_scalar_type (const char *name, size_t name_len)\n+create_scalar_type (const char *name)\n {\n-  type_p r = XCNEW (struct type);\n-  r->kind = TYPE_SCALAR;\n-  r->u.sc = (char *) xmemdup (name, name_len, name_len + 1);\n-  return r;\n+  if (!strcmp (name, \"char\") || !strcmp (name, \"unsigned char\"))\n+    return &scalar_char;\n+  else\n+    return &scalar_nonchar;\n }\n \n /* Return a pointer to T.  */\n@@ -499,7 +510,7 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n   bitmap_tp = create_pointer (find_structure (\"bitmap_element_def\", 0));\n   basic_block_tp = create_pointer (find_structure (\"basic_block_def\", 0));\n   constant_tp = create_pointer (find_structure (\"constant_descriptor_rtx\", 0));\n-  scalar_tp = create_scalar_type (\"rtunion scalar\", 14);\n+  scalar_tp = &scalar_nonchar;  /* rtunion int */\n \n   {\n     pair_p note_flds = NULL;\n@@ -796,13 +807,11 @@ adjust_field_type (type_p t, options_p opt)\n   if (! length_p\n       && pointer_p\n       && t->u.p->kind == TYPE_SCALAR\n-      && (strcmp (t->u.p->u.sc, \"char\") == 0\n-\t  || strcmp (t->u.p->u.sc, \"unsigned char\") == 0))\n+      && t->u.p->u.scalar_is_char)\n     return &string_type;\n   if (t->kind == TYPE_ARRAY && t->u.a.p->kind == TYPE_POINTER\n       && t->u.a.p->u.p->kind == TYPE_SCALAR\n-      && (strcmp (t->u.a.p->u.p->u.sc, \"char\") == 0\n-\t  || strcmp (t->u.a.p->u.p->u.sc, \"unsigned char\") == 0))\n+      && t->u.a.p->u.p->u.scalar_is_char)\n     return create_array (&string_type, t->u.a.len);\n \n   return t;\n@@ -3015,7 +3024,7 @@ note_def_vec (const char *typename, bool is_scalar, struct fileloc *pos)\n \n   if (is_scalar)\n     {\n-      t = create_scalar_type (typename, strlen (typename));\n+      t = create_scalar_type (typename);\n       o = 0;\n     }\n   else\n@@ -3034,15 +3043,15 @@ note_def_vec (const char *typename, bool is_scalar, struct fileloc *pos)\n   fields = f;\n \n   f = XNEW (struct pair);\n-  f->type = adjust_field_type (create_scalar_type (\"unsigned\", 8), 0);\n+  f->type = adjust_field_type (create_scalar_type (\"unsigned\"), 0);\n   f->name = \"alloc\";\n   f->opt = 0;\n   f->line = *pos;\n   f->next = fields;\n   fields = f;\n \n   f = XNEW (struct pair);\n-  f->type = adjust_field_type (create_scalar_type (\"unsigned\", 8), 0);\n+  f->type = adjust_field_type (create_scalar_type (\"unsigned\"), 0);\n   f->name = \"num\";\n   f->opt = 0;\n   f->line = *pos;\n@@ -3083,10 +3092,13 @@ main (int ARG_UNUSED (argc), char ** ARG_UNUSED (argv))\n   static struct fileloc pos = { __FILE__, __LINE__ };\n   unsigned j;\n \n-  gen_rtx_next ();\n-\n   srcdir_len = strlen (srcdir);\n \n+  scalar_char.u.scalar_is_char = true;\n+  scalar_nonchar.u.scalar_is_char = false;\n+\n+  gen_rtx_next ();\n+\n   do_scalar_typedef (\"CUMULATIVE_ARGS\", &pos);\n   do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos);\n   do_scalar_typedef (\"double_int\", &pos);\n@@ -3101,9 +3113,7 @@ main (int ARG_UNUSED (argc), char ** ARG_UNUSED (argv))\n \n   do_typedef (\"PTR\", create_pointer (resolve_typedef (\"void\", &pos)), &pos);\n \n-  do_typedef (\"HARD_REG_SET\", create_array (\n-\t      create_scalar_type (\"unsigned long\", strlen (\"unsigned long\")),\n-\t      \"2\"), &pos);\n+  do_typedef (\"HARD_REG_SET\", create_array (&scalar_nonchar, \"2\"), &pos);\n \n   for (i = 0; i < NUM_GT_FILES; i++)\n     {"}, {"sha": "1ee9d3acffb93ebc29fae6a42477b91905522321", "filename": "gcc/gengtype.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95161faf6d635df17a7792840aa73600624b11fb/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95161faf6d635df17a7792840aa73600624b11fb/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=95161faf6d635df17a7792840aa73600624b11fb", "patch": "@@ -90,7 +90,7 @@ struct type {\n       lang_bitmap bitmap;\n       type_p lang_struct;\n     } s;\n-    char *sc;\n+    bool scalar_is_char;\n     struct {\n       type_p p;\n       const char *len;\n@@ -112,9 +112,6 @@ struct type {\n   || (x)->kind == TYPE_STRUCT \t\t\t\\\n   || (x)->kind == TYPE_LANG_STRUCT)\n \n-/* The one and only TYPE_STRING.  */\n-extern struct type string_type;\n-\n /* Variables used to communicate between the lexer and the parser.  */\n extern int lexer_toplevel_done;\n extern struct fileloc lexer_line;\n@@ -132,12 +129,13 @@ extern char * xasprintf (const char *, ...)\n \n /* Constructor routines for types.  */\n extern void do_typedef (const char *s, type_p t, struct fileloc *pos);\n+extern void do_scalar_typedef (const char *s, struct fileloc *pos);\n extern type_p resolve_typedef (const char *s, struct fileloc *pos);\n extern type_p new_structure (const char *name, int isunion,\n \t\t\t     struct fileloc *pos, pair_p fields,\n \t\t\t     options_p o);\n extern type_p find_structure (const char *s, int isunion);\n-extern type_p create_scalar_type (const char *name, size_t name_len);\n+extern type_p create_scalar_type (const char *name);\n extern type_p create_pointer (type_p t);\n extern type_p create_array (type_p t, const char *len);\n extern options_p create_option (options_p, const char *name, const void *info);"}]}