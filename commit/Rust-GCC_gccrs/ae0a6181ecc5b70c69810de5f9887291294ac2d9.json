{"sha": "ae0a6181ecc5b70c69810de5f9887291294ac2d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUwYTYxODFlY2M1YjcwYzY5ODEwZGU1Zjk4ODcyOTEyOTRhYzJkOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-05-19T15:15:22Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-19T15:15:22Z"}, "message": "decl.c (saveable_obstack): Declare.\n\n\t* decl.c (saveable_obstack): Declare.\n\t(pushdecl): Copy TYPE_DECLs to the same obstack as the type they\n\tdeclare, if necessary.\n\nFrom-SVN: r19882", "tree": {"sha": "c4ebe4e769e50541db7cd4df4e5cb06b128f43a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4ebe4e769e50541db7cd4df4e5cb06b128f43a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae0a6181ecc5b70c69810de5f9887291294ac2d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae0a6181ecc5b70c69810de5f9887291294ac2d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae0a6181ecc5b70c69810de5f9887291294ac2d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae0a6181ecc5b70c69810de5f9887291294ac2d9/comments", "author": null, "committer": null, "parents": [{"sha": "79edd21c9de35e7269dc1f9346cbc799e380563a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79edd21c9de35e7269dc1f9346cbc799e380563a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79edd21c9de35e7269dc1f9346cbc799e380563a"}], "stats": {"total": 48, "additions": 48, "deletions": 0}, "files": [{"sha": "63ed57b87f74f3037620375e50d348433dba6888", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae0a6181ecc5b70c69810de5f9887291294ac2d9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae0a6181ecc5b70c69810de5f9887291294ac2d9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ae0a6181ecc5b70c69810de5f9887291294ac2d9", "patch": "@@ -1,3 +1,9 @@\n+Tue May 19 15:13:39 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* decl.c (saveable_obstack): Declare.\n+\t(pushdecl): Copy TYPE_DECLs to the same obstack as the type they\n+\tdeclare, if necessary.\n+\n Tue May 19 14:50:27 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* call.c (compare_qual): Remove."}, {"sha": "b6b2f66fef93f32c76838ed8215887a744bc5c39", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae0a6181ecc5b70c69810de5f9887291294ac2d9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae0a6181ecc5b70c69810de5f9887291294ac2d9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ae0a6181ecc5b70c69810de5f9887291294ac2d9", "patch": "@@ -48,6 +48,7 @@ Boston, MA 02111-1307, USA.  */\n extern tree builtin_return_address_fndecl;\n \n extern struct obstack permanent_obstack;\n+extern struct obstack* saveable_obstack;\n \n extern int current_class_depth;\n \n@@ -3368,11 +3369,52 @@ pushdecl (x)\n             }\n           else if (type != error_mark_node && TYPE_NAME (type) != x)\n             {\n+\t      push_obstacks (TYPE_OBSTACK (type), TYPE_OBSTACK (type));\n+\n+\t      if (!TREE_PERMANENT (x) \n+\t\t  && TYPE_OBSTACK (type) != saveable_obstack)\n+\t\t{\n+\t\t  /* X should have been allocated on the saveable\n+\t\t     obstack.  Since the type was not, the type may\n+\t\t     outlive X, unless we make a copy of X.  Here are\n+\t\t     some examples:\n+\t\t     \n+\t\t     template <class T>\n+\t\t     void f()\n+\t\t     {\n+\t\t       typedef S<T> Type_t;\n+\t\t       Type_t::foo();\n+\t\t     }\n+\t\t     \n+\t\t     Here, we will create a SCOPE_REF with Type_t as\n+\t\t     its first argument, and save the SCOPE_REF for\n+\t\t     later, so that we can tsubst into it.  But, that\n+\t\t     means we need to save the TYPE_DECL for Type_t.\n+\t\t     \n+\t\t     But, we must save the TYPE_DECL even when not\n+\t\t     processing_template_decl.  For example,\n+\t\t     \n+\t\t     void f() \n+\t\t     {\n+\t\t       typedef int I;\n+\t\t       g<I>();\n+\t\t     }\n+\t\t     \n+\t\t     may create a declaration of g with `I' as one of\n+\t\t     the arguments.  In the old days, we used to use\n+\t\t     the underlying types for things, but now we try\n+\t\t     to use the typedef names for readability.  */\n+\t\t  x = copy_node (x);\n+\t\t  copy_lang_decl (x);\n+\t\t}\n+\n \t      DECL_ORIGINAL_TYPE (x) = type;\n               type = build_type_copy (type);\n \t      TYPE_STUB_DECL (type) = TYPE_STUB_DECL (DECL_ORIGINAL_TYPE (x));\n               TYPE_NAME (type) = x;\n               TREE_TYPE (x) = type;\n+\n+\t      pop_obstacks ();\n             }\n \n \t  if (type != error_mark_node"}]}