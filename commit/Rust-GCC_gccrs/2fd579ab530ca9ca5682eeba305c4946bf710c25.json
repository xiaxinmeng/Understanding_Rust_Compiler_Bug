{"sha": "2fd579ab530ca9ca5682eeba305c4946bf710c25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZkNTc5YWI1MzBjYTljYTU2ODJlZWJhMzA1YzQ5NDZiZjcxMGMyNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-04-11T07:30:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-04-11T07:30:59Z"}, "message": "re PR tree-optimization/90018 (r265453 miscompiled 527.cam4_r in SPEC CPU 2017)\n\n2019-04-11  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/90018\n\t* tree-vect-data-refs.c (vect_preserves_scalar_order_p):\n\tTest both SLP and interleaving variants.\n\n\t* gcc.dg/vect/pr90018.c: New testcase.\n\nFrom-SVN: r270273", "tree": {"sha": "c0a759263425c5222f9e84e09139d9cc3d576ddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0a759263425c5222f9e84e09139d9cc3d576ddd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fd579ab530ca9ca5682eeba305c4946bf710c25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd579ab530ca9ca5682eeba305c4946bf710c25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fd579ab530ca9ca5682eeba305c4946bf710c25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd579ab530ca9ca5682eeba305c4946bf710c25/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "375a6bc674794fc8cb53ff703a636e84dd6df9be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/375a6bc674794fc8cb53ff703a636e84dd6df9be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/375a6bc674794fc8cb53ff703a636e84dd6df9be"}], "stats": {"total": 127, "additions": 112, "deletions": 15}, "files": [{"sha": "f1ed98e6f66999313a70279604f3b3aadc90ed02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd579ab530ca9ca5682eeba305c4946bf710c25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd579ab530ca9ca5682eeba305c4946bf710c25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fd579ab530ca9ca5682eeba305c4946bf710c25", "patch": "@@ -1,3 +1,9 @@\n+2019-04-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/90018\n+\t* tree-vect-data-refs.c (vect_preserves_scalar_order_p):\n+\tTest both SLP and interleaving variants.\n+\n 2019-04-11  Robin Dapp  <rdapp@linux.ibm.com>\n \n \t* config/s390/8561.md: New file."}, {"sha": "2443e443215a6a6bb1c6b6cc74c1f6f46b3edfc5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd579ab530ca9ca5682eeba305c4946bf710c25/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd579ab530ca9ca5682eeba305c4946bf710c25/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2fd579ab530ca9ca5682eeba305c4946bf710c25", "patch": "@@ -1,3 +1,8 @@\n+2019-04-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/90018\n+\t* gcc.dg/vect/pr90018.c: New testcase.\n+\n 2018-04-10  Steve Ellcey  <sellcey@marvell.com>\n \n \tPR rtl-optimization/87763"}, {"sha": "d98b4c86c069182b5a0fd0623cd3de0add609fc0", "filename": "gcc/testsuite/gcc.dg/vect/pr90018.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd579ab530ca9ca5682eeba305c4946bf710c25/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr90018.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd579ab530ca9ca5682eeba305c4946bf710c25/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr90018.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr90018.c?ref=2fd579ab530ca9ca5682eeba305c4946bf710c25", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_double } */\n+\n+#include \"tree-vect.h\"\n+\n+void __attribute__((noinline,noclone))\n+foo (double *a4, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      /* We may not apply interleaving to the group (a), (b) because of (c).\n+         Instead group (d) and (b).  */\n+      double tem1 = a4[i*4] + a4[i*4+n*4] /* (a) */;\n+      double tem2 = a4[i*4+2*n*4+1];\n+      a4[i*4+n*4+1] = tem1; /* (c) */\n+      a4[i*4+1] = tem2;\n+      double tem3 = a4[i*4] - tem2;\n+      double tem4 = tem3 + a4[i*4+n*4] /* (d) */;\n+      a4[i*4+n*4+1] = tem4 + a4[i*4+n*4+1] /* (b) */;\n+    }\n+}\n+int main(int argc, char **argv)\n+{\n+  int n = 11;\n+  double a4[4 * n * 3];\n+  double a42[4 * n * 3];\n+  check_vect ();\n+  for (int i = 0; i < 4 * n * 3; ++i)\n+    {\n+      a4[i] = a42[i] = i;\n+      __asm__ volatile (\"\": : : \"memory\");\n+    }\n+  foo (a4, n);\n+  for (int i = 0; i < n; ++i)\n+    {\n+      double tem1 = a42[i*4] + a42[i*4+n*4];\n+      double tem2 = a42[i*4+2*n*4+1];\n+      a42[i*4+n*4+1] = tem1;\n+      a42[i*4+1] = tem2;\n+      double tem3 = a42[i*4] - tem2;\n+      double tem4 = tem3 + a42[i*4+n*4];\n+      a42[i*4+n*4+1] = tem4 + a42[i*4+n*4+1];\n+      __asm__ volatile (\"\": : : \"memory\");\n+    }\n+  for (int i = 0; i < 4 * n * 3; ++i)\n+    if (a4[i] != a42[i])\n+      __builtin_abort ();\n+  return 0;\n+}\n+\n+/* For v2df we try to use SLP and fail miserably.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_sizes_32B_16B } } } */"}, {"sha": "d71a39ffd78be9838d9f0d9f3c98389edf3e7a40", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fd579ab530ca9ca5682eeba305c4946bf710c25/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fd579ab530ca9ca5682eeba305c4946bf710c25/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=2fd579ab530ca9ca5682eeba305c4946bf710c25", "patch": "@@ -234,26 +234,60 @@ vect_preserves_scalar_order_p (dr_vec_info *dr_info_a, dr_vec_info *dr_info_b)\n     return true;\n \n   /* STMT_A and STMT_B belong to overlapping groups.  All loads in a\n-     group are emitted at the position of the last scalar load and all\n-     stores in a group are emitted at the position of the last scalar store.\n+     SLP group are emitted at the position of the last scalar load and\n+     all loads in an interleaving group are emitted at the position\n+     of the first scalar load.\n+     Stores in a group are emitted at the position of the last scalar store.\n      Compute that position and check whether the resulting order matches\n-     the current one.  */\n-  stmt_vec_info last_a = DR_GROUP_FIRST_ELEMENT (stmtinfo_a);\n+     the current one.\n+     We have not yet decided between SLP and interleaving so we have\n+     to conservatively assume both.  */\n+  stmt_vec_info il_a;\n+  stmt_vec_info last_a = il_a = DR_GROUP_FIRST_ELEMENT (stmtinfo_a);\n   if (last_a)\n-    for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (last_a); s;\n-\t s = DR_GROUP_NEXT_ELEMENT (s))\n-      last_a = get_later_stmt (last_a, s);\n+    {\n+      for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (last_a); s;\n+\t   s = DR_GROUP_NEXT_ELEMENT (s))\n+\tlast_a = get_later_stmt (last_a, s);\n+      if (!DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_a)))\n+\t{\n+\t  for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (il_a); s;\n+\t       s = DR_GROUP_NEXT_ELEMENT (s))\n+\t    if (get_later_stmt (il_a, s) == il_a)\n+\t      il_a = s;\n+\t}\n+      else\n+\til_a = last_a;\n+    }\n   else\n-    last_a = stmtinfo_a;\n-  stmt_vec_info last_b = DR_GROUP_FIRST_ELEMENT (stmtinfo_b);\n+    last_a = il_a = stmtinfo_a;\n+  stmt_vec_info il_b;\n+  stmt_vec_info last_b = il_b = DR_GROUP_FIRST_ELEMENT (stmtinfo_b);\n   if (last_b)\n-    for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (last_b); s;\n-\t s = DR_GROUP_NEXT_ELEMENT (s))\n-      last_b = get_later_stmt (last_b, s);\n+    {\n+      for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (last_b); s;\n+\t   s = DR_GROUP_NEXT_ELEMENT (s))\n+\tlast_b = get_later_stmt (last_b, s);\n+      if (!DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_b)))\n+\t{\n+\t  for (stmt_vec_info s = DR_GROUP_NEXT_ELEMENT (il_b); s;\n+\t       s = DR_GROUP_NEXT_ELEMENT (s))\n+\t    if (get_later_stmt (il_b, s) == il_b)\n+\t      il_b = s;\n+\t}\n+      else\n+\til_b = last_b;\n+    }\n   else\n-    last_b = stmtinfo_b;\n-  return ((get_later_stmt (last_a, last_b) == last_a)\n-\t  == (get_later_stmt (stmtinfo_a, stmtinfo_b) == stmtinfo_a));\n+    last_b = il_b = stmtinfo_b;\n+  bool a_after_b = (get_later_stmt (stmtinfo_a, stmtinfo_b) == stmtinfo_a);\n+  return (/* SLP */\n+\t  (get_later_stmt (last_a, last_b) == last_a) == a_after_b\n+\t  /* Interleaving */\n+\t  && (get_later_stmt (il_a, il_b) == il_a) == a_after_b\n+\t  /* Mixed */\n+\t  && (get_later_stmt (il_a, last_b) == il_a) == a_after_b\n+\t  && (get_later_stmt (last_a, il_b) == last_a) == a_after_b);\n }\n \n /* A subroutine of vect_analyze_data_ref_dependence.  Handle"}]}