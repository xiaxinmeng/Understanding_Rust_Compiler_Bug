{"sha": "dcdd0f055731a8c960a15e5de8715d041d9a7876", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNkZDBmMDU1NzMxYThjOTYwYTE1ZTVkZTg3MTVkMDQxZDlhNzg3Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:47:39Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:47:39Z"}, "message": "[AArch64] Make more use of function_abi\n\nThis patch makes more use of the function_abi infrastructure.\nWe can then avoid checking specifically for the vector PCS in\na few places, and can test it more directly otherwise.\n\nSpecifically: we no longer need to call df_set_regs_ever_live\nfor the extra call-saved registers, since IRA now does that for us.\nWe also don't need to handle the vector PCS specially in\naarch64_epilogue_uses, because DF now marks the registers\nas live on exit.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_layout_frame): Use crtl->abi\n\tto test whether we're compiling a vector PCS function and to test\n\twhether the function needs to save a particular register.\n\tRemove the vector PCS handling of df_set_regs_ever_live.\n\t(aarch64_components_for_bb): Use crtl->abi to test whether\n\tthe function needs to save a particular register.\n\t(aarch64_process_components): Use crtl->abi to test whether\n\twe're compiling a vector PCS function.\n\t(aarch64_expand_prologue, aarch64_expand_epilogue): Likewise.\n\t(aarch64_epilogue_uses): Remove handling of vector PCS functions.\n\nFrom-SVN: r276341", "tree": {"sha": "5dcc47b1d3b1582a7550d764ca7e32f6334b5bbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dcc47b1d3b1582a7550d764ca7e32f6334b5bbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcdd0f055731a8c960a15e5de8715d041d9a7876", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcdd0f055731a8c960a15e5de8715d041d9a7876", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcdd0f055731a8c960a15e5de8715d041d9a7876", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcdd0f055731a8c960a15e5de8715d041d9a7876/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ce9d2a37f2db20328286f5d3d5a13a4e765c59f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce9d2a37f2db20328286f5d3d5a13a4e765c59f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce9d2a37f2db20328286f5d3d5a13a4e765c59f7"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "c3f77270629f1d00d00b0a1410a9e06f8f8a991f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcdd0f055731a8c960a15e5de8715d041d9a7876/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcdd0f055731a8c960a15e5de8715d041d9a7876/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dcdd0f055731a8c960a15e5de8715d041d9a7876", "patch": "@@ -1,3 +1,16 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_layout_frame): Use crtl->abi\n+\tto test whether we're compiling a vector PCS function and to test\n+\twhether the function needs to save a particular register.\n+\tRemove the vector PCS handling of df_set_regs_ever_live.\n+\t(aarch64_components_for_bb): Use crtl->abi to test whether\n+\tthe function needs to save a particular register.\n+\t(aarch64_process_components): Use crtl->abi to test whether\n+\twe're compiling a vector PCS function.\n+\t(aarch64_expand_prologue, aarch64_expand_epilogue): Likewise.\n+\t(aarch64_epilogue_uses): Remove handling of vector PCS functions.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (aarch64_use_simple_return_insn_p):"}, {"sha": "ec180c8bd4f850b101b08d96efedb2c5e53b1f93", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcdd0f055731a8c960a15e5de8715d041d9a7876/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcdd0f055731a8c960a15e5de8715d041d9a7876/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=dcdd0f055731a8c960a15e5de8715d041d9a7876", "patch": "@@ -5334,7 +5334,7 @@ aarch64_layout_frame (void)\n {\n   HOST_WIDE_INT offset = 0;\n   int regno, last_fp_reg = INVALID_REGNUM;\n-  bool simd_function = aarch64_simd_decl_p (cfun->decl);\n+  bool simd_function = (crtl->abi->id () == ARM_PCS_SIMD);\n \n   cfun->machine->frame.emit_frame_chain = aarch64_needs_frame_chain ();\n \n@@ -5348,17 +5348,6 @@ aarch64_layout_frame (void)\n   cfun->machine->frame.wb_candidate1 = INVALID_REGNUM;\n   cfun->machine->frame.wb_candidate2 = INVALID_REGNUM;\n \n-  /* If this is a non-leaf simd function with calls we assume that\n-     at least one of those calls is to a non-simd function and thus\n-     we must save V8 to V23 in the prologue.  */\n-\n-  if (simd_function && !crtl->is_leaf)\n-    {\n-      for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n-\tif (FP_SIMD_SAVED_REGNUM_P (regno))\n- \t  df_set_regs_ever_live (regno, true);\n-    }\n-\n   /* First mark all the registers that really need to be saved...  */\n   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n     cfun->machine->frame.reg_offset[regno] = SLOT_NOT_REQUIRED;\n@@ -5375,14 +5364,15 @@ aarch64_layout_frame (void)\n   /* ... and any callee saved register that dataflow says is live.  */\n   for (regno = R0_REGNUM; regno <= R30_REGNUM; regno++)\n     if (df_regs_ever_live_p (regno)\n+\t&& !fixed_regs[regno]\n \t&& (regno == R30_REGNUM\n-\t    || !call_used_or_fixed_reg_p (regno)))\n+\t    || !crtl->abi->clobbers_full_reg_p (regno)))\n       cfun->machine->frame.reg_offset[regno] = SLOT_REQUIRED;\n \n   for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n     if (df_regs_ever_live_p (regno)\n-\t&& (!call_used_or_fixed_reg_p (regno)\n-\t    || (simd_function && FP_SIMD_SAVED_REGNUM_P (regno))))\n+\t&& !fixed_regs[regno]\n+\t&& !crtl->abi->clobbers_full_reg_p (regno))\n       {\n \tcfun->machine->frame.reg_offset[regno] = SLOT_REQUIRED;\n \tlast_fp_reg = regno;\n@@ -5971,7 +5961,6 @@ aarch64_components_for_bb (basic_block bb)\n   bitmap in = DF_LIVE_IN (bb);\n   bitmap gen = &DF_LIVE_BB_INFO (bb)->gen;\n   bitmap kill = &DF_LIVE_BB_INFO (bb)->kill;\n-  bool simd_function = aarch64_simd_decl_p (cfun->decl);\n \n   sbitmap components = sbitmap_alloc (LAST_SAVED_REGNUM + 1);\n   bitmap_clear (components);\n@@ -5994,8 +5983,8 @@ aarch64_components_for_bb (basic_block bb)\n \n   /* GPRs are used in a bb if they are in the IN, GEN, or KILL sets.  */\n   for (unsigned regno = 0; regno <= LAST_SAVED_REGNUM; regno++)\n-    if ((!call_used_or_fixed_reg_p (regno)\n-\t|| (simd_function && FP_SIMD_SAVED_REGNUM_P (regno)))\n+    if (!fixed_regs[regno]\n+\t&& !crtl->abi->clobbers_full_reg_p (regno)\n \t&& (TEST_HARD_REG_BIT (extra_caller_saves, regno)\n \t    || bitmap_bit_p (in, regno)\n \t    || bitmap_bit_p (gen, regno)\n@@ -6100,7 +6089,7 @@ aarch64_process_components (sbitmap components, bool prologue_p)\n \t mergeable with the current one into a pair.  */\n       if (!satisfies_constraint_Ump (mem)\n \t  || GP_REGNUM_P (regno) != GP_REGNUM_P (regno2)\n-\t  || (aarch64_simd_decl_p (cfun->decl) && FP_REGNUM_P (regno))\n+\t  || (crtl->abi->id () == ARM_PCS_SIMD && FP_REGNUM_P (regno))\n \t  || maybe_ne ((offset2 - cfun->machine->frame.reg_offset[regno]),\n \t\t       GET_MODE_SIZE (mode)))\n \t{\n@@ -6432,8 +6421,6 @@ aarch64_epilogue_uses (int regno)\n     {\n       if (regno == LR_REGNUM)\n \treturn 1;\n-      if (aarch64_simd_decl_p (cfun->decl) && FP_SIMD_SAVED_REGNUM_P (regno))\n-\treturn 1;\n     }\n   return 0;\n }\n@@ -6634,7 +6621,7 @@ aarch64_expand_prologue (void)\n \n   aarch64_save_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n \t\t\t     callee_adjust != 0 || emit_frame_chain);\n-  if (aarch64_simd_decl_p (cfun->decl))\n+  if (crtl->abi->id () == ARM_PCS_SIMD)\n     aarch64_save_callee_saves (TFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n \t\t\t       callee_adjust != 0 || emit_frame_chain);\n   else\n@@ -6733,7 +6720,7 @@ aarch64_expand_epilogue (bool for_sibcall)\n \n   aarch64_restore_callee_saves (DImode, callee_offset, R0_REGNUM, R30_REGNUM,\n \t\t\t\tcallee_adjust != 0, &cfi_ops);\n-  if (aarch64_simd_decl_p (cfun->decl))\n+  if (crtl->abi->id () == ARM_PCS_SIMD)\n     aarch64_restore_callee_saves (TFmode, callee_offset, V0_REGNUM, V31_REGNUM,\n \t\t\t\t  callee_adjust != 0, &cfi_ops);\n   else"}]}