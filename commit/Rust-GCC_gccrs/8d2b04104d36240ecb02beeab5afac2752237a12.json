{"sha": "8d2b04104d36240ecb02beeab5afac2752237a12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyYjA0MTA0ZDM2MjQwZWNiMDJiZWVhYjVhZmFjMjc1MjIzN2ExMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-08-11T14:28:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-08-11T14:28:36Z"}, "message": "re PR middle-end/50040 (missed warning: \u2018x.y\u2019 is used uninitialized in this function)\n\n2011-08-11  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/50040\n\t* gimplify.c (gimplify_modify_expr_complex_part): Mark the\n\tload of the other piece with TREE_NO_WARNING.\n\t* tree-flow.h (warn_uninit): Adjust prototype.\n\t* tree-ssa.c (warn_uninit): Take uninitialized SSA name,\n\tthe base variable and the expression that is used separately.\n\tProperly query all TREE_NO_WARNING flags.\n\t(struct walk_data): Remove.\n\t(warn_uninitialized_var): Likewise.\n\t(warn_uninitialized_vars): Do not walk gimple pieces but simply\n\tlook at all SSA uses of the statement.  Handle unused memory\n\tseparately.\n\t* tree-ssa-uninit.c (warn_uninitialized_phi): Adjust.\n\n\t* g++.dg/warn/unit-1.C: Un-XFAIL.\n\t* gcc.dg/uninit-I.c: Likewise.\n\nFrom-SVN: r177667", "tree": {"sha": "b10a9fb84133c6a18ce3929ae02f730bf26e7935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b10a9fb84133c6a18ce3929ae02f730bf26e7935"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d2b04104d36240ecb02beeab5afac2752237a12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2b04104d36240ecb02beeab5afac2752237a12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2b04104d36240ecb02beeab5afac2752237a12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2b04104d36240ecb02beeab5afac2752237a12/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f8de043406d8d477133894e84124f8ac4ad8c64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f8de043406d8d477133894e84124f8ac4ad8c64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f8de043406d8d477133894e84124f8ac4ad8c64"}], "stats": {"total": 220, "additions": 96, "deletions": 124}, "files": [{"sha": "711452a073ce7085f6914d7e4d8e08d86c2ce6e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d2b04104d36240ecb02beeab5afac2752237a12", "patch": "@@ -1,3 +1,19 @@\n+2011-08-11  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/50040\n+\t* gimplify.c (gimplify_modify_expr_complex_part): Mark the\n+\tload of the other piece with TREE_NO_WARNING.\n+\t* tree-flow.h (warn_uninit): Adjust prototype.\n+\t* tree-ssa.c (warn_uninit): Take uninitialized SSA name,\n+\tthe base variable and the expression that is used separately.\n+\tProperly query all TREE_NO_WARNING flags.\n+\t(struct walk_data): Remove.\n+\t(warn_uninitialized_var): Likewise.\n+\t(warn_uninitialized_vars): Do not walk gimple pieces but simply\n+\tlook at all SSA uses of the statement.  Handle unused memory\n+\tseparately.\n+\t* tree-ssa-uninit.c (warn_uninitialized_phi): Adjust.\n+\n 2011-08-11   Kazuhiro Inaoka  <kazuhiro.inaoka.ud@renesas.com>\n \n \t* config/rx/rx.md (movsicc): Allow register to register"}, {"sha": "2668aa6e0328b53ad2ddfec0f7ae6a20e9ac789d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=8d2b04104d36240ecb02beeab5afac2752237a12", "patch": "@@ -4483,6 +4483,7 @@ gimplify_modify_expr_complex_part (tree *expr_p, gimple_seq *pre_p,\n \n   ocode = code == REALPART_EXPR ? IMAGPART_EXPR : REALPART_EXPR;\n   other = build1 (ocode, TREE_TYPE (rhs), lhs);\n+  TREE_NO_WARNING (other) = 1;\n   other = get_formal_tmp_var (other, pre_p);\n \n   realpart = code == REALPART_EXPR ? rhs : other;"}, {"sha": "18f5f6b6aaaf69a668443d13b74178d99b7258f2", "filename": "gcc/testsuite/g++.dg/warn/unit-1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funit-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funit-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Funit-1.C?ref=8d2b04104d36240ecb02beeab5afac2752237a12", "patch": "@@ -4,7 +4,7 @@\n struct a { int mode; };\n int sys_msgctl (void)\n {\n-  struct a setbuf;  /* { dg-warning \"'setbuf.mode' is used\" \"\" { xfail *-*-* } } */\n-  return setbuf.mode;\n+  struct a setbuf;\n+  return setbuf.mode;  /* { dg-warning \"'setbuf.a::mode' is used\" \"\" } */\n }\n "}, {"sha": "3f80d961c1422cd9a648fc61afb6b7052d624277", "filename": "gcc/testsuite/gcc.dg/uninit-I.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-I.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-I.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-I.c?ref=8d2b04104d36240ecb02beeab5afac2752237a12", "patch": "@@ -3,6 +3,6 @@\n \n int sys_msgctl (void)\n {\n-  struct { int mode; } setbuf;  /* { dg-warning \"'setbuf\\.mode' is used\" \"\" { xfail *-*-* } } */\n-  return setbuf.mode;\n+  struct { int mode; } setbuf;\n+  return setbuf.mode;  /* { dg-warning \"'setbuf\\.mode' is used\" \"\" } */\n }"}, {"sha": "28c0d8aabbc121e6a31675a4baff73773e394d01", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=8d2b04104d36240ecb02beeab5afac2752237a12", "patch": "@@ -542,7 +542,7 @@ extern void flush_pending_stmts (edge);\n extern void verify_ssa (bool);\n extern void delete_tree_ssa (void);\n extern bool ssa_undefined_value_p (tree);\n-extern void warn_uninit (enum opt_code, tree, const char *, void *);\n+extern void warn_uninit (enum opt_code, tree, tree, tree, const char *, void *);\n extern unsigned int warn_uninitialized_vars (bool);\n extern void execute_update_addresses_taken (void);\n "}, {"sha": "f1ec31527c28f804be9345e0d860fba1d70e5115", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=8d2b04104d36240ecb02beeab5afac2752237a12", "patch": "@@ -1953,7 +1953,8 @@ warn_uninitialized_phi (gimple phi, VEC(gimple, heap) **worklist,\n     return;\n \n   uninit_op = gimple_phi_arg_def (phi, MASK_FIRST_SET_BIT (uninit_opnds));\n-  warn_uninit (OPT_Wmaybe_uninitialized, uninit_op,\n+  warn_uninit (OPT_Wmaybe_uninitialized, uninit_op, SSA_NAME_VAR (uninit_op),\n+\t       SSA_NAME_VAR (uninit_op),\n                \"%qD may be used uninitialized in this function\",\n                uninit_use_stmt);\n "}, {"sha": "980716944ff501ef0bcbd2bc39291ab5dde51052", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 72, "deletions": 118, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2b04104d36240ecb02beeab5afac2752237a12/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=8d2b04104d36240ecb02beeab5afac2752237a12", "patch": "@@ -1652,14 +1652,15 @@ walk_use_def_chains (tree var, walk_use_def_chains_fn fn, void *data,\n    again for plain uninitialized variables, since optimization may have\n    changed conditionally uninitialized to unconditionally uninitialized.  */\n \n-/* Emit a warning for T, an SSA_NAME, being uninitialized.  The exact\n+/* Emit a warning for EXPR based on variable VAR at the point in the\n+   program T, an SSA_NAME, is used being uninitialized.  The exact\n    warning text is in MSGID and LOCUS may contain a location or be null.\n    WC is the warning code.  */\n \n void\n-warn_uninit (enum opt_code wc, tree t, const char *gmsgid, void *data)\n+warn_uninit (enum opt_code wc, tree t,\n+\t     tree expr, tree var, const char *gmsgid, void *data)\n {\n-  tree var = SSA_NAME_VAR (t);\n   gimple context = (gimple) data;\n   location_t location;\n   expanded_location xloc, floc;\n@@ -1669,21 +1670,21 @@ warn_uninit (enum opt_code wc, tree t, const char *gmsgid, void *data)\n \n   /* TREE_NO_WARNING either means we already warned, or the front end\n      wishes to suppress the warning.  */\n-  if (TREE_NO_WARNING (var))\n-    return;\n-\n-  /* Do not warn if it can be initialized outside this module.  */\n-  if (is_global_var (var))\n+  if ((context\n+       && (gimple_no_warning_p (context)\n+\t   || (gimple_assign_single_p (context)\n+\t       && TREE_NO_WARNING (gimple_assign_rhs1 (context)))))\n+      || TREE_NO_WARNING (expr))\n     return;\n \n   location = (context != NULL && gimple_has_location (context))\n \t     ? gimple_location (context)\n \t     : DECL_SOURCE_LOCATION (var);\n   xloc = expand_location (location);\n   floc = expand_location (DECL_SOURCE_LOCATION (cfun->decl));\n-  if (warning_at (location, wc, gmsgid, var))\n+  if (warning_at (location, wc, gmsgid, expr))\n     {\n-      TREE_NO_WARNING (var) = 1;\n+      TREE_NO_WARNING (expr) = 1;\n \n       if (location == DECL_SOURCE_LOCATION (var))\n \treturn;\n@@ -1694,126 +1695,79 @@ warn_uninit (enum opt_code wc, tree t, const char *gmsgid, void *data)\n     }\n }\n \n-struct walk_data {\n-  gimple stmt;\n-  bool always_executed;\n-  bool warn_possibly_uninitialized;\n-};\n-\n-/* Called via walk_tree, look for SSA_NAMEs that have empty definitions\n-   and warn about them.  */\n-\n-static tree\n-warn_uninitialized_var (tree *tp, int *walk_subtrees, void *data_)\n-{\n-  struct walk_stmt_info *wi = (struct walk_stmt_info *) data_;\n-  struct walk_data *data = (struct walk_data *) wi->info;\n-  tree t = *tp;\n-\n-  /* We do not care about LHS.  */\n-  if (wi->is_lhs)\n-    {\n-      /* Except for operands of dereferences.  */\n-      if (!INDIRECT_REF_P (t)\n-\t  && TREE_CODE (t) != MEM_REF)\n-\treturn NULL_TREE;\n-      t = TREE_OPERAND (t, 0);\n-    }\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case ADDR_EXPR:\n-      /* Taking the address of an uninitialized variable does not\n-\t count as using it.  */\n-      *walk_subtrees = 0;\n-      break;\n-\n-    case VAR_DECL:\n-      {\n-\t/* A VAR_DECL in the RHS of a gimple statement may mean that\n-\t   this variable is loaded from memory.  */\n-\tuse_operand_p vuse;\n-\ttree op;\n-\n-\t/* If there is not gimple stmt,\n-\t   or alias information has not been computed,\n-\t   then we cannot check VUSE ops.  */\n-\tif (data->stmt == NULL)\n-\t  return NULL_TREE;\n-\n-\t/* If the load happens as part of a call do not warn about it.  */\n-\tif (is_gimple_call (data->stmt))\n-\t  return NULL_TREE;\n-\n-\tvuse = gimple_vuse_op (data->stmt);\n-\tif (vuse == NULL_USE_OPERAND_P)\n-\t  return NULL_TREE;\n-\n-\top = USE_FROM_PTR (vuse);\n-\tif (t != SSA_NAME_VAR (op)\n-\t    || !SSA_NAME_IS_DEFAULT_DEF (op))\n-\t  return NULL_TREE;\n-\t/* If this is a VUSE of t and it is the default definition,\n-\t   then warn about op.  */\n-\tt = op;\n-\t/* Fall through into SSA_NAME.  */\n-      }\n-\n-    case SSA_NAME:\n-      /* We only do data flow with SSA_NAMEs, so that's all we\n-\t can warn about.  */\n-      if (data->always_executed)\n-        warn_uninit (OPT_Wuninitialized,\n-\t             t, \"%qD is used uninitialized in this function\",\n-\t\t     data->stmt);\n-      else if (data->warn_possibly_uninitialized)\n-        warn_uninit (OPT_Wuninitialized,\n-\t             t, \"%qD may be used uninitialized in this function\",\n-\t\t     data->stmt);\n-      *walk_subtrees = 0;\n-      break;\n-\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-      /* The total store transformation performed during gimplification\n-\t creates uninitialized variable uses.  If all is well, these will\n-\t be optimized away, so don't warn now.  */\n-      if (TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME)\n-\t*walk_subtrees = 0;\n-      break;\n-\n-    default:\n-      if (IS_TYPE_OR_DECL_P (t))\n-\t*walk_subtrees = 0;\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n unsigned int\n warn_uninitialized_vars (bool warn_possibly_uninitialized)\n {\n   gimple_stmt_iterator gsi;\n   basic_block bb;\n-  struct walk_data data;\n-\n-  data.warn_possibly_uninitialized = warn_possibly_uninitialized;\n-\n \n   FOR_EACH_BB (bb)\n     {\n-      data.always_executed = dominated_by_p (CDI_POST_DOMINATORS,\n+      bool always_executed = dominated_by_p (CDI_POST_DOMINATORS,\n \t\t\t\t\t     single_succ (ENTRY_BLOCK_PTR), bb);\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  struct walk_stmt_info wi;\n-\t  data.stmt = gsi_stmt (gsi);\n-\t  if (is_gimple_debug (data.stmt))\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  use_operand_p use_p;\n+\t  ssa_op_iter op_iter;\n+\t  tree use;\n+\n+\t  if (is_gimple_debug (stmt))\n \t    continue;\n-\t  memset (&wi, 0, sizeof (wi));\n-\t  wi.info = &data;\n-\t  walk_gimple_op (gsi_stmt (gsi), warn_uninitialized_var, &wi);\n+\n+\t  /* We only do data flow with SSA_NAMEs, so that's all we\n+\t     can warn about.  */\n+\t  FOR_EACH_SSA_USE_OPERAND (use_p, stmt, op_iter, SSA_OP_USE)\n+\t    {\n+\t      use = USE_FROM_PTR (use_p);\n+\t      if (always_executed)\n+\t\twarn_uninit (OPT_Wuninitialized, use,\n+\t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n+\t\t\t     \"%qD is used uninitialized in this function\",\n+\t\t\t     stmt);\n+\t      else if (warn_possibly_uninitialized)\n+\t\twarn_uninit (OPT_Wuninitialized, use,\n+\t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n+\t\t\t     \"%qD may be used uninitialized in this function\",\n+\t\t\t     stmt);\n+\t    }\n+\n+\t  /* For memory the only cheap thing we can do is see if we\n+\t     have a use of the default def of the virtual operand.\n+\t     ???  Note that at -O0 we do not have virtual operands.\n+\t     ???  Not so cheap would be to use the alias oracle via\n+\t     walk_aliased_vdefs, if we don't find any aliasing vdef\n+\t     warn as is-used-uninitialized, if we don't find an aliasing\n+\t     vdef that kills our use (stmt_kills_ref_p), warn as\n+\t     may-be-used-uninitialized.  But this walk is quadratic and\n+\t     so must be limited which means we would miss warning\n+\t     opportunities.  */\n+\t  use = gimple_vuse (stmt);\n+\t  if (use\n+\t      && gimple_assign_single_p (stmt)\n+\t      && !gimple_vdef (stmt)\n+\t      && SSA_NAME_IS_DEFAULT_DEF (use))\n+\t    {\n+\t      tree rhs = gimple_assign_rhs1 (stmt);\n+\t      tree base = get_base_address (rhs);\n+\n+\t      /* Do not warn if it can be initialized outside this function.  */\n+\t      if (TREE_CODE (base) != VAR_DECL\n+\t\t  || DECL_HARD_REGISTER (base)\n+\t\t  || is_global_var (base))\n+\t\tcontinue;\n+\n+\t      if (always_executed)\n+\t\twarn_uninit (OPT_Wuninitialized, use, gimple_assign_rhs1 (stmt),\n+\t\t\t     base,\n+\t\t\t     \"%qE is used uninitialized in this function\",\n+\t\t\t     stmt);\n+\t      else if (warn_possibly_uninitialized)\n+\t\twarn_uninit (OPT_Wuninitialized, use, gimple_assign_rhs1 (stmt),\n+\t\t\t     base,\n+\t\t\t     \"%qE may be used uninitialized in this function\",\n+\t\t\t     stmt);\n+\t    }\n \t}\n     }\n "}]}