{"sha": "47a6f66054936affc847afa61eed3d245381e58b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdhNmY2NjA1NDkzNmFmZmM4NDdhZmE2MWVlZDNkMjQ1MzgxZTU4Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-04T10:27:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-04T10:27:59Z"}, "message": "[multiple changes]\n\n2015-03-04  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb (Is_ARECnF_Entity): New flag (ARECnF is an extra formal).\n\t(Next_Formal): Don't return ARECnF formal.\n\t(Last_Formal): Don't consider ARECnF formal.\n\t(Next_Formal_With_Extras): Do consider ARECnF formal.\n\t* einfo.ads (Is_ARECnF_Entity): New flag (ARECnF is an extra formal).\n\t* exp_unst.adb (Create_Entities): Set Is_ARECnF_Entity flag.\n\n2015-03-04  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch6.adb (Expand_Simple_Function_Return): When the returned\n\tobject is a class-wide interface object and we generate the\n\taccessibility described in RM 6.5(8/3) then displace the pointer\n\tto the object to reference the base of the object (to get access\n\tto the TSD of the object).\n\nFrom-SVN: r221182", "tree": {"sha": "92a577a1c315481ff12ed533a235c47020eb282c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92a577a1c315481ff12ed533a235c47020eb282c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47a6f66054936affc847afa61eed3d245381e58b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a6f66054936affc847afa61eed3d245381e58b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a6f66054936affc847afa61eed3d245381e58b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a6f66054936affc847afa61eed3d245381e58b/comments", "author": null, "committer": null, "parents": [{"sha": "550671691ee841093b72631af3b4bcf7dbad68d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/550671691ee841093b72631af3b4bcf7dbad68d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/550671691ee841093b72631af3b4bcf7dbad68d6"}], "stats": {"total": 159, "additions": 138, "deletions": 21}, "files": [{"sha": "386ae314f26ef09b44342fcf0bf5439ee1579ccf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=47a6f66054936affc847afa61eed3d245381e58b", "patch": "@@ -1,3 +1,20 @@\n+2015-03-04  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb (Is_ARECnF_Entity): New flag (ARECnF is an extra formal).\n+\t(Next_Formal): Don't return ARECnF formal.\n+\t(Last_Formal): Don't consider ARECnF formal.\n+\t(Next_Formal_With_Extras): Do consider ARECnF formal.\n+\t* einfo.ads (Is_ARECnF_Entity): New flag (ARECnF is an extra formal).\n+\t* exp_unst.adb (Create_Entities): Set Is_ARECnF_Entity flag.\n+\n+2015-03-04  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Simple_Function_Return): When the returned\n+\tobject is a class-wide interface object and we generate the\n+\taccessibility described in RM 6.5(8/3) then displace the pointer\n+\tto the object to reference the base of the object (to get access\n+\tto the TSD of the object).\n+\n 2015-03-04  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Analyze_Abstract_State): Use routine"}, {"sha": "95776dad601524a7bbcb27e64afe15ca766cb2be", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=47a6f66054936affc847afa61eed3d245381e58b", "patch": "@@ -585,7 +585,7 @@ package body Einfo is\n    --    Has_Nested_Subprogram           Flag282\n    --    Uplevel_Reference_Noted         Flag283\n \n-   --    (unused)                        Flag284\n+   --    Is_ARECnF_Entity                Flag284\n    --    (unused)                        Flag285\n    --    (unused)                        Flag286\n \n@@ -1901,6 +1901,11 @@ package body Einfo is\n       return Flag146 (Id);\n    end Is_Abstract_Type;\n \n+   function Is_ARECnF_Entity (Id : E) return B is\n+   begin\n+      return Flag284 (Id);\n+   end Is_ARECnF_Entity;\n+\n    function Is_Local_Anonymous_Access (Id : E) return B is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -4783,6 +4788,11 @@ package body Einfo is\n       Set_Flag146 (Id, V);\n    end Set_Is_Abstract_Type;\n \n+   procedure Set_Is_ARECnF_Entity (Id : E; V : B := True) is\n+   begin\n+      Set_Flag284 (Id, V);\n+   end Set_Is_ARECnF_Entity;\n+\n    procedure Set_Is_Local_Anonymous_Access (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -7562,7 +7572,7 @@ package body Einfo is\n \n    function Last_Formal (Id : E) return E is\n       Formal : E;\n-\n+      NForm  : E;\n    begin\n       pragma Assert\n         (Is_Overloadable (Id)\n@@ -7577,8 +7587,10 @@ package body Einfo is\n          Formal := First_Formal (Id);\n \n          if Present (Formal) then\n-            while Present (Next_Formal (Formal)) loop\n-               Formal := Next_Formal (Formal);\n+            loop\n+               NForm := Next_Formal (Formal);\n+               exit when No (NForm) or else Is_ARECnF_Entity (NForm);\n+               Formal := NForm;\n             end loop;\n          end if;\n \n@@ -7784,10 +7796,21 @@ package body Einfo is\n \n       P := Id;\n       loop\n-         P := Next_Entity (P);\n+         Next_Entity (P);\n+\n+         --  Return Empty if no next entity, or its an ARECnF entity (since\n+         --  the latter is the last extra formal, not to be returned here).\n \n-         if No (P) or else Is_Formal (P) then\n+         if No (P) or else Is_ARECnF_Entity (P) then\n+            return Empty;\n+\n+         --  If next entity is a formal, return it\n+\n+         elsif Is_Formal (P) then\n             return P;\n+\n+         --  Else one, unless we have an internal entity, which we skip\n+\n          elsif not Is_Internal (P) then\n             return Empty;\n          end if;\n@@ -7799,11 +7822,30 @@ package body Einfo is\n    -----------------------------\n \n    function Next_Formal_With_Extras (Id : E) return E is\n+      NForm : Entity_Id;\n+      Next  : Entity_Id;\n+\n    begin\n       if Present (Extra_Formal (Id)) then\n          return Extra_Formal (Id);\n+\n       else\n-         return Next_Formal (Id);\n+         NForm := Next_Formal (Id);\n+\n+         if Present (NForm) then\n+            return NForm;\n+\n+         --  Deal with ARECnF entity as last extra formal\n+\n+         else\n+            Next := Next_Entity (Id);\n+\n+            if Present (Next) and then Is_ARECnF_Entity (Next) then\n+               return Next;\n+            else\n+               return Empty;\n+            end if;\n+         end if;\n       end if;\n    end Next_Formal_With_Extras;\n \n@@ -8652,6 +8694,7 @@ package body Einfo is\n       W (\"In_Use\",                          Flag8   (Id));\n       W (\"Is_Abstract_Subprogram\",          Flag19  (Id));\n       W (\"Is_Abstract_Type\",                Flag146 (Id));\n+      W (\"Is_ARECnF_Entity\",                Flag284 (Id));\n       W (\"Is_Access_Constant\",              Flag69  (Id));\n       W (\"Is_Ada_2005_Only\",                Flag185 (Id));\n       W (\"Is_Ada_2012_Only\",                Flag199 (Id));"}, {"sha": "3b6f5be7abb25435e4ca2ae309c6a768168bd811", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=47a6f66054936affc847afa61eed3d245381e58b", "patch": "@@ -2176,6 +2176,15 @@ package Einfo is\n --       carry the keyword aliased, and on record components that have the\n --       keyword. For Ada 2012, also applies to formal parameters.\n \n+--    Is_ARECnF_Entity (Flag284)\n+--       Defined in all entities. Set for the ARECnF E_In_Parameter entity that\n+--       is generated for nested subprograms that require an activation record.\n+--       Logically this is an extra formal, and must be treated that way, but\n+--       we can't use the normal Extra_Formal mechanism since it is designed\n+--       to handle only cases where an extra formal is associated with one of\n+--       the source formals, which is not the case for ARECnF entities. Hence\n+--       we use this special flag to deal with this special extra formal.\n+\n --    Is_Atomic (Flag85)\n --       Defined in all type entities, and also in constants, components and\n --       variables. Set if a pragma Atomic or Shared applies to the entity.\n@@ -5248,6 +5257,7 @@ package Einfo is\n    --    In_Private_Part                     (Flag45)\n    --    Is_Ada_2005_Only                    (Flag185)\n    --    Is_Ada_2012_Only                    (Flag199)\n+   --    Is_ARECnF_Entity                    (Flag284)\n    --    Is_Bit_Packed_Array                 (Flag122)  (base type only)\n    --    Is_Aliased                          (Flag15)\n    --    Is_Character_Type                   (Flag63)\n@@ -6801,6 +6811,7 @@ package Einfo is\n    function Is_Ada_2005_Only                    (Id : E) return B;\n    function Is_Ada_2012_Only                    (Id : E) return B;\n    function Is_Aliased                          (Id : E) return B;\n+   function Is_ARECnF_Entity                    (Id : E) return B;\n    function Is_Asynchronous                     (Id : E) return B;\n    function Is_Atomic                           (Id : E) return B;\n    function Is_Bit_Packed_Array                 (Id : E) return B;\n@@ -7449,6 +7460,7 @@ package Einfo is\n    procedure Set_Is_Ada_2005_Only                (Id : E; V : B := True);\n    procedure Set_Is_Ada_2012_Only                (Id : E; V : B := True);\n    procedure Set_Is_Aliased                      (Id : E; V : B := True);\n+   procedure Set_Is_ARECnF_Entity                (Id : E; V : B := True);\n    procedure Set_Is_Asynchronous                 (Id : E; V : B := True);\n    procedure Set_Is_Atomic                       (Id : E; V : B := True);\n    procedure Set_Is_Bit_Packed_Array             (Id : E; V : B := True);\n@@ -8216,6 +8228,7 @@ package Einfo is\n    pragma Inline (Is_Ada_2012_Only);\n    pragma Inline (Is_Aggregate_Type);\n    pragma Inline (Is_Aliased);\n+   pragma Inline (Is_ARECnF_Entity);\n    pragma Inline (Is_Array_Type);\n    pragma Inline (Is_Assignable);\n    pragma Inline (Is_Asynchronous);\n@@ -8708,6 +8721,7 @@ package Einfo is\n    pragma Inline (Set_Is_Ada_2005_Only);\n    pragma Inline (Set_Is_Ada_2012_Only);\n    pragma Inline (Set_Is_Aliased);\n+   pragma Inline (Set_Is_ARECnF_Entity);\n    pragma Inline (Set_Is_Asynchronous);\n    pragma Inline (Set_Is_Atomic);\n    pragma Inline (Set_Is_Bit_Packed_Array);"}, {"sha": "0b9fb75328b806a5cc3fec5df37faf4ed0332a30", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 54, "deletions": 12, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=47a6f66054936affc847afa61eed3d245381e58b", "patch": "@@ -4379,7 +4379,7 @@ package body Exp_Ch6 is\n            (Result, New_Occurrence_Of (Return_Statement_Entity (N), Loc));\n \n          --  If the object decl was already rewritten as a renaming, then we\n-         --  don't want to do the object allocation and transformation of of\n+         --  don't want to do the object allocation and transformation of\n          --  the return object declaration to a renaming. This case occurs\n          --  when the return object is initialized by a call to another\n          --  build-in-place function, and that function is responsible for\n@@ -6266,18 +6266,60 @@ package body Exp_Ch6 is\n \n             if Is_Class_Wide_Type (Etype (Exp))\n               and then Is_Interface (Etype (Exp))\n-              and then Nkind (Exp) = N_Explicit_Dereference\n             then\n-               Tag_Node :=\n-                 Make_Explicit_Dereference (Loc,\n-                   Prefix =>\n-                     Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                       Make_Function_Call (Loc,\n-                         Name                   =>\n-                           New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n-                         Parameter_Associations => New_List (\n-                           Unchecked_Convert_To (RTE (RE_Address),\n-                             Duplicate_Subexpr (Prefix (Exp)))))));\n+               --  If the expression is an explicit dereference then we can\n+               --  directly displace the pointer to reference the base of\n+               --  the object.\n+\n+               if Nkind (Exp) = N_Explicit_Dereference then\n+                  Tag_Node :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix =>\n+                        Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                          Make_Function_Call (Loc,\n+                            Name                   =>\n+                              New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n+                            Parameter_Associations => New_List (\n+                              Unchecked_Convert_To (RTE (RE_Address),\n+                                Duplicate_Subexpr (Prefix (Exp)))))));\n+\n+               --  Similar case to the previous one but the expression is a\n+               --  renaming of an explicit dereference.\n+\n+               elsif Nkind (Exp) = N_Identifier\n+                 and then Present (Renamed_Object (Entity (Exp)))\n+                 and then Nkind (Renamed_Object (Entity (Exp)))\n+                            = N_Explicit_Dereference\n+               then\n+                  Tag_Node :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix =>\n+                        Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                          Make_Function_Call (Loc,\n+                            Name                   =>\n+                              New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n+                            Parameter_Associations => New_List (\n+                              Unchecked_Convert_To (RTE (RE_Address),\n+                                Duplicate_Subexpr\n+                                  (Prefix\n+                                    (Renamed_Object (Entity (Exp)))))))));\n+\n+               --  Common case: obtain the address of the actual object and\n+               --  displace the pointer to reference the base of the object.\n+\n+               else\n+                  Tag_Node :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix =>\n+                        Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                          Make_Function_Call (Loc,\n+                            Name               =>\n+                              New_Occurrence_Of (RTE (RE_Base_Address), Loc),\n+                            Parameter_Associations => New_List (\n+                              Make_Attribute_Reference (Loc,\n+                                Prefix         => Duplicate_Subexpr (Exp),\n+                                Attribute_Name => Name_Address)))));\n+               end if;\n             else\n                Tag_Node :=\n                  Make_Attribute_Reference (Loc,"}, {"sha": "a850e7816fa0b0f152bb43cc959f8f2260ae6197", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47a6f66054936affc847afa61eed3d245381e58b/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=47a6f66054936affc847afa61eed3d245381e58b", "patch": "@@ -591,7 +591,7 @@ package body Exp_Unst is\n       --  at the start so that all the entities are defined, regardless of the\n       --  order in which we do the code insertions.\n \n-      for J in Subps.First .. Subps.Last loop\n+      Create_Entities : for J in Subps.First .. Subps.Last loop\n          declare\n             STJ : Subp_Entry renames Subps.Table (J);\n             Loc : constant Source_Ptr := Sloc (STJ.Bod);\n@@ -611,6 +611,7 @@ package body Exp_Unst is\n                STJ.ARECnF :=\n                  Make_Defining_Identifier (Loc,\n                    Chars => Name_Find_Str (AREC_String (STJ.Lev - 1) & \"F\"));\n+               Set_Is_ARECnF_Entity (STJ.ARECnF, True);\n             else\n                STJ.ARECnF := Empty;\n             end if;\n@@ -654,7 +655,7 @@ package body Exp_Unst is\n                STJ.ARECnU := Empty;\n             end if;\n          end;\n-      end loop;\n+      end loop Create_Entities;\n \n       --  Loop through subprograms\n "}]}