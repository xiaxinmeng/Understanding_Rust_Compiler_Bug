{"sha": "f7b529fae761c8603888bee76614147954754e75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdiNTI5ZmFlNzYxYzg2MDM4ODhiZWU3NjYxNDE0Nzk1NDc1NGU3NQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-11-08T14:56:41Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-11-08T14:56:41Z"}, "message": "arith.c, [...]: Fix comment formatting.\n\n\t* arith.c, array.c, decl.c, expr.c, f95-lang.c, gfortran.h,\n\tgfortranspec.c, interface.c, intrinsic.c, iresolve.c, match.c,\n\tmodule.c, parse.c, parse.h, primary.c, resolve.c, scanner.c,\n\ttrans-array.c, trans-array.h, trans-expr.c, trans-intrinsic.c,\n\ttrans-io.c, trans-stmt.c, trans.h: Fix comment formatting.\n\nFrom-SVN: r90266", "tree": {"sha": "bf128e11ba70bddbb7f8b8beb206603bd3c66ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf128e11ba70bddbb7f8b8beb206603bd3c66ad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7b529fae761c8603888bee76614147954754e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b529fae761c8603888bee76614147954754e75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7b529fae761c8603888bee76614147954754e75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b529fae761c8603888bee76614147954754e75/comments", "author": null, "committer": null, "parents": [{"sha": "03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03fd3f84d88fb235f16093b9da6e91e6f4a7c253"}], "stats": {"total": 230, "additions": 119, "deletions": 111}, "files": [{"sha": "9cc72efe2daceec6864bf6dd7c9999260e79673a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -1,3 +1,11 @@\n+2004-11-08  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* arith.c, array.c, decl.c, expr.c, f95-lang.c, gfortran.h,\n+\tgfortranspec.c, interface.c, intrinsic.c, iresolve.c, match.c,\n+\tmodule.c, parse.c, parse.h, primary.c, resolve.c, scanner.c,\n+\ttrans-array.c, trans-array.h, trans-expr.c, trans-intrinsic.c,\n+\ttrans-io.c, trans-stmt.c, trans.h: Fix comment formatting.\n+\n 2004-11-06  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/18023"}, {"sha": "36b8cc29be5305320d0ecd5821cb95e1f2edaa64", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -205,7 +205,7 @@ gfc_arith_init_1 (void)\n          is compiled with -pedantic, and reflects the belief that\n          Standard Fortran requires integers to be symmetrical, i.e.\n          every negative integer must have a representable positive\n-         absolute value, and vice versa. */\n+         absolute value, and vice versa.  */\n          \n       mpz_init (int_info->pedantic_min_int);\n       mpz_neg (int_info->pedantic_min_int, int_info->huge);"}, {"sha": "14848282d3a9c600b61f9884993b82af72251847", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -968,7 +968,7 @@ check_element_type (gfc_expr * expr)\n }\n \n \n-/* Recursive work function for gfc_check_constructor_type(). */\n+/* Recursive work function for gfc_check_constructor_type().  */\n \n static try\n check_constructor_type (gfc_constructor * c)\n@@ -1609,7 +1609,7 @@ gfc_get_array_element (gfc_expr * array, int element)\n \n /* These are needed just to accommodate RESHAPE().  There are no\n    diagnostics here, we just return a negative number if something\n-   goes wrong. */\n+   goes wrong.  */\n \n \n /* Get the size of single dimension of an array specification.  The"}, {"sha": "5f7e8462c2d715f921456715ddb5ab5a4e994b23", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -401,7 +401,7 @@ match_old_style_init (const char *name)\n /* Match the stuff following a DATA statement. If ERROR_FLAG is set,\n    we are matching a DATA statement and are therefore issuing an error\n    if we encounter something unexpected, if not, we're trying to match \n-   an old-style intialization expression of the form INTEGER I /2/.   */\n+   an old-style intialization expression of the form INTEGER I /2/.  */\n \n match\n gfc_match_data (void)\n@@ -3292,7 +3292,7 @@ gfc_match_derived_decl (void)\n      components.  The ways this can happen is via a function\n      definition, an INTRINSIC statement or a subtype in another\n      derived type that is a pointer.  The first part of the AND clause\n-     is true if a the symbol is not the return value of a function. */\n+     is true if a the symbol is not the return value of a function.  */\n   if (sym->attr.flavor != FL_DERIVED\n       && gfc_add_flavor (&sym->attr, FL_DERIVED, NULL) == FAILURE)\n     return MATCH_ERROR;"}, {"sha": "5037c8c68348aa3c2ddeb82fe23908f6ddd28ef6", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -583,7 +583,7 @@ gfc_build_conversion (gfc_expr * e)\n    The exception is that the operands of an exponential don't have to\n    have the same type.  If possible, the base is promoted to the type\n    of the exponent.  For example, 1**2.3 becomes 1.0**2.3, but\n-   1.0**2 stays as it is. */\n+   1.0**2 stays as it is.  */\n \n void\n gfc_type_convert_binary (gfc_expr * e)"}, {"sha": "2ccca098c9f4a04aab0f5cb91aad6ea7551d4c0a", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -341,7 +341,7 @@ GTY(())\n   /* For each level (except the global one), a chain of BLOCK nodes for all\n      the levels that were entered and exited one level down from this one.  */\n   tree blocks;\n-  /* The binding level containing this one (the enclosing binding level). */\n+  /* The binding level containing this one (the enclosing binding level).  */\n   struct binding_level *level_chain;\n };\n \n@@ -436,7 +436,7 @@ poplevel (int keep, int reverse, int functionbody)\n        subblock_node = TREE_CHAIN (subblock_node))\n     if (DECL_NAME (subblock_node) != 0)\n       /* If the identifier was used or addressed via a local extern decl,\n-         don't forget that fact.   */\n+         don't forget that fact.  */\n       if (DECL_EXTERNAL (subblock_node))\n \t{\n \t  if (TREE_USED (subblock_node))\n@@ -489,7 +489,7 @@ insert_block (tree block)\n }\n \n /* Records a ..._DECL node DECL as belonging to the current lexical scope.\n-   Returns the ..._DECL node. */\n+   Returns the ..._DECL node.  */\n \n tree\n pushdecl (tree decl)\n@@ -507,7 +507,7 @@ pushdecl (tree decl)\n   TREE_CHAIN (decl) = current_binding_level->names;\n   current_binding_level->names = decl;\n \n-  /* For the declartion of a type, set its name if it is not already set. */\n+  /* For the declartion of a type, set its name if it is not already set.  */\n \n   if (TREE_CODE (decl) == TYPE_DECL && TYPE_NAME (TREE_TYPE (decl)) == 0)\n     {\n@@ -575,7 +575,7 @@ gfc_init_decl_processing (void)\n \n   /* Build common tree nodes. char_type_node is unsigned because we\n      only use it for actual characters, not for INTEGER(1). Also, we\n-     want double_type_node to actually have double precision.   */\n+     want double_type_node to actually have double precision.  */\n   build_common_tree_nodes (false, false);\n   set_sizetype (long_unsigned_type_node);\n   build_common_tree_nodes_2 (0);"}, {"sha": "1e42eb6a813bcce94862cb37fd149df6f128d684", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -99,11 +99,11 @@ mstring;\n /* Flags to specify which standardi/extension contains a feature.  */\n #define GFC_STD_GNU                (1<<5)    /* GNU Fortran extension.  */\n #define GFC_STD_F2003             (1<<4)    /* New in F2003.  */\n-/* Note that no features were obsoleted nor deleted in F2003. */\n-#define GFC_STD_F95                 (1<<3)    /* New in F95. */\n+/* Note that no features were obsoleted nor deleted in F2003.  */\n+#define GFC_STD_F95                 (1<<3)    /* New in F95.  */\n #define GFC_STD_F95_DEL         (1<<2)    /* Deleted in F95.  */\n #define GFC_STD_F95_OBS        (1<<1)    /* Obsoleted in F95.  */\n-#define GFC_STD_F77                 (1<<0)    /* Up to and including F77. */\n+#define GFC_STD_F77                 (1<<0)    /* Up to and including F77.  */\n \n /*************************** Enums *****************************/\n \n@@ -1209,7 +1209,7 @@ gfc_iterator;\n #define gfc_get_iterator() gfc_getmem(sizeof(gfc_iterator))\n \n \n-/* Allocation structure for ALLOCATE, DEALLOCATE and NULLIFY statements. */\n+/* Allocation structure for ALLOCATE, DEALLOCATE and NULLIFY statements.  */\n \n typedef struct gfc_alloc\n {"}, {"sha": "90db93d2d2fe76bb84d1264ff8f6ae546eca3247", "filename": "gcc/fortran/gfortranspec.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fgfortranspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fgfortranspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortranspec.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -68,24 +68,24 @@ Boston, MA 02111-1307, USA.  */\n    skip over.  */\n typedef enum\n {\n-  OPTION_b,\t\t\t/* Aka --prefix. */\n-  OPTION_B,\t\t\t/* Aka --target. */\n-  OPTION_c,\t\t\t/* Aka --compile. */\n-  OPTION_E,\t\t\t/* Aka --preprocess. */\n-  OPTION_help,\t\t\t/* --help. */\n-  OPTION_i,\t\t\t/* -imacros, -include, -include-*. */\n+  OPTION_b,\t\t\t/* Aka --prefix.  */\n+  OPTION_B,\t\t\t/* Aka --target.  */\n+  OPTION_c,\t\t\t/* Aka --compile.  */\n+  OPTION_E,\t\t\t/* Aka --preprocess.  */\n+  OPTION_help,\t\t\t/* --help.  */\n+  OPTION_i,\t\t\t/* -imacros, -include, -include-*.  */\n   OPTION_l,\n-  OPTION_L,\t\t\t/* Aka --library-directory. */\n+  OPTION_L,\t\t\t/* Aka --library-directory.  */\n   OPTION_nostdlib,\t\t/* Aka --no-standard-libraries, or\n-\t\t\t\t   -nodefaultlibs. */\n-  OPTION_o,\t\t\t/* Aka --output. */\n-  OPTION_S,\t\t\t/* Aka --assemble. */\n-  OPTION_syntax_only,\t\t/* -fsyntax-only. */\n-  OPTION_v,\t\t\t/* Aka --verbose. */\n-  OPTION_version,\t\t/* --version. */\n-  OPTION_V,\t\t\t/* Aka --use-version. */\n-  OPTION_x,\t\t\t/* Aka --language. */\n-  OPTION_\t\t\t/* Unrecognized or unimportant. */\n+\t\t\t\t   -nodefaultlibs.  */\n+  OPTION_o,\t\t\t/* Aka --output.  */\n+  OPTION_S,\t\t\t/* Aka --assemble.  */\n+  OPTION_syntax_only,\t\t/* -fsyntax-only.  */\n+  OPTION_v,\t\t\t/* Aka --verbose.  */\n+  OPTION_version,\t\t/* --version.  */\n+  OPTION_V,\t\t\t/* Aka --use-version.  */\n+  OPTION_x,\t\t\t/* Aka --language.  */\n+  OPTION_\t\t\t/* Unrecognized or unimportant.  */\n }\n Option;\n \n@@ -133,7 +133,7 @@ lookup_option (Option *xopt, int *xskip, const char **xarg, const char *text)\n   const char *arg = NULL;\n \n   if ((skip = SWITCH_TAKES_ARG (text[1])))\n-    skip -= (text[2] != '\\0');\t/* See gcc.c. */\n+    skip -= (text[2] != '\\0');\t/* See gcc.c.  */\n \n   if (text[1] == 'B')\n     opt = OPTION_B, skip = (text[2] == '\\0'), arg = text + 2;\n@@ -161,7 +161,7 @@ lookup_option (Option *xopt, int *xskip, const char **xarg, const char *text)\n     opt = OPTION_x, arg = text + 2;\n   else\n     {\n-      if ((skip = WORD_SWITCH_TAKES_ARG (text + 1)) != 0)\t/* See gcc.c. */\n+      if ((skip = WORD_SWITCH_TAKES_ARG (text + 1)) != 0)\t/* See gcc.c.  */\n \t;\n       else if (!strcmp (text, \"-fhelp\"))\t/* Really --help!! */\n \topt = OPTION_help;\n@@ -212,14 +212,14 @@ append_arg (const char *arg)\n \t  || !strcmp (arg, g77_xargv[g77_newargc])))\n     {\n       ++g77_newargc;\n-      return;\t\t\t/* Nothing new here. */\n+      return;\t\t\t/* Nothing new here.  */\n     }\n \n   if (g77_newargv == g77_xargv)\n-    {\t\t\t\t/* Make new arglist. */\n+    {\t\t\t\t/* Make new arglist.  */\n       int i;\n \n-      newargsize = (g77_xargc << 2) + 20;\t/* This should handle all. */\n+      newargsize = (g77_xargc << 2) + 20;\t/* This should handle all.  */\n       g77_newargv = (const char **) xmalloc (newargsize * sizeof (char *));\n \n       /* Copy what has been done so far.  */\n@@ -384,13 +384,13 @@ For more information about these matters, see the file named COPYING\\n\\\n \n   /* Second pass through arglist, transforming arguments as appropriate.  */\n \n-  append_arg (argv[0]);\t\t/* Start with command name, of course. */\n+  append_arg (argv[0]);\t\t/* Start with command name, of course.  */\n \n   for (i = 1; i < argc; ++i)\n     {\n       if (argv[i][0] == '\\0')\n \t{\n-\t  append_arg (argv[i]);\t/* Interesting.  Just append as is. */\n+\t  append_arg (argv[i]);\t/* Interesting.  Just append as is.  */\n \t  continue;\n \t}\n \n@@ -417,9 +417,9 @@ For more information about these matters, see the file named COPYING\\n\\\n \n       if ((argv[i][0] == '-') && (argv[i][1] != 'l'))\n \t{\n-\t  /* Not a filename or library. */\n+\t  /* Not a filename or library.  */\n \n-\t  if (saw_library == 1 && need_math)\t/* -l<library>. */\n+\t  if (saw_library == 1 && need_math)\t/* -l<library>.  */\n \t    append_arg (MATH_LIBRARY);\n \n \t  saw_library = 0;\n@@ -428,13 +428,13 @@ For more information about these matters, see the file named COPYING\\n\\\n \n \t  if (argv[i][1] == '\\0')\n \t    {\n-\t      append_arg (argv[i]);\t/* \"-\" == Standard input. */\n+\t      append_arg (argv[i]);\t/* \"-\" == Standard input.  */\n \t      continue;\n \t    }\n \n \t  if (opt == OPTION_x)\n \t    {\n-\t      /* Track input language. */\n+\t      /* Track input language.  */\n \t      const char *lang;\n \n \t      if (arg == NULL)\n@@ -453,16 +453,16 @@ For more information about these matters, see the file named COPYING\\n\\\n \t  continue;\n \t}\n \n-      /* A filename/library, not an option. */\n+      /* A filename/library, not an option.  */\n \n       if (saw_speclang)\n-\tsaw_library = 0;\t/* -xfoo currently active. */\n+\tsaw_library = 0;\t/* -xfoo currently active.  */\n       else\n-\t{\t\t\t/* -lfoo or filename. */\n+\t{\t\t\t/* -lfoo or filename.  */\n \t  if (strcmp (argv[i], MATH_LIBRARY) == 0)\n \t    {\n \t      if (saw_library == 1)\n-\t\tsaw_library = 2;\t/* -l<library> -lm. */\n+\t\tsaw_library = 2;\t/* -l<library> -lm.  */\n \t      else\n \t\t{\n \t\t  if (0 == use_init)\n@@ -474,9 +474,9 @@ For more information about these matters, see the file named COPYING\\n\\\n \t\t}\n \t    }\n \t  else if (strcmp (argv[i], FORTRAN_LIBRARY) == 0)\n-\t    saw_library = 1;\t/* -l<library>. */\n+\t    saw_library = 1;\t/* -l<library>.  */\n \t  else\n-\t    {\t\t\t/* Other library, or filename. */\n+\t    {\t\t\t/* Other library, or filename.  */\n \t      if (saw_library == 1 && need_math)\n \t\tappend_arg (MATH_LIBRARY);\n \t      saw_library = 0;\n@@ -488,7 +488,7 @@ For more information about these matters, see the file named COPYING\\n\\\n   /* Append `-lg2c -lm' as necessary.  */\n \n   if (library)\n-    {\t\t\t\t/* Doing a link and no -nostdlib. */\n+    {\t\t\t\t/* Doing a link and no -nostdlib.  */\n       if (saw_speclang)\n \tappend_arg (\"-xnone\");\n \n@@ -538,12 +538,12 @@ For more information about these matters, see the file named COPYING\\n\\\n   *in_argv = g77_newargv;\n }\n \n-/* Called before linking.  Returns 0 on success and -1 on failure. */\n+/* Called before linking.  Returns 0 on success and -1 on failure.  */\n int\n-lang_specific_pre_link (void)\t/* Not used for F77. */\n+lang_specific_pre_link (void)\t/* Not used for F77.  */\n {\n   return 0;\n }\n \n-/* Number of extra output files that lang_specific_pre_link may generate. */\n-int lang_specific_extra_outfiles = 0;\t/* Not used for F77. */\n+/* Number of extra output files that lang_specific_pre_link may generate.  */\n+int lang_specific_extra_outfiles = 0;\t/* Not used for F77.  */"}, {"sha": "87b243775cfa51bb6beee08aec4028e85410d37b", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -710,7 +710,7 @@ count_types_test (gfc_formal_arglist * f1, gfc_formal_arglist * f2)\n \t  ac1++;\n \n       /* Count the number of arguments in f2 with that type, including\n-         those that are optional. */\n+         those that are optional.  */\n       ac2 = 0;\n \n       for (f = f2; f; f = f->next)\n@@ -1313,7 +1313,7 @@ argpair;\n    order:\n     - p->a->expr == NULL\n     - p->a->expr->expr_type != EXPR_VARIABLE\n-    - growing p->a->expr->symbol.   */\n+    - growing p->a->expr->symbol.  */\n \n static int\n pair_cmp (const void *p1, const void *p2)"}, {"sha": "462d0767309484b72a390ce22c348c677682b2b1", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -41,7 +41,7 @@ static gfc_namespace *gfc_intrinsic_namespace;\n int gfc_init_expr = 0;\n \n /* Pointers to a intrinsic function and its argument names being\n-   checked. */\n+   checked.  */\n \n char *gfc_current_intrinsic, *gfc_current_intrinsic_arg[MAX_INTRINSIC_ARGS];\n locus *gfc_current_intrinsic_where;\n@@ -222,7 +222,7 @@ add_sym (const char *name, int elemental, int actual_ok ATTRIBUTE_UNUSED,\n   va_list argp;\n \n   /* First check that the intrinsic belongs to the selected standard.\n-     If not, don't add it to the symbol list. */\n+     If not, don't add it to the symbol list.  */\n   if (!(gfc_option.allow_std & standard))\n     return;\n \n@@ -422,7 +422,7 @@ static void add_sym_2 (const char *name, int elemental, int actual_ok, bt type,\n \n \n /* Add the name of an intrinsic subroutine with two arguments to the list\n-   of intrinsic names. */\n+   of intrinsic names.  */\n \n static void add_sym_2s (const char *name, int elemental, int actual_ok, bt type,\n \t\t\tint kind, int standard,\n@@ -526,7 +526,7 @@ static void add_sym_3red (const char *name, int elemental,\n }\n \n /* Add the name of an intrinsic subroutine with three arguments to the list\n-   of intrinsic names. */\n+   of intrinsic names.  */\n \n static void add_sym_3s (const char *name, int elemental, int actual_ok, bt type,\n \t\t\tint kind, int standard,\n@@ -1688,7 +1688,7 @@ add_functions (void)\n \n   make_generic (\"scan\", GFC_ISYM_SCAN, GFC_STD_F95);\n \n-  /* Added for G77 compatibility garbage. */\n+  /* Added for G77 compatibility garbage.  */\n   add_sym_0 (\"second\", 0, 1, BT_REAL, 4,  GFC_STD_GNU,NULL, NULL, NULL);\n \n   make_generic (\"second\", GFC_ISYM_SECOND, GFC_STD_GNU);\n@@ -1903,7 +1903,7 @@ add_subroutines (void)\n \t      gfc_check_cpu_time, NULL, gfc_resolve_cpu_time,\n \t      tm, BT_REAL, dr, 0);\n \n-  /* More G77 compatibility garbage. */\n+  /* More G77 compatibility garbage.  */\n   add_sym_1s (\"second\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      gfc_check_second_sub, NULL, gfc_resolve_second_sub,\n \t      tm, BT_REAL, dr, 0);\n@@ -1913,7 +1913,7 @@ add_subroutines (void)\n \t      dt, BT_CHARACTER, dc, 1, tm, BT_CHARACTER, dc, 1,\n \t      zn, BT_CHARACTER, dc, 1, vl, BT_INTEGER, di, 1);\n \n-  /* More G77 compatibility garbage. */\n+  /* More G77 compatibility garbage.  */\n   add_sym_2s (\"etime\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t     gfc_check_etime_sub, NULL, gfc_resolve_etime_sub,\n \t     vl, BT_REAL, 4, 0, tm, BT_REAL, 4, 0);\n@@ -1953,7 +1953,7 @@ add_subroutines (void)\n \t      st, BT_INTEGER, di, 1);\n \n \n-  /* F2003 subroutine to get environment variables. */\n+  /* F2003 subroutine to get environment variables.  */\n \n   add_sym_5s (\"get_environment_variable\", 0, 1, BT_UNKNOWN, 0, GFC_STD_F2003,\n \t     NULL, NULL, gfc_resolve_get_environment_variable,\n@@ -1979,7 +1979,7 @@ add_subroutines (void)\n \t     sz, BT_INTEGER, di, 1, pt, BT_INTEGER, di, 1,\n \t     gt, BT_INTEGER, di, 1);\n \n-  /* More G77 compatibility garbage. */\n+  /* More G77 compatibility garbage.  */\n   add_sym_1s (\"srand\", 0, 1, BT_UNKNOWN, di, GFC_STD_GNU,\n              gfc_check_srand, NULL, gfc_resolve_srand,\n              c, BT_INTEGER, 4, 0);\n@@ -2138,7 +2138,7 @@ gfc_intrinsic_init_1 (void)\n   add_conversions ();\n \n   /* Set the pure flag.  All intrinsic functions are pure, and\n-     intrinsic subroutines are pure if they are elemental. */\n+     intrinsic subroutines are pure if they are elemental.  */\n \n   for (i = 0; i < nfunc; i++)\n     functions[i].pure = 1;\n@@ -2304,7 +2304,7 @@ sort_actual (const char *name, gfc_actual_arglist ** ap,\n \n       actual = a;\n     }\n-  actual->next = NULL;\t\t/* End the sorted argument list. */\n+  actual->next = NULL;\t\t/* End the sorted argument list.  */\n \n   return SUCCESS;\n }\n@@ -2831,7 +2831,7 @@ gfc_intrinsic_sub_interface (gfc_code * c, int error_flag)\n     }\n \n   /* The subroutine corresponds to an intrinsic.  Allow errors to be\n-     seen at this point. */\n+     seen at this point.  */\n   gfc_suppress_error = 0;\n \n   if (isym->resolve.s1 != NULL)"}, {"sha": "d6bbe268bffad4c0cd9a99bd1a1ec4c001836d85", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -1594,7 +1594,7 @@ gfc_resolve_get_command_argument (gfc_code * c)\n   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n }\n \n-/* Resolve the get_environment_variable intrinsic subroutine. */\n+/* Resolve the get_environment_variable intrinsic subroutine.  */\n \n void\n gfc_resolve_get_environment_variable (gfc_code * code)"}, {"sha": "210de97de90dd914c085b0fd40d2637fe0a2bfa7", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -2673,7 +2673,7 @@ match_case_selector (gfc_case ** cp)\n \tgoto need_expr;\n \n       /* If we're not looking at a ':' now, make a range out of a single\n-\t target.  Else get the upper bound for the case range. */\n+\t target.  Else get the upper bound for the case range.  */\n       if (gfc_match_char (':') != MATCH_YES)\n \tc->high = c->low;\n       else"}, {"sha": "10beca31c915a1124e8e80ad2614cf285cdb887b", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -1398,7 +1398,7 @@ static const mstring attr_bits[] =\n     minit (NULL, -1)\n };\n \n-/* Specialisation of mio_name. */\n+/* Specialisation of mio_name.  */\n DECL_MIO_NAME(ab_attribute)\n DECL_MIO_NAME(ar_type)\n DECL_MIO_NAME(array_type)\n@@ -2334,7 +2334,7 @@ static const mstring expr_types[] = {\n \n /* INTRINSIC_ASSIGN is missing because it is used as an index for\n    generic operators, not in expressions.  INTRINSIC_USER is also\n-   replaced by the correct function name by the time we see it. */\n+   replaced by the correct function name by the time we see it.  */\n \n static const mstring intrinsics[] =\n {"}, {"sha": "11bd8efbff4e6b7e0ba8eed90114f799645fea13", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -400,7 +400,7 @@ next_fixed (void)\n \t  break;\n \n           /* Comments have already been skipped by the time we get\n-\t     here so don't bother checking for them. */\n+\t     here so don't bother checking for them.  */\n \n \tdefault:\n \t  gfc_buffer_error (0);"}, {"sha": "c1f6a194f6bb07a8f648b49302d01005a97a05bd", "filename": "gcc/fortran/parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -45,7 +45,7 @@ typedef struct gfc_state_data\n   struct gfc_code *head, *tail;\n   struct gfc_state_data *previous;\n \n-  /* Block-specific state data. */\n+  /* Block-specific state data.  */\n   union\n   {\n     gfc_st_label *end_do_label;"}, {"sha": "6484ec60cc28d3212230536560b27a96a2ea0eff", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -374,7 +374,7 @@ match_real_constant (gfc_expr ** result, int signflag)\n \t    {\n \t      c = gfc_next_char ();\n \t      if (c == '.')\n-\t\tgoto done;\t/* Operator named .e. or .d. */\n+\t\tgoto done;\t/* Operator named .e. or .d.  */\n \t    }\n \n \t  if (ISALPHA (c))\n@@ -1654,7 +1654,7 @@ match_varspec (gfc_expr * primary, int equiv_flag)\n    dumped).  If we see a full part or section of an array, the\n    expression is also an array.\n \n-   We can have at most one full array reference. */\n+   We can have at most one full array reference.  */\n \n symbol_attribute\n gfc_variable_attr (gfc_expr * expr, gfc_typespec * ts)"}, {"sha": "e592a02ae42fa28e334e63a655f47c2a73852b94", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -287,7 +287,7 @@ resolve_contained_fntype (gfc_symbol * sym, gfc_namespace * ns)\n \n \n /* Add NEW_ARGS to the formal argument list of PROC, taking care not to\n-   introduce duplicates.   */\n+   introduce duplicates.  */\n \n static void\n merge_argument_lists (gfc_symbol *proc, gfc_formal_arglist *new_args)\n@@ -343,7 +343,7 @@ resolve_entries (gfc_namespace * ns)\n   if (ns->proc_name->attr.entry_master)\n     return;\n \n-  /* If this isn't a procedure something has gone horribly wrong.   */\n+  /* If this isn't a procedure something has gone horribly wrong.  */\n   gcc_assert (ns->proc_name->attr.flavor == FL_PROCEDURE);\n   \n   /* Remember the current namespace.  */\n@@ -433,7 +433,7 @@ resolve_contained_functions (gfc_namespace * ns)\n \n \n /* Resolve all of the elements of a structure constructor and make sure that\n-   the types are correct. */\n+   the types are correct.  */\n \n static try\n resolve_structure_cons (gfc_expr * expr)\n@@ -1581,7 +1581,7 @@ check_dimension (int i, gfc_array_ref * ar, gfc_array_spec * as)\n {\n \n /* Given start, end and stride values, calculate the minimum and\n-   maximum referenced indexes. */\n+   maximum referenced indexes.  */\n \n   switch (ar->type)\n     {\n@@ -1609,7 +1609,7 @@ check_dimension (int i, gfc_array_ref * ar, gfc_array_spec * as)\n \tgoto bound;\n \n       /* TODO: Possibly, we could warn about end[i] being out-of-bound although\n-         it is legal (see 6.2.2.3.1). */\n+         it is legal (see 6.2.2.3.1).  */\n \n       break;\n \n@@ -1982,7 +1982,7 @@ resolve_ref (gfc_expr * expr)\n \n \n /* Given an expression, determine its shape.  This is easier than it sounds.\n-   Leaves the shape array NULL if it is not possible to determine the shape. */\n+   Leaves the shape array NULL if it is not possible to determine the shape.  */\n \n static void\n expression_shape (gfc_expr * e)\n@@ -2022,7 +2022,7 @@ expression_rank (gfc_expr * e)\n     {\n       if (e->expr_type == EXPR_ARRAY)\n \tgoto done;\n-      /* Constructors can have a rank different from one via RESHAPE().   */\n+      /* Constructors can have a rank different from one via RESHAPE().  */\n \n       if (e->symtree == NULL)\n \t{\n@@ -3346,7 +3346,7 @@ gfc_resolve_assign_in_forall (gfc_code *code, int nvar, gfc_expr **var_expr)\n       forall_index = var_expr[n]->symtree->n.sym;\n \n       /* Check whether the assignment target is one of the FORALL index\n-         variable. */\n+         variable.  */\n       if ((code->expr->expr_type == EXPR_VARIABLE)\n           && (code->expr->symtree->n.sym == forall_index))\n         gfc_error (\"Assignment to a FORALL index variable at %L\",\n@@ -3461,7 +3461,7 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n   if (forall_save == 0)\n     {\n       /* Count the total number of FORALL index in the nested FORALL\n-         construct in order to allocate the VAR_EXPR with proper size.   */\n+         construct in order to allocate the VAR_EXPR with proper size.  */\n       next = code;\n       while ((next != NULL) && (next->op == EXEC_FORALL))\n         {\n@@ -3470,7 +3470,7 @@ gfc_resolve_forall (gfc_code *code, gfc_namespace *ns, int forall_save)\n           next = next->block->next;\n         }\n \n-      /* allocate VAR_EXPR with NUMBER_OF_FORALL_INDEX elements.   */\n+      /* Allocate VAR_EXPR with NUMBER_OF_FORALL_INDEX elements.  */\n       var_expr = (gfc_expr **) gfc_getmem (total_var * sizeof (gfc_expr *));\n     }\n \n@@ -4071,7 +4071,7 @@ resolve_symbol (gfc_symbol * sym)\n     gfc_error(\"Intrinsic at %L does not exist\", &sym->declared_at);\n \n   /* Resolve array specifier. Check as well some constraints\n-     on COMMON blocks. */\n+     on COMMON blocks.  */\n \n   check_constant = sym->attr.in_common && !sym->attr.pointer;\n   gfc_resolve_array_spec (sym->as, check_constant);"}, {"sha": "3731398242dbf94fe04a33d2e925706c77d5a2c6", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -468,7 +468,7 @@ gfc_next_char_literal (int in_string)\n \tgoto done;\n \n       /* If the next nonblank character is a ! or \\n, we've got a\n-         continuation line. */\n+         continuation line.  */\n       old_loc = gfc_current_locus;\n \n       c = next_char ();\n@@ -981,7 +981,7 @@ include_line (char *line)\n   if (*c != '\\0' && *c != '!')\n     return false;\n \n-  /* We have an include line at this point. */\n+  /* We have an include line at this point.  */\n \n   *stop = '\\0'; /* It's ok to trash the buffer, as this line won't be\n \t\t   read by anything else.  */\n@@ -1093,7 +1093,7 @@ load_file (char *filename, bool initial)\n \n \n /* Determine the source form from the filename extension.  We assume\n-   case insensitivity. */\n+   case insensitivity.  */\n \n static gfc_source_form\n form_from_filename (const char *filename)"}, {"sha": "6380bcf2953259bc6bee48f8efca6f7471b1177a", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -1040,7 +1040,7 @@ get_array_ctor_var_strlen (gfc_expr * expr, tree * len)\n \t  break;\n \n \tcase COMPONENT_REF:\n-\t  /* Use the length of the component. */\n+\t  /* Use the length of the component.  */\n \t  ts = &ref->u.c.component->ts;\n \t  break;\n \n@@ -2025,7 +2025,7 @@ gfc_conv_section_upper_bound (gfc_ss * ss, int n, stmtblock_t * pblock)\n     }\n   else\n     {\n-      /* No upper bound was specified, so use the bound of the array. */\n+      /* No upper bound was specified, so use the bound of the array.  */\n       bound = gfc_conv_array_ubound (desc, dim);\n     }\n \n@@ -2396,7 +2396,7 @@ gfc_conv_resolve_dependencies (gfc_loopinfo * loop, gfc_ss * dest,\n    the range of the loop variables.  Creates a temporary if required.\n    Calculates how to transform from loop variables to array indices for each\n    expression.  Also generates code for scalar expressions which have been\n-   moved outside the loop. */\n+   moved outside the loop.  */\n \n void\n gfc_conv_loop_setup (gfc_loopinfo * loop)\n@@ -2436,7 +2436,7 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t      /* Try to figure out the size of the constructor.  */\n \t      /* TODO: avoid this by making the frontend set the shape.  */\n \t      gfc_get_array_cons_size (&i, ss->expr->value.constructor);\n-\t      /* A negative value means we failed. */\n+\t      /* A negative value means we failed.  */\n \t      if (mpz_sgn (i) > 0)\n \t\t{\n \t\t  mpz_sub_ui (i, i, 1);\n@@ -2997,7 +2997,7 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n           gfc_add_block_to_block (pblock, &se.pre);\n           gfc_add_modify_expr (pblock, ubound, se.expr);\n         }\n-      /* The offset of this dimension.  offset = offset - lbound * stride. */\n+      /* The offset of this dimension.  offset = offset - lbound * stride.  */\n       tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, lbound, size));\n       offset = fold (build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n \n@@ -3361,7 +3361,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n           tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type, tmp, lbound));\n           gfc_add_modify_expr (&block, ubound, tmp);\n \t}\n-      /* The offset of this dimension.  offset = offset - lbound * stride. */\n+      /* The offset of this dimension.  offset = offset - lbound * stride.  */\n       tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, lbound, stride));\n       offset = fold (build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n \n@@ -4208,7 +4208,7 @@ gfc_walk_op_expr (gfc_ss * ss, gfc_expr * expr)\n   if (head2 == ss)\n     return head2;\n \n-  /* All operands require scalarization. */\n+  /* All operands require scalarization.  */\n   if (head != ss && (expr->op2 == NULL || head2 != head))\n     return head2;\n "}, {"sha": "b4407693909bba848ba57f3adc523fd6a4fab988", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -90,7 +90,7 @@ void gfc_conv_array_parameter (gfc_se *, gfc_expr *, gfc_ss *, int);\n /* These work with both descriptors and descriptorless arrays.  */\n tree gfc_conv_array_data (tree);\n tree gfc_conv_array_offset (tree);\n-/* Return either an INT_CST or an expression for that part of the descriptor. */\n+/* Return either an INT_CST or an expression for that part of the descriptor.  */\n tree gfc_conv_array_stride (tree, int);\n tree gfc_conv_array_lbound (tree, int);\n tree gfc_conv_array_ubound (tree, int);"}, {"sha": "d6da9bf96db1611ecb0687358427a123f42313e2", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -156,7 +156,7 @@ gfc_get_expr_charlen (gfc_expr *e)\n \n   /* First candidate: if the variable is of type CHARACTER, the\n      expression's length could be the length of the character\n-     variable. */\n+     variable.  */\n   if (e->symtree->n.sym->ts.type == BT_CHARACTER)\n     length = e->symtree->n.sym->ts.cl->backend_decl;\n "}, {"sha": "927fcfce7b93580343c8e7d1beeded4d4e5d5aed", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -132,7 +132,7 @@ static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =\n    elemental functions to manipulate reals.  */\n typedef struct\n {\n-  tree arg;     /* Variable tree to view convert to integer.   */ \n+  tree arg;     /* Variable tree to view convert to integer.  */\n   tree expn;    /* Variable tree to save exponent.  */\n   tree frac;    /* Variable tree to save fraction.  */\n   tree smask;   /* Constant tree of sign's mask.  */\n@@ -165,7 +165,7 @@ gfc_conv_intrinsic_function_args (gfc_se * se, gfc_expr * expr)\n \tcontinue;\n \n       /* Evaluate the parameter.  This will substitute scalarized\n-         references automatically. */\n+         references automatically.  */\n       gfc_init_se (&argse, se);\n \n       if (actual->expr->ts.type == BT_CHARACTER)\n@@ -2254,7 +2254,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n }\n \n \n-/* Scan a string for any one of the characters in a set of characters.   */\n+/* Scan a string for any one of the characters in a set of characters.  */\n \n static void\n gfc_conv_intrinsic_scan (gfc_se * se, gfc_expr * expr)"}, {"sha": "d5e8df6d2dfb9f0c60263df950883443b52dbb71", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -135,7 +135,7 @@ static GTY(()) tree iocall_set_nml_val_log;\n \n /* Variable for keeping track of what the last data transfer statement\n    was.  Used for deciding which subroutine to call when the data\n-   transfer is complete. */\n+   transfer is complete.  */\n static enum { READ, WRITE, IOLENGTH } last_dt;\n \n #define ADD_FIELD(name, type)\t\t\t\t\t\t\\\n@@ -166,7 +166,7 @@ gfc_build_io_library_fndecls (void)\n \n   /* Build the st_parameter structure.  Information associated with I/O\n      calls are transferred here.  This must match the one defined in the\n-     library exactly. */\n+     library exactly.  */\n \n   ioparm_type = make_node (RECORD_TYPE);\n   TYPE_NAME (ioparm_type) = get_identifier (\"_gfc_ioparm\");\n@@ -857,7 +857,7 @@ get_new_var_expr(gfc_symbol * sym)\n \n    Note that the first output field appears after the name of the\n    variable, not of the field name.  This causes a little complication\n-   documented below. */\n+   documented below.  */\n \n static void\n transfer_namelist_element (stmtblock_t * block, gfc_typespec * ts, tree addr_expr, \n@@ -890,7 +890,7 @@ transfer_namelist_element (stmtblock_t * block, gfc_typespec * ts, tree addr_exp\n              derived type variable.  All other fields are anonymous\n              and appear with nulls in their string and string_length\n              fields.  After the first use, we set string and\n-             string_length to null. */\n+             string_length to null.  */\n           string = null_pointer_node;\n           string_length = integer_zero_node;\n         }\n@@ -1190,7 +1190,7 @@ transfer_array_component (tree expr, gfc_component * cm)\n       mpz_add_ui (ss->shape[n], ss->shape[n], 1);\n     }\n \n-  /* Once we got ss, we use scalarizer to create the loop. */\n+  /* Once we got ss, we use scalarizer to create the loop.  */\n \n   gfc_init_loopinfo (&loop);\n   gfc_add_ss_to_loop (&loop, ss);\n@@ -1212,7 +1212,7 @@ transfer_array_component (tree expr, gfc_component * cm)\n   transfer_expr (&se, &cm->ts, tmp);\n \n   /* We are done now with the loop body.  Wrap up the scalarizer and\n-     return. */\n+     return.  */\n \n   gfc_add_block_to_block (&body, &se.pre);\n   gfc_add_block_to_block (&body, &se.post);"}, {"sha": "a403693fc45ab2df5fbe5822d1f81ab8f4c51a0a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -1899,7 +1899,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n   type = gfc_typenode_for_spec (&expr1->ts);\n \n   /* Allocate temporary for nested forall construct according to the\n-     information in nested_forall_info and inner_size. */\n+     information in nested_forall_info and inner_size.  */\n   tmp1 = allocate_temp_for_forall_nest (nested_forall_info, type,\n                                 inner_size, block, &ptemp1);\n \n@@ -2348,7 +2348,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n     }\n \n   /* Copy the mask into a temporary variable if required.\n-     For now we assume a mask temporary is needed. */\n+     For now we assume a mask temporary is needed.  */\n   if (code->expr)\n     {\n       /* Allocate the mask temporary.  */\n@@ -3025,7 +3025,7 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n \n /* As the WHERE or WHERE construct statement can be nested, we call\n    gfc_trans_where_2 to do the translation, and pass the initial\n-   NULL values for both the control mask and the pending control mask. */\n+   NULL values for both the control mask and the pending control mask.  */\n \n tree\n gfc_trans_where (gfc_code * code)"}, {"sha": "33d422aa526b5028eee352d08e2a315795666511", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b529fae761c8603888bee76614147954754e75/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=f7b529fae761c8603888bee76614147954754e75", "patch": "@@ -308,7 +308,7 @@ tree gfc_trans_scalar_assign (gfc_se *, gfc_se *, bt);\n /* Translate COMMON blocks.  */\n void gfc_trans_common (gfc_namespace *);\n \n-/* Translate a derived type constructor. */\n+/* Translate a derived type constructor.  */\n void gfc_conv_structure (gfc_se *, gfc_expr *, int);\n \n /* Return an expression which determines if a dummy parameter is present.  */"}]}