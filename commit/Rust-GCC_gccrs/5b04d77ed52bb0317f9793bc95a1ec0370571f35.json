{"sha": "5b04d77ed52bb0317f9793bc95a1ec0370571f35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIwNGQ3N2VkNTJiYjAzMTdmOTc5M2JjOTVhMWVjMDM3MDU3MWYzNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-06-19T12:25:06Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-06-19T12:25:06Z"}, "message": "tree-vectorizer.c (try_vectorize_loop_1): Split out of ...\n\n2018-06-19  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.c (try_vectorize_loop_1): Split out of ...\n\t(vectorize_loops): ... here.  Fix dbgcnt handling.\n\t(try_vectorize_loop): Wrap try_vectorize_loop_1.\n\nFrom-SVN: r261740", "tree": {"sha": "7285ab13618e89a61d37ce5323ecc16a3e6cb355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7285ab13618e89a61d37ce5323ecc16a3e6cb355"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b04d77ed52bb0317f9793bc95a1ec0370571f35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b04d77ed52bb0317f9793bc95a1ec0370571f35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b04d77ed52bb0317f9793bc95a1ec0370571f35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b04d77ed52bb0317f9793bc95a1ec0370571f35/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8006534c792ff92192ede8b3918fc6ba59553a9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8006534c792ff92192ede8b3918fc6ba59553a9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8006534c792ff92192ede8b3918fc6ba59553a9b"}], "stats": {"total": 318, "additions": 167, "deletions": 151}, "files": [{"sha": "7c4b9e6ae965e8a45c5ced07040c4975b9b3ce5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b04d77ed52bb0317f9793bc95a1ec0370571f35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b04d77ed52bb0317f9793bc95a1ec0370571f35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b04d77ed52bb0317f9793bc95a1ec0370571f35", "patch": "@@ -1,3 +1,9 @@\n+2018-06-19  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vectorizer.c (try_vectorize_loop_1): Split out of ...\n+\t(vectorize_loops): ... here.  Fix dbgcnt handling.\n+\t(try_vectorize_loop): Wrap try_vectorize_loop_1.\n+\n 2018-06-19  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/86197"}, {"sha": "1c487e608ffbdc549dd8f276715f63382a0a967f", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 161, "deletions": 151, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b04d77ed52bb0317f9793bc95a1ec0370571f35/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b04d77ed52bb0317f9793bc95a1ec0370571f35/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=5b04d77ed52bb0317f9793bc95a1ec0370571f35", "patch": "@@ -659,6 +659,158 @@ set_uid_loop_bbs (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n   free (bbs);\n }\n \n+/* Try to vectorize LOOP.  */\n+\n+static unsigned\n+try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n+\t\t      unsigned *num_vectorized_loops,\n+\t\t      loop_p loop, loop_vec_info orig_loop_vinfo,\n+\t\t      gimple *loop_vectorized_call,\n+\t\t      gimple *loop_dist_alias_call)\n+{\n+  unsigned ret = 0;\n+  vect_location = find_loop_location (loop);\n+  if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOCATION\n+      && dump_enabled_p ())\n+    dump_printf (MSG_NOTE, \"\\nAnalyzing loop at %s:%d\\n\",\n+\t\t LOCATION_FILE (vect_location),\n+\t\t LOCATION_LINE (vect_location));\n+\n+  loop_vec_info loop_vinfo = vect_analyze_loop (loop, orig_loop_vinfo);\n+  loop->aux = loop_vinfo;\n+\n+  if (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n+    {\n+      /* Free existing information if loop is analyzed with some\n+\t assumptions.  */\n+      if (loop_constraint_set_p (loop, LOOP_C_FINITE))\n+\tvect_free_loop_info_assumptions (loop);\n+\n+      /* If we applied if-conversion then try to vectorize the\n+\t BB of innermost loops.\n+\t ???  Ideally BB vectorization would learn to vectorize\n+\t control flow by applying if-conversion on-the-fly, the\n+\t following retains the if-converted loop body even when\n+\t only non-if-converted parts took part in BB vectorization.  */\n+      if (flag_tree_slp_vectorize != 0\n+\t  && loop_vectorized_call\n+\t  && ! loop->inner)\n+\t{\n+\t  basic_block bb = loop->header;\n+\t  bool has_mask_load_store = false;\n+\t  for (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+\t       !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      if (is_gimple_call (stmt)\n+\t\t  && gimple_call_internal_p (stmt)\n+\t\t  && (gimple_call_internal_fn (stmt) == IFN_MASK_LOAD\n+\t\t      || gimple_call_internal_fn (stmt) == IFN_MASK_STORE))\n+\t\t{\n+\t\t  has_mask_load_store = true;\n+\t\t  break;\n+\t\t}\n+\t      gimple_set_uid (stmt, -1);\n+\t      gimple_set_visited (stmt, false);\n+\t    }\n+\t  if (! has_mask_load_store && vect_slp_bb (bb))\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"basic block vectorized\\n\");\n+\t      fold_loop_internal_call (loop_vectorized_call,\n+\t\t\t\t       boolean_true_node);\n+\t      loop_vectorized_call = NULL;\n+\t      ret |= TODO_cleanup_cfg;\n+\t    }\n+\t}\n+      /* If outer loop vectorization fails for LOOP_VECTORIZED guarded\n+\t loop, don't vectorize its inner loop; we'll attempt to\n+\t vectorize LOOP_VECTORIZED guarded inner loop of the scalar\n+\t loop version.  */\n+      if (loop_vectorized_call && loop->inner)\n+\tloop->inner->dont_vectorize = true;\n+      return ret;\n+    }\n+\n+  if (!dbg_cnt (vect_loop))\n+    {\n+      /* Free existing information if loop is analyzed with some\n+\t assumptions.  */\n+      if (loop_constraint_set_p (loop, LOOP_C_FINITE))\n+\tvect_free_loop_info_assumptions (loop);\n+      return ret;\n+    }\n+\n+  if (loop_vectorized_call)\n+    set_uid_loop_bbs (loop_vinfo, loop_vectorized_call);\n+\n+  unsigned HOST_WIDE_INT bytes;\n+  if (current_vector_size.is_constant (&bytes))\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t     \"loop vectorized vectorized using \"\n+\t\t     HOST_WIDE_INT_PRINT_UNSIGNED \" byte \"\n+\t\t     \"vectors\\n\", bytes);\n+  else\n+    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n+\t\t     \"loop vectorized using variable length vectors\\n\");\n+\n+  loop_p new_loop = vect_transform_loop (loop_vinfo);\n+  (*num_vectorized_loops)++;\n+  /* Now that the loop has been vectorized, allow it to be unrolled\n+     etc.  */\n+  loop->force_vectorize = false;\n+\n+  if (loop->simduid)\n+    {\n+      simduid_to_vf *simduid_to_vf_data = XNEW (simduid_to_vf);\n+      if (!simduid_to_vf_htab)\n+\tsimduid_to_vf_htab = new hash_table<simduid_to_vf> (15);\n+      simduid_to_vf_data->simduid = DECL_UID (loop->simduid);\n+      simduid_to_vf_data->vf = loop_vinfo->vectorization_factor;\n+      *simduid_to_vf_htab->find_slot (simduid_to_vf_data, INSERT)\n+\t  = simduid_to_vf_data;\n+    }\n+\n+  if (loop_vectorized_call)\n+    {\n+      fold_loop_internal_call (loop_vectorized_call, boolean_true_node);\n+      loop_vectorized_call = NULL;\n+      ret |= TODO_cleanup_cfg;\n+    }\n+  if (loop_dist_alias_call)\n+    {\n+      tree value = gimple_call_arg (loop_dist_alias_call, 1);\n+      fold_loop_internal_call (loop_dist_alias_call, value);\n+      loop_dist_alias_call = NULL;\n+      ret |= TODO_cleanup_cfg;\n+    }\n+\n+  /* Epilogue of vectorized loop must be vectorized too.  */\n+  if (new_loop)\n+    ret |= try_vectorize_loop_1 (simduid_to_vf_htab, num_vectorized_loops,\n+\t\t\t\t new_loop, loop_vinfo, NULL, NULL);\n+\n+  return ret;\n+}\n+\n+/* Try to vectorize LOOP.  */\n+\n+static unsigned\n+try_vectorize_loop (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n+\t\t    unsigned *num_vectorized_loops, loop_p loop)\n+{\n+  if (!((flag_tree_loop_vectorize\n+\t && optimize_loop_nest_for_speed_p (loop))\n+\t|| loop->force_vectorize))\n+    return 0;\n+\n+  return try_vectorize_loop_1 (simduid_to_vf_htab, num_vectorized_loops,\n+\t\t\t       loop, NULL,\n+\t\t\t       vect_loop_vectorized_call (loop),\n+\t\t\t       vect_loop_dist_alias_call (loop));\n+}\n+\n+\n /* Function vectorize_loops.\n \n    Entry point to loop vectorization phase.  */\n@@ -674,7 +826,6 @@ vectorize_loops (void)\n   hash_table<simd_array_to_simduid> *simd_array_to_simduid_htab = NULL;\n   bool any_ifcvt_loops = false;\n   unsigned ret = 0;\n-  struct loop *new_loop;\n \n   vect_loops_num = number_of_loops (cfun);\n \n@@ -727,157 +878,18 @@ vectorize_loops (void)\n \t\t  = get_loop (cfun, tree_to_shwi (arg));\n \t\tif (vector_loop && vector_loop != loop)\n \t\t  {\n-\t\t    loop = vector_loop;\n \t\t    /* Make sure we don't vectorize it twice.  */\n-\t\t    loop->dont_vectorize = true;\n-\t\t    goto try_vectorize;\n+\t\t    vector_loop->dont_vectorize = true;\n+\t\t    ret |= try_vectorize_loop (simduid_to_vf_htab,\n+\t\t\t\t\t       &num_vectorized_loops,\n+\t\t\t\t\t       vector_loop);\n \t\t  }\n \t      }\n \t  }\n       }\n     else\n-      {\n-\tloop_vec_info loop_vinfo, orig_loop_vinfo;\n-\tgimple *loop_vectorized_call, *loop_dist_alias_call;\n-       try_vectorize:\n-\tif (!((flag_tree_loop_vectorize\n-\t       && optimize_loop_nest_for_speed_p (loop))\n-\t      || loop->force_vectorize))\n-\t  continue;\n-\torig_loop_vinfo = NULL;\n-\tloop_vectorized_call = vect_loop_vectorized_call (loop);\n-\tloop_dist_alias_call = vect_loop_dist_alias_call (loop);\n-       vectorize_epilogue:\n-\tvect_location = find_loop_location (loop);\n-        if (LOCATION_LOCUS (vect_location) != UNKNOWN_LOCATION\n-\t    && dump_enabled_p ())\n-\t  dump_printf (MSG_NOTE, \"\\nAnalyzing loop at %s:%d\\n\",\n-                       LOCATION_FILE (vect_location),\n-\t\t       LOCATION_LINE (vect_location));\n-\n-\tloop_vinfo = vect_analyze_loop (loop, orig_loop_vinfo);\n-\tloop->aux = loop_vinfo;\n-\n-\tif (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))\n-\t  {\n-\t    /* Free existing information if loop is analyzed with some\n-\t       assumptions.  */\n-\t    if (loop_constraint_set_p (loop, LOOP_C_FINITE))\n-\t      vect_free_loop_info_assumptions (loop);\n-\n-\t    /* If we applied if-conversion then try to vectorize the\n-\t       BB of innermost loops.\n-\t       ???  Ideally BB vectorization would learn to vectorize\n-\t       control flow by applying if-conversion on-the-fly, the\n-\t       following retains the if-converted loop body even when\n-\t       only non-if-converted parts took part in BB vectorization.  */\n-\t    if (flag_tree_slp_vectorize != 0\n-\t\t&& loop_vectorized_call\n-\t\t&& ! loop->inner)\n-\t      {\n-\t\tbasic_block bb = loop->header;\n-\t\tbool has_mask_load_store = false;\n-\t\tfor (gimple_stmt_iterator gsi = gsi_start_bb (bb);\n-\t\t     !gsi_end_p (gsi); gsi_next (&gsi))\n-\t\t  {\n-\t\t    gimple *stmt = gsi_stmt (gsi);\n-\t\t    if (is_gimple_call (stmt)\n-\t\t\t&& gimple_call_internal_p (stmt)\n-\t\t\t&& (gimple_call_internal_fn (stmt) == IFN_MASK_LOAD\n-\t\t\t    || gimple_call_internal_fn (stmt) == IFN_MASK_STORE))\n-\t\t      {\n-\t\t\thas_mask_load_store = true;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    gimple_set_uid (stmt, -1);\n-\t\t    gimple_set_visited (stmt, false);\n-\t\t  }\n-\t\tif (! has_mask_load_store && vect_slp_bb (bb))\n-\t\t  {\n-\t\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t     \"basic block vectorized\\n\");\n-\t\t    fold_loop_internal_call (loop_vectorized_call,\n-\t\t\t\t\t     boolean_true_node);\n-\t\t    loop_vectorized_call = NULL;\n-\t\t    ret |= TODO_cleanup_cfg;\n-\t\t  }\n-\t      }\n-\t    /* If outer loop vectorization fails for LOOP_VECTORIZED guarded\n-\t       loop, don't vectorize its inner loop; we'll attempt to\n-\t       vectorize LOOP_VECTORIZED guarded inner loop of the scalar\n-\t       loop version.  */\n-\t    if (loop_vectorized_call && loop->inner)\n-\t      loop->inner->dont_vectorize = true;\n-\t    continue;\n-\t  }\n-\n-        if (!dbg_cnt (vect_loop))\n-\t  {\n-\t    /* We may miss some if-converted loops due to\n-\t       debug counter.  Set any_ifcvt_loops to visit\n-\t       them at finalization.  */\n-\t    any_ifcvt_loops = true;\n-\t    /* Free existing information if loop is analyzed with some\n-\t       assumptions.  */\n-\t    if (loop_constraint_set_p (loop, LOOP_C_FINITE))\n-\t      vect_free_loop_info_assumptions (loop);\n-\n-\t    break;\n-\t  }\n-\n-\tif (loop_vectorized_call)\n-\t  set_uid_loop_bbs (loop_vinfo, loop_vectorized_call);\n-\n-\tunsigned HOST_WIDE_INT bytes;\n-\tif (current_vector_size.is_constant (&bytes))\n-\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t   \"loop vectorized vectorized using \"\n-\t\t\t   HOST_WIDE_INT_PRINT_UNSIGNED \" byte \"\n-\t\t\t   \"vectors\\n\", bytes);\n-\telse\n-\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,\n-\t\t\t   \"loop vectorized using variable length vectors\\n\");\n-\n-\tnew_loop = vect_transform_loop (loop_vinfo);\n-\tnum_vectorized_loops++;\n-\t/* Now that the loop has been vectorized, allow it to be unrolled\n-\t   etc.  */\n-\tloop->force_vectorize = false;\n-\n-\tif (loop->simduid)\n-\t  {\n-\t    simduid_to_vf *simduid_to_vf_data = XNEW (simduid_to_vf);\n-\t    if (!simduid_to_vf_htab)\n-\t      simduid_to_vf_htab = new hash_table<simduid_to_vf> (15);\n-\t    simduid_to_vf_data->simduid = DECL_UID (loop->simduid);\n-\t    simduid_to_vf_data->vf = loop_vinfo->vectorization_factor;\n-\t    *simduid_to_vf_htab->find_slot (simduid_to_vf_data, INSERT)\n-\t      = simduid_to_vf_data;\n-\t  }\n-\n-\tif (loop_vectorized_call)\n-\t  {\n-\t    fold_loop_internal_call (loop_vectorized_call, boolean_true_node);\n-\t    loop_vectorized_call = NULL;\n-\t    ret |= TODO_cleanup_cfg;\n-\t  }\n-\tif (loop_dist_alias_call)\n-\t  {\n-\t    tree value = gimple_call_arg (loop_dist_alias_call, 1);\n-\t    fold_loop_internal_call (loop_dist_alias_call, value);\n-\t    loop_dist_alias_call = NULL;\n-\t    ret |= TODO_cleanup_cfg;\n-\t  }\n-\n-\tif (new_loop)\n-\t  {\n-\t    /* Epilogue of vectorized loop must be vectorized too.  */\n-\t    vect_loops_num = number_of_loops (cfun);\n-\t    loop = new_loop;\n-\t    orig_loop_vinfo = loop_vinfo;  /* To pass vect_analyze_loop.  */\n-\t    goto vectorize_epilogue;\n-\t  }\n-      }\n+      ret |= try_vectorize_loop (simduid_to_vf_htab, &num_vectorized_loops,\n+\t\t\t\t loop);\n \n   vect_location = UNKNOWN_LOCATION;\n \n@@ -914,18 +926,16 @@ vectorize_loops (void)\n \t  }\n       }\n \n-  for (i = 1; i < vect_loops_num; i++)\n+  for (i = 1; i < number_of_loops (cfun); i++)\n     {\n       loop_vec_info loop_vinfo;\n       bool has_mask_store;\n \n       loop = get_loop (cfun, i);\n-      if (!loop)\n+      if (!loop || !loop->aux)\n \tcontinue;\n       loop_vinfo = (loop_vec_info) loop->aux;\n-      has_mask_store = false;\n-      if (loop_vinfo)\n-\thas_mask_store = LOOP_VINFO_HAS_MASK_STORE (loop_vinfo);\n+      has_mask_store = LOOP_VINFO_HAS_MASK_STORE (loop_vinfo);\n       delete loop_vinfo;\n       if (has_mask_store\n \t  && targetm.vectorize.empty_mask_is_expensive (IFN_MASK_STORE))"}]}