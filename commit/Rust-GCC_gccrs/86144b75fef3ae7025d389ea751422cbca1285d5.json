{"sha": "86144b75fef3ae7025d389ea751422cbca1285d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYxNDRiNzVmZWYzYWU3MDI1ZDM4OWVhNzUxNDIyY2JjYTEyODVkNQ==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-03-28T22:43:13Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1997-03-28T22:43:13Z"}, "message": "Initial revision\n\nFrom-SVN: r13824", "tree": {"sha": "becd738ddc5b06610356cfe6f9cd4196d8810996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/becd738ddc5b06610356cfe6f9cd4196d8810996"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86144b75fef3ae7025d389ea751422cbca1285d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86144b75fef3ae7025d389ea751422cbca1285d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86144b75fef3ae7025d389ea751422cbca1285d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86144b75fef3ae7025d389ea751422cbca1285d5/comments", "author": null, "committer": null, "parents": [{"sha": "0d332addc1a564afecc4602dd9d0b0f42c4ec5ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d332addc1a564afecc4602dd9d0b0f42c4ec5ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d332addc1a564afecc4602dd9d0b0f42c4ec5ce"}], "stats": {"total": 3150, "additions": 3150, "deletions": 0}, "files": [{"sha": "59d802ccaed8c91db79d95be4f78c71c195c4651", "filename": "gcc/gcov-io.h", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86144b75fef3ae7025d389ea751422cbca1285d5/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86144b75fef3ae7025d389ea751422cbca1285d5/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=86144b75fef3ae7025d389ea751422cbca1285d5", "patch": "@@ -0,0 +1,136 @@\n+/* Machine-independent I/O routines for gcov.\n+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Bob Manson <manson@cygnus.com>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef GCOV_IO_H\n+#define GCOV_IO_H\n+#include <stdio.h>\n+\n+/* These routines only work for signed values. */\n+\n+/* Store a portable representation of VALUE in DEST using BYTES*8-1 bits.\n+   Return a non-zero value if VALUE requires more than BYTES*8-1 bits\n+   to store. */\n+\n+static int\n+__store_long (value, dest, bytes)\n+     long value;\n+     char *dest;\n+     int bytes;\n+{\n+  int upper_bit = (value < 0 ? 128 : 0);\n+  int i;\n+\n+  if (value < 0)\n+    {\n+      long oldvalue = value;\n+      value = -value;\n+      if (oldvalue != -value)\n+\treturn 1;\n+    }\n+\n+  for(i = 0 ; i < (sizeof (value) < bytes ? sizeof (value) : bytes) ; i++) {\n+    dest[i] = value & (i == (bytes - 1) ? 127 : 255);\n+    value = value / 256;\n+  }\n+\n+  if (value && value != -1)\n+    return 1;\n+\n+  for(; i < bytes ; i++) \n+    dest[i] = 0;\n+  dest[bytes - 1] |= upper_bit;\n+  return 0;\n+}\n+\n+/* Retrieve a quantity containing BYTES*8-1 bits from SOURCE and store\n+   the result in DEST. Returns a non-zero value if the value in SOURCE\n+   will not fit in DEST. */\n+\n+static int\n+__fetch_long (dest, source, bytes)\n+     long *dest;\n+     char *source;\n+     int bytes;\n+{\n+  long value = 0;\n+  int i;\n+\n+  for (i = bytes - 1; i > (sizeof (*dest) - 1); i--)\n+    if (source[i] & (i == (bytes - 1) ? 127 : 255 ))\n+      return 1;\n+\n+  for (; i >= 0; i--)\n+    value = value * 256 + (source[i] & (i == (bytes - 1) ? 127 : 255));\n+\n+  if ((source[bytes - 1] & 128) && (value > 0))\n+    value = - value;\n+\n+  *dest = value;\n+  return 0;\n+}\n+\n+/* Write a BYTES*8-bit quantity to FILE, portably. Returns a non-zero\n+   value if the write fails, or if VALUE can't be stored in BYTES*8\n+   bits.\n+\n+   Note that VALUE may not actually be large enough to hold BYTES*8\n+   bits, but BYTES characters will be written anyway.\n+\n+   BYTES may be a maximum of 10. */\n+\n+static int\n+__write_long (value, file, bytes)\n+     long value;\n+     FILE *file;\n+     int bytes;\n+{\n+  char c[10];\n+\n+  if (bytes > 10 || __store_long (value, c, bytes))\n+    return 1;\n+  else\n+    return fwrite(c, 1, bytes, file) != bytes;\n+}\n+\n+/* Read a quantity containing BYTES bytes from FILE, portably. Return\n+   a non-zero value if the read fails or if the value will not fit\n+   in DEST.\n+\n+   Note that DEST may not be large enough to hold all of the requested\n+   data, but the function will read BYTES characters anyway.\n+\n+   BYTES may be a maximum of 10. */\n+\n+static int\n+__read_long (dest, file, bytes)\n+     long *dest;\n+     FILE *file;\n+     int bytes;\n+{\n+  char c[10];\n+\n+  if (bytes > 10 || fread(c, 1, bytes, file) != bytes)\n+    return 1;\n+  else\n+    return __fetch_long (dest, c, bytes);\n+}\n+\n+#endif"}, {"sha": "26374c1df6dccde34e128d823aede29cf3cdeeab", "filename": "gcc/gcov.c", "status": "added", "additions": 1380, "deletions": 0, "changes": 1380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86144b75fef3ae7025d389ea751422cbca1285d5/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86144b75fef3ae7025d389ea751422cbca1285d5/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=86144b75fef3ae7025d389ea751422cbca1285d5", "patch": "@@ -0,0 +1,1380 @@\n+/* Gcov.c: prepend line execution counts and branch probabilities to a\n+   source file.\n+   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997 Free Software\n+   Foundation, Inc.\n+   Contributed by James E. Wilson of Cygnus Support.\n+   Mongled by Bob Manson of Cygnus Support.\n+\n+Gcov is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+Gcov is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with Gcov; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* ??? The code in final.c that produces the struct bb assumes that there is\n+   no padding between the fields.  This is not necessary true.  The current\n+   code can only be trusted if longs and pointers are the same size.  */\n+\n+/* ??? No need to print an execution count on every line, could just print\n+   it on the first line of each block, and only print it on a subsequent\n+   line in the same block if the count changes.  */\n+\n+/* ??? Print a list of the ten blocks with the highest execution counts,\n+   and list the line numbers corresponding to those blocks.  Also, perhaps\n+   list the line numbers with the highest execution counts, only printing\n+   the first if there are several which are all listed in the same block.  */\n+\n+/* ??? Should have an option to print the number of basic blocks, and the\n+   percent of them that are covered.  */\n+\n+/* ??? Does not correctly handle the case where two .bb files refer to the\n+   same included source file.  For example, if one has a short file containing\n+   only inline functions, which is then included in two other files, then\n+   there will be two .bb files which refer to the include file, but there\n+   is no way to get the total execution counts for the included file, can\n+   only get execution counts for one or the other of the including files.  */\n+\n+#include <stdio.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+/* The only need for this is so that we get macro definitions for rindex\n+   if necessary.  */\n+#include \"config.h\"\n+\n+#include \"gcov-io.h\"\n+\n+extern char * rindex ();\n+\n+/* The .bb file format consists of several lists of 4-byte integers\n+   which are the line numbers of each basic block in the file.  Each\n+   list is terminated by a zero.  These lists correspond to the basic\n+   blocks in the reconstructed program flow graph.\n+\n+   A line number of -1 indicates that a source file name (padded to a\n+   long boundary) follows.  The padded file name is followed by\n+   another -1 to make it easy to scan past file names.  A -2 indicates\n+   that a function name (padded to a long boundary) follows; the name\n+   is followed by another -2 to make it easy to scan past the function\n+   name.\n+\n+   The .bbg file contains enough info to enable gcov to reconstruct the\n+   program flow graph.  The first word is the number of basic blocks,\n+   the second word is the number of arcs, followed by the list of arcs\n+   (source bb, dest bb pairs), then a -1, then the number of instrumented\n+   arcs followed by the instrumented arcs, followed by another -1.  This\n+   is repeated for each function.\n+\n+   The .da file contains the execution count for each instrumented branch.\n+\n+   The .bb and .bbg files are created by giving GCC the -ftest-coverage option,\n+   and the .da files are created when an executable compiled with\n+   -fprofile-arcs is run.  */\n+\n+/* The functions in this file for creating and solution program flow graphs\n+   are very similar to functions in the gcc source file profile.c.  */\n+\n+char gcov_version_string[] = \"GNU gcov version 1.5\\n\";\n+\n+/* This is the size of the buffer used to read in source file lines.  */\n+\n+#define STRING_SIZE 200\n+\n+/* One copy of this structure is created for each source file mentioned in the\n+   .bb file.  */\n+\n+struct sourcefile\n+{\n+  char *name;\n+  int maxlineno;\n+  struct sourcefile *next;\n+};\n+\n+/* This points to the head of the sourcefile structure list.  */\n+\n+struct sourcefile *sources;\n+\n+/* One of these is dynamically created whenever we identify an arc in the\n+   function.  */\n+\n+struct adj_list {\n+  int source;\n+  int target;\n+  int arc_count;\n+  unsigned int count_valid : 1;\n+  unsigned int on_tree : 1;\n+  unsigned int fake : 1;\n+  unsigned int fall_through : 1;\n+#if 0\n+  /* Not needed for gcov, but defined in profile.c.  */\n+  rtx branch_insn;\n+#endif\n+  struct adj_list *pred_next;\n+  struct adj_list *succ_next;\n+};\n+\n+/* Count the number of basic blocks, and create an array of these structures,\n+   one for each bb in the function.  */\n+\n+struct bb_info {\n+  struct adj_list *succ;\n+  struct adj_list *pred;\n+  int succ_count;\n+  int pred_count;\n+  int exec_count;\n+  unsigned int count_valid : 1;\n+  unsigned int on_tree : 1;\n+#if 0\n+  /* Not needed for gcov, but defined in profile.c.  */\n+  rtx first_insn;\n+#endif\n+};\n+\n+/* When outputting branch probabilities, one of these structures is created\n+   for each branch/call.  */\n+\n+struct arcdata\n+{\n+  int prob;\n+  int call_insn;\n+  struct arcdata *next;\n+};\n+\n+/* Used to save the list of bb_graphs, one per function.  */\n+\n+struct bb_info_list {\n+  /* Indexed by block number, holds the basic block graph for one function.  */\n+  struct bb_info *bb_graph;\n+  int num_blocks;\n+  struct bb_info_list *next;\n+};\n+\n+/* Holds a list of function basic block graphs.  */\n+\n+static struct bb_info_list *bb_graph_list = 0;\n+\n+/* Name and file pointer of the input file for the basic block graph.  */\n+\n+static char *bbg_file_name;\n+static FILE *bbg_file;\n+\n+/* Name and file pointer of the input file for the arc count data.  */\n+\n+static char *da_file_name;\n+static FILE *da_file;\n+\n+/* Name and file pointer of the input file for the basic block line counts.  */\n+\n+static char *bb_file_name;\n+static FILE *bb_file;\n+\n+/* Holds the entire contents of the bb_file read into memory.  */\n+\n+static char *bb_data;\n+\n+/* Size of bb_data array in longs.  */\n+\n+static long bb_data_size;\n+\n+/* Name and file pointer of the output file.  */\n+\n+static char *gcov_file_name;\n+static FILE *gcov_file;\n+\n+/* Name of the file mentioned on the command line.  */\n+\n+static char *input_file_name = 0;\n+\n+/* Output branch probabilities if true.  */\n+\n+static int output_branch_probs = 0;\n+\n+/* Output a gcov file if this is true.  This is on by default, and can\n+   be turned off by the -n option.  */\n+\n+static int output_gcov_file = 1;\n+\n+/* For included files, make the gcov output file name include the name of\n+   the input source file.  For example, if x.h is included in a.c, then the\n+   output file name is a.c.x.h.gcov instead of x.h.gcov.  This works only\n+   when a single source file is specified.  */\n+\n+static int output_long_names = 0;\n+\n+/* Output summary info for each function.  */\n+\n+static int output_function_summary = 0;\n+\n+/* Object directory file prefix.  This is the directory where .bb and .bbg\n+   files are looked for, if non-zero.  */\n+\n+static char *object_directory = 0;\n+\n+/* Forward declarations.  */\n+static void process_args ();\n+static void open_files ();\n+static void read_files ();\n+static void scan_for_source_files ();\n+static void output_data ();\n+char * xmalloc ();\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  process_args (argc, argv);\n+\n+  open_files ();\n+\n+  read_files ();\n+\n+  scan_for_source_files ();\n+\n+  output_data ();\n+\n+  return 0;\n+}\n+\n+char *\n+xmalloc (size)\n+     unsigned size;\n+{\n+  register char *value = (char *) malloc (size);\n+  if (value == 0)\n+    {\n+      fprintf (stderr, \"error: virtual memory exhausted\");\n+      exit (1);\n+    }\n+  return value;\n+}\n+\n+/* More 'friendly' abort that prints the line and file.\n+   config.h can #define abort fancy_abort if you like that sort of thing.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fprintf (stderr, \"Internal gcc abort.\\n\");\n+  exit (FATAL_EXIT_CODE);\n+}\n+\f\n+/* Print a usage message and exit.  */\n+\n+static void\n+print_usage ()\n+{\n+  fprintf (stderr, \"gcov [-b] [-v] [-n] [-l] [-f] [-o OBJDIR] file\\n\");\n+  exit (1);\n+}\n+\n+/* Parse the command line.  */\n+\n+static void\n+process_args (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  int i;\n+\n+  for (i = 1; i < argc; i++)\n+    {\n+      if (argv[i][0] == '-')\n+\t{\n+\t  if (argv[i][1] == 'b')\n+\t    output_branch_probs = 1;\n+\t  else if (argv[i][1] == 'v')\n+\t    fputs (gcov_version_string, stderr);\n+\t  else if (argv[i][1] == 'n')\n+\t    output_gcov_file = 0;\n+\t  else if (argv[i][1] == 'l')\n+\t    output_long_names = 1;\n+\t  else if (argv[i][1] == 'f')\n+\t    output_function_summary = 1;\n+\t  else if (argv[i][1] == 'o' && argv[i][2] == '\\0')\n+\t    object_directory = argv[++i];\n+\t  else\n+\t    print_usage ();\n+\t}\n+      else if (! input_file_name)\n+\tinput_file_name = argv[i];\n+      else\n+\tprint_usage ();\n+    }\n+\n+  if (! input_file_name)\n+    print_usage ();\n+}\n+\n+\n+/* Find and open the .bb, .da, and .bbg files.  */\n+\n+static void\n+open_files ()\n+{\n+  int count, objdir_count;\n+  char *cptr;\n+\n+  /* Determine the names of the .bb, .bbg, and .da files.  Strip off the\n+     extension, if any, and append the new extensions.  */\n+  count = strlen (input_file_name);\n+  if (object_directory)\n+    objdir_count = strlen (object_directory);\n+  else\n+    objdir_count = 0;\n+\n+  da_file_name = xmalloc (count + objdir_count + 4);\n+  bb_file_name = xmalloc (count + objdir_count + 4);\n+  bbg_file_name = xmalloc (count + objdir_count + 5);\n+\n+  if (object_directory)\n+    {\n+      strcpy (da_file_name, object_directory);\n+      strcpy (bb_file_name, object_directory);\n+      strcpy (bbg_file_name, object_directory);\n+\n+      if (object_directory[objdir_count - 1] != '/')\n+\t{\n+\t  strcat (da_file_name, \"/\");\n+\t  strcat (bb_file_name, \"/\");\n+\t  strcat (bbg_file_name, \"/\");\n+\t}\n+\n+      cptr = rindex (input_file_name, '/');\n+      if (cptr)\n+\t{\n+\t  strcat (da_file_name, cptr + 1);\n+\t  strcat (bb_file_name, cptr + 1);\n+\t  strcat (bbg_file_name, cptr + 1);\n+\t}\n+      else\n+\t{\n+\t  strcat (da_file_name, input_file_name);\n+\t  strcat (bb_file_name, input_file_name);\n+\t  strcat (bbg_file_name, input_file_name);\n+\t}\n+    }\n+  else\n+    {\n+      strcpy (da_file_name, input_file_name);\n+      strcpy (bb_file_name, input_file_name);\n+      strcpy (bbg_file_name, input_file_name);\n+    }\n+\n+  cptr = rindex (bb_file_name, '.');\n+  if (cptr)\n+    strcpy (cptr, \".bb\");\n+  else\n+    strcat (bb_file_name, \".bb\");\n+\n+  cptr = rindex (da_file_name, '.');\n+  if (cptr)\n+    strcpy (cptr, \".da\");\n+  else\n+    strcat (da_file_name, \".da\");\n+\n+  cptr = rindex (bbg_file_name, '.');\n+  if (cptr)\n+    strcpy (cptr, \".bbg\");\n+  else\n+    strcat (bbg_file_name, \".bbg\");\n+\n+  bb_file = fopen (bb_file_name, \"r\");\n+  if (bb_file == NULL)\n+    {\n+      fprintf (stderr, \"Could not open basic block file %s.\\n\", bb_file_name);\n+      exit (1);\n+    }\n+\n+  /* If none of the functions in the file were executed, then there won't\n+     be a .da file.  Just assume that all counts are zero in this case.  */\n+  da_file = fopen (da_file_name, \"r\");\n+  if (da_file == NULL)\n+    {\n+      fprintf (stderr, \"Could not open data file %s.\\n\", da_file_name);\n+      fprintf (stderr, \"Assuming that all execution counts are zero.\\n\");\n+    }\n+    \n+  bbg_file = fopen (bbg_file_name, \"r\");\n+  if (bbg_file == NULL)\n+    {\n+      fprintf (stderr, \"Could not open program flow graph file %s.\\n\",\n+\t       bbg_file_name);\n+      exit (1);\n+    }\n+\n+  /* Check for empty .bbg file.  This indicates that there is no executable\n+     code in this source file.  */\n+  /* Set the EOF condition if at the end of file.  */\n+  ungetc (getc (bbg_file), bbg_file);\n+  if (feof (bbg_file))\n+    {\n+      fprintf (stderr, \"No executable code associated with file %s.\\n\",\n+\t       input_file_name);\n+      exit (2);\n+    }\n+}\n+\f\n+/* Initialize a new arc.  */\n+\n+static void\n+init_arc (arcptr, source, target, bb_graph)\n+     struct adj_list *arcptr;\n+     int source, target;\n+     struct bb_info *bb_graph;\n+{\n+  arcptr->target = target;\n+  arcptr->source = source;\n+\n+  arcptr->arc_count = 0;\n+  arcptr->count_valid = 0;\n+  arcptr->on_tree = 0;\n+  arcptr->fake = 0;\n+  arcptr->fall_through = 0;\n+\n+  arcptr->succ_next = bb_graph[source].succ;\n+  bb_graph[source].succ = arcptr;\n+  bb_graph[source].succ_count++;\n+\n+  arcptr->pred_next = bb_graph[target].pred;\n+  bb_graph[target].pred = arcptr;\n+  bb_graph[target].pred_count++;\n+}\n+\n+\n+/* Reverse the arcs on a arc list.  */\n+\n+static struct adj_list *\n+reverse_arcs (arcptr)\n+     struct adj_list *arcptr;\n+{\n+  struct adj_list *prev = 0;\n+  struct adj_list *next;\n+\n+  for ( ; arcptr; arcptr = next)\n+    {\n+      next = arcptr->succ_next;\n+      arcptr->succ_next = prev;\n+      prev = arcptr;\n+    }\n+\n+  return prev;\n+}\n+\n+\n+/* Construct the program flow graph from the .bbg file, and read in the data\n+   in the .da file.  */\n+\n+static void\n+create_program_flow_graph (bptr)\n+     struct bb_info_list *bptr;\n+{\n+  long num_blocks, number_arcs, src, dest, flag_bits, num_arcs_per_block;\n+  int i;\n+  struct adj_list *arcptr;\n+  struct bb_info *bb_graph;\n+\n+  /* Read the number of blocks.  */\n+  __read_long (&num_blocks, bbg_file, 4);\n+\n+  /* Create an array of size bb number of bb_info structs.  Bzero it.  */\n+  bb_graph = (struct bb_info *) xmalloc (num_blocks\n+\t\t\t\t\t * sizeof (struct bb_info));\n+  bzero ((char *) bb_graph, sizeof (struct bb_info) * num_blocks);\n+\n+  bptr->bb_graph = bb_graph;\n+  bptr->num_blocks = num_blocks;\n+\n+  /* Read and create each arc from the .bbg file.  */\n+  __read_long (&number_arcs, bbg_file, 4);\n+  for (i = 0; i < num_blocks; i++)\n+    {\n+      int j;\n+\n+      __read_long (&num_arcs_per_block, bbg_file, 4);\n+      for (j = 0; j < num_arcs_per_block; j++)\n+\t{\n+\t  if (number_arcs-- < 0)\n+\t    abort ();\n+\n+\t  src = i;\n+\t  __read_long (&dest, bbg_file, 4);\n+\n+\t  arcptr = (struct adj_list *) xmalloc (sizeof (struct adj_list));\n+\t  init_arc (arcptr, src, dest, bb_graph);\n+\n+\t  __read_long (&flag_bits, bbg_file, 4);\n+\t  arcptr->on_tree = flag_bits & 0x1;\n+\t  arcptr->fake = !! (flag_bits & 0x2);\n+\t  arcptr->fall_through = !! (flag_bits & 0x4);\n+\t}\n+    }\n+\n+  if (number_arcs)\n+    abort ();\n+\n+  /* Read and ignore the -1 separating the arc list from the arc list of the\n+     next function.  */\n+  __read_long (&src, bbg_file, 4);\n+  if (src != -1)\n+    abort ();\n+\n+  /* Must reverse the order of all succ arcs, to ensure that they match\n+     the order of the data in the .da file.  */\n+\n+  for (i = 0; i < num_blocks; i++)\n+    if (bb_graph[i].succ)\n+      bb_graph[i].succ = reverse_arcs (bb_graph[i].succ);\n+\n+  /* For each arc not on the spanning tree, set its execution count from\n+     the .da file.  */\n+\n+  /* The first count in the .da file is the number of times that the function\n+     was entered.  This is the exec_count for block zero.  */\n+\n+  /* This duplicates code in branch_prob in profile.c.  */\n+\n+  for (i = 0; i < num_blocks; i++)\n+    for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+      if (! arcptr->on_tree)\n+\t{\n+\t  long tmp_count = 0;;\n+\t  if (da_file && __read_long (&tmp_count, da_file, 8))\n+\t    abort();\n+\n+\t  arcptr->arc_count = tmp_count;\n+\t  arcptr->count_valid = 1;\n+\t  bb_graph[i].succ_count--;\n+\t  bb_graph[arcptr->target].pred_count--;\n+\t}\n+}\n+  \n+static void\n+solve_program_flow_graph (bptr)\n+     struct bb_info_list *bptr;\n+{\n+  int passes, changes, total;\n+  int i;\n+  struct adj_list *arcptr;\n+  struct bb_info *bb_graph;\n+  int num_blocks;\n+\n+  num_blocks = bptr->num_blocks;\n+  bb_graph = bptr->bb_graph;\n+\n+  /* For every block in the file,\n+     - if every exit/entrance arc has a known count, then set the block count\n+     - if the block count is known, and every exit/entrance arc but one has\n+       a known execution count, then set the count of the remaining arc\n+\n+     As arc counts are set, decrement the succ/pred count, but don't delete\n+     the arc, that way we can easily tell when all arcs are known, or only\n+     one arc is unknown.  */\n+\n+  /* The order that the basic blocks are iterated through is important.\n+     Since the code that finds spanning trees starts with block 0, low numbered\n+     arcs are put on the spanning tree in preference to high numbered arcs.\n+     Hence, most instrumented arcs are at the end.  Graph solving works much\n+     faster if we propagate numbers from the end to the start.\n+\n+     This takes an average of slightly more than 3 passes.  */\n+\n+  changes = 1;\n+  passes = 0;\n+  while (changes)\n+    {\n+      passes++;\n+      changes = 0;\n+\n+      for (i = num_blocks - 1; i >= 0; i--)\n+\t{\n+\t  if (! bb_graph[i].count_valid)\n+\t    {\n+\t      if (bb_graph[i].succ_count == 0)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  for (arcptr = bb_graph[i].succ; arcptr;\n+\t\t       arcptr = arcptr->succ_next)\n+\t\t    total += arcptr->arc_count;\n+\t\t  bb_graph[i].exec_count = total;\n+\t\t  bb_graph[i].count_valid = 1;\n+\t\t  changes = 1;\n+\t\t}\n+\t      else if (bb_graph[i].pred_count == 0)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  for (arcptr = bb_graph[i].pred; arcptr;\n+\t\t       arcptr = arcptr->pred_next)\n+\t\t    total += arcptr->arc_count;\n+\t\t  bb_graph[i].exec_count = total;\n+\t\t  bb_graph[i].count_valid = 1;\n+\t\t  changes = 1;\n+\t\t}\n+\t    }\n+\t  if (bb_graph[i].count_valid)\n+\t    {\n+\t      if (bb_graph[i].succ_count == 1)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  /* One of the counts will be invalid, but it is zero,\n+\t\t     so adding it in also doesn't hurt.  */\n+\t\t  for (arcptr = bb_graph[i].succ; arcptr;\n+\t\t       arcptr = arcptr->succ_next)\n+\t\t    total += arcptr->arc_count;\n+\t\t  /* Calculate count for remaining arc by conservation.  */\n+\t\t  total = bb_graph[i].exec_count - total;\n+\t\t  /* Search for the invalid arc, and set its count.  */\n+\t\t  for (arcptr = bb_graph[i].succ; arcptr;\n+\t\t       arcptr = arcptr->succ_next)\n+\t\t    if (! arcptr->count_valid)\n+\t\t      break;\n+\t\t  if (! arcptr)\n+\t\t    abort ();\n+\t\t  arcptr->count_valid = 1;\n+\t\t  arcptr->arc_count = total;\n+\t\t  bb_graph[i].succ_count--;\n+\n+\t\t  bb_graph[arcptr->target].pred_count--;\n+\t\t  changes = 1;\n+\t\t}\n+\t      if (bb_graph[i].pred_count == 1)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  /* One of the counts will be invalid, but it is zero,\n+\t\t     so adding it in also doesn't hurt.  */\n+\t\t  for (arcptr = bb_graph[i].pred; arcptr;\n+\t\t       arcptr = arcptr->pred_next)\n+\t\t    total += arcptr->arc_count;\n+\t\t  /* Calculate count for remaining arc by conservation.  */\n+\t\t  total = bb_graph[i].exec_count - total;\n+\t\t  /* Search for the invalid arc, and set its count.  */\n+\t\t  for (arcptr = bb_graph[i].pred; arcptr;\n+\t\t       arcptr = arcptr->pred_next)\n+\t\t    if (! arcptr->count_valid)\n+\t\t      break;\n+\t\t  if (! arcptr)\n+\t\t    abort ();\n+\t\t  arcptr->count_valid = 1;\n+\t\t  arcptr->arc_count = total;\n+\t\t  bb_graph[i].pred_count--;\n+\n+\t\t  bb_graph[arcptr->source].succ_count--;\n+\t\t  changes = 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\t      \n+  /* If the graph has been correctly solved, every block will have a\n+     succ and pred count of zero.  */\n+  for (i = 0; i < num_blocks; i++)\n+    if (bb_graph[i].succ_count || bb_graph[i].pred_count)\n+      abort ();\n+}\n+\n+\n+static void\n+read_files ()\n+{\n+  struct stat buf;\n+  struct bb_info_list *list_end = 0;\n+  struct bb_info_list *b_ptr;\n+  long total, first_time;\n+\n+  /* Read and ignore the first word of the .da file, which is the count of\n+     how many numbers follow.  */\n+  if (da_file && __read_long (&total, da_file, 8))\n+    abort();\n+\n+  while (! feof (bbg_file))\n+    {\n+      b_ptr = (struct bb_info_list *) xmalloc (sizeof (struct bb_info_list));\n+\n+      b_ptr->next = 0;\n+      if (list_end)\n+\tlist_end->next = b_ptr;\n+      else\n+\tbb_graph_list = b_ptr;\n+      list_end = b_ptr;\n+\n+      /* Read in the data in the .bbg file and reconstruct the program flow\n+\t graph for one function.  */\n+      create_program_flow_graph (b_ptr, first_time);\n+\n+      /* Set the EOF condition if at the end of file.  */\n+      ungetc (getc (bbg_file), bbg_file);\n+    }\n+\n+  /* Check to make sure the .da file data is valid.  */\n+\n+  if (da_file)\n+    {\n+      if (feof (da_file))\n+\tfprintf (stderr, \".da file contents exhausted too early\\n\");\n+      /* Should be at end of file now.  */\n+      if (__read_long (&total, da_file, 8) == 0)\n+\tfprintf (stderr, \".da file contents not exhausted\\n\");\n+    }\n+\n+  /* Calculate all of the basic block execution counts and branch\n+     taken probabilities.  */\n+\n+  for (b_ptr = bb_graph_list; b_ptr; b_ptr = b_ptr->next)\n+    solve_program_flow_graph (b_ptr);\n+\n+  /* Read in all of the data from the .bb file.   This info will be accessed\n+     sequentially twice.  */\n+  stat (bb_file_name, &buf);\n+  bb_data_size = buf.st_size / 4;\n+\n+  bb_data = (char *) xmalloc (buf.st_size);\n+  fread (bb_data, sizeof (char), buf.st_size, bb_file);\n+  \n+  fclose (bb_file);\n+  if (da_file)\n+    fclose (da_file);\n+  fclose (bbg_file);\n+}\n+\n+\n+/* Scan the data in the .bb file to find all source files referenced,\n+   and the largest line number mentioned in each one.  */\n+\n+static void\n+scan_for_source_files ()\n+{\n+  struct sourcefile *s_ptr;\n+  char *ptr;\n+  int count;\n+  long line_num;\n+\n+  /* Search the bb_data to find:\n+     1) The number of sources files contained herein, and\n+     2) The largest line number for each source file.  */\n+\n+  ptr = bb_data;\n+  sources = 0;\n+  for (count = 0; count < bb_data_size; count++)\n+    {\n+      __fetch_long (&line_num, ptr, 4);\n+      ptr += 4;\n+      if (line_num == -1)\n+\t{\n+\t  /* A source file name follows.  Check to see if we already have\n+\t   a sourcefile structure for this file.  */\n+\t  s_ptr = sources;\n+\t  while (s_ptr && strcmp (s_ptr->name, ptr))\n+\t    s_ptr = s_ptr->next;\n+\n+\t  if (s_ptr == 0)\n+\t    {\n+\t      /* No sourcefile structure for this file name exists, create\n+\t\t a new one, and append it to the front of the sources list.  */\n+\t      s_ptr = (struct sourcefile *) xmalloc (sizeof(struct sourcefile));\n+\t      s_ptr->name = xmalloc (strlen ((char *) ptr) + 1);\n+\t      strcpy (s_ptr->name, (char *) ptr);\n+\t      s_ptr->maxlineno = 0;\n+\t      s_ptr->next = sources;\n+\t      sources = s_ptr;\n+\t    }\n+\n+\t  /* Scan past the file name.  */\n+\t  {\n+\t    long delim;\n+\t    do {\n+\t      count++;\n+\t      __fetch_long (&delim, ptr, 4);\n+\t      ptr += 4;\n+\t    } while (delim != line_num);\n+\t  }\n+\t}\n+      else if (line_num == -2)\n+\t{\n+\t  long delim;\n+\n+\t  /* A function name follows.  Ignore it.  */\n+\t  do {\n+\t    count++;\n+\t    __fetch_long (&delim, ptr, 4);\n+\t    ptr += 4;\n+\t  } while (delim != line_num);\n+\t}\n+      /* There will be a zero before the first file name, in which case s_ptr\n+\t will still be uninitialized.  So, only try to set the maxlineno\n+\t field if line_num is non-zero.  */\n+      else if (line_num > 0)\n+\t{\n+\t  if (s_ptr->maxlineno <= line_num)\n+\t    s_ptr->maxlineno = line_num + 1;\n+\t}\n+      else if (line_num < 0)\n+\t{\n+\t  /* Don't know what this is, but it's garbage. */\n+\t  abort();\n+\t}\n+    }\n+}\n+\f\n+/* For calculating coverage at the function level.  */\n+\n+static int function_source_lines;\n+static int function_source_lines_executed;\n+static int function_branches;\n+static int function_branches_executed;\n+static int function_branches_taken;\n+static int function_calls;\n+static int function_calls_executed;\n+static char *function_name;\n+\n+/* Calculate the branch taken probabilities for all arcs branches at the\n+   end of this block.  */\n+\n+static void\n+calculate_branch_probs (current_graph, block_num, branch_probs, last_line_num)\n+     struct bb_info_list *current_graph;\n+     int block_num;\n+     struct arcdata **branch_probs;\n+     int last_line_num;\n+{\n+  int total;\n+  struct adj_list *arcptr;\n+  struct arcdata *end_ptr, *a_ptr;\n+\n+  total = current_graph->bb_graph[block_num].exec_count;\n+  for (arcptr = current_graph->bb_graph[block_num].succ; arcptr;\n+       arcptr = arcptr->succ_next)\n+    {\n+      /* Ignore fall through arcs as they aren't really branches.  */\n+\n+      if (arcptr->fall_through)\n+\tcontinue;\n+\t\t      \n+      a_ptr = (struct arcdata *) xmalloc (sizeof (struct arcdata));\n+      if (total == 0)\n+\ta_ptr->prob = -1;\n+      else\n+\ta_ptr->prob = ((arcptr->arc_count * 100) + (total >> 1)) / total;\n+      a_ptr->call_insn = arcptr->fake;\n+\n+      if (output_function_summary)\n+\t{\n+\t  if (a_ptr->call_insn)\n+\t    {\n+\t      function_calls++;\n+\t      if (a_ptr->prob != -1)\n+\t\tfunction_calls_executed++;\n+\t    }\n+\t  else\n+\t    {\n+\t      function_branches++;\n+\t      if (a_ptr->prob != -1)\n+\t\tfunction_branches_executed++;\n+\t      if (a_ptr->prob > 0)\n+\t\tfunction_branches_taken++;\n+\t    }\n+\t}\n+\n+      /* Append the new branch to the end of the list.  */\n+      a_ptr->next = 0;\n+      if (! branch_probs[last_line_num])\n+\tbranch_probs[last_line_num] = a_ptr;\n+      else\n+\t{\n+\t  end_ptr = branch_probs[last_line_num];\n+\t  while (end_ptr->next != 0)\n+\t    end_ptr = end_ptr->next;\n+\t  end_ptr->next = a_ptr;\n+\t}\n+    }\n+}\n+\n+/* Output summary info for a function.  */\n+\n+static void\n+function_summary ()\n+{\n+  if (function_source_lines)\n+    fprintf (stdout, \"%6.2lf%% of %d source lines executed in function %s\\n\",\n+\t     (((double) function_source_lines_executed / function_source_lines)\n+\t      * 100), function_source_lines, function_name);\n+  else\n+    fprintf (stdout, \"No executable source lines in function %s\\n\",\n+\t     function_name);\n+\n+  if (output_branch_probs)\n+    {\n+      if (function_branches)\n+\t{\n+\t  fprintf (stdout, \"%6.2lf%% of %d branches executed in funcion %s\\n\",\n+\t\t   (((double) function_branches_executed / function_branches)\n+\t\t    * 100), function_branches, function_name);\n+\t  fprintf (stdout,\n+\t\t\"%6.2lf%% of %d branches taken at least once in function %s\\n\",\n+\t\t   (((double) function_branches_taken / function_branches)\n+\t\t    * 100), function_branches, function_name);\n+\t}\n+      else\n+\tfprintf (stdout, \"No branches in function %s\\n\", function_name);\n+      if (function_calls)\n+\tfprintf (stdout, \"%6.2lf%% of %d calls executed in function %s\\n\",\n+\t\t (((double) function_calls_executed / function_calls)\n+\t\t  * 100), function_calls, function_name);\n+      else\n+\tfprintf (stdout, \"No calls in function %s\\n\", function_name);\n+    }\n+}\n+\n+/* Calculate line execution counts, and output the data to a .tcov file.  */\n+\n+static void\n+output_data ()\n+{\n+  /* When scanning data, this is true only if the data applies to the\n+     current source file.  */\n+  int this_file;\n+  /* An array indexed by line number which indicates how many times that line\n+     was executed.  */\n+  long *line_counts;\n+  /* An array indexed by line number which indicates whether the line was\n+     present in the bb file (i.e. whether it had code associate with it).\n+     Lines never executed are those which both exist, and have zero execution\n+     counts.  */\n+  char *line_exists;\n+  /* An array indexed by line number, which contains a list of branch\n+     probabilities, one for each branch on that line.  */\n+  struct arcdata **branch_probs;\n+  struct sourcefile *s_ptr;\n+  char *source_file_name;\n+  FILE *source_file;\n+  struct bb_info_list *current_graph;\n+  int count;\n+  char *cptr;\n+  long block_num;\n+  long line_num;\n+  long last_line_num;\n+  int i;\n+  struct arcdata *a_ptr;\n+  /* Buffer used for reading in lines from the source file.  */\n+  char string[STRING_SIZE];\n+  /* For calculating coverage at the file level.  */\n+  int total_source_lines;\n+  int total_source_lines_executed;\n+  int total_branches;\n+  int total_branches_executed;\n+  int total_branches_taken;\n+  int total_calls;\n+  int total_calls_executed;\n+\n+  /* Now, for each source file, allocate an array big enough to hold a count\n+     for each line.  Scan through the bb_data, and when the file name matches\n+     the current file name, then for each following line number, increment\n+     the line number execution count indicated by the execution count of\n+     the appropriate basic block.  */\n+\n+  for (s_ptr = sources; s_ptr; s_ptr = s_ptr->next)\n+    {\n+      /* If this is a relative file name, and an object directory has been\n+\t specified, then make it relative to the object directory name.  */\n+      if (*s_ptr->name != '/' && object_directory != 0\n+\t  && *object_directory != '\\0')\n+\t{\n+\t  int objdir_count = strlen (object_directory);\n+\t  source_file_name = xmalloc (objdir_count + strlen (s_ptr->name) + 2);\n+\t  strcpy (source_file_name, object_directory);\n+\t  if (object_directory[objdir_count - 1] != '/')\n+\t    source_file_name[objdir_count++] = '/';\n+\t  strcpy (source_file_name + objdir_count, s_ptr->name);\n+\t}\n+      else\n+\tsource_file_name = s_ptr->name;\n+\n+      line_counts = (long *) xmalloc (sizeof (long) * s_ptr->maxlineno);\n+      bzero ((char *) line_counts, sizeof (long) * s_ptr->maxlineno);\n+      line_exists = xmalloc (s_ptr->maxlineno);\n+      bzero (line_exists, s_ptr->maxlineno);\n+      if (output_branch_probs)\n+\t{\n+\t  branch_probs = (struct arcdata **) xmalloc (sizeof (struct arcdata **)\n+\t\t\t\t\t\t      * s_ptr->maxlineno);\n+\t  bzero ((char *) branch_probs, \n+\t\t sizeof (struct arcdata **) * s_ptr->maxlineno);\n+\t}\n+      \n+      /* There will be a zero at the beginning of the bb info, before the\n+\t first list of line numbers, so must initialize block_num to 0.  */\n+      block_num = 0;\n+      this_file = 0;\n+      current_graph = 0;\n+      {\n+\t/* Pointer into the bb_data, incremented while scanning the data.  */\n+\tchar *ptr = bb_data;\n+\tfor (count = 0; count < bb_data_size; count++)\n+\t  {\n+\t    long delim;\n+\n+\t    __fetch_long (&line_num, ptr, 4);\n+\t    ptr += 4;\n+\t    if (line_num == -1)\n+\t      {\n+\t\t/* Marks the beginning of a file name.  Check to see whether\n+\t\t   this is the filename we are currently collecting data for.  */\n+\n+\t\tif (strcmp (s_ptr->name, ptr))\n+\t\t  this_file = 0;\n+\t\telse\n+\t\t  this_file = 1;\n+\t      \n+\t\t/* Scan past the file name.  */\n+\t\tdo {\n+\t\t  count++;\n+\t\t  __fetch_long (&delim, ptr, 4);\n+\t\t  ptr += 4;\n+\t\t} while (delim != line_num);\n+\t      }\n+\t    else if (line_num == -2)\n+\t      {\n+\t\t/* Marks the start of a new function.  Advance to the next\n+\t\t   program flow graph.  */\n+\n+\t\tif (! current_graph)\n+\t\t  current_graph = bb_graph_list;\n+\t\telse\n+\t\t  {\n+\t\t    if (block_num == current_graph->num_blocks - 1)\n+\t\t      /* Last block falls through to exit.  */\n+\t\t      ;\n+\t\t    else if (block_num == current_graph->num_blocks - 2)\n+\t\t      {\n+\t\t\tif (output_branch_probs && this_file)\n+\t\t\t  calculate_branch_probs (current_graph, block_num,\n+\t\t\t\t\t\t  branch_probs, last_line_num);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tfprintf (stderr,\n+\t\t\t\t \"didn't use all bb entries of graph, function %s\\n\",\n+\t\t\t\t function_name);\n+\t\t\tfprintf (stderr, \"block_num = %d, num_blocks = %d\\n\",\n+\t\t\t\t block_num, current_graph->num_blocks);\n+\t\t      }\n+\n+\t\t    current_graph = current_graph->next;\n+\t\t    block_num = 0;\n+\n+\t\t    if (output_function_summary && this_file)\n+\t\t      function_summary ();\n+\t\t  }\n+\n+\t\tif (output_function_summary)\n+\t\t  {\n+\t\t    function_source_lines = 0;\n+\t\t    function_source_lines_executed = 0;\n+\t\t    function_branches = 0;\n+\t\t    function_branches_executed = 0;\n+\t\t    function_branches_taken = 0;\n+\t\t    function_calls = 0;\n+\t\t    function_calls_executed = 0;\n+\t\t  }\n+\n+\t\t/* Save the function name for later use.  */\n+\t\tfunction_name = ptr;\n+\n+\t\t/* Scan past the file name.  */\n+\t\tdo {\n+\t\t  count++;\n+\t\t  __fetch_long (&delim, ptr, 4);\n+\t\t  ptr += 4;\n+\t\t} while (delim != line_num);\n+\t      }\n+\t    else if (line_num == 0)\n+\t      {\n+\t\t/* Marks the end of a block.  */\n+\n+\t\tif (block_num >= current_graph->num_blocks)\n+\t\t  {\n+\t\t    fprintf (stderr, \"ERROR: too many basic blocks in .bb file %s\\n\",\n+\t\t\t     function_name);\n+\t\t    abort ();\n+\t\t  }\n+\t\t  \n+\t\tif (output_branch_probs && this_file)\n+\t\t  calculate_branch_probs (current_graph, block_num,\n+\t\t\t\t\t  branch_probs, last_line_num);\n+\n+\t\tblock_num++;\n+\t      }\n+\t    else if (this_file)\n+\t      {\n+\t\tif (output_function_summary)\n+\t\t  {\n+\t\t    if (line_exists[line_num] == 0)\n+\t\t      function_source_lines++;\n+\t\t    if (line_counts[line_num] == 0\n+\t\t\t&& current_graph->bb_graph[block_num].exec_count != 0)\n+\t\t      function_source_lines_executed++;\n+\t\t  }\n+\n+\t\t/* Accumulate execution data for this line number.  */\n+\n+\t\tline_counts[line_num]\n+\t\t  += current_graph->bb_graph[block_num].exec_count;\n+\t\tline_exists[line_num] = 1;\n+\t\tlast_line_num = line_num;\n+\t      }\n+\t  }\n+      }\n+\n+      if (output_function_summary && this_file)\n+\tfunction_summary ();\n+\n+      /* Calculate summary test coverage statistics.  */\n+\n+      total_source_lines = 0;\n+      total_source_lines_executed = 0;\n+      total_branches = 0;\n+      total_branches_executed = 0;\n+      total_branches_taken = 0;\n+      total_calls = 0;\n+      total_calls_executed = 0;\n+\n+      for (count = 1; count < s_ptr->maxlineno; count++)\n+\t{\n+\t  if (line_exists[count])\n+\t    {\n+\t      total_source_lines++;\n+\t      if (line_counts[count])\n+\t\ttotal_source_lines_executed++;\n+\t    }\n+\t  if (output_branch_probs)\n+\t    {\n+\t      for (a_ptr = branch_probs[count]; a_ptr; a_ptr = a_ptr->next)\n+\t\t{\n+\t\t  if (a_ptr->call_insn)\n+\t\t    {\n+\t\t      total_calls++;\n+\t\t      if (a_ptr->prob != -1)\n+\t\t\ttotal_calls_executed++;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      total_branches++;\n+\t\t      if (a_ptr->prob != -1)\n+\t\t\ttotal_branches_executed++;\n+\t\t      if (a_ptr->prob > 0)\n+\t\t\ttotal_branches_taken++;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (total_source_lines)\n+\tfprintf (stdout,\n+\t\t \"%6.2lf%% of %d source lines executed in file %s\\n\",\n+\t\t (((double) total_source_lines_executed / total_source_lines)\n+\t\t  * 100), total_source_lines, source_file_name);\n+      else\n+\tfprintf (stdout, \"No executable source lines in file %s\\n\",\n+\t\t source_file_name);\n+\n+      if (output_branch_probs)\n+\t{\n+\t  if (total_branches)\n+\t    {\n+\t      fprintf (stdout, \"%6.2lf%% of %d branches executed in file %s\\n\",\n+\t\t       (((double) total_branches_executed / total_branches)\n+\t\t\t* 100), total_branches, source_file_name);\n+\t      fprintf (stdout,\n+\t\t    \"%6.2lf%% of %d branches taken at least once in file %s\\n\",\n+\t\t       (((double) total_branches_taken / total_branches)\n+\t\t\t* 100), total_branches, source_file_name);\n+\t    }\n+\t  else\n+\t    fprintf (stdout, \"No branches in file %s\\n\", source_file_name);\n+\t  if (total_calls)\n+\t    fprintf (stdout, \"%6.2lf%% of %d calls executed in file %s\\n\",\n+\t\t     (((double) total_calls_executed / total_calls)\n+\t\t      * 100), total_calls, source_file_name);\n+\t  else\n+\t    fprintf (stdout, \"No calls in file %s\\n\", source_file_name);\n+\t}\n+\n+      if (output_gcov_file)\n+\t{\n+\t  /* Now the statistics are ready.  Read in the source file one line\n+\t     at a time, and output that line to the gcov file preceeded by\n+\t     its execution count if non zero.  */\n+      \n+\t  source_file = fopen (source_file_name, \"r\");\n+\t  if (source_file == NULL)\n+\t    {\n+\t      fprintf (stderr, \"Could not open source file %s.\\n\",\n+\t\t       source_file_name);\n+\t      free (line_counts);\n+\t      free (line_exists);\n+\t      continue;\n+\t    }\n+\n+\t  count = strlen (source_file_name);\n+\t  cptr = rindex (s_ptr->name, '/');\n+\t  if (cptr)\n+\t    cptr = cptr + 1;\n+\t  else\n+\t    cptr = s_ptr->name;\n+\t  if (output_long_names && strcmp (cptr, input_file_name))\n+\t    {\n+\t      gcov_file_name = xmalloc (count + 7 + strlen (input_file_name));\n+\t      \n+\t      cptr = rindex (input_file_name, '/');\n+\t      if (cptr)\n+\t\tstrcpy (gcov_file_name, cptr + 1);\n+\t      else\n+\t\tstrcpy (gcov_file_name, input_file_name);\n+\n+\t      strcat (gcov_file_name, \".\");\n+\n+\t      cptr = rindex (source_file_name, '/');\n+\t      if (cptr)\n+\t\tstrcat (gcov_file_name, cptr + 1);\n+\t      else\n+\t\tstrcat (gcov_file_name, source_file_name);\n+\t    }\n+\t  else\n+\t    {\n+\t      gcov_file_name = xmalloc (count + 6);\n+\t      cptr = rindex (source_file_name, '/');\n+\t      if (cptr)\n+\t\tstrcpy (gcov_file_name, cptr + 1);\n+\t      else\n+\t\tstrcpy (gcov_file_name, source_file_name);\n+\t    }\n+\n+\t  /* Don't strip off the ending for compatibility with tcov, since\n+\t     this results in confusion if there is more than one file with\n+\t     the same basename, e.g. tmp.c and tmp.h.  */\n+\t  strcat (gcov_file_name, \".gcov\");\n+\n+\t  gcov_file = fopen (gcov_file_name, \"w\");\n+\n+\t  if (gcov_file == NULL)\n+\t    {\n+\t      fprintf (stderr, \"Could not open output file %s.\\n\",\n+\t\t       gcov_file_name);\n+\t      fclose (source_file);\n+\t      free (line_counts);\n+\t      free (line_exists);\n+\t      continue;\n+\t    }\n+\n+\t  fprintf (stdout, \"Creating %s.\\n\", gcov_file_name);\n+\n+\t  for (count = 1; count < s_ptr->maxlineno; count++)\n+\t    {\n+\t      char *retval;\n+\t      int len;\n+\n+\t      retval = fgets (string, STRING_SIZE, source_file);\n+\n+\t      /* For lines which don't exist in the .bb file, print nothing\n+\t\t before the source line.  For lines which exist but were never\n+\t\t executed, print ###### before the source line.  Otherwise,\n+\t\t print the execution count before the source line.  */\n+\t      /* There are 16 spaces of identation added before the source line\n+\t\t so that tabs won't be messed up.  */\n+\t      if (line_exists[count])\n+\t\t{\n+\t\t  if (line_counts[count])\n+\t\t    fprintf (gcov_file, \"%12d    %s\", line_counts[count],\n+\t\t\t     string);\n+\t\t  else\n+\t\t    fprintf (gcov_file, \"      ######    %s\", string);\n+\t\t}\n+\t      else\n+\t\tfprintf (gcov_file, \"\\t\\t%s\", string);\n+\n+\t      /* In case the source file line is larger than our buffer, keep\n+\t\t reading and outputing lines until we get a newline.  */\n+\t      len = strlen (string);\n+\t      while ((len == 0 || string[strlen (string) - 1] != '\\n') &&\n+\t\t     retval != NULL)\n+\t\t{\n+\t\t  retval = fgets (string, STRING_SIZE, source_file);\n+\t\t  fputs (string, gcov_file);\n+\t\t}\n+\n+\t      if (output_branch_probs)\n+\t\t{\n+\t\t  for (i = 0, a_ptr = branch_probs[count]; a_ptr;\n+\t\t       a_ptr = a_ptr->next, i++)\n+\t\t    {\n+\t\t      if (a_ptr->call_insn)\n+\t\t\t{\n+\t\t\t  if (a_ptr->prob == -1)\n+\t\t\t    fprintf (gcov_file, \"call %d never executed\\n\", i);\n+\t\t\t  else\n+\t\t\t    fprintf (gcov_file,\n+\t\t\t\t     \"call %d returns = %d%%\\n\",\n+\t\t\t\t     i, 100 - a_ptr->prob);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  if (a_ptr->prob == -1)\n+\t\t\t    fprintf (gcov_file, \"branch %d never executed\\n\",\n+\t\t\t\t     i);\n+\t\t\t  else\n+\t\t\t    fprintf (gcov_file, \"branch %d taken = %d%%\\n\", i,\n+\t\t\t\t     a_ptr->prob);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      /* Gracefully handle errors while reading the source file.  */\n+\t      if (retval == NULL)\n+\t\t{\n+\t\t  fprintf (stderr,\n+\t\t\t   \"Unexpected EOF while reading source file %s.\\n\",\n+\t\t\t   source_file_name);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* Handle all remaining source lines.  There may be lines\n+\t     after the last line of code.  */\n+\n+\t  {\n+\t    char *retval = fgets (string, STRING_SIZE, source_file);\n+\t    while (retval != NULL)\n+\t      {\n+\t\tint len;\n+\n+\t\tfprintf (gcov_file, \"\\t\\t%s\", string);\n+\n+\t\t/* In case the source file line is larger than our buffer, keep\n+\t\t   reading and outputing lines until we get a newline.  */\n+\t\tlen = strlen (string);\n+\t\twhile ((len == 0 || string[strlen (string) - 1] != '\\n') &&\n+\t\t       retval != NULL)\n+\t\t  {\n+\t\t    retval = fgets (string, STRING_SIZE, source_file);\n+\t\t    fputs (string, gcov_file);\n+\t\t  }\n+\n+\t\tretval = fgets (string, STRING_SIZE, source_file);\n+\t      }\n+\t  }\n+\n+\t  fclose (source_file);\n+\t  fclose (gcov_file);\n+\t}\n+\n+      free (line_counts);\n+      free (line_exists);\n+    }\n+}"}, {"sha": "dcdd5fe6574157a8eb933285083b55ab7ab3cdb6", "filename": "gcc/profile.c", "status": "added", "additions": 1634, "deletions": 0, "changes": 1634, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86144b75fef3ae7025d389ea751422cbca1285d5/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86144b75fef3ae7025d389ea751422cbca1285d5/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=86144b75fef3ae7025d389ea751422cbca1285d5", "patch": "@@ -0,0 +1,1634 @@\n+/* Calculate branch probabilities, and basic block execution counts. \n+   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by James E. Wilson, UC Berkeley/Cygnus Support;\n+   based on some ideas from Dain Samples of UC Berkeley.\n+   Further mangling by Bob Manson, Cygnus Support.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* ??? Really should not put insns inside of LIBCALL sequences, when putting\n+   insns after a call, should look for the insn setting the retval, and\n+   insert the insns after that one.  */\n+\n+/* ??? Register allocation should use basic block execution counts to\n+   give preference to the most commonly executed blocks.  */\n+\n+/* ??? The .da files are not safe.  Changing the program after creating .da\n+   files or using different options when compiling with -fbranch-probabilities\n+   can result the arc data not matching the program.  Maybe add instrumented\n+   arc count to .bbg file?  Maybe check whether PFG matches the .bbg file?  */\n+\n+/* ??? Should calculate branch probabilities before instrumenting code, since\n+   then we can use arc counts to help decide which arcs to instrument.  */\n+\n+/* ??? Rearrange code so that the most frequently executed arcs become from\n+   one block to the next block (i.e. a fall through), move seldom executed\n+   code outside of loops even at the expense of adding a few branches to\n+   achieve this, see Dain Sample's UC Berkeley thesis.  */\n+\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"insn-flags.h\"\n+#include \"insn-config.h\"\n+#include \"output.h\"\n+#include <stdio.h>\n+#include \"tree.h\"\n+#include \"output.h\"\n+#include \"gcov-io.h\"\n+\n+extern char * xmalloc ();\n+extern void free ();\n+extern tree get_file_function_name ();\n+\n+/* One of these is dynamically created whenever we identify an arc in the\n+   function.  */\n+\n+struct adj_list\n+{\n+  int source;\n+  int target;\n+  int arc_count;\n+  unsigned int count_valid : 1;\n+  unsigned int on_tree : 1;\n+  unsigned int fake : 1;\n+  unsigned int fall_through : 1;\n+  rtx branch_insn;\n+  struct adj_list *pred_next;\n+  struct adj_list *succ_next;\n+};\n+\n+#define ARC_TARGET(ARCPTR) (ARCPTR->target)\n+#define ARC_SOURCE(ARCPTR) (ARCPTR->source)\n+#define ARC_COUNT(ARCPTR)  (ARCPTR->arc_count)\n+\n+/* Count the number of basic blocks, and create an array of these structures,\n+   one for each bb in the function.  */\n+\n+struct bb_info\n+{\n+  struct adj_list *succ;\n+  struct adj_list *pred;\n+  int succ_count;\n+  int pred_count;\n+  int exec_count;\n+  unsigned int count_valid : 1;\n+  unsigned int on_tree : 1;\n+  rtx first_insn;\n+};\n+\n+/* Indexed by label number, gives the basic block number containing that\n+   label.  */\n+\n+static int *label_to_bb;\n+\n+/* Number of valid entries in the label_to_bb array.  */\n+\n+static int label_to_bb_size;\n+\n+/* Indexed by block index, holds the basic block graph.  */\n+\n+static struct bb_info *bb_graph;\n+\n+/* Name and file pointer of the output file for the basic block graph.  */\n+\n+static char *bbg_file_name;\n+static FILE *bbg_file;\n+\n+/* Name and file pointer of the input file for the arc count data.  */\n+\n+static char *da_file_name;\n+static FILE *da_file;\n+\n+/* Pointer of the output file for the basic block/line number map. */\n+static FILE *bb_file;\n+\n+/* Last source file name written to bb_file. */\n+\n+static char *last_bb_file_name;\n+\n+/* Indicates whether the next line number note should be output to\n+   bb_file or not.  Used to eliminate a redundant note after an\n+   expanded inline function call.  */\n+\n+static int ignore_next_note;\n+\n+/* Used by final, for allocating the proper amount of storage for the\n+   instrumented arc execution counts.  */\n+\n+int count_instrumented_arcs;\n+\n+/* Number of executions for the return label.  */\n+\n+int return_label_execution_count;\n+\n+/* Collect statistics on the performance of this pass for the entire source\n+   file.  */\n+\n+static int total_num_blocks;\n+static int total_num_arcs;\n+static int total_num_arcs_instrumented;\n+static int total_num_blocks_created;\n+static int total_num_passes;\n+static int total_num_times_called;\n+static int total_hist_br_prob[20];\n+static int total_num_never_executed;\n+static int total_num_branches;\n+\n+/* Forward declarations.  */\n+static void init_arc PROTO((struct adj_list *, int, int, rtx));\n+static void find_spanning_tree PROTO((int));\n+static void expand_spanning_tree PROTO((int));\n+static void fill_spanning_tree PROTO((int));\n+static void init_arc_profiler PROTO((void));\n+static void output_arc_profiler PROTO((int, rtx));\n+\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+/* If non-zero, we need to output a constructor to set up the\n+   per-object-file data. */\n+static int need_func_profiler = 0;\n+\n+\f\n+/* Add arc instrumentation code to the entire insn chain.\n+\n+   F is the first insn of the chain.\n+   NUM_BLOCKS is the number of basic blocks found in F.\n+   DUMP_FILE, if nonzero, is an rtl dump file we can write to.  */\n+\n+static void\n+instrument_arcs (f, num_blocks, dump_file)\n+     rtx f;\n+     int num_blocks;\n+     FILE *dump_file;\n+{\n+  register int i;\n+  register struct adj_list *arcptr, *backptr;\n+  int num_arcs = 0;\n+  int num_instr_arcs = 0;\n+  rtx insn;\n+\n+  int neg_one = -1;\n+  int zero = 0;\n+  int inverted;\n+  rtx note;\n+\n+  /* Instrument the program start.  */\n+  /* Handle block 0 specially, since it will always be instrumented,\n+     but it doesn't have a valid first_insn or branch_insn.  We must\n+     put the instructions before the NOTE_INSN_FUNCTION_BEG note, so\n+     that they don't clobber any of the parameters of the current\n+     function.  */\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE\n+\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_FUNCTION_BEG)\n+      break;\n+  insn = PREV_INSN (insn);\n+  need_func_profiler = 1;\n+  output_arc_profiler (total_num_arcs_instrumented + num_instr_arcs++, insn);\n+\n+  for (i = 1; i < num_blocks; i++)\n+    for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+      if (! arcptr->on_tree)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Arc %d to %d instrumented\\n\", i,\n+\t\t     ARC_TARGET (arcptr));\n+\n+\t  /* Check to see if this arc is the only exit from its source block,\n+\t     or the only entrance to its target block.  In either case,\n+\t     we don't need to create a new block to instrument the arc.  */\n+\t  \n+\t  if (bb_graph[i].succ == arcptr && arcptr->succ_next == 0)\n+\t    {\n+\t      /* Instrument the source block.  */\n+\t      output_arc_profiler (total_num_arcs_instrumented\n+\t\t\t\t   + num_instr_arcs++,\n+\t\t\t\t   PREV_INSN (bb_graph[i].first_insn));\n+\t    }\n+\t  else if (arcptr == bb_graph[ARC_TARGET (arcptr)].pred\n+\t\t   && arcptr->pred_next == 0)\n+\t    {\n+\t      /* Instrument the target block.  */\n+\t      output_arc_profiler (total_num_arcs_instrumented\n+\t\t\t\t   + num_instr_arcs++, \n+\t\t\t\t   PREV_INSN (bb_graph[ARC_TARGET (arcptr)].first_insn));\n+\t    }\n+\t  else if (arcptr->fall_through)\n+\t    {\n+\t      /* This is a fall-through; put the instrumentation code after\n+\t\t the branch that ends this block.  */\n+\t      \n+\t      for (backptr = bb_graph[i].succ; backptr;\n+\t\t   backptr = backptr->succ_next)\n+\t\tif (backptr != arcptr)\n+\t\t  break;\n+\t      \n+\t      output_arc_profiler (total_num_arcs_instrumented\n+\t\t\t\t   + num_instr_arcs++,\n+\t\t\t\t   backptr->branch_insn);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Must emit a new basic block to hold the arc counting code.  */\n+\t      enum rtx_code code = GET_CODE (PATTERN (arcptr->branch_insn));\n+\n+\t      if (code == SET)\n+\t\t{\n+\t\t  /* Create the new basic block right after the branch.\n+\t\t     Invert the branch so that it jumps past the end of the new\n+\t\t     block.  The new block will consist of the instrumentation\n+\t\t     code, and a jump to the target of this arc.  */\n+\t\t  int this_is_simplejump = simplejump_p (arcptr->branch_insn);\n+\t\t  rtx new_label = gen_label_rtx ();\n+\t\t  rtx old_label, set_src;\n+\t\t  rtx after = arcptr->branch_insn;\n+\t\t  \n+\t\t  /* Simplejumps can't reach here.  */\n+\t\t  if (this_is_simplejump)\n+\t\t    abort ();\n+\n+\t\t  /* We can't use JUMP_LABEL, because it won't be set if we\n+\t\t     are compiling without optimization.  */\n+\n+\t\t  set_src = SET_SRC (single_set (arcptr->branch_insn));\n+\t\t  if (GET_CODE (set_src) == LABEL_REF)\n+\t\t    old_label = set_src;\n+\t\t  else if (GET_CODE (set_src) != IF_THEN_ELSE)\n+\t\t    abort ();\n+\t\t  else if (XEXP (set_src, 1) == pc_rtx)\n+\t\t    old_label = XEXP (XEXP (set_src, 2), 0);\n+\t\t  else\n+\t\t    old_label = XEXP (XEXP (set_src, 1), 0);\n+\n+\t\t  /* Set the JUMP_LABEL so that redirect_jump will work.  */\n+\t\t  JUMP_LABEL (arcptr->branch_insn) = old_label;\n+\n+\t\t  /* Add a use for OLD_LABEL that will be needed when we emit\n+\t\t     the JUMP_INSN below.  If we don't do this here,\n+\t\t     `invert_jump' might delete it for us.  We must add two\n+\t\t     when not optimizing, because the NUSES is zero now,\n+\t\t     but must be at least two to prevent the label from being\n+\t\t     deleted.  */\n+\t\t  LABEL_NUSES (old_label) += 2;\n+\t\t  \n+\t\t  /* Emit the insns for the new block in reverse order,\n+\t\t     since that is most convenient.  */\n+\n+\t\t  if (this_is_simplejump)\n+\t\t    {\n+\t\t      after = NEXT_INSN (arcptr->branch_insn);\n+\t\t      if (! redirect_jump (arcptr->branch_insn, new_label))\n+\t\t\t/* Don't know what to do if this branch won't\n+\t\t\t   redirect.  */\n+\t\t\tabort ();\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (! invert_jump (arcptr->branch_insn, new_label))\n+\t\t\t/* Don't know what to do if this branch won't invert.  */\n+\t\t\tabort ();\n+\n+\t\t      emit_label_after (new_label, after);\n+\t\t      LABEL_NUSES (new_label)++;\n+\t\t    }\n+\t\t  emit_barrier_after (after);\n+\t\t  emit_jump_insn_after (gen_jump (old_label), after);\n+\t\t  JUMP_LABEL (NEXT_INSN (after)) = old_label;\n+\t\t  \n+\t\t  /* Instrument the source arc.  */\n+\t\t  output_arc_profiler (total_num_arcs_instrumented\n+\t\t\t\t       + num_instr_arcs++,\n+\t\t\t\t       after);\n+\t\t  if (this_is_simplejump)\n+\t\t    {\n+\t\t      emit_label_after (new_label, after);\n+\t\t      LABEL_NUSES (new_label)++;\n+\t\t    }\n+\t\t}\n+\t      else if (code == ADDR_VEC || code == ADDR_DIFF_VEC)\n+\t\t{\n+\t\t  /* A table jump.  Create a new basic block immediately\n+\t\t     after the table, by emitting a barrier, a label, a\n+\t\t     counting note, and a jump to the old label.  Put the\n+\t\t     new label in the table.  */\n+\t\t  \n+\t\t  rtx new_label = gen_label_rtx ();\n+\t\t  rtx old_lref, new_lref;\n+\t\t  int index;\n+\t\t  \n+\t\t  /* Must determine the old_label reference, do this\n+\t\t     by counting the arcs after this one, which will\n+\t\t     give the index of our label in the table.  */\n+\t\t  \n+\t\t  index = 0;\n+\t\t  for (backptr = arcptr->succ_next; backptr;\n+\t\t       backptr = backptr->succ_next)\n+\t\t    index++;\n+\t\t  \n+\t\t  old_lref = XVECEXP (PATTERN (arcptr->branch_insn),\n+\t\t\t\t      (code == ADDR_DIFF_VEC), index);\n+\t\t  \n+\t\t  /* Emit the insns for the new block in reverse order,\n+\t\t     since that is most convenient.  */\n+\t\t  emit_jump_insn_after (gen_jump (XEXP (old_lref, 0)),\n+\t\t\t\t\tarcptr->branch_insn);\n+\t\t  JUMP_LABEL (NEXT_INSN (arcptr->branch_insn))\n+\t\t    = XEXP (old_lref, 0);\n+\n+\t\t  /* Instrument the source arc.  */\n+\t\t  output_arc_profiler (total_num_arcs_instrumented\n+\t\t\t\t       + num_instr_arcs++,\n+\t\t\t\t       arcptr->branch_insn);\n+\n+\t\t  emit_label_after (new_label, arcptr->branch_insn);\n+\t\t  LABEL_NUSES (NEXT_INSN (arcptr->branch_insn))++;\n+\t\t  emit_barrier_after (arcptr->branch_insn);\n+\t\t  \n+\t\t  /* Fix up the table jump.  */\n+\t\t  new_lref = gen_rtx (LABEL_REF, Pmode, new_label);\n+\t\t  XVECEXP (PATTERN (arcptr->branch_insn),\n+\t\t\t   (code == ADDR_DIFF_VEC), index) = new_lref;\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\n+\t      num_arcs += 1;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"Arc %d to %d needed new basic block\\n\", i,\n+\t\t\t ARC_TARGET (arcptr));\n+\t    }\n+\t}\n+  \n+  total_num_arcs_instrumented += num_instr_arcs;\n+  count_instrumented_arcs = total_num_arcs_instrumented;\n+\n+  total_num_blocks_created += num_arcs;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"%d arcs instrumented\\n\", num_instr_arcs);\n+      fprintf (dump_file, \"%d extra basic blocks created\\n\", num_arcs);\n+    }\n+}\n+\n+/* Output STRING to bb_file, surrounded by DELIMITER.  */\n+\n+static void\n+output_gcov_string (string, delimiter)\n+     char *string;\n+     long delimiter;\n+{\n+  long temp;\n+\t\t\t\n+  /* Write a delimiter to indicate that a file name follows.  */\n+  __write_long (delimiter, bb_file, 4);\n+\n+  /* Write the string.  */\n+  temp = strlen (string) + 1;\n+  fwrite (string, temp, 1, bb_file);\n+\n+  /* Append a few zeros, to align the output to a 4 byte boundary.  */\n+  temp = temp & 0x3;\n+  if (temp)\n+    {\n+      char c[4];\n+\n+      c[0] = c[1] = c[2] = c[3] = 0;\n+      fwrite (c, sizeof (char), 4 - temp, bb_file);\n+    }\n+\n+  /* Store another delimiter in the .bb file, just to make it easy to find the\n+     end of the file name.  */\n+  __write_long (delimiter, bb_file, 4);\n+}\n+\f\n+/* Instrument and/or analyze program behavior based on program flow graph.\n+   In either case, this function builds a flow graph for the function being\n+   compiled.  The flow graph is stored in BB_GRAPH.\n+\n+   When FLAG_PROFILE_ARCS is nonzero, this function instruments the arcs in\n+   the flow graph that are needed to reconstruct the dynamic behavior of the\n+   flow graph.\n+\n+   When FLAG_BRANCH_PROBABILITIES is nonzero, this function reads auxilliary\n+   information from a data file containing arc count information from previous\n+   executions of the function being compiled.  In this case, the flow graph is\n+   annotated with actual execution counts, which are later propagated into the\n+   rtl for optimization purposes.\n+\n+   Main entry point of this file.  */\n+\n+void\n+branch_prob (f, dump_file)\n+     rtx f;\n+     FILE *dump_file;\n+{\n+  int i, num_blocks;\n+  int dest;\n+  rtx insn;\n+  struct adj_list *arcptr;\n+  int num_arcs, changes, passes;\n+  int total, prob;\n+  int hist_br_prob[20], num_never_executed, num_branches;\n+  /* Set to non-zero if we got bad count information.  */\n+  int bad_counts = 0;\n+\n+  /* start of a function.  */\n+  if (flag_test_coverage)\n+    output_gcov_string (current_function_name, (long) -2);\n+\n+  /* Execute this only if doing arc profiling or branch probabilities.  */\n+  if (! profile_arc_flag && ! flag_branch_probabilities\n+      && ! flag_test_coverage)\n+    abort ();\n+\n+  total_num_times_called++;\n+\n+  /* Create an array label_to_bb of ints of size max_label_num.  */\n+  label_to_bb_size = max_label_num ();\n+  label_to_bb = (int *) oballoc (label_to_bb_size * sizeof (int));\n+  bzero ((char *) label_to_bb, label_to_bb_size * sizeof (int));\n+\n+  /* Scan the insns in the function, count the number of basic blocks\n+     present.  When a code label is passed, set label_to_bb[label] = bb\n+     number.  */\n+\n+  /* The first block found will be block 1, so that function entry can be\n+     block 0.  */\n+\n+  {\n+    register RTX_CODE prev_code = JUMP_INSN;\n+    register RTX_CODE code;\n+    register rtx insn;\n+    register int i;\n+    int block_separator_emitted = 0;\n+\n+    ignore_next_note = 0;\n+\n+    for (insn = NEXT_INSN (f), i = 0; insn; insn = NEXT_INSN (insn))\n+      {\n+\tcode = GET_CODE (insn);\n+\n+\tif (code == BARRIER)\n+\t  ;\n+\telse if (code == CODE_LABEL)\n+\t  /* This label is part of the next block, but we can't increment\n+\t     block number yet since there might be multiple labels.  */\n+\t  label_to_bb[CODE_LABEL_NUMBER (insn)] = i + 1;\n+\t/* We make NOTE_INSN_SETJMP notes into a block of their own, so that\n+\t   they can be the target of the fake arc for the setjmp call.\n+\t   This avoids creating cycles of fake arcs, which would happen if\n+\t   the block after the setjmp call contained a call insn.  */\n+\telse if ((prev_code == JUMP_INSN || prev_code == CALL_INSN\n+\t\t  || prev_code == CODE_LABEL || prev_code == BARRIER)\n+\t\t && (GET_RTX_CLASS (code) == 'i'\n+\t\t     || (code == NOTE &&\n+\t\t\t NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)))\n+\t  {\n+\t    i += 1;\n+\n+\t    /* Emit the block separator if it hasn't already been emitted.  */\n+\t    if (flag_test_coverage && ! block_separator_emitted)\n+\t      {\n+\t\t/* Output a zero to the .bb file to indicate that a new\n+\t\t   block list is starting.  */\n+\t\t__write_long (0, bb_file, 4);\n+\t      }\n+\t    block_separator_emitted = 0;\n+\t  }\n+\t/* If flag_test_coverage is true, then we must add an entry to the\n+\t   .bb file for every note.  */\n+\telse if (code == NOTE && flag_test_coverage)\n+\t  {\n+\t    /* Must ignore the line number notes that immediately follow the\n+\t       end of an inline function to avoid counting it twice.  There\n+\t       is a note before the call, and one after the call.  */\n+\t    if (NOTE_LINE_NUMBER (insn) == NOTE_REPEATED_LINE_NUMBER)\n+\t      ignore_next_note = 1;\n+\t    else if (NOTE_LINE_NUMBER (insn) > 0)\n+\t      {\n+\t\tif (ignore_next_note)\n+\t\t  ignore_next_note = 0;\n+\t\telse\n+\t\t  {\n+\t\t    /* Emit a block separator here to ensure that a NOTE\n+\t\t       immediately following a JUMP_INSN or CALL_INSN will end\n+\t\t       up in the right basic block list.  */\n+\t\t    if ((prev_code == JUMP_INSN || prev_code == CALL_INSN\n+\t\t\t || prev_code == CODE_LABEL || prev_code == BARRIER)\n+\t\t\t&& ! block_separator_emitted)\n+\t\t      {\n+\t\t\t/* Output a zero to the .bb file to indicate that\n+\t\t\t   a new block list is starting.  */\n+\t\t\t__write_long (0, bb_file, 4);\n+\n+\t\t\tblock_separator_emitted = 1;\n+\t\t      }\n+\t\t    \n+\t\t    /* If this is a new source file, then output the file's\n+\t\t       name to the .bb file.  */\n+\t\t    if (! last_bb_file_name\n+\t\t\t|| strcmp (NOTE_SOURCE_FILE (insn),\n+\t\t\t\t   last_bb_file_name))\n+\t\t      {\n+\t\t\tif (last_bb_file_name)\n+\t\t\t  free (last_bb_file_name);\n+\t\t\tlast_bb_file_name =\n+\t\t\t  xmalloc (strlen (NOTE_SOURCE_FILE (insn)) + 1);\n+\t\t\tstrcpy (last_bb_file_name, NOTE_SOURCE_FILE (insn));\n+\t\t\toutput_gcov_string (NOTE_SOURCE_FILE (insn), (long)-1);\n+\t\t      }\n+\n+\t\t    /* Output the line number to the .bb file.  Must be done\n+\t\t       after the output_bb_profile_data() call, and after the\n+\t\t       file name is written, to ensure that it is correctly\n+\t\t       handled by gcov.  */\n+\t\t    __write_long (NOTE_LINE_NUMBER (insn), bb_file, 4);\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tif (code != NOTE)\n+\t  prev_code = code;\n+\telse if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+\t  prev_code = CALL_INSN;\n+      }\n+\n+    /* Allocate last `normal' entry for bb_graph.  */\n+\n+    /* The last insn was a jump, call, or label.  In that case we have\n+       a block at the end of the function with no insns.  */\n+    if (prev_code == JUMP_INSN || prev_code == CALL_INSN\n+\t|| prev_code == CODE_LABEL || prev_code == BARRIER)\n+      {\n+\ti++;\n+\n+\t/* Emit the block separator if it hasn't already been emitted.  */\n+\tif (flag_test_coverage && ! block_separator_emitted)\n+\t  {\n+\t    /* Output a zero to the .bb file to indicate that a new\n+\t       block list is starting.  */\n+\t    __write_long (0, bb_file, 4);\n+\t  }\n+      }\n+\n+    /* Create another block to stand for EXIT, and make all return insns, and\n+       the last basic block point here.  Add one more to account for block\n+       zero.  */\n+    num_blocks = i + 2;\n+  }\n+\n+  total_num_blocks += num_blocks;\n+  if (dump_file)\n+    fprintf (dump_file, \"%d basic blocks\\n\", num_blocks);\n+\n+  /* If we are only doing test coverage here, then return now.  */\n+  if (! profile_arc_flag && ! flag_branch_probabilities)\n+    return;\n+\n+  /* Create and initialize the arrays that will hold bb_graph\n+     and execution count info.  */\n+\n+  bb_graph = (struct bb_info *) alloca (num_blocks * sizeof (struct bb_info));\n+  bzero ((char *) bb_graph, (sizeof (struct bb_info) * num_blocks));\n+\n+  {\n+    /* Scan the insns again:\n+       - at the entry to each basic block, increment the predecessor count\n+       (and successor of previous block) if it is a fall through entry,\n+       create adj_list entries for this and the previous block\n+       - at each jump insn, increment predecessor/successor counts for\n+       target/source basic blocks, add this insn to pred/succ lists.\n+\n+       This also cannot be broken out as a separate subroutine\n+       because it uses `alloca'.  */\n+\n+    register RTX_CODE prev_code = JUMP_INSN;\n+    register RTX_CODE code;\n+    register rtx insn;\n+    register int i;\n+    int fall_through = 0;\n+    struct adj_list *arcptr;\n+    int dest;\n+\n+    /* Block 0 always falls through to block 1.  */\n+    num_arcs = 0;\n+    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n+    init_arc (arcptr, 0, 1, 0);\n+    arcptr->fall_through = 1;\n+    num_arcs++;\n+\n+    /* Add a fake fall through arc from the last block to block 0, to make the\n+       graph complete.  */\n+    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n+    init_arc (arcptr, num_blocks - 1, 0, 0);\n+    arcptr->fake = 1;\n+    num_arcs++;\n+\n+    /* Exit must be one node of the graph, and all exits from the function\n+       must point there.  When see a return branch, must point the arc to the\n+       exit node.  */\n+\n+    /* Must start scan with second insn in function as above.  */\n+    for (insn = NEXT_INSN (f), i = 0; insn; insn = NEXT_INSN (insn))\n+      {\n+\tcode = GET_CODE (insn);\n+\n+\tif (code == BARRIER)\n+\t  fall_through = 0;\n+\telse if (code == CODE_LABEL)\n+\t  ;\n+\t/* We make NOTE_INSN_SETJMP notes into a block of their own, so that\n+\t   they can be the target of the fake arc for the setjmp call.\n+\t   This avoids creating cycles of fake arcs, which would happen if\n+\t   the block after the setjmp call ended with a call.  */\n+\telse if ((prev_code == JUMP_INSN || prev_code == CALL_INSN\n+\t\t  || prev_code == CODE_LABEL || prev_code == BARRIER)\n+\t\t && (GET_RTX_CLASS (code) == 'i'\n+\t\t     || (code == NOTE &&\n+\t\t\t NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)))\n+\t  {\n+\t    /* This is the first insn of the block.  */\n+\t    i += 1;\n+\t    if (fall_through)\n+\t      {\n+\t\tarcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n+\t\tinit_arc (arcptr, i - 1, i, 0);\n+\t\tarcptr->fall_through = 1;\n+\n+\t\tnum_arcs++;\n+\t      }\n+\t    fall_through = 1;\n+\t    bb_graph[i].first_insn = insn;\n+\t  }\n+\telse if (code == NOTE)\n+\t  ;\n+\n+\tif (code == CALL_INSN)\n+\t  {\n+\t    /* In the normal case, the call returns, and this is just like\n+\t       a branch fall through.  */\n+\t    fall_through = 1;\n+\n+\t    /* Setjmp may return more times than called, so to make the graph\n+\t       solvable, add a fake arc from the function entrance to the\n+\t       next block.\n+\n+\t       All other functions may return fewer times than called (if\n+\t       a descendent call longjmp or exit), so to make the graph\n+\t       solvable, add a fake arc to the function exit from the\n+\t       current block.\n+\n+\t       Distinguish the cases by checking for a SETJUMP note.\n+\t       A call_insn can be the last ins of a function, so must check\n+\t       to see if next insn actually exists.  */\n+\t    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n+\t    if (NEXT_INSN (insn)\n+\t\t&& GET_CODE (NEXT_INSN (insn)) == NOTE\n+\t\t&& NOTE_LINE_NUMBER (NEXT_INSN (insn)) == NOTE_INSN_SETJMP)\n+\t      init_arc (arcptr, 0, i+1, insn);\n+\t    else\n+\t      init_arc (arcptr, i, num_blocks-1, insn);\n+\t    arcptr->fake = 1;\n+\t    num_arcs++;\n+\t  }\n+\telse if (code == JUMP_INSN)\n+\t  {\n+\t    rtx tem, pattern = PATTERN (insn);\n+\t    rtx tablejump = 0;\n+\n+\t    /* If running without optimization, then jump label won't be valid,\n+\t       so we must search for the destination label in that case.\n+\t       We have to handle tablejumps and returns specially anyways, so\n+\t       we don't check the JUMP_LABEL at all here.  */\n+\n+\t    if (GET_CODE (pattern) == PARALLEL)\n+\t      {\n+\t\t/* This assumes that PARALLEL jumps are tablejump entry\n+\t\t   jumps.  */\n+\t\t/* Make an arc from this jump to the label of the\n+\t\t   jump table.  This will instrument the number of\n+\t\t   times the switch statement is executed.  */\n+\t\tif (GET_CODE (XVECEXP (pattern, 0, 1)) == USE)\n+\t\t  {\n+\t\t    tem = XEXP (XVECEXP (pattern, 0, 1), 0);\n+\t\t    if (GET_CODE (tem) != LABEL_REF)\n+\t\t      abort ();\n+\t\t    dest = label_to_bb[CODE_LABEL_NUMBER (XEXP (tem, 0))];\n+\t\t  }\n+\t\telse if (GET_CODE (XVECEXP (pattern, 0, 0)) == SET\n+\t\t\t && SET_DEST (XVECEXP (pattern, 0, 0)) == pc_rtx)\n+\t\t  {\n+\t\t    tem = SET_SRC (XVECEXP (pattern, 0, 0));\n+\t\t    if (GET_CODE (tem) == PLUS\n+\t\t\t&& GET_CODE (XEXP (tem, 1)) == LABEL_REF)\n+\t\t      {\n+\t\t\ttem = XEXP (tem, 1);\n+\t\t\tdest = label_to_bb [CODE_LABEL_NUMBER (XEXP (tem, 0))];\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  abort ();\n+\t      }\n+\t    else if (GET_CODE (pattern) == ADDR_VEC\n+\t\t     || GET_CODE (pattern) == ADDR_DIFF_VEC)\n+\t      tablejump = pattern;\n+\t    else if (GET_CODE (pattern) == RETURN)\n+\t      dest = num_blocks - 1;\n+\t    else if ((tem = SET_SRC (pattern))\n+\t\t     && GET_CODE (tem) == LABEL_REF)\n+\t      dest = label_to_bb[CODE_LABEL_NUMBER (XEXP (tem, 0))];\n+\t    else\n+\t      {\n+\t\trtx label_ref;\n+\n+\t\t/* Must be an IF_THEN_ELSE branch.  */\n+\t\tif (GET_CODE (tem) != IF_THEN_ELSE)\n+\t\t  abort ();\n+\t\tif (XEXP (tem, 1) != pc_rtx)\n+\t\t  label_ref = XEXP (tem, 1);\n+\t\telse\n+\t\t  label_ref = XEXP (tem, 2);\n+\t\tdest = label_to_bb[CODE_LABEL_NUMBER (XEXP (label_ref, 0))];\n+\t      }\n+\n+\t    if (tablejump)\n+\t      {\n+\t\tint diff_vec_p = GET_CODE (tablejump) == ADDR_DIFF_VEC;\n+\t\tint len = XVECLEN (tablejump, diff_vec_p);\n+\t\tint k;\n+\n+\t\tfor (k = 0; k < len; k++)\n+\t\t  {\n+\t\t    rtx tem = XEXP (XVECEXP (tablejump, diff_vec_p, k), 0);\n+\t\t    dest = label_to_bb[CODE_LABEL_NUMBER (tem)];\n+\n+\t\t    arcptr = (struct adj_list *) alloca (sizeof(struct adj_list));\n+\t\t    init_arc (arcptr, i, dest, insn);\n+\n+\t\t    num_arcs++;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\tarcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n+\t\tinit_arc (arcptr, i, dest, insn);\n+\n+\t\tnum_arcs++;\n+\t      }\n+\n+\t    /* Determine whether or not this jump will fall through.\n+\t       Unconditional jumps and returns are not always followed by\n+\t       barriers.  */\n+\t    pattern = PATTERN (insn);\n+\t    if (GET_CODE (pattern) == PARALLEL\n+\t\t|| GET_CODE (pattern) == RETURN)\n+\t      fall_through = 0;\n+\t    else if (GET_CODE (pattern) == ADDR_VEC\n+\t\t     || GET_CODE (pattern) == ADDR_DIFF_VEC)\n+\t      /* These aren't actually jump insns, but they never fall\n+\t\t through, so...  */\n+\t      fall_through = 0;\n+\t    else\n+\t      {\n+\t\tif (GET_CODE (pattern) != SET || SET_DEST (pattern) != pc_rtx)\n+\t\t  abort ();\n+\t\tif (GET_CODE (SET_SRC (pattern)) != IF_THEN_ELSE)\n+\t\t  fall_through = 0;\n+\t      }\n+\t  }\n+\n+\tif (code != NOTE)\n+\t  prev_code = code;\n+\telse if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+\t  prev_code = CALL_INSN;\n+      }\n+\n+    /* If the code at the end of the function would give a new block, then\n+       do the following.  */\n+\n+    if (prev_code == JUMP_INSN || prev_code == CALL_INSN\n+\t|| prev_code == CODE_LABEL || prev_code == BARRIER)\n+      {\n+\tif (fall_through)\n+\t  {\n+\t    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n+\t    init_arc (arcptr, i, i + 1, 0);\n+\t    arcptr->fall_through = 1;\n+\n+\t    num_arcs++;\n+\t  }\n+\t  \n+\t/* This may not be a real insn, but that should not cause a problem.  */\n+\tbb_graph[i+1].first_insn = get_last_insn ();\n+      }\n+\n+    /* There is always a fake arc from the last block of the function\n+       to the function exit block.  */\n+    arcptr = (struct adj_list *) alloca (sizeof (struct adj_list));\n+    init_arc (arcptr, num_blocks-2, num_blocks-1, 0);\n+    arcptr->fake = 1;\n+    num_arcs++;\n+  }\n+\n+  total_num_arcs += num_arcs;\n+  if (dump_file)\n+    fprintf (dump_file, \"%d arcs\\n\", num_arcs);\n+\n+  /* Create spanning tree from basic block graph, mark each arc that is\n+     on the spanning tree.  */\n+\n+  /* To reduce the instrumentation cost, make two passes over the tree.\n+     First, put as many must-split (crowded and fake) arcs on the tree as\n+     possible, then on the second pass fill in the rest of the tree.\n+     Note that the spanning tree is considered undirected, so that as many\n+     must-split arcs as possible can be put on it.\n+\n+     Fallthough arcs which are crowded should not be chosen on the first\n+     pass, since they do not require creating a new basic block.  These\n+     arcs will have fall_through set.  */\n+\n+  find_spanning_tree (num_blocks);\n+\n+  /* Create a .bbg file from which gcov can reconstruct the basic block\n+     graph.  First output the number of basic blocks, and then for every\n+     arc output the source and target basic block numbers.\n+     NOTE: The format of this file must be compatible with gcov.  */\n+\n+  if (flag_test_coverage)\n+    {\n+      int flag_bits;\n+\n+      __write_long (num_blocks, bbg_file, 4);\n+      __write_long (num_arcs, bbg_file, 4);\n+\n+      for (i = 0; i < num_blocks; i++)\n+\t{\n+\t  long count = 0;\n+\t  for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+\t    count++;\n+\t  __write_long (count, bbg_file, 4);\n+\n+\t  for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+\t    {\n+\t      flag_bits = 0;\n+\t      if (arcptr->on_tree)\n+\t\tflag_bits |= 0x1;\n+\t      if (arcptr->fake)\n+\t\tflag_bits |= 0x2;\n+\t      if (arcptr->fall_through)\n+\t\tflag_bits |= 0x4;\n+\n+\t      __write_long (ARC_TARGET (arcptr), bbg_file, 4);\n+\t      __write_long (flag_bits, bbg_file, 4);\n+\t    }\n+\t}\n+\n+      /* Emit a -1 to separate the list of all arcs from the list of\n+\t loop back edges that follows.  */\n+      __write_long (-1, bbg_file, 4);\n+    }\n+\n+  /* For each arc not on the spanning tree, add counting code as rtl.  */\n+\n+  if (profile_arc_flag)\n+    instrument_arcs (f, num_blocks, dump_file);\n+\n+  /* Execute the rest only if doing branch probabilities.  */\n+  if (! flag_branch_probabilities)\n+    return;\n+\n+  /* For each arc not on the spanning tree, set its execution count from\n+     the .da file.  */\n+\n+  /* The first count in the .da file is the number of times that the function\n+     was entered.  This is the exec_count for block zero.  */\n+\n+  num_arcs = 0;\n+  for (i = 0; i < num_blocks; i++)\n+    for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+      if (! arcptr->on_tree)\n+\t{\n+\t  num_arcs++;\n+\t  if (da_file)\n+\t    {\n+\t      long value;\n+\t      __read_long (&value, da_file, 8);\n+\t      ARC_COUNT (arcptr) = value;\n+\t    }\n+\t  else\n+\t    ARC_COUNT (arcptr) = 0;\n+\t  arcptr->count_valid = 1;\n+\t  bb_graph[i].succ_count--;\n+\t  bb_graph[ARC_TARGET (arcptr)].pred_count--;\n+\t}\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"%d arc counts read\\n\", num_arcs);\n+\n+  /* For every block in the file,\n+     - if every exit/entrance arc has a known count, then set the block count\n+     - if the block count is known, and every exit/entrance arc but one has\n+       a known execution count, then set the count of the remaining arc\n+\n+     As arc counts are set, decrement the succ/pred count, but don't delete\n+     the arc, that way we can easily tell when all arcs are known, or only\n+     one arc is unknown.  */\n+\n+  /* The order that the basic blocks are iterated through is important.\n+     Since the code that finds spanning trees starts with block 0, low numbered\n+     arcs are put on the spanning tree in preference to high numbered arcs.\n+     Hence, most instrumented arcs are at the end.  Graph solving works much\n+     faster if we propagate numbers from the end to the start.\n+     \n+     This takes an average of slightly more than 3 passes.  */\n+\n+  changes = 1;\n+  passes = 0;\n+  while (changes)\n+    {\n+      passes++;\n+      changes = 0;\n+\n+      for (i = num_blocks - 1; i >= 0; i--)\n+\t{\n+\t  struct bb_info *binfo = &bb_graph[i];\n+\t  if (! binfo->count_valid)\n+\t    {\n+\t      if (binfo->succ_count == 0)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  for (arcptr = binfo->succ; arcptr;\n+\t\t       arcptr = arcptr->succ_next)\n+\t\t    total += ARC_COUNT (arcptr);\n+\t\t  binfo->exec_count = total;\n+\t\t  binfo->count_valid = 1;\n+\t\t  changes = 1;\n+\t\t}\n+\t      else if (binfo->pred_count == 0)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  for (arcptr = binfo->pred; arcptr;\n+\t\t       arcptr = arcptr->pred_next)\n+\t\t    total += ARC_COUNT (arcptr);\n+\t\t  binfo->exec_count = total;\n+\t\t  binfo->count_valid = 1;\n+\t\t  changes = 1;\n+\t\t}\n+\t    }\n+\t  if (binfo->count_valid)\n+\t    {\n+\t      if (binfo->succ_count == 1)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  /* One of the counts will be invalid, but it is zero,\n+\t\t     so adding it in also doesn't hurt.  */\n+\t\t  for (arcptr = binfo->succ; arcptr;\n+\t\t       arcptr = arcptr->succ_next)\n+\t\t    total += ARC_COUNT (arcptr);\n+\t\t  /* Calculate count for remaining arc by conservation.  */\n+\t\t  total = binfo->exec_count - total;\n+\t\t  /* Search for the invalid arc, and set its count.  */\n+\t\t  for (arcptr = binfo->succ; arcptr;\n+\t\t       arcptr = arcptr->succ_next)\n+\t\t    if (! arcptr->count_valid)\n+\t\t      break;\n+\t\t  if (! arcptr)\n+\t\t    abort ();\n+\t\t  arcptr->count_valid = 1;\n+\t\t  ARC_COUNT (arcptr) = total;\n+\t\t  binfo->succ_count--;\n+\t\t  \n+\t\t  bb_graph[ARC_TARGET (arcptr)].pred_count--;\n+\t\t  changes = 1;\n+\t\t}\n+\t      if (binfo->pred_count == 1)\n+\t\t{\n+\t\t  total = 0;\n+\t\t  /* One of the counts will be invalid, but it is zero,\n+\t\t     so adding it in also doesn't hurt.  */\n+\t\t  for (arcptr = binfo->pred; arcptr;\n+\t\t       arcptr = arcptr->pred_next)\n+\t\t    total += ARC_COUNT (arcptr);\n+\t\t  /* Calculate count for remaining arc by conservation.  */\n+\t\t  total = binfo->exec_count - total;\n+\t\t  /* Search for the invalid arc, and set its count.  */\n+\t\t  for (arcptr = binfo->pred; arcptr;\n+\t\t       arcptr = arcptr->pred_next)\n+\t\t    if (! arcptr->count_valid)\n+\t\t      break;\n+\t\t  if (! arcptr)\n+\t\t    abort ();\n+\t\t  arcptr->count_valid = 1;\n+\t\t  ARC_COUNT (arcptr) = total;\n+\t\t  binfo->pred_count--;\n+\t\t  \n+\t\t  bb_graph[ARC_SOURCE (arcptr)].succ_count--;\n+\t\t  changes = 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  total_num_passes += passes;\n+  if (dump_file)\n+    fprintf (dump_file, \"Graph solving took %d passes.\\n\\n\", passes);\n+\n+  /* If the graph has been correctly solved, every block will have a\n+     succ and pred count of zero.  */\n+  for (i = 0; i < num_blocks; i++)\n+    {\n+      struct bb_info *binfo = &bb_graph[i];\n+      if (binfo->succ_count || binfo->pred_count)\n+\tabort ();\n+    }\n+\n+  /* For every arc, calculate its branch probability and add a reg_note\n+     to the branch insn to indicate this.  */\n+\n+  for (i = 0; i < 20; i++)\n+    hist_br_prob[i] = 0;\n+  num_never_executed = 0;\n+  num_branches = 0;\n+\n+  for (i = 0; i < num_blocks; i++)\n+    {\n+      struct bb_info *binfo = &bb_graph[i];\n+\n+      total = binfo->exec_count;\n+      for (arcptr = binfo->succ; arcptr; arcptr = arcptr->succ_next)\n+\t{\n+\t  if (arcptr->branch_insn)\n+\t    {\n+\t      /* This calculates the branch probability as an integer between\n+\t\t 0 and REG_BR_PROB_BASE, properly rounded to the nearest\n+\t\t integer.  Perform the arithmetic in double to avoid\n+\t\t overflowing the range of ints.  */\n+\n+\t      if (total == 0)\n+\t\tprob = -1;\n+\t      else\n+\t\t{\n+\t\t  rtx pat = PATTERN (arcptr->branch_insn);\n+\t\t  \n+\t\t  prob = (((double)ARC_COUNT (arcptr) * REG_BR_PROB_BASE)\n+\t\t\t  + (total >> 1)) / total;\n+\t\t  if (prob < 0 || prob > REG_BR_PROB_BASE)\n+\t\t    {\n+\t\t      if (dump_file)\n+\t\t\tfprintf (dump_file, \"bad count: prob for %d-%d thought to be %d (forcibly normalized)\\n\",\n+\t\t\t\t ARC_SOURCE (arcptr), ARC_TARGET (arcptr),\n+\t\t\t\t prob);\n+\n+\t\t      bad_counts = 1;\n+\t\t      prob = REG_BR_PROB_BASE / 2;\n+\t\t    }\n+\t\t  \n+\t\t  /* Match up probability with JUMP pattern.  */\n+\n+\t\t  if (GET_CODE (pat) == SET\n+\t\t      && GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE)\n+\t\t    {\n+\t\t      if (ARC_TARGET (arcptr) == ARC_SOURCE (arcptr) + 1)\n+\t\t\t{\n+\t\t\t  /* A fall through arc should never have a\n+\t\t\t     branch insn.  */\n+\t\t\t  abort ();\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* This is the arc for the taken branch.  */\n+\t\t\t  if (GET_CODE (XEXP (SET_SRC (pat), 2)) != PC)\n+\t\t\t    prob = REG_BR_PROB_BASE - prob;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      \n+\t      if (prob == -1)\n+\t\tnum_never_executed++;\n+\t      else\n+\t\t{\n+\t\t  int index = prob * 20 / REG_BR_PROB_BASE;\n+\t\t  if (index == 20)\n+\t\t    index = 19;\n+\t\t  hist_br_prob[index]++;\n+\t\t}\n+\t      num_branches++;\n+\t      \n+\t      REG_NOTES (arcptr->branch_insn)\n+\t\t= gen_rtx (EXPR_LIST, REG_BR_PROB, GEN_INT (prob),\n+\t\t\t   REG_NOTES (arcptr->branch_insn));\n+\t    }\n+\t}\n+\n+      /* Add a REG_EXEC_COUNT note to the first instruction of this block.  */\n+      if (! binfo->first_insn \n+\t  || GET_RTX_CLASS (GET_CODE (binfo->first_insn)) != 'i')\n+\t{\n+\t  /* Block 0 is a fake block representing function entry, and does\n+\t     not have a real first insn.  The second last block might not\n+\t     begin with a real insn.  */\n+\t  if (i == num_blocks - 1)\n+\t    return_label_execution_count = total;\n+\t  else if (i != 0 && i != num_blocks - 2)\n+\t    abort ();\n+\t}\n+      else\n+\t{\n+\t  REG_NOTES (binfo->first_insn)\n+\t    = gen_rtx (EXPR_LIST, REG_EXEC_COUNT, GEN_INT (total),\n+\t\t       REG_NOTES (binfo->first_insn));\n+\t  if (i == num_blocks - 1)\n+\t    return_label_execution_count = total;\n+\t}\n+    }\n+  \n+  /* This should never happen.  */\n+  if (bad_counts)\n+    warning (\"Arc profiling: some arc counts were bad.\");\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"%d branches\\n\", num_branches);\n+      fprintf (dump_file, \"%d branches never executed\\n\",\n+\t       num_never_executed);\n+      if (num_branches)\n+\tfor (i = 0; i < 10; i++)\n+\t  fprintf (dump_file, \"%d%% branches in range %d-%d%%\\n\",\n+\t\t   (hist_br_prob[i]+hist_br_prob[19-i])*100/num_branches,\n+\t\t   5*i, 5*i+5);\n+\n+      total_num_branches += num_branches;\n+      total_num_never_executed += num_never_executed;\n+      for (i = 0; i < 20; i++)\n+\ttotal_hist_br_prob[i] += hist_br_prob[i];\n+    }\n+\n+}\n+\f\n+/* Initialize a new arc.\n+   ARCPTR is the empty adj_list this function fills in.\n+   SOURCE is the block number of the source block.\n+   TARGET is the block number of the target block.\n+   INSN is the insn which transfers control from SOURCE to TARGET,\n+   or zero if the transfer is implicit.  */\n+\n+static void\n+init_arc (arcptr, source, target, insn)\n+     struct adj_list *arcptr;\n+     int source, target;\n+     rtx insn;\n+{\n+  ARC_TARGET (arcptr) = target;\n+  ARC_SOURCE (arcptr) = source;\n+\n+  ARC_COUNT (arcptr) = 0;\n+  arcptr->count_valid = 0;\n+  arcptr->on_tree = 0;\n+  arcptr->fake = 0;\n+  arcptr->fall_through = 0;\n+  arcptr->branch_insn = insn;\n+\n+  arcptr->succ_next = bb_graph[source].succ;\n+  bb_graph[source].succ = arcptr;\n+  bb_graph[source].succ_count++;\n+\n+  arcptr->pred_next = bb_graph[target].pred;\n+  bb_graph[target].pred = arcptr;\n+  bb_graph[target].pred_count++;\n+}\n+\n+/* This function searches all of the arcs in the program flow graph, and puts\n+   as many bad arcs as possible onto the spanning tree.  Bad arcs include\n+   fake arcs (needed for setjmp(), longjmp(), exit()) which MUST be on the\n+   spanning tree as they can't be instrumented.  Also, arcs which must be\n+   split when instrumented should be part of the spanning tree if possible.  */\n+\n+static void\n+find_spanning_tree (num_blocks)\n+     int num_blocks;\n+{\n+  int i;\n+  struct adj_list *arcptr;\n+  struct bb_info *binfo = &bb_graph[0];\n+\n+  /* Fake arcs must be part of the spanning tree, and are always safe to put\n+     on the spanning tree.  Fake arcs will either be a successor of node 0,\n+     a predecessor of the last node, or from the last node to node 0.  */\n+\n+  for (arcptr = bb_graph[0].succ; arcptr; arcptr = arcptr->succ_next)\n+    if (arcptr->fake)\n+      {\n+\t/* Adding this arc should never cause a cycle.  This is a fatal \n+\t   error if it would.  */\n+\tif (bb_graph[ARC_TARGET (arcptr)].on_tree && binfo->on_tree)\n+\t  abort();\n+\telse\n+\t  {\n+\t    arcptr->on_tree = 1;\n+\t    bb_graph[ARC_TARGET (arcptr)].on_tree = 1;\n+\t    binfo->on_tree = 1;\n+\t  }\n+      }\n+\n+  binfo = &bb_graph[num_blocks-1];\n+  for (arcptr = binfo->pred; arcptr; arcptr = arcptr->pred_next)\n+    if (arcptr->fake)\n+      {\n+\t/* Adding this arc should never cause a cycle.  This is a fatal \n+\t   error if it would.  */\n+\tif (bb_graph[ARC_SOURCE (arcptr)].on_tree && binfo->on_tree)\n+\t  abort();\n+\telse\n+\t  {\n+\t    arcptr->on_tree = 1;\n+\t    bb_graph[ARC_SOURCE (arcptr)].on_tree = 1;\n+\t    binfo->on_tree = 1;\n+\t  }\n+      }\n+  /* The only entrace to node zero is a fake arc.  */\n+  bb_graph[0].pred->on_tree = 1;\n+  \n+  /* Arcs which are crowded at both the source and target should be put on\n+     the spanning tree if possible, except for fall_throuch arcs which never\n+     require adding a new block even if crowded, add arcs with the same source\n+     and dest which must always be instrumented.  */\n+  for (i = 0; i < num_blocks; i++)\n+    {\n+      binfo = &bb_graph[i];\n+\n+      for (arcptr = binfo->succ; arcptr; arcptr = arcptr->succ_next)\n+\tif (! ((binfo->succ == arcptr && arcptr->succ_next == 0)\n+\t       || (bb_graph[ARC_TARGET (arcptr)].pred\n+\t\t   && arcptr->pred_next == 0))\n+\t    && ! arcptr->fall_through\n+\t    && ARC_TARGET (arcptr) != i)\n+\t  {\n+\t    /* This is a crowded arc at both source and target.  Try to put\n+\t       in on the spanning tree.  Can do this if either the source or\n+\t       target block is not yet on the tree.  */\n+\t    if (! bb_graph[ARC_TARGET (arcptr)].on_tree\t|| ! binfo->on_tree)\n+\t      {\n+\t\tarcptr->on_tree = 1;\n+\t\tbb_graph[ARC_TARGET (arcptr)].on_tree = 1;\n+\t\tbinfo->on_tree = 1;\n+\t      }\n+\t  }\n+    }\n+\n+  /* Clear all of the basic block on_tree bits, so that we can use them to\n+     create the spanning tree.  */\n+  for (i = 0; i < num_blocks; i++)\n+    bb_graph[i].on_tree = 0;\n+\n+  /* Now fill in the spanning tree until every basic block is on it.\n+     Don't put the 0 to 1 fall through arc on the tree, since it is \n+     always cheap to instrument, so start filling the tree from node 1.  */\n+\n+  for (i = 1; i < num_blocks; i++)\n+    for (arcptr = bb_graph[i].succ; arcptr; arcptr = arcptr->succ_next)\n+      if (! arcptr->on_tree\n+\t  && ! bb_graph[ARC_TARGET (arcptr)].on_tree)\n+\t{\n+\t  fill_spanning_tree (i);\n+\t  break;\n+\t}\n+}\n+\n+/* Add arcs reached from BLOCK to the spanning tree if they are needed and\n+   not already there.  */\n+\n+static void\n+fill_spanning_tree (block)\n+     int block;\n+{\n+  struct adj_list *arcptr;\n+  \n+  expand_spanning_tree (block);\n+\n+  for (arcptr = bb_graph[block].succ; arcptr; arcptr = arcptr->succ_next)\n+    if (! arcptr->on_tree\n+\t&& ! bb_graph[ARC_TARGET (arcptr)].on_tree)\n+      {\n+\tarcptr->on_tree = 1;\n+\tfill_spanning_tree (ARC_TARGET (arcptr));\n+      }\n+}\n+\n+/* When first visit a block, must add all blocks that are already connected\n+   to this block via tree arcs to the spanning tree.  */\n+\n+static void\n+expand_spanning_tree (block)\n+     int block;\n+{\n+  struct adj_list *arcptr;\n+\n+  bb_graph[block].on_tree = 1;\n+\n+  for (arcptr = bb_graph[block].succ; arcptr; arcptr = arcptr->succ_next)\n+    if (arcptr->on_tree && ! bb_graph[ARC_TARGET (arcptr)].on_tree)\n+      expand_spanning_tree (ARC_TARGET (arcptr));\n+    \n+  for (arcptr = bb_graph[block].pred;\n+       arcptr; arcptr = arcptr->pred_next)\n+    if (arcptr->on_tree && ! bb_graph[ARC_SOURCE (arcptr)].on_tree)\n+      expand_spanning_tree (ARC_SOURCE (arcptr));\n+}\n+\f\n+/* Perform file-level initialization for branch-prob processing.  */\n+\n+void\n+init_branch_prob (filename)\n+     char *filename;\n+{\n+  long len;\n+  int i;\n+\n+  if (flag_test_coverage)\n+    {\n+      /* Open an output file for the basic block/line number map.  */\n+      int len = strlen (filename);\n+      char *data_file = (char *) alloca (len + 4);\n+      strcpy (data_file, filename);\n+      strip_off_ending (data_file, len);\n+      strcat (data_file, \".bb\");\n+      if ((bb_file = fopen (data_file, \"w\")) == 0)\n+\tpfatal_with_name (data_file);\n+\n+      /* Open an output file for the program flow graph.  */\n+      len = strlen (filename);\n+      bbg_file_name = (char *) alloca (len + 5);\n+      strcpy (bbg_file_name, filename);\n+      strip_off_ending (bbg_file_name, len);\n+      strcat (bbg_file_name, \".bbg\");\n+      if ((bbg_file = fopen (bbg_file_name, \"w\")) == 0)\n+\tpfatal_with_name (bbg_file_name);\n+\n+      /* Initialize to zero, to ensure that the first file name will be\n+\t written to the .bb file.  */\n+      last_bb_file_name = 0;\n+    }\n+\n+  if (flag_branch_probabilities)\n+    {\n+      len = strlen (filename);\n+      da_file_name = (char *) alloca (len + 4);\n+      strcpy (da_file_name, filename);\n+      strip_off_ending (da_file_name, len);\n+      strcat (da_file_name, \".da\");\n+      if ((da_file = fopen (da_file_name, \"r\")) == 0)\n+\twarning (\"file %s not found, execution counts assumed to be zero.\",\n+\t\t da_file_name);\n+\n+      /* The first word in the .da file gives the number of instrumented arcs,\n+\t which is not needed for our purposes.  */\n+\n+      if (da_file)\n+\t__read_long (&len, da_file, 8);\n+    }\n+\n+  if (profile_arc_flag)\n+    init_arc_profiler ();\n+\n+  total_num_blocks = 0;\n+  total_num_arcs = 0;\n+  total_num_arcs_instrumented = 0;\n+  total_num_blocks_created = 0;\n+  total_num_passes = 0;\n+  total_num_times_called = 0;\n+  total_num_branches = 0;\n+  total_num_never_executed = 0;\n+  for (i = 0; i < 20; i++)\n+    total_hist_br_prob[i] = 0;\n+}\n+\n+/* Performs file-level cleanup after branch-prob processing\n+   is completed.  */\n+\n+void\n+end_branch_prob (dump_file)\n+     FILE *dump_file;\n+{\n+  if (flag_test_coverage)\n+    {\n+      fclose (bb_file);\n+      fclose (bbg_file);\n+    }\n+\n+  if (flag_branch_probabilities)\n+    {\n+      if (da_file)\n+\t{\n+\t  long temp;\n+\t  /* This seems slightly dangerous, as it presumes the EOF\n+\t     flag will not be set until an attempt is made to read\n+\t     past the end of the file. */\n+\t  if (feof (da_file))\n+\t    warning (\".da file contents exhausted too early\\n\");\n+\t  /* Should be at end of file now.  */\n+\t  if (__read_long (&temp, da_file, 8) == 0)\n+\t    warning (\".da file contents not exhausted\\n\");\n+\t  fclose (da_file);\n+\t}\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n\");\n+      fprintf (dump_file, \"Total number of blocks: %d\\n\", total_num_blocks);\n+      fprintf (dump_file, \"Total number of arcs: %d\\n\", total_num_arcs);\n+      fprintf (dump_file, \"Total number of instrumented arcs: %d\\n\",\n+\t       total_num_arcs_instrumented);\n+      fprintf (dump_file, \"Total number of blocks created: %d\\n\",\n+\t       total_num_blocks_created);\n+      fprintf (dump_file, \"Total number of graph solution passes: %d\\n\",\n+\t       total_num_passes);\n+      if (total_num_times_called != 0)\n+\tfprintf (dump_file, \"Average number of graph solution passes: %d\\n\",\n+\t\t (total_num_passes + (total_num_times_called  >> 1))\n+\t\t / total_num_times_called);\n+      fprintf (dump_file, \"Total number of branches: %d\\n\", total_num_branches);\n+      fprintf (dump_file, \"Total number of branches never executed: %d\\n\",\n+\t       total_num_never_executed);\n+      if (total_num_branches)\n+\t{\n+\t  int i;\n+\n+\t  for (i = 0; i < 10; i++)\n+\t    fprintf (dump_file, \"%d%% branches in range %d-%d%%\\n\",\n+\t\t     (total_hist_br_prob[i] + total_hist_br_prob[19-i]) * 100\n+\t\t     / total_num_branches, 5*i, 5*i+5);\n+\t}\n+    }\n+}\n+\f\n+/* The label used by the arc profiling code.  */\n+\n+static rtx profiler_label;\n+\n+/* Initialize the profiler_label.  */\n+\n+static void\n+init_arc_profiler ()\n+{\n+  /* Generate and save a copy of this so it can be shared.  */\n+  char *name = xmalloc (20);\n+  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n+  profiler_label = gen_rtx (SYMBOL_REF, Pmode, name);\n+}\n+\n+/* Output instructions as RTL to increment the arc execution count.  */\n+\n+static void\n+output_arc_profiler (arcno, insert_after)\n+     int arcno;\n+     rtx insert_after;\n+{\n+  rtx profiler_target_addr\n+    = (arcno\n+       ? gen_rtx (CONST, Pmode,\n+\t\t  gen_rtx (PLUS, Pmode, profiler_label,\n+\t\t\t   gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t    LONG_TYPE_SIZE / BITS_PER_UNIT * arcno)))\n+       : profiler_label);\n+  enum machine_mode mode = mode_for_size (LONG_TYPE_SIZE, MODE_INT, 0);\n+  rtx profiler_reg = gen_reg_rtx (mode);\n+  rtx address_reg = gen_reg_rtx (Pmode);\n+  rtx mem_ref, add_ref;\n+  rtx sequence;\n+\n+#ifdef SMALL_REGISTER_CLASSES\n+  /* In this case, reload can use explicitly mentioned hard registers for\n+     reloads.  It is not safe to output profiling code between a call\n+     and the instruction that copies the result to a pseudo-reg.  This\n+     is because reload may allocate one of the profiling code pseudo-regs\n+     to the return value reg, thus clobbering the return value.  So we\n+     must check for calls here, and emit the profiling code after the\n+     instruction that uses the return value, if any.\n+\n+     ??? The code here performs the same tests that reload does so hopefully\n+     all the bases are covered.  */\n+\n+  if (SMALL_REGISTER_CLASSES\n+      && GET_CODE (insert_after) == CALL_INSN\n+      && (GET_CODE (PATTERN (insert_after)) == SET\n+\t  || (GET_CODE (PATTERN (insert_after)) == PARALLEL\n+\t      && GET_CODE (XVECEXP (PATTERN (insert_after), 0, 0)) == SET)))\n+    {\n+      rtx return_reg;\n+      rtx next_insert_after = next_nonnote_insn (insert_after);\n+\n+      if (GET_CODE (next_insert_after) == INSN)\n+\t{\n+\t  /* The first insn after the call may be a stack pop, skip it.  */\n+\t  if (GET_CODE (PATTERN (next_insert_after)) == SET\n+\t      && SET_DEST (PATTERN (next_insert_after)) == stack_pointer_rtx)\n+\t    next_insert_after = next_nonnote_insn (next_insert_after);\n+\n+\t  if (GET_CODE (PATTERN (insert_after)) == SET)\n+\t    return_reg = SET_DEST (PATTERN (insert_after));\n+\t  else\n+\t    return_reg = SET_DEST (XVECEXP (PATTERN (insert_after), 0, 0));\n+\n+\t  if (reg_referenced_p (return_reg, PATTERN (next_insert_after)))\n+\t    insert_after = next_insert_after;\n+\t}\n+    }\n+#endif\n+\n+  start_sequence ();\n+\n+  emit_move_insn (address_reg, profiler_target_addr);\n+  mem_ref = gen_rtx (MEM, mode, address_reg);\n+  emit_move_insn (profiler_reg, mem_ref);\n+\n+  add_ref = gen_rtx (PLUS, mode, profiler_reg, GEN_INT (1));\n+  emit_move_insn (profiler_reg, add_ref);\n+\n+  /* This is the same rtx as above, but it is not legal to share this rtx.  */\n+  mem_ref = gen_rtx (MEM, mode, address_reg);\n+  emit_move_insn (mem_ref, profiler_reg);\n+\n+  sequence = gen_sequence ();\n+  end_sequence ();\n+  emit_insn_after (sequence, insert_after);\n+}\n+\n+/* Output code for a constructor that will invoke __bb_init_func, if\n+   this has not already been done. */\n+\n+void\n+output_func_start_profiler ()\n+{\n+  tree fnname, fndecl;\n+  char *name, *cfnname;\n+  rtx table_address;\n+  enum machine_mode mode = mode_for_size (LONG_TYPE_SIZE, MODE_INT, 0);\n+\n+  /* It's either already been output, or we don't need it because we're\n+     not doing profile-arcs. */\n+  if (! need_func_profiler)\n+    return;\n+\n+  need_func_profiler = 0;\n+\n+  /* Synthesize a constructor function to invoke __bb_init_func with a\n+     pointer to this object file's profile block. */\n+  start_sequence ();\n+\n+  /* Try and make a unique name given the \"file function name\".\n+\n+     And no, I don't like this either. */\n+\n+  fnname = get_file_function_name ('I');\n+  cfnname = IDENTIFIER_POINTER (fnname);\n+  name = xmalloc (strlen (cfnname) + 5);\n+  sprintf (name, \"%sGCOV\",cfnname);\n+  fnname = get_identifier (name);\n+  free (name);\n+\n+  fndecl = build_decl (FUNCTION_DECL, fnname,\n+\t\t       build_function_type (void_type_node, NULL_TREE));\n+  DECL_EXTERNAL (fndecl) = 1;\n+  TREE_PUBLIC (fndecl) = 1;\n+  DECL_ASSEMBLER_NAME (fndecl) = fnname;\n+  DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+  current_function_decl = fndecl;\n+  pushlevel (0);\n+  make_function_rtl (fndecl);\n+  init_function_start (fndecl, input_filename, lineno);\n+  expand_function_start (fndecl, 0);\n+\n+  /* Actually generate the code to call __bb_init_func. */\n+  name = xmalloc (20);\n+  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n+  table_address = force_reg (Pmode, gen_rtx (SYMBOL_REF, Pmode, name));\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__bb_init_func\"), 0,\n+\t\t     mode, 1, table_address, Pmode);\n+\n+  expand_function_end (input_filename, lineno, 0);\n+  poplevel (1, 0, 1);\n+  rest_of_compilation (fndecl);\n+  fflush (asm_out_file);\n+  current_function_decl = NULL_TREE;\n+\n+  assemble_constructor (IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n+}"}]}