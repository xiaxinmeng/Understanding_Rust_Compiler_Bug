{"sha": "348eea5f00fe47fa13c235e9e93c082b8b285f97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ4ZWVhNWYwMGZlNDdmYTEzYzIzNWU5ZTkzYzA4MmI4YjI4NWY5Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-09-16T21:02:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-09-16T21:02:54Z"}, "message": "dse.c (find_shift_sequence): Allow word as well as subword shifts.\n\ngcc/\n\t* dse.c (find_shift_sequence): Allow word as well as subword shifts.\n\tDo the tentative shift expansion with the DF_NO_INSN_RESCAN flag set.\n\tFix the call to insn_rtx_cost.  Skip access sizes that require a\n\treal truncation of the store register.  Use convert_move instead\n\tof gen_lowpart when narrowing the result.\n\t(replace_read): Use convert_move instead of gen_lowpart when\n\tnarrowing the store rhs.\n\ngcc/testsuite/\n\t* gcc.target/mips/dse-1.c: New test.\n\nFrom-SVN: r128530", "tree": {"sha": "24f70bdc3e262c76611c228272c31e27b2f21f85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24f70bdc3e262c76611c228272c31e27b2f21f85"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/348eea5f00fe47fa13c235e9e93c082b8b285f97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348eea5f00fe47fa13c235e9e93c082b8b285f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/348eea5f00fe47fa13c235e9e93c082b8b285f97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/348eea5f00fe47fa13c235e9e93c082b8b285f97/comments", "author": null, "committer": null, "parents": [{"sha": "0ee3f0a892918371a5245de973480bc443126558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ee3f0a892918371a5245de973480bc443126558", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ee3f0a892918371a5245de973480bc443126558"}], "stats": {"total": 81, "additions": 70, "deletions": 11}, "files": [{"sha": "60bd52db87f2f9021f4c32d7f6a5334b119bea98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348eea5f00fe47fa13c235e9e93c082b8b285f97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348eea5f00fe47fa13c235e9e93c082b8b285f97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=348eea5f00fe47fa13c235e9e93c082b8b285f97", "patch": "@@ -1,3 +1,13 @@\n+2007-09-16  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* dse.c (find_shift_sequence): Allow word as well as subword shifts.\n+\tDo the tentative shift expansion with the DF_NO_INSN_RESCAN flag set.\n+\tFix the call to insn_rtx_cost.  Skip access sizes that require a\n+\treal truncation of the store register.  Use convert_move instead\n+\tof gen_lowpart when narrowing the result.\n+\t(replace_read): Use convert_move instead of gen_lowpart when\n+\tnarrowing the store rhs.\n+\n 2007-09-16  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* config/mips/mips.md (SHORT): Fix long line."}, {"sha": "1aa1598e6b49b7cc524efcce80becfe9f96c7c6e", "filename": "gcc/dse.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348eea5f00fe47fa13c235e9e93c082b8b285f97/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348eea5f00fe47fa13c235e9e93c082b8b285f97/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=348eea5f00fe47fa13c235e9e93c082b8b285f97", "patch": "@@ -1407,21 +1407,31 @@ find_shift_sequence (rtx read_reg,\n      justify the value we want to read but is available in one insn on\n      the machine.  */\n \n-  while (access_size < UNITS_PER_WORD)\n+  for (; access_size <= UNITS_PER_WORD; access_size *= 2)\n     {\n-      rtx target;\n-      enum machine_mode new_mode\n-\t= smallest_mode_for_size (access_size * BITS_PER_UNIT,\n-\t\t\t\t  GET_MODE_CLASS (read_mode));\n-      rtx new_reg = gen_reg_rtx (new_mode);\n+      rtx target, new_reg;\n+      enum machine_mode new_mode;\n+\n+      /* Try a wider mode if truncating the store mode to ACCESS_SIZE\n+\t bytes requires a real instruction.  */\n+      if (access_size < GET_MODE_SIZE (store_mode)\n+\t  && !TRULY_NOOP_TRUNCATION (access_size * BITS_PER_UNIT,\n+\t\t\t\t     GET_MODE_BITSIZE (store_mode)))\n+\tcontinue;\n+\n+      new_mode = smallest_mode_for_size (access_size * BITS_PER_UNIT,\n+\t\t\t\t\t GET_MODE_CLASS (read_mode));\n+      new_reg = gen_reg_rtx (new_mode);\n \n       start_sequence ();\n \n       /* In theory we could also check for an ashr.  Ian Taylor knows\n \t of one dsp where the cost of these two was not the same.  But\n \t this really is a rare case anyway.  */\n+      df_set_flags (DF_NO_INSN_RESCAN);\n       target = expand_binop (new_mode, lshr_optab, new_reg,\n \t\t\t     GEN_INT (shift), new_reg, 1, OPTAB_DIRECT);\n+      df_clear_flags (DF_NO_INSN_RESCAN);\n \n       if (target == new_reg)\n \t{\n@@ -1436,7 +1446,8 @@ find_shift_sequence (rtx read_reg,\n \t      rtx insn;\n \n \t      for (insn = shift_seq; insn != NULL_RTX; insn = NEXT_INSN (insn))\n-\t\tcost += insn_rtx_cost (insn);\n+\t\tif (INSN_P (insn))\n+\t\t  cost += insn_rtx_cost (PATTERN (insn));\n \n \t      /* The computation up to here is essentially independent\n \t\t of the arguments and could be precomputed.  It may\n@@ -1455,7 +1466,7 @@ find_shift_sequence (rtx read_reg,\n \t\t  start_sequence ();\n \t\t  emit_move_insn (new_reg, gen_lowpart (new_mode, store_info->rhs));\n \t\t  emit_insn (shift_seq);\n-\t\t  emit_move_insn (read_reg,  gen_lowpart (read_mode, new_reg));\n+\t\t  convert_move (read_reg, new_reg, 1);\n \t\t  \n \t\t  if (dump_file)\n \t\t    {\n@@ -1480,8 +1491,6 @@ find_shift_sequence (rtx read_reg,\n       else\n \t/* End the sequence.  */\n \tend_sequence ();\n-\n-      access_size = access_size * 2;\n     }\n \n   return NULL;\n@@ -1595,7 +1604,7 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \t     place, we need to extract the value in the right from the\n \t     rhs of the store.  */\n \t  start_sequence ();\n-\t  emit_move_insn (read_reg, gen_lowpart (read_mode, store_info->rhs));\n+\t  convert_move (read_reg, store_info->rhs, 1);\n \t  \n \t  if (dump_file)\n \t    fprintf (dump_file, \" -- adding extract insn r%d:%s = r%d:%s\\n\","}, {"sha": "1fea6a1daafd5db6660315a2a2c299d5235f3a2a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348eea5f00fe47fa13c235e9e93c082b8b285f97/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348eea5f00fe47fa13c235e9e93c082b8b285f97/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=348eea5f00fe47fa13c235e9e93c082b8b285f97", "patch": "@@ -1,3 +1,7 @@\n+2007-09-16  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* gcc.target/mips/dse-1.c: New test.\n+\n 2007-09-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/32756"}, {"sha": "a2b844509683edb7e44c1eedfa7c1e2c3834f774", "filename": "gcc/testsuite/gcc.target/mips/dse-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/348eea5f00fe47fa13c235e9e93c082b8b285f97/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fdse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/348eea5f00fe47fa13c235e9e93c082b8b285f97/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fdse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fdse-1.c?ref=348eea5f00fe47fa13c235e9e93c082b8b285f97", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-mips-options \"-mgp64 -O\" } */\n+\n+#define TEST(ID, TYPE1, TYPE2)\t\t\t\t\t\\\n+  union {\t\t\t\t\t\t\t\\\n+    TYPE1 m1[sizeof (TYPE2) / sizeof (TYPE1)];\t\t\t\\\n+    TYPE2 m2;\t\t\t\t\t\t\t\\\n+  } u##ID;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  /* The MIPS16 versions of the shifts we need are too\t\t\\\n+     expensive.  */\t\t\t\t\t\t\\\n+  TYPE1 __attribute__((nomips16))\t\t\t\t\\\n+  f##ID (TYPE2 x)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    u##ID.m2 = x;\t\t\t\t\t\t\\\n+    return (u##ID.m1[0]\t\t\t\t\t\t\\\n+\t    + u##ID.m1[sizeof (TYPE2) / sizeof (TYPE1) - 1]);\t\\\n+  }\n+\n+TEST (1, unsigned int, unsigned long long);\n+TEST (2, int, long long);\n+TEST (3, unsigned short, unsigned long long);\n+TEST (4, short, long long);\n+TEST (5, unsigned char, unsigned long long);\n+TEST (6, signed char, long long);\n+\n+TEST (7, unsigned short, unsigned int);\n+TEST (8, short, int);\n+TEST (9, unsigned char, unsigned int);\n+TEST (10, signed char, int);\n+\n+/* DSE isn't yet read to consider stores of subregs, so the corresponding\n+   (char, short) tests won't pass.  */\n+\n+/* { dg-final { scan-assembler-not \"\\tlh\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\tlw\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\tlb\\t\" } } */"}]}