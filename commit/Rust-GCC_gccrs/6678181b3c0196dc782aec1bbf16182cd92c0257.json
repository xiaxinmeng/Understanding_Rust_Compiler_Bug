{"sha": "6678181b3c0196dc782aec1bbf16182cd92c0257", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY3ODE4MWIzYzAxOTZkYzc4MmFlYzFiYmYxNjE4MmNkOTJjMDI1Nw==", "commit": {"author": {"name": "Warren Levy", "email": "warrenl@cygnus.com", "date": "2000-11-03T07:43:06Z"}, "committer": {"name": "Warren Levy", "email": "warrenl@gcc.gnu.org", "date": "2000-11-03T07:43:06Z"}, "message": "InetAddress.java (addr): Renamed from 'address'.\n\n\t* java/net/InetAddress.java (addr): Renamed from 'address'.\n\t(address): New field to match Serialized Form doc.\n\t(hostName): Renamed from 'hostname' to match Serialized Form doc.\n\t(family): New serialization field.\n\t(serialVersionUID): New field.\n\t(readObject): New method.\n\t(writeObject): New method.\n\t(getFamily): New native method.\n\t(InetAddress): Set family.\n\t* java/net/natInetAddress.cc (getFamily): New method.\n\t(addr): Renamed from 'address'.\n\t(hostName): Renamed from 'hostname' to match Serialized Form doc.\n\t* java/net/natPlainDatagramSocketImpl.cc (addr): Renamed from 'address'.\n\t* java/net/natPlainSocketImpl.cc (addr): Renamed from 'address'.\n\nSerialization mod.\n\nFrom-SVN: r37222", "tree": {"sha": "4592ce97a133d04d307e48d5b9937d20b94bfa47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4592ce97a133d04d307e48d5b9937d20b94bfa47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6678181b3c0196dc782aec1bbf16182cd92c0257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6678181b3c0196dc782aec1bbf16182cd92c0257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6678181b3c0196dc782aec1bbf16182cd92c0257", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6678181b3c0196dc782aec1bbf16182cd92c0257/comments", "author": null, "committer": null, "parents": [{"sha": "11d6fb5451edf66542a7052bb8973e42ddfb7dbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11d6fb5451edf66542a7052bb8973e42ddfb7dbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11d6fb5451edf66542a7052bb8973e42ddfb7dbf"}], "stats": {"total": 157, "additions": 120, "deletions": 37}, "files": [{"sha": "025d08e98d0ed34655d5f4220a74881bffe3be3e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6678181b3c0196dc782aec1bbf16182cd92c0257", "patch": "@@ -1,3 +1,20 @@\n+2000-11-02  Warren Levy  <warrenl@cygnus.com>\n+\n+\t* java/net/InetAddress.java (addr): Renamed from 'address'.\n+\t(address): New field to match Serialized Form doc.\n+\t(hostName): Renamed from 'hostname' to match Serialized Form doc.\n+\t(family): New serialization field.\n+\t(serialVersionUID): New field.\n+\t(readObject): New method.\n+\t(writeObject): New method.\n+\t(getFamily): New native method.\n+\t(InetAddress): Set family.\n+\t* java/net/natInetAddress.cc (getFamily): New method.\n+\t(addr): Renamed from 'address'.\n+\t(hostName): Renamed from 'hostname' to match Serialized Form doc.\n+\t* java/net/natPlainDatagramSocketImpl.cc (addr): Renamed from 'address'.\n+\t* java/net/natPlainSocketImpl.cc (addr): Renamed from 'address'.\n+\n 2000-11-03  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/util/AbstractList.java (SubList): Make it a top-level private"}, {"sha": "f1a12354be8a7b9582798fbbf3a381e8b3097c18", "filename": "libjava/java/net/InetAddress.java", "status": "modified", "additions": 64, "deletions": 19, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=6678181b3c0196dc782aec1bbf16182cd92c0257", "patch": "@@ -1,6 +1,6 @@\n // INetAddress.java -- An Internet Protocol (IP) address.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -9,6 +9,9 @@\n details.  */\n \n package java.net;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.IOException;\n \n /**\n  * @author Per Bothner\n@@ -24,37 +27,79 @@\n \n public final class InetAddress implements java.io.Serializable\n {\n-  byte[] address;\n-  String hostname;\n+  // The Serialized Form specifies that an int 'address' is saved/restored.\n+  // This class uses a byte array internally so we'll just do the conversion\n+  // at serialization time and leave the rest of the algorithm as is.\n+  private int address;\n+  transient byte[] addr;\n+  String hostName;\n+  // The field 'family' seems to be the AF_ value.\n+  // FIXME: Much of the code in the other java.net classes does not make\n+  // use of this family field.  A better implementation would be to make\n+  // use of getaddrinfo() and have other methods just check the family\n+  // field rather than examining the length of the address each time.\n+  int family;\n+  private static final long serialVersionUID = 3286316764910316507L;\n+\n+  private void readObject(ObjectInputStream ois)\n+    throws IOException, ClassNotFoundException\n+  {\n+    ois.defaultReadObject();\n+    addr = new byte[4];\n+    addr[3] = (byte) address;\n+    for (int i = 2; i >= 0; --i)\n+      addr[i] = (byte) (address >>= 8);\n+    // Ignore family from serialized data.  Since the saved address is 32 bits\n+    // the deserialized object will have an IPv4 address i.e. AF_INET family.\n+    // FIXME: An alternative is to call the aton method on the deserialized\n+    // hostname to get a new address.  The Serialized Form doc is silent\n+    // on how these fields are used.\n+    family = getFamily (addr);\n+  }\n+\n+  private void writeObject(ObjectOutputStream oos) throws IOException\n+  {\n+    // Build a 32 bit address from the last 4 bytes of a 4 byte IPv4 address\n+    // or a 16 byte IPv6 address.\n+    int len = addr.length;\n+    int i = len - 4;\n+    for (; i < len; i++)\n+      address = address << 8 | (((int) addr[i]) & 0xFF);\n+    oos.defaultWriteObject();\n+  }\n+\n+  private static native int getFamily (byte[] address);\n \n   InetAddress (byte[] address, String hostname)\n   {\n-    this.address = address;\n-    this.hostname = hostname;\n+    addr = address;\n+    hostName = hostname;\n+    if (address != null)\n+      family = getFamily (address);\n   }\n \n   public boolean isMulticastAddress ()\n   {\n-    int len = address.length;\n+    int len = addr.length;\n     if (len == 4)\n-      return (address[0] & 0xF0) == 0xE0;\n+      return (addr[0] & 0xF0) == 0xE0;\n     if (len == 16)\n-      return address[0] == (byte) 0xFF;\n+      return addr[0] == (byte) 0xFF;\n     return false;\n   }\n \n   public String getHostName ()\n   {\n-    if (hostname == null)\n+    if (hostName == null)\n       lookup (null, this, false);\n-    return hostname;\n+    return hostName;\n   }\n \n   public byte[] getAddress ()\n   {\n     // An experiment shows that JDK1.2 returns a different byte array each\n     // time.  This makes sense, in terms of security.\n-    return (byte[]) address.clone();\n+    return (byte[]) addr.clone();\n   }\n \n   /* Helper function due to a CNI limitation.  */\n@@ -83,15 +128,15 @@ private static SecurityException checkConnect (String hostname)\n   public String getHostAddress ()\n   {\n     StringBuffer sbuf = new StringBuffer(40);\n-    int len = address.length;\n+    int len = addr.length;\n     int i = 0;\n     if (len == 16)\n       { // An IPv6 address.\n \tfor (;  ;  i += 2)\n \t  {\n \t    if (i >= 16)\n \t      return sbuf.toString();\n-\t    int x = ((address[i] & 0xFF) << 8) | (address[i+1] & 0xFF);\n+\t    int x = ((addr[i] & 0xFF) << 8) | (addr[i+1] & 0xFF);\n \t    boolean empty = sbuf.length() == 0;\n \t    if (empty)\n \t      {\n@@ -116,7 +161,7 @@ else if (i > 0)\n       }\n     for ( ;  ; )\n       {\n-\tsbuf.append(address[i] & 0xFF);\n+\tsbuf.append(addr[i] & 0xFF);\n \ti++;\n \tif (i == len)\n \t  break;\n@@ -130,10 +175,10 @@ public int hashCode()\n     // There hashing algorithm is not specified, but a simple experiment\n     // shows that it is equal to the address, as a 32-bit big-endian integer.\n     int hash = 0;\n-    int len = address.length;\n+    int len = addr.length;\n     int i = len > 4 ? len - 4 : 0;\n     for ( ; i < len;  i++)\n-      hash = (hash << 8) | (address[i] & 0xFF);\n+      hash = (hash << 8) | (addr[i] & 0xFF);\n     return hash;\n   }\n \n@@ -147,8 +192,8 @@ public boolean equals (Object obj)\n     // different host names.\"  This violates the description in the\n     // JDK 1.2 API documentation.  A little experiementation\n     // shows that the latter is correct.\n-    byte[] addr1 = address;\n-    byte[] addr2 = ((InetAddress) obj).address;\n+    byte[] addr1 = addr;\n+    byte[] addr2 = ((InetAddress) obj).addr;\n     if (addr1.length != addr2.length)\n       return false;\n     for (int i = addr1.length;  --i >= 0;  )\n@@ -208,7 +253,7 @@ public static InetAddress getLocalHost() throws UnknownHostException\n     // However, if there is a security manager, and the cached result\n     // is other than \"localhost\", we need to check again.\n     if (localhost == null\n-\t|| (s != null && localhost.address != localhostAddress))\n+\t|| (s != null && localhost.addr != localhostAddress))\n       getLocalHost(s);\n     return localhost;\n   }"}, {"sha": "68a0b411828c37d96713afc209e5453c4f435259", "filename": "libjava/java/net/natInetAddress.cc", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddress.cc?ref=6678181b3c0196dc782aec1bbf16182cd92c0257", "patch": "@@ -66,6 +66,12 @@ java::net::InetAddress::aton (jstring)\n   return NULL;\n }\n \n+jint\n+java::net::InetAddress::getFamily (jbyteArray bytes)\n+{\n+  return 0;\n+}\n+\n JArray<java::net::InetAddress*> *\n java::net::InetAddress::lookup (jstring, java::net::InetAddress *, jboolean)\n {\n@@ -127,6 +133,20 @@ java::net::InetAddress::aton (jstring host)\n   return result;\n }\n \n+jint\n+java::net::InetAddress::getFamily (jbyteArray bytes)\n+{\n+  int len = bytes->length;\n+  if (len == 4)\n+    return AF_INET;\n+#ifdef HAVE_INET6\n+  else if (len == 16)\n+    return AF_INET6;\n+#endif /* HAVE_INET6 */\n+  else\n+    JvFail (\"unrecognized size\");\n+}\n+\n \n JArray<java::net::InetAddress*> *\n java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n@@ -196,21 +216,21 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n     }\n   else\n     {\n-      jbyteArray bytes = iaddr->address;\n+      jbyteArray bytes = iaddr->addr;\n       char *chars = (char*) elements (bytes);\n       int len = bytes->length;\n       int type;\n       char *val;\n       if (len == 4)\n \t{\n \t  val = chars;\n-\t  type = AF_INET;\n+\t  type = iaddr->family = AF_INET;\n \t}\n #ifdef HAVE_INET6\n       else if (len == 16)\n \t{\n \t  val = (char *) &chars;\n-\t  type = AF_INET6;\n+\t  type = iaddr->family = AF_INET6;\n \t}\n #endif /* HAVE_INET6 */\n       else\n@@ -255,16 +275,16 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n       java::lang::SecurityException *ex = checkConnect (host);\n       if (ex != NULL)\n \t{\n-\t  if (iaddr == NULL || iaddr->address == NULL)\n+\t  if (iaddr == NULL || iaddr->addr == NULL)\n \t    throw ex;\n \t  hptr = NULL;\n \t}\n     }\n   if (hptr == NULL)\n     {\n-      if (iaddr != NULL && iaddr->address != NULL)\n+      if (iaddr != NULL && iaddr->addr != NULL)\n \t{\n-\t  iaddr->hostname = iaddr->getHostAddress();\n+\t  iaddr->hostName = iaddr->getHostAddress();\n \t  return NULL;\n \t}\n       else\n@@ -296,13 +316,14 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n     {\n       if (iaddrs[i] == NULL)\n \tiaddrs[i] = new java::net::InetAddress (NULL, NULL);\n-      if (iaddrs[i]->hostname == NULL)\n-        iaddrs[i]->hostname = host;\n-      if (iaddrs[i]->address == NULL)\n+      if (iaddrs[i]->hostName == NULL)\n+        iaddrs[i]->hostName = host;\n+      if (iaddrs[i]->addr == NULL)\n \t{\n \t  char *bytes = hptr->h_addr_list[i];\n-\t  iaddrs[i]->address = JvNewByteArray (hptr->h_length);\n-\t  memcpy (elements (iaddrs[i]->address), bytes, hptr->h_length);\n+\t  iaddrs[i]->addr = JvNewByteArray (hptr->h_length);\n+\t  iaddrs[i]->family = getFamily (iaddrs[i]->addr);\n+\t  memcpy (elements (iaddrs[i]->addr), bytes, hptr->h_length);\n \t}\n     }\n   return result;"}, {"sha": "a90d2a8e8e0b78a85e22254689a3dad14e3eea52", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=6678181b3c0196dc782aec1bbf16182cd92c0257", "patch": "@@ -184,7 +184,7 @@ java::net::PlainDatagramSocketImpl::bind (jint lport,\n   union SockAddr u;\n   struct sockaddr *ptr = (struct sockaddr *) &u.address;\n   // FIXME: Use getaddrinfo() to get actual protocol instead of assuming ipv4.\n-  jbyteArray haddress = host->address;\n+  jbyteArray haddress = host->addr;\n   jbyte *bytes = elements (haddress);\n   int len = haddress->length;\n \n@@ -257,7 +257,7 @@ java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *i)\n   else\n     throw new java::net::SocketException (JvNewStringUTF (\"invalid family\"));\n \n-  i->address = raddr;\n+  i->addr = raddr;\n   return rport;\n  error:\n   char* strerr = strerror (errno);\n@@ -270,7 +270,7 @@ java::net::PlainDatagramSocketImpl::send (java::net::DatagramPacket *p)\n   // FIXME: Deal with Multicast and if the socket is connected.\n   jint rport = p->getPort();\n   union SockAddr u;\n-  jbyteArray haddress = p->getAddress()->address;\n+  jbyteArray haddress = p->getAddress()->addr;\n   jbyte *bytes = elements (haddress);\n   int len = haddress->length;\n   struct sockaddr *ptr = (struct sockaddr *) &u.address;\n@@ -391,7 +391,7 @@ java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *inetaddr,\n \t\t\t\t\t      jboolean join)\n {\n   union McastReq u;\n-  jbyteArray haddress = inetaddr->address;\n+  jbyteArray haddress = inetaddr->addr;\n   jbyte *bytes = elements (haddress);\n   int len = haddress->length;\n   int level, opname;\n@@ -499,7 +499,7 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n \tint level, opname;\n \tconst char *ptr;\n \n-\thaddress = ((java::net::InetAddress *) value)->address;\n+\thaddress = ((java::net::InetAddress *) value)->addr;\n \tbytes = elements (haddress);\n \tlen = haddress->length;\n \tif (len == 4)"}, {"sha": "751b79821e2c037175cb03ab27224effaa8abd30", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6678181b3c0196dc782aec1bbf16182cd92c0257/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=6678181b3c0196dc782aec1bbf16182cd92c0257", "patch": "@@ -134,7 +134,7 @@ java::net::PlainSocketImpl::bind (java::net::InetAddress *host, jint lport)\n {\n   union SockAddr u;\n   struct sockaddr *ptr = (struct sockaddr *) &u.address;\n-  jbyteArray haddress = host->address;\n+  jbyteArray haddress = host->addr;\n   jbyte *bytes = elements (haddress);\n   int len = haddress->length;\n   int i = 1;\n@@ -186,7 +186,7 @@ java::net::PlainSocketImpl::connect (java::net::InetAddress *host, jint rport)\n {\n   union SockAddr u;\n   socklen_t addrlen = sizeof(u);\n-  jbyteArray haddress = host->address;\n+  jbyteArray haddress = host->addr;\n   jbyte *bytes = elements (haddress);\n   int len = haddress->length;\n   struct sockaddr *ptr = (struct sockaddr *) &u.address;"}]}