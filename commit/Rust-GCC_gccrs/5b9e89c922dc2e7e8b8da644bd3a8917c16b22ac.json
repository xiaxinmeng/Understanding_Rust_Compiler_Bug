{"sha": "5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI5ZTg5YzkyMmRjMmU3ZThiOGRhNjQ0YmQzYTg5MTdjMTZiMjJhYw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-01-29T12:13:12Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-01-29T12:13:12Z"}, "message": "SRA: Add verification of accesses\n\n2020-01-29  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (verify_sra_access_forest): New function.\n\t(verify_all_sra_access_forests): Likewise.\n\t(create_artificial_child_access): Set parent.\n\t(analyze_all_variable_accesses): Call the verifier.", "tree": {"sha": "b5b378a812b1127d8f0e04ef813a6da2278093a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5b378a812b1127d8f0e04ef813a6da2278093a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c7107778f16c2db6e97e73fdec6d6606b619864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c7107778f16c2db6e97e73fdec6d6606b619864", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c7107778f16c2db6e97e73fdec6d6606b619864"}], "stats": {"total": 93, "additions": 93, "deletions": 0}, "files": [{"sha": "16247a59304acd39c46f40bf4c460f168b4eafb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac", "patch": "@@ -1,3 +1,10 @@\n+2020-01-29  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (verify_sra_access_forest): New function.\n+\t(verify_all_sra_access_forests): Likewise.\n+\t(create_artificial_child_access): Set parent.\n+\t(analyze_all_variable_accesses): Call the verifier.\n+\n 2020-01-28  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraph.c (cgraph_edge::resolve_speculation): Only lookup direct edge"}, {"sha": "36106fecaf181c7b9e2abfce6b6b9decaabbafb3", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=5b9e89c922dc2e7e8b8da644bd3a8917c16b22ac", "patch": "@@ -2321,6 +2321,88 @@ build_access_trees (struct access *access)\n   return true;\n }\n \n+/* Traverse the access forest where ROOT is the first root and verify that\n+   various important invariants hold true.  */\n+\n+DEBUG_FUNCTION void\n+verify_sra_access_forest (struct access *root)\n+{\n+  struct access *access = root;\n+  tree first_base = root->base;\n+  gcc_assert (DECL_P (first_base));\n+  do\n+    {\n+      gcc_assert (access->base == first_base);\n+      if (access->parent)\n+\tgcc_assert (access->offset >= access->parent->offset\n+\t\t    && access->size <= access->parent->size);\n+      if (access->next_sibling)\n+\tgcc_assert (access->next_sibling->offset\n+\t\t    >= access->offset + access->size);\n+\n+      poly_int64 poffset, psize, pmax_size;\n+      bool reverse;\n+      tree base = get_ref_base_and_extent (access->expr, &poffset, &psize,\n+\t\t\t\t\t   &pmax_size, &reverse);\n+      HOST_WIDE_INT offset, size, max_size;\n+      if (!poffset.is_constant (&offset)\n+\t  || !psize.is_constant (&size)\n+\t  || !pmax_size.is_constant (&max_size))\n+\tgcc_unreachable ();\n+      gcc_assert (base == first_base);\n+      gcc_assert (offset == access->offset);\n+      gcc_assert (access->grp_unscalarizable_region\n+\t\t  || size == max_size);\n+      gcc_assert (max_size == access->size);\n+      gcc_assert (reverse == access->reverse);\n+\n+      if (access->first_child)\n+\t{\n+\t  gcc_assert (access->first_child->parent == access);\n+\t  access = access->first_child;\n+\t}\n+      else if (access->next_sibling)\n+\t{\n+\t  gcc_assert (access->next_sibling->parent == access->parent);\n+\t  access = access->next_sibling;\n+\t}\n+      else\n+\t{\n+\t  while (access->parent && !access->next_sibling)\n+\t    access = access->parent;\n+\t  if (access->next_sibling)\n+\t    access = access->next_sibling;\n+\t  else\n+\t    {\n+\t      gcc_assert (access == root);\n+\t      root = root->next_grp;\n+\t      access = root;\n+\t    }\n+\t}\n+    }\n+  while (access);\n+}\n+\n+/* Verify access forests of all candidates with accesses by calling\n+   verify_access_forest on each on them.  */\n+\n+DEBUG_FUNCTION void\n+verify_all_sra_access_forests (void)\n+{\n+  bitmap_iterator bi;\n+  unsigned i;\n+  EXECUTE_IF_SET_IN_BITMAP (candidate_bitmap, 0, i, bi)\n+    {\n+      tree var = candidate (i);\n+      struct access *access = get_first_repr_for_decl (var);\n+      if (access)\n+\t{\n+\t  gcc_assert (access->base == var);\n+\t  verify_sra_access_forest (access);\n+\t}\n+    }\n+}\n+\n /* Return true if expr contains some ARRAY_REFs into a variable bounded\n    array.  */\n \n@@ -2566,6 +2648,7 @@ create_artificial_child_access (struct access *parent, struct access *model,\n   access->offset = new_offset;\n   access->size = model->size;\n   access->type = model->type;\n+  access->parent = parent;\n   access->grp_write = set_grp_write;\n   access->grp_read = false;\n   access->reverse = model->reverse;\n@@ -2850,6 +2933,9 @@ analyze_all_variable_accesses (void)\n \n   propagate_all_subaccesses ();\n \n+  if (flag_checking)\n+    verify_all_sra_access_forests ();\n+\n   bitmap_copy (tmp, candidate_bitmap);\n   EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)\n     {"}]}