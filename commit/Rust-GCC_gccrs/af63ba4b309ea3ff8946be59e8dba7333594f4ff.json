{"sha": "af63ba4b309ea3ff8946be59e8dba7333594f4ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY2M2JhNGIzMDllYTNmZjg5NDZiZTU5ZThkYmE3MzMzNTk0ZjRmZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-09-09T21:22:15Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-09-09T21:22:15Z"}, "message": "Implement P0035R4, C++17 new of over-aligned types.\n\ngcc/cp/\n\t* cp-tree.h (enum cp_tree_index): Add CPTI_ALIGN_TYPE.\n\t(align_type_node): New macro.\n\t* call.c (build_operator_new_call): Handle C++17 aligned new.\n\t(second_parm_is_size_t, build_op_delete_call): Likewise.\n\t(non_placement_deallocation_fn_p): Likewise. Rename to\n\tusual_deallocation_fn_p.\n\t(aligned_allocation_fn_p, aligned_deallocation_fn_p): New.\n\t* decl.c (cxx_init_decl_processing): Add aligned new support.\n\t* init.c (type_has_new_extended_alignment): New.\n\t(build_new_1): Handle aligned new.\n\t* tree.c (vec_copy_and_insert): New.\ngcc/c-family/\n\t* c.opt: Add -faligned-new and -Waligned-new.\n\t* c-common.c (max_align_t_align): Split out from...\n\t(cxx_fundamental_alignment_p): ...here.\n\t* c-common.h: Declare it.\n\t* c-cppbuiltin.c (c_cpp_builtins): Handle aligned new.\nlibstdc++-v3/\n\t* libsupc++/new: Declare aligned new/delete operators.\n\t* config/abi/pre/gnu.ver: Export them.\n\t* configure.ac: Check for aligned_alloc, posix_memalign, memalign,\n\t_aligned_malloc.\n\t* libsupc++/new_opa.cc: New.\n\t* libsupc++/new_opant.cc: New.\n\t* libsupc++/new_opva.cc: New.\n\t* libsupc++/new_opva.cc: New.\n\t* libsupc++/del_opa.cc: New.\n\t* libsupc++/del_opant.cc: New.\n\t* libsupc++/del_opsa.cc: New.\n\t* libsupc++/del_opva.cc: New.\n\t* libsupc++/del_opvant.cc: New.\n\t* libsupc++/del_opvsa.cc: New.\n\t* libsupc++/Makefile.am: Build them.\n\nFrom-SVN: r240056", "tree": {"sha": "9648be877d043d0cd4ebb37ef5b0e82da08fd4f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9648be877d043d0cd4ebb37ef5b0e82da08fd4f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af63ba4b309ea3ff8946be59e8dba7333594f4ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af63ba4b309ea3ff8946be59e8dba7333594f4ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af63ba4b309ea3ff8946be59e8dba7333594f4ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af63ba4b309ea3ff8946be59e8dba7333594f4ff/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "51389084ec8de8c5a1055c77a2df5a84c5597af6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51389084ec8de8c5a1055c77a2df5a84c5597af6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51389084ec8de8c5a1055c77a2df5a84c5597af6"}], "stats": {"total": 1111, "additions": 1046, "deletions": 65}, "files": [{"sha": "ba892487aa8657185bd4d191f39f9c65319f1111", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -1,3 +1,12 @@\n+2016-09-09  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement C++17 new of over-aligned types.\n+\t* c.opt: Add -faligned-new and -Waligned-new.\n+\t* c-common.c (max_align_t_align): Split out from...\n+\t(cxx_fundamental_alignment_p): ...here.\n+\t* c-common.h: Declare it.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Handle aligned new.\n+\n 2016-09-09  Joseph Myers  <joseph@codesourcery.com>\n \n \t* c-cppbuiltin.c (builtin_define_type_width): New function."}, {"sha": "9a66cfeb297a58661319b862460ae52ead12421f", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -12878,6 +12878,19 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n   return stv_nothing;\n }\n \n+/* Return the alignment of std::max_align_t.\n+\n+   [support.types.layout] The type max_align_t is a POD type whose alignment\n+   requirement is at least as great as that of every scalar type, and whose\n+   alignment requirement is supported in every context.  */\n+\n+unsigned\n+max_align_t_align ()\n+{\n+  return MAX (TYPE_ALIGN (long_long_integer_type_node),\n+\t      TYPE_ALIGN (long_double_type_node));\n+}\n+\n /* Return true iff ALIGN is an integral constant that is a fundamental\n    alignment, as defined by [basic.align] in the c++-11\n    specifications.\n@@ -12886,14 +12899,12 @@ scalar_to_vector (location_t loc, enum tree_code code, tree op0, tree op1,\n \n        [A fundamental alignment is represented by an alignment less than or\n         equal to the greatest alignment supported by the implementation\n-        in all contexts, which is equal to\n-        alignof(max_align_t)].  */\n+        in all contexts, which is equal to alignof(max_align_t)].  */\n \n bool\n-cxx_fundamental_alignment_p  (unsigned align)\n+cxx_fundamental_alignment_p (unsigned align)\n {\n-  return (align <=  MAX (TYPE_ALIGN (long_long_integer_type_node),\n-\t\t\t TYPE_ALIGN (long_double_type_node)));\n+  return (align <= max_align_t_align ());\n }\n \n /* Return true if T is a pointer to a zero-sized aggregate.  */"}, {"sha": "2e211c491a52d891eb78a38da9574c4d090f4517", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -863,6 +863,7 @@ extern bool keyword_begins_type_specifier (enum rid);\n extern bool keyword_is_storage_class_specifier (enum rid);\n extern bool keyword_is_type_qualifier (enum rid);\n extern bool keyword_is_decl_specifier (enum rid);\n+extern unsigned max_align_t_align (void);\n extern bool cxx_fundamental_alignment_p (unsigned);\n extern bool pointer_to_zero_sized_aggr_p (tree);\n extern bool diagnose_mismatched_attributes (tree, tree);"}, {"sha": "bb30829c9871984d2de98d60f6454cee0919004d", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -944,6 +944,12 @@ c_cpp_builtins (cpp_reader *pfile)\n \tcpp_define (pfile, \"__cpp_transactional_memory=210500\");\n       if (flag_sized_deallocation)\n \tcpp_define (pfile, \"__cpp_sized_deallocation=201309\");\n+      if (aligned_new_threshhold)\n+\t{\n+\t  cpp_define (pfile, \"__cpp_aligned_new=201606\");\n+\t  cpp_define_formatted (pfile, \"__STDCPP_DEFAULT_NEW_ALIGNMENT__=%d\",\n+\t\t\t\taligned_new_threshhold);\n+\t}\n     }\n   /* Note that we define this for C as well, so that we know if\n      __attribute__((cleanup)) will interface with EH.  */"}, {"sha": "c55c7c34961044b0c79f39691bb9402b56e44181", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -271,6 +271,26 @@ Waddress\n C ObjC C++ ObjC++ Var(warn_address) Warning LangEnabledBy(C ObjC C++ ObjC++,Wall)\n Warn about suspicious uses of memory addresses.\n \n+Enum\n+Name(warn_aligned_new_level) Type(int) UnknownError(argument %qs to %<-Waligned-new%> not recognized)\n+\n+EnumValue\n+Enum(warn_aligned_new_level) String(none) Value(0)\n+\n+EnumValue\n+Enum(warn_aligned_new_level) String(global) Value(1)\n+\n+EnumValue\n+Enum(warn_aligned_new_level) String(all) Value(2)\n+\n+Waligned-new\n+C++ ObjC++ Alias(Waligned-new=,global,none)\n+Warn about 'new' of type with extended alignment without -faligned-new.\n+\n+Waligned-new=\n+C++ ObjC++ Var(warn_aligned_new) Enum(warn_aligned_new_level) Joined Warning LangEnabledBy(C++ ObjC++,Wall,1,0)\n+-Waligned-new=all Warn even if 'new' uses a class member allocation function.\n+\n Wall\n C ObjC C++ ObjC++ Warning\n Enable most warning messages.\n@@ -1032,6 +1052,14 @@ fada-spec-parent=\n C ObjC C++ ObjC++ RejectNegative Joined Var(ada_specs_parent)\n -fada-spec-parent=unit  Dump Ada specs as child units of given parent.\n \n+faligned-new\n+C++ ObjC++ Alias(faligned-new=,1,0)\n+Support C++17 allocation of over-aligned types.\n+\n+faligned-new=\n+C++ ObjC++ Joined Var(aligned_new_threshhold) UInteger Init(-1)\n+-faligned-new=<N> Use C++17 over-aligned type allocation for alignments greater than N.\n+\n fall-virtual\n C++ ObjC++ Ignore Warn(switch %qs is no longer supported)\n "}, {"sha": "94809939c6384d73d33856103ebb6883cb66b03a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -1,3 +1,18 @@\n+2016-09-09  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0035R4, C++17 new of over-aligned types.\n+\t* cp-tree.h (enum cp_tree_index): Add CPTI_ALIGN_TYPE.\n+\t(align_type_node): New macro.\n+\t* call.c (build_operator_new_call): Handle C++17 aligned new.\n+\t(second_parm_is_size_t, build_op_delete_call): Likewise.\n+\t(non_placement_deallocation_fn_p): Likewise. Rename to\n+\tusual_deallocation_fn_p.\n+\t(aligned_allocation_fn_p, aligned_deallocation_fn_p): New.\n+\t* decl.c (cxx_init_decl_processing): Add aligned new support.\n+\t* init.c (type_has_new_extended_alignment): New.\n+\t(build_new_1): Handle aligned new.\n+\t* tree.c (vec_copy_and_insert): New.\n+\n 2016-09-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/77396"}, {"sha": "167d77810c8b451a44e938485580056c43a9ccc6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 128, "deletions": 46, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -4211,13 +4211,14 @@ build_new_function_call (tree fn, vec<tree, va_gc> **args, bool koenig_p,\n \n tree\n build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n-\t\t\t tree *size, tree *cookie_size, tree size_check,\n+\t\t\t tree *size, tree *cookie_size,\n+\t\t\t tree align_arg, tree size_check,\n \t\t\t tree *fn, tsubst_flags_t complain)\n {\n   tree original_size = *size;\n   tree fns;\n   struct z_candidate *candidates;\n-  struct z_candidate *cand;\n+  struct z_candidate *cand = NULL;\n   bool any_viable_p;\n \n   if (fn)\n@@ -4247,9 +4248,20 @@ build_operator_new_call (tree fnname, vec<tree, va_gc> **args,\n      we disregard block-scope declarations of \"operator new\".  */\n   fns = lookup_function_nonclass (fnname, *args, /*block_p=*/false);\n \n+  if (align_arg)\n+    {\n+      vec<tree, va_gc>* align_args\n+\t= vec_copy_and_insert (*args, align_arg, 1);\n+      cand = perform_overload_resolution (fns, align_args, &candidates,\n+\t\t\t\t\t  &any_viable_p, tf_none);\n+      /* If no aligned allocation function matches, try again without the\n+\t alignment.  */\n+    }\n+\n   /* Figure out what function is being called.  */\n-  cand = perform_overload_resolution (fns, *args, &candidates, &any_viable_p,\n-\t\t\t\t      complain);\n+  if (!cand)\n+    cand = perform_overload_resolution (fns, *args, &candidates, &any_viable_p,\n+\t\t\t\t\tcomplain);\n \n   /* If no suitable function could be found, issue an error message\n      and give up.  */\n@@ -5945,16 +5957,65 @@ static bool\n second_parm_is_size_t (tree fn)\n {\n   tree t = FUNCTION_ARG_CHAIN (fn);\n-  return (t\n-\t  && same_type_p (TREE_VALUE (t), size_type_node)\n-\t  && TREE_CHAIN (t) == void_list_node);\n+  if (!t || !same_type_p (TREE_VALUE (t), size_type_node))\n+    return false;\n+  t = TREE_CHAIN (t);\n+  if (t == void_list_node)\n+    return true;\n+  if (aligned_new_threshhold && t\n+      && same_type_p (TREE_VALUE (t), align_type_node)\n+      && TREE_CHAIN (t) == void_list_node)\n+    return true;\n+  return false;\n+}\n+\n+/* True if T, an allocation function, has std::align_val_t as its second\n+   argument.  */\n+\n+bool\n+aligned_allocation_fn_p (tree t)\n+{\n+  if (!aligned_new_threshhold)\n+    return false;\n+\n+  tree a = FUNCTION_ARG_CHAIN (t);\n+  return (a && same_type_p (TREE_VALUE (a), align_type_node));\n+}\n+\n+/* Returns true iff T, an element of an OVERLOAD chain, is a usual deallocation\n+   function (3.7.4.2 [basic.stc.dynamic.deallocation]) with a parameter of\n+   std::align_val_t.  */\n+\n+static bool\n+aligned_deallocation_fn_p (tree t)\n+{\n+  if (!aligned_new_threshhold)\n+    return false;\n+\n+  /* A template instance is never a usual deallocation function,\n+     regardless of its signature.  */\n+  if (TREE_CODE (t) == TEMPLATE_DECL\n+      || primary_template_instantiation_p (t))\n+    return false;\n+\n+  tree a = FUNCTION_ARG_CHAIN (t);\n+  if (same_type_p (TREE_VALUE (a), align_type_node)\n+      && TREE_CHAIN (a) == void_list_node)\n+    return true;\n+  if (!same_type_p (TREE_VALUE (a), size_type_node))\n+    return false;\n+  a = TREE_CHAIN (a);\n+  if (a && same_type_p (TREE_VALUE (a), align_type_node)\n+      && TREE_CHAIN (a) == void_list_node)\n+    return true;\n+  return false;\n }\n \n /* Returns true iff T, an element of an OVERLOAD chain, is a usual\n    deallocation function (3.7.4.2 [basic.stc.dynamic.deallocation]).  */\n \n bool\n-non_placement_deallocation_fn_p (tree t)\n+usual_deallocation_fn_p (tree t)\n {\n   /* A template instance is never a usual deallocation function,\n      regardless of its signature.  */\n@@ -5970,10 +6031,15 @@ non_placement_deallocation_fn_p (tree t)\n      of which has type std::size_t (18.2), then this function is a usual\n      deallocation function.  */\n   bool global = DECL_NAMESPACE_SCOPE_P (t);\n-  if (FUNCTION_ARG_CHAIN (t) == void_list_node\n+  tree chain = FUNCTION_ARG_CHAIN (t);\n+  if (!chain)\n+    return false;\n+  if (chain == void_list_node\n       || ((!global || flag_sized_deallocation)\n \t  && second_parm_is_size_t (t)))\n     return true;\n+  if (aligned_deallocation_fn_p (t))\n+    return true;\n   return false;\n }\n \n@@ -6076,7 +6142,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t\t t; t = OVL_NEXT (t))\n \t      {\n \t\ttree elt = OVL_CURRENT (t);\n-\t\tif (non_placement_deallocation_fn_p (elt)\n+\t\tif (usual_deallocation_fn_p (elt)\n \t\t    && FUNCTION_ARG_CHAIN (elt) == void_list_node)\n \t\t  goto ok;\n \t      }\n@@ -6118,51 +6184,62 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t t; t = OVL_NEXT (t))\n       {\n \ttree elt = OVL_CURRENT (t);\n-\tif (non_placement_deallocation_fn_p (elt))\n+\tif (usual_deallocation_fn_p (elt))\n \t  {\n-\t    fn = elt;\n-\t    /* \"If a class T has a member deallocation function named\n-\t       operator delete with exactly one parameter, then that\n-\t       function is a usual (non-placement) deallocation\n-\t       function. If class T does not declare such an operator\n-\t       delete but does declare a member deallocation function named\n-\t       operator delete with exactly two parameters, the second of\n-\t       which has type std::size_t (18.2), then this function is a\n-\t       usual deallocation function.\"\n-\n-\t       So in a class (void*) beats (void*, size_t).  */\n-\t    if (DECL_CLASS_SCOPE_P (fn))\n+\t    if (!fn)\n \t      {\n-\t\tif (FUNCTION_ARG_CHAIN (fn) == void_list_node)\n-\t\t  break;\n+\t\tfn = elt;\n+\t\tcontinue;\n \t      }\n-\t    /* At global scope (in C++14 and above) the rules are different:\n-\n-\t       If deallocation function lookup finds both a usual\n-\t       deallocation function with only a pointer parameter and a\n-\t       usual deallocation function with both a pointer parameter\n-\t       and a size parameter, the function to be called is selected\n-\t       as follows:\n-\n-\t       * If the type is complete and if, for the second alternative\n-\t       (delete array) only, the operand is a pointer to a class\n-\t       type with a non-trivial destructor or a (possibly\n-\t       multi-dimensional) array thereof, the function with two\n-\t       parameters is selected.\n-\n-\t       * Otherwise, it is unspecified which of the two deallocation\n-\t       functions is selected. */\n+\n+\t    /* -- If the type has new-extended alignment, a function with a\n+\t       parameter of type std::align_val_t is preferred; otherwise a\n+\t       function without such a parameter is preferred. If exactly one\n+\t       preferred function is found, that function is selected and the\n+\t       selection process terminates. If more than one preferred\n+\t       function is found, all non-preferred functions are eliminated\n+\t       from further consideration.  */\n+\t    if (aligned_new_threshhold)\n+\t      {\n+\t\tbool want_align = type_has_new_extended_alignment (type);\n+\t\tbool fn_align = aligned_deallocation_fn_p (fn);\n+\t\tbool elt_align = aligned_deallocation_fn_p (elt);\n+\n+\t\tif (elt_align != fn_align)\n+\t\t  {\n+\t\t    if (want_align == elt_align)\n+\t\t      fn = elt;\n+\t\t    continue;\n+\t\t  }\n+\t      }\n+\n+\t    /* -- If the deallocation functions have class scope, the one\n+\t       without a parameter of type std::size_t is selected.  */\n+\t    bool want_size;\n+\t    if (DECL_CLASS_SCOPE_P (fn))\n+\t      want_size = false;\n+\n+\t    /* -- If the type is complete and if, for the second alternative\n+\t       (delete array) only, the operand is a pointer to a class type\n+\t       with a non-trivial destructor or a (possibly multi-dimensional)\n+\t       array thereof, the function with a parameter of type std::size_t\n+\t       is selected.\n+\n+\t       -- Otherwise, it is unspecified whether a deallocation function\n+\t       with a parameter of type std::size_t is selected.  */\n \t    else\n \t      {\n-\t\tbool want_size = COMPLETE_TYPE_P (type);\n+\t\twant_size = COMPLETE_TYPE_P (type);\n \t\tif (code == VEC_DELETE_EXPR\n \t\t    && !TYPE_VEC_NEW_USES_COOKIE (type))\n \t\t  /* We need a cookie to determine the array size.  */\n \t\t  want_size = false;\n-\t\tbool have_size = (FUNCTION_ARG_CHAIN (fn) != void_list_node);\n-\t\tif (want_size == have_size)\n-\t\t  break;\n \t      }\n+\t    bool fn_size = second_parm_is_size_t (fn);\n+\t    bool elt_size = second_parm_is_size_t (elt);\n+\t    gcc_assert (fn_size != elt_size);\n+\t    if (want_size == elt_size)\n+\t      fn = elt;\n \t  }\n       }\n \n@@ -6200,8 +6277,13 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t  tree ret;\n \t  vec<tree, va_gc> *args = make_tree_vector ();\n \t  args->quick_push (addr);\n-\t  if (FUNCTION_ARG_CHAIN (fn) != void_list_node)\n+\t  if (second_parm_is_size_t (fn))\n \t    args->quick_push (size);\n+\t  if (aligned_deallocation_fn_p (fn))\n+\t    {\n+\t      tree al = build_int_cst (align_type_node, TYPE_ALIGN_UNIT (type));\n+\t      args->quick_push (al);\n+\t    }\n \t  ret = cp_build_function_call_vec (fn, &args, complain);\n \t  release_tree_vector (args);\n \t  return ret;"}, {"sha": "d4bfb26d1e390252fe46edca17b0497099bd2fc9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -1147,6 +1147,8 @@ enum cp_tree_index\n     CPTI_NULLPTR,\n     CPTI_NULLPTR_TYPE,\n \n+    CPTI_ALIGN_TYPE,\n+\n     CPTI_MAX\n };\n \n@@ -1182,6 +1184,8 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]\n #define nullptr_node\t\t\tcp_global_trees[CPTI_NULLPTR]\n #define nullptr_type_node\t\tcp_global_trees[CPTI_NULLPTR_TYPE]\n+/* std::align_val_t */\n+#define align_type_node\t\t\tcp_global_trees[CPTI_ALIGN_TYPE]\n \n /* We cache these tree nodes so as to call get_identifier less\n    frequently.  */\n@@ -5561,7 +5565,7 @@ extern tree build_user_type_conversion\t\t(tree, tree, int,\n extern tree build_new_function_call\t\t(tree, vec<tree, va_gc> **, bool, \n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_operator_new_call\t\t(tree, vec<tree, va_gc> **, tree *,\n-\t\t\t\t\t\t tree *, tree, tree *,\n+\t\t\t\t\t\t tree *, tree, tree, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_new_method_call\t\t(tree, tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tree, int, tree *,\n@@ -5573,7 +5577,8 @@ extern tree build_new_op\t\t\t(location_t, enum tree_code,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_op_call\t\t\t(tree, vec<tree, va_gc> **,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern bool non_placement_deallocation_fn_p\t(tree);\n+extern bool aligned_allocation_fn_p\t\t(tree);\n+extern bool usual_deallocation_fn_p\t(tree);\n extern tree build_op_delete_call\t\t(enum tree_code, tree, tree,\n \t\t\t\t\t\t bool, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n@@ -5966,6 +5971,7 @@ extern tree get_nsdmi\t\t\t\t(tree, bool);\n extern tree build_offset_ref\t\t\t(tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree throw_bad_array_new_length\t\t(void);\n+extern bool type_has_new_extended_alignment\t(tree);\n extern tree build_new\t\t\t\t(vec<tree, va_gc> **, tree, tree,\n \t\t\t\t\t\t vec<tree, va_gc> **, int,\n                                                  tsubst_flags_t);\n@@ -6528,6 +6534,7 @@ extern tree build_min_nt_loc\t\t\t(location_t, enum tree_code,\n extern tree build_min_non_dep\t\t\t(enum tree_code, tree, ...);\n extern tree build_min_non_dep_op_overload\t(enum tree_code, tree, tree, ...);\n extern tree build_min_non_dep_call_vec\t\t(tree, tree, vec<tree, va_gc> *);\n+extern vec<tree, va_gc>* vec_copy_and_insert    (vec<tree, va_gc>*, tree, unsigned);\n extern tree build_cplus_new\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_aggr_init_expr\t\t(tree, tree);\n extern tree get_target_expr\t\t\t(tree);"}, {"sha": "9d91387c7f1b91ce378efe7d189c31272ec75929", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -4132,6 +4132,17 @@ cxx_init_decl_processing (void)\n   /* Now, C++.  */\n   current_lang_name = lang_name_cplusplus;\n \n+  if (aligned_new_threshhold > 1\n+      && exact_log2 (aligned_new_threshhold) == -1)\n+    {\n+      error (\"-faligned-new=%d is not a power of two\", aligned_new_threshhold);\n+      aligned_new_threshhold = 1;\n+    }\n+  if (aligned_new_threshhold == -1)\n+    aligned_new_threshhold = (cxx_dialect >= cxx1z) ? 1 : 0;\n+  if (aligned_new_threshhold == 1)\n+    aligned_new_threshhold = max_align_t_align () / BITS_PER_UNIT;\n+\n   {\n     tree newattrs, extvisattr;\n     tree newtype, deltype;\n@@ -4199,6 +4210,47 @@ cxx_init_decl_processing (void)\n \tpush_cp_library_fn (VEC_DELETE_EXPR, deltype, ECF_NOTHROW);\n       }\n \n+    if (aligned_new_threshhold)\n+      {\n+\tpush_namespace (std_identifier);\n+\ttree align_id = get_identifier (\"align_val_t\");\n+\talign_type_node = start_enum (align_id, NULL_TREE, size_type_node,\n+\t\t\t\t      NULL_TREE, /*scoped*/true, NULL);\n+\tpop_namespace ();\n+\n+\t/* operator new (size_t, align_val_t); */\n+\tnewtype = build_function_type_list (ptr_type_node, size_type_node,\n+\t\t\t\t\t    align_type_node, NULL_TREE);\n+\tnewtype = cp_build_type_attribute_variant (newtype, newattrs);\n+\tnewtype = build_exception_variant (newtype, new_eh_spec);\n+\topnew = push_cp_library_fn (NEW_EXPR, newtype, 0);\n+\tDECL_IS_MALLOC (opnew) = 1;\n+\tDECL_IS_OPERATOR_NEW (opnew) = 1;\n+\topnew = push_cp_library_fn (VEC_NEW_EXPR, newtype, 0);\n+\tDECL_IS_MALLOC (opnew) = 1;\n+\tDECL_IS_OPERATOR_NEW (opnew) = 1;\n+\n+\t/* operator delete (void *, align_val_t); */\n+\tdeltype = build_function_type_list (void_type_node, ptr_type_node,\n+\t\t\t\t\t    align_type_node, NULL_TREE);\n+\tdeltype = cp_build_type_attribute_variant (deltype, extvisattr);\n+\tdeltype = build_exception_variant (deltype, empty_except_spec);\n+\tpush_cp_library_fn (DELETE_EXPR, deltype, ECF_NOTHROW);\n+\tpush_cp_library_fn (VEC_DELETE_EXPR, deltype, ECF_NOTHROW);\n+\n+\tif (flag_sized_deallocation)\n+\t  {\n+\t    /* operator delete (void *, size_t, align_val_t); */\n+\t    deltype = build_function_type_list (void_type_node, ptr_type_node,\n+\t\t\t\t\t\tsize_type_node, align_type_node,\n+\t\t\t\t\t\tNULL_TREE);\n+\t    deltype = cp_build_type_attribute_variant (deltype, extvisattr);\n+\t    deltype = build_exception_variant (deltype, empty_except_spec);\n+\t    push_cp_library_fn (DELETE_EXPR, deltype, ECF_NOTHROW);\n+\t    push_cp_library_fn (VEC_DELETE_EXPR, deltype, ECF_NOTHROW);\n+\t  }\n+      }\n+\n     nullptr_type_node = make_node (NULLPTR_TYPE);\n     TYPE_SIZE (nullptr_type_node) = bitsize_int (GET_MODE_BITSIZE (ptr_mode));\n     TYPE_SIZE_UNIT (nullptr_type_node) = size_int (GET_MODE_SIZE (ptr_mode));"}, {"sha": "a320f92d402b15b2dd61fb5495c733f210848b37", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -4488,7 +4488,7 @@ maybe_warn_sized_delete (enum tree_code code)\n     {\n       tree fn = OVL_CURRENT (ovl);\n       /* We're only interested in usual deallocation functions.  */\n-      if (!non_placement_deallocation_fn_p (fn))\n+      if (!usual_deallocation_fn_p (fn))\n \tcontinue;\n       if (FUNCTION_ARG_CHAIN (fn) == void_list_node)\n \tunsized = fn;"}, {"sha": "5bb7f2911179d4638a0ffd15e19bd8f76f6fa738", "filename": "gcc/cp/init.c", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -2569,6 +2569,15 @@ warn_placement_new_too_small (tree type, tree nelts, tree size, tree oper)\n     }\n }\n \n+/* True if alignof(T) > __STDCPP_DEFAULT_NEW_ALIGNMENT__.  */\n+\n+bool\n+type_has_new_extended_alignment (tree t)\n+{\n+  return (aligned_new_threshhold\n+\t  && TYPE_ALIGN_UNIT (t) > (unsigned)aligned_new_threshhold);\n+}\n+\n /* Generate code for a new-expression, including calling the \"operator\n    new\" function, initializing the object, and, if an exception occurs\n    during construction, cleaning up.  The arguments are as for\n@@ -2840,6 +2849,10 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t}\n     }\n \n+  tree align_arg = NULL_TREE;\n+  if (type_has_new_extended_alignment (elt_type))\n+    align_arg = build_int_cst (align_type_node, TYPE_ALIGN_UNIT (elt_type));\n+\n   alloc_fn = NULL_TREE;\n \n   /* If PLACEMENT is a single simple pointer type not passed by\n@@ -2954,12 +2967,28 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n                 }\n \t      return error_mark_node;\n \t    }\n-\t  alloc_call = build_new_method_call (build_dummy_object (elt_type),\n-\t\t\t\t\t      fns, placement,\n-\t\t\t\t\t      /*conversion_path=*/NULL_TREE,\n-\t\t\t\t\t      LOOKUP_NORMAL,\n-\t\t\t\t\t      &alloc_fn,\n-\t\t\t\t\t      complain);\n+\t  tree dummy = build_dummy_object (elt_type);\n+\t  alloc_call = NULL_TREE;\n+\t  if (align_arg)\n+\t    {\n+\t      vec<tree, va_gc> *align_args\n+\t\t= vec_copy_and_insert (*placement, align_arg, 1);\n+\t      alloc_call\n+\t\t= build_new_method_call (dummy, fns, &align_args,\n+\t\t\t\t\t /*conversion_path=*/NULL_TREE,\n+\t\t\t\t\t LOOKUP_NORMAL, &alloc_fn, tf_none);\n+\t      /* If no matching function is found and the allocated object type\n+\t\t has new-extended alignment, the alignment argument is removed\n+\t\t from the argument list, and overload resolution is performed\n+\t\t again.  */\n+\t      if (alloc_call == error_mark_node)\n+\t\talloc_call = NULL_TREE;\n+\t    }\n+\t  if (!alloc_call)\n+\t    alloc_call = build_new_method_call (dummy, fns, placement,\n+\t\t\t\t\t\t/*conversion_path=*/NULL_TREE,\n+\t\t\t\t\t\tLOOKUP_NORMAL,\n+\t\t\t\t\t\t&alloc_fn, complain);\n \t}\n       else\n \t{\n@@ -2976,6 +3005,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n \t  alloc_call = build_operator_new_call (fnname, placement,\n \t\t\t\t\t\t&size, &cookie_size,\n+\t\t\t\t\t\talign_arg,\n \t\t\t\t\t\touter_nelts_check,\n \t\t\t\t\t\t&alloc_fn, complain);\n \t}\n@@ -2986,6 +3016,20 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n   gcc_assert (alloc_fn != NULL_TREE);\n \n+  if (warn_aligned_new\n+      && TYPE_ALIGN (elt_type) > max_align_t_align ()\n+      && (warn_aligned_new > 1\n+\t  || CP_DECL_CONTEXT (alloc_fn) == global_namespace)\n+      && !aligned_allocation_fn_p (alloc_fn))\n+    {\n+      warning (OPT_Waligned_new_, \"%<new%> of type %qT with extended \"\n+\t       \"alignment %d\", elt_type, TYPE_ALIGN_UNIT (elt_type));\n+      inform (input_location, \"uses %qD, which does not have an alignment \"\n+\t      \"parameter\", alloc_fn);\n+      inform (input_location, \"use %<-faligned-new%> to enable C++17 \"\n+\t      \"over-aligned new support\");\n+    }\n+\n   /* If we found a simple case of PLACEMENT_EXPR above, then copy it\n      into a temporary variable.  */\n   if (!processing_template_decl"}, {"sha": "bd2e8f667390780abf53760cc9e4b1365f242fd8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -2920,6 +2920,30 @@ build_min_non_dep_op_overload (enum tree_code op,\n   return call;\n }\n \n+/* Return a new tree vec copied from VEC, with ELT inserted at index IDX.  */\n+\n+vec<tree, va_gc> *\n+vec_copy_and_insert (vec<tree, va_gc> *old_vec, tree elt, unsigned idx)\n+{\n+  unsigned len = vec_safe_length (old_vec);\n+  gcc_assert (idx <= len);\n+\n+  vec<tree, va_gc> *new_vec = NULL;\n+  vec_alloc (new_vec, len + 1);\n+\n+  unsigned i;\n+  for (i = 0; i < len; ++i)\n+    {\n+      if (i == idx)\n+\tnew_vec->quick_push (elt);\n+      new_vec->quick_push ((*old_vec)[i]);\n+    }\n+  if (i == idx)\n+    new_vec->quick_push (elt);\n+\n+  return new_vec;\n+}\n+\n tree\n get_type_decl (tree t)\n {"}, {"sha": "b2eaea7c15d2bc1b216fe5f38ea7a51554270960", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -190,7 +190,7 @@ in the following sections.\n @item C++ Language Options\n @xref{C++ Dialect Options,,Options Controlling C++ Dialect}.\n @gccoptlist{-fabi-version=@var{n}  -fno-access-control @gol\n--fargs-in-order=@var{n} -fcheck-new @gol\n+-faligned-new=@var{n} -fargs-in-order=@var{n} -fcheck-new @gol\n -fconstexpr-depth=@var{n} -fconstexpr-loop-limit=@var{n} @gol\n -ffriend-injection @gol\n -fno-elide-constructors @gol\n@@ -2237,6 +2237,15 @@ option is used for the warning.\n Turn off all access checking.  This switch is mainly useful for working\n around bugs in the access control code.\n \n+@item -faligned-new\n+@opindex faligned-new\n+Enable support for C++17 @code{new} of types that require more\n+alignment than @code{void* ::operator new(std::size_t)} provides.  A\n+numeric argument such as @code{-faligned-new=32} can be used to\n+specify how much alignment (in bytes) is provided by that function,\n+but few users will need to override the default of\n+@code{alignof(std::max_align_t)}.\n+\n @item -fcheck-new\n @opindex fcheck-new\n Check that the pointer returned by @code{operator new} is non-null\n@@ -5062,6 +5071,18 @@ disables the warnings about non-ISO @code{printf} / @code{scanf} format\n width specifiers @code{I32}, @code{I64}, and @code{I} used on Windows targets,\n which depend on the MS runtime.\n \n+@item -Waligned-new\n+@opindex Waligned-new\n+@opindex Wno-aligned-new\n+Warn about a new-expression of a type that requires greater alignment\n+than the @code{alignof(std::max_align_t)} but uses an allocation\n+function without an explicit alignment parameter. This option is\n+enabled by @option{-Wall}.\n+\n+Normally this only warns about global allocation functions, but\n+@option{-Waligned-new=all} also warns about class member allocation\n+functions.\n+\n @item -Wplacement-new\n @itemx -Wplacement-new=@var{n}\n @opindex Wplacement-new"}, {"sha": "b0a1e864effc3ffb1191ec74343b029b7b6e629c", "filename": "gcc/testsuite/g++.dg/cpp0x/Wattributes1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWattributes1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWattributes1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2FWattributes1.C?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -5,4 +5,4 @@\n #include <new>\n __attribute__((visibility(\"hidden\")))void*operator new(std::size_t); // { dg-warning \"visibility attribute ignored\" }\n \n-// { dg-message \"previous declaration\" \"\" { target *-*-* } 116 }\n+// { dg-message \"previous declaration\" \"\" { target *-*-* } 120 }"}, {"sha": "735296fd8fa74ebcdc8cc8c239ea43ac6d4a7980", "filename": "gcc/testsuite/g++.dg/cpp1z/aligned-new1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new1.C?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,17 @@\n+// { dg-options -std=c++1z }\n+// { dg-do run }\n+\n+#ifndef __STDCPP_DEFAULT_NEW_ALIGNMENT__\n+#error __STDCPP_DEFAULT_NEW_ALIGNMENT__ not defined\n+#endif\n+\n+#include <cstdint>\n+\n+struct alignas(64) A { int i; };\n+\n+int main()\n+{\n+  A *p = new A;\n+  if (std::intptr_t(p) % 64 != 0)\n+    __builtin_abort();\n+}"}, {"sha": "fe159692b3bee142aa381a80d40a518b4ec0e72f", "filename": "gcc/testsuite/g++.dg/cpp1z/aligned-new2.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new2.C?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,31 @@\n+// { dg-options -std=c++1z }\n+// { dg-do run }\n+\n+#include <new>\n+\n+struct alignas(64) A {\n+  int i;\n+  A() { throw 42; }\n+};\n+struct B { int i; } b;\n+\n+void *operator new (std::size_t s, std::align_val_t a, B b)\n+{\n+  return operator new (s, a);\n+}\n+\n+bool deleted = false;\n+void operator delete (void *p, std::align_val_t, B)\n+{\n+  deleted = true;\n+}\n+\n+int main()\n+{\n+  try {\n+    A *p = new (b) A;\n+    __builtin_abort ();\n+  } catch (...) {}\n+  if (!deleted)\n+    __builtin_abort ();\n+}"}, {"sha": "73e33432542b9dfb6ebfe0751b9c96dc1a8b63c0", "filename": "gcc/testsuite/g++.dg/cpp1z/aligned-new3.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new3.C?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,23 @@\n+// { dg-options -std=c++1z }\n+// { dg-do run }\n+\n+#include <new>\n+\n+struct alignas(64) A {\n+  int i;\n+};\n+\n+bool deleted = false;\n+void operator delete (void *p, std::size_t, std::align_val_t)\n+{\n+  deleted = true;\n+  operator delete (p);\n+}\n+\n+int main()\n+{\n+  A *p = new A;\n+  delete p;\n+  if (!deleted)\n+    __builtin_abort();\n+}"}, {"sha": "cc63a1455898661c254d1b5d42fbe1aa8e2d7eba", "filename": "gcc/testsuite/g++.dg/cpp1z/aligned-new4.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new4.C?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++14 -Waligned-new\" }\n+\n+struct alignas(64) A { int i; };\n+struct alignas(64) B {\n+  int i;\n+  void *operator new(__SIZE_TYPE__);\n+};\n+\n+int main()\n+{\n+  A* ap = new A;\t\t// { dg-warning \"-Waligned-new\" }\n+  B* bp = new B;\n+}"}, {"sha": "eb178d46dff8cc9768d2a47cf24034d060e74f57", "filename": "gcc/testsuite/g++.dg/cpp1z/aligned-new4a.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new4a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new4a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new4a.C?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++14 -Waligned-new=all\" }\n+\n+struct alignas(64) A { int i; };\n+struct alignas(64) B {\n+  int i;\n+  void *operator new(__SIZE_TYPE__);\n+};\n+\n+int main()\n+{\n+  A* ap = new A;\t\t// { dg-warning \"-Waligned-new\" }\n+  B* bp = new B;\t\t// { dg-warning \"-Waligned-new\" }\n+}"}, {"sha": "525129e4c4049f655acc47f64a5ac8f0bc564eca", "filename": "gcc/testsuite/g++.dg/cpp1z/aligned-new5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Faligned-new5.C?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,14 @@\n+// { dg-options -faligned-new }\n+// { dg-do run }\n+\n+#include <new>\n+#include <stdint.h>\n+\n+struct A { int i; };\n+\n+int main()\n+{\n+  A* ap = new (std::align_val_t(64)) A;\n+  if (intptr_t(ap) % 64 != 0)\n+    __builtin_abort();\n+}"}, {"sha": "982572e65cc500310f012cdeafc60149b37e0153", "filename": "gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffeat-cxx1z.C?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -350,6 +350,12 @@\n #  error \"__cpp_if_constexpr != 201606\"\n #endif\n \n+#ifndef __cpp_aligned_new\n+#  error \"__cpp_aligned_new\"\n+#elif __cpp_aligned_new != 201606\n+#  error \"__cpp_aligned_new != 201606\"\n+#endif\n+\n #ifdef __has_cpp_attribute\n \n #  if ! __has_cpp_attribute(maybe_unused)"}, {"sha": "4ba6593664bfafde0eabc435f8ad042411905d58", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -1,3 +1,22 @@\n+2016-09-09  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P0035R4, C++17 new of over-aligned types.\n+\t* libsupc++/new: Declare aligned new/delete operators.\n+\t* config/abi/pre/gnu.ver: Export them.\n+\t* configure.ac: Check for aligned_alloc, posix_memalign, memalign,\n+\t_aligned_malloc.\n+\t* libsupc++/new_opa.cc: New.\n+\t* libsupc++/new_opant.cc: New.\n+\t* libsupc++/new_opva.cc: New.\n+\t* libsupc++/new_opva.cc: New.\n+\t* libsupc++/del_opa.cc: New.\n+\t* libsupc++/del_opant.cc: New.\n+\t* libsupc++/del_opsa.cc: New.\n+\t* libsupc++/del_opva.cc: New.\n+\t* libsupc++/del_opvant.cc: New.\n+\t* libsupc++/del_opvsa.cc: New.\n+\t* libsupc++/Makefile.am: Build them.\n+\n 2016-09-05  Tim Shen  <timshen@google.com>\n \n \t* include/std/variant: include bits/move.h for std::addressof."}, {"sha": "2ab6e0d6a49a14c4900a495e89aeb5241b267cf9", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -6,6 +6,9 @@\n /* Define to 1 if you have the `acosl' function. */\n #undef HAVE_ACOSL\n \n+/* Define to 1 if you have the `aligned_alloc' function. */\n+#undef HAVE_ALIGNED_ALLOC\n+\n /* Define to 1 if you have the `asinf' function. */\n #undef HAVE_ASINF\n \n@@ -285,6 +288,9 @@\n /* Define if mbstate_t exists in wchar.h. */\n #undef HAVE_MBSTATE_T\n \n+/* Define to 1 if you have the `memalign' function. */\n+#undef HAVE_MEMALIGN\n+\n /* Define to 1 if you have the <memory.h> header file. */\n #undef HAVE_MEMORY_H\n \n@@ -309,6 +315,9 @@\n /* Define if poll is available in <poll.h>. */\n #undef HAVE_POLL\n \n+/* Define to 1 if you have the `posix_memalign' function. */\n+#undef HAVE_POSIX_MEMALIGN\n+\n /* Define to 1 if you have the `powf' function. */\n #undef HAVE_POWF\n \n@@ -505,6 +514,9 @@\n /* Define to 1 if you have the `_acosl' function. */\n #undef HAVE__ACOSL\n \n+/* Define to 1 if you have the `_aligned_malloc' function. */\n+#undef HAVE__ALIGNED_MALLOC\n+\n /* Define to 1 if you have the `_asinf' function. */\n #undef HAVE__ASINF\n "}, {"sha": "9b5bb238b7ed3475fe2c860be51df26432c46a78", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -2197,6 +2197,18 @@ CXXABI_1.3.11 {\n     __cxa_init_primary_exception;\n     _ZNSt15__exception_ptr13exception_ptrC1EPv;\n \n+    # C++17 aligned new/delete\n+    _ZnwmSt11align_val_t;\n+    _ZnwmSt11align_val_tRKSt9nothrow_t;\n+    _ZnamSt11align_val_t;\n+    _ZnamSt11align_val_tRKSt9nothrow_t;\n+    _ZdlPvSt11align_val_t;\n+    _ZdlPvSt11align_val_tRKSt9nothrow_t;\n+    _ZdlPvmSt11align_val_t;\n+    _ZdaPvSt11align_val_t;\n+    _ZdaPvSt11align_val_tRKSt9nothrow_t;\n+    _ZdaPvmSt11align_val_t;\n+\n } CXXABI_1.3.10;\n \n # Symbols in the support library (libsupc++) supporting transactional memory."}, {"sha": "6332c4d7f87a959002fbf8b5728c64031681e977", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -27969,6 +27969,19 @@ if test \"x$ac_cv_func___cxa_thread_atexit_impl\" = x\"\"yes; then :\n #define HAVE___CXA_THREAD_ATEXIT_IMPL 1\n _ACEOF\n \n+fi\n+done\n+\n+  for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc\n+do :\n+  as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n+ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\"\n+eval as_val=\\$$as_ac_var\n+   if test \"x$as_val\" = x\"\"yes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define `$as_echo \"HAVE_$ac_func\" | $as_tr_cpp` 1\n+_ACEOF\n+\n fi\n done\n "}, {"sha": "5657ecb27dc505ce4ec514611596751a480d9a7f", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -256,6 +256,7 @@ if $GLIBCXX_IS_NATIVE; then\n   GCC_CHECK_TLS\n \n   AC_CHECK_FUNCS(__cxa_thread_atexit_impl)\n+  AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)\n \n   # For iconv support.\n   AM_ICONV"}, {"sha": "2df31ff668ef8e1b31198edfb6723a42ea9b196c", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -88,6 +88,16 @@ sources = \\\n \tnew_opnt.cc \\\n \tnew_opv.cc \\\n \tnew_opvnt.cc \\\n+\tnew_opa.cc \\\n+\tnew_opant.cc \\\n+\tnew_opva.cc \\\n+\tnew_opvant.cc \\\n+\tdel_opa.cc \\\n+\tdel_opant.cc \\\n+\tdel_opsa.cc \\\n+\tdel_opva.cc \\\n+\tdel_opvant.cc \\\n+\tdel_opvsa.cc \\\n \tpbase_type_info.cc \\\n \tpmem_type_info.cc \\\n \tpointer_type_info.cc \\\n@@ -189,6 +199,28 @@ del_opvs.lo: del_opvs.cc\n del_opvs.o: del_opvs.cc\n \t$(CXXCOMPILE) -std=gnu++14 -Wno-sized-deallocation -c $<\n \n+# Use special rules for the C++17 sources so that the proper flags are passed.\n+new_opa.lo: new_opa.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+new_opant.lo: new_opant.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+new_opva.lo: new_opva.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+new_opvant.lo: new_opvant.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opa.lo: del_opa.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opant.lo: del_opant.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opsa.lo: del_opsa.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opva.lo: del_opva.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opvant.lo: del_opvant.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opvsa.lo: del_opvsa.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+\n # AM_CXXFLAGS needs to be in each subdirectory so that it can be\n # modified in a per-library or per-sub-library way.  Need to manually\n # set this option because CONFIG_CXXFLAGS has to be after"}, {"sha": "e828ed909cae06e4455644db825742439fdda5fa", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -125,9 +125,11 @@ am__objects_1 = array_type_info.lo atexit_arm.lo atexit_thread.lo \\\n \tfunction_type_info.lo fundamental_type_info.lo guard.lo \\\n \tguard_error.lo hash_bytes.lo nested_exception.lo \\\n \tnew_handler.lo new_op.lo new_opnt.lo new_opv.lo new_opvnt.lo \\\n-\tpbase_type_info.lo pmem_type_info.lo pointer_type_info.lo \\\n-\tpure.lo si_class_type_info.lo tinfo.lo tinfo2.lo vec.lo \\\n-\tvmi_class_type_info.lo vterminate.lo\n+\tnew_opa.lo new_opant.lo new_opva.lo new_opvant.lo del_opa.lo \\\n+\tdel_opant.lo del_opsa.lo del_opva.lo del_opvant.lo \\\n+\tdel_opvsa.lo pbase_type_info.lo pmem_type_info.lo \\\n+\tpointer_type_info.lo pure.lo si_class_type_info.lo tinfo.lo \\\n+\ttinfo2.lo vec.lo vmi_class_type_info.lo vterminate.lo\n @GLIBCXX_HOSTED_TRUE@am__objects_2 = cp-demangle.lo\n @ENABLE_VTABLE_VERIFY_TRUE@@VTV_CYGMIN_FALSE@am__objects_3 =  \\\n @ENABLE_VTABLE_VERIFY_TRUE@@VTV_CYGMIN_FALSE@\tvtv_stubs.lo\n@@ -445,6 +447,16 @@ sources = \\\n \tnew_opnt.cc \\\n \tnew_opv.cc \\\n \tnew_opvnt.cc \\\n+\tnew_opa.cc \\\n+\tnew_opant.cc \\\n+\tnew_opva.cc \\\n+\tnew_opvant.cc \\\n+\tdel_opa.cc \\\n+\tdel_opant.cc \\\n+\tdel_opsa.cc \\\n+\tdel_opva.cc \\\n+\tdel_opvant.cc \\\n+\tdel_opvsa.cc \\\n \tpbase_type_info.cc \\\n \tpmem_type_info.cc \\\n \tpointer_type_info.cc \\\n@@ -916,6 +928,28 @@ del_opvs.lo: del_opvs.cc\n del_opvs.o: del_opvs.cc\n \t$(CXXCOMPILE) -std=gnu++14 -Wno-sized-deallocation -c $<\n \n+# Use special rules for the C++17 sources so that the proper flags are passed.\n+new_opa.lo: new_opa.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+new_opant.lo: new_opant.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+new_opva.lo: new_opva.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+new_opvant.lo: new_opvant.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opa.lo: del_opa.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opant.lo: del_opant.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opsa.lo: del_opsa.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opva.lo: del_opva.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opvant.lo: del_opvant.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+del_opvsa.lo: del_opvsa.cc\n+\t$(LTCXXCOMPILE) -std=gnu++1z -c $<\n+\n install-stdHEADERS: $(std_HEADERS)\n \t@$(NORMAL_INSTALL)\n \t$(mkinstalldirs) $(DESTDIR)$(stddir)"}, {"sha": "889bdb719350e4cb448f13a74a598d1f0431c9d4", "filename": "libstdc++-v3/libsupc++/del_opa.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opa.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,54 @@\n+// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+\n+#if !_GLIBCXX_HOSTED\n+// A freestanding C runtime may not provide \"free\" -- but there is no\n+// other reasonable way to implement \"operator delete\".\n+namespace std\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+  extern \"C\" void free(void*);\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+#else\n+# include <cstdlib>\n+#endif\n+\n+#include \"new\"\n+\n+// The sized deletes are defined in other files.\n+#pragma GCC diagnostic ignored \"-Wsized-deallocation\"\n+\n+_GLIBCXX_WEAK_DEFINITION void\n+operator delete(void* ptr, std::align_val_t) _GLIBCXX_USE_NOEXCEPT\n+{\n+#if !_GLIBCXX_HAVE_ALIGNED_ALLOC && _GLIBCXX_HAVE__ALIGNED_MALLOC\n+  _aligned_free (ptr);\n+#else\n+  std::free(ptr);\n+#endif\n+}"}, {"sha": "1b1919ce927025ee36e1e362d5d7ce09d44e58af", "filename": "libstdc++-v3/libsupc++/del_opant.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opant.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opant.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opant.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,33 @@\n+// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#include \"new\"\n+\n+_GLIBCXX_WEAK_DEFINITION void\n+operator delete (void *ptr, std::align_val_t al, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT\n+{\n+  ::operator delete (ptr, al);\n+}"}, {"sha": "7880efeb27933ac90850c8ab1d360bda02dda2ba", "filename": "libstdc++-v3/libsupc++/del_opsa.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opsa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opsa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opsa.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,33 @@\n+// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#include \"new\"\n+\n+_GLIBCXX_WEAK_DEFINITION void\n+operator delete(void* ptr, std::size_t, std::align_val_t al) _GLIBCXX_USE_NOEXCEPT\n+{\n+  ::operator delete (ptr, al);\n+}"}, {"sha": "95d2a3f8d2489b18dbf12962b46620b98827ab29", "filename": "libstdc++-v3/libsupc++/del_opva.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opva.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opva.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opva.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,36 @@\n+// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#include \"new\"\n+\n+// The sized deletes are defined in other files.\n+#pragma GCC diagnostic ignored \"-Wsized-deallocation\"\n+\n+_GLIBCXX_WEAK_DEFINITION void\n+operator delete[] (void *ptr, std::align_val_t al) _GLIBCXX_USE_NOEXCEPT\n+{\n+  ::operator delete (ptr, al);\n+}"}, {"sha": "5840c8f70e0a92ee90dbf9ebebecf3fc000cbb46", "filename": "libstdc++-v3/libsupc++/del_opvant.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opvant.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opvant.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opvant.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,33 @@\n+// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#include \"new\"\n+\n+_GLIBCXX_WEAK_DEFINITION void\n+operator delete[] (void *ptr, std::align_val_t al, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT\n+{\n+  ::operator delete[] (ptr, al);\n+}"}, {"sha": "61586b06e1111d50a9078cfb1960cf63b2a83cae", "filename": "libstdc++-v3/libsupc++/del_opvsa.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opvsa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opvsa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fdel_opvsa.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,33 @@\n+// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#include \"new\"\n+\n+_GLIBCXX_WEAK_DEFINITION void\n+operator delete[] (void *ptr, std::size_t, std::align_val_t al) _GLIBCXX_USE_NOEXCEPT\n+{\n+  ::operator delete[] (ptr, al);\n+}"}, {"sha": "477fadc218cb4d8d620bee2be10a617d7431a341", "filename": "libstdc++-v3/libsupc++/new", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -79,6 +79,10 @@ namespace std\n   };\n #endif\n \n+#if __cpp_aligned_new\n+  enum class align_val_t: size_t {};\n+#endif\n+\n   struct nothrow_t\n   {\n #if __cplusplus >= 201103L\n@@ -135,6 +139,30 @@ void operator delete(void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT\n   __attribute__((__externally_visible__));\n void operator delete[](void*, const std::nothrow_t&) _GLIBCXX_USE_NOEXCEPT\n   __attribute__((__externally_visible__));\n+#if __cpp_aligned_new\n+void* operator new(std::size_t, std::align_val_t)\n+  __attribute__((__externally_visible__));\n+void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)\n+  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n+void operator delete(void*, std::align_val_t)\n+  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n+void operator delete(void*, std::align_val_t, const std::nothrow_t&)\n+  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n+void* operator new[](std::size_t, std::align_val_t)\n+  __attribute__((__externally_visible__));\n+void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)\n+  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n+void operator delete[](void*, std::align_val_t)\n+  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n+void operator delete[](void*, std::align_val_t, const std::nothrow_t&)\n+  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n+#if __cpp_sized_deallocation\n+void operator delete(void*, std::size_t, std::align_val_t)\n+  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n+void operator delete[](void*, std::size_t, std::align_val_t)\n+  _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));\n+#endif // __cpp_sized_deallocation\n+#endif // __cpp_aligned_new\n \n // Default placement versions of operator new.\n inline void* operator new(std::size_t, void* __p) _GLIBCXX_USE_NOEXCEPT"}, {"sha": "6ff5421bd152ba98d76a963a9d1a7a45bcd7d4ea", "filename": "libstdc++-v3/libsupc++/new_opa.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opa.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,76 @@\n+// Support routines for the -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#include <stdlib.h>\n+#include <bits/exception_defines.h>\n+#include \"new\"\n+\n+using std::new_handler;\n+using std::bad_alloc;\n+\n+#if !_GLIBCXX_HAVE_ALIGNED_ALLOC\n+#if _GLIBCXX_HAVE__ALIGNED_MALLOC\n+#define aligned_alloc(al,sz) _aligned_malloc(sz,al)\n+#elif _GLIBCXX_HAVE_POSIX_MEMALIGN\n+static inline void*\n+aligned_alloc (std::size_t al, std::size_t sz)\n+{\n+  void *ptr;\n+  int ret = posix_memalign (&ptr, al, sz);\n+  if (ret == 0)\n+    return ptr;\n+  return nullptr;\n+}\n+#elif _GLIBCXX_HAVE_MEMALIGN\n+#include <malloc.h>\n+#define aligned_alloc memalign\n+#else\n+// The C library doesn't provide any aligned allocation functions, declare\n+// aligned_alloc and get a link failure if aligned new is used.\n+extern \"C\" void *aligned_alloc(std::size_t, std::size_t);\n+#endif\n+#endif\n+\n+_GLIBCXX_WEAK_DEFINITION void *\n+operator new (std::size_t sz, std::align_val_t al)\n+{\n+  void *p;\n+\n+  /* malloc (0) is unpredictable; avoid it.  */\n+  if (sz == 0)\n+    sz = 1;\n+\n+  while (__builtin_expect ((p = aligned_alloc ((std::size_t)al, sz)) == 0,\n+\t\t\t   false))\n+    {\n+      new_handler handler = std::get_new_handler ();\n+      if (! handler)\n+\t_GLIBCXX_THROW_OR_ABORT(bad_alloc());\n+      handler ();\n+    }\n+\n+  return p;\n+}"}, {"sha": "c863d64f2d4806fd6d7d98ae3ddb05ac37618b9a", "filename": "libstdc++-v3/libsupc++/new_opant.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opant.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opant.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opant.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,41 @@\n+// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#include \"new\"\n+\n+_GLIBCXX_WEAK_DEFINITION void*\n+operator new(std::size_t sz, std::align_val_t al, const std::nothrow_t&)\n+  _GLIBCXX_USE_NOEXCEPT\n+{\n+  __try\n+    {\n+      return operator new(sz, al);\n+    }\n+  __catch(...)\n+    {\n+      return 0;\n+    }\n+}"}, {"sha": "7109431b2696f0d05cef1d94f132e00d67a886f9", "filename": "libstdc++-v3/libsupc++/new_opva.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opva.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opva.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opva.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,33 @@\n+// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#include \"new\"\n+\n+_GLIBCXX_WEAK_DEFINITION void*\n+operator new[] (std::size_t sz, std::align_val_t al)\n+{\n+  return ::operator new(sz, al);\n+}"}, {"sha": "a32fec8432a824e9ef85f26cc69a749886e19236", "filename": "libstdc++-v3/libsupc++/new_opvant.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opvant.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af63ba4b309ea3ff8946be59e8dba7333594f4ff/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opvant.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fnew_opvant.cc?ref=af63ba4b309ea3ff8946be59e8dba7333594f4ff", "patch": "@@ -0,0 +1,41 @@\n+// Boilerplate support routines for -*- C++ -*- dynamic memory management.\n+\n+// Copyright (C) 1997-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// GCC is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <bits/c++config.h>\n+#include \"new\"\n+\n+_GLIBCXX_WEAK_DEFINITION void*\n+operator new[] (std::size_t sz, std::align_val_t al, const std::nothrow_t&)\n+  _GLIBCXX_USE_NOEXCEPT\n+{\n+  __try\n+    {\n+      return ::operator new[](sz, al);\n+    }\n+  __catch(...)\n+    {\n+      return 0;\n+    }\n+}"}]}