{"sha": "09ef48fe18e9314a3b9a42692864644c01e5b50d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDllZjQ4ZmUxOGU5MzE0YTNiOWE0MjY5Mjg2NDY0NGMwMWU1YjUwZA==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2007-06-06T10:16:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:16:54Z"}, "message": "gigi.h, trans.c (Identifier_to_gnu): Change test for deferred constant by adding guard that the entity is an...\n\n2007-04-20  Gary Dismukes  <dismukes@adacore.com>\n\t    Eric Botcazou  <ebotcazou@adacore.com>\n\t    Tristan Gingold  <gingold@adacore.com>\n\t    Olivier Hainque  <hainque@adacore.com>\n\n\t* gigi.h, trans.c (Identifier_to_gnu): Change test for deferred\n\tconstant by adding guard that the entity is an E_Constant before\n\ttesting presence of Full_view (and remove now-unnecessary test that\n\tentity is not a type).\n\tFor a CONST_DECL used by reference, manually retrieve\n\tthe DECL_INITIAL.  Do not invoke fold in the other DECL_P cases either.\n\t(struct language_function): Move from utils.c to here.\n\t(struct parm_attr): New structure.\n\t(parm_attr, parm_attr vector, parm_attr GC vector): New types.\n\t(f_parm_attr_cache): New macro.\n\t(Attribute_to_gnu) <Attr_Length>: When not optimizing, cache the\n\texpressions for the 'First, 'Last and 'Length attributes of the\n\tunconstrained array IN parameters.\n\t(Subprogram_Body_to_gnu): Use gnu_subprog_decl throughout.\n\tAllocate the information structure for the function earlier, as well\n\tas the language-specific part.\n\tIf the parameter attributes cache has been populated, evaluate the\n\tcached expressions on entry.\n\t(takes_address): Add OPERAND_TYPE parameter.  Handle N_Function_Call,\n\tN_Procedure_Call_Statement and N_Indexed_Component.\n\t(Pragma_to_gnu): Translate inspection_point to an asm statement\n\tcontainaing a comment and a reference to the object (either its address\n\tfor BLKmode or its value).\n\t(Identifier_to_gnu): Use TREE_CONSTANT instead of CONST_DECL to decide\n\tto go to DECL_INITIAL. Together with the size constraint relaxation\n\tin create_var_decl, enlarges the set of situations in which an\n\tidentifier may be used as an initializer without implying elaboration\n\tcode.\n\t(Subprogram_Body_to_gnu): Do not fiddle with the debug interface but set\n\tDECL_IGNORED_P on the function if Needs_Debug_Info is not set on the\n\tnode.\n\t(maybe_stabilize_reference): Remove lvalues_only parameter.\n\t(gnat_stabilize_reference): Adjust for above change.\n\t(gnat_to_gnu): Do not set location information on the result\n\tif it is a reference.\n\t(add_cleanup): Add gnat_node parameter and set the location of the\n\tcleanup to it.\n\t(Handled_Sequence_Of_Statements_to_gnu): Adjust calls to add_cleanup.\n\t(Exception_Handler_to_gnu_zcx): Likewise.\n\t(gigi): Remove the cgraph node if the elaboration procedure is empty.\n\t(Subprogram_Body_to_gnu): If a stub is attached to the subprogram, emit\n\tthe former right after the latter.\n\t(start_stmt_group): Make global.\n\t(end_stmt_group): Likewise.\n\t(gnu_constraint_error_label_stack, gnu_storage_error_label_stack): New\n\tvars.\n\t(gnu_program_error_label_stack): Likewise.\n\t(gigi): Initialize them.\n\t(call_to_gnu, gnat_to_gnu, emit_check): Add new arg to build_call_raise.\n\t(gnat_to_gnu, N_{Push,Pop}_{Constraint,Storage,Program}_Error_Label):\n\tNew cases.\n\t(push_exception_label_stack): New function.\n\t(takes_address): New function.\n\n\t* utils.c (struct language_function): Move to trans.c from here.\n\t(unchecked_convert): Do not wrap up integer constants in\n\tVIEW_CONVERT_EXPRs.\n\t(create_var_decl_1): Decouple TREE_CONSTANT from CONST_DECL. Prevent\n\tthe latter for aggregate types, unexpected by later passes, and relax an\n\tarbitrary size constraint on the former.\n\t(create_field_decl): Use tree_int_cst_equal instead of operand_equal_p\n\tto compare the sizes.\n\t(convert_vms_descriptor): When converting to a fat pointer type, be\n\tprepared for a S descriptor at runtime in spite of a SB specification.\n\t(shift_unc_components_for_thin_pointers): New function.\n\t(write_record_type_debug_info): For variable-sized fields, cap the\n\talignment of the pointer to the computed alignment.\n\t(finish_record_type): Change HAS_REP parameter into REP_LEVEL.\n\tIf REP_LEVEL is 2, do not compute the sizes.\n\t(build_vms_descriptor): Adjust for new prototype of finish_record_type.\n\t(build_unc_object_type): Likewise.\n\t(declare_debug_type): New function.\n\n        * ada-tree.def: USE_STMT: removed (not emitted anymore).\n\n        * misc.c (gnat_expand_expr): Call to gnat_expand_stmt removed because\n        no statement is expandable anymore.\n        (gnat_init_gcc_eh): Do not initialize the DWARF-2 CFI machinery twice.\n        (gnat_handle_option): Only allow flag_eliminate_debug_types to be set\n        when the user requested it explicitely.\n        (gnat_post_options): By default, set flag_eliminate_unused_debug_types\n        to 0 for Ada.\n        (get_alias_set): Return alias set 0 for a type if\n        TYPE_UNIVERSAL_ALIASING_P is set on its main variant.\n\n        * ada-tree.h: (TYPE_UNIVERSAL_ALIASING_P): New macro.\n        (DECL_FUNCTION_STUB): New accessor macro.\n        (SET_DECL_FUNCTION_STUB): New setter macro.\n\n        * lang.opt (feliminate-unused-debug-types): Intercept this flag for Ada.\n\n\t* fe.h (Get_Local_Raise_Call_Entity, Get_RT_Exception_Entity): New\n\tdeclarations.\n\nFrom-SVN: r125371", "tree": {"sha": "ef59df58fad7bd905b3d7ef9766f7c88ea579fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef59df58fad7bd905b3d7ef9766f7c88ea579fdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09ef48fe18e9314a3b9a42692864644c01e5b50d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09ef48fe18e9314a3b9a42692864644c01e5b50d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09ef48fe18e9314a3b9a42692864644c01e5b50d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09ef48fe18e9314a3b9a42692864644c01e5b50d/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fce2526fe8eb39b0f069e23edc125d3e5faaf6d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce2526fe8eb39b0f069e23edc125d3e5faaf6d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fce2526fe8eb39b0f069e23edc125d3e5faaf6d9"}], "stats": {"total": 1444, "additions": 1022, "deletions": 422}, "files": [{"sha": "8dfd6ddb278506982fdc15d0ac9b34753dfefc87", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=09ef48fe18e9314a3b9a42692864644c01e5b50d", "patch": "@@ -80,6 +80,3 @@ DEFTREECODE (REGION_STMT, \"region_stmt\", tcc_statement, 3)\n    handler itself, and HANDLER_STMT_BLOCK is the BLOCK node for this\n    binding. */\n DEFTREECODE (HANDLER_STMT, \"handler_stmt\", tcc_statement, 3)\n-\n-/* A statement that emits a USE for its single operand.  */\n-DEFTREECODE (USE_STMT, \"use_expr\", tcc_statement, 1)"}, {"sha": "fb4f7481f530d536f173c1c445ab43b52ada0249", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=09ef48fe18e9314a3b9a42692864644c01e5b50d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2006 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -161,6 +161,9 @@ struct lang_type GTY(()) {tree t; };\n    padding or alignment.  */\n #define TYPE_IS_PADDING_P(NODE) TYPE_LANG_FLAG_5 (RECORD_TYPE_CHECK (NODE))\n \n+/* True if TYPE can alias any other types.  */\n+#define TYPE_UNIVERSAL_ALIASING_P(NODE) TYPE_LANG_FLAG_6 (NODE)\n+\n /* This field is only defined for FUNCTION_TYPE nodes. If the Ada\n    subprogram contains no parameters passed by copy in/copy out then this\n    field is 0. Otherwise it points to a list of nodes used to specify the\n@@ -288,6 +291,13 @@ struct lang_type GTY(()) {tree t; };\n #define SET_DECL_RENAMED_OBJECT(NODE, X) \\\n   SET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE), X)\n \n+/* In a FUNCTION_DECL, points to the stub associated with the function\n+   if any, otherwise 0.  */\n+#define DECL_FUNCTION_STUB(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))\n+#define SET_DECL_FUNCTION_STUB(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE), X)\n+\n /* In a FIELD_DECL corresponding to a discriminant, contains the\n    discriminant number.  */\n #define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))"}, {"sha": "59ecea4612e754e2b3dfd4c2be45fb97db6384f0", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=09ef48fe18e9314a3b9a42692864644c01e5b50d", "patch": "@@ -100,6 +100,14 @@ extern Entity_Id             Error_Msg_Node_2;\n extern Uint                  Error_Msg_Uint_1;\n extern Uint                  Error_Msg_Uint_2;\n \n+/* exp_ch11:  */\n+\n+#define Get_Local_Raise_Call_Entity exp_ch11__get_local_raise_call_entity\n+#define Get_RT_Exception_Entity exp_ch11__get_rt_exception_entity\n+\n+extern Entity_Id Get_Local_Raise_Call_Entity (void);\n+extern Entity_Id Get_RT_Exception_Entity (int);\n+\n /* exp_code:  */\n \n #define Asm_Input_Constraint exp_code__asm_input_constraint"}, {"sha": "a42c1232c15c35c6cda0219f42b1e469957bc31e", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 75, "deletions": 38, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=09ef48fe18e9314a3b9a42692864644c01e5b50d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -51,6 +51,11 @@ extern bool must_pass_by_ref (tree gnu_type);\n /* Initialize DUMMY_NODE_TABLE.  */\n extern void init_dummy_type (void);\n \n+/* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n+   GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n+   refer to an Ada type.  */\n+extern tree gnat_to_gnu_type (Entity_Id gnat_entity);\n+\n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n    entity, this routine returns the equivalent GCC tree for that entity\n    (an ..._DECL node) and associates the ..._DECL node with the input GNAT\n@@ -73,24 +78,42 @@ extern tree gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr,\n    FIELD_DECL.  */\n extern tree gnat_to_gnu_field_decl (Entity_Id gnat_entity);\n \n-/* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n-   GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n-   refer to an Ada type.  */\n-extern tree gnat_to_gnu_type (Entity_Id gnat_entity);\n+/* Wrap up compilation of T, a TYPE_DECL, possibly deferring it.  */\n+extern void rest_of_type_decl_compilation (tree t);\n+\n+/* Start a new statement group chained to the previous group.  */\n+extern void start_stmt_group (void);\n \n /* Add GNU_STMT to the current BLOCK_STMT node.  */\n extern void add_stmt (tree gnu_stmt);\n \n /* Similar, but set the location of GNU_STMT to that of GNAT_NODE.  */\n extern void add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node);\n \n+/* Return code corresponding to the current code group.  It is normally\n+   a STATEMENT_LIST, but may also be a BIND_EXPR or TRY_FINALLY_EXPR if\n+   BLOCK or cleanups were set.  */\n+extern tree end_stmt_group (void);\n+\n /* Set the BLOCK node corresponding to the current code group to GNU_BLOCK.  */\n extern void set_block_for_group (tree);\n \n /* Add a declaration statement for GNU_DECL to the current BLOCK_STMT node.\n    Get SLOC from GNAT_ENTITY.  */\n extern void add_decl_expr (tree gnu_decl, Entity_Id gnat_entity);\n \n+/* Finalize any From_With_Type incomplete types.  We do this after processing\n+   our compilation unit and after processing its spec, if this is a body.  */\n+extern void finalize_from_with_types (void);\n+\n+/* Return the equivalent type to be used for GNAT_ENTITY, if it's a\n+   kind of type (such E_Task_Type) that has a different type which Gigi\n+   uses for its representation.  If the type does not have a special type\n+   for its representation, return GNAT_ENTITY.  If a type is supposed to\n+   exist, but does not, abort unless annotating types, in which case\n+   return Empty.   If GNAT_ENTITY is Empty, return Empty.  */\n+extern Entity_Id Gigi_Equivalent_Type (Entity_Id);\n+\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n extern void elaborate_entity (Entity_Id gnat_entity);\n@@ -108,9 +131,12 @@ extern tree get_unpadded_type (Entity_Id gnat_entity);\n /* Called when we need to protect a variable object using a save_expr.  */\n extern tree maybe_variable (tree gnu_operand);\n \n-/* Create a record type that contains a field of TYPE with a starting bit\n-   position so that it is aligned to ALIGN bits and is SIZE bytes long.  */\n-extern tree make_aligning_type (tree type, int align, tree size);\n+/* Create a record type that contains a SIZE bytes long field of TYPE with a\n+    starting bit position so that it is aligned to ALIGN bits, and leaving at\n+    least ROOM bytes free before the field.  BASE_ALIGN is the alignment the\n+    record is guaranteed to get.  */\n+extern tree make_aligning_type (tree type, unsigned int align, tree size,\n+\t\t\t\tunsigned int base_align, int room);\n \n /* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n    if needed.  We have already verified that SIZE and TYPE are large enough.\n@@ -244,26 +270,19 @@ extern tree protect_multiple_eval (tree exp);\n    binary and unary operations.  */\n extern void init_code_table (void);\n \n+/* Return a label to branch to for the exception type in KIND or NULL_TREE\n+   if none.  */\n+extern tree get_exception_label (char);\n+\n /* Current node being treated, in case gigi_abort or Check_Elaboration_Code\n    called.  */\n extern Node_Id error_gnat_node;\n \n-/* This is equivalent to stabilize_reference in GCC's tree.c, but we know how\n-   to handle our new nodes and we take extra arguments.\n-\n-   FORCE says whether to force evaluation of everything,\n-\n-   SUCCESS we set to true unless we walk through something we don't\n-   know how to stabilize, or through something which is not an lvalue\n-   and LVALUES_ONLY is true, in which cases we set to false.  */\n-extern tree maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n-\t\t\t\t       bool *success);\n-\n-/* Wrapper around maybe_stabilize_reference, for common uses without\n-   lvalue restrictions and without need to examine the success\n-   indication.  */\n-\n-extern tree gnat_stabilize_reference (tree ref, bool force);\n+/* This is equivalent to stabilize_reference in tree.c, but we know how to\n+   handle our own nodes and we take extra arguments.  FORCE says whether to\n+   force evaluation of everything.  We set SUCCESS to true unless we walk\n+   through something we don't know how to stabilize.  */\n+extern tree maybe_stabilize_reference (tree ref, bool force, bool *success);\n \n /* Highest number in the front-end node table.  */\n extern int max_gnat_nodes;\n@@ -483,17 +502,23 @@ extern bool present_gnu_tree (Entity_Id gnat_entity);\n /* Initialize tables for above routines.  */\n extern void init_gnat_to_gnu (void);\n \n-/* Given a record type (RECORD_TYPE) and a chain of FIELD_DECL\n-   nodes (FIELDLIST), finish constructing the record or union type.\n-   If HAS_REP is true, this record has a rep clause; don't call\n-   layout_type but merely set the size and alignment ourselves.\n-   If DEFER_DEBUG is true, do not call the debugging routines\n-   on this type; it will be done later. */\n+/* Given a record type RECORD_TYPE and a chain of FIELD_DECL nodes FIELDLIST,\n+   finish constructing the record or union type.  If REP_LEVEL is zero, this\n+   record has no representation clause and so will be entirely laid out here.\n+   If REP_LEVEL is one, this record has a representation clause and has been\n+   laid out already; only set the sizes and alignment.  If REP_LEVEL is two,\n+   this record is derived from a parent record and thus inherits its layout;\n+   only make a pass on the fields to finalize them.  If DO_NOT_FINALIZE is\n+   true, the record type is expected to be modified afterwards so it will\n+   not be sent to the back-end for finalization.  */\n extern void finish_record_type (tree record_type, tree fieldlist,\n-                                bool has_rep, bool defer_debug);\n+                                int rep_level, bool do_not_finalize);\n \n-/*  Output the debug information associated to a record type.  */\n-extern void write_record_type_debug_info (tree);\n+/* Wrap up compilation of RECORD_TYPE, i.e. most notably output all\n+   the debug information associated with it.  It need not be invoked\n+   directly in most cases since finish_record_type takes care of doing\n+   so, unless explicitly requested not to through DO_NOT_FINALIZE.  */\n+extern void rest_of_record_type_compilation (tree record_type);\n \n /* Returns a FUNCTION_TYPE node. RETURN_TYPE is the type returned by the\n    subprogram. If it is void_type_node, then we are dealing with a procedure,\n@@ -515,8 +540,10 @@ extern tree create_subprog_type (tree return_type, tree param_decl_list,\n extern tree copy_type (tree type);\n \n /* Return an INTEGER_TYPE of SIZETYPE with range MIN to MAX and whose\n-   TYPE_INDEX_TYPE is INDEX.  */\n-extern tree create_index_type (tree min, tree max, tree index);\n+   TYPE_INDEX_TYPE is INDEX.  GNAT_NODE is used for the position of\n+   the decl.  */\n+extern tree create_index_type (tree min, tree max, tree index,\n+\t\t\t       Node_Id gnat_node);\n \n /* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n    string) and TYPE is a ..._TYPE node giving its data type.\n@@ -623,10 +650,13 @@ extern tree build_template (tree template_type, tree array_type, tree expr);\n    a constructor is made for the type.  GNAT_ENTITY is a gnat node used\n    to print out an error message if the mechanism cannot be applied to\n    an object of that type and also for the name.  */\n-\n extern tree build_vms_descriptor (tree type, Mechanism_Type mech,\n                                   Entity_Id gnat_entity);\n \n+/* Build a stub for the subprogram specified by the GCC tree GNU_SUBPROG\n+   and the GNAT node GNAT_SUBPROG.  */\n+extern void build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog);\n+\n /* Build a type to be used to represent an aliased object whose nominal\n    type is an unconstrained array.  This consists of a RECORD_TYPE containing\n    a field of TEMPLATE_TYPE and a field of OBJECT_TYPE, which is an\n@@ -641,6 +671,10 @@ extern tree build_unc_object_type (tree template_type, tree object_type,\n extern tree build_unc_object_type_from_ptr (tree thin_fat_ptr_type,\n \t\t\t\t\t    tree object_type, tree name);\n \n+/* Shift the component offsets within an unconstrained object TYPE to make it\n+   suitable for use as a designated type for thin pointers.  */\n+extern void shift_unc_components_for_thin_pointers (tree type);\n+\n /* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.  In\n    the normal case this is just two adjustments, but we have more to do\n    if NEW is an UNCONSTRAINED_ARRAY_TYPE.  */\n@@ -731,8 +765,11 @@ extern tree build_call_0_expr (tree fundecl);\n \n    GNAT_NODE is the gnat node conveying the source location for which the\n    error should be signaled, or Empty in which case the error is signaled on\n-   the current ref_file_name/input_line.  */\n-extern tree build_call_raise (int msg, Node_Id gnat_node);\n+   the current ref_file_name/input_line.\n+\n+   KIND says which kind of exception this is for\n+    (N_Raise_{Constraint,Storage,Program}_Error).  */\n+extern tree build_call_raise (int msg, Node_Id gnat_node, char kind);\n \n /* Return a CONSTRUCTOR of TYPE whose list is LIST.  This is not the\n    same as build_constructor in the language-independent tree.c.  */"}, {"sha": "f524e37fee7995b14d853865b19625e4e17b43f5", "filename": "gcc/ada/lang.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang.opt?ref=09ef48fe18e9314a3b9a42692864644c01e5b50d", "patch": "@@ -69,6 +69,12 @@ nostdinc\n Ada RejectNegative\n ; Don't look for source files\n \n+feliminate-unused-debug-types\n+Ada\n+; Effect documented for C - intercepted for Ada to force the associated flag\n+; not to be set by default, as it currently eliminates unreferenced parallel\n+; types we need for encoding descriptions to the debugger.\n+\n nostdlib\n Ada\n ; Don't look for object files"}, {"sha": "e63856de00976212bcc926049456f0778fa582da", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=09ef48fe18e9314a3b9a42692864644c01e5b50d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                           C Implementation File                          *\n  *                                                                          *\n- *          Copyright (C) 1992-2006, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -302,6 +302,14 @@ gnat_handle_option (size_t scode, const char *arg, int value ATTRIBUTE_UNUSED)\n       gnat_argc++;\n       break;\n \n+    case OPT_feliminate_unused_debug_types:\n+      /* We arrange for post_option to be able to only set the corresponding\n+         flag to 1 when explicitely requested by the user.  We expect the\n+         default flag value to be either 0 or positive, and expose a positive\n+         -f as a negative value to post_option.  */\n+      flag_eliminate_unused_debug_types = -value;\n+      break;\n+\n     case OPT_fRTS_:\n       gnat_argv[gnat_argc] = xstrdup (\"-fRTS\");\n       gnat_argc++;\n@@ -362,6 +370,14 @@ gnat_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n   if (flag_inline_functions)\n     flag_inline_trees = 2;\n \n+  /* Force eliminate_unused_debug_types to 0 unless an explicit positive\n+     -f has been passed.  This forces the default to 0 for Ada, which might\n+     differ from the common default.  */\n+  if (flag_eliminate_unused_debug_types < 0)\n+    flag_eliminate_unused_debug_types = 1;\n+  else\n+    flag_eliminate_unused_debug_types = 0;\n+\n   /* The structural alias analysis machinery essentially assumes that\n      everything is addressable (modulo bit-fields) by disregarding\n      the TYPE_NONALIASED_COMPONENT and DECL_NONADDRESSABLE_P macros.  */\n@@ -484,6 +500,11 @@ gnat_compute_largest_alignment (void)\n void\n gnat_init_gcc_eh (void)\n {\n+#ifdef DWARF2_UNWIND_INFO\n+  /* lang_dependent_init already called dwarf2out_frame_init if true.  */\n+  int dwarf2out_frame_initialized = dwarf2out_do_frame ();\n+#endif\n+\n   /* We shouldn't do anything if the No_Exceptions_Handler pragma is set,\n      though. This could for instance lead to the emission of tables with\n      references to symbols (such as the Ada eh personality routine) within\n@@ -517,7 +538,7 @@ gnat_init_gcc_eh (void)\n \n   init_eh ();\n #ifdef DWARF2_UNWIND_INFO\n-  if (dwarf2out_do_frame ())\n+  if (!dwarf2out_frame_initialized && dwarf2out_do_frame ())\n     dwarf2out_frame_init ();\n #endif\n }\n@@ -633,13 +654,6 @@ gnat_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n   tree type = TREE_TYPE (exp);\n   tree new;\n \n-  /* If this is a statement, call the expansion routine for statements.  */\n-  if (IS_STMT (exp))\n-    {\n-      gnat_expand_stmt (exp);\n-      return const0_rtx;\n-    }\n-\n   /* Update EXP to be the new expression to expand.  */\n   switch (TREE_CODE (exp))\n     {\n@@ -746,6 +760,10 @@ gnat_get_alias_set (tree type)\n     return\n       get_alias_set (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (type)))));\n \n+  /* If the type can alias any other types, return the alias set 0.  */\n+  else if (TYPE_P (type)\n+\t   && TYPE_UNIVERSAL_ALIASING_P (TYPE_MAIN_VARIANT (type)))\n+    return 0;\n \n   return -1;\n }"}, {"sha": "438b149b4efc34afe6d72c4480dba5074e20a930", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 498, "deletions": 194, "changes": 692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=09ef48fe18e9314a3b9a42692864644c01e5b50d", "patch": "@@ -82,6 +82,31 @@ const char *ref_filename;\n    types with representation information. */\n bool type_annotate_only;\n \n+/* When not optimizing, we cache the 'First, 'Last and 'Length attributes\n+   of unconstrained array IN parameters to avoid emitting a great deal of\n+   redundant instructions to recompute them each time.  */\n+struct parm_attr GTY (())\n+{\n+  int id; /* GTY doesn't like Entity_Id.  */\n+  int dim;\n+  tree first;\n+  tree last;\n+  tree length;\n+};\n+\n+typedef struct parm_attr *parm_attr;\n+\n+DEF_VEC_P(parm_attr);\n+DEF_VEC_ALLOC_P(parm_attr,gc);\n+\n+struct language_function GTY(())\n+{\n+  VEC(parm_attr,gc) *parm_attr_cache;\n+};\n+\n+#define f_parm_attr_cache \\\n+  DECL_STRUCT_FUNCTION (current_function_decl)->language->parm_attr_cache\n+\n /* A structure used to gather together information about a statement group.\n    We use this to gather related statements, for example the \"then\" part\n    of a IF.  In the case where it represents a lexical scope, we may also\n@@ -137,6 +162,11 @@ static GTY(()) tree gnu_loop_label_stack;\n    TREE_VALUE of each entry is the label at the end of the switch.  */\n static GTY(()) tree gnu_switch_label_stack;\n \n+/* List of TREE_LIST nodes containing the stacks for N_{Push,Pop}_*_Label.  */\n+static GTY(()) tree gnu_constraint_error_label_stack;\n+static GTY(()) tree gnu_storage_error_label_stack;\n+static GTY(()) tree gnu_program_error_label_stack;\n+\n /* Map GNAT tree codes to GCC tree codes for simple expressions.  */\n static enum tree_code gnu_codes[Number_Node_Kinds];\n \n@@ -146,12 +176,11 @@ Node_Id error_gnat_node;\n static void Compilation_Unit_to_gnu (Node_Id);\n static void record_code_position (Node_Id);\n static void insert_code_for (Node_Id);\n-static void start_stmt_group (void);\n-static void add_cleanup (tree);\n+static void add_cleanup (tree, Node_Id);\n static tree mark_visited (tree *, int *, void *);\n static tree unshare_save_expr (tree *, int *, void *);\n-static tree end_stmt_group (void);\n static void add_stmt_list (List_Id);\n+static void push_exception_label_stack (tree *, Entity_Id);\n static tree build_stmt_group (List_Id, bool);\n static void push_stack (tree *, tree, tree);\n static void pop_stack (tree *);\n@@ -169,9 +198,10 @@ static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n+static tree gnat_stabilize_reference (tree, bool);\n static tree gnat_stabilize_reference_1 (tree, bool);\n static void annotate_with_node (tree, Node_Id);\n-\n+static int takes_address (Node_Id, tree);\n \f\n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.  */\n@@ -222,6 +252,10 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n \t\t false);\n \n   gnu_except_ptr_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n+  gnu_constraint_error_label_stack\n+    = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n+  gnu_storage_error_label_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n+  gnu_program_error_label_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n \n   gnu_standard_long_long_float\n     = gnat_to_gnu_entity (Base_Type (standard_long_long_float), NULL_TREE, 0);\n@@ -274,7 +308,10 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n \n       /* If there are no statements, there is no elaboration code.  */\n       if (!gnu_stmts || !STATEMENT_LIST_HEAD (gnu_stmts))\n-\tSet_Has_No_Elaboration_Code (info->gnat_node, 1);\n+\t{\n+\t  Set_Has_No_Elaboration_Code (info->gnat_node, 1);\n+\t  cgraph_remove_node (cgraph_node (info->elab_proc));\n+\t}\n       else\n \t{\n \t  /* Otherwise, compile the function.  Note that we'll be gimplifying\n@@ -299,6 +336,54 @@ gnat_init_stmt_group (void)\n     set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n }\n \f\n+/* Returns a positive value if GNAT_NODE denotes an address construction\n+   for an operand of OPERAND_TYPE, zero otherwise.  This is int instead\n+   of bool to facilitate usage in non purely binary logic contexts.  */\n+\n+static int\n+takes_address (Node_Id gnat_node, tree operand_type)\n+{\n+  switch (Nkind (gnat_node))\n+    {\n+    case N_Reference:\n+      return 1;\n+\n+    case N_Attribute_Reference:\n+      {\n+\tunsigned char id = Get_Attribute_Id (Attribute_Name (gnat_node));\n+\treturn id == Attr_Address\n+\t       || id == Attr_Access\n+\t       || id == Attr_Unchecked_Access\n+\t       || id == Attr_Unrestricted_Access;\n+      }\n+\n+    case N_Function_Call:\n+    case N_Procedure_Call_Statement:\n+      return must_pass_by_ref (operand_type)\n+\t     || default_pass_by_ref (operand_type);\n+\n+    case N_Indexed_Component:\n+      {\n+\tNode_Id gnat_temp;\n+\t/* ??? Consider that referencing an indexed component with a\n+\t   non-constant index forces the whole aggregate to memory.\n+\t   Note that N_Integer_Literal is conservative, any static\n+\t   expression in the RM sense could probably be accepted.  */\n+\tfor (gnat_temp = First (Expressions (gnat_node));\n+\t     Present (gnat_temp);\n+\t     gnat_temp = Next (gnat_temp))\n+\t  if (Nkind (gnat_temp) != N_Integer_Literal)\n+\t    return 1;\n+\treturn takes_address (Parent (gnat_node), operand_type);\n+      }\n+\n+    default:\n+      return 0;\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Identifier,\n    to a GCC tree, which is returned.  GNU_RESULT_TYPE_P is a pointer to\n    where we should place the result type.  */\n@@ -310,6 +395,16 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   tree gnu_result;\n   Node_Id gnat_temp, gnat_temp_type;\n \n+  /* Whether the parent of gnat_node is taking its address.  Needed in\n+     specific circumstances only, so evaluated lazily. < 0 means unknown,\n+     > 0 means known true, 0 means known false.  */\n+  int parent_takes_address = -1;\n+\n+  /* If GNAT_NODE is a constant, whether we should use the initialization\n+     value instead of the constant entity, typically for scalars with an\n+     address clause when the parent is not taking the address.  */\n+  bool use_constant_initializer = false;\n+\n   /* If the Etype of this node does not equal the Etype of the Entity,\n      something is wrong with the entity map, probably in generic\n      instantiation. However, this does not apply to types. Since we sometime\n@@ -351,20 +446,17 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      in particular if it is a derived type  */\n   if (Is_Private_Type (gnat_temp_type)\n       && Has_Unknown_Discriminants (gnat_temp_type)\n-      && Present (Full_View (gnat_temp))\n-      && !Is_Type (gnat_temp))\n+      && Ekind (gnat_temp) == E_Constant\n+      && Present (Full_View (gnat_temp)))\n     {\n       gnat_temp = Full_View (gnat_temp);\n       gnat_temp_type = Etype (gnat_temp);\n-      gnu_result_type = get_unpadded_type (gnat_temp_type);\n     }\n   else\n     {\n-      /* Expand the type of this identifier first, in case it is an enumeral\n-\t literal, which only get made when the type is expanded.  There is no\n-\t order-of-elaboration issue here.  We want to use the Actual_Subtype if\n-\t it has already been elaborated, otherwise the Etype.  Avoid using\n-\t Actual_Subtype for packed arrays to simplify things.  */\n+      /* We want to use the Actual_Subtype if it has already been elaborated,\n+\t otherwise the Etype.  Avoid using Actual_Subtype for packed arrays to\n+\t simplify things.  */\n       if ((Ekind (gnat_temp) == E_Constant\n \t   || Ekind (gnat_temp) == E_Variable || Is_Formal (gnat_temp))\n \t  && !(Is_Array_Type (Etype (gnat_temp))\n@@ -374,11 +466,41 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \tgnat_temp_type = Actual_Subtype (gnat_temp);\n       else\n \tgnat_temp_type = Etype (gnat_node);\n+    }\n \n-      gnu_result_type = get_unpadded_type (gnat_temp_type);\n+  /* Expand the type of this identifier first, in case it is an enumeral\n+     literal, which only get made when the type is expanded.  There is no\n+     order-of-elaboration issue here.  */\n+  gnu_result_type = get_unpadded_type (gnat_temp_type);\n+\n+  /* If this is a non-imported scalar constant with an address clause,\n+     retrieve the value instead of a pointer to be dereferenced, unless the\n+     parent is taking the address.  This is generally more efficient and\n+     actually required if this is a static expression because it might be used\n+     in a context where a dereference is inappropriate, such as a case\n+     statement alternative or a record discriminant.  There is no possible\n+     volatile-ness shortciruit here since Volatile constants must be imported\n+     per C.6. */\n+  if (Ekind (gnat_temp) == E_Constant && Is_Scalar_Type (gnat_temp_type)\n+      && !Is_Imported (gnat_temp)\n+      && Present (Address_Clause (gnat_temp)))\n+    {\n+      parent_takes_address\n+\t= takes_address (Parent (gnat_node), gnu_result_type);\n+      use_constant_initializer = !parent_takes_address;\n     }\n \n-  gnu_result = gnat_to_gnu_entity (gnat_temp, NULL_TREE, 0);\n+  if (use_constant_initializer)\n+    {\n+      /* If this is a deferred constant, the initializer is attached to the\n+\t the full view.  */\n+      if (Present (Full_View (gnat_temp)))\n+\tgnat_temp = Full_View (gnat_temp);\n+\n+      gnu_result = gnat_to_gnu (Expression (Declaration_Node (gnat_temp)));\n+    }\n+  else\n+    gnu_result = gnat_to_gnu_entity (gnat_temp, NULL_TREE, 0);\n \n   /* If we are in an exception handler, force this variable into memory to\n      ensure optimization does not remove stores that appear redundant but are\n@@ -404,8 +526,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   /* Some objects (such as parameters passed by reference, globals of\n      variable size, and renamed objects) actually represent the address\n      of the object.  In that case, we must do the dereference.  Likewise,\n-     deal with parameters to foreign convention subprograms.  Call fold\n-     here since GNU_RESULT may be a CONST_DECL.  */\n+     deal with parameters to foreign convention subprograms.  */\n   if (DECL_P (gnu_result)\n       && (DECL_BY_REF_P (gnu_result)\n \t  || (TREE_CODE (gnu_result) == PARM_DECL\n@@ -429,9 +550,15 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t       && (! DECL_RENAMING_GLOBAL_P (gnu_result)\n \t\t   || global_bindings_p ()))\n \tgnu_result = renamed_obj;\n-      else\n+\n+      /* Return the underlying CST for a CONST_DECL like a few lines below,\n+\t after dereferencing in this case.  */\n+      else if (TREE_CODE (gnu_result) == CONST_DECL)\n \tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t     fold (gnu_result));\n+\t\t\t\t     DECL_INITIAL (gnu_result));\n+\n+      else\n+\tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_result);\n \n       TREE_READONLY (gnu_result) = TREE_STATIC (gnu_result) = ro;\n     }\n@@ -448,23 +575,26 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \tgnu_result_type = TREE_TYPE (TYPE_FIELDS (gnu_result_type));\n     }\n \n-  /* We always want to return the underlying INTEGER_CST for an enumeration\n-     literal to avoid the need to call fold in lots of places.  But don't do\n-     this is the parent will be taking the address of this object.  */\n-  if (TREE_CODE (gnu_result) == CONST_DECL)\n+  /* If we have a constant declaration and it's initializer at hand, return\n+     the latter to avoid the need to call fold in lots of places and the need\n+     of elaboration code if this Id is used as an initializer itself.  Don't\n+     do this if the parent will be taking the address of this object and\n+     there is a corresponding variable to take the address of.  */\n+  if (TREE_CONSTANT (gnu_result)\n+      && DECL_P (gnu_result) && DECL_INITIAL (gnu_result))\n     {\n-      gnat_temp = Parent (gnat_node);\n-      if (!DECL_CONST_CORRESPONDING_VAR (gnu_result)\n-\t  || (Nkind (gnat_temp) != N_Reference\n-\t      && !(Nkind (gnat_temp) == N_Attribute_Reference\n-\t\t   && ((Get_Attribute_Id (Attribute_Name (gnat_temp))\n-\t\t\t== Attr_Address)\n-\t\t       || (Get_Attribute_Id (Attribute_Name (gnat_temp))\n-\t\t\t   == Attr_Access)\n-\t\t       || (Get_Attribute_Id (Attribute_Name (gnat_temp))\n-\t\t\t    == Attr_Unchecked_Access)\n-\t\t       || (Get_Attribute_Id (Attribute_Name (gnat_temp))\n-\t\t\t   == Attr_Unrestricted_Access)))))\n+      tree object\n+\t= (TREE_CODE (gnu_result) == CONST_DECL\n+\t   ? DECL_CONST_CORRESPONDING_VAR (gnu_result) : gnu_result);\n+\n+      /* If there is a corresponding variable, we only want to return the CST\n+\t value if the parent is not taking the address.  Evaluate this now if\n+\t we have not already done so.  */\n+      if (object && parent_takes_address < 0)\n+\tparent_takes_address\n+\t  = takes_address (Parent (gnat_node), gnu_result_type);\n+\n+      if (!object || !parent_takes_address)\n \tgnu_result = DECL_INITIAL (gnu_result);\n     }\n \n@@ -497,12 +627,47 @@ Pragma_to_gnu (Node_Id gnat_node)\n \t   Present (gnat_temp);\n \t   gnat_temp = Next (gnat_temp))\n \t{\n-\t  tree gnu_expr = gnat_to_gnu (Expression (gnat_temp));\n+\t  Node_Id gnat_expr = Expression (gnat_temp);\n+\t  tree gnu_expr = gnat_to_gnu (gnat_expr);\n+\t  int use_address;\n+\t  enum machine_mode mode;\n+\t  tree asm_constraint = NULL_TREE;\n+#ifdef ASM_COMMENT_START\n+\t  char *comment;\n+#endif\n \n \t  if (TREE_CODE (gnu_expr) == UNCONSTRAINED_ARRAY_REF)\n \t    gnu_expr = TREE_OPERAND (gnu_expr, 0);\n \n-\t  gnu_expr = build1 (USE_STMT, void_type_node, gnu_expr);\n+\t  /* Use the value only if it fits into a normal register,\n+\t     otherwise use the address.  */\n+\t  mode = TYPE_MODE (TREE_TYPE (gnu_expr));\n+\t  use_address = ((GET_MODE_CLASS (mode) != MODE_INT\n+\t\t\t  && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n+\t\t\t || GET_MODE_SIZE (mode) > UNITS_PER_WORD);\n+\n+\t  if (use_address)\n+\t    gnu_expr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr);\n+\n+#ifdef ASM_COMMENT_START\n+\t  comment = concat (ASM_COMMENT_START,\n+\t\t\t    \" inspection point: \",\n+\t\t\t    Get_Name_String (Chars (gnat_expr)),\n+\t\t\t    use_address ? \" address\" : \"\",\n+\t\t\t    \" is in %0\",\n+\t\t\t    NULL);\n+\t  asm_constraint = build_string (strlen (comment), comment);\n+\t  free (comment);\n+#endif\n+\t  gnu_expr = build4 (ASM_EXPR, void_type_node,\n+\t\t\t     asm_constraint,\n+\t\t\t     NULL_TREE,\n+\t\t\t     tree_cons\n+\t\t\t     (build_tree_list (NULL_TREE,\n+\t\t\t\t\t       build_string (1, \"g\")),\n+\t\t\t      gnu_expr, NULL_TREE),\n+\t\t\t     NULL_TREE);\n+\t  ASM_VOLATILE_P (gnu_expr) = 1;\n \t  annotate_with_node (gnu_expr, gnat_node);\n \t  append_to_statement_list (gnu_expr, &gnu_result);\n \t}\n@@ -839,11 +1004,18 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       {\n \tint Dimension = (Present (Expressions (gnat_node))\n \t\t\t ? UI_To_Int (Intval (First (Expressions (gnat_node))))\n-\t\t\t : 1);\n+\t\t\t : 1), i;\n+\tstruct parm_attr *pa = NULL;\n+\tEntity_Id gnat_param = Empty;\n \n \t/* Make sure any implicit dereference gets done.  */\n \tgnu_prefix = maybe_implicit_deref (gnu_prefix);\n \tgnu_prefix = maybe_unconstrained_array (gnu_prefix);\n+\t/* We treat unconstrained array IN parameters specially.  */\n+\tif (Nkind (Prefix (gnat_node)) == N_Identifier\n+\t    && !Is_Constrained (Etype (Prefix (gnat_node)))\n+\t    && Ekind (Entity (Prefix (gnat_node))) == E_In_Parameter)\n+\t  gnat_param = Entity (Prefix (gnat_node));\n \tgnu_type = TREE_TYPE (gnu_prefix);\n \tprefix_unused = true;\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n@@ -862,22 +1034,66 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t    Dimension = ndim + 1 - Dimension;\n \t  }\n \n-\tfor (; Dimension > 1; Dimension--)\n+\tfor (i = 1; i < Dimension; i++)\n \t  gnu_type = TREE_TYPE (gnu_type);\n \n \tgcc_assert (TREE_CODE (gnu_type) == ARRAY_TYPE);\n+\n+\t/* When not optimizing, look up the slot associated with the parameter\n+\t   and the dimension in the cache and create a new one on failure.  */\n+\tif (!optimize && Present (gnat_param))\n+\t  {\n+\t    for (i = 0; VEC_iterate (parm_attr, f_parm_attr_cache, i, pa); i++)\n+\t      if (pa->id == gnat_param && pa->dim == Dimension)\n+\t\tbreak;\n+\n+\t    if (!pa)\n+\t      {\n+\t\tpa = GGC_CNEW (struct parm_attr);\n+\t\tpa->id = gnat_param;\n+\t\tpa->dim = Dimension;\n+\t\tVEC_safe_push (parm_attr, gc, f_parm_attr_cache, pa);\n+\t      }\n+\t  }\n+\n+\t/* Return the cached expression or build a new one.  */\n \tif (attribute == Attr_First)\n-\t  gnu_result\n-\t    = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)));\n+\t  {\n+\t    if (pa && pa->first)\n+\t      {\n+\t\tgnu_result = pa->first;\n+\t\tbreak;\n+\t      }\n+\n+\t    gnu_result\n+\t      = TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)));\n+\t  }\n+\n \telse if (attribute == Attr_Last)\n-\t  gnu_result\n-\t    = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)));\n-\telse\n-\t  /* 'Length or 'Range_Length.  */\n \t  {\n-\t    tree gnu_compute_type\n+\t    if (pa && pa->last)\n+\t      {\n+\t\tgnu_result = pa->last;\n+\t\tbreak;\n+\t      }\n+\n+\t    gnu_result\n+\t      = TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type)));\n+\t  }\n+\n+\telse /* attribute == Attr_Range_Length || attribute == Attr_Length  */\n+\t  {\n+\t    tree gnu_compute_type;\n+\n+\t    if (pa && pa->length)\n+\t      {\n+\t\tgnu_result = pa->length;\n+\t\tbreak;\n+\t      }\n+\n+\t    gnu_compute_type\n \t      = get_signed_or_unsigned_type (0,\n-\t\t\t\t\t      get_base_type (gnu_result_type));\n+\t\t\t\t\t     get_base_type (gnu_result_type));\n \n \t    gnu_result\n \t      = build_binary_op\n@@ -901,6 +1117,23 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t   an unconstrained array type.  */\n \tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result,\n \t\t\t\t\t\t     gnu_prefix);\n+\n+\t/* Cache the expression we have just computed.  Since we want to do it\n+\t   at runtime, we force the use of a SAVE_EXPR and let the gimplifier\n+\t   create the temporary.  */\n+\tif (pa)\n+\t  {\n+\t    gnu_result\n+\t      = build1 (SAVE_EXPR, TREE_TYPE (gnu_result), gnu_result);\n+\t    TREE_SIDE_EFFECTS (gnu_result) = 1;\n+\t    TREE_INVARIANT (gnu_result) = 1;\n+\t    if (attribute == Attr_First)\n+\t      pa->first = gnu_result;\n+\t    else if (attribute == Attr_Last)\n+\t      pa->last = gnu_result;\n+\t    else\n+\t      pa->length = gnu_result;\n+\t  }\n \tbreak;\n       }\n \n@@ -1181,29 +1414,6 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t\t  gnu_high = fold (TYPE_MAX_VALUE (gnu_type));\n \t\t  break;\n \t\t}\n-\t      /* Static values are handled by the next case to which we'll\n-\t\t fallthrough.  If this is a constant with an address clause\n-\t\t attached, we need to get to the initialization expression\n-\t\t first, as the GCC tree for the entity might happen to be an\n-\t\t INDIRECT_REF otherwise.  */\n-\t      else if (Ekind (Entity (gnat_choice)) == E_Constant\n-\t\t       && Present (Address_Clause (Entity (gnat_choice))))\n-\t\t{\n-\t\t  /* We might have a deferred constant with an address clause\n-\t\t     on either the incomplete or the full view.  While the\n-\t\t     Address_Clause is always attached to the visible entity,\n-\t\t     as tested above, the static value is the Expression\n-\t\t     attached to the the declaration of the entity or of its\n-\t\t     full view if any.  */\n-\n-\t\t  Entity_Id gnat_constant = Entity (gnat_choice);\n-\n-\t\t  if (Present (Full_View (gnat_constant)))\n-\t\t    gnat_constant = Full_View (gnat_constant);\n-\n-\t\t  gnat_choice\n-\t\t    = Expression (Declaration_Node (gnat_constant));\n-\t\t}\n \n \t      /* ... fall through ... */\n \n@@ -1453,9 +1663,6 @@ establish_gnat_vms_condition_handler (void)\n static void\n Subprogram_Body_to_gnu (Node_Id gnat_node)\n {\n-  /* Save debug output mode in case it is reset.  */\n-  enum debug_info_type save_write_symbols = write_symbols;\n-  const struct gcc_debug_hooks *const save_debug_hooks = debug_hooks;\n   /* Defining identifier of a parameter to the subprogram.  */\n   Entity_Id gnat_param;\n   /* The defining identifier for the subprogram body. Note that if a\n@@ -1471,6 +1678,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   tree gnu_subprog_type;\n   tree gnu_cico_list;\n   tree gnu_result;\n+  VEC(parm_attr,gc) *cache;\n \n   /* If this is a generic object or if it has been eliminated,\n      ignore it.  */\n@@ -1479,14 +1687,6 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n       || Is_Eliminated (gnat_subprog_id))\n     return;\n \n-  /* If debug information is suppressed for the subprogram, turn debug\n-     mode off for the duration of processing.  */\n-  if (!Needs_Debug_Info (gnat_subprog_id))\n-    {\n-      write_symbols = NO_DEBUG;\n-      debug_hooks = &do_nothing_debug_hooks;\n-    }\n-\n   /* If this subprogram acts as its own spec, define it.  Otherwise, just get\n      the already-elaborated tree node.  However, if this subprogram had its\n      elaboration deferred, we will already have made a tree node for it.  So\n@@ -1500,11 +1700,19 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   gnu_subprog_type = TREE_TYPE (gnu_subprog_decl);\n \n+  /* Propagate the debug mode.  */\n+  if (!Needs_Debug_Info (gnat_subprog_id))\n+    DECL_IGNORED_P (gnu_subprog_decl) = 1;\n+\n   /* Set the line number in the decl to correspond to that of the body so that\n-     the line number notes are written\n-     correctly.  */\n+     the line number notes are written correctly.  */\n   Sloc_to_locus (Sloc (gnat_node), &DECL_SOURCE_LOCATION (gnu_subprog_decl));\n \n+  /* Initialize the information structure for the function.  */\n+  allocate_struct_function (gnu_subprog_decl);\n+  DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language\n+    = GGC_CNEW (struct language_function);\n+\n   begin_subprog_body (gnu_subprog_decl);\n   gnu_cico_list = TYPE_CI_CO_LIST (gnu_subprog_type);\n \n@@ -1540,7 +1748,6 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t\t     gnat_to_gnu_entity (gnat_param, NULL_TREE, 1));\n       }\n \n-\n   /* On VMS, establish our condition handler to possibly turn a condition into\n      the corresponding exception if the subprogram has a foreign convention or\n      is exported.\n@@ -1549,9 +1756,9 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n      we must turn a condition into the corresponding exception even if there\n      is no applicable Ada handler, and need at least one condition handler per\n      possible call chain involving GNAT code.  OTOH, establishing the handler\n-     has a cost so we want to minimize the number of subprograms into which this\n-     happens.  The foreign or exported condition is expected to satisfy all\n-     the constraints.  */\n+     has a cost so we want to minimize the number of subprograms into which\n+     this happens.  The foreign or exported condition is expected to satisfy\n+     all the constraints.  */\n   if (TARGET_ABI_OPEN_VMS\n       && (Has_Foreign_Convention (gnat_node) || Is_Exported (gnat_node)))\n     establish_gnat_vms_condition_handler ();\n@@ -1564,6 +1771,30 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n   gnat_poplevel ();\n   gnu_result = end_stmt_group ();\n \n+  /* If we populated the parameter attributes cache, we need to make sure\n+     that the cached expressions are evaluated on all possible paths.  */\n+  cache = DECL_STRUCT_FUNCTION (gnu_subprog_decl)->language->parm_attr_cache;\n+  if (cache)\n+    {\n+      struct parm_attr *pa;\n+      int i;\n+\n+      start_stmt_group ();\n+\n+      for (i = 0; VEC_iterate (parm_attr, cache, i, pa); i++)\n+\t{\n+\t  if (pa->first)\n+\t    add_stmt (pa->first);\n+\t  if (pa->last)\n+\t    add_stmt (pa->last);\n+\t  if (pa->length)\n+\t    add_stmt (pa->length);\n+\t}\n+\n+      add_stmt (gnu_result);\n+      gnu_result = end_stmt_group ();\n+    }\n+\n   /* If we made a special return label, we need to make a block that contains\n      the definition of that label and the copying to the return value.  That\n      block first contains the function, then the label and copy statement.  */\n@@ -1588,22 +1819,20 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \tgnu_retval = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_retval);\n \n       add_stmt_with_node\n-\t(build_return_expr (DECL_RESULT (current_function_decl), gnu_retval),\n+\t(build_return_expr (DECL_RESULT (gnu_subprog_decl), gnu_retval),\n \t gnat_node);\n       gnat_poplevel ();\n       gnu_result = end_stmt_group ();\n     }\n \n   pop_stack (&gnu_return_label_stack);\n \n-  /* Initialize the information node for the function and set the\n-     end location.  */\n-  allocate_struct_function (current_function_decl);\n+  /* Set the end location.  */\n   Sloc_to_locus\n     ((Present (End_Label (Handled_Statement_Sequence (gnat_node)))\n       ? Sloc (End_Label (Handled_Statement_Sequence (gnat_node)))\n       : Sloc (gnat_node)),\n-     &cfun->function_end_locus);\n+     &DECL_STRUCT_FUNCTION (gnu_subprog_decl)->function_end_locus);\n \n   end_subprog_body (gnu_result);\n \n@@ -1615,9 +1844,10 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n     if (TREE_CODE (get_gnu_tree (gnat_param)) == VAR_DECL)\n       save_gnu_tree (gnat_param, NULL_TREE, false);\n \n+  if (DECL_FUNCTION_STUB (gnu_subprog_decl))\n+    build_function_stub (gnu_subprog_decl, gnat_subprog_id);\n+\n   mark_out_of_scope (Defining_Unit_Name (Specification (gnat_node)));\n-  write_symbols = save_write_symbols;\n-  debug_hooks = save_debug_hooks;\n }\n \f\n /* Subroutine of gnat_to_gnu to translate gnat_node, either an N_Function_Call\n@@ -1671,7 +1901,8 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n       {\n \ttree call_expr\n-\t  = build_call_raise (PE_Stubbed_Subprogram_Called, gnat_node);\n+\t  = build_call_raise (PE_Stubbed_Subprogram_Called, gnat_node,\n+\t\t\t      N_Raise_Program_Error);\n \n \tif (Nkind (gnat_node) == N_Function_Call && !gnu_target)\n \t  {\n@@ -2271,14 +2502,16 @@ Handled_Sequence_Of_Statements_to_gnu (Node_Id gnat_node)\n       set_block_jmpbuf_decl (gnu_jmpbuf_decl);\n \n       /* When we exit this block, restore the saved value.  */\n-      add_cleanup (build_call_1_expr (set_jmpbuf_decl, gnu_jmpsave_decl));\n+      add_cleanup (build_call_1_expr (set_jmpbuf_decl, gnu_jmpsave_decl),\n+\t\t   End_Label (gnat_node));\n     }\n \n   /* If we are to call a function when exiting this block, add a cleanup\n      to the binding level we made above.  Note that add_cleanup is FIFO\n      so we must register this cleanup after the EH cleanup just above.  */\n   if (at_end)\n-    add_cleanup (build_call_0_expr (gnat_to_gnu (At_End_Proc (gnat_node))));\n+    add_cleanup (build_call_0_expr (gnat_to_gnu (At_End_Proc (gnat_node))),\n+\t\t End_Label (gnat_node));\n \n   /* Now build the tree for the declarations and statements inside this block.\n      If this is SJLJ, set our jmp_buf as the current buffer.  */\n@@ -2581,7 +2814,9 @@ Exception_Handler_to_gnu_zcx (Node_Id gnat_node)\n   add_stmt_with_node (build_call_1_expr (begin_handler_decl,\n \t\t\t\t\t gnu_incoming_exc_ptr),\n \t\t      gnat_node);\n-  add_cleanup (build_call_1_expr (end_handler_decl, gnu_incoming_exc_ptr));\n+  /* ??? We don't seem to have an End_Label at hand to set the location.  */\n+  add_cleanup (build_call_1_expr (end_handler_decl, gnu_incoming_exc_ptr),\n+\t       Empty);\n   add_stmt_list (Statements (gnat_node));\n   gnat_poplevel ();\n \n@@ -2618,7 +2853,10 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   if (Nkind (Unit (gnat_node)) == N_Package_Body\n       || (Nkind (Unit (gnat_node)) == N_Subprogram_Body\n \t      && !Acts_As_Spec (gnat_node)))\n-    add_stmt (gnat_to_gnu (Library_Unit (gnat_node)));\n+    {\n+      add_stmt (gnat_to_gnu (Library_Unit (gnat_node)));\n+      finalize_from_with_types ();\n+    }\n \n   process_inlined_subprograms (gnat_node);\n \n@@ -2639,6 +2877,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   /* Process any pragmas and actions following the unit.  */\n   add_stmt_list (Pragmas_After (Aux_Decls_Node (gnat_node)));\n   add_stmt_list (Actions (Aux_Decls_Node (gnat_node)));\n+  finalize_from_with_types ();\n \n   /* Save away what we've made so far and record this potential elaboration\n      procedure.  */\n@@ -2695,7 +2934,8 @@ gnat_to_gnu (Node_Id gnat_node)\n       && Nkind (gnat_node) != N_Identifier\n       && !Compile_Time_Known_Value (gnat_node))\n     return build1 (NULL_EXPR, get_unpadded_type (Etype (gnat_node)),\n-\t\t   build_call_raise (CE_Range_Check_Failed, gnat_node));\n+\t\t   build_call_raise (CE_Range_Check_Failed, gnat_node,\n+\t\t\t\t     N_Raise_Constraint_Error));\n \n   /* If this is a Statement and we are at top level, it must be part of the\n      elaboration procedure, so mark us as being in that procedure and push our\n@@ -3232,6 +3472,19 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   NULL_TREE, void_ftype, NULL_TREE, false, true, true, NULL,\n \t\t   gnat_node));\n \n+\t/* Check for 'Address of a subprogram or function that has\n+\t   a Freeze_Node and whose saved tree is an ADDR_EXPR.  If we have\n+\t   such, return that ADDR_EXPR.  */\n+\tif (attribute == Attr_Address\n+\t    && Nkind (Prefix (gnat_node)) == N_Identifier\n+\t    && (Ekind (Entity (Prefix (gnat_node))) == E_Function\n+\t\t|| Ekind (Entity (Prefix (gnat_node))) == E_Procedure)\n+\t    && Present (Freeze_Node (Entity (Prefix (gnat_node))))\n+\t    && present_gnu_tree (Entity (Prefix (gnat_node)))\n+\t    && (TREE_CODE (get_gnu_tree (Entity (Prefix (gnat_node))))\n+\t\t== TREE_LIST))\n+\t  return TREE_PURPOSE (get_gnu_tree (Entity (Prefix (gnat_node))));\n+\n \tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attribute);\n       }\n       break;\n@@ -3649,7 +3902,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t Storage_Error: execution shouldn't have gotten here anyway.  */\n       if (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))) == INTEGER_CST\n \t   && TREE_OVERFLOW (TYPE_SIZE_UNIT (TREE_TYPE (gnu_lhs))))\n-\tgnu_result = build_call_raise (SE_Object_Too_Large, gnat_node);\n+\tgnu_result = build_call_raise (SE_Object_Too_Large, gnat_node,\n+\t\t\t\t       N_Raise_Storage_Error);\n       else if (Nkind (Expression (gnat_node)) == N_Function_Call\n \t       && !Do_Range_Check (Expression (gnat_node)))\n \tgnu_result = call_to_gnu (Expression (gnat_node),\n@@ -3876,11 +4130,23 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* Unless there is a freeze node, declare the subprogram.  We consider\n \t this a \"definition\" even though we're not generating code for\n \t the subprogram because we will be making the corresponding GCC\n-\t node here.  */\n-\n-      if (No (Freeze_Node (Defining_Entity (Specification (gnat_node)))))\n+\t node here.  If there is a freeze node, make a dummy ADDR_EXPR\n+\t so we can take the address of this subprogram before its freeze\n+\t point; we'll fill in the ADDR_EXPR later.  Put that ADDR_EXPR\n+\t into a TREE_LIST that contains space for the value specified\n+\t in an Address clause.  */\n+      if (Freeze_Node (Defining_Entity (Specification (gnat_node))))\n+\tsave_gnu_tree (Defining_Entity (Specification (gnat_node)),\n+\t\t       tree_cons (build1 (ADDR_EXPR,\n+\t\t\t\t\t  build_pointer_type\n+\t\t\t\t\t  (make_node (FUNCTION_TYPE)),\n+\t\t\t\t\t  NULL_TREE),\n+\t\t\t\t  NULL_TREE, NULL_TREE),\n+\t\t       true);\n+      else\n \tgnat_to_gnu_entity (Defining_Entity (Specification (gnat_node)),\n \t\t\t    NULL_TREE, 1);\n+\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -4042,6 +4308,36 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       break;\n \n+    case N_Push_Constraint_Error_Label:\n+      push_exception_label_stack (&gnu_constraint_error_label_stack,\n+\t\t\t\t  Exception_Label (gnat_node));\n+      break;\n+\n+    case N_Push_Storage_Error_Label:\n+      push_exception_label_stack (&gnu_storage_error_label_stack,\n+\t\t\t\t  Exception_Label (gnat_node));\n+      break;\n+\n+    case N_Push_Program_Error_Label:\n+      push_exception_label_stack (&gnu_program_error_label_stack,\n+\t\t\t\t  Exception_Label (gnat_node));\n+      break;\n+\n+    case N_Pop_Constraint_Error_Label:\n+      gnu_constraint_error_label_stack\n+\t= TREE_CHAIN (gnu_constraint_error_label_stack);\n+      break;\n+\n+    case N_Pop_Storage_Error_Label:\n+      gnu_storage_error_label_stack\n+\t= TREE_CHAIN (gnu_storage_error_label_stack);\n+      break;\n+\n+    case N_Pop_Program_Error_Label:\n+      gnu_program_error_label_stack\n+\t= TREE_CHAIN (gnu_program_error_label_stack);\n+      break;\n+\n     /*******************************/\n     /* Chapter 12: Generic Units:  */\n     /*******************************/\n@@ -4077,9 +4373,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       /* Get the value to use as the address and save it as the\n \t equivalent for GNAT_TEMP.  When the object is frozen,\n-\t gnat_to_gnu_entity will do the right thing. */\n-      save_gnu_tree (Entity (Name (gnat_node)),\n-\t\t     gnat_to_gnu (Expression (gnat_node)), true);\n+\t gnat_to_gnu_entity will do the right thing. We have to handle\n+\t subprograms differently here.  */\n+      if (Ekind (Entity (Name (gnat_node))) == E_Procedure\n+\t  || Ekind (Entity (Name (gnat_node))) == E_Function)\n+\tTREE_VALUE (get_gnu_tree (Entity (Name (gnat_node))))\n+\t  = gnat_to_gnu (Expression (gnat_node));\n+      else\n+\tsave_gnu_tree (Entity (Name (gnat_node)),\n+\t\t       gnat_to_gnu (Expression (gnat_node)), true);\n       break;\n \n     case N_Enumeration_Representation_Clause:\n@@ -4295,7 +4597,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n       gnu_result\n-\t= build_call_raise (UI_To_Int (Reason (gnat_node)), gnat_node);\n+\t= build_call_raise (UI_To_Int (Reason (gnat_node)), gnat_node,\n+\t\t\t    Nkind (gnat_node));\n \n       /* If the type is VOID, this is a statement, so we need to\n \t generate the code for the call.  Handle a Condition, if there\n@@ -4387,10 +4690,12 @@ gnat_to_gnu (Node_Id gnat_node)\n       current_function_decl = NULL_TREE;\n     }\n \n-  /* Set the location information into the result.  Note that we may have\n+  /* Set the location information on the result if it is a real expression.\n+     References can be reused for multiple GNAT nodes and they would get\n+     the location information of their last use.  Note that we may have\n      no result if we tried to build a CALL_EXPR node to a procedure with\n      no side-effects and optimization is enabled.  */\n-  if (gnu_result && EXPR_P (gnu_result))\n+  if (gnu_result && EXPR_P (gnu_result) && !REFERENCE_CLASS_P (gnu_result))\n     annotate_with_node (gnu_result, gnat_node);\n \n   /* If we're supposed to return something of void_type, it means we have\n@@ -4406,7 +4711,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       gnu_result\n \t= build1 (NULL_EXPR, gnu_result_type,\n-\t\t  build_call_raise (CE_Overflow_Check_Failed, gnat_node));\n+\t\t  build_call_raise (CE_Overflow_Check_Failed, gnat_node,\n+\t\t\t\t    N_Raise_Constraint_Error));\n     }\n \n   /* If our result has side-effects and is of an unconstrained type,\n@@ -4511,6 +4817,20 @@ gnat_to_gnu (Node_Id gnat_node)\n   return gnu_result;\n }\n \f\n+/* Subroutine of above to push the exception label stack.  GNU_STACK is\n+   a pointer to the stack to update and GNAT_LABEL, if present, is the\n+   label to push onto the stack.  */\n+\n+static void\n+push_exception_label_stack (tree *gnu_stack, Entity_Id gnat_label)\n+{\n+  tree gnu_label = (Present (gnat_label)\n+\t\t    ? gnat_to_gnu_entity (gnat_label, NULL_TREE, 0)\n+\t\t    : NULL_TREE);\n+\n+  *gnu_stack = tree_cons (NULL_TREE, gnu_label, *gnu_stack);\n+}\n+\f\n /* Record the current code position in GNAT_NODE.  */\n \n static void\n@@ -4533,7 +4853,7 @@ insert_code_for (Node_Id gnat_node)\n \f\n /* Start a new statement group chained to the previous group.  */\n \n-static void\n+void\n start_stmt_group (void)\n {\n   struct stmt_group *group = stmt_group_free_list;\n@@ -4608,7 +4928,7 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n     add_stmt_with_node (gnu_stmt, gnat_entity);\n \n   /* If this is a variable and an initializer is attached to it, it must be\n-     valid for the context.  Similar to init_const in create_var_decl_1.  */ \n+     valid for the context.  Similar to init_const in create_var_decl_1.  */\n   if (TREE_CODE (gnu_decl) == VAR_DECL\n       && (gnu_init = DECL_INITIAL (gnu_decl)) != NULL_TREE\n       && (TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (TREE_TYPE (gnu_init))\n@@ -4672,11 +4992,14 @@ unshare_save_expr (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n-/* Add GNU_CLEANUP, a cleanup action, to the current code group.  */\n+/* Add GNU_CLEANUP, a cleanup action, to the current code group and\n+   set its location to that of GNAT_NODE if present.  */\n \n static void\n-add_cleanup (tree gnu_cleanup)\n+add_cleanup (tree gnu_cleanup, Node_Id gnat_node)\n {\n+  if (Present (gnat_node))\n+    annotate_with_node (gnu_cleanup, gnat_node);\n   append_to_statement_list (gnu_cleanup, &current_stmt_group->cleanups);\n }\n \n@@ -4693,7 +5016,7 @@ set_block_for_group (tree gnu_block)\n    a STATEMENT_LIST, but may also be a BIND_EXPR or TRY_FINALLY_EXPR if\n    BLOCK or cleanups were set.  */\n \n-static tree\n+tree\n end_stmt_group (void)\n {\n   struct stmt_group *group = current_stmt_group;\n@@ -4784,36 +5107,6 @@ pop_stack (tree *gnu_stack_ptr)\n   gnu_stack_free_list = gnu_node;\n }\n \f\n-/* GNU_STMT is a statement.  We generate code for that statement.  */\n-\n-void\n-gnat_expand_stmt (tree gnu_stmt)\n-{\n-#if 0\n-  tree gnu_elmt, gnu_elmt_2;\n-#endif\n-\n-  switch (TREE_CODE (gnu_stmt))\n-    {\n-#if 0\n-    case USE_STMT:\n-      /* First write a volatile ASM_INPUT to prevent anything from being\n-\t moved.  */\n-      gnu_elmt = gen_rtx_ASM_INPUT (VOIDmode, \"\");\n-      MEM_VOLATILE_P (gnu_elmt) = 1;\n-      emit_insn (gnu_elmt);\n-\n-      gnu_elmt = expand_expr (TREE_OPERAND (gnu_stmt, 0), NULL_RTX, VOIDmode,\n-\t\t\t    modifier);\n-      emit_insn (gen_rtx_USE (VOIDmode, ));\n-      return target;\n-#endif\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\f\n /* Generate GIMPLE in place for the expression at *EXPR_P.  */\n \n int\n@@ -4841,7 +5134,7 @@ gnat_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n \t  TREE_NO_WARNING (*expr_p) = 1;\n \t}\n \n-      append_to_statement_list (TREE_OPERAND (expr, 0), pre_p);\n+      gimplify_and_add (TREE_OPERAND (expr, 0), pre_p);\n       return GS_OK;\n \n     case UNCONSTRAINED_ARRAY_REF:\n@@ -4941,10 +5234,6 @@ gnat_gimplify_stmt (tree *stmt_p)\n       *stmt_p = STMT_STMT_STMT (stmt);\n       return GS_OK;\n \n-    case USE_STMT:\n-      *stmt_p = NULL_TREE;\n-      return GS_ALL_DONE;\n-\n     case LOOP_STMT:\n       {\n \ttree gnu_start_label = create_artificial_label ();\n@@ -5105,8 +5394,11 @@ process_freeze_entity (Node_Id gnat_node)\n     = present_gnu_tree (gnat_entity) ? get_gnu_tree (gnat_entity) : 0;\n \n   /* If this entity has an Address representation clause, GNU_OLD is the\n-     address, so discard it here.  */\n-  if (Present (Address_Clause (gnat_entity)))\n+     address, so discard it here.  The exception is if this is a subprogram.\n+     In that case, GNU_OLD is a TREE_LIST that contains both an address and\n+     the ADDR_EXPR needed to take the address of the subprogram.  */\n+  if (Present (Address_Clause (gnat_entity))\n+      && TREE_CODE (gnu_old) != TREE_LIST)\n     gnu_old = 0;\n \n   /* Don't do anything for class-wide types they are always\n@@ -5119,14 +5411,14 @@ process_freeze_entity (Node_Id gnat_node)\n   /* Don't do anything for subprograms that may have been elaborated before\n      their freeze nodes.  This can happen, for example because of an inner call\n      in an instance body, or a previous compilation of a spec for inlining\n-     purposes.  */\n-  if  ((gnu_old\n-        && TREE_CODE (gnu_old) == FUNCTION_DECL\n-        && (Ekind (gnat_entity) == E_Function\n-          || Ekind (gnat_entity) == E_Procedure))\n-    || (gnu_old\n-        && (TREE_CODE (TREE_TYPE (gnu_old)) == FUNCTION_TYPE\n-        && Ekind (gnat_entity) == E_Subprogram_Type)))\n+     purposes.  ??? Does this still occur?  */\n+  if (gnu_old\n+      && ((TREE_CODE (gnu_old) == FUNCTION_DECL\n+\t   && (Ekind (gnat_entity) == E_Function\n+\t       || Ekind (gnat_entity) == E_Procedure))\n+\t  || (TREE_CODE (gnu_old) != TREE_LIST\n+\t      && TREE_CODE (TREE_TYPE (gnu_old)) == FUNCTION_TYPE\n+\t      && Ekind (gnat_entity) == E_Subprogram_Type)))\n     return;\n \n   /* If we have a non-dummy type old tree, we have nothing to do, except\n@@ -5137,7 +5429,8 @@ process_freeze_entity (Node_Id gnat_node)\n      freeze node, e.g. while processing the other.  */\n   if (gnu_old\n       && !(TREE_CODE (gnu_old) == TYPE_DECL\n-\t   && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old))))\n+\t   && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old)))\n+      && TREE_CODE (gnu_old) != TREE_LIST)\n     {\n       gcc_assert ((IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n \t\t   && Present (Full_View (gnat_entity))\n@@ -5151,10 +5444,14 @@ process_freeze_entity (Node_Id gnat_node)\n   /* Reset the saved tree, if any, and elaborate the object or type for real.\n      If there is a full declaration, elaborate it and copy the type to\n      GNAT_ENTITY.  Likewise if this is the record subtype corresponding to\n-     a class wide type or subtype.  */\n-  if (gnu_old)\n+     a class wide type or subtype.  First handle the subprogram case: there,\n+     we have to set the GNU tree to be the address clause, if any.  */\n+  else if (gnu_old)\n     {\n       save_gnu_tree (gnat_entity, NULL_TREE, false);\n+      if (TREE_CODE (gnu_old) == TREE_LIST && TREE_VALUE (gnu_old))\n+\tsave_gnu_tree (gnat_entity, TREE_VALUE (gnu_old), true);\n+\n       if (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n   \t  && Present (Full_View (gnat_entity))\n   \t  && present_gnu_tree (Full_View (gnat_entity)))\n@@ -5191,6 +5488,15 @@ process_freeze_entity (Node_Id gnat_node)\n   else\n     gnu_new = gnat_to_gnu_entity (gnat_entity, gnu_init, 1);\n \n+  /* If this was a subprogram being frozen, we have to update the ADDR_EXPR\n+     we previously made.  Update the operand, then set up to update the\n+     pointers.  */\n+  if (gnu_old && TREE_CODE (gnu_old) == TREE_LIST)\n+    {\n+      TREE_OPERAND (TREE_PURPOSE (gnu_old), 0) = gnu_new;\n+      gnu_old = TREE_TYPE (TREE_PURPOSE (gnu_old));\n+    }\n+\n   /* If we've made any pointers to the old version of this type, we\n      have to update them.  */\n   if (gnu_old)\n@@ -5458,7 +5764,7 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason)\n   tree gnu_call;\n   tree gnu_result;\n \n-  gnu_call = build_call_raise (reason, Empty);\n+  gnu_call = build_call_raise (reason, Empty, N_Raise_Constraint_Error);\n \n   /* Use an outer COMPOUND_EXPR to make sure that GNU_EXPR will get evaluated\n      in front of the comparison in case it ends up being a SAVE_EXPR.  Put the\n@@ -6035,18 +6341,13 @@ protect_multiple_eval (tree exp)\n \t\t\t\t\t\t exp)));\n }\n \f\n-/* This is equivalent to stabilize_reference in GCC's tree.c, but we know how\n-   to handle our new nodes and we take extra arguments:\n-\n-   FORCE says whether to force evaluation of everything,\n-\n-   SUCCESS we set to true unless we walk through something we don't know how\n-   to stabilize, or through something which is not an lvalue and LVALUES_ONLY\n-   is true, in which cases we set to false.  */\n+/* This is equivalent to stabilize_reference in tree.c, but we know how to\n+   handle our own nodes and we take extra arguments.  FORCE says whether to\n+   force evaluation of everything.  We set SUCCESS to true unless we walk\n+   through something we don't know how to stabilize.  */\n \n tree\n-maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n-\t\t\t   bool *success)\n+maybe_stabilize_reference (tree ref, bool force, bool *success)\n {\n   tree type = TREE_TYPE (ref);\n   enum tree_code code = TREE_CODE (ref);\n@@ -6064,14 +6365,6 @@ maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n       return ref;\n \n     case ADDR_EXPR:\n-      /*  A standalone ADDR_EXPR is never an lvalue, and this one can't\n-\t  be nested inside an outer INDIRECT_REF, since INDIRECT_REF goes\n-\t  straight to gnat_stabilize_reference_1.  */\n-      if (lvalues_only)\n-\tgoto failure;\n-\n-      /* ... Fallthru ... */\n-\n     case NOP_EXPR:\n     case CONVERT_EXPR:\n     case FLOAT_EXPR:\n@@ -6080,7 +6373,7 @@ maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n       result\n \t= build1 (code, type,\n \t\t  maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t     lvalues_only, success));\n+\t\t\t\t\t     success));\n       break;\n \n     case INDIRECT_REF:\n@@ -6093,14 +6386,14 @@ maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n     case COMPONENT_REF:\n      result = build3 (COMPONENT_REF, type,\n \t\t      maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t lvalues_only, success),\n+\t\t\t\t\t\t success),\n \t\t      TREE_OPERAND (ref, 1), NULL_TREE);\n       break;\n \n     case BIT_FIELD_REF:\n       result = build3 (BIT_FIELD_REF, type,\n \t\t       maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t  lvalues_only, success),\n+\t\t\t\t\t\t  success),\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n \t\t\t\t\t\t   force),\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 2),\n@@ -6111,7 +6404,7 @@ maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n     case ARRAY_RANGE_REF:\n       result = build4 (code, type,\n \t\t       maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t  lvalues_only, success),\n+\t\t\t\t\t\t  success),\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n \t\t\t\t\t\t   force),\n \t\t       NULL_TREE, NULL_TREE);\n@@ -6122,9 +6415,6 @@ maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n       break;\n \n     case CALL_EXPR:\n-      if (lvalues_only)\n-\tgoto failure;\n-\n       /* This generates better code than the scheme in protect_multiple_eval\n \t because large objects will be returned via invisible reference in\n \t most ABIs so the temporary will directly be filled by the callee.  */\n@@ -6139,7 +6429,6 @@ maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n       /* If arg isn't a kind of lvalue we recognize, make no change.\n \t Caller should recognize the error for an invalid lvalue.  */\n     default:\n-    failure:\n       *success = false;\n       return ref;\n     }\n@@ -6165,11 +6454,11 @@ maybe_stabilize_reference (tree ref, bool force, bool lvalues_only,\n    lvalue restrictions and without need to examine the success\n    indication.  */\n \n-tree\n+static tree\n gnat_stabilize_reference (tree ref, bool force)\n {\n-  bool stabilized;\n-  return maybe_stabilize_reference (ref, force, false, &stabilized);\n+  bool dummy;\n+  return maybe_stabilize_reference (ref, force, &dummy);\n }\n \n /* Similar to stabilize_reference_1 in tree.c, but supports an extra\n@@ -6443,3 +6732,18 @@ init_code_table (void)\n }\n \n #include \"gt-ada-trans.h\"\n+/* Return a label to branch to for the exception type in KIND or NULL_TREE\n+   if none.  */\n+\n+tree\n+get_exception_label (char kind)\n+{\n+  if (kind == N_Raise_Constraint_Error)\n+    return TREE_VALUE (gnu_constraint_error_label_stack);\n+  else if (kind == N_Raise_Storage_Error)\n+    return TREE_VALUE (gnu_storage_error_label_stack);\n+  else if (kind == N_Raise_Program_Error)\n+    return TREE_VALUE (gnu_program_error_label_stack);\n+  else\n+    return NULL_TREE;\n+}"}, {"sha": "69d4a887b8d254ed383f157ce6105b33d23966f2", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 397, "deletions": 177, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09ef48fe18e9314a3b9a42692864644c01e5b50d/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=09ef48fe18e9314a3b9a42692864644c01e5b50d", "patch": "@@ -148,27 +148,22 @@ static GTY(()) struct gnat_binding_level *current_binding_level;\n static GTY((deletable)) struct gnat_binding_level *free_binding_level;\n \n /* An array of global declarations.  */\n-static GTY(()) VEC (tree,gc) *global_decls;\n+static GTY(()) VEC(tree,gc) *global_decls;\n \n /* An array of builtin declarations.  */\n-static GTY(()) VEC (tree,gc) *builtin_decls;\n+static GTY(()) VEC(tree,gc) *builtin_decls;\n \n /* An array of global renaming pointers.  */\n-static GTY(()) VEC (tree,gc) *global_renaming_pointers;\n+static GTY(()) VEC(tree,gc) *global_renaming_pointers;\n \n /* Arrays of functions called automatically at the beginning and\n    end of execution, on targets without .ctors/.dtors sections.  */\n-static GTY(()) VEC (tree,gc) *static_ctors;\n-static GTY(()) VEC (tree,gc) *static_dtors;\n+static GTY(()) VEC(tree,gc) *static_ctors;\n+static GTY(()) VEC(tree,gc) *static_dtors;\n \n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n \n-struct language_function GTY(())\n-{\n-  int unused;\n-};\n-\n static void gnat_install_builtins (void);\n static tree merge_sizes (tree, tree, tree, bool, bool);\n static tree compute_related_constant (tree, tree);\n@@ -246,44 +241,34 @@ init_dummy_type (void)\n tree\n make_dummy_type (Entity_Id gnat_type)\n {\n-  Entity_Id gnat_underlying;\n+  Entity_Id gnat_underlying = Gigi_Equivalent_Type (gnat_type);\n   tree gnu_type;\n-  enum tree_code code;\n-\n-  /* Find a full type for GNAT_TYPE, taking into account any class wide\n-     types.  */\n-  if (Is_Class_Wide_Type (gnat_type) && Present (Equivalent_Type (gnat_type)))\n-    gnat_type = Equivalent_Type (gnat_type);\n-  else if (Ekind (gnat_type) == E_Class_Wide_Type)\n-    gnat_type = Root_Type (gnat_type);\n-\n-  /* Find a full view for GNAT_TYPE, looking through any incomplete or\n-     private types.  */\n-  if (IN (Ekind (gnat_type), Incomplete_Kind)\n-      && From_With_Type (gnat_type))\n-    gnat_underlying = Non_Limited_View (gnat_type);\n-  else if (IN (Ekind (gnat_type), Incomplete_Or_Private_Kind)\n-\t   && Present (Full_View (gnat_type)))\n-    gnat_underlying = Full_View (gnat_type);\n-  else\n+\n+  /* If there is an equivalent type, get its underlying type.  */\n+  if (Present (gnat_underlying))\n+    gnat_underlying = Underlying_Type (gnat_underlying);\n+\n+  /* If there was no equivalent type (can only happen when just annotating\n+     types) or underlying type, go back to the original type.  */\n+  if (No (gnat_underlying))\n     gnat_underlying = gnat_type;\n \n   /* If it there already a dummy type, use that one.  Else make one.  */\n   if (PRESENT_DUMMY_NODE (gnat_underlying))\n     return GET_DUMMY_NODE (gnat_underlying);\n \n-  /* If this is a record, make this a RECORD_TYPE or UNION_TYPE; else make\n-     it an ENUMERAL_TYPE.  */\n-  if (Is_Record_Type (gnat_underlying))\n-    code = tree_code_for_record_type (gnat_underlying);\n-  else\n-    code = ENUMERAL_TYPE;\n-\n-  gnu_type = make_node (code);\n+  /* If this is a record, make a RECORD_TYPE or UNION_TYPE; else make\n+     an ENUMERAL_TYPE.  */\n+  gnu_type = make_node (Is_Record_Type (gnat_underlying)\n+\t\t\t? tree_code_for_record_type (gnat_underlying)\n+\t\t\t: ENUMERAL_TYPE);\n   TYPE_NAME (gnu_type) = get_entity_name (gnat_type);\n   TYPE_DUMMY_P (gnu_type) = 1;\n   if (AGGREGATE_TYPE_P (gnu_type))\n-    TYPE_STUB_DECL (gnu_type) = build_decl (TYPE_DECL, NULL_TREE, gnu_type);\n+    {\n+      TYPE_STUB_DECL (gnu_type) = build_decl (TYPE_DECL, NULL_TREE, gnu_type);\n+      TYPE_BY_REFERENCE_P (gnu_type) = Is_By_Reference_Type (gnat_type);\n+    }\n \n   SET_DUMMY_NODE (gnat_underlying, gnu_type);\n \n@@ -443,7 +428,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n   add_decl_expr (decl, gnat_node);\n \n   /* Put the declaration on the list.  The list of declarations is in reverse\n-     order. The list will be reversed later.  Put global variables in the\n+     order.  The list will be reversed later.  Put global variables in the\n      globals list and builtin functions in a dedicated list to speed up\n      further lookups.  Don't put TYPE_DECLs for UNCONSTRAINED_ARRAY_TYPE into\n      the list, as they will cause trouble with the debugger and aren't needed\n@@ -469,22 +454,29 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n      set, was set to an IDENTIFIER_NODE, indicating an internal name,\n      or if the previous type name was not derived from a source name.\n      We'd rather have the type named with a real name and all the pointer\n-     types to the same object have the same POINTER_TYPE node.  Code in this\n-     function in c-decl.c makes a copy of the type node here, but that may\n-     cause us trouble with incomplete types, so let's not try it (at least\n-     for now).  */\n-\n-  if (TREE_CODE (decl) == TYPE_DECL\n-      && DECL_NAME (decl)\n-      && (!TYPE_NAME (TREE_TYPE (decl))\n-\t  || TREE_CODE (TYPE_NAME (TREE_TYPE (decl))) == IDENTIFIER_NODE\n-\t  || (TREE_CODE (TYPE_NAME (TREE_TYPE (decl))) == TYPE_DECL\n-\t      && DECL_ARTIFICIAL (TYPE_NAME (TREE_TYPE (decl)))\n-\t      && !DECL_ARTIFICIAL (decl))))\n-    TYPE_NAME (TREE_TYPE (decl)) = decl;\n-\n-  /*  if (TREE_CODE (decl) != CONST_DECL)\n-      rest_of_decl_compilation (decl, global_bindings_p (), 0); */\n+     types to the same object have the same POINTER_TYPE node.  Code in the\n+     equivalent function of c-decl.c makes a copy of the type node here, but\n+     that may cause us trouble with incomplete types.  We make an exception\n+     for fat pointer types because the compiler automatically builds them\n+     for unconstrained array types and the debugger uses them to represent\n+     both these and pointers to these.  */\n+  if (TREE_CODE (decl) == TYPE_DECL && DECL_NAME (decl))\n+    {\n+      tree t = TREE_TYPE (decl);\n+\n+      if (!TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) == IDENTIFIER_NODE)\n+\tTYPE_NAME (t) = decl;\n+      else if (TYPE_FAT_POINTER_P (t))\n+\t{\n+\t  tree tt = build_variant_type_copy (t);\n+\t  TYPE_NAME (tt) = decl;\n+\t  TREE_USED (tt) = TREE_USED (t);\n+\t  TREE_TYPE (decl) = tt;\n+\t  DECL_ORIGINAL_TYPE (decl) = t;\n+\t}\n+      else if (DECL_ARTIFICIAL (TYPE_NAME (t)) && !DECL_ARTIFICIAL (decl))\n+\tTYPE_NAME (t) = decl;\n+    }\n }\n \f\n /* Do little here.  Set up the standard declarations later after the\n@@ -762,15 +754,19 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n   main_identifier_node = get_identifier (\"main\");\n }\n \f\n-/* Given a record type (RECORD_TYPE) and a chain of FIELD_DECL nodes\n-   (FIELDLIST), finish constructing the record or union type.  If HAS_REP is\n-   true, this record has a rep clause; don't call layout_type but merely set\n-   the size and alignment ourselves.  If DEFER_DEBUG is true, do not call\n-   the debugging routines on this type; it will be done later. */\n+/* Given a record type RECORD_TYPE and a chain of FIELD_DECL nodes FIELDLIST,\n+   finish constructing the record or union type.  If REP_LEVEL is zero, this\n+   record has no representation clause and so will be entirely laid out here.\n+   If REP_LEVEL is one, this record has a representation clause and has been\n+   laid out already; only set the sizes and alignment.  If REP_LEVEL is two,\n+   this record is derived from a parent record and thus inherits its layout;\n+   only make a pass on the fields to finalize them.  If DO_NOT_FINALIZE is\n+   true, the record type is expected to be modified afterwards so it will\n+   not be sent to the back-end for finalization.  */\n \n void\n-finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n-                    bool defer_debug)\n+finish_record_type (tree record_type, tree fieldlist, int rep_level,\n+\t\t    bool do_not_finalize)\n {\n   enum tree_code code = TREE_CODE (record_type);\n   tree ada_size = bitsize_zero_node;\n@@ -790,8 +786,7 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \n   /* Globally initialize the record first.  If this is a rep'ed record,\n      that just means some initializations; otherwise, layout the record.  */\n-\n-  if (has_rep)\n+  if (rep_level > 0)\n     {\n       TYPE_ALIGN (record_type) = MAX (BITS_PER_UNIT, TYPE_ALIGN (record_type));\n       TYPE_MODE (record_type) = BLKmode;\n@@ -864,7 +859,7 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n       DECL_NONADDRESSABLE_P (field)\n \t|= DECL_BIT_FIELD (field) && DECL_MODE (field) != BLKmode;\n \n-      if (has_rep && !DECL_BIT_FIELD (field))\n+      if ((rep_level > 0) && !DECL_BIT_FIELD (field))\n \tTYPE_ALIGN (record_type)\n \t  = MAX (TYPE_ALIGN (record_type), DECL_ALIGN (field));\n \n@@ -894,9 +889,10 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n \t     the case of empty variants.  */\n \t  ada_size\n \t    = merge_sizes (ada_size, pos, this_ada_size,\n-\t\t\t   TREE_CODE (type) == QUAL_UNION_TYPE, has_rep);\n-\t  size = merge_sizes (size, pos, this_size,\n-\t\t\t      TREE_CODE (type) == QUAL_UNION_TYPE, has_rep);\n+\t\t\t   TREE_CODE (type) == QUAL_UNION_TYPE, rep_level > 0);\n+\t  size\n+\t    = merge_sizes (size, pos, this_size,\n+\t\t\t   TREE_CODE (type) == QUAL_UNION_TYPE, rep_level > 0);\n \t  break;\n \n \tdefault:\n@@ -907,41 +903,47 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n   if (code == QUAL_UNION_TYPE)\n     nreverse (fieldlist);\n \n-  /* If this is a padding record, we never want to make the size smaller than\n-     what was specified in it, if any.  */\n-  if (TREE_CODE (record_type) == RECORD_TYPE\n-      && TYPE_IS_PADDING_P (record_type) && TYPE_SIZE (record_type))\n-    size = TYPE_SIZE (record_type);\n-\n-  /* Now set any of the values we've just computed that apply.  */\n-  if (!TYPE_IS_FAT_POINTER_P (record_type)\n-      && !TYPE_CONTAINS_TEMPLATE_P (record_type))\n-    SET_TYPE_ADA_SIZE (record_type, ada_size);\n-\n-  if (has_rep)\n+  if (rep_level < 2)\n     {\n-      tree size_unit\n-\t= (had_size_unit ? TYPE_SIZE_UNIT (record_type)\n-\t   : convert (sizetype, size_binop (CEIL_DIV_EXPR, size,\n-\t\t\t\t\t    bitsize_unit_node)));\n-\n-      TYPE_SIZE (record_type)\n-\t= variable_size (round_up (size, TYPE_ALIGN (record_type)));\n-      TYPE_SIZE_UNIT (record_type)\n-\t= variable_size (round_up (size_unit,\n-\t\t\t\t   TYPE_ALIGN (record_type) / BITS_PER_UNIT));\n-\n-      compute_record_mode (record_type);\n+      /* If this is a padding record, we never want to make the size smaller\n+\t than what was specified in it, if any.  */\n+      if (TREE_CODE (record_type) == RECORD_TYPE\n+\t  && TYPE_IS_PADDING_P (record_type) && TYPE_SIZE (record_type))\n+\tsize = TYPE_SIZE (record_type);\n+\n+      /* Now set any of the values we've just computed that apply.  */\n+      if (!TYPE_IS_FAT_POINTER_P (record_type)\n+\t  && !TYPE_CONTAINS_TEMPLATE_P (record_type))\n+\tSET_TYPE_ADA_SIZE (record_type, ada_size);\n+\n+      if (rep_level > 0)\n+\t{\n+\t  tree size_unit = had_size_unit\n+\t\t\t   ? TYPE_SIZE_UNIT (record_type)\n+\t\t\t   : convert (sizetype,\n+\t\t\t\t      size_binop (CEIL_DIV_EXPR, size,\n+\t\t\t\t\t\t  bitsize_unit_node));\n+\t  unsigned int align = TYPE_ALIGN (record_type);\n+\n+\t  TYPE_SIZE (record_type) = variable_size (round_up (size, align));\n+\t  TYPE_SIZE_UNIT (record_type)\n+\t    = variable_size (round_up (size_unit, align / BITS_PER_UNIT));\n+\n+\t  compute_record_mode (record_type);\n+\t}\n     }\n \n-  if (!defer_debug)\n-    write_record_type_debug_info (record_type);\n+  if (!do_not_finalize)\n+    rest_of_record_type_compilation (record_type);\n }\n \n-/* Output the debug information associated to a record type.  */\n+/* Wrap up compilation of RECORD_TYPE, i.e. most notably output all\n+   the debug information associated with it.  It need not be invoked\n+   directly in most cases since finish_record_type takes care of doing\n+   so, unless explicitly requested not to through DO_NOT_FINALIZE.  */\n \n void\n-write_record_type_debug_info (tree record_type)\n+rest_of_record_type_compilation (tree record_type)\n {\n   tree fieldlist = TYPE_FIELDS (record_type);\n   tree field;\n@@ -1027,31 +1029,28 @@ write_record_type_debug_info (tree record_type)\n \t    pos = compute_related_constant (curpos, last_pos);\n \n \t  if (!pos && TREE_CODE (curpos) == MULT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (curpos, 1)) == INTEGER_CST)\n+\t      && host_integerp (TREE_OPERAND (curpos, 1), 1))\n \t    {\n-\t      /* An offset which is a bit-and operation with a negative\n-\t\t power of 2 means an alignment corresponding to this power\n-\t\t of 2.  */\n \t      tree offset = TREE_OPERAND (curpos, 0);\n+\t      align = tree_low_cst (TREE_OPERAND (curpos, 1), 1);\n \n \t      /* Strip off any conversions.  */\n \t      while (TREE_CODE (offset) == NON_LVALUE_EXPR\n \t\t     || TREE_CODE (offset) == NOP_EXPR\n \t\t     || TREE_CODE (offset) == CONVERT_EXPR)\n \t\toffset = TREE_OPERAND (offset, 0);\n \n-\t      if (TREE_CODE (offset) == BIT_AND_EXPR)\n+\t      /* An offset which is a bitwise AND with a negative power of 2\n+\t\t means an alignment corresponding to this power of 2.  */\n+\t      if (TREE_CODE (offset) == BIT_AND_EXPR\n+\t\t  && host_integerp (TREE_OPERAND (offset, 1), 0)\n+\t\t  && tree_int_cst_sgn (TREE_OPERAND (offset, 1)) < 0)\n \t\t{\n-\t\t  int p = exact_log2\n-\t\t    (- TREE_INT_CST_LOW (TREE_OPERAND (offset, 1)));\n-\n-\t\t  if (p < 0)\n-\t\t    p = 1;\n-\n-\t\t  align = p * TREE_INT_CST_LOW (TREE_OPERAND (curpos, 1));\n+\t\t  unsigned int pow\n+\t\t    = - tree_low_cst (TREE_OPERAND (offset, 1), 0);\n+\t\t  if (exact_log2 (pow) > 0)\n+\t\t    align *= pow;\n \t\t}\n-\t      else\n-\t\talign = TREE_INT_CST_LOW (TREE_OPERAND (curpos, 1));\n \n \t      pos = compute_related_constant (curpos,\n \t\t\t\t\t      round_up (last_pos, align));\n@@ -1085,11 +1084,19 @@ write_record_type_debug_info (tree record_type)\n \t  if (!pos)\n \t    pos = bitsize_zero_node;\n \n-\t  /* See if this type is variable-size and make a new type\n-\t     and indicate the indirection if so.  */\n+\t  /* See if this type is variable-sized and make a pointer type\n+\t     and indicate the indirection if so.  Beware that the debug\n+\t     back-end may adjust the position computed above according\n+\t     to the alignment of the field type, i.e. the pointer type\n+\t     in this case, if we don't preventively counter that.  */\n \t  if (TREE_CODE (DECL_SIZE (old_field)) != INTEGER_CST)\n \t    {\n \t      field_type = build_pointer_type (field_type);\n+\t      if (align != 0 && TYPE_ALIGN (field_type) > align)\n+\t\t{\n+\t\t  field_type = copy_node (field_type);\n+\t\t  TYPE_ALIGN (field_type) = align;\n+\t\t}\n \t      var = true;\n \t    }\n \n@@ -1129,10 +1136,10 @@ write_record_type_debug_info (tree record_type)\n       TYPE_FIELDS (new_record_type)\n \t= nreverse (TYPE_FIELDS (new_record_type));\n \n-      rest_of_type_compilation (new_record_type, true);\n+      rest_of_type_decl_compilation (TYPE_STUB_DECL (new_record_type));\n     }\n \n-  rest_of_type_compilation (record_type, true);\n+  rest_of_type_decl_compilation (TYPE_STUB_DECL (record_type));\n }\n \n /* Utility function of above to merge LAST_SIZE, the previous size of a record\n@@ -1313,10 +1320,11 @@ copy_type (tree type)\n }\n \f\n /* Return an INTEGER_TYPE of SIZETYPE with range MIN to MAX and whose\n-   TYPE_INDEX_TYPE is INDEX.  */\n+   TYPE_INDEX_TYPE is INDEX.  GNAT_NODE is used for the position of\n+   the decl.  */\n \n tree\n-create_index_type (tree min, tree max, tree index)\n+create_index_type (tree min, tree max, tree index, Node_Id gnat_node)\n {\n   /* First build a type for the desired range.  */\n   tree type = build_index_2_type (min, max);\n@@ -1332,7 +1340,7 @@ create_index_type (tree min, tree max, tree index)\n     type = copy_type (type);\n \n   SET_TYPE_INDEX_TYPE (type, index);\n-  create_type_decl (NULL_TREE, type, NULL, true, false, Empty);\n+  create_type_decl (NULL_TREE, type, NULL, true, false, gnat_node);\n   return type;\n }\n \f\n@@ -1361,15 +1369,13 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n      UNCONSTRAINED_ARRAY_TYPE, which the debugger does not support,\n      and ENUMERAL_TYPE or RECORD_TYPE which is handled separately, or\n      type for which debugging information was not requested.  */\n-  if (code == UNCONSTRAINED_ARRAY_TYPE || ! debug_info_p)\n+  if (code == UNCONSTRAINED_ARRAY_TYPE || !debug_info_p)\n     DECL_IGNORED_P (type_decl) = 1;\n-  if (code == UNCONSTRAINED_ARRAY_TYPE || TYPE_IS_DUMMY_P (type)\n-      || !debug_info_p)\n-    DECL_IGNORED_P (type_decl) = 1;\n-  else if (code != ENUMERAL_TYPE && code != RECORD_TYPE\n+  else if (code != ENUMERAL_TYPE\n+\t   && (code != RECORD_TYPE || TYPE_IS_FAT_POINTER_P (type))\n \t   && !((code == POINTER_TYPE || code == REFERENCE_TYPE)\n \t\t&& TYPE_IS_DUMMY_P (TREE_TYPE (type))))\n-    rest_of_decl_compilation (type_decl, global_bindings_p (), 0);\n+    rest_of_type_decl_compilation (type_decl);\n \n   return type_decl;\n }\n@@ -1402,30 +1408,35 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n \t\t   struct attrib *attr_list, Node_Id gnat_node)\n {\n   bool init_const\n-    = (!var_init\n-       ? false\n-       : (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (var_init))\n-\t  && (global_bindings_p () || static_flag\n-\t      ? 0 != initializer_constant_valid_p (var_init,\n-\t\t\t\t\t\t   TREE_TYPE (var_init))\n-\t      : TREE_CONSTANT (var_init))));\n+    = (var_init != 0\n+       && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (var_init))\n+       && (global_bindings_p () || static_flag\n+\t   ? initializer_constant_valid_p (var_init, TREE_TYPE (var_init)) != 0\n+\t   : TREE_CONSTANT (var_init)));\n+\n+  /* Whether we will make TREE_CONSTANT the DECL we produce here, in which\n+     case the initializer may be used in-lieu of the DECL node (as done in\n+     Identifier_to_gnu).  This is useful to prevent the need of elaboration\n+     code when an identifier for which such a decl is made is in turn used as\n+     an initializer.  We used to rely on CONST vs VAR_DECL for this purpose,\n+     but extra constraints apply to this choice (see below) and are not\n+     relevant to the distinction we wish to make. */\n+  bool constant_p = const_flag && init_const;\n+\n+  /* The actual DECL node.  CONST_DECL was initially intended for enumerals\n+     and may be used for scalars in general but not for aggregates.  */\n   tree var_decl\n-    = build_decl ((const_flag && const_decl_allowed_flag && init_const\n-\t\t   /* Only make a CONST_DECL for sufficiently-small objects.\n-\t\t      We consider complex double \"sufficiently-small\"  */\n-\t\t   && TYPE_SIZE (type) != 0\n-\t\t   && host_integerp (TYPE_SIZE_UNIT (type), 1)\n-\t\t   && 0 >= compare_tree_int (TYPE_SIZE_UNIT (type),\n-\t\t\t\t\t     GET_MODE_SIZE (DCmode)))\n-\t\t  ? CONST_DECL : VAR_DECL, var_name, type);\n-\n-  /* If this is external, throw away any initializations unless this is a\n-     CONST_DECL (meaning we have a constant); they will be done elsewhere.\n-     If we are defining a global here, leave a constant initialization and\n-     save any variable elaborations for the elaboration routine.  If we are\n-     just annotating types, throw away the initialization if it isn't a\n-     constant.  */\n-  if ((extern_flag && TREE_CODE (var_decl) != CONST_DECL)\n+    = build_decl ((constant_p && const_decl_allowed_flag\n+\t\t   && !AGGREGATE_TYPE_P (type)) ? CONST_DECL : VAR_DECL,\n+\t\t  var_name, type);\n+\n+  /* If this is external, throw away any initializations (they will be done\n+     elsewhere) unless this is a a constant for which we would like to remain\n+     able to get the initializer.  If we are defining a global here, leave a\n+     constant initialization and save any variable elaborations for the\n+     elaboration routine.  If we are just annotating types, throw away the\n+     initialization if it isn't a constant.  */\n+  if ((extern_flag && !constant_p)\n       || (type_annotate_only && var_init && !TREE_CONSTANT (var_init)))\n     var_init = NULL_TREE;\n \n@@ -1447,7 +1458,7 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n   TREE_READONLY (var_decl) = const_flag;\n   DECL_EXTERNAL (var_decl) = extern_flag;\n   TREE_PUBLIC   (var_decl) = public_flag || extern_flag;\n-  TREE_CONSTANT (var_decl) = TREE_CODE (var_decl) == CONST_DECL;\n+  TREE_CONSTANT (var_decl) = constant_p;\n   TREE_THIS_VOLATILE (var_decl) = TREE_SIDE_EFFECTS (var_decl)\n     = TYPE_VOLATILE (type);\n \n@@ -1570,7 +1581,7 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n       && size\n       && TREE_CODE (size) == INTEGER_CST\n       && TREE_CODE (TYPE_SIZE (field_type)) == INTEGER_CST\n-      && (!operand_equal_p (TYPE_SIZE (field_type), size, 0)\n+      && (!tree_int_cst_equal (size, TYPE_SIZE (field_type))\n \t  || (pos && !value_factor_p (pos, TYPE_ALIGN (field_type)))\n \t  || packed\n \t  || (TYPE_ALIGN (record_type) != 0\n@@ -1908,7 +1919,7 @@ create_subprog_decl (tree subprog_name, tree asm_name,\n }\n \f\n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram\n-   body. This routine needs to be invoked before processing the declarations\n+   body.  This routine needs to be invoked before processing the declarations\n    appearing in the subprogram.  */\n \n void\n@@ -2483,7 +2494,7 @@ build_template (tree template_type, tree array_type, tree expr)\n \t  && TYPE_HAS_ACTUAL_BOUNDS_P (array_type)))\n     bound_list = TYPE_ACTUAL_BOUNDS (array_type);\n \n-  /* First make the list for a CONSTRUCTOR for the template.   Go down the\n+  /* First make the list for a CONSTRUCTOR for the template.  Go down the\n      field list of the template instead of the type chain because this\n      array might be an Ada array of arrays and we can't tell where the\n      nested arrays stop being the underlying object.  */\n@@ -2510,8 +2521,8 @@ build_template (tree template_type, tree array_type, tree expr)\n       else\n \tgcc_unreachable ();\n \n-      min = convert (TREE_TYPE (TREE_CHAIN (field)), TYPE_MIN_VALUE (bounds));\n-      max = convert (TREE_TYPE (field), TYPE_MAX_VALUE (bounds));\n+      min = convert (TREE_TYPE (field), TYPE_MIN_VALUE (bounds));\n+      max = convert (TREE_TYPE (TREE_CHAIN (field)), TYPE_MAX_VALUE (bounds));\n \n       /* If either MIN or MAX involve a PLACEHOLDER_EXPR, we must\n \t substitute it from OBJECT.  */\n@@ -2536,6 +2547,7 @@ tree\n build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n {\n   tree record_type = make_node (RECORD_TYPE);\n+  tree pointer32_type;\n   tree field_list = 0;\n   int class;\n   int dtype = 0;\n@@ -2655,8 +2667,11 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n     case By_Descriptor_SB:\n       class = 15;\n       break;\n+    case By_Descriptor:\n+    case By_Descriptor_S:\n     default:\n       class = 1;\n+      break;\n     }\n \n   /* Make the type for a descriptor for VMS.  The first four fields\n@@ -2677,14 +2692,17 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \t\t\t\t\t       gnat_type_for_size (8, 1),\n \t\t\t\t\t       record_type, size_int (class)));\n \n+  /* Of course this will crash at run-time if the address space is not\n+     within the low 32 bits, but there is nothing else we can do.  */\n+  pointer32_type = build_pointer_type_for_mode (type, SImode, false);\n+\n   field_list\n     = chainon (field_list,\n \t       make_descriptor_field\n-\t       (\"POINTER\",\n-\t\tbuild_pointer_type_for_mode (type, SImode, false), record_type,\n-\t\tbuild1 (ADDR_EXPR,\n-\t\t\tbuild_pointer_type_for_mode (type, SImode, false),\n-\t\t\tbuild0 (PLACEHOLDER_EXPR, type))));\n+\t       (\"POINTER\", pointer32_type, record_type,\n+\t\tbuild_unary_op (ADDR_EXPR,\n+\t\t\t\tpointer32_type,\n+\t\t\t\tbuild0 (PLACEHOLDER_EXPR, type))));\n \n   switch (mech)\n     {\n@@ -2702,7 +2720,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       field_list\n \t= chainon (field_list,\n \t\t   make_descriptor_field\n-\t\t   (\"SB_L2\", gnat_type_for_size (32, 1), record_type,\n+\t\t   (\"SB_U1\", gnat_type_for_size (32, 1), record_type,\n \t\t    TREE_CODE (type) == ARRAY_TYPE\n \t\t    ? TYPE_MAX_VALUE (TYPE_DOMAIN (type)) : size_zero_node));\n       break;\n@@ -2764,7 +2782,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \t\t\t    tem)));\n \n       /* Next come the addressing coefficients.  */\n-      tem = size_int (1);\n+      tem = size_one_node;\n       for (i = 0; i < ndim; i++)\n \t{\n \t  char fname[3];\n@@ -2813,7 +2831,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       post_error (\"unsupported descriptor type for &\", gnat_entity);\n     }\n \n-  finish_record_type (record_type, field_list, false, true);\n+  finish_record_type (record_type, field_list, 0, true);\n   create_type_decl (create_concat_name (gnat_entity, \"DESC\"), record_type,\n \t\t    NULL, true, false, gnat_entity);\n \n@@ -2832,6 +2850,183 @@ make_descriptor_field (const char *name, tree type,\n   DECL_INITIAL (field) = initial;\n   return field;\n }\n+\n+/* Convert GNU_EXPR, a pointer to a VMS descriptor, to GNU_TYPE, a regular\n+   pointer or fat pointer type.  GNAT_SUBPROG is the subprogram to which\n+   the VMS descriptor is passed.  */\n+\n+static tree\n+convert_vms_descriptor (tree gnu_type, tree gnu_expr, Entity_Id gnat_subprog)\n+{\n+  tree desc_type = TREE_TYPE (TREE_TYPE (gnu_expr));\n+  tree desc = build1 (INDIRECT_REF, desc_type, gnu_expr);\n+  /* The CLASS field is the 3rd field in the descriptor.  */\n+  tree class = TREE_CHAIN (TREE_CHAIN (TYPE_FIELDS (desc_type)));\n+  /* The POINTER field is the 4th field in the descriptor.  */\n+  tree pointer = TREE_CHAIN (class);\n+\n+  /* Retrieve the value of the POINTER field.  */\n+  gnu_expr\n+    = build3 (COMPONENT_REF, TREE_TYPE (pointer), desc, pointer, NULL_TREE);\n+\n+  if (POINTER_TYPE_P (gnu_type))\n+    return convert (gnu_type, gnu_expr);\n+\n+  else if (TYPE_FAT_POINTER_P (gnu_type))\n+    {\n+      tree p_array_type = TREE_TYPE (TYPE_FIELDS (gnu_type));\n+      tree p_bounds_type = TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_type)));\n+      tree template_type = TREE_TYPE (p_bounds_type);\n+      tree min_field = TYPE_FIELDS (template_type);\n+      tree max_field = TREE_CHAIN (TYPE_FIELDS (template_type));\n+      tree template, template_addr, aflags, dimct, t, u;\n+      /* See the head comment of build_vms_descriptor.  */\n+      int iclass = TREE_INT_CST_LOW (DECL_INITIAL (class));\n+\n+      /* Convert POINTER to the type of the P_ARRAY field.  */\n+      gnu_expr = convert (p_array_type, gnu_expr);\n+\n+      switch (iclass)\n+\t{\n+\tcase 1:  /* Class S  */\n+\tcase 15: /* Class SB */\n+\t  /* Build {1, LENGTH} template; LENGTH is the 1st field.  */\n+\t  t = TYPE_FIELDS (desc_type);\n+\t  t = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n+\t  t = tree_cons (min_field,\n+\t\t\t convert (TREE_TYPE (min_field), integer_one_node),\n+\t\t\t tree_cons (max_field,\n+\t\t\t\t    convert (TREE_TYPE (max_field), t),\n+\t\t\t\t    NULL_TREE));\n+\t  template = gnat_build_constructor (template_type, t);\n+\t  template_addr = build_unary_op (ADDR_EXPR, NULL_TREE, template);\n+\n+\t  /* For class S, we are done.  */\n+\t  if (iclass == 1)\n+\t    break;\n+\n+\t  /* Test that we really have a SB descriptor, like DEC Ada.  */\n+\t  t = build3 (COMPONENT_REF, TREE_TYPE (class), desc, class, NULL);\n+\t  u = convert (TREE_TYPE (class), DECL_INITIAL (class));\n+\t  u = build_binary_op (EQ_EXPR, integer_type_node, t, u);\n+\t  /* If so, there is already a template in the descriptor and\n+\t     it is located right after the POINTER field.  */\n+\t  t = TREE_CHAIN (pointer);\n+\t  template = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n+\t  /* Otherwise use the {1, LENGTH} template we build above.  */\n+\t  template_addr = build3 (COND_EXPR, p_bounds_type, u,\n+\t\t\t\t  build_unary_op (ADDR_EXPR, p_bounds_type,\n+\t\t\t\t \t\t template),\n+\t\t\t\t  template_addr);\n+\t  break;\n+\n+\tcase 4:  /* Class A */\n+\t  /* The AFLAGS field is the 7th field in the descriptor.  */\n+\t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (pointer)));\n+\t  aflags = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n+\t  /* The DIMCT field is the 8th field in the descriptor.  */\n+\t  t = TREE_CHAIN (t);\n+\t  dimct = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n+\t  /* Raise CONSTRAINT_ERROR if either more than 1 dimension\n+\t     or FL_COEFF or FL_BOUNDS not set.  */\n+\t  u = build_int_cst (TREE_TYPE (aflags), 192);\n+\t  u = build_binary_op (TRUTH_OR_EXPR, integer_type_node,\n+\t\t\t       build_binary_op (NE_EXPR, integer_type_node,\n+\t\t\t\t\t\tdimct,\n+\t\t\t\t\t\tconvert (TREE_TYPE (dimct),\n+\t\t\t\t\t\t\t size_one_node)),\n+\t\t\t       build_binary_op (NE_EXPR, integer_type_node,\n+\t\t\t\t\t\tbuild2 (BIT_AND_EXPR,\n+\t\t\t\t\t\t\tTREE_TYPE (aflags),\n+\t\t\t\t\t\t\taflags, u),\n+\t\t\t\t\t\tu));\n+\t  add_stmt (build3 (COND_EXPR, void_type_node, u,\n+\t\t\t    build_call_raise (CE_Length_Check_Failed, Empty,\n+\t\t\t\t\t      N_Raise_Constraint_Error),\n+\t\t\t    NULL_TREE));\n+\t  /* There is already a template in the descriptor and it is\n+\t     located at the start of block 3 (12th field).  */\n+\t  t = TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (t))));\n+\t  template = build3 (COMPONENT_REF, TREE_TYPE (t), desc, t, NULL_TREE);\n+\t  template_addr = build_unary_op (ADDR_EXPR, p_bounds_type, template);\n+\t  break;\n+\n+\tcase 10: /* Class NCA */\n+\tdefault:\n+\t  post_error (\"unsupported descriptor type for &\", gnat_subprog);\n+\t  template_addr = integer_zero_node;\n+\t  break;\n+\t}\n+\n+      /* Build the fat pointer in the form of a constructor.  */\n+      t = tree_cons (TYPE_FIELDS (gnu_type), gnu_expr,\n+\t\t     tree_cons (TREE_CHAIN (TYPE_FIELDS (gnu_type)),\n+\t\t\t\ttemplate_addr, NULL_TREE));\n+      return gnat_build_constructor (gnu_type, t);\n+    }\n+\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Build a stub for the subprogram specified by the GCC tree GNU_SUBPROG\n+   and the GNAT node GNAT_SUBPROG.  */\n+\n+void\n+build_function_stub (tree gnu_subprog, Entity_Id gnat_subprog)\n+{\n+  tree gnu_subprog_type, gnu_subprog_addr, gnu_subprog_call;\n+  tree gnu_stub_param, gnu_param_list, gnu_arg_types, gnu_param;\n+  tree gnu_stub_decl = DECL_FUNCTION_STUB (gnu_subprog);\n+  tree gnu_body;\n+\n+  gnu_subprog_type = TREE_TYPE (gnu_subprog);\n+  gnu_param_list = NULL_TREE;\n+\n+  begin_subprog_body (gnu_stub_decl);\n+  gnat_pushlevel ();\n+\n+  start_stmt_group ();\n+\n+  /* Loop over the parameters of the stub and translate any of them\n+     passed by descriptor into a by reference one.  */\n+  for (gnu_stub_param = DECL_ARGUMENTS (gnu_stub_decl),\n+       gnu_arg_types = TYPE_ARG_TYPES (gnu_subprog_type);\n+       gnu_stub_param;\n+       gnu_stub_param = TREE_CHAIN (gnu_stub_param),\n+       gnu_arg_types = TREE_CHAIN (gnu_arg_types))\n+    {\n+      if (DECL_BY_DESCRIPTOR_P (gnu_stub_param))\n+\tgnu_param = convert_vms_descriptor (TREE_VALUE (gnu_arg_types),\n+\t\t\t\t\t    gnu_stub_param, gnat_subprog);\n+      else\n+\tgnu_param = gnu_stub_param;\n+\n+      gnu_param_list = tree_cons (NULL_TREE, gnu_param, gnu_param_list);\n+    }\n+\n+  gnu_body = end_stmt_group ();\n+\n+  /* Invoke the internal subprogram.  */\n+  gnu_subprog_addr = build1 (ADDR_EXPR, build_pointer_type (gnu_subprog_type),\n+\t\t\t     gnu_subprog);\n+  gnu_subprog_call = build3 (CALL_EXPR, TREE_TYPE (gnu_subprog_type),\n+\t\t\t     gnu_subprog_addr, nreverse (gnu_param_list),\n+\t\t\t     NULL_TREE);\n+\n+  /* Propagate the return value, if any.  */\n+  if (VOID_TYPE_P (TREE_TYPE (gnu_subprog_type)))\n+    append_to_statement_list (gnu_subprog_call, &gnu_body);\n+  else\n+    append_to_statement_list (build_return_expr (DECL_RESULT (gnu_stub_decl),\n+\t\t\t\t\t\t gnu_subprog_call),\n+\t\t\t      &gnu_body);\n+\n+  gnat_poplevel ();\n+\n+  allocate_struct_function (gnu_stub_decl);\n+  end_subprog_body (gnu_body);\n+}\n \f\n /* Build a type to be used to represent an aliased object whose nominal\n    type is an unconstrained array.  This consists of a RECORD_TYPE containing\n@@ -2854,7 +3049,7 @@ build_unc_object_type (tree template_type, tree object_type, tree name)\n   finish_record_type (type,\n \t\t      chainon (chainon (NULL_TREE, template_field),\n \t\t\t       array_field),\n-\t\t      false, false);\n+\t\t      0, false);\n \n   return type;\n }\n@@ -2875,6 +3070,27 @@ build_unc_object_type_from_ptr (tree thin_fat_ptr_type, tree object_type,\n        : TREE_TYPE (TYPE_FIELDS (TREE_TYPE (thin_fat_ptr_type))));\n   return build_unc_object_type (template_type, object_type, name);\n }\n+\n+/* Shift the component offsets within an unconstrained object TYPE to make it\n+   suitable for use as a designated type for thin pointers.  */\n+\n+void\n+shift_unc_components_for_thin_pointers (tree type)\n+{\n+  /* Thin pointer values designate the ARRAY data of an unconstrained object,\n+     allocated past the BOUNDS template.  The designated type is adjusted to\n+     have ARRAY at position zero and the template at a negative offset, so\n+     that COMPONENT_REFs on (*thin_ptr) designate the proper location.  */\n+\n+  tree bounds_field = TYPE_FIELDS (type);\n+  tree array_field  = TREE_CHAIN (TYPE_FIELDS (type));\n+\n+  DECL_FIELD_OFFSET (bounds_field)\n+    = size_binop (MINUS_EXPR, size_zero_node, byte_position (array_field));\n+\n+  DECL_FIELD_OFFSET (array_field) = size_zero_node;\n+  DECL_FIELD_BIT_OFFSET (array_field) = bitsize_zero_node;\n+}\n \f\n /* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.  In\n    the normal case this is just two adjustments, but we have more to do\n@@ -3002,23 +3218,26 @@ update_pointer_to (tree old_type, tree new_type)\n \n       update_pointer_to (TYPE_OBJECT_RECORD_TYPE (old_type), new_obj_rec);\n \n-      TREE_TYPE (TYPE_FIELDS (new_obj_rec)) = TREE_TYPE (ptr_temp_type);\n+      TREE_TYPE (TYPE_FIELDS (new_obj_rec))\n+\t= TREE_TYPE (TREE_TYPE (TREE_CHAIN (new_fields)));\n+\n       TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec)))\n \t= TREE_TYPE (TREE_TYPE (new_fields));\n-      DECL_SIZE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec)))\n-\t= TYPE_SIZE (TREE_TYPE (TREE_TYPE (new_fields)));\n-      DECL_SIZE_UNIT (TREE_CHAIN (TYPE_FIELDS (new_obj_rec)))\n-\t= TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (new_fields)));\n-\n-      TYPE_SIZE (new_obj_rec)\n-\t= size_binop (PLUS_EXPR,\n-\t\t      DECL_SIZE (TYPE_FIELDS (new_obj_rec)),\n-\t\t      DECL_SIZE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec))));\n-      TYPE_SIZE_UNIT (new_obj_rec)\n-\t= size_binop (PLUS_EXPR,\n-\t\t      DECL_SIZE_UNIT (TYPE_FIELDS (new_obj_rec)),\n-\t\t      DECL_SIZE_UNIT (TREE_CHAIN (TYPE_FIELDS (new_obj_rec))));\n-      rest_of_type_compilation (ptr, global_bindings_p ());\n+\n+      /* The size recomputation needs to account for alignment constraints, so\n+\t we let layout_type work it out.  This will reset the field offsets to\n+\t what they would be in a regular record, so we shift them back to what\n+\t we want them to be for a thin pointer designated type afterwards.  */\n+\n+      DECL_SIZE (TYPE_FIELDS (new_obj_rec)) = 0;\n+      DECL_SIZE (TREE_CHAIN (TYPE_FIELDS (new_obj_rec))) = 0;\n+      TYPE_SIZE (new_obj_rec) = 0;\n+      layout_type (new_obj_rec);\n+\n+      shift_unc_components_for_thin_pointers (new_obj_rec);\n+\n+      /* We are done, at last.  */\n+      rest_of_record_type_compilation (ptr);\n     }\n }\n \f\n@@ -3617,7 +3836,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t into a base type, we need to ensure that VRP doesn't propagate range\n \t information since this conversion may be done precisely to validate\n \t that the object is within the range it is supposed to have.  */\n-      else if (TREE_CODE (type) == INTEGER_TYPE && !TREE_TYPE (type)\n+      else if (TREE_CODE (expr) != INTEGER_CST\n+\t       && TREE_CODE (type) == INTEGER_TYPE && !TREE_TYPE (type)\n \t       && ((TREE_CODE (etype) == INTEGER_TYPE && TREE_TYPE (etype))\n \t\t   || TREE_CODE (etype) == ENUMERAL_TYPE\n \t\t   || TREE_CODE (etype) == BOOLEAN_TYPE))"}]}