{"sha": "39dffea3c7e295b6e847f6709605de5ff2aff038", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkZmZlYTNjN2UyOTViNmU4NDdmNjcwOTYwNWRlNWZmMmFmZjAzOA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-12-19T23:30:21Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-12-19T23:30:21Z"}, "message": "(FIRST_PSEUDO_REGISTER): Increment.\n\n(FIXED_REGISTERS, CALL_USED_REGISTERS, REGISTER_NAMES,\nDEBUG_REGISTER_NAMES): Add entry for new RAP reg.\n(RAP_REG_NUM, RETURN_ADDRESS_POINTER_REGNUM): New macros.\n(RETURN_ADDR_RTX): Define.\n(ELIMINABLE_REGS, CAN_ELIMINATE, INITIAL_ELIMINATION_OFFSET):\nAdd RETURN_ADDRESS_POINTER_REGNUM support.\n\nFrom-SVN: r10819", "tree": {"sha": "769ec9ff546ec6c0bf9b25c61cd91394b099e593", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/769ec9ff546ec6c0bf9b25c61cd91394b099e593"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39dffea3c7e295b6e847f6709605de5ff2aff038", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39dffea3c7e295b6e847f6709605de5ff2aff038", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39dffea3c7e295b6e847f6709605de5ff2aff038", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39dffea3c7e295b6e847f6709605de5ff2aff038/comments", "author": null, "committer": null, "parents": [{"sha": "b987661c069eddeab42d9df123f515bdc53bb5a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b987661c069eddeab42d9df123f515bdc53bb5a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b987661c069eddeab42d9df123f515bdc53bb5a0"}], "stats": {"total": 51, "additions": 43, "deletions": 8}, "files": [{"sha": "bfb516fe55e511e104f38dfcd7cc72eb42688f4a", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39dffea3c7e295b6e847f6709605de5ff2aff038/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39dffea3c7e295b6e847f6709605de5ff2aff038/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=39dffea3c7e295b6e847f6709605de5ff2aff038", "patch": "@@ -1173,12 +1173,14 @@ do {                                                  \\\n    even those that are not normally considered general registers.\n \n    On the Mips, we have 32 integer registers, 32 floating point\n-   registers and the special registers hi, lo, hilo, and fp status.\n+   registers and the special registers hi, lo, hilo, fp status, and rap.\n    The hilo register is only used in 64 bit mode.  It represents a 64\n    bit value stored as two 32 bit values in the hi and lo registers;\n-   this is the result of the mult instruction.  */\n+   this is the result of the mult instruction.  rap is a pointer to the\n+   stack where the return address reg ($31) was stored.  This is needed\n+   for C++ exception handling.  */\n \n-#define FIRST_PSEUDO_REGISTER 68\n+#define FIRST_PSEUDO_REGISTER 69\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -1191,7 +1193,7 @@ do {                                                  \\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  0, 0, 0, 1\t\t\t\t\t\t\t\t\\\n+  0, 0, 0, 1, 1\t\t\t\t\t\t\t\t\\\n }\n \n \n@@ -1208,7 +1210,7 @@ do {                                                  \\\n   0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1,\t\t\t\\\n   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n   1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n-  1, 1, 1, 1\t\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1\t\t\t\t\t\t\t\t\\\n }\n \n \n@@ -1234,6 +1236,8 @@ do {                                                  \\\n #define ST_REG_LAST  67\n #define ST_REG_NUM   (ST_REG_LAST - ST_REG_FIRST + 1)\n \n+#define RAP_REG_NUM   68\n+\n #define AT_REGNUM\t(GP_REG_FIRST + 1)\n #define HI_REGNUM\t(MD_REG_FIRST + 0)\n #define LO_REGNUM\t(MD_REG_FIRST + 1)\n@@ -1306,6 +1310,10 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM GP_REG_FIRST\n \n+/* Fake register that holds the address on the stack of the\n+   current function's return address.  */\n+#define RETURN_ADDRESS_POINTER_REGNUM RAP_REG_NUM\n+\n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 2)\n \n@@ -1675,6 +1683,25 @@ extern enum reg_class\tmips_secondary_reload_class ();\n \t: current_function_outgoing_args_size)\n #endif\n \n+/* The return address for the current frame is in r31 is this is a leaf\n+   function.  Otherwise, it is on the stack.  It is at a variable offset\n+   from sp/fp/ap, so we define a fake hard register rap which is a\n+   poiner to the return address on the stack.  This always gets eliminated\n+   during reload to be either the frame pointer or the stack pointer plus\n+   an offset.  */\n+\n+/* ??? This definition fails for leaf functions.  There is currently no\n+   general solution for this problem.  */\n+\n+/* ??? There appears to be no way to get the return address of any previous\n+   frame except by disassembling instructions in the prologue/epilogue.\n+   So currently we support only the current frame.  */\n+\n+#define RETURN_ADDR_RTX(count, frame)\t\t\t\\\n+  ((count == 0)\t\t\t\t\t\t\\\n+   ? gen_rtx (MEM, Pmode, gen_rtx (REG, Pmode, RETURN_ADDRESS_POINTER_REGNUM))\\\n+   : (fatal (\"RETURN_ADDR_RTX not supported for count != 0\"), (rtx) 0))\n+\n /* Structure to be filled in by compute_frame_size with register\n    save masks, and offsets for the current function.  */\n \n@@ -1736,9 +1763,10 @@ extern struct mips_frame_info current_frame_info;\n #define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n {{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\t\t\\\n  { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},\t\t\t\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n+ { RETURN_ADDRESS_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\t\\\n  { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n \n-\n /* A C expression that returns non-zero if the compiler is allowed to\n    try to replace register number FROM-REG with register number\n    TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is\n@@ -1748,7 +1776,9 @@ extern struct mips_frame_info current_frame_info;\n \n #define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n   (!frame_pointer_needed\t\t\t\t\t\t\\\n-   || ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM))\n+   || ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\t\\\n+   || ((FROM) == RETURN_ADDRESS_POINTER_REGNUM\t\t\t\t\\\n+       && (TO) == FRAME_POINTER_REGNUM))\n \n /* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It\n    specifies the initial difference between the specified pair of\n@@ -1766,6 +1796,10 @@ extern struct mips_frame_info current_frame_info;\n \t\t- (ABI_64BIT && mips_isa >= 3\t\t\t\t \\\n \t\t   ? current_function_pretend_args_size\t\t\t \\\n \t\t   : 0));\t\t\t\t\t\t \\\n+  else if ((FROM) == RETURN_ADDRESS_POINTER_REGNUM\t\t\t \\\n+\t   && ((TO) == FRAME_POINTER_REGNUM\t\t\t\t \\\n+\t       || (TO) == STACK_POINTER_REGNUM))\t\t\t \\\n+    (OFFSET) = current_frame_info.gp_sp_offset;\t\t\t\t \\\n   else\t\t\t\t\t\t\t\t\t \\\n     abort ();\t\t\t\t\t\t\t\t \\\n }\n@@ -3135,6 +3169,7 @@ while (0)\n   &mips_reg_names[65][0],\t\t\t\t\t\t\\\n   &mips_reg_names[66][0],\t\t\t\t\t\t\\\n   &mips_reg_names[67][0],\t\t\t\t\t\t\\\n+  &mips_reg_names[68][0],\t\t\t\t\t\t\\\n }\n \n /* print-rtl.c can't use REGISTER_NAMES, since it depends on mips.c.\n@@ -3149,7 +3184,7 @@ while (0)\n   \"$f8\",  \"$f9\",  \"$f10\", \"$f11\", \"$f12\", \"$f13\", \"$f14\", \"$f15\",\t\\\n   \"$f16\", \"$f17\", \"$f18\", \"$f19\", \"$f20\", \"$f21\", \"$f22\", \"$f23\",\t\\\n   \"$f24\", \"$f25\", \"$f26\", \"$f27\", \"$f28\", \"$f29\", \"$f30\", \"$f31\",\t\\\n-  \"hi\",   \"lo\",   \"accum\",\"$fcr31\"\t\t\t\t\t\\\n+  \"hi\",   \"lo\",   \"accum\",\"$fcr31\",\"$rap\"\t\t\t\t\\\n }\n \n /* If defined, a C initializer for an array of structures"}]}