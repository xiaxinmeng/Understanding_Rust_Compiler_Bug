{"sha": "67289ea63916a799f9967e52f936b5b9c3cbc5ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyODllYTYzOTE2YTc5OWY5OTY3ZTUyZjkzNmI1YjljM2NiYzVlZA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-01T23:19:44Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-01T23:19:44Z"}, "message": "bitmap.h (BITMAP_XMALLOC): New macro.\n\n\t* bitmap.h (BITMAP_XMALLOC): New macro.\n\t* flow.c (CLEAN_ALLOCA): Remove.\n\t(delete_unreachable_blocks): Use xmalloc/xcalloc instead of alloca.\n\t(life_analysis): Likewise.\n\t(update_life_info): Don't use CLEAN_ALLOCA.\n\t(life_analysis_1): Use xmalloc/xcalloc instead of alloca.\n\t(calculate_global_regs_live): Likewise.\n\t(print_rtl_with_bb): Likewise.\n\t(verify_flow_info): Likewise.\n\t* global.c (global_alloc): Likewise.\n\t(global_conflicts): Likewise.\n\t* integrate.c (save_for_inline_nocopy): Likewise.\n\t(expand_inline_function): Likewise.\n\t* jump.c (jump_optimize_1): Likewise.\n\t(duplicate_loop_exit_test): Likewise.\n\t(thread_jumps): Likewise.\n\t* loop.c (loop_optimize): Likewise.\n\t(combine_givs): Likewise.\n\t(recombine_givs): Likewise.\n\t* reorg.c (dbr_schedule): Likewise.\n\t* unroll.c (unroll_loop): Likewise.\n\nFrom-SVN: r30333", "tree": {"sha": "e2aa2abd5578d723ad70e9ad0a620e80a13fc241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2aa2abd5578d723ad70e9ad0a620e80a13fc241"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67289ea63916a799f9967e52f936b5b9c3cbc5ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67289ea63916a799f9967e52f936b5b9c3cbc5ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67289ea63916a799f9967e52f936b5b9c3cbc5ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67289ea63916a799f9967e52f936b5b9c3cbc5ed/comments", "author": null, "committer": null, "parents": [{"sha": "20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca"}], "stats": {"total": 321, "additions": 194, "deletions": 127}, "files": [{"sha": "33c48e6ef129a5ecb96a684594e41597372392a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67289ea63916a799f9967e52f936b5b9c3cbc5ed", "patch": "@@ -1,5 +1,26 @@\n Mon Nov  1 15:41:01 1999  Mark P. Mitchell  <mark@codesourcery.com>\n \n+\t* bitmap.h (BITMAP_XMALLOC): New macro.\n+\t* flow.c (CLEAN_ALLOCA): Remove.\n+\t(delete_unreachable_blocks): Use xmalloc/xcalloc instead of alloca.\n+\t(life_analysis): Likewise.\n+\t(update_life_info): Don't use CLEAN_ALLOCA.\n+\t(life_analysis_1): Use xmalloc/xcalloc instead of alloca.\n+\t(calculate_global_regs_live): Likewise.\n+\t(print_rtl_with_bb): Likewise.\n+\t(verify_flow_info): Likewise.\n+\t* global.c (global_alloc): Likewise.\n+\t(global_conflicts): Likewise.\n+\t* integrate.c (save_for_inline_nocopy): Likewise.\n+\t(expand_inline_function): Likewise.\n+\t* jump.c (jump_optimize_1): Likewise.\n+\t(duplicate_loop_exit_test): Likewise.\n+\t(thread_jumps): Likewise.\n+\t* loop.c (loop_optimize): Likewise.\n+\t(combine_givs): Likewise.\n+\t(recombine_givs): Likewise.\n+\t* reorg.c (dbr_schedule): Likewise.\n+\n \t* combine.c (combine_instructions): Use xmalloc instead of alloca.\n \n Mon Nov  1 13:22:30 1999  Richard Henderson  <rth@cygnus.com>"}, {"sha": "9b8875a01853e9c4864bac6159dd526ae15622a1", "filename": "gcc/bitmap.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=67289ea63916a799f9967e52f936b5b9c3cbc5ed", "patch": "@@ -114,6 +114,10 @@ extern void debug_bitmap PROTO((bitmap));\n #define BITMAP_ALLOCA()\t\t\t\t\t\t\\\n   bitmap_initialize ((bitmap) alloca (sizeof (bitmap_head)))\n \n+/* Allocate a bitmap with xmalloc.  */\n+#define BITMAP_XMALLOC()                                        \\\n+  bitmap_initialize ((bitmap) xmalloc (sizeof (bitmap_head)))\n+\n /* Do any cleanup needed on a bitmap when it is no longer used.  */\n #define BITMAP_FREE(BITMAP)\t\t\t\t\t\\\n do {\t\t\t\t\\"}, {"sha": "d2d50914b10d62d1e0bcdd9e9090ed3b4e596740", "filename": "gcc/flow.c", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=67289ea63916a799f9967e52f936b5b9c3cbc5ed", "patch": "@@ -157,13 +157,6 @@ Boston, MA 02111-1307, USA.  */\n #define HAVE_prologue 0\n #endif\n \n-#ifdef USE_C_ALLOCA\n-#define CLEAN_ALLOCA  alloca (0)\n-#else\n-#define CLEAN_ALLOCA\n-#endif\n-\n-\n /* The contents of the current function definition are allocated\n    in this obstack, and all are freed at the end of the function.\n    For top-level functions, this is temporary_obstack.\n@@ -1668,7 +1661,7 @@ delete_unreachable_blocks ()\n   int i, n;\n \n   n = n_basic_blocks;\n-  tos = worklist = (basic_block *) alloca (sizeof (basic_block) * n);\n+  tos = worklist = (basic_block *) xmalloc (sizeof (basic_block) * n);\n \n   /* Use basic_block->aux as a marker.  Clear them all.  */\n \n@@ -1752,6 +1745,8 @@ delete_unreachable_blocks ()\n      blocks to remove as well. */\n   if (deleted_handler)\n     delete_eh_regions ();\n+\n+  free (worklist);\n }\n \n /* Find EH regions for which there is no longer a handler, and delete them.  */\n@@ -2453,7 +2448,7 @@ life_analysis (f, nregs, file, remove_dead_code)\n #endif\n \n   /* Allocate a bitmap to be filled in by record_volatile_insns.  */\n-  uid_volatile = BITMAP_ALLOCA ();\n+  uid_volatile = BITMAP_XMALLOC ();\n \n   /* We want alias analysis information for local dead store elimination.  */\n   init_alias_analysis ();\n@@ -2472,6 +2467,7 @@ life_analysis (f, nregs, file, remove_dead_code)\n     dump_flow_info (file);\n \n   BITMAP_FREE (uid_volatile);\n+  free (uid_volatile);\n   free_basic_block_vars (1);\n }\n \n@@ -2601,8 +2597,6 @@ update_life_info (blocks, extent, prop_flags)\n \n       if (extent == UPDATE_LIFE_LOCAL)\n \tverify_local_live_at_start (tmp, bb);\n-\n-      CLEAN_ALLOCA;\n     });\n \n   FREE_REG_SET (tmp);\n@@ -2916,8 +2910,7 @@ life_analysis_1 (f, nregs, flags)\n   allocate_reg_life_data ();\n   allocate_bb_life_data ();\n \n-  reg_next_use = (rtx *) alloca (nregs * sizeof (rtx));\n-  memset (reg_next_use, 0, nregs * sizeof (rtx));\n+  reg_next_use = (rtx *) xcalloc (nregs, sizeof (rtx));\n \n   /* Assume that the stack pointer is unchanging if alloca hasn't been used.\n      This will be cleared by record_volatile_insns if it encounters an insn\n@@ -2971,8 +2964,6 @@ life_analysis_1 (f, nregs, flags)\n \n \tCOPY_REG_SET (tmp, bb->global_live_at_end);\n \tpropagate_block (tmp, bb->head, bb->end, (regset) NULL, i, flags);\n-\n-\tCLEAN_ALLOCA;\n       }\n \n     FREE_REG_SET (tmp);\n@@ -3000,6 +2991,8 @@ life_analysis_1 (f, nregs, flags)\n   if (reload_completed)\n     memcpy (regs_ever_live, save_regs_ever_live, sizeof (regs_ever_live));\n \n+  /* Clean up.  */\n+  free (reg_next_use);\n   reg_next_use = NULL;\n }\n \n@@ -3022,7 +3015,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n   /* Create a worklist.  Allocate an extra slot for ENTRY_BLOCK, and one\n      because the `head == tail' style test for an empty queue doesn't \n      work with a full queue.  */\n-  queue = (basic_block *) alloca ((n_basic_blocks + 2) * sizeof (*queue));\n+  queue = (basic_block *) xmalloc ((n_basic_blocks + 2) * sizeof (*queue));\n   qtail = queue;\n   qhead = qend = queue + n_basic_blocks + 2;\n \n@@ -3158,6 +3151,8 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n       basic_block bb = BASIC_BLOCK (i);\n       FREE_REG_SET (bb->local_set);\n     });\n+\n+  free (queue);\n }\n \f\n /* Subroutines of life analysis.  */\n@@ -5069,15 +5064,11 @@ print_rtl_with_bb (outf, rtx_first)\n       enum bb_state { NOT_IN_BB, IN_ONE_BB, IN_MULTIPLE_BB };\n       int max_uid = get_max_uid ();\n       basic_block *start = (basic_block *)\n-\talloca (max_uid * sizeof (basic_block));\n+\txcalloc (max_uid, sizeof (basic_block));\n       basic_block *end = (basic_block *)\n-\talloca (max_uid * sizeof (basic_block));\n+\txcalloc (max_uid, sizeof (basic_block));\n       enum bb_state *in_bb_p = (enum bb_state *)\n-\talloca (max_uid * sizeof (enum bb_state));\n-\n-      memset (start, 0, max_uid * sizeof (basic_block));\n-      memset (end, 0, max_uid * sizeof (basic_block));\n-      memset (in_bb_p, 0, max_uid * sizeof (enum bb_state));\n+\txcalloc (max_uid, sizeof (enum bb_state));\n \n       for (i = n_basic_blocks - 1; i >= 0; i--)\n \t{\n@@ -5134,6 +5125,10 @@ print_rtl_with_bb (outf, rtx_first)\n \t  if (did_output)\n \t    putc ('\\n', outf);\n \t}\n+\n+      free (start);\n+      free (end);\n+      free (in_bb_p);\n     }\n \n   if (current_function_epilogue_delay_list != 0)\n@@ -5878,8 +5873,7 @@ verify_flow_info ()\n   rtx x;\n   int i, err = 0;\n \n-  bb_info = (basic_block *) alloca (max_uid * sizeof (basic_block));\n-  memset (bb_info, 0, max_uid * sizeof (basic_block));\n+  bb_info = (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n \n   /* First pass check head/end pointers and set bb_info array used by\n      later passes.  */\n@@ -6074,6 +6068,9 @@ verify_flow_info ()\n \n   if (err)\n     abort ();\n+\n+  /* Clean up.  */\n+  free (bb_info);\n }\n \f\n /* Functions to access an edge list with a vector representation."}, {"sha": "2e460265a95b4958465e17b0a996121496c45aa2", "filename": "gcc/global.c", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=67289ea63916a799f9967e52f936b5b9c3cbc5ed", "patch": "@@ -372,15 +372,14 @@ global_alloc (file)\n   /* Establish mappings from register number to allocation number\n      and vice versa.  In the process, count the allocnos.  */\n \n-  reg_allocno = (int *) alloca (max_regno * sizeof (int));\n+  reg_allocno = (int *) xmalloc (max_regno * sizeof (int));\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     reg_allocno[i] = -1;\n \n   /* Initialize the shared-hard-reg mapping\n      from the list of pairs that may share.  */\n-  reg_may_share = (int *) alloca (max_regno * sizeof (int));\n-  bzero ((char *) reg_may_share, max_regno * sizeof (int));\n+  reg_may_share = (int *) xcalloc (max_regno, sizeof (int));\n   for (x = regs_may_share; x; x = XEXP (XEXP (x, 1), 1))\n     {\n       int r1 = REGNO (XEXP (x, 0));\n@@ -411,15 +410,11 @@ global_alloc (file)\n     else\n       reg_allocno[i] = -1;\n \n-  allocno_reg = (int *) alloca (max_allocno * sizeof (int));\n-  allocno_size = (int *) alloca (max_allocno * sizeof (int));\n-  allocno_calls_crossed = (int *) alloca (max_allocno * sizeof (int));\n-  allocno_n_refs = (int *) alloca (max_allocno * sizeof (int));\n-  allocno_live_length = (int *) alloca (max_allocno * sizeof (int));\n-  bzero ((char *) allocno_size, max_allocno * sizeof (int));\n-  bzero ((char *) allocno_calls_crossed, max_allocno * sizeof (int));\n-  bzero ((char *) allocno_n_refs, max_allocno * sizeof (int));\n-  bzero ((char *) allocno_live_length, max_allocno * sizeof (int));\n+  allocno_reg = (int *) xmalloc (max_allocno * sizeof (int));\n+  allocno_size = (int *) xcalloc (max_allocno, sizeof (int));\n+  allocno_calls_crossed = (int *) xcalloc (max_allocno, sizeof (int));\n+  allocno_n_refs = (int *) xcalloc (max_allocno, sizeof (int));\n+  allocno_live_length = (int *) xcalloc (max_allocno, sizeof (int));\n \n   for (i = FIRST_PSEUDO_REGISTER; i < (size_t) max_regno; i++)\n     if (reg_allocno[i] >= 0)\n@@ -461,26 +456,15 @@ global_alloc (file)\n      initialize them.  */\n \n   hard_reg_conflicts\n-    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero ((char *) hard_reg_conflicts, max_allocno * sizeof (HARD_REG_SET));\n-\n+    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n   hard_reg_preferences\n-    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero ((char *) hard_reg_preferences, max_allocno * sizeof (HARD_REG_SET));\n-  \n+    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n   hard_reg_copy_preferences\n-    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero ((char *) hard_reg_copy_preferences,\n-\t max_allocno * sizeof (HARD_REG_SET));\n-  \n+    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n   hard_reg_full_preferences\n-    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero ((char *) hard_reg_full_preferences,\n-\t max_allocno * sizeof (HARD_REG_SET));\n-  \n+    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n   regs_someone_prefers\n-    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n-  bzero ((char *) regs_someone_prefers, max_allocno * sizeof (HARD_REG_SET));\n+    = (HARD_REG_SET *) xcalloc (max_allocno, sizeof (HARD_REG_SET));\n \n   allocno_row_words = (max_allocno + INT_BITS - 1) / INT_BITS;\n \n@@ -490,7 +474,7 @@ global_alloc (file)\n   conflicts = (INT_TYPE *) xcalloc (max_allocno * allocno_row_words,\n \t\t\t\t    sizeof (INT_TYPE));\n \n-  allocnos_live = (INT_TYPE *) alloca (allocno_row_words * sizeof (INT_TYPE));\n+  allocnos_live = (INT_TYPE *) xmalloc (allocno_row_words * sizeof (INT_TYPE));\n \n   /* If there is work to be done (at least one reg to allocate),\n      perform global conflict analysis and allocate the regs.  */\n@@ -523,7 +507,7 @@ global_alloc (file)\n \n       /* Determine the order to allocate the remaining pseudo registers.  */\n \n-      allocno_order = (int *) alloca (max_allocno * sizeof (int));\n+      allocno_order = (int *) xmalloc (max_allocno * sizeof (int));\n       for (i = 0; i < (size_t) max_allocno; i++)\n \tallocno_order[i] = i;\n \n@@ -568,6 +552,8 @@ global_alloc (file)\n \t    if (reg_alternate_class (allocno_reg[allocno_order[i]]) != NO_REGS)\n \t      find_reg (allocno_order[i], 0, 1, 0, 0);\n \t  }\n+\n+      free (allocno_order);\n     }\n \n   /* Do the reloads now while the allocno data still exist, so that we can\n@@ -582,7 +568,22 @@ global_alloc (file)\n       retval = reload (get_insns (), 1, file);\n     }\n \n+  /* Clean up.  */\n+  free (reg_allocno);\n+  free (reg_may_share);\n+  free (allocno_reg);\n+  free (allocno_size);\n+  free (allocno_calls_crossed);\n+  free (allocno_n_refs);\n+  free (allocno_live_length);\n+  free (hard_reg_conflicts);\n+  free (hard_reg_preferences);\n+  free (hard_reg_copy_preferences);\n+  free (hard_reg_full_preferences);\n+  free (regs_someone_prefers);\n   free (conflicts);\n+  free (allocnos_live);\n+\n   return retval;\n }\n \n@@ -626,9 +627,9 @@ global_conflicts ()\n   int *block_start_allocnos;\n \n   /* Make a vector that mark_reg_{store,clobber} will store in.  */\n-  regs_set = (rtx *) alloca (max_parallel * sizeof (rtx) * 2);\n+  regs_set = (rtx *) xmalloc (max_parallel * sizeof (rtx) * 2);\n \n-  block_start_allocnos = (int *) alloca (max_allocno * sizeof (int));\n+  block_start_allocnos = (int *) xmalloc (max_allocno * sizeof (int));\n \n   for (b = 0; b < n_basic_blocks; b++)\n     {\n@@ -788,6 +789,10 @@ global_conflicts ()\n \t  insn = NEXT_INSN (insn);\n \t}\n     }\n+\n+  /* Clean up.  */\n+  free (block_start_allocnos);\n+  free (regs_set);\n }\n /* Expand the preference information by looking for cases where one allocno\n    dies in an insn that sets an allocno.  If those two allocnos don't conflict,"}, {"sha": "b7a1af6a285d29a31ca453c49dd29ca94eb675e8", "filename": "gcc/integrate.c", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=67289ea63916a799f9967e52f936b5b9c3cbc5ed", "patch": "@@ -350,7 +350,7 @@ save_for_inline_nocopy (fndecl)\n      for the parms, prior to elimination of virtual registers.\n      These values are needed for substituting parms properly.  */\n \n-  parmdecl_map = (tree *) alloca (max_parm_reg * sizeof (tree));\n+  parmdecl_map = (tree *) xmalloc (max_parm_reg * sizeof (tree));\n \n   /* Make and emit a return-label if we have not already done so.  */\n \n@@ -401,6 +401,9 @@ save_for_inline_nocopy (fndecl)\n   current_function->original_arg_vector = argvec;\n   current_function->original_decl_initial = DECL_INITIAL (fndecl);\n   DECL_SAVED_INSNS (fndecl) = current_function;\n+\n+  /* Clean up.  */\n+  free (parmdecl_map);\n }\n \f\n /* Note whether a parameter is modified or not.  */\n@@ -566,8 +569,8 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   /* Expand the function arguments.  Do this first so that any\n      new registers get created before we allocate the maps.  */\n \n-  arg_vals = (rtx *) alloca (nargs * sizeof (rtx));\n-  arg_trees = (tree *) alloca (nargs * sizeof (tree));\n+  arg_vals = (rtx *) xmalloc (nargs * sizeof (rtx));\n+  arg_trees = (tree *) xmalloc (nargs * sizeof (tree));\n \n   for (formal = DECL_ARGUMENTS (fndecl), actual = parms, i = 0;\n        formal;\n@@ -649,11 +652,10 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t\n   /* Allocate the structures we use to remap things.  */\n \n-  map = (struct inline_remap *) alloca (sizeof (struct inline_remap));\n+  map = (struct inline_remap *) xmalloc (sizeof (struct inline_remap));\n   map->fndecl = fndecl;\n \n-  map->reg_map = (rtx *) alloca (max_regno * sizeof (rtx));\n-  bzero ((char *) map->reg_map, max_regno * sizeof (rtx));\n+  map->reg_map = (rtx *) xcalloc (max_regno, sizeof (rtx));\n \n   /* We used to use alloca here, but the size of what it would try to\n      allocate would occasionally cause it to exceed the stack limit and\n@@ -663,8 +665,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   map->label_map = real_label_map;\n \n   inl_max_uid = (inl_f->emit->x_cur_insn_uid + 1);\n-  map->insn_map = (rtx *) alloca (inl_max_uid * sizeof (rtx));\n-  bzero ((char *) map->insn_map, inl_max_uid * sizeof (rtx));\n+  map->insn_map = (rtx *) xcalloc (inl_max_uid, sizeof (rtx));\n   map->min_insnno = 0;\n   map->max_insnno = inl_max_uid;\n \n@@ -1356,8 +1357,13 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   /* Make sure we free the things we explicitly allocated with xmalloc.  */\n   if (real_label_map)\n     free (real_label_map);\n-  if (map)\n-    VARRAY_FREE (map->const_equiv_varray);\n+  VARRAY_FREE (map->const_equiv_varray);\n+  free (map->reg_map);\n+  free (map->insn_map);\n+  free (map);\n+  free (arg_vals);\n+  free (arg_trees);\n+\n   inlining = inlining_previous;\n \n   return target;"}, {"sha": "1867de17969f62bd97f5f47729d36f17c17da1c4", "filename": "gcc/jump.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=67289ea63916a799f9967e52f936b5b9c3cbc5ed", "patch": "@@ -205,8 +205,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n   /* Leave some extra room for labels and duplicate exit test insns\n      we make.  */\n   max_jump_chain = max_uid * 14 / 10;\n-  jump_chain = (rtx *) alloca (max_jump_chain * sizeof (rtx));\n-  bzero ((char *) jump_chain, max_jump_chain * sizeof (rtx));\n+  jump_chain = (rtx *) xcalloc (max_jump_chain, sizeof (rtx));\n \n   mark_all_labels (f, cross_jump);\n \n@@ -227,7 +226,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n   /* Quit now if we just wanted to rebuild the JUMP_LABEL and REG_LABEL\n      notes and recompute LABEL_NUSES.  */\n   if (mark_labels_only)\n-    return;\n+    goto end;\n \n   exception_optimize ();\n \n@@ -245,10 +244,8 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n       /* Zero the \"deleted\" flag of all the \"deleted\" insns.  */\n       for (insn = f; insn; insn = NEXT_INSN (insn))\n \tINSN_DELETED_P (insn) = 0;\n-\n-      /* Show that the jump chain is not valid.  */\n-      jump_chain = 0;\n-      return;\n+      \n+      goto end;\n     }\n \n #ifdef HAVE_return\n@@ -2301,7 +2298,9 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n   if (calculate_can_reach_end (last_insn, 0, 1))\n     can_reach_end = 1;\n \n-  /* Show JUMP_CHAIN no longer valid.  */\n+end:\n+  /* Clean up.  */\n+  free (jump_chain);\n   jump_chain = 0;\n }\n \f\n@@ -2872,10 +2871,7 @@ duplicate_loop_exit_test (loop_start)\n \t    /* We can do the replacement.  Allocate reg_map if this is the\n \t       first replacement we found.  */\n \t    if (reg_map == 0)\n-\t      {\n-\t\treg_map = (rtx *) alloca (max_reg * sizeof (rtx));\n-\t\tbzero ((char *) reg_map, max_reg * sizeof (rtx));\n-\t      }\n+\t      reg_map = (rtx *) xcalloc (max_reg, sizeof (rtx));\n \n \t    REG_LOOP_TEST_P (reg) = 1;\n \n@@ -2986,6 +2982,10 @@ duplicate_loop_exit_test (loop_start)\n   emit_note_before (NOTE_INSN_LOOP_VTOP, exitcode);\n \n   delete_insn (next_nonnote_insn (loop_start));\n+  \n+  /* Clean up.  */\n+  if (reg_map)\n+    free (reg_map);\n \n   return 1;\n }\n@@ -5182,9 +5182,9 @@ thread_jumps (f, max_reg, flag_before_loop)\n   int *all_reset;\n \n   /* Allocate register tables and quick-reset table.  */\n-  modified_regs = (char *) alloca (max_reg * sizeof (char));\n-  same_regs = (int *) alloca (max_reg * sizeof (int));\n-  all_reset = (int *) alloca (max_reg * sizeof (int));\n+  modified_regs = (char *) xmalloc (max_reg * sizeof (char));\n+  same_regs = (int *) xmalloc (max_reg * sizeof (int));\n+  all_reset = (int *) xmalloc (max_reg * sizeof (int));\n   for (i = 0; i < max_reg; i++)\n     all_reset[i] = -1;\n     \n@@ -5342,6 +5342,11 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t    }\n \t}\n     }\n+\n+  /* Clean up.  */\n+  free (modified_regs);\n+  free (same_regs);\n+  free (all_reset);\n }\n \f\n /* This is like RTX_EQUAL_P except that it knows about our handling of"}, {"sha": "8290342c80d378412b50c63fa2ab8393ad1cb0e1", "filename": "gcc/loop.c", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=67289ea63916a799f9967e52f936b5b9c3cbc5ed", "patch": "@@ -464,9 +464,6 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n \n   max_reg_before_loop = max_reg_num ();\n \n-  moved_once = (char *) alloca (max_reg_before_loop);\n-  bzero (moved_once, max_reg_before_loop);\n-\n   regs_may_share = 0;\n \n   /* Count the number of loops.  */\n@@ -483,31 +480,29 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n   if (max_loop_num == 0)\n     return;\n \n+  moved_once = (char *) xcalloc (max_reg_before_loop, sizeof (char));\n+\n   /* Get size to use for tables indexed by uids.\n      Leave some space for labels allocated by find_and_verify_loops.  */\n   max_uid_for_loop = get_max_uid () + 1 + max_loop_num * 32;\n \n-  uid_luid = (int *) alloca (max_uid_for_loop * sizeof (int));\n-  uid_loop_num = (int *) alloca (max_uid_for_loop * sizeof (int));\n-\n-  bzero ((char *) uid_luid, max_uid_for_loop * sizeof (int));\n-  bzero ((char *) uid_loop_num, max_uid_for_loop * sizeof (int));\n+  uid_luid = (int *) xcalloc (max_uid_for_loop, sizeof (int));\n+  uid_loop_num = (int *) xcalloc (max_uid_for_loop, sizeof (int));\n \n   /* Allocate tables for recording each loop.  We set each entry, so they need\n      not be zeroed.  */\n-  loop_number_loop_starts = (rtx *) alloca (max_loop_num * sizeof (rtx));\n-  loop_number_loop_ends = (rtx *) alloca (max_loop_num * sizeof (rtx));\n-  loop_number_loop_cont = (rtx *) alloca (max_loop_num * sizeof (rtx));\n-  loop_number_cont_dominator = (rtx *) alloca (max_loop_num * sizeof (rtx));\n-  loop_outer_loop = (int *) alloca (max_loop_num * sizeof (int));\n-  loop_invalid = (char *) alloca (max_loop_num * sizeof (char));\n-  loop_number_exit_labels = (rtx *) alloca (max_loop_num * sizeof (rtx));\n-  loop_number_exit_count = (int *) alloca (max_loop_num * sizeof (int));\n+  loop_number_loop_starts = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n+  loop_number_loop_ends = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n+  loop_number_loop_cont = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n+  loop_number_cont_dominator = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n+  loop_outer_loop = (int *) xmalloc (max_loop_num * sizeof (int));\n+  loop_invalid = (char *) xmalloc (max_loop_num * sizeof (char));\n+  loop_number_exit_labels = (rtx *) xmalloc (max_loop_num * sizeof (rtx));\n+  loop_number_exit_count = (int *) xmalloc (max_loop_num * sizeof (int));\n \n #ifdef HAVE_decrement_and_branch_on_count\n   /* Allocate for BCT optimization */\n-  loop_used_count_register = (int *) alloca (max_loop_num * sizeof (int));\n-  bzero ((char *) loop_used_count_register, max_loop_num * sizeof (int));\n+  loop_used_count_register = (int *) xcalloc (max_loop_num, sizeof (int));\n #endif  /* HAVE_decrement_and_branch_on_count */\n \n   /* Find and process each loop.\n@@ -574,6 +569,23 @@ loop_optimize (f, dumpfile, unroll_p, bct_p)\n     unroll_block_trees ();\n \n   end_alias_analysis ();\n+\n+  /* Clean up.  */\n+  free (moved_once);\n+  free (uid_luid);\n+  free (uid_loop_num);\n+  free (loop_number_loop_starts);\n+  free (loop_number_loop_ends);\n+  free (loop_number_loop_cont);\n+  free (loop_number_cont_dominator);\n+  free (loop_outer_loop);\n+  free (loop_invalid);\n+  free (loop_number_exit_labels);\n+  free (loop_number_exit_count);\n+#ifdef HAVE_decrement_and_branch_on_count\n+  free (loop_used_count_register);\n+#endif  /* HAVE_decrement_and_branch_on_count */\n+\n }\n \f\n /* Returns the next insn, in execution order, after INSN.  START and\n@@ -7116,11 +7128,8 @@ combine_givs (bl)\n     if (!g1->ignore)\n       giv_array[i++] = g1;\n \n-  stats = (struct combine_givs_stats *) alloca (giv_count * sizeof (*stats));\n-  bzero ((char *) stats, giv_count * sizeof (*stats));\n-\n-  can_combine = (rtx *) alloca (giv_count * giv_count * sizeof(rtx));\n-  bzero ((char *) can_combine, giv_count * giv_count * sizeof(rtx));\n+  stats = (struct combine_givs_stats *) xcalloc (giv_count, sizeof (*stats));\n+  can_combine = (rtx *) xcalloc (giv_count, giv_count * sizeof(rtx));\n \n   for (i = 0; i < giv_count; i++)\n     {\n@@ -7250,6 +7259,10 @@ combine_givs (bl)\n \t  goto restart;\n \t}\n     }\n+\n+  /* Clean up.  */\n+  free (stats);\n+  free (can_combine);\n }\n \f\n struct recombine_givs_stats\n@@ -7387,8 +7400,8 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n \tgiv_count++;\n     }\n   giv_array\n-    = (struct induction **) alloca (giv_count * sizeof (struct induction *));\n-  stats = (struct recombine_givs_stats *) alloca (giv_count * sizeof *stats);\n+    = (struct induction **) xmalloc (giv_count * sizeof (struct induction *));\n+  stats = (struct recombine_givs_stats *) xmalloc (giv_count * sizeof *stats);\n \n   /* Initialize stats and set up the ix field for each giv in stats to name\n      the corresponding index into stats.  */\n@@ -7679,6 +7692,10 @@ recombine_givs (bl, loop_start, loop_end, unroll_p)\n \t    rescan = i;\n \t}\n     }\n+\n+  /* Clean up.  */\n+  free (giv_array);\n+  free (stats);\n }\n \f\n /* EMIT code before INSERT_BEFORE to set REG = B * M + A.  */"}, {"sha": "1ba5feb181a7357c15493555de5a6f85525514b4", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=67289ea63916a799f9967e52f936b5b9c3cbc5ed", "patch": "@@ -3531,7 +3531,7 @@ dbr_schedule (first, file)\n \tepilogue_insn = insn;\n     }\n \n-  uid_to_ruid = (int *) alloca ((max_uid + 1) * sizeof (int));\n+  uid_to_ruid = (int *) xmalloc ((max_uid + 1) * sizeof (int));\n   for (i = 0, insn = first; insn; i++, insn = NEXT_INSN (insn))\n     uid_to_ruid[INSN_UID (insn)] = i;\n   \n@@ -3676,5 +3676,6 @@ dbr_schedule (first, file)\n \t\t\t\t\t    REG_NOTES (insn));\n     }\n   free_resource_info ();\n+  free (uid_to_ruid);\n }\n #endif /* DELAY_SLOTS */"}, {"sha": "e4ed9f6fff5c708778386ddca57f67b64cd7dc6d", "filename": "gcc/unroll.c", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67289ea63916a799f9967e52f936b5b9c3cbc5ed/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=67289ea63916a799f9967e52f936b5b9c3cbc5ed", "patch": "@@ -682,7 +682,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n   max_labelno = max_label_num ();\n   max_insnno = get_max_uid ();\n \n-  map = (struct inline_remap *) alloca (sizeof (struct inline_remap));\n+  map = (struct inline_remap *) xmalloc (sizeof (struct inline_remap));\n \n   map->integrating = 0;\n   map->const_equiv_varray = 0;\n@@ -691,10 +691,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   if (max_labelno > 0)\n     {\n-      map->label_map = (rtx *) alloca (max_labelno * sizeof (rtx));\n+      map->label_map = (rtx *) xmalloc (max_labelno * sizeof (rtx));\n \n-      local_label = (char *) alloca (max_labelno);\n-      bzero (local_label, max_labelno);\n+      local_label = (char *) xcalloc (max_labelno, sizeof (char));\n     }\n   else\n     map->label_map = 0;\n@@ -742,7 +741,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   /* Allocate space for the insn map.  */\n \n-  map->insn_map = (rtx *) alloca (max_insnno * sizeof (rtx));\n+  map->insn_map = (rtx *) xmalloc (max_insnno * sizeof (rtx));\n \n   /* Set this to zero, to indicate that we are doing loop unrolling,\n      not function inlining.  */\n@@ -768,17 +767,12 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n      preconditioning code and find_splittable_regs will never be used\n      to access the splittable_regs[] and addr_combined_regs[] arrays.  */\n \n-  splittable_regs = (rtx *) alloca (maxregnum * sizeof (rtx));\n-  bzero ((char *) splittable_regs, maxregnum * sizeof (rtx));\n-  derived_regs = (char *) alloca (maxregnum);\n-  bzero (derived_regs, maxregnum);\n-  splittable_regs_updates = (int *) alloca (maxregnum * sizeof (int));\n-  bzero ((char *) splittable_regs_updates, maxregnum * sizeof (int));\n+  splittable_regs = (rtx *) xcalloc (maxregnum, sizeof (rtx));\n+  derived_regs = (char *) xcalloc (maxregnum, sizeof (char));\n+  splittable_regs_updates = (int *) xcalloc (maxregnum, sizeof (int));\n   addr_combined_regs\n-    = (struct induction **) alloca (maxregnum * sizeof (struct induction *));\n-  bzero ((char *) addr_combined_regs, maxregnum * sizeof (struct induction *));\n-  local_regno = (char *) alloca (maxregnum);\n-  bzero (local_regno, maxregnum);\n+    = (struct induction **) xcalloc (maxregnum, sizeof (struct induction *));\n+  local_regno = (char *) xcalloc (maxregnum, sizeof (char));\n \n   /* Mark all local registers, i.e. the ones which are referenced only\n      inside the loop.  */\n@@ -884,7 +878,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  rtx *labels;\n \t  int abs_inc, neg_inc;\n \n-\t  map->reg_map = (rtx *) alloca (maxregnum * sizeof (rtx));\n+\t  map->reg_map = (rtx *) xmalloc (maxregnum * sizeof (rtx));\n \n \t  VARRAY_CONST_EQUIV_INIT (map->const_equiv_varray, maxregnum,\n \t\t\t\t   \"unroll_loop\");\n@@ -930,7 +924,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  /* Now emit a sequence of branches to jump to the proper precond\n \t     loop entry point.  */\n \n-\t  labels = (rtx *) alloca (sizeof (rtx) * unroll_number);\n+\t  labels = (rtx *) xmalloc (sizeof (rtx) * unroll_number);\n \t  for (i = 0; i < unroll_number; i++)\n \t    labels[i] = gen_label_rtx ();\n \n@@ -1109,6 +1103,9 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  /* Set unroll type to MODULO now.  */\n \t  unroll_type = UNROLL_MODULO;\n \t  loop_preconditioned = 1;\n+\n+\t  /* Clean up.  */\n+\t  free (labels);\n \t}\n     }\n \n@@ -1146,7 +1143,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n      the constant maps also.  */\n \n   maxregnum = max_reg_num ();\n-  map->reg_map = (rtx *) alloca (maxregnum * sizeof (rtx));\n+  map->reg_map = (rtx *) xmalloc (maxregnum * sizeof (rtx));\n \n   init_reg_map (map, maxregnum);\n \n@@ -1286,8 +1283,22 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n     emit_label_after (exit_label, loop_end);\n \n  egress:\n-  if (map && map->const_equiv_varray)\n+  if (map->const_equiv_varray)\n     VARRAY_FREE (map->const_equiv_varray);\n+  if (map->label_map)\n+    {\n+      free (map->label_map);\n+      free (local_label);\n+    }\n+  free (map->insn_map);\n+  free (splittable_regs);\n+  free (derived_regs);\n+  free (splittable_regs_updates);\n+  free (addr_combined_regs);\n+  free (local_regno);\n+  if (map->reg_map)\n+    free (map->reg_map);\n+  free (map);\n }\n \f\n /* Return true if the loop can be safely, and profitably, preconditioned"}]}