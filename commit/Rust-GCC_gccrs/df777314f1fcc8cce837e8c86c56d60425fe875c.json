{"sha": "df777314f1fcc8cce837e8c86c56d60425fe875c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3NzczMTRmMWZjYzhjY2U4MzdlOGM4NmM1NmQ2MDQyNWZlODc1Yw==", "commit": {"author": {"name": "Jose Ruiz", "email": "ruiz@adacore.com", "date": "2007-04-06T09:22:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:22:40Z"}, "message": "gnatcmd.adb (B_Start): Add prefix of binder generated file.\n\n2007-04-06  Jose Ruiz  <ruiz@adacore.com>\n\t    Vincent Celier  <celier@adacore.com>\n\n\t* gnatcmd.adb (B_Start): Add prefix of binder generated file.\n\t(Stack_String): Add this String that contains the name of the Stack\n\tpackage in the project file.\n\t(Packages_To_Check_By_Stack): Add this list that contains the packages\n\tto be checked by gnatstack, which are the naming and the stack packages.\n\t(Check_Files): If no .ci files were specified for gnatstack we add all\n\tthe .ci files belonging to the projects, including binder generated\n\tfiles.\n\t(Non_VMS_Usage): Document that gnatstack accept project file switches.\n\t(GNATCmd): Update the B_Start variable if we are in a VMS environment.\n\tAdd gnatstack to the list of commands that use project file related\n\tswitches, and get the single attribute Switches from the stack package\n\tin a project file when calling gnatstack. Parse the -U flag for\n\tprocessing files belonging to all projects in the project tree.\n\tRemove all processing for command Setup\n\n\t* prj-attr.adb: Add new package Stack with single attribute Switches\n\n\t* vms_conv.ads (Command_Type): Add command Stack.\n\tMove to body declarations that are only used in the body: types Item_Id,\n\tTranslation_Type, Item_Ptr, Item and its subtypes.\n\n\t* vms_conv.adb: (Initialize): Add data for new command Stack.\n\tAdd declarations moved from the spec: types Item_Id, Translation_Type,\n\tItem_Ptr, Item and its subtypes.\n\t(Cargs_Buffer): New table\n\t(Cargs): New Boolean global variable\n\t(Process_Buffer): New procedure to create arguments\n\t(Place): Put character in table Buffer or Cargs_Buffer depending on the\n\t value of Cargs.\n\t(Process_Argument): Set Cargs when processing qualifiers for GNAT\n\tCOMPILE\n\t(VMS_Conversion): Call Process_Buffer for table Buffer and, if it is not\n\tempty, for table Cargs_Buffer.\n\t(Initialize): Remove component Setup in Command_List\n\nFrom-SVN: r123575", "tree": {"sha": "728c0e48acae89c929bea240ac7785541055714d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/728c0e48acae89c929bea240ac7785541055714d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df777314f1fcc8cce837e8c86c56d60425fe875c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df777314f1fcc8cce837e8c86c56d60425fe875c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df777314f1fcc8cce837e8c86c56d60425fe875c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df777314f1fcc8cce837e8c86c56d60425fe875c/comments", "author": {"login": "JoseRuizAdaCore", "id": 22770339, "node_id": "MDQ6VXNlcjIyNzcwMzM5", "avatar_url": "https://avatars.githubusercontent.com/u/22770339?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoseRuizAdaCore", "html_url": "https://github.com/JoseRuizAdaCore", "followers_url": "https://api.github.com/users/JoseRuizAdaCore/followers", "following_url": "https://api.github.com/users/JoseRuizAdaCore/following{/other_user}", "gists_url": "https://api.github.com/users/JoseRuizAdaCore/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoseRuizAdaCore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoseRuizAdaCore/subscriptions", "organizations_url": "https://api.github.com/users/JoseRuizAdaCore/orgs", "repos_url": "https://api.github.com/users/JoseRuizAdaCore/repos", "events_url": "https://api.github.com/users/JoseRuizAdaCore/events{/privacy}", "received_events_url": "https://api.github.com/users/JoseRuizAdaCore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf6ba14a7b33298f8478ce1b42ed8dac21ce4284", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf6ba14a7b33298f8478ce1b42ed8dac21ce4284", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf6ba14a7b33298f8478ce1b42ed8dac21ce4284"}], "stats": {"total": 979, "additions": 516, "deletions": 463}, "files": [{"sha": "d503a0c334f31a439a526600fae3fcb58716c40a", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 268, "deletions": 258, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df777314f1fcc8cce837e8c86c56d60425fe875c/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df777314f1fcc8cce837e8c86c56d60425fe875c/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=df777314f1fcc8cce837e8c86c56d60425fe875c", "patch": "@@ -29,6 +29,7 @@ with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n with Csets;\n with MLib.Tgt; use MLib.Tgt;\n with MLib.Utl;\n+with MLib.Fil;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Osint;    use Osint;\n@@ -60,6 +61,9 @@ procedure GNATCmd is\n    Current_Verbosity : Prj.Verbosity := Prj.Default;\n    Tool_Package_Name : Name_Id       := No_Name;\n \n+   B_Start : String_Ptr    := new String'(\"b~\");\n+   --  Prefix of binder generated file, changed to b__ for VMS\n+\n    Old_Project_File_Used : Boolean := False;\n    --  This flag indicates a switch -p (for gnatxref and gnatfind) for\n    --  an old fashioned project file. -p cannot be used in conjonction\n@@ -120,6 +124,7 @@ procedure GNATCmd is\n    Linker_String    : constant String_Access := new String'(\"linker\");\n    Gnatls_String    : constant String_Access := new String'(\"gnatls\");\n    Pretty_String    : constant String_Access := new String'(\"pretty_printer\");\n+   Stack_String     : constant String_Access := new String'(\"stack\");\n    Gnatstub_String  : constant String_Access := new String'(\"gnatstub\");\n    Metric_String    : constant String_Access := new String'(\"metrics\");\n    Xref_String      : constant String_Access := new String'(\"cross_reference\");\n@@ -145,6 +150,9 @@ procedure GNATCmd is\n    Packages_To_Check_By_Pretty    : constant String_List_Access :=\n      new String_List'((Naming_String, Pretty_String, Compiler_String));\n \n+   Packages_To_Check_By_Stack     : constant String_List_Access :=\n+     new String_List'((Naming_String, Stack_String));\n+\n    Packages_To_Check_By_Gnatstub  : constant String_List_Access :=\n      new String_List'((Naming_String, Gnatstub_String, Compiler_String));\n \n@@ -174,54 +182,52 @@ procedure GNATCmd is\n    --  The path of the working directory\n \n    All_Projects : Boolean := False;\n-   --  Flag used for GNAT PRETTY and GNAT METRIC to indicate that\n-   --  the underlying tool (gnatcheck, gnatpp or gnatmetric) should be invoked\n-   --  for all sources of all projects.\n+   --  Flag used for GNAT CHECK, GNAT PRETTY, GNAT METRIC, and GNAT STACK to\n+   --  indicate that the underlying tool (gnatcheck, gnatpp or gnatmetric)\n+   --  should be invoked for all sources of all projects.\n \n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    procedure Add_To_Carg_Switches (Switch : String_Access);\n-   --  Add a switch to the Carg_Switches table. If it is the first one,\n-   --  put the switch \"-cargs\" at the beginning of the table.\n+   --  Add a switch to the Carg_Switches table. If it is the first one, put the\n+   --  switch \"-cargs\" at the beginning of the table.\n \n    procedure Add_To_Rules_Switches (Switch : String_Access);\n-   --  Add a switch to the Rules_Switches table. If it is the first one,\n-   --  put the switch \"-crules\" at the beginning of the table.\n+   --  Add a switch to the Rules_Switches table. If it is the first one, put\n+   --  the switch \"-crules\" at the beginning of the table.\n \n    procedure Check_Files;\n-   --  For GNAT LIST, GNAT PRETTY and GNAT METRIC, check if a project\n-   --  file is specified, without any file arguments. If it is the case,\n-   --  invoke the GNAT tool with the proper list of files, derived from\n+   --  For GNAT LIST, GNAT PRETTY, GNAT METRIC, and GNAT STACK, check if a\n+   --  project file is specified, without any file arguments. If it is the\n+   --  case, invoke the GNAT tool with the proper list of files, derived from\n    --  the sources of the project.\n \n    function Check_Project\n      (Project      : Project_Id;\n       Root_Project : Project_Id) return Boolean;\n-   --  Returns True if Project = Root_Project.\n-   --  For GNAT METRIC, also returns True if Project is extended by\n-   --  Root_Project.\n+   --  Returns True if Project = Root_Project or if we want to consider all\n+   --  sources of all projects. For GNAT METRIC, also returns True if Project\n+   --  is extended by Root_Project.\n \n    procedure Check_Relative_Executable (Name : in out String_Access);\n-   --  Check if an executable is specified as a relative path.\n-   --  If it is, and the path contains directory information, fail.\n-   --  Otherwise, prepend the exec directory.\n-   --  This procedure is only used for GNAT LINK when a project file\n-   --  is specified.\n+   --  Check if an executable is specified as a relative path. If it is, and\n+   --  the path contains directory information, fail. Otherwise, prepend the\n+   --  exec directory. This procedure is only used for GNAT LINK when a project\n+   --  file is specified.\n \n    function Configuration_Pragmas_File return Name_Id;\n    --  Return an argument, if there is a configuration pragmas file to be\n-   --  specified for Project, otherwise return No_Name.\n-   --  Used for gnatstub (GNAT STUB), gnatpp (GNAT PRETTY), gnatelim\n-   --  (GNAT ELIM), and gnatmetric (GNAT METRIC).\n+   --  specified for Project, otherwise return No_Name. Used for gnatstub (GNAT\n+   --  STUB), gnatpp (GNAT PRETTY), gnatelim (GNAT ELIM), and gnatmetric (GNAT\n+   --  METRIC).\n \n    procedure Delete_Temp_Config_Files;\n    --  Delete all temporary config files\n \n    function Index (Char : Character; Str : String) return Natural;\n-   --  Returns the first occurrence of Char in Str.\n-   --  Returns 0 if Char is not in Str.\n+   --  Returns first occurrence of Char in Str, returns 0 if Char not in Str\n \n    procedure Non_VMS_Usage;\n    --  Display usage for platforms other than VMS\n@@ -232,20 +238,20 @@ procedure GNATCmd is\n    procedure Set_Library_For\n      (Project             : Project_Id;\n       There_Are_Libraries : in out Boolean);\n-   --  If Project is a library project, add the correct\n-   --  -L and -l switches to the linker invocation.\n+   --  If Project is a library project, add the correct -L and -l switches to\n+   --  the linker invocation.\n \n    procedure Set_Libraries is\n       new For_Every_Project_Imported (Boolean, Set_Library_For);\n-   --  Add the -L and -l switches to the linker for all\n-   --  of the library projects.\n+   --  Add the -L and -l switches to the linker for all of the library\n+   --  projects.\n \n    procedure Test_If_Relative_Path\n      (Switch : in out String_Access;\n       Parent : String);\n-   --  Test if Switch is a relative search path switch.\n-   --  If it is and it includes directory information, prepend the path with\n-   --  Parent.This subprogram is only called when using project files.\n+   --  Test if Switch is a relative search path switch. If it is and it\n+   --  includes directory information, prepend the path with Parent. This\n+   --  subprogram is only called when using project files.\n \n    --------------------------\n    -- Add_To_Carg_Switches --\n@@ -300,27 +306,89 @@ procedure GNATCmd is\n          end if;\n       end loop;\n \n-      --  If all arguments were switches, add the path names of\n-      --  all the sources of the main project.\n+      --  If all arguments were switches, add the path names of all the sources\n+      --  of the main project.\n \n       if Add_Sources then\n          declare\n             Current_Last : constant Integer := Last_Switches.Last;\n          begin\n+            --  Gnatstack needs to add the the .ci file for the binder\n+            --  generated files corresponding to all of the library projects\n+            --  and main units belonging to the application.\n+\n+            if The_Command = Stack then\n+               for Proj in Project_Table.First ..\n+                           Project_Table.Last (Project_Tree.Projects)\n+               loop\n+                  if Check_Project (Proj, Project) then\n+                     declare\n+                        Data : Project_Data renames\n+                                 Project_Tree.Projects.Table (Proj);\n+                        Main : String_List_Id := Data.Mains;\n+                        File : String_Access;\n+\n+                     begin\n+                        --  Include binder generated files for main programs\n+\n+                        while Main /= Nil_String loop\n+                           File :=\n+                             new String'\n+                               (Get_Name_String (Data.Object_Directory) &\n+                                Directory_Separator                     &\n+                                B_Start.all                             &\n+                                MLib.Fil.Ext_To\n+                                  (Get_Name_String\n+                                     (Project_Tree.String_Elements.Table\n+                                        (Main).Value),\n+                                   \"ci\"));\n+\n+                           if Is_Regular_File (File.all) then\n+                              Last_Switches.Increment_Last;\n+                              Last_Switches.Table (Last_Switches.Last) := File;\n+                           end if;\n+\n+                           Main :=\n+                             Project_Tree.String_Elements.Table (Main).Next;\n+                        end loop;\n+\n+                        if Data.Library then\n+\n+                           --  Include the .ci file for the binder generated\n+                           --  files that contains the initialization and\n+                           --  finalization of the library.\n+\n+                           File :=\n+                             new String'\n+                               (Get_Name_String (Data.Object_Directory) &\n+                                Directory_Separator                     &\n+                                B_Start.all                             &\n+                                Get_Name_String (Data.Library_Name)     &\n+                                \".ci\");\n+\n+                           if Is_Regular_File (File.all) then\n+                              Last_Switches.Increment_Last;\n+                              Last_Switches.Table (Last_Switches.Last) := File;\n+                           end if;\n+                        end if;\n+                     end;\n+                  end if;\n+               end loop;\n+            end if;\n+\n             for Unit in Unit_Table.First ..\n                         Unit_Table.Last (Project_Tree.Units)\n             loop\n                Unit_Data := Project_Tree.Units.Table (Unit);\n \n-               --  For gnatls, we only need to put the library units,\n-               --  body or spec, but not the subunits.\n+               --  For gnatls, we only need to put the library units, body or\n+               --  spec, but not the subunits.\n \n                if The_Command = List then\n                   if\n                     Unit_Data.File_Names (Body_Part).Name /= No_Name\n                   then\n-                     --  There is a body; check if it is for this\n-                     --  project.\n+                     --  There is a body, check if it is for this project\n \n                      if Unit_Data.File_Names (Body_Part).Project =\n                        Project\n@@ -330,9 +398,9 @@ procedure GNATCmd is\n                         if Unit_Data.File_Names (Specification).Name =\n                           No_Name\n                         then\n-                           --  We have a body with no spec: we need\n-                           --  to check if this is a subunit, because\n-                           --  gnatls will complain about subunits.\n+                           --  We have a body with no spec: we need to check if\n+                           --  this is a subunit, because gnatls will complain\n+                           --  about subunits.\n \n                            declare\n                               Src_Ind : Source_File_Index;\n@@ -359,11 +427,11 @@ procedure GNATCmd is\n                         end if;\n                      end if;\n \n-                  elsif Unit_Data.File_Names (Specification).Name /=\n-                    No_Name\n+                  elsif\n+                    Unit_Data.File_Names (Specification).Name /= No_Name\n                   then\n-                     --  We have a spec with no body; check if it is\n-                     --  for this project.\n+                     --  We have a spec with no body; check if it is for this\n+                     --  project.\n \n                      if Unit_Data.File_Names (Specification).Project =\n                        Project\n@@ -377,14 +445,97 @@ procedure GNATCmd is\n                      end if;\n                   end if;\n \n+               --  For gnatstack, we put the .ci files corresponding to the\n+               --  different units, including the binder generated files. We\n+               --  only need to do that for the library units, body or spec,\n+               --  but not the subunits.\n+\n+               elsif The_Command = Stack then\n+                  if\n+                    Unit_Data.File_Names (Body_Part).Name /= No_Name\n+                  then\n+                     --  There is a body. Check if .ci files for this project\n+                     --  must be added.\n+\n+                     if\n+                       Check_Project\n+                         (Unit_Data.File_Names (Body_Part).Project, Project)\n+                     then\n+                        Subunit := False;\n+\n+                        if\n+                          Unit_Data.File_Names (Specification).Name = No_Name\n+                        then\n+                           --  We have a body with no spec: we need to check\n+                           --  if this is a subunit, because .ci files are not\n+                           --  generated for subunits.\n+\n+                           declare\n+                              Src_Ind : Source_File_Index;\n+\n+                           begin\n+                              Src_Ind := Sinput.P.Load_Project_File\n+                                (Get_Name_String\n+                                   (Unit_Data.File_Names (Body_Part).Path));\n+\n+                              Subunit :=\n+                                Sinput.P.Source_File_Is_Subunit (Src_Ind);\n+                           end;\n+                        end if;\n+\n+                        if not Subunit then\n+                           Last_Switches.Increment_Last;\n+                           Last_Switches.Table (Last_Switches.Last) :=\n+                             new String'\n+                               (Get_Name_String\n+                                    (Project_Tree.Projects.Table\n+                                         (Unit_Data.File_Names\n+                                              (Body_Part).Project).\n+                                         Object_Directory)           &\n+                                Directory_Separator                  &\n+                                MLib.Fil.Ext_To\n+                                  (Get_Name_String\n+                                     (Unit_Data.File_Names\n+                                        (Body_Part).Display_Name),\n+                                   \"ci\"));\n+                        end if;\n+                     end if;\n+\n+                  elsif\n+                    Unit_Data.File_Names (Specification).Name /= No_Name\n+                  then\n+                     --  We have a spec with no body. Check if it is for this\n+                     --  project.\n+\n+                     if\n+                       Check_Project\n+                         (Unit_Data.File_Names (Specification).Project,\n+                          Project)\n+                     then\n+                        Last_Switches.Increment_Last;\n+                        Last_Switches.Table (Last_Switches.Last) :=\n+                          new String'\n+                            (Get_Name_String\n+                                 (Project_Tree.Projects.Table\n+                                      (Unit_Data.File_Names\n+                                           (Specification).Project).\n+                                      Object_Directory)              &\n+                             Dir_Separator                           &\n+                             MLib.Fil.Ext_To\n+                               (Get_Name_String\n+                                  (Unit_Data.File_Names\n+                                     (Specification).Name),\n+                                \"ci\"));\n+                     end if;\n+                  end if;\n+\n                else\n                   --  For gnatcheck, gnatpp and gnatmetric, put all sources\n                   --  of the project, or of all projects if -U was specified.\n \n                   for Kind in Spec_Or_Body loop\n \n-                     --  Put only sources that belong to the main\n-                     --  project.\n+                     --  Put only sources that belong to the main project\n \n                      if Check_Project\n                           (Unit_Data.File_Names (Kind).Project, Project)\n@@ -400,9 +551,9 @@ procedure GNATCmd is\n                end if;\n             end loop;\n \n-            --  If the list of files is too long, create a temporary\n-            --  text file that lists these files, and pass this temp\n-            --  file to gnatcheck, gnatpp or gnatmetric using switch -files=.\n+            --  If the list of files is too long, create a temporary text file\n+            --  that lists these files, and pass this temp file to gnatcheck,\n+            --  gnatpp or gnatmetric using switch -files=.\n \n             if Last_Switches.Last - Current_Last >\n               Max_Files_On_The_Command_Line\n@@ -421,8 +572,7 @@ procedure GNATCmd is\n                        Last_Switches.Last\n                      loop\n                         Len := Last_Switches.Table (Index)'Length;\n-                        Buffer (1 .. Len) :=\n-                          Last_Switches.Table (Index).all;\n+                        Buffer (1 .. Len) := Last_Switches.Table (Index).all;\n                         Len := Len + 1;\n                         Buffer (Len) := ASCII.LF;\n                         Buffer (Len + 1) := ASCII.NUL;\n@@ -440,13 +590,12 @@ procedure GNATCmd is\n                         OK := False;\n                      end if;\n \n-                     --  If there were any problem creating the temp\n-                     --  file, then pass the list of files.\n+                     --  If there were any problem creating the temp file, then\n+                     --  pass the list of files.\n \n                      if OK then\n \n-                        --  Replace the list of files with\n-                        --  \"-files=<temp file name>\".\n+                        --  Replace list of files with -files=<temp file name>\n \n                         Last_Switches.Set_Last (Current_Last + 1);\n                         Last_Switches.Table (Last_Switches.Last) :=\n@@ -476,10 +625,10 @@ procedure GNATCmd is\n \n       elsif The_Command = Metric then\n          declare\n-            Data : Project_Data :=\n-                     Project_Tree.Projects.Table (Root_Project);\n+            Data : Project_Data;\n \n          begin\n+            Data := Project_Tree.Projects.Table (Root_Project);\n             while Data.Extends /= No_Project loop\n                if Project = Data.Extends then\n                   return True;\n@@ -601,14 +750,14 @@ procedure GNATCmd is\n    ------------------\n \n    procedure Process_Link is\n-      Look_For_Executable  : Boolean := True;\n-      There_Are_Libraries  : Boolean := False;\n-      Path_Option          : constant String_Access :=\n-                               MLib.Linker_Library_Path_Option;\n-      Prj                  : Project_Id := Project;\n-      Arg                  : String_Access;\n-      Last                 : Natural := 0;\n-      Skip_Executable      : Boolean := False;\n+      Look_For_Executable : Boolean := True;\n+      There_Are_Libraries : Boolean := False;\n+      Path_Option         : constant String_Access :=\n+                              MLib.Linker_Library_Path_Option;\n+      Prj                 : Project_Id := Project;\n+      Arg                 : String_Access;\n+      Last                : Natural := 0;\n+      Skip_Executable     : Boolean := False;\n \n    begin\n       --  Add the default search directories, to be able to find\n@@ -640,9 +789,9 @@ procedure GNATCmd is\n          Last_Switches.Table (Last_Switches.Last) :=\n            new String'(\"-lgnat\");\n \n-         --  If Path_Option is not null, create the switch\n-         --  (\"-Wl,-rpath,\" or equivalent) with all the library dirs\n-         --  plus the standard GNAT library dir.\n+         --  If Path_Option is not null, create the switch (\"-Wl,-rpath,\" or\n+         --  equivalent) with all the library dirs plus the standard GNAT\n+         --  library dir.\n \n          if Path_Option /= null then\n             declare\n@@ -656,16 +805,15 @@ procedure GNATCmd is\n                for Index in\n                  Library_Paths.First .. Library_Paths.Last\n                loop\n-                  --  Add the length of the library dir plus one\n-                  --  for the directory separator.\n+                  --  Add the length of the library dir plus one for the\n+                  --  directory separator.\n \n                   Length :=\n                     Length +\n                       Library_Paths.Table (Index)'Length + 1;\n                end loop;\n \n-               --  Finally, add the length of the standard GNAT\n-               --  library dir.\n+               --  Finally, add the length of the standard GNAT library dir\n \n                Length := Length + MLib.Utl.Lib_Directory'Length;\n                Option := new String (1 .. Length);\n@@ -704,11 +852,10 @@ procedure GNATCmd is\n          end if;\n       end if;\n \n-      --  Check if the first ALI file specified can be found, either\n-      --  in the object directory of the main project or in an object\n-      --  directory of a project file extended by the main project.\n-      --  If the ALI file can be found, replace its name with its\n-      --  absolute path.\n+      --  Check if the first ALI file specified can be found, either in the\n+      --  object directory of the main project or in an object directory of a\n+      --  project file extended by the main project. If the ALI file can be\n+      --  found, replace its name with its absolute path.\n \n       Skip_Executable := False;\n \n@@ -753,8 +900,8 @@ procedure GNATCmd is\n                      Last := ALI_File'Last;\n                   end if;\n \n-                  --  If file name includes directory information,\n-                  --  stop if ALI file exists.\n+                  --  If file name includes directory information, stop if ALI\n+                  --  file exists.\n \n                   if Is_Absolute_Path (ALI_File (1 .. Last)) then\n                      Test_Existence := True;\n@@ -804,8 +951,7 @@ procedure GNATCmd is\n                            end if;\n                         end;\n \n-                        --  Go to the project being extended,\n-                        --  if any.\n+                        --  Go to the project being extended, if any\n \n                         Prj :=\n                           Project_Tree.Projects.Table (Prj).Extends;\n@@ -817,8 +963,8 @@ procedure GNATCmd is\n          end if;\n       end loop Switch_Loop;\n \n-      --  If a relative path output file has been specified, we add\n-      --  the exec directory.\n+      --  If a relative path output file has been specified, we add the exec\n+      --  directory.\n \n       for J in reverse 1 .. Last_Switches.Last - 1 loop\n          if Last_Switches.Table (J).all = \"-o\" then\n@@ -840,10 +986,9 @@ procedure GNATCmd is\n          end loop;\n       end if;\n \n-      --  If no executable is specified, then find the name\n-      --  of the first ALI file on the command line and issue\n-      --  a -o switch with the absolute path of the executable\n-      --  in the exec directory.\n+      --  If no executable is specified, then find the name of the first ALI\n+      --  file on the command line and issue a -o switch with the absolute path\n+      --  of the executable in the exec directory.\n \n       if Look_For_Executable then\n          for J in 1 .. Last_Switches.Last loop\n@@ -1030,8 +1175,8 @@ procedure GNATCmd is\n       end loop;\n \n       New_Line;\n-      Put_Line (\"Commands find, list, metric, pretty, stub and xref accept \" &\n-                \"project file switches -vPx, -Pprj and -Xnam=val\");\n+      Put_Line (\"Commands find, list, metric, pretty, stack, stub and xref \" &\n+                \"accept project file switches -vPx, -Pprj and -Xnam=val\");\n       New_Line;\n    end Non_VMS_Usage;\n \n@@ -1061,10 +1206,9 @@ begin\n \n    VMS_Conv.Initialize;\n \n-   --  Add the directory where the GNAT driver is invoked in front of the\n-   --  path, if the GNAT driver is invoked with directory information.\n-   --  Only do this if the platform is not VMS, where the notion of path\n-   --  does not really exist.\n+   --  Add the directory where the GNAT driver is invoked in front of the path,\n+   --  if the GNAT driver is invoked with directory information. Do not do this\n+   --  for VMS, where the notion of path does not really exist.\n \n    if not OpenVMS then\n       declare\n@@ -1101,6 +1245,8 @@ begin\n    then\n       VMS_Conversion (The_Command);\n \n+      B_Start := new String'(\"b__\");\n+\n    --  If not on VMS, scan the command line directly\n \n    else\n@@ -1193,8 +1339,8 @@ begin\n                            raise Error_Exit;\n                      end;\n \n-                     --  Read line by line and put the content of each\n-                     --  non empty line in the Last_Switches table.\n+                     --  Read line by line and put the content of each non-\n+                     --  empty line in the Last_Switches table.\n \n                      while not End_Of_File (Arg_File) loop\n                         Get_Line (Arg_File, Line, Last);\n@@ -1229,149 +1375,6 @@ begin\n       Exec_Path : String_Access;\n \n    begin\n-      --  First deal with built-in command(s)\n-\n-      if The_Command = Setup then\n-         Process_Setup :\n-         declare\n-            Arg_Num : Positive := 1;\n-            Argv    : String_Access;\n-\n-         begin\n-            while Arg_Num <= Last_Switches.Last loop\n-               Argv := Last_Switches.Table (Arg_Num);\n-\n-               if Argv (Argv'First) /= '-' then\n-                  Fail (\"invalid parameter \"\"\", Argv.all, \"\"\"\");\n-\n-               else\n-                  if Argv'Length = 1 then\n-                     Fail\n-                       (\"switch character cannot be followed by a blank\");\n-                  end if;\n-\n-                  --  -vPx  Specify verbosity while parsing project files\n-\n-                  if Argv'Length = 4\n-                    and then Argv (Argv'First + 1 .. Argv'First + 2) = \"vP\"\n-                  then\n-                     case Argv (Argv'Last) is\n-                        when '0' =>\n-                           Current_Verbosity := Prj.Default;\n-                        when '1' =>\n-                           Current_Verbosity := Prj.Medium;\n-                        when '2' =>\n-                           Current_Verbosity := Prj.High;\n-                        when others =>\n-                           Fail (\"Invalid switch: \", Argv.all);\n-                     end case;\n-\n-                  --  -Pproject_file  Specify project file to be used\n-\n-                  elsif Argv (Argv'First + 1) = 'P' then\n-\n-                     --  Only one -P switch can be used\n-\n-                     if Project_File /= null then\n-                        Fail\n-                          (Argv.all,\n-                           \": second project file forbidden (first is \"\"\",\n-                           Project_File.all & \"\"\")\");\n-\n-                     elsif Argv'Length = 2 then\n-\n-                        --  There is space between -P and the project file\n-                        --  name. -P cannot be the last option.\n-\n-                        if Arg_Num = Last_Switches.Last then\n-                           Fail (\"project file name missing after -P\");\n-\n-                        else\n-                           Arg_Num := Arg_Num + 1;\n-                           Argv := Last_Switches.Table (Arg_Num);\n-\n-                           --  After -P, there must be a project file name,\n-                           --  not another switch.\n-\n-                           if Argv (Argv'First) = '-' then\n-                              Fail (\"project file name missing after -P\");\n-\n-                           else\n-                              Project_File := new String'(Argv.all);\n-                           end if;\n-                        end if;\n-\n-                     else\n-                        --  No space between -P and project file name\n-\n-                        Project_File :=\n-                          new String'(Argv (Argv'First + 2 .. Argv'Last));\n-                     end if;\n-\n-                  --  -Xexternal=value Specify an external reference to be\n-                  --                   used in project files\n-\n-                  elsif Argv'Length >= 5\n-                    and then Argv (Argv'First + 1) = 'X'\n-                  then\n-                     declare\n-                        Equal_Pos : constant Natural :=\n-                          Index ('=', Argv (Argv'First + 2 .. Argv'Last));\n-                     begin\n-                        if Equal_Pos >= Argv'First + 3 and then\n-                          Equal_Pos /= Argv'Last then\n-                           Add\n-                             (External_Name =>\n-                              Argv (Argv'First + 2 .. Equal_Pos - 1),\n-                              Value     => Argv (Equal_Pos + 1 .. Argv'Last));\n-                        else\n-                           Fail\n-                             (Argv.all,\n-                              \" is not a valid external assignment.\");\n-                        end if;\n-                     end;\n-\n-                  elsif Argv.all = \"-v\" then\n-                     Verbose_Mode := True;\n-\n-                  elsif Argv.all = \"-q\" then\n-                     Quiet_Output := True;\n-\n-                  else\n-                     Fail (\"invalid parameter \"\"\", Argv.all, \"\"\"\");\n-                  end if;\n-               end if;\n-\n-               Arg_Num := Arg_Num + 1;\n-            end loop;\n-\n-            if Project_File = null then\n-               Fail (\"no project file specified\");\n-            end if;\n-\n-            Setup_Projects := True;\n-\n-            Prj.Pars.Set_Verbosity (To => Current_Verbosity);\n-\n-            --  Missing directories are created during processing of the\n-            --  project tree.\n-\n-            Prj.Pars.Parse\n-              (Project           => Project,\n-               In_Tree           => Project_Tree,\n-               Project_File_Name => Project_File.all,\n-               Packages_To_Check => All_Packages);\n-\n-            if Project = Prj.No_Project then\n-               Fail (\"\"\"\", Project_File.all, \"\"\" processing failed\");\n-            end if;\n-\n-            --  Processing is done\n-\n-            return;\n-         end Process_Setup;\n-      end if;\n-\n       --  Locate the executable for the command\n \n       Exec_Path := Locate_Exec_On_Path (Program);\n@@ -1391,8 +1394,8 @@ begin\n          end loop;\n       end if;\n \n-      --  For BIND, CHECK, FIND, LINK, LIST, PRETTY ad  XREF, look for project\n-      --  file related switches.\n+      --  For BIND, CHECK, ELIM, FIND, LINK, LIST, PRETTY, STACK, STUB,\n+      --  METRIC ad  XREF, look for project file related switches.\n \n       if The_Command = Bind\n         or else The_Command = Check\n@@ -1402,6 +1405,7 @@ begin\n         or else The_Command = List\n         or else The_Command = Xref\n         or else The_Command = Pretty\n+        or else The_Command = Stack\n         or else The_Command = Stub\n         or else The_Command = Metric\n       then\n@@ -1430,6 +1434,9 @@ begin\n             when Pretty =>\n                Tool_Package_Name := Name_Pretty_Printer;\n                Packages_To_Check := Packages_To_Check_By_Pretty;\n+            when Stack =>\n+               Tool_Package_Name := Name_Stack;\n+               Packages_To_Check := Packages_To_Check_By_Stack;\n             when Stub =>\n                Tool_Package_Name := Name_Gnatstub;\n                Packages_To_Check := Packages_To_Check_By_Gnatstub;\n@@ -1440,8 +1447,8 @@ begin\n                null;\n          end case;\n \n-         --  Check that the switches are consistent.\n-         --  Detect project file related switches.\n+         --  Check that the switches are consistent. Detect project file\n+         --  related switches.\n \n          Inspect_Switches :\n          declare\n@@ -1562,7 +1569,9 @@ begin\n                   then\n                      declare\n                         Equal_Pos : constant Natural :=\n-                          Index ('=', Argv (Argv'First + 2 .. Argv'Last));\n+                                      Index\n+                                        ('=',\n+                                         Argv (Argv'First + 2 .. Argv'Last));\n                      begin\n                         if Equal_Pos >= Argv'First + 3 and then\n                           Equal_Pos /= Argv'Last then\n@@ -1581,7 +1590,8 @@ begin\n                   elsif\n                     (The_Command = Check  or else\n                      The_Command = Pretty or else\n-                     The_Command = Metric)\n+                     The_Command = Metric or else\n+                     The_Command = Stack)\n                     and then Argv'Length = 2\n                     and then Argv (2) = 'U'\n                   then\n@@ -1640,25 +1650,25 @@ begin\n             if Pkg /= No_Package then\n                Element := Project_Tree.Packages.Table (Pkg);\n \n-               --  Packages Gnatls has a single attribute Switches, that is\n-               --  not an associative array.\n+               --  Packages Gnatls and Gnatstack have a single attribute\n+               --  Switches, that is not an associative array.\n \n-               if The_Command = List then\n+               if The_Command = List or else The_Command = Stack then\n                   The_Switches :=\n                     Prj.Util.Value_Of\n                     (Variable_Name => Snames.Name_Switches,\n                      In_Variables  => Element.Decl.Attributes,\n                      In_Tree       => Project_Tree);\n \n                --  Packages Binder (for gnatbind), Cross_Reference (for\n-               --  gnatxref), Linker (for gnatlink) Finder (for gnatfind),\n-               --  Pretty_Printer (for gnatpp) Eliminate (for gnatelim),\n-               --  Check (for gnatcheck) and Metric (for gnatmetric) have\n-               --  an attributed Switches, an associative array, indexed\n-               --  by the name of the file.\n+               --  gnatxref), Linker (for gnatlink), Finder (for gnatfind),\n+               --  Pretty_Printer (for gnatpp), Eliminate (for gnatelim), Check\n+               --  (for gnatcheck), and Metric (for gnatmetric) have an\n+               --  attributed Switches, an associative array, indexed by the\n+               --  name of the file.\n \n-               --  They also have an attribute Default_Switches, indexed\n-               --  by the name of the programming language.\n+               --  They also have an attribute Default_Switches, indexed by the\n+               --  name of the programming language.\n \n                else\n                   if The_Switches.Kind = Prj.Undefined then\n@@ -1790,7 +1800,6 @@ begin\n                         declare\n                            Switch : constant String :=\n                                       Get_Name_String (The_Switches.Value);\n-\n                         begin\n                            if Switch'Length > 0 then\n                               Add_To_Carg_Switches (new String'(Switch));\n@@ -2031,14 +2040,15 @@ begin\n             end;\n          end if;\n \n-         --  For gnat check, gnat pretty, gnat metric ands gnat list,\n-         --  if no file has been put on the command line, call tool with all\n-         --  the sources of the main project.\n+         --  For gnat check, gnat pretty, gnat metric, gnat list, and gnat\n+         --  stack, if no file has been put on the command line, call tool\n+         --  with all the sources of the main project.\n \n          if The_Command = Check  or else\n             The_Command = Pretty or else\n             The_Command = Metric or else\n-            The_Command = List\n+            The_Command = List   or else\n+            The_Command = Stack\n          then\n             Check_Files;\n          end if;"}, {"sha": "5b10900180032ed2f0483e61168a99f751260d04", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df777314f1fcc8cce837e8c86c56d60425fe875c/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df777314f1fcc8cce837e8c86c56d60425fe875c/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=df777314f1fcc8cce837e8c86c56d60425fe875c", "patch": "@@ -191,6 +191,11 @@ package body Prj.Attr is\n      \"SVvcs_file_check#\" &\n      \"SVvcs_log_check#\" &\n \n+   --  package Stack\n+\n+     \"Pstack#\" &\n+     \"LVswitches#\" &\n+\n    --  package Language_Processing\n \n      \"Planguage_processing#\" &"}, {"sha": "250ed6206c8182423ab88082b1491d1b5be8891f", "filename": "gcc/ada/vms_conv.adb", "status": "modified", "additions": 241, "deletions": 75, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df777314f1fcc8cce837e8c86c56d60425fe875c/gcc%2Fada%2Fvms_conv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df777314f1fcc8cce837e8c86c56d60425fe875c/gcc%2Fada%2Fvms_conv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.adb?ref=df777314f1fcc8cce837e8c86c56d60425fe875c", "patch": "@@ -36,6 +36,134 @@ with Ada.Text_IO;             use Ada.Text_IO;\n \n package body VMS_Conv is\n \n+   -------------------------\n+   -- Internal Structures --\n+   -------------------------\n+\n+   --  The switches and commands are defined by strings in the previous\n+   --  section so that they are easy to modify, but internally, they are\n+   --  kept in a more conveniently accessible form described in this\n+   --  section.\n+\n+   --  Commands, command qualifers and options have a similar common format\n+   --  so that searching for matching names can be done in a common manner.\n+\n+   type Item_Id is (Id_Command, Id_Switch, Id_Option);\n+\n+   type Translation_Type is\n+     (\n+      T_Direct,\n+      --  A qualifier with no options.\n+      --  Example: GNAT MAKE /VERBOSE\n+\n+      T_Directories,\n+      --  A qualifier followed by a list of directories\n+      --  Example: GNAT COMPILE /SEARCH=([], [.FOO], [.BAR])\n+\n+      T_Directory,\n+      --  A qualifier followed by one directory\n+      --  Example: GNAT LIBRARY /SET=[.VAXFLOATLIB]\n+\n+      T_File,\n+      --  A qualifier followed by a filename\n+      --  Example: GNAT LINK /EXECUTABLE=FOO.EXE\n+\n+      T_No_Space_File,\n+      --  A qualifier followed by a filename\n+      --  Example: GNAT MAKE /PROJECT_FILE=PRJ.GPR\n+\n+      T_Numeric,\n+      --  A qualifier followed by a numeric value.\n+      --  Example: GNAT CHOP /FILE_NAME_MAX_LENGTH=39\n+\n+      T_String,\n+      --  A qualifier followed by a quoted string. Only used by\n+      --  /IDENTIFICATION qualifier.\n+      --  Example: GNAT LINK /IDENTIFICATION=\"3.14a1 version\"\n+\n+      T_Options,\n+      --  A qualifier followed by a list of options.\n+      --  Example: GNAT COMPILE /REPRESENTATION_INFO=(ARRAYS,OBJECTS)\n+\n+      T_Commands,\n+      --  A qualifier followed by a list. Only used for\n+      --  MAKE /COMPILER_QUALIFIERS /BINDER_QUALIFIERS /LINKER_QUALIFIERS\n+      --  (gnatmake -cargs -bargs -largs )\n+      --  Example: GNAT MAKE ... /LINKER_QUALIFIERS /VERBOSE FOOBAR.OBJ\n+\n+      T_Other,\n+      --  A qualifier passed directly to the linker. Only used\n+      --  for LINK and SHARED if no other match is found.\n+      --  Example: GNAT LINK FOO.ALI /SYSSHR\n+\n+      T_Alphanumplus\n+      --  A qualifier followed by a legal linker symbol prefix. Only used\n+      --  for BIND /BUILD_LIBRARY (gnatbind -Lxyz).\n+      --  Example: GNAT BIND /BUILD_LIBRARY=foobar\n+      );\n+\n+   type Item (Id : Item_Id);\n+   type Item_Ptr is access all Item;\n+\n+   type Item (Id : Item_Id) is record\n+      Name : String_Ptr;\n+      --  Name of the command, switch (with slash) or option\n+\n+      Next : Item_Ptr;\n+      --  Pointer to next item on list, always has the same Id value\n+\n+      Command : Command_Type := Undefined;\n+\n+      Unix_String : String_Ptr := null;\n+      --  Corresponding Unix string. For a command, this is the unix command\n+      --  name and possible default switches. For a switch or option it is\n+      --  the unix switch string.\n+\n+      case Id is\n+\n+         when Id_Command =>\n+\n+            Switches : Item_Ptr;\n+            --  Pointer to list of switch items for the command, linked\n+            --  through the Next fields with null terminating the list.\n+\n+            Usage : String_Ptr;\n+            --  Usage information, used only for errors and the default\n+            --  list of commands output.\n+\n+            Params : Parameter_Ref;\n+            --  Array of parameters\n+\n+            Defext : String (1 .. 3);\n+            --  Default extension. If non-blank, then this extension is\n+            --  supplied by default as the extension for any file parameter\n+            --  which does not have an extension already.\n+\n+         when Id_Switch =>\n+\n+            Translation : Translation_Type;\n+            --  Type of switch translation. For all cases, except Options,\n+            --  this is the only field needed, since the Unix translation\n+            --  is found in Unix_String.\n+\n+            Options : Item_Ptr;\n+            --  For the Options case, this field is set to point to a list\n+            --  of options item (for this case Unix_String is null in the\n+            --  main switch item). The end of the list is marked by null.\n+\n+         when Id_Option =>\n+\n+            null;\n+            --  No special fields needed, since Name and Unix_String are\n+            --  sufficient to completely described an option.\n+\n+      end case;\n+   end record;\n+\n+   subtype Command_Item is Item (Id_Command);\n+   subtype Switch_Item  is Item (Id_Switch);\n+   subtype Option_Item  is Item (Id_Option);\n+\n    Keep_Temps_Option : constant Item_Ptr :=\n                          new Item'\n                            (Id          => Id_Option,\n@@ -80,6 +208,19 @@ package body VMS_Conv is\n       Table_Initial        => 4096,\n       Table_Increment      => 100,\n       Table_Name           => \"Buffer\");\n+   --  Table to store the command to be used\n+\n+   package Cargs_Buffer is new Table.Table\n+     (Table_Component_Type => Character,\n+      Table_Index_Type     => Integer,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 4096,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Cargs_Buffer\");\n+   --  Table to store the compiler switches for GNAT COMPILE\n+\n+   Cargs : Boolean := False;\n+   --  When True, commands should go to Cargs_Buffer instead of Buffer table\n \n    function Init_Object_Dirs return Argument_List;\n    --  Get the list of the object directories\n@@ -145,6 +286,10 @@ package body VMS_Conv is\n    --  Process one argument from the command line, or one line from\n    --  from a command line file. For the first call, set The_Command.\n \n+   procedure Process_Buffer (S : String);\n+   --  Process the characters in the Buffer table or the Cargs_Buffer table\n+   --  to convert these into arguments.\n+\n    procedure Validate_Command_Or_Option (N : VMS_Data.String_Ptr);\n    --  Check that N is a valid command or option name, i.e. that it is of the\n    --  form of an Ada identifier with upper case letters and underscores.\n@@ -360,16 +505,6 @@ package body VMS_Conv is\n             Params   => new Parameter_Array'(1 => Unlimited_Files),\n             Defext   => \"   \"),\n \n-         Setup =>\n-           (Cname    => new S'(\"SETUP\"),\n-            Usage    => new S'(\"GNAT SETUP /qualifiers\"),\n-            VMS_Only => False,\n-            Unixcmd  => new S'(\"\"),\n-            Unixsws  => null,\n-            Switches => Setup_Switches'Access,\n-            Params   => new Parameter_Array'(1 => Unlimited_Files),\n-            Defext   => \"   \"),\n-\n          Shared =>\n            (Cname    => new S'(\"SHARED\"),\n             Usage    => new S'(\"GNAT SHARED [obj_&_lib_&_exe_&_opt\"\n@@ -382,6 +517,16 @@ package body VMS_Conv is\n             Params   => new Parameter_Array'(1 => Unlimited_Files),\n             Defext   => \"   \"),\n \n+         Stack =>\n+           (Cname    => new S'(\"STACK\"),\n+            Usage    => new S'(\"GNAT STACK /qualifiers ci_files\"),\n+            VMS_Only => False,\n+            Unixcmd  => new S'(\"gnatstack\"),\n+            Unixsws  => null,\n+            Switches => Stack_Switches'Access,\n+            Params   => new Parameter_Array'(1 => Unlimited_Files),\n+            Defext   => \"ci\" & ASCII.NUL),\n+\n          Stub =>\n            (Cname    => new S'(\"STUB\"),\n             Usage    => new S'(\"GNAT STUB file [directory]/qualifiers\"),\n@@ -673,8 +818,11 @@ package body VMS_Conv is\n \n    procedure Place (C : Character) is\n    begin\n-      Buffer.Increment_Last;\n-      Buffer.Table (Buffer.Last) := C;\n+      if Cargs then\n+         Cargs_Buffer.Append (C);\n+      else\n+         Buffer.Append (C);\n+      end if;\n    end Place;\n \n    procedure Place (S : String) is\n@@ -1052,6 +1200,8 @@ package body VMS_Conv is\n       --  Start of processing for Process_Argument\n \n    begin\n+      Cargs := False;\n+\n       --  If an argument file is open, read the next non empty line\n \n       if Is_Open (Arg_File) then\n@@ -1554,6 +1704,8 @@ package body VMS_Conv is\n             else\n                Output_File_Expected := False;\n \n+               Cargs := Command.Name.all = \"COMPILE\";\n+\n                --  This code is too heavily nested, should be\n                --  separated out as separate subprogram ???\n \n@@ -1966,6 +2118,73 @@ package body VMS_Conv is\n       end if;\n    end Process_Argument;\n \n+   --------------------\n+   -- Process_Buffer --\n+   --------------------\n+\n+   procedure Process_Buffer (S : String) is\n+      P1, P2     : Natural;\n+      Inside_Nul : Boolean := False;\n+      Arg        : String (1 .. 1024);\n+      Arg_Ctr    : Natural;\n+\n+   begin\n+      P1 := 1;\n+      while P1 <= S'Last and then S (P1) = ' ' loop\n+         P1 := P1 + 1;\n+      end loop;\n+\n+      Arg_Ctr := 1;\n+      Arg (Arg_Ctr) := S (P1);\n+\n+      while P1 <= S'Last loop\n+         if S (P1) = ASCII.NUL then\n+            if Inside_Nul then\n+               Inside_Nul := False;\n+            else\n+               Inside_Nul := True;\n+            end if;\n+         end if;\n+\n+         if S (P1) = ' ' and then not Inside_Nul then\n+            P1 := P1 + 1;\n+            Arg_Ctr := Arg_Ctr + 1;\n+            Arg (Arg_Ctr) := S (P1);\n+\n+         else\n+            Last_Switches.Increment_Last;\n+            P2 := P1;\n+\n+            while P2 < S'Last\n+              and then (S (P2 + 1) /= ' ' or else\n+                        Inside_Nul)\n+            loop\n+               P2 := P2 + 1;\n+               Arg_Ctr := Arg_Ctr + 1;\n+               Arg (Arg_Ctr) := S (P2);\n+               if S (P2) = ASCII.NUL then\n+                  Arg_Ctr := Arg_Ctr - 1;\n+\n+                  if Inside_Nul then\n+                     Inside_Nul := False;\n+                  else\n+                     Inside_Nul := True;\n+                  end if;\n+               end if;\n+            end loop;\n+\n+            Last_Switches.Table (Last_Switches.Last) :=\n+              new String'(String (Arg (1 .. Arg_Ctr)));\n+            P1 := P2 + 2;\n+\n+            exit when P1 > S'Last;\n+\n+            Arg_Ctr := 1;\n+            Arg (Arg_Ctr) := S (P1);\n+         end if;\n+      end loop;\n+   end Process_Buffer;\n+\n    --------------------------------\n    -- Validate_Command_Or_Option --\n    --------------------------------\n@@ -2012,8 +2231,9 @@ package body VMS_Conv is\n    --------------------\n \n    procedure VMS_Conversion (The_Command : out Command_Type) is\n-      Result : Command_Type := Undefined;\n-      Result_Set : Boolean := False;\n+      Result     : Command_Type := Undefined;\n+      Result_Set : Boolean      := False;\n+\n    begin\n       Buffer.Init;\n \n@@ -2040,10 +2260,9 @@ package body VMS_Conv is\n          raise Normal_Exit;\n       end if;\n \n-      Arg_Num := 1;\n-\n       --  Loop through arguments\n \n+      Arg_Num := 1;\n       while Arg_Num <= Argument_Count loop\n          Process_Argument (Result);\n \n@@ -2079,66 +2298,13 @@ package body VMS_Conv is\n          --  Prepare arguments for a call to spawn, filtering out\n          --  embedded nulls place there to delineate strings.\n \n-         declare\n-            P1, P2     : Natural;\n-            Inside_Nul : Boolean := False;\n-            Arg        : String (1 .. 1024);\n-            Arg_Ctr    : Natural;\n-\n-         begin\n-            P1 := 1;\n-\n-            while P1 <= Buffer.Last and then Buffer.Table (P1) = ' ' loop\n-               P1 := P1 + 1;\n-            end loop;\n-\n-            Arg_Ctr := 1;\n-            Arg (Arg_Ctr) := Buffer.Table (P1);\n-\n-            while P1 <= Buffer.Last loop\n-\n-               if Buffer.Table (P1) = ASCII.NUL then\n-                  if Inside_Nul then\n-                     Inside_Nul := False;\n-                  else\n-                     Inside_Nul := True;\n-                  end if;\n-               end if;\n-\n-               if Buffer.Table (P1) = ' ' and then not Inside_Nul then\n-                  P1 := P1 + 1;\n-                  Arg_Ctr := Arg_Ctr + 1;\n-                  Arg (Arg_Ctr) := Buffer.Table (P1);\n+         Process_Buffer (String (Buffer.Table (1 .. Buffer.Last)));\n \n-               else\n-                  Last_Switches.Increment_Last;\n-                  P2 := P1;\n-\n-                  while P2 < Buffer.Last\n-                    and then (Buffer.Table (P2 + 1) /= ' ' or else\n-                              Inside_Nul)\n-                  loop\n-                     P2 := P2 + 1;\n-                     Arg_Ctr := Arg_Ctr + 1;\n-                     Arg (Arg_Ctr) := Buffer.Table (P2);\n-                     if Buffer.Table (P2) = ASCII.NUL then\n-                        Arg_Ctr := Arg_Ctr - 1;\n-                        if Inside_Nul then\n-                           Inside_Nul := False;\n-                        else\n-                           Inside_Nul := True;\n-                        end if;\n-                     end if;\n-                  end loop;\n-\n-                  Last_Switches.Table (Last_Switches.Last) :=\n-                    new String'(String (Arg (1 .. Arg_Ctr)));\n-                  P1 := P2 + 2;\n-                  Arg_Ctr := 1;\n-                  Arg (Arg_Ctr) := Buffer.Table (P1);\n-               end if;\n-            end loop;\n-         end;\n+         if Cargs_Buffer.Last > 1 then\n+            Last_Switches.Append (new String'(\"-cargs\"));\n+            Process_Buffer\n+              (String (Cargs_Buffer.Table (1 .. Cargs_Buffer.Last)));\n+         end if;\n       end if;\n    end VMS_Conversion;\n "}, {"sha": "98496df730e1e1e18b3139f0038d9d8297e1ccf3", "filename": "gcc/ada/vms_conv.ads", "status": "modified", "additions": 2, "deletions": 130, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df777314f1fcc8cce837e8c86c56d60425fe875c/gcc%2Fada%2Fvms_conv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df777314f1fcc8cce837e8c86c56d60425fe875c/gcc%2Fada%2Fvms_conv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fvms_conv.ads?ref=df777314f1fcc8cce837e8c86c56d60425fe875c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2003-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -109,8 +109,8 @@ package VMS_Conv is\n       Name,\n       Preprocess,\n       Pretty,\n-      Setup,\n       Shared,\n+      Stack,\n       Stub,\n       Xref,\n       Undefined);\n@@ -158,134 +158,6 @@ package VMS_Conv is\n       --  an extension already.\n    end record;\n \n-   -------------------------\n-   -- Internal Structures --\n-   -------------------------\n-\n-   --  The switches and commands are defined by strings in the previous\n-   --  section so that they are easy to modify, but internally, they are\n-   --  kept in a more conveniently accessible form described in this\n-   --  section.\n-\n-   --  Commands, command qualifers and options have a similar common format\n-   --  so that searching for matching names can be done in a common manner.\n-\n-   type Item_Id is (Id_Command, Id_Switch, Id_Option);\n-\n-   type Translation_Type is\n-     (\n-      T_Direct,\n-      --  A qualifier with no options.\n-      --  Example: GNAT MAKE /VERBOSE\n-\n-      T_Directories,\n-      --  A qualifier followed by a list of directories\n-      --  Example: GNAT COMPILE /SEARCH=([], [.FOO], [.BAR])\n-\n-      T_Directory,\n-      --  A qualifier followed by one directory\n-      --  Example: GNAT LIBRARY /SET=[.VAXFLOATLIB]\n-\n-      T_File,\n-      --  A qualifier followed by a filename\n-      --  Example: GNAT LINK /EXECUTABLE=FOO.EXE\n-\n-      T_No_Space_File,\n-      --  A qualifier followed by a filename\n-      --  Example: GNAT MAKE /PROJECT_FILE=PRJ.GPR\n-\n-      T_Numeric,\n-      --  A qualifier followed by a numeric value.\n-      --  Example: GNAT CHOP /FILE_NAME_MAX_LENGTH=39\n-\n-      T_String,\n-      --  A qualifier followed by a quoted string. Only used by\n-      --  /IDENTIFICATION qualifier.\n-      --  Example: GNAT LINK /IDENTIFICATION=\"3.14a1 version\"\n-\n-      T_Options,\n-      --  A qualifier followed by a list of options.\n-      --  Example: GNAT COMPILE /REPRESENTATION_INFO=(ARRAYS,OBJECTS)\n-\n-      T_Commands,\n-      --  A qualifier followed by a list. Only used for\n-      --  MAKE /COMPILER_QUALIFIERS /BINDER_QUALIFIERS /LINKER_QUALIFIERS\n-      --  (gnatmake -cargs -bargs -largs )\n-      --  Example: GNAT MAKE ... /LINKER_QUALIFIERS /VERBOSE FOOBAR.OBJ\n-\n-      T_Other,\n-      --  A qualifier passed directly to the linker. Only used\n-      --  for LINK and SHARED if no other match is found.\n-      --  Example: GNAT LINK FOO.ALI /SYSSHR\n-\n-      T_Alphanumplus\n-      --  A qualifier followed by a legal linker symbol prefix. Only used\n-      --  for BIND /BUILD_LIBRARY (gnatbind -Lxyz).\n-      --  Example: GNAT BIND /BUILD_LIBRARY=foobar\n-      );\n-\n-   type Item (Id : Item_Id);\n-   type Item_Ptr is access all Item;\n-\n-   type Item (Id : Item_Id) is record\n-      Name : String_Ptr;\n-      --  Name of the command, switch (with slash) or option\n-\n-      Next : Item_Ptr;\n-      --  Pointer to next item on list, always has the same Id value\n-\n-      Command : Command_Type := Undefined;\n-\n-      Unix_String : String_Ptr := null;\n-      --  Corresponding Unix string. For a command, this is the unix command\n-      --  name and possible default switches. For a switch or option it is\n-      --  the unix switch string.\n-\n-      case Id is\n-\n-         when Id_Command =>\n-\n-            Switches : Item_Ptr;\n-            --  Pointer to list of switch items for the command, linked\n-            --  through the Next fields with null terminating the list.\n-\n-            Usage : String_Ptr;\n-            --  Usage information, used only for errors and the default\n-            --  list of commands output.\n-\n-            Params : Parameter_Ref;\n-            --  Array of parameters\n-\n-            Defext : String (1 .. 3);\n-            --  Default extension. If non-blank, then this extension is\n-            --  supplied by default as the extension for any file parameter\n-            --  which does not have an extension already.\n-\n-         when Id_Switch =>\n-\n-            Translation : Translation_Type;\n-            --  Type of switch translation. For all cases, except Options,\n-            --  this is the only field needed, since the Unix translation\n-            --  is found in Unix_String.\n-\n-            Options : Item_Ptr;\n-            --  For the Options case, this field is set to point to a list\n-            --  of options item (for this case Unix_String is null in the\n-            --  main switch item). The end of the list is marked by null.\n-\n-         when Id_Option =>\n-\n-            null;\n-            --  No special fields needed, since Name and Unix_String are\n-            --  sufficient to completely described an option.\n-\n-      end case;\n-   end record;\n-\n-   subtype Command_Item is Item (Id_Command);\n-   subtype Switch_Item  is Item (Id_Switch);\n-   subtype Option_Item  is Item (Id_Option);\n-\n    -------------------\n    -- Switch Tables --\n    -------------------"}]}