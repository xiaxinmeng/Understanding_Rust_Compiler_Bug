{"sha": "020d86db8896f088435830595640e6fc21bc64ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIwZDg2ZGI4ODk2ZjA4ODQzNTgzMDU5NTY0MGU2ZmMyMWJjNjRhZA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-05-29T13:40:40Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-05-29T13:44:13Z"}, "message": "c++: lambdas inside constraints [PR92652]\n\nWhen parsing a constraint-expression, a requires-clause or a\nrequires-expression, we temporarily increment processing_template_decl\nso that we always obtain template trees which we could later reduce via\nsubstitution even when not inside a template.\n\nBut incrementing processing_template_decl when we're already inside a\ntemplate has the unintended side effect of shifting up the template\nparameter levels of a lambda defined inside one of these constructs,\nwhich leads to confusion later during substitution into the lambda.\n\nThis patch fixes this issue by incrementing processing_template_decl\nduring parsing of these constructs only if it is 0.\n\nPasses 'make check-c++', and also tested by building cmcstl2, does this\nlook OK to commit after a full bootstrap/regtest?\n\ngcc/cp/ChangeLog:\n\n\tPR c++/92652\n\tPR c++/93698\n\tPR c++/94128\n\t* parser.c (cp_parser_requires_clause_expression): Temporarily\n\tincrement processing_template_decl only if it is 0.\n\t(cp_parser_constraint_expression): Likewise.\n\t(cp_parser_requires_expression): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/92652\n\tPR c++/93698\n\tPR c++/94128\n\t* g++.dg/cpp2a/concepts-lambda8.C: New test.\n\t* g++.dg/cpp2a/concepts-lambda9.C: New test.\n\t* g++.dg/cpp2a/concepts-lambda10.C: New test.", "tree": {"sha": "46a81ae2adc3ed593e8ae5b548f7b9bce73ceb2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46a81ae2adc3ed593e8ae5b548f7b9bce73ceb2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/020d86db8896f088435830595640e6fc21bc64ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/020d86db8896f088435830595640e6fc21bc64ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/020d86db8896f088435830595640e6fc21bc64ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/020d86db8896f088435830595640e6fc21bc64ad/comments", "author": null, "committer": null, "parents": [{"sha": "e069285cdf457cc85070e522380c4e25b0d2ed25", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e069285cdf457cc85070e522380c4e25b0d2ed25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e069285cdf457cc85070e522380c4e25b0d2ed25"}], "stats": {"total": 50, "additions": 44, "deletions": 6}, "files": [{"sha": "74c40efd936c940ea46c0c30c62f411e38908a8e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020d86db8896f088435830595640e6fc21bc64ad/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020d86db8896f088435830595640e6fc21bc64ad/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=020d86db8896f088435830595640e6fc21bc64ad", "patch": "@@ -27663,11 +27663,16 @@ static tree\n cp_parser_requires_clause_expression (cp_parser *parser, bool lambda_p)\n {\n   processing_constraint_expression_sentinel parsing_constraint;\n-  ++processing_template_decl;\n+  temp_override<int> ovr (processing_template_decl);\n+  if (!processing_template_decl)\n+    /* Adjust processing_template_decl so that we always obtain template\n+       trees here.  We don't do the usual ++processing_template_decl\n+       because that would skew the template parameter depth of a lambda\n+       within if we're already inside a template.  */\n+    processing_template_decl = 1;\n   cp_expr expr = cp_parser_constraint_logical_or_expression (parser, lambda_p);\n   if (check_for_bare_parameter_packs (expr))\n     expr = error_mark_node;\n-  --processing_template_decl;\n   return expr;\n }\n \n@@ -27684,12 +27689,14 @@ static tree\n cp_parser_constraint_expression (cp_parser *parser)\n {\n   processing_constraint_expression_sentinel parsing_constraint;\n-  ++processing_template_decl;\n+  temp_override<int> ovr (processing_template_decl);\n+  if (!processing_template_decl)\n+    /* As in cp_parser_requires_clause_expression.  */\n+    processing_template_decl = 1;\n   cp_expr expr = cp_parser_binary_expression (parser, false, true,\n \t\t\t\t\t      PREC_NOT_OPERATOR, NULL);\n   if (check_for_bare_parameter_packs (expr))\n     expr = error_mark_node;\n-  --processing_template_decl;\n   expr.maybe_add_location_wrapper ();\n   return expr;\n }\n@@ -27798,9 +27805,11 @@ cp_parser_requires_expression (cp_parser *parser)\n       parms = NULL_TREE;\n \n     /* Parse the requirement body. */\n-    ++processing_template_decl;\n+    temp_override<int> ovr (processing_template_decl);\n+    if (!processing_template_decl)\n+      /* As in cp_parser_requires_clause_expression.  */\n+      processing_template_decl = 1;\n     reqs = cp_parser_requirement_body (parser);\n-    --processing_template_decl;\n     if (reqs == error_mark_node)\n       return error_mark_node;\n   }"}, {"sha": "392da312b2805651a18792ce8ef942b6b31a506b", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda10.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020d86db8896f088435830595640e6fc21bc64ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020d86db8896f088435830595640e6fc21bc64ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda10.C?ref=020d86db8896f088435830595640e6fc21bc64ad", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/94128\n+// { dg-do compile { target c++20 } }\n+\n+void test(auto param)\n+requires requires{ { [](auto p){return p;}(param) }; };\n+\n+void test2() { test(1); }"}, {"sha": "c1c9be682d0eecd4fbf1df73d900b237dc07d3c1", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda8.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020d86db8896f088435830595640e6fc21bc64ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020d86db8896f088435830595640e6fc21bc64ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda8.C?ref=020d86db8896f088435830595640e6fc21bc64ad", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/92652\n+// { dg-do compile { target concepts } }\n+\n+template < typename T >\n+    requires ([]{return true ;}())\n+void h() { }\n+\n+int main()\n+{\n+    h<int>();\n+}"}, {"sha": "6b81ba0adac895d867fd599875adb9a450f074c9", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda9.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020d86db8896f088435830595640e6fc21bc64ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020d86db8896f088435830595640e6fc21bc64ad/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda9.C?ref=020d86db8896f088435830595640e6fc21bc64ad", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/93698\n+// { dg-do compile { target concepts } }\n+\n+#include <utility>\n+\n+template <int N>\n+concept foo = []<std::size_t... Is>(std::index_sequence<Is...>) constexpr {\n+  return (Is + ...) > 10;\n+}(std::make_index_sequence<N>());\n+\n+bool a = foo<7>;"}]}