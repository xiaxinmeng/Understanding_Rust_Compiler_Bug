{"sha": "2e3f842fe69ce4e74cfe18493429b807af271083", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUzZjg0MmZlNjljZTRlNzRjZmUxODQ5MzQyOWI4MDdhZjI3MTA4Mw==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2008-07-30T19:20:43Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2008-07-30T19:20:43Z"}, "message": "[multiple changes]\n\n2008-07-30  Joey Ye  <joey.ye@intel.com>\n\t    H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* builtins.c (expand_builtin_setjmp_receiver): Replace\n\tvirtual_incoming_args_rtx with crtl->args.internal_arg_pointer.\n\t(expand_builtin_apply_args_1): Likewise.\n\t(expand_builtin_longjmp): Need DRAP for stack alignment.\n\t(expand_builtin_apply): Likewise.\n\n\t* caller-save.c (setup_save_areas): Call assign_stack_local_1\n\tinstead of assign_stack_local to allow alignment reduction.\n\n\t* calls.c (emit_call_1): Need DRAP for stack alignment if\n\treturn pops.\n\t(expand_call): Replace virtual_incoming_args_rtx with\n\tcrtl->args.internal_arg_pointer.\n\t* stmt.c (expand_nl_goto_receiver): Likewise.\n\n\t* cfgexpand.c (get_decl_align_unit): Estimate stack variable\n\talignment and store to stack_alignment_estimated and\n\tmax_used_stack_slot_alignment.\n\t(expand_one_var): Likewise.\n\t(expand_stack_alignment): New function.\n\t(tree_expand_cfg): Initialize max_used_stack_slot_alignment\n\tand stack_alignment_estimated fields in rtl_data.  Call\n\texpand_stack_alignment at end.\n\n\t* defaults.h (INCOMING_STACK_BOUNDARY): New.\n\t(MAX_STACK_ALIGNMENT): Likewise.\n\t(MAX_SUPPORTED_STACK_ALIGNMENT): Likewise.\n\t(SUPPORTS_STACK_ALIGNMENT): Likewise.\n\n\t* emit-rtl.c (gen_reg_rtx): Estimate stack alignment for\n\tstack alignment when generating virtual registers.\n\n\t* function.c (assign_stack_local): Renamed to ...\n\t(assign_stack_local_1): This.  Add a parameter to indicate\n\tif it is OK to reduce alignment.\n\t(assign_stack_local): Use it.\n\t(instantiate_new_reg): Instantiate virtual incoming args rtx\n\tto vDRAP if stack realignment and DRAP is needed.\n\t(assign_parms): Collect parameter/return type alignment and\n\tcontribute to stack_alignment_estimated.\n\t(locate_and_pad_parm): Likewise.\n\t(get_arg_pointer_save_area): Replace virtual_incoming_args_rtx\n\twith crtl->args.internal_arg_pointer.\n\n\t* function.h (rtl_data): Add new field drap_reg,\n\tmax_used_stack_slot_alignment, stack_alignment_estimated,\n\tstack_realign_needed, need_drap, stack_realign_processed and\n\tstack_realign_finalized.\n\t(stack_realign_fp): New macro.\n\t(stack_realign_drap): Likewise.\n\n\t* global.c (compute_regsets): Frame pointer is needed when\n\tstack is realigned.  Can eliminate frame pointer when stack is\n\trealigned and dynamic realigned argument pointer isn't used.\n\n\t* reload1.c (update_eliminables):  Frame pointer is needed\n\twhen stack is realigned.\n\t(init_elim_table): Can eliminate frame pointer when stack is\n\trealigned and dynamic realigned argument pointer isn't used.\n\n\t* rtl.h (assign_stack_local_1): Declare new funtion.\n\n\t* target-def.h (TARGET_UPDATE_STACK_BOUNDARY): New.\n\t(TARGET_GET_DRAP_RTX): Likewise.\n\t(TARGET_CALLS): Add TARGET_UPDATE_STACK_BOUNDARY and\n\tTARGET_GET_DRAP_RTX.\n\n\t* target.h (gcc_target): Add update_stack_boundary and\n\tget_drap_rtx.\n\n\t* tree-vectorizer.c (vect_can_force_dr_alignment_p): Replace\n\tSTACK_BOUNDARY with MAX_STACK_ALIGNMENT.\n\n2008-07-30  Xuepeng Guo  <xuepeng.guo@intel.com>\n\t    H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* dwarf2out.c (dw_fde_struct): Add stack_realignment, drap_reg,\n\tvdrap_reg, stack_realign and drap_reg_saved.\n\t(add_cfi): Don't allow redefining CFA when DRAP is used.\n\t(reg_save): Handle stack alignment.\n\t(dwarf2out_frame_debug_expr): Add rules 16-20 to handle stack\n\talignment.  Don't generate DWARF information for (set fp sp)\n\twhen DRAP is used.\n\t(dwarf2out_begin_prologue): Initialize drap_reg and vdrap_reg\n\tto INVALID_REGNUM.\n\t(int_loc_descriptor): Move prototype forward.  Also define if\n\tDWARF2_UNWIND_INFO is true.\n\t(output_cfa_loc): Handle DW_CFA_expression.\n\t(build_cfa_aligned_loc): New.\n\t(based_loc_descr): Update assert for stack realign.  For local\n\tvariables, use sp+offset when stack is aligned without drap and\n\tfp+offset when stack is aligned with drap.  For arguments, use\n\tcfa+offset when drap is used to align stack.\n\n2008-07-30  Joey Ye  <joey.ye@intel.com>\n\t    H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* config/i386/i386.c (ix86_force_align_arg_pointer_string):\n\tBreak long line.\n\t(ix86_gen_andsp): New.\n\t(ix86_user_incoming_stack_boundary): Likewise.\n\t(ix86_default_incoming_stack_boundary): Likewise.\n\t(ix86_incoming_stack_boundary): Likewise.\n\t(ix86_can_eliminate): Likewise.\n\t(find_drap_reg): Likewise.\n\t(ix86_update_stack_boundary): Likewise.\n\t(ix86_get_drap_rtx): Likewise.\n\t(ix86_finalize_stack_realign_flags): Likewise.\n\t(TARGET_UPDATE_STACK_BOUNDARY): Likewise.\n\t(TARGET_GET_DRAP_RTX): Likewise.\n\t(override_options): Overide option value for new options.\n\t(ix86_function_ok_for_sibcall): Remove check for\n\tforce_align_arg_pointer.\n\t(ix86_handle_cconv_attribute): Likewise.\n\t(ix86_function_regparm): Likewise.\n\t(setup_incoming_varargs_64): Don't set stack_alignment_needed\n\there.\n\t(ix86_va_start): Replace virtual_incoming_args_rtx with\n\tcrtl->args.internal_arg_pointer.\n\t(ix86_select_alt_pic_regnum): Check DRAP register.\n\t(ix86_save_reg): Replace force_align_arg_pointer with drap_reg.\n\t(ix86_compute_frame_layout): Compute frame layout wrt stack\n\trealignment.\n\t(ix86_internal_arg_pointer): Just return\n\tvirtual_incoming_args_rtx.\n\t(ix86_expand_prologue): Decide if stack realignment is needed\n\tand generate prologue code accordingly.\n\t(ix86_expand_epilogue): Generate epilogue code wrt stack\n\trealignment is really needed or not.\n\t\n\t* config/i386/i386.h (MAIN_STACK_BOUNDARY): New.\n\t(ABI_STACK_BOUNDARY): Likewise.\n\t(PREFERRED_STACK_BOUNDARY_DEFAULT): Likewise.\n\t(STACK_REALIGN_DEFAULT): Likewise.\n\t(INCOMING_STACK_BOUNDARY): Likewise.\n\t(MAX_STACK_ALIGNMENT): Likewise.\n\t(ix86_incoming_stack_boundary): Likewise.\n\t(FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN): Removed.\n\t(REAL_PIC_OFFSET_TABLE_REGNUM): Updated to use BX_REG.\n\t(CAN_ELIMINATE): Defined with ix86_can_eliminate.\n\t(machine_function): Remove force_align_arg_pointer.\n\n\t* config/i386/i386.md (BX_REG): New.\n\t(R13_REG): Likewise.\n\n\t* config/i386/i386.opt (mforce_drap): New.\n\t(mincoming-stack-boundary): Likewise.\n\t(mstackrealign): Add Init(-1).\n\n\t* config/i386/i386-protos.h (ix86_can_eliminate): New\n\n2008-07-30  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* doc/extend.texi: Update force_align_arg_pointer.\n\n\t* doc/invoke.texi: Document -mincoming-stack-boundary.  Update\n\t-mstackrealign.\n\n\t* doc/tm.texi (MAX_STACK_ALIGNMENT): Add macro.\n\t(INCOMING_STACK_BOUNDARY): Likewise.\n\t(TARGET_UPDATE_STACK_BOUNDARY): New target hook.\n\t(TARGET_GET_DRAP_RTX): Likewise.\n\nFrom-SVN: r138335", "tree": {"sha": "9703441244044dbd6ab33443385887297f540e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9703441244044dbd6ab33443385887297f540e4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e3f842fe69ce4e74cfe18493429b807af271083", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3f842fe69ce4e74cfe18493429b807af271083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e3f842fe69ce4e74cfe18493429b807af271083", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3f842fe69ce4e74cfe18493429b807af271083/comments", "author": null, "committer": null, "parents": [{"sha": "22129589211764a55ee21f9202ab80b3772817b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22129589211764a55ee21f9202ab80b3772817b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22129589211764a55ee21f9202ab80b3772817b6"}], "stats": {"total": 1444, "additions": 1239, "deletions": 205}, "files": [{"sha": "bc455ab423fcb8a063a6f4387c542fc747faf5db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -1,3 +1,169 @@\n+2008-07-30  Joey Ye  <joey.ye@intel.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* builtins.c (expand_builtin_setjmp_receiver): Replace\n+\tvirtual_incoming_args_rtx with crtl->args.internal_arg_pointer.\n+\t(expand_builtin_apply_args_1): Likewise.\n+\t(expand_builtin_longjmp): Need DRAP for stack alignment.\n+\t(expand_builtin_apply): Likewise.\n+\n+\t* caller-save.c (setup_save_areas): Call assign_stack_local_1\n+\tinstead of assign_stack_local to allow alignment reduction.\n+\n+\t* calls.c (emit_call_1): Need DRAP for stack alignment if\n+\treturn pops.\n+\t(expand_call): Replace virtual_incoming_args_rtx with\n+\tcrtl->args.internal_arg_pointer.\n+\t* stmt.c (expand_nl_goto_receiver): Likewise.\n+\n+\t* cfgexpand.c (get_decl_align_unit): Estimate stack variable\n+\talignment and store to stack_alignment_estimated and\n+\tmax_used_stack_slot_alignment.\n+\t(expand_one_var): Likewise.\n+\t(expand_stack_alignment): New function.\n+\t(tree_expand_cfg): Initialize max_used_stack_slot_alignment\n+\tand stack_alignment_estimated fields in rtl_data.  Call\n+\texpand_stack_alignment at end.\n+\n+\t* defaults.h (INCOMING_STACK_BOUNDARY): New.\n+\t(MAX_STACK_ALIGNMENT): Likewise.\n+\t(MAX_SUPPORTED_STACK_ALIGNMENT): Likewise.\n+\t(SUPPORTS_STACK_ALIGNMENT): Likewise.\n+\n+\t* emit-rtl.c (gen_reg_rtx): Estimate stack alignment for\n+\tstack alignment when generating virtual registers.\n+\n+\t* function.c (assign_stack_local): Renamed to ...\n+\t(assign_stack_local_1): This.  Add a parameter to indicate\n+\tif it is OK to reduce alignment.\n+\t(assign_stack_local): Use it.\n+\t(instantiate_new_reg): Instantiate virtual incoming args rtx\n+\tto vDRAP if stack realignment and DRAP is needed.\n+\t(assign_parms): Collect parameter/return type alignment and\n+\tcontribute to stack_alignment_estimated.\n+\t(locate_and_pad_parm): Likewise.\n+\t(get_arg_pointer_save_area): Replace virtual_incoming_args_rtx\n+\twith crtl->args.internal_arg_pointer.\n+\n+\t* function.h (rtl_data): Add new field drap_reg,\n+\tmax_used_stack_slot_alignment, stack_alignment_estimated,\n+\tstack_realign_needed, need_drap, stack_realign_processed and\n+\tstack_realign_finalized.\n+\t(stack_realign_fp): New macro.\n+\t(stack_realign_drap): Likewise.\n+\n+\t* global.c (compute_regsets): Frame pointer is needed when\n+\tstack is realigned.  Can eliminate frame pointer when stack is\n+\trealigned and dynamic realigned argument pointer isn't used.\n+\n+\t* reload1.c (update_eliminables):  Frame pointer is needed\n+\twhen stack is realigned.\n+\t(init_elim_table): Can eliminate frame pointer when stack is\n+\trealigned and dynamic realigned argument pointer isn't used.\n+\n+\t* rtl.h (assign_stack_local_1): Declare new funtion.\n+\n+\t* target-def.h (TARGET_UPDATE_STACK_BOUNDARY): New.\n+\t(TARGET_GET_DRAP_RTX): Likewise.\n+\t(TARGET_CALLS): Add TARGET_UPDATE_STACK_BOUNDARY and\n+\tTARGET_GET_DRAP_RTX.\n+\n+\t* target.h (gcc_target): Add update_stack_boundary and\n+\tget_drap_rtx.\n+\n+\t* tree-vectorizer.c (vect_can_force_dr_alignment_p): Replace\n+\tSTACK_BOUNDARY with MAX_STACK_ALIGNMENT.\n+\n+2008-07-30  Xuepeng Guo  <xuepeng.guo@intel.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* dwarf2out.c (dw_fde_struct): Add stack_realignment, drap_reg,\n+\tvdrap_reg, stack_realign and drap_reg_saved.\n+\t(add_cfi): Don't allow redefining CFA when DRAP is used.\n+\t(reg_save): Handle stack alignment.\n+\t(dwarf2out_frame_debug_expr): Add rules 16-20 to handle stack\n+\talignment.  Don't generate DWARF information for (set fp sp)\n+\twhen DRAP is used.\n+\t(dwarf2out_begin_prologue): Initialize drap_reg and vdrap_reg\n+\tto INVALID_REGNUM.\n+\t(int_loc_descriptor): Move prototype forward.  Also define if\n+\tDWARF2_UNWIND_INFO is true.\n+\t(output_cfa_loc): Handle DW_CFA_expression.\n+\t(build_cfa_aligned_loc): New.\n+\t(based_loc_descr): Update assert for stack realign.  For local\n+\tvariables, use sp+offset when stack is aligned without drap and\n+\tfp+offset when stack is aligned with drap.  For arguments, use\n+\tcfa+offset when drap is used to align stack.\n+\n+2008-07-30  Joey Ye  <joey.ye@intel.com>\n+\t    H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/i386/i386.c (ix86_force_align_arg_pointer_string):\n+\tBreak long line.\n+\t(ix86_gen_andsp): New.\n+\t(ix86_user_incoming_stack_boundary): Likewise.\n+\t(ix86_default_incoming_stack_boundary): Likewise.\n+\t(ix86_incoming_stack_boundary): Likewise.\n+\t(ix86_can_eliminate): Likewise.\n+\t(find_drap_reg): Likewise.\n+\t(ix86_update_stack_boundary): Likewise.\n+\t(ix86_get_drap_rtx): Likewise.\n+\t(ix86_finalize_stack_realign_flags): Likewise.\n+\t(TARGET_UPDATE_STACK_BOUNDARY): Likewise.\n+\t(TARGET_GET_DRAP_RTX): Likewise.\n+\t(override_options): Overide option value for new options.\n+\t(ix86_function_ok_for_sibcall): Remove check for\n+\tforce_align_arg_pointer.\n+\t(ix86_handle_cconv_attribute): Likewise.\n+\t(ix86_function_regparm): Likewise.\n+\t(setup_incoming_varargs_64): Don't set stack_alignment_needed\n+\there.\n+\t(ix86_va_start): Replace virtual_incoming_args_rtx with\n+\tcrtl->args.internal_arg_pointer.\n+\t(ix86_select_alt_pic_regnum): Check DRAP register.\n+\t(ix86_save_reg): Replace force_align_arg_pointer with drap_reg.\n+\t(ix86_compute_frame_layout): Compute frame layout wrt stack\n+\trealignment.\n+\t(ix86_internal_arg_pointer): Just return\n+\tvirtual_incoming_args_rtx.\n+\t(ix86_expand_prologue): Decide if stack realignment is needed\n+\tand generate prologue code accordingly.\n+\t(ix86_expand_epilogue): Generate epilogue code wrt stack\n+\trealignment is really needed or not.\n+\t\n+\t* config/i386/i386.h (MAIN_STACK_BOUNDARY): New.\n+\t(ABI_STACK_BOUNDARY): Likewise.\n+\t(PREFERRED_STACK_BOUNDARY_DEFAULT): Likewise.\n+\t(STACK_REALIGN_DEFAULT): Likewise.\n+\t(INCOMING_STACK_BOUNDARY): Likewise.\n+\t(MAX_STACK_ALIGNMENT): Likewise.\n+\t(ix86_incoming_stack_boundary): Likewise.\n+\t(FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN): Removed.\n+\t(REAL_PIC_OFFSET_TABLE_REGNUM): Updated to use BX_REG.\n+\t(CAN_ELIMINATE): Defined with ix86_can_eliminate.\n+\t(machine_function): Remove force_align_arg_pointer.\n+\n+\t* config/i386/i386.md (BX_REG): New.\n+\t(R13_REG): Likewise.\n+\n+\t* config/i386/i386.opt (mforce_drap): New.\n+\t(mincoming-stack-boundary): Likewise.\n+\t(mstackrealign): Add Init(-1).\n+\n+\t* config/i386/i386-protos.h (ix86_can_eliminate): New\n+\n+2008-07-30  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* doc/extend.texi: Update force_align_arg_pointer.\n+\n+\t* doc/invoke.texi: Document -mincoming-stack-boundary.  Update\n+\t-mstackrealign.\n+\n+\t* doc/tm.texi (MAX_STACK_ALIGNMENT): Add macro.\n+\t(INCOMING_STACK_BOUNDARY): Likewise.\n+\t(TARGET_UPDATE_STACK_BOUNDARY): New target hook.\n+\t(TARGET_GET_DRAP_RTX): Likewise.\n+\n 2008-07-30  Andreas Schwab  <schwab@suse.de>\n \n \tPR rtl-optimization/36929"}, {"sha": "9a9c6a33b5143fa59f26a5907c2b6af576e40a7b", "filename": "gcc/builtins.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -743,7 +743,7 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n \t{\n \t  /* Now restore our arg pointer from the address at which it\n \t     was saved in our stack frame.  */\n-\t  emit_move_insn (virtual_incoming_args_rtx,\n+\t  emit_move_insn (crtl->args.internal_arg_pointer,\n \t\t\t  copy_to_reg (get_arg_pointer_save_area ()));\n \t}\n     }\n@@ -778,6 +778,11 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n   rtx fp, lab, stack, insn, last;\n   enum machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n \n+  /* DRAP is needed for stack realign if longjmp is expanded to current \n+     function  */\n+  if (SUPPORTS_STACK_ALIGNMENT)\n+    crtl->need_drap = true;\n+\n   if (setjmp_alias_set == -1)\n     setjmp_alias_set = new_alias_set ();\n \n@@ -1345,7 +1350,7 @@ expand_builtin_apply_args_1 (void)\n       }\n \n   /* Save the arg pointer to the block.  */\n-  tem = copy_to_reg (virtual_incoming_args_rtx);\n+  tem = copy_to_reg (crtl->args.internal_arg_pointer);\n #ifdef STACK_GROWS_DOWNWARD\n   /* We need the pointer as the caller actually passed them to us, not\n      as we might have pretended they were passed.  Make sure it's a valid\n@@ -1453,6 +1458,14 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n   /* Allocate a block of memory onto the stack and copy the memory\n      arguments to the outgoing arguments address.  */\n   allocate_dynamic_stack_space (argsize, 0, BITS_PER_UNIT);\n+\n+  /* Set DRAP flag to true, even though allocate_dynamic_stack_space\n+     may have already set current_function_calls_alloca to true.\n+     current_function_calls_alloca won't be set if argsize is zero,\n+     so we have to guarantee need_drap is true here.  */\n+  if (SUPPORTS_STACK_ALIGNMENT)\n+    crtl->need_drap = true;\n+\n   dest = virtual_outgoing_args_rtx;\n #ifndef STACK_GROWS_DOWNWARD\n   if (GET_CODE (argsize) == CONST_INT)"}, {"sha": "e3d76c654be8184e11c82156ac1edc6adb772553", "filename": "gcc/caller-save.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -356,10 +356,16 @@ setup_save_areas (void)\n \tif (! do_save)\n \t  continue;\n \n-\t/* We have found an acceptable mode to store in.  */\n+\t/* We have found an acceptable mode to store in.  Since hard\n+\t   register is always saved in the widest mode available,\n+\t   the mode may be wider than necessary, it is OK to reduce\n+\t   the alignment of spill space.  We will verify that it is\n+\t   equal to or greater than required when we restore and save\n+\t   the hard register in insert_restore and insert_save.  */\n \tregno_save_mem[i][j]\n-\t  = assign_stack_local (regno_save_mode[i][j],\n-\t\t\t\tGET_MODE_SIZE (regno_save_mode[i][j]), 0);\n+\t  = assign_stack_local_1 (regno_save_mode[i][j],\n+\t\t\t\tGET_MODE_SIZE (regno_save_mode[i][j]),\n+\t\t\t\t0, true);\n \n \t/* Setup single word save area just in case...  */\n \tfor (k = 0; k < j; k++)"}, {"sha": "d48c0d15654bcc6c3bbe6d043775f906c2c0884d", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -415,6 +415,10 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n       rounded_stack_size -= n_popped;\n       rounded_stack_size_rtx = GEN_INT (rounded_stack_size);\n       stack_pointer_delta -= n_popped;\n+\n+      /* If popup is needed, stack realign must use DRAP  */\n+      if (SUPPORTS_STACK_ALIGNMENT)\n+        crtl->need_drap = true;\n     }\n \n   if (!ACCUMULATE_OUTGOING_ARGS)\n@@ -2405,7 +2409,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t incoming argument block.  */\n       if (pass == 0)\n \t{\n-\t  argblock = virtual_incoming_args_rtx;\n+\t  argblock = crtl->args.internal_arg_pointer;\n \t  argblock\n #ifdef STACK_GROWS_DOWNWARD\n \t    = plus_constant (argblock, crtl->args.pretend_args_size);"}, {"sha": "623ad85afb4d269724f9e34e59960ad4948a2b5a", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 107, "deletions": 2, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -499,10 +499,25 @@ get_decl_align_unit (tree decl)\n \n   align = DECL_ALIGN (decl);\n   align = LOCAL_ALIGNMENT (TREE_TYPE (decl), align);\n-  if (align > PREFERRED_STACK_BOUNDARY)\n-    align = PREFERRED_STACK_BOUNDARY;\n+\n+  if (align > MAX_SUPPORTED_STACK_ALIGNMENT)\n+    align = MAX_SUPPORTED_STACK_ALIGNMENT;\n+\n+  if (SUPPORTS_STACK_ALIGNMENT)\n+    {\n+      if (crtl->stack_alignment_estimated < align)\n+\t{\n+\t  gcc_assert(!crtl->stack_realign_processed);\n+          crtl->stack_alignment_estimated = align;\n+\t}\n+    }\n+\n+  /* stack_alignment_needed > PREFERRED_STACK_BOUNDARY is permitted.\n+     So here we only make sure stack_alignment_needed >= align.  */\n   if (crtl->stack_alignment_needed < align)\n     crtl->stack_alignment_needed = align;\n+  if (crtl->max_used_stack_slot_alignment < crtl->stack_alignment_needed)\n+    crtl->max_used_stack_slot_alignment = crtl->stack_alignment_needed;\n \n   return align / BITS_PER_UNIT;\n }\n@@ -1059,6 +1074,31 @@ defer_stack_allocation (tree var, bool toplevel)\n static HOST_WIDE_INT\n expand_one_var (tree var, bool toplevel, bool really_expand)\n {\n+  if (SUPPORTS_STACK_ALIGNMENT\n+      && TREE_TYPE (var) != error_mark_node\n+      && TREE_CODE (var) == VAR_DECL)\n+    {\n+      unsigned int align;\n+\n+      /* Because we don't know if VAR will be in register or on stack,\n+\t we conservatively assume it will be on stack even if VAR is\n+\t eventually put into register after RA pass.  For non-automatic\n+\t variables, which won't be on stack, we collect alignment of\n+\t type and ignore user specified alignment.  */\n+      if (TREE_STATIC (var) || DECL_EXTERNAL (var))\n+\talign = TYPE_ALIGN (TREE_TYPE (var));\n+      else\n+\talign = DECL_ALIGN (var);\n+\n+      if (crtl->stack_alignment_estimated < align)\n+        {\n+          /* stack_alignment_estimated shouldn't change after stack\n+             realign decision made */\n+          gcc_assert(!crtl->stack_realign_processed);\n+\t  crtl->stack_alignment_estimated = align;\n+\t}\n+    }\n+\n   if (TREE_CODE (var) != VAR_DECL)\n     ;\n   else if (DECL_EXTERNAL (var))\n@@ -2136,6 +2176,66 @@ discover_nonconstant_array_refs (void)\n       }\n }\n \n+/* This function sets crtl->args.internal_arg_pointer to a virtual\n+   register if DRAP is needed.  Local register allocator will replace\n+   virtual_incoming_args_rtx with the virtual register.  */\n+\n+static void\n+expand_stack_alignment (void)\n+{\n+  rtx drap_rtx;\n+  unsigned int preferred_stack_boundary;\n+\n+  if (! SUPPORTS_STACK_ALIGNMENT)\n+    return;\n+  \n+  if (cfun->calls_alloca\n+      || cfun->has_nonlocal_label\n+      || crtl->has_nonlocal_goto)\n+    crtl->need_drap = true;\n+\n+  gcc_assert (crtl->stack_alignment_needed\n+\t      <= crtl->stack_alignment_estimated);\n+\n+  /* Update stack boundary if needed.  */\n+  if (targetm.calls.update_stack_boundary)\n+    targetm.calls.update_stack_boundary (); \n+\n+  /* Update crtl->stack_alignment_estimated and use it later to align\n+     stack.  We check PREFERRED_STACK_BOUNDARY if there may be non-call\n+     exceptions since callgraph doesn't collect incoming stack alignment\n+     in this case.  */\n+  if (flag_non_call_exceptions\n+      && PREFERRED_STACK_BOUNDARY > crtl->preferred_stack_boundary)\n+    preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+  else\n+    preferred_stack_boundary = crtl->preferred_stack_boundary;\n+  if (preferred_stack_boundary > crtl->stack_alignment_estimated)\n+    crtl->stack_alignment_estimated = preferred_stack_boundary;\n+  if (preferred_stack_boundary > crtl->stack_alignment_needed)\n+    crtl->stack_alignment_needed = preferred_stack_boundary;\n+\n+  crtl->stack_realign_needed\n+    = INCOMING_STACK_BOUNDARY < crtl->stack_alignment_estimated;\n+\n+  crtl->stack_realign_processed = true;\n+\n+  /* Target has to redefine TARGET_GET_DRAP_RTX to support stack\n+     alignment.  */\n+  gcc_assert (targetm.calls.get_drap_rtx != NULL);\n+  drap_rtx = targetm.calls.get_drap_rtx (); \n+\n+  /* Do nothing if NULL is returned, which means DRAP is not needed.  */\n+  if (NULL != drap_rtx)\n+    {\n+      crtl->args.internal_arg_pointer = drap_rtx;\n+\n+      /* Call fixup_tail_calls to clean up REG_EQUIV note if DRAP is\n+         needed. */\n+      fixup_tail_calls ();\n+    }\n+}\n+\n /* Translate the intermediate representation contained in the CFG\n    from GIMPLE trees to RTL.\n \n@@ -2174,6 +2274,8 @@ gimple_expand_cfg (void)\n \n   targetm.expand_to_rtl_hook ();\n   crtl->stack_alignment_needed = STACK_BOUNDARY;\n+  crtl->max_used_stack_slot_alignment = STACK_BOUNDARY;\n+  crtl->stack_alignment_estimated = STACK_BOUNDARY;\n   crtl->preferred_stack_boundary = STACK_BOUNDARY;\n   cfun->cfg->max_jumptable_ents = 0;\n \n@@ -2248,6 +2350,9 @@ gimple_expand_cfg (void)\n   sbitmap_free (blocks);\n \n   compact_blocks ();\n+\n+  expand_stack_alignment ();\n+\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif"}, {"sha": "3276bd8e2022c2dc352d9cdefded342123425d47", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -28,6 +28,7 @@ extern int ix86_frame_pointer_required (void);\n extern void ix86_setup_frame_addresses (void);\n \n extern void ix86_file_end (void);\n+extern int ix86_can_eliminate (int, int);\n extern HOST_WIDE_INT ix86_initial_elimination_offset (int, int);\n extern void ix86_expand_prologue (void);\n extern void ix86_expand_epilogue (int);"}, {"sha": "c9cbe69b262bbcba1a808f7a70aaa209e7794676", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 351, "deletions": 129, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -1708,7 +1708,8 @@ static int ix86_regparm;\n \n /* -mstackrealign option */\n extern int ix86_force_align_arg_pointer;\n-static const char ix86_force_align_arg_pointer_string[] = \"force_align_arg_pointer\";\n+static const char ix86_force_align_arg_pointer_string[]\n+  = \"force_align_arg_pointer\";\n \n static rtx (*ix86_gen_leave) (void);\n static rtx (*ix86_gen_pop1) (rtx);\n@@ -1717,10 +1718,21 @@ static rtx (*ix86_gen_sub3) (rtx, rtx, rtx);\n static rtx (*ix86_gen_sub3_carry) (rtx, rtx, rtx, rtx);\n static rtx (*ix86_gen_one_cmpl2) (rtx, rtx);\n static rtx (*ix86_gen_monitor) (rtx, rtx, rtx);\n+static rtx (*ix86_gen_andsp) (rtx, rtx, rtx);\n \n /* Preferred alignment for stack boundary in bits.  */\n unsigned int ix86_preferred_stack_boundary;\n \n+/* Alignment for incoming stack boundary in bits specified at\n+   command line.  */\n+static unsigned int ix86_user_incoming_stack_boundary;\n+\n+/* Default alignment for incoming stack boundary in bits.  */\n+static unsigned int ix86_default_incoming_stack_boundary;\n+\n+/* Alignment for incoming stack boundary in bits.  */\n+unsigned int ix86_incoming_stack_boundary;\n+\n /* Values 1-5: see jump.c */\n int ix86_branch_cost;\n \n@@ -3015,11 +3027,9 @@ override_options (bool main_args_p)\n   if (TARGET_SSE4_2 || TARGET_ABM)\n     ix86_isa_flags |= OPTION_MASK_ISA_POPCNT & ~ix86_isa_flags_explicit;\n \n-  /* Validate -mpreferred-stack-boundary= value, or provide default.\n-     The default of 128 bits is for Pentium III's SSE __m128.  We can't\n-     change it because of optimize_size.  Otherwise, we can't mix object\n-     files compiled with -Os and -On.  */\n-  ix86_preferred_stack_boundary = 128;\n+  /* Validate -mpreferred-stack-boundary= value or default it to\n+     PREFERRED_STACK_BOUNDARY_DEFAULT.  */\n+  ix86_preferred_stack_boundary = PREFERRED_STACK_BOUNDARY_DEFAULT;\n   if (ix86_preferred_stack_boundary_string)\n     {\n       i = atoi (ix86_preferred_stack_boundary_string);\n@@ -3030,6 +3040,31 @@ override_options (bool main_args_p)\n \tix86_preferred_stack_boundary = (1 << i) * BITS_PER_UNIT;\n     }\n \n+  /* Set the default value for -mstackrealign.  */\n+  if (ix86_force_align_arg_pointer == -1)\n+    ix86_force_align_arg_pointer = STACK_REALIGN_DEFAULT;\n+\n+  /* Validate -mincoming-stack-boundary= value or default it to\n+     ABI_STACK_BOUNDARY/PREFERRED_STACK_BOUNDARY.  */\n+  if (ix86_force_align_arg_pointer)\n+    ix86_default_incoming_stack_boundary = ABI_STACK_BOUNDARY;\n+  else\n+    ix86_default_incoming_stack_boundary = PREFERRED_STACK_BOUNDARY;\n+  ix86_incoming_stack_boundary = ix86_default_incoming_stack_boundary;\n+  if (ix86_incoming_stack_boundary_string)\n+    {\n+      i = atoi (ix86_incoming_stack_boundary_string);\n+      if (i < (TARGET_64BIT ? 4 : 2) || i > 12)\n+\terror (\"-mincoming-stack-boundary=%d is not between %d and 12\",\n+\t       i, TARGET_64BIT ? 4 : 2);\n+      else\n+\t{\n+\t  ix86_user_incoming_stack_boundary = (1 << i) * BITS_PER_UNIT;\n+\t  ix86_incoming_stack_boundary\n+\t    = ix86_user_incoming_stack_boundary;\n+\t}\n+    }\n+\n   /* Accept -msseregparm only if at least SSE support is enabled.  */\n   if (TARGET_SSEREGPARM\n       && ! TARGET_SSE)\n@@ -3162,6 +3197,7 @@ override_options (bool main_args_p)\n       ix86_gen_sub3_carry = gen_subdi3_carry_rex64;\n       ix86_gen_one_cmpl2 = gen_one_cmpldi2;\n       ix86_gen_monitor = gen_sse3_monitor64;\n+      ix86_gen_andsp = gen_anddi3;\n     }\n   else\n     {\n@@ -3172,6 +3208,7 @@ override_options (bool main_args_p)\n       ix86_gen_sub3_carry = gen_subsi3_carry;\n       ix86_gen_one_cmpl2 = gen_one_cmplsi2;\n       ix86_gen_monitor = gen_sse3_monitor;\n+      ix86_gen_andsp = gen_andsi3;\n     }\n \n #ifdef USE_IX86_CLD\n@@ -4002,11 +4039,6 @@ ix86_function_ok_for_sibcall (tree decl, tree exp)\n       && ix86_function_regparm (TREE_TYPE (decl), NULL) >= 3)\n     return false;\n \n-  /* If we forced aligned the stack, then sibcalling would unalign the\n-     stack, which may break the called function.  */\n-  if (cfun->machine->force_align_arg_pointer)\n-    return false;\n-\n   /* Otherwise okay.  That also includes certain types of indirect calls.  */\n   return true;\n }\n@@ -4057,15 +4089,6 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n \t  *no_add_attrs = true;\n \t}\n \n-      if (!TARGET_64BIT\n-\t  && lookup_attribute (ix86_force_align_arg_pointer_string,\n-\t\t\t       TYPE_ATTRIBUTES (*node))\n-\t  && compare_tree_int (cst, REGPARM_MAX-1))\n-\t{\n-\t  error (\"%s functions limited to %d register parameters\",\n-\t\t ix86_force_align_arg_pointer_string, REGPARM_MAX-1);\n-\t}\n-\n       return NULL_TREE;\n     }\n \n@@ -4227,8 +4250,7 @@ ix86_function_regparm (const_tree type, const_tree decl)\n \t  /* We can't use regparm(3) for nested functions as these use\n \t     static chain pointer in third argument.  */\n \t  if (local_regparm == 3\n-\t      && (decl_function_context (decl)\n-                  || ix86_force_align_arg_pointer)\n+\t      && decl_function_context (decl)\n \t      && !DECL_NO_STATIC_CHAIN (decl))\n \t    local_regparm = 2;\n \n@@ -4237,13 +4259,11 @@ ix86_function_regparm (const_tree type, const_tree decl)\n \t     the callee DECL_STRUCT_FUNCTION is gone, so we fall back to\n \t     scanning the attributes for the self-realigning property.  */\n \t  f = DECL_STRUCT_FUNCTION (decl);\n-\t  if (local_regparm == 3\n-\t      && (f ? !!f->machine->force_align_arg_pointer\n-\t\t  : !!lookup_attribute (ix86_force_align_arg_pointer_string,\n-\t\t\t\t\tTYPE_ATTRIBUTES (TREE_TYPE (decl)))))\n-\t    local_regparm = 2;\n+          /* Since current internal arg pointer won't conflict with\n+\t     parameter passing regs, so no need to change stack\n+\t     realignment and adjust regparm number.\n \n-\t  /* Each fixed register usage increases register pressure,\n+\t     Each fixed register usage increases register pressure,\n \t     so less registers should be used for argument passing.\n \t     This functionality can be overriden by an explicit\n \t     regparm value.  */\n@@ -6154,14 +6174,6 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n \n   /* Indicate to allocate space on the stack for varargs save area.  */\n   ix86_save_varrargs_registers = 1;\n-  /* We need 16-byte stack alignment to save SSE registers.  If user\n-     asked for lower preferred_stack_boundary, lets just hope that he knows\n-     what he is doing and won't varargs SSE values.\n-\n-     We also may end up assuming that only 64bit values are stored in SSE\n-     register let some floating point program work.  */\n-  if (ix86_preferred_stack_boundary >= BIGGEST_ALIGNMENT)\n-    crtl->stack_alignment_needed = BIGGEST_ALIGNMENT;\n \n   save_area = frame_pointer_rtx;\n   set = get_varargs_alias_set ();\n@@ -6344,7 +6356,7 @@ ix86_va_start (tree valist, rtx nextarg)\n \n   /* Find the overflow area.  */\n   type = TREE_TYPE (ovf);\n-  t = make_tree (type, virtual_incoming_args_rtx);\n+  t = make_tree (type, crtl->args.internal_arg_pointer);\n   if (words != 0)\n     t = build2 (POINTER_PLUS_EXPR, type, t,\n \t        size_int (words * UNITS_PER_WORD));\n@@ -7101,9 +7113,14 @@ ix86_select_alt_pic_regnum (void)\n   if (current_function_is_leaf && !crtl->profile\n       && !ix86_current_function_calls_tls_descriptor)\n     {\n-      int i;\n+      int i, drap;\n+      /* Can't use the same register for both PIC and DRAP.  */\n+      if (crtl->drap_reg)\n+\tdrap = REGNO (crtl->drap_reg);\n+      else\n+\tdrap = -1;\n       for (i = 2; i >= 0; --i)\n-        if (!df_regs_ever_live_p (i))\n+        if (i != drap && !df_regs_ever_live_p (i))\n \t  return i;\n     }\n \n@@ -7139,8 +7156,8 @@ ix86_save_reg (unsigned int regno, int maybe_eh_return)\n \t}\n     }\n \n-  if (cfun->machine->force_align_arg_pointer\n-      && regno == REGNO (cfun->machine->force_align_arg_pointer))\n+  if (crtl->drap_reg\n+      && regno == REGNO (crtl->drap_reg))\n     return 1;\n \n   return (df_regs_ever_live_p (regno)\n@@ -7163,6 +7180,24 @@ ix86_nsaved_regs (void)\n   return nregs;\n }\n \n+/* Given FROM and TO register numbers, say whether this elimination is\n+   allowed.  If stack alignment is needed, we can only replace argument\n+   pointer with hard frame pointer, or replace frame pointer with stack\n+   pointer.  Otherwise, frame pointer elimination is automatically\n+   handled and all other eliminations are valid.  */\n+\n+int\n+ix86_can_eliminate (int from, int to)\n+{\n+  if (stack_realign_fp)\n+    return ((from == ARG_POINTER_REGNUM\n+\t     && to == HARD_FRAME_POINTER_REGNUM)\n+\t    || (from == FRAME_POINTER_REGNUM\n+\t\t&& to == STACK_POINTER_REGNUM));\n+  else\n+    return to == STACK_POINTER_REGNUM ? !frame_pointer_needed : 1;\n+}\n+\n /* Return the offset between two registers, one to be eliminated, and the other\n    its replacement, at the start of a routine.  */\n \n@@ -7206,6 +7241,10 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   stack_alignment_needed = crtl->stack_alignment_needed / BITS_PER_UNIT;\n   preferred_alignment = crtl->preferred_stack_boundary / BITS_PER_UNIT;\n \n+  gcc_assert (!size || stack_alignment_needed);\n+  gcc_assert (preferred_alignment >= STACK_BOUNDARY / BITS_PER_UNIT);\n+  gcc_assert (preferred_alignment <= stack_alignment_needed);\n+\n   /* During reload iteration the amount of registers saved can change.\n      Recompute the value as needed.  Do not recompute when amount of registers\n      didn't change as reload does multiple calls to the function and does not\n@@ -7248,18 +7287,9 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \n   frame->hard_frame_pointer_offset = offset;\n \n-  /* Do some sanity checking of stack_alignment_needed and\n-     preferred_alignment, since i386 port is the only using those features\n-     that may break easily.  */\n-\n-  gcc_assert (!size || stack_alignment_needed);\n-  gcc_assert (preferred_alignment >= STACK_BOUNDARY / BITS_PER_UNIT);\n-  gcc_assert (preferred_alignment <= PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT);\n-  gcc_assert (stack_alignment_needed\n-\t      <= PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT);\n-\n-  if (stack_alignment_needed < STACK_BOUNDARY / BITS_PER_UNIT)\n-    stack_alignment_needed = STACK_BOUNDARY / BITS_PER_UNIT;\n+  /* Set offset to aligned because the realigned frame tarts from here.  */\n+  if (stack_realign_fp)\n+    offset = (offset + stack_alignment_needed -1) & -stack_alignment_needed;\n \n   /* Register save area */\n   offset += frame->nregs * UNITS_PER_WORD;\n@@ -7425,38 +7455,131 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset, int style)\n     RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n-/* Handle the TARGET_INTERNAL_ARG_POINTER hook.  */\n+/* Find an available register to be used as dynamic realign argument\n+   pointer regsiter.  Such a register will be written in prologue and\n+   used in begin of body, so it must not be\n+\t1. parameter passing register.\n+\t2. GOT pointer.\n+   We reuse static-chain register if it is available.  Otherwise, we\n+   use DI for i386 and R13 for x86-64.  We chose R13 since it has\n+   shorter encoding.\n+\n+   Return: the regno of chosen register.  */\n+\n+static unsigned int \n+find_drap_reg (void)\n+{\n+  tree decl = cfun->decl;\n+\n+  if (TARGET_64BIT)\n+    {\n+      /* Use R13 for nested function or function need static chain.\n+\t Since function with tail call may use any caller-saved\n+\t registers in epilogue, DRAP must not use caller-saved\n+\t register in such case.  */\n+      if ((decl_function_context (decl)\n+\t   && !DECL_NO_STATIC_CHAIN (decl))\n+\t  || crtl->tail_call_emit)\n+\treturn R13_REG;\n+\n+      return R10_REG;\n+    }\n+  else\n+    {\n+      /* Use DI for nested function or function need static chain.\n+\t Since function with tail call may use any caller-saved\n+\t registers in epilogue, DRAP must not use caller-saved\n+\t register in such case.  */\n+      if ((decl_function_context (decl)\n+\t   && !DECL_NO_STATIC_CHAIN (decl))\n+\t  || crtl->tail_call_emit)\n+\treturn DI_REG;\n+    \n+      /* Reuse static chain register if it isn't used for parameter\n+         passing.  */\n+      if (ix86_function_regparm (TREE_TYPE (decl), decl) <= 2\n+\t  && !lookup_attribute (\"fastcall\",\n+    \t\t\t\tTYPE_ATTRIBUTES (TREE_TYPE (decl))))\n+\treturn CX_REG;\n+      else\n+\treturn DI_REG;\n+    }\n+}\n+\n+/* Update incoming stack boundary and estimated stack alignment.  */\n+\n+static void\n+ix86_update_stack_boundary (void)\n+{\n+  /* Prefer the one specified at command line. */\n+  ix86_incoming_stack_boundary \n+    = (ix86_user_incoming_stack_boundary\n+       ? ix86_user_incoming_stack_boundary\n+       : ix86_default_incoming_stack_boundary);\n+\n+  /* Incoming stack alignment can be changed on individual functions\n+     via force_align_arg_pointer attribute.  We use the smallest\n+     incoming stack boundary.  */\n+  if (ix86_incoming_stack_boundary > ABI_STACK_BOUNDARY\n+      && lookup_attribute (ix86_force_align_arg_pointer_string,\n+\t\t\t   TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))))\n+    ix86_incoming_stack_boundary = ABI_STACK_BOUNDARY;\n+\n+  /* Stack at entrance of main is aligned by runtime.  We use the\n+     smallest incoming stack boundary. */\n+  if (ix86_incoming_stack_boundary > MAIN_STACK_BOUNDARY\n+      && DECL_NAME (current_function_decl)\n+      && MAIN_NAME_P (DECL_NAME (current_function_decl))\n+      && DECL_FILE_SCOPE_P (current_function_decl))\n+    ix86_incoming_stack_boundary = MAIN_STACK_BOUNDARY;\n+\n+  /* x86_64 vararg needs 16byte stack alignment for register save\n+     area.  */\n+  if (TARGET_64BIT\n+      && cfun->stdarg\n+      && crtl->stack_alignment_estimated < 128)\n+    crtl->stack_alignment_estimated = 128;\n+}\n+\n+/* Handle the TARGET_GET_DRAP_RTX hook.  Return NULL if no DRAP is\n+   needed or an rtx for DRAP otherwise.  */\n \n static rtx\n-ix86_internal_arg_pointer (void)\n+ix86_get_drap_rtx (void)\n {\n-  bool has_force_align_arg_pointer =\n-    (0 != lookup_attribute (ix86_force_align_arg_pointer_string,\n-\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))));\n-  if ((FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n-       && DECL_NAME (current_function_decl)\n-       && MAIN_NAME_P (DECL_NAME (current_function_decl))\n-       && DECL_FILE_SCOPE_P (current_function_decl))\n-      || ix86_force_align_arg_pointer\n-      || has_force_align_arg_pointer)\n-    {\n-      /* Nested functions can't realign the stack due to a register\n-\t conflict.  */\n-      if (DECL_CONTEXT (current_function_decl)\n-\t  && TREE_CODE (DECL_CONTEXT (current_function_decl)) == FUNCTION_DECL)\n-\t{\n-\t  if (ix86_force_align_arg_pointer)\n-\t    warning (0, \"-mstackrealign ignored for nested functions\");\n-\t  if (has_force_align_arg_pointer)\n-\t    error (\"%s not supported for nested functions\",\n-\t\t   ix86_force_align_arg_pointer_string);\n-\t  return virtual_incoming_args_rtx;\n-\t}\n-      cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, CX_REG);\n-      return copy_to_reg (cfun->machine->force_align_arg_pointer);\n+  if (ix86_force_drap || !ACCUMULATE_OUTGOING_ARGS)\n+    crtl->need_drap = true;\n+\n+  if (stack_realign_drap)\n+    {\n+      /* Assign DRAP to vDRAP and returns vDRAP */\n+      unsigned int regno = find_drap_reg ();\n+      rtx drap_vreg;\n+      rtx arg_ptr;\n+      rtx seq, insn;\n+\n+      arg_ptr = gen_rtx_REG (Pmode, regno);\n+      crtl->drap_reg = arg_ptr;\n+\n+      start_sequence ();\n+      drap_vreg = copy_to_reg (arg_ptr);\n+      seq = get_insns ();\n+      end_sequence ();\n+      \n+      insn = emit_insn_before (seq, NEXT_INSN (entry_of_function ()));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      return drap_vreg;\n     }\n   else\n-    return virtual_incoming_args_rtx;\n+    return NULL;\n+}\n+\n+/* Handle the TARGET_INTERNAL_ARG_POINTER hook.  */\n+\n+static rtx\n+ix86_internal_arg_pointer (void)\n+{\n+  return virtual_incoming_args_rtx;\n }\n \n /* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.\n@@ -7483,6 +7606,31 @@ ix86_dwarf_handle_frame_unspec (const char *label, rtx pattern, int index)\n     }\n }\n \n+/* Finalize stack_realign_needed flag, which will guide prologue/epilogue\n+   to be generated in correct form.  */\n+static void \n+ix86_finalize_stack_realign_flags (void)\n+{\n+  /* Check if stack realign is really needed after reload, and \n+     stores result in cfun */\n+  unsigned int stack_realign = (ix86_incoming_stack_boundary\n+\t\t\t\t< (current_function_is_leaf\n+\t\t\t\t   ? crtl->max_used_stack_slot_alignment\n+\t\t\t\t   : crtl->stack_alignment_needed));\n+\n+  if (crtl->stack_realign_finalized)\n+    {\n+      /* After stack_realign_needed is finalized, we can't no longer\n+\t change it.  */\n+      gcc_assert (crtl->stack_realign_needed == stack_realign);\n+    }\n+  else\n+    {\n+      crtl->stack_realign_needed = stack_realign;\n+      crtl->stack_realign_finalized = true;\n+    }\n+}\n+\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -7493,52 +7641,58 @@ ix86_expand_prologue (void)\n   struct ix86_frame frame;\n   HOST_WIDE_INT allocate;\n \n+  ix86_finalize_stack_realign_flags ();\n+\n+  /* DRAP should not coexist with stack_realign_fp */\n+  gcc_assert (!(crtl->drap_reg && stack_realign_fp));\n+\n   ix86_compute_frame_layout (&frame);\n \n-  if (cfun->machine->force_align_arg_pointer)\n+  /* Emit prologue code to adjust stack alignment and setup DRAP, in case\n+     of DRAP is needed and stack realignment is really needed after reload */\n+  if (crtl->drap_reg && crtl->stack_realign_needed)\n     {\n       rtx x, y;\n+      int align_bytes = crtl->stack_alignment_needed / BITS_PER_UNIT;\n+      int param_ptr_offset = (call_used_regs[REGNO (crtl->drap_reg)]\n+\t\t\t      ? 0 : STACK_BOUNDARY / BITS_PER_UNIT);\n+\n+      gcc_assert (stack_realign_drap);\n \n       /* Grab the argument pointer.  */\n-      x = plus_constant (stack_pointer_rtx, 4);\n-      y = cfun->machine->force_align_arg_pointer;\n-      insn = emit_insn (gen_rtx_SET (VOIDmode, y, x));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n+      x = plus_constant (stack_pointer_rtx, \n+                         (STACK_BOUNDARY / BITS_PER_UNIT \n+\t\t\t  + param_ptr_offset));\n+      y = crtl->drap_reg;\n \n-      /* The unwind info consists of two parts: install the fafp as the cfa,\n-\t and record the fafp as the \"save register\" of the stack pointer.\n-\t The later is there in order that the unwinder can see where it\n-\t should restore the stack pointer across the and insn.  */\n-      x = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, const0_rtx), UNSPEC_DEF_CFA);\n-      x = gen_rtx_SET (VOIDmode, y, x);\n-      RTX_FRAME_RELATED_P (x) = 1;\n-      y = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, stack_pointer_rtx),\n-\t\t\t  UNSPEC_REG_SAVE);\n-      y = gen_rtx_SET (VOIDmode, cfun->machine->force_align_arg_pointer, y);\n-      RTX_FRAME_RELATED_P (y) = 1;\n-      x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, x, y));\n-      x = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, x, NULL);\n-      REG_NOTES (insn) = x;\n+      /* Only need to push parameter pointer reg if it is caller\n+\t saved reg */\n+      if (!call_used_regs[REGNO (crtl->drap_reg)])\n+\t{\n+\t  /* Push arg pointer reg */\n+\t  insn = emit_insn (gen_push (y));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t}\n+\n+      insn = emit_insn (gen_rtx_SET (VOIDmode, y, x));\n+      RTX_FRAME_RELATED_P (insn) = 1; \n \n       /* Align the stack.  */\n-      emit_insn (gen_andsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t     GEN_INT (-16)));\n-\n-      /* And here we cheat like madmen with the unwind info.  We force the\n-\t cfa register back to sp+4, which is exactly what it was at the\n-\t start of the function.  Re-pushing the return address results in\n-\t the return at the same spot relative to the cfa, and thus is\n-\t correct wrt the unwind info.  */\n-      x = cfun->machine->force_align_arg_pointer;\n-      x = gen_frame_mem (Pmode, plus_constant (x, -4));\n-      insn = emit_insn (gen_push (x));\n+      insn = emit_insn ((*ix86_gen_andsp) (stack_pointer_rtx,\n+\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t   GEN_INT (-align_bytes)));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n-      x = GEN_INT (4);\n-      x = gen_rtx_UNSPEC (VOIDmode, gen_rtvec (1, x), UNSPEC_DEF_CFA);\n-      x = gen_rtx_SET (VOIDmode, stack_pointer_rtx, x);\n-      x = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, x, NULL);\n-      REG_NOTES (insn) = x;\n+      /* Replicate the return address on the stack so that return\n+\t address can be reached via (argp - 1) slot.  This is needed\n+\t to implement macro RETURN_ADDR_RTX and intrinsic function\n+\t expand_builtin_return_addr etc.  */\n+      x = crtl->drap_reg;\n+      x = gen_frame_mem (Pmode,\n+                         plus_constant (x,\n+\t\t\t\t\t-(STACK_BOUNDARY / BITS_PER_UNIT)));\n+      insn = emit_insn (gen_push (x));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   /* Note: AT&T enter does NOT have reversed args.  Enter is probably\n@@ -7553,6 +7707,18 @@ ix86_expand_prologue (void)\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  if (stack_realign_fp)\n+    {\n+      int align_bytes = crtl->stack_alignment_needed / BITS_PER_UNIT;\n+      gcc_assert (align_bytes > STACK_BOUNDARY / BITS_PER_UNIT);\n+\n+      /* Align the stack.  */\n+      insn = emit_insn ((*ix86_gen_andsp) (stack_pointer_rtx,\n+\t\t\t\t\t   stack_pointer_rtx,\n+\t\t\t\t\t   GEN_INT (-align_bytes)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n   allocate = frame.to_allocate;\n \n   if (!frame.save_regs_using_mov)\n@@ -7567,7 +7733,9 @@ ix86_expand_prologue (void)\n      a red zone location */\n   if (!TARGET_64BIT_MS_ABI && TARGET_RED_ZONE && frame.save_regs_using_mov\n       && (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT))\n-    ix86_emit_save_regs_using_mov (frame_pointer_needed ? hard_frame_pointer_rtx\n+    ix86_emit_save_regs_using_mov ((frame_pointer_needed\n+\t\t\t\t     && !crtl->stack_realign_needed) \n+                                   ? hard_frame_pointer_rtx\n \t\t\t\t   : stack_pointer_rtx,\n \t\t\t\t   -frame.nregs * UNITS_PER_WORD);\n \n@@ -7626,8 +7794,11 @@ ix86_expand_prologue (void)\n       && !(!TARGET_64BIT_MS_ABI && TARGET_RED_ZONE\n          && (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT)))\n     {\n-      if (!frame_pointer_needed || !frame.to_allocate)\n-        ix86_emit_save_regs_using_mov (stack_pointer_rtx, frame.to_allocate);\n+      if (!frame_pointer_needed\n+\t  || !frame.to_allocate\n+\t  || crtl->stack_realign_needed)\n+        ix86_emit_save_regs_using_mov (stack_pointer_rtx,\n+\t\t\t\t       frame.to_allocate);\n       else\n         ix86_emit_save_regs_using_mov (hard_frame_pointer_rtx,\n \t\t\t\t       -frame.nregs * UNITS_PER_WORD);\n@@ -7678,6 +7849,16 @@ ix86_expand_prologue (void)\n       emit_insn (gen_blockage ());\n     }\n \n+  if (crtl->drap_reg && !crtl->stack_realign_needed)\n+    {\n+      /* vDRAP is setup but after reload it turns out stack realign\n+         isn't necessary, here we will emit prologue to setup DRAP\n+         without stack realign adjustment */\n+      int drap_bp_offset = STACK_BOUNDARY / BITS_PER_UNIT * 2;\n+      rtx x = plus_constant (hard_frame_pointer_rtx, drap_bp_offset);\n+      insn = emit_insn (gen_rtx_SET (VOIDmode, crtl->drap_reg, x));\n+    }\n+\n   /* Emit cld instruction if stringops are used in the function.  */\n   if (TARGET_CLD && ix86_current_function_needs_cld)\n     emit_insn (gen_cld ());\n@@ -7719,10 +7900,17 @@ void\n ix86_expand_epilogue (int style)\n {\n   int regno;\n-  int sp_valid = !frame_pointer_needed || current_function_sp_is_unchanging;\n+  int sp_valid;\n   struct ix86_frame frame;\n   HOST_WIDE_INT offset;\n \n+  ix86_finalize_stack_realign_flags ();\n+\n+ /* When stack is realigned, SP must be valid.  */\n+  sp_valid = (!frame_pointer_needed\n+\t      || current_function_sp_is_unchanging\n+\t      || stack_realign_fp);\n+\n   ix86_compute_frame_layout (&frame);\n \n   /* Calculate start of saved registers relative to ebp.  Special care\n@@ -7756,11 +7944,16 @@ ix86_expand_epilogue (int style)\n     {\n       /* Restore registers.  We can use ebp or esp to address the memory\n \t locations.  If both are available, default to ebp, since offsets\n-\t are known to be small.  Only exception is esp pointing directly to the\n-\t end of block of saved registers, where we may simplify addressing\n-\t mode.  */\n+\t are known to be small.  Only exception is esp pointing directly\n+\t to the end of block of saved registers, where we may simplify\n+\t addressing mode.  \n+\n+\t If we are realigning stack with bp and sp, regs restore can't\n+\t be addressed by bp. sp must be used instead.  */\n \n-      if (!frame_pointer_needed || (sp_valid && !frame.to_allocate))\n+      if (!frame_pointer_needed\n+\t  || (sp_valid && !frame.to_allocate) \n+\t  || stack_realign_fp)\n \tix86_emit_restore_regs_using_mov (stack_pointer_rtx,\n \t\t\t\t\t  frame.to_allocate, style == 2);\n       else\n@@ -7772,6 +7965,9 @@ ix86_expand_epilogue (int style)\n \t{\n \t  rtx tmp, sa = EH_RETURN_STACKADJ_RTX;\n \n+\t  /* Stack align doesn't work with eh_return.  */\n+\t  gcc_assert (!crtl->stack_realign_needed);\n+\n \t  if (frame_pointer_needed)\n \t    {\n \t      tmp = gen_rtx_PLUS (Pmode, hard_frame_pointer_rtx, sa);\n@@ -7813,10 +8009,16 @@ ix86_expand_epilogue (int style)\n   else\n     {\n       /* First step is to deallocate the stack frame so that we can\n-\t pop the registers.  */\n+\t pop the registers.\n+\n+\t If we realign stack with frame pointer, then stack pointer\n+         won't be able to recover via lea $offset(%bp), %sp, because\n+         there is a padding area between bp and sp for realign. \n+         \"add $to_allocate, %sp\" must be used instead.  */\n       if (!sp_valid)\n \t{\n \t  gcc_assert (frame_pointer_needed);\n+          gcc_assert (!stack_realign_fp);\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t     hard_frame_pointer_rtx,\n \t\t\t\t     GEN_INT (offset), style);\n@@ -7835,15 +8037,31 @@ ix86_expand_epilogue (int style)\n \t  if (TARGET_USE_LEAVE)\n \t    emit_insn ((*ix86_gen_leave) ());\n \t  else\n-\t    emit_insn ((*ix86_gen_pop1) (hard_frame_pointer_rtx));\n+            {\n+              /* For stack realigned really happens, recover stack \n+                 pointer to hard frame pointer is a must, if not using \n+                 leave.  */\n+              if (stack_realign_fp)\n+\t\tpro_epilogue_adjust_stack (stack_pointer_rtx,\n+\t\t\t\t\t   hard_frame_pointer_rtx,\n+\t\t\t\t\t   const0_rtx, style);\n+\t      emit_insn ((*ix86_gen_pop1) (hard_frame_pointer_rtx));\n+            }\n \t}\n     }\n \n-  if (cfun->machine->force_align_arg_pointer)\n+  if (crtl->drap_reg && crtl->stack_realign_needed)\n     {\n-      emit_insn (gen_addsi3 (stack_pointer_rtx,\n-\t\t\t     cfun->machine->force_align_arg_pointer,\n-\t\t\t     GEN_INT (-4)));\n+      int param_ptr_offset = (call_used_regs[REGNO (crtl->drap_reg)]\n+\t\t\t      ? 0 : STACK_BOUNDARY / BITS_PER_UNIT);\n+      gcc_assert (stack_realign_drap);\n+      emit_insn ((*ix86_gen_add3) (stack_pointer_rtx,\n+\t\t\t\t   crtl->drap_reg,\n+\t\t\t\t   GEN_INT (-(STACK_BOUNDARY / BITS_PER_UNIT\n+\t\t\t\t\t      + param_ptr_offset))));\n+      if (!call_used_regs[REGNO (crtl->drap_reg)])\n+\temit_insn ((*ix86_gen_pop1) (crtl->drap_reg));\n+      \n     }\n \n   /* Sibcall epilogues don't want a return instruction.  */\n@@ -27275,6 +27493,10 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #define TARGET_PASS_BY_REFERENCE ix86_pass_by_reference\n #undef TARGET_INTERNAL_ARG_POINTER\n #define TARGET_INTERNAL_ARG_POINTER ix86_internal_arg_pointer\n+#undef TARGET_UPDATE_STACK_BOUNDARY\n+#define TARGET_UPDATE_STACK_BOUNDARY ix86_update_stack_boundary\n+#undef TARGET_GET_DRAP_RTX\n+#define TARGET_GET_DRAP_RTX ix86_get_drap_rtx\n #undef TARGET_DWARF_HANDLE_FRAME_UNSPEC\n #define TARGET_DWARF_HANDLE_FRAME_UNSPEC ix86_dwarf_handle_frame_unspec\n #undef TARGET_STRICT_ARGUMENT_NAMING"}, {"sha": "a98e278e9ad5f329b8731683e5869bebf65d8b4f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -648,16 +648,32 @@ enum target_cpu_default\n #define STACK_BOUNDARY\t(TARGET_64BIT && DEFAULT_ABI == MS_ABI ? 128 \\\n \t\t\t\t\t\t\t       : BITS_PER_WORD)\n \n+/* Stack boundary of the main function guaranteed by OS.  */\n+#define MAIN_STACK_BOUNDARY (TARGET_64BIT ? 128 : 32)\n+\n+/* Stack boundary guaranteed by ABI.  */\n+#define ABI_STACK_BOUNDARY (TARGET_64BIT ? 128 : 32)\n+\n /* Boundary (in *bits*) on which the stack pointer prefers to be\n    aligned; the compiler cannot rely on having this alignment.  */\n #define PREFERRED_STACK_BOUNDARY ix86_preferred_stack_boundary\n \n-/* As of July 2001, many runtimes do not align the stack properly when\n-   entering main.  This causes expand_main_function to forcibly align\n-   the stack, which results in aligned frames for functions called from\n-   main, though it does nothing for the alignment of main itself.  */\n-#define FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN \\\n-  (ix86_preferred_stack_boundary > STACK_BOUNDARY && !TARGET_64BIT)\n+/* It should be ABI_STACK_BOUNDARY.  But we set it to 128 bits for\n+   both 32bit and 64bit, to support codes that need 128 bit stack\n+   alignment for SSE instructions, but can't realign the stack.  */\n+#define PREFERRED_STACK_BOUNDARY_DEFAULT 128\n+\n+/* 1 if -mstackrealign should be turned on by default.  It will\n+   generate an alternate prologue and epilogue that realigns the\n+   runtime stack if nessary.  This supports mixing codes that keep a\n+   4-byte aligned stack, as specified by i386 psABI, with codes that\n+   need a 16-byte aligned stack, as required by SSE instructions.  If\n+   STACK_REALIGN_DEFAULT is 1 and PREFERRED_STACK_BOUNDARY_DEFAULT is\n+   128, stacks for all functions may be realigned.  */\n+#define STACK_REALIGN_DEFAULT 0\n+\n+/* Boundary (in *bits*) on which the incoming stack is aligned.  */\n+#define INCOMING_STACK_BOUNDARY ix86_incoming_stack_boundary\n \n /* Target OS keeps a vector-aligned (128-bit, 16-byte) stack.  This is\n    mandatory for the 64-bit ABI, and may or may not be true for other\n@@ -684,6 +700,9 @@ enum target_cpu_default\n \n #define BIGGEST_ALIGNMENT 128\n \n+/* Maximum stack alignment.  */\n+#define MAX_STACK_ALIGNMENT MAX_OFILE_ALIGNMENT\n+\n /* Decide whether a variable of mode MODE should be 128 bit aligned.  */\n #define ALIGN_MODE_128(MODE) \\\n  ((MODE) == XFmode || SSE_REG_MODE_P (MODE))\n@@ -1110,7 +1129,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n    the pic register when possible.  The change is visible after the\n    prologue has been emitted.  */\n \n-#define REAL_PIC_OFFSET_TABLE_REGNUM  3\n+#define REAL_PIC_OFFSET_TABLE_REGNUM  BX_REG\n \n #define PIC_OFFSET_TABLE_REGNUM\t\t\t\t\\\n   ((TARGET_64BIT && ix86_cmodel == CM_SMALL_PIC)\t\\\n@@ -1629,12 +1648,9 @@ typedef struct ix86_args {\n  { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\t\\\n \n /* Given FROM and TO register numbers, say whether this elimination is\n-   allowed.  Frame pointer elimination is automatically handled.\n-\n-   All other eliminations are valid.  */\n+   allowed.   */\n \n-#define CAN_ELIMINATE(FROM, TO) \\\n-  ((TO) == STACK_POINTER_REGNUM ? !frame_pointer_needed : 1)\n+#define CAN_ELIMINATE(FROM, TO) ix86_can_eliminate ((FROM), (TO))\n \n /* Define the offset between two registers, one to be eliminated, and the other\n    its replacement, at the start of a routine.  */\n@@ -2203,6 +2219,7 @@ enum asm_dialect {\n \n extern enum asm_dialect ix86_asm_dialect;\n extern unsigned int ix86_preferred_stack_boundary;\n+extern unsigned int ix86_incoming_stack_boundary;\n extern int ix86_branch_cost, ix86_section_threshold;\n \n /* Smallest class containing REGNO.  */\n@@ -2304,7 +2321,6 @@ struct machine_function GTY(())\n {\n   struct stack_local_entry *stack_locals;\n   const char *some_ld_name;\n-  rtx force_align_arg_pointer;\n   int save_varrargs_registers;\n   int accesses_prev_frame;\n   int optimize_mode_switching[MAX_386_ENTITIES];"}, {"sha": "2e737b10abefc01f1a653c2f799551d58873bdc8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -245,6 +245,7 @@\n   [(AX_REG\t\t\t 0)\n    (DX_REG\t\t\t 1)\n    (CX_REG\t\t\t 2)\n+   (BX_REG\t\t\t 3)\n    (SI_REG\t\t\t 4)\n    (DI_REG\t\t\t 5)\n    (BP_REG\t\t\t 6)\n@@ -254,6 +255,7 @@\n    (FPCR_REG\t\t\t19)\n    (R10_REG\t\t\t39)\n    (R11_REG\t\t\t40)\n+   (R13_REG\t\t\t42)\n   ])\n \n ;; Insns whose names begin with \"x86_\" are emitted by gen_FOO calls"}, {"sha": "fc59b77ac7b5dbac70eb9f221301eab07c07408a", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -112,6 +112,10 @@ mfancy-math-387\n Target RejectNegative Report InverseMask(NO_FANCY_MATH_387, USE_FANCY_MATH_387) Save\n Generate sin, cos, sqrt for FPU\n \n+mforce-drap\n+Target Report Var(ix86_force_drap)\n+Always use Dynamic Realigned Argument Pointer (DRAP) to realign stack\n+\n mfp-ret-in-387\n Target Report Mask(FLOAT_RETURNS) Save\n Return values of functions in FPU registers\n@@ -168,6 +172,10 @@ mpreferred-stack-boundary=\n Target RejectNegative Joined Var(ix86_preferred_stack_boundary_string)\n Attempt to keep stack aligned to this power of 2\n \n+mincoming-stack-boundary=\n+Target RejectNegative Joined Var(ix86_incoming_stack_boundary_string)\n+Assume incoming stack aligned to this power of 2\n+\n mpush-args\n Target Report InverseMask(NO_PUSH_ARGS, PUSH_ARGS) Save\n Use push instructions to save outgoing arguments\n@@ -193,7 +201,7 @@ Target RejectNegative Mask(SSEREGPARM) Save\n Use SSE register passing conventions for SF and DF mode\n \n mstackrealign\n-Target Report Var(ix86_force_align_arg_pointer)\n+Target Report Var(ix86_force_align_arg_pointer) Init(-1)\n Realign stack in prologue\n \n mstack-arg-probe"}, {"sha": "e68a0651a6727ab818ca46ca5269d50832614eb1", "filename": "gcc/defaults.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -563,6 +563,12 @@ along with GCC; see the file COPYING3.  If not see\n #define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n #endif\n \n+/* Set INCOMING_STACK_BOUNDARY to PREFERRED_STACK_BOUNDARY if it is not\n+   defined.  */\n+#ifndef INCOMING_STACK_BOUNDARY\n+#define INCOMING_STACK_BOUNDARY PREFERRED_STACK_BOUNDARY\n+#endif\n+\n #ifndef TARGET_DEFAULT_PACK_STRUCT\n #define TARGET_DEFAULT_PACK_STRUCT 0\n #endif\n@@ -950,6 +956,21 @@ along with GCC; see the file COPYING3.  If not see\n #define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 0\n #endif\n \n+/* MAX_STACK_ALIGNMENT is the maximum stack alignment guaranteed by\n+   the backend.  MAX_SUPPORTED_STACK_ALIGNMENT is the maximum best\n+   effort stack alignment supported by the backend.  If the backend\n+   supports stack alignment, MAX_SUPPORTED_STACK_ALIGNMENT and\n+   MAX_STACK_ALIGNMENT are the same.  Otherwise, the incoming stack\n+   boundary will limit the maximum guaranteed stack alignment.  */\n+#ifdef MAX_STACK_ALIGNMENT\n+#define MAX_SUPPORTED_STACK_ALIGNMENT MAX_STACK_ALIGNMENT\n+#else\n+#define MAX_STACK_ALIGNMENT STACK_BOUNDARY\n+#define MAX_SUPPORTED_STACK_ALIGNMENT PREFERRED_STACK_BOUNDARY\n+#endif\n+\n+#define SUPPORTS_STACK_ALIGNMENT (MAX_STACK_ALIGNMENT > STACK_BOUNDARY)\n+\n #ifndef LOCAL_ALIGNMENT\n #define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n #endif"}, {"sha": "9557ba3bad9803f49f7b717d5739223f9abf97e4", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -2959,15 +2959,9 @@ floating point arguments on the stack.\n @cindex @code{force_align_arg_pointer} attribute\n On the Intel x86, the @code{force_align_arg_pointer} attribute may be\n applied to individual function definitions, generating an alternate\n-prologue and epilogue that realigns the runtime stack.  This supports\n-mixing legacy codes that run with a 4-byte aligned stack with modern\n-codes that keep a 16-byte stack for SSE compatibility.  The alternate\n-prologue and epilogue are slower and bigger than the regular ones, and\n-the alternate prologue requires a scratch register; this lowers the\n-number of registers available if used in conjunction with the\n-@code{regparm} attribute.  The @code{force_align_arg_pointer}\n-attribute is incompatible with nested functions; this is considered a\n-hard error.\n+prologue and epilogue that realigns the runtime stack if necessary.\n+This supports mixing legacy codes that run with a 4-byte aligned stack\n+with modern codes that keep a 16-byte stack for SSE compatibility.\n \n @item resbank\n @cindex @code{resbank} attribute"}, {"sha": "764edc22b18fbb59a0d781c20f1a212de30e508a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -555,7 +555,9 @@ Objective-C and Objective-C++ Dialects}.\n -masm=@var{dialect}  -mno-fancy-math-387 @gol\n -mno-fp-ret-in-387  -msoft-float @gol\n -mno-wide-multiply  -mrtd  -malign-double @gol\n--mpreferred-stack-boundary=@var{num} -mcld -mcx16 -msahf -mrecip @gol\n+-mpreferred-stack-boundary=@var{num}\n+-mincoming-stack-boundary=@var{num}\n+-mcld -mcx16 -msahf -mrecip @gol\n -mmmx  -msse  -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -msse4 @gol\n -maes -mpclmul @gol\n -msse4a -m3dnow -mpopcnt -mabm -msse5 @gol\n@@ -10739,17 +10741,11 @@ when this option is used to set the precision to less than extended precision.\n \n @item -mstackrealign\n @opindex mstackrealign\n-Realign the stack at entry.  On the Intel x86, the\n-@option{-mstackrealign} option will generate an alternate prologue and\n-epilogue that realigns the runtime stack.  This supports mixing legacy\n-codes that keep a 4-byte aligned stack with modern codes that keep a\n-16-byte stack for SSE compatibility.  The alternate prologue and\n-epilogue are slower and bigger than the regular ones, and the\n-alternate prologue requires an extra scratch register; this lowers the\n-number of registers available if used in conjunction with the\n-@code{regparm} attribute.  The @option{-mstackrealign} option is\n-incompatible with the nested function prologue; this is considered a\n-hard error.  See also the attribute @code{force_align_arg_pointer},\n+Realign the stack at entry.  On the Intel x86, the @option{-mstackrealign}\n+option will generate an alternate prologue and epilogue that realigns the\n+runtime stack if necessary.  This supports mixing legacy codes that keep\n+a 4-byte aligned stack with modern codes that keep a 16-byte stack for\n+SSE compatibility.  See also the attribute @code{force_align_arg_pointer},\n applicable to individual functions.\n \n @item -mpreferred-stack-boundary=@var{num}\n@@ -10758,6 +10754,12 @@ Attempt to keep the stack boundary aligned to a 2 raised to @var{num}\n byte boundary.  If @option{-mpreferred-stack-boundary} is not specified,\n the default is 4 (16 bytes or 128 bits).\n \n+@item -mincoming-stack-boundary=@var{num}\n+@opindex mincoming-stack-boundary\n+Assume the incoming stack is aligned to a 2 raised to @var{num} byte\n+boundary.  If @option{-mincoming-stack-boundary} is not specified,\n+the one specified by @option{-mpreferred-stack-boundary} will be used.\n+\n On Pentium and PentiumPro, @code{double} and @code{long double} values\n should be aligned to an 8 byte boundary (see @option{-malign-double}) or\n suffer significant run time performance penalties.  On Pentium III, the"}, {"sha": "228af27d621d3aa4a5417b38add330249559ec43", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -1084,6 +1084,12 @@ macro must evaluate to a value equal to or larger than\n @code{STACK_BOUNDARY}.\n @end defmac\n \n+@defmac INCOMING_STACK_BOUNDARY\n+Define this macro if the incoming stack boundary may be different\n+from @code{PREFERRED_STACK_BOUNDARY}.  This macro must evaluate\n+to a value equal to or larger than @code{STACK_BOUNDARY}.\n+@end defmac\n+\n @defmac FUNCTION_BOUNDARY\n Alignment required for a function entry point, in bits.\n @end defmac\n@@ -1122,6 +1128,18 @@ field alignment has not been set by the\n @code{__attribute__ ((aligned (@var{n})))} construct.\n @end defmac\n \n+@defmac MAX_STACK_ALIGNMENT\n+Biggest stack alignment guaranteed by the backend.  Use this macro\n+to specify the maximum alignment of a variable on stack.\n+\n+If not defined, the default value is @code{STACK_BOUNDARY}.\n+\n+@c FIXME: The default should be @code{PREFERRED_STACK_BOUNDARY}.\n+@c But the fix for PR 32893 indicates that we can only guarantee\n+@c maximum stack alignment on stack up to @code{STACK_BOUNDARY}, not\n+@c @code{PREFERRED_STACK_BOUNDARY}, if stack alignment isn't supported.\n+@end defmac\n+\n @defmac MAX_OFILE_ALIGNMENT\n Biggest alignment supported by the object file format of this machine.\n Use this macro to limit the alignment which can be specified using the\n@@ -10586,6 +10604,17 @@ call stack unwinding.  It is used in declarations in @file{unwind-generic.h}\n and the associated definitions of those functions.\n @end defmac\n \n+@deftypefn {Target Hook} void TARGET_UPDATE_STACK_BOUNDARY (void)\n+Define this macro to update the current function stack boundary if\n+necessary.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} rtx TARGET_GET_DRAP_RTX (void)\n+Define this macro to an rtx for Dynamic Realign Argument Pointer if a\n+different argument pointer register is needed to access the function's\n+argument list when stack is aligned.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {bool} TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS (void)\n When optimization is disabled, this hook indicates whether or not\n arguments should be allocated to stack slots.  Normally, GCC allocates"}, {"sha": "72514a61a273a32266655c159b2401e9e5bfa017", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 267, "deletions": 11, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -239,9 +239,18 @@ typedef struct dw_fde_struct GTY(())\n   bool dw_fde_switched_sections;\n   dw_cfi_ref dw_fde_cfi;\n   unsigned funcdef_number;\n+  HOST_WIDE_INT stack_realignment;\n+  /* Dynamic realign argument pointer register.  */\n+  unsigned int drap_reg;\n+  /* Virtual dynamic realign argument pointer register.  */\n+  unsigned int vdrap_reg;\n   unsigned all_throwers_are_sibcalls : 1;\n   unsigned nothrow : 1;\n   unsigned uses_eh_lsda : 1;\n+  /* Whether we did stack realign in this call frame.  */\n+  unsigned stack_realign : 1;\n+  /* Whether dynamic realign argument pointer register has been saved.  */\n+  unsigned drap_reg_saved: 1;\n }\n dw_fde_node;\n \n@@ -388,6 +397,8 @@ static void get_cfa_from_loc_descr (dw_cfa_location *,\n \t\t\t\t    struct dw_loc_descr_struct *);\n static struct dw_loc_descr_struct *build_cfa_loc\n   (dw_cfa_location *, HOST_WIDE_INT);\n+static struct dw_loc_descr_struct *build_cfa_aligned_loc\n+  (HOST_WIDE_INT, HOST_WIDE_INT);\n static void def_cfa_1 (const char *, dw_cfa_location *);\n \n /* How to start an assembler comment.  */\n@@ -621,6 +632,23 @@ static inline void\n add_cfi (dw_cfi_ref *list_head, dw_cfi_ref cfi)\n {\n   dw_cfi_ref *p;\n+  dw_fde_ref fde = current_fde ();\n+\n+  /* When DRAP is used, CFA is defined with an expression.  Redefine\n+     CFA may lead to a different CFA value.   */\n+  if (fde && fde->drap_reg != INVALID_REGNUM)\n+    switch (cfi->dw_cfi_opc)\n+      {\n+        case DW_CFA_def_cfa_register:\n+        case DW_CFA_def_cfa_offset:\n+        case DW_CFA_def_cfa_offset_sf:\n+        case DW_CFA_def_cfa:\n+        case DW_CFA_def_cfa_sf:\n+\t  gcc_unreachable ();\n+\n+        default:\n+          break;\n+      }\n \n   /* Find the end of the chain.  */\n   for (p = list_head; (*p) != NULL; p = &(*p)->dw_cfi_next)\n@@ -880,10 +908,22 @@ static void\n reg_save (const char *label, unsigned int reg, unsigned int sreg, HOST_WIDE_INT offset)\n {\n   dw_cfi_ref cfi = new_cfi ();\n+  dw_fde_ref fde = current_fde ();\n \n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n \n-  if (sreg == INVALID_REGNUM)\n+  /* When stack is aligned, store REG using DW_CFA_expression with\n+     FP.  */\n+  if (fde\n+      && fde->stack_realign\n+      && sreg == INVALID_REGNUM)\n+    {\n+      cfi->dw_cfi_opc = DW_CFA_expression;\n+      cfi->dw_cfi_oprnd2.dw_cfi_reg_num = reg;\n+      cfi->dw_cfi_oprnd1.dw_cfi_loc\n+\t= build_cfa_aligned_loc (offset, fde->stack_realignment);\n+    }\n+  else if (sreg == INVALID_REGNUM)\n     {\n       if (reg & ~0x3f)\n \t/* The register number won't fit in 6 bits, so we have to use\n@@ -1445,6 +1485,11 @@ static dw_cfa_location cfa_temp;\n \t       difference of the original location and cfa_store's\n \t       location (or cfa_temp's location if cfa_temp is used).\n \n+  Rules 16-20: If AND operation happens on sp in prologue, we assume\n+\t       stack is realigned.  We will use a group of DW_OP_XXX\n+\t       expressions to represent the location of the stored\n+\t       register instead of CFA+offset.\n+\n   The Rules\n \n   \"{a,b}\" indicates a choice of a xor b.\n@@ -1538,13 +1583,48 @@ static dw_cfa_location cfa_temp;\n \n   Rule 15:\n   (set <reg> {unspec, unspec_volatile})\n-  effects: target-dependent  */\n+  effects: target-dependent\n+\n+  Rule 16:\n+  (set sp (and: sp <const_int>))\n+  constraints: cfa_store.reg == sp\n+  effects: current_fde.stack_realign = 1\n+           cfa_store.offset = 0\n+\t   fde->drap_reg = cfa.reg if cfa.reg != sp and cfa.reg != fp\n+\n+  Rule 17:\n+  (set (mem ({pre_inc, pre_dec} sp)) (mem (plus (cfa.reg) (const_int))))\n+  effects: cfa_store.offset += -/+ mode_size(mem)\n+\n+  Rule 18:\n+  (set (mem ({pre_inc, pre_dec} sp)) fp)\n+  constraints: fde->stack_realign == 1\n+  effects: cfa_store.offset = 0\n+\t   cfa.reg != HARD_FRAME_POINTER_REGNUM\n+\n+  Rule 19:\n+  (set (mem ({pre_inc, pre_dec} sp)) cfa.reg)\n+  constraints: fde->stack_realign == 1\n+               && cfa.offset == 0\n+               && cfa.indirect == 0\n+               && cfa.reg != HARD_FRAME_POINTER_REGNUM\n+  effects: Use DW_CFA_def_cfa_expression to define cfa\n+  \t   cfa.reg == fde->drap_reg\n+\n+  Rule 20:\n+  (set reg fde->drap_reg)\n+  constraints: fde->vdrap_reg == INVALID_REGNUM\n+  effects: fde->vdrap_reg = reg.\n+  (set mem fde->drap_reg)\n+  constraints: fde->drap_reg_saved == 1\n+  effects: none.  */\n \n static void\n dwarf2out_frame_debug_expr (rtx expr, const char *label)\n {\n   rtx src, dest, span;\n   HOST_WIDE_INT offset;\n+  dw_fde_ref fde;\n \n   /* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of\n      the PARALLEL independently. The first element is always processed if\n@@ -1621,6 +1701,26 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \tsrc = rsi;\n     }\n \n+  fde = current_fde ();\n+\n+  if (GET_CODE (src) == REG\n+      && fde\n+      && fde->drap_reg == REGNO (src)\n+      && (fde->drap_reg_saved\n+\t  || GET_CODE (dest) == REG))\n+    {\n+      /* Rule 20 */\n+      /* If we are saving dynamic realign argument pointer to a\n+\t register, the destination is virtual dynamic realign\n+\t argument pointer.  It may be used to access argument.  */\n+      if (GET_CODE (dest) == REG)\n+\t{\n+\t  gcc_assert (fde->vdrap_reg == INVALID_REGNUM);\n+\t  fde->vdrap_reg = REGNO (dest);\n+\t}\n+      return;\n+    }\n+\n   switch (GET_CODE (dest))\n     {\n     case REG:\n@@ -1649,7 +1749,19 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t\t\t  /* For the SPARC and its register window.  */\n \t\t\t  || (DWARF_FRAME_REGNUM (REGNO (src))\n \t\t\t      == DWARF_FRAME_RETURN_COLUMN));\n-\t      queue_reg_save (label, src, dest, 0);\n+\n+              /* After stack is aligned, we can only save SP in FP\n+\t\t if drap register is used.  In this case, we have\n+\t\t to restore stack pointer with the CFA value and we\n+\t\t don't generate this DWARF information.  */\n+\t      if (fde\n+\t\t  && fde->stack_realign\n+\t\t  && REGNO (src) == STACK_POINTER_REGNUM)\n+\t\tgcc_assert (REGNO (dest) == HARD_FRAME_POINTER_REGNUM\n+\t\t\t    && fde->drap_reg != INVALID_REGNUM\n+\t\t\t    && cfa.reg != REGNO (src));\n+\t      else\n+\t\tqueue_reg_save (label, src, dest, 0);\n \t    }\n \t  break;\n \n@@ -1782,6 +1894,24 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  targetm.dwarf_handle_frame_unspec (label, expr, XINT (src, 1));\n \t  return;\n \n+\t  /* Rule 16 */\n+\tcase AND:\n+          /* If this AND operation happens on stack pointer in prologue,\n+\t     we assume the stack is realigned and we extract the\n+\t     alignment.  */\n+          if (fde && XEXP (src, 0) == stack_pointer_rtx)\n+            {\n+              gcc_assert (cfa_store.reg == REGNO (XEXP (src, 0)));\n+              fde->stack_realign = 1;\n+              fde->stack_realignment = INTVAL (XEXP (src, 1));\n+              cfa_store.offset = 0;\n+\n+\t      if (cfa.reg != STACK_POINTER_REGNUM\n+\t\t  && cfa.reg != HARD_FRAME_POINTER_REGNUM)\n+\t\tfde->drap_reg = cfa.reg;\n+            }\n+          return;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1790,7 +1920,6 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n       break;\n \n     case MEM:\n-      gcc_assert (REG_P (src));\n \n       /* Saving a register to the stack.  Make sure dest is relative to the\n \t CFA register.  */\n@@ -1821,10 +1950,23 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  if (GET_CODE (XEXP (dest, 0)) == PRE_INC)\n \t    offset = -offset;\n \n-\t  gcc_assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM\n+\t  gcc_assert ((REGNO (XEXP (XEXP (dest, 0), 0))\n+\t\t       == STACK_POINTER_REGNUM)\n \t\t      && cfa_store.reg == STACK_POINTER_REGNUM);\n \n \t  cfa_store.offset += offset;\n+\n+          /* Rule 18: If stack is aligned, we will use FP as a\n+\t     reference to represent the address of the stored\n+\t     regiser.  */\n+          if (fde\n+              && fde->stack_realign\n+              && src == hard_frame_pointer_rtx)\n+\t    {\n+\t      gcc_assert (cfa.reg != HARD_FRAME_POINTER_REGNUM);\n+\t      cfa_store.offset = 0;\n+\t    }\n+\n \t  if (cfa.reg == STACK_POINTER_REGNUM)\n \t    cfa.offset = cfa_store.offset;\n \n@@ -1893,6 +2035,32 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \n \t  if (cfa.offset == 0)\n \t    {\n+              /* Rule 19 */\n+              /* If stack is aligned, putting CFA reg into stack means\n+\t\t we can no longer use reg + offset to represent CFA.\n+\t\t Here we use DW_CFA_def_cfa_expression instead.  The\n+\t\t result of this expression equals to the original CFA\n+\t\t value.  */\n+              if (fde\n+                  && fde->stack_realign\n+                  && cfa.indirect == 0\n+                  && cfa.reg != HARD_FRAME_POINTER_REGNUM)\n+                {\n+\t\t  dw_cfa_location cfa_exp;\n+\n+\t\t  gcc_assert (fde->drap_reg == cfa.reg);\n+\n+\t\t  cfa_exp.indirect = 1;\n+\t\t  cfa_exp.reg = HARD_FRAME_POINTER_REGNUM;\n+\t\t  cfa_exp.base_offset = offset;\n+\t\t  cfa_exp.offset = 0;\n+\n+\t\t  fde->drap_reg_saved = 1;\n+\n+\t\t  def_cfa_1 (label, &cfa_exp);\n+\t\t  break;\n+                }\n+\n \t      /* If the source register is exactly the CFA, assume\n \t\t we're saving SP like any other register; this happens\n \t\t on the ARM.  */\n@@ -1917,6 +2085,12 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t      break;\n \t    }\n \t}\n+        /* Rule 17 */\n+        /* If the source operand of this MEM operation is not a\n+\t   register, basically the source is return address.  Here\n+\t   we only care how much stack grew and we don't save it.  */\n+      if (!REG_P (src))\n+        break;\n \n       def_cfa_1 (label, &cfa);\n       {\n@@ -2693,6 +2867,8 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   fde->nothrow = TREE_NOTHROW (current_function_decl);\n   fde->uses_eh_lsda = crtl->uses_eh_lsda;\n   fde->all_throwers_are_sibcalls = crtl->all_throwers_are_sibcalls;\n+  fde->drap_reg = INVALID_REGNUM;\n+  fde->vdrap_reg = INVALID_REGNUM;\n \n   args_size = old_args_size = 0;\n \n@@ -2924,6 +3100,7 @@ typedef struct dw_loc_list_struct GTY(())\n static const char *dwarf_stack_op_name (unsigned);\n static dw_loc_descr_ref new_loc_descr (enum dwarf_location_atom,\n \t\t\t\t       unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT);\n+static dw_loc_descr_ref int_loc_descriptor (HOST_WIDE_INT);\n static void add_loc_descr (dw_loc_descr_ref *, dw_loc_descr_ref);\n static unsigned long size_of_loc_descr (dw_loc_descr_ref);\n static unsigned long size_of_locs (dw_loc_descr_ref);\n@@ -3583,6 +3760,9 @@ output_cfa_loc (dw_cfi_ref cfi)\n   dw_loc_descr_ref loc;\n   unsigned long size;\n \n+  if (cfi->dw_cfi_opc == DW_CFA_expression)\n+    dw2_asm_output_data (1, cfi->dw_cfi_oprnd2.dw_cfi_reg_num, NULL);\n+\n   /* Output the size of the block.  */\n   loc = cfi->dw_cfi_oprnd1.dw_cfi_loc;\n   size = size_of_locs (loc);\n@@ -3642,6 +3822,38 @@ build_cfa_loc (dw_cfa_location *cfa, HOST_WIDE_INT offset)\n   return head;\n }\n \n+/* This function builds a dwarf location descriptor sequence for\n+   the address at OFFSET from the CFA when stack is aligned to\n+   ALIGNMENT byte.  */\n+\n+static struct dw_loc_descr_struct *\n+build_cfa_aligned_loc (HOST_WIDE_INT offset, HOST_WIDE_INT alignment)\n+{\n+  struct dw_loc_descr_struct *head;\n+  unsigned int dwarf_fp\n+    = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);\n+\n+ /* When CFA is defined as FP+OFFSET, emulate stack alignment.  */\n+  if (cfa.reg == HARD_FRAME_POINTER_REGNUM && cfa.indirect == 0)\n+    {\n+      if (dwarf_fp <= 31)\n+\thead = new_loc_descr (DW_OP_breg0 + dwarf_fp, 0, 0);\n+      else\n+\thead = new_loc_descr (DW_OP_bregx, dwarf_fp, 0);\n+\n+      add_loc_descr (&head, int_loc_descriptor (alignment));\n+      add_loc_descr (&head, new_loc_descr (DW_OP_and, 0, 0));\n+\n+      add_loc_descr (&head, int_loc_descriptor (offset));\n+      add_loc_descr (&head, new_loc_descr (DW_OP_plus, 0, 0));\n+    }\n+  else if (dwarf_fp <= 31)\n+    head = new_loc_descr (DW_OP_breg0 + dwarf_fp, offset, 0);\n+  else\n+    head = new_loc_descr (DW_OP_bregx, dwarf_fp, offset);\n+  return head;\n+}\n+\n /* This function fills in aa dw_cfa_location structure from a dwarf location\n    descriptor sequence.  */\n \n@@ -4310,7 +4522,6 @@ static dw_loc_descr_ref one_reg_loc_descriptor (unsigned int,\n \t\t\t\t\t\tenum var_init_status);\n static dw_loc_descr_ref multiple_reg_loc_descriptor (rtx, rtx,\n \t\t\t\t\t\t     enum var_init_status);\n-static dw_loc_descr_ref int_loc_descriptor (HOST_WIDE_INT);\n static dw_loc_descr_ref based_loc_descr (rtx, HOST_WIDE_INT,\n \t\t\t\t\t enum var_init_status);\n static int is_based_loc (const_rtx);\n@@ -8997,6 +9208,10 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs,\n   return loc_result;\n }\n \n+#endif /* DWARF2_DEBUGGING_INFO */\n+\n+#if defined (DWARF2_DEBUGGING_INFO) || defined (DWARF2_UNWIND_INFO)\n+\n /* Return a location descriptor that designates a constant.  */\n \n static dw_loc_descr_ref\n@@ -9035,6 +9250,9 @@ int_loc_descriptor (HOST_WIDE_INT i)\n \n   return new_loc_descr (op, i, 0);\n }\n+#endif\n+\n+#ifdef DWARF2_DEBUGGING_INFO\n \n /* Return a location descriptor that designates a base+offset location.  */\n \n@@ -9044,6 +9262,7 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n {\n   unsigned int regno;\n   dw_loc_descr_ref result;\n+  dw_fde_ref fde = current_fde ();\n \n   /* We only use \"frame base\" when we're sure we're talking about the\n      post-prologue local stack frame.  We do this by *not* running\n@@ -9060,13 +9279,45 @@ based_loc_descr (rtx reg, HOST_WIDE_INT offset,\n \t      offset += INTVAL (XEXP (elim, 1));\n \t      elim = XEXP (elim, 0);\n \t    }\n-\t  gcc_assert (elim == (frame_pointer_needed ? hard_frame_pointer_rtx\n-\t\t      : stack_pointer_rtx));\n-\t  offset += frame_pointer_fb_offset;\n+\t  gcc_assert ((SUPPORTS_STACK_ALIGNMENT\n+\t\t       && (elim == hard_frame_pointer_rtx\n+\t\t\t   || elim == stack_pointer_rtx))\n+\t              || elim == (frame_pointer_needed\n+\t\t\t\t  ? hard_frame_pointer_rtx\n+\t\t\t\t  : stack_pointer_rtx));\n+\n+\t  /* If drap register is used to align stack, use frame\n+\t     pointer + offset to access stack variables.  If stack\n+\t     is aligned without drap, use stack pointer + offset to\n+\t     access stack variables.  */\n+\t  if (fde\n+\t      && fde->stack_realign\n+\t      && cfa.reg == HARD_FRAME_POINTER_REGNUM\n+\t      && reg == frame_pointer_rtx)\n+\t    {\n+\t      int base_reg\n+\t\t= DWARF_FRAME_REGNUM (cfa.indirect\n+\t\t\t\t      ? HARD_FRAME_POINTER_REGNUM\n+\t\t\t\t      : STACK_POINTER_REGNUM);\n+\t      if (base_reg <= 31)\n+\t\treturn new_loc_descr (DW_OP_breg0 + base_reg, offset, 0);\n+\t      else\n+\t\treturn new_loc_descr (DW_OP_bregx, base_reg, offset);\n+\t    }\n \n+\t  offset += frame_pointer_fb_offset;\n \t  return new_loc_descr (DW_OP_fbreg, offset, 0);\n \t}\n     }\n+  else if (fde\n+\t   && fde->drap_reg != INVALID_REGNUM\n+\t   && (fde->drap_reg == REGNO (reg)\n+\t       || fde->vdrap_reg == REGNO (reg)))\n+    {\n+      /* Use cfa+offset to represent the location of arguments passed\n+\t on stack when drap is used to align stack.  */\n+      return new_loc_descr (DW_OP_fbreg, offset, 0);\n+    }\n \n   regno = dbx_reg_number (reg);\n   if (regno <= 31)\n@@ -11111,8 +11362,13 @@ compute_frame_pointer_to_fb_displacement (HOST_WIDE_INT offset)\n       offset += INTVAL (XEXP (elim, 1));\n       elim = XEXP (elim, 0);\n     }\n-  gcc_assert (elim == (frame_pointer_needed ? hard_frame_pointer_rtx\n-\t\t       : stack_pointer_rtx));\n+\n+  gcc_assert ((SUPPORTS_STACK_ALIGNMENT\n+\t       && (elim == hard_frame_pointer_rtx\n+\t\t   || elim == stack_pointer_rtx))\n+\t      || elim == (frame_pointer_needed\n+\t\t\t  ? hard_frame_pointer_rtx\n+\t\t\t  : stack_pointer_rtx));\n \n   frame_pointer_fb_offset = -offset;\n }"}, {"sha": "a0af7b39436666907fd236e6eb1f444c5504d7a2", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -864,9 +864,18 @@ rtx\n gen_reg_rtx (enum machine_mode mode)\n {\n   rtx val;\n+  unsigned int align = GET_MODE_ALIGNMENT (mode);\n \n   gcc_assert (can_create_pseudo_p ());\n \n+  /* If a virtual register with bigger mode alignment is generated,\n+     increase stack alignment estimation because it might be spilled\n+     to stack later.  */\n+  if (SUPPORTS_STACK_ALIGNMENT \n+      && crtl->stack_alignment_estimated < align\n+      && !crtl->stack_realign_processed)\n+    crtl->stack_alignment_estimated = align;\n+\n   if (generating_concat_p\n       && (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n \t  || GET_MODE_CLASS (mode) == MODE_COMPLEX_INT))"}, {"sha": "b9d9ec59cc0456f1d3c832f1d5e0c3c54135a251", "filename": "gcc/function.c", "status": "modified", "additions": 131, "deletions": 9, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -350,10 +350,14 @@ get_stack_local_alignment (tree type, enum machine_mode mode)\n    -2 means use BITS_PER_UNIT,\n    positive specifies alignment boundary in bits.\n \n+   If REDUCE_ALIGNMENT_OK is true, it is OK to reduce alignment.\n+\n    We do not round to stack_boundary here.  */\n \n rtx\n-assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n+assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size,\n+\t\t      int align,\n+\t\t      bool reduce_alignment_ok ATTRIBUTE_UNUSED)\n {\n   rtx x, addr;\n   int bigend_correction = 0;\n@@ -375,17 +379,52 @@ assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n   else\n     alignment = align / BITS_PER_UNIT;\n \n+  alignment_in_bits = alignment * BITS_PER_UNIT;\n+\n   if (FRAME_GROWS_DOWNWARD)\n     frame_offset -= size;\n \n-  /* Ignore alignment we can't do with expected alignment of the boundary.  */\n-  if (alignment * BITS_PER_UNIT > PREFERRED_STACK_BOUNDARY)\n-    alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+  /* Ignore alignment if it exceeds MAX_SUPPORTED_STACK_ALIGNMENT.  */\n+  if (alignment_in_bits > MAX_SUPPORTED_STACK_ALIGNMENT)\n+    {\n+      alignment_in_bits = MAX_SUPPORTED_STACK_ALIGNMENT;\n+      alignment = alignment_in_bits / BITS_PER_UNIT;\n+    }\n \n-  alignment_in_bits = alignment * BITS_PER_UNIT;\n+  if (SUPPORTS_STACK_ALIGNMENT)\n+    {\n+      if (crtl->stack_alignment_estimated < alignment_in_bits)\n+\t{\n+          if (!crtl->stack_realign_processed)\n+\t    crtl->stack_alignment_estimated = alignment_in_bits;\n+          else\n+\t    {\n+\t      /* If stack is realigned and stack alignment value\n+\t\t hasn't been finalized, it is OK not to increase\n+\t\t stack_alignment_estimated.  The bigger alignment\n+\t\t requirement is recorded in stack_alignment_needed\n+\t\t below.  */\n+\t      gcc_assert (!crtl->stack_realign_finalized);\n+\t      if (!crtl->stack_realign_needed)\n+\t\t{\n+\t\t  /* It is OK to reduce the alignment as long as the\n+\t\t     requested size is 0 or the estimated stack\n+\t\t     alignment >= mode alignment.  */\n+\t\t  gcc_assert (reduce_alignment_ok\n+\t\t              || size == 0\n+\t\t\t      || (crtl->stack_alignment_estimated\n+\t\t\t\t  >= GET_MODE_ALIGNMENT (mode)));\n+\t\t  alignment_in_bits = crtl->stack_alignment_estimated;\n+\t\t  alignment = alignment_in_bits / BITS_PER_UNIT;\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n   if (crtl->stack_alignment_needed < alignment_in_bits)\n     crtl->stack_alignment_needed = alignment_in_bits;\n+  if (crtl->max_used_stack_slot_alignment < crtl->stack_alignment_needed)\n+    crtl->max_used_stack_slot_alignment = crtl->stack_alignment_needed;\n \n   /* Calculate how many bytes the start of local variables is off from\n      stack alignment.  */\n@@ -449,6 +488,14 @@ assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n \n   return x;\n }\n+\n+/* Wrap up assign_stack_local_1 with last parameter as false.  */\n+\n+rtx\n+assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n+{\n+  return assign_stack_local_1 (mode, size, align, false);\n+}\n \f\n /* Removes temporary slot TEMP from LIST.  */\n \n@@ -1167,7 +1214,17 @@ instantiate_new_reg (rtx x, HOST_WIDE_INT *poffset)\n   HOST_WIDE_INT offset;\n \n   if (x == virtual_incoming_args_rtx)\n-    new = arg_pointer_rtx, offset = in_arg_offset;\n+    {\n+      /* Replace virtual_incoming_args_rtx to internal arg pointer here */\n+      if (crtl->args.internal_arg_pointer != virtual_incoming_args_rtx)\n+        {\n+          gcc_assert (stack_realign_drap);\n+          new = crtl->args.internal_arg_pointer;\n+          offset = 0;\n+        }\n+      else\n+        new = arg_pointer_rtx, offset = in_arg_offset;\n+    }\n   else if (x == virtual_stack_vars_rtx)\n     new = frame_pointer_rtx, offset = var_offset;\n   else if (x == virtual_stack_dynamic_rtx)\n@@ -2947,6 +3004,20 @@ assign_parms (tree fndecl)\n \t  continue;\n \t}\n \n+      /* Estimate stack alignment from parameter alignment.  */\n+      if (SUPPORTS_STACK_ALIGNMENT)\n+        {\n+          unsigned int align = FUNCTION_ARG_BOUNDARY (data.promoted_mode,\n+\t\t\t\t\t\t      data.passed_type);\n+\t  if (TYPE_ALIGN (data.nominal_type) > align)\n+\t    align = TYPE_ALIGN (data.passed_type);\n+\t  if (crtl->stack_alignment_estimated < align)\n+\t    {\n+\t      gcc_assert (!crtl->stack_realign_processed);\n+\t      crtl->stack_alignment_estimated = align;\n+\t    }\n+\t}\n+\t\n       if (cfun->stdarg && !TREE_CHAIN (parm))\n \tassign_parms_setup_varargs (&all, &data, false);\n \n@@ -2984,6 +3055,28 @@ assign_parms (tree fndecl)\n      now that all parameters have been copied out of hard registers.  */\n   emit_insn (all.first_conversion_insn);\n \n+  /* Estimate reload stack alignment from scalar return mode.  */\n+  if (SUPPORTS_STACK_ALIGNMENT)\n+    {\n+      if (DECL_RESULT (fndecl))\n+\t{\n+\t  tree type = TREE_TYPE (DECL_RESULT (fndecl));\n+\t  enum machine_mode mode = TYPE_MODE (type);\n+\n+\t  if (mode != BLKmode\n+\t      && mode != VOIDmode\n+\t      && !AGGREGATE_TYPE_P (type))\n+\t    {\n+\t      unsigned int align = GET_MODE_ALIGNMENT (mode);\n+\t      if (crtl->stack_alignment_estimated < align)\n+\t\t{\n+\t\t  gcc_assert (!crtl->stack_realign_processed);\n+\t\t  crtl->stack_alignment_estimated = align;\n+\t\t}\n+\t    }\n+\t} \n+    }\n+\n   /* If we are receiving a struct value address as the first argument, set up\n      the RTL for the function result. As this might require code to convert\n      the transmitted address to Pmode, we do this here to ensure that possible\n@@ -3257,15 +3350,43 @@ locate_and_pad_parm (enum machine_mode passed_mode, tree type, int in_regs,\n     = type ? size_in_bytes (type) : size_int (GET_MODE_SIZE (passed_mode));\n   where_pad = FUNCTION_ARG_PADDING (passed_mode, type);\n   boundary = FUNCTION_ARG_BOUNDARY (passed_mode, type);\n-  if (boundary > PREFERRED_STACK_BOUNDARY)\n-    boundary = PREFERRED_STACK_BOUNDARY;\n   locate->where_pad = where_pad;\n+\n+  /* Alignment can't exceed MAX_SUPPORTED_STACK_ALIGNMENT.  */\n+  if (boundary > MAX_SUPPORTED_STACK_ALIGNMENT)\n+    boundary = MAX_SUPPORTED_STACK_ALIGNMENT;\n+\n   locate->boundary = boundary;\n \n+  if (SUPPORTS_STACK_ALIGNMENT)\n+    {\n+      /* stack_alignment_estimated can't change after stack has been\n+\t realigned.  */\n+      if (crtl->stack_alignment_estimated < boundary)\n+        {\n+          if (!crtl->stack_realign_processed)\n+\t    crtl->stack_alignment_estimated = boundary;\n+\t  else\n+\t    {\n+\t      /* If stack is realigned and stack alignment value\n+\t\t hasn't been finalized, it is OK not to increase\n+\t\t stack_alignment_estimated.  The bigger alignment\n+\t\t requirement is recorded in stack_alignment_needed\n+\t\t below.  */\n+\t      gcc_assert (!crtl->stack_realign_finalized\n+\t\t\t  && crtl->stack_realign_needed);\n+\t    }\n+\t}\n+    }\n+\n   /* Remember if the outgoing parameter requires extra alignment on the\n      calling function side.  */\n   if (crtl->stack_alignment_needed < boundary)\n     crtl->stack_alignment_needed = boundary;\n+  if (crtl->max_used_stack_slot_alignment < crtl->stack_alignment_needed)\n+    crtl->max_used_stack_slot_alignment = crtl->stack_alignment_needed;\n+  if (crtl->preferred_stack_boundary < boundary)\n+    crtl->preferred_stack_boundary = boundary;\n \n #ifdef ARGS_GROW_DOWNWARD\n   locate->slot_offset.constant = -initial_offset_ptr->constant;\n@@ -4602,7 +4723,8 @@ get_arg_pointer_save_area (void)\n \t generated stack slot may not be a valid memory address, so we\n \t have to check it and fix it if necessary.  */\n       start_sequence ();\n-      emit_move_insn (validize_mem (ret), virtual_incoming_args_rtx);\n+      emit_move_insn (validize_mem (ret),\n+                      crtl->args.internal_arg_pointer);\n       seq = get_insns ();\n       end_sequence ();\n "}, {"sha": "ebba29f3862658ebd9214d3abc1c2abb96f1efd3", "filename": "gcc/function.h", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -311,6 +311,9 @@ struct rtl_data GTY(())\n      needed by inner routines.  */\n   rtx x_arg_pointer_save_area;\n \n+  /* Dynamic Realign Argument Pointer used for realigning stack.  */\n+  rtx drap_reg;\n+\n   /* Offset to end of allocated area of stack frame.\n      If stack grows down, this is the address of the last stack slot allocated.\n      If stack grows up, this is the address for the next slot.  */\n@@ -328,12 +331,26 @@ struct rtl_data GTY(())\n   /* Current nesting level for temporaries.  */\n   int x_temp_slot_level;\n \n-  /* The largest alignment of slot allocated on the stack.  */\n+  /* The largest alignment needed on the stack, including requirement\n+     for outgoing stack alignment.  */\n   unsigned int stack_alignment_needed;\n \n-  /* Preferred alignment of the end of stack frame.  */\n+  /* Preferred alignment of the end of stack frame, which is preferred\n+     to call other functions.  */\n   unsigned int preferred_stack_boundary;\n \n+  /* The largest alignment of slot allocated on the stack.  */\n+  unsigned int max_used_stack_slot_alignment;\n+\n+  /* The stack alignment estimated before reload, with consideration of\n+     following factors:\n+     1. Alignment of local stack variables (max_used_stack_slot_alignment)\n+     2. Alignment requirement to call other functions \n+        (preferred_stack_boundary)\n+     3. Alignment of non-local stack variables but might be spilled in\n+        local stack.  */\n+  unsigned int stack_alignment_estimated;\n+\n   /* For reorg.  */\n \n   /* If some insns can be deferred to the delay slots of the epilogue, the\n@@ -393,13 +410,32 @@ struct rtl_data GTY(())\n   /* Nonzero if code to initialize arg_pointer_save_area has been emitted.  */\n   bool arg_pointer_save_area_init;\n \n-  /* Nonzero means current function must be given a frame pointer.\n-     Set in stmt.c if anything is allocated on the stack there.\n-     Set in reload1.c if anything is allocated on the stack there.  */\n+  /* Nonzero if current function must be given a frame pointer.\n+     Set in global.c if anything is allocated on the stack there.  */\n   bool frame_pointer_needed;\n \n   /* When set, expand should optimize for speed.  */\n   bool maybe_hot_insn_p;\n+\n+  /* Nonzero if function stack realignment is needed. This flag may be\n+     set twice: before and after reload. It is set before reload wrt\n+     stack alignment estimation before reload. It will be changed after \n+     reload if by then criteria of stack realignment is different. \n+     The value set after reload is the accurate one and is finalized.  */\n+  bool stack_realign_needed;\n+\n+  /* Nonzero if function being compiled needs dynamic realigned\n+     argument pointer (drap) if stack needs realigning.  */\n+  bool need_drap;\n+\n+  /* Nonzero if function stack realignment estimation is done, namely\n+     stack_realign_needed flag has been set before reload wrt\n+     estimated stack alignment info.  */\n+  bool stack_realign_processed;\n+\n+  /* Nonzero if function stack realignment has been finalized, namely\n+     stack_realign_needed flag has been set and finalized after reload.  */\n+  bool stack_realign_finalized;\n };\n \n #define return_label (crtl->x_return_label)\n@@ -414,6 +450,8 @@ struct rtl_data GTY(())\n #define temp_slot_level (crtl->x_temp_slot_level)\n #define nonlocal_goto_handler_labels (crtl->x_nonlocal_goto_handler_labels)\n #define frame_pointer_needed (crtl->frame_pointer_needed)\n+#define stack_realign_fp (crtl->stack_realign_needed && !crtl->need_drap)\n+#define stack_realign_drap (crtl->stack_realign_needed && crtl->need_drap)\n \n extern GTY(()) struct rtl_data x_rtl;\n "}, {"sha": "690a80c8a85fc9f5562c5cd63d3f1fa5fd90b23f", "filename": "gcc/global.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -233,6 +233,7 @@ compute_regsets (HARD_REG_SET *elim_set,\n     = (! flag_omit_frame_pointer\n        || (cfun->calls_alloca && EXIT_IGNORE_STACK)\n        || crtl->accesses_prior_frames\n+       || crtl->stack_realign_needed\n        || FRAME_POINTER_REQUIRED);\n \n   frame_pointer_needed = need_fp;\n@@ -256,7 +257,10 @@ compute_regsets (HARD_REG_SET *elim_set,\n     {\n       bool cannot_elim\n \t= (! CAN_ELIMINATE (eliminables[i].from, eliminables[i].to)\n-\t   || (eliminables[i].to == STACK_POINTER_REGNUM && need_fp));\n+\t   || (eliminables[i].to == STACK_POINTER_REGNUM\n+\t       && need_fp \n+\t       && (! SUPPORTS_STACK_ALIGNMENT\n+\t\t   || ! stack_realign_fp)));\n \n       if (!regs_asm_clobbered[eliminables[i].from])\n \t{"}, {"sha": "9b81062216ffbb995bfb19da03465cda1359b245", "filename": "gcc/reload1.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -3663,8 +3663,11 @@ update_eliminables (HARD_REG_SET *pset)\n   frame_pointer_needed = 1;\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n-      if (ep->can_eliminate && ep->from == FRAME_POINTER_REGNUM\n-\t  && ep->to != HARD_FRAME_POINTER_REGNUM)\n+      if (ep->can_eliminate\n+\t  && ep->from == FRAME_POINTER_REGNUM\n+\t  && ep->to != HARD_FRAME_POINTER_REGNUM\n+\t  && (! SUPPORTS_STACK_ALIGNMENT\n+\t      || ! crtl->stack_realign_needed))\n \tframe_pointer_needed = 0;\n \n       if (! ep->can_eliminate && ep->can_eliminate_previous)\n@@ -3720,7 +3723,10 @@ init_elim_table (void)\n       ep->to = ep1->to;\n       ep->can_eliminate = ep->can_eliminate_previous\n \t= (CAN_ELIMINATE (ep->from, ep->to)\n-\t   && ! (ep->to == STACK_POINTER_REGNUM && frame_pointer_needed));\n+\t   && ! (ep->to == STACK_POINTER_REGNUM\n+\t\t && frame_pointer_needed \n+\t\t && (! SUPPORTS_STACK_ALIGNMENT\n+\t\t     || ! stack_realign_fp)));\n     }\n #else\n   reg_eliminate[0].from = reg_eliminate_1[0].from;"}, {"sha": "5281b1484dbad76cc6f2498a75fa0dac4e0262de", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -1572,6 +1572,7 @@ extern rtx simplify_subtraction (rtx);\n \n /* In function.c  */\n extern rtx assign_stack_local (enum machine_mode, HOST_WIDE_INT, int);\n+extern rtx assign_stack_local_1 (enum machine_mode, HOST_WIDE_INT, int, bool);\n extern rtx assign_stack_temp (enum machine_mode, HOST_WIDE_INT, int);\n extern rtx assign_stack_temp_for_type (enum machine_mode,\n \t\t\t\t       HOST_WIDE_INT, int, tree);"}, {"sha": "38d7b439aec0d3516d036072111aace03b784c07", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -1813,7 +1813,7 @@ expand_nl_goto_receiver (void)\n \t{\n \t  /* Now restore our arg pointer from the address at which it\n \t     was saved in our stack frame.  */\n-\t  emit_move_insn (virtual_incoming_args_rtx,\n+\t  emit_move_insn (crtl->args.internal_arg_pointer,\n \t\t\t  copy_to_reg (get_arg_pointer_save_area ()));\n \t}\n     }"}, {"sha": "cd64b386e9ed306ccc499af48e4a65830c0b191a", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -571,6 +571,8 @@\n \n #define TARGET_FUNCTION_VALUE default_function_value\n #define TARGET_INTERNAL_ARG_POINTER default_internal_arg_pointer\n+#define TARGET_UPDATE_STACK_BOUNDARY NULL\n+#define TARGET_GET_DRAP_RTX NULL\n #define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS hook_bool_void_true\n \n #define TARGET_CALLS {\t\t\t\t\t\t\\\n@@ -592,6 +594,8 @@\n    TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN,\t\t\t\\\n    TARGET_FUNCTION_VALUE,\t\t\t\t\t\\\n    TARGET_INTERNAL_ARG_POINTER,\t\t\t\t\t\\\n+   TARGET_UPDATE_STACK_BOUNDARY,\t\t\t\t\\\n+   TARGET_GET_DRAP_RTX,\t\t\t\t\t\t\\\n    TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\t\t\t\t\\\n    }\n "}, {"sha": "3a104c5632b56b1442044338c0851922c159d22c", "filename": "gcc/target.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -839,6 +839,13 @@ struct gcc_target\n        current function.  */\n     rtx (*internal_arg_pointer) (void);\n \n+    /* Update the current function stack boundary if needed.  */\n+    void (*update_stack_boundary) (void);\n+\n+    /* Handle stack alignment and return an rtx for Dynamic Realign\n+       Argument Pointer if necessary.  */\n+    rtx (*get_drap_rtx) (void);\n+\n     /* Return true if all function parameters should be spilled to the\n        stack.  */\n     bool (*allocate_stack_slots_for_args) (void);"}, {"sha": "22e2e0c4cee2aab74e94012f044e556807e2296d", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3f842fe69ce4e74cfe18493429b807af271083/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=2e3f842fe69ce4e74cfe18493429b807af271083", "patch": "@@ -1830,9 +1830,7 @@ vect_can_force_dr_alignment_p (const_tree decl, unsigned int alignment)\n   if (TREE_STATIC (decl))\n     return (alignment <= MAX_OFILE_ALIGNMENT);\n   else\n-    /* This used to be PREFERRED_STACK_BOUNDARY, however, that is not 100%\n-       correct until someone implements forced stack alignment.  */\n-    return (alignment <= STACK_BOUNDARY); \n+    return (alignment <= MAX_STACK_ALIGNMENT);\n }\n \n "}]}