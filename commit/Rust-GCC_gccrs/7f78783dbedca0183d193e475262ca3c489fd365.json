{"sha": "7f78783dbedca0183d193e475262ca3c489fd365", "node_id": "C_kwDOANBUbNoAKDdmNzg3ODNkYmVkY2EwMTgzZDE5M2U0NzUyNjJjYTNjNDg5ZmQzNjU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-05-12T06:31:20Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-05-12T06:31:20Z"}, "message": "openmp: Add omp_all_memory support (C/C++ only so far)\n\nThe ugly part is that OpenMP 5.1 made omp_all_memory a reserved identifier\nwhich isn't allowed to be used anywhere but in the depend clause, this is\nagainst how everything else has been handled in OpenMP so far (where\nsome identifiers could have special meaning in some OpenMP clauses or\npragmas but not elsewhere).\nThe patch handles it by making it a conditional keyword (for -fopenmp\nonly) and emitting a better diagnostics when it is used in a primary\nexpression.  Having a nicer diagnostics when e.g. trying to do\nint omp_all_memory;\nor\nint *omp_all_memory[10];\netc. would mean changing too many spots and hooking into name lookups\nto reject declaring any such symbols would be too ugly and I'm afraid\nthere are way too many spots where one can introduce a name\n(variables, functions, namespaces, struct, enum, enumerators, template\narguments, ...).\n\nOtherwise, the handling is quite simple, normal depend clauses lower\ninto addresses of variables being handed over to the library, for\nomp_all_memory I'm using NULL pointers.  omp_all_memory can only be\nused with inout or out depend kinds and means that a task is dependent\non all previously created sibling tasks that have any dependency (of\nany depend kind) and that any later created sibling tasks will be\ndependent on it if they have any dependency.\n\n2022-05-12  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* gimplify.cc (gimplify_omp_depend): Don't build_fold_addr_expr\n\tif null_pointer_node.\n\t(gimplify_scan_omp_clauses): Likewise.\n\t* tree-pretty-print.cc (dump_omp_clause): Print null_pointer_node\n\tas omp_all_memory.\ngcc/c-family/\n\t* c-common.h (enum rid): Add RID_OMP_ALL_MEMORY.\n\t* c-omp.cc (c_finish_omp_depobj): Don't build_fold_addr_expr\n\tif null_pointer_node.\ngcc/c/\n\t* c-parser.cc (c_parse_init): Register omp_all_memory as keyword\n\tif flag_openmp.\n\t(c_parser_postfix_expression): Diagnose uses of omp_all_memory\n\tin postfix expressions.\n\t(c_parser_omp_variable_list): Handle omp_all_memory in depend\n\tclause.\n\t* c-typeck.cc (c_finish_omp_clauses): Handle omp_all_memory\n\tkeyword in depend clause as null_pointer_node, diagnose invalid\n\tuses.\ngcc/cp/\n\t* lex.cc (init_reswords): Register omp_all_memory as keyword\n\tif flag_openmp.\n\t* parser.cc (cp_parser_primary_expression): Diagnose uses of\n\tomp_all_memory in postfix expressions.\n\t(cp_parser_omp_var_list_no_open): Handle omp_all_memory in depend\n\tclause.\n\t* semantics.cc (finish_omp_clauses): Handle omp_all_memory\n\tkeyword in depend clause as null_pointer_node, diagnose invalid\n\tuses.\n\t* pt.cc (tsubst_omp_clause_decl): Pass through omp_all_memory.\ngcc/testsuite/\n\t* c-c++-common/gomp/all-memory-1.c: New test.\n\t* c-c++-common/gomp/all-memory-2.c: New test.\n\t* c-c++-common/gomp/all-memory-3.c: New test.\n\t* g++.dg/gomp/all-memory-1.C: New test.\n\t* g++.dg/gomp/all-memory-2.C: New test.\nlibgomp/\n\t* libgomp.h (struct gomp_task): Add depend_all_memory member.\n\t* task.c (gomp_init_task): Initialize depend_all_memory.\n\t(gomp_task_handle_depend): Handle omp_all_memory.\n\t(gomp_task_run_post_handle_depend_hash): Clear\n\tparent->depend_all_memory if equal to current task.\n\t(gomp_task_maybe_wait_for_dependencies): Handle omp_all_memory.\n\t* testsuite/libgomp.c-c++-common/depend-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/depend-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/depend-3.c: New test.", "tree": {"sha": "894cab7fc78808ee0b5e59ac3f2bb8a3eee01e90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/894cab7fc78808ee0b5e59ac3f2bb8a3eee01e90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f78783dbedca0183d193e475262ca3c489fd365", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f78783dbedca0183d193e475262ca3c489fd365", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f78783dbedca0183d193e475262ca3c489fd365", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f78783dbedca0183d193e475262ca3c489fd365/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8585185cc4de3a9268af6afc42a0e86b7ba72b12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8585185cc4de3a9268af6afc42a0e86b7ba72b12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8585185cc4de3a9268af6afc42a0e86b7ba72b12"}], "stats": {"total": 853, "additions": 817, "deletions": 36}, "files": [{"sha": "47442c95a53528161cb1f592adc1b113ed493288", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -219,6 +219,9 @@ enum rid\n   RID_AT_INTERFACE,\n   RID_AT_IMPLEMENTATION,\n \n+  /* OpenMP */\n+  RID_OMP_ALL_MEMORY,\n+\n   /* Named address support, mapping the keyword to a particular named address\n      number.  Named address space 0 is reserved for the generic address.  If\n      there are more than 254 named addresses, the addr_space_t type will need"}, {"sha": "987ba7d724aea62955d368e563eaa6a9883c4086", "filename": "gcc/c-family/c-omp.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fc-family%2Fc-omp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fc-family%2Fc-omp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.cc?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -757,7 +757,7 @@ c_finish_omp_depobj (location_t loc, tree depobj,\n \t      t = build2 (COMPOUND_EXPR, TREE_TYPE (t1), TREE_OPERAND (t, 0),\n \t\t\t  t1);\n \t    }\n-\t  else\n+\t  else if (t != null_pointer_node)\n \t    t = build_fold_addr_expr (t);\n \t  break;\n \tdefault:"}, {"sha": "51a07252c7b94dd7e430117ac1318f5ecfdcd466", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -165,6 +165,14 @@ c_parse_init (void)\n       C_SET_RID_CODE (id, RID_FIRST_INT_N + i);\n       C_IS_RESERVED_WORD (id) = 1;\n     }\n+\n+  if (flag_openmp)\n+    {\n+      id = get_identifier (\"omp_all_memory\");\n+      C_SET_RID_CODE (id, RID_OMP_ALL_MEMORY);\n+      C_IS_RESERVED_WORD (id) = 1;\n+      ridpointers [RID_OMP_ALL_MEMORY] = id;\n+    }\n }\n \f\n /* A parser structure recording information about the state and\n@@ -10202,6 +10210,13 @@ c_parser_postfix_expression (c_parser *parser)\n \tcase RID_GENERIC:\n \t  expr = c_parser_generic_selection (parser);\n \t  break;\n+\tcase RID_OMP_ALL_MEMORY:\n+\t  gcc_assert (flag_openmp);\n+\t  c_parser_consume_token (parser);\n+\t  error_at (loc, \"%<omp_all_memory%> may only be used in OpenMP \"\n+\t\t\t \"%<depend%> clause\");\n+\t  expr.set_error ();\n+\t  break;\n \tdefault:\n \t  c_parser_error (parser, \"expected expression\");\n \t  expr.set_error ();\n@@ -13025,7 +13040,19 @@ c_parser_omp_variable_list (c_parser *parser,\n \t  if (c_parser_next_token_is_not (parser, CPP_NAME)\n \t      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n \t    {\n-\t      struct c_expr expr = c_parser_expr_no_commas (parser, NULL);\n+\t      struct c_expr expr;\n+\t      if (kind == OMP_CLAUSE_DEPEND\n+\t\t  && c_parser_next_token_is_keyword (parser,\n+\t\t\t\t\t\t     RID_OMP_ALL_MEMORY)\n+\t\t  && (c_parser_peek_2nd_token (parser)->type == CPP_COMMA\n+\t\t      || (c_parser_peek_2nd_token (parser)->type\n+\t\t\t  == CPP_CLOSE_PAREN)))\n+\t\t{\n+\t\t  expr.value = ridpointers[RID_OMP_ALL_MEMORY];\n+\t\t  c_parser_consume_token (parser);\n+\t\t}\n+\t      else\n+\t\texpr = c_parser_expr_no_commas (parser, NULL);\n \t      if (expr.value != error_mark_node)\n \t\t{\n \t\t  tree u = build_omp_clause (clause_loc, kind);"}, {"sha": "bcfe08b82bcf157fe369bd8ffafe9aa1e4826b51", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -14832,6 +14832,18 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  if (t == error_mark_node)\n \t    remove = true;\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t   && t == ridpointers[RID_OMP_ALL_MEMORY])\n+\t    {\n+\t      if (OMP_CLAUSE_DEPEND_KIND (c) != OMP_CLAUSE_DEPEND_OUT\n+\t\t  && OMP_CLAUSE_DEPEND_KIND (c) != OMP_CLAUSE_DEPEND_INOUT)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<omp_all_memory%> used with %<depend%> kind \"\n+\t\t\t    \"other than %<out%> or %<inout%>\");\n+\t\t  remove = true;\n+\t\t}\n+\t    }\n \t  else if (!lvalue_p (t))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n@@ -14873,24 +14885,32 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  if (!remove)\n \t    {\n-\t      tree addr = build_unary_op (OMP_CLAUSE_LOCATION (c), ADDR_EXPR,\n-\t\t\t\t\t  t, false);\n-\t      if (addr == error_mark_node)\n-\t\tremove = true;\n+\t      if (t == ridpointers[RID_OMP_ALL_MEMORY])\n+\t\tt = null_pointer_node;\n \t      else\n \t\t{\n+\t\t  tree addr = build_unary_op (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t      ADDR_EXPR, t, false);\n+\t\t  if (addr == error_mark_node)\n+\t\t    {\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n \t\t  t = build_indirect_ref (OMP_CLAUSE_LOCATION (c), addr,\n \t\t\t\t\t  RO_UNARY_STAR);\n \t\t  if (t == error_mark_node)\n-\t\t    remove = true;\n-\t\t  else if (TREE_CODE (OMP_CLAUSE_DECL (c)) == TREE_LIST\n-\t\t\t   && TREE_PURPOSE (OMP_CLAUSE_DECL (c))\n-\t\t\t   && (TREE_CODE (TREE_PURPOSE (OMP_CLAUSE_DECL (c)))\n-\t\t\t       == TREE_VEC))\n-\t\t    TREE_VALUE (OMP_CLAUSE_DECL (c)) = t;\n-\t\t  else\n-\t\t    OMP_CLAUSE_DECL (c) = t;\n+\t\t    {\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n \t\t}\n+\t      if (TREE_CODE (OMP_CLAUSE_DECL (c)) == TREE_LIST\n+\t\t  && TREE_PURPOSE (OMP_CLAUSE_DECL (c))\n+\t\t  && (TREE_CODE (TREE_PURPOSE (OMP_CLAUSE_DECL (c)))\n+\t\t      == TREE_VEC))\n+\t\tTREE_VALUE (OMP_CLAUSE_DECL (c)) = t;\n+\t      else\n+\t\tOMP_CLAUSE_DECL (c) = t;\n \t    }\n \t  break;\n "}, {"sha": "0b121a91e1cdeb0c04fdc0c68a21ee6f04e03bf5", "filename": "gcc/cp/lex.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fcp%2Flex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fcp%2Flex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.cc?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -273,6 +273,14 @@ init_reswords (void)\n       C_SET_RID_CODE (id, RID_FIRST_INT_N + i);\n       set_identifier_kind (id, cik_keyword);\n     }\n+\n+  if (flag_openmp)\n+    {\n+      id = get_identifier (\"omp_all_memory\");\n+      C_SET_RID_CODE (id, RID_OMP_ALL_MEMORY);\n+      set_identifier_kind (id, cik_keyword);\n+      ridpointers [RID_OMP_ALL_MEMORY] = id;\n+    }\n }\n \n static void"}, {"sha": "84f379c7bff331b1501a4a33562a273a4a241d9d", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -5876,6 +5876,14 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_AT_SELECTOR:\n \t  return cp_parser_objc_expression (parser);\n \n+\tcase RID_OMP_ALL_MEMORY:\n+\t  gcc_assert (flag_openmp);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  error_at (token->location,\n+\t\t    \"%<omp_all_memory%> may only be used in OpenMP \"\n+\t\t    \"%<depend%> clause\");\n+\t  return error_mark_node;\n+\n \tcase RID_TEMPLATE:\n \t  if (parser->in_function_body\n \t      && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n@@ -36735,6 +36743,15 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t  decl = cp_parser_primary_expression (parser, false, false, false,\n \t\t\t\t\t       &idk);\n \t}\n+      else if (kind == OMP_CLAUSE_DEPEND\n+\t       && cp_parser_is_keyword (token, RID_OMP_ALL_MEMORY)\n+\t       && (cp_lexer_nth_token_is (parser->lexer, 2, CPP_COMMA)\n+\t\t   || cp_lexer_nth_token_is (parser->lexer, 2,\n+\t\t\t\t\t     CPP_CLOSE_PAREN)))\n+\t{\n+\t  decl = ridpointers[RID_OMP_ALL_MEMORY];\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t}\n       else\n \t{\n \t  name = cp_parser_id_expression (parser, /*template_p=*/false,"}, {"sha": "06b4a7d197a39632a4f0c13974c8d589bd50998f", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -17601,8 +17601,8 @@ static tree\n tsubst_omp_clause_decl (tree decl, tree args, tsubst_flags_t complain,\n \t\t\ttree in_decl, tree *iterator_cache)\n {\n-  if (decl == NULL_TREE)\n-    return NULL_TREE;\n+  if (decl == NULL_TREE || decl == ridpointers[RID_OMP_ALL_MEMORY])\n+    return decl;\n \n   /* Handle OpenMP iterators.  */\n   if (TREE_CODE (decl) == TREE_LIST"}, {"sha": "61f49be32ff5390210a24fa9df72e452c3b64e9b", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -7815,6 +7815,20 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  if (t == error_mark_node)\n \t    remove = true;\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t   && t == ridpointers[RID_OMP_ALL_MEMORY])\n+\t    {\n+\t      if (OMP_CLAUSE_DEPEND_KIND (c) != OMP_CLAUSE_DEPEND_OUT\n+\t\t  && OMP_CLAUSE_DEPEND_KIND (c) != OMP_CLAUSE_DEPEND_INOUT)\n+\t\t{\n+\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t    \"%<omp_all_memory%> used with %<depend%> kind \"\n+\t\t\t    \"other than %<out%> or %<inout%>\");\n+\t\t  remove = true;\n+\t\t}\n+\t      if (processing_template_decl)\n+\t\tbreak;\n+\t    }\n \t  else if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n \t    break;\n \t  else if (!lvalue_p (t))\n@@ -7867,24 +7881,32 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  if (!remove)\n \t    {\n-\t      tree addr = cp_build_addr_expr (t, tf_warning_or_error);\n-\t      if (addr == error_mark_node)\n-\t\tremove = true;\n+\t      if (t == ridpointers[RID_OMP_ALL_MEMORY])\n+\t\tt = null_pointer_node;\n \t      else\n \t\t{\n+\t\t  tree addr = cp_build_addr_expr (t, tf_warning_or_error);\n+\t\t  if (addr == error_mark_node)\n+\t\t    {\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n \t\t  t = cp_build_indirect_ref (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t     addr, RO_UNARY_STAR,\n \t\t\t\t\t     tf_warning_or_error);\n \t\t  if (t == error_mark_node)\n-\t\t    remove = true;\n-\t\t  else if (TREE_CODE (OMP_CLAUSE_DECL (c)) == TREE_LIST\n-\t\t\t   && TREE_PURPOSE (OMP_CLAUSE_DECL (c))\n-\t\t\t   && (TREE_CODE (TREE_PURPOSE (OMP_CLAUSE_DECL (c)))\n-\t\t\t       == TREE_VEC))\n-\t\t    TREE_VALUE (OMP_CLAUSE_DECL (c)) = t;\n-\t\t  else\n-\t\t    OMP_CLAUSE_DECL (c) = t;\n+\t\t    {\n+\t\t      remove = true;\n+\t\t      break;\n+\t\t    }\n \t\t}\n+\t      if (TREE_CODE (OMP_CLAUSE_DECL (c)) == TREE_LIST\n+\t\t  && TREE_PURPOSE (OMP_CLAUSE_DECL (c))\n+\t\t  && (TREE_CODE (TREE_PURPOSE (OMP_CLAUSE_DECL (c)))\n+\t\t      == TREE_VEC))\n+\t\tTREE_VALUE (OMP_CLAUSE_DECL (c)) = t;\n+\t      else\n+\t\tOMP_CLAUSE_DECL (c) = t;\n \t    }\n \t  break;\n \tcase OMP_CLAUSE_DETACH:"}, {"sha": "13413d019c4be8c0550225f5f205dfb51fe2ff38", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -8623,7 +8623,8 @@ gimplify_omp_depend (tree *list_p, gimple_seq *pre_p)\n \t      }\n \t    if (error_operand_p (TREE_VALUE (t)))\n \t      return 2;\n-\t    TREE_VALUE (t) = build_fold_addr_expr (TREE_VALUE (t));\n+\t    if (TREE_VALUE (t) != null_pointer_node)\n+\t      TREE_VALUE (t) = build_fold_addr_expr (TREE_VALUE (t));\n \t    r = build4 (ARRAY_REF, ptr_type_node, array, cnts[i],\n \t\t\tNULL_TREE, NULL_TREE);\n \t    tem = build2_loc (OMP_CLAUSE_LOCATION (c), MODIFY_EXPR,\n@@ -8650,7 +8651,8 @@ gimplify_omp_depend (tree *list_p, gimple_seq *pre_p)\n \t      }\n \t    if (error_operand_p (OMP_CLAUSE_DECL (c)))\n \t      return 2;\n-\t    OMP_CLAUSE_DECL (c) = build_fold_addr_expr (OMP_CLAUSE_DECL (c));\n+\t    if (OMP_CLAUSE_DECL (c) != null_pointer_node)\n+\t      OMP_CLAUSE_DECL (c) = build_fold_addr_expr (OMP_CLAUSE_DECL (c));\n \t    if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p, NULL,\n \t\t\t       is_gimple_val, fb_rvalue) == GS_ERROR)\n \t      return 2;\n@@ -10346,12 +10348,15 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      remove = true;\n \t      break;\n \t    }\n-\t  OMP_CLAUSE_DECL (c) = build_fold_addr_expr (OMP_CLAUSE_DECL (c));\n-\t  if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p, NULL,\n-\t\t\t     is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t  if (OMP_CLAUSE_DECL (c) != null_pointer_node)\n \t    {\n-\t      remove = true;\n-\t      break;\n+\t      OMP_CLAUSE_DECL (c) = build_fold_addr_expr (OMP_CLAUSE_DECL (c));\n+\t      if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p, NULL,\n+\t\t\t\t is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t\t{\n+\t\t  remove = true;\n+\t\t  break;\n+\t\t}\n \t    }\n \t  if (code == OMP_TASK)\n \t    ctx->has_depend = true;"}, {"sha": "5d63e0d09394386db69b2cd24c4ddb868cf2b03a", "filename": "gcc/testsuite/c-c++-common/gomp/all-memory-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fall-memory-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fall-memory-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fall-memory-1.c?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -0,0 +1,52 @@\n+int omp_all_memory;\t\t\t/* { dg-error \"expected\" } */\n+\n+void\n+foo (void)\n+{\n+  int p = (&omp_all_memory)[0];\t\t/* { dg-error \"'omp_all_memory' may only be used in OpenMP 'depend' clause\" } */\n+}\n+\n+void\n+bar (void)\n+{\n+  int *omp_all_memory;\t\t\t/* { dg-error \"expected\" } */\n+}\n+\n+void\n+baz (void)\n+{\n+  struct omp_all_memory { int a; };\t/* { dg-error \"expected\" } */\n+}\n+\n+void\n+qux (void)\n+{\n+  union omp_all_memory { int a; };\t/* { dg-error \"expected\" } */\n+}\n+\n+void\n+corge (void)\n+{\n+  enum omp_all_memory { OAM; };\t\t/* { dg-error \"expected\" } */\n+}\n+\n+void\n+garply (void)\n+{\n+  enum E { omp_all_memory }; }\t\t/* { dg-error \"expected\" } */\n+\n+void\n+boo (void)\n+{\n+  int x, y;\n+  #pragma omp task private (omp_all_memory)\t\t\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task depend(inout: *&omp_all_memory)\t\t/* { dg-error \"'omp_all_memory' may only be used in OpenMP 'depend' clause\" } */\n+  ;\n+  #pragma omp task depend(inout: omp_all_memory[0])\t\t/* { dg-error \"'omp_all_memory' may only be used in OpenMP 'depend' clause\" } */\n+  ;\n+  #pragma omp task depend(in: omp_all_memory)\t\t\t/* { dg-error \"'omp_all_memory' used with 'depend' kind other than 'out' or 'inout'\" } */\n+  ;\n+  #pragma omp task depend(mutexinoutset: omp_all_memory)\t/* { dg-error \"'omp_all_memory' used with 'depend' kind other than 'out' or 'inout'\" } */\n+  ;\n+}"}, {"sha": "6f5d31be29ca8bfe969e907d262ba35ee57f7bca", "filename": "gcc/testsuite/c-c++-common/gomp/all-memory-2.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fall-memory-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fall-memory-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fall-memory-2.c?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-options \"-fno-openmp\" } */\n+\n+int omp_all_memory;\t\t\t/* { dg-bogus \"expected\" } */\n+\n+void\n+foo (void)\n+{\n+  int p = (&omp_all_memory)[0];\t\t/* { dg-bogus \"'omp_all_memory' may only be used in OpenMP 'depend' clause\" } */\n+}\n+\n+void\n+bar (void)\n+{\n+  int *omp_all_memory;\t\t\t/* { dg-bogus \"expected\" } */\n+}\n+\n+void\n+baz (void)\n+{\n+  struct omp_all_memory { int a; };\t/* { dg-bogus \"expected\" } */\n+}\n+\n+void\n+qux (void)\n+{\n+  union omp_all_memory { int a; };\t/* { dg-bogus \"expected\" } */\n+}\n+\n+void\n+corge (void)\n+{\n+  enum omp_all_memory { OAM };\t\t/* { dg-bogus \"expected\" } */\n+}\n+\n+void\n+garply (void)\n+{\n+  enum E { omp_all_memory };\t\t/* { dg-bogus \"expected\" } */\n+}\n+\n+void\n+boo (void)\n+{\n+  int x, y;\n+  #pragma omp task private (omp_all_memory)\n+  ;\n+  #pragma omp task depend(inout: *&omp_all_memory)\n+  ;\n+  #pragma omp task depend(inout: omp_all_memory[0])\n+  ;\n+  #pragma omp task depend(in: omp_all_memory)\n+  ;\n+  #pragma omp task depend(mutexinoutset: omp_all_memory)\n+  ;\n+}"}, {"sha": "f178b8d91f115c0102f5588c91f70bdd1f9ddbc6", "filename": "gcc/testsuite/c-c++-common/gomp/all-memory-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fall-memory-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fall-memory-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fall-memory-3.c?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -0,0 +1,22 @@\n+typedef struct __attribute__((__aligned__ (sizeof (void *)))) omp_depend_t {\n+  char __omp_depend_t__[2 * sizeof (void *)];\n+} omp_depend_t;\n+\n+omp_depend_t z;\n+\n+void\n+foo (void)\n+{\n+  int x = 0, y = 0;\n+  #pragma omp task depend(out: omp_all_memory)\n+  ;\n+  #pragma omp task depend(inout: omp_all_memory)\n+  ;\n+  #pragma omp task depend(out: x, omp_all_memory, y)\n+  ;\n+  #pragma omp task depend(inout: omp_all_memory, y)\n+  ;\n+  #pragma omp task depend(out: x, omp_all_memory)\n+  ;\n+  #pragma omp depobj (z) depend (inout: omp_all_memory)\n+}"}, {"sha": "8f3358df8b193e0c8fbc816260f89373b0558165", "filename": "gcc/testsuite/g++.dg/gomp/all-memory-1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fall-memory-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fall-memory-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fall-memory-1.C?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -0,0 +1,24 @@\n+namespace A\n+{\n+  namespace omp_all_memory\t\t// { dg-error \"expected\" }\n+  {\n+  }\n+}\n+\n+namespace B\n+{\n+  template <int N>\n+  void omp_all_memory () {}\t\t// { dg-error \"expected\" }\n+}\n+\n+namespace C\n+{\n+  template <int N>\n+  struct omp_all_memory {};\t\t// { dg-error \"expected\" }\n+}\n+\n+namespace D\n+{\n+  template <int omp_all_memory>\t\t// { dg-error \"expected\" }\n+  struct S {};\n+}"}, {"sha": "1acf3915a923c76dfdb9f003e19cfa3b86ffa0e8", "filename": "gcc/testsuite/g++.dg/gomp/all-memory-2.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fall-memory-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fall-memory-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fall-memory-2.C?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -0,0 +1,26 @@\n+// { dg-options \"-fno-openmp\" }\n+\n+namespace A\n+{\n+  namespace omp_all_memory\t\t// { dg-bogus \"expected\" }\n+  {\n+  }\n+}\n+\n+namespace B\n+{\n+  template <int N>\n+  void omp_all_memory () {}\t\t// { dg-bogus \"expected\" }\n+}\n+\n+namespace C\n+{\n+  template <int N>\n+  struct omp_all_memory {};\t\t// { dg-bogus \"expected\" }\n+}\n+\n+namespace D\n+{\n+  template <int omp_all_memory>\t\t// { dg-bogus \"expected\" }\n+  struct S {};\n+}"}, {"sha": "d7615aa51a86960669f8cbecb6ab0326ddfba533", "filename": "gcc/tree-pretty-print.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftree-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/gcc%2Ftree-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.cc?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -850,7 +850,10 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \t    pp_string (pp, name);\n \t    pp_colon (pp);\n \t  }\n-\tdump_generic_node (pp, t, spc, flags, false);\n+\tif (t == null_pointer_node)\n+\t  pp_string (pp, \"omp_all_memory\");\n+\telse\n+\t  dump_generic_node (pp, t, spc, flags, false);\n \tpp_right_paren (pp);\n       }\n       break;"}, {"sha": "295d10fd0c349f5bae825962a28ab685ab358947", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -574,6 +574,8 @@ struct gomp_task\n   struct gomp_dependers_vec *dependers;\n   struct htab *depend_hash;\n   struct gomp_taskwait *taskwait;\n+  /* Last depend({,in}out:omp_all_memory) child if any.  */\n+  struct gomp_task *depend_all_memory;\n   /* Number of items in DEPEND.  */\n   size_t depend_count;\n   /* Number of tasks this task depends on.  Once this counter reaches"}, {"sha": "db4a6f71fb76512121192e504f52f89f7ae00b79", "filename": "libgomp/task.c", "status": "modified", "additions": 167, "deletions": 1, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Ftask.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Ftask.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftask.c?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -80,6 +80,7 @@ gomp_init_task (struct gomp_task *task, struct gomp_task *parent_task,\n   task->dependers = NULL;\n   task->depend_hash = NULL;\n   task->taskwait = NULL;\n+  task->depend_all_memory = NULL;\n   task->depend_count = 0;\n   task->completion_sem = NULL;\n   task->deferred_p = false;\n@@ -171,6 +172,7 @@ gomp_task_handle_depend (struct gomp_task *task, struct gomp_task *parent,\n   size_t ndepend = (uintptr_t) depend[0];\n   size_t i;\n   hash_entry_type ent;\n+  bool all_memory = false;\n \n   if (ndepend)\n     {\n@@ -181,6 +183,7 @@ gomp_task_handle_depend (struct gomp_task *task, struct gomp_task *parent,\n \t{\n \t  task->depend[i].addr = depend[2 + i];\n \t  task->depend[i].is_in = i >= nout;\n+\t  all_memory |= i < nout && depend[2 + i] == NULL;\n \t}\n     }\n   else\n@@ -201,6 +204,8 @@ gomp_task_handle_depend (struct gomp_task *task, struct gomp_task *parent,\n \t    {\n \t    case GOMP_DEPEND_OUT:\n \t    case GOMP_DEPEND_INOUT:\n+\t      all_memory |= d[0] == NULL;\n+\t      break;\n \t    case GOMP_DEPEND_MUTEXINOUTSET:\n \t      break;\n \t    case GOMP_DEPEND_IN:\n@@ -226,8 +231,126 @@ gomp_task_handle_depend (struct gomp_task *task, struct gomp_task *parent,\n \t  task->depend[n++].is_in = 1;\n \t}\n     }\n-  task->depend_count = ndepend;\n   task->num_dependees = 0;\n+  if (__builtin_expect (parent->depend_all_memory && ndepend, false))\n+    {\n+      struct gomp_task *tsk = parent->depend_all_memory;\n+      if (tsk->dependers == NULL)\n+\t{\n+\t  tsk->dependers\n+\t    = gomp_malloc (sizeof (struct gomp_dependers_vec)\n+\t\t\t   + 6 * sizeof (struct gomp_task *));\n+\t  tsk->dependers->n_elem = 1;\n+\t  tsk->dependers->allocated = 6;\n+\t  tsk->dependers->elem[0] = task;\n+\t}\n+      else\n+\t{\n+\t  if (tsk->dependers->n_elem == tsk->dependers->allocated)\n+\t    {\n+\t      tsk->dependers->allocated\n+\t\t= tsk->dependers->allocated * 2 + 2;\n+\t      tsk->dependers\n+\t\t= gomp_realloc (tsk->dependers,\n+\t\t\t\tsizeof (struct gomp_dependers_vec)\n+\t\t\t\t+ (tsk->dependers->allocated\n+\t\t\t\t   * sizeof (struct gomp_task *)));\n+\t    }\n+\t  tsk->dependers->elem[tsk->dependers->n_elem++] = task;\n+\t}\n+      task->num_dependees++;\n+    }\n+  if (__builtin_expect (all_memory, false))\n+    {\n+      /* A task with depend(inout: omp_all_memory) depends on all previous\n+\t sibling tasks which have any dependencies and all later sibling\n+\t tasks which have any dependencies depend on it.  */\n+      task->depend_count = 1;\n+      task->depend[0].addr = NULL;\n+      task->depend[0].next = NULL;\n+      task->depend[0].prev = NULL;\n+      task->depend[0].task = task;\n+      task->depend[0].redundant = true;\n+      task->depend[0].redundant_out = false;\n+      if (parent->depend_hash)\n+\t{\n+\t  /* Inlined htab_traverse + htab_clear.  All newer siblings can\n+\t     just depend on this task.  Add dependencies on all previous\n+\t     sibling tasks with dependencies and make them redundant and\n+\t     clear the hash table.  */\n+\t  hash_entry_type *slot = &parent->depend_hash->entries[0];\n+\t  hash_entry_type *end = slot + htab_size (parent->depend_hash);\n+\t  for (; slot != end; ++slot)\n+\t    {\n+\t      if (*slot == HTAB_EMPTY_ENTRY)\n+\t\tcontinue;\n+\t      if (*slot != HTAB_DELETED_ENTRY)\n+\t\t{\n+\t\t  for (ent = *slot; ent; ent = ent->next)\n+\t\t    {\n+\t\t      struct gomp_task *tsk = ent->task;\n+\n+\t\t      if (ent->redundant_out)\n+\t\t\tbreak;\n+\n+\t\t      ent->redundant = true;\n+\t\t      if (tsk->dependers == NULL)\n+\t\t\t{\n+\t\t\t  tsk->dependers\n+\t\t\t    = gomp_malloc (sizeof (struct gomp_dependers_vec)\n+\t\t\t\t\t   + 6 * sizeof (struct gomp_task *));\n+\t\t\t  tsk->dependers->n_elem = 1;\n+\t\t\t  tsk->dependers->allocated = 6;\n+\t\t\t  tsk->dependers->elem[0] = task;\n+\t\t\t  task->num_dependees++;\n+\t\t\t  continue;\n+\t\t\t}\n+\t\t      /* We already have some other dependency on tsk from\n+\t\t\t earlier depend clause.  */\n+\t\t      else if (tsk->dependers->n_elem\n+\t\t\t       && (tsk->dependers->elem[tsk->dependers->n_elem\n+\t\t\t\t\t\t\t- 1] == task))\n+\t\t\tcontinue;\n+\t\t      else if (tsk->dependers->n_elem\n+\t\t\t       == tsk->dependers->allocated)\n+\t\t\t{\n+\t\t\t  tsk->dependers->allocated\n+\t\t\t    = tsk->dependers->allocated * 2 + 2;\n+\t\t\t  tsk->dependers\n+\t\t\t    = gomp_realloc (tsk->dependers,\n+\t\t\t\t\t    sizeof (struct gomp_dependers_vec)\n+\t\t\t\t\t    + (tsk->dependers->allocated\n+\t\t\t\t\t       * sizeof (struct gomp_task *)));\n+\t\t\t}\n+\t\t      tsk->dependers->elem[tsk->dependers->n_elem++] = task;\n+\t\t      task->num_dependees++;\n+\t\t    }\n+\t\t  while (ent)\n+\t\t    {\n+\t\t      ent->redundant = true;\n+\t\t      ent = ent->next;\n+\t\t    }\n+\t\t}\n+\t      *slot = HTAB_EMPTY_ENTRY;\n+\t    }\n+\t  if (htab_size (parent->depend_hash) <= 32)\n+\t    {\n+\t      parent->depend_hash->n_elements = 0;\n+\t      parent->depend_hash->n_deleted = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Shrink the hash table if it would be too large.\n+\t\t We don't want to walk e.g. megabytes of empty hash\n+\t\t table for every depend(inout: omp_all_memory).  */\n+\t      free (parent->depend_hash);\n+\t      parent->depend_hash = htab_create (12);\n+\t    }\n+\t}\n+      parent->depend_all_memory = task;\n+      return;\n+    }\n+  task->depend_count = ndepend;\n   if (parent->depend_hash == NULL)\n     parent->depend_hash = htab_create (2 * ndepend > 12 ? 2 * ndepend : 12);\n   for (i = 0; i < ndepend; i++)\n@@ -1175,6 +1298,8 @@ gomp_task_run_post_handle_depend_hash (struct gomp_task *child_task)\n   struct gomp_task *parent = child_task->parent;\n   size_t i;\n \n+  if (parent->depend_all_memory == child_task)\n+    parent->depend_all_memory = NULL;\n   for (i = 0; i < child_task->depend_count; i++)\n     if (!child_task->depend[i].redundant)\n       {\n@@ -1738,6 +1863,17 @@ gomp_task_maybe_wait_for_dependencies (void **depend)\n       n = 5;\n     }\n   gomp_mutex_lock (&team->task_lock);\n+  if (__builtin_expect (task->depend_all_memory && ndepend, false))\n+    {\n+      struct gomp_task *tsk = task->depend_all_memory;\n+      if (!tsk->parent_depends_on)\n+\t{\n+\t  tsk->parent_depends_on = true;\n+\t  ++num_awaited;\n+\t  if (tsk->num_dependees == 0 && tsk->kind == GOMP_TASK_WAITING)\n+\t    priority_queue_upgrade_task (tsk, task);\n+\t}\n+    }\n   for (i = 0; i < ndepend; i++)\n     {\n       elem.addr = depend[i + n];\n@@ -1760,6 +1896,36 @@ gomp_task_maybe_wait_for_dependencies (void **depend)\n \t    }\n \t  elem.addr = d[0];\n \t}\n+      if (__builtin_expect (elem.addr == NULL && !elem.is_in, false))\n+\t{\n+\t  size_t size = htab_size (task->depend_hash);\n+\t  if (htab_elements (task->depend_hash) * 8 < size && size > 32)\n+\t    htab_expand (task->depend_hash);\n+\n+\t  /* depend(inout: omp_all_memory) - depend on all previous\n+\t     sibling tasks that do have dependencies.  Inlined\n+\t     htab_traverse.  */\n+\t  hash_entry_type *slot = &task->depend_hash->entries[0];\n+\t  hash_entry_type *end = slot + htab_size (task->depend_hash);\n+\t  for (; slot != end; ++slot)\n+\t    {\n+\t      if (*slot == HTAB_EMPTY_ENTRY || *slot == HTAB_DELETED_ENTRY)\n+\t\tcontinue;\n+\t      for (ent = *slot; ent; ent = ent->next)\n+\t\t{\n+\t\t  struct gomp_task *tsk = ent->task;\n+\t\t  if (!tsk->parent_depends_on)\n+\t\t    {\n+\t\t      tsk->parent_depends_on = true;\n+\t\t      ++num_awaited;\n+\t\t      if (tsk->num_dependees == 0\n+\t\t\t  && tsk->kind == GOMP_TASK_WAITING)\n+\t\t\tpriority_queue_upgrade_task (tsk, task);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  break;\n+\t}\n       ent = htab_find (task->depend_hash, &elem);\n       for (; ent; ent = ent->next)\n \tif (elem.is_in && ent->is_in)"}, {"sha": "3376b99b18c3db7f52fa785cf483f0b3deda1ced", "filename": "libgomp/testsuite/libgomp.c-c++-common/depend-1.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-1.c?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -0,0 +1,110 @@\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+void\n+test (int ifval)\n+{\n+  int a[8], b[8], i;\n+  for (i = 0; i < 8; i++)\n+    {\n+      a[i] = i;\n+      b[i] = 2 * i;\n+    }\n+  #pragma omp parallel\n+  #pragma omp single\n+  {\n+    #pragma omp task shared(a) depend(in: a[0])\n+    {\n+      usleep (5000);\n+      a[0] = 42;\n+    }\n+    #pragma omp task shared(a) depend(out: a[1])\n+    {\n+      usleep (5000);\n+      a[1] = 43;\n+    }\n+    #pragma omp task shared(a) depend(inout: a[2])\n+    {\n+      usleep (5000);\n+      a[2] = 44;\n+    }\n+    #pragma omp task shared(a) depend(mutexinoutset: a[3])\n+    {\n+      usleep (5000);\n+      a[3] = 45;\n+    }\n+    #pragma omp task shared(a)\n+    {\n+      usleep (15000);\n+      a[4] = 46;\n+    }\n+    #pragma omp task shared(b) depend(in: b[0])\n+    {\n+      usleep (5000);\n+      b[0] = 47;\n+    }\n+    #pragma omp task shared(b) depend(in: b[4])\n+    {\n+      usleep (5000);\n+      b[4] = 48;\n+    }\n+    /* None of the above tasks depend on each other.\n+       The following task depends on all but the a[4] = 46; one.  */\n+    #pragma omp task shared(a, b) depend(out: omp_all_memory) private(i) if(ifval)\n+    {\n+      if (a[0] != 42 || a[1] != 43 || a[2] != 44 || a[3] != 45\n+\t  || a[5] != 5 || a[6] != 6 || a[7] != 7\n+\t  || b[0] != 47 || b[1] != 2 || b[2] != 4 || b[3] != 6\n+\t  || b[4] != 48 || b[5] != 10 || b[6] != 12 || b[7] != 14)\n+\tabort ();\n+      for (i = 0; i < 8; ++i)\n+\tif (i != 4)\n+\t  a[i] = 3 * i + 7;\n+      for (i = 0; i < 8; ++i)\n+\tb[i] = 4 * i - 7;\n+    }\n+    /* The following task depends on both b[0] = 47; and\n+       above omp_all_memory tasks, but as the latter depends on\n+       the former, effectively it is dependent just on the omp_all_memory\n+       task.  */\n+    #pragma omp task shared(b) depend(inout: b[0])\n+    {\n+      usleep (5000);\n+      b[0] = 49;\n+    }\n+    /* The following task depends on all the above except a[4] = 46; one,\n+       but it can be reduced to dependency on the above omp_all_memory\n+       one and b[0] = 49; one.  */\n+    #pragma omp task shared(a, b) depend(inout: b[7], omp_all_memory, b[6]) \\\n+\t\t     private(i) if(ifval)\n+    {\n+      for (i = 0; i < 8; ++i)\n+\tif (i != 4)\n+\t  {\n+\t    if (a[i] != 3 * i + 7)\n+\t      abort ();\n+\t    a[i] = 5 * i + 50;\n+\t  }\n+      if (b[0] != 49)\n+\tabort ();\n+      b[0] = 6 * i + 57;\n+      for (i = 1; i < 8; ++i)\n+\t{\n+\t  if (b[i] != 4 * i - 7) \n+\t    abort ();\n+\t  b[i] = 6 * i + 57;\n+\t}\n+    }\n+    #pragma omp taskwait\n+    if (a[4] != 46)\n+      abort ();\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  test (1);\n+  test (0);\n+  return 0;\n+}"}, {"sha": "d7b533555c43a4df8d181f6740349fc67786e010", "filename": "libgomp/testsuite/libgomp.c-c++-common/depend-2.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-2.c?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -0,0 +1,116 @@\n+#include <omp.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+void\n+test (int ifval)\n+{\n+  int a[8], b[8], i;\n+  omp_depend_t d1, d2;\n+  #pragma omp depobj (d1) depend(inout: omp_all_memory) \n+  #pragma omp depobj (d2) depend(out: omp_all_memory)\n+  for (i = 0; i < 8; i++)\n+    {\n+      a[i] = i;\n+      b[i] = 2 * i;\n+    }\n+  #pragma omp parallel\n+  #pragma omp single\n+  {\n+    #pragma omp task shared(a) depend(in: a[0])\n+    {\n+      usleep (5000);\n+      a[0] = 42;\n+    }\n+    #pragma omp task shared(a) depend(out: a[1])\n+    {\n+      usleep (5000);\n+      a[1] = 43;\n+    }\n+    #pragma omp task shared(a) depend(inout: a[2])\n+    {\n+      usleep (5000);\n+      a[2] = 44;\n+    }\n+    #pragma omp task shared(a) depend(mutexinoutset: a[3])\n+    {\n+      usleep (5000);\n+      a[3] = 45;\n+    }\n+    #pragma omp task shared(a)\n+    {\n+      usleep (15000);\n+      a[4] = 46;\n+    }\n+    #pragma omp task shared(b) depend(in: b[0])\n+    {\n+      usleep (5000);\n+      b[0] = 47;\n+    }\n+    #pragma omp task shared(b) depend(in: b[4])\n+    {\n+      usleep (5000);\n+      b[4] = 48;\n+    }\n+    /* None of the above tasks depend on each other.\n+       The following task depends on all but the a[4] = 46; one.  */\n+    #pragma omp task shared(a, b) depend(depobj: d1) private(i) if(ifval)\n+    {\n+      if (a[0] != 42 || a[1] != 43 || a[2] != 44 || a[3] != 45\n+\t  || a[5] != 5 || a[6] != 6 || a[7] != 7\n+\t  || b[0] != 47 || b[1] != 2 || b[2] != 4 || b[3] != 6\n+\t  || b[4] != 48 || b[5] != 10 || b[6] != 12 || b[7] != 14)\n+\tabort ();\n+      for (i = 0; i < 8; ++i)\n+\tif (i != 4)\n+\t  a[i] = 3 * i + 7;\n+      for (i = 0; i < 8; ++i)\n+\tb[i] = 4 * i - 7;\n+    }\n+    /* The following task depends on both b[0] = 47; and\n+       above omp_all_memory tasks, but as the latter depends on\n+       the former, effectively it is dependent just on the omp_all_memory\n+       task.  */\n+    #pragma omp task shared(b) depend(inout: b[0])\n+    {\n+      usleep (5000);\n+      b[0] = 49;\n+    }\n+    /* The following task depends on all the above except a[4] = 46; one,\n+       but it can be reduced to dependency on the above omp_all_memory\n+       one and b[0] = 49; one.  */\n+    #pragma omp task shared(a, b) depend(inout: b[6]) depend(depobj: d2) \\\n+\t\t     depend(out: b[7]) private(i) if(ifval)\n+    {\n+      for (i = 0; i < 8; ++i)\n+\tif (i != 4)\n+\t  {\n+\t    if (a[i] != 3 * i + 7)\n+\t      abort ();\n+\t    a[i] = 5 * i + 50;\n+\t  }\n+      if (b[0] != 49)\n+\tabort ();\n+      b[0] = 6 * i + 57;\n+      for (i = 1; i < 8; ++i)\n+\t{\n+\t  if (b[i] != 4 * i - 7) \n+\t    abort ();\n+\t  b[i] = 6 * i + 57;\n+\t}\n+    }\n+    #pragma omp taskwait\n+    if (a[4] != 46)\n+      abort ();\n+  }\n+  #pragma omp depobj (d2) destroy\n+  #pragma omp depobj (d1) destroy\n+}\n+\n+int\n+main ()\n+{\n+  test (1);\n+  test (0);\n+  return 0;\n+}"}, {"sha": "052e77c81e12e0137c2ea193717d09037db205db", "filename": "libgomp/testsuite/libgomp.c-c++-common/depend-3.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78783dbedca0183d193e475262ca3c489fd365/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fdepend-3.c?ref=7f78783dbedca0183d193e475262ca3c489fd365", "patch": "@@ -0,0 +1,103 @@\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+int\n+main ()\n+{\n+  int a[8], b[8], i;\n+  for (i = 0; i < 8; i++)\n+    {\n+      a[i] = i;\n+      b[i] = 2 * i;\n+    }\n+  #pragma omp parallel\n+  #pragma omp single\n+  {\n+    #pragma omp task shared(a) depend(in: a[0])\n+    {\n+      usleep (5000);\n+      a[0] = 42;\n+    }\n+    #pragma omp task shared(a) depend(out: a[1])\n+    {\n+      usleep (5000);\n+      a[1] = 43;\n+    }\n+    #pragma omp task shared(a) depend(inout: a[2])\n+    {\n+      usleep (5000);\n+      a[2] = 44;\n+    }\n+    #pragma omp task shared(a) depend(mutexinoutset: a[3])\n+    {\n+      usleep (5000);\n+      a[3] = 45;\n+    }\n+    #pragma omp task shared(a)\n+    {\n+      usleep (15000);\n+      a[4] = 46;\n+    }\n+    #pragma omp task shared(b) depend(in: b[0])\n+    {\n+      usleep (5000);\n+      b[0] = 47;\n+    }\n+    #pragma omp task shared(b) depend(in: b[4])\n+    {\n+      usleep (5000);\n+      b[4] = 48;\n+    }\n+    /* None of the above tasks depend on each other.\n+       The following task depends on all but the a[4] = 46; one.  */\n+    #pragma omp task shared(a, b) depend(iterator (j=0:7), inout: omp_all_memory) private(i)\n+    {\n+      if (a[0] != 42 || a[1] != 43 || a[2] != 44 || a[3] != 45\n+\t  || a[5] != 5 || a[6] != 6 || a[7] != 7\n+\t  || b[0] != 47 || b[1] != 2 || b[2] != 4 || b[3] != 6\n+\t  || b[4] != 48 || b[5] != 10 || b[6] != 12 || b[7] != 14)\n+\tabort ();\n+      for (i = 0; i < 8; ++i)\n+\tif (i != 4)\n+\t  a[i] = 3 * i + 7;\n+      for (i = 0; i < 8; ++i)\n+\tb[i] = 4 * i - 7;\n+    }\n+    /* The following task depends on both b[0] = 47; and\n+       above omp_all_memory tasks, but as the latter depends on\n+       the former, effectively it is dependent just on the omp_all_memory\n+       task.  */\n+    #pragma omp task shared(b) depend(inout: b[0])\n+    {\n+      usleep (5000);\n+      b[0] = 49;\n+    }\n+    /* The following task depends on all the above except a[4] = 46; one,\n+       but it can be reduced to dependency on the above omp_all_memory\n+       one and b[0] = 49; one.  */\n+    #pragma omp task shared(a, b) depend(inout: b[7]) depend(iterator(j=4:5), out: omp_all_memory) \\\n+\t\t     depend(inout: b[6]) private(i)\n+    {\n+      for (i = 0; i < 8; ++i)\n+\tif (i != 4)\n+\t  {\n+\t    if (a[i] != 3 * i + 7)\n+\t      abort ();\n+\t    a[i] = 5 * i + 50;\n+\t  }\n+      if (b[0] != 49)\n+\tabort ();\n+      b[0] = 6 * i + 57;\n+      for (i = 1; i < 8; ++i)\n+\t{\n+\t  if (b[i] != 4 * i - 7) \n+\t    abort ();\n+\t  b[i] = 6 * i + 57;\n+\t}\n+    }\n+    #pragma omp taskwait\n+    if (a[4] != 46)\n+      abort ();\n+  }\n+  return 0;\n+}"}]}