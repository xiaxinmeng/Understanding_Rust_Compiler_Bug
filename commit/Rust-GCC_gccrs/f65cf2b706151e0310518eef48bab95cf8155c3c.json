{"sha": "f65cf2b706151e0310518eef48bab95cf8155c3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY1Y2YyYjcwNjE1MWUwMzEwNTE4ZWVmNDhiYWI5NWNmODE1NWMzYw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-01-14T23:00:59Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-01-14T23:00:59Z"}, "message": "re PR tree-optimization/45934 (g++.old-deja/g++.other/dtor5.C FAILs with -finline-small-functions)\n\n2011-01-14  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/45934\n\tPR tree-optimization/46302\n\t* ipa-prop.c (type_change_info): New type.\n\t(stmt_may_be_vtbl_ptr_store): New function.\n\t(check_stmt_for_type_change): Likewise.\n\t(detect_type_change): Likewise.\n\t(detect_type_change_ssa): Likewise.\n\t(compute_complex_assign_jump_func): Check for dynamic type change.\n\t(compute_complex_ancestor_jump_func): Likewise.\n\t(compute_known_type_jump_func): Likewise.\n\t(compute_scalar_jump_functions): Likewise.\n\t(ipa_analyze_virtual_call_uses): Likewise.\n\t(ipa_analyze_node): Push and pop cfun, set current_function_decl.\n\n\t* testsuite/g++.dg/ipa/devirt-c-1.C: New test.\n\t* testsuite/g++.dg/ipa/devirt-c-2.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-c-3.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-c-4.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-c-5.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-c-6.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-6.C: Likewise.\n\t* testsuite/g++.dg/ipa/devirt-d-1.C: Likewise.\n\t* testsuite/g++.dg/torture/pr45934.C: Likewise.\n\nFrom-SVN: r168825", "tree": {"sha": "4d29e7117ee16a5f9008d05eba9ee4b04ac9cecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d29e7117ee16a5f9008d05eba9ee4b04ac9cecf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f65cf2b706151e0310518eef48bab95cf8155c3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65cf2b706151e0310518eef48bab95cf8155c3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f65cf2b706151e0310518eef48bab95cf8155c3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65cf2b706151e0310518eef48bab95cf8155c3c/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc0d2dae5a60054f04b687335e5c561ece6d4c36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0d2dae5a60054f04b687335e5c561ece6d4c36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc0d2dae5a60054f04b687335e5c561ece6d4c36"}], "stats": {"total": 865, "additions": 840, "deletions": 25}, "files": [{"sha": "d4d7dc4d5abdf12e64758c28e40d471f9f892225", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -1,3 +1,19 @@\n+2011-01-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/45934\n+\tPR tree-optimization/46302\n+\t* ipa-prop.c (type_change_info): New type.\n+\t(stmt_may_be_vtbl_ptr_store): New function.\n+\t(check_stmt_for_type_change): Likewise.\n+\t(detect_type_change): Likewise.\n+\t(detect_type_change_ssa): Likewise.\n+\t(compute_complex_assign_jump_func): Check for dynamic type change.\n+\t(compute_complex_ancestor_jump_func): Likewise.\n+\t(compute_known_type_jump_func): Likewise.\n+\t(compute_scalar_jump_functions): Likewise.\n+\t(ipa_analyze_virtual_call_uses): Likewise.\n+\t(ipa_analyze_node): Push and pop cfun, set current_function_decl.\n+\n 2011-01-14  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/i386/i386.h (CC1_CPU_SPEC_1): Don't handle -msse5."}, {"sha": "fd672218b4b56741f0342ea8ebd34306ea54a12e", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 187, "deletions": 25, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -350,6 +350,153 @@ ipa_print_all_jump_functions (FILE *f)\n     }\n }\n \n+/* Structure to be passed in between detect_type_change and\n+   check_stmt_for_type_change.  */\n+\n+struct type_change_info\n+{\n+  /* Set to true if dynamic type change has been detected.  */\n+  bool type_maybe_changed;\n+};\n+\n+/* Return true if STMT can modify a virtual method table pointer.\n+\n+   This function makes special assumptions about both constructors and\n+   destructors which are all the functions that are allowed to alter the VMT\n+   pointers.  It assumes that destructors begin with assignment into all VMT\n+   pointers and that constructors essentially look in the following way:\n+\n+   1) The very first thing they do is that they call constructors of ancestor\n+   sub-objects that have them.\n+\n+   2) Then VMT pointers of this and all its ancestors is set to new values\n+   corresponding to the type corresponding to the constructor.\n+\n+   3) Only afterwards, other stuff such as constructor of member sub-objects\n+   and the code written by the user is run.  Only this may include calling\n+   virtual functions, directly or indirectly.\n+\n+   There is no way to call a constructor of an ancestor sub-object in any\n+   other way.\n+\n+   This means that we do not have to care whether constructors get the correct\n+   type information because they will always change it (in fact, if we define\n+   the type to be given by the VMT pointer, it is undefined).\n+\n+   The most important fact to derive from the above is that if, for some\n+   statement in the section 3, we try to detect whether the dynamic type has\n+   changed, we can safely ignore all calls as we examine the function body\n+   backwards until we reach statements in section 2 because these calls cannot\n+   be ancestor constructors or destructors (if the input is not bogus) and so\n+   do not change the dynamic type (this holds true only for automatically\n+   allocated objects but at the moment we devirtualize only these).  We then\n+   must detect that statements in section 2 change the dynamic type and can try\n+   to derive the new type.  That is enough and we can stop, we will never see\n+   the calls into constructors of sub-objects in this code.  Therefore we can\n+   safely ignore all call statements that we traverse.\n+  */\n+\n+static bool\n+stmt_may_be_vtbl_ptr_store (gimple stmt)\n+{\n+  if (is_gimple_call (stmt))\n+    return false;\n+  else if (is_gimple_assign (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (stmt);\n+\n+      if (TREE_CODE (lhs) == COMPONENT_REF\n+\t  && !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1))\n+\t  && !AGGREGATE_TYPE_P (TREE_TYPE (lhs)))\n+\t    return false;\n+      /* In the future we might want to use get_base_ref_and_offset to find\n+\t if there is a field corresponding to the offset and if so, proceed\n+\t almost like if it was a component ref.  */\n+    }\n+  return true;\n+}\n+\n+/* Callbeck of walk_aliased_vdefs and a helper function for\n+   detect_type_change to check whether a particular statement may modify\n+   the virtual table pointer, and if possible also determine the new type of\n+   the (sub-)object.  It stores its result into DATA, which points to a\n+   type_change_info structure.  */\n+\n+static bool\n+check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (vdef);\n+  struct type_change_info *tci = (struct type_change_info *) data;\n+\n+  if (stmt_may_be_vtbl_ptr_store (stmt))\n+    {\n+      tci->type_maybe_changed = true;\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Detect whether the dynamic type of ARG has changed (before callsite CALL) by\n+   looking for assignments to its virtual table pointer.  If it is, return true\n+   and fill in the jump function JFUNC with relevant type information or set it\n+   to unknown.  ARG is the object itself (not a pointer to it, unless\n+   dereferenced).  BASE is the base of the memory access as returned by\n+   get_ref_base_and_extent, as is the offset.  */\n+\n+static bool\n+detect_type_change (tree arg, tree base, gimple call,\n+\t\t    struct ipa_jump_func *jfunc, HOST_WIDE_INT offset)\n+{\n+  struct type_change_info tci;\n+  ao_ref ao;\n+\n+  gcc_checking_assert (DECL_P (arg)\n+\t\t       || TREE_CODE (arg) == MEM_REF\n+\t\t       || handled_component_p (arg));\n+  /* Const calls cannot call virtual methods through VMT and so type changes do\n+     not matter.  */\n+  if (!gimple_vuse (call))\n+    return false;\n+\n+  tci.type_maybe_changed = false;\n+\n+  ao.ref = arg;\n+  ao.base = base;\n+  ao.offset = offset;\n+  ao.size = POINTER_SIZE;\n+  ao.max_size = ao.size;\n+  ao.ref_alias_set = -1;\n+  ao.base_alias_set = -1;\n+\n+  walk_aliased_vdefs (&ao, gimple_vuse (call), check_stmt_for_type_change,\n+\t\t      &tci, NULL);\n+  if (!tci.type_maybe_changed)\n+    return false;\n+\n+  jfunc->type = IPA_JF_UNKNOWN;\n+  return true;\n+}\n+\n+/* Like detect_type_change but ARG is supposed to be a non-dereferenced pointer\n+   SSA name (its dereference will become the base and the offset is assumed to\n+   be zero).  */\n+\n+static bool\n+detect_type_change_ssa (tree arg, gimple call, struct ipa_jump_func *jfunc)\n+{\n+  gcc_checking_assert (TREE_CODE (arg) == SSA_NAME);\n+  if (!POINTER_TYPE_P (TREE_TYPE (arg))\n+      || TREE_CODE (TREE_TYPE (TREE_TYPE (arg))) != RECORD_TYPE)\n+    return false;\n+\n+  arg = build2 (MEM_REF, ptr_type_node, arg,\n+                build_int_cst (ptr_type_node, 0));\n+\n+  return detect_type_change (arg, arg, call, jfunc, 0);\n+}\n+\n+\n /* Given that an actual argument is an SSA_NAME (given in NAME) and is a result\n    of an assignment statement STMT, try to find out whether NAME can be\n    described by a (possibly polynomial) pass-through jump-function or an\n@@ -359,10 +506,10 @@ ipa_print_all_jump_functions (FILE *f)\n static void\n compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t\t\t\t  struct ipa_jump_func *jfunc,\n-\t\t\t\t  gimple stmt, tree name)\n+\t\t\t\t  gimple call, gimple stmt, tree name)\n {\n   HOST_WIDE_INT offset, size, max_size;\n-  tree op1, op2, base, type;\n+  tree op1, op2, base, ssa;\n   int index;\n \n   op1 = gimple_assign_rhs1 (stmt);\n@@ -388,7 +535,8 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \t  jfunc->value.pass_through.operation = gimple_assign_rhs_code (stmt);\n \t  jfunc->value.pass_through.operand = op2;\n \t}\n-      else if (gimple_assign_unary_nop_p (stmt))\n+      else if (gimple_assign_unary_nop_p (stmt)\n+\t       && !detect_type_change_ssa (op1, call, jfunc))\n \t{\n \t  jfunc->type = IPA_JF_PASS_THROUGH;\n \t  jfunc->value.pass_through.formal_id = index;\n@@ -399,10 +547,8 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n \n   if (TREE_CODE (op1) != ADDR_EXPR)\n     return;\n-\n   op1 = TREE_OPERAND (op1, 0);\n-  type = TREE_TYPE (op1);\n-  if (TREE_CODE (type) != RECORD_TYPE)\n+  if (TREE_CODE (TREE_TYPE (op1)) != RECORD_TYPE)\n     return;\n   base = get_ref_base_and_extent (op1, &offset, &size, &max_size);\n   if (TREE_CODE (base) != MEM_REF\n@@ -411,20 +557,21 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n       || max_size != size)\n     return;\n   offset += mem_ref_offset (base).low * BITS_PER_UNIT;\n-  base = TREE_OPERAND (base, 0);\n-  if (TREE_CODE (base) != SSA_NAME\n-      || !SSA_NAME_IS_DEFAULT_DEF (base)\n+  ssa = TREE_OPERAND (base, 0);\n+  if (TREE_CODE (ssa) != SSA_NAME\n+      || !SSA_NAME_IS_DEFAULT_DEF (ssa)\n       || offset < 0)\n     return;\n \n   /* Dynamic types are changed only in constructors and destructors and  */\n-  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (base));\n-  if (index >= 0)\n+  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (ssa));\n+  if (index >= 0\n+      && !detect_type_change (op1, base, call, jfunc, offset))\n     {\n       jfunc->type = IPA_JF_ANCESTOR;\n       jfunc->value.ancestor.formal_id = index;\n       jfunc->value.ancestor.offset = offset;\n-      jfunc->value.ancestor.type = type;\n+      jfunc->value.ancestor.type = TREE_TYPE (op1);\n     }\n }\n \n@@ -453,12 +600,12 @@ compute_complex_assign_jump_func (struct ipa_node_params *info,\n static void\n compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n \t\t\t\t    struct ipa_jump_func *jfunc,\n-\t\t\t\t    gimple phi)\n+\t\t\t\t    gimple call, gimple phi)\n {\n   HOST_WIDE_INT offset, size, max_size;\n   gimple assign, cond;\n   basic_block phi_bb, assign_bb, cond_bb;\n-  tree tmp, parm, expr;\n+  tree tmp, parm, expr, obj;\n   int index, i;\n \n   if (gimple_phi_num_args (phi) != 2)\n@@ -486,6 +633,7 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n   if (TREE_CODE (expr) != ADDR_EXPR)\n     return;\n   expr = TREE_OPERAND (expr, 0);\n+  obj = expr;\n   expr = get_ref_base_and_extent (expr, &offset, &size, &max_size);\n \n   if (TREE_CODE (expr) != MEM_REF\n@@ -513,7 +661,6 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n       || !integer_zerop (gimple_cond_rhs (cond)))\n     return;\n \n-\n   phi_bb = gimple_bb (phi);\n   for (i = 0; i < 2; i++)\n     {\n@@ -522,18 +669,22 @@ compute_complex_ancestor_jump_func (struct ipa_node_params *info,\n \treturn;\n     }\n \n-  jfunc->type = IPA_JF_ANCESTOR;\n-  jfunc->value.ancestor.formal_id = index;\n-  jfunc->value.ancestor.offset = offset;\n-  jfunc->value.ancestor.type = TREE_TYPE (TREE_TYPE (tmp));\n+  if (!detect_type_change (obj, expr, call, jfunc, offset))\n+    {\n+      jfunc->type = IPA_JF_ANCESTOR;\n+      jfunc->value.ancestor.formal_id = index;\n+      jfunc->value.ancestor.offset = offset;\n+      jfunc->value.ancestor.type = TREE_TYPE (obj);;\n+    }\n }\n \n /* Given OP whch is passed as an actual argument to a called function,\n    determine if it is possible to construct a KNOWN_TYPE jump function for it\n    and if so, create one and store it to JFUNC.  */\n \n static void\n-compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc)\n+compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc,\n+\t\t\t      gimple call)\n {\n   HOST_WIDE_INT offset, size, max_size;\n   tree base, binfo;\n@@ -551,6 +702,9 @@ compute_known_type_jump_func (tree op, struct ipa_jump_func *jfunc)\n       || is_global_var (base))\n     return;\n \n+  if (detect_type_change (op, base, call, jfunc, offset))\n+    return;\n+\n   binfo = TYPE_BINFO (TREE_TYPE (base));\n   if (!binfo)\n     return;\n@@ -592,7 +746,8 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \t    {\n \t      int index = ipa_get_param_decl_index (info, SSA_NAME_VAR (arg));\n \n-\t      if (index >= 0)\n+\t      if (index >= 0\n+\t\t  && !detect_type_change_ssa (arg, call, &functions[num]))\n \t\t{\n \t\t  functions[num].type = IPA_JF_PASS_THROUGH;\n \t\t  functions[num].value.pass_through.formal_id = index;\n@@ -604,14 +759,14 @@ compute_scalar_jump_functions (struct ipa_node_params *info,\n \t      gimple stmt = SSA_NAME_DEF_STMT (arg);\n \t      if (is_gimple_assign (stmt))\n \t\tcompute_complex_assign_jump_func (info, &functions[num],\n-\t\t\t\t\t\t  stmt, arg);\n+\t\t\t\t\t\t  call, stmt, arg);\n \t      else if (gimple_code (stmt) == GIMPLE_PHI)\n \t\tcompute_complex_ancestor_jump_func (info, &functions[num],\n-\t\t\t\t\t\t    stmt);\n+\t\t\t\t\t\t    call, stmt);\n \t    }\n \t}\n       else\n-\tcompute_known_type_jump_func (arg, &functions[num]);\n+\tcompute_known_type_jump_func (arg, &functions[num], call);\n     }\n }\n \n@@ -1218,6 +1373,7 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n \t\t\t       struct ipa_node_params *info, gimple call,\n \t\t\t       tree target)\n {\n+  struct ipa_jump_func jfunc;\n   tree obj = OBJ_TYPE_REF_OBJECT (target);\n   tree var;\n   int index;\n@@ -1241,7 +1397,8 @@ ipa_analyze_virtual_call_uses (struct cgraph_node *node,\n   var = SSA_NAME_VAR (obj);\n   index = ipa_get_param_decl_index (info, var);\n \n-  if (index >= 0)\n+  if (index >= 0\n+      && !detect_type_change_ssa (obj, call, &jfunc))\n     ipa_note_param_call (node, index, call, true);\n }\n \n@@ -1364,6 +1521,8 @@ ipa_analyze_node (struct cgraph_node *node)\n   struct param_analysis_info *parms_info;\n   int i, param_count;\n \n+  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+  current_function_decl = node->decl;\n   ipa_initialize_node_params (node);\n \n   param_count = ipa_get_param_count (info);\n@@ -1376,6 +1535,9 @@ ipa_analyze_node (struct cgraph_node *node)\n   for (i = 0; i < param_count; i++)\n     if (parms_info[i].visited_statements)\n       BITMAP_FREE (parms_info[i].visited_statements);\n+\n+  current_function_decl = NULL;\n+  pop_cfun ();\n }\n \n "}, {"sha": "b1d5a5f13cf0314b7623c1969c100595c3daaa38", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -1,3 +1,17 @@\n+2011-01-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR tree-optimization/45934\n+\tPR tree-optimization/46302\n+\t* g++.dg/ipa/devirt-c-1.C: New test.\n+\t* g++.dg/ipa/devirt-c-2.C: Likewise.\n+\t* g++.dg/ipa/devirt-c-3.C: Likewise.\n+\t* g++.dg/ipa/devirt-c-4.C: Likewise.\n+\t* g++.dg/ipa/devirt-c-5.C: Likewise.\n+\t* g++.dg/ipa/devirt-c-6.C: Likewise.\n+\t* g++.dg/ipa/devirt-6.C: Likewise.\n+\t* g++.dg/ipa/devirt-d-1.C: Likewise.\n+\t* g++.dg/torture/pr45934.C: Likewise.\n+\n 2011-01-14  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/variadic105.C: New."}, {"sha": "e9a5d7093b9f40858b2a9d000fbd007eab5712f6", "filename": "gcc/testsuite/g++.dg/ipa/devirt-6.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-6.C?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -0,0 +1,38 @@\n+/* Verify that we either do not do any devirtualization or correctly\n+   spot that foo changes the dynamic type of the passed object.  */\n+\n+/* { dg-do run } */\n+/* { dg-options \"-O3\"  } */\n+\n+extern \"C\" void abort (void);\n+extern \"C\" void *malloc(__SIZE_TYPE__);\n+\n+inline void* operator new(__SIZE_TYPE__, void* __p) throw() { return __p;}\n+\n+int x;\n+\n+class A {\n+public:\n+   virtual ~A() { }\n+};\n+\n+class B : public A {\n+public:\n+   virtual ~B() { if (x == 1) abort (); x = 1; }\n+};\n+\n+void __attribute__((noinline,noclone)) foo (void *p)\n+{\n+ B *b = reinterpret_cast<B *>(p);\n+ b->~B();\n+ new (p) A;\n+}\n+\n+int main()\n+{\n+ void *p = __builtin_malloc (sizeof (B));\n+ new (p) B;\n+ foo(p);\n+ reinterpret_cast<A *>(p)->~A();\n+ return 0;\n+}"}, {"sha": "df2230d4c66af7e9d63f8a07e7862ee82533d03c", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-1.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-1.C?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -0,0 +1,71 @@\n+/* Verify that ipa-cp correctly detects the dynamic type of an object\n+   under construction when doing devirtualization.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  A();\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+static int middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+A::A ()\n+{\n+  if (middleman (this, get_input ()) != 2)\n+    abort ();\n+}\n+\n+static void bah ()\n+{\n+  class B b;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    bah ();\n+  return 0;\n+}"}, {"sha": "d37fe50cda2c0eb6858f977f7ccd8bc838ae2f98", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-2.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-2.C?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -0,0 +1,79 @@\n+/* Verify that ipa-cp correctly detects the dynamic type of an object\n+   under construction when doing devirtualization.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class Distraction\n+{\n+public:\n+  float f;\n+  double d;\n+  Distraction ()\n+  {\n+    f = 8.3;\n+    d = 10.2;\n+  }\n+  virtual float bar (float z);\n+};\n+\n+class A\n+{\n+public:\n+  int data;\n+  A();\n+  virtual int foo (int i);\n+};\n+\n+class B : public Distraction, public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+float Distraction::bar (float z)\n+{\n+  f += z;\n+  return f/2;\n+}\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static int middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+A::A()\n+{\n+  if (middleman (this, get_input ()) != 2)\n+    abort ();\n+}\n+\n+static void bah ()\n+{\n+  class B b;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    bah ();\n+  return 0;\n+}"}, {"sha": "c8791f79e64f859dea609b60cc8e6b6eb013be75", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-3.C", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-3.C?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -0,0 +1,80 @@\n+/* Verify that ipa-cp correctly detects the dynamic type of an object\n+   under construction when doing devirtualization.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-inline\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class Distraction\n+{\n+public:\n+  float f;\n+  double d;\n+  Distraction ()\n+  {\n+    f = 8.3;\n+    d = 10.2;\n+  }\n+  virtual float bar (float z);\n+};\n+\n+class A\n+{\n+public:\n+  int data;\n+  A();\n+  virtual int foo (int i);\n+};\n+\n+class B : public Distraction, public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+float Distraction::bar (float z)\n+{\n+  f += z;\n+  return f/2;\n+}\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static int __attribute__ ((noinline))\n+middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+inline __attribute__ ((always_inline)) A::A()\n+{\n+  if (middleman (this, get_input ()) != 2)\n+    abort ();\n+}\n+\n+static void bah ()\n+{\n+  class B b;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    bah ();\n+  return 0;\n+}"}, {"sha": "56d41e4967e3f966a14152e0ac58df9f154854c4", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-4.C", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-4.C?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -0,0 +1,110 @@\n+/* Verify that ipa-cp correctly detects the dynamic type of an object\n+   under construction when doing devirtualization.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-inline\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class Distraction\n+{\n+public:\n+  float f;\n+  double d;\n+  Distraction ()\n+  {\n+    f = 8.3;\n+    d = 10.2;\n+  }\n+  virtual float bar (float z);\n+};\n+\n+class A\n+{\n+public:\n+  int data;\n+  A();\n+  virtual int foo (int i);\n+};\n+\n+class B : public Distraction, public A\n+{\n+public:\n+  B();\n+  virtual int foo (int i);\n+};\n+\n+class C : public B\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+\n+float Distraction::bar (float z)\n+{\n+  f += z;\n+  return f/2;\n+}\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static int __attribute__ ((noinline))\n+middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+static void __attribute__ ((noinline))\n+sth2 (A *a)\n+{\n+  if (a->foo (get_input ()) != 3)\n+    abort ();\n+}\n+\n+inline void __attribute__ ((always_inline)) sth1 (B *b)\n+{\n+  sth2 (b);\n+}\n+\n+inline __attribute__ ((always_inline)) A::A()\n+{\n+  if (middleman (this, get_input ()) != 2)\n+    abort ();\n+}\n+\n+B::B() : Distraction(), A()\n+{\n+  sth1 (this);\n+}\n+\n+static void bah ()\n+{\n+  class C c;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    bah ();\n+  return 0;\n+}"}, {"sha": "637d7d4be1bc8aa3b7731f984ce71f3114831cbb", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-5.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-5.C?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -0,0 +1,79 @@\n+/* Verify that ipa-cp correctly detects the dynamic type of an object\n+   under construction when doing devirtualization.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class B;\n+\n+class A\n+{\n+public:\n+  int data;\n+  A();\n+  A(B *b);\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+static int middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+A::A ()\n+{\n+}\n+\n+A::A (B *b)\n+{\n+  if (middleman (b, get_input ()) != 3)\n+    abort ();\n+}\n+\n+static void bah ()\n+{\n+  B b;\n+  A a(&b);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    bah ();\n+  return 0;\n+}"}, {"sha": "f9b8b6954c8a64c6e65a838caba3f558f809021d", "filename": "gcc/testsuite/g++.dg/ipa/devirt-c-6.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-c-6.C?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -0,0 +1,72 @@\n+/* Verify that ipa-cp correctly detects the dynamic type of an object\n+   under construction when doing devirtualization.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-inline\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  A();\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+static inline int __attribute__ ((always_inline))\n+middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+__attribute__ ((noinline)) A::A ()\n+{\n+  if (middleman (this, get_input ()) != 2)\n+    abort ();\n+}\n+\n+static void bah ()\n+{\n+  class B b;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    bah ();\n+  return 0;\n+}"}, {"sha": "3897a7782b3adaafd0f35007d8383eeff113ed02", "filename": "gcc/testsuite/g++.dg/ipa/devirt-d-1.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-d-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-d-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-d-1.C?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -0,0 +1,71 @@\n+/* Verify that ipa-cp correctly detects the dynamic type of an object\n+   under destruction when doing devirtualization.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -fno-early-inlining -fno-inline\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class A\n+{\n+public:\n+  int data;\n+  ~A();\n+  virtual int foo (int i);\n+};\n+\n+class B : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+class C : public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int C::foo (int i)\n+{\n+  return i + 3;\n+}\n+\n+static int middleman (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+A::~A ()\n+{\n+  if (middleman (this, get_input ()) != 2)\n+    abort ();\n+}\n+\n+static void bah ()\n+{\n+  class B b;\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  int i;\n+\n+  for (i = 0; i < 10; i++)\n+    bah ();\n+  return 0;\n+}"}, {"sha": "f43964107c2e492341a2eaee370af2b773e7ab9b", "filename": "gcc/testsuite/g++.dg/torture/pr45934.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr45934.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65cf2b706151e0310518eef48bab95cf8155c3c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr45934.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr45934.C?ref=f65cf2b706151e0310518eef48bab95cf8155c3c", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+\n+extern \"C\" void abort ();\n+\n+struct B *b;\n+\n+struct B\n+{\n+  virtual void f () { }\n+  ~B() { b->f(); }\n+};\n+\n+struct D : public B\n+{\n+  virtual void f () { abort (); }\n+};\n+\n+int main ()\n+{\n+  D d;\n+  b = &d;\n+  return 0;\n+}"}]}