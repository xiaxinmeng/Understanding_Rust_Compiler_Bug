{"sha": "6969eb0dcfe75fd7175f2971ef2a350ebc087805", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk2OWViMGRjZmU3NWZkNzE3NWYyOTcxZWYyYTM1MGViYzA4NzgwNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2014-09-22T07:38:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-09-22T07:38:12Z"}, "message": "hard-reg-set.h: Include hash-table.h.\n\ngcc/\n\t* hard-reg-set.h: Include hash-table.h.\n\t(target_hard_regs): Add a finalize method and a x_simplifiable_subregs\n\tfield.\n\t* target-globals.c (target_globals::~target_globals): Call\n\thard_regs->finalize.\n\t* rtl.h (subreg_shape): New structure.\n\t(shape_of_subreg): New function.\n\t(simplifiable_subregs): Declare.\n\t* reginfo.c (simplifiable_subreg): New structure.\n\t(simplifiable_subregs_hasher): Likewise.\n\t(simplifiable_subregs): New function.\n\t(invalid_mode_changes): Delete.\n\t(alid_mode_changes, valid_mode_changes_obstack): New variables.\n\t(record_subregs_of_mode): Remove subregs_of_mode parameter.\n\tRecord valid mode changes in valid_mode_changes.\n\t(find_subregs_of_mode): Remove subregs_of_mode parameter.\n\tUpdate calls to record_subregs_of_mode.\n\t(init_subregs_of_mode): Remove invalid_mode_changes and bitmap\n\thandling.  Initialize new variables.  Update call to\n\tfind_subregs_of_mode.\n\t(invalid_mode_change_p): Check new variables instead of\n\tinvalid_mode_changes.\n\t(finish_subregs_of_mode): Finalize new variables instead of\n\tinvalid_mode_changes.\n\t(target_hard_regs::finalize): New function.\n\t* ira-costs.c (print_allocno_costs): Call invalid_mode_change_p\n\teven when CLASS_CANNOT_CHANGE_MODE is undefined.\n\nFrom-SVN: r215449", "tree": {"sha": "c22e285369e1c4471ca4321ef553f4227182b181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c22e285369e1c4471ca4321ef553f4227182b181"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6969eb0dcfe75fd7175f2971ef2a350ebc087805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6969eb0dcfe75fd7175f2971ef2a350ebc087805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6969eb0dcfe75fd7175f2971ef2a350ebc087805", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6969eb0dcfe75fd7175f2971ef2a350ebc087805/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7af3b946a4181ba5ae292a4a2ff905a4ae999073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7af3b946a4181ba5ae292a4a2ff905a4ae999073", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7af3b946a4181ba5ae292a4a2ff905a4ae999073"}], "stats": {"total": 258, "additions": 198, "deletions": 60}, "files": [{"sha": "5f6d4a3545053b4d965bbd8f64a136c3be14ecd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6969eb0dcfe75fd7175f2971ef2a350ebc087805", "patch": "@@ -1,3 +1,33 @@\n+2014-09-22  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* hard-reg-set.h: Include hash-table.h.\n+\t(target_hard_regs): Add a finalize method and a x_simplifiable_subregs\n+\tfield.\n+\t* target-globals.c (target_globals::~target_globals): Call\n+\thard_regs->finalize.\n+\t* rtl.h (subreg_shape): New structure.\n+\t(shape_of_subreg): New function.\n+\t(simplifiable_subregs): Declare.\n+\t* reginfo.c (simplifiable_subreg): New structure.\n+\t(simplifiable_subregs_hasher): Likewise.\n+\t(simplifiable_subregs): New function.\n+\t(invalid_mode_changes): Delete.\n+\t(alid_mode_changes, valid_mode_changes_obstack): New variables.\n+\t(record_subregs_of_mode): Remove subregs_of_mode parameter.\n+\tRecord valid mode changes in valid_mode_changes.\n+\t(find_subregs_of_mode): Remove subregs_of_mode parameter.\n+\tUpdate calls to record_subregs_of_mode.\n+\t(init_subregs_of_mode): Remove invalid_mode_changes and bitmap\n+\thandling.  Initialize new variables.  Update call to\n+\tfind_subregs_of_mode.\n+\t(invalid_mode_change_p): Check new variables instead of\n+\tinvalid_mode_changes.\n+\t(finish_subregs_of_mode): Finalize new variables instead of\n+\tinvalid_mode_changes.\n+\t(target_hard_regs::finalize): New function.\n+\t* ira-costs.c (print_allocno_costs): Call invalid_mode_change_p\n+\teven when CLASS_CANNOT_CHANGE_MODE is undefined.\n+\n 2014-09-22  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* combine.c (subst): Use simplify_subreg_regno rather than"}, {"sha": "c32516c6913c7fcc9c2e7e20e0b303fe8ddaa788", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=6969eb0dcfe75fd7175f2971ef2a350ebc087805", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_HARD_REG_SET_H\n #define GCC_HARD_REG_SET_H\n \n+#include \"hash-table.h\"\n+\n /* Define the type of a set of hard registers.  */\n \n /* HARD_REG_ELT_TYPE is a typedef of the unsigned integral type which\n@@ -613,7 +615,11 @@ hard_reg_set_iter_next (hard_reg_set_iterator *iter, unsigned *regno)\n \n extern char global_regs[FIRST_PSEUDO_REGISTER];\n \n+struct simplifiable_subregs_hasher;\n+\n struct target_hard_regs {\n+  void finalize ();\n+\n   /* The set of registers that actually exist on the current target.  */\n   HARD_REG_SET x_accessible_reg_set;\n \n@@ -688,6 +694,10 @@ struct target_hard_regs {\n \n   /* Vector indexed by hardware reg giving its name.  */\n   const char *x_reg_names[FIRST_PSEUDO_REGISTER];\n+\n+  /* Records which registers can form a particular subreg, with the subreg\n+     being identified by its outer mode, inner mode and offset.  */\n+  hash_table <simplifiable_subregs_hasher> *x_simplifiable_subregs;\n };\n \n extern struct target_hard_regs default_target_hard_regs;"}, {"sha": "38d0e0edeee82e788a924dd806163c5968a1b8e6", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=6969eb0dcfe75fd7175f2971ef2a350ebc087805", "patch": "@@ -1438,10 +1438,7 @@ print_allocno_costs (FILE *f)\n \t{\n \t  rclass = cost_classes[k];\n \t  if (contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (regno)]\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t      && ! invalid_mode_change_p (regno, (enum reg_class) rclass)\n-#endif\n-\t      )\n+\t      && ! invalid_mode_change_p (regno, (enum reg_class) rclass))\n \t    {\n \t      fprintf (f, \" %s:%d\", reg_class_names[rclass],\n \t\t       COSTS (costs, i)->cost[k]);\n@@ -1480,10 +1477,7 @@ print_pseudo_costs (FILE *f)\n \t{\n \t  rclass = cost_classes[k];\n \t  if (contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (regno)]\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t      && ! invalid_mode_change_p (regno, (enum reg_class) rclass)\n-#endif\n-\t      )\n+\t      && ! invalid_mode_change_p (regno, (enum reg_class) rclass))\n \t    fprintf (f, \" %s:%d\", reg_class_names[rclass],\n \t\t     COSTS (costs, regno)->cost[k]);\n \t}\n@@ -1725,10 +1719,7 @@ find_costs_and_classes (FILE *dump_file)\n \t      /* Ignore classes that are too small or invalid for this\n \t\t operand.  */\n \t      if (! contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (i)]\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t\t  || invalid_mode_change_p (i, (enum reg_class) rclass)\n-#endif\n-\t\t  )\n+\t\t  || invalid_mode_change_p (i, (enum reg_class) rclass))\n \t\tcontinue;\n \t      if (i_costs[k] < best_cost)\n \t\t{\n@@ -1822,10 +1813,7 @@ find_costs_and_classes (FILE *dump_file)\n \t\t      /* Ignore classes that are too small or invalid\n \t\t\t for this operand.  */\n \t\t      if (! contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (i)]\n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\t\t\t  || invalid_mode_change_p (i, (enum reg_class) rclass)\n-#endif\n-\t\t\t  )\n+\t\t\t  || invalid_mode_change_p (i, (enum reg_class) rclass))\n \t\t\t;\n \t\t      else if (total_a_costs[k] < best_cost)\n \t\t\t{"}, {"sha": "226152278b4a03a03883830476d3bc1ab3f5bad5", "filename": "gcc/reginfo.c", "status": "modified", "additions": 92, "deletions": 44, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=6969eb0dcfe75fd7175f2971ef2a350ebc087805", "patch": "@@ -54,6 +54,24 @@ along with GCC; see the file COPYING3.  If not see\n \n int max_regno;\n \n+/* Used to cache the results of simplifiable_subregs.  SHAPE is the input\n+   parameter and SIMPLIFIABLE_REGS is the result.  */\n+struct simplifiable_subreg\n+{\n+  simplifiable_subreg (const subreg_shape &);\n+\n+  subreg_shape shape;\n+  HARD_REG_SET simplifiable_regs;\n+};\n+\n+struct simplifiable_subregs_hasher : typed_noop_remove <simplifiable_subreg>\n+{\n+  typedef simplifiable_subreg value_type;\n+  typedef subreg_shape compare_type;\n+\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n \f\n struct target_hard_regs default_target_hard_regs;\n struct target_regs default_target_regs;\n@@ -1193,64 +1211,102 @@ reg_classes_intersect_p (reg_class_t c1, reg_class_t c2)\n }\n \n \f\n+inline hashval_t\n+simplifiable_subregs_hasher::hash (const value_type *value)\n+{\n+  return value->shape.unique_id ();\n+}\n+\n+inline bool\n+simplifiable_subregs_hasher::equal (const value_type *value,\n+\t\t\t\t    const compare_type *compare)\n+{\n+  return value->shape == *compare;\n+}\n+\n+inline simplifiable_subreg::simplifiable_subreg (const subreg_shape &shape_in)\n+  : shape (shape_in)\n+{\n+  CLEAR_HARD_REG_SET (simplifiable_regs);\n+}\n+\n+/* Return the set of hard registers that are able to form the subreg\n+   described by SHAPE.  */\n+\n+const HARD_REG_SET &\n+simplifiable_subregs (const subreg_shape &shape)\n+{\n+  if (!this_target_hard_regs->x_simplifiable_subregs)\n+    this_target_hard_regs->x_simplifiable_subregs\n+      = new hash_table <simplifiable_subregs_hasher> (30);\n+  simplifiable_subreg **slot\n+    = (this_target_hard_regs->x_simplifiable_subregs\n+       ->find_slot_with_hash (&shape, shape.unique_id (), INSERT));\n+\n+  if (!*slot)\n+    {\n+      simplifiable_subreg *info = new simplifiable_subreg (shape);\n+      for (unsigned int i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n+\tif (HARD_REGNO_MODE_OK (i, shape.inner_mode)\n+\t    && simplify_subreg_regno (i, shape.inner_mode, shape.offset,\n+\t\t\t\t      shape.outer_mode) >= 0)\n+\t  SET_HARD_REG_BIT (info->simplifiable_regs, i);\n+      *slot = info;\n+    }\n+  return (*slot)->simplifiable_regs;\n+}\n \n /* Passes for keeping and updating info about modes of registers\n    inside subregisters.  */\n \n-#ifdef CANNOT_CHANGE_MODE_CLASS\n-\n-static bitmap invalid_mode_changes;\n+static HARD_REG_SET **valid_mode_changes;\n+static obstack valid_mode_changes_obstack;\n \n static void\n-record_subregs_of_mode (rtx subreg, bitmap subregs_of_mode)\n+record_subregs_of_mode (rtx subreg)\n {\n-  enum machine_mode mode;\n   unsigned int regno;\n \n   if (!REG_P (SUBREG_REG (subreg)))\n     return;\n \n   regno = REGNO (SUBREG_REG (subreg));\n-  mode = GET_MODE (subreg);\n-\n   if (regno < FIRST_PSEUDO_REGISTER)\n     return;\n \n-  if (bitmap_set_bit (subregs_of_mode,\n-\t\t      regno * NUM_MACHINE_MODES + (unsigned int) mode))\n+  if (valid_mode_changes[regno])\n+    AND_HARD_REG_SET (*valid_mode_changes[regno],\n+\t\t      simplifiable_subregs (shape_of_subreg (subreg)));\n+  else\n     {\n-      unsigned int rclass;\n-      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n-\tif (!bitmap_bit_p (invalid_mode_changes,\n-\t\t\t   regno * N_REG_CLASSES + rclass)\n-\t    && CANNOT_CHANGE_MODE_CLASS (PSEUDO_REGNO_MODE (regno),\n-\t\t\t\t\t mode, (enum reg_class) rclass))\n-\t  bitmap_set_bit (invalid_mode_changes,\n-\t\t\t  regno * N_REG_CLASSES + rclass);\n+      valid_mode_changes[regno]\n+\t= XOBNEW (&valid_mode_changes_obstack, HARD_REG_SET);\n+      COPY_HARD_REG_SET (*valid_mode_changes[regno],\n+\t\t\t simplifiable_subregs (shape_of_subreg (subreg)));\n     }\n }\n \n /* Call record_subregs_of_mode for all the subregs in X.  */\n static void\n-find_subregs_of_mode (rtx x, bitmap subregs_of_mode)\n+find_subregs_of_mode (rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   const char * const fmt = GET_RTX_FORMAT (code);\n   int i;\n \n   if (code == SUBREG)\n-    record_subregs_of_mode (x, subregs_of_mode);\n+    record_subregs_of_mode (x);\n \n   /* Time for some deep diving.  */\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tfind_subregs_of_mode (XEXP (x, i), subregs_of_mode);\n+\tfind_subregs_of_mode (XEXP (x, i));\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    find_subregs_of_mode (XVECEXP (x, i, j), subregs_of_mode);\n+\t    find_subregs_of_mode (XVECEXP (x, i, j));\n \t}\n     }\n }\n@@ -1260,46 +1316,38 @@ init_subregs_of_mode (void)\n {\n   basic_block bb;\n   rtx_insn *insn;\n-  bitmap_obstack srom_obstack;\n-  bitmap subregs_of_mode;\n \n-  gcc_assert (invalid_mode_changes == NULL);\n-  invalid_mode_changes = BITMAP_ALLOC (NULL);\n-  bitmap_obstack_initialize (&srom_obstack);\n-  subregs_of_mode = BITMAP_ALLOC (&srom_obstack);\n+  gcc_obstack_init (&valid_mode_changes_obstack);\n+  valid_mode_changes = XCNEWVEC (HARD_REG_SET *, max_reg_num ());\n \n   FOR_EACH_BB_FN (bb, cfun)\n     FOR_BB_INSNS (bb, insn)\n       if (NONDEBUG_INSN_P (insn))\n-        find_subregs_of_mode (PATTERN (insn), subregs_of_mode);\n-\n-  BITMAP_FREE (subregs_of_mode);\n-  bitmap_obstack_release (&srom_obstack);\n+        find_subregs_of_mode (PATTERN (insn));\n }\n \n /* Return 1 if REGNO has had an invalid mode change in CLASS from FROM\n    mode.  */\n bool\n-invalid_mode_change_p (unsigned int regno,\n-\t\t       enum reg_class rclass)\n+invalid_mode_change_p (unsigned int regno, enum reg_class rclass)\n {\n-  return bitmap_bit_p (invalid_mode_changes,\n-\t\t       regno * N_REG_CLASSES + (unsigned) rclass);\n+  return (valid_mode_changes[regno]\n+\t  && !hard_reg_set_intersect_p (reg_class_contents[rclass],\n+\t\t\t\t\t*valid_mode_changes[regno]));\n }\n \n void\n finish_subregs_of_mode (void)\n {\n-  BITMAP_FREE (invalid_mode_changes);\n-}\n-#else\n-void\n-init_subregs_of_mode (void)\n-{\n+  XDELETEVEC (valid_mode_changes);\n+  obstack_finish (&valid_mode_changes_obstack);\n }\n+\n+/* Free all data attached to the structure.  This isn't a destructor because\n+   we don't want to run on exit.  */\n+\n void\n-finish_subregs_of_mode (void)\n+target_hard_regs::finalize ()\n {\n+  delete x_simplifiable_subregs;\n }\n-\n-#endif /* CANNOT_CHANGE_MODE_CLASS */"}, {"sha": "e73f73154386fdd67eaa2671ee37f87f2ff339b6", "filename": "gcc/rtl.h", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6969eb0dcfe75fd7175f2971ef2a350ebc087805", "patch": "@@ -1831,6 +1831,64 @@ costs_add_n_insns (struct full_rtx_costs *c, int n)\n   c->size += COSTS_N_INSNS (n);\n }\n \n+/* Describes the shape of a subreg:\n+\n+   inner_mode == the mode of the SUBREG_REG\n+   offset     == the SUBREG_BYTE\n+   outer_mode == the mode of the SUBREG itself.  */\n+struct subreg_shape {\n+  subreg_shape (enum machine_mode, unsigned int, enum machine_mode);\n+  bool operator == (const subreg_shape &) const;\n+  bool operator != (const subreg_shape &) const;\n+  unsigned int unique_id () const;\n+\n+  enum machine_mode inner_mode;\n+  unsigned int offset;\n+  enum machine_mode outer_mode;\n+};\n+\n+inline\n+subreg_shape::subreg_shape (enum machine_mode inner_mode_in,\n+\t\t\t    unsigned int offset_in,\n+\t\t\t    enum machine_mode outer_mode_in)\n+  : inner_mode (inner_mode_in), offset (offset_in), outer_mode (outer_mode_in)\n+{}\n+\n+inline bool\n+subreg_shape::operator == (const subreg_shape &other) const\n+{\n+  return (inner_mode == other.inner_mode\n+\t  && offset == other.offset\n+\t  && outer_mode == other.outer_mode);\n+}\n+\n+inline bool\n+subreg_shape::operator != (const subreg_shape &other) const\n+{\n+  return !operator == (other);\n+}\n+\n+/* Return an integer that uniquely identifies this shape.  Structures\n+   like rtx_def assume that a mode can fit in an 8-bit bitfield and no\n+   current mode is anywhere near being 65536 bytes in size, so the\n+   id comfortably fits in an int.  */\n+\n+inline unsigned int\n+subreg_shape::unique_id () const\n+{\n+  STATIC_ASSERT (MAX_MACHINE_MODE <= 256);\n+  return (int) inner_mode + ((int) outer_mode << 8) + (offset << 16);\n+}\n+\n+/* Return the shape of a SUBREG rtx.  */\n+\n+static inline subreg_shape\n+shape_of_subreg (const_rtx x)\n+{\n+  return subreg_shape (GET_MODE (SUBREG_REG (x)),\n+\t\t       SUBREG_BYTE (x), GET_MODE (x));\n+}\n+\n /* Information about an address.  This structure is supposed to be able\n    to represent all supported target addresses.  Please extend it if it\n    is not yet general enough.  */\n@@ -2727,6 +2785,9 @@ extern bool val_signbit_known_clear_p (enum machine_mode,\n /* In reginfo.c  */\n extern enum machine_mode choose_hard_reg_mode (unsigned int, unsigned int,\n \t\t\t\t\t       bool);\n+#ifdef HARD_CONST\n+extern const HARD_REG_SET &simplifiable_subregs (const subreg_shape &);\n+#endif\n \n /* In emit-rtl.c  */\n extern rtx set_for_reg_notes (rtx);"}, {"sha": "52ac2c02dfcb47817fa113bd2e70115ee2363aaf", "filename": "gcc/target-globals.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6969eb0dcfe75fd7175f2971ef2a350ebc087805/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=6969eb0dcfe75fd7175f2971ef2a350ebc087805", "patch": "@@ -125,6 +125,7 @@ target_globals::~target_globals ()\n   /* default_target_globals points to static data so shouldn't be freed.  */\n   if (this != &default_target_globals)\n     {\n+      hard_regs->finalize ();\n       XDELETE (flag_state);\n       XDELETE (regs);\n       XDELETE (recog);"}]}