{"sha": "c765c8cb73b0bb91e9f0401ab6567b6218b910e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc2NWM4Y2I3M2IwYmI5MWU5ZjA0MDFhYjY1NjdiNjIxOGI5MTBlNQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2018-06-06T21:11:15Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-06-06T21:11:15Z"}, "message": "re PR target/85657 (Make __ibm128 a separate type, even if long double uses the IBM double-double format)\n\n[gcc]\n2018-06-06  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_passes_ieee128): New boolean to\n\ttrack if we pass or return IEEE 128-bit floating point.\n\t(ieee128_mangling_gcc_8_1): New boolean to say whether to generate\n\tC++ mangling that is compatible with GCC 8.1.\n\t(TARGET_ASM_GLOBALIZE_DECL_NAME): Override target hook.\n\t(init_cumulative_args): Note if we pass or return IEEE 128-bit\n\tfloating point types.\n\t(rs6000_function_arg_advance_1): Likewise.\n\t(rs6000_mangle_type): Optionally generate mangled names that match\n\twhat GCC 8.1 generated for IEEE 128-bit floating point types.\n\t(rs6000_globalize_decl_name): If we have an external function that\n\tpasses or returns IEEE 128-bit types, generate a weak reference\n\tfrom the mangled name used in GCC 8.1 to the current mangled\n\tname.\n\n[gcc]\n2018-06-05  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_init_builtins): Make __ibm128 use\n\tthe long double type if long double is IBM extended double.  Make\n\t__float128 use the long double type if long double is IEEE 128-bit.\n\n[gcc/testsuite]\n2018-06-05  Michael Meissner  <meissner@linux.ibm.com>\n\n\tPR target/85657\n\t* g++.dg/pr85657.C: Only test whether __ibm128 and long double can\n\tbe used in templates.  Don't check for them in overloaded functions.\n\nFrom-SVN: r261246", "tree": {"sha": "275dcfb6667d7feb398c5115a168ec6bb4c1016b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/275dcfb6667d7feb398c5115a168ec6bb4c1016b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c765c8cb73b0bb91e9f0401ab6567b6218b910e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c765c8cb73b0bb91e9f0401ab6567b6218b910e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c765c8cb73b0bb91e9f0401ab6567b6218b910e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c765c8cb73b0bb91e9f0401ab6567b6218b910e5/comments", "author": null, "committer": null, "parents": [{"sha": "9d67f13e6afe013a65c1e910bf8fdda976dcd1ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d67f13e6afe013a65c1e910bf8fdda976dcd1ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d67f13e6afe013a65c1e910bf8fdda976dcd1ad"}], "stats": {"total": 134, "additions": 103, "deletions": 31}, "files": [{"sha": "f82ccb3d6e85e39e2c277754983b5e24baaec186", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c765c8cb73b0bb91e9f0401ab6567b6218b910e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c765c8cb73b0bb91e9f0401ab6567b6218b910e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c765c8cb73b0bb91e9f0401ab6567b6218b910e5", "patch": "@@ -1,3 +1,23 @@\n+2018-06-05  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_passes_ieee128): New boolean to\n+\ttrack if we pass or return IEEE 128-bit floating point.\n+\t(ieee128_mangling_gcc_8_1): New boolean to say whether to generate\n+\tC++ mangling that is compatible with GCC 8.1.\n+\t(TARGET_ASM_GLOBALIZE_DECL_NAME): Override target hook.\n+\t(init_cumulative_args): Note if we pass or return IEEE 128-bit\n+\tfloating point types.\n+\t(rs6000_function_arg_advance_1): Likewise.\n+\t(rs6000_mangle_type): Optionally generate mangled names that match\n+\twhat GCC 8.1 generated for IEEE 128-bit floating point types.\n+\t(rs6000_globalize_decl_name): If we have an external function that\n+\tpasses or returns IEEE 128-bit types, generate a weak reference\n+\tfrom the mangled name used in GCC 8.1 to the current mangled\n+\tname.\n+\t(rs6000_init_builtins): Make __ibm128 use the long double type if\n+\tlong double is IBM extended double.  Make __float128 use the long\n+\tdouble type if long double is IEEE 128-bit.\n+\n 2018-06-06  Jim Wilson  <jimw@sifive.com>\n \n \t* config/riscv/riscv.c (enum riscv_privilege_levels): New."}, {"sha": "bbee6cbc1e3e0f2ad0438ddc79cbe0d420001860", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 75, "deletions": 6, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c765c8cb73b0bb91e9f0401ab6567b6218b910e5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c765c8cb73b0bb91e9f0401ab6567b6218b910e5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c765c8cb73b0bb91e9f0401ab6567b6218b910e5", "patch": "@@ -200,6 +200,17 @@ int dot_symbols;\n    of this machine mode.  */\n scalar_int_mode rs6000_pmode;\n \n+/* Note whether IEEE 128-bit floating point was passed or returned, either as\n+   the __float128/_Float128 explicit type, or when long double is IEEE 128-bit\n+   floating point.  We changed the default C++ mangling for these types and we\n+   may want to generate a weak alias of the old mangling (U10__float128) to the\n+   new mangling (u9__ieee128).  */\n+static bool rs6000_passes_ieee128;\n+\n+/* Generate the manged name (i.e. U10__float128) used in GCC 8.1, and not the\n+   name used in current releases (i.e. u9__ieee128).  */\n+static bool ieee128_mangling_gcc_8_1;\n+\n /* Width in bits of a pointer.  */\n unsigned rs6000_pointer_size;\n \n@@ -1973,6 +1984,11 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_STARTING_FRAME_OFFSET\n #define TARGET_STARTING_FRAME_OFFSET rs6000_starting_frame_offset\n+\n+#if TARGET_ELF && RS6000_WEAK\n+#undef TARGET_ASM_GLOBALIZE_DECL_NAME\n+#define TARGET_ASM_GLOBALIZE_DECL_NAME rs6000_globalize_decl_name\n+#endif\n \f\n \n /* Processor table.  */\n@@ -11108,6 +11124,12 @@ init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n \t\t\t  && (TYPE_MAIN_VARIANT (return_type)\n \t\t\t      == long_double_type_node))))\n \t\trs6000_passes_long_double = true;\n+\n+\t      /* Note if we passed or return a IEEE 128-bit type.  We changed\n+\t\t the mangling for these types, and we may need to make an alias\n+\t\t with the old mangling.  */\n+\t      if (FLOAT128_IEEE_P (return_mode))\n+\t\trs6000_passes_ieee128 = true;\n \t    }\n \t  if (ALTIVEC_OR_VSX_VECTOR_MODE (return_mode))\n \t    rs6000_passes_vector = true;\n@@ -11559,6 +11581,12 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t\t  || (type != NULL\n \t\t      && TYPE_MAIN_VARIANT (type) == long_double_type_node)))\n \t    rs6000_passes_long_double = true;\n+\n+\t  /* Note if we passed or return a IEEE 128-bit type.  We changed the\n+\t     mangling for these types, and we may need to make an alias with\n+\t     the old mangling.  */\n+\t  if (FLOAT128_IEEE_P (mode))\n+\t    rs6000_passes_ieee128 = true;\n \t}\n       if (named && ALTIVEC_OR_VSX_VECTOR_MODE (mode))\n \trs6000_passes_vector = true;\n@@ -16355,14 +16383,21 @@ rs6000_init_builtins (void)\n      __ieee128.  */\n   if (TARGET_FLOAT128_TYPE)\n     {\n-      ibm128_float_type_node = make_node (REAL_TYPE);\n-      TYPE_PRECISION (ibm128_float_type_node) = 128;\n-      SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n-      layout_type (ibm128_float_type_node);\n+      if (TARGET_IEEEQUAD || !TARGET_LONG_DOUBLE_128)\n+\t{\n+\t  ibm128_float_type_node = make_node (REAL_TYPE);\n+\t  TYPE_PRECISION (ibm128_float_type_node) = 128;\n+\t  SET_TYPE_MODE (ibm128_float_type_node, IFmode);\n+\t  layout_type (ibm128_float_type_node);\n+\t}\n+      else\n+\tibm128_float_type_node = long_double_type_node;\n+\n       lang_hooks.types.register_builtin_type (ibm128_float_type_node,\n \t\t\t\t\t      \"__ibm128\");\n \n-      ieee128_float_type_node = float128_type_node;\n+      ieee128_float_type_node\n+\t= TARGET_IEEEQUAD ? long_double_type_node : float128_type_node;\n       lang_hooks.types.register_builtin_type (ieee128_float_type_node,\n \t\t\t\t\t      \"__ieee128\");\n     }\n@@ -32117,7 +32152,7 @@ rs6000_mangle_type (const_tree type)\n   if (SCALAR_FLOAT_TYPE_P (type) && FLOAT128_IBM_P (TYPE_MODE (type)))\n     return \"g\";\n   if (SCALAR_FLOAT_TYPE_P (type) && FLOAT128_IEEE_P (TYPE_MODE (type)))\n-    return \"u9__ieee128\";\n+    return ieee128_mangling_gcc_8_1 ? \"U10__float128\" : \"u9__ieee128\";\n \n   /* For all other types, use the default mangling.  */\n   return NULL;\n@@ -38726,6 +38761,40 @@ rs6000_starting_frame_offset (void)\n     return 0;\n   return RS6000_STARTING_FRAME_OFFSET;\n }\n+\f\n+\n+/* Create an alias for a mangled name where we have changed the mangling (in\n+   GCC 8.1, we used U10__float128, and now we use u9__ieee128).  This is called\n+   via the target hook TARGET_ASM_GLOBALIZE_DECL_NAME.  */\n+\n+#if TARGET_ELF && RS6000_WEAK\n+static void\n+rs6000_globalize_decl_name (FILE * stream, tree decl)\n+{\n+  const char *name = XSTR (XEXP (DECL_RTL (decl), 0), 0);\n+\n+  targetm.asm_out.globalize_label (stream, name);\n+\n+  if (rs6000_passes_ieee128 && name[0] == '_' && name[1] == 'Z')\n+    {\n+      tree save_asm_name = DECL_ASSEMBLER_NAME (decl);\n+      const char *old_name;\n+\n+      ieee128_mangling_gcc_8_1 = true;\n+      lang_hooks.set_decl_assembler_name (decl);\n+      old_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+      SET_DECL_ASSEMBLER_NAME (decl, save_asm_name);\n+      ieee128_mangling_gcc_8_1 = false;\n+\n+      if (strcmp (name, old_name) != 0)\n+\t{\n+\t  fprintf (stream, \"\\t.weak %s\\n\", old_name);\n+\t  fprintf (stream, \"\\t.set %s,%s\\n\", old_name, name);\n+\t}\n+    }\n+}\n+#endif\n+\n \f\n struct gcc_target targetm = TARGET_INITIALIZER;\n "}, {"sha": "04d7628e8ed0b88b6d166464ef115f456d4bb15d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c765c8cb73b0bb91e9f0401ab6567b6218b910e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c765c8cb73b0bb91e9f0401ab6567b6218b910e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c765c8cb73b0bb91e9f0401ab6567b6218b910e5", "patch": "@@ -1,3 +1,9 @@\n+2018-06-06  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\tPR target/85657\n+\t* g++.dg/pr85657.C: Only test whether __ibm128 and long double can\n+\tbe used in templates.  Don't check for them in overloaded functions.\n+\n 2018-06-06  Jim Wilson  <jimw@sifive.com>\n \n \t* gcc.target/riscv/interrupt-5.c (sub3): Add new test."}, {"sha": "e62b62abcc5a10f230f361c633c1109e6e665bf0", "filename": "gcc/testsuite/g++.dg/pr85657.C", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c765c8cb73b0bb91e9f0401ab6567b6218b910e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr85657.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c765c8cb73b0bb91e9f0401ab6567b6218b910e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr85657.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr85657.C?ref=c765c8cb73b0bb91e9f0401ab6567b6218b910e5", "patch": "@@ -3,8 +3,8 @@\n // { dg-options \"-mvsx -mfloat128 -O2 -mabi=ibmlongdouble -Wno-psabi\" }\n \n // PR 85657\n-// Check that __ibm128 and long double are represented as different types, even\n-// if long double is currently using the same representation as __ibm128.\n+// Check that __ibm128 and long double can be used in the same template,\n+// even if long double uses the IBM extended double representation.\n \n template <class __T> inline bool\n iszero (__T __val)\n@@ -18,30 +18,7 @@ use_template (void)\n   long double ld = 0.0;\n   __ibm128 ibm = 0.0;\n \n-#ifdef _ARCH_PWR7\n   __asm__ (\" # %x0, %x1\" : \"+d\" (ld), \"+d\" (ibm));\n-#endif\n \n   return iszero (ld) + iszero (ibm);\n }\n-\n-class foo {\n-public:\n-  foo () {}\n-  ~foo () {}\n-  inline bool iszero (long double ld) { return ld == 0.0; }\n-  inline bool iszero (__ibm128 i128) { return i128 == 0.0; }\n-} st;\n-\n-int\n-use_class (void)\n-{\n-  long double ld = 0.0;\n-  __ibm128 ibm = 0.0;\n-\n-#ifdef _ARCH_PWR7\n-  __asm__ (\" # %x0, %x1\" : \"+d\" (ld), \"+d\" (ibm));\n-#endif\n-\n-  return st.iszero (ld) + st.iszero (ibm);\n-}"}]}