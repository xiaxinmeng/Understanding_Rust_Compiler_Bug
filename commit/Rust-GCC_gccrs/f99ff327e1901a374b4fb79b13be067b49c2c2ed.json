{"sha": "f99ff327e1901a374b4fb79b13be067b49c2c2ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk5ZmYzMjdlMTkwMWEzNzRiNGZiNzliMTNiZTA2N2I0OWMyYzJlZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:26:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-26T11:26:32Z"}, "message": "[multiple changes]\n\n2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* aspects.adb Add an entry for entry bodies in table\n\tHas_Aspect_Specifications_Flag.\n\t(Aspects_On_Body_Or_Stub_OK): Entry bodies now allow for certain\n\taspects.\n\t* contracts.adb (Add_Contract_Items): Code cleanup. Add\n\tprocessing for entry bodies, entry declarations and task units.\n\t(Analyze_Subprogram_Body_Contract): Renamed\n\tto Analyze_Entry_Or_Subprogram_Body_Contract. Do not\n\tanalyze the contract of an entry body unless annotating the\n\toriginal tree.\n\t(Analyze_Subprogram_Contract): Renamed to\n\tAnalyze_Entry_Or_Subprogram_Contract.  Do not analyze the contract\n\tof an entry declaration unless annotating the original tree.\n\t(Analyze_Task_Contract): New routine.\n\t* contracts.ads (Add_Contract_Item): Update the comment on usage.\n\t(Analyze_Package_Body_Contract): Update comment on usage.\n\t(Analyze_Package_Contract): Update the comment on usage.\n\t(Analyze_Subprogram_Body_Contract): Renamed to\n\tAnalyze_Entry_Or_Subprogram_Body_Contract.\n\t(Analyze_Subprogram_Body_Stub_Contract): Update the comment on usage.\n\t(Analyze_Subprogram_Contract): Renamed to\n\tAnalyze_Entry_Or_Subprogram_Contract.\n\t(Analyze_Task_Contract): New routine.\n\t* einfo.adb (Contract): Restructure the assertion to include\n\tentries and task units.\n\t(SPARK_Pragma): This attribute now applies to operators.\n\t(SPARK_Pragma_Inherited): This flag now applies to operators.\n\t(Set_Contract): Restructure the assertion to include entries and task\n\tunits.\n\t(Set_SPARK_Pragma): This attribute now applies to operators.\n\t(Set_SPARK_Pragma_Inherited): This flag now applies to operators.\n\t(Write_Field34_Name): Write out all Ekinds that have a contract.\n\t(Write_Field40_Name): SPARK_Pragma now applies to operators.\n\t* einfo.ads: Update the documentation of attribute Contract along\n\twith usage in nodes.  Update the documentation of attributes\n\tSPARK_Pragma and SPARK_Pragma_Inherited.\n\t* exp_ch6.adb (Freeze_Subprogram): Update the call to\n\tAnalyze_Subprogram_Contract.\n\t* par-ch9.adb (P_Entry_Barrier): Do not parse keyword \"is\" as it\n\tis not part of the entry barrier production.\n\t(P_Entry_Body): Parse the optional aspect specifications. Diagnose\n\tmisplaced aspects.\n\t* sem_attr.adb (Analyze_Attribute_Old_Result): Update the call\n\tto Find_Related_Subprogram_Or_Body.\n\t* sem_aux.adb (Unit_Declaration_Node) Add an entry for entry\n\tdeclarations and bodies.\n\t* sem_ch3.adb (Analyze_Declarations): Analyze the contracts of\n\tentry declarations, entry bodies and task units.\n\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body):\n\tUpdate the call to Analyze_Subprogram_Body_Contract.\n\t(Analyze_Subprogram_Body_Helper): Update the call to\n\tAnalyze_Subprogram_Body_Contract.\n\t* sem_ch9.adb (Analyze_Entry_Body): Analyze the aspect\n\tspecifications and the contract.\n\t* sem_ch10.adb (Analyze_Compilation_Unit): Update the call to\n\tAnalyze_Subprogram_Contract.\n\t* sem_ch12.adb (Save_References_In_Pragma): Update the call to\n\tFind_Related_Subprogram_Or_Body.\n\t* sem_ch13.adb (Analyze_Aspects_On_Body_Or_Stub): Use\n\tUnique_Defining_Entity rather than rummaging around in nodes.\n\t(Diagnose_Misplaced_Aspects): Update comment on usage. Update the\n\terror messages to accomondate the increasing number of contexts.\n\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part):\n\tUpdate the call to Find_Related_Subprogram_Or_Body.\n\t(Analyze_Depends_Global): Update the call to\n\tFind_Related_Subprogram_Or_Body. Add processing for entry\n\tdeclarations.\n\t(Analyze_Depends_In_Decl_Part): Update the call\n\tto Find_Related_Subprogram_Or_Body. Task units have no formal\n\tparameters to install.\t(Analyze_Global_In_Decl_Part): Update\n\tthe call to Find_Related_Subprogram_Or_Body. Task units have no\n\tformal parameters to install.\n\t(Analyze_Global_Item): Use Fix_Msg to handle the increasing number of\n\tcontexts.\n\t(Analyze_Pragma): Update the call to Find_Related_Subprogram_Or_Body.\n\tPerform full analysis when various pragmas appear in an entry body.\n\t(Analyze_Pre_Post_Condition): Update the call to\n\tFind_Related_Subprogram_Or_Body. Perform full analysis when the pragma\n\tappears in an entry body.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Update the call to\n\tFind_Related_Subprogram_Or_Body.\n\t(Analyze_Refined_Depends_Global_Post): Update\n\tthe call to Find_Related_Subprogram_Or_Body. Use\n\tFix_Msg to handle the increasing number of contexts.\n\t(Analyze_Refined_Depends_In_Decl_Part): Update\n\tthe call to Find_Related_Subprogram_Or_Body. Use\n\tUnique_Defining_Entity to obtain the entity of the\n\tspec. Use Fix_Msg to handle the increasing number of contexts.\n\t(Analyze_Refined_Global_In_Decl_Part): Update the call to\n\tFind_Related_Subprogram_Or_Body. Use Unique_Defining_Entity to obtain\n\tthe entity of the spec. Use Fix_Msg to handle the increasing number of\n\tcontexts.\n\t(Analyze_Test_Case_In_Decl_Part): Update the call to\n\tFind_Related_Subprogram_Or_Body.\n\t(Check_Dependency_Clause): Use Fix_Msg to handle the increasing number\n\tof contexts.\n\t(Check_Mode_Restriction_In_Enclosing_Context): Use\n\tFix_Msg to handle the increasing number of contexts.\n\t(Collect_Subprogram_Inputs_Outputs): Use the refined\n\tversions of the pragmas when the context is an entry body or\n\ta task body.\n\t(Find_Related_Subprogram_Or_Body): Renamed to\n\tFind_Related_Declaration_Or_Body.  Add processing for entries\n\tand task units.\n\t(Fix_Msg): New routine.\n\t(Role_Error): Use Fix_Msg to handle the increasing number of contexts.\n\t* sem_prag.ads (Find_Related_Subprogram_Or_Body): Renamed to\n\tFind_Related_Declaration_Or_Body.  Update the comment on usage.\n\t* sem_util.adb (Is_Entry_Body): New routine.\n\t(Is_Entry_Declaration): New routine.\n\t* sem_util.ads (Is_Entry_Body): New routine.\n\t(Is_Entry_Declaration): New routine.\n\n2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* inline.adb (Has_Excluded_Declaration): A subtype declaration\n\twith a predicate aspect generates a subprogram, and therefore\n\tprevents the inlining of the enclosing subprogram.\n\t* osint.ads: Fix typo.\n\nFrom-SVN: r229333", "tree": {"sha": "4d6b96a02fd5a8727109942f2dc645efbb3c1458", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d6b96a02fd5a8727109942f2dc645efbb3c1458"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f99ff327e1901a374b4fb79b13be067b49c2c2ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f99ff327e1901a374b4fb79b13be067b49c2c2ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f99ff327e1901a374b4fb79b13be067b49c2c2ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f99ff327e1901a374b4fb79b13be067b49c2c2ed/comments", "author": null, "committer": null, "parents": [{"sha": "1f145d79e95b1b7d90c95b7615993bc9ff767931", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f145d79e95b1b7d90c95b7615993bc9ff767931", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f145d79e95b1b7d90c95b7615993bc9ff767931"}], "stats": {"total": 1622, "additions": 1068, "deletions": 554}, "files": [{"sha": "ae7c1a460ae03e9ffc86cb7632266b25751f84db", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -1,3 +1,126 @@\n+2015-10-26  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* aspects.adb Add an entry for entry bodies in table\n+\tHas_Aspect_Specifications_Flag.\n+\t(Aspects_On_Body_Or_Stub_OK): Entry bodies now allow for certain\n+\taspects.\n+\t* contracts.adb (Add_Contract_Items): Code cleanup. Add\n+\tprocessing for entry bodies, entry declarations and task units.\n+\t(Analyze_Subprogram_Body_Contract): Renamed\n+\tto Analyze_Entry_Or_Subprogram_Body_Contract. Do not\n+\tanalyze the contract of an entry body unless annotating the\n+\toriginal tree.\n+\t(Analyze_Subprogram_Contract): Renamed to\n+\tAnalyze_Entry_Or_Subprogram_Contract.  Do not analyze the contract\n+\tof an entry declaration unless annotating the original tree.\n+\t(Analyze_Task_Contract): New routine.\n+\t* contracts.ads (Add_Contract_Item): Update the comment on usage.\n+\t(Analyze_Package_Body_Contract): Update comment on usage.\n+\t(Analyze_Package_Contract): Update the comment on usage.\n+\t(Analyze_Subprogram_Body_Contract): Renamed to\n+\tAnalyze_Entry_Or_Subprogram_Body_Contract.\n+\t(Analyze_Subprogram_Body_Stub_Contract): Update the comment on usage.\n+\t(Analyze_Subprogram_Contract): Renamed to\n+\tAnalyze_Entry_Or_Subprogram_Contract.\n+\t(Analyze_Task_Contract): New routine.\n+\t* einfo.adb (Contract): Restructure the assertion to include\n+\tentries and task units.\n+\t(SPARK_Pragma): This attribute now applies to operators.\n+\t(SPARK_Pragma_Inherited): This flag now applies to operators.\n+\t(Set_Contract): Restructure the assertion to include entries and task\n+\tunits.\n+\t(Set_SPARK_Pragma): This attribute now applies to operators.\n+\t(Set_SPARK_Pragma_Inherited): This flag now applies to operators.\n+\t(Write_Field34_Name): Write out all Ekinds that have a contract.\n+\t(Write_Field40_Name): SPARK_Pragma now applies to operators.\n+\t* einfo.ads: Update the documentation of attribute Contract along\n+\twith usage in nodes.  Update the documentation of attributes\n+\tSPARK_Pragma and SPARK_Pragma_Inherited.\n+\t* exp_ch6.adb (Freeze_Subprogram): Update the call to\n+\tAnalyze_Subprogram_Contract.\n+\t* par-ch9.adb (P_Entry_Barrier): Do not parse keyword \"is\" as it\n+\tis not part of the entry barrier production.\n+\t(P_Entry_Body): Parse the optional aspect specifications. Diagnose\n+\tmisplaced aspects.\n+\t* sem_attr.adb (Analyze_Attribute_Old_Result): Update the call\n+\tto Find_Related_Subprogram_Or_Body.\n+\t* sem_aux.adb (Unit_Declaration_Node) Add an entry for entry\n+\tdeclarations and bodies.\n+\t* sem_ch3.adb (Analyze_Declarations): Analyze the contracts of\n+\tentry declarations, entry bodies and task units.\n+\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body):\n+\tUpdate the call to Analyze_Subprogram_Body_Contract.\n+\t(Analyze_Subprogram_Body_Helper): Update the call to\n+\tAnalyze_Subprogram_Body_Contract.\n+\t* sem_ch9.adb (Analyze_Entry_Body): Analyze the aspect\n+\tspecifications and the contract.\n+\t* sem_ch10.adb (Analyze_Compilation_Unit): Update the call to\n+\tAnalyze_Subprogram_Contract.\n+\t* sem_ch12.adb (Save_References_In_Pragma): Update the call to\n+\tFind_Related_Subprogram_Or_Body.\n+\t* sem_ch13.adb (Analyze_Aspects_On_Body_Or_Stub): Use\n+\tUnique_Defining_Entity rather than rummaging around in nodes.\n+\t(Diagnose_Misplaced_Aspects): Update comment on usage. Update the\n+\terror messages to accomondate the increasing number of contexts.\n+\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part):\n+\tUpdate the call to Find_Related_Subprogram_Or_Body.\n+\t(Analyze_Depends_Global): Update the call to\n+\tFind_Related_Subprogram_Or_Body. Add processing for entry\n+\tdeclarations.\n+\t(Analyze_Depends_In_Decl_Part): Update the call\n+\tto Find_Related_Subprogram_Or_Body. Task units have no formal\n+\tparameters to install.\t(Analyze_Global_In_Decl_Part): Update\n+\tthe call to Find_Related_Subprogram_Or_Body. Task units have no\n+\tformal parameters to install.\n+\t(Analyze_Global_Item): Use Fix_Msg to handle the increasing number of\n+\tcontexts.\n+\t(Analyze_Pragma): Update the call to Find_Related_Subprogram_Or_Body.\n+\tPerform full analysis when various pragmas appear in an entry body.\n+\t(Analyze_Pre_Post_Condition): Update the call to\n+\tFind_Related_Subprogram_Or_Body. Perform full analysis when the pragma\n+\tappears in an entry body.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Update the call to\n+\tFind_Related_Subprogram_Or_Body.\n+\t(Analyze_Refined_Depends_Global_Post): Update\n+\tthe call to Find_Related_Subprogram_Or_Body. Use\n+\tFix_Msg to handle the increasing number of contexts.\n+\t(Analyze_Refined_Depends_In_Decl_Part): Update\n+\tthe call to Find_Related_Subprogram_Or_Body. Use\n+\tUnique_Defining_Entity to obtain the entity of the\n+\tspec. Use Fix_Msg to handle the increasing number of contexts.\n+\t(Analyze_Refined_Global_In_Decl_Part): Update the call to\n+\tFind_Related_Subprogram_Or_Body. Use Unique_Defining_Entity to obtain\n+\tthe entity of the spec. Use Fix_Msg to handle the increasing number of\n+\tcontexts.\n+\t(Analyze_Test_Case_In_Decl_Part): Update the call to\n+\tFind_Related_Subprogram_Or_Body.\n+\t(Check_Dependency_Clause): Use Fix_Msg to handle the increasing number\n+\tof contexts.\n+\t(Check_Mode_Restriction_In_Enclosing_Context): Use\n+\tFix_Msg to handle the increasing number of contexts.\n+\t(Collect_Subprogram_Inputs_Outputs): Use the refined\n+\tversions of the pragmas when the context is an entry body or\n+\ta task body.\n+\t(Find_Related_Subprogram_Or_Body): Renamed to\n+\tFind_Related_Declaration_Or_Body.  Add processing for entries\n+\tand task units.\n+\t(Fix_Msg): New routine.\n+\t(Role_Error): Use Fix_Msg to handle the increasing number of contexts.\n+\t* sem_prag.ads (Find_Related_Subprogram_Or_Body): Renamed to\n+\tFind_Related_Declaration_Or_Body.  Update the comment on usage.\n+\t* sem_util.adb (Is_Entry_Body): New routine.\n+\t(Is_Entry_Declaration): New routine.\n+\t* sem_util.ads (Is_Entry_Body): New routine.\n+\t(Is_Entry_Declaration): New routine.\n+\n+2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* inline.adb (Has_Excluded_Declaration): A subtype declaration\n+\twith a predicate aspect generates a subprogram, and therefore\n+\tprevents the inlining of the enclosing subprogram.\n+\t* osint.ads: Fix typo.\n+\n+\n 2015-10-26  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_case.adb (Check_Choice_Set): Choose initial choice range"}, {"sha": "f42e9bfd7235b31e25f15dee6e935efffde1cf72", "filename": "gcc/ada/aspects.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -154,7 +154,8 @@ package body Aspects is\n \n       pragma Assert (Has_Aspects (N));\n       pragma Assert (Nkind (N) in N_Body_Stub\n-                       or else Nkind_In (N, N_Package_Body,\n+                       or else Nkind_In (N, N_Entry_Body,\n+                                            N_Package_Body,\n                                             N_Protected_Body,\n                                             N_Subprogram_Body,\n                                             N_Task_Body));\n@@ -427,6 +428,7 @@ package body Aspects is\n    Has_Aspect_Specifications_Flag : constant array (Node_Kind) of Boolean :=\n      (N_Abstract_Subprogram_Declaration        => True,\n       N_Component_Declaration                  => True,\n+      N_Entry_Body                             => True,\n       N_Entry_Declaration                      => True,\n       N_Exception_Declaration                  => True,\n       N_Exception_Renaming_Declaration         => True,"}, {"sha": "87c39fbd551478f78619d8cacbb98a3bff0f1047", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 351, "deletions": 232, "changes": 583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -121,7 +121,7 @@ package body Contracts is\n          Set_Contract (Id, Items);\n       end if;\n \n-      --  Contract items related to constants. Applicable pragmas are:\n+      --  Constants, the applicable pragmas are:\n       --    Part_Of\n \n       if Ekind (Id) = E_Constant then\n@@ -134,46 +134,25 @@ package body Contracts is\n             raise Program_Error;\n          end if;\n \n-      --  Contract items related to [generic] packages or instantiations. The\n-      --  applicable pragmas are:\n-      --    Abstract_States\n-      --    Initial_Condition\n-      --    Initializes\n-      --    Part_Of (instantiation only)\n-\n-      elsif Ekind_In (Id, E_Generic_Package, E_Package) then\n-         if Nam_In (Prag_Nam, Name_Abstract_State,\n-                              Name_Initial_Condition,\n-                              Name_Initializes)\n-         then\n-            Add_Classification;\n-\n-         --  Indicator Part_Of must be associated with a package instantiation\n+      --  Entry bodies, the applicable pragmas are:\n+      --    Refined_Depends\n+      --    Refined_Global\n+      --    Refined_Post\n \n-         elsif Prag_Nam = Name_Part_Of and then Is_Generic_Instance (Id) then\n+      elsif Is_Entry_Body (Id) then\n+         if Nam_In (Prag_Nam, Name_Refined_Depends, Name_Refined_Global) then\n             Add_Classification;\n \n-         --  The pragma is not a proper contract item\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-\n-      --  Contract items related to package bodies. The applicable pragmas are:\n-      --    Refined_States\n-\n-      elsif Ekind (Id) = E_Package_Body then\n-         if Prag_Nam = Name_Refined_State then\n-            Add_Classification;\n+         elsif Prag_Nam = Name_Refined_Post then\n+            Add_Pre_Post_Condition;\n \n          --  The pragma is not a proper contract item\n \n          else\n             raise Program_Error;\n          end if;\n \n-      --  Contract items related to subprogram or entry declarations. The\n-      --  applicable pragmas are:\n+      --  Entry or subprogram declarations, the applicable pragmas are:\n       --    Contract_Cases\n       --    Depends\n       --    Extensions_Visible\n@@ -183,9 +162,11 @@ package body Contracts is\n       --    Test_Case\n       --    Volatile_Function\n \n-      elsif Ekind_In (Id, E_Entry, E_Entry_Family)\n-        or else Is_Generic_Subprogram (Id)\n-        or else Is_Subprogram (Id)\n+      elsif Is_Entry_Declaration (Id)\n+        or else Ekind_In (Id, E_Function,\n+                              E_Generic_Function,\n+                              E_Generic_Procedure,\n+                              E_Procedure)\n       then\n          if Nam_In (Prag_Nam, Name_Postcondition, Name_Precondition) then\n             Add_Pre_Post_Condition;\n@@ -210,7 +191,44 @@ package body Contracts is\n             raise Program_Error;\n          end if;\n \n-      --  Contract items related to subprogram bodies. Applicable pragmas are:\n+      --  Packages or instantiations, the applicable pragmas are:\n+      --    Abstract_States\n+      --    Initial_Condition\n+      --    Initializes\n+      --    Part_Of (instantiation only)\n+\n+      elsif Ekind_In (Id, E_Generic_Package, E_Package) then\n+         if Nam_In (Prag_Nam, Name_Abstract_State,\n+                              Name_Initial_Condition,\n+                              Name_Initializes)\n+         then\n+            Add_Classification;\n+\n+         --  Indicator Part_Of must be associated with a package instantiation\n+\n+         elsif Prag_Nam = Name_Part_Of and then Is_Generic_Instance (Id) then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Package bodies, the applicable pragmas are:\n+      --    Refined_States\n+\n+      elsif Ekind (Id) = E_Package_Body then\n+         if Prag_Nam = Name_Refined_State then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Subprogram bodies, the applicable pragmas are:\n       --    Postcondition\n       --    Precondition\n       --    Refined_Depends\n@@ -233,7 +251,35 @@ package body Contracts is\n             raise Program_Error;\n          end if;\n \n-      --  Contract items related to variables. Applicable pragmas are:\n+      --  Task bodies, the applicable pragmas are:\n+      --    Refined_Depends\n+      --    Refined_Global\n+\n+      elsif Ekind (Id) = E_Task_Body then\n+         if Nam_In (Prag_Nam, Name_Refined_Depends, Name_Refined_Global) then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Task units, the applicable pragmas are:\n+      --    Depends\n+      --    Global\n+\n+      elsif Ekind (Id) = E_Task_Type then\n+         if Nam_In (Prag_Nam, Name_Depends, Name_Global) then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Variables, the applicable pragmas are:\n       --    Async_Readers\n       --    Async_Writers\n       --    Constant_After_Elaboration\n@@ -284,6 +330,231 @@ package body Contracts is\n       end loop;\n    end Analyze_Enclosing_Package_Body_Contract;\n \n+   -----------------------------------------------\n+   -- Analyze_Entry_Or_Subprogram_Body_Contract --\n+   -----------------------------------------------\n+\n+   procedure Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n+      Body_Decl : constant Node_Id   := Unit_Declaration_Node (Body_Id);\n+      Items     : constant Node_Id   := Contract (Body_Id);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Body_Decl);\n+      Mode      : SPARK_Mode_Type;\n+\n+   begin\n+      --  When a subprogram body declaration is illegal, its defining entity is\n+      --  left unanalyzed. There is nothing left to do in this case because the\n+      --  body lacks a contract, or even a proper Ekind.\n+\n+      if Ekind (Body_Id) = E_Void then\n+         return;\n+\n+      --  Do not analyze the contract of an entry body unless annotating the\n+      --  original tree. It is preferable to analyze the contract after the\n+      --  entry body has been transformed into a subprogram body to properly\n+      --  handle references to unpacked formals.\n+\n+      elsif Ekind_In (Body_Id, E_Entry, E_Entry_Family)\n+        and then not ASIS_Mode\n+        and then not GNATprove_Mode\n+      then\n+         return;\n+\n+      --  Do not analyze a contract multiple times\n+\n+      elsif Present (Items) then\n+         if Analyzed (Items) then\n+            return;\n+         else\n+            Set_Analyzed (Items);\n+         end if;\n+      end if;\n+\n+      --  Due to the timing of contract analysis, delayed pragmas may be\n+      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n+      --  context. To remedy this, restore the original SPARK_Mode of the\n+      --  related subprogram body.\n+\n+      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n+\n+      --  Ensure that the contract cases or postconditions mention 'Result or\n+      --  define a post-state.\n+\n+      Check_Result_And_Post_State (Body_Id);\n+\n+      --  A stand-alone nonvolatile function body cannot have an effectively\n+      --  volatile formal parameter or return type (SPARK RM 7.1.3(9)). This\n+      --  check is relevant only when SPARK_Mode is on, as it is not a standard\n+      --  legality rule. The check is performed here because Volatile_Function\n+      --  is processed after the analysis of the related subprogram body.\n+\n+      if SPARK_Mode = On\n+        and then Ekind_In (Body_Id, E_Function, E_Generic_Function)\n+        and then not Is_Volatile_Function (Body_Id)\n+      then\n+         Check_Nonvolatile_Function_Profile (Body_Id);\n+      end if;\n+\n+      --  Restore the SPARK_Mode of the enclosing context after all delayed\n+      --  pragmas have been analyzed.\n+\n+      Restore_SPARK_Mode (Mode);\n+\n+      --  Capture all global references in a generic subprogram body now that\n+      --  the contract has been analyzed.\n+\n+      if Is_Generic_Declaration_Or_Body (Body_Decl) then\n+         Save_Global_References_In_Contract\n+           (Templ  => Original_Node (Body_Decl),\n+            Gen_Id => Spec_Id);\n+      end if;\n+\n+      --  Deal with preconditions, [refined] postconditions, Contract_Cases,\n+      --  invariants and predicates associated with body and its spec. Do not\n+      --  expand the contract of subprogram body stubs.\n+\n+      if Nkind (Body_Decl) = N_Subprogram_Body then\n+         Expand_Subprogram_Contract (Body_Id);\n+      end if;\n+   end Analyze_Entry_Or_Subprogram_Body_Contract;\n+\n+   ------------------------------------------\n+   -- Analyze_Entry_Or_Subprogram_Contract --\n+   ------------------------------------------\n+\n+   procedure Analyze_Entry_Or_Subprogram_Contract (Subp_Id : Entity_Id) is\n+      Items     : constant Node_Id := Contract (Subp_Id);\n+      Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n+      Depends   : Node_Id := Empty;\n+      Global    : Node_Id := Empty;\n+      Mode      : SPARK_Mode_Type;\n+      Prag      : Node_Id;\n+      Prag_Nam  : Name_Id;\n+\n+   begin\n+      --  Do not analyze the contract of an entry declaration unless annotating\n+      --  the original tree. It is preferable to analyze the contract after the\n+      --  entry declaration has been transformed into a subprogram declaration\n+      --  to properly handle references to unpacked formals.\n+\n+      if Ekind_In (Subp_Id, E_Entry, E_Entry_Family)\n+        and then not ASIS_Mode\n+        and then not GNATprove_Mode\n+      then\n+         return;\n+\n+      --  Do not analyze a contract multiple times\n+\n+      elsif Present (Items) then\n+         if Analyzed (Items) then\n+            return;\n+         else\n+            Set_Analyzed (Items);\n+         end if;\n+      end if;\n+\n+      --  Due to the timing of contract analysis, delayed pragmas may be\n+      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n+      --  context. To remedy this, restore the original SPARK_Mode of the\n+      --  related subprogram body.\n+\n+      Save_SPARK_Mode_And_Set (Subp_Id, Mode);\n+\n+      --  All subprograms carry a contract, but for some it is not significant\n+      --  and should not be processed.\n+\n+      if not Has_Significant_Contract (Subp_Id) then\n+         null;\n+\n+      elsif Present (Items) then\n+\n+         --  Analyze pre- and postconditions\n+\n+         Prag := Pre_Post_Conditions (Items);\n+         while Present (Prag) loop\n+            Analyze_Pre_Post_Condition_In_Decl_Part (Prag);\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze contract-cases and test-cases\n+\n+         Prag := Contract_Test_Cases (Items);\n+         while Present (Prag) loop\n+            Prag_Nam := Pragma_Name (Prag);\n+\n+            if Prag_Nam = Name_Contract_Cases then\n+               Analyze_Contract_Cases_In_Decl_Part (Prag);\n+            else\n+               pragma Assert (Prag_Nam = Name_Test_Case);\n+               Analyze_Test_Case_In_Decl_Part (Prag);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze classification pragmas\n+\n+         Prag := Classifications (Items);\n+         while Present (Prag) loop\n+            Prag_Nam := Pragma_Name (Prag);\n+\n+            if Prag_Nam = Name_Depends then\n+               Depends := Prag;\n+\n+            elsif Prag_Nam = Name_Global then\n+               Global := Prag;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze Global first, as Depends may mention items classified in\n+         --  the global categorization.\n+\n+         if Present (Global) then\n+            Analyze_Global_In_Decl_Part (Global);\n+         end if;\n+\n+         --  Depends must be analyzed after Global in order to see the modes of\n+         --  all global items.\n+\n+         if Present (Depends) then\n+            Analyze_Depends_In_Decl_Part (Depends);\n+         end if;\n+\n+         --  Ensure that the contract cases or postconditions mention 'Result\n+         --  or define a post-state.\n+\n+         Check_Result_And_Post_State (Subp_Id);\n+      end if;\n+\n+      --  A nonvolatile function cannot have an effectively volatile formal\n+      --  parameter or return type (SPARK RM 7.1.3(9)). This check is relevant\n+      --  only when SPARK_Mode is on, as it is not a standard legality rule.\n+      --  The check is performed here because pragma Volatile_Function is\n+      --  processed after the analysis of the related subprogram declaration.\n+\n+      if SPARK_Mode = On\n+        and then Ekind_In (Subp_Id, E_Function, E_Generic_Function)\n+        and then not Is_Volatile_Function (Subp_Id)\n+      then\n+         Check_Nonvolatile_Function_Profile (Subp_Id);\n+      end if;\n+\n+      --  Restore the SPARK_Mode of the enclosing context after all delayed\n+      --  pragmas have been analyzed.\n+\n+      Restore_SPARK_Mode (Mode);\n+\n+      --  Capture all global references in a generic subprogram now that the\n+      --  contract has been analyzed.\n+\n+      if Is_Generic_Declaration_Or_Body (Subp_Decl) then\n+         Save_Global_References_In_Contract\n+           (Templ  => Original_Node (Subp_Decl),\n+            Gen_Id => Subp_Id);\n+      end if;\n+   end Analyze_Entry_Or_Subprogram_Contract;\n+\n    -----------------------------\n    -- Analyze_Object_Contract --\n    -----------------------------\n@@ -617,94 +888,47 @@ package body Contracts is\n       end if;\n    end Analyze_Package_Contract;\n \n-   --------------------------------------\n-   -- Analyze_Subprogram_Body_Contract --\n-   --------------------------------------\n+   -------------------------------------------\n+   -- Analyze_Subprogram_Body_Stub_Contract --\n+   -------------------------------------------\n \n-   procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n-      Body_Decl : constant Node_Id   := Unit_Declaration_Node (Body_Id);\n-      Items     : constant Node_Id   := Contract (Body_Id);\n-      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Body_Decl);\n-      Mode      : SPARK_Mode_Type;\n+   procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id) is\n+      Stub_Decl : constant Node_Id   := Parent (Parent (Stub_Id));\n+      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of_Stub (Stub_Decl);\n \n    begin\n-      --  When a subprogram body declaration is illegal, its defining entity is\n-      --  left unanalyzed. There is nothing left to do in this case because the\n-      --  body lacks a contract, or even a proper Ekind.\n-\n-      if Ekind (Body_Id) = E_Void then\n-         return;\n-\n-      --  Do not analyze a contract multiple times\n-\n-      elsif Present (Items) then\n-         if Analyzed (Items) then\n-            return;\n-         else\n-            Set_Analyzed (Items);\n-         end if;\n-      end if;\n-\n-      --  Due to the timing of contract analysis, delayed pragmas may be\n-      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n-      --  context. To remedy this, restore the original SPARK_Mode of the\n-      --  related subprogram body.\n-\n-      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n-\n-      --  Ensure that the contract cases or postconditions mention 'Result or\n-      --  define a post-state.\n-\n-      Check_Result_And_Post_State (Body_Id);\n-\n-      --  A stand-alone nonvolatile function body cannot have an effectively\n-      --  volatile formal parameter or return type (SPARK RM 7.1.3(9)). This\n-      --  check is relevant only when SPARK_Mode is on, as it is not a standard\n-      --  legality rule. The check is performed here because Volatile_Function\n-      --  is processed after the analysis of the related subprogram body.\n-\n-      if SPARK_Mode = On\n-        and then Ekind_In (Body_Id, E_Function, E_Generic_Function)\n-        and then not Is_Volatile_Function (Body_Id)\n-      then\n-         Check_Nonvolatile_Function_Profile (Body_Id);\n-      end if;\n-\n-      --  Restore the SPARK_Mode of the enclosing context after all delayed\n-      --  pragmas have been analyzed.\n-\n-      Restore_SPARK_Mode (Mode);\n+      --  A subprogram body stub may act as its own spec or as the completion\n+      --  of a previous declaration. Depending on the context, the contract of\n+      --  the stub may contain two sets of pragmas.\n \n-      --  Capture all global references in a generic subprogram body now that\n-      --  the contract has been analyzed.\n+      --  The stub is a completion, the applicable pragmas are:\n+      --    Refined_Depends\n+      --    Refined_Global\n \n-      if Is_Generic_Declaration_Or_Body (Body_Decl) then\n-         Save_Global_References_In_Contract\n-           (Templ  => Original_Node (Body_Decl),\n-            Gen_Id => Spec_Id);\n-      end if;\n+      if Present (Spec_Id) then\n+         Analyze_Entry_Or_Subprogram_Body_Contract (Stub_Id);\n \n-      --  Deal with preconditions, [refined] postconditions, Contract_Cases,\n-      --  invariants and predicates associated with body and its spec. Do not\n-      --  expand the contract of subprogram body stubs.\n+      --  The stub acts as its own spec, the applicable pragmas are:\n+      --    Contract_Cases\n+      --    Depends\n+      --    Global\n+      --    Postcondition\n+      --    Precondition\n+      --    Test_Case\n \n-      if Nkind (Body_Decl) = N_Subprogram_Body then\n-         Expand_Subprogram_Contract (Body_Id);\n+      else\n+         Analyze_Entry_Or_Subprogram_Contract (Stub_Id);\n       end if;\n-   end Analyze_Subprogram_Body_Contract;\n+   end Analyze_Subprogram_Body_Stub_Contract;\n \n-   ---------------------------------\n-   -- Analyze_Subprogram_Contract --\n-   ---------------------------------\n+   ---------------------------\n+   -- Analyze_Task_Contract --\n+   ---------------------------\n \n-   procedure Analyze_Subprogram_Contract (Subp_Id : Entity_Id) is\n-      Items     : constant Node_Id := Contract (Subp_Id);\n-      Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n-      Depends   : Node_Id := Empty;\n-      Global    : Node_Id := Empty;\n-      Mode      : SPARK_Mode_Type;\n-      Prag      : Node_Id;\n-      Prag_Nam  : Name_Id;\n+   procedure Analyze_Task_Contract (Task_Id : Entity_Id) is\n+      Items : constant Node_Id := Contract (Task_Id);\n+      Mode  : SPARK_Mode_Type;\n+      Prag  : Node_Id;\n \n    begin\n       --  Do not analyze a contract multiple times\n@@ -722,136 +946,31 @@ package body Contracts is\n       --  context. To remedy this, restore the original SPARK_Mode of the\n       --  related subprogram body.\n \n-      Save_SPARK_Mode_And_Set (Subp_Id, Mode);\n-\n-      --  All subprograms carry a contract, but for some it is not significant\n-      --  and should not be processed.\n-\n-      if not Has_Significant_Contract (Subp_Id) then\n-         null;\n-\n-      elsif Present (Items) then\n-\n-         --  Analyze pre- and postconditions\n-\n-         Prag := Pre_Post_Conditions (Items);\n-         while Present (Prag) loop\n-            Analyze_Pre_Post_Condition_In_Decl_Part (Prag);\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Analyze contract-cases and test-cases\n-\n-         Prag := Contract_Test_Cases (Items);\n-         while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n-\n-            if Prag_Nam = Name_Contract_Cases then\n-               Analyze_Contract_Cases_In_Decl_Part (Prag);\n-            else\n-               pragma Assert (Prag_Nam = Name_Test_Case);\n-               Analyze_Test_Case_In_Decl_Part (Prag);\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Analyze classification pragmas\n-\n-         Prag := Classifications (Items);\n-         while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n-\n-            if Prag_Nam = Name_Depends then\n-               Depends := Prag;\n-\n-            elsif Prag_Nam = Name_Global then\n-               Global := Prag;\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Analyze Global first, as Depends may mention items classified in\n-         --  the global categorization.\n-\n-         if Present (Global) then\n-            Analyze_Global_In_Decl_Part (Global);\n-         end if;\n-\n-         --  Depends must be analyzed after Global in order to see the modes of\n-         --  all global items.\n+      Save_SPARK_Mode_And_Set (Task_Id, Mode);\n \n-         if Present (Depends) then\n-            Analyze_Depends_In_Decl_Part (Depends);\n-         end if;\n+      --  Analyze Global first, as Depends may mention items classified in the\n+      --  global categorization.\n \n-         --  Ensure that the contract cases or postconditions mention 'Result\n-         --  or define a post-state.\n+      Prag := Get_Pragma (Task_Id, Pragma_Global);\n \n-         Check_Result_And_Post_State (Subp_Id);\n+      if Present (Prag) then\n+         Analyze_Global_In_Decl_Part (Prag);\n       end if;\n \n-      --  A nonvolatile function cannot have an effectively volatile formal\n-      --  parameter or return type (SPARK RM 7.1.3(9)). This check is relevant\n-      --  only when SPARK_Mode is on, as it is not a standard legality rule.\n-      --  The check is performed here because pragma Volatile_Function is\n-      --  processed after the analysis of the related subprogram declaration.\n+      --  Depends must be analyzed after Global in order to see the modes of\n+      --  all global items.\n \n-      if SPARK_Mode = On\n-        and then Ekind_In (Subp_Id, E_Function, E_Generic_Function)\n-        and then not Is_Volatile_Function (Subp_Id)\n-      then\n-         Check_Nonvolatile_Function_Profile (Subp_Id);\n+      Prag := Get_Pragma (Task_Id, Pragma_Depends);\n+\n+      if Present (Prag) then\n+         Analyze_Depends_In_Decl_Part (Prag);\n       end if;\n \n       --  Restore the SPARK_Mode of the enclosing context after all delayed\n       --  pragmas have been analyzed.\n \n       Restore_SPARK_Mode (Mode);\n-\n-      --  Capture all global references in a generic subprogram now that the\n-      --  contract has been analyzed.\n-\n-      if Is_Generic_Declaration_Or_Body (Subp_Decl) then\n-         Save_Global_References_In_Contract\n-           (Templ  => Original_Node (Subp_Decl),\n-            Gen_Id => Subp_Id);\n-      end if;\n-   end Analyze_Subprogram_Contract;\n-\n-   -------------------------------------------\n-   -- Analyze_Subprogram_Body_Stub_Contract --\n-   -------------------------------------------\n-\n-   procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id) is\n-      Stub_Decl : constant Node_Id   := Parent (Parent (Stub_Id));\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of_Stub (Stub_Decl);\n-\n-   begin\n-      --  A subprogram body stub may act as its own spec or as the completion\n-      --  of a previous declaration. Depending on the context, the contract of\n-      --  the stub may contain two sets of pragmas.\n-\n-      --  The stub is a completion, the applicable pragmas are:\n-      --    Refined_Depends\n-      --    Refined_Global\n-\n-      if Present (Spec_Id) then\n-         Analyze_Subprogram_Body_Contract (Stub_Id);\n-\n-      --  The stub acts as its own spec, the applicable pragmas are:\n-      --    Contract_Cases\n-      --    Depends\n-      --    Global\n-      --    Postcondition\n-      --    Precondition\n-      --    Test_Case\n-\n-      else\n-         Analyze_Subprogram_Contract (Stub_Id);\n-      end if;\n-   end Analyze_Subprogram_Body_Stub_Contract;\n+   end Analyze_Task_Contract;\n \n    -----------------------------\n    -- Create_Generic_Contract --"}, {"sha": "3814dfc8277f2f1593a82d7e7f05a47e93cf5692", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 41, "deletions": 34, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -31,9 +31,9 @@ with Types; use Types;\n package Contracts is\n \n    procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id);\n-   --  Add pragma Prag to the contract of a constant, entry, package [body],\n-   --  subprogram [body], or variable denoted by Id. The following are valid\n-   --  pragmas:\n+   --  Add pragma Prag to the contract of a constant, entry, entry family,\n+   --  [generic] package, package body, [generic] subprogram, subprogram body,\n+   --  variable or task unit denoted by Id. The following are valid pragmas:\n    --    Abstract_State\n    --    Async_Readers\n    --    Async_Writers\n@@ -60,6 +60,31 @@ package Contracts is\n    --  Analyze the contract of the nearest package body (if any) enclosing\n    --  package or subprogram body Body_Decl.\n \n+   procedure Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id : Entity_Id);\n+   --  Analyze all delayed pragmas chained on the contract of entry or\n+   --  subprogram body Body_Id as if they appeared at the end of a declarative\n+   --  region. Pragmas in question are:\n+   --    Contract_Cases   (stand alone subprogram body)\n+   --    Depends          (stand alone subprogram body)\n+   --    Global           (stand alone subprogram body)\n+   --    Postcondition    (stand alone subprogram body)\n+   --    Precondition     (stand alone subprogram body)\n+   --    Refined_Depends\n+   --    Refined_Global\n+   --    Refined_Post\n+   --    Test_Case        (stand alone subprogram body)\n+\n+   procedure Analyze_Entry_Or_Subprogram_Contract (Subp_Id : Entity_Id);\n+   --  Analyze all delayed pragmas chained on the contract of entry or\n+   --  subprogram Subp_Id as if they appeared at the end of a declarative\n+   --  region. The pragmas in question are:\n+   --    Contract_Cases\n+   --    Depends\n+   --    Global\n+   --    Postcondition\n+   --    Precondition\n+   --    Test_Case\n+\n    procedure Analyze_Object_Contract (Obj_Id : Entity_Id);\n    --  Analyze all delayed pragmas chained on the contract of object Obj_Id as\n    --  if they appeared at the end of the declarative region. The pragmas to be\n@@ -73,51 +98,26 @@ package Contracts is\n    procedure Analyze_Package_Body_Contract\n      (Body_Id   : Entity_Id;\n       Freeze_Id : Entity_Id := Empty);\n-   --  Analyze all delayed aspects chained on the contract of package body\n+   --  Analyze all delayed pragmas chained on the contract of package body\n    --  Body_Id as if they appeared at the end of a declarative region. The\n-   --  aspects that are considered are:\n+   --  pragmas that are considered are:\n    --    Refined_State\n    --\n    --  Freeze_Id is the entity of a [generic] package body or a [generic]\n    --  subprogram body which \"freezes\" the contract of Body_Id.\n \n    procedure Analyze_Package_Contract (Pack_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of package Pack_Id\n-   --  as if they appeared at the end of a declarative region. The aspects\n+   --  Analyze all delayed pragmas chained on the contract of package Pack_Id\n+   --  as if they appeared at the end of a declarative region. The pragmas\n    --  that are considered are:\n    --    Initial_Condition\n    --    Initializes\n    --    Part_Of\n \n-   procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of subprogram body\n-   --  Body_Id as if they appeared at the end of a declarative region. Aspects\n-   --  in question are:\n-   --    Contract_Cases   (stand alone body)\n-   --    Depends          (stand alone body)\n-   --    Global           (stand alone body)\n-   --    Postcondition    (stand alone body)\n-   --    Precondition     (stand alone body)\n-   --    Refined_Depends\n-   --    Refined_Global\n-   --    Refined_Post\n-   --    Test_Case        (stand alone body)\n-\n-   procedure Analyze_Subprogram_Contract (Subp_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of subprogram\n-   --  Subp_Id as if they appeared at the end of a declarative region. The\n-   --  aspects in question are:\n-   --    Contract_Cases\n-   --    Depends\n-   --    Global\n-   --    Postcondition\n-   --    Precondition\n-   --    Test_Case\n-\n    procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of a subprogram body\n+   --  Analyze all delayed pragmas chained on the contract of a subprogram body\n    --  stub Stub_Id as if they appeared at the end of a declarative region. The\n-   --  aspects in question are:\n+   --  pragmas in question are:\n    --    Contract_Cases\n    --    Depends\n    --    Global\n@@ -128,6 +128,13 @@ package Contracts is\n    --    Refined_Post\n    --    Test_Case\n \n+   procedure Analyze_Task_Contract (Task_Id : Entity_Id);\n+   --  Analyze all delayed pragmas chained on the contract of a task unit\n+   --  Task_Id as if they appeared at the end of a declarative region. The\n+   --  pragmas in question are:\n+   --    Depends\n+   --    Global\n+\n    procedure Create_Generic_Contract (Unit : Node_Id);\n    --  Create a contract node for a generic package, generic subprogram, or a\n    --  generic body denoted by Unit by collecting all source contract-related"}, {"sha": "d7d19ab5117516679796046c31a44b6fa50713ae", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 47, "deletions": 19, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -1205,16 +1205,25 @@ package body Einfo is\n    function Contract (Id : E) return N is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Constant,\n-                       E_Entry,\n+        (Ekind_In (Id, E_Constant,         --  object variants\n+                       E_Variable)\n+           or else\n+         Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n-                       E_Generic_Package,\n+                       E_Function,\n+                       E_Generic_Function,\n+                       E_Generic_Procedure,\n+                       E_Operator,\n+                       E_Procedure,\n+                       E_Subprogram_Body)\n+           or else\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body,\n-                       E_Subprogram_Body,\n-                       E_Variable,\n-                       E_Void)\n-          or else Is_Subprogram_Or_Generic_Subprogram (Id));\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Task_Body,         --  synchronized variants\n+                       E_Task_Type,\n+                       E_Void));            --  special purpose\n       return Node34 (Id);\n    end Contract;\n \n@@ -3139,6 +3148,7 @@ package body Einfo is\n                        E_Function,\n                        E_Generic_Function,\n                        E_Generic_Procedure,\n+                       E_Operator,\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n@@ -3161,6 +3171,7 @@ package body Einfo is\n                        E_Function,\n                        E_Generic_Function,\n                        E_Generic_Procedure,\n+                       E_Operator,\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n@@ -3834,16 +3845,25 @@ package body Einfo is\n    procedure Set_Contract (Id : E; V : N) is\n    begin\n       pragma Assert\n-        (Ekind_In (Id, E_Constant,\n-                       E_Entry,\n+        (Ekind_In (Id, E_Constant,         --  object variants\n+                       E_Variable)\n+           or else\n+         Ekind_In (Id, E_Entry,            --  overloadable variants\n                        E_Entry_Family,\n-                       E_Generic_Package,\n+                       E_Function,\n+                       E_Generic_Function,\n+                       E_Generic_Procedure,\n+                       E_Operator,\n+                       E_Procedure,\n+                       E_Subprogram_Body)\n+           or else\n+         Ekind_In (Id, E_Generic_Package,  --  package variants\n                        E_Package,\n-                       E_Package_Body,\n-                       E_Subprogram_Body,\n-                       E_Variable,\n-                       E_Void)\n-          or else Is_Subprogram_Or_Generic_Subprogram (Id));\n+                       E_Package_Body)\n+           or else\n+         Ekind_In (Id, E_Task_Body,         --  synchronized variants\n+                       E_Task_Type,\n+                       E_Void));            --  special purpose\n       Set_Node34 (Id, V);\n    end Set_Contract;\n \n@@ -6170,6 +6190,7 @@ package body Einfo is\n                        E_Function,\n                        E_Generic_Function,\n                        E_Generic_Procedure,\n+                       E_Operator,\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n@@ -6192,6 +6213,7 @@ package body Einfo is\n                        E_Function,\n                        E_Generic_Function,\n                        E_Generic_Procedure,\n+                       E_Operator,\n                        E_Procedure,\n                        E_Subprogram_Body)\n            or else\n@@ -10212,14 +10234,19 @@ package body Einfo is\n          when E_Constant                                   |\n               E_Entry                                      |\n               E_Entry_Family                               |\n+              E_Function                                   |\n+              E_Generic_Function                           |\n               E_Generic_Package                            |\n+              E_Generic_Procedure                          |\n+              E_Operator                                   |\n               E_Package                                    |\n               E_Package_Body                               |\n+              E_Procedure                                  |\n               E_Subprogram_Body                            |\n+              E_Task_Body                                  |\n+              E_Task_Type                                  |\n               E_Variable                                   |\n-              E_Void                                       |\n-              Generic_Subprogram_Kind                      |\n-              Subprogram_Kind                              =>\n+              E_Void                                       =>\n             Write_Str (\"Contract\");\n \n          when others                                       =>\n@@ -10317,6 +10344,7 @@ package body Einfo is\n               E_Generic_Function                           |\n               E_Generic_Package                            |\n               E_Generic_Procedure                          |\n+              E_Operator                                   |\n               E_Package                                    |\n               E_Package_Body                               |\n               E_Procedure                                  |"}, {"sha": "e74a0a7ffc20ae0b23c2352764fc11e1a64aba58", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -705,10 +705,10 @@ package Einfo is\n --       of declaration, procedure call, assignment statement or pragma.\n \n --    Contract (Node34)\n---       Defined in constant, entry, entry family, [generic] package, package\n---       body, [generic] subprogram, subprogram body, and variable entities.\n---       Points to the contract of the entity, holding various assertion items\n---       and data classifiers.\n+--       Defined in constant, entry, entry family, operator, [generic] package,\n+--       package body, [generic] subprogram, subprogram body, variable and task\n+--       type entities. Points to the contract of the entity, holding various\n+--       assertion items and data classifiers.\n \n --    Corresponding_Concurrent_Type (Node18)\n --       Defined in record types that are constructed by the expander to\n@@ -4087,19 +4087,20 @@ package Einfo is\n --       inherited, rather than a local one.\n \n --    SPARK_Pragma (Node40)\n---       Present in entries, [generic] package specs, package bodies, [generic]\n---       subprogram specs, subprogram bodies and synchronized types. Points to\n---       the N_Pragma node that applies to the spec or body. This is either set\n---       by a local SPARK_Mode pragma or is inherited from the context (from an\n---       outer scope for the spec case or from the spec for the body case). In\n---       the case where it is inherited the flag SPARK_Pragma_Inherited is set.\n---       Empty if no SPARK_Mode pragma is applicable.\n+--       Present in entries, operators, [generic] packages, package bodies,\n+--       [generic] subprograms, subprogram bodies and synchronized types.\n+--       Points to the N_Pragma node that applies to the spec or body. This\n+--       is either set by a local SPARK_Mode pragma or is inherited from the\n+--       context (from an outer scope for the spec case or from the spec for\n+--       the body case). In the case where it is inherited the flag\n+--       SPARK_Pragma_Inherited is set. Empty if no SPARK_Mode pragma is\n+--       applicable.\n \n --    SPARK_Pragma_Inherited (Flag265)\n---       Present in entries, [generic] package specs, package bodies, [generic]\n---       subprogram specs, subprogram bodies and synchronized types. Set if the\n---       SPARK_Pragma attribute points to a pragma that is inherited, rather\n---       than a local one.\n+--       Present in entries, operators, [generic] packages, package bodies,\n+--       [generic] subprograms, subprogram bodies and synchronized types. Set\n+--       if the SPARK_Pragma attribute points to a pragma that is inherited,\n+--       rather than a local one.\n \n --    Spec_Entity (Node19)\n --       Defined in package body entities. Points to corresponding package\n@@ -6041,13 +6042,15 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Import_Pragma                       (Node35)\n+   --    SPARK_Pragma                        (Node40)\n+   --    Default_Expressions_Processed       (Flag108)\n    --    Has_Invariants                      (Flag232)\n    --    Has_Nested_Subprogram               (Flag282)\n-   --    Is_Machine_Code_Subprogram          (Flag137)\n-   --    Is_Pure                             (Flag44)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n+   --    Is_Machine_Code_Subprogram          (Flag137)\n    --    Is_Primitive                        (Flag218)\n-   --    Default_Expressions_Processed       (Flag108)\n+   --    Is_Pure                             (Flag44)\n+   --    SPARK_Pragma_Inherited              (Flag265)\n    --    Aren't there more flags and fields? seems like this list should be\n    --    more similar to the E_Function list, which is much longer ???\n \n@@ -6378,6 +6381,7 @@ package Einfo is\n    --    (plus type attributes)\n \n    --  E_Task_Body\n+   --    Contract                            (Node34)\n    --    SPARK_Pragma                        (Node40)\n    --    SPARK_Pragma_Inherited              (Flag265)\n    --    (any others??? First/Last Entity, Scope_Depth???)\n@@ -6396,6 +6400,7 @@ package Einfo is\n    --    Task_Body_Procedure                 (Node25)\n    --    Storage_Size_Variable               (Node26)   (base type only)\n    --    Relative_Deadline_Variable          (Node28)   (base type only)\n+   --    Contract                            (Node34)\n    --    SPARK_Pragma                        (Node40)\n    --    SPARK_Aux_Pragma                    (Node41)\n    --    Delay_Cleanups                      (Flag114)"}, {"sha": "a666ab22b8593ce31dc690e8c7f6700f28eda0c6", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -7105,7 +7105,7 @@ package body Exp_Ch6 is\n       if Nkind (Parent (Subp)) = N_Procedure_Specification\n         and then Null_Present (Parent (Subp))\n       then\n-         Analyze_Subprogram_Contract (Subp);\n+         Analyze_Entry_Or_Subprogram_Contract (Subp);\n       end if;\n    end Freeze_Subprogram;\n "}, {"sha": "2bee1927c2dda64fe0ce7e4a0386307379106bae", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -3513,6 +3513,37 @@ package body Inline is\n               (\"cannot inline & (nested procedure instantiation)?\",\n                D, Subp);\n             return True;\n+\n+         --  Subtype declarations with predicates will generate predicate\n+         --  functions, i.e. nested subprogram bodies, so inlining is not\n+         --  possible.\n+\n+         elsif Nkind (D) = N_Subtype_Declaration\n+           and then Present (Aspect_Specifications (D))\n+         then\n+            declare\n+               A    : Node_Id;\n+               A_Id : Aspect_Id;\n+\n+            begin\n+               A := First (Aspect_Specifications (D));\n+               while Present (A) loop\n+                  A_Id := Get_Aspect_Id (Chars (Identifier (A)));\n+\n+                  if A_Id = Aspect_Predicate\n+                    or else A_Id = Aspect_Static_Predicate\n+                    or else A_Id = Aspect_Dynamic_Predicate\n+                  then\n+                     Cannot_Inline\n+                       (\"cannot inline & \"\n+                        & \"(subtype declaration with predicate)?\",\n+                        D, Subp);\n+                     return True;\n+                  end if;\n+\n+                  Next (A);\n+               end loop;\n+            end;\n          end if;\n \n          Next (D);"}, {"sha": "2e6f0904de35a1141d5990195bcae560cefb3e13", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -760,7 +760,7 @@ private\n    --  for this file. This routine merely constructs the name.\n \n    procedure Write_Info (Info : String);\n-   --  Implement Write_Binder_Info, Write_Debug_Info, and Write_Library_Info\n+   --  Implements Write_Binder_Info, Write_Debug_Info, and Write_Library_Info\n \n    procedure Write_With_Check (A : Address; N  : Integer);\n    --  Writes N bytes from buffer starting at address A to file whose FD is"}, {"sha": "1137823133e72241d856a48818e7d3c53ed0820a", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 62, "deletions": 35, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1089,7 +1089,6 @@ package body Ch9 is\n          Resync_Past_Semicolon;\n          Pop_Scope_Stack; -- discard unused entry\n          return Error;\n-\n    end P_Accept_Statement;\n \n    ------------------------\n@@ -1098,12 +1097,45 @@ package body Ch9 is\n \n    --  Parsed by P_Expression (4.4)\n \n+   --------------------------\n+   -- 9.5.2  Entry Barrier --\n+   --------------------------\n+\n+   --  ENTRY_BARRIER ::= when CONDITION\n+\n+   --  Error_Recovery: cannot raise Error_Resync\n+\n+   function P_Entry_Barrier return Node_Id is\n+      Bnode : Node_Id;\n+\n+   begin\n+      if Token = Tok_When then\n+         Scan; -- past WHEN;\n+         Bnode := P_Expression_No_Right_Paren;\n+\n+         if Token = Tok_Colon_Equal then\n+            Error_Msg_SC -- CODEFIX\n+              (\"|\"\":=\"\" should be \"\"=\"\"\");\n+            Scan;\n+            Bnode := P_Expression_No_Right_Paren;\n+         end if;\n+\n+      else\n+         T_When; -- to give error message\n+         Bnode := Error;\n+      end if;\n+\n+      return Bnode;\n+   end P_Entry_Barrier;\n+\n    -----------------------\n    -- 9.5.2  Entry Body --\n    -----------------------\n \n    --  ENTRY_BODY ::=\n-   --    entry DEFINING_IDENTIFIER ENTRY_BODY_FORMAL_PART ENTRY_BARRIER is\n+   --    entry DEFINING_IDENTIFIER ENTRY_BODY_FORMAL_PART\n+   --      [ASPECT_SPECIFICATIONS] ENTRY_BARRIER\n+   --    is\n    --      DECLARATIVE_PART\n    --    begin\n    --      HANDLED_SEQUENCE_OF_STATEMENTS\n@@ -1114,6 +1146,7 @@ package body Ch9 is\n    --  Error_Recovery: cannot raise Error_Resync\n \n    function P_Entry_Body return Node_Id is\n+      Dummy_Node       : Node_Id;\n       Entry_Node       : Node_Id;\n       Formal_Part_Node : Node_Id;\n       Name_Node        : Node_Id;\n@@ -1135,8 +1168,34 @@ package body Ch9 is\n       Formal_Part_Node := P_Entry_Body_Formal_Part;\n       Set_Entry_Body_Formal_Part (Entry_Node, Formal_Part_Node);\n \n+      --  Ada 2012 (AI12-0169): Aspect specifications may appear on an entry\n+      --  body immediately after the formal part. Do not parse the aspect\n+      --  specifications directly because the \"when\" of the entry barrier may\n+      --  be interpreted as a misused \"with\".\n+\n+      if Token = Tok_With then\n+         P_Aspect_Specifications (Entry_Node, Semicolon => False);\n+      end if;\n+\n       Set_Condition (Formal_Part_Node, P_Entry_Barrier);\n+\n+      --  Detect an illegal placement of aspect specifications following the\n+      --  entry barrier.\n+\n+      --    entry E ... when Barrier with Aspect is\n+\n+      if Token = Tok_With then\n+         Error_Msg_SC (\"aspect specifications must come before entry barrier\");\n+\n+         --  Consume the illegal aspects to allow for parsing to continue\n+\n+         Dummy_Node := New_Node (N_Entry_Body, Sloc (Entry_Node));\n+         P_Aspect_Specifications (Dummy_Node, Semicolon => False);\n+      end if;\n+\n+      TF_Is;\n       Parse_Decls_Begin_End (Entry_Node);\n+\n       return Entry_Node;\n    end P_Entry_Body;\n \n@@ -1185,38 +1244,6 @@ package body Ch9 is\n       return Fpart_Node;\n    end P_Entry_Body_Formal_Part;\n \n-   --------------------------\n-   -- 9.5.2  Entry Barrier --\n-   --------------------------\n-\n-   --  ENTRY_BARRIER ::= when CONDITION\n-\n-   --  Error_Recovery: cannot raise Error_Resync\n-\n-   function P_Entry_Barrier return Node_Id is\n-      Bnode : Node_Id;\n-\n-   begin\n-      if Token = Tok_When then\n-         Scan; -- past WHEN;\n-         Bnode := P_Expression_No_Right_Paren;\n-\n-         if Token = Tok_Colon_Equal then\n-            Error_Msg_SC -- CODEFIX\n-              (\"|\"\":=\"\" should be \"\"=\"\"\");\n-            Scan;\n-            Bnode := P_Expression_No_Right_Paren;\n-         end if;\n-\n-      else\n-         T_When; -- to give error message\n-         Bnode := Error;\n-      end if;\n-\n-      TF_Is;\n-      return Bnode;\n-   end P_Entry_Barrier;\n-\n    --------------------------------------\n    -- 9.5.2  Entry Index Specification --\n    --------------------------------------"}, {"sha": "e08709fd2acee42084705ffce28e8a09d940b401", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -1330,7 +1330,7 @@ package body Sem_Attr is\n          if Nkind (Prag) = N_Aspect_Specification then\n             Subp_Decl := Parent (Prag);\n          else\n-            Subp_Decl := Find_Related_Subprogram_Or_Body (Prag);\n+            Subp_Decl := Find_Related_Declaration_Or_Body (Prag);\n          end if;\n \n          --  The aspect or pragma where the attribute resides should be"}, {"sha": "b7bf9f4d5c6e5e3aa7894c7d27bac784d090afbe", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -819,8 +819,8 @@ package body Sem_Aux is\n          --  Generic subprogram body\n \n          elsif Is_Subprogram (S)\n-           and then Nkind (Unit_Declaration_Node (S))\n-                      = N_Generic_Subprogram_Declaration\n+           and then Nkind (Unit_Declaration_Node (S)) =\n+                      N_Generic_Subprogram_Declaration\n          then\n             return True;\n          end if;\n@@ -1649,6 +1649,8 @@ package body Sem_Aux is\n       --  Isn't there some better way to express the following ???\n \n       while Nkind (N) /= N_Abstract_Subprogram_Declaration\n+        and then Nkind (N) /= N_Entry_Body\n+        and then Nkind (N) /= N_Entry_Declaration\n         and then Nkind (N) /= N_Formal_Package_Declaration\n         and then Nkind (N) /= N_Function_Instantiation\n         and then Nkind (N) /= N_Generic_Package_Declaration"}, {"sha": "5de074e1f2565ca40336f4c8d1e2feaac4296e03", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -939,7 +939,7 @@ package body Sem_Ch10 is\n       if Nkind_In (Unit_Node, N_Generic_Subprogram_Declaration,\n                               N_Subprogram_Declaration)\n       then\n-         Analyze_Subprogram_Contract (Defining_Entity (Unit_Node));\n+         Analyze_Entry_Or_Subprogram_Contract (Defining_Entity (Unit_Node));\n       end if;\n \n       --  Generate distribution stubs if requested and no error"}, {"sha": "e7d076ae6bbc0b484f9875b053bfdc25f1f81e7e", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -14796,10 +14796,9 @@ package body Sem_Ch12 is\n             elsif Is_Generic_Contract_Pragma (Prag) and then Prag /= Templ then\n                if Is_Package_Contract_Annotation (Prag) then\n                   Context := Find_Related_Package_Or_Body (Prag);\n-\n                else\n                   pragma Assert (Is_Subprogram_Contract_Annotation (Prag));\n-                  Context := Find_Related_Subprogram_Or_Body (Prag);\n+                  Context := Find_Related_Declaration_Or_Body (Prag);\n                end if;\n \n                --  The use of Original_Node accounts for the case when the"}, {"sha": "cf2ba436cb13075c8c1397de9baf255bd42a04c6", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -3474,9 +3474,9 @@ package body Sem_Ch13 is\n       Body_Id : constant Entity_Id := Defining_Entity (N);\n \n       procedure Diagnose_Misplaced_Aspects (Spec_Id : Entity_Id);\n-      --  Subprogram body [stub] N has aspects, but they are not properly\n-      --  placed. Emit an error message depending on the aspects involved.\n-      --  Spec_Id is the entity of the corresponding spec.\n+      --  Body [stub] N has aspects, but they are not properly placed. Emit an\n+      --  error message depending on the aspects involved. Spec_Id denotes the\n+      --  entity of the corresponding spec.\n \n       --------------------------------\n       -- Diagnose_Misplaced_Aspects --\n@@ -3532,7 +3532,7 @@ package body Sem_Ch13 is\n \n             else\n                Error_Msg_N\n-                 (\"aspect specification must appear in subprogram declaration\",\n+                 (\"aspect specification must appear on initial declaration\",\n                   Asp);\n             end if;\n          end Misplaced_Aspect_Error;\n@@ -3574,7 +3574,7 @@ package body Sem_Ch13 is\n \n             else\n                Error_Msg_N\n-                 (\"aspect specification must appear in subprogram declaration\",\n+                 (\"aspect specification must appear on initial declaration\",\n                   Asp);\n             end if;\n \n@@ -3584,23 +3584,17 @@ package body Sem_Ch13 is\n \n       --  Local variables\n \n-      Spec_Id : Entity_Id;\n+      Spec_Id : constant Entity_Id := Unique_Defining_Entity (N);\n \n    --  Start of processing for Analyze_Aspects_On_Body_Or_Stub\n \n    begin\n-      if Nkind (N) = N_Subprogram_Body_Stub then\n-         Spec_Id := Corresponding_Spec_Of_Stub (N);\n-      else\n-         Spec_Id := Corresponding_Spec (N);\n-      end if;\n-\n       --  Language-defined aspects cannot be associated with a subprogram body\n       --  [stub] if the subprogram has a spec. Certain implementation defined\n       --  aspects are allowed to break this rule (for all applicable cases, see\n       --  table Aspects.Aspect_On_Body_Or_Stub_OK).\n \n-      if Present (Spec_Id) and then not Aspects_On_Body_Or_Stub_OK (N) then\n+      if Spec_Id /= Body_Id and then not Aspects_On_Body_Or_Stub_OK (N) then\n          Diagnose_Misplaced_Aspects (Spec_Id);\n       else\n          Analyze_Aspect_Specifications (N, Body_Id);"}, {"sha": "e1eadd19d52fc79928990ca4c3ac5735506f95a8", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -2505,16 +2505,23 @@ package body Sem_Ch3 is\n                Analyze_Object_Contract (Defining_Entity (Decl));\n \n             elsif Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n+                                  N_Entry_Declaration,\n                                   N_Generic_Subprogram_Declaration,\n                                   N_Subprogram_Declaration)\n             then\n-               Analyze_Subprogram_Contract (Defining_Entity (Decl));\n+               Analyze_Entry_Or_Subprogram_Contract (Defining_Entity (Decl));\n \n-            elsif Nkind (Decl) = N_Subprogram_Body then\n-               Analyze_Subprogram_Body_Contract (Defining_Entity (Decl));\n+            elsif Nkind_In (Decl, N_Entry_Body, N_Subprogram_Body) then\n+               Analyze_Entry_Or_Subprogram_Body_Contract\n+                 (Defining_Entity (Decl));\n \n             elsif Nkind (Decl) = N_Subprogram_Body_Stub then\n                Analyze_Subprogram_Body_Stub_Contract (Defining_Entity (Decl));\n+\n+            elsif Nkind_In (Decl, N_Single_Task_Declaration,\n+                                  N_Task_Type_Declaration)\n+            then\n+               Analyze_Task_Contract (Defining_Entity (Decl));\n             end if;\n \n             Next (Decl);"}, {"sha": "ec92bf4581340bcc1dca90378a320e8bac6fb5c5", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -1385,7 +1385,7 @@ package body Sem_Ch6 is\n          --  have been analyzed. This ensures that any contract-related pragmas\n          --  are available through the N_Contract node of the body.\n \n-         Analyze_Subprogram_Body_Contract (Body_Id);\n+         Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id);\n \n          Analyze (Handled_Statement_Sequence (N));\n          Save_Global_References (Original_Node (N));\n@@ -3789,7 +3789,7 @@ package body Sem_Ch6 is\n       --  after the declarations of the body have been processed as pragmas\n       --  are now chained on the contract of the subprogram body.\n \n-      Analyze_Subprogram_Body_Contract (Body_Id);\n+      Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id);\n \n       --  If SPARK_Mode for body is not On, disable frontend inlining for this\n       --  subprogram in GNATprove mode, as its body should not be analyzed."}, {"sha": "62d72516d4fc404c1e3d066a51eb4c517654ad1e", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -1213,8 +1213,8 @@ package body Sem_Ch9 is\n          Set_Ekind (Id, E_Entry);\n       end if;\n \n-      Set_Scope          (Id, Current_Scope);\n       Set_Etype          (Id, Standard_Void_Type);\n+      Set_Scope          (Id, Current_Scope);\n       Set_Accept_Address (Id, New_Elmt_List);\n \n       --  Set the SPARK_Mode from the current context (may be overwritten later\n@@ -1223,6 +1223,12 @@ package body Sem_Ch9 is\n       Set_SPARK_Pragma           (Id, SPARK_Mode_Pragma);\n       Set_SPARK_Pragma_Inherited (Id);\n \n+      --  Analyze any aspect specifications that appear on the entry body\n+\n+      if Has_Aspects (N) then\n+         Analyze_Aspect_Specifications_On_Body_Or_Stub (N);\n+      end if;\n+\n       E := First_Entity (P_Type);\n       while Present (E) loop\n          if Chars (E) = Chars (Id)\n@@ -1352,6 +1358,12 @@ package body Sem_Ch9 is\n          Inspect_Deferred_Constant_Completion (Decls);\n       end if;\n \n+      --  Process the contract of the subprogram body after all declarations\n+      --  have been analyzed. This ensures that any contract-related pragmas\n+      --  are available through the N_Contract node of the body.\n+\n+      Analyze_Entry_Or_Subprogram_Body_Contract (Id);\n+\n       if Present (Stats) then\n          Analyze (Stats);\n       end if;"}, {"sha": "cbefd3898a7b96563268d243c5baee365f60d985", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 297, "deletions": 174, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -209,6 +209,12 @@ package body Sem_Prag is\n    --  Do_Checks is set, the routine reports duplicate pragmas. The routine\n    --  returns Empty when reaching the start of the node chain.\n \n+   function Fix_Msg (Id : Entity_Id; Msg : String) return String;\n+   --  Replace all occurrences of \"subprogram\" in string Msg with a specific\n+   --  word depending on the Ekind of Id as follows:\n+   --    * When Id is an entry [family], replace with \"entry\"\n+   --    * When Id is a task type, replace with \"task unit\"\n+\n    function Get_Base_Subprogram (Def_Id : Entity_Id) return Entity_Id;\n    --  If Def_Id refers to a renamed subprogram, then the base subprogram (the\n    --  original one, following the renaming chain) is returned. Otherwise the\n@@ -386,7 +392,7 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n+      Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n       Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n       CCases    : constant Node_Id   := Expression (Get_Argument (N, Spec_Id));\n \n@@ -465,7 +471,7 @@ package body Sem_Prag is\n \n    procedure Analyze_Depends_In_Decl_Part (N : Node_Id) is\n       Loc       : constant Source_Ptr := Sloc (N);\n-      Subp_Decl : constant Node_Id    := Find_Related_Subprogram_Or_Body (N);\n+      Subp_Decl : constant Node_Id    := Find_Related_Declaration_Or_Body (N);\n       Spec_Id   : constant Entity_Id  := Unique_Defining_Entity (Subp_Decl);\n \n       All_Inputs_Seen : Elist_Id := No_Elist;\n@@ -1144,8 +1150,8 @@ package body Sem_Prag is\n \n                Error_Msg_Name_1 := Chars (Spec_Id);\n                SPARK_Msg_NE\n-                 (\"\\& is not part of the input or output set of subprogram %\",\n-                  Item, Item_Id);\n+                 (Fix_Msg (Spec_Id, \"\\& is not part of the input or output \"\n+                  & \"set of subprogram %\"), Item, Item_Id);\n \n             --  The mode of the item and its role in pragma [Refined_]Depends\n             --  are in conflict. Construct a detailed message explaining the\n@@ -1638,7 +1644,9 @@ package body Sem_Prag is\n                Restore_Scope := True;\n                Push_Scope (Spec_Id);\n \n-               if Is_Generic_Subprogram (Spec_Id) then\n+               if Ekind (Spec_Id) = E_Task_Type then\n+                  null;\n+               elsif Is_Generic_Subprogram (Spec_Id) then\n                   Install_Generic_Formals (Spec_Id);\n                else\n                   Install_Formals (Spec_Id);\n@@ -1772,7 +1780,7 @@ package body Sem_Prag is\n    ---------------------------------\n \n    procedure Analyze_Global_In_Decl_Part (N : Node_Id) is\n-      Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n+      Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n       Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n       Subp_Id   : constant Entity_Id := Defining_Entity (Subp_Decl);\n \n@@ -1876,8 +1884,8 @@ package body Sem_Prag is\n                if Is_Formal (Item_Id) then\n                   if Scope (Item_Id) = Spec_Id then\n                      SPARK_Msg_NE\n-                       (\"global item cannot reference parameter of \"\n-                        & \"subprogram &\", Item, Spec_Id);\n+                       (Fix_Msg (Spec_Id, \"global item cannot reference \"\n+                        & \"parameter of subprogram &\"), Item, Spec_Id);\n                      return;\n                   end if;\n \n@@ -2096,9 +2104,10 @@ package body Sem_Prag is\n                      SPARK_Msg_NE\n                        (\"global item & cannot have mode In_Out or Output\",\n                         Item, Item_Id);\n+\n                      SPARK_Msg_NE\n-                       (\"\\item already appears as input of subprogram &\",\n-                        Item, Context);\n+                       (Fix_Msg (Subp_Id, \"\\item already appears as input of \"\n+                        & \"subprogram &\"), Item, Context);\n \n                      --  Stop the traversal once an error has been detected\n \n@@ -2257,7 +2266,9 @@ package body Sem_Prag is\n             Restore_Scope := True;\n             Push_Scope (Spec_Id);\n \n-            if Is_Generic_Subprogram (Spec_Id) then\n+            if Ekind (Spec_Id) = E_Task_Type then\n+               null;\n+            elsif Is_Generic_Subprogram (Spec_Id) then\n                Install_Generic_Formals (Spec_Id);\n             else\n                Install_Formals (Spec_Id);\n@@ -3351,21 +3362,26 @@ package body Sem_Prag is\n          --  associated with a subprogram declaration or a body that acts as a\n          --  spec.\n \n-         Subp_Decl := Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n+         Subp_Decl := Find_Related_Declaration_Or_Body (N, Do_Checks => True);\n+\n+         --  Entry\n+\n+         if Nkind (Subp_Decl) = N_Entry_Declaration then\n+            null;\n \n          --  Generic subprogram\n \n-         if Nkind (Subp_Decl) = N_Generic_Subprogram_Declaration then\n+         elsif Nkind (Subp_Decl) = N_Generic_Subprogram_Declaration then\n             null;\n \n-         --  Body acts as spec\n+         --  Subprogram body acts as spec\n \n          elsif Nkind (Subp_Decl) = N_Subprogram_Body\n            and then No (Corresponding_Spec (Subp_Decl))\n          then\n             null;\n \n-         --  Body stub acts as spec\n+         --  Subprogram body stub acts as spec\n \n          elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n            and then No (Corresponding_Spec_Of_Stub (Subp_Decl))\n@@ -3377,6 +3393,11 @@ package body Sem_Prag is\n          elsif Nkind (Subp_Decl) = N_Subprogram_Declaration then\n             null;\n \n+         --  Task unit\n+\n+         elsif Nkind (Subp_Decl) = N_Task_Type_Declaration then\n+            null;\n+\n          else\n             Pragma_Misplaced;\n             return;\n@@ -3387,6 +3408,16 @@ package body Sem_Prag is\n          Legal   := True;\n          Spec_Id := Unique_Defining_Entity (Subp_Decl);\n \n+         --  When the related context is an entry, it must be a protected entry\n+         --  (SPARK RM 6.1.4(6)).\n+\n+         if Is_Entry_Declaration (Spec_Id)\n+           and then Ekind (Scope (Spec_Id)) /= E_Protected_Type\n+         then\n+            Pragma_Misplaced;\n+            return;\n+         end if;\n+\n          --  A pragma that applies to a Ghost entity becomes Ghost for the\n          --  purposes of legality checks and removal of ignored Ghost code.\n \n@@ -3686,7 +3717,8 @@ package body Sem_Prag is\n          --  Ensure the proper placement of the pragma\n \n          Subp_Decl :=\n-           Find_Related_Subprogram_Or_Body (N, Do_Checks => not Duplicates_OK);\n+           Find_Related_Declaration_Or_Body\n+             (N, Do_Checks => not Duplicates_OK);\n \n          --  When a pre/postcondition pragma applies to an abstract subprogram,\n          --  its original form must be an aspect with 'Class.\n@@ -3759,10 +3791,11 @@ package body Sem_Prag is\n \n          Mark_Pragma_As_Ghost (N, Subp_Id);\n \n-         --  Fully analyze the pragma when it appears inside a subprogram\n-         --  body because it cannot benefit from forward references.\n+         --  Fully analyze the pragma when it appears inside an entry or\n+         --  subprogram body because it cannot benefit from forward references.\n \n-         if Nkind_In (Subp_Decl, N_Subprogram_Body,\n+         if Nkind_In (Subp_Decl, N_Entry_Body,\n+                                 N_Subprogram_Body,\n                                  N_Subprogram_Body_Stub)\n          then\n             --  The legality checks of pragmas Precondition and Postcondition\n@@ -3801,23 +3834,36 @@ package body Sem_Prag is\n          --  Verify the placement of the pragma and check for duplicates. The\n          --  pragma must apply to a subprogram body [stub].\n \n-         Body_Decl := Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n+         Body_Decl := Find_Related_Declaration_Or_Body (N, Do_Checks => True);\n+\n+         --  Entry body\n+\n+         if Nkind (Body_Decl) = N_Entry_Body then\n+            null;\n+\n+         --  Subprogram body\n \n-         --  Extract the entities of the spec and body\n+         elsif Nkind (Body_Decl) = N_Subprogram_Body then\n+            null;\n \n-         if Nkind (Body_Decl) = N_Subprogram_Body then\n-            Body_Id := Defining_Entity (Body_Decl);\n-            Spec_Id := Corresponding_Spec (Body_Decl);\n+         --  Subprogram body stub\n \n          elsif Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n-            Body_Id := Defining_Entity (Body_Decl);\n-            Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n+            null;\n+\n+         --  Task body\n+\n+         elsif Nkind (Body_Decl) = N_Task_Body then\n+            null;\n \n          else\n             Pragma_Misplaced;\n             return;\n          end if;\n \n+         Body_Id := Defining_Entity (Body_Decl);\n+         Spec_Id := Unique_Defining_Entity (Body_Decl);\n+\n          --  The pragma must apply to the second declaration of a subprogram.\n          --  In other words, the body [stub] cannot acts as a spec.\n \n@@ -3839,10 +3885,17 @@ package body Sem_Prag is\n \n          Spec_Decl := Unit_Declaration_Node (Spec_Id);\n \n+         --  The proper context of a entry declaration is the declaration of\n+         --  the enclosing synchronized type.\n+\n+         if Nkind (Spec_Decl) = N_Entry_Declaration then\n+            Spec_Decl := Parent (Parent (Spec_Decl));\n+         end if;\n+\n          if Nkind (Parent (Spec_Decl)) /= N_Package_Specification then\n             Error_Pragma\n-              (\"pragma % must apply to the body of a subprogram declared in a \"\n-               & \"package specification\");\n+              (Fix_Msg (Spec_Id, \"pragma % must apply to the body of \"\n+               & \"subprogram declared in a package specification\"));\n             return;\n          end if;\n \n@@ -12275,7 +12328,7 @@ package body Sem_Prag is\n             --  as a spec.\n \n             Subp_Decl :=\n-              Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n+              Find_Related_Declaration_Or_Body (N, Do_Checks => True);\n \n             --  Generic subprogram\n \n@@ -12319,10 +12372,12 @@ package body Sem_Prag is\n             Mark_Pragma_As_Ghost (N, Spec_Id);\n             Ensure_Aggregate_Form (Get_Argument (N, Spec_Id));\n \n-            --  Fully analyze the pragma when it appears inside a subprogram\n-            --  body because it cannot benefit from forward references.\n+            --  Fully analyze the pragma when it appears inside an entry\n+            --  or subprogram body because it cannot benefit from forward\n+            --  references.\n \n-            if Nkind_In (Subp_Decl, N_Subprogram_Body,\n+            if Nkind_In (Subp_Decl, N_Entry_Body,\n+                                    N_Subprogram_Body,\n                                     N_Subprogram_Body_Stub)\n             then\n                --  The legality checks of pragma Contract_Cases are affected by\n@@ -13046,10 +13101,12 @@ package body Sem_Prag is\n \n                Add_Contract_Item (N, Spec_Id);\n \n-               --  Fully analyze the pragma when it appears inside a subprogram\n-               --  body because it cannot benefit from forward references.\n+               --  Fully analyze the pragma when it appears inside an entry\n+               --  or subprogram body because it cannot benefit from forward\n+               --  references.\n \n-               if Nkind_In (Subp_Decl, N_Subprogram_Body,\n+               if Nkind_In (Subp_Decl, N_Entry_Body,\n+                                       N_Subprogram_Body,\n                                        N_Subprogram_Body_Stub)\n                then\n                   --  The legality checks of pragmas Depends and Global are\n@@ -13993,7 +14050,7 @@ package body Sem_Prag is\n             Check_At_Most_N_Arguments (1);\n \n             Subp_Decl :=\n-              Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n+              Find_Related_Declaration_Or_Body (N, Do_Checks => True);\n \n             --  Generic subprogram declaration\n \n@@ -14564,10 +14621,12 @@ package body Sem_Prag is\n \n                Add_Contract_Item (N, Spec_Id);\n \n-               --  Fully analyze the pragma when it appears inside a subprogram\n-               --  body because it cannot benefit from forward references.\n+               --  Fully analyze the pragma when it appears inside an entry\n+               --  or subprogram body because it cannot benefit from forward\n+               --  references.\n \n-               if Nkind_In (Subp_Decl, N_Subprogram_Body,\n+               if Nkind_In (Subp_Decl, N_Entry_Body,\n+                                       N_Subprogram_Body,\n                                        N_Subprogram_Body_Stub)\n                then\n                   --  The legality checks of pragmas Depends and Global are\n@@ -20991,7 +21050,7 @@ package body Sem_Prag is\n                return;\n             end if;\n \n-            Subp_Decl := Find_Related_Subprogram_Or_Body (N);\n+            Subp_Decl := Find_Related_Declaration_Or_Body (N);\n \n             --  Find the enclosing context\n \n@@ -21067,10 +21126,12 @@ package body Sem_Prag is\n \n             Check_Distinct_Name (Subp_Id);\n \n-            --  Fully analyze the pragma when it appears inside a subprogram\n-            --  body because it cannot benefit from forward references.\n+            --  Fully analyze the pragma when it appears inside an entry\n+            --  or subprogram body because it cannot benefit from forward\n+            --  references.\n \n-            if Nkind_In (Subp_Decl, N_Subprogram_Body,\n+            if Nkind_In (Subp_Decl, N_Entry_Body,\n+                                    N_Subprogram_Body,\n                                     N_Subprogram_Body_Stub)\n             then\n                --  The legality checks of pragma Test_Case are affected by the\n@@ -21910,7 +21971,7 @@ package body Sem_Prag is\n             Check_At_Most_N_Arguments (1);\n \n             Subp_Decl :=\n-              Find_Related_Subprogram_Or_Body (N, Do_Checks => True);\n+              Find_Related_Declaration_Or_Body (N, Do_Checks => True);\n \n             --  Generic subprogram\n \n@@ -22575,7 +22636,7 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n+      Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n       Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n       Expr      : constant Node_Id   := Expression (Get_Argument (N, Spec_Id));\n \n@@ -22773,9 +22834,9 @@ package body Sem_Prag is\n \n                Item_Id := Available_View (Entity_Of (Item));\n \n-               return Ekind (Item_Id) = E_Abstract_State\n-                 and then Has_Null_Refinement (Item_Id);\n-\n+               return\n+                 Ekind (Item_Id) = E_Abstract_State\n+                   and then Has_Null_Refinement (Item_Id);\n             else\n                return False;\n             end if;\n@@ -23059,8 +23120,8 @@ package body Sem_Prag is\n \n          if not Clause_Matched then\n             SPARK_Msg_NE\n-              (\"dependence clause of subprogram & has no matching refinement \"\n-               & \"in body\", Dep_Clause, Spec_Id);\n+              (Fix_Msg (Spec_Id, \"dependence clause of subprogram & has no \"\n+               & \"matching refinement in body\"), Dep_Clause, Spec_Id);\n          end if;\n       end Check_Dependency_Clause;\n \n@@ -23377,7 +23438,7 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Body_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n+      Body_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n       Body_Id   : constant Entity_Id := Defining_Entity (Body_Decl);\n       Errors    : constant Nat       := Serious_Errors_Detected;\n       Clause    : Node_Id;\n@@ -23394,21 +23455,16 @@ package body Sem_Prag is\n          return;\n       end if;\n \n-      if Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n-         Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n-      else\n-         Spec_Id := Corresponding_Spec (Body_Decl);\n-      end if;\n-\n+      Spec_Id := Unique_Defining_Entity (Body_Decl);\n       Depends := Get_Pragma (Spec_Id, Pragma_Depends);\n \n       --  Subprogram declarations lacks pragma Depends. Refined_Depends is\n       --  rendered useless as there is nothing to refine (SPARK RM 7.2.5(2)).\n \n       if No (Depends) then\n          SPARK_Msg_NE\n-           (\"useless refinement, declaration of subprogram & lacks aspect or \"\n-            & \"pragma Depends\", N, Spec_Id);\n+           (Fix_Msg (Spec_Id, \"useless refinement, declaration of subprogram \"\n+            & \"& lacks aspect or pragma Depends\"), N, Spec_Id);\n          goto Leave;\n       end if;\n \n@@ -23421,8 +23477,8 @@ package body Sem_Prag is\n \n       if Nkind (Deps) = N_Null then\n          SPARK_Msg_NE\n-           (\"useless refinement, subprogram & does not depend on abstract \"\n-            & \"state with visible refinement\", N, Spec_Id);\n+           (Fix_Msg (Spec_Id, \"useless refinement, subprogram & does not \"\n+            & \"depend on abstract state with visible refinement\"), N, Spec_Id);\n          goto Leave;\n       end if;\n \n@@ -24355,7 +24411,7 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Body_Decl : constant Node_Id := Find_Related_Subprogram_Or_Body (N);\n+      Body_Decl : constant Node_Id := Find_Related_Declaration_Or_Body (N);\n       Errors    : constant Nat     := Serious_Errors_Detected;\n       Items     : Node_Id;\n \n@@ -24368,22 +24424,17 @@ package body Sem_Prag is\n          return;\n       end if;\n \n-      if Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n-         Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n-      else\n-         Spec_Id := Corresponding_Spec (Body_Decl);\n-      end if;\n-\n-      Global := Get_Pragma (Spec_Id, Pragma_Global);\n-      Items  := Expression (Get_Argument (N, Spec_Id));\n+      Spec_Id := Unique_Defining_Entity (Body_Decl);\n+      Global  := Get_Pragma (Spec_Id, Pragma_Global);\n+      Items   := Expression (Get_Argument (N, Spec_Id));\n \n       --  The subprogram declaration lacks pragma Global. This renders\n       --  Refined_Global useless as there is nothing to refine.\n \n       if No (Global) then\n          SPARK_Msg_NE\n-           (\"useless refinement, declaration of subprogram & lacks aspect or \"\n-            & \"pragma Global\", N, Spec_Id);\n+           (Fix_Msg (Spec_Id, \"useless refinement, declaration of subprogram \"\n+            & \"& lacks aspect or pragma Global\"), N, Spec_Id);\n          goto Leave;\n       end if;\n \n@@ -24415,8 +24466,9 @@ package body Sem_Prag is\n            and then not Has_Null_State\n          then\n             SPARK_Msg_NE\n-              (\"useless refinement, subprogram & does not depend on abstract \"\n-               & \"state with visible refinement\", N, Spec_Id);\n+              (Fix_Msg (Spec_Id, \"useless refinement, subprogram & does not \"\n+               & \"depend on abstract state with visible refinement\"),\n+               N, Spec_Id);\n             goto Leave;\n \n          --  The global refinement of inputs and outputs cannot be null when\n@@ -24432,8 +24484,8 @@ package body Sem_Prag is\n            and then not Has_Null_State\n          then\n             SPARK_Msg_NE\n-              (\"refinement cannot be null, subprogram & has global items\",\n-               N, Spec_Id);\n+              (Fix_Msg (Spec_Id, \"refinement cannot be null, subprogram & has \"\n+               & \"global items\"), N, Spec_Id);\n             goto Leave;\n          end if;\n       end if;\n@@ -25292,7 +25344,7 @@ package body Sem_Prag is\n    ------------------------------------\n \n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id) is\n-      Subp_Decl : constant Node_Id   := Find_Related_Subprogram_Or_Body (N);\n+      Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n       Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n \n       procedure Preanalyze_Test_Case_Arg (Arg_Nam : Name_Id);\n@@ -26326,10 +26378,13 @@ package body Sem_Prag is\n          Next_Entity (Formal);\n       end loop;\n \n-      --  When processing a subprogram body, look for pragmas Refined_Depends\n-      --  and Refined_Global as they specify the inputs and outputs.\n+      --  When processing an entry, subprogram or task body, look for pragmas\n+      --  Refined_Depends and Refined_Global as they specify the inputs and\n+      --  outputs.\n \n-      if Ekind (Subp_Id) = E_Subprogram_Body then\n+      if Is_Entry_Body (Subp_Id)\n+        or else Ekind_In (Subp_Id, E_Subprogram_Body, E_Task_Body)\n+      then\n          Depends := Get_Pragma (Subp_Id, Pragma_Refined_Depends);\n          Global  := Get_Pragma (Subp_Id, Pragma_Refined_Global);\n \n@@ -26469,99 +26524,11 @@ package body Sem_Prag is\n       return Empty;\n    end Find_Related_Context;\n \n-   ----------------------------------\n-   -- Find_Related_Package_Or_Body --\n-   ----------------------------------\n-\n-   function Find_Related_Package_Or_Body\n-     (Prag      : Node_Id;\n-      Do_Checks : Boolean := False) return Node_Id\n-   is\n-      Context  : constant Node_Id := Parent (Prag);\n-      Prag_Nam : constant Name_Id := Pragma_Name (Prag);\n-      Stmt     : Node_Id;\n-\n-   begin\n-      Stmt := Prev (Prag);\n-      while Present (Stmt) loop\n-\n-         --  Skip prior pragmas, but check for duplicates\n-\n-         if Nkind (Stmt) = N_Pragma then\n-            if Do_Checks and then Pragma_Name (Stmt) = Prag_Nam then\n-               Duplication_Error\n-                 (Prag => Prag,\n-                  Prev => Stmt);\n-            end if;\n-\n-         --  Skip internally generated code\n-\n-         elsif not Comes_From_Source (Stmt) then\n-            if Nkind (Stmt) = N_Subprogram_Declaration then\n-\n-               --  The subprogram declaration is an internally generated spec\n-               --  for an expression function.\n-\n-               if Nkind (Original_Node (Stmt)) = N_Expression_Function then\n-                  return Stmt;\n-\n-               --  The subprogram is actually an instance housed within an\n-               --  anonymous wrapper package.\n-\n-               elsif Present (Generic_Parent (Specification (Stmt))) then\n-                  return Stmt;\n-               end if;\n-            end if;\n-\n-         --  Return the current source construct which is illegal\n-\n-         else\n-            return Stmt;\n-         end if;\n-\n-         Prev (Stmt);\n-      end loop;\n-\n-      --  If we fall through, then the pragma was either the first declaration\n-      --  or it was preceded by other pragmas and no source constructs.\n-\n-      --  The pragma is associated with a package. The immediate context in\n-      --  this case is the specification of the package.\n-\n-      if Nkind (Context) = N_Package_Specification then\n-         return Parent (Context);\n-\n-      --  The pragma appears in the declarations of a package body\n-\n-      elsif Nkind (Context) = N_Package_Body then\n-         return Context;\n-\n-      --  The pragma appears in the statements of a package body\n-\n-      elsif Nkind (Context) = N_Handled_Sequence_Of_Statements\n-        and then Nkind (Parent (Context)) = N_Package_Body\n-      then\n-         return Parent (Context);\n-\n-      --  The pragma is a byproduct of aspect expansion, return the related\n-      --  context of the original aspect. This case has a lower priority as\n-      --  the above circuitry pinpoints precisely the related context.\n-\n-      elsif Present (Corresponding_Aspect (Prag)) then\n-         return Parent (Corresponding_Aspect (Prag));\n-\n-      --  No candidate packge [body] found\n-\n-      else\n-         return Empty;\n-      end if;\n-   end Find_Related_Package_Or_Body;\n-\n-   -------------------------------------\n-   -- Find_Related_Subprogram_Or_Body --\n-   -------------------------------------\n+   --------------------------------------\n+   -- Find_Related_Declaration_Or_Body --\n+   --------------------------------------\n \n-   function Find_Related_Subprogram_Or_Body\n+   function Find_Related_Declaration_Or_Body\n      (Prag      : Node_Id;\n       Do_Checks : Boolean := False) return Node_Id\n    is\n@@ -26604,7 +26571,7 @@ package body Sem_Prag is\n                                           Name_Refined_Post);\n       --  Refinement pragmas must be associated with a subprogram body [stub]\n \n-   --  Start of processing for Find_Related_Subprogram_Or_Body\n+   --  Start of processing for Find_Related_Declaration_Or_Body\n \n    begin\n       Stmt := Prev (Prag);\n@@ -26660,6 +26627,14 @@ package body Sem_Prag is\n                elsif Present (Generic_Parent (Specification (Stmt))) then\n                   return Stmt;\n                end if;\n+\n+            --  The pragma applies to a single task declaration rewritten as a\n+            --  task type.\n+\n+            elsif Nkind (Stmt) = N_Task_Type_Declaration\n+              and then Nkind (Original_Node (Stmt)) = N_Single_Task_Declaration\n+            then\n+               return Stmt;\n             end if;\n \n          --  Return the current construct which is either a subprogram body,\n@@ -26680,6 +26655,11 @@ package body Sem_Prag is\n       if Nkind (Context) = N_Compilation_Unit_Aux then\n          return Unit (Parent (Context));\n \n+      --  The pragma appears inside the declarations of an entry body\n+\n+      elsif Nkind (Context) = N_Entry_Body then\n+         return Context;\n+\n       --  The pragma appears inside the statements of a subprogram body. This\n       --  placement is the result of subprogram contract expansion.\n \n@@ -26691,6 +26671,11 @@ package body Sem_Prag is\n       elsif Nkind (Context) = N_Subprogram_Body then\n          return Context;\n \n+      --  The pragma appears inside the declarative part of a task body\n+\n+      elsif Nkind (Context) = N_Task_Body then\n+         return Context;\n+\n       --  The pragma is a byproduct of aspect expansion, return the related\n       --  context of the original aspect. This case has a lower priority as\n       --  the above circuitry pinpoints precisely the related context.\n@@ -26703,7 +26688,145 @@ package body Sem_Prag is\n       else\n          return Empty;\n       end if;\n-   end Find_Related_Subprogram_Or_Body;\n+   end Find_Related_Declaration_Or_Body;\n+\n+   ----------------------------------\n+   -- Find_Related_Package_Or_Body --\n+   ----------------------------------\n+\n+   function Find_Related_Package_Or_Body\n+     (Prag      : Node_Id;\n+      Do_Checks : Boolean := False) return Node_Id\n+   is\n+      Context  : constant Node_Id := Parent (Prag);\n+      Prag_Nam : constant Name_Id := Pragma_Name (Prag);\n+      Stmt     : Node_Id;\n+\n+   begin\n+      Stmt := Prev (Prag);\n+      while Present (Stmt) loop\n+\n+         --  Skip prior pragmas, but check for duplicates\n+\n+         if Nkind (Stmt) = N_Pragma then\n+            if Do_Checks and then Pragma_Name (Stmt) = Prag_Nam then\n+               Duplication_Error\n+                 (Prag => Prag,\n+                  Prev => Stmt);\n+            end if;\n+\n+         --  Skip internally generated code\n+\n+         elsif not Comes_From_Source (Stmt) then\n+            if Nkind (Stmt) = N_Subprogram_Declaration then\n+\n+               --  The subprogram declaration is an internally generated spec\n+               --  for an expression function.\n+\n+               if Nkind (Original_Node (Stmt)) = N_Expression_Function then\n+                  return Stmt;\n+\n+               --  The subprogram is actually an instance housed within an\n+               --  anonymous wrapper package.\n+\n+               elsif Present (Generic_Parent (Specification (Stmt))) then\n+                  return Stmt;\n+               end if;\n+            end if;\n+\n+         --  Return the current source construct which is illegal\n+\n+         else\n+            return Stmt;\n+         end if;\n+\n+         Prev (Stmt);\n+      end loop;\n+\n+      --  If we fall through, then the pragma was either the first declaration\n+      --  or it was preceded by other pragmas and no source constructs.\n+\n+      --  The pragma is associated with a package. The immediate context in\n+      --  this case is the specification of the package.\n+\n+      if Nkind (Context) = N_Package_Specification then\n+         return Parent (Context);\n+\n+      --  The pragma appears in the declarations of a package body\n+\n+      elsif Nkind (Context) = N_Package_Body then\n+         return Context;\n+\n+      --  The pragma appears in the statements of a package body\n+\n+      elsif Nkind (Context) = N_Handled_Sequence_Of_Statements\n+        and then Nkind (Parent (Context)) = N_Package_Body\n+      then\n+         return Parent (Context);\n+\n+      --  The pragma is a byproduct of aspect expansion, return the related\n+      --  context of the original aspect. This case has a lower priority as\n+      --  the above circuitry pinpoints precisely the related context.\n+\n+      elsif Present (Corresponding_Aspect (Prag)) then\n+         return Parent (Corresponding_Aspect (Prag));\n+\n+      --  No candidate packge [body] found\n+\n+      else\n+         return Empty;\n+      end if;\n+   end Find_Related_Package_Or_Body;\n+\n+   -------------\n+   -- Fix_Msg --\n+   -------------\n+\n+   function Fix_Msg (Id : Entity_Id; Msg : String) return String is\n+      Msg_Last  : constant Natural := Msg'Last;\n+      Msg_Index : Natural;\n+      Res       : String (Msg'Range) := (others => ' ');\n+      Res_Index : Natural;\n+\n+   begin\n+      --  Copy all characters from the input message Msg to result Res with\n+      --  suitable replacements.\n+\n+      Msg_Index := Msg'First;\n+      Res_Index := Res'First;\n+      while Msg_Index <= Msg_Last loop\n+\n+         --  Replace \"subprogram\" with a different word\n+\n+         if Msg_Index <= Msg_Last - 10\n+           and then Msg (Msg_Index .. Msg_Index + 9) = \"subprogram\"\n+         then\n+            if Ekind_In (Id, E_Entry, E_Entry_Family) then\n+               Res (Res_Index .. Res_Index + 4) := \"entry\";\n+               Res_Index := Res_Index + 5;\n+\n+            elsif Ekind_In (Id, E_Task_Body, E_Task_Type) then\n+               Res (Res_Index .. Res_Index + 8) := \"task unit\";\n+               Res_Index := Res_Index + 9;\n+\n+            else\n+               Res (Res_Index .. Res_Index + 9) := \"subprogram\";\n+               Res_Index := Res_Index + 10;\n+            end if;\n+\n+            Msg_Index := Msg_Index + 10;\n+\n+         --  Otherwise copy the character\n+\n+         else\n+            Res (Res_Index) := Msg (Msg_Index);\n+            Msg_Index := Msg_Index + 1;\n+            Res_Index := Res_Index + 1;\n+         end if;\n+      end loop;\n+\n+      return Res (Res'First .. Res_Index - 1);\n+   end Fix_Msg;\n \n    ------------------\n    -- Get_Argument --"}, {"sha": "e8c647e4dda114d799f28201c80bb15952e2cbd3", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -327,22 +327,29 @@ package Sem_Prag is\n    --  the pragma is illegal. If flag Do_Checks is set, the routine reports\n    --  duplicate pragmas.\n \n-   function Find_Related_Subprogram_Or_Body\n+   function Find_Related_Declaration_Or_Body\n      (Prag      : Node_Id;\n       Do_Checks : Boolean := False) return Node_Id;\n-   --  Subsidiary to the analysis of pragmas Contract_Cases, Depends, Global,\n-   --  Refined_Depends, Refined_Global and Refined_Post and attribute 'Result.\n-   --  Find the declaration of the related subprogram [body or stub] subject\n-   --  to pragma Prag. If flag Do_Checks is set, the routine reports duplicate\n-   --  pragmas and detects improper use of refinement pragmas in stand alone\n-   --  expression functions. The returned value depends on the related pragma\n-   --  as follows:\n-   --    1) Pragmas Contract_Cases, Depends and Global yield the corresponding\n-   --       N_Subprogram_Declaration node or if the pragma applies to a stand\n-   --       alone body, the N_Subprogram_Body node or Empty if illegal.\n-   --    2) Pragmas Refined_Depends, Refined_Global and Refined_Post yield\n-   --       N_Subprogram_Body or N_Subprogram_Body_Stub nodes or Empty if\n-   --       illegal.\n+   --  Subsidiary to the analysis of pragmas\n+   --    Contract_Cases\n+   --    Depends\n+   --    Extensions_Visible\n+   --    Global\n+   --    Post\n+   --    Post_Class\n+   --    Postcondition\n+   --    Pre\n+   --    Pre_Class\n+   --    Precondition\n+   --    Refined_Depends\n+   --    Refined_Global\n+   --    Refined_Post\n+   --    Test_Case\n+   --  as well as attributes 'Old and 'Result. Find the declaration of the\n+   --  related entry, subprogram or task type [body] subject to pragma Prag.\n+   --  If flag Do_Checks is set, the routine reports duplicate pragmas and\n+   --  detects improper use of refinement pragmas in stand alone expression\n+   --  functions.\n \n    function Get_Argument\n      (Prag       : Node_Id;"}, {"sha": "de8472af9a4f2f8381c2db23436d36a89255c4f4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -11444,6 +11444,28 @@ package body Sem_Util is\n       end if;\n    end Is_Effectively_Volatile_Object;\n \n+   -------------------\n+   -- Is_Entry_Body --\n+   -------------------\n+\n+   function Is_Entry_Body (Id : Entity_Id) return Boolean is\n+   begin\n+      return\n+        Ekind_In (Id, E_Entry, E_Entry_Family)\n+          and then Nkind (Unit_Declaration_Node (Id)) = N_Entry_Body;\n+   end Is_Entry_Body;\n+\n+   --------------------------\n+   -- Is_Entry_Declaration --\n+   --------------------------\n+\n+   function Is_Entry_Declaration (Id : Entity_Id) return Boolean is\n+   begin\n+      return\n+        Ekind_In (Id, E_Entry, E_Entry_Family)\n+          and then Nkind (Unit_Declaration_Node (Id)) = N_Entry_Declaration;\n+   end Is_Entry_Declaration;\n+\n    ----------------------------\n    -- Is_Expression_Function --\n    ----------------------------"}, {"sha": "867aa00dbb0983015b1472c9d2edd25c308bfddd", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f99ff327e1901a374b4fb79b13be067b49c2c2ed/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f99ff327e1901a374b4fb79b13be067b49c2c2ed", "patch": "@@ -1283,6 +1283,12 @@ package Sem_Util is\n    --  Determine whether an arbitrary node denotes an effectively volatile\n    --  object (SPARK RM 7.1.2).\n \n+   function Is_Entry_Body (Id : Entity_Id) return Boolean;\n+   --  Determine whether entity Id is the body entity of an entry [family]\n+\n+   function Is_Entry_Declaration (Id : Entity_Id) return Boolean;\n+   --  Determine whether entity Id is the spec entity of an entry [family]\n+\n    function Is_Expression_Function (Subp : Entity_Id) return Boolean;\n    --  Predicate to determine whether a scope entity comes from a rewritten\n    --  expression function call, and should be inlined unconditionally. Also"}]}