{"sha": "2ac0649d7bf3eacbf92add1ec2b54045c401a4c2", "node_id": "C_kwDOANBUbNoAKDJhYzA2NDlkN2JmM2VhY2JmOTJhZGQxZWMyYjU0MDQ1YzQwMWE0YzI", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-01-16T20:47:09Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-01-17T00:06:28Z"}, "message": "libstdc++: Implement C++20 atomic<shared_ptr> and atomic<weak_ptr>\n\nThis adds another piece of C++20, the std::atomic specializations for\nstd::shared_ptr and std::weak_ptr.\n\nThe new _Sp_atomic type mimics the structure of shared_ptr<T> and\nweak_ptr<T>, holding a T* pointer (the one returned by get() on a\nshared_ptr/weak ptr) and a _Sp_counted_base<>* pointer to the\nref-counted control block. For _Sp_atomic the low bit of the control\nblock pointer is used as a lock bit, to ensure only one thread will\naccess the object at a time.  The pointer is actually stored as a\nuintptr_t to avoid accidental dereferences of the pointer when unlocked\n(which would be a race) or when locked (which would dereference the\nwrong pointer value due to the low bit being set). To get a raw pointer\nto the control block, the lock must be acquired. Converting between a\n_Sp_atomic and a shared_ptr or weak_ptr requires manually adjusting the\nT* and _Sp_counted_base<>* members of the shared/weak ptr, instead of\ngoing through the public API. This must be done carefully to ensure that\nany change in the number of owners is reflected in a ref-count update.\n\nCo-authored-by: Thomas Rodgers <trodgers@redhat.com>\nSigned-off-by: Thomas Rodgers <trodgers@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/shared_ptr_atomic.h (__cpp_lib_atomic_shared_ptr):\n\tNew macro.\n\t(_Sp_atomic): New class template.\n\t(atomic<shared_ptr<T>>, atomic<weak_ptr<T>>): New partial\n\tspecializations.\n\t* include/bits/shared_ptr_base.h (__shared_count, __weak_count)\n\t(__shared_ptr, __weak_ptr): Declare _Sp_atomic as a friend.\n\t* include/std/version (__cpp_lib_atomic_shared_ptr): New macro.\n\t* testsuite/20_util/shared_ptr/atomic/atomic_shared_ptr.cc: New\n\ttest.\n\t* testsuite/20_util/weak_ptr/atomic_weak_ptr.cc: New test.", "tree": {"sha": "c858f264e67f6e875b9a122ebe865ed95bc6f154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c858f264e67f6e875b9a122ebe865ed95bc6f154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86e3b476d5defaa79c94d40b76cbeec21cd02e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86e3b476d5defaa79c94d40b76cbeec21cd02e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86e3b476d5defaa79c94d40b76cbeec21cd02e5f"}], "stats": {"total": 718, "additions": 718, "deletions": 0}, "files": [{"sha": "900499bae32e631a76512bd93ed43f353c161863", "filename": "libstdc++-v3/include/bits/shared_ptr_atomic.h", "status": "modified", "additions": 455, "deletions": 0, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_atomic.h?ref=2ac0649d7bf3eacbf92add1ec2b54045c401a4c2", "patch": "@@ -327,6 +327,461 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n   /// @}\n \n+#if __cplusplus >= 202002L\n+# define __cpp_lib_atomic_shared_ptr 201711L\n+  template<typename _Tp>\n+    class atomic;\n+\n+  template<typename _Up>\n+    static constexpr bool __is_shared_ptr = false;\n+  template<typename _Up>\n+    static constexpr bool __is_shared_ptr<shared_ptr<_Up>> = true;\n+\n+  template<typename _Tp>\n+    class _Sp_atomic\n+    {\n+      using value_type = _Tp;\n+\n+      friend class atomic<_Tp>;\n+\n+      // An atomic version of __shared_count<> and __weak_count<>.\n+      // Stores a _Sp_counted_base<>* but uses the LSB as a lock.\n+      struct _Atomic_count\n+      {\n+\t// Either __shared_count<> or __weak_count<>\n+\tusing __count_type = decltype(_Tp::_M_refcount);\n+\n+\t// _Sp_counted_base<>*\n+\tusing pointer = decltype(__count_type::_M_pi);\n+\n+\t// Ensure we can use the LSB as the lock bit.\n+\tstatic_assert(alignof(remove_pointer_t<pointer>) > 1);\n+\n+\t_Atomic_count() : _M_val(0) { }\n+\n+\texplicit\n+\t_Atomic_count(__count_type&& __c) noexcept\n+\t: _M_val(reinterpret_cast<uintptr_t>(__c._M_pi))\n+\t{\n+\t  __c._M_pi = nullptr;\n+\t}\n+\n+\t~_Atomic_count()\n+\t{\n+\t  auto __val = _M_val.load(memory_order_relaxed);\n+\t  __glibcxx_assert(!(__val & _S_lock_bit));\n+\t  if (auto __pi = reinterpret_cast<pointer>(__val))\n+\t    {\n+\t      if constexpr (__is_shared_ptr<_Tp>)\n+\t\t__pi->_M_release();\n+\t      else\n+\t\t__pi->_M_weak_release();\n+\t    }\n+\t}\n+\n+\t_Atomic_count(const _Atomic_count&) = delete;\n+\t_Atomic_count& operator=(const _Atomic_count&) = delete;\n+\n+\t// Precondition: Caller does not hold lock!\n+\t// Returns the raw pointer value without the lock bit set.\n+\tpointer\n+\tlock(memory_order __o) const noexcept\n+\t{\n+\t  // To acquire the lock we flip the LSB from 0 to 1.\n+\n+\t  auto __current = _M_val.load(memory_order_relaxed);\n+\t  while (__current & _S_lock_bit)\n+\t    {\n+\t      __detail::__thread_relax();\n+\t      __current = _M_val.load(memory_order_relaxed);\n+\t    }\n+\n+\t  while (!_M_val.compare_exchange_strong(__current,\n+\t\t\t\t\t\t __current | _S_lock_bit,\n+\t\t\t\t\t\t __o,\n+\t\t\t\t\t\t memory_order_relaxed))\n+\t    {\n+\t      __detail::__thread_relax();\n+\t      __current = __current & ~_S_lock_bit;\n+\t    }\n+\t  return reinterpret_cast<pointer>(__current);\n+\t}\n+\n+\t// Precondition: caller holds lock!\n+\tvoid\n+\tunlock(memory_order __o) const noexcept\n+\t{\n+\t  _M_val.fetch_sub(1, __o);\n+\t}\n+\n+\t// Swaps the values of *this and __c, and unlocks *this.\n+\t// Precondition: caller holds lock!\n+\tvoid\n+\t_M_swap_unlock(__count_type& __c, memory_order __o) noexcept\n+\t{\n+\t  if (__o != memory_order_seq_cst)\n+\t    __o = memory_order_release;\n+\t  auto __x = reinterpret_cast<uintptr_t>(__c._M_pi);\n+\t  __x = _M_val.exchange(__x, __o);\n+\t  __c._M_pi = reinterpret_cast<pointer>(__x & ~_S_lock_bit);\n+\t}\n+\n+#if __cpp_lib_atomic_wait\n+\t// Precondition: caller holds lock!\n+\tvoid\n+\t_M_wait_unlock(memory_order __o) const noexcept\n+\t{\n+\t  auto __v = _M_val.fetch_sub(1, memory_order_relaxed);\n+\t  _M_val.wait(__v & ~_S_lock_bit, __o);\n+\t}\n+\n+\tvoid\n+\tnotify_one() noexcept\n+\t{\n+\t  _M_val.notify_one();\n+\t}\n+\n+\tvoid\n+\tnotify_all() noexcept\n+\t{\n+\t  _M_val.notify_all();\n+\t}\n+#endif\n+\n+      private:\n+\tmutable __atomic_base<uintptr_t> _M_val{0};\n+\tstatic constexpr uintptr_t _S_lock_bit{1};\n+      };\n+\n+      typename _Tp::element_type* _M_ptr;\n+      _Atomic_count _M_refcount;\n+\n+      static _Atomic_count::pointer\n+      _S_add_ref(_Atomic_count::pointer __p)\n+      {\n+\tif (__p)\n+\t  {\n+\t    if constexpr (__is_shared_ptr<_Tp>)\n+\t      __p->_M_add_ref_copy();\n+\t    else\n+\t      __p->_M_weak_add_ref();\n+\t  }\n+\treturn __p;\n+      }\n+\n+      constexpr _Sp_atomic() noexcept = default;\n+\n+      explicit\n+      _Sp_atomic(value_type __r) noexcept\n+      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))\n+      { }\n+\n+      ~_Sp_atomic() = default;\n+\n+      _Sp_atomic(const _Sp_atomic&) = delete;\n+      void operator=(const _Sp_atomic&) = delete;\n+\n+      value_type\n+      load(memory_order __o) const noexcept\n+      {\n+\t__glibcxx_assert(__o != memory_order_release\n+\t\t\t   && __o != memory_order_acq_rel);\n+\t// Ensure that the correct value of _M_ptr is visible after locking.,\n+\t// by upgrading relaxed or consume to acquire.\n+\tif (__o != memory_order_seq_cst)\n+\t  __o = memory_order_acquire;\n+\n+\tvalue_type __ret;\n+\tauto __pi = _M_refcount.lock(__o);\n+\t__ret._M_ptr = _M_ptr;\n+\t__ret._M_refcount._M_pi = _S_add_ref(__pi);\n+\t_M_refcount.unlock(memory_order_relaxed);\n+\treturn __ret;\n+      }\n+\n+      void\n+      swap(value_type& __r, memory_order __o) noexcept\n+      {\n+\t_M_refcount.lock(memory_order_acquire);\n+\tstd::swap(_M_ptr, __r._M_ptr);\n+\t_M_refcount._M_swap_unlock(__r._M_refcount, __o);\n+      }\n+\n+      bool\n+      compare_exchange_strong(value_type& __expected, value_type __desired,\n+\t\t\t      memory_order __o, memory_order __o2) noexcept\n+      {\n+\tbool __result = true;\n+\tauto __pi = _M_refcount.lock(memory_order_acquire);\n+\tif (_M_ptr == __expected._M_ptr\n+\t      && __pi == __expected._M_refcount._M_pi)\n+\t  {\n+\t    _M_ptr = __desired._M_ptr;\n+\t    _M_refcount._M_swap_unlock(__desired._M_refcount, __o);\n+\t  }\n+\telse\n+\t  {\n+\t    _Tp __sink = std::move(__expected);\n+\t    __expected._M_ptr = _M_ptr;\n+\t    __expected._M_refcount._M_pi = _S_add_ref(__pi);\n+\t    _M_refcount.unlock(__o2);\n+\t    __result = false;\n+\t  }\n+\treturn __result;\n+      }\n+\n+#if __cpp_lib_atomic_wait\n+      void\n+      wait(value_type __old, memory_order __o) const noexcept\n+      {\n+\tauto __pi = _M_refcount.lock(memory_order_acquire);\n+\tif (_M_ptr == __old._M_ptr && __pi == __old._M_refcount._M_pi)\n+\t  _M_refcount._M_wait_unlock(__o);\n+\telse\n+\t  _M_refcount.unlock(memory_order_relaxed);\n+      }\n+\n+      void\n+      notify_one() noexcept\n+      {\n+\t_M_refcount.notify_one();\n+      }\n+\n+      void\n+      notify_all() noexcept\n+      {\n+\t_M_refcount.notify_all();\n+      }\n+#endif\n+    };\n+\n+  template<typename _Tp>\n+    class atomic<shared_ptr<_Tp>>\n+    {\n+    public:\n+      using value_type = shared_ptr<_Tp>;\n+\n+      static constexpr bool is_always_lock_free = false;\n+\n+      bool\n+      is_lock_free() const noexcept\n+      { return false; }\n+\n+      constexpr atomic() noexcept = default;\n+\n+      atomic(shared_ptr<_Tp> __r) noexcept\n+      : _M_impl(std::move(__r))\n+      { }\n+\n+      atomic(const atomic&) = delete;\n+      void operator=(const atomic&) = delete;\n+\n+      shared_ptr<_Tp>\n+      load(memory_order __o = memory_order_seq_cst) const noexcept\n+      { return _M_impl.load(__o); }\n+\n+      operator shared_ptr<_Tp>() const noexcept\n+      { return _M_impl.load(memory_order_seq_cst); }\n+\n+      void\n+      store(shared_ptr<_Tp> __desired,\n+\t    memory_order __o = memory_order_seq_cst) noexcept\n+      { _M_impl.swap(__desired, __o); }\n+\n+      void\n+      operator=(shared_ptr<_Tp> __desired) noexcept\n+      { _M_impl.swap(__desired, memory_order_seq_cst); }\n+\n+      shared_ptr<_Tp>\n+      exchange(shared_ptr<_Tp> __desired,\n+\t       memory_order __o = memory_order_seq_cst) noexcept\n+      {\n+\t_M_impl.swap(__desired, __o);\n+\treturn __desired;\n+      }\n+\n+      bool\n+      compare_exchange_strong(shared_ptr<_Tp>& __expected,\n+\t\t\t      shared_ptr<_Tp> __desired,\n+\t\t\t      memory_order __o, memory_order __o2) noexcept\n+      {\n+\treturn _M_impl.compare_exchange_strong(__expected, __desired, __o, __o2);\n+      }\n+\n+      bool\n+      compare_exchange_strong(value_type& __expected, value_type __desired,\n+\t\t\t      memory_order __o = memory_order_seq_cst) noexcept\n+      {\n+\tmemory_order __o2;\n+\tswitch (__o)\n+\t{\n+\tcase memory_order_acq_rel:\n+\t  __o2 = memory_order_acquire;\n+\t  break;\n+\tcase memory_order_release:\n+\t  __o2 = memory_order_relaxed;\n+\t  break;\n+\tdefault:\n+\t  __o2 = __o;\n+\t}\n+\treturn compare_exchange_strong(__expected, std::move(__desired),\n+\t\t\t\t       __o, __o2);\n+      }\n+\n+      bool\n+      compare_exchange_weak(value_type& __expected, value_type __desired,\n+\t\t\t    memory_order __o, memory_order __o2) noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, std::move(__desired),\n+\t\t\t\t       __o, __o2);\n+      }\n+\n+      bool\n+      compare_exchange_weak(value_type& __expected, value_type __desired,\n+\t\t\t    memory_order __o = memory_order_seq_cst) noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, std::move(__desired), __o);\n+      }\n+\n+#if __cpp_lib_atomic_wait\n+      void\n+      wait(value_type __old,\n+\t   memory_order __o = memory_order_seq_cst) const noexcept\n+      {\n+\t_M_impl.wait(std::move(__old), __o);\n+      }\n+\n+      void\n+      notify_one() noexcept\n+      {\n+\t_M_impl.notify_one();\n+      }\n+\n+      void\n+      notify_all() noexcept\n+      {\n+\t_M_impl.notify_all();\n+      }\n+#endif\n+\n+    private:\n+      _Sp_atomic<shared_ptr<_Tp>> _M_impl;\n+    };\n+\n+  template<typename _Tp>\n+    class atomic<weak_ptr<_Tp>>\n+    {\n+    public:\n+      using value_type = weak_ptr<_Tp>;\n+\n+      static constexpr bool is_always_lock_free = false;\n+\n+      bool\n+      is_lock_free() const noexcept\n+      { return false; }\n+\n+      constexpr atomic() noexcept = default;\n+\n+      atomic(weak_ptr<_Tp> __r) noexcept\n+     : _M_impl(move(__r))\n+      { }\n+\n+      atomic(const atomic&) = delete;\n+      void operator=(const atomic&) = delete;\n+\n+      weak_ptr<_Tp>\n+      load(memory_order __o = memory_order_seq_cst) const noexcept\n+      { return _M_impl.load(__o); }\n+\n+      operator weak_ptr<_Tp>() const noexcept\n+      { return _M_impl.load(memory_order_seq_cst); }\n+\n+      void\n+      store(weak_ptr<_Tp> __desired,\n+\t    memory_order __o = memory_order_seq_cst) noexcept\n+      { _M_impl.swap(__desired, __o); }\n+\n+      void\n+      operator=(weak_ptr<_Tp> __desired) noexcept\n+      { _M_impl.swap(__desired, memory_order_seq_cst); }\n+\n+      weak_ptr<_Tp>\n+      exchange(weak_ptr<_Tp> __desired,\n+\t       memory_order __o = memory_order_seq_cst) noexcept\n+      {\n+\t_M_impl.swap(__desired, __o);\n+\treturn __desired;\n+      }\n+\n+      bool\n+      compare_exchange_strong(weak_ptr<_Tp>& __expected,\n+\t\t\t      weak_ptr<_Tp> __desired,\n+\t\t\t      memory_order __o, memory_order __o2) noexcept\n+      {\n+\treturn _M_impl.compare_exchange_strong(__expected, __desired, __o, __o2);\n+      }\n+\n+      bool\n+      compare_exchange_strong(value_type& __expected, value_type __desired,\n+\t\t\t      memory_order __o = memory_order_seq_cst) noexcept\n+      {\n+\tmemory_order __o2;\n+\tswitch (__o)\n+\t{\n+\tcase memory_order_acq_rel:\n+\t  __o2 = memory_order_acquire;\n+\t  break;\n+\tcase memory_order_release:\n+\t  __o2 = memory_order_relaxed;\n+\t  break;\n+\tdefault:\n+\t  __o2 = __o;\n+\t}\n+\treturn compare_exchange_strong(__expected, std::move(__desired),\n+\t\t\t\t       __o, __o2);\n+      }\n+\n+      bool\n+      compare_exchange_weak(value_type& __expected, value_type __desired,\n+\t\t\t    memory_order __o, memory_order __o2) noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, std::move(__desired),\n+\t\t\t\t       __o, __o2);\n+      }\n+\n+      bool\n+      compare_exchange_weak(value_type& __expected, value_type __desired,\n+\t\t\t    memory_order __o = memory_order_seq_cst) noexcept\n+      {\n+\treturn compare_exchange_strong(__expected, std::move(__desired), __o);\n+      }\n+\n+#if __cpp_lib_atomic_wait\n+      void\n+      wait(value_type __old,\n+\t   memory_order __o = memory_order_seq_cst) const noexcept\n+      {\n+\t_M_impl.wait(std::move(__old), __o);\n+      }\n+\n+      void\n+      notify_one() noexcept\n+      {\n+\t_M_impl.notify_one();\n+      }\n+\n+      void\n+      notify_all() noexcept\n+      {\n+\t_M_impl.notify_all();\n+      }\n+#endif\n+\n+    private:\n+      _Sp_atomic<weak_ptr<_Tp>> _M_impl;\n+    };\n+#endif // C++20\n+\n   /// @} relates shared_ptr\n   /// @} group pointer_abstractions\n "}, {"sha": "5b8f84b65be4d9396ca162421d8ee0761c315311", "filename": "libstdc++-v3/include/bits/shared_ptr_base.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_base.h?ref=2ac0649d7bf3eacbf92add1ec2b54045c401a4c2", "patch": "@@ -409,6 +409,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<_Lock_policy _Lp = __default_lock_policy>\n     class __shared_count;\n \n+#if __cplusplus >= 202002L\n+  template<typename>\n+    class _Sp_atomic;\n+#endif\n \n   // Counted ptr with no deleter or allocator support\n   template<typename _Ptr, _Lock_policy _Lp>\n@@ -1121,6 +1125,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       friend class __weak_count<_Lp>;\n+#if __cplusplus >= 202002L\n+      template<typename> friend class _Sp_atomic;\n+#endif\n \n       _Sp_counted_base<_Lp>*  _M_pi;\n     };\n@@ -1218,6 +1225,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       friend class __shared_count<_Lp>;\n+#if __cplusplus >= 202002L\n+      template<typename> friend class _Sp_atomic;\n+#endif\n \n       _Sp_counted_base<_Lp>*  _M_pi;\n     };\n@@ -1765,6 +1775,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Del, typename _Tp1>\n \tfriend _Del* get_deleter(const shared_ptr<_Tp1>&) noexcept;\n \n+#if __cplusplus >= 202002L\n+      friend _Sp_atomic<shared_ptr<_Tp>>;\n+#endif\n+\n       element_type*\t   _M_ptr;         // Contained pointer.\n       __shared_count<_Lp>  _M_refcount;    // Reference counter.\n     };\n@@ -2097,6 +2111,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n       friend class __enable_shared_from_this<_Tp, _Lp>;\n       friend class enable_shared_from_this<_Tp>;\n+#if __cplusplus >= 202002L\n+      friend _Sp_atomic<weak_ptr<_Tp>>;\n+#endif\n \n       element_type*\t _M_ptr;         // Contained pointer.\n       __weak_count<_Lp>  _M_refcount;    // Reference counter."}, {"sha": "7bd32f67f19fb7cd59dc3b0b1b7277e7dd9e4d66", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=2ac0649d7bf3eacbf92add1ec2b54045c401a4c2", "patch": "@@ -215,6 +215,7 @@\n #if _GLIBCXX_HOSTED\n #define __cpp_lib_array_constexpr 201811L\n #define __cpp_lib_assume_aligned 201811L\n+#define __cpp_lib_atomic_shared_ptr 201711L\n #if defined _GLIBCXX_HAS_GTHREADS || defined _GLIBCXX_HAVE_LINUX_FUTEX\n # define __cpp_lib_atomic_wait 201907L\n # if __cpp_aligned_new"}, {"sha": "725e7ba50314fdd988df2ffeaef83809af66850d", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/atomic/atomic_shared_ptr.cc", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2Fatomic_shared_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2Fatomic_shared_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2Fatomic_shared_ptr.cc?ref=2ac0649d7bf3eacbf92add1ec2b54045c401a4c2", "patch": "@@ -0,0 +1,150 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target gthreads }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+// { dg-add-options libatomic }\n+\n+#include <memory>\n+\n+#ifndef __cpp_lib_atomic_shared_ptr\n+# error \"Feature-test macro for atomic<shared_ptr<T>> missing in <memory>\"\n+#elif __cpp_lib_atomic_shared_ptr != 201711L\n+# error \"Feature-test macro for atomic<shared_ptr<T>> has wrong value in <memory>\"\n+#endif\n+\n+#include <thread>\n+\n+#include <testsuite_hooks.h>\n+\n+void\n+test_is_lock_free()\n+{\n+  using test_type = std::atomic<std::shared_ptr<int>>;\n+  static_assert( test_type::is_always_lock_free == false );\n+\n+  test_type p;\n+  VERIFY( p.is_lock_free() == false );\n+}\n+\n+void\n+test_atomic_shared_ptr()\n+{\n+  struct A { int a; int b; };\n+\n+  auto a = std::make_shared<A>( 0, 42 );\n+  using ptr_t = std::shared_ptr<A>;\n+  {\n+    std::atomic<ptr_t> p{ };\n+    VERIFY( p.load().get() == nullptr );\n+  }\n+\n+  std::atomic<ptr_t> p{ a };\n+  VERIFY( p.load().get() == a.get() );\n+  auto b = std::make_shared<A>( 42, 0 );\n+  p.store(b);\n+  VERIFY( p.load().get() != a.get() );\n+  VERIFY( p.load().get() == b.get() );\n+  p.exchange(a);\n+  VERIFY( p.load().get() != b.get() );\n+  VERIFY( p.load().get() == a.get() );\n+\n+  {\n+    ptr_t aa{ a };\n+    VERIFY( p.compare_exchange_strong(aa, b,\n+\t\t\t\t      std::memory_order_seq_cst,\n+\t\t\t\t      std::memory_order_seq_cst) == true );\n+    ptr_t bb{ a };\n+    VERIFY( p.compare_exchange_strong(bb, b,\n+\t\t\t\t      std::memory_order_seq_cst,\n+\t\t\t\t      std::memory_order_seq_cst) == false );\n+    VERIFY( bb.get() == b.get() );\n+  }\n+\n+  {\n+    ptr_t bb{ b };\n+    VERIFY( p.compare_exchange_weak(bb, a,\n+\t\t\t\t    std::memory_order_seq_cst,\n+\t\t\t\t    std::memory_order_seq_cst) == true );\n+    ptr_t aa{ b };\n+    VERIFY( p.compare_exchange_weak(aa, a,\n+\t\t\t\t      std::memory_order_seq_cst,\n+\t\t\t\t      std::memory_order_seq_cst) == false );\n+    VERIFY( aa.get() == a.get() );\n+  }\n+}\n+\n+void\n+test_wait_notify()\n+{\n+  std::atomic<std::shared_ptr<int>> p;\n+  std::shared_ptr<int> a = std::make_shared<int>();\n+  std::shared_ptr<int> b = std::make_shared<int>();\n+\n+  p.store(a);\n+  p.wait(b);\n+  std::thread t([&]\n+      {\n+\tp.store(b);\n+\tp.notify_one();\n+      });\n+  p.wait(a);\n+  t.join();\n+}\n+\n+int counter = 0;\n+\n+void\n+test_counting()\n+{\n+  struct X\n+  {\n+    ~X() { ++counter; }\n+  };\n+\n+  {\n+    std::atomic<std::shared_ptr<X>> p{ std::make_shared<X>() };\n+    std::shared_ptr<X> a = p.load();\n+    VERIFY( a.use_count() == 2 ); // p, a\n+    p.store({});\n+    VERIFY( a.use_count() == 1 ); // a\n+    p.store(a);\n+    VERIFY( a.use_count() == 2 ); // p, a\n+    std::shared_ptr<X> b = std::make_shared<X>();\n+    std::shared_ptr<X> c = p.exchange(b);\n+    VERIFY( a.use_count() == 2 ); // a, c\n+    VERIFY( c == a );\n+    VERIFY( b.use_count() == 2 ); // p, b\n+    std::atomic<std::shared_ptr<X>> p2{a};\n+    VERIFY( a.use_count() == 3 ); // p2, a, c\n+    VERIFY( p2.compare_exchange_strong(a, b) );\n+    VERIFY( a.use_count() == 2 ); // a, c\n+    VERIFY( b.use_count() == 3 ); // p, p2, b\n+    VERIFY ( ! p2.compare_exchange_strong(a, b) );\n+    VERIFY( a == b );\n+    VERIFY( a.use_count() == 4 ); // p, p2, a, b\n+    VERIFY( b.use_count() == 4 );\n+    VERIFY( c.use_count() == 1 ); // c\n+    VERIFY( p.compare_exchange_weak(b, c) );\n+    VERIFY( b.use_count() == 3 ); // p2, a, b\n+    VERIFY( c.use_count() == 2 ); // p, c\n+    VERIFY( ! p.compare_exchange_weak(a, b) );\n+    VERIFY( a == c );\n+    VERIFY( a.use_count() == 3 ); // p, a, c\n+    VERIFY( b.use_count() == 2 ); // p2, b\n+    VERIFY( c.use_count() == 3 ); // p, a, c\n+    a.reset();\n+    b.reset();\n+    c.reset();\n+    VERIFY( counter == 0 );\n+  }\n+  VERIFY( counter == 2 );\n+}\n+\n+int\n+main()\n+{\n+  test_is_lock_free();\n+  test_atomic_shared_ptr();\n+  test_wait_notify();\n+  test_counting();\n+}"}, {"sha": "e394e5562b918c850e5fea818c5772451f8c7ef1", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/atomic_weak_ptr.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fatomic_weak_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac0649d7bf3eacbf92add1ec2b54045c401a4c2/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fatomic_weak_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fatomic_weak_ptr.cc?ref=2ac0649d7bf3eacbf92add1ec2b54045c401a4c2", "patch": "@@ -0,0 +1,95 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target gthreads }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+// { dg-add-options libatomic }\n+\n+#include <memory>\n+#include <thread>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_is_lock_free()\n+{\n+  using test_type = std::atomic<std::weak_ptr<int>>;\n+  static_assert( test_type::is_always_lock_free == false );\n+\n+  test_type p;\n+  VERIFY( p.is_lock_free() == false );\n+}\n+\n+void\n+test_atomic_weak_ptr()\n+{\n+  struct A { int a; int b; };\n+\n+  auto a = std::make_shared<A>( 0, 42 );\n+  using ptr_t = std::weak_ptr<A>;\n+  ptr_t wa{ a };\n+  {\n+    std::atomic<ptr_t> p{ };\n+    VERIFY( p.load().lock().get() == nullptr );\n+  }\n+\n+  std::atomic<ptr_t> p{ wa };\n+  VERIFY( p.load().lock().get() == a.get() );\n+\n+  auto b = std::make_shared<A>( 42, 0 );\n+  ptr_t wb{ b };\n+  p.store(wb);\n+  VERIFY( p.load().lock().get() != a.get() );\n+  VERIFY( p.load().lock().get() == b.get() );\n+  p.exchange(wa);\n+  VERIFY( p.load().lock().get() != b.get() );\n+  VERIFY( p.load().lock().get() == a.get() );\n+\n+  {\n+    ptr_t aa{ a };\n+    VERIFY( p.compare_exchange_strong(aa, b,\n+\t\t\t\t      std::memory_order_seq_cst,\n+\t\t\t\t      std::memory_order_seq_cst) == true );\n+    ptr_t bb{ a };\n+    VERIFY( p.compare_exchange_strong(bb, b,\n+\t\t\t\t\tstd::memory_order_seq_cst,\n+\t\t\t\t\tstd::memory_order_seq_cst) == false );\n+    VERIFY( bb.lock().get() == b.get() );\n+  }\n+\n+  {\n+    ptr_t bb{ b };\n+    VERIFY( p.compare_exchange_weak(bb, a,\n+\t\t\t\t    std::memory_order_seq_cst,\n+\t\t\t\t    std::memory_order_seq_cst) == true );\n+    ptr_t aa{ b };\n+    VERIFY( p.compare_exchange_weak(aa, a,\n+\t\t\t\t    std::memory_order_seq_cst,\n+\t\t\t\t    std::memory_order_seq_cst) == false );\n+    VERIFY( aa.lock().get() == a.get() );\n+  }\n+}\n+\n+void\n+test_wait_notify()\n+{\n+  std::atomic<std::weak_ptr<int>> p;\n+  std::weak_ptr<int> a = std::make_shared<int>();\n+  std::weak_ptr<int> b = std::make_shared<int>();\n+\n+  p.store(a);\n+  p.wait(b);\n+  std::thread t([&]\n+      {\n+\tp.store(b);\n+\tp.notify_one();\n+      });\n+  p.wait(a);\n+  t.join();\n+}\n+\n+int\n+main()\n+{\n+  test_is_lock_free();\n+  test_atomic_weak_ptr();\n+  test_wait_notify();\n+}"}]}