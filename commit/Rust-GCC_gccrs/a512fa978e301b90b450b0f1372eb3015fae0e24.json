{"sha": "a512fa978e301b90b450b0f1372eb3015fae0e24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUxMmZhOTc4ZTMwMWI5MGI0NTBiMGYxMzcyZWIzMDE1ZmFlMGUyNA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "2000-02-16T00:59:17Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2000-02-16T00:59:17Z"}, "message": "sh.md (udivsi3_i1, [...]): Name.\n\n\t* sh.md (udivsi3_i1, divsi3_i1, umulhisi3_i, mulhisi3_i): Name.\n\t(smulsi3_highpart_i): Name.\n\t(udivsi3): Wrap emitted insns in REG_LIBCALL / REG_RETVAL notes.\n\t(divsi3, mulhisi3, umulhisi3, mulsidi3, umulsidi3): Likewise.\n\t(smulsi3_highpart, umulsi3_highpart): Likewise.\n\n\t(mulsidi3_i, umulsidi3_i): Make rtl describe operation\n\tcorrectly independent of endianness.\n\t(mulsidi3, umulsidi3): Now define_insn.  Hide details that\n\tconfuse the optimizers.\n\t(mulsidi3+1, umulsidi3+1): New define_split.\n\nFrom-SVN: r31997", "tree": {"sha": "d0e1afd85805618db1aa4741db829f2fb65e7afd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0e1afd85805618db1aa4741db829f2fb65e7afd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a512fa978e301b90b450b0f1372eb3015fae0e24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a512fa978e301b90b450b0f1372eb3015fae0e24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a512fa978e301b90b450b0f1372eb3015fae0e24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a512fa978e301b90b450b0f1372eb3015fae0e24/comments", "author": null, "committer": null, "parents": [{"sha": "73d7c68909ac0094a2ab30f1f8dad3eac59c36ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73d7c68909ac0094a2ab30f1f8dad3eac59c36ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73d7c68909ac0094a2ab30f1f8dad3eac59c36ac"}], "stats": {"total": 227, "additions": 165, "deletions": 62}, "files": [{"sha": "a9ad4340a22312f9c02fe9e2dcc0aa3342d23de8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a512fa978e301b90b450b0f1372eb3015fae0e24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a512fa978e301b90b450b0f1372eb3015fae0e24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a512fa978e301b90b450b0f1372eb3015fae0e24", "patch": "@@ -1,3 +1,17 @@\n+Wed Feb 16 00:58:06 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* sh.md (udivsi3_i1, divsi3_i1, umulhisi3_i, mulhisi3_i): Name.\n+\t(smulsi3_highpart_i): Name.\n+\t(udivsi3): Wrap emitted insns in REG_LIBCALL / REG_RETVAL notes.\n+\t(divsi3, mulhisi3, umulhisi3, mulsidi3, umulsidi3): Likewise.\n+\t(smulsi3_highpart, umulsi3_highpart): Likewise.\n+\n+\t(mulsidi3_i, umulsidi3_i): Make rtl describe operation\n+\tcorrectly independent of endianness.\n+\t(mulsidi3, umulsidi3): Now define_insn.  Hide details that\n+\tconfuse the optimizers.\n+\t(mulsidi3+1, umulsidi3+1): New define_split.\n+\n Tue Feb 15 23:22:26 2000  Andrew Haley  <aph@cygnus.com>\n \n \t* config/sh/sh.md: Guard insn splits against illegal registers."}, {"sha": "3a662cd565525baec47fb7de99909719fbe2679d", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 151, "deletions": 62, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a512fa978e301b90b450b0f1372eb3015fae0e24/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a512fa978e301b90b450b0f1372eb3015fae0e24/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=a512fa978e301b90b450b0f1372eb3015fae0e24", "patch": "@@ -868,7 +868,7 @@\n ;; This reload would clobber the value in r0 we are trying to store.\n ;; If we let reload allocate r0, then this problem can never happen.\n \n-(define_insn \"\"\n+(define_insn \"udivsi3_i1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n \t(udiv:SI (reg:SI 4) (reg:SI 5)))\n    (clobber (reg:SI 18))\n@@ -917,9 +917,9 @@\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_expand \"udivsi3\"\n-  [(set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"\"))\n+  [(set (match_dup 3) (symbol_ref:SI \"__udivsi3\"))\n+   (set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"\"))\n    (set (reg:SI 5) (match_operand:SI 2 \"general_operand\" \"\"))\n-   (set (match_dup 3) (symbol_ref:SI \"__udivsi3\"))\n    (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (udiv:SI (reg:SI 4)\n \t\t\t    (reg:SI 5)))\n@@ -930,22 +930,36 @@\n   \"\"\n   \"\n {\n+  rtx first, last;\n+\n   operands[3] = gen_reg_rtx(SImode);\n+  /* Emit the move of the address to a pseudo outside of the libcall.  */\n   if (TARGET_HARD_SH4)\n     {\n-      emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n-      emit_move_insn (gen_rtx (REG, SImode, 5), operands[2]);\n       emit_move_insn (operands[3],\n \t\t      gen_rtx_SYMBOL_REF (SImode, \\\"__udivsi3_i4\\\"));\n       if (TARGET_FPU_SINGLE)\n-\temit_insn (gen_udivsi3_i4_single (operands[0], operands[3]));\n+\tlast = gen_udivsi3_i4_single (operands[0], operands[3]);\n       else\n-\temit_insn (gen_udivsi3_i4 (operands[0], operands[3]));\n-      DONE;\n+\tlast = gen_udivsi3_i4 (operands[0], operands[3]);\n+    }\n+  else\n+    {\n+      emit_move_insn (operands[3],\n+\t\t      gen_rtx_SYMBOL_REF (SImode, \\\"__udivsi3\\\"));\n+      last = gen_udivsi3_i1 (operands[0], operands[3]);\n     }\n+  first = emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);\n+  emit_move_insn (gen_rtx_REG (SImode, 5), operands[2]);\n+  last = emit_insn (last);\n+  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n+     invariant code motion can move it.  */\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  DONE;\n }\")\n \n-(define_insn \"\"\n+(define_insn \"divsi3_i1\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n \t(div:SI (reg:SI 4) (reg:SI 5)))\n    (clobber (reg:SI 18))\n@@ -987,9 +1001,9 @@\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_expand \"divsi3\"\n-  [(set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"\"))\n+  [(set (match_dup 3) (symbol_ref:SI \"__sdivsi3\"))\n+   (set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"\"))\n    (set (reg:SI 5) (match_operand:SI 2 \"general_operand\" \"\"))\n-   (set (match_dup 3) (symbol_ref:SI \"__sdivsi3\"))\n    (parallel [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t   (div:SI (reg:SI 4)\n \t\t\t   (reg:SI 5)))\n@@ -1002,34 +1016,47 @@\n   \"\"\n   \"\n {\n+  rtx first, last;\n+\n   operands[3] = gen_reg_rtx(SImode);\n+  /* Emit the move of the address to a pseudo outside of the libcall.  */\n   if (TARGET_HARD_SH4)\n     {\n-      emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n-      emit_move_insn (gen_rtx (REG, SImode, 5), operands[2]);\n       emit_move_insn (operands[3],\n \t\t      gen_rtx_SYMBOL_REF (SImode, \\\"__sdivsi3_i4\\\"));\n       if (TARGET_FPU_SINGLE)\n-\temit_insn (gen_divsi3_i4_single (operands[0], operands[3]));\n+\tlast = gen_divsi3_i4_single (operands[0], operands[3]);\n       else\n-\temit_insn (gen_divsi3_i4 (operands[0], operands[3]));\n-      DONE;\n+\tlast = gen_divsi3_i4 (operands[0], operands[3]);\n     }\n+  else\n+    {\n+      emit_move_insn (operands[3], gen_rtx_SYMBOL_REF (SImode, \\\"__sdivsi3\\\"));\n+      last = gen_divsi3_i1 (operands[0], operands[3]);\n+    }\n+  first = emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);\n+  emit_move_insn (gen_rtx_REG (SImode, 5), operands[2]);\n+  last = emit_insn (last);\n+  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n+     invariant code motion can move it.  */\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  DONE;\n }\")\n \f\n ;; -------------------------------------------------------------------------\n ;; Multiplication instructions\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"\"\n+(define_insn \"umulhisi3_i\"\n   [(set (reg:SI 21)\n \t(mult:SI (zero_extend:SI (match_operand:HI 0 \"arith_reg_operand\" \"r\"))\n \t\t (zero_extend:SI (match_operand:HI 1 \"arith_reg_operand\" \"r\"))))]\n   \"\"\n   \"mulu\t%1,%0\"\n   [(set_attr \"type\" \"smpy\")])\n \n-(define_insn \"\"\n+(define_insn \"mulhisi3_i\"\n   [(set (reg:SI 21)\n \t(mult:SI (sign_extend:SI\n \t\t  (match_operand:HI 0 \"arith_reg_operand\" \"r\"))\n@@ -1048,7 +1075,18 @@\n    (set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(reg:SI 21))]\n   \"\"\n-  \"\")\n+  \"\n+{\n+  rtx first, last;\n+\n+  first = emit_insn (gen_mulhisi3_i (operands[1], operands[2]));\n+  last = emit_move_insn (operands[0], gen_rtx_REG (SImode, 21));\n+  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n+     invariant code motion can move it.  */\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  DONE;\n+}\")\n \n (define_expand \"umulhisi3\"\n   [(set (reg:SI 21)\n@@ -1059,7 +1097,18 @@\n    (set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(reg:SI 21))]\n   \"\"\n-  \"\")\n+  \"\n+{\n+  rtx first, last;\n+\n+  first = emit_insn (gen_umulhisi3_i (operands[1], operands[2]));\n+  last = emit_move_insn (operands[0], gen_rtx_REG (SImode, 21));\n+  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n+     invariant code motion can move it.  */\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  DONE;\n+}\")\n \n ;; mulsi3 on the SH2 can be done in one instruction, on the SH1 we generate\n ;; a call to a routine which clobbers known registers.\n@@ -1142,72 +1191,90 @@\n }\")\n \n (define_insn \"mulsidi3_i\"\n-  [(set (reg:DI 20)\n-\t(mult:DI (sign_extend:DI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n-\t\t (sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))]\n+  [(set (reg:SI 20)\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t\t\t       (sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n+\t\t      (const_int 32))))\n+   (set (reg:SI 21)\n+\t(mult:SI (match_dup 0)\n+\t\t (match_dup 1)))]\n   \"TARGET_SH2\"\n   \"dmuls.l\t%1,%0\"\n   [(set_attr \"type\" \"dmpy\")])\n \n-(define_expand \"mulsidi3\"\n-  [(set (reg:DI 20)\n+(define_insn \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n+\t(mult:DI (sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t\t (sign_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n+   (clobber (reg:DI 20))]\n+  \"TARGET_SH2\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n \t(mult:DI (sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n \t\t (sign_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"\"))))\n-   (set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n-\t(reg:DI 20))]\n+   (clobber (reg:DI 20))]\n   \"TARGET_SH2\"\n+  [(const_int 0)]\n   \"\n {\n-  /* We must swap the two words when copying them from MACH/MACL to the\n-     output register.  */\n-  if (TARGET_LITTLE_ENDIAN)\n-    {\n-      rtx low_dst = operand_subword (operands[0], 0, 1, DImode);\n-      rtx high_dst = operand_subword (operands[0], 1, 1, DImode);\n+  rtx low_dst = gen_lowpart (SImode, operands[0]);\n+  rtx high_dst = gen_highpart (SImode, operands[0]);\n \n-      emit_insn (gen_mulsidi3_i (operands[1], operands[2]));\n+  emit_insn (gen_mulsidi3_i (operands[1], operands[2]));\n \n-      emit_insn (gen_rtx_CLOBBER (VOIDmode, operands[0]));\n-      emit_move_insn (low_dst, gen_rtx_REG (SImode, 21));\n-      emit_move_insn (high_dst, gen_rtx_REG (SImode, 20));\n-      DONE;\n-    }\n+  emit_move_insn (low_dst, gen_rtx_REG (SImode, 21));\n+  emit_move_insn (high_dst, gen_rtx_REG (SImode, 20));\n+  /* We need something to tag the possible REG_EQUAL notes on to.  */\n+  emit_move_insn (operands[0], operands[0]);\n+  DONE;\n }\")\n \n (define_insn \"umulsidi3_i\"\n-  [(set (reg:DI 20)\n-\t(mult:DI (zero_extend:DI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n-\t\t (zero_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))]\n+  [(set (reg:SI 20)\n+\t(truncate:SI\n+\t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t\t\t       (zero_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n+\t\t      (const_int 32))))\n+   (set (reg:SI 21)\n+\t(mult:SI (match_dup 0)\n+\t\t (match_dup 1)))]\n   \"TARGET_SH2\"\n   \"dmulu.l\t%1,%0\"\n   [(set_attr \"type\" \"dmpy\")])\n \n-(define_expand \"umulsidi3\"\n-  [(set (reg:DI 20)\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"=r\")\n+\t(mult:DI (zero_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t\t (zero_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))\n+   (clobber (reg:DI 20))]\n+  \"TARGET_SH2\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n \t(mult:DI (zero_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"\"))\n \t\t (zero_extend:DI (match_operand:SI 2 \"arith_reg_operand\" \"\"))))\n-   (set (match_operand:DI 0 \"arith_reg_operand\" \"\")\n-\t(reg:DI 20))]\n+   (clobber (reg:DI 20))]\n   \"TARGET_SH2\"\n+  [(const_int 0)]\n   \"\n {\n-  /* We must swap the two words when copying them from MACH/MACL to the\n-     output register.  */\n-  if (TARGET_LITTLE_ENDIAN)\n-    {\n-      rtx low_dst = operand_subword (operands[0], 0, 1, DImode);\n-      rtx high_dst = operand_subword (operands[0], 1, 1, DImode);\n+  rtx low_dst = gen_lowpart (SImode, operands[0]);\n+  rtx high_dst = gen_highpart (SImode, operands[0]);\n \n-      emit_insn (gen_umulsidi3_i (operands[1], operands[2]));\n+  emit_insn (gen_umulsidi3_i (operands[1], operands[2]));\n \n-      emit_insn (gen_rtx_CLOBBER (VOIDmode, operands[0]));\n-      emit_move_insn (low_dst, gen_rtx_REG (SImode, 21));\n-      emit_move_insn (high_dst, gen_rtx_REG (SImode, 20));\n-      DONE;\n-    }\n+  emit_move_insn (low_dst, gen_rtx_REG (SImode, 21));\n+  emit_move_insn (high_dst, gen_rtx_REG (SImode, 20));\n+  /* We need something to tag the possible REG_EQUAL notes on to.  */\n+  emit_move_insn (operands[0], operands[0]);\n+  DONE;\n }\")\n \n-(define_insn \"\"\n+(define_insn \"smulsi3_highpart_i\"\n   [(set (reg:SI 20)\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n@@ -1228,9 +1295,20 @@\n    (set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(reg:SI 20))]\n   \"TARGET_SH2\"\n-  \"\")\n+  \"\n+{\n+  rtx first, last;\n \n-(define_insn \"\"\n+  first = emit_insn (gen_smulsi3_highpart_i (operands[1], operands[2]));\n+  last = emit_move_insn (operands[0], gen_rtx_REG (SImode, 20));\n+  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n+     invariant code motion can move it.  */\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  DONE;\n+}\")\n+\n+(define_insn \"umulsi3_highpart_i\"\n   [(set (reg:SI 20)\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (zero_extend:DI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n@@ -1251,7 +1329,18 @@\n    (set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(reg:SI 20))]\n   \"TARGET_SH2\"\n-  \"\")\n+  \"\n+{\n+  rtx first, last;\n+\n+  first = emit_insn (gen_umulsi3_highpart_i (operands[1], operands[2]));\n+  last = emit_move_insn (operands[0], gen_rtx_REG (SImode, 20));\n+  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n+     invariant code motion can move it.  */\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  DONE;\n+}\")\n \f\n ;; -------------------------------------------------------------------------\n ;; Logical operations"}]}