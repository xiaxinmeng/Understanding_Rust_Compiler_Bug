{"sha": "facb23dc4ec9ced099de4b5a7a147ab8b972fa23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFjYjIzZGM0ZWM5Y2VkMDk5ZGU0YjVhN2ExNDdhYjhiOTcyZmEyMw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-01-23T21:56:54Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2013-01-23T21:56:54Z"}, "message": "Improve performance of byte-swapped I/O.\n\n2013-01-23  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* io/file_pos.c (unformatted_backspace): Use __builtin_bswapXX\n\tinstead of reverse_memcpy.\n\t* io/io.h (reverse_memcpy): Remove prototype.\n\t* io/transfer.c (reverse_memcpy): Make static, move towards\n\tbeginning of file.\n\t(bswap_array): New function.\n\t(unformatted_read): Use bswap_array to byte swap the data\n\tin-place.\n\t(unformatted_write): Use a larger temp buffer and bswap_array.\n\t(us_read): Use __builtin_bswapXX instead of reverse_memcpy.\n\t(write_us_marker): Likewise.\n\nFrom-SVN: r195413", "tree": {"sha": "f0cd204c1489f4588e613e65677efe4e43b3c72e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0cd204c1489f4588e613e65677efe4e43b3c72e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/facb23dc4ec9ced099de4b5a7a147ab8b972fa23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/facb23dc4ec9ced099de4b5a7a147ab8b972fa23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/facb23dc4ec9ced099de4b5a7a147ab8b972fa23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/facb23dc4ec9ced099de4b5a7a147ab8b972fa23/comments", "author": null, "committer": null, "parents": [{"sha": "ad3e2ad2ffc774435804519077ca46d15410c928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad3e2ad2ffc774435804519077ca46d15410c928", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad3e2ad2ffc774435804519077ca46d15410c928"}], "stats": {"total": 246, "additions": 178, "deletions": 68}, "files": [{"sha": "d4ccff4f2a6b13bc70036fb27f06224ed93ce747", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facb23dc4ec9ced099de4b5a7a147ab8b972fa23/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facb23dc4ec9ced099de4b5a7a147ab8b972fa23/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=facb23dc4ec9ced099de4b5a7a147ab8b972fa23", "patch": "@@ -1,3 +1,17 @@\n+2013-01-23  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* io/file_pos.c (unformatted_backspace): Use __builtin_bswapXX\n+\tinstead of reverse_memcpy.\n+\t* io/io.h (reverse_memcpy): Remove prototype.\n+\t* io/transfer.c (reverse_memcpy): Make static, move towards\n+\tbeginning of file.\n+\t(bswap_array): New function.\n+\t(unformatted_read): Use bswap_array to byte swap the data\n+\tin-place.\n+\t(unformatted_write): Use a larger temp buffer and bswap_array.\n+\t(us_read): Use __builtin_bswapXX instead of reverse_memcpy.\n+\t(write_us_marker): Likewise.\n+\n 2013-01-14  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tUpdate copyright years."}, {"sha": "8b4fda3dd91bf5959eabc8c5370ef8c4190b991a", "filename": "libgfortran/io/file_pos.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facb23dc4ec9ced099de4b5a7a147ab8b972fa23/libgfortran%2Fio%2Ffile_pos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facb23dc4ec9ced099de4b5a7a147ab8b972fa23/libgfortran%2Fio%2Ffile_pos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ffile_pos.c?ref=facb23dc4ec9ced099de4b5a7a147ab8b972fa23", "patch": "@@ -139,15 +139,21 @@ unformatted_backspace (st_parameter_filepos *fpp, gfc_unit *u)\n \t}\n       else\n \t{\n+\t  uint32_t u32;\n+\t  uint64_t u64;\n \t  switch (length)\n \t    {\n \t    case sizeof(GFC_INTEGER_4):\n-\t      reverse_memcpy (&m4, p, sizeof (m4));\n+\t      memcpy (&u32, p, sizeof (u32));\n+\t      u32 = __builtin_bswap32 (u32);\n+\t      memcpy (&m4, &u32, sizeof (m4));\n \t      m = m4;\n \t      break;\n \n \t    case sizeof(GFC_INTEGER_8):\n-\t      reverse_memcpy (&m8, p, sizeof (m8));\n+\t      memcpy (&u64, p, sizeof (u64));\n+\t      u64 = __builtin_bswap64 (u64);\n+\t      memcpy (&m8, &u64, sizeof (m8));\n \t      m = m8;\n \t      break;\n "}, {"sha": "8ea9326670b5aaeb24f24b5f34f39daca4c61f1f", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facb23dc4ec9ced099de4b5a7a147ab8b972fa23/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facb23dc4ec9ced099de4b5a7a147ab8b972fa23/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=facb23dc4ec9ced099de4b5a7a147ab8b972fa23", "patch": "@@ -647,9 +647,6 @@ internal_proto(init_loop_spec);\n extern void next_record (st_parameter_dt *, int);\n internal_proto(next_record);\n \n-extern void reverse_memcpy (void *, const void *, size_t);\n-internal_proto (reverse_memcpy);\n-\n extern void st_wait (st_parameter_wait *);\n export_proto(st_wait);\n "}, {"sha": "515c34f378eda2c1cb35bfe78b42442fd1a9e22e", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 156, "deletions": 63, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/facb23dc4ec9ced099de4b5a7a147ab8b972fa23/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/facb23dc4ec9ced099de4b5a7a147ab8b972fa23/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=facb23dc4ec9ced099de4b5a7a147ab8b972fa23", "patch": "@@ -877,50 +877,138 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n }\n \n \n-/* Master function for unformatted reads.  */\n+/* Reverse memcpy - used for byte swapping.  */\n \n static void\n-unformatted_read (st_parameter_dt *dtp, bt type,\n-\t\t  void *dest, int kind, size_t size, size_t nelems)\n+reverse_memcpy (void *dest, const void *src, size_t n)\n {\n-  if (likely (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_NATIVE)\n-      || kind == 1)\n+  char *d, *s;\n+  size_t i;\n+\n+  d = (char *) dest;\n+  s = (char *) src + n - 1;\n+\n+  /* Write with ascending order - this is likely faster\n+     on modern architectures because of write combining.  */\n+  for (i=0; i<n; i++)\n+      *(d++) = *(s--);\n+}\n+\n+\n+/* Utility function for byteswapping an array, using the bswap\n+   builtins if possible. dest and src can overlap completely, or then\n+   they must point to separate objects; partial overlaps are not\n+   allowed.  */\n+\n+static void\n+bswap_array (void *dest, const void *src, size_t size, size_t nelems)\n+{\n+  const char *ps; \n+  char *pd;\n+\n+  switch (size)\n     {\n-      if (type == BT_CHARACTER)\n-\tsize *= GFC_SIZE_OF_CHAR_KIND(kind);\n-      read_block_direct (dtp, dest, size * nelems);\n+    case 1:\n+      break;\n+    case 2:\n+      for (size_t i = 0; i < nelems; i++)\n+\t((uint16_t*)dest)[i] = __builtin_bswap16 (((uint16_t*)src)[i]);\n+      break;\n+    case 4:\n+      for (size_t i = 0; i < nelems; i++)\n+\t((uint32_t*)dest)[i] = __builtin_bswap32 (((uint32_t*)src)[i]);\n+      break;\n+    case 8:\n+      for (size_t i = 0; i < nelems; i++)\n+\t((uint64_t*)dest)[i] = __builtin_bswap64 (((uint64_t*)src)[i]);\n+      break;\n+    case 12:\n+      ps = src;\n+      pd = dest;\n+      for (size_t i = 0; i < nelems; i++)\n+\t{\n+\t  uint32_t tmp;\n+\t  memcpy (&tmp, ps, 4);\n+\t  *(uint32_t*)pd = __builtin_bswap32 (*(uint32_t*)(ps + 8));\n+\t  *(uint32_t*)(pd + 4) = __builtin_bswap32 (*(uint32_t*)(ps + 4));\n+\t  *(uint32_t*)(pd + 8) = __builtin_bswap32 (tmp);\n+\t  ps += size;\n+\t  pd += size;\n+\t}\n+      break;\n+    case 16:\n+      ps = src;\n+      pd = dest;\n+      for (size_t i = 0; i < nelems; i++)\n+\t{\n+\t  uint64_t tmp;\n+\t  memcpy (&tmp, ps, 8);\n+\t  *(uint64_t*)pd = __builtin_bswap64 (*(uint64_t*)(ps + 8));\n+\t  *(uint64_t*)(pd + 8) = __builtin_bswap64 (tmp);\n+\t  ps += size;\n+\t  pd += size;\n+\t}\n+      break;\n+    default:\n+      pd = dest;\n+      if (dest != src)\n+\t{\n+\t  ps = src;\n+\t  for (size_t i = 0; i < nelems; i++)\n+\t    {\n+\t      reverse_memcpy (pd, ps, size);\n+\t      ps += size;\n+\t      pd += size;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* In-place byte swap.  */\n+\t  for (size_t i = 0; i < nelems; i++)\n+\t    {\n+\t      char tmp, *low = pd, *high = pd + size - 1;\n+\t      for (size_t j = 0; j < size/2; j++)\n+\t\t{\n+\t\t  tmp = *low;\n+\t\t  *low = *high;\n+\t\t  *high = tmp;\n+\t\t  low++;\n+\t\t  high--;\n+\t\t}\n+\t      pd += size;\n+\t    }\n+\t}\n     }\n-  else\n-    {\n-      char buffer[16];\n-      char *p;\n-      size_t i;\n+}\n+\n \n-      p = dest;\n+/* Master function for unformatted reads.  */\n+\n+static void\n+unformatted_read (st_parameter_dt *dtp, bt type,\n+\t\t  void *dest, int kind, size_t size, size_t nelems)\n+{\n+  if (type == BT_CHARACTER)\n+    size *= GFC_SIZE_OF_CHAR_KIND(kind);\n+  read_block_direct (dtp, dest, size * nelems);\n \n+  if (unlikely (dtp->u.p.current_unit->flags.convert == GFC_CONVERT_SWAP)\n+      && kind != 1)\n+    {\n       /* Handle wide chracters.  */\n-      if (type == BT_CHARACTER && kind != 1)\n-\t{\n-\t  nelems *= size;\n-\t  size = kind;\n-\t}\n+      if (type == BT_CHARACTER)\n+  \t{\n+  \t  nelems *= size;\n+  \t  size = kind;\n+  \t}\n \n       /* Break up complex into its constituent reals.  */\n-      if (type == BT_COMPLEX)\n-\t{\n-\t  nelems *= 2;\n-\t  size /= 2;\n-\t}\n-      \n-      /* By now, all complex variables have been split into their\n-\t constituent reals.  */\n-      \n-      for (i = 0; i < nelems; i++)\n-\t{\n- \t  read_block_direct (dtp, buffer, size);\n- \t  reverse_memcpy (p, buffer, size);\n- \t  p += size;\n- \t}\n+      else if (type == BT_COMPLEX)\n+  \t{\n+  \t  nelems *= 2;\n+  \t  size /= 2;\n+  \t}\n+      bswap_array (dest, dest, size, nelems);\n     }\n }\n \n@@ -944,9 +1032,10 @@ unformatted_write (st_parameter_dt *dtp, bt type,\n     }\n   else\n     {\n-      char buffer[16];\n+#define BSWAP_BUFSZ 512\n+      char buffer[BSWAP_BUFSZ];\n       char *p;\n-      size_t i;\n+      size_t nrem;\n \n       p = source;\n \n@@ -967,12 +1056,21 @@ unformatted_write (st_parameter_dt *dtp, bt type,\n       /* By now, all complex variables have been split into their\n \t constituent reals.  */\n \n-      for (i = 0; i < nelems; i++)\n+      nrem = nelems;\n+      do\n \t{\n-\t  reverse_memcpy(buffer, p, size);\n- \t  p += size;\n-\t  write_buf (dtp, buffer, size);\n+\t  size_t nc;\n+\t  if (size * nrem > BSWAP_BUFSZ)\n+\t    nc = BSWAP_BUFSZ / size;\n+\t  else\n+\t    nc = nrem;\n+\n+\t  bswap_array (buffer, p, size, nc);\n+\t  write_buf (dtp, buffer, size * nc);\n+\t  p += size * nc;\n+\t  nrem -= nc;\n \t}\n+      while (nrem > 0);\n     }\n }\n \n@@ -2152,22 +2250,30 @@ us_read (st_parameter_dt *dtp, int continued)\n \t}\n     }\n   else\n+    {\n+      uint32_t u32;\n+      uint64_t u64;\n       switch (nr)\n \t{\n \tcase sizeof(GFC_INTEGER_4):\n-\t  reverse_memcpy (&i4, &i, sizeof (i4));\n+\t  memcpy (&u32, &i, sizeof (u32));\n+\t  u32 = __builtin_bswap32 (u32);\n+\t  memcpy (&i4, &u32, sizeof (i4));\n \t  i = i4;\n \t  break;\n \n \tcase sizeof(GFC_INTEGER_8):\n-\t  reverse_memcpy (&i8, &i, sizeof (i8));\n+\t  memcpy (&u64, &i, sizeof (u64));\n+\t  u64 = __builtin_bswap64 (u64);\n+\t  memcpy (&i8, &u64, sizeof (i8));\n \t  i = i8;\n \t  break;\n \n \tdefault:\n \t  runtime_error (\"Illegal value for record marker\");\n \t  break;\n \t}\n+    }\n \n   if (i >= 0)\n     {\n@@ -3035,7 +3141,6 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n   size_t len;\n   GFC_INTEGER_4 buf4;\n   GFC_INTEGER_8 buf8;\n-  char p[sizeof (GFC_INTEGER_8)];\n \n   if (compile_options.record_marker == 0)\n     len = sizeof (GFC_INTEGER_4);\n@@ -3064,18 +3169,22 @@ write_us_marker (st_parameter_dt *dtp, const gfc_offset buf)\n     }\n   else\n     {\n+      uint32_t u32;\n+      uint64_t u64;\n       switch (len)\n \t{\n \tcase sizeof (GFC_INTEGER_4):\n \t  buf4 = buf;\n-\t  reverse_memcpy (p, &buf4, sizeof (GFC_INTEGER_4));\n-\t  return swrite (dtp->u.p.current_unit->s, p, len);\n+\t  memcpy (&u32, &buf4, sizeof (u32));\n+\t  u32 = __builtin_bswap32 (u32);\n+\t  return swrite (dtp->u.p.current_unit->s, &u32, len);\n \t  break;\n \n \tcase sizeof (GFC_INTEGER_8):\n \t  buf8 = buf;\n-\t  reverse_memcpy (p, &buf8, sizeof (GFC_INTEGER_8));\n-\t  return swrite (dtp->u.p.current_unit->s, p, len);\n+\t  memcpy (&u64, &buf8, sizeof (u64));\n+\t  u64 = __builtin_bswap64 (u64);\n+\t  return swrite (dtp->u.p.current_unit->s, &u64, len);\n \t  break;\n \n \tdefault:\n@@ -3712,22 +3821,6 @@ st_set_nml_var_dim (st_parameter_dt *dtp, GFC_INTEGER_4 n_dim,\n   GFC_DIMENSION_SET(nml->dim[n],lbound,ubound,stride);\n }\n \n-/* Reverse memcpy - used for byte swapping.  */\n-\n-void reverse_memcpy (void *dest, const void *src, size_t n)\n-{\n-  char *d, *s;\n-  size_t i;\n-\n-  d = (char *) dest;\n-  s = (char *) src + n - 1;\n-\n-  /* Write with ascending order - this is likely faster\n-     on modern architectures because of write combining.  */\n-  for (i=0; i<n; i++)\n-      *(d++) = *(s--);\n-}\n-\n \n /* Once upon a time, a poor innocent Fortran program was reading a\n    file, when suddenly it hit the end-of-file (EOF).  Unfortunately"}]}