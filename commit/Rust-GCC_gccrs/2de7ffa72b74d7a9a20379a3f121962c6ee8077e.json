{"sha": "2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRlN2ZmYTcyYjc0ZDdhOWEyMDM3OWEzZjEyMTk2MmM2ZWU4MDc3ZQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-07-19T07:11:39Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-07-19T07:11:39Z"}, "message": "sh.c (sh_use_dfa_interface): Remove.\n\n2004-07-19  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* config/sh/sh.c (sh_use_dfa_interface): Remove.\n\t(TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE): Set to\n\thook_int_void_1.\n\t* config/sh/sh.md: Extract pipeline descriptions\n\tinto separate files.\n\t* config/sh/sh1.md: New file, extracted from sh.md.\n\t* config/sh/sh4.md: New file, extracted from sh.md.\n\t* config/sh/shmedia.md: New file, extracted from sh.md\n\tand rewritten using new-style pipeline description.\n\nFrom-SVN: r84910", "tree": {"sha": "c3512e8bd8887070acb0a6be40fdeb0dd0b110fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3512e8bd8887070acb0a6be40fdeb0dd0b110fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/comments", "author": null, "committer": null, "parents": [{"sha": "caf43ca4ae350a2a0bb4b0063d967d88be74f77c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caf43ca4ae350a2a0bb4b0063d967d88be74f77c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caf43ca4ae350a2a0bb4b0063d967d88be74f77c"}], "stats": {"total": 1265, "additions": 674, "deletions": 591}, "files": [{"sha": "ec21efaa9c3c8b096915b1e8f90cb5e5672449b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "patch": "@@ -1,9 +1,21 @@\n+2004-07-12  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* config/sh/sh.c (sh_use_dfa_interface): Remove.\n+\t(TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE): Set to\n+\thook_int_void_1.\n+\t* config/sh/sh.md: Extract pipeline descriptions\n+\tinto separate files.\n+\t* config/sh/sh1.md: New file, extracted from sh.md.\n+\t* config/sh/sh4.md: New file, extracted from sh.md.\n+\t* config/sh/shmedia.md: New file, extracted from sh.md\n+\tand rewritten using new-style pipeline description.\n+\n 2004-07-18  Zack Weinberg  <zack@codesourcery.com>\n \n \t* config/pa/pa.md: Delete the two remaining define_peephole\n \tpatterns.\n \n-2004-07-10  Steven Bosscher  <stevenb@suse.de>\n+2004-07-18  Steven Bosscher  <stevenb@suse.de>\n \t    Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* c-common.c (c_common_truthvalue_conversion): Don't warn if"}, {"sha": "5c5a72b442b4e3bc115a0d05015885f7e3f7d9b7", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "patch": "@@ -227,7 +227,6 @@ static tree sh_handle_renesas_attribute (tree *, tree, tree, int, bool *);\n static void sh_output_function_epilogue (FILE *, HOST_WIDE_INT);\n static void sh_insert_attributes (tree, tree *);\n static int sh_adjust_cost (rtx, rtx, rtx, int);\n-static int sh_use_dfa_interface (void);\n static int sh_issue_rate (void);\n static int sh_dfa_new_cycle (FILE *, int, rtx, int, int, int *sort_p);\n static short find_set_regmode_weight (rtx, enum machine_mode);\n@@ -323,8 +322,8 @@ static bool sh_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n #define TARGET_SCHED_ADJUST_COST sh_adjust_cost\n \n #undef TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \n-#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE \\\n-\t\t\t\tsh_use_dfa_interface\n+#define TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE hook_int_void_1\n+\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE sh_issue_rate\n \n@@ -8551,19 +8550,6 @@ sh_pr_n_sets (void)\n   return REG_N_SETS (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n }\n \n-/* This Function returns nonzero if the DFA based scheduler interface\n-   is to be used.  At present this is only supported properly for the SH4.\n-   For the SH1 the current DFA model is just the converted form of the old\n-   pipeline model description.  */\n-static int\n-sh_use_dfa_interface (void)\n-{\n-  if (TARGET_SH1)\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n /* This function returns \"2\" to indicate dual issue for the SH4\n    processor.  To be used by the DFA pipeline description.  */\n static int"}, {"sha": "4af9cf9a14bef2564d5c0b5f6604944921ebe277", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 5, "deletions": 574, "changes": 579, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "patch": "@@ -422,134 +422,13 @@\n \t\t\t (const_int 4)\n \t\t\t (const_int 2))))\n \n-;; Load and store instructions save a cycle if they are aligned on a\n-;; four byte boundary.  Using a function unit for stores encourages\n-;; gcc to separate load and store instructions by one instruction,\n-;; which makes it more likely that the linker will be able to word\n-;; align them when relaxing.\n-\n-;; SH-1 scheduling\n-\n-(define_automaton \"sh1\")\n-(define_cpu_unit \"sh1memory,sh1int,sh1mpy,sh1fp\" \"sh1\")\n-\n-;; Loads have a latency of two.\n-;; However, call insns can have a delay slot, so that we want one more\n-;; insn to be scheduled between the load of the function address and the call.\n-;; This is equivalent to a latency of three.\n-;; ADJUST_COST can only properly handle reductions of the cost, so we\n-;; use a latency of three here.\n-;; We only do this for SImode loads of general registers, to make the work\n-;; for ADJUST_COST easier.\n-(define_insn_reservation \"sh1_load_si\" 3\n-  (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"load_si,pcload_si\"))\n-  \"sh1memory*2\")\n-\n-(define_insn_reservation \"sh1_load_store\" 2\n-  (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"load,pcload,pload,store,pstore\"))\n-  \"sh1memory*2\")\n-\n-(define_insn_reservation \"sh1_arith3\" 3\n-  (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"arith3,arith3b\"))\n-  \"sh1int*3\")\n-\n-(define_insn_reservation \"sh1_dyn_shift\" 2\n-  (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"dyn_shift\"))\n-  \"sh1int*2\")\n-\n-(define_insn_reservation \"sh1_int\" 1\n-  (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"!arith3,arith3b,dyn_shift\"))\n-  \"sh1int\")\n-\n-;; ??? These are approximations.\n-(define_insn_reservation \"sh1_smpy\" 2\n-  (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"smpy\"))\n-  \"sh1mpy*2\")\n-\n-(define_insn_reservation \"sh1_dmpy\" 3\n-  (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"dmpy\"))\n-  \"sh1mpy*3\")\n-\n-(define_insn_reservation \"sh1_fp\" 2\n-  (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"fp,fmove\"))\n-  \"sh1fp\")\n-\n-(define_insn_reservation \"sh1_fdiv\" 13\n-  (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"fdiv\"))\n-  \"sh1fp*12\")\n-\n-;; SH-5 SHmedia scheduling\n-;; When executing SHmedia code, the SH-5 is a fairly straightforward\n-;; single-issue machine.  It has four pipelines, the branch unit (br),\n-;; the integer and multimedia unit (imu), the load/store unit (lsu), and\n-;; the floating point unit (fpu).\n-;;\n-;; (define_function_unit {name} {num-units} {n-users} {test}\n-;;                       {ready-delay} {issue-delay} [{conflict-list}])\n-\n-;; Every instruction on SH-5 occupies the issue resource for at least one\n-;; cycle.\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"!pt_media,ptabs_media,invalidate_line_media,dmpy_media,load_media,fload_media,fcmp_media,fmove_media,fparith_media,dfparith_media,fpconv_media,dfpconv_media,dfmul_media,store_media,fstore_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media\")) 1 1)\n-\n-;; Here model the instructions with a latency greater than one cycle.\n-\n-;; Specify the various types of instruction which have latency > 1\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"mcmp_media\")) 2 1)\n-\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"dmpy_media,load_media,fcmp_media,mac_media\")) 3 1)\n-;; but see sh_adjust_cost for mac_media exception.\n-\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"fload_media,fmove_media\")) 4 1)\n-\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"d2mpy_media\")) 4 2)\n-\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"pt_media,ptabs_media\")) 5 1)\n-\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"fparith_media,dfparith_media,fpconv_media,dfpconv_media\")) 6 1)\n-\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\")\n-       (eq_attr \"type\" \"invalidate_line_media\")) 7 7)\n-\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"dfmul_media\")) 9 4)\n-\n-(define_function_unit \"sh5issue\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"atrans_media\")) 10 5)\n+;; DFA descriptions for the pipelines\n \n-;; Floating-point divide and square-root occupy an additional resource,\n-;; which is not internally pipelined.  However, other instructions\n-;; can continue to issue.\n-(define_function_unit \"sh5fds\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"fdiv_media\"))  19 19)\n+(include \"sh1.md\")\n+(include \"shmedia.md\")\n+(include \"sh4.md\")\n \n-(define_function_unit \"sh5fds\" 1 0\n-  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"dfdiv_media\")) 35 35)\n-\n-; Definitions for filling branch delay slots.\n+;; Definitions for filling delay slots\n \n (define_attr \"needs_delay_slot\" \"yes,no\" (const_string \"no\"))\n \n@@ -10791,451 +10670,3 @@ mov.l\\\\t1f,r0\\\\n\\\\\n }\"\n   [(set_attr \"type\" \"other\")])\n \n-;; The following description  models the\n-;; SH4 pipeline using the DFA based scheduler.\n-;; The DFA based description is better way to model\n-;; a superscalar pipeline as compared to function unit\n-;; reservation model.\n-;; 1. The function unit based model is oriented to describe at most one\n-;;    unit reservation by each insn. It is difficult to model unit reservations in multiple\n-;;    pipeline units by same insn. This can be done using DFA based description.\n-;; 2. The execution performance of DFA based scheduler does not depend on processor complexity.\n-;; 3. Writing all unit reservations for an instruction class is more natural description\n-;;    of the pipeline and makes interface of the hazard recognizer simpler than the\n-;;    old function unit based model.\n-;; 4. The DFA model is richer and is a part of greater overall framework of RCSP.\n-\n-\n-;; Two automata are defined to reduce number of states\n-;; which a single large automaton will have.(Factoring)\n-\n-(define_automaton \"inst_pipeline,fpu_pipe\")\n-\n-;; This unit is basically the decode unit of the processor.\n-;; Since SH4 is a dual issue machine,it is as if there are two\n-;; units so that any insn can be processed by either one\n-;; of the decoding unit.\n-\n-(define_cpu_unit \"pipe_01,pipe_02\" \"inst_pipeline\")\n-\n-\n-;; The fixed point arithmetic calculator(?? EX Unit).\n-\n-(define_cpu_unit  \"int\" \"inst_pipeline\")\n-\n-;; f1_1 and f1_2 are floating point units.Actually there is\n-;; a f1 unit which can overlap with other f1 unit but\n-;; not another F1 unit.It is as though there were two\n-;; f1 units.\n-\n-(define_cpu_unit \"f1_1,f1_2\" \"fpu_pipe\")\n-\n-;; The floating point units (except FS - F2 always precedes it.)\n-\n-(define_cpu_unit \"F0,F1,F2,F3\" \"fpu_pipe\")\n-\n-;; This is basically the MA unit of SH4\n-;; used in LOAD/STORE pipeline.\n-\n-(define_cpu_unit \"memory\" \"inst_pipeline\")\n-\n-;; However, there are LS group insns that don't use it, even ones that\n-;; complete in 0 cycles.  So we use an extra unit for the issue of LS insns.\n-(define_cpu_unit \"load_store\" \"inst_pipeline\")\n-\n-;; The address calculator used for branch instructions.\n-;; This will be reserved after \"issue\" of branch instructions\n-;; and this is to make sure that no two branch instructions\n-;; can be issued in parallel.\n-\n-(define_cpu_unit \"pcr_addrcalc\" \"inst_pipeline\")\n-\n-;; ----------------------------------------------------\n-;; This reservation is to simplify the dual issue description.\n-\n-(define_reservation  \"issue\"  \"pipe_01|pipe_02\")\n-\n-;; This is to express the locking of D stage.\n-;; Note that the issue of a CO group insn also effectively locks the D stage.\n-\n-(define_reservation  \"d_lock\" \"pipe_01+pipe_02\")\n-\n-;; Every FE instruction but fipr / ftrv starts with issue and this.\n-(define_reservation \"F01\" \"F0+F1\")\n-\n-;; This is to simplify description where F1,F2,FS\n-;; are used simultaneously.\n-\n-(define_reservation \"fpu\" \"F1+F2\")\n-\n-;; This is to highlight the fact that f1\n-;; cannot overlap with F1.\n-\n-(exclusion_set  \"f1_1,f1_2\" \"F1\")\n-\n-(define_insn_reservation \"nil\" 0 (eq_attr \"type\" \"nil\") \"nothing\")\n-\n-;; Although reg moves have a latency of zero\n-;; we need to highlight that they use D stage\n-;; for one cycle.\n-\n-;; Group:\tMT\n-\n-(define_insn_reservation \"reg_mov\" 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"move\"))\n-  \"issue\")\n-\n-;; Group:\tLS\n-\n-(define_insn_reservation \"freg_mov\" 0\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"fmove\"))\n-  \"issue+load_store\")\n-\n-;; We don't model all pipeline stages; we model the issue ('D') stage\n-;; inasmuch as we allow only two instructions to issue simultaneously,\n-;; and CO instructions prevent any simultaneous issue of another instruction.\n-;; (This uses pipe_01 and pipe_02).\n-;; Double issue of EX insns is prevented by using the int unit in the EX stage.\n-;; Double issue of EX / BR insns is prevented by using the int unit /\n-;; pcr_addrcalc unit in the EX stage.\n-;; Double issue of BR / LS instructions is prevented by using the\n-;; pcr_addrcalc / load_store unit in the issue cycle.\n-;; Double issue of FE instructions is prevented by using F0 in the first\n-;; pipeline stage after the first D stage.\n-;; There is no need to describe the [ES]X / [MN]A / S stages after a D stage\n-;; (except in the cases outlined above), nor to describe the FS stage after\n-;; the F2 stage.\n-\n-;; Other MT  group instructions(1 step operations)\n-;; Group:\tMT\n-;; Latency: \t1\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"mt\" 1\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"mt_group\"))\n-  \"issue\")\n-\n-;; Fixed Point Arithmetic Instructions(1 step operations)\n-;; Group:\tEX\n-;; Latency: \t1\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"sh4_simple_arith\" 1\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"insn_class\" \"ex_group\"))\n-  \"issue,int\")\n-\n-;; Load and store instructions have no alignment peculiarities for the SH4,\n-;; but they use the load-store unit, which they share with the fmove type\n-;; insns (fldi[01]; fmov frn,frm; flds; fsts; fabs; fneg) .\n-;; Loads have a latency of two.\n-;; However, call insns can only paired with a preceding insn, and have\n-;; a delay slot, so that we want two more insns to be scheduled between the\n-;; load of the function address and the call.  This is equivalent to a\n-;; latency of three.\n-;; ADJUST_COST can only properly handle reductions of the cost, so we\n-;; use a latency of three here, which gets multiplied by 10 to yield 30.\n-;; We only do this for SImode loads of general registers, to make the work\n-;; for ADJUST_COST easier.\n-\n-;; Load Store instructions. (MOV.[BWL]@(d,GBR)\n-;; Group:\tLS\n-;; Latency: \t2\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"sh4_load\" 2\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"load,pcload\"))\n-  \"issue+load_store,nothing,memory\")\n-\n-;; calls / sfuncs need an extra instruction for their delay slot.\n-;; Moreover, estimating the latency for SImode loads as 3 will also allow\n-;; adjust_cost to meaningfully bump it back up to 3 if they load the shift\n-;; count of a dynamic shift.\n-(define_insn_reservation \"sh4_load_si\" 3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"load_si,pcload_si\"))\n-  \"issue+load_store,nothing,memory\")\n-\n-;; (define_bypass 2 \"sh4_load_si\" \"!sh4_call\")\n-\n-;; The load latency is upped to three higher if the dependent insn does\n-;; double precision computation.  We want the 'default' latency to reflect\n-;; that increased latency because otherwise the insn priorities won't\n-;; allow proper scheduling.\n-(define_insn_reservation \"sh4_fload\" 3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"fload,pcfload\"))\n-  \"issue+load_store,nothing,memory\")\n-\n-;; (define_bypass 2 \"sh4_fload\" \"!\")\n-\n-(define_insn_reservation \"sh4_store\" 1\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"store\"))\n-  \"issue+load_store,nothing,memory\")\n-\n-;; Load Store instructions.\n-;; Group:\tLS\n-;; Latency: \t1\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"sh4_gp_fpul\" 1\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"gp_fpul\"))\n-  \"issue+load_store\")\n-\n-;; Load Store instructions.\n-;; Group:\tLS\n-;; Latency: \t3\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"sh4_fpul_gp\" 3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"fpul_gp\"))\n-  \"issue+load_store\")\n-\n-;; Branch (BF,BF/S,BT,BT/S,BRA)\n-;; Group:\tBR\n-;; Latency when taken: \t2 (or 1)\n-;; Issue Rate: \t1\n-;; The latency is 1 when displacement is 0.\n-;; We can't really do much with the latency, even if we could express it,\n-;; but the pairing restrictions are useful to take into account.\n-;; ??? If the branch is likely, we might want to fill the delay slot;\n-;; if the branch is likely, but not very likely, should we pretend to use\n-;; a resource that CO instructions use, to get a pairable delay slot insn?\n-\n-(define_insn_reservation \"sh4_branch\"  1\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"cbranch,jump\"))\n-  \"issue+pcr_addrcalc\")\n-\n-;; Branch Far (JMP,RTS,BRAF)\n-;; Group:\tCO\n-;; Latency: \t3\n-;; Issue Rate: \t2\n-;; ??? Scheduling happens before branch shortening, and hence jmp and braf\n-;; can't be distinguished from bra for the \"jump\" pattern.\n-\n-(define_insn_reservation \"sh4_return\" 3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"return,jump_ind\"))\n-         \"d_lock*2\")\n-\n-;; RTE\n-;; Group:\tCO\n-;; Latency: \t5\n-;; Issue Rate: \t5\n-;; this instruction can be executed in any of the pipelines\n-;; and blocks the pipeline for next 4 stages.\n-\n-(define_insn_reservation \"sh4_return_from_exp\" 5\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"rte\"))\n-  \"d_lock*5\")\n-\n-;; OCBP, OCBWB\n-;; Group:\tCO\n-;; Latency: \t1-5\n-;; Issue Rate: \t1\n-\n-;; cwb is used for the sequence ocbwb @%0; extu.w %0,%2; or %1,%2; mov.l %0,@%2\n-;; ocbwb on its own would be \"d_lock,nothing,memory*5\"\n-(define_insn_reservation \"ocbwb\"  6\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"cwb\"))\n-  \"d_lock*2,(d_lock+memory)*3,issue+load_store+memory,memory*2\")\n-\n-;; LDS to PR,JSR\n-;; Group:\tCO\n-;; Latency: \t3\n-;; Issue Rate: \t2\n-;; The SX stage is blocked for last 2 cycles.\n-;; OTOH, the only time that has an effect for insns generated by the compiler\n-;; is when lds to PR is followed by sts from PR - and that is highly unlikely -\n-;; or when we are doing a function call - and we don't do inter-function\n-;; scheduling.  For the function call case, it's really best that we end with\n-;; something that models an rts.\n-\n-(define_insn_reservation \"sh4_lds_to_pr\" 3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"prset\") )\n-  \"d_lock*2\")\n-\n-;; calls introduce a longisch delay that is likely to flush the pipelines\n-;; of the caller's instructions.  Ordinary functions tend to end with a\n-;; load to restore a register (in the delay slot of rts), while sfuncs\n-;; tend to end with an EX or MT insn.  But that is not actually relevant,\n-;; since there are no instructions that contend for memory access early.\n-;; We could, of course, provide exact scheduling information for specific\n-;; sfuncs, if that should prove useful.\n-\n-(define_insn_reservation \"sh4_call\" 16\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"call,sfunc\"))\n-  \"d_lock*16\")\n-\n-;; LDS.L to PR\n-;; Group:\tCO\n-;; Latency: \t3\n-;; Issue Rate: \t2\n-;; The SX unit is blocked for last 2 cycles.\n-\n-(define_insn_reservation \"ldsmem_to_pr\"  3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"pload\"))\n-  \"d_lock*2\")\n-\n-;; STS from PR\n-;; Group:\tCO\n-;; Latency: \t2\n-;; Issue Rate: \t2\n-;; The SX unit in second and third cycles.\n-\n-(define_insn_reservation \"sts_from_pr\" 2\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"prget\"))\n-  \"d_lock*2\")\n-\n-;; STS.L from PR\n-;; Group:\tCO\n-;; Latency: \t2\n-;; Issue Rate: \t2\n-\n-(define_insn_reservation \"sh4_prstore_mem\" 2\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"pstore\"))\n-  \"d_lock*2,nothing,memory\")\n-\n-;; LDS to FPSCR\n-;; Group:\tCO\n-;; Latency: \t4\n-;; Issue Rate: \t1\n-;; F1 is blocked for last three cycles.\n-\n-(define_insn_reservation \"fpscr_load\" 4\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"gp_fpscr\"))\n-  \"d_lock,nothing,F1*3\")\n-\n-;; LDS.L to FPSCR\n-;; Group:\tCO\n-;; Latency: \t1 / 4\n-;; Latency to update Rn is 1 and latency to update FPSCR is 4\n-;; Issue Rate: \t1\n-;; F1 is blocked for last three cycles.\n-\n-(define_insn_reservation \"fpscr_load_mem\" 4\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\"  \"mem_fpscr\"))\n-  \"d_lock,nothing,(F1+memory),F1*2\")\n-\n-\f\n-;; Fixed point multiplication (DMULS.L DMULU.L MUL.L MULS.W,MULU.W)\n-;; Group:\tCO\n-;; Latency: \t4 / 4\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"multi\" 4\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"smpy,dmpy\"))\n-  \"d_lock,(d_lock+f1_1),(f1_1|f1_2)*3,F2\")\n-\n-;; Fixed STS from MACL / MACH\n-;; Group:\tCO\n-;; Latency: \t3\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"sh4_mac_gp\" 3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"mac_gp\"))\n-  \"d_lock\")\n-\n-\n-;; Single precision floating point computation FCMP/EQ,\n-;; FCMP/GT, FADD, FLOAT, FMAC, FMUL, FSUB, FTRC, FRVHG, FSCHG\n-;; Group:\tFE\n-;; Latency: \t3/4\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"fp_arith\"  3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"fp\"))\n-  \"issue,F01,F2\")\n-\n-(define_insn_reservation \"fp_arith_ftrc\"  3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"ftrc_s\"))\n-  \"issue,F01,F2\")\n-\n-(define_bypass 1 \"fp_arith_ftrc\" \"sh4_fpul_gp\")\n-\n-;; Single Precision FDIV/SQRT\n-;; Group:\tFE\n-;; Latency: \t12/13 (FDIV); 11/12 (FSQRT)\n-;; Issue Rate: \t1\n-;; We describe fdiv here; fsqrt is actually one cycle faster.\n-\n-(define_insn_reservation \"fp_div\" 12\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"fdiv\"))\n-  \"issue,F01+F3,F2+F3,F3*7,F1+F3,F2\")\n-\n-;; Double Precision floating point computation\n-;; (FCNVDS, FCNVSD, FLOAT, FTRC)\n-;; Group:\tFE\n-;; Latency: \t(3,4)/5\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"dp_float\" 4\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"dfp_conv\"))\n-  \"issue,F01,F1+F2,F2\")\n-\n-;; Double-precision floating-point (FADD,FMUL,FSUB)\n-;; Group:\tFE\n-;; Latency: \t(7,8)/9\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"fp_double_arith\" 8\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"dfp_arith\"))\n-  \"issue,F01,F1+F2,fpu*4,F2\")\n-\n-;; Double-precision FCMP (FCMP/EQ,FCMP/GT)\n-;; Group:\tCO\n-;; Latency: \t3/5\n-;; Issue Rate: \t2\n-\n-(define_insn_reservation \"fp_double_cmp\" 3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"dfp_cmp\"))\n-  \"d_lock,(d_lock+F01),F1+F2,F2\")\n-\n-;; Double precision FDIV/SQRT\n-;; Group:\tFE\n-;; Latency: \t(24,25)/26\n-;; Issue Rate: \t1\n-\n-(define_insn_reservation \"dp_div\" 25\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"dfdiv\"))\n-  \"issue,F01+F3,F1+F2+F3,F2+F3,F3*16,F1+F3,(fpu+F3)*2,F2\")\n-\n-\n-;; Use the branch-not-taken case to model arith3 insns.  For the branch taken\n-;; case, we'd get a d_lock instead of issue at the end.\n-(define_insn_reservation \"arith3\" 3\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"arith3\"))\n-  \"issue,d_lock+pcr_addrcalc,issue\")\n-\n-;; arith3b insns schedule the same no matter if the branch is taken or not.\n-(define_insn_reservation \"arith3b\" 2\n-  (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"arith3\"))\n-  \"issue,d_lock+pcr_addrcalc\")"}, {"sha": "e317e2ca3e164edee5b2a83f813f7db617762334", "filename": "gcc/config/sh/sh1.md", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fsh1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fsh1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh1.md?ref=2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "patch": "@@ -0,0 +1,86 @@\n+;; DFA scheduling description for Renesas / SuperH SH.\n+;; Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Load and store instructions save a cycle if they are aligned on a\n+;; four byte boundary.  Using a function unit for stores encourages\n+;; gcc to separate load and store instructions by one instruction,\n+;; which makes it more likely that the linker will be able to word\n+;; align them when relaxing.\n+\n+;; SH-1 scheduling.  This is just a conversion of the old scheduling\n+;; model, using define_function_unit.\n+\n+(define_automaton \"sh1\")\n+(define_cpu_unit \"sh1memory,sh1int,sh1mpy,sh1fp\" \"sh1\")\n+\n+;; Loads have a latency of two.\n+;; However, call insns can have a delay slot, so that we want one more\n+;; insn to be scheduled between the load of the function address and the call.\n+;; This is equivalent to a latency of three.\n+;; ADJUST_COST can only properly handle reductions of the cost, so we\n+;; use a latency of three here.\n+;; We only do this for SImode loads of general registers, to make the work\n+;; for ADJUST_COST easier.\n+(define_insn_reservation \"sh1_load_si\" 3\n+  (and (eq_attr \"pipe_model\" \"sh1\")\n+       (eq_attr \"type\" \"load_si,pcload_si\"))\n+  \"sh1memory*2\")\n+\n+(define_insn_reservation \"sh1_load_store\" 2\n+  (and (eq_attr \"pipe_model\" \"sh1\")\n+       (eq_attr \"type\" \"load,pcload,pload,store,pstore\"))\n+  \"sh1memory*2\")\n+\n+(define_insn_reservation \"sh1_arith3\" 3\n+  (and (eq_attr \"pipe_model\" \"sh1\")\n+       (eq_attr \"type\" \"arith3,arith3b\"))\n+  \"sh1int*3\")\n+\n+(define_insn_reservation \"sh1_dyn_shift\" 2\n+  (and (eq_attr \"pipe_model\" \"sh1\")\n+       (eq_attr \"type\" \"dyn_shift\"))\n+  \"sh1int*2\")\n+\n+(define_insn_reservation \"sh1_int\" 1\n+  (and (eq_attr \"pipe_model\" \"sh1\")\n+       (eq_attr \"type\" \"!arith3,arith3b,dyn_shift\"))\n+  \"sh1int\")\n+\n+;; ??? These are approximations.\n+(define_insn_reservation \"sh1_smpy\" 2\n+  (and (eq_attr \"pipe_model\" \"sh1\")\n+       (eq_attr \"type\" \"smpy\"))\n+  \"sh1mpy*2\")\n+\n+(define_insn_reservation \"sh1_dmpy\" 3\n+  (and (eq_attr \"pipe_model\" \"sh1\")\n+       (eq_attr \"type\" \"dmpy\"))\n+  \"sh1mpy*3\")\n+\n+(define_insn_reservation \"sh1_fp\" 2\n+  (and (eq_attr \"pipe_model\" \"sh1\")\n+       (eq_attr \"type\" \"fp,fmove\"))\n+  \"sh1fp\")\n+\n+(define_insn_reservation \"sh1_fdiv\" 13\n+  (and (eq_attr \"pipe_model\" \"sh1\")\n+       (eq_attr \"type\" \"fdiv\"))\n+  \"sh1fp*12\")\n+"}, {"sha": "25ac7327f82d77cde743e22ca055f1db2636b843", "filename": "gcc/config/sh/sh4.md", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fsh4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fsh4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh4.md?ref=2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "patch": "@@ -0,0 +1,475 @@\n+;; DFA scheduling description for SH4.\n+;; Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Load and store instructions save a cycle if they are aligned on a\n+;; four byte boundary.  Using a function unit for stores encourages\n+;; gcc to separate load and store instructions by one instruction,\n+;; which makes it more likely that the linker will be able to word\n+;; align them when relaxing.\n+\n+;; The following description models the SH4 pipeline using the DFA based\n+;; scheduler.  The DFA based description is better way to model a\n+;; superscalar pipeline as compared to function unit reservation model.\n+;; 1. The function unit based model is oriented to describe at most one\n+;;    unit reservation by each insn. It is difficult to model unit reservations\n+;;    in multiple pipeline units by same insn.  This can be done using DFA\n+;;    based description.\n+;; 2. The execution performance of DFA based scheduler does not depend on\n+;;    processor complexity.\n+;; 3. Writing all unit reservations for an instruction class is a more natural\n+;;    description of the pipeline and makes the interface to the hazard\n+;;    recognizer simpler than the old function unit based model.\n+;; 4. The DFA model is richer and is a part of greater overall framework\n+;;    of RCSP.\n+\n+\n+;; Two automata are defined to reduce number of states\n+;; which a single large automaton will have. (Factoring)\n+\n+(define_automaton \"inst_pipeline,fpu_pipe\")\n+\n+;; This unit is basically the decode unit of the processor.\n+;; Since SH4 is a dual issue machine,it is as if there are two\n+;; units so that any insn can be processed by either one\n+;; of the decoding unit.\n+\n+(define_cpu_unit \"pipe_01,pipe_02\" \"inst_pipeline\")\n+\n+\n+;; The fixed point arithmetic calculator(?? EX Unit).\n+\n+(define_cpu_unit  \"int\" \"inst_pipeline\")\n+\n+;; f1_1 and f1_2 are floating point units.Actually there is\n+;; a f1 unit which can overlap with other f1 unit but\n+;; not another F1 unit.It is as though there were two\n+;; f1 units.\n+\n+(define_cpu_unit \"f1_1,f1_2\" \"fpu_pipe\")\n+\n+;; The floating point units (except FS - F2 always precedes it.)\n+\n+(define_cpu_unit \"F0,F1,F2,F3\" \"fpu_pipe\")\n+\n+;; This is basically the MA unit of SH4\n+;; used in LOAD/STORE pipeline.\n+\n+(define_cpu_unit \"memory\" \"inst_pipeline\")\n+\n+;; However, there are LS group insns that don't use it, even ones that\n+;; complete in 0 cycles.  So we use an extra unit for the issue of LS insns.\n+(define_cpu_unit \"load_store\" \"inst_pipeline\")\n+\n+;; The address calculator used for branch instructions.\n+;; This will be reserved after \"issue\" of branch instructions\n+;; and this is to make sure that no two branch instructions\n+;; can be issued in parallel.\n+\n+(define_cpu_unit \"pcr_addrcalc\" \"inst_pipeline\")\n+\n+;; ----------------------------------------------------\n+;; This reservation is to simplify the dual issue description.\n+\n+(define_reservation  \"issue\"  \"pipe_01|pipe_02\")\n+\n+;; This is to express the locking of D stage.\n+;; Note that the issue of a CO group insn also effectively locks the D stage.\n+\n+(define_reservation  \"d_lock\" \"pipe_01+pipe_02\")\n+\n+;; Every FE instruction but fipr / ftrv starts with issue and this.\n+(define_reservation \"F01\" \"F0+F1\")\n+\n+;; This is to simplify description where F1,F2,FS\n+;; are used simultaneously.\n+\n+(define_reservation \"fpu\" \"F1+F2\")\n+\n+;; This is to highlight the fact that f1\n+;; cannot overlap with F1.\n+\n+(exclusion_set  \"f1_1,f1_2\" \"F1\")\n+\n+(define_insn_reservation \"nil\" 0 (eq_attr \"type\" \"nil\") \"nothing\")\n+\n+;; Although reg moves have a latency of zero\n+;; we need to highlight that they use D stage\n+;; for one cycle.\n+\n+;; Group:\tMT\n+\n+(define_insn_reservation \"reg_mov\" 0\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"move\"))\n+  \"issue\")\n+\n+;; Group:\tLS\n+\n+(define_insn_reservation \"freg_mov\" 0\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fmove\"))\n+  \"issue+load_store\")\n+\n+;; We don't model all pipeline stages; we model the issue ('D') stage\n+;; inasmuch as we allow only two instructions to issue simultaneously,\n+;; and CO instructions prevent any simultaneous issue of another instruction.\n+;; (This uses pipe_01 and pipe_02).\n+;; Double issue of EX insns is prevented by using the int unit in the EX stage.\n+;; Double issue of EX / BR insns is prevented by using the int unit /\n+;; pcr_addrcalc unit in the EX stage.\n+;; Double issue of BR / LS instructions is prevented by using the\n+;; pcr_addrcalc / load_store unit in the issue cycle.\n+;; Double issue of FE instructions is prevented by using F0 in the first\n+;; pipeline stage after the first D stage.\n+;; There is no need to describe the [ES]X / [MN]A / S stages after a D stage\n+;; (except in the cases outlined above), nor to describe the FS stage after\n+;; the F2 stage.\n+\n+;; Other MT  group instructions(1 step operations)\n+;; Group:\tMT\n+;; Latency: \t1\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"mt\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"mt_group\"))\n+  \"issue\")\n+\n+;; Fixed Point Arithmetic Instructions(1 step operations)\n+;; Group:\tEX\n+;; Latency: \t1\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"sh4_simple_arith\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"insn_class\" \"ex_group\"))\n+  \"issue,int\")\n+\n+;; Load and store instructions have no alignment peculiarities for the SH4,\n+;; but they use the load-store unit, which they share with the fmove type\n+;; insns (fldi[01]; fmov frn,frm; flds; fsts; fabs; fneg) .\n+;; Loads have a latency of two.\n+;; However, call insns can only paired with a preceding insn, and have\n+;; a delay slot, so that we want two more insns to be scheduled between the\n+;; load of the function address and the call.  This is equivalent to a\n+;; latency of three.\n+;; ADJUST_COST can only properly handle reductions of the cost, so we\n+;; use a latency of three here, which gets multiplied by 10 to yield 30.\n+;; We only do this for SImode loads of general registers, to make the work\n+;; for ADJUST_COST easier.\n+\n+;; Load Store instructions. (MOV.[BWL]@(d,GBR)\n+;; Group:\tLS\n+;; Latency: \t2\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"sh4_load\" 2\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"load,pcload\"))\n+  \"issue+load_store,nothing,memory\")\n+\n+;; calls / sfuncs need an extra instruction for their delay slot.\n+;; Moreover, estimating the latency for SImode loads as 3 will also allow\n+;; adjust_cost to meaningfully bump it back up to 3 if they load the shift\n+;; count of a dynamic shift.\n+(define_insn_reservation \"sh4_load_si\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"load_si,pcload_si\"))\n+  \"issue+load_store,nothing,memory\")\n+\n+;; (define_bypass 2 \"sh4_load_si\" \"!sh4_call\")\n+\n+;; The load latency is upped to three higher if the dependent insn does\n+;; double precision computation.  We want the 'default' latency to reflect\n+;; that increased latency because otherwise the insn priorities won't\n+;; allow proper scheduling.\n+(define_insn_reservation \"sh4_fload\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fload,pcfload\"))\n+  \"issue+load_store,nothing,memory\")\n+\n+;; (define_bypass 2 \"sh4_fload\" \"!\")\n+\n+(define_insn_reservation \"sh4_store\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"store\"))\n+  \"issue+load_store,nothing,memory\")\n+\n+;; Load Store instructions.\n+;; Group:\tLS\n+;; Latency: \t1\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"sh4_gp_fpul\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"gp_fpul\"))\n+  \"issue+load_store\")\n+\n+;; Load Store instructions.\n+;; Group:\tLS\n+;; Latency: \t3\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"sh4_fpul_gp\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fpul_gp\"))\n+  \"issue+load_store\")\n+\n+;; Branch (BF,BF/S,BT,BT/S,BRA)\n+;; Group:\tBR\n+;; Latency when taken: \t2 (or 1)\n+;; Issue Rate: \t1\n+;; The latency is 1 when displacement is 0.\n+;; We can't really do much with the latency, even if we could express it,\n+;; but the pairing restrictions are useful to take into account.\n+;; ??? If the branch is likely, we might want to fill the delay slot;\n+;; if the branch is likely, but not very likely, should we pretend to use\n+;; a resource that CO instructions use, to get a pairable delay slot insn?\n+\n+(define_insn_reservation \"sh4_branch\"  1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"cbranch,jump\"))\n+  \"issue+pcr_addrcalc\")\n+\n+;; Branch Far (JMP,RTS,BRAF)\n+;; Group:\tCO\n+;; Latency: \t3\n+;; Issue Rate: \t2\n+;; ??? Scheduling happens before branch shortening, and hence jmp and braf\n+;; can't be distinguished from bra for the \"jump\" pattern.\n+\n+(define_insn_reservation \"sh4_return\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"return,jump_ind\"))\n+         \"d_lock*2\")\n+\n+;; RTE\n+;; Group:\tCO\n+;; Latency: \t5\n+;; Issue Rate: \t5\n+;; this instruction can be executed in any of the pipelines\n+;; and blocks the pipeline for next 4 stages.\n+\n+(define_insn_reservation \"sh4_return_from_exp\" 5\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"rte\"))\n+  \"d_lock*5\")\n+\n+;; OCBP, OCBWB\n+;; Group:\tCO\n+;; Latency: \t1-5\n+;; Issue Rate: \t1\n+\n+;; cwb is used for the sequence ocbwb @%0; extu.w %0,%2; or %1,%2; mov.l %0,@%2\n+;; ocbwb on its own would be \"d_lock,nothing,memory*5\"\n+(define_insn_reservation \"ocbwb\"  6\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"cwb\"))\n+  \"d_lock*2,(d_lock+memory)*3,issue+load_store+memory,memory*2\")\n+\n+;; LDS to PR,JSR\n+;; Group:\tCO\n+;; Latency: \t3\n+;; Issue Rate: \t2\n+;; The SX stage is blocked for last 2 cycles.\n+;; OTOH, the only time that has an effect for insns generated by the compiler\n+;; is when lds to PR is followed by sts from PR - and that is highly unlikely -\n+;; or when we are doing a function call - and we don't do inter-function\n+;; scheduling.  For the function call case, it's really best that we end with\n+;; something that models an rts.\n+\n+(define_insn_reservation \"sh4_lds_to_pr\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"prset\") )\n+  \"d_lock*2\")\n+\n+;; calls introduce a longisch delay that is likely to flush the pipelines\n+;; of the caller's instructions.  Ordinary functions tend to end with a\n+;; load to restore a register (in the delay slot of rts), while sfuncs\n+;; tend to end with an EX or MT insn.  But that is not actually relevant,\n+;; since there are no instructions that contend for memory access early.\n+;; We could, of course, provide exact scheduling information for specific\n+;; sfuncs, if that should prove useful.\n+\n+(define_insn_reservation \"sh4_call\" 16\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"call,sfunc\"))\n+  \"d_lock*16\")\n+\n+;; LDS.L to PR\n+;; Group:\tCO\n+;; Latency: \t3\n+;; Issue Rate: \t2\n+;; The SX unit is blocked for last 2 cycles.\n+\n+(define_insn_reservation \"ldsmem_to_pr\"  3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"pload\"))\n+  \"d_lock*2\")\n+\n+;; STS from PR\n+;; Group:\tCO\n+;; Latency: \t2\n+;; Issue Rate: \t2\n+;; The SX unit in second and third cycles.\n+\n+(define_insn_reservation \"sts_from_pr\" 2\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"prget\"))\n+  \"d_lock*2\")\n+\n+;; STS.L from PR\n+;; Group:\tCO\n+;; Latency: \t2\n+;; Issue Rate: \t2\n+\n+(define_insn_reservation \"sh4_prstore_mem\" 2\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"pstore\"))\n+  \"d_lock*2,nothing,memory\")\n+\n+;; LDS to FPSCR\n+;; Group:\tCO\n+;; Latency: \t4\n+;; Issue Rate: \t1\n+;; F1 is blocked for last three cycles.\n+\n+(define_insn_reservation \"fpscr_load\" 4\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"gp_fpscr\"))\n+  \"d_lock,nothing,F1*3\")\n+\n+;; LDS.L to FPSCR\n+;; Group:\tCO\n+;; Latency: \t1 / 4\n+;; Latency to update Rn is 1 and latency to update FPSCR is 4\n+;; Issue Rate: \t1\n+;; F1 is blocked for last three cycles.\n+\n+(define_insn_reservation \"fpscr_load_mem\" 4\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\"  \"mem_fpscr\"))\n+  \"d_lock,nothing,(F1+memory),F1*2\")\n+\n+\f\n+;; Fixed point multiplication (DMULS.L DMULU.L MUL.L MULS.W,MULU.W)\n+;; Group:\tCO\n+;; Latency: \t4 / 4\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"multi\" 4\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"smpy,dmpy\"))\n+  \"d_lock,(d_lock+f1_1),(f1_1|f1_2)*3,F2\")\n+\n+;; Fixed STS from MACL / MACH\n+;; Group:\tCO\n+;; Latency: \t3\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"sh4_mac_gp\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"mac_gp\"))\n+  \"d_lock\")\n+\n+\n+;; Single precision floating point computation FCMP/EQ,\n+;; FCMP/GT, FADD, FLOAT, FMAC, FMUL, FSUB, FTRC, FRVHG, FSCHG\n+;; Group:\tFE\n+;; Latency: \t3/4\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"fp_arith\"  3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fp\"))\n+  \"issue,F01,F2\")\n+\n+(define_insn_reservation \"fp_arith_ftrc\"  3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"ftrc_s\"))\n+  \"issue,F01,F2\")\n+\n+(define_bypass 1 \"fp_arith_ftrc\" \"sh4_fpul_gp\")\n+\n+;; Single Precision FDIV/SQRT\n+;; Group:\tFE\n+;; Latency: \t12/13 (FDIV); 11/12 (FSQRT)\n+;; Issue Rate: \t1\n+;; We describe fdiv here; fsqrt is actually one cycle faster.\n+\n+(define_insn_reservation \"fp_div\" 12\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fdiv\"))\n+  \"issue,F01+F3,F2+F3,F3*7,F1+F3,F2\")\n+\n+;; Double Precision floating point computation\n+;; (FCNVDS, FCNVSD, FLOAT, FTRC)\n+;; Group:\tFE\n+;; Latency: \t(3,4)/5\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"dp_float\" 4\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"dfp_conv\"))\n+  \"issue,F01,F1+F2,F2\")\n+\n+;; Double-precision floating-point (FADD,FMUL,FSUB)\n+;; Group:\tFE\n+;; Latency: \t(7,8)/9\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"fp_double_arith\" 8\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"dfp_arith\"))\n+  \"issue,F01,F1+F2,fpu*4,F2\")\n+\n+;; Double-precision FCMP (FCMP/EQ,FCMP/GT)\n+;; Group:\tCO\n+;; Latency: \t3/5\n+;; Issue Rate: \t2\n+\n+(define_insn_reservation \"fp_double_cmp\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"dfp_cmp\"))\n+  \"d_lock,(d_lock+F01),F1+F2,F2\")\n+\n+;; Double precision FDIV/SQRT\n+;; Group:\tFE\n+;; Latency: \t(24,25)/26\n+;; Issue Rate: \t1\n+\n+(define_insn_reservation \"dp_div\" 25\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"dfdiv\"))\n+  \"issue,F01+F3,F1+F2+F3,F2+F3,F3*16,F1+F3,(fpu+F3)*2,F2\")\n+\n+\n+;; Use the branch-not-taken case to model arith3 insns.  For the branch taken\n+;; case, we'd get a d_lock instead of issue at the end.\n+(define_insn_reservation \"arith3\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"arith3\"))\n+  \"issue,d_lock+pcr_addrcalc,issue\")\n+\n+;; arith3b insns schedule the same no matter if the branch is taken or not.\n+(define_insn_reservation \"arith3b\" 2\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"arith3\"))\n+  \"issue,d_lock+pcr_addrcalc\")"}, {"sha": "4efed77b7ed4904952f299c2ef608011c7b5955b", "filename": "gcc/config/sh/shmedia.md", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fshmedia.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de7ffa72b74d7a9a20379a3f121962c6ee8077e/gcc%2Fconfig%2Fsh%2Fshmedia.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fshmedia.md?ref=2de7ffa72b74d7a9a20379a3f121962c6ee8077e", "patch": "@@ -0,0 +1,93 @@\n+;; DFA scheduling description for SH-5 SHmedia instructions.\n+;; Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; This is just a conversion of the old model using define_function_unit.\n+\n+;; When executing SHmedia code, the SH-5 is a fairly straightforward\n+;; single-issue machine.  It has four pipelines, the branch unit (br),\n+;; the integer and multimedia unit (imu), the load/store unit (lsu), and\n+;; the floating point unit (fpu).\n+\n+(define_automaton \"shmedia\")\n+\n+(define_cpu_unit \"sh5issue,sh5fds\" \"shmedia\")\n+\n+;; Every instruction on SH-5 occupies the issue resource for at least one\n+;; cycle.\n+(define_insn_reservation \"shmedia1\" 1\n+  (and (eq_attr \"pipe_model\" \"sh5media\")\n+       (eq_attr \"type\" \"!pt_media,ptabs_media,invalidate_line_media,dmpy_media,load_media,fload_media,fcmp_media,fmove_media,fparith_media,dfparith_media,fpconv_media,dfpconv_media,dfmul_media,store_media,fstore_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media\"))\n+  \"sh5issue\")\n+\n+;; Specify the various types of instruction which have latency > 1\n+(define_insn_reservation \"shmedia2\" 2\n+  (and (eq_attr \"pipe_model\" \"sh5media\")\n+       (eq_attr \"type\" \"mcmp_media\"))\n+  \"sh5issue\")\n+\n+(define_insn_reservation \"shmedia3\" 3\n+  (and (eq_attr \"pipe_model\" \"sh5media\")\n+       (eq_attr \"type\" \"dmpy_media,load_media,fcmp_media,mac_media\"))\n+  \"sh5issue\")\n+;; but see sh_adjust_cost for mac_media exception.\n+\n+(define_insn_reservation \"shmedia4\" 4\n+  (and (eq_attr \"pipe_model\" \"sh5media\")\n+       (eq_attr \"type\" \"fload_media,fmove_media\"))\n+  \"sh5issue\")\n+\n+(define_insn_reservation \"shmedia_d2mpy\" 4\n+  (and (eq_attr \"pipe_model\" \"sh5media\")\n+       (eq_attr \"type\" \"d2mpy_media\"))\n+  \"sh5issue*2\")\n+\n+(define_insn_reservation \"shmedia5\" 5\n+  (and (eq_attr \"pipe_model\" \"sh5media\")\n+       (eq_attr \"type\" \"pt_media,ptabs_media\"))\n+  \"sh5issue\")\n+\n+(define_insn_reservation \"shmedia6\" 6\n+  (and (eq_attr \"pipe_model\" \"sh5media\")\n+       (eq_attr \"type\" \"fparith_media,dfparith_media,fpconv_media,dfpconv_media\"))\n+  \"sh5issue\")\n+\n+(define_insn_reservation \"shmedia_invalidate\" 7\n+  (and (eq_attr \"pipe_model\" \"sh5media\")\n+       (eq_attr \"type\" \"invalidate_line_media\"))\n+  \"sh5issue*7\")\n+\n+(define_insn_reservation \"shmedia_dfmul\" 9\n+  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"dfmul_media\"))\n+  \"sh5issue*4\")\n+\n+(define_insn_reservation \"shmedia_atrans\" 10\n+  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"atrans_media\"))\n+  \"sh5issue*5\")\n+\n+;; Floating-point divide and square-root occupy an additional resource,\n+;; which is not internally pipelined.  However, other instructions\n+;; can continue to issue.\n+(define_insn_reservation \"shmedia_fdiv\" 19\n+  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"fdiv_media\"))\n+  \"sh5fds*19\")\n+\n+(define_insn_reservation \"shmedia_dfdiv\" 35\n+  (and (eq_attr \"pipe_model\" \"sh5media\") (eq_attr \"type\" \"dfdiv_media\"))\n+  \"sh5fds*35\")"}]}