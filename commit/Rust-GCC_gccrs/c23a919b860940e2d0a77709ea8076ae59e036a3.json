{"sha": "c23a919b860940e2d0a77709ea8076ae59e036a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIzYTkxOWI4NjA5NDBlMmQwYTc3NzA5ZWE4MDc2YWU1OWUwMzZhMw==", "commit": {"author": {"name": "Chung-Ju Wu", "email": "jasonwucj@gmail.com", "date": "2014-07-04T07:23:32Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2014-07-04T07:23:32Z"}, "message": "Move ISR impelentation to nds32-isr.c module.\n\ngcc/\n\t* config/nds32/nds32.c (nds32_emit_section_head_template): Move to ...\n\t(nds32_emit_section_tail_template): Move to ...\n\t(nds32_emit_isr_jmptbl_section): Move to ...\n\t(nds32_emit_isr_vector_section): Move to ...\n\t(nds32_emit_isr_reset_conten): Move to ...\n\t(nds32_check_isr_attrs_conflict): Move to ...\n\t(nds32_construct_isr_vectors_information): Move to ...\n\t(nds32_asm_file_start): Move implementation to ...\n\t(nds32_asm_file_end): Move implementation to ...\n\t* config/nds32/nds32-isr.c: ... here.\n\t* config/nds32/nds32-protos.h\n\t(nds32_check_isr_attrs_conflict): Declare.\n\t(nds32_construct_isr_vectors_information): Declare.\n\t(nds32_asm_file_start_for_isr): Declare.\n\t(nds32_asm_file_end_for_isr): Declare.\n\nCo-Authored-By: Kito Cheng <kito@0xlab.org>\nCo-Authored-By: Monk Chiang <sh.chiang04@gmail.com>\n\nFrom-SVN: r212281", "tree": {"sha": "eedff2e40212b9aee32cea924d181550fa0b259f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eedff2e40212b9aee32cea924d181550fa0b259f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c23a919b860940e2d0a77709ea8076ae59e036a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23a919b860940e2d0a77709ea8076ae59e036a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c23a919b860940e2d0a77709ea8076ae59e036a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23a919b860940e2d0a77709ea8076ae59e036a3/comments", "author": {"login": "jasonwucj", "id": 5520732, "node_id": "MDQ6VXNlcjU1MjA3MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/5520732?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jasonwucj", "html_url": "https://github.com/jasonwucj", "followers_url": "https://api.github.com/users/jasonwucj/followers", "following_url": "https://api.github.com/users/jasonwucj/following{/other_user}", "gists_url": "https://api.github.com/users/jasonwucj/gists{/gist_id}", "starred_url": "https://api.github.com/users/jasonwucj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jasonwucj/subscriptions", "organizations_url": "https://api.github.com/users/jasonwucj/orgs", "repos_url": "https://api.github.com/users/jasonwucj/repos", "events_url": "https://api.github.com/users/jasonwucj/events{/privacy}", "received_events_url": "https://api.github.com/users/jasonwucj/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0c935b507bc4b8d8489956da1f35edc529233bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0c935b507bc4b8d8489956da1f35edc529233bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0c935b507bc4b8d8489956da1f35edc529233bd"}], "stats": {"total": 1093, "additions": 587, "deletions": 506}, "files": [{"sha": "7979ab7aa0ca268d0787e6f9e062534d131280b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23a919b860940e2d0a77709ea8076ae59e036a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23a919b860940e2d0a77709ea8076ae59e036a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c23a919b860940e2d0a77709ea8076ae59e036a3", "patch": "@@ -1,3 +1,23 @@\n+2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n+\t    Kito Cheng  <kito@0xlab.org>\n+\t    Monk Chiang  <sh.chiang04@gmail.com>\n+\n+\t* config/nds32/nds32.c (nds32_emit_section_head_template): Move to ...\n+\t(nds32_emit_section_tail_template): Move to ...\n+\t(nds32_emit_isr_jmptbl_section): Move to ...\n+\t(nds32_emit_isr_vector_section): Move to ...\n+\t(nds32_emit_isr_reset_conten): Move to ...\n+\t(nds32_check_isr_attrs_conflict): Move to ...\n+\t(nds32_construct_isr_vectors_information): Move to ...\n+\t(nds32_asm_file_start): Move implementation to ...\n+\t(nds32_asm_file_end): Move implementation to ...\n+\t* config/nds32/nds32-isr.c: ... here.\n+\t* config/nds32/nds32-protos.h\n+\t(nds32_check_isr_attrs_conflict): Declare.\n+\t(nds32_construct_isr_vectors_information): Declare.\n+\t(nds32_asm_file_start_for_isr): Declare.\n+\t(nds32_asm_file_end_for_isr): Declare.\n+\n 2014-07-04  Chung-Ju Wu  <jasonwucj@gmail.com>\n \t    Kito Cheng  <kito@0xlab.org>\n \t    Monk Chiang  <sh.chiang04@gmail.com>"}, {"sha": "ef0187c39cf9eabb3d9aeea4a24a8c5cdb53bc9b", "filename": "gcc/config/nds32/nds32-isr.c", "status": "modified", "additions": 558, "deletions": 0, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23a919b860940e2d0a77709ea8076ae59e036a3/gcc%2Fconfig%2Fnds32%2Fnds32-isr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23a919b860940e2d0a77709ea8076ae59e036a3/gcc%2Fconfig%2Fnds32%2Fnds32-isr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-isr.c?ref=c23a919b860940e2d0a77709ea8076ae59e036a3", "patch": "@@ -17,3 +17,561 @@\n    You should have received a copy of the GNU General Public License\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n+\n+/* ------------------------------------------------------------------------ */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"stor-layout.h\"\n+#include \"varasm.h\"\n+#include \"calls.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"insn-config.h\"\t/* Required by recog.h.  */\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\t\t/* For DFA state_t.  */\n+#include \"insn-codes.h\"\t\t/* For CODE_FOR_xxx.  */\n+#include \"reload.h\"\t\t/* For push_reload().  */\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"recog.h\"\n+#include \"diagnostic-core.h\"\n+#include \"df.h\"\n+#include \"tm_p.h\"\n+#include \"tm-constrs.h\"\n+#include \"optabs.h\"\t\t/* For GEN_FCN.  */\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\t\t/* For add_builtin_function().  */\n+#include \"ggc.h\"\n+#include \"builtins.h\"\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* Refer to nds32.h, there are maximum 73 isr vectors in nds32 architecture.\n+   0 for reset handler with __attribute__((reset())),\n+   1-8 for exception handler with __attribute__((exception(1,...,8))),\n+   and 9-72 for interrupt handler with __attribute__((interrupt(0,...,63))).\n+   We use an array to record essential information for each vector.  */\n+static struct nds32_isr_info nds32_isr_vectors[NDS32_N_ISR_VECTORS];\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* A helper function to emit section head template.  */\n+static void\n+nds32_emit_section_head_template (char section_name[],\n+\t\t\t\t  char symbol_name[],\n+\t\t\t\t  int align_value,\n+\t\t\t\t  bool object_p)\n+{\n+  const char *flags_str;\n+  const char *type_str;\n+\n+  flags_str = (object_p) ? \"\\\"a\\\"\" : \"\\\"ax\\\"\";\n+  type_str = (object_p) ? \"@object\" : \"@function\";\n+\n+  fprintf (asm_out_file, \"\\t.section\\t%s, %s\\n\", section_name, flags_str);\n+  fprintf (asm_out_file, \"\\t.align\\t%d\\n\", align_value);\n+  fprintf (asm_out_file, \"\\t.global\\t%s\\n\", symbol_name);\n+  fprintf (asm_out_file, \"\\t.type\\t%s, %s\\n\", symbol_name, type_str);\n+  fprintf (asm_out_file, \"%s:\\n\", symbol_name);\n+}\n+\n+/* A helper function to emit section tail template.  */\n+static void\n+nds32_emit_section_tail_template (char symbol_name[])\n+{\n+  fprintf (asm_out_file, \"\\t.size\\t%s, .-%s\\n\", symbol_name, symbol_name);\n+}\n+\n+/* Function to emit isr jump table section.  */\n+static void\n+nds32_emit_isr_jmptbl_section (int vector_id)\n+{\n+  char section_name[100];\n+  char symbol_name[100];\n+\n+  /* Prepare jmptbl section and symbol name.  */\n+  snprintf (section_name, sizeof (section_name),\n+\t    \".nds32_jmptbl.%02d\", vector_id);\n+  snprintf (symbol_name, sizeof (symbol_name),\n+\t    \"_nds32_jmptbl_%02d\", vector_id);\n+\n+  nds32_emit_section_head_template (section_name, symbol_name, 2, true);\n+  fprintf (asm_out_file, \"\\t.word\\t%s\\n\",\n+\t\t\t nds32_isr_vectors[vector_id].func_name);\n+  nds32_emit_section_tail_template (symbol_name);\n+}\n+\n+/* Function to emit isr vector section.  */\n+static void\n+nds32_emit_isr_vector_section (int vector_id)\n+{\n+  unsigned int vector_number_offset = 0;\n+  const char *c_str = \"CATEGORY\";\n+  const char *sr_str = \"SR\";\n+  const char *nt_str = \"NT\";\n+  const char *vs_str = \"VS\";\n+  char first_level_handler_name[100];\n+  char section_name[100];\n+  char symbol_name[100];\n+\n+  /* Set the vector number offset so that we can calculate\n+     the value that user specifies in the attribute.\n+     We also prepare the category string for first level handler name.  */\n+  switch (nds32_isr_vectors[vector_id].category)\n+    {\n+    case NDS32_ISR_INTERRUPT:\n+      vector_number_offset = 9;\n+      c_str = \"i\";\n+      break;\n+    case NDS32_ISR_EXCEPTION:\n+      vector_number_offset = 0;\n+      c_str = \"e\";\n+      break;\n+    case NDS32_ISR_NONE:\n+    case NDS32_ISR_RESET:\n+      /* Normally it should not be here.  */\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  /* Prepare save reg string for first level handler name.  */\n+  switch (nds32_isr_vectors[vector_id].save_reg)\n+    {\n+    case NDS32_SAVE_ALL:\n+      sr_str = \"sa\";\n+      break;\n+    case NDS32_PARTIAL_SAVE:\n+      sr_str = \"ps\";\n+      break;\n+    }\n+\n+  /* Prepare nested type string for first level handler name.  */\n+  switch (nds32_isr_vectors[vector_id].nested_type)\n+    {\n+    case NDS32_NESTED:\n+      nt_str = \"ns\";\n+      break;\n+    case NDS32_NOT_NESTED:\n+      nt_str = \"nn\";\n+      break;\n+    case NDS32_NESTED_READY:\n+      nt_str = \"nr\";\n+      break;\n+    }\n+\n+  /* Currently we have 4-byte or 16-byte size for each vector.\n+     If it is 4-byte, the first level handler name has suffix string \"_4b\".  */\n+  vs_str = (nds32_isr_vector_size == 4) ? \"_4b\" : \"\";\n+\n+  /* Now we can create first level handler name.  */\n+  snprintf (first_level_handler_name, sizeof (first_level_handler_name),\n+\t    \"_nds32_%s_%s_%s%s\", c_str, sr_str, nt_str, vs_str);\n+\n+  /* Prepare vector section and symbol name.  */\n+  snprintf (section_name, sizeof (section_name),\n+\t    \".nds32_vector.%02d\", vector_id);\n+  snprintf (symbol_name, sizeof (symbol_name),\n+\t    \"_nds32_vector_%02d%s\", vector_id, vs_str);\n+\n+\n+  /* Everything is ready.  We can start emit vector section content.  */\n+  nds32_emit_section_head_template (section_name, symbol_name,\n+\t\t\t\t    floor_log2 (nds32_isr_vector_size), false);\n+\n+  /* According to the vector size, the instructions in the\n+     vector section may be different.  */\n+  if (nds32_isr_vector_size == 4)\n+    {\n+      /* This block is for 4-byte vector size.\n+         Hardware $VID support is necessary and only one instruction\n+         is needed in vector section.  */\n+      fprintf (asm_out_file, \"\\tj\\t%s ! jump to first level handler\\n\",\n+\t\t\t     first_level_handler_name);\n+    }\n+  else\n+    {\n+      /* This block is for 16-byte vector size.\n+         There is NO hardware $VID so that we need several instructions\n+         such as pushing GPRs and preparing software vid at vector section.\n+         For pushing GPRs, there are four variations for\n+         16-byte vector content and we have to handle each combination.\n+         For preparing software vid, note that the vid need to\n+         be substracted vector_number_offset.  */\n+      if (TARGET_REDUCED_REGS)\n+\t{\n+\t  if (nds32_isr_vectors[vector_id].save_reg == NDS32_SAVE_ALL)\n+\t    {\n+\t      /* Case of reduced set registers and save_all attribute.  */\n+\t      fprintf (asm_out_file, \"\\t! reduced set regs + save_all\\n\");\n+\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r15, [$sp], $r15, 0xf\\n\");\n+\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r0, [$sp], $r10, 0x0\\n\");\n+\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Case of reduced set registers and partial_save attribute.  */\n+\t      fprintf (asm_out_file, \"\\t! reduced set regs + partial_save\\n\");\n+\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r15, [$sp], $r15, 0x2\\n\");\n+\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r0, [$sp], $r5, 0x0\\n\");\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (nds32_isr_vectors[vector_id].save_reg == NDS32_SAVE_ALL)\n+\t    {\n+\t      /* Case of full set registers and save_all attribute.  */\n+\t      fprintf (asm_out_file, \"\\t! full set regs + save_all\\n\");\n+\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r0, [$sp], $r27, 0xf\\n\");\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Case of full set registers and partial_save attribute.  */\n+\t      fprintf (asm_out_file, \"\\t! full set regs + partial_save\\n\");\n+\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r15, [$sp], $r27, 0x2\\n\");\n+\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r0, [$sp], $r5, 0x0\\n\");\n+\t    }\n+\t}\n+\n+      fprintf (asm_out_file, \"\\tmovi\\t$r0, %d ! preparing software vid\\n\",\n+\t\t\t     vector_id - vector_number_offset);\n+      fprintf (asm_out_file, \"\\tj\\t%s ! jump to first level handler\\n\",\n+\t\t\t     first_level_handler_name);\n+    }\n+\n+  nds32_emit_section_tail_template (symbol_name);\n+}\n+\n+/* Function to emit isr reset handler content.\n+   Including all jmptbl/vector references, jmptbl section,\n+   vector section, nmi handler section, and warm handler section.  */\n+static void\n+nds32_emit_isr_reset_content (void)\n+{\n+  unsigned int i;\n+  unsigned int total_n_vectors;\n+  const char *vs_str;\n+  char reset_handler_name[100];\n+  char section_name[100];\n+  char symbol_name[100];\n+\n+  total_n_vectors = nds32_isr_vectors[0].total_n_vectors;\n+  vs_str = (nds32_isr_vector_size == 4) ? \"_4b\" : \"\";\n+\n+  fprintf (asm_out_file, \"\\t! RESET HANDLER CONTENT - BEGIN !\\n\");\n+\n+  /* Create references in .rodata according to total number of vectors.  */\n+  fprintf (asm_out_file, \"\\t.section\\t.rodata\\n\");\n+  fprintf (asm_out_file, \"\\t.align\\t2\\n\");\n+\n+  /* Emit jmptbl references.  */\n+  fprintf (asm_out_file, \"\\t ! references to jmptbl section entries\\n\");\n+  for (i = 0; i < total_n_vectors; i++)\n+    fprintf (asm_out_file, \"\\t.word\\t_nds32_jmptbl_%02d\\n\", i);\n+\n+  /* Emit vector references.  */\n+  fprintf (asm_out_file, \"\\t ! references to vector section entries\\n\");\n+  for (i = 0; i < total_n_vectors; i++)\n+    fprintf (asm_out_file, \"\\t.word\\t_nds32_vector_%02d%s\\n\", i, vs_str);\n+\n+  /* Emit jmptbl_00 section.  */\n+  snprintf (section_name, sizeof (section_name), \".nds32_jmptbl.00\");\n+  snprintf (symbol_name, sizeof (symbol_name), \"_nds32_jmptbl_00\");\n+\n+  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n+  nds32_emit_section_head_template (section_name, symbol_name, 2, true);\n+  fprintf (asm_out_file, \"\\t.word\\t%s\\n\",\n+\t\t\t nds32_isr_vectors[0].func_name);\n+  nds32_emit_section_tail_template (symbol_name);\n+\n+  /* Emit vector_00 section.  */\n+  snprintf (section_name, sizeof (section_name), \".nds32_vector.00\");\n+  snprintf (symbol_name, sizeof (symbol_name), \"_nds32_vector_00%s\", vs_str);\n+  snprintf (reset_handler_name, sizeof (reset_handler_name),\n+\t    \"_nds32_reset%s\", vs_str);\n+\n+  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n+  nds32_emit_section_head_template (section_name, symbol_name,\n+\t\t\t\t    floor_log2 (nds32_isr_vector_size), false);\n+  fprintf (asm_out_file, \"\\tj\\t%s ! jump to reset handler\\n\",\n+\t\t\t reset_handler_name);\n+  nds32_emit_section_tail_template (symbol_name);\n+\n+  /* Emit nmi handler section.  */\n+  snprintf (section_name, sizeof (section_name), \".nds32_nmih\");\n+  snprintf (symbol_name, sizeof (symbol_name), \"_nds32_nmih\");\n+\n+  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n+  nds32_emit_section_head_template (section_name, symbol_name, 2, true);\n+  fprintf (asm_out_file, \"\\t.word\\t%s\\n\",\n+\t\t\t (strlen (nds32_isr_vectors[0].nmi_name) == 0)\n+\t\t\t ? \"0\"\n+\t\t\t : nds32_isr_vectors[0].nmi_name);\n+  nds32_emit_section_tail_template (symbol_name);\n+\n+  /* Emit warm handler section.  */\n+  snprintf (section_name, sizeof (section_name), \".nds32_wrh\");\n+  snprintf (symbol_name, sizeof (symbol_name), \"_nds32_wrh\");\n+\n+  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n+  nds32_emit_section_head_template (section_name, symbol_name, 2, true);\n+  fprintf (asm_out_file, \"\\t.word\\t%s\\n\",\n+\t\t\t (strlen (nds32_isr_vectors[0].warm_name) == 0)\n+\t\t\t ? \"0\"\n+\t\t\t : nds32_isr_vectors[0].warm_name);\n+  nds32_emit_section_tail_template (symbol_name);\n+\n+  fprintf (asm_out_file, \"\\t! RESET HANDLER CONTENT - END !\\n\");\n+}\n+\n+/* Function for nds32_merge_decl_attributes() and nds32_insert_attributes()\n+   to check if there are any conflict isr-specific attributes being set.\n+   We need to check:\n+     1. Only 'save_all' or 'partial_save' in the attributes.\n+     2. Only 'nested', 'not_nested', or 'nested_ready' in the attributes.\n+     3. Only 'interrupt', 'exception', or 'reset' in the attributes.  */\n+void\n+nds32_check_isr_attrs_conflict (tree func_decl, tree func_attrs)\n+{\n+  int save_all_p, partial_save_p;\n+  int nested_p, not_nested_p, nested_ready_p;\n+  int intr_p, excp_p, reset_p;\n+\n+  /* Initialize variables.  */\n+  save_all_p = partial_save_p = 0;\n+  nested_p = not_nested_p = nested_ready_p = 0;\n+  intr_p = excp_p = reset_p = 0;\n+\n+  /* We must check at MOST one attribute to set save-reg.  */\n+  if (lookup_attribute (\"save_all\", func_attrs))\n+    save_all_p = 1;\n+  if (lookup_attribute (\"partial_save\", func_attrs))\n+    partial_save_p = 1;\n+\n+  if ((save_all_p + partial_save_p) > 1)\n+    error (\"multiple save reg attributes to function %qD\", func_decl);\n+\n+  /* We must check at MOST one attribute to set nested-type.  */\n+  if (lookup_attribute (\"nested\", func_attrs))\n+    nested_p = 1;\n+  if (lookup_attribute (\"not_nested\", func_attrs))\n+    not_nested_p = 1;\n+  if (lookup_attribute (\"nested_ready\", func_attrs))\n+    nested_ready_p = 1;\n+\n+  if ((nested_p + not_nested_p + nested_ready_p) > 1)\n+    error (\"multiple nested types attributes to function %qD\", func_decl);\n+\n+  /* We must check at MOST one attribute to\n+     set interrupt/exception/reset.  */\n+  if (lookup_attribute (\"interrupt\", func_attrs))\n+    intr_p = 1;\n+  if (lookup_attribute (\"exception\", func_attrs))\n+    excp_p = 1;\n+  if (lookup_attribute (\"reset\", func_attrs))\n+    reset_p = 1;\n+\n+  if ((intr_p + excp_p + reset_p) > 1)\n+    error (\"multiple interrupt attributes to function %qD\", func_decl);\n+}\n+\n+/* Function to construct isr vectors information array.\n+   We DO NOT HAVE TO check if the attributes are valid\n+   because those works are supposed to be done on\n+   nds32_merge_decl_attributes() and nds32_insert_attributes().  */\n+void\n+nds32_construct_isr_vectors_information (tree func_attrs,\n+\t\t\t\t\t const char *func_name)\n+{\n+  tree save_all, partial_save;\n+  tree nested, not_nested, nested_ready;\n+  tree intr, excp, reset;\n+\n+  save_all     = lookup_attribute (\"save_all\", func_attrs);\n+  partial_save = lookup_attribute (\"partial_save\", func_attrs);\n+\n+  nested       = lookup_attribute (\"nested\", func_attrs);\n+  not_nested   = lookup_attribute (\"not_nested\", func_attrs);\n+  nested_ready = lookup_attribute (\"nested_ready\", func_attrs);\n+\n+  intr  = lookup_attribute (\"interrupt\", func_attrs);\n+  excp  = lookup_attribute (\"exception\", func_attrs);\n+  reset = lookup_attribute (\"reset\", func_attrs);\n+\n+  /* If there is no interrupt/exception/reset, we can return immediately.  */\n+  if (!intr && !excp && !reset)\n+    return;\n+\n+  /* If we are here, either we have interrupt/exception,\n+     or reset attribute.  */\n+  if (intr || excp)\n+    {\n+      tree id_list;\n+\n+      /* Prepare id list so that we can traverse and set vector id.  */\n+      id_list = (intr) ? (TREE_VALUE (intr)) : (TREE_VALUE (excp));\n+\n+      while (id_list)\n+\t{\n+\t  tree id;\n+\t  int vector_id;\n+\t  unsigned int vector_number_offset;\n+\n+\t  /* The way to handle interrupt or exception is the same,\n+\t     we just need to take care of actual vector number.\n+\t     For interrupt(0..63), the actual vector number is (9..72).\n+\t     For exception(1..8), the actual vector number is (1..8).  */\n+\t  vector_number_offset = (intr) ? (9) : (0);\n+\n+\t  /* Pick up each vector id value.  */\n+\t  id = TREE_VALUE (id_list);\n+\t  /* Add vector_number_offset to get actual vector number.  */\n+\t  vector_id = TREE_INT_CST_LOW (id) + vector_number_offset;\n+\n+\t  /* Enable corresponding vector and set function name.  */\n+\t  nds32_isr_vectors[vector_id].category = (intr)\n+\t\t\t\t\t\t  ? (NDS32_ISR_INTERRUPT)\n+\t\t\t\t\t\t  : (NDS32_ISR_EXCEPTION);\n+\t  strcpy (nds32_isr_vectors[vector_id].func_name, func_name);\n+\n+\t  /* Set register saving scheme.  */\n+\t  if (save_all)\n+\t    nds32_isr_vectors[vector_id].save_reg = NDS32_SAVE_ALL;\n+\t  else if (partial_save)\n+\t    nds32_isr_vectors[vector_id].save_reg = NDS32_PARTIAL_SAVE;\n+\n+\t  /* Set nested type.  */\n+\t  if (nested)\n+\t    nds32_isr_vectors[vector_id].nested_type = NDS32_NESTED;\n+\t  else if (not_nested)\n+\t    nds32_isr_vectors[vector_id].nested_type = NDS32_NOT_NESTED;\n+\t  else if (nested_ready)\n+\t    nds32_isr_vectors[vector_id].nested_type = NDS32_NESTED_READY;\n+\n+\t  /* Advance to next id.  */\n+\t  id_list = TREE_CHAIN (id_list);\n+\t}\n+    }\n+  else\n+    {\n+      tree id_list;\n+      tree id;\n+      tree nmi, warm;\n+\n+      /* Deal with reset attribute.  Its vector number is always 0.  */\n+      nds32_isr_vectors[0].category = NDS32_ISR_RESET;\n+\n+      /* Prepare id_list and identify id value so that\n+         we can set total number of vectors.  */\n+      id_list = TREE_VALUE (reset);\n+      id = TREE_VALUE (id_list);\n+\n+      /* The total vectors = interrupt + exception numbers + reset.\n+         There are 8 exception and 1 reset in nds32 architecture.  */\n+      nds32_isr_vectors[0].total_n_vectors = TREE_INT_CST_LOW (id) + 8 + 1;\n+      strcpy (nds32_isr_vectors[0].func_name, func_name);\n+\n+      /* Retrieve nmi and warm function.  */\n+      nmi  = lookup_attribute (\"nmi\", func_attrs);\n+      warm = lookup_attribute (\"warm\", func_attrs);\n+\n+      if (nmi != NULL_TREE)\n+\t{\n+\t  tree nmi_func_list;\n+\t  tree nmi_func;\n+\n+\t  nmi_func_list = TREE_VALUE (nmi);\n+\t  nmi_func = TREE_VALUE (nmi_func_list);\n+\n+\t  /* Record nmi function name.  */\n+\t  strcpy (nds32_isr_vectors[0].nmi_name,\n+\t\t  IDENTIFIER_POINTER (nmi_func));\n+\t}\n+\n+      if (warm != NULL_TREE)\n+\t{\n+\t  tree warm_func_list;\n+\t  tree warm_func;\n+\n+\t  warm_func_list = TREE_VALUE (warm);\n+\t  warm_func = TREE_VALUE (warm_func_list);\n+\n+\t  /* Record warm function name.  */\n+\t  strcpy (nds32_isr_vectors[0].warm_name,\n+\t\t  IDENTIFIER_POINTER (warm_func));\n+\t}\n+    }\n+}\n+\n+/* A helper function to handle isr stuff at the beginning of asm file.  */\n+void\n+nds32_asm_file_start_for_isr (void)\n+{\n+  int i;\n+\n+  /* Initialize isr vector information array before compiling functions.  */\n+  for (i = 0; i < NDS32_N_ISR_VECTORS; i++)\n+    {\n+      nds32_isr_vectors[i].category = NDS32_ISR_NONE;\n+      strcpy (nds32_isr_vectors[i].func_name, \"\");\n+      nds32_isr_vectors[i].save_reg = NDS32_PARTIAL_SAVE;\n+      nds32_isr_vectors[i].nested_type = NDS32_NOT_NESTED;\n+      nds32_isr_vectors[i].total_n_vectors = 0;\n+      strcpy (nds32_isr_vectors[i].nmi_name, \"\");\n+      strcpy (nds32_isr_vectors[i].warm_name, \"\");\n+    }\n+}\n+\n+/* A helper function to handle isr stuff at the end of asm file.  */\n+void\n+nds32_asm_file_end_for_isr (void)\n+{\n+  int i;\n+\n+  /* If all the vectors are NDS32_ISR_NONE, we can return immediately.  */\n+  for (i = 0; i < NDS32_N_ISR_VECTORS; i++)\n+    if (nds32_isr_vectors[i].category != NDS32_ISR_NONE)\n+      break;\n+\n+  if (i == NDS32_N_ISR_VECTORS)\n+    return;\n+\n+  /* At least one vector is NOT NDS32_ISR_NONE,\n+     we should output isr vector information.  */\n+  fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n+  fprintf (asm_out_file, \"\\t! The isr vector information:\\n\");\n+  fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n+\n+  /* Check reset handler first.  Its vector number is always 0.  */\n+  if (nds32_isr_vectors[0].category == NDS32_ISR_RESET)\n+    {\n+      nds32_emit_isr_reset_content ();\n+      fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n+    }\n+\n+  /* Check other vectors, starting from vector number 1.  */\n+  for (i = 1; i < NDS32_N_ISR_VECTORS; i++)\n+    {\n+      if (nds32_isr_vectors[i].category == NDS32_ISR_INTERRUPT\n+\t  || nds32_isr_vectors[i].category == NDS32_ISR_EXCEPTION)\n+\t{\n+\t  /* Found one vector which is interupt or exception.\n+\t     Output its jmptbl and vector section content.  */\n+\t  fprintf (asm_out_file, \"\\t! interrupt/exception vector %02d\\n\", i);\n+\t  fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n+\t  nds32_emit_isr_jmptbl_section (i);\n+\t  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n+\t  nds32_emit_isr_vector_section (i);\n+\t  fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n+\t}\n+    }\n+}\n+\n+/* ------------------------------------------------------------------------ */"}, {"sha": "f5b15abe69ba066cfac146105fb8af76b8aa980c", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23a919b860940e2d0a77709ea8076ae59e036a3/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23a919b860940e2d0a77709ea8076ae59e036a3/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=c23a919b860940e2d0a77709ea8076ae59e036a3", "patch": "@@ -125,4 +125,11 @@ extern const char *nds32_output_stack_pop (void);\n \n extern int nds32_target_alignment (rtx);\n \n+/* Auxiliary functions for ISR implementation.  */\n+\n+extern void nds32_check_isr_attrs_conflict (tree, tree);\n+extern void nds32_construct_isr_vectors_information (tree, const char *);\n+extern void nds32_asm_file_start_for_isr (void);\n+extern void nds32_asm_file_end_for_isr (void);\n+\n /* ------------------------------------------------------------------------ */"}, {"sha": "746a5e193875ebd86196a4edcbbfb61a07bf3330", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 2, "deletions": 506, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c23a919b860940e2d0a77709ea8076ae59e036a3/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c23a919b860940e2d0a77709ea8076ae59e036a3/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=c23a919b860940e2d0a77709ea8076ae59e036a3", "patch": "@@ -73,13 +73,6 @@\n /* PART 1: Auxiliary static variable definitions and\n            target hook static variable definitions.  */\n \n-/* Refer to nds32.h, there are maximum 73 isr vectors in nds32 architecture.\n-   0 for reset handler with __attribute__((reset())),\n-   1-8 for exception handler with __attribute__((exception(1,...,8))),\n-   and 9-72 for interrupt handler with __attribute__((interrupt(0,...,63))).\n-   We use an array to record essential information for each vector.  */\n-static struct nds32_isr_info nds32_isr_vectors[NDS32_N_ISR_VECTORS];\n-\n /* Define intrinsic register names.\n    Please refer to nds32_intrinsic.h file, the index is corresponding to\n    'enum nds32_intrinsic_registers' data type values.\n@@ -907,453 +900,6 @@ nds32_consecutive_registers_load_store_p (rtx op,\n   return true;\n }\n \n-/* A helper function to emit section head template.  */\n-static void\n-nds32_emit_section_head_template (char section_name[],\n-\t\t\t\t  char symbol_name[],\n-\t\t\t\t  int align_value,\n-\t\t\t\t  bool object_p)\n-{\n-  const char *flags_str;\n-  const char *type_str;\n-\n-  flags_str = (object_p) ? \"\\\"a\\\"\" : \"\\\"ax\\\"\";\n-  type_str = (object_p) ? \"@object\" : \"@function\";\n-\n-  fprintf (asm_out_file, \"\\t.section\\t%s, %s\\n\", section_name, flags_str);\n-  fprintf (asm_out_file, \"\\t.align\\t%d\\n\", align_value);\n-  fprintf (asm_out_file, \"\\t.global\\t%s\\n\", symbol_name);\n-  fprintf (asm_out_file, \"\\t.type\\t%s, %s\\n\", symbol_name, type_str);\n-  fprintf (asm_out_file, \"%s:\\n\", symbol_name);\n-}\n-\n-/* A helper function to emit section tail template.  */\n-static void\n-nds32_emit_section_tail_template (char symbol_name[])\n-{\n-  fprintf (asm_out_file, \"\\t.size\\t%s, .-%s\\n\", symbol_name, symbol_name);\n-}\n-\n-/* Function to emit isr jump table section.  */\n-static void\n-nds32_emit_isr_jmptbl_section (int vector_id)\n-{\n-  char section_name[100];\n-  char symbol_name[100];\n-\n-  /* Prepare jmptbl section and symbol name.  */\n-  snprintf (section_name, sizeof (section_name),\n-\t    \".nds32_jmptbl.%02d\", vector_id);\n-  snprintf (symbol_name, sizeof (symbol_name),\n-\t    \"_nds32_jmptbl_%02d\", vector_id);\n-\n-  nds32_emit_section_head_template (section_name, symbol_name, 2, true);\n-  fprintf (asm_out_file, \"\\t.word\\t%s\\n\",\n-\t\t\t nds32_isr_vectors[vector_id].func_name);\n-  nds32_emit_section_tail_template (symbol_name);\n-}\n-\n-/* Function to emit isr vector section.  */\n-static void\n-nds32_emit_isr_vector_section (int vector_id)\n-{\n-  unsigned int vector_number_offset = 0;\n-  const char *c_str = \"CATEGORY\";\n-  const char *sr_str = \"SR\";\n-  const char *nt_str = \"NT\";\n-  const char *vs_str = \"VS\";\n-  char first_level_handler_name[100];\n-  char section_name[100];\n-  char symbol_name[100];\n-\n-  /* Set the vector number offset so that we can calculate\n-     the value that user specifies in the attribute.\n-     We also prepare the category string for first level handler name.  */\n-  switch (nds32_isr_vectors[vector_id].category)\n-    {\n-    case NDS32_ISR_INTERRUPT:\n-      vector_number_offset = 9;\n-      c_str = \"i\";\n-      break;\n-    case NDS32_ISR_EXCEPTION:\n-      vector_number_offset = 0;\n-      c_str = \"e\";\n-      break;\n-    case NDS32_ISR_NONE:\n-    case NDS32_ISR_RESET:\n-      /* Normally it should not be here.  */\n-      gcc_unreachable ();\n-      break;\n-    }\n-\n-  /* Prepare save reg string for first level handler name.  */\n-  switch (nds32_isr_vectors[vector_id].save_reg)\n-    {\n-    case NDS32_SAVE_ALL:\n-      sr_str = \"sa\";\n-      break;\n-    case NDS32_PARTIAL_SAVE:\n-      sr_str = \"ps\";\n-      break;\n-    }\n-\n-  /* Prepare nested type string for first level handler name.  */\n-  switch (nds32_isr_vectors[vector_id].nested_type)\n-    {\n-    case NDS32_NESTED:\n-      nt_str = \"ns\";\n-      break;\n-    case NDS32_NOT_NESTED:\n-      nt_str = \"nn\";\n-      break;\n-    case NDS32_NESTED_READY:\n-      nt_str = \"nr\";\n-      break;\n-    }\n-\n-  /* Currently we have 4-byte or 16-byte size for each vector.\n-     If it is 4-byte, the first level handler name has suffix string \"_4b\".  */\n-  vs_str = (nds32_isr_vector_size == 4) ? \"_4b\" : \"\";\n-\n-  /* Now we can create first level handler name.  */\n-  snprintf (first_level_handler_name, sizeof (first_level_handler_name),\n-\t    \"_nds32_%s_%s_%s%s\", c_str, sr_str, nt_str, vs_str);\n-\n-  /* Prepare vector section and symbol name.  */\n-  snprintf (section_name, sizeof (section_name),\n-\t    \".nds32_vector.%02d\", vector_id);\n-  snprintf (symbol_name, sizeof (symbol_name),\n-\t    \"_nds32_vector_%02d%s\", vector_id, vs_str);\n-\n-\n-  /* Everything is ready.  We can start emit vector section content.  */\n-  nds32_emit_section_head_template (section_name, symbol_name,\n-\t\t\t\t    floor_log2 (nds32_isr_vector_size), false);\n-\n-  /* According to the vector size, the instructions in the\n-     vector section may be different.  */\n-  if (nds32_isr_vector_size == 4)\n-    {\n-      /* This block is for 4-byte vector size.\n-         Hardware $VID support is necessary and only one instruction\n-         is needed in vector section.  */\n-      fprintf (asm_out_file, \"\\tj\\t%s ! jump to first level handler\\n\",\n-\t\t\t     first_level_handler_name);\n-    }\n-  else\n-    {\n-      /* This block is for 16-byte vector size.\n-         There is NO hardware $VID so that we need several instructions\n-         such as pushing GPRs and preparing software vid at vector section.\n-         For pushing GPRs, there are four variations for\n-         16-byte vector content and we have to handle each combination.\n-         For preparing software vid, note that the vid need to\n-         be substracted vector_number_offset.  */\n-      if (TARGET_REDUCED_REGS)\n-\t{\n-\t  if (nds32_isr_vectors[vector_id].save_reg == NDS32_SAVE_ALL)\n-\t    {\n-\t      /* Case of reduced set registers and save_all attribute.  */\n-\t      fprintf (asm_out_file, \"\\t! reduced set regs + save_all\\n\");\n-\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r15, [$sp], $r15, 0xf\\n\");\n-\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r0, [$sp], $r10, 0x0\\n\");\n-\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Case of reduced set registers and partial_save attribute.  */\n-\t      fprintf (asm_out_file, \"\\t! reduced set regs + partial_save\\n\");\n-\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r15, [$sp], $r15, 0x2\\n\");\n-\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r0, [$sp], $r5, 0x0\\n\");\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (nds32_isr_vectors[vector_id].save_reg == NDS32_SAVE_ALL)\n-\t    {\n-\t      /* Case of full set registers and save_all attribute.  */\n-\t      fprintf (asm_out_file, \"\\t! full set regs + save_all\\n\");\n-\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r0, [$sp], $r27, 0xf\\n\");\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Case of full set registers and partial_save attribute.  */\n-\t      fprintf (asm_out_file, \"\\t! full set regs + partial_save\\n\");\n-\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r15, [$sp], $r27, 0x2\\n\");\n-\t      fprintf (asm_out_file, \"\\tsmw.adm\\t$r0, [$sp], $r5, 0x0\\n\");\n-\t    }\n-\t}\n-\n-      fprintf (asm_out_file, \"\\tmovi\\t$r0, %d ! preparing software vid\\n\",\n-\t\t\t     vector_id - vector_number_offset);\n-      fprintf (asm_out_file, \"\\tj\\t%s ! jump to first level handler\\n\",\n-\t\t\t     first_level_handler_name);\n-    }\n-\n-  nds32_emit_section_tail_template (symbol_name);\n-}\n-\n-/* Function to emit isr reset handler content.\n-   Including all jmptbl/vector references, jmptbl section,\n-   vector section, nmi handler section, and warm handler section.  */\n-static void\n-nds32_emit_isr_reset_content (void)\n-{\n-  unsigned int i;\n-  unsigned int total_n_vectors;\n-  const char *vs_str;\n-  char reset_handler_name[100];\n-  char section_name[100];\n-  char symbol_name[100];\n-\n-  total_n_vectors = nds32_isr_vectors[0].total_n_vectors;\n-  vs_str = (nds32_isr_vector_size == 4) ? \"_4b\" : \"\";\n-\n-  fprintf (asm_out_file, \"\\t! RESET HANDLER CONTENT - BEGIN !\\n\");\n-\n-  /* Create references in .rodata according to total number of vectors.  */\n-  fprintf (asm_out_file, \"\\t.section\\t.rodata\\n\");\n-  fprintf (asm_out_file, \"\\t.align\\t2\\n\");\n-\n-  /* Emit jmptbl references.  */\n-  fprintf (asm_out_file, \"\\t ! references to jmptbl section entries\\n\");\n-  for (i = 0; i < total_n_vectors; i++)\n-    fprintf (asm_out_file, \"\\t.word\\t_nds32_jmptbl_%02d\\n\", i);\n-\n-  /* Emit vector references.  */\n-  fprintf (asm_out_file, \"\\t ! references to vector section entries\\n\");\n-  for (i = 0; i < total_n_vectors; i++)\n-    fprintf (asm_out_file, \"\\t.word\\t_nds32_vector_%02d%s\\n\", i, vs_str);\n-\n-  /* Emit jmptbl_00 section.  */\n-  snprintf (section_name, sizeof (section_name), \".nds32_jmptbl.00\");\n-  snprintf (symbol_name, sizeof (symbol_name), \"_nds32_jmptbl_00\");\n-\n-  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n-  nds32_emit_section_head_template (section_name, symbol_name, 2, true);\n-  fprintf (asm_out_file, \"\\t.word\\t%s\\n\",\n-\t\t\t nds32_isr_vectors[0].func_name);\n-  nds32_emit_section_tail_template (symbol_name);\n-\n-  /* Emit vector_00 section.  */\n-  snprintf (section_name, sizeof (section_name), \".nds32_vector.00\");\n-  snprintf (symbol_name, sizeof (symbol_name), \"_nds32_vector_00%s\", vs_str);\n-  snprintf (reset_handler_name, sizeof (reset_handler_name),\n-\t    \"_nds32_reset%s\", vs_str);\n-\n-  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n-  nds32_emit_section_head_template (section_name, symbol_name,\n-\t\t\t\t    floor_log2 (nds32_isr_vector_size), false);\n-  fprintf (asm_out_file, \"\\tj\\t%s ! jump to reset handler\\n\",\n-\t\t\t reset_handler_name);\n-  nds32_emit_section_tail_template (symbol_name);\n-\n-  /* Emit nmi handler section.  */\n-  snprintf (section_name, sizeof (section_name), \".nds32_nmih\");\n-  snprintf (symbol_name, sizeof (symbol_name), \"_nds32_nmih\");\n-\n-  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n-  nds32_emit_section_head_template (section_name, symbol_name, 2, true);\n-  fprintf (asm_out_file, \"\\t.word\\t%s\\n\",\n-\t\t\t (strlen (nds32_isr_vectors[0].nmi_name) == 0)\n-\t\t\t ? \"0\"\n-\t\t\t : nds32_isr_vectors[0].nmi_name);\n-  nds32_emit_section_tail_template (symbol_name);\n-\n-  /* Emit warm handler section.  */\n-  snprintf (section_name, sizeof (section_name), \".nds32_wrh\");\n-  snprintf (symbol_name, sizeof (symbol_name), \"_nds32_wrh\");\n-\n-  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n-  nds32_emit_section_head_template (section_name, symbol_name, 2, true);\n-  fprintf (asm_out_file, \"\\t.word\\t%s\\n\",\n-\t\t\t (strlen (nds32_isr_vectors[0].warm_name) == 0)\n-\t\t\t ? \"0\"\n-\t\t\t : nds32_isr_vectors[0].warm_name);\n-  nds32_emit_section_tail_template (symbol_name);\n-\n-  fprintf (asm_out_file, \"\\t! RESET HANDLER CONTENT - END !\\n\");\n-}\n-\n-/* Function for nds32_merge_decl_attributes() and nds32_insert_attributes()\n-   to check if there are any conflict isr-specific attributes being set.\n-   We need to check:\n-     1. Only 'save_all' or 'partial_save' in the attributes.\n-     2. Only 'nested', 'not_nested', or 'nested_ready' in the attributes.\n-     3. Only 'interrupt', 'exception', or 'reset' in the attributes.  */\n-static void\n-nds32_check_isr_attrs_conflict (tree func_decl, tree func_attrs)\n-{\n-  int save_all_p, partial_save_p;\n-  int nested_p, not_nested_p, nested_ready_p;\n-  int intr_p, excp_p, reset_p;\n-\n-  /* Initialize variables.  */\n-  save_all_p = partial_save_p = 0;\n-  nested_p = not_nested_p = nested_ready_p = 0;\n-  intr_p = excp_p = reset_p = 0;\n-\n-  /* We must check at MOST one attribute to set save-reg.  */\n-  if (lookup_attribute (\"save_all\", func_attrs))\n-    save_all_p = 1;\n-  if (lookup_attribute (\"partial_save\", func_attrs))\n-    partial_save_p = 1;\n-\n-  if ((save_all_p + partial_save_p) > 1)\n-    error (\"multiple save reg attributes to function %qD\", func_decl);\n-\n-  /* We must check at MOST one attribute to set nested-type.  */\n-  if (lookup_attribute (\"nested\", func_attrs))\n-    nested_p = 1;\n-  if (lookup_attribute (\"not_nested\", func_attrs))\n-    not_nested_p = 1;\n-  if (lookup_attribute (\"nested_ready\", func_attrs))\n-    nested_ready_p = 1;\n-\n-  if ((nested_p + not_nested_p + nested_ready_p) > 1)\n-    error (\"multiple nested types attributes to function %qD\", func_decl);\n-\n-  /* We must check at MOST one attribute to\n-     set interrupt/exception/reset.  */\n-  if (lookup_attribute (\"interrupt\", func_attrs))\n-    intr_p = 1;\n-  if (lookup_attribute (\"exception\", func_attrs))\n-    excp_p = 1;\n-  if (lookup_attribute (\"reset\", func_attrs))\n-    reset_p = 1;\n-\n-  if ((intr_p + excp_p + reset_p) > 1)\n-    error (\"multiple interrupt attributes to function %qD\", func_decl);\n-}\n-\n-/* Function to construct isr vectors information array.\n-   We DO NOT HAVE TO check if the attributes are valid\n-   because those works are supposed to be done on\n-   nds32_merge_decl_attributes() and nds32_insert_attributes().  */\n-static void\n-nds32_construct_isr_vectors_information (tree func_attrs,\n-\t\t\t\t\t const char *func_name)\n-{\n-  tree save_all, partial_save;\n-  tree nested, not_nested, nested_ready;\n-  tree intr, excp, reset;\n-\n-  save_all     = lookup_attribute (\"save_all\", func_attrs);\n-  partial_save = lookup_attribute (\"partial_save\", func_attrs);\n-\n-  nested       = lookup_attribute (\"nested\", func_attrs);\n-  not_nested   = lookup_attribute (\"not_nested\", func_attrs);\n-  nested_ready = lookup_attribute (\"nested_ready\", func_attrs);\n-\n-  intr  = lookup_attribute (\"interrupt\", func_attrs);\n-  excp  = lookup_attribute (\"exception\", func_attrs);\n-  reset = lookup_attribute (\"reset\", func_attrs);\n-\n-  /* If there is no interrupt/exception/reset, we can return immediately.  */\n-  if (!intr && !excp && !reset)\n-    return;\n-\n-  /* If we are here, either we have interrupt/exception,\n-     or reset attribute.  */\n-  if (intr || excp)\n-    {\n-      tree id_list;\n-\n-      /* Prepare id list so that we can traverse and set vector id.  */\n-      id_list = (intr) ? (TREE_VALUE (intr)) : (TREE_VALUE (excp));\n-\n-      while (id_list)\n-\t{\n-\t  tree id;\n-\t  int vector_id;\n-\t  unsigned int vector_number_offset;\n-\n-\t  /* The way to handle interrupt or exception is the same,\n-\t     we just need to take care of actual vector number.\n-\t     For interrupt(0..63), the actual vector number is (9..72).\n-\t     For exception(1..8), the actual vector number is (1..8).  */\n-\t  vector_number_offset = (intr) ? (9) : (0);\n-\n-\t  /* Pick up each vector id value.  */\n-\t  id = TREE_VALUE (id_list);\n-\t  /* Add vector_number_offset to get actual vector number.  */\n-\t  vector_id = TREE_INT_CST_LOW (id) + vector_number_offset;\n-\n-\t  /* Enable corresponding vector and set function name.  */\n-\t  nds32_isr_vectors[vector_id].category = (intr)\n-\t\t\t\t\t\t  ? (NDS32_ISR_INTERRUPT)\n-\t\t\t\t\t\t  : (NDS32_ISR_EXCEPTION);\n-\t  strcpy (nds32_isr_vectors[vector_id].func_name, func_name);\n-\n-\t  /* Set register saving scheme.  */\n-\t  if (save_all)\n-\t    nds32_isr_vectors[vector_id].save_reg = NDS32_SAVE_ALL;\n-\t  else if (partial_save)\n-\t    nds32_isr_vectors[vector_id].save_reg = NDS32_PARTIAL_SAVE;\n-\n-\t  /* Set nested type.  */\n-\t  if (nested)\n-\t    nds32_isr_vectors[vector_id].nested_type = NDS32_NESTED;\n-\t  else if (not_nested)\n-\t    nds32_isr_vectors[vector_id].nested_type = NDS32_NOT_NESTED;\n-\t  else if (nested_ready)\n-\t    nds32_isr_vectors[vector_id].nested_type = NDS32_NESTED_READY;\n-\n-\t  /* Advance to next id.  */\n-\t  id_list = TREE_CHAIN (id_list);\n-\t}\n-    }\n-  else\n-    {\n-      tree id_list;\n-      tree id;\n-      tree nmi, warm;\n-\n-      /* Deal with reset attribute.  Its vector number is always 0.  */\n-      nds32_isr_vectors[0].category = NDS32_ISR_RESET;\n-\n-      /* Prepare id_list and identify id value so that\n-         we can set total number of vectors.  */\n-      id_list = TREE_VALUE (reset);\n-      id = TREE_VALUE (id_list);\n-\n-      /* The total vectors = interrupt + exception numbers + reset.\n-         There are 8 exception and 1 reset in nds32 architecture.  */\n-      nds32_isr_vectors[0].total_n_vectors = TREE_INT_CST_LOW (id) + 8 + 1;\n-      strcpy (nds32_isr_vectors[0].func_name, func_name);\n-\n-      /* Retrieve nmi and warm function.  */\n-      nmi  = lookup_attribute (\"nmi\", func_attrs);\n-      warm = lookup_attribute (\"warm\", func_attrs);\n-\n-      if (nmi != NULL_TREE)\n-\t{\n-\t  tree nmi_func_list;\n-\t  tree nmi_func;\n-\n-\t  nmi_func_list = TREE_VALUE (nmi);\n-\t  nmi_func = TREE_VALUE (nmi_func_list);\n-\n-\t  /* Record nmi function name.  */\n-\t  strcpy (nds32_isr_vectors[0].nmi_name,\n-\t\t  IDENTIFIER_POINTER (nmi_func));\n-\t}\n-\n-      if (warm != NULL_TREE)\n-\t{\n-\t  tree warm_func_list;\n-\t  tree warm_func;\n-\n-\t  warm_func_list = TREE_VALUE (warm);\n-\t  warm_func = TREE_VALUE (warm_func_list);\n-\n-\t  /* Record warm function name.  */\n-\t  strcpy (nds32_isr_vectors[0].warm_name,\n-\t\t  IDENTIFIER_POINTER (warm_func));\n-\t}\n-    }\n-}\n-\n /* Function that may creates more instructions\n    for large value on adjusting stack pointer.\n \n@@ -2655,8 +2201,6 @@ static int nds32_address_cost (rtx address,\n static void\n nds32_asm_file_start (void)\n {\n-  int i;\n-\n   default_file_start ();\n \n   /* Tell assembler which ABI we are using.  */\n@@ -2742,61 +2286,13 @@ nds32_asm_file_start (void)\n \n   fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n \n-  /* Initialize isr vector information array before compiling functions.  */\n-  for (i = 0; i < NDS32_N_ISR_VECTORS; i++)\n-    {\n-      nds32_isr_vectors[i].category = NDS32_ISR_NONE;\n-      strcpy (nds32_isr_vectors[i].func_name, \"\");\n-      nds32_isr_vectors[i].save_reg = NDS32_PARTIAL_SAVE;\n-      nds32_isr_vectors[i].nested_type = NDS32_NOT_NESTED;\n-      nds32_isr_vectors[i].total_n_vectors = 0;\n-      strcpy (nds32_isr_vectors[i].nmi_name, \"\");\n-      strcpy (nds32_isr_vectors[i].warm_name, \"\");\n-    }\n+  nds32_asm_file_start_for_isr ();\n }\n \n static void\n nds32_asm_file_end (void)\n {\n-  int i;\n-\n-  /* If all the vectors are NDS32_ISR_NONE, we can return immediately.  */\n-  for (i = 0; i < NDS32_N_ISR_VECTORS; i++)\n-    if (nds32_isr_vectors[i].category != NDS32_ISR_NONE)\n-      break;\n-\n-  if (i == NDS32_N_ISR_VECTORS)\n-    return;\n-\n-  /* At least one vector is NOT NDS32_ISR_NONE,\n-     we should output isr vector information.  */\n-  fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n-  fprintf (asm_out_file, \"\\t! The isr vector information:\\n\");\n-  fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n-\n-  /* Check reset handler first.  Its vector number is always 0.  */\n-  if (nds32_isr_vectors[0].category == NDS32_ISR_RESET)\n-    {\n-      nds32_emit_isr_reset_content ();\n-      fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n-    }\n-\n-  /* Check other vectors, starting from vector number 1.  */\n-  for (i = 1; i < NDS32_N_ISR_VECTORS; i++)\n-    {\n-      if (nds32_isr_vectors[i].category == NDS32_ISR_INTERRUPT\n-\t  || nds32_isr_vectors[i].category == NDS32_ISR_EXCEPTION)\n-\t{\n-\t  /* Found one vector which is interupt or exception.\n-\t     Output its jmptbl and vector section content.  */\n-\t  fprintf (asm_out_file, \"\\t! interrupt/exception vector %02d\\n\", i);\n-\t  fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n-\t  nds32_emit_isr_jmptbl_section (i);\n-\t  fprintf (asm_out_file, \"\\t! ....................................\\n\");\n-\t  nds32_emit_isr_vector_section (i);\n-\t  fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n-\t}\n-    }\n+  nds32_asm_file_end_for_isr ();\n \n   fprintf (asm_out_file, \"\\t! ------------------------------------\\n\");\n }"}]}