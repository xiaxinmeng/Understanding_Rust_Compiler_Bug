{"sha": "ae6dca8c651783208564001c56786f3abc762cf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU2ZGNhOGM2NTE3ODMyMDg1NjQwMDFjNTY3ODZmM2FiYzc2MmNmMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-03-20T08:14:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-03-20T08:14:42Z"}, "message": "re PR target/84945 (UBSAN: gcc/config/i386/i386.c:33312:22: runtime error: shift exponent 32 is too large for 32-bit type 'int')\n\n\tPR target/84945\n\t* config/i386/i386.c (fold_builtin_cpu): For features above 31\n\tuse __cpu_features2 variable instead of __cpu_model.__cpu_features[0].\n\tUse 1U instead of 1.  Formatting fixes.\n\n\t* gcc.target/i386/pr84945.c: New test.\n\n\t* config/i386/cpuinfo.h (__cpu_features2): Declare.\n\t* config/i386/cpuinfo.c (__cpu_features2): New variable for\n\tifndef SHARED only.\n\t(set_feature): Define.\n\t(get_available_features): Use set_feature macro.  Set __cpu_features2\n\tto the second word of features ifndef SHARED.\n\nFrom-SVN: r258673", "tree": {"sha": "434aa97e62aef6d534c2885c7c96fb7a40824a55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/434aa97e62aef6d534c2885c7c96fb7a40824a55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae6dca8c651783208564001c56786f3abc762cf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae6dca8c651783208564001c56786f3abc762cf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae6dca8c651783208564001c56786f3abc762cf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae6dca8c651783208564001c56786f3abc762cf3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18c5bc3f908b51b44b1b35ece40052221122fe0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18c5bc3f908b51b44b1b35ece40052221122fe0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18c5bc3f908b51b44b1b35ece40052221122fe0c"}], "stats": {"total": 149, "additions": 108, "deletions": 41}, "files": [{"sha": "f7829760592482237f84afddcde5991b53f0effd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae6dca8c651783208564001c56786f3abc762cf3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae6dca8c651783208564001c56786f3abc762cf3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae6dca8c651783208564001c56786f3abc762cf3", "patch": "@@ -1,5 +1,10 @@\n 2018-03-20  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR target/84945\n+\t* config/i386/i386.c (fold_builtin_cpu): For features above 31\n+\tuse __cpu_features2 variable instead of __cpu_model.__cpu_features[0].\n+\tUse 1U instead of 1.  Formatting fixes.\n+\n \tPR c/84953\n \t* builtins.c (fold_builtin_strpbrk): For strpbrk(x, \"\") use type\n \tinstead of TREE_TYPE (s1) for the return value."}, {"sha": "5b1e962dedb04b220c9cc717580b9bddba7619b8", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae6dca8c651783208564001c56786f3abc762cf3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae6dca8c651783208564001c56786f3abc762cf3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ae6dca8c651783208564001c56786f3abc762cf3", "patch": "@@ -33265,8 +33265,8 @@ fold_builtin_cpu (tree fndecl, tree *args)\n \t}\n \n       /* Get the appropriate field in __cpu_model.  */\n-      ref =  build3 (COMPONENT_REF, TREE_TYPE (field), __cpu_model_var,\n-\t\t     field, NULL_TREE);\n+      ref = build3 (COMPONENT_REF, TREE_TYPE (field), __cpu_model_var,\n+\t\t    field, NULL_TREE);\n \n       /* Check the value.  */\n       final = build2 (EQ_EXPR, unsigned_type_node, ref,\n@@ -33296,20 +33296,34 @@ fold_builtin_cpu (tree fndecl, tree *args)\n \t  return integer_zero_node;\n \t}\n \n+      if (isa_names_table[i].feature >= 32)\n+\t{\n+\t  tree __cpu_features2_var = make_var_decl (unsigned_type_node,\n+\t\t\t\t\t\t    \"__cpu_features2\");\n+\n+\t  varpool_node::add (__cpu_features2_var);\n+\t  field_val = (1U << (isa_names_table[i].feature - 32));\n+\t  /* Return __cpu_features2 & field_val  */\n+\t  final = build2 (BIT_AND_EXPR, unsigned_type_node,\n+\t\t\t  __cpu_features2_var,\n+\t\t\t  build_int_cstu (unsigned_type_node, field_val));\n+\t  return build1 (CONVERT_EXPR, integer_type_node, final);\n+\t}\n+\n       field = TYPE_FIELDS (__processor_model_type);\n       /* Get the last field, which is __cpu_features.  */\n       while (DECL_CHAIN (field))\n         field = DECL_CHAIN (field);\n \n       /* Get the appropriate field: __cpu_model.__cpu_features  */\n-      ref =  build3 (COMPONENT_REF, TREE_TYPE (field), __cpu_model_var,\n-\t\t     field, NULL_TREE);\n+      ref = build3 (COMPONENT_REF, TREE_TYPE (field), __cpu_model_var,\n+\t\t    field, NULL_TREE);\n \n       /* Access the 0th element of __cpu_features array.  */\n       array_elt = build4 (ARRAY_REF, unsigned_type_node, ref,\n \t\t\t  integer_zero_node, NULL_TREE, NULL_TREE);\n \n-      field_val = (1 << isa_names_table[i].feature);\n+      field_val = (1U << isa_names_table[i].feature);\n       /* Return __cpu_model.__cpu_features[0] & field_val  */\n       final = build2 (BIT_AND_EXPR, unsigned_type_node, array_elt,\n \t\t      build_int_cstu (unsigned_type_node, field_val));"}, {"sha": "3058d9147ae65aec4809d86082dbf514e53bebdb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae6dca8c651783208564001c56786f3abc762cf3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae6dca8c651783208564001c56786f3abc762cf3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ae6dca8c651783208564001c56786f3abc762cf3", "patch": "@@ -1,3 +1,8 @@\n+2018-03-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/84945\n+\t* gcc.target/i386/pr84945.c: New test.\n+\n 2018-03-20  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \tPR target/81647"}, {"sha": "9599867886004fb3c79584357f061a87289eb288", "filename": "gcc/testsuite/gcc.target/i386/pr84945.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae6dca8c651783208564001c56786f3abc762cf3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84945.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae6dca8c651783208564001c56786f3abc762cf3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84945.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr84945.c?ref=ae6dca8c651783208564001c56786f3abc762cf3", "patch": "@@ -0,0 +1,16 @@\n+/* PR target/84945 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+int\n+main ()\n+{\n+  /* AVX512_VNNI instructions are all EVEX encoded, so if\n+     __builtin_cpu_supports says avx512vnni is available and avx512f is not,\n+     this is a GCC bug.  Ditto for AVX512_BITALG  */\n+  if (!__builtin_cpu_supports (\"avx512f\")\n+      && (__builtin_cpu_supports (\"avx512vnni\")\n+\t  || __builtin_cpu_supports (\"avx512bitalg\")))\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "a3da8dca79343ce5d4c230ec9f76f5edc312b23d", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae6dca8c651783208564001c56786f3abc762cf3/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae6dca8c651783208564001c56786f3abc762cf3/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ae6dca8c651783208564001c56786f3abc762cf3", "patch": "@@ -1,3 +1,13 @@\n+2018-03-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/84945\n+\t* config/i386/cpuinfo.h (__cpu_features2): Declare.\n+\t* config/i386/cpuinfo.c (__cpu_features2): New variable for\n+\tifndef SHARED only.\n+\t(set_feature): Define.\n+\t(get_available_features): Use set_feature macro.  Set __cpu_features2\n+\tto the second word of features ifndef SHARED.\n+\n 2018-03-15  Julia Koval  <julia.koval@intel.com>\n \n \t* config/i386/cpuinfo.c (get_available_features): Add"}, {"sha": "4eb3f5cd9441e55668b3f2b1ce10902bc9cf8e6b", "filename": "libgcc/config/i386/cpuinfo.c", "status": "modified", "additions": 52, "deletions": 36, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae6dca8c651783208564001c56786f3abc762cf3/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae6dca8c651783208564001c56786f3abc762cf3/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fcpuinfo.c?ref=ae6dca8c651783208564001c56786f3abc762cf3", "patch": "@@ -39,6 +39,13 @@ int __cpu_indicator_init (void)\n \n \n struct __processor_model __cpu_model = { };\n+#ifndef SHARED\n+/* We want to move away from __cpu_model in libgcc_s.so.1 and the\n+   size of __cpu_model is part of ABI.  So, new features that don't\n+   fit into __cpu_model.__cpu_features[0] go into extra variables\n+   in libgcc.a only, preferrably hidden.  */\n+unsigned int __cpu_features2;\n+#endif\n \n \n /* Get the specific type of AMD CPU.  */\n@@ -231,78 +238,82 @@ get_available_features (unsigned int ecx, unsigned int edx,\n   unsigned int ext_level;\n \n   unsigned int features = 0;\n+  unsigned int features2 = 0;\n+\n+#define set_feature(f) \\\n+  if (f < 32) features |= (1U << f); else features2 |= (1U << (f - 32))\n \n   if (edx & bit_CMOV)\n-    features |= (1 << FEATURE_CMOV);\n+    set_feature (FEATURE_CMOV);\n   if (edx & bit_MMX)\n-    features |= (1 << FEATURE_MMX);\n+    set_feature (FEATURE_MMX);\n   if (edx & bit_SSE)\n-    features |= (1 << FEATURE_SSE);\n+    set_feature (FEATURE_SSE);\n   if (edx & bit_SSE2)\n-    features |= (1 << FEATURE_SSE2);\n+    set_feature (FEATURE_SSE2);\n   if (ecx & bit_POPCNT)\n-    features |= (1 << FEATURE_POPCNT);\n+    set_feature (FEATURE_POPCNT);\n   if (ecx & bit_AES)\n-    features |= (1 << FEATURE_AES);\n+    set_feature (FEATURE_AES);\n   if (ecx & bit_PCLMUL)\n-    features |= (1 << FEATURE_PCLMUL);\n+    set_feature (FEATURE_PCLMUL);\n   if (ecx & bit_SSE3)\n-    features |= (1 << FEATURE_SSE3);\n+    set_feature (FEATURE_SSE3);\n   if (ecx & bit_SSSE3)\n-    features |= (1 << FEATURE_SSSE3);\n+    set_feature (FEATURE_SSSE3);\n   if (ecx & bit_SSE4_1)\n-    features |= (1 << FEATURE_SSE4_1);\n+    set_feature (FEATURE_SSE4_1);\n   if (ecx & bit_SSE4_2)\n-    features |= (1 << FEATURE_SSE4_2);\n+    set_feature (FEATURE_SSE4_2);\n   if (ecx & bit_AVX)\n-    features |= (1 << FEATURE_AVX);\n+    set_feature (FEATURE_AVX);\n   if (ecx & bit_FMA)\n-    features |= (1 << FEATURE_FMA);\n+    set_feature (FEATURE_FMA);\n \n   /* Get Advanced Features at level 7 (eax = 7, ecx = 0). */\n   if (max_cpuid_level >= 7)\n     {\n       __cpuid_count (7, 0, eax, ebx, ecx, edx);\n       if (ebx & bit_BMI)\n-        features |= (1 << FEATURE_BMI);\n+\tset_feature (FEATURE_BMI);\n       if (ebx & bit_AVX2)\n-\tfeatures |= (1 << FEATURE_AVX2);\n+\tset_feature (FEATURE_AVX2);\n       if (ebx & bit_BMI2)\n-        features |= (1 << FEATURE_BMI2);\n+\tset_feature (FEATURE_BMI2);\n       if (ebx & bit_AVX512F)\n-\tfeatures |= (1 << FEATURE_AVX512F);\n+\tset_feature (FEATURE_AVX512F);\n       if (ebx & bit_AVX512VL)\n-\tfeatures |= (1 << FEATURE_AVX512VL);\n+\tset_feature (FEATURE_AVX512VL);\n       if (ebx & bit_AVX512BW)\n-\tfeatures |= (1 << FEATURE_AVX512BW);\n+\tset_feature (FEATURE_AVX512BW);\n       if (ebx & bit_AVX512DQ)\n-\tfeatures |= (1 << FEATURE_AVX512DQ);\n+\tset_feature (FEATURE_AVX512DQ);\n       if (ebx & bit_AVX512CD)\n-\tfeatures |= (1 << FEATURE_AVX512CD);\n+\tset_feature (FEATURE_AVX512CD);\n       if (ebx & bit_AVX512PF)\n-\tfeatures |= (1 << FEATURE_AVX512PF);\n+\tset_feature (FEATURE_AVX512PF);\n       if (ebx & bit_AVX512ER)\n-\tfeatures |= (1 << FEATURE_AVX512ER);\n+\tset_feature (FEATURE_AVX512ER);\n       if (ebx & bit_AVX512IFMA)\n-\tfeatures |= (1 << FEATURE_AVX512IFMA);\n+\tset_feature (FEATURE_AVX512IFMA);\n       if (ecx & bit_AVX512VBMI)\n-\tfeatures |= (1 << FEATURE_AVX512VBMI);\n+\tset_feature (FEATURE_AVX512VBMI);\n       if (ecx & bit_AVX512VBMI2)\n-\tfeatures |= (1 << FEATURE_AVX512VBMI2);\n+\tset_feature (FEATURE_AVX512VBMI2);\n       if (ecx & bit_GFNI)\n-\tfeatures |= (1 << FEATURE_GFNI);\n+\tset_feature (FEATURE_GFNI);\n       if (ecx & bit_VPCLMULQDQ)\n-\tfeatures |= (1 << FEATURE_VPCLMULQDQ);\n+\tset_feature (FEATURE_VPCLMULQDQ);\n       if (ecx & bit_AVX512VNNI)\n-\tfeatures |= (1 << FEATURE_AVX512VNNI);\n+\tset_feature (FEATURE_AVX512VNNI);\n       if (ecx & bit_AVX512BITALG)\n-\tfeatures |= (1 << FEATURE_AVX512BITALG);\n+\tset_feature (FEATURE_AVX512BITALG);\n       if (ecx & bit_AVX512VPOPCNTDQ)\n-\tfeatures |= (1 << FEATURE_AVX512VPOPCNTDQ);\n+\tset_feature (FEATURE_AVX512VPOPCNTDQ);\n       if (edx & bit_AVX5124VNNIW)\n-\tfeatures |= (1 << FEATURE_AVX5124VNNIW);\n+\tset_feature (FEATURE_AVX5124VNNIW);\n       if (edx & bit_AVX5124FMAPS)\n-\tfeatures |= (1 << FEATURE_AVX5124FMAPS);\n+\tset_feature (FEATURE_AVX5124FMAPS);\n     }\n \n   /* Check cpuid level of extended features.  */\n@@ -313,14 +324,19 @@ get_available_features (unsigned int ecx, unsigned int edx,\n       __cpuid (0x80000001, eax, ebx, ecx, edx);\n \n       if (ecx & bit_SSE4a)\n-\tfeatures |= (1 << FEATURE_SSE4_A);\n+\tset_feature (FEATURE_SSE4_A);\n       if (ecx & bit_FMA4)\n-\tfeatures |= (1 << FEATURE_FMA4);\n+\tset_feature (FEATURE_FMA4);\n       if (ecx & bit_XOP)\n-\tfeatures |= (1 << FEATURE_XOP);\n+\tset_feature (FEATURE_XOP);\n     }\n     \n   __cpu_model.__cpu_features[0] = features;\n+#ifndef SHARED\n+  __cpu_features2 = features2;\n+#else\n+  (void) features2;\n+#endif\n }\n \n /* A constructor function that is sets __cpu_model and __cpu_features with"}, {"sha": "ab2260c38dfc09d8918b567064fa2933c93f9e6a", "filename": "libgcc/config/i386/cpuinfo.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae6dca8c651783208564001c56786f3abc762cf3/libgcc%2Fconfig%2Fi386%2Fcpuinfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae6dca8c651783208564001c56786f3abc762cf3/libgcc%2Fconfig%2Fi386%2Fcpuinfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fcpuinfo.h?ref=ae6dca8c651783208564001c56786f3abc762cf3", "patch": "@@ -124,3 +124,4 @@ extern struct __processor_model\n   unsigned int __cpu_subtype;\n   unsigned int __cpu_features[1];\n } __cpu_model;\n+extern unsigned int __cpu_features2;"}]}