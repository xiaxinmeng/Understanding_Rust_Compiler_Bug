{"sha": "8b287aea3561278b4002864c0d1c29b769493448", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIyODdhZWEzNTYxMjc4YjQwMDI4NjRjMGQxYzI5Yjc2OTQ5MzQ0OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-11-11T22:38:33Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-11-11T22:38:33Z"}, "message": "re PR rtl-optimization/59461 (missed zero-extension elimination in the combiner)\n\n\tPR rtl-optimization/59461\n\t* doc/rtl.texi (paradoxical subregs): Add missing word.\n\t* combine.c (reg_nonzero_bits_for_combine): Do not discard results\n\tin modes with precision larger than that of last_set_mode.\n\t* rtlanal.c (nonzero_bits1) <SUBREG>: If WORD_REGISTER_OPERATIONS is\n\tset and LOAD_EXTEND_OP is appropriate, propagate results from inner\n\tREGs to paradoxical SUBREGs.\n\t(num_sign_bit_copies1) <SUBREG>: Likewise.  Check that the mode is not\n\tlarger than a word before invoking LOAD_EXTEND_OP on it.\n\nFrom-SVN: r242326", "tree": {"sha": "d0c42b5c68c9cac41892a474b5a2eeccd1791ba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0c42b5c68c9cac41892a474b5a2eeccd1791ba7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b287aea3561278b4002864c0d1c29b769493448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b287aea3561278b4002864c0d1c29b769493448", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b287aea3561278b4002864c0d1c29b769493448", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b287aea3561278b4002864c0d1c29b769493448/comments", "author": null, "committer": null, "parents": [{"sha": "84971f1bade1acb6b721260fb02f3740642c643e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84971f1bade1acb6b721260fb02f3740642c643e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84971f1bade1acb6b721260fb02f3740642c643e"}], "stats": {"total": 96, "additions": 64, "deletions": 32}, "files": [{"sha": "de764a3e912075a5b35c216b172ad1ee3f3e76ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b287aea3561278b4002864c0d1c29b769493448/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b287aea3561278b4002864c0d1c29b769493448/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b287aea3561278b4002864c0d1c29b769493448", "patch": "@@ -1,3 +1,15 @@\n+2016-11-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/59461\n+\t* doc/rtl.texi (paradoxical subregs): Add missing word.\n+\t* combine.c (reg_nonzero_bits_for_combine): Do not discard results\n+\tin modes with precision larger than that of last_set_mode.\n+\t* rtlanal.c (nonzero_bits1) <SUBREG>: If WORD_REGISTER_OPERATIONS is\n+\tset and LOAD_EXTEND_OP is appropriate, propagate results from inner\n+\tREGs to paradoxical SUBREGs.\n+\t(num_sign_bit_copies1) <SUBREG>: Likewise.  Check that the mode is not\n+\tlarger than a word before invoking LOAD_EXTEND_OP on it.\n+\n 2016-11-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/78243"}, {"sha": "6b7bdd0f687d0d0d79f2bcdfccbe757a88ff7a7e", "filename": "gcc/combine.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8b287aea3561278b4002864c0d1c29b769493448", "patch": "@@ -9895,18 +9895,17 @@ reg_nonzero_bits_for_combine (const_rtx x, machine_mode mode,\n \t\t  (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb),\n \t\t   REGNO (x)))))\n     {\n-      unsigned HOST_WIDE_INT mask = rsp->last_set_nonzero_bits;\n-\n-      if (GET_MODE_PRECISION (rsp->last_set_mode) < GET_MODE_PRECISION (mode))\n-\t/* We don't know anything about the upper bits.  */\n-\tmask |= GET_MODE_MASK (mode) ^ GET_MODE_MASK (rsp->last_set_mode);\n-\n-      *nonzero &= mask;\n+      /* Note that, even if the precision of last_set_mode is lower than that\n+\t of mode, record_value_for_reg invoked nonzero_bits on the register\n+\t with nonzero_bits_mode (because last_set_mode is necessarily integral\n+\t and HWI_COMPUTABLE_MODE_P in this case) so bits in nonzero_bits_mode\n+\t are all valid, hence in mode too since nonzero_bits_mode is defined\n+\t to the largest HWI_COMPUTABLE_MODE_P mode.  */\n+      *nonzero &= rsp->last_set_nonzero_bits;\n       return NULL;\n     }\n \n   tem = get_last_value (x);\n-\n   if (tem)\n     {\n       if (SHORT_IMMEDIATES_SIGN_EXTEND)\n@@ -9915,7 +9914,8 @@ reg_nonzero_bits_for_combine (const_rtx x, machine_mode mode,\n \n       return tem;\n     }\n-  else if (nonzero_sign_valid && rsp->nonzero_bits)\n+\n+  if (nonzero_sign_valid && rsp->nonzero_bits)\n     {\n       unsigned HOST_WIDE_INT mask = rsp->nonzero_bits;\n "}, {"sha": "175f60dcf0894c54b960265e3cc9784642a47dbd", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=8b287aea3561278b4002864c0d1c29b769493448", "patch": "@@ -1882,7 +1882,7 @@ When used as an rvalue, the low-order bits of the @code{subreg} are\n taken from @var{reg} while the high-order bits may or may not be\n defined.\n \n-The high-order bits of rvalues are in the following circumstances:\n+The high-order bits of rvalues are defined in the following circumstances:\n \n @itemize\n @item @code{subreg}s of @code{mem}"}, {"sha": "4617e8ee449d62da3217f285c5a0e35846fcdfaa", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=8b287aea3561278b4002864c0d1c29b769493448", "patch": "@@ -4256,7 +4256,7 @@ cached_nonzero_bits (const_rtx x, machine_mode mode, const_rtx known_x,\n /* Given an expression, X, compute which bits in X can be nonzero.\n    We don't care about bits outside of those defined in MODE.\n \n-   For most X this is simply GET_MODE_MASK (GET_MODE (MODE)), but if X is\n+   For most X this is simply GET_MODE_MASK (GET_MODE (X)), but if X is\n    an arithmetic operation, we can do better.  */\n \n static unsigned HOST_WIDE_INT\n@@ -4563,38 +4563,35 @@ nonzero_bits1 (const_rtx x, machine_mode mode, const_rtx known_x,\n       /* If this is a SUBREG formed for a promoted variable that has\n \t been zero-extended, we know that at least the high-order bits\n \t are zero, though others might be too.  */\n-\n       if (SUBREG_PROMOTED_VAR_P (x) && SUBREG_PROMOTED_UNSIGNED_P (x))\n \tnonzero = GET_MODE_MASK (GET_MODE (x))\n \t\t  & cached_nonzero_bits (SUBREG_REG (x), GET_MODE (x),\n \t\t\t\t\t known_x, known_mode, known_ret);\n \n-      inner_mode = GET_MODE (SUBREG_REG (x));\n       /* If the inner mode is a single word for both the host and target\n \t machines, we can compute this from which bits of the inner\n \t object might be nonzero.  */\n+      inner_mode = GET_MODE (SUBREG_REG (x));\n       if (GET_MODE_PRECISION (inner_mode) <= BITS_PER_WORD\n-\t  && (GET_MODE_PRECISION (inner_mode) <= HOST_BITS_PER_WIDE_INT))\n+\t  && GET_MODE_PRECISION (inner_mode) <= HOST_BITS_PER_WIDE_INT)\n \t{\n \t  nonzero &= cached_nonzero_bits (SUBREG_REG (x), mode,\n \t\t\t\t\t  known_x, known_mode, known_ret);\n \n           /* On many CISC machines, accessing an object in a wider mode\n \t     causes the high-order bits to become undefined.  So they are\n \t     not known to be zero.  */\n-\t  if (!WORD_REGISTER_OPERATIONS\n-\t      /* If this is a typical RISC machine, we only have to worry\n-\t\t about the way loads are extended.  */\n-\t      || ((LOAD_EXTEND_OP (inner_mode) == SIGN_EXTEND\n-\t\t     ? val_signbit_known_set_p (inner_mode, nonzero)\n-\t\t     : LOAD_EXTEND_OP (inner_mode) != ZERO_EXTEND)\n-\t\t   || !MEM_P (SUBREG_REG (x))))\n-\t    {\n-\t      if (GET_MODE_PRECISION (GET_MODE (x))\n+\t  if ((!WORD_REGISTER_OPERATIONS\n+\t       /* If this is a typical RISC machine, we only have to worry\n+\t\t  about the way loads are extended.  */\n+\t\t|| (LOAD_EXTEND_OP (inner_mode) == SIGN_EXTEND\n+\t\t    ? val_signbit_known_set_p (inner_mode, nonzero)\n+\t\t    : LOAD_EXTEND_OP (inner_mode) != ZERO_EXTEND)\n+\t\t|| (!MEM_P (SUBREG_REG (x)) && !REG_P (SUBREG_REG (x))))\n+\t      && GET_MODE_PRECISION (GET_MODE (x))\n \t\t  > GET_MODE_PRECISION (inner_mode))\n-\t\tnonzero |= (GET_MODE_MASK (GET_MODE (x))\n-\t\t\t    & ~GET_MODE_MASK (inner_mode));\n-\t    }\n+\t    nonzero\n+\t      |= (GET_MODE_MASK (GET_MODE (x)) & ~GET_MODE_MASK (inner_mode));\n \t}\n       break;\n \n@@ -4799,6 +4796,7 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n {\n   enum rtx_code code = GET_CODE (x);\n   unsigned int bitwidth = GET_MODE_PRECISION (mode);\n+  machine_mode inner_mode;\n   int num0, num1, result;\n   unsigned HOST_WIDE_INT nonzero;\n \n@@ -4906,13 +4904,13 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t}\n \n       /* For a smaller object, just ignore the high bits.  */\n-      if (bitwidth <= GET_MODE_PRECISION (GET_MODE (SUBREG_REG (x))))\n+      inner_mode = GET_MODE (SUBREG_REG (x));\n+      if (bitwidth <= GET_MODE_PRECISION (inner_mode))\n \t{\n \t  num0 = cached_num_sign_bit_copies (SUBREG_REG (x), VOIDmode,\n \t\t\t\t\t     known_x, known_mode, known_ret);\n-\t  return MAX (1, (num0\n-\t\t\t  - (int) (GET_MODE_PRECISION (GET_MODE (SUBREG_REG (x)))\n-\t\t\t\t   - bitwidth)));\n+\t  return\n+\t    MAX (1, num0 - (int) (GET_MODE_PRECISION (inner_mode) - bitwidth));\n \t}\n \n       /* For paradoxical SUBREGs on machines where all register operations\n@@ -4926,9 +4924,10 @@ num_sign_bit_copies1 (const_rtx x, machine_mode mode, const_rtx known_x,\n \t to the stack.  */\n \n       if (WORD_REGISTER_OPERATIONS\n+\t  && GET_MODE_PRECISION (inner_mode) <= BITS_PER_WORD\n+\t  && LOAD_EXTEND_OP (inner_mode) == SIGN_EXTEND\n \t  && paradoxical_subreg_p (x)\n-\t  && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (x))) == SIGN_EXTEND\n-\t  && MEM_P (SUBREG_REG (x)))\n+\t  && (MEM_P (SUBREG_REG (x)) || REG_P (SUBREG_REG (x))))\n \treturn cached_num_sign_bit_copies (SUBREG_REG (x), mode,\n \t\t\t\t\t   known_x, known_mode, known_ret);\n       break;"}, {"sha": "b8ee57d5fe30990c019108de6218de5dba0d0f70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b287aea3561278b4002864c0d1c29b769493448", "patch": "@@ -1,3 +1,7 @@\n+2016-11-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/sparc/20161111-1.c: New test.\n+\n 2016-11-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/78310"}, {"sha": "eda8b0a9f1252e1b199a665c8586741e0886108a", "filename": "gcc/testsuite/gcc.target/sparc/20161111-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20161111-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b287aea3561278b4002864c0d1c29b769493448/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20161111-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2F20161111-1.c?ref=8b287aea3561278b4002864c0d1c29b769493448", "patch": "@@ -0,0 +1,17 @@\n+/* PR rtl-optimization/59461 */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+extern char zeb_test_array[10];\n+\n+unsigned char ee_isdigit2(unsigned int i)\n+{\n+  unsigned char c = zeb_test_array[i];\n+  unsigned char retval;\n+\n+  retval = ((c>='0') & (c<='9')) ? 1 : 0;\n+  return retval;\n+}\n+\n+/* { dg-final { scan-assembler-not \"and\\t%\" } } */"}]}