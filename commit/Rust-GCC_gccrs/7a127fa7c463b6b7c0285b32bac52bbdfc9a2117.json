{"sha": "7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ExMjdmYTdjNDYzYjZiN2MwMjg1YjMyYmFjNTJiYmRmYzlhMjExNw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-01-08T01:00:25Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-01-08T01:00:25Z"}, "message": "PR c/68966 - atomic_fetch_* on atomic_bool not diagnosed\n\ngcc/ChangeLog:\n\t* doc/extend.texi (__atomic Builtins, __sync Builtins): Document\n\tconstraint on the type of arguments.\n\ngcc/c-family/ChangeLog:\n\t* c-common.c (sync_resolve_size): Reject first argument when it's\n\ta pointer to _Bool.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/atomic-fetch-bool.c: New test.\n\t* gcc.dg/sync-fetch-bool.c: New test.\n\nFrom-SVN: r232147", "tree": {"sha": "d7b58a67882cd51f1addf5e9b63478ed3a012eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7b58a67882cd51f1addf5e9b63478ed3a012eb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9733b8599c75031c40b85c15666730135f6f59b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9733b8599c75031c40b85c15666730135f6f59b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9733b8599c75031c40b85c15666730135f6f59b"}], "stats": {"total": 188, "additions": 180, "deletions": 8}, "files": [{"sha": "73315996c08fcd495ecc28984a0b7bb9244973de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "patch": "@@ -1,3 +1,9 @@\n+2016-01-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/68966\n+\t* doc/extend.texi (__atomic Builtins, __sync Builtins): Document\n+\tconstraint on the type of arguments.\n+\n 2016-01-07  Andreas Tobler  <andreast@gcc.gnu.org>\n \n \t* config/arm/freebsd.h: Rename SUBTARGET_OVERRIDE_OPTIONS to"}, {"sha": "a2743d8f8d94ffdddac81269279846239a7b9043", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "patch": "@@ -1,3 +1,10 @@\n+gcc/c-family/ChangeLog:\n+2016-01-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/68966\n+\t* c-common.c (sync_resolve_size): Reject first argument when it's\n+\ta pointer to _Bool.\n+\n 2016-01-05  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/69122"}, {"sha": "0fd37b5c6df2d75acb6bcae44d9822601860ddbf", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "patch": "@@ -10657,11 +10657,16 @@ builtin_type_for_size (int size, bool unsignedp)\n /* A helper function for resolve_overloaded_builtin in resolving the\n    overloaded __sync_ builtins.  Returns a positive power of 2 if the\n    first operand of PARAMS is a pointer to a supported data type.\n-   Returns 0 if an error is encountered.  */\n+   Returns 0 if an error is encountered.\n+   FETCH is true when FUNCTION is one of the _FETCH_OP_ or _OP_FETCH_\n+   built-ins.  */\n \n static int\n-sync_resolve_size (tree function, vec<tree, va_gc> *params)\n+sync_resolve_size (tree function, vec<tree, va_gc> *params, bool fetch)\n {\n+  /* Type of the argument.  */\n+  tree argtype;\n+  /* Type the argument points to.  */\n   tree type;\n   int size;\n \n@@ -10671,7 +10676,7 @@ sync_resolve_size (tree function, vec<tree, va_gc> *params)\n       return 0;\n     }\n \n-  type = TREE_TYPE ((*params)[0]);\n+  argtype = type = TREE_TYPE ((*params)[0]);\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* Force array-to-pointer decay for C++.  */\n@@ -10686,12 +10691,16 @@ sync_resolve_size (tree function, vec<tree, va_gc> *params)\n   if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n     goto incompatible;\n \n+  if (fetch && TREE_CODE (type) == BOOLEAN_TYPE)\n+    goto incompatible;\n+\n   size = tree_to_uhwi (TYPE_SIZE_UNIT (type));\n   if (size == 1 || size == 2 || size == 4 || size == 8 || size == 16)\n     return size;\n \n  incompatible:\n-  error (\"incompatible type for argument %d of %qE\", 1, function);\n+  error (\"operand type %qT is incompatible with argument %d of %qE\",\n+\t argtype, 1, function);\n   return 0;\n }\n \n@@ -11250,6 +11259,11 @@ resolve_overloaded_builtin (location_t loc, tree function,\n \t\t\t    vec<tree, va_gc> *params)\n {\n   enum built_in_function orig_code = DECL_FUNCTION_CODE (function);\n+\n+  /* Is function one of the _FETCH_OP_ or _OP_FETCH_ built-ins?\n+     Those are not valid to call with a pointer to _Bool (or C++ bool)\n+     and so must be rejected.  */\n+  bool fetch_op = true;\n   bool orig_format = true;\n   tree new_return = NULL_TREE;\n \n@@ -11325,6 +11339,10 @@ resolve_overloaded_builtin (location_t loc, tree function,\n     case BUILT_IN_ATOMIC_COMPARE_EXCHANGE_N:\n     case BUILT_IN_ATOMIC_LOAD_N:\n     case BUILT_IN_ATOMIC_STORE_N:\n+      {\n+\tfetch_op = false;\n+\t/* Fallthrough to further processing.  */\n+      }\n     case BUILT_IN_ATOMIC_ADD_FETCH_N:\n     case BUILT_IN_ATOMIC_SUB_FETCH_N:\n     case BUILT_IN_ATOMIC_AND_FETCH_N:\n@@ -11358,7 +11376,16 @@ resolve_overloaded_builtin (location_t loc, tree function,\n     case BUILT_IN_SYNC_LOCK_TEST_AND_SET_N:\n     case BUILT_IN_SYNC_LOCK_RELEASE_N:\n       {\n-\tint n = sync_resolve_size (function, params);\n+\t/* The following are not _FETCH_OPs and must be accepted with\n+\t   pointers to _Bool (or C++ bool).  */\n+\tif (fetch_op)\n+\t  fetch_op =\n+\t    (orig_code != BUILT_IN_SYNC_BOOL_COMPARE_AND_SWAP_N\n+\t     && orig_code != BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_N\n+\t     && orig_code != BUILT_IN_SYNC_LOCK_TEST_AND_SET_N\n+\t     && orig_code != BUILT_IN_SYNC_LOCK_RELEASE_N);\n+\n+\tint n = sync_resolve_size (function, params, fetch_op);\n \ttree new_function, first_param, result;\n \tenum built_in_function fncode;\n "}, {"sha": "8122c4cff059ff79b1270ba36737b7c705c50cd1", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "patch": "@@ -9316,6 +9316,9 @@ returns the value that had previously been in memory.  That is,\n @{ tmp = *ptr; *ptr = ~(tmp & value); return tmp; @}   // nand\n @end smallexample\n \n+The object pointed to by the first argument must be of integer or pointer\n+type.  It must not be a Boolean type.\n+\n @emph{Note:} GCC 4.4 and later implement @code{__sync_fetch_and_nand}\n as @code{*ptr = ~(tmp & value)} instead of @code{*ptr = ~tmp & value}.\n \n@@ -9339,6 +9342,9 @@ return the new value.  That is,\n @{ *ptr = ~(*ptr & value); return *ptr; @}   // nand\n @end smallexample\n \n+The same constraints on arguments apply as for the corresponding\n+@code{__sync_op_and_fetch} built-in functions.\n+\n @emph{Note:} GCC 4.4 and later implement @code{__sync_nand_and_fetch}\n as @code{*ptr = ~(*ptr & value)} instead of\n @code{*ptr = ~*ptr & value}.\n@@ -9585,13 +9591,14 @@ pointer.\n @deftypefnx {Built-in Function} @var{type} __atomic_or_fetch (@var{type} *ptr, @var{type} val, int memorder)\n @deftypefnx {Built-in Function} @var{type} __atomic_nand_fetch (@var{type} *ptr, @var{type} val, int memorder)\n These built-in functions perform the operation suggested by the name, and\n-return the result of the operation. That is,\n+return the result of the operation.  That is,\n \n @smallexample\n @{ *ptr @var{op}= val; return *ptr; @}\n @end smallexample\n \n-All memory orders are valid.\n+The object pointed to by the first argument must be of integer or pointer\n+type.  It must not be a Boolean type.  All memory orders are valid.\n \n @end deftypefn\n \n@@ -9608,7 +9615,8 @@ return the value that had previously been in @code{*@var{ptr}}.  That is,\n @{ tmp = *ptr; *ptr @var{op}= val; return tmp; @}\n @end smallexample\n \n-All memory orders are valid.\n+The same constraints on arguments apply as for the corresponding\n+@code{__atomic_op_fetch} built-in functions.  All memory orders are valid.\n \n @end deftypefn\n "}, {"sha": "5840815a918782a9b21c775ac589e478f1085605", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "patch": "@@ -1,3 +1,9 @@\n+2016-01-07  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/68966\n+\t* gcc.dg/atomic-fetch-bool.c: New test.\n+\t* gcc.dg/sync-fetch-bool.c: New test.\n+\n 2016-01-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR fortran/66680"}, {"sha": "f7af11f5c134d880b092195d81dcc300673d4344", "filename": "gcc/testsuite/gcc.dg/atomic-fetch-bool.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-fetch-bool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-fetch-bool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-fetch-bool.c?ref=7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "patch": "@@ -0,0 +1,64 @@\n+/* PR c/68966 - atomic_fetch_* on atomic_bool not diagnosed\n+   Test to verify that calls to __atomic_fetch_op funcions with a _Bool\n+   argument are rejected.  This is necessary because GCC expects that\n+   all initialized _Bool objects have a specific representation and\n+   allowing atomic operations to change it would break the invariant.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-pedantic-errors -std=c11\" } */\n+\n+\n+void test_atomic_bool (_Atomic _Bool *a)\n+{\n+  enum { SEQ_CST = __ATOMIC_SEQ_CST };\n+  \n+  __atomic_fetch_add (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_add.\" } */\n+  __atomic_fetch_sub (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_sub.\" } */\n+  __atomic_fetch_and (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_and.\" } */\n+  __atomic_fetch_xor (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_xor.\" } */\n+  __atomic_fetch_or (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_or.\" } */\n+  __atomic_fetch_nand (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_nand.\" } */\n+\n+  __atomic_add_fetch (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_add_fetch.\" } */\n+  __atomic_sub_fetch (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_sub_fetch.\" } */\n+  __atomic_and_fetch (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_and_fetch.\" } */\n+  __atomic_xor_fetch (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_xor_fetch.\" } */\n+  __atomic_or_fetch (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_or_fetch.\" } */\n+  __atomic_nand_fetch (a, 1, SEQ_CST);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__atomic_nand_fetch.\" } */\n+\n+  /* The following are valid and must be accepted.  */\n+  _Bool val = 0, ret = 0;\n+  __atomic_exchange (a, &val, &ret, SEQ_CST);\n+  __atomic_exchange_n (a, val, SEQ_CST);\n+  __atomic_compare_exchange (a, &val, &ret, !1, SEQ_CST, SEQ_CST);\n+  __atomic_compare_exchange_n (a, &val, ret, !1, SEQ_CST, SEQ_CST);\n+  __atomic_test_and_set (a, SEQ_CST);\n+  __atomic_clear (a, SEQ_CST);\n+}\n+\n+void test_bool (_Bool *b)\n+{\n+  enum { SEQ_CST = __ATOMIC_SEQ_CST };\n+  \n+  __atomic_fetch_add (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_add.\" } */\n+  __atomic_fetch_sub (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_sub.\" } */\n+  __atomic_fetch_and (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_and.\" } */\n+  __atomic_fetch_xor (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_xor.\" } */\n+  __atomic_fetch_or (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_or.\" } */\n+  __atomic_fetch_nand (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_fetch_nand.\" } */\n+\n+  __atomic_add_fetch (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_add_fetch.\" } */\n+  __atomic_sub_fetch (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_sub_fetch.\" } */\n+  __atomic_and_fetch (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_and_fetch.\" } */\n+  __atomic_xor_fetch (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_xor_fetch.\" } */\n+  __atomic_or_fetch (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_or_fetch.\" } */\n+  __atomic_nand_fetch (b, 1, SEQ_CST);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__atomic_nand_fetch.\" } */\n+\n+  /* The following are valid and must be accepted.  */\n+  _Bool val = 0, ret = 0;\n+  __atomic_exchange (b, &val, &ret, SEQ_CST);\n+  __atomic_exchange_n (b, val, SEQ_CST);\n+  __atomic_compare_exchange (b, &val, &ret, !1, SEQ_CST, SEQ_CST);\n+  __atomic_compare_exchange_n (b, &val, ret, !1, SEQ_CST, SEQ_CST);\n+  __atomic_test_and_set (b, SEQ_CST);\n+  __atomic_clear (b, SEQ_CST);\n+}"}, {"sha": "1d156a970b46c707366b63384f7132785771ffa5", "filename": "gcc/testsuite/gcc.dg/sync-fetch-bool.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Ftestsuite%2Fgcc.dg%2Fsync-fetch-bool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a127fa7c463b6b7c0285b32bac52bbdfc9a2117/gcc%2Ftestsuite%2Fgcc.dg%2Fsync-fetch-bool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsync-fetch-bool.c?ref=7a127fa7c463b6b7c0285b32bac52bbdfc9a2117", "patch": "@@ -0,0 +1,54 @@\n+/* PR c/68966 - atomic_fetch_* on atomic_bool not diagnosed\n+   Test to verify that calls to __sync_fetch_op funcions with a _Bool\n+   argument are rejected.  This is necessary because GCC expects that\n+   all initialized _Bool objects have a specific representation and\n+   allowing atomic operations to change it would break the invariant.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-pedantic-errors -std=c11\" } */\n+\n+\n+void test_sync_atomic_bool (_Atomic _Bool *a)\n+{\n+  __sync_fetch_and_add (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_add.\" } */\n+  __sync_fetch_and_sub (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_sub.\" } */\n+  __sync_fetch_and_and (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_and.\" } */\n+  __sync_fetch_and_xor (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_xor.\" } */\n+  __sync_fetch_and_or (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_or.\" } */\n+  __sync_fetch_and_nand (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_nand.\" } */\n+  \n+  __sync_add_and_fetch (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_add_and_fetch.\" } */\n+  __sync_sub_and_fetch (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_sub_and_fetch.\" } */\n+  __sync_and_and_fetch (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_and_and_fetch.\" } */\n+  __sync_xor_and_fetch (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_xor_and_fetch.\" } */\n+  __sync_or_and_fetch (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_or_and_fetch.\" } */\n+  __sync_nand_and_fetch (a, 1);   /* { dg-error \"operand type ._Atomic _Bool \\\\*. is incompatible with argument 1 of .__sync_nand_and_fetch.\" } */\n+\n+  /* The following are valid and must be accepted.  */\n+  __sync_bool_compare_and_swap (a, 0, 1);\n+  __sync_val_compare_and_swap (a, 0, 1);\n+  __sync_lock_test_and_set (a, 1);\n+  __sync_lock_release (a);\n+}\n+\n+void test_sync_bool (_Bool *b)\n+{\n+  __sync_fetch_and_add (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_add.\" } */\n+  __sync_fetch_and_sub (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_sub.\" } */\n+  __sync_fetch_and_and (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_and.\" } */\n+  __sync_fetch_and_xor (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_xor.\" } */\n+  __sync_fetch_and_or (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_or.\" } */\n+  __sync_fetch_and_nand (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_fetch_and_nand.\" } */\n+  \n+  __sync_add_and_fetch (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_add_and_fetch.\" } */\n+  __sync_sub_and_fetch (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_sub_and_fetch.\" } */\n+  __sync_and_and_fetch (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_and_and_fetch.\" } */\n+  __sync_xor_and_fetch (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_xor_and_fetch.\" } */\n+  __sync_or_and_fetch (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_or_and_fetch.\" } */\n+  __sync_nand_and_fetch (b, 1);   /* { dg-error \"operand type ._Bool \\\\*. is incompatible with argument 1 of .__sync_nand_and_fetch.\" } */\n+\n+  /* The following are valid and must be accepted.  */\n+  __sync_bool_compare_and_swap (b, 0, 1);\n+  __sync_val_compare_and_swap (b, 0, 1);\n+  __sync_lock_test_and_set (b, 1);\n+  __sync_lock_release (b);\n+}"}]}