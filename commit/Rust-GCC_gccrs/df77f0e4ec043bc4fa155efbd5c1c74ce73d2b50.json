{"sha": "df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY3N2YwZTRlYzA0M2JjNGZhMTU1ZWZiZDVjMWM3NGNlNzNkMmI1MA==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2013-12-05T09:18:38Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2013-12-05T09:18:38Z"}, "message": "libsanitizer merge from upstream r196090\n\nFrom-SVN: r205695", "tree": {"sha": "20d85354103063e38b162a6a90b7ae51fb4b6104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20d85354103063e38b162a6a90b7ae51fb4b6104"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "649d196dbd78a119786f204d36b7c5d4dcb3a949", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649d196dbd78a119786f204d36b7c5d4dcb3a949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/649d196dbd78a119786f204d36b7c5d4dcb3a949"}], "stats": {"total": 6174, "additions": 4535, "deletions": 1639}, "files": [{"sha": "f72c72c8991fdaea54e059422cc828757b195803", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -1,3 +1,8 @@\n+2013-12-05  Kostya Serebryany  <kcc@google.com>\n+\n+\t* c-c++-common/asan/null-deref-1.c: Update the test\n+\tto match the fresh asan run-time.\n+\n 2013-12-05  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/59374"}, {"sha": "6aea9d295f392139e2ec714dbde0acc2581bcba0", "filename": "gcc/testsuite/c-c++-common/asan/null-deref-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fnull-deref-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fnull-deref-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fnull-deref-1.c?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -18,6 +18,5 @@ int main()\n \n /* { dg-output \"ERROR: AddressSanitizer:? SEGV on unknown address\\[^\\n\\r]*\" } */\n /* { dg-output \"0x\\[0-9a-f\\]+ \\[^\\n\\r]*pc 0x\\[0-9a-f\\]+\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n-/* { dg-output \"\\[^\\n\\r]*AddressSanitizer can not provide additional info.*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #0 0x\\[0-9a-f\\]+ (in \\[^\\n\\r]*NullDeref\\[^\\n\\r]* (\\[^\\n\\r]*null-deref-1.c:10|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */\n /* { dg-output \"    #1 0x\\[0-9a-f\\]+ (in _*main (\\[^\\n\\r]*null-deref-1.c:15|\\[^\\n\\r]*:0)|\\[(\\])\\[^\\n\\r]*(\\n|\\r\\n|\\r)\" } */"}, {"sha": "661c326de73a33ace67e5c397f353f0d0b3fea91", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -1,3 +1,13 @@\n+2013-12-05  Kostya Serebryany  <kcc@google.com>\n+\n+\t* All source files: Merge from upstream r196090.\n+\t* tsan/Makefile.am (tsan_files): Added new files.\n+\t* tsan/Makefile.in: Regenerate.\n+\t* sanitizer_common/Makefile.am (sanitizer_common_files): Added new fles.\n+\t* sanitizer_common/Makefile.in: Regenerate.\n+\t* lsan/Makefile.am (lsan_files): Added new files.\n+\t* lsan/Makefile.in: Regenerate.\n+\n 2013-11-29  Jakub Jelinek  <jakub@redhat.com>\n \t    Yury Gribov  <y.gribov@samsung.com>\n "}, {"sha": "084cd2d4ee6e53e1a4f5ba0cde15ce9a083977bb", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -1,4 +1,4 @@\n-191666\n+196090\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "763f4a58ef9f3c0e31f0ac96aa477c4eca7b7f3c", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -33,10 +33,11 @@ void InitializeAllocator();\n class AsanChunkView {\n  public:\n   explicit AsanChunkView(AsanChunk *chunk) : chunk_(chunk) {}\n-  bool IsValid() { return chunk_ != 0; }\n-  uptr Beg();       // first byte of user memory.\n-  uptr End();       // last byte of user memory.\n-  uptr UsedSize();  // size requested by the user.\n+  bool IsValid();   // Checks if AsanChunkView points to a valid allocated\n+                    // or quarantined chunk.\n+  uptr Beg();       // First byte of user memory.\n+  uptr End();       // Last byte of user memory.\n+  uptr UsedSize();  // Size requested by the user.\n   uptr AllocTid();\n   uptr FreeTid();\n   void GetAllocStack(StackTrace *stack);\n@@ -88,16 +89,12 @@ class AsanChunkFifoList: public IntrusiveList<AsanChunk> {\n };\n \n struct AsanThreadLocalMallocStorage {\n-  explicit AsanThreadLocalMallocStorage(LinkerInitialized x)\n-      { }\n-  AsanThreadLocalMallocStorage() {\n-    CHECK(REAL(memset));\n-    REAL(memset)(this, 0, sizeof(AsanThreadLocalMallocStorage));\n-  }\n-\n   uptr quarantine_cache[16];\n   uptr allocator2_cache[96 * (512 * 8 + 16)];  // Opaque.\n   void CommitBack();\n+ private:\n+  // These objects are allocated via mmap() and are zero-initialized.\n+  AsanThreadLocalMallocStorage() {}\n };\n \n void *asan_memalign(uptr alignment, uptr size, StackTrace *stack,\n@@ -112,7 +109,7 @@ void *asan_pvalloc(uptr size, StackTrace *stack);\n \n int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n                           StackTrace *stack);\n-uptr asan_malloc_usable_size(void *ptr, StackTrace *stack);\n+uptr asan_malloc_usable_size(void *ptr, uptr pc, uptr bp);\n \n uptr asan_mz_size(const void *ptr);\n void asan_mz_force_lock();"}, {"sha": "b9d66dc7a4ad885a071dddee7623d2c86d374819", "filename": "libsanitizer/asan/asan_allocator2.cc", "status": "modified", "additions": 31, "deletions": 40, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_allocator2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_allocator2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator2.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -92,7 +92,7 @@ AllocatorCache *GetAllocatorCache(AsanThreadLocalMallocStorage *ms) {\n static Allocator allocator;\n \n static const uptr kMaxAllowedMallocSize =\n-  FIRST_32_SECOND_64(3UL << 30, 8UL << 30);\n+  FIRST_32_SECOND_64(3UL << 30, 64UL << 30);\n \n static const uptr kMaxThreadLocalQuarantine =\n   FIRST_32_SECOND_64(1 << 18, 1 << 20);\n@@ -184,14 +184,19 @@ COMPILER_CHECK(kChunkHeader2Size <= 16);\n \n struct AsanChunk: ChunkBase {\n   uptr Beg() { return reinterpret_cast<uptr>(this) + kChunkHeaderSize; }\n-  uptr UsedSize() {\n+  uptr UsedSize(bool locked_version = false) {\n     if (user_requested_size != SizeClassMap::kMaxSize)\n       return user_requested_size;\n-    return *reinterpret_cast<uptr *>(allocator.GetMetaData(AllocBeg()));\n-  }\n-  void *AllocBeg() {\n-    if (from_memalign)\n+    return *reinterpret_cast<uptr *>(\n+                allocator.GetMetaData(AllocBeg(locked_version)));\n+  }\n+  void *AllocBeg(bool locked_version = false) {\n+    if (from_memalign) {\n+      if (locked_version)\n+        return allocator.GetBlockBeginFastLocked(\n+            reinterpret_cast<void *>(this));\n       return allocator.GetBlockBegin(reinterpret_cast<void *>(this));\n+    }\n     return reinterpret_cast<void*>(Beg() - RZLog2Size(rz_log));\n   }\n   // If we don't use stack depot, we store the alloc/free stack traces\n@@ -211,11 +216,14 @@ struct AsanChunk: ChunkBase {\n     uptr available = RoundUpTo(user_requested_size, SHADOW_GRANULARITY);\n     return (available - kChunkHeader2Size) / sizeof(u32);\n   }\n-  bool AddrIsInside(uptr addr) {\n-    return (addr >= Beg()) && (addr < Beg() + UsedSize());\n+  bool AddrIsInside(uptr addr, bool locked_version = false) {\n+    return (addr >= Beg()) && (addr < Beg() + UsedSize(locked_version));\n   }\n };\n \n+bool AsanChunkView::IsValid() {\n+  return chunk_ != 0 && chunk_->chunk_state != CHUNK_AVAILABLE;\n+}\n uptr AsanChunkView::Beg() { return chunk_->Beg(); }\n uptr AsanChunkView::End() { return Beg() + UsedSize(); }\n uptr AsanChunkView::UsedSize() { return chunk_->UsedSize(); }\n@@ -226,25 +234,16 @@ static void GetStackTraceFromId(u32 id, StackTrace *stack) {\n   CHECK(id);\n   uptr size = 0;\n   const uptr *trace = StackDepotGet(id, &size);\n-  CHECK_LT(size, kStackTraceMax);\n-  internal_memcpy(stack->trace, trace, sizeof(uptr) * size);\n-  stack->size = size;\n+  CHECK(trace);\n+  stack->CopyFrom(trace, size);\n }\n \n void AsanChunkView::GetAllocStack(StackTrace *stack) {\n-  if (flags()->use_stack_depot)\n-    GetStackTraceFromId(chunk_->alloc_context_id, stack);\n-  else\n-    StackTrace::UncompressStack(stack, chunk_->AllocStackBeg(),\n-                                chunk_->AllocStackSize());\n+  GetStackTraceFromId(chunk_->alloc_context_id, stack);\n }\n \n void AsanChunkView::GetFreeStack(StackTrace *stack) {\n-  if (flags()->use_stack_depot)\n-    GetStackTraceFromId(chunk_->free_context_id, stack);\n-  else\n-    StackTrace::UncompressStack(stack, chunk_->FreeStackBeg(),\n-                                chunk_->FreeStackSize());\n+  GetStackTraceFromId(chunk_->free_context_id, stack);\n }\n \n struct QuarantineCallback;\n@@ -390,12 +389,7 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n     meta[1] = chunk_beg;\n   }\n \n-  if (fl.use_stack_depot) {\n-    m->alloc_context_id = StackDepotPut(stack->trace, stack->size);\n-  } else {\n-    m->alloc_context_id = 0;\n-    StackTrace::CompressStack(stack, m->AllocStackBeg(), m->AllocStackSize());\n-  }\n+  m->alloc_context_id = StackDepotPut(stack->trace, stack->size);\n \n   uptr size_rounded_down_to_granularity = RoundDownTo(size, SHADOW_GRANULARITY);\n   // Unpoison the bulk of the memory region.\n@@ -404,7 +398,7 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n   // Deal with the end of the region if size is not aligned to granularity.\n   if (size != size_rounded_down_to_granularity && fl.poison_heap) {\n     u8 *shadow = (u8*)MemToShadow(user_beg + size_rounded_down_to_granularity);\n-    *shadow = size & (SHADOW_GRANULARITY - 1);\n+    *shadow = fl.poison_partial ? (size & (SHADOW_GRANULARITY - 1)) : 0;\n   }\n \n   AsanStats &thread_stats = GetCurrentThreadStats();\n@@ -463,12 +457,7 @@ static void QuarantineChunk(AsanChunk *m, void *ptr,\n     CHECK_EQ(m->free_tid, kInvalidTid);\n   AsanThread *t = GetCurrentThread();\n   m->free_tid = t ? t->tid() : 0;\n-  if (flags()->use_stack_depot) {\n-    m->free_context_id = StackDepotPut(stack->trace, stack->size);\n-  } else {\n-    m->free_context_id = 0;\n-    StackTrace::CompressStack(stack, m->FreeStackBeg(), m->FreeStackSize());\n-  }\n+  m->free_context_id = StackDepotPut(stack->trace, stack->size);\n   // Poison the region.\n   PoisonShadow(m->Beg(),\n                RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n@@ -673,12 +662,13 @@ int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n   return 0;\n }\n \n-uptr asan_malloc_usable_size(void *ptr, StackTrace *stack) {\n-  CHECK(stack);\n+uptr asan_malloc_usable_size(void *ptr, uptr pc, uptr bp) {\n   if (ptr == 0) return 0;\n   uptr usable_size = AllocationSize(reinterpret_cast<uptr>(ptr));\n-  if (flags()->check_malloc_usable_size && (usable_size == 0))\n-    ReportMallocUsableSizeNotOwned((uptr)ptr, stack);\n+  if (flags()->check_malloc_usable_size && (usable_size == 0)) {\n+    GET_STACK_TRACE_FATAL(pc, bp);\n+    ReportMallocUsableSizeNotOwned((uptr)ptr, &stack);\n+  }\n   return usable_size;\n }\n \n@@ -718,7 +708,8 @@ uptr PointsIntoChunk(void* p) {\n   __asan::AsanChunk *m = __asan::GetAsanChunkByAddrFastLocked(addr);\n   if (!m) return 0;\n   uptr chunk = m->Beg();\n-  if ((m->chunk_state == __asan::CHUNK_ALLOCATED) && m->AddrIsInside(addr))\n+  if ((m->chunk_state == __asan::CHUNK_ALLOCATED) &&\n+      m->AddrIsInside(addr, /*locked_version=*/true))\n     return chunk;\n   return 0;\n }\n@@ -751,7 +742,7 @@ void LsanMetadata::set_tag(ChunkTag value) {\n \n uptr LsanMetadata::requested_size() const {\n   __asan::AsanChunk *m = reinterpret_cast<__asan::AsanChunk *>(metadata_);\n-  return m->UsedSize();\n+  return m->UsedSize(/*locked_version=*/true);\n }\n \n u32 LsanMetadata::stack_trace_id() const {"}, {"sha": "19c31f0def8f39740e65e41d299820f707203326", "filename": "libsanitizer/asan/asan_dll_thunk.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_dll_thunk.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -130,6 +130,8 @@ extern \"C\" {\n   }\n }\n \n+WRAP_V_V(__asan_handle_no_return)\n+\n WRAP_V_W(__asan_report_store1)\n WRAP_V_W(__asan_report_store2)\n WRAP_V_W(__asan_report_store4)"}, {"sha": "cf4122472efe4c125af6500ec7fc935fb3c08a9b", "filename": "libsanitizer/asan/asan_fake_stack.cc", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -43,7 +43,7 @@ FakeStack *FakeStack::Create(uptr stack_size_log) {\n   FakeStack *res = reinterpret_cast<FakeStack *>(\n       MmapOrDie(RequiredSize(stack_size_log), \"FakeStack\"));\n   res->stack_size_log_ = stack_size_log;\n-  if (flags()->verbosity) {\n+  if (common_flags()->verbosity) {\n     u8 *p = reinterpret_cast<u8 *>(res);\n     Report(\"T%d: FakeStack created: %p -- %p stack_size_log: %zd \\n\",\n            GetCurrentTidOrInvalid(), p,\n@@ -132,6 +132,20 @@ NOINLINE void FakeStack::GC(uptr real_stack) {\n   needs_gc_ = false;\n }\n \n+void FakeStack::ForEachFakeFrame(RangeIteratorCallback callback, void *arg) {\n+  for (uptr class_id = 0; class_id < kNumberOfSizeClasses; class_id++) {\n+    u8 *flags = GetFlags(stack_size_log(), class_id);\n+    for (uptr i = 0, n = NumberOfFrames(stack_size_log(), class_id); i < n;\n+         i++) {\n+      if (flags[i] == 0) continue;  // not allocated.\n+      FakeFrame *ff = reinterpret_cast<FakeFrame *>(\n+          GetFrame(stack_size_log(), class_id, i));\n+      uptr begin = reinterpret_cast<uptr>(ff);\n+      callback(begin, begin + FakeStack::BytesInSizeClass(class_id), arg);\n+    }\n+  }\n+}\n+\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n static THREADLOCAL FakeStack *fake_stack_tls;\n "}, {"sha": "5196025681cf3b2dda788a0fdae22ead2a8bfdb1", "filename": "libsanitizer/asan/asan_fake_stack.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_fake_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_fake_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -146,6 +146,8 @@ class FakeStack {\n   void HandleNoReturn();\n   void GC(uptr real_stack);\n \n+  void ForEachFakeFrame(RangeIteratorCallback callback, void *arg);\n+\n  private:\n   FakeStack() { }\n   static const uptr kFlagsOffset = 4096;  // This is were the flags begin."}, {"sha": "62b5d3215d34ca37d57f3f22aa63640352675fbc", "filename": "libsanitizer/asan/asan_flags.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -30,8 +30,6 @@ struct Flags {\n   // Lower value may reduce memory usage but increase the chance of\n   // false negatives.\n   int  quarantine_size;\n-  // Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\n-  int  verbosity;\n   // Size (in bytes) of redzones around heap objects.\n   // Requirement: redzone >= 32, is a power of two.\n   int  redzone;\n@@ -83,6 +81,9 @@ struct Flags {\n   bool print_legend;\n   // If set, prints ASan exit stats even after program terminates successfully.\n   bool atexit;\n+  // If set, coverage information will be dumped at shutdown time if the\n+  // appropriate instrumentation was enabled.\n+  bool coverage;\n   // By default, disable core dumper on 64-bit - it makes little sense\n   // to dump 16T+ core.\n   bool disable_core;\n@@ -96,10 +97,11 @@ struct Flags {\n   // Poison (or not) the heap memory on [de]allocation. Zero value is useful\n   // for benchmarking the allocator or instrumentator.\n   bool poison_heap;\n+  // If true, poison partially addressable 8-byte aligned words (default=true).\n+  // This flag affects heap and global buffers, but not stack buffers.\n+  bool poison_partial;\n   // Report errors on malloc/delete, new/free, new/delete[], etc.\n   bool alloc_dealloc_mismatch;\n-  // Use stack depot instead of storing stacks in the redzones.\n-  bool use_stack_depot;\n   // If true, assume that memcmp(p1, p2, n) always reads n bytes before\n   // comparing p1 and p2.\n   bool strict_memcmp;"}, {"sha": "e97850a854aa2dca2f5189a0c44366dcf016869c", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -92,15 +92,13 @@ static void RegisterGlobal(const Global *g) {\n   CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n   if (flags()->poison_heap)\n     PoisonRedZones(*g);\n-  ListOfGlobals *l =\n-      (ListOfGlobals*)allocator_for_globals.Allocate(sizeof(ListOfGlobals));\n+  ListOfGlobals *l = new(allocator_for_globals) ListOfGlobals;\n   l->g = g;\n   l->next = list_of_all_globals;\n   list_of_all_globals = l;\n   if (g->has_dynamic_init) {\n     if (dynamic_init_globals == 0) {\n-      void *mem = allocator_for_globals.Allocate(sizeof(VectorOfGlobals));\n-      dynamic_init_globals = new(mem)\n+      dynamic_init_globals = new(allocator_for_globals)\n           VectorOfGlobals(kDynamicInitGlobalsInitialCapacity);\n     }\n     DynInitGlobal dyn_global = { *g, false };"}, {"sha": "decbfea5f755332b36dccc3d74e9678e79831738", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -92,6 +92,11 @@ void SetThreadName(const char *name) {\n     asanThreadRegistry().SetThreadName(t->tid(), name);\n }\n \n+int OnExit() {\n+  // FIXME: ask frontend whether we need to return failure.\n+  return 0;\n+}\n+\n }  // namespace __asan\n \n // ---------------------- Wrappers ---------------- {{{1\n@@ -100,6 +105,19 @@ using namespace __asan;  // NOLINT\n DECLARE_REAL_AND_INTERCEPTOR(void *, malloc, uptr)\n DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n \n+#if !SANITIZER_MAC\n+#define ASAN_INTERCEPT_FUNC(name)                                      \\\n+  do {                                                                 \\\n+    if ((!INTERCEPT_FUNCTION(name) || !REAL(name)) &&                  \\\n+        common_flags()->verbosity > 0)                                 \\\n+      Report(\"AddressSanitizer: failed to intercept '\" #name \"'\\n\");   \\\n+  } while (0)\n+#else\n+// OS X interceptors don't need to be initialized with INTERCEPT_FUNCTION.\n+#define ASAN_INTERCEPT_FUNC(name)\n+#endif  // SANITIZER_MAC\n+\n+#define COMMON_INTERCEPT_FUNCTION(name) ASAN_INTERCEPT_FUNC(name)\n #define COMMON_INTERCEPTOR_UNPOISON_PARAM(ctx, count) \\\n   do {                                                \\\n   } while (false)\n@@ -124,16 +142,28 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n   do {                                                      \\\n   } while (false)\n #define COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, name) SetThreadName(name)\n+// Should be asanThreadRegistry().SetThreadNameByUserId(thread, name)\n+// But asan does not remember UserId's for threads (pthread_t);\n+// and remembers all ever existed threads, so the linear search by UserId\n+// can be slow.\n+#define COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, name) \\\n+  do {                                                         \\\n+  } while (false)\n #define COMMON_INTERCEPTOR_BLOCK_REAL(name) REAL(name)\n+#define COMMON_INTERCEPTOR_ON_EXIT(ctx) OnExit()\n #include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n \n #define COMMON_SYSCALL_PRE_READ_RANGE(p, s) ASAN_READ_RANGE(p, s)\n #define COMMON_SYSCALL_PRE_WRITE_RANGE(p, s) ASAN_WRITE_RANGE(p, s)\n #define COMMON_SYSCALL_POST_READ_RANGE(p, s) \\\n   do {                                       \\\n+    (void)(p);                               \\\n+    (void)(s);                               \\\n   } while (false)\n #define COMMON_SYSCALL_POST_WRITE_RANGE(p, s) \\\n   do {                                        \\\n+    (void)(p);                                \\\n+    (void)(s);                                \\\n   } while (false)\n #include \"sanitizer_common/sanitizer_common_syscalls.inc\"\n \n@@ -144,8 +174,6 @@ static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n }\n \n #if ASAN_INTERCEPT_PTHREAD_CREATE\n-extern \"C\" int pthread_attr_getdetachstate(void *attr, int *v);\n-\n INTERCEPTOR(int, pthread_create, void *thread,\n     void *attr, void *(*start_routine)(void*), void *arg) {\n   EnsureMainThreadIDIsCorrect();\n@@ -155,7 +183,7 @@ INTERCEPTOR(int, pthread_create, void *thread,\n   GET_STACK_TRACE_THREAD;\n   int detached = 0;\n   if (attr != 0)\n-    pthread_attr_getdetachstate(attr, &detached);\n+    REAL(pthread_attr_getdetachstate)(attr, &detached);\n \n   u32 current_tid = GetCurrentTidOrInvalid();\n   AsanThread *t = AsanThread::Create(start_routine, arg);\n@@ -256,7 +284,7 @@ static void MlockIsUnsupported() {\n   static bool printed = false;\n   if (printed) return;\n   printed = true;\n-  if (flags()->verbosity > 0) {\n+  if (common_flags()->verbosity > 0) {\n     Printf(\"INFO: AddressSanitizer ignores \"\n            \"mlock/mlockall/munlock/munlockall\\n\");\n   }\n@@ -645,16 +673,6 @@ INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n }\n #endif  // ASAN_INTERCEPT___CXA_ATEXIT\n \n-#if !SANITIZER_MAC\n-#define ASAN_INTERCEPT_FUNC(name) do { \\\n-      if (!INTERCEPT_FUNCTION(name) && flags()->verbosity > 0) \\\n-        Report(\"AddressSanitizer: failed to intercept '\" #name \"'\\n\"); \\\n-    } while (0)\n-#else\n-// OS X interceptors don't need to be initialized with INTERCEPT_FUNCTION.\n-#define ASAN_INTERCEPT_FUNC(name)\n-#endif  // SANITIZER_MAC\n-\n #if SANITIZER_WINDOWS\n INTERCEPTOR_WINAPI(DWORD, CreateThread,\n                    void* security, uptr stack_size,\n@@ -767,7 +785,7 @@ void InitializeAsanInterceptors() {\n   InitializeWindowsInterceptors();\n #endif\n \n-  if (flags()->verbosity > 0) {\n+  if (common_flags()->verbosity > 0) {\n     Report(\"AddressSanitizer: libc interceptors initialized\\n\");\n   }\n }"}, {"sha": "ede273a71701b7efe7b8e50a47a484f084a6254c", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -96,6 +96,7 @@ void StopInitOrderChecking();\n void AsanTSDInit(void (*destructor)(void *tsd));\n void *AsanTSDGet();\n void AsanTSDSet(void *tsd);\n+void PlatformTSDDtor(void *tsd);\n \n void AppendToErrorMessageBuffer(const char *buffer);\n \n@@ -133,6 +134,7 @@ const int kAsanStackPartialRedzoneMagic = 0xf4;\n const int kAsanStackAfterReturnMagic = 0xf5;\n const int kAsanInitializationOrderMagic = 0xf6;\n const int kAsanUserPoisonedMemoryMagic = 0xf7;\n+const int kAsanContiguousContainerOOBMagic = 0xfc;\n const int kAsanStackUseAfterScopeMagic = 0xf8;\n const int kAsanGlobalRedzoneMagic = 0xf9;\n const int kAsanInternalHeapMagic = 0xfe;"}, {"sha": "0692eb1f455d037226e258526d4523029a9c15e2", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -56,6 +56,12 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   *pc = ucontext->uc_mcontext.arm_pc;\n   *bp = ucontext->uc_mcontext.arm_fp;\n   *sp = ucontext->uc_mcontext.arm_sp;\n+# elif defined(__hppa__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+  *pc = ucontext->uc_mcontext.sc_iaoq[0];\n+  /* GCC uses %r3 whenever a frame pointer is needed.  */\n+  *bp = ucontext->uc_mcontext.sc_gr[3];\n+  *sp = ucontext->uc_mcontext.sc_gr[30];\n # elif defined(__x86_64__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.gregs[REG_RIP];"}, {"sha": "8d01843afafb7157e7e5b56614ee25ff50b9e7c6", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -172,7 +172,7 @@ void MaybeReexec() {\n       // Set DYLD_INSERT_LIBRARIES equal to the runtime dylib name.\n       setenv(kDyldInsertLibraries, info.dli_fname, /*overwrite*/0);\n     }\n-    if (flags()->verbosity >= 1) {\n+    if (common_flags()->verbosity >= 1) {\n       Report(\"exec()-ing the program with\\n\");\n       Report(\"%s=%s\\n\", kDyldInsertLibraries, new_env);\n       Report(\"to enable ASan wrappers.\\n\");\n@@ -309,7 +309,7 @@ extern \"C\"\n void asan_dispatch_call_block_and_release(void *block) {\n   GET_STACK_TRACE_THREAD;\n   asan_block_context_t *context = (asan_block_context_t*)block;\n-  if (flags()->verbosity >= 2) {\n+  if (common_flags()->verbosity >= 2) {\n     Report(\"asan_dispatch_call_block_and_release(): \"\n            \"context: %p, pthread_self: %p\\n\",\n            block, pthread_self());\n@@ -344,7 +344,7 @@ asan_block_context_t *alloc_asan_context(void *ctxt, dispatch_function_t func,\n                                   dispatch_function_t func) {                 \\\n     GET_STACK_TRACE_THREAD;                                                   \\\n     asan_block_context_t *asan_ctxt = alloc_asan_context(ctxt, func, &stack); \\\n-    if (flags()->verbosity >= 2) {                                            \\\n+    if (common_flags()->verbosity >= 2) {                                     \\\n       Report(#dispatch_x_f \"(): context: %p, pthread_self: %p\\n\",             \\\n              asan_ctxt, pthread_self());                                      \\\n        PRINT_CURRENT_STACK();                                                 \\\n@@ -362,7 +362,7 @@ INTERCEPTOR(void, dispatch_after_f, dispatch_time_t when,\n                                     dispatch_function_t func) {\n   GET_STACK_TRACE_THREAD;\n   asan_block_context_t *asan_ctxt = alloc_asan_context(ctxt, func, &stack);\n-  if (flags()->verbosity >= 2) {\n+  if (common_flags()->verbosity >= 2) {\n     Report(\"dispatch_after_f: %p\\n\", asan_ctxt);\n     PRINT_CURRENT_STACK();\n   }\n@@ -375,7 +375,7 @@ INTERCEPTOR(void, dispatch_group_async_f, dispatch_group_t group,\n                                           dispatch_function_t func) {\n   GET_STACK_TRACE_THREAD;\n   asan_block_context_t *asan_ctxt = alloc_asan_context(ctxt, func, &stack);\n-  if (flags()->verbosity >= 2) {\n+  if (common_flags()->verbosity >= 2) {\n     Report(\"dispatch_group_async_f(): context: %p, pthread_self: %p\\n\",\n            asan_ctxt, pthread_self());\n     PRINT_CURRENT_STACK();"}, {"sha": "e3495cb090068605b60074b8a0e4e237d0937fc7", "filename": "libsanitizer/asan/asan_malloc_linux.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -103,8 +103,9 @@ INTERCEPTOR(void*, __libc_memalign, uptr align, uptr s)\n   ALIAS(\"memalign\");\n \n INTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_malloc_usable_size(ptr, &stack);\n+  GET_CURRENT_PC_BP_SP;\n+  (void)sp;\n+  return asan_malloc_usable_size(ptr, pc, bp);\n }\n \n // We avoid including malloc.h for portability reasons."}, {"sha": "1f2495ffc5090ae455852a913dd47ed8d850a40d", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -96,8 +96,9 @@ void* _recalloc(void* p, size_t n, size_t elem_size) {\n \n SANITIZER_INTERFACE_ATTRIBUTE\n size_t _msize(void *ptr) {\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_malloc_usable_size(ptr, &stack);\n+  GET_CURRENT_PC_BP_SP;\n+  (void)sp;\n+  return asan_malloc_usable_size(ptr, pc, bp);\n }\n \n int _CrtDbgReport(int, const char*, int,"}, {"sha": "86d49909b68f7eeaa951c83721d784d4a2799212", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -12,6 +12,7 @@\n \n #include \"asan_poisoning.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_flags.h\"\n \n namespace __asan {\n \n@@ -66,7 +67,7 @@ void __asan_poison_memory_region(void const volatile *addr, uptr size) {\n   if (!flags()->allow_user_poisoning || size == 0) return;\n   uptr beg_addr = (uptr)addr;\n   uptr end_addr = beg_addr + size;\n-  if (flags()->verbosity >= 1) {\n+  if (common_flags()->verbosity >= 1) {\n     Printf(\"Trying to poison memory region [%p, %p)\\n\",\n            (void*)beg_addr, (void*)end_addr);\n   }\n@@ -108,7 +109,7 @@ void __asan_unpoison_memory_region(void const volatile *addr, uptr size) {\n   if (!flags()->allow_user_poisoning || size == 0) return;\n   uptr beg_addr = (uptr)addr;\n   uptr end_addr = beg_addr + size;\n-  if (flags()->verbosity >= 1) {\n+  if (common_flags()->verbosity >= 1) {\n     Printf(\"Trying to unpoison memory region [%p, %p)\\n\",\n            (void*)beg_addr, (void*)end_addr);\n   }\n@@ -242,13 +243,57 @@ static void PoisonAlignedStackMemory(uptr addr, uptr size, bool do_poison) {\n }\n \n void __asan_poison_stack_memory(uptr addr, uptr size) {\n-  if (flags()->verbosity > 0)\n+  if (common_flags()->verbosity > 0)\n     Report(\"poisoning: %p %zx\\n\", (void*)addr, size);\n   PoisonAlignedStackMemory(addr, size, true);\n }\n \n void __asan_unpoison_stack_memory(uptr addr, uptr size) {\n-  if (flags()->verbosity > 0)\n+  if (common_flags()->verbosity > 0)\n     Report(\"unpoisoning: %p %zx\\n\", (void*)addr, size);\n   PoisonAlignedStackMemory(addr, size, false);\n }\n+\n+void __sanitizer_annotate_contiguous_container(const void *beg_p,\n+                                               const void *end_p,\n+                                               const void *old_mid_p,\n+                                               const void *new_mid_p) {\n+  if (common_flags()->verbosity >= 2)\n+    Printf(\"contiguous_container: %p %p %p %p\\n\", beg_p, end_p, old_mid_p,\n+           new_mid_p);\n+  uptr beg = reinterpret_cast<uptr>(beg_p);\n+  uptr end= reinterpret_cast<uptr>(end_p);\n+  uptr old_mid = reinterpret_cast<uptr>(old_mid_p);\n+  uptr new_mid = reinterpret_cast<uptr>(new_mid_p);\n+  uptr granularity = SHADOW_GRANULARITY;\n+  CHECK(beg <= old_mid && beg <= new_mid && old_mid <= end && new_mid <= end &&\n+        IsAligned(beg, granularity));\n+  CHECK_LE(end - beg,\n+           FIRST_32_SECOND_64(1UL << 30, 1UL << 34)); // Sanity check.\n+\n+  uptr a = RoundDownTo(Min(old_mid, new_mid), granularity);\n+  uptr c = RoundUpTo(Max(old_mid, new_mid), granularity);\n+  uptr d1 = RoundDownTo(old_mid, granularity);\n+  uptr d2 = RoundUpTo(old_mid, granularity);\n+  // Currently we should be in this state:\n+  // [a, d1) is good, [d2, c) is bad, [d1, d2) is partially good.\n+  // Make a quick sanity check that we are indeed in this state.\n+  if (d1 != d2)\n+    CHECK_EQ(*(u8*)MemToShadow(d1), old_mid - d1);\n+  if (a + granularity <= d1)\n+    CHECK_EQ(*(u8*)MemToShadow(a), 0);\n+  if (d2 + granularity <= c && c <= end)\n+    CHECK_EQ(*(u8 *)MemToShadow(c - granularity),\n+             kAsanContiguousContainerOOBMagic);\n+\n+  uptr b1 = RoundDownTo(new_mid, granularity);\n+  uptr b2 = RoundUpTo(new_mid, granularity);\n+  // New state:\n+  // [a, b1) is good, [b2, c) is bad, [b1, b2) is partially good.\n+  PoisonShadow(a, b1 - a, 0);\n+  PoisonShadow(b2, c - b2, kAsanContiguousContainerOOBMagic);\n+  if (b1 != b2) {\n+    CHECK_EQ(b2 - b1, granularity);\n+    *(u8*)MemToShadow(b1) = static_cast<u8>(new_mid - b1);\n+  }\n+}"}, {"sha": "da79a0ff2e40c4bc25919d980b96b7a9f007bd1e", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -41,6 +41,7 @@ ALWAYS_INLINE void FastPoisonShadow(uptr aligned_beg, uptr aligned_size,\n ALWAYS_INLINE void FastPoisonShadowPartialRightRedzone(\n     uptr aligned_addr, uptr size, uptr redzone_size, u8 value) {\n   DCHECK(flags()->poison_heap);\n+  bool poison_partial = flags()->poison_partial;\n   u8 *shadow = (u8*)MEM_TO_SHADOW(aligned_addr);\n   for (uptr i = 0; i < redzone_size; i += SHADOW_GRANULARITY, shadow++) {\n     if (i + SHADOW_GRANULARITY <= size) {\n@@ -49,7 +50,7 @@ ALWAYS_INLINE void FastPoisonShadowPartialRightRedzone(\n       *shadow = (SHADOW_GRANULARITY == 128) ? 0xff : value;  // unaddressable\n     } else {\n       // first size-i bytes are addressable\n-      *shadow = static_cast<u8>(size - i);\n+      *shadow = poison_partial ? static_cast<u8>(size - i) : 0;\n     }\n   }\n }"}, {"sha": "ac4ec9e01911e624659f3f8f1dd618bdad03c806", "filename": "libsanitizer/asan/asan_posix.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -1,4 +1,4 @@\n-//===-- asan_linux.cc -----------------------------------------------------===//\n+//===-- asan_posix.cc -----------------------------------------------------===//\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n@@ -42,7 +42,7 @@ static void MaybeInstallSigaction(int signum,\n   sigact.sa_flags = SA_SIGINFO;\n   if (flags()->use_sigaltstack) sigact.sa_flags |= SA_ONSTACK;\n   CHECK_EQ(0, REAL(sigaction)(signum, &sigact, 0));\n-  if (flags()->verbosity >= 1) {\n+  if (common_flags()->verbosity >= 1) {\n     Report(\"Installed the sigaction for signal %d\\n\", signum);\n   }\n }\n@@ -69,7 +69,7 @@ void SetAlternateSignalStack() {\n   altstack.ss_flags = 0;\n   altstack.ss_size = kAltStackSize;\n   CHECK_EQ(0, sigaltstack(&altstack, 0));\n-  if (flags()->verbosity > 0) {\n+  if (common_flags()->verbosity > 0) {\n     Report(\"Alternative stack for T%d set: [%p,%p)\\n\",\n            GetCurrentTidOrInvalid(),\n            altstack.ss_sp, (char*)altstack.ss_sp + altstack.ss_size);\n@@ -114,6 +114,15 @@ void AsanTSDSet(void *tsd) {\n   pthread_setspecific(tsd_key, tsd);\n }\n \n+void PlatformTSDDtor(void *tsd) {\n+  AsanThreadContext *context = (AsanThreadContext*)tsd;\n+  if (context->destructor_iterations > 1) {\n+    context->destructor_iterations--;\n+    CHECK_EQ(0, pthread_setspecific(tsd_key, tsd));\n+    return;\n+  }\n+  AsanThread::TSDDtor(tsd);\n+}\n }  // namespace __asan\n \n #endif  // SANITIZER_LINUX || SANITIZER_MAC"}, {"sha": "70c4b481a2f1d863e61a7055cbde958d46c4dbed", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -18,6 +18,7 @@\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_report_decorator.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n \n namespace __asan {\n@@ -71,6 +72,7 @@ class Decorator: private __sanitizer::AnsiColorDecorator {\n       case kAsanInitializationOrderMagic:\n         return Cyan();\n       case kAsanUserPoisonedMemoryMagic:\n+      case kAsanContiguousContainerOOBMagic:\n         return Blue();\n       case kAsanStackUseAfterScopeMagic:\n         return Magenta();\n@@ -117,19 +119,21 @@ static void PrintLegend() {\n   for (u8 i = 1; i < SHADOW_GRANULARITY; i++)\n     PrintShadowByte(\"\", i, \" \");\n   Printf(\"\\n\");\n-  PrintShadowByte(\"  Heap left redzone:     \", kAsanHeapLeftRedzoneMagic);\n-  PrintShadowByte(\"  Heap right redzone:    \", kAsanHeapRightRedzoneMagic);\n-  PrintShadowByte(\"  Freed heap region:     \", kAsanHeapFreeMagic);\n-  PrintShadowByte(\"  Stack left redzone:    \", kAsanStackLeftRedzoneMagic);\n-  PrintShadowByte(\"  Stack mid redzone:     \", kAsanStackMidRedzoneMagic);\n-  PrintShadowByte(\"  Stack right redzone:   \", kAsanStackRightRedzoneMagic);\n-  PrintShadowByte(\"  Stack partial redzone: \", kAsanStackPartialRedzoneMagic);\n-  PrintShadowByte(\"  Stack after return:    \", kAsanStackAfterReturnMagic);\n-  PrintShadowByte(\"  Stack use after scope: \", kAsanStackUseAfterScopeMagic);\n-  PrintShadowByte(\"  Global redzone:        \", kAsanGlobalRedzoneMagic);\n-  PrintShadowByte(\"  Global init order:     \", kAsanInitializationOrderMagic);\n-  PrintShadowByte(\"  Poisoned by user:      \", kAsanUserPoisonedMemoryMagic);\n-  PrintShadowByte(\"  ASan internal:         \", kAsanInternalHeapMagic);\n+  PrintShadowByte(\"  Heap left redzone:       \", kAsanHeapLeftRedzoneMagic);\n+  PrintShadowByte(\"  Heap right redzone:      \", kAsanHeapRightRedzoneMagic);\n+  PrintShadowByte(\"  Freed heap region:       \", kAsanHeapFreeMagic);\n+  PrintShadowByte(\"  Stack left redzone:      \", kAsanStackLeftRedzoneMagic);\n+  PrintShadowByte(\"  Stack mid redzone:       \", kAsanStackMidRedzoneMagic);\n+  PrintShadowByte(\"  Stack right redzone:     \", kAsanStackRightRedzoneMagic);\n+  PrintShadowByte(\"  Stack partial redzone:   \", kAsanStackPartialRedzoneMagic);\n+  PrintShadowByte(\"  Stack after return:      \", kAsanStackAfterReturnMagic);\n+  PrintShadowByte(\"  Stack use after scope:   \", kAsanStackUseAfterScopeMagic);\n+  PrintShadowByte(\"  Global redzone:          \", kAsanGlobalRedzoneMagic);\n+  PrintShadowByte(\"  Global init order:       \", kAsanInitializationOrderMagic);\n+  PrintShadowByte(\"  Poisoned by user:        \", kAsanUserPoisonedMemoryMagic);\n+  PrintShadowByte(\"  Contiguous container OOB:\",\n+                  kAsanContiguousContainerOOBMagic);\n+  PrintShadowByte(\"  ASan internal:           \", kAsanInternalHeapMagic);\n }\n \n static void PrintShadowMemoryForAddress(uptr addr) {\n@@ -178,8 +182,8 @@ static bool IsASCII(unsigned char c) {\n static const char *MaybeDemangleGlobalName(const char *name) {\n   // We can spoil names of globals with C linkage, so use an heuristic\n   // approach to check if the name should be demangled.\n-  return (name[0] == '_' && name[1] == 'Z' && &getSymbolizer)\n-             ? getSymbolizer()->Demangle(name)\n+  return (name[0] == '_' && name[1] == 'Z')\n+             ? Symbolizer::Get()->Demangle(name)\n              : name;\n }\n \n@@ -412,7 +416,11 @@ static void DescribeAccessToHeapChunk(AsanChunkView chunk, uptr addr,\n \n void DescribeHeapAddress(uptr addr, uptr access_size) {\n   AsanChunkView chunk = FindHeapChunkByAddress(addr);\n-  if (!chunk.IsValid()) return;\n+  if (!chunk.IsValid()) {\n+    Printf(\"AddressSanitizer can not describe address in more detail \"\n+           \"(wild memory access suspected).\\n\");\n+    return;\n+  }\n   DescribeAccessToHeapChunk(chunk, addr, access_size);\n   CHECK(chunk.AllocTid() != kInvalidTid);\n   asanThreadRegistry().CheckLocked();\n@@ -479,7 +487,9 @@ void DescribeThread(AsanThreadContext *context) {\n          context->parent_tid,\n          ThreadNameWithParenthesis(context->parent_tid,\n                                    tname, sizeof(tname)));\n-  PrintStack(&context->stack);\n+  uptr stack_size;\n+  const uptr *stack_trace = StackDepotGet(context->stack_id, &stack_size);\n+  PrintStack(stack_trace, stack_size);\n   // Recursively described parent thread if needed.\n   if (flags()->print_full_thread_history) {\n     AsanThreadContext *parent_context =\n@@ -540,22 +550,6 @@ class ScopedInErrorReport {\n   }\n };\n \n-static void ReportSummary(const char *error_type, StackTrace *stack) {\n-  if (!stack->size) return;\n-  if (&getSymbolizer && getSymbolizer()->IsAvailable()) {\n-    AddressInfo ai;\n-    // Currently, we include the first stack frame into the report summary.\n-    // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n-    uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n-    getSymbolizer()->SymbolizeCode(pc, &ai, 1);\n-    ReportErrorSummary(error_type,\n-                       StripPathPrefix(ai.file,\n-                                       common_flags()->strip_path_prefix),\n-                       ai.line, ai.function);\n-  }\n-  // FIXME: do we need to print anything at all if there is no symbolizer?\n-}\n-\n void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n@@ -565,13 +559,13 @@ void ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr) {\n              (void*)addr, (void*)pc, (void*)sp, (void*)bp,\n              GetCurrentTidOrInvalid());\n   Printf(\"%s\", d.EndWarning());\n-  Printf(\"AddressSanitizer can not provide additional info.\\n\");\n   GET_STACK_TRACE_FATAL(pc, bp);\n   PrintStack(&stack);\n-  ReportSummary(\"SEGV\", &stack);\n+  Printf(\"AddressSanitizer can not provide additional info.\\n\");\n+  ReportErrorSummary(\"SEGV\", &stack);\n }\n \n-void ReportDoubleFree(uptr addr, StackTrace *stack) {\n+void ReportDoubleFree(uptr addr, StackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n@@ -581,14 +575,15 @@ void ReportDoubleFree(uptr addr, StackTrace *stack) {\n          \"thread T%d%s:\\n\",\n          addr, curr_tid,\n          ThreadNameWithParenthesis(curr_tid, tname, sizeof(tname)));\n-\n   Printf(\"%s\", d.EndWarning());\n-  PrintStack(stack);\n+  CHECK_GT(free_stack->size, 0);\n+  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n+  PrintStack(&stack);\n   DescribeHeapAddress(addr, 1);\n-  ReportSummary(\"double-free\", stack);\n+  ReportErrorSummary(\"double-free\", &stack);\n }\n \n-void ReportFreeNotMalloced(uptr addr, StackTrace *stack) {\n+void ReportFreeNotMalloced(uptr addr, StackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n@@ -598,12 +593,14 @@ void ReportFreeNotMalloced(uptr addr, StackTrace *stack) {\n              \"which was not malloc()-ed: %p in thread T%d%s\\n\", addr,\n          curr_tid, ThreadNameWithParenthesis(curr_tid, tname, sizeof(tname)));\n   Printf(\"%s\", d.EndWarning());\n-  PrintStack(stack);\n+  CHECK_GT(free_stack->size, 0);\n+  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n+  PrintStack(&stack);\n   DescribeHeapAddress(addr, 1);\n-  ReportSummary(\"bad-free\", stack);\n+  ReportErrorSummary(\"bad-free\", &stack);\n }\n \n-void ReportAllocTypeMismatch(uptr addr, StackTrace *stack,\n+void ReportAllocTypeMismatch(uptr addr, StackTrace *free_stack,\n                              AllocType alloc_type,\n                              AllocType dealloc_type) {\n   static const char *alloc_names[] =\n@@ -617,9 +614,11 @@ void ReportAllocTypeMismatch(uptr addr, StackTrace *stack,\n   Report(\"ERROR: AddressSanitizer: alloc-dealloc-mismatch (%s vs %s) on %p\\n\",\n         alloc_names[alloc_type], dealloc_names[dealloc_type], addr);\n   Printf(\"%s\", d.EndWarning());\n-  PrintStack(stack);\n+  CHECK_GT(free_stack->size, 0);\n+  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n+  PrintStack(&stack);\n   DescribeHeapAddress(addr, 1);\n-  ReportSummary(\"alloc-dealloc-mismatch\", stack);\n+  ReportErrorSummary(\"alloc-dealloc-mismatch\", &stack);\n   Report(\"HINT: if you don't care about these warnings you may set \"\n          \"ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n\");\n }\n@@ -634,7 +633,7 @@ void ReportMallocUsableSizeNotOwned(uptr addr, StackTrace *stack) {\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n-  ReportSummary(\"bad-malloc_usable_size\", stack);\n+  ReportErrorSummary(\"bad-malloc_usable_size\", stack);\n }\n \n void ReportAsanGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n@@ -647,7 +646,7 @@ void ReportAsanGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n   Printf(\"%s\", d.EndWarning());\n   PrintStack(stack);\n   DescribeHeapAddress(addr, 1);\n-  ReportSummary(\"bad-__asan_get_allocated_size\", stack);\n+  ReportErrorSummary(\"bad-__asan_get_allocated_size\", stack);\n }\n \n void ReportStringFunctionMemoryRangesOverlap(\n@@ -665,7 +664,7 @@ void ReportStringFunctionMemoryRangesOverlap(\n   PrintStack(stack);\n   DescribeAddress((uptr)offset1, length1);\n   DescribeAddress((uptr)offset2, length2);\n-  ReportSummary(bug_type, stack);\n+  ReportErrorSummary(bug_type, stack);\n }\n \n // ----------------------- Mac-specific reports ----------------- {{{1\n@@ -747,6 +746,9 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp,\n       case kAsanUserPoisonedMemoryMagic:\n         bug_descr = \"use-after-poison\";\n         break;\n+      case kAsanContiguousContainerOOBMagic:\n+        bug_descr = \"container-overflow\";\n+        break;\n       case kAsanStackUseAfterScopeMagic:\n         bug_descr = \"stack-use-after-scope\";\n         break;\n@@ -775,7 +777,7 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp,\n   PrintStack(&stack);\n \n   DescribeAddress(addr, access_size);\n-  ReportSummary(bug_descr, &stack);\n+  ReportErrorSummary(bug_descr, &stack);\n   PrintShadowMemoryForAddress(addr);\n }\n "}, {"sha": "e4c756e557fe18eff9710052eb4a8a41aa9d4e39", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -31,9 +31,9 @@ void DescribeThread(AsanThreadContext *context);\n \n // Different kinds of error reports.\n void NORETURN ReportSIGSEGV(uptr pc, uptr sp, uptr bp, uptr addr);\n-void NORETURN ReportDoubleFree(uptr addr, StackTrace *stack);\n-void NORETURN ReportFreeNotMalloced(uptr addr, StackTrace *stack);\n-void NORETURN ReportAllocTypeMismatch(uptr addr, StackTrace *stack,\n+void NORETURN ReportDoubleFree(uptr addr, StackTrace *free_stack);\n+void NORETURN ReportFreeNotMalloced(uptr addr, StackTrace *free_stack);\n+void NORETURN ReportAllocTypeMismatch(uptr addr, StackTrace *free_stack,\n                                       AllocType alloc_type,\n                                       AllocType dealloc_type);\n void NORETURN ReportMallocUsableSizeNotOwned(uptr addr,"}, {"sha": "537d40612aa5424c66d3854f88ac28b184767a45", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -49,6 +49,8 @@ static void AsanDie() {\n       UnmapOrDie((void*)kLowShadowBeg, kHighShadowEnd - kLowShadowBeg);\n     }\n   }\n+  if (flags()->coverage)\n+    __sanitizer_cov_dump();\n   if (death_callback)\n     death_callback();\n   if (flags()->abort_on_error)\n@@ -86,11 +88,11 @@ static const char *MaybeUseAsanDefaultOptionsCompileDefiniton() {\n }\n \n static void ParseFlagsFromString(Flags *f, const char *str) {\n-  ParseCommonFlagsFromString(str);\n-  CHECK((uptr)common_flags()->malloc_context_size <= kStackTraceMax);\n+  CommonFlags *cf = common_flags();\n+  ParseCommonFlagsFromString(cf, str);\n+  CHECK((uptr)cf->malloc_context_size <= kStackTraceMax);\n \n   ParseFlag(str, &f->quarantine_size, \"quarantine_size\");\n-  ParseFlag(str, &f->verbosity, \"verbosity\");\n   ParseFlag(str, &f->redzone, \"redzone\");\n   CHECK_GE(f->redzone, 16);\n   CHECK(IsPowerOfTwo(f->redzone));\n@@ -119,32 +121,25 @@ static void ParseFlagsFromString(Flags *f, const char *str) {\n   ParseFlag(str, &f->print_stats, \"print_stats\");\n   ParseFlag(str, &f->print_legend, \"print_legend\");\n   ParseFlag(str, &f->atexit, \"atexit\");\n+  ParseFlag(str, &f->coverage, \"coverage\");\n   ParseFlag(str, &f->disable_core, \"disable_core\");\n   ParseFlag(str, &f->allow_reexec, \"allow_reexec\");\n   ParseFlag(str, &f->print_full_thread_history, \"print_full_thread_history\");\n   ParseFlag(str, &f->poison_heap, \"poison_heap\");\n+  ParseFlag(str, &f->poison_partial, \"poison_partial\");\n   ParseFlag(str, &f->alloc_dealloc_mismatch, \"alloc_dealloc_mismatch\");\n-  ParseFlag(str, &f->use_stack_depot, \"use_stack_depot\");\n   ParseFlag(str, &f->strict_memcmp, \"strict_memcmp\");\n   ParseFlag(str, &f->strict_init_order, \"strict_init_order\");\n }\n \n void InitializeFlags(Flags *f, const char *env) {\n   CommonFlags *cf = common_flags();\n+  SetCommonFlagsDefaults(cf);\n   cf->external_symbolizer_path = GetEnv(\"ASAN_SYMBOLIZER_PATH\");\n-  cf->symbolize = true;\n   cf->malloc_context_size = kDefaultMallocContextSize;\n-  cf->fast_unwind_on_fatal = false;\n-  cf->fast_unwind_on_malloc = true;\n-  cf->strip_path_prefix = \"\";\n-  cf->handle_ioctl = false;\n-  cf->log_path = 0;\n-  cf->detect_leaks = false;\n-  cf->leak_check_at_exit = true;\n \n   internal_memset(f, 0, sizeof(*f));\n   f->quarantine_size = (ASAN_LOW_MEMORY) ? 1UL << 26 : 1UL << 28;\n-  f->verbosity = 0;\n   f->redzone = 16;\n   f->debug = false;\n   f->report_globals = 1;\n@@ -168,14 +163,15 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->print_stats = false;\n   f->print_legend = true;\n   f->atexit = false;\n+  f->coverage = false;\n   f->disable_core = (SANITIZER_WORDSIZE == 64);\n   f->allow_reexec = true;\n   f->print_full_thread_history = true;\n   f->poison_heap = true;\n+  f->poison_partial = true;\n   // Turn off alloc/dealloc mismatch checker on Mac and Windows for now.\n   // TODO(glider,timurrrr): Fix known issues and enable this back.\n   f->alloc_dealloc_mismatch = (SANITIZER_MAC == 0) && (SANITIZER_WINDOWS == 0);\n-  f->use_stack_depot = true;\n   f->strict_memcmp = true;\n   f->strict_init_order = false;\n \n@@ -184,7 +180,7 @@ void InitializeFlags(Flags *f, const char *env) {\n \n   // Override from user-specified string.\n   ParseFlagsFromString(f, MaybeCallAsanDefaultOptions());\n-  if (flags()->verbosity) {\n+  if (cf->verbosity) {\n     Report(\"Using the defaults from __asan_default_options: %s\\n\",\n            MaybeCallAsanDefaultOptions());\n   }\n@@ -200,10 +196,10 @@ void InitializeFlags(Flags *f, const char *env) {\n   }\n #endif\n \n-  if (cf->detect_leaks && !f->use_stack_depot) {\n-    Report(\"%s: detect_leaks is ignored (requires use_stack_depot).\\n\",\n-           SanitizerToolName);\n-    cf->detect_leaks = false;\n+  // Make \"strict_init_order\" imply \"check_initialization_order\".\n+  // TODO(samsonov): Use a single runtime flag for an init-order checker.\n+  if (f->strict_init_order) {\n+    f->check_initialization_order = true;\n   }\n }\n \n@@ -462,7 +458,7 @@ void __asan_init() {\n   __asan_option_detect_stack_use_after_return =\n       flags()->detect_stack_use_after_return;\n \n-  if (flags()->verbosity && options) {\n+  if (common_flags()->verbosity && options) {\n     Report(\"Parsed ASAN_OPTIONS: %s\\n\", options);\n   }\n \n@@ -472,11 +468,6 @@ void __asan_init() {\n   // Setup internal allocator callback.\n   SetLowLevelAllocateCallback(OnLowLevelAllocate);\n \n-  if (flags()->atexit) {\n-    Atexit(asan_atexit);\n-  }\n-\n-  // interceptors\n   InitializeAsanInterceptors();\n \n   ReplaceSystemMalloc();\n@@ -495,7 +486,7 @@ void __asan_init() {\n   }\n #endif\n \n-  if (flags()->verbosity)\n+  if (common_flags()->verbosity)\n     PrintAddressSpaceLayout();\n \n   if (flags()->disable_core) {\n@@ -531,24 +522,32 @@ void __asan_init() {\n     Die();\n   }\n \n+  AsanTSDInit(PlatformTSDDtor);\n   InstallSignalHandlers();\n \n-  AsanTSDInit(AsanThread::TSDDtor);\n   // Allocator should be initialized before starting external symbolizer, as\n   // fork() on Mac locks the allocator.\n   InitializeAllocator();\n \n   // Start symbolizer process if necessary.\n-  if (common_flags()->symbolize && &getSymbolizer) {\n-    getSymbolizer()\n-        ->InitializeExternal(common_flags()->external_symbolizer_path);\n+  if (common_flags()->symbolize) {\n+    Symbolizer::Init(common_flags()->external_symbolizer_path);\n+  } else {\n+    Symbolizer::Disable();\n   }\n \n   // On Linux AsanThread::ThreadStart() calls malloc() that's why asan_inited\n   // should be set to 1 prior to initializing the threads.\n   asan_inited = 1;\n   asan_init_is_running = false;\n \n+  if (flags()->atexit)\n+    Atexit(asan_atexit);\n+\n+  if (flags()->coverage)\n+    Atexit(__sanitizer_cov_dump);\n+\n+  // interceptors\n   InitTlsSize();\n \n   // Create main thread.\n@@ -568,7 +567,7 @@ void __asan_init() {\n   }\n #endif  // CAN_SANITIZE_LEAKS\n \n-  if (flags()->verbosity) {\n+  if (common_flags()->verbosity) {\n     Report(\"AddressSanitizer Init done\\n\");\n   }\n }"}, {"sha": "93671a03a9289e2538816601e3d23642a287ba06", "filename": "libsanitizer/asan/asan_stack.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -22,9 +22,12 @@ static bool MaybeCallAsanSymbolize(const void *pc, char *out_buffer,\n                              : false;\n }\n \n+void PrintStack(const uptr *trace, uptr size) {\n+  StackTrace::PrintStack(trace, size, MaybeCallAsanSymbolize);\n+}\n+\n void PrintStack(StackTrace *stack) {\n-  stack->PrintStack(stack->trace, stack->size, common_flags()->symbolize,\n-                    common_flags()->strip_path_prefix, MaybeCallAsanSymbolize);\n+  PrintStack(stack->trace, stack->size);\n }\n \n }  // namespace __asan"}, {"sha": "c929c887d06b71d52c5a57ce69f39f6652cbb6f5", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -20,6 +20,7 @@\n namespace __asan {\n \n void PrintStack(StackTrace *stack);\n+void PrintStack(const uptr *trace, uptr size);\n \n }  // namespace __asan\n \n@@ -29,19 +30,24 @@ void PrintStack(StackTrace *stack);\n #if SANITIZER_WINDOWS\n #define GET_STACK_TRACE_WITH_PC_AND_BP(max_s, pc, bp, fast) \\\n   StackTrace stack;                                         \\\n-  GetStackTrace(&stack, max_s, pc, bp, 0, 0, fast)\n+  stack.Unwind(max_s, pc, bp, 0, 0, fast)\n #else\n-#define GET_STACK_TRACE_WITH_PC_AND_BP(max_s, pc, bp, fast)                \\\n-  StackTrace stack;                                                        \\\n-  {                                                                        \\\n-    AsanThread *t;                                                         \\\n-    stack.size = 0;                                                        \\\n-    if (asan_inited && (t = GetCurrentThread()) && !t->isUnwinding()) {    \\\n-      uptr stack_top = t->stack_top();                                     \\\n-      uptr stack_bottom = t->stack_bottom();                               \\\n-      ScopedUnwinding unwind_scope(t);                                     \\\n-      GetStackTrace(&stack, max_s, pc, bp, stack_top, stack_bottom, fast); \\\n-    }                                                                      \\\n+#define GET_STACK_TRACE_WITH_PC_AND_BP(max_s, pc, bp, fast)                    \\\n+  StackTrace stack;                                                            \\\n+  {                                                                            \\\n+    AsanThread *t;                                                             \\\n+    stack.size = 0;                                                            \\\n+    if (asan_inited) {                                                         \\\n+      if ((t = GetCurrentThread()) && !t->isUnwinding()) {                     \\\n+        uptr stack_top = t->stack_top();                                       \\\n+        uptr stack_bottom = t->stack_bottom();                                 \\\n+        ScopedUnwinding unwind_scope(t);                                       \\\n+        stack.Unwind(max_s, pc, bp, stack_top, stack_bottom, fast);            \\\n+      } else if (t == 0 && !fast) {                                            \\\n+        /* If GetCurrentThread() has failed, try to do slow unwind anyways. */ \\\n+        stack.Unwind(max_s, pc, bp, 0, 0, false);                              \\\n+      }                                                                        \\\n+    }                                                                          \\\n   }\n #endif  // SANITIZER_WINDOWS\n "}, {"sha": "5b04b1718ebc130d6da1c56770fb356f9a77833f", "filename": "libsanitizer/asan/asan_stats.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -45,9 +45,9 @@ struct AsanStats {\n   uptr malloc_large;\n   uptr malloc_small_slow;\n \n-  // Ctor for global AsanStats (accumulated stats and main thread stats).\n+  // Ctor for global AsanStats (accumulated stats for dead threads).\n   explicit AsanStats(LinkerInitialized) { }\n-  // Default ctor for thread-local stats.\n+  // Creates empty stats.\n   AsanStats();\n \n   void Print();  // Prints formatted stats to stderr."}, {"sha": "5a9c2dddffb8608ff1584e6008065741e87cc454", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -17,6 +17,7 @@\n #include \"asan_mapping.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"lsan/lsan_common.h\"\n \n namespace __asan {\n@@ -25,9 +26,8 @@ namespace __asan {\n \n void AsanThreadContext::OnCreated(void *arg) {\n   CreateThreadContextArgs *args = static_cast<CreateThreadContextArgs*>(arg);\n-  if (args->stack) {\n-    internal_memcpy(&stack, args->stack, sizeof(stack));\n-  }\n+  if (args->stack)\n+    stack_id = StackDepotPut(args->stack->trace, args->stack->size);\n   thread = args->thread;\n   thread->set_context(this);\n }\n@@ -41,9 +41,12 @@ void AsanThreadContext::OnFinished() {\n static ALIGNED(16) char thread_registry_placeholder[sizeof(ThreadRegistry)];\n static ThreadRegistry *asan_thread_registry;\n \n+static BlockingMutex mu_for_thread_context(LINKER_INITIALIZED);\n+static LowLevelAllocator allocator_for_thread_context;\n+\n static ThreadContextBase *GetAsanThreadContext(u32 tid) {\n-  void *mem = MmapOrDie(sizeof(AsanThreadContext), \"AsanThreadContext\");\n-  return new(mem) AsanThreadContext(tid);\n+  BlockingMutexLock lock(&mu_for_thread_context);\n+  return new(allocator_for_thread_context) AsanThreadContext(tid);\n }\n \n ThreadRegistry &asanThreadRegistry() {\n@@ -76,24 +79,25 @@ AsanThread *AsanThread::Create(thread_callback_t start_routine,\n   AsanThread *thread = (AsanThread*)MmapOrDie(size, __FUNCTION__);\n   thread->start_routine_ = start_routine;\n   thread->arg_ = arg;\n-  thread->context_ = 0;\n \n   return thread;\n }\n \n void AsanThread::TSDDtor(void *tsd) {\n   AsanThreadContext *context = (AsanThreadContext*)tsd;\n-  if (flags()->verbosity >= 1)\n+  if (common_flags()->verbosity >= 1)\n     Report(\"T%d TSDDtor\\n\", context->tid);\n   if (context->thread)\n     context->thread->Destroy();\n }\n \n void AsanThread::Destroy() {\n-  if (flags()->verbosity >= 1) {\n+  if (common_flags()->verbosity >= 1) {\n     Report(\"T%d exited\\n\", tid());\n   }\n \n+  malloc_storage().CommitBack();\n+  if (flags()->use_sigaltstack) UnsetAlternateSignalStack();\n   asanThreadRegistry().FinishThread(tid());\n   FlushToDeadThreadStats(&stats_);\n   // We also clear the shadow on thread destruction because\n@@ -136,7 +140,7 @@ void AsanThread::Init() {\n   CHECK(AddrIsInMem(stack_bottom_));\n   CHECK(AddrIsInMem(stack_top_ - 1));\n   ClearShadowForThreadStackAndTLS();\n-  if (flags()->verbosity >= 1) {\n+  if (common_flags()->verbosity >= 1) {\n     int local = 0;\n     Report(\"T%d: stack [%p,%p) size 0x%zx; local=%p\\n\",\n            tid(), (void*)stack_bottom_, (void*)stack_top_,\n@@ -160,10 +164,14 @@ thread_return_t AsanThread::ThreadStart(uptr os_id) {\n   }\n \n   thread_return_t res = start_routine_(arg_);\n-  malloc_storage().CommitBack();\n-  if (flags()->use_sigaltstack) UnsetAlternateSignalStack();\n \n-  this->Destroy();\n+  // On POSIX systems we defer this to the TSD destructor. LSan will consider\n+  // the thread's memory as non-live from the moment we call Destroy(), even\n+  // though that memory might contain pointers to heap objects which will be\n+  // cleaned up by a user-defined TSD destructor. Thus, calling Destroy() before\n+  // the TSD destructors have run might cause false positives in LSan.\n+  if (!SANITIZER_POSIX)\n+    this->Destroy();\n \n   return res;\n }\n@@ -257,7 +265,7 @@ AsanThread *GetCurrentThread() {\n \n void SetCurrentThread(AsanThread *t) {\n   CHECK(t->context());\n-  if (flags()->verbosity >= 2) {\n+  if (common_flags()->verbosity >= 2) {\n     Report(\"SetCurrentThread: %p for thread %p\\n\",\n            t->context(), (void*)GetThreadSelf());\n   }\n@@ -286,17 +294,21 @@ void EnsureMainThreadIDIsCorrect() {\n   if (context && (context->tid == 0))\n     context->os_id = GetTid();\n }\n+\n+__asan::AsanThread *GetAsanThreadByOsIDLocked(uptr os_id) {\n+  __asan::AsanThreadContext *context = static_cast<__asan::AsanThreadContext *>(\n+      __asan::asanThreadRegistry().FindThreadContextByOsIDLocked(os_id));\n+  if (!context) return 0;\n+  return context->thread;\n+}\n }  // namespace __asan\n \n // --- Implementation of LSan-specific functions --- {{{1\n namespace __lsan {\n bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n                            uptr *tls_begin, uptr *tls_end,\n                            uptr *cache_begin, uptr *cache_end) {\n-  __asan::AsanThreadContext *context = static_cast<__asan::AsanThreadContext *>(\n-      __asan::asanThreadRegistry().FindThreadContextByOsIDLocked(os_id));\n-  if (!context) return false;\n-  __asan::AsanThread *t = context->thread;\n+  __asan::AsanThread *t = __asan::GetAsanThreadByOsIDLocked(os_id);\n   if (!t) return false;\n   *stack_begin = t->stack_bottom();\n   *stack_end = t->stack_top();\n@@ -308,6 +320,13 @@ bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n   return true;\n }\n \n+void ForEachExtraStackRange(uptr os_id, RangeIteratorCallback callback,\n+                            void *arg) {\n+  __asan::AsanThread *t = __asan::GetAsanThreadByOsIDLocked(os_id);\n+  if (t && t->has_fake_stack())\n+    t->fake_stack()->ForEachFakeFrame(callback, arg);\n+}\n+\n void LockThreadRegistry() {\n   __asan::asanThreadRegistry().Lock();\n }"}, {"sha": "5a917fa9a3da03d9e5ab1277c03e3282645d0586", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -17,6 +17,7 @@\n #include \"asan_fake_stack.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_thread_registry.h\"\n \n@@ -34,19 +35,21 @@ class AsanThreadContext : public ThreadContextBase {\n   explicit AsanThreadContext(int tid)\n       : ThreadContextBase(tid),\n         announced(false),\n+        destructor_iterations(kPthreadDestructorIterations),\n+        stack_id(0),\n         thread(0) {\n-    internal_memset(&stack, 0, sizeof(stack));\n   }\n   bool announced;\n-  StackTrace stack;\n+  u8 destructor_iterations;\n+  u32 stack_id;\n   AsanThread *thread;\n \n   void OnCreated(void *arg);\n   void OnFinished();\n };\n \n // AsanThreadContext objects are never freed, so we need many of them.\n-COMPILER_CHECK(sizeof(AsanThreadContext) <= 4096);\n+COMPILER_CHECK(sizeof(AsanThreadContext) <= 256);\n \n // AsanThread are stored in TSD and destroyed when the thread dies.\n class AsanThread {\n@@ -96,33 +99,34 @@ class AsanThread {\n   // True is this thread is currently unwinding stack (i.e. collecting a stack\n   // trace). Used to prevent deadlocks on platforms where libc unwinder calls\n   // malloc internally. See PR17116 for more details.\n-  bool isUnwinding() const { return unwinding; }\n-  void setUnwinding(bool b) { unwinding = b; }\n+  bool isUnwinding() const { return unwinding_; }\n+  void setUnwinding(bool b) { unwinding_ = b; }\n \n   AsanThreadLocalMallocStorage &malloc_storage() { return malloc_storage_; }\n   AsanStats &stats() { return stats_; }\n \n  private:\n-  AsanThread() : unwinding(false) {}\n+  // NOTE: There is no AsanThread constructor. It is allocated\n+  // via mmap() and *must* be valid in zero-initialized state.\n   void SetThreadStackAndTls();\n   void ClearShadowForThreadStackAndTLS();\n   FakeStack *AsyncSignalSafeLazyInitFakeStack();\n \n   AsanThreadContext *context_;\n   thread_callback_t start_routine_;\n   void *arg_;\n-  uptr  stack_top_;\n-  uptr  stack_bottom_;\n+  uptr stack_top_;\n+  uptr stack_bottom_;\n   // stack_size_ == stack_top_ - stack_bottom_;\n   // It needs to be set in a async-signal-safe manner.\n-  uptr  stack_size_;\n+  uptr stack_size_;\n   uptr tls_begin_;\n   uptr tls_end_;\n \n   FakeStack *fake_stack_;\n   AsanThreadLocalMallocStorage malloc_storage_;\n   AsanStats stats_;\n-  bool unwinding;\n+  bool unwinding_;\n };\n \n // ScopedUnwinding is a scope for stacktracing member of a context"}, {"sha": "8ffa58faa371253c8b4237980f31656ce2342d9a", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -58,6 +58,9 @@ void AsanTSDSet(void *tsd) {\n   fake_tsd = tsd;\n }\n \n+void PlatformTSDDtor(void *tsd) {\n+  AsanThread::TSDDtor(tsd);\n+}\n // ---------------------- Various stuff ---------------- {{{1\n void MaybeReexec() {\n   // No need to re-exec on Windows."}, {"sha": "956cb86d697a331460f15e8cda70be053ab0f184", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -25,10 +25,6 @@ extern \"C\" {\n   // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n   void __sanitizer_set_report_path(const char *path);\n \n-  // Tell the tools to write their reports to given file descriptor instead of\n-  // stderr.\n-  void __sanitizer_set_report_fd(int fd);\n-\n   // Notify the tools that the sandbox is going to be turned on. The reserved\n   // parameter will be used in the future to hold a structure with functions\n   // that the tools may call to bypass the sandbox.\n@@ -49,6 +45,44 @@ extern \"C\" {\n   void __sanitizer_unaligned_store32(void *p, uint32_t x);\n   void __sanitizer_unaligned_store64(void *p, uint64_t x);\n \n+  // Record and dump coverage info.\n+  void __sanitizer_cov_dump();\n+\n+  // Annotate the current state of a contiguous container, such as\n+  // std::vector, std::string or similar.\n+  // A contiguous container is a container that keeps all of its elements\n+  // in a contiguous region of memory. The container owns the region of memory\n+  // [beg, end); the memory [beg, mid) is used to store the current elements\n+  // and the memory [mid, end) is reserved for future elements;\n+  // end <= mid <= end. For example, in \"std::vector<> v\"\n+  //   beg = &v[0];\n+  //   end = beg + v.capacity() * sizeof(v[0]);\n+  //   mid = beg + v.size()     * sizeof(v[0]);\n+  //\n+  // This annotation tells the Sanitizer tool about the current state of the\n+  // container so that the tool can report errors when memory from [mid, end)\n+  // is accessed. Insert this annotation into methods like push_back/pop_back.\n+  // Supply the old and the new values of mid (old_mid/new_mid).\n+  // In the initial state mid == end and so should be the final\n+  // state when the container is destroyed or when it reallocates the storage.\n+  //\n+  // Use with caution and don't use for anything other than vector-like classes.\n+  //\n+  // For AddressSanitizer, 'beg' should be 8-aligned and 'end' should\n+  // be either 8-aligned or it should point to the end of a separate heap-,\n+  // stack-, or global- allocated buffer. I.e. the following will not work:\n+  //   int64_t x[2];  // 16 bytes, 8-aligned.\n+  //   char *beg = (char *)&x[0];\n+  //   char *end = beg + 12;  // Not 8 aligned, not the end of the buffer.\n+  // This however will work fine:\n+  //   int32_t x[3];  // 12 bytes, but 8-aligned under AddressSanitizer.\n+  //   char *beg = (char*)&x[0];\n+  //   char *end = beg + 12;  // Not 8-aligned, but is the end of the buffer.\n+  void __sanitizer_annotate_contiguous_container(const void *beg,\n+                                                 const void *end,\n+                                                 const void *old_mid,\n+                                                 const void *new_mid);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "17742b6c1c407a4383cf09d766a359f51a675aa1", "filename": "libsanitizer/include/sanitizer/linux_syscall_hooks.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -985,10 +985,11 @@\n #else\n #define __sanitizer_syscall_pre_pread64(fd, buf, count, pos0, pos1)            \\\n   __sanitizer_syscall_pre_impl_pread64((long)(fd), (long)(buf), (long)(count), \\\n-                                       (long)(pos))\n+                                       (long)(pos0), (long)(pos1))\n #define __sanitizer_syscall_post_pread64(res, fd, buf, count, pos0, pos1) \\\n   __sanitizer_syscall_post_impl_pread64(res, (long)(fd), (long)(buf),     \\\n-                                        (long)(count), (long)(pos))\n+                                        (long)(count), (long)(pos0), \\\n+                                        (long)(pos1))\n #define __sanitizer_syscall_pre_pwrite64(fd, buf, count, pos0, pos1) \\\n   __sanitizer_syscall_pre_impl_pwrite64(                             \\\n       (long)(fd), (long)(buf), (long)(count), (long)(pos0), (long)(pos1))"}, {"sha": "7393f4c26be2b3a8a64e9f42e2c400d7707b3ae6", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -236,12 +236,18 @@ typedef unsigned long uptr;  // NOLINT\n #if defined(__linux__)\n # include \"interception_linux.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_LINUX(func)\n+# define INTERCEPT_FUNCTION_VER(func, symver) \\\n+    INTERCEPT_FUNCTION_VER_LINUX(func, symver)\n #elif defined(__APPLE__)\n # include \"interception_mac.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_MAC(func)\n+# define INTERCEPT_FUNCTION_VER(func, symver) \\\n+    INTERCEPT_FUNCTION_VER_MAC(func, symver)\n #else  // defined(_WIN32)\n # include \"interception_win.h\"\n # define INTERCEPT_FUNCTION(func) INTERCEPT_FUNCTION_WIN(func)\n+# define INTERCEPT_FUNCTION_VER(func, symver) \\\n+    INTERCEPT_FUNCTION_VER_WIN(func, symver)\n #endif\n \n #undef INCLUDED_FROM_INTERCEPTION_LIB"}, {"sha": "5ab24db438ee3ae758450f9bcbdbc2f947beb9e3", "filename": "libsanitizer/interception/interception_linux.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finterception%2Finterception_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finterception%2Finterception_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_linux.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -33,9 +33,12 @@ void *GetFuncAddrVer(const char *func_name, const char *ver);\n           (::__interception::uptr)&WRAP(func))\n \n #if !defined(__ANDROID__)  // android does not have dlvsym\n-#define INTERCEPT_FUNCTION_VER(func, symver) \\\n-    ::__interception::real_##func = (func##_f)(unsigned long) \\\n-        ::__interception::GetFuncAddrVer(#func, #symver)\n+# define INTERCEPT_FUNCTION_VER_LINUX(func, symver) \\\n+     ::__interception::real_##func = (func##_f)(unsigned long) \\\n+         ::__interception::GetFuncAddrVer(#func, symver)\n+#else\n+# define INTERCEPT_FUNCTION_VER_LINUX(func, symver) \\\n+     INTERCEPT_FUNCTION_LINUX(func)\n #endif  // !defined(__ANDROID__)\n \n #endif  // INTERCEPTION_LINUX_H"}, {"sha": "fbcb473b57994d88ae7ef8ebd67b9601ca36456b", "filename": "libsanitizer/interception/interception_mac.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finterception%2Finterception_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finterception%2Finterception_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_mac.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -20,6 +20,7 @@\n #define INTERCEPTION_MAC_H\n \n #define INTERCEPT_FUNCTION_MAC(func)\n+#define INTERCEPT_FUNCTION_VER_MAC(func, symver)\n \n #endif  // INTERCEPTION_MAC_H\n #endif  // __APPLE__"}, {"sha": "b46ad0dc66f47a1e0215fd36bc578c57db4d8038", "filename": "libsanitizer/interception/interception_win.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finterception%2Finterception_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Finterception%2Finterception_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -39,5 +39,8 @@ bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func);\n         (::__interception::uptr*)&REAL(func))\n #endif\n \n+#define INTERCEPT_FUNCTION_VER_WIN(func, symver) \\\n+    INTERCEPT_FUNCTION_WIN(func)\n+\n #endif  // INTERCEPTION_WIN_H\n #endif  // _WIN32"}, {"sha": "4784d7cbdc3462dbac93d41e8464fb2783733736", "filename": "libsanitizer/lsan/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.am?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -22,6 +22,7 @@ lsan_files = \\\n \tlsan.cc \\\n \tlsan_allocator.cc \\\n \tlsan_interceptors.cc \\\n+\tlsan_preinit.cc \\\n \tlsan_thread.cc\n \n libsanitizer_lsan_la_SOURCES = $(sanitizer_lsan_files)"}, {"sha": "b09469e09905bf49d7866cf8a4c031c2030693b8", "filename": "libsanitizer/lsan/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.in?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -83,7 +83,7 @@ liblsan_la_DEPENDENCIES =  \\\n \t$(am__DEPENDENCIES_1)\n am__objects_1 = lsan_common.lo lsan_common_linux.lo\n am__objects_2 = $(am__objects_1) lsan.lo lsan_allocator.lo \\\n-\tlsan_interceptors.lo lsan_thread.lo\n+\tlsan_interceptors.lo lsan_preinit.lo lsan_thread.lo\n am_liblsan_la_OBJECTS = $(am__objects_2)\n liblsan_la_OBJECTS = $(am_liblsan_la_OBJECTS)\n liblsan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -264,6 +264,7 @@ lsan_files = \\\n \tlsan.cc \\\n \tlsan_allocator.cc \\\n \tlsan_interceptors.cc \\\n+\tlsan_preinit.cc \\\n \tlsan_thread.cc\n \n libsanitizer_lsan_la_SOURCES = $(sanitizer_lsan_files)\n@@ -400,6 +401,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_common_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_interceptors.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_preinit.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lsan_thread.Plo@am__quote@\n \n .cc.o:"}, {"sha": "270979a78e7e4d29338b303c7bbd64b97cf016ab", "filename": "libsanitizer/lsan/lsan.cc", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -18,26 +18,30 @@\n #include \"lsan_common.h\"\n #include \"lsan_thread.h\"\n \n+bool lsan_inited;\n+bool lsan_init_is_running;\n+\n namespace __lsan {\n \n static void InitializeCommonFlags() {\n   CommonFlags *cf = common_flags();\n+  SetCommonFlagsDefaults(cf);\n   cf->external_symbolizer_path = GetEnv(\"LSAN_SYMBOLIZER_PATH\");\n-  cf->symbolize = true;\n-  cf->strip_path_prefix = \"\";\n-  cf->fast_unwind_on_malloc = true;\n   cf->malloc_context_size = 30;\n   cf->detect_leaks = true;\n-  cf->leak_check_at_exit = true;\n \n-  ParseCommonFlagsFromString(GetEnv(\"LSAN_OPTIONS\"));\n+  ParseCommonFlagsFromString(cf, GetEnv(\"LSAN_OPTIONS\"));\n }\n \n-void Init() {\n-  static bool inited;\n-  if (inited)\n+}  // namespace __lsan\n+\n+using namespace __lsan;  // NOLINT\n+\n+extern \"C\" void __lsan_init() {\n+  CHECK(!lsan_init_is_running);\n+  if (lsan_inited)\n     return;\n-  inited = true;\n+  lsan_init_is_running = true;\n   SanitizerToolName = \"LeakSanitizer\";\n   InitializeCommonFlags();\n   InitializeAllocator();\n@@ -51,13 +55,14 @@ void Init() {\n \n   // Start symbolizer process if necessary.\n   if (common_flags()->symbolize) {\n-    getSymbolizer()\n-        ->InitializeExternal(common_flags()->external_symbolizer_path);\n+    Symbolizer::Init(common_flags()->external_symbolizer_path);\n+  } else {\n+    Symbolizer::Disable();\n   }\n \n   InitCommonLsan();\n   if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit)\n     Atexit(DoLeakCheck);\n+  lsan_inited = true;\n+  lsan_init_is_running = false;\n }\n-\n-}  // namespace __lsan"}, {"sha": "8a5030ce87814f83478d7fba9ec431362bb607fb", "filename": "libsanitizer/lsan/lsan.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -15,7 +15,11 @@\n \n namespace __lsan {\n \n-void Init();\n void InitializeInterceptors();\n \n }  // namespace __lsan\n+\n+extern bool lsan_inited;\n+extern bool lsan_init_is_running;\n+\n+extern \"C\" void __lsan_init();"}, {"sha": "ce47dfcd215a8454c80ad5c3212a2eb234fc62e9", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -18,6 +18,8 @@\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"lsan_common.h\"\n \n+extern \"C\" void *memset(void *ptr, int value, uptr num);\n+\n namespace __lsan {\n \n static const uptr kMaxAllowedMallocSize = 8UL << 30;\n@@ -32,7 +34,7 @@ struct ChunkMetadata {\n };\n \n typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize,\n-        sizeof(ChunkMetadata), CompactSizeClassMap> PrimaryAllocator;\n+        sizeof(ChunkMetadata), DefaultSizeClassMap> PrimaryAllocator;\n typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n typedef LargeMmapAllocator<> SecondaryAllocator;\n typedef CombinedAllocator<PrimaryAllocator, AllocatorCache,\n@@ -78,7 +80,10 @@ void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n     Report(\"WARNING: LeakSanitizer failed to allocate %zu bytes\\n\", size);\n     return 0;\n   }\n-  void *p = allocator.Allocate(&cache, size, alignment, cleared);\n+  void *p = allocator.Allocate(&cache, size, alignment, false);\n+  // Do not rely on the allocator to clear the memory (it's slow).\n+  if (cleared && allocator.FromPrimary(p))\n+    memset(p, 0, size);\n   RegisterAllocation(stack, p, size);\n   return p;\n }"}, {"sha": "bbc5b5f0378ae7acff1ffac56810969f19e6a9d1", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -91,8 +91,12 @@ void InitializeSuppressions() {\n \n void InitCommonLsan() {\n   InitializeFlags();\n-  InitializeSuppressions();\n-  InitializePlatformSpecificModules();\n+  if (common_flags()->detect_leaks) {\n+    // Initialization which can fail or print warnings should only be done if\n+    // LSan is actually enabled.\n+    InitializeSuppressions();\n+    InitializePlatformSpecificModules();\n+  }\n }\n \n class Decorator: private __sanitizer::AnsiColorDecorator {\n@@ -136,6 +140,8 @@ void ScanRangeForPointers(uptr begin, uptr end,\n     if (!CanBeAHeapPointer(reinterpret_cast<uptr>(p))) continue;\n     uptr chunk = PointsIntoChunk(p);\n     if (!chunk) continue;\n+    // Pointers to self don't count. This matters when tag == kIndirectlyLeaked.\n+    if (chunk == begin) continue;\n     LsanMetadata m(chunk);\n     // Reachable beats ignored beats leaked.\n     if (m.tag() == kReachable) continue;\n@@ -149,6 +155,11 @@ void ScanRangeForPointers(uptr begin, uptr end,\n   }\n }\n \n+void ForEachExtraStackRangeCb(uptr begin, uptr end, void* arg) {\n+  Frontier *frontier = reinterpret_cast<Frontier *>(arg);\n+  ScanRangeForPointers(begin, end, frontier, \"FAKE STACK\", kReachable);\n+}\n+\n // Scans thread data (stacks and TLS) for heap pointers.\n static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n                            Frontier *frontier) {\n@@ -197,6 +208,7 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n       }\n       ScanRangeForPointers(stack_begin, stack_end, frontier, \"STACK\",\n                            kReachable);\n+      ForEachExtraStackRange(os_id, ForEachExtraStackRangeCb, frontier);\n     }\n \n     if (flags()->use_tls) {\n@@ -261,6 +273,8 @@ static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads) {\n   // The check here is relatively expensive, so we do this in a separate flood\n   // fill. That way we can skip the check for chunks that are reachable\n   // otherwise.\n+  if (flags()->log_pointers)\n+    Report(\"Processing platform-specific allocations.\\n\");\n   ProcessPlatformSpecificAllocations(&frontier);\n   FloodFillTag(&frontier, kReachable);\n \n@@ -281,8 +295,7 @@ static void PrintStackTraceById(u32 stack_trace_id) {\n   CHECK(stack_trace_id);\n   uptr size = 0;\n   const uptr *trace = StackDepotGet(stack_trace_id, &size);\n-  StackTrace::PrintStack(trace, size, common_flags()->symbolize,\n-                         common_flags()->strip_path_prefix, 0);\n+  StackTrace::PrintStack(trace, size);\n }\n \n // ForEachChunk callback. Aggregates unreachable chunks into a LeakReport.\n@@ -400,8 +413,8 @@ static Suppression *GetSuppressionForAddr(uptr addr) {\n   static const uptr kMaxAddrFrames = 16;\n   InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n   for (uptr i = 0; i < kMaxAddrFrames; i++) new (&addr_frames[i]) AddressInfo();\n-  uptr addr_frames_num =\n-      getSymbolizer()->SymbolizeCode(addr, addr_frames.data(), kMaxAddrFrames);\n+  uptr addr_frames_num = Symbolizer::Get()->SymbolizeCode(\n+      addr, addr_frames.data(), kMaxAddrFrames);\n   for (uptr i = 0; i < addr_frames_num; i++) {\n     Suppression* s;\n     if (suppression_ctx->Match(addr_frames[i].function, SuppressionLeak, &s) ||\n@@ -479,7 +492,6 @@ void LeakReport::PrintLargest(uptr num_leaks_to_print) {\n            leaks_[i].total_size, leaks_[i].hit_count);\n     Printf(\"%s\", d.End());\n     PrintStackTraceById(leaks_[i].stack_trace_id);\n-    Printf(\"\\n\");\n     leaks_printed++;\n     if (leaks_printed == num_leaks_to_print) break;\n   }\n@@ -497,12 +509,11 @@ void LeakReport::PrintSummary() {\n       bytes += leaks_[i].total_size;\n       allocations += leaks_[i].hit_count;\n   }\n-  const int kMaxSummaryLength = 128;\n   InternalScopedBuffer<char> summary(kMaxSummaryLength);\n-  internal_snprintf(summary.data(), kMaxSummaryLength,\n-                    \"LeakSanitizer: %zu byte(s) leaked in %zu allocation(s).\",\n-                    bytes, allocations);\n-  __sanitizer_report_error_summary(summary.data());\n+  internal_snprintf(summary.data(), summary.size(),\n+                    \"%zu byte(s) leaked in %zu allocation(s).\", bytes,\n+                    allocations);\n+  ReportErrorSummary(summary.data());\n }\n \n uptr LeakReport::ApplySuppressions() {\n@@ -528,6 +539,8 @@ extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE\n void __lsan_ignore_object(const void *p) {\n #if CAN_SANITIZE_LEAKS\n+  if (!common_flags()->detect_leaks)\n+    return;\n   // Cannot use PointsIntoChunk or LsanMetadata here, since the allocator is not\n   // locked.\n   BlockingMutexLock l(&global_mutex);\n@@ -552,7 +565,7 @@ void __lsan_disable() {\n SANITIZER_INTERFACE_ATTRIBUTE\n void __lsan_enable() {\n #if CAN_SANITIZE_LEAKS\n-  if (!__lsan::disable_counter) {\n+  if (!__lsan::disable_counter && common_flags()->detect_leaks) {\n     Report(\"Unmatched call to __lsan_enable().\\n\");\n     Die();\n   }"}, {"sha": "5d9b4eb62e1a31431fc16cad309eec3fec5bf7b9", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -133,6 +133,8 @@ void UnlockThreadRegistry();\n bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n                            uptr *tls_begin, uptr *tls_end,\n                            uptr *cache_begin, uptr *cache_end);\n+void ForEachExtraStackRange(uptr os_id, RangeIteratorCallback callback,\n+                            void *arg);\n // If called from the main thread, updates the main thread's TID in the thread\n // registry. We need this to handle processes that fork() without a subsequent\n // exec(), which invalidates the recorded TID. To update it, we must call"}, {"sha": "1940902ef837c87b39178fe007fce6dd02124eb7", "filename": "libsanitizer/lsan/lsan_interceptors.cc", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -42,11 +42,17 @@ int pthread_setspecific(unsigned key, const void *v);\n       stack_top = t->stack_end();                                            \\\n       stack_bottom = t->stack_begin();                                       \\\n     }                                                                        \\\n-    GetStackTrace(&stack, __sanitizer::common_flags()->malloc_context_size,  \\\n-                  StackTrace::GetCurrentPc(),                                \\\n-                  GET_CURRENT_FRAME(), stack_top, stack_bottom, fast);       \\\n+    stack.Unwind(__sanitizer::common_flags()->malloc_context_size,           \\\n+                 StackTrace::GetCurrentPc(),                                 \\\n+                 GET_CURRENT_FRAME(), stack_top, stack_bottom, fast);        \\\n   }\n \n+#define ENSURE_LSAN_INITED do {   \\\n+  CHECK(!lsan_init_is_running);   \\\n+  if (!lsan_inited)               \\\n+    __lsan_init();                \\\n+} while (0)\n+\n ///// Malloc/free interceptors. /////\n \n const bool kAlwaysClearMemory = true;\n@@ -56,54 +62,65 @@ namespace std {\n }\n \n INTERCEPTOR(void*, malloc, uptr size) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   GET_STACK_TRACE;\n   return Allocate(stack, size, 1, kAlwaysClearMemory);\n }\n \n INTERCEPTOR(void, free, void *p) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   Deallocate(p);\n }\n \n INTERCEPTOR(void*, calloc, uptr nmemb, uptr size) {\n+  if (lsan_init_is_running) {\n+    // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n+    const uptr kCallocPoolSize = 1024;\n+    static uptr calloc_memory_for_dlsym[kCallocPoolSize];\n+    static uptr allocated;\n+    uptr size_in_words = ((nmemb * size) + kWordSize - 1) / kWordSize;\n+    void *mem = (void*)&calloc_memory_for_dlsym[allocated];\n+    allocated += size_in_words;\n+    CHECK(allocated < kCallocPoolSize);\n+    return mem;\n+  }\n   if (CallocShouldReturnNullDueToOverflow(size, nmemb)) return 0;\n-  Init();\n+  ENSURE_LSAN_INITED;\n   GET_STACK_TRACE;\n   size *= nmemb;\n   return Allocate(stack, size, 1, true);\n }\n \n INTERCEPTOR(void*, realloc, void *q, uptr size) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   GET_STACK_TRACE;\n   return Reallocate(stack, q, size, 1);\n }\n \n INTERCEPTOR(void*, memalign, uptr alignment, uptr size) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   GET_STACK_TRACE;\n   return Allocate(stack, size, alignment, kAlwaysClearMemory);\n }\n \n INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   GET_STACK_TRACE;\n   *memptr = Allocate(stack, size, alignment, kAlwaysClearMemory);\n   // FIXME: Return ENOMEM if user requested more than max alloc size.\n   return 0;\n }\n \n INTERCEPTOR(void*, valloc, uptr size) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   GET_STACK_TRACE;\n   if (size == 0)\n     size = GetPageSizeCached();\n   return Allocate(stack, size, GetPageSizeCached(), kAlwaysClearMemory);\n }\n \n INTERCEPTOR(uptr, malloc_usable_size, void *ptr) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   return GetMallocUsableSize(ptr);\n }\n \n@@ -122,7 +139,7 @@ INTERCEPTOR(int, mallopt, int cmd, int value) {\n }\n \n INTERCEPTOR(void*, pvalloc, uptr size) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   GET_STACK_TRACE;\n   uptr PageSize = GetPageSizeCached();\n   size = RoundUpTo(size, PageSize);\n@@ -136,7 +153,7 @@ INTERCEPTOR(void*, pvalloc, uptr size) {\n INTERCEPTOR(void, cfree, void *p) ALIAS(\"free\");\n \n #define OPERATOR_NEW_BODY                              \\\n-  Init();                                              \\\n+  ENSURE_LSAN_INITED;                                  \\\n   GET_STACK_TRACE;                                     \\\n   return Allocate(stack, size, 1, kAlwaysClearMemory);\n \n@@ -150,7 +167,7 @@ INTERCEPTOR_ATTRIBUTE\n void *operator new[](uptr size, std::nothrow_t const&) { OPERATOR_NEW_BODY; }\n \n #define OPERATOR_DELETE_BODY \\\n-  Init();                    \\\n+  ENSURE_LSAN_INITED;        \\\n   Deallocate(ptr);\n \n INTERCEPTOR_ATTRIBUTE\n@@ -190,9 +207,6 @@ struct ThreadParam {\n   atomic_uintptr_t tid;\n };\n \n-// PTHREAD_DESTRUCTOR_ITERATIONS from glibc.\n-const uptr kPthreadDestructorIterations = 4;\n-\n extern \"C\" void *__lsan_thread_start_func(void *arg) {\n   ThreadParam *p = (ThreadParam*)arg;\n   void* (*callback)(void *arg) = p->callback;\n@@ -215,14 +229,14 @@ extern \"C\" void *__lsan_thread_start_func(void *arg) {\n \n INTERCEPTOR(int, pthread_create, void *th, void *attr,\n             void *(*callback)(void *), void *param) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   EnsureMainThreadIDIsCorrect();\n   __sanitizer_pthread_attr_t myattr;\n   if (attr == 0) {\n     pthread_attr_init(&myattr);\n     attr = &myattr;\n   }\n-  AdjustStackSizeLinux(attr, 0);\n+  AdjustStackSizeLinux(attr);\n   int detached = 0;\n   pthread_attr_getdetachstate(attr, &detached);\n   ThreadParam p;\n@@ -243,7 +257,7 @@ INTERCEPTOR(int, pthread_create, void *th, void *attr,\n }\n \n INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n-  Init();\n+  ENSURE_LSAN_INITED;\n   int tid = ThreadTid((uptr)th);\n   int res = REAL(pthread_join)(th, ret);\n   if (res == 0)"}, {"sha": "856f9f78787febdcd09c21f8e90454c39e6d1e4e", "filename": "libsanitizer/lsan/lsan_preinit.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_preinit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_preinit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_preinit.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,24 @@\n+//===-- lsan_preinit.cc ---------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of LeakSanitizer.\n+//\n+// Call __lsan_init at the very early stage of process startup.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"lsan.h\"\n+\n+#ifndef LSAN_USE_PREINIT_ARRAY\n+#define LSAN_USE_PREINIT_ARRAY 1\n+#endif\n+\n+#if LSAN_USE_PREINIT_ARRAY && !defined(PIC)\n+  // We force __lsan_init to be called before anyone else by placing it into\n+  // .preinit_array section.\n+  __attribute__((section(\".preinit_array\"), used))\n+  void (*__local_lsan_preinit)(void) = __lsan_init;\n+#endif"}, {"sha": "07f9d0ab4398165e65366a8350005e9370e4e70a", "filename": "libsanitizer/lsan/lsan_thread.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Flsan%2Flsan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -143,6 +143,10 @@ bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n   return true;\n }\n \n+void ForEachExtraStackRange(uptr os_id, RangeIteratorCallback callback,\n+                            void *arg) {\n+}\n+\n void LockThreadRegistry() {\n   thread_registry->Lock();\n }"}, {"sha": "979d52d77e19dc6e24f45e6ad44b8d80188922c6", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -14,22 +14,28 @@ sanitizer_common_files = \\\n \tsanitizer_allocator.cc \\\n \tsanitizer_common.cc \\\n \tsanitizer_common_libcdep.cc \\\n+\tsanitizer_coverage.cc \\\n \tsanitizer_flags.cc \\\n \tsanitizer_libc.cc \\\n+\tsanitizer_libignore.cc \\\n \tsanitizer_linux.cc \\\n \tsanitizer_linux_libcdep.cc \\\n \tsanitizer_mac.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n-\tsanitizer_posix.cc \\\n \tsanitizer_posix_libcdep.cc \\\n+\tsanitizer_posix.cc \\\n \tsanitizer_printf.cc \\\n \tsanitizer_stackdepot.cc \\\n \tsanitizer_stacktrace.cc \\\n+\tsanitizer_stacktrace_libcdep.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n \tsanitizer_suppressions.cc \\\n \tsanitizer_symbolizer_posix_libcdep.cc \\\n \tsanitizer_symbolizer_win.cc \\\n+\tsanitizer_symbolizer.cc \\\n+\tsanitizer_symbolizer_libbacktrace.cc \\\n+\tsanitizer_symbolizer_libcdep.cc \\\n \tsanitizer_thread_registry.cc \\\n \tsanitizer_win.cc\n "}, {"sha": "032cca41198be409b74d4583badd61793cbcdcae", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -56,17 +56,19 @@ CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n libsanitizer_common_la_LIBADD =\n am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n-\tsanitizer_common_libcdep.lo sanitizer_flags.lo \\\n-\tsanitizer_libc.lo sanitizer_linux.lo \\\n-\tsanitizer_linux_libcdep.lo sanitizer_mac.lo \\\n+\tsanitizer_common_libcdep.lo sanitizer_coverage.lo \\\n+\tsanitizer_flags.lo sanitizer_libc.lo sanitizer_libignore.lo \\\n+\tsanitizer_linux.lo sanitizer_linux_libcdep.lo sanitizer_mac.lo \\\n \tsanitizer_platform_limits_linux.lo \\\n-\tsanitizer_platform_limits_posix.lo sanitizer_posix.lo \\\n-\tsanitizer_posix_libcdep.lo sanitizer_printf.lo \\\n-\tsanitizer_stackdepot.lo sanitizer_stacktrace.lo \\\n+\tsanitizer_platform_limits_posix.lo sanitizer_posix_libcdep.lo \\\n+\tsanitizer_posix.lo sanitizer_printf.lo sanitizer_stackdepot.lo \\\n+\tsanitizer_stacktrace.lo sanitizer_stacktrace_libcdep.lo \\\n \tsanitizer_stoptheworld_linux_libcdep.lo \\\n \tsanitizer_suppressions.lo \\\n \tsanitizer_symbolizer_posix_libcdep.lo \\\n-\tsanitizer_symbolizer_win.lo sanitizer_thread_registry.lo \\\n+\tsanitizer_symbolizer_win.lo sanitizer_symbolizer.lo \\\n+\tsanitizer_symbolizer_libbacktrace.lo \\\n+\tsanitizer_symbolizer_libcdep.lo sanitizer_thread_registry.lo \\\n \tsanitizer_win.lo\n am_libsanitizer_common_la_OBJECTS = $(am__objects_1)\n libsanitizer_common_la_OBJECTS = $(am_libsanitizer_common_la_OBJECTS)\n@@ -235,22 +237,28 @@ sanitizer_common_files = \\\n \tsanitizer_allocator.cc \\\n \tsanitizer_common.cc \\\n \tsanitizer_common_libcdep.cc \\\n+\tsanitizer_coverage.cc \\\n \tsanitizer_flags.cc \\\n \tsanitizer_libc.cc \\\n+\tsanitizer_libignore.cc \\\n \tsanitizer_linux.cc \\\n \tsanitizer_linux_libcdep.cc \\\n \tsanitizer_mac.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n \tsanitizer_platform_limits_posix.cc \\\n-\tsanitizer_posix.cc \\\n \tsanitizer_posix_libcdep.cc \\\n+\tsanitizer_posix.cc \\\n \tsanitizer_printf.cc \\\n \tsanitizer_stackdepot.cc \\\n \tsanitizer_stacktrace.cc \\\n+\tsanitizer_stacktrace_libcdep.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n \tsanitizer_suppressions.cc \\\n \tsanitizer_symbolizer_posix_libcdep.cc \\\n \tsanitizer_symbolizer_win.cc \\\n+\tsanitizer_symbolizer.cc \\\n+\tsanitizer_symbolizer_libbacktrace.cc \\\n+\tsanitizer_symbolizer_libcdep.cc \\\n \tsanitizer_thread_registry.cc \\\n \tsanitizer_win.cc\n \n@@ -350,8 +358,10 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_common_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_coverage.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libignore.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@\n@@ -362,8 +372,12 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_printf.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stoptheworld_linux_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_suppressions.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_libbacktrace.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_win.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_thread_registry.Plo@am__quote@"}, {"sha": "8ba825f14ec29476ecf181d76f3fdba473f27f6e", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 68, "deletions": 4, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -585,7 +585,69 @@ class FlatByteMap {\n   u8 map_[kSize];\n };\n \n-// FIXME: Also implement TwoLevelByteMap.\n+// TwoLevelByteMap maps integers in range [0, kSize1*kSize2) to u8 values.\n+// It is implemented as a two-dimensional array: array of kSize1 pointers\n+// to kSize2-byte arrays. The secondary arrays are mmaped on demand.\n+// Each value is initially zero and can be set to something else only once.\n+// Setting and getting values from multiple threads is safe w/o extra locking.\n+template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>\n+class TwoLevelByteMap {\n+ public:\n+  void TestOnlyInit() {\n+    internal_memset(map1_, 0, sizeof(map1_));\n+    mu_.Init();\n+  }\n+  void TestOnlyUnmap() {\n+    for (uptr i = 0; i < kSize1; i++) {\n+      u8 *p = Get(i);\n+      if (!p) continue;\n+      MapUnmapCallback().OnUnmap(reinterpret_cast<uptr>(p), kSize2);\n+      UnmapOrDie(p, kSize2);\n+    }\n+  }\n+\n+  uptr size() const { return kSize1 * kSize2; }\n+  uptr size1() const { return kSize1; }\n+  uptr size2() const { return kSize2; }\n+\n+  void set(uptr idx, u8 val) {\n+    CHECK_LT(idx, kSize1 * kSize2);\n+    u8 *map2 = GetOrCreate(idx / kSize2);\n+    CHECK_EQ(0U, map2[idx % kSize2]);\n+    map2[idx % kSize2] = val;\n+  }\n+\n+  u8 operator[] (uptr idx) const {\n+    CHECK_LT(idx, kSize1 * kSize2);\n+    u8 *map2 = Get(idx / kSize2);\n+    if (!map2) return 0;\n+    return map2[idx % kSize2];\n+  }\n+\n+ private:\n+  u8 *Get(uptr idx) const {\n+    CHECK_LT(idx, kSize1);\n+    return reinterpret_cast<u8 *>(\n+        atomic_load(&map1_[idx], memory_order_acquire));\n+  }\n+\n+  u8 *GetOrCreate(uptr idx) {\n+    u8 *res = Get(idx);\n+    if (!res) {\n+      SpinMutexLock l(&mu_);\n+      if (!(res = Get(idx))) {\n+        res = (u8*)MmapOrDie(kSize2, \"TwoLevelByteMap\");\n+        MapUnmapCallback().OnMap(reinterpret_cast<uptr>(res), kSize2);\n+        atomic_store(&map1_[idx], reinterpret_cast<uptr>(res),\n+                     memory_order_release);\n+      }\n+    }\n+    return res;\n+  }\n+\n+  atomic_uintptr_t map1_[kSize1];\n+  StaticSpinMutex mu_;\n+};\n \n // SizeClassAllocator32 -- allocator for 32-bit address space.\n // This allocator can theoretically be used on 64-bit arch, but there it is less\n@@ -1049,6 +1111,7 @@ class LargeMmapAllocator {\n   // This function does the same as GetBlockBegin, but is much faster.\n   // Must be called with the allocator locked.\n   void *GetBlockBeginFastLocked(void *ptr) {\n+    mutex_.CheckLocked();\n     uptr p = reinterpret_cast<uptr>(ptr);\n     uptr n = n_chunks_;\n     if (!n) return 0;\n@@ -1181,14 +1244,15 @@ class CombinedAllocator {\n     if (alignment > 8)\n       size = RoundUpTo(size, alignment);\n     void *res;\n-    if (primary_.CanAllocate(size, alignment))\n+    bool from_primary = primary_.CanAllocate(size, alignment);\n+    if (from_primary)\n       res = cache->Allocate(&primary_, primary_.ClassID(size));\n     else\n       res = secondary_.Allocate(&stats_, size, alignment);\n     if (alignment > 8)\n       CHECK_EQ(reinterpret_cast<uptr>(res) & (alignment - 1), 0);\n-    if (cleared && res)\n-      internal_memset(res, 0, size);\n+    if (cleared && res && from_primary)\n+      internal_bzero_aligned16(res, RoundUpTo(size, 16));\n     return res;\n   }\n "}, {"sha": "efdb89e36825c749d3729a05a9fba4b7402513fe", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_internal.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -25,21 +25,25 @@ static const uptr kInternalAllocatorSpace = 0;\n #if SANITIZER_WORDSIZE == 32\n static const u64 kInternalAllocatorSize = (1ULL << 32);\n static const uptr kInternalAllocatorRegionSizeLog = 20;\n+static const uptr kInternalAllocatorNumRegions =\n+    kInternalAllocatorSize >> kInternalAllocatorRegionSizeLog;\n+typedef FlatByteMap<kInternalAllocatorNumRegions> ByteMap;\n #else\n static const u64 kInternalAllocatorSize = (1ULL << 47);\n static const uptr kInternalAllocatorRegionSizeLog = 24;\n-#endif\n-static const uptr kInternalAllocatorFlatByteMapSize =\n+static const uptr kInternalAllocatorNumRegions =\n     kInternalAllocatorSize >> kInternalAllocatorRegionSizeLog;\n+typedef TwoLevelByteMap<(kInternalAllocatorNumRegions >> 12), 1 << 12> ByteMap;\n+#endif\n typedef SizeClassAllocator32<\n     kInternalAllocatorSpace, kInternalAllocatorSize, 16, InternalSizeClassMap,\n-    kInternalAllocatorRegionSizeLog,\n-    FlatByteMap<kInternalAllocatorFlatByteMapSize> > PrimaryInternalAllocator;\n+    kInternalAllocatorRegionSizeLog, ByteMap> PrimaryInternalAllocator;\n \n typedef SizeClassAllocatorLocalCache<PrimaryInternalAllocator>\n     InternalAllocatorCache;\n \n-// We don't want our internal allocator to do any map/unmap operations.\n+// We don't want our internal allocator to do any map/unmap operations from\n+// LargeMmapAllocator.\n struct CrashOnMapUnmap {\n   void OnMap(uptr p, uptr size) const {\n     RAW_CHECK_MSG(0, \"Unexpected mmap in InternalAllocator!\");"}, {"sha": "bf73dc6339b67084dc0f663e83a775ed37d8baba", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 91, "deletions": 17, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -10,12 +10,14 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n const char *SanitizerToolName = \"SanitizerTool\";\n-uptr SanitizerVerbosity = 0;\n \n uptr GetPageSizeCached() {\n   static uptr PageSize;\n@@ -134,14 +136,71 @@ void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {\n   return (void*)res;\n }\n \n+const char *StripPathPrefix(const char *filepath,\n+                            const char *strip_path_prefix) {\n+  if (filepath == 0) return 0;\n+  if (strip_path_prefix == 0) return filepath;\n+  const char *pos = internal_strstr(filepath, strip_path_prefix);\n+  if (pos == 0) return filepath;\n+  pos += internal_strlen(strip_path_prefix);\n+  if (pos[0] == '.' && pos[1] == '/')\n+    pos += 2;\n+  return pos;\n+}\n+\n+void PrintSourceLocation(InternalScopedString *buffer, const char *file,\n+                         int line, int column) {\n+  CHECK(file);\n+  buffer->append(\"%s\",\n+                 StripPathPrefix(file, common_flags()->strip_path_prefix));\n+  if (line > 0) {\n+    buffer->append(\":%d\", line);\n+    if (column > 0)\n+      buffer->append(\":%d\", column);\n+  }\n+}\n+\n+void PrintModuleAndOffset(InternalScopedString *buffer, const char *module,\n+                          uptr offset) {\n+  buffer->append(\"(%s+0x%zx)\",\n+                 StripPathPrefix(module, common_flags()->strip_path_prefix),\n+                 offset);\n+}\n+\n+void ReportErrorSummary(const char *error_message) {\n+  if (!common_flags()->print_summary)\n+    return;\n+  InternalScopedBuffer<char> buff(kMaxSummaryLength);\n+  internal_snprintf(buff.data(), buff.size(),\n+                    \"SUMMARY: %s: %s\", SanitizerToolName, error_message);\n+  __sanitizer_report_error_summary(buff.data());\n+}\n+\n void ReportErrorSummary(const char *error_type, const char *file,\n                         int line, const char *function) {\n-  const int kMaxSize = 1024;  // We don't want a summary too long.\n-  InternalScopedBuffer<char> buff(kMaxSize);\n-  internal_snprintf(buff.data(), kMaxSize, \"%s: %s %s:%d %s\",\n-                    SanitizerToolName, error_type,\n-                    file ? file : \"??\", line, function ? function : \"??\");\n-  __sanitizer_report_error_summary(buff.data());\n+  if (!common_flags()->print_summary)\n+    return;\n+  InternalScopedBuffer<char> buff(kMaxSummaryLength);\n+  internal_snprintf(\n+      buff.data(), buff.size(), \"%s %s:%d %s\", error_type,\n+      file ? StripPathPrefix(file, common_flags()->strip_path_prefix) : \"??\",\n+      line, function ? function : \"??\");\n+  ReportErrorSummary(buff.data());\n+}\n+\n+void ReportErrorSummary(const char *error_type, StackTrace *stack) {\n+  if (!common_flags()->print_summary)\n+    return;\n+  AddressInfo ai;\n+#if !SANITIZER_GO\n+  if (stack->size > 0 && Symbolizer::Get()->IsAvailable()) {\n+    // Currently, we include the first stack frame into the report summary.\n+    // Maybe sometimes we need to choose another frame (e.g. skip memcpy/etc).\n+    uptr pc = StackTrace::GetPreviousInstructionPc(stack->trace[0]);\n+    Symbolizer::Get()->SymbolizeCode(pc, &ai, 1);\n+  }\n+#endif\n+  ReportErrorSummary(error_type, ai.file, ai.line, ai.function);\n }\n \n LoadedModule::LoadedModule(const char *module_name, uptr base_address) {\n@@ -165,32 +224,47 @@ bool LoadedModule::containsAddress(uptr address) const {\n   return false;\n }\n \n+char *StripModuleName(const char *module) {\n+  if (module == 0)\n+    return 0;\n+  const char *short_module_name = internal_strrchr(module, '/');\n+  if (short_module_name)\n+    short_module_name += 1;\n+  else\n+    short_module_name = module;\n+  return internal_strdup(short_module_name);\n+}\n+\n }  // namespace __sanitizer\n \n using namespace __sanitizer;  // NOLINT\n \n extern \"C\" {\n void __sanitizer_set_report_path(const char *path) {\n-  if (!path) return;\n+  if (!path)\n+    return;\n   uptr len = internal_strlen(path);\n   if (len > sizeof(report_path_prefix) - 100) {\n     Report(\"ERROR: Path is too long: %c%c%c%c%c%c%c%c...\\n\",\n            path[0], path[1], path[2], path[3],\n            path[4], path[5], path[6], path[7]);\n     Die();\n   }\n-  internal_strncpy(report_path_prefix, path, sizeof(report_path_prefix));\n-  report_path_prefix[len] = '\\0';\n-  report_fd = kInvalidFd;\n-  log_to_file = true;\n-}\n-\n-void __sanitizer_set_report_fd(int fd) {\n   if (report_fd != kStdoutFd &&\n       report_fd != kStderrFd &&\n       report_fd != kInvalidFd)\n     internal_close(report_fd);\n-  report_fd = fd;\n+  report_fd = kInvalidFd;\n+  log_to_file = false;\n+  if (internal_strcmp(path, \"stdout\") == 0) {\n+    report_fd = kStdoutFd;\n+  } else if (internal_strcmp(path, \"stderr\") == 0) {\n+    report_fd = kStderrFd;\n+  } else {\n+    internal_strncpy(report_path_prefix, path, sizeof(report_path_prefix));\n+    report_path_prefix[len] = '\\0';\n+    log_to_file = true;\n+  }\n }\n \n void NOINLINE __sanitizer_sandbox_on_notify(void *reserved) {\n@@ -199,6 +273,6 @@ void NOINLINE __sanitizer_sandbox_on_notify(void *reserved) {\n }\n \n void __sanitizer_report_error_summary(const char *error_summary) {\n-  Printf(\"SUMMARY: %s\\n\", error_summary);\n+  Printf(\"%s\\n\", error_summary);\n }\n }  // extern \"C\""}, {"sha": "833c2b07e35c2b6f7ef61f0ef630da033243d555", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -34,7 +34,6 @@ const uptr kCacheLineSize = 64;\n const uptr kMaxPathLength = 512;\n \n extern const char *SanitizerToolName;  // Can be changed by the tool.\n-extern uptr SanitizerVerbosity;\n \n uptr GetPageSize();\n uptr GetPageSizeCached();\n@@ -86,6 +85,23 @@ class InternalScopedBuffer {\n   void operator=(const InternalScopedBuffer&);\n };\n \n+class InternalScopedString : public InternalScopedBuffer<char> {\n+ public:\n+  explicit InternalScopedString(uptr max_length)\n+      : InternalScopedBuffer<char>(max_length), length_(0) {\n+    (*this)[0] = '\\0';\n+  }\n+  uptr length() { return length_; }\n+  void clear() {\n+    (*this)[0] = '\\0';\n+    length_ = 0;\n+  }\n+  void append(const char *format, ...);\n+\n+ private:\n+  uptr length_;\n+};\n+\n // Simple low-level (mmap-based) allocator for internal use. Doesn't have\n // constructor, so all instances of LowLevelAllocator should be\n // linker initialized.\n@@ -110,6 +126,7 @@ bool PrintsToTtyCached();\n void Printf(const char *format, ...);\n void Report(const char *format, ...);\n void SetPrintfAndReportCallback(void (*callback)(const char *));\n+\n // Can be used to prevent mixing error reports from different sanitizers.\n extern StaticSpinMutex CommonSanitizerReportMutex;\n void MaybeOpenReportFile();\n@@ -130,6 +147,14 @@ uptr ReadFileToBuffer(const char *file_name, char **buff,\n // in '*buff_size'.\n void *MapFileToMemory(const char *file_name, uptr *buff_size);\n \n+// Error report formatting.\n+const char *StripPathPrefix(const char *filepath,\n+                            const char *strip_file_prefix);\n+void PrintSourceLocation(InternalScopedString *buffer, const char *file,\n+                         int line, int column);\n+void PrintModuleAndOffset(InternalScopedString *buffer,\n+                          const char *module, uptr offset);\n+\n // OS\n void DisableCoreDumper();\n void DumpProcessMap();\n@@ -153,6 +178,9 @@ void SleepForMillis(int millis);\n u64 NanoTime();\n int Atexit(void (*function)(void));\n void SortArray(uptr *array, uptr size);\n+// Strip the directories from the module name, return a new string allocated\n+// with internal_strdup.\n+char *StripModuleName(const char *module);\n \n // Exit\n void NORETURN Abort();\n@@ -176,11 +204,17 @@ typedef void (*CheckFailedCallbackType)(const char *, int, const char *,\n                                        u64, u64);\n void SetCheckFailedCallback(CheckFailedCallbackType callback);\n \n-// Construct a one-line string like\n-//  SanitizerToolName: error_type file:line function\n-// and call __sanitizer_report_error_summary on it.\n+// We don't want a summary too long.\n+const int kMaxSummaryLength = 1024;\n+// Construct a one-line string:\n+//   SUMMARY: SanitizerToolName: error_message\n+// and pass it to __sanitizer_report_error_summary.\n+void ReportErrorSummary(const char *error_message);\n+// Same as above, but construct error_message as:\n+//   error_type: file:line function\n void ReportErrorSummary(const char *error_type, const char *file,\n                         int line, const char *function);\n+void ReportErrorSummary(const char *error_type, StackTrace *trace);\n \n // Math\n #if SANITIZER_WINDOWS && !defined(__clang__) && !defined(__GNUC__)\n@@ -326,6 +360,8 @@ class InternalMmapVector {\n     return capacity_;\n   }\n \n+  void clear() { size_ = 0; }\n+\n  private:\n   void Resize(uptr new_capacity) {\n     CHECK_GT(new_capacity, 0);\n@@ -431,6 +467,20 @@ typedef bool (*string_predicate_t)(const char *);\n uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n                       string_predicate_t filter);\n \n+#if SANITIZER_POSIX\n+const uptr kPthreadDestructorIterations = 4;\n+#else\n+// Unused on Windows.\n+const uptr kPthreadDestructorIterations = 0;\n+#endif\n+\n+// Callback type for iterating over a set of memory ranges.\n+typedef void (*RangeIteratorCallback)(uptr begin, uptr end, void *arg);\n }  // namespace __sanitizer\n \n+inline void *operator new(__sanitizer::operator_new_size_type size,\n+                          __sanitizer::LowLevelAllocator &alloc) {\n+  return alloc.Allocate(size);\n+}\n+\n #endif  // SANITIZER_COMMON_H"}, {"sha": "45b12fcaf16ed47e872f3bddb9ae1f8adb89f9ac", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 1076, "deletions": 292, "changes": 1368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -13,19 +13,51 @@\n //   COMMON_INTERCEPTOR_ENTER\n //   COMMON_INTERCEPTOR_READ_RANGE\n //   COMMON_INTERCEPTOR_WRITE_RANGE\n+//   COMMON_INTERCEPTOR_INITIALIZE_RANGE\n //   COMMON_INTERCEPTOR_FD_ACQUIRE\n //   COMMON_INTERCEPTOR_FD_RELEASE\n+//   COMMON_INTERCEPTOR_FD_ACCESS\n //   COMMON_INTERCEPTOR_SET_THREAD_NAME\n+//   COMMON_INTERCEPTOR_ON_EXIT\n+//   COMMON_INTERCEPTOR_MUTEX_LOCK\n+//   COMMON_INTERCEPTOR_MUTEX_UNLOCK\n+//   COMMON_INTERCEPTOR_MUTEX_REPAIR\n+//   COMMON_INTERCEPTOR_SET_PTHREAD_NAME\n+//   COMMON_INTERCEPTOR_HANDLE_RECVMSG\n //===----------------------------------------------------------------------===//\n #include \"interception/interception.h\"\n #include \"sanitizer_platform_interceptors.h\"\n \n #include <stdarg.h>\n \n-#if SANITIZER_WINDOWS\n+#if SANITIZER_WINDOWS && !defined(va_copy)\n #define va_copy(dst, src) ((dst) = (src))\n #endif // _WIN32\n \n+#ifndef COMMON_INTERCEPTOR_INITIALIZE_RANGE\n+#define COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, p, size) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_FD_ACCESS\n+#define COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_MUTEX_LOCK\n+#define COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_MUTEX_UNLOCK\n+#define COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_MUTEX_REPAIR\n+#define COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m) {}\n+#endif\n+\n+#ifndef COMMON_INTERCEPTOR_HANDLE_RECVMSG\n+#define COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg) ((void)(msg))\n+#endif\n+\n #if SANITIZER_INTERCEPT_STRCMP\n static inline int CharCmpX(unsigned char c1, unsigned char c2) {\n   return (c1 == c2) ? 0 : (c1 < c2) ? -1 : 1;\n@@ -36,7 +68,7 @@ INTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n   COMMON_INTERCEPTOR_ENTER(ctx, strcmp, s1, s2);\n   unsigned char c1, c2;\n   uptr i;\n-  for (i = 0; ; i++) {\n+  for (i = 0;; i++) {\n     c1 = (unsigned char)s1[i];\n     c2 = (unsigned char)s2[i];\n     if (c1 != c2 || c1 == '\\0') break;\n@@ -61,8 +93,8 @@ INTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr size) {\n   return CharCmpX(c1, c2);\n }\n \n-#define INIT_STRCMP INTERCEPT_FUNCTION(strcmp)\n-#define INIT_STRNCMP INTERCEPT_FUNCTION(strncmp)\n+#define INIT_STRCMP COMMON_INTERCEPT_FUNCTION(strcmp)\n+#define INIT_STRNCMP COMMON_INTERCEPT_FUNCTION(strncmp)\n #else\n #define INIT_STRCMP\n #define INIT_STRNCMP\n@@ -80,11 +112,10 @@ INTERCEPTOR(int, strcasecmp, const char *s1, const char *s2) {\n   COMMON_INTERCEPTOR_ENTER(ctx, strcasecmp, s1, s2);\n   unsigned char c1 = 0, c2 = 0;\n   uptr i;\n-  for (i = 0; ; i++) {\n+  for (i = 0;; i++) {\n     c1 = (unsigned char)s1[i];\n     c2 = (unsigned char)s2[i];\n-    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0')\n-      break;\n+    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n   }\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, i + 1);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, i + 1);\n@@ -99,16 +130,15 @@ INTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, SIZE_T n) {\n   for (i = 0; i < n; i++) {\n     c1 = (unsigned char)s1[i];\n     c2 = (unsigned char)s2[i];\n-    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0')\n-      break;\n+    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n   }\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, Min(i + 1, n));\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, Min(i + 1, n));\n   return CharCaseCmp(c1, c2);\n }\n \n-#define INIT_STRCASECMP INTERCEPT_FUNCTION(strcasecmp)\n-#define INIT_STRNCASECMP INTERCEPT_FUNCTION(strncasecmp)\n+#define INIT_STRCASECMP COMMON_INTERCEPT_FUNCTION(strcasecmp)\n+#define INIT_STRNCASECMP COMMON_INTERCEPT_FUNCTION(strncasecmp)\n #else\n #define INIT_STRCASECMP\n #define INIT_STRNCASECMP\n@@ -123,10 +153,10 @@ INTERCEPTOR(double, frexp, double x, int *exp) {\n   return res;\n }\n \n-#define INIT_FREXP INTERCEPT_FUNCTION(frexp);\n+#define INIT_FREXP COMMON_INTERCEPT_FUNCTION(frexp);\n #else\n #define INIT_FREXP\n-#endif // SANITIZER_INTERCEPT_FREXP\n+#endif  // SANITIZER_INTERCEPT_FREXP\n \n #if SANITIZER_INTERCEPT_FREXPF_FREXPL\n INTERCEPTOR(float, frexpf, float x, int *exp) {\n@@ -145,12 +175,12 @@ INTERCEPTOR(long double, frexpl, long double x, int *exp) {\n   return res;\n }\n \n-#define INIT_FREXPF_FREXPL                       \\\n-  INTERCEPT_FUNCTION(frexpf);                    \\\n-  INTERCEPT_FUNCTION(frexpl)\n+#define INIT_FREXPF_FREXPL           \\\n+  COMMON_INTERCEPT_FUNCTION(frexpf); \\\n+  COMMON_INTERCEPT_FUNCTION(frexpl)\n #else\n #define INIT_FREXPF_FREXPL\n-#endif // SANITIZER_INTERCEPT_FREXPF_FREXPL\n+#endif  // SANITIZER_INTERCEPT_FREXPF_FREXPL\n \n #if SI_NOT_WINDOWS\n static void write_iovec(void *ctx, struct __sanitizer_iovec *iovec,\n@@ -177,14 +207,13 @@ static void read_iovec(void *ctx, struct __sanitizer_iovec *iovec,\n INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, read, fd, ptr, count);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n   SSIZE_T res = REAL(read)(fd, ptr, count);\n-  if (res > 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n-  if (res >= 0 && fd >= 0)\n-    COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n+  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n   return res;\n }\n-#define INIT_READ INTERCEPT_FUNCTION(read)\n+#define INIT_READ COMMON_INTERCEPT_FUNCTION(read)\n #else\n #define INIT_READ\n #endif\n@@ -193,14 +222,13 @@ INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n INTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pread, fd, ptr, count, offset);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n   SSIZE_T res = REAL(pread)(fd, ptr, count, offset);\n-  if (res > 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n-  if (res >= 0 && fd >= 0)\n-    COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n+  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n   return res;\n }\n-#define INIT_PREAD INTERCEPT_FUNCTION(pread)\n+#define INIT_PREAD COMMON_INTERCEPT_FUNCTION(pread)\n #else\n #define INIT_PREAD\n #endif\n@@ -209,14 +237,13 @@ INTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n INTERCEPTOR(SSIZE_T, pread64, int fd, void *ptr, SIZE_T count, OFF64_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pread64, fd, ptr, count, offset);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n   SSIZE_T res = REAL(pread64)(fd, ptr, count, offset);\n-  if (res > 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n-  if (res >= 0 && fd >= 0)\n-    COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n+  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n   return res;\n }\n-#define INIT_PREAD64 INTERCEPT_FUNCTION(pread64)\n+#define INIT_PREAD64 COMMON_INTERCEPT_FUNCTION(pread64)\n #else\n #define INIT_PREAD64\n #endif\n@@ -226,12 +253,13 @@ INTERCEPTOR_WITH_SUFFIX(SSIZE_T, readv, int fd, __sanitizer_iovec *iov,\n                         int iovcnt) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, readv, fd, iov, iovcnt);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n   SSIZE_T res = REAL(readv)(fd, iov, iovcnt);\n   if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n   if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n   return res;\n }\n-#define INIT_READV INTERCEPT_FUNCTION(readv)\n+#define INIT_READV COMMON_INTERCEPT_FUNCTION(readv)\n #else\n #define INIT_READV\n #endif\n@@ -241,12 +269,13 @@ INTERCEPTOR(SSIZE_T, preadv, int fd, __sanitizer_iovec *iov, int iovcnt,\n             OFF_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, preadv, fd, iov, iovcnt, offset);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n   SSIZE_T res = REAL(preadv)(fd, iov, iovcnt, offset);\n   if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n   if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n   return res;\n }\n-#define INIT_PREADV INTERCEPT_FUNCTION(preadv)\n+#define INIT_PREADV COMMON_INTERCEPT_FUNCTION(preadv)\n #else\n #define INIT_PREADV\n #endif\n@@ -256,12 +285,13 @@ INTERCEPTOR(SSIZE_T, preadv64, int fd, __sanitizer_iovec *iov, int iovcnt,\n             OFF64_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, preadv64, fd, iov, iovcnt, offset);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n   SSIZE_T res = REAL(preadv64)(fd, iov, iovcnt, offset);\n   if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n   if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n   return res;\n }\n-#define INIT_PREADV64 INTERCEPT_FUNCTION(preadv64)\n+#define INIT_PREADV64 COMMON_INTERCEPT_FUNCTION(preadv64)\n #else\n #define INIT_PREADV64\n #endif\n@@ -270,15 +300,14 @@ INTERCEPTOR(SSIZE_T, preadv64, int fd, __sanitizer_iovec *iov, int iovcnt,\n INTERCEPTOR(SSIZE_T, write, int fd, void *ptr, SIZE_T count) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, write, fd, ptr, count);\n-  if (fd >= 0)\n-    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n+  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n   SSIZE_T res = REAL(write)(fd, ptr, count);\n   // FIXME: this check should be _before_ the call to REAL(write), not after\n-  if (res > 0)\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n+  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n   return res;\n }\n-#define INIT_WRITE INTERCEPT_FUNCTION(write)\n+#define INIT_WRITE COMMON_INTERCEPT_FUNCTION(write)\n #else\n #define INIT_WRITE\n #endif\n@@ -287,14 +316,13 @@ INTERCEPTOR(SSIZE_T, write, int fd, void *ptr, SIZE_T count) {\n INTERCEPTOR(SSIZE_T, pwrite, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pwrite, fd, ptr, count, offset);\n-  if (fd >= 0)\n-    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n+  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n   SSIZE_T res = REAL(pwrite)(fd, ptr, count, offset);\n-  if (res > 0)\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n+  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n   return res;\n }\n-#define INIT_PWRITE INTERCEPT_FUNCTION(pwrite)\n+#define INIT_PWRITE COMMON_INTERCEPT_FUNCTION(pwrite)\n #else\n #define INIT_PWRITE\n #endif\n@@ -304,14 +332,13 @@ INTERCEPTOR(SSIZE_T, pwrite64, int fd, void *ptr, OFF64_T count,\n             OFF64_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pwrite64, fd, ptr, count, offset);\n-  if (fd >= 0)\n-    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n+  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n   SSIZE_T res = REAL(pwrite64)(fd, ptr, count, offset);\n-  if (res > 0)\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n+  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n   return res;\n }\n-#define INIT_PWRITE64 INTERCEPT_FUNCTION(pwrite64)\n+#define INIT_PWRITE64 COMMON_INTERCEPT_FUNCTION(pwrite64)\n #else\n #define INIT_PWRITE64\n #endif\n@@ -321,12 +348,13 @@ INTERCEPTOR_WITH_SUFFIX(SSIZE_T, writev, int fd, __sanitizer_iovec *iov,\n                         int iovcnt) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, writev, fd, iov, iovcnt);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n   if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n   SSIZE_T res = REAL(writev)(fd, iov, iovcnt);\n   if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n   return res;\n }\n-#define INIT_WRITEV INTERCEPT_FUNCTION(writev)\n+#define INIT_WRITEV COMMON_INTERCEPT_FUNCTION(writev)\n #else\n #define INIT_WRITEV\n #endif\n@@ -336,12 +364,13 @@ INTERCEPTOR(SSIZE_T, pwritev, int fd, __sanitizer_iovec *iov, int iovcnt,\n             OFF_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pwritev, fd, iov, iovcnt, offset);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n   if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n   SSIZE_T res = REAL(pwritev)(fd, iov, iovcnt, offset);\n   if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n   return res;\n }\n-#define INIT_PWRITEV INTERCEPT_FUNCTION(pwritev)\n+#define INIT_PWRITEV COMMON_INTERCEPT_FUNCTION(pwritev)\n #else\n #define INIT_PWRITEV\n #endif\n@@ -351,20 +380,21 @@ INTERCEPTOR(SSIZE_T, pwritev64, int fd, __sanitizer_iovec *iov, int iovcnt,\n             OFF64_T offset) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, pwritev64, fd, iov, iovcnt, offset);\n+  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n   if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n   SSIZE_T res = REAL(pwritev64)(fd, iov, iovcnt, offset);\n   if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n   return res;\n }\n-#define INIT_PWRITEV64 INTERCEPT_FUNCTION(pwritev64)\n+#define INIT_PWRITEV64 COMMON_INTERCEPT_FUNCTION(pwritev64)\n #else\n #define INIT_PWRITEV64\n #endif\n \n #if SANITIZER_INTERCEPT_PRCTL\n-INTERCEPTOR(int, prctl, int option,\n-            unsigned long arg2, unsigned long arg3,   // NOLINT\n-            unsigned long arg4, unsigned long arg5) { // NOLINT\n+INTERCEPTOR(int, prctl, int option, unsigned long arg2,\n+            unsigned long arg3,                        // NOLINT\n+            unsigned long arg4, unsigned long arg5) {  // NOLINT\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, prctl, option, arg2, arg3, arg4, arg5);\n   static const int PR_SET_NAME = 15;\n@@ -377,11 +407,10 @@ INTERCEPTOR(int, prctl, int option,\n   }\n   return res;\n }\n-#define INIT_PRCTL INTERCEPT_FUNCTION(prctl)\n+#define INIT_PRCTL COMMON_INTERCEPT_FUNCTION(prctl)\n #else\n #define INIT_PRCTL\n-#endif // SANITIZER_INTERCEPT_PRCTL\n-\n+#endif  // SANITIZER_INTERCEPT_PRCTL\n \n #if SANITIZER_INTERCEPT_TIME\n INTERCEPTOR(unsigned long, time, unsigned long *t) {\n@@ -393,51 +422,58 @@ INTERCEPTOR(unsigned long, time, unsigned long *t) {\n   }\n   return res;\n }\n-#define INIT_TIME                                \\\n-  INTERCEPT_FUNCTION(time);\n+#define INIT_TIME COMMON_INTERCEPT_FUNCTION(time);\n #else\n #define INIT_TIME\n-#endif // SANITIZER_INTERCEPT_TIME\n-\n+#endif  // SANITIZER_INTERCEPT_TIME\n \n #if SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n-INTERCEPTOR(void *, localtime, unsigned long *timep) {\n+static void unpoison_tm(void *ctx, __sanitizer_tm *tm) {\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tm, sizeof(*tm));\n+  if (tm->tm_zone) {\n+    // Can not use COMMON_INTERCEPTOR_WRITE_RANGE here, because tm->tm_zone\n+    // can point to shared memory and tsan would report a data race.\n+    COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, tm->tm_zone,\n+                                        REAL(strlen(tm->tm_zone)) + 1);\n+  }\n+}\n+INTERCEPTOR(__sanitizer_tm *, localtime, unsigned long *timep) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, localtime, timep);\n-  void *res = REAL(localtime)(timep);\n+  __sanitizer_tm *res = REAL(localtime)(timep);\n   if (res) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_tm_sz);\n+    unpoison_tm(ctx, res);\n   }\n   return res;\n }\n-INTERCEPTOR(void *, localtime_r, unsigned long *timep, void *result) {\n+INTERCEPTOR(__sanitizer_tm *, localtime_r, unsigned long *timep, void *result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, localtime_r, timep, result);\n-  void *res = REAL(localtime_r)(timep, result);\n+  __sanitizer_tm *res = REAL(localtime_r)(timep, result);\n   if (res) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_tm_sz);\n+    unpoison_tm(ctx, res);\n   }\n   return res;\n }\n-INTERCEPTOR(void *, gmtime, unsigned long *timep) {\n+INTERCEPTOR(__sanitizer_tm *, gmtime, unsigned long *timep) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, gmtime, timep);\n-  void *res = REAL(gmtime)(timep);\n+  __sanitizer_tm *res = REAL(gmtime)(timep);\n   if (res) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_tm_sz);\n+    unpoison_tm(ctx, res);\n   }\n   return res;\n }\n-INTERCEPTOR(void *, gmtime_r, unsigned long *timep, void *result) {\n+INTERCEPTOR(__sanitizer_tm *, gmtime_r, unsigned long *timep, void *result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, gmtime_r, timep, result);\n-  void *res = REAL(gmtime_r)(timep, result);\n+  __sanitizer_tm *res = REAL(gmtime_r)(timep, result);\n   if (res) {\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_tm_sz);\n+    unpoison_tm(ctx, res);\n   }\n   return res;\n }\n@@ -461,38 +497,59 @@ INTERCEPTOR(char *, ctime_r, unsigned long *timep, char *result) {\n   }\n   return res;\n }\n-INTERCEPTOR(char *, asctime, void *tm) {\n+INTERCEPTOR(char *, asctime, __sanitizer_tm *tm) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, asctime, tm);\n   char *res = REAL(asctime)(tm);\n   if (res) {\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, struct_tm_sz);\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, sizeof(*tm));\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   }\n   return res;\n }\n-INTERCEPTOR(char *, asctime_r, void *tm, char *result) {\n+INTERCEPTOR(char *, asctime_r, __sanitizer_tm *tm, char *result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, asctime_r, tm, result);\n   char *res = REAL(asctime_r)(tm, result);\n   if (res) {\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, struct_tm_sz);\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, sizeof(*tm));\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   }\n   return res;\n }\n-#define INIT_LOCALTIME_AND_FRIENDS               \\\n-  INTERCEPT_FUNCTION(localtime);                 \\\n-  INTERCEPT_FUNCTION(localtime_r);               \\\n-  INTERCEPT_FUNCTION(gmtime);                    \\\n-  INTERCEPT_FUNCTION(gmtime_r);                  \\\n-  INTERCEPT_FUNCTION(ctime);                     \\\n-  INTERCEPT_FUNCTION(ctime_r);                   \\\n-  INTERCEPT_FUNCTION(asctime);                   \\\n-  INTERCEPT_FUNCTION(asctime_r);\n+#define INIT_LOCALTIME_AND_FRIENDS        \\\n+  COMMON_INTERCEPT_FUNCTION(localtime);   \\\n+  COMMON_INTERCEPT_FUNCTION(localtime_r); \\\n+  COMMON_INTERCEPT_FUNCTION(gmtime);      \\\n+  COMMON_INTERCEPT_FUNCTION(gmtime_r);    \\\n+  COMMON_INTERCEPT_FUNCTION(ctime);       \\\n+  COMMON_INTERCEPT_FUNCTION(ctime_r);     \\\n+  COMMON_INTERCEPT_FUNCTION(asctime);     \\\n+  COMMON_INTERCEPT_FUNCTION(asctime_r);\n #else\n #define INIT_LOCALTIME_AND_FRIENDS\n-#endif // SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n+#endif  // SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n+\n+#if SANITIZER_INTERCEPT_STRPTIME\n+INTERCEPTOR(char *, strptime, char *s, char *format, __sanitizer_tm *tm) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, strptime, s, format, tm);\n+  if (format)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, format, REAL(strlen)(format) + 1);\n+  char *res = REAL(strptime)(s, format, tm);\n+  if (res) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, res - s);\n+    // Do not call unpoison_tm here, because strptime does not, in fact,\n+    // initialize the entire struct tm. For example, tm_zone pointer is left\n+    // uninitialized.\n+    if (tm) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tm, sizeof(*tm));\n+  }\n+  return res;\n+}\n+#define INIT_STRPTIME COMMON_INTERCEPT_FUNCTION(strptime);\n+#else\n+#define INIT_STRPTIME\n+#endif\n \n #if SANITIZER_INTERCEPT_SCANF\n \n@@ -566,25 +623,25 @@ SCANF_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n #endif\n \n #if SANITIZER_INTERCEPT_SCANF\n-#define INIT_SCANF             \\\n-  INTERCEPT_FUNCTION(scanf);   \\\n-  INTERCEPT_FUNCTION(sscanf);  \\\n-  INTERCEPT_FUNCTION(fscanf);  \\\n-  INTERCEPT_FUNCTION(vscanf);  \\\n-  INTERCEPT_FUNCTION(vsscanf); \\\n-  INTERCEPT_FUNCTION(vfscanf);\n+#define INIT_SCANF                    \\\n+  COMMON_INTERCEPT_FUNCTION(scanf);   \\\n+  COMMON_INTERCEPT_FUNCTION(sscanf);  \\\n+  COMMON_INTERCEPT_FUNCTION(fscanf);  \\\n+  COMMON_INTERCEPT_FUNCTION(vscanf);  \\\n+  COMMON_INTERCEPT_FUNCTION(vsscanf); \\\n+  COMMON_INTERCEPT_FUNCTION(vfscanf);\n #else\n #define INIT_SCANF\n #endif\n \n #if SANITIZER_INTERCEPT_ISOC99_SCANF\n-#define INIT_ISOC99_SCANF               \\\n-  INTERCEPT_FUNCTION(__isoc99_scanf);   \\\n-  INTERCEPT_FUNCTION(__isoc99_sscanf);  \\\n-  INTERCEPT_FUNCTION(__isoc99_fscanf);  \\\n-  INTERCEPT_FUNCTION(__isoc99_vscanf);  \\\n-  INTERCEPT_FUNCTION(__isoc99_vsscanf); \\\n-  INTERCEPT_FUNCTION(__isoc99_vfscanf);\n+#define INIT_ISOC99_SCANF                      \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_scanf);   \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_sscanf);  \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_fscanf);  \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_vscanf);  \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_vsscanf); \\\n+  COMMON_INTERCEPT_FUNCTION(__isoc99_vfscanf);\n #else\n #define INIT_ISOC99_SCANF\n #endif\n@@ -599,77 +656,67 @@ INTERCEPTOR(int, ioctl, int d, unsigned request, void *arg) {\n \n   // Note: TSan does not use common flags, and they are zero-initialized.\n   // This effectively disables ioctl handling in TSan.\n-  if (!common_flags()->handle_ioctl)\n-    return REAL(ioctl)(d, request, arg);\n+  if (!common_flags()->handle_ioctl) return REAL(ioctl)(d, request, arg);\n \n   const ioctl_desc *desc = ioctl_lookup(request);\n-  if (!desc)\n-    Printf(\"WARNING: unknown ioctl %x\\n\", request);\n+  if (!desc) Printf(\"WARNING: unknown ioctl %x\\n\", request);\n \n-  if (desc)\n-    ioctl_common_pre(ctx, desc, d, request, arg);\n+  if (desc) ioctl_common_pre(ctx, desc, d, request, arg);\n   int res = REAL(ioctl)(d, request, arg);\n   // FIXME: some ioctls have different return values for success and failure.\n-  if (desc && res != -1)\n-    ioctl_common_post(ctx, desc, res, d, request, arg);\n+  if (desc && res != -1) ioctl_common_post(ctx, desc, res, d, request, arg);\n   return res;\n }\n #define INIT_IOCTL \\\n   ioctl_init();    \\\n-  INTERCEPT_FUNCTION(ioctl);\n+  COMMON_INTERCEPT_FUNCTION(ioctl);\n #else\n #define INIT_IOCTL\n #endif\n \n-\n #if SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS\n INTERCEPTOR(void *, getpwnam, const char *name) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwnam, name);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n   void *res = REAL(getpwnam)(name);\n-  if (res != 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_passwd_sz);\n+  if (res != 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_passwd_sz);\n   return res;\n }\n INTERCEPTOR(void *, getpwuid, u32 uid) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwuid, uid);\n   void *res = REAL(getpwuid)(uid);\n-  if (res != 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_passwd_sz);\n+  if (res != 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_passwd_sz);\n   return res;\n }\n INTERCEPTOR(void *, getgrnam, const char *name) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrnam, name);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n   void *res = REAL(getgrnam)(name);\n-  if (res != 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_group_sz);\n+  if (res != 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_group_sz);\n   return res;\n }\n INTERCEPTOR(void *, getgrgid, u32 gid) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrgid, gid);\n   void *res = REAL(getgrgid)(gid);\n-  if (res != 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_group_sz);\n+  if (res != 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_group_sz);\n   return res;\n }\n-#define INIT_GETPWNAM_AND_FRIENDS                  \\\n-  INTERCEPT_FUNCTION(getpwnam);                    \\\n-  INTERCEPT_FUNCTION(getpwuid);                    \\\n-  INTERCEPT_FUNCTION(getgrnam);                    \\\n-  INTERCEPT_FUNCTION(getgrgid);\n+#define INIT_GETPWNAM_AND_FRIENDS      \\\n+  COMMON_INTERCEPT_FUNCTION(getpwnam); \\\n+  COMMON_INTERCEPT_FUNCTION(getpwuid); \\\n+  COMMON_INTERCEPT_FUNCTION(getgrnam); \\\n+  COMMON_INTERCEPT_FUNCTION(getgrgid);\n #else\n #define INIT_GETPWNAM_AND_FRIENDS\n #endif\n \n-\n #if SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\n-INTERCEPTOR(int, getpwnam_r, const char *name, void *pwd,\n-    char *buf, SIZE_T buflen, void **result) {\n+INTERCEPTOR(int, getpwnam_r, const char *name, void *pwd, char *buf,\n+            SIZE_T buflen, void **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwnam_r, name, pwd, buf, buflen, result);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n@@ -680,8 +727,8 @@ INTERCEPTOR(int, getpwnam_r, const char *name, void *pwd,\n   }\n   return res;\n }\n-INTERCEPTOR(int, getpwuid_r, u32 uid, void *pwd,\n-    char *buf, SIZE_T buflen, void **result) {\n+INTERCEPTOR(int, getpwuid_r, u32 uid, void *pwd, char *buf, SIZE_T buflen,\n+            void **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getpwuid_r, uid, pwd, buf, buflen, result);\n   int res = REAL(getpwuid_r)(uid, pwd, buf, buflen, result);\n@@ -691,8 +738,8 @@ INTERCEPTOR(int, getpwuid_r, u32 uid, void *pwd,\n   }\n   return res;\n }\n-INTERCEPTOR(int, getgrnam_r, const char *name, void *grp,\n-    char *buf, SIZE_T buflen, void **result) {\n+INTERCEPTOR(int, getgrnam_r, const char *name, void *grp, char *buf,\n+            SIZE_T buflen, void **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrnam_r, name, grp, buf, buflen, result);\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n@@ -703,8 +750,8 @@ INTERCEPTOR(int, getgrnam_r, const char *name, void *grp,\n   }\n   return res;\n }\n-INTERCEPTOR(int, getgrgid_r, u32 gid, void *grp,\n-    char *buf, SIZE_T buflen, void **result) {\n+INTERCEPTOR(int, getgrgid_r, u32 gid, void *grp, char *buf, SIZE_T buflen,\n+            void **result) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgrgid_r, gid, grp, buf, buflen, result);\n   int res = REAL(getgrgid_r)(gid, grp, buf, buflen, result);\n@@ -714,16 +761,15 @@ INTERCEPTOR(int, getgrgid_r, u32 gid, void *grp,\n   }\n   return res;\n }\n-#define INIT_GETPWNAM_R_AND_FRIENDS                \\\n-  INTERCEPT_FUNCTION(getpwnam_r);                  \\\n-  INTERCEPT_FUNCTION(getpwuid_r);                  \\\n-  INTERCEPT_FUNCTION(getgrnam_r);                  \\\n-  INTERCEPT_FUNCTION(getgrgid_r);\n+#define INIT_GETPWNAM_R_AND_FRIENDS      \\\n+  COMMON_INTERCEPT_FUNCTION(getpwnam_r); \\\n+  COMMON_INTERCEPT_FUNCTION(getpwuid_r); \\\n+  COMMON_INTERCEPT_FUNCTION(getgrnam_r); \\\n+  COMMON_INTERCEPT_FUNCTION(getgrgid_r);\n #else\n #define INIT_GETPWNAM_R_AND_FRIENDS\n #endif\n \n-\n #if SANITIZER_INTERCEPT_CLOCK_GETTIME\n INTERCEPTOR(int, clock_getres, u32 clk_id, void *tp) {\n   void *ctx;\n@@ -749,15 +795,14 @@ INTERCEPTOR(int, clock_settime, u32 clk_id, const void *tp) {\n   COMMON_INTERCEPTOR_READ_RANGE(ctx, tp, struct_timespec_sz);\n   return REAL(clock_settime)(clk_id, tp);\n }\n-#define INIT_CLOCK_GETTIME                         \\\n-  INTERCEPT_FUNCTION(clock_getres);                \\\n-  INTERCEPT_FUNCTION(clock_gettime);               \\\n-  INTERCEPT_FUNCTION(clock_settime);\n+#define INIT_CLOCK_GETTIME                  \\\n+  COMMON_INTERCEPT_FUNCTION(clock_getres);  \\\n+  COMMON_INTERCEPT_FUNCTION(clock_gettime); \\\n+  COMMON_INTERCEPT_FUNCTION(clock_settime);\n #else\n #define INIT_CLOCK_GETTIME\n #endif\n \n-\n #if SANITIZER_INTERCEPT_GETITIMER\n INTERCEPTOR(int, getitimer, int which, void *curr_value) {\n   void *ctx;\n@@ -779,9 +824,9 @@ INTERCEPTOR(int, setitimer, int which, const void *new_value, void *old_value) {\n   }\n   return res;\n }\n-#define INIT_GETITIMER                             \\\n-  INTERCEPT_FUNCTION(getitimer);                   \\\n-  INTERCEPT_FUNCTION(setitimer);\n+#define INIT_GETITIMER                  \\\n+  COMMON_INTERCEPT_FUNCTION(getitimer); \\\n+  COMMON_INTERCEPT_FUNCTION(setitimer);\n #else\n #define INIT_GETITIMER\n #endif\n@@ -799,8 +844,8 @@ static void unpoison_glob_t(void *ctx, __sanitizer_glob_t *pglob) {\n   }\n }\n \n-static THREADLOCAL __sanitizer_glob_t* pglob_copy;\n-static THREADLOCAL void* glob_ctx;\n+static THREADLOCAL __sanitizer_glob_t *pglob_copy;\n+static THREADLOCAL void *glob_ctx;\n \n static void wrapped_gl_closedir(void *dir) {\n   COMMON_INTERCEPTOR_UNPOISON_PARAM(glob_ctx, 1);\n@@ -835,9 +880,10 @@ INTERCEPTOR(int, glob, const char *pattern, int flags,\n             __sanitizer_glob_t *pglob) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, glob, pattern, flags, errfunc, pglob);\n-  __sanitizer_glob_t glob_copy = {0, 0, 0, 0, wrapped_gl_closedir,\n-                                  wrapped_gl_readdir, wrapped_gl_opendir,\n-                                  wrapped_gl_lstat, wrapped_gl_stat};\n+  __sanitizer_glob_t glob_copy = {\n+      0,                  0,                   0,\n+      0,                  wrapped_gl_closedir, wrapped_gl_readdir,\n+      wrapped_gl_opendir, wrapped_gl_lstat,    wrapped_gl_stat};\n   if (flags & glob_altdirfunc) {\n     Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n     Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n@@ -866,9 +912,10 @@ INTERCEPTOR(int, glob64, const char *pattern, int flags,\n             __sanitizer_glob_t *pglob) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, glob64, pattern, flags, errfunc, pglob);\n-  __sanitizer_glob_t glob_copy = {0, 0, 0, 0, wrapped_gl_closedir,\n-                                  wrapped_gl_readdir, wrapped_gl_opendir,\n-                                  wrapped_gl_lstat, wrapped_gl_stat};\n+  __sanitizer_glob_t glob_copy = {\n+      0,                  0,                   0,\n+      0,                  wrapped_gl_closedir, wrapped_gl_readdir,\n+      wrapped_gl_opendir, wrapped_gl_lstat,    wrapped_gl_stat};\n   if (flags & glob_altdirfunc) {\n     Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n     Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n@@ -891,9 +938,9 @@ INTERCEPTOR(int, glob64, const char *pattern, int flags,\n   if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n   return res;\n }\n-#define INIT_GLOB           \\\n-  INTERCEPT_FUNCTION(glob); \\\n-  INTERCEPT_FUNCTION(glob64);\n+#define INIT_GLOB                  \\\n+  COMMON_INTERCEPT_FUNCTION(glob); \\\n+  COMMON_INTERCEPT_FUNCTION(glob64);\n #else  // SANITIZER_INTERCEPT_GLOB\n #define INIT_GLOB\n #endif  // SANITIZER_INTERCEPT_GLOB\n@@ -911,7 +958,7 @@ INTERCEPTOR_WITH_SUFFIX(int, wait, int *status) {\n   return res;\n }\n INTERCEPTOR_WITH_SUFFIX(int, waitid, int idtype, int id, void *infop,\n-  int options) {\n+                        int options) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, waitid, idtype, id, infop, options);\n   int res = REAL(waitid)(idtype, id, infop, options);\n@@ -932,10 +979,8 @@ INTERCEPTOR(int, wait3, int *status, int options, void *rusage) {\n   COMMON_INTERCEPTOR_ENTER(ctx, wait3, status, options, rusage);\n   int res = REAL(wait3)(status, options, rusage);\n   if (res != -1) {\n-    if (status)\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n-    if (rusage)\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n+    if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n+    if (rusage) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n   }\n   return res;\n }\n@@ -944,19 +989,17 @@ INTERCEPTOR(int, wait4, int pid, int *status, int options, void *rusage) {\n   COMMON_INTERCEPTOR_ENTER(ctx, wait4, pid, status, options, rusage);\n   int res = REAL(wait4)(pid, status, options, rusage);\n   if (res != -1) {\n-    if (status)\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n-    if (rusage)\n-      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n+    if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n+    if (rusage) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n   }\n   return res;\n }\n-#define INIT_WAIT                                \\\n-  INTERCEPT_FUNCTION(wait);                      \\\n-  INTERCEPT_FUNCTION(waitid);                    \\\n-  INTERCEPT_FUNCTION(waitpid);                   \\\n-  INTERCEPT_FUNCTION(wait3);                     \\\n-  INTERCEPT_FUNCTION(wait4);\n+#define INIT_WAIT                     \\\n+  COMMON_INTERCEPT_FUNCTION(wait);    \\\n+  COMMON_INTERCEPT_FUNCTION(waitid);  \\\n+  COMMON_INTERCEPT_FUNCTION(waitpid); \\\n+  COMMON_INTERCEPT_FUNCTION(wait3);   \\\n+  COMMON_INTERCEPT_FUNCTION(wait4);\n #else\n #define INIT_WAIT\n #endif\n@@ -969,8 +1012,7 @@ INTERCEPTOR(char *, inet_ntop, int af, const void *src, char *dst, u32 size) {\n   if (sz) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sz);\n   // FIXME: figure out read size based on the address family.\n   char *res = REAL(inet_ntop)(af, src, dst, size);\n-  if (res)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n }\n INTERCEPTOR(int, inet_pton, int af, const char *src, void *dst) {\n@@ -984,9 +1026,9 @@ INTERCEPTOR(int, inet_pton, int af, const char *src, void *dst) {\n   }\n   return res;\n }\n-#define INIT_INET                                \\\n-  INTERCEPT_FUNCTION(inet_ntop);                 \\\n-  INTERCEPT_FUNCTION(inet_pton);\n+#define INIT_INET                       \\\n+  COMMON_INTERCEPT_FUNCTION(inet_ntop); \\\n+  COMMON_INTERCEPT_FUNCTION(inet_pton);\n #else\n #define INIT_INET\n #endif\n@@ -1003,7 +1045,7 @@ INTERCEPTOR(int, inet_aton, const char *cp, void *dst) {\n   }\n   return res;\n }\n-#define INIT_INET_ATON INTERCEPT_FUNCTION(inet_aton);\n+#define INIT_INET_ATON COMMON_INTERCEPT_FUNCTION(inet_aton);\n #else\n #define INIT_INET_ATON\n #endif\n@@ -1019,7 +1061,8 @@ INTERCEPTOR(int, pthread_getschedparam, uptr thread, int *policy, int *param) {\n   }\n   return res;\n }\n-#define INIT_PTHREAD_GETSCHEDPARAM INTERCEPT_FUNCTION(pthread_getschedparam);\n+#define INIT_PTHREAD_GETSCHEDPARAM \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_getschedparam);\n #else\n #define INIT_PTHREAD_GETSCHEDPARAM\n #endif\n@@ -1051,7 +1094,7 @@ INTERCEPTOR(int, getaddrinfo, char *node, char *service,\n   }\n   return res;\n }\n-#define INIT_GETADDRINFO INTERCEPT_FUNCTION(getaddrinfo);\n+#define INIT_GETADDRINFO COMMON_INTERCEPT_FUNCTION(getaddrinfo);\n #else\n #define INIT_GETADDRINFO\n #endif\n@@ -1074,7 +1117,7 @@ INTERCEPTOR(int, getnameinfo, void *sockaddr, unsigned salen, char *host,\n   }\n   return res;\n }\n-#define INIT_GETNAMEINFO INTERCEPT_FUNCTION(getnameinfo);\n+#define INIT_GETNAMEINFO COMMON_INTERCEPT_FUNCTION(getnameinfo);\n #else\n #define INIT_GETNAMEINFO\n #endif\n@@ -1091,7 +1134,7 @@ INTERCEPTOR(int, getsockname, int sock_fd, void *addr, int *addrlen) {\n   }\n   return res;\n }\n-#define INIT_GETSOCKNAME INTERCEPT_FUNCTION(getsockname);\n+#define INIT_GETSOCKNAME COMMON_INTERCEPT_FUNCTION(getsockname);\n #else\n #define INIT_GETSOCKNAME\n #endif\n@@ -1137,10 +1180,10 @@ INTERCEPTOR(struct __sanitizer_hostent *, gethostbyaddr, void *addr, int len,\n   return res;\n }\n \n-INTERCEPTOR(struct __sanitizer_hostent *, gethostent) {\n+INTERCEPTOR(struct __sanitizer_hostent *, gethostent, int fake) {\n   void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, gethostent);\n-  struct __sanitizer_hostent *res = REAL(gethostent)();\n+  COMMON_INTERCEPTOR_ENTER(ctx, gethostent, fake);\n+  struct __sanitizer_hostent *res = REAL(gethostent)(fake);\n   if (res) write_hostent(ctx, res);\n   return res;\n }\n@@ -1152,11 +1195,11 @@ INTERCEPTOR(struct __sanitizer_hostent *, gethostbyname2, char *name, int af) {\n   if (res) write_hostent(ctx, res);\n   return res;\n }\n-#define INIT_GETHOSTBYNAME           \\\n-  INTERCEPT_FUNCTION(gethostent);    \\\n-  INTERCEPT_FUNCTION(gethostbyaddr); \\\n-  INTERCEPT_FUNCTION(gethostbyname); \\\n-  INTERCEPT_FUNCTION(gethostbyname2);\n+#define INIT_GETHOSTBYNAME                  \\\n+  COMMON_INTERCEPT_FUNCTION(gethostent);    \\\n+  COMMON_INTERCEPT_FUNCTION(gethostbyaddr); \\\n+  COMMON_INTERCEPT_FUNCTION(gethostbyname); \\\n+  COMMON_INTERCEPT_FUNCTION(gethostbyname2);\n #else\n #define INIT_GETHOSTBYNAME\n #endif\n@@ -1235,11 +1278,11 @@ INTERCEPTOR(int, gethostbyname2_r, char *name, int af,\n   }\n   return res;\n }\n-#define INIT_GETHOSTBYNAME_R           \\\n-  INTERCEPT_FUNCTION(gethostent_r);    \\\n-  INTERCEPT_FUNCTION(gethostbyaddr_r); \\\n-  INTERCEPT_FUNCTION(gethostbyname_r); \\\n-  INTERCEPT_FUNCTION(gethostbyname2_r);\n+#define INIT_GETHOSTBYNAME_R                  \\\n+  COMMON_INTERCEPT_FUNCTION(gethostent_r);    \\\n+  COMMON_INTERCEPT_FUNCTION(gethostbyaddr_r); \\\n+  COMMON_INTERCEPT_FUNCTION(gethostbyname_r); \\\n+  COMMON_INTERCEPT_FUNCTION(gethostbyname2_r);\n #else\n #define INIT_GETHOSTBYNAME_R\n #endif\n@@ -1256,7 +1299,7 @@ INTERCEPTOR(int, getsockopt, int sockfd, int level, int optname, void *optval,\n     if (optval && optlen) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, optval, *optlen);\n   return res;\n }\n-#define INIT_GETSOCKOPT INTERCEPT_FUNCTION(getsockopt);\n+#define INIT_GETSOCKOPT COMMON_INTERCEPT_FUNCTION(getsockopt);\n #else\n #define INIT_GETSOCKOPT\n #endif\n@@ -1272,14 +1315,13 @@ INTERCEPTOR(int, accept, int fd, void *addr, unsigned *addrlen) {\n   }\n   int fd2 = REAL(accept)(fd, addr, addrlen);\n   if (fd2 >= 0) {\n-    if (fd >= 0)\n-      COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n+    if (fd >= 0) COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n     if (addr && addrlen)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n   }\n   return fd2;\n }\n-#define INIT_ACCEPT INTERCEPT_FUNCTION(accept);\n+#define INIT_ACCEPT COMMON_INTERCEPT_FUNCTION(accept);\n #else\n #define INIT_ACCEPT\n #endif\n@@ -1295,14 +1337,13 @@ INTERCEPTOR(int, accept4, int fd, void *addr, unsigned *addrlen, int f) {\n   }\n   int fd2 = REAL(accept4)(fd, addr, addrlen, f);\n   if (fd2 >= 0) {\n-    if (fd >= 0)\n-      COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n+    if (fd >= 0) COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n     if (addr && addrlen)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n   }\n   return fd2;\n }\n-#define INIT_ACCEPT4 INTERCEPT_FUNCTION(accept4);\n+#define INIT_ACCEPT4 COMMON_INTERCEPT_FUNCTION(accept4);\n #else\n #define INIT_ACCEPT4\n #endif\n@@ -1335,10 +1376,10 @@ INTERCEPTOR(long double, modfl, long double x, long double *iptr) {\n   }\n   return res;\n }\n-#define INIT_MODF            \\\n-  INTERCEPT_FUNCTION(modf);  \\\n-  INTERCEPT_FUNCTION(modff); \\\n-  INTERCEPT_FUNCTION(modfl);\n+#define INIT_MODF                   \\\n+  COMMON_INTERCEPT_FUNCTION(modf);  \\\n+  COMMON_INTERCEPT_FUNCTION(modff); \\\n+  COMMON_INTERCEPT_FUNCTION(modfl);\n #else\n #define INIT_MODF\n #endif\n@@ -1347,14 +1388,13 @@ INTERCEPTOR(long double, modfl, long double x, long double *iptr) {\n static void write_msghdr(void *ctx, struct __sanitizer_msghdr *msg,\n                          SSIZE_T maxlen) {\n   COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg, sizeof(*msg));\n-  if (msg->msg_name)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_name,\n-                                   REAL(strlen)((char *)msg->msg_name) + 1);\n-  if (msg->msg_iov)\n+  if (msg->msg_name && msg->msg_namelen)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_name, msg->msg_namelen);\n+  if (msg->msg_iov && msg->msg_iovlen)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_iov,\n                                    sizeof(*msg->msg_iov) * msg->msg_iovlen);\n   write_iovec(ctx, msg->msg_iov, msg->msg_iovlen, maxlen);\n-  if (msg->msg_control)\n+  if (msg->msg_control && msg->msg_controllen)\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_control, msg->msg_controllen);\n }\n \n@@ -1365,11 +1405,14 @@ INTERCEPTOR(SSIZE_T, recvmsg, int fd, struct __sanitizer_msghdr *msg,\n   SSIZE_T res = REAL(recvmsg)(fd, msg, flags);\n   if (res >= 0) {\n     if (fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n-    if (msg) write_msghdr(ctx, msg, res);\n+    if (msg) {\n+      write_msghdr(ctx, msg, res);\n+      COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg);\n+    }\n   }\n   return res;\n }\n-#define INIT_RECVMSG INTERCEPT_FUNCTION(recvmsg);\n+#define INIT_RECVMSG COMMON_INTERCEPT_FUNCTION(recvmsg);\n #else\n #define INIT_RECVMSG\n #endif\n@@ -1385,7 +1428,7 @@ INTERCEPTOR(int, getpeername, int sockfd, void *addr, unsigned *addrlen) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(addr_sz, *addrlen));\n   return res;\n }\n-#define INIT_GETPEERNAME INTERCEPT_FUNCTION(getpeername);\n+#define INIT_GETPEERNAME COMMON_INTERCEPT_FUNCTION(getpeername);\n #else\n #define INIT_GETPEERNAME\n #endif\n@@ -1399,7 +1442,7 @@ INTERCEPTOR(int, sysinfo, void *info) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, struct_sysinfo_sz);\n   return res;\n }\n-#define INIT_SYSINFO INTERCEPT_FUNCTION(sysinfo);\n+#define INIT_SYSINFO COMMON_INTERCEPT_FUNCTION(sysinfo);\n #else\n #define INIT_SYSINFO\n #endif\n@@ -1409,8 +1452,7 @@ INTERCEPTOR(__sanitizer_dirent *, readdir, void *dirp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, readdir, dirp);\n   __sanitizer_dirent *res = REAL(readdir)(dirp);\n-  if (res)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n   return res;\n }\n \n@@ -1427,9 +1469,9 @@ INTERCEPTOR(int, readdir_r, void *dirp, __sanitizer_dirent *entry,\n   return res;\n }\n \n-#define INIT_READDIR           \\\n-  INTERCEPT_FUNCTION(readdir); \\\n-  INTERCEPT_FUNCTION(readdir_r);\n+#define INIT_READDIR                  \\\n+  COMMON_INTERCEPT_FUNCTION(readdir); \\\n+  COMMON_INTERCEPT_FUNCTION(readdir_r);\n #else\n #define INIT_READDIR\n #endif\n@@ -1439,8 +1481,7 @@ INTERCEPTOR(__sanitizer_dirent64 *, readdir64, void *dirp) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, readdir64, dirp);\n   __sanitizer_dirent64 *res = REAL(readdir64)(dirp);\n-  if (res)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n   return res;\n }\n \n@@ -1456,9 +1497,9 @@ INTERCEPTOR(int, readdir64_r, void *dirp, __sanitizer_dirent64 *entry,\n   }\n   return res;\n }\n-#define INIT_READDIR64           \\\n-  INTERCEPT_FUNCTION(readdir64); \\\n-  INTERCEPT_FUNCTION(readdir64_r);\n+#define INIT_READDIR64                  \\\n+  COMMON_INTERCEPT_FUNCTION(readdir64); \\\n+  COMMON_INTERCEPT_FUNCTION(readdir64_r);\n #else\n #define INIT_READDIR64\n #endif\n@@ -1504,8 +1545,7 @@ INTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n   return res;\n }\n \n-#define INIT_PTRACE           \\\n-  INTERCEPT_FUNCTION(ptrace);\n+#define INIT_PTRACE COMMON_INTERCEPT_FUNCTION(ptrace);\n #else\n #define INIT_PTRACE\n #endif\n@@ -1517,13 +1557,11 @@ INTERCEPTOR(char *, setlocale, int category, char *locale) {\n   if (locale)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, locale, REAL(strlen)(locale) + 1);\n   char *res = REAL(setlocale)(category, locale);\n-  if (res)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n }\n \n-#define INIT_SETLOCALE           \\\n-  INTERCEPT_FUNCTION(setlocale);\n+#define INIT_SETLOCALE COMMON_INTERCEPT_FUNCTION(setlocale);\n #else\n #define INIT_SETLOCALE\n #endif\n@@ -1533,28 +1571,25 @@ INTERCEPTOR(char *, getcwd, char *buf, SIZE_T size) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getcwd, buf, size);\n   char *res = REAL(getcwd)(buf, size);\n-  if (res)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n }\n-#define INIT_GETCWD           \\\n-  INTERCEPT_FUNCTION(getcwd);\n+#define INIT_GETCWD COMMON_INTERCEPT_FUNCTION(getcwd);\n #else\n #define INIT_GETCWD\n #endif\n \n #if SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME\n-INTERCEPTOR(char *, get_current_dir_name) {\n+INTERCEPTOR(char *, get_current_dir_name, int fake) {\n   void *ctx;\n-  COMMON_INTERCEPTOR_ENTER(ctx, get_current_dir_name);\n-  char *res = REAL(get_current_dir_name)();\n-  if (res)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  COMMON_INTERCEPTOR_ENTER(ctx, get_current_dir_name, fake);\n+  char *res = REAL(get_current_dir_name)(fake);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n }\n \n-#define INIT_GET_CURRENT_DIR_NAME           \\\n-  INTERCEPT_FUNCTION(get_current_dir_name);\n+#define INIT_GET_CURRENT_DIR_NAME \\\n+  COMMON_INTERCEPT_FUNCTION(get_current_dir_name);\n #else\n #define INIT_GET_CURRENT_DIR_NAME\n #endif\n@@ -1576,9 +1611,9 @@ INTERCEPTOR(INTMAX_T, strtoumax, const char *nptr, char **endptr, int base) {\n   return res;\n }\n \n-#define INIT_STRTOIMAX           \\\n-  INTERCEPT_FUNCTION(strtoimax); \\\n-  INTERCEPT_FUNCTION(strtoumax);\n+#define INIT_STRTOIMAX                  \\\n+  COMMON_INTERCEPT_FUNCTION(strtoimax); \\\n+  COMMON_INTERCEPT_FUNCTION(strtoumax);\n #else\n #define INIT_STRTOIMAX\n #endif\n@@ -1611,9 +1646,9 @@ INTERCEPTOR(SIZE_T, mbsrtowcs, wchar_t *dest, const char **src, SIZE_T len,\n   return res;\n }\n \n-#define INIT_MBSTOWCS           \\\n-  INTERCEPT_FUNCTION(mbstowcs); \\\n-  INTERCEPT_FUNCTION(mbsrtowcs);\n+#define INIT_MBSTOWCS                  \\\n+  COMMON_INTERCEPT_FUNCTION(mbstowcs); \\\n+  COMMON_INTERCEPT_FUNCTION(mbsrtowcs);\n #else\n #define INIT_MBSTOWCS\n #endif\n@@ -1636,7 +1671,7 @@ INTERCEPTOR(SIZE_T, mbsnrtowcs, wchar_t *dest, const char **src, SIZE_T nms,\n   return res;\n }\n \n-#define INIT_MBSNRTOWCS INTERCEPT_FUNCTION(mbsnrtowcs);\n+#define INIT_MBSNRTOWCS COMMON_INTERCEPT_FUNCTION(mbsnrtowcs);\n #else\n #define INIT_MBSNRTOWCS\n #endif\n@@ -1667,9 +1702,9 @@ INTERCEPTOR(SIZE_T, wcsrtombs, char *dest, const wchar_t **src, SIZE_T len,\n   return res;\n }\n \n-#define INIT_WCSTOMBS           \\\n-  INTERCEPT_FUNCTION(wcstombs); \\\n-  INTERCEPT_FUNCTION(wcsrtombs);\n+#define INIT_WCSTOMBS                  \\\n+  COMMON_INTERCEPT_FUNCTION(wcstombs); \\\n+  COMMON_INTERCEPT_FUNCTION(wcsrtombs);\n #else\n #define INIT_WCSTOMBS\n #endif\n@@ -1692,12 +1727,11 @@ INTERCEPTOR(SIZE_T, wcsnrtombs, char *dest, const wchar_t **src, SIZE_T nms,\n   return res;\n }\n \n-#define INIT_WCSNRTOMBS INTERCEPT_FUNCTION(wcsnrtombs);\n+#define INIT_WCSNRTOMBS COMMON_INTERCEPT_FUNCTION(wcsnrtombs);\n #else\n #define INIT_WCSNRTOMBS\n #endif\n \n-\n #if SANITIZER_INTERCEPT_TCGETATTR\n INTERCEPTOR(int, tcgetattr, int fd, void *termios_p) {\n   void *ctx;\n@@ -1708,12 +1742,11 @@ INTERCEPTOR(int, tcgetattr, int fd, void *termios_p) {\n   return res;\n }\n \n-#define INIT_TCGETATTR INTERCEPT_FUNCTION(tcgetattr);\n+#define INIT_TCGETATTR COMMON_INTERCEPT_FUNCTION(tcgetattr);\n #else\n #define INIT_TCGETATTR\n #endif\n \n-\n #if SANITIZER_INTERCEPT_REALPATH\n INTERCEPTOR(char *, realpath, const char *path, char *resolved_path) {\n   void *ctx;\n@@ -1729,12 +1762,11 @@ INTERCEPTOR(char *, realpath, const char *path, char *resolved_path) {\n     allocated_path = resolved_path = (char *)WRAP(malloc)(path_max + 1);\n \n   char *res = REAL(realpath)(path, resolved_path);\n-  if (allocated_path && !res)\n-    WRAP(free)(allocated_path);\n+  if (allocated_path && !res) WRAP(free)(allocated_path);\n   if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n }\n-#define INIT_REALPATH INTERCEPT_FUNCTION(realpath);\n+#define INIT_REALPATH COMMON_INTERCEPT_FUNCTION(realpath);\n #else\n #define INIT_REALPATH\n #endif\n@@ -1748,7 +1780,8 @@ INTERCEPTOR(char *, canonicalize_file_name, const char *path) {\n   if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n }\n-#define INIT_CANONICALIZE_FILE_NAME INTERCEPT_FUNCTION(canonicalize_file_name);\n+#define INIT_CANONICALIZE_FILE_NAME \\\n+  COMMON_INTERCEPT_FUNCTION(canonicalize_file_name);\n #else\n #define INIT_CANONICALIZE_FILE_NAME\n #endif\n@@ -1762,7 +1795,7 @@ INTERCEPTOR(SIZE_T, confstr, int name, char *buf, SIZE_T len) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, res < len ? res : len);\n   return res;\n }\n-#define INIT_CONFSTR INTERCEPT_FUNCTION(confstr);\n+#define INIT_CONFSTR COMMON_INTERCEPT_FUNCTION(confstr);\n #else\n #define INIT_CONFSTR\n #endif\n@@ -1772,11 +1805,10 @@ INTERCEPTOR(int, sched_getaffinity, int pid, SIZE_T cpusetsize, void *mask) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, sched_getaffinity, pid, cpusetsize, mask);\n   int res = REAL(sched_getaffinity)(pid, cpusetsize, mask);\n-  if (mask && !res)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mask, cpusetsize);\n+  if (mask && !res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mask, cpusetsize);\n   return res;\n }\n-#define INIT_SCHED_GETAFFINITY INTERCEPT_FUNCTION(sched_getaffinity);\n+#define INIT_SCHED_GETAFFINITY COMMON_INTERCEPT_FUNCTION(sched_getaffinity);\n #else\n #define INIT_SCHED_GETAFFINITY\n #endif\n@@ -1786,11 +1818,10 @@ INTERCEPTOR(char *, strerror, int errnum) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, strerror, errnum);\n   char *res = REAL(strerror)(errnum);\n-  if (res)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n   return res;\n }\n-#define INIT_STRERROR INTERCEPT_FUNCTION(strerror);\n+#define INIT_STRERROR COMMON_INTERCEPT_FUNCTION(strerror);\n #else\n #define INIT_STRERROR\n #endif\n@@ -1818,11 +1849,26 @@ INTERCEPTOR(char *, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n   }\n   return res;\n }\n-#define INIT_STRERROR_R INTERCEPT_FUNCTION(strerror_r);\n+#define INIT_STRERROR_R COMMON_INTERCEPT_FUNCTION(strerror_r);\n #else\n #define INIT_STRERROR_R\n #endif\n \n+#if SANITIZER_INTERCEPT_XPG_STRERROR_R\n+INTERCEPTOR(int, __xpg_strerror_r, int errnum, char *buf, SIZE_T buflen) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, __xpg_strerror_r, errnum, buf, buflen);\n+  int res = REAL(__xpg_strerror_r)(errnum, buf, buflen);\n+  // This version always returns a null-terminated string.\n+  if (buf && buflen)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n+  return res;\n+}\n+#define INIT_XPG_STRERROR_R COMMON_INTERCEPT_FUNCTION(__xpg_strerror_r);\n+#else\n+#define INIT_XPG_STRERROR_R\n+#endif\n+\n #if SANITIZER_INTERCEPT_SCANDIR\n typedef int (*scandir_filter_f)(const struct __sanitizer_dirent *);\n typedef int (*scandir_compar_f)(const struct __sanitizer_dirent **,\n@@ -1871,7 +1917,7 @@ INTERCEPTOR(int, scandir, char *dirp, __sanitizer_dirent ***namelist,\n   }\n   return res;\n }\n-#define INIT_SCANDIR INTERCEPT_FUNCTION(scandir);\n+#define INIT_SCANDIR COMMON_INTERCEPT_FUNCTION(scandir);\n #else\n #define INIT_SCANDIR\n #endif\n@@ -1925,7 +1971,7 @@ INTERCEPTOR(int, scandir64, char *dirp, __sanitizer_dirent64 ***namelist,\n   }\n   return res;\n }\n-#define INIT_SCANDIR64 INTERCEPT_FUNCTION(scandir64);\n+#define INIT_SCANDIR64 COMMON_INTERCEPT_FUNCTION(scandir64);\n #else\n #define INIT_SCANDIR64\n #endif\n@@ -1935,11 +1981,10 @@ INTERCEPTOR(int, getgroups, int size, u32 *lst) {\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, getgroups, size, lst);\n   int res = REAL(getgroups)(size, lst);\n-  if (res && lst)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lst, res * sizeof(*lst));\n+  if (res && lst) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lst, res * sizeof(*lst));\n   return res;\n }\n-#define INIT_GETGROUPS INTERCEPT_FUNCTION(getgroups);\n+#define INIT_GETGROUPS COMMON_INTERCEPT_FUNCTION(getgroups);\n #else\n #define INIT_GETGROUPS\n #endif\n@@ -1969,7 +2014,7 @@ INTERCEPTOR(int, poll, __sanitizer_pollfd *fds, __sanitizer_nfds_t nfds,\n   if (fds && nfds) write_pollfd(ctx, fds, nfds);\n   return res;\n }\n-#define INIT_POLL INTERCEPT_FUNCTION(poll);\n+#define INIT_POLL COMMON_INTERCEPT_FUNCTION(poll);\n #else\n #define INIT_POLL\n #endif\n@@ -1988,7 +2033,7 @@ INTERCEPTOR(int, ppoll, __sanitizer_pollfd *fds, __sanitizer_nfds_t nfds,\n   if (fds && nfds) write_pollfd(ctx, fds, nfds);\n   return res;\n }\n-#define INIT_PPOLL INTERCEPT_FUNCTION(ppoll);\n+#define INIT_PPOLL COMMON_INTERCEPT_FUNCTION(ppoll);\n #else\n #define INIT_PPOLL\n #endif\n@@ -2011,7 +2056,7 @@ INTERCEPTOR(int, wordexp, char *s, __sanitizer_wordexp_t *p, int flags) {\n   }\n   return res;\n }\n-#define INIT_WORDEXP INTERCEPT_FUNCTION(wordexp);\n+#define INIT_WORDEXP COMMON_INTERCEPT_FUNCTION(wordexp);\n #else\n #define INIT_WORDEXP\n #endif\n@@ -2025,7 +2070,7 @@ INTERCEPTOR(int, sigwait, __sanitizer_sigset_t *set, int *sig) {\n   if (!res && sig) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sig, sizeof(*sig));\n   return res;\n }\n-#define INIT_SIGWAIT INTERCEPT_FUNCTION(sigwait);\n+#define INIT_SIGWAIT COMMON_INTERCEPT_FUNCTION(sigwait);\n #else\n #define INIT_SIGWAIT\n #endif\n@@ -2039,7 +2084,7 @@ INTERCEPTOR(int, sigwaitinfo, __sanitizer_sigset_t *set, void *info) {\n   if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n   return res;\n }\n-#define INIT_SIGWAITINFO INTERCEPT_FUNCTION(sigwaitinfo);\n+#define INIT_SIGWAITINFO COMMON_INTERCEPT_FUNCTION(sigwaitinfo);\n #else\n #define INIT_SIGWAITINFO\n #endif\n@@ -2055,7 +2100,7 @@ INTERCEPTOR(int, sigtimedwait, __sanitizer_sigset_t *set, void *info,\n   if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n   return res;\n }\n-#define INIT_SIGTIMEDWAIT INTERCEPT_FUNCTION(sigtimedwait);\n+#define INIT_SIGTIMEDWAIT COMMON_INTERCEPT_FUNCTION(sigtimedwait);\n #else\n #define INIT_SIGTIMEDWAIT\n #endif\n@@ -2076,9 +2121,9 @@ INTERCEPTOR(int, sigfillset, __sanitizer_sigset_t *set) {\n   if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n   return res;\n }\n-#define INIT_SIGSETOPS             \\\n-  INTERCEPT_FUNCTION(sigemptyset); \\\n-  INTERCEPT_FUNCTION(sigfillset);\n+#define INIT_SIGSETOPS                    \\\n+  COMMON_INTERCEPT_FUNCTION(sigemptyset); \\\n+  COMMON_INTERCEPT_FUNCTION(sigfillset);\n #else\n #define INIT_SIGSETOPS\n #endif\n@@ -2091,7 +2136,7 @@ INTERCEPTOR(int, sigpending, __sanitizer_sigset_t *set) {\n   if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n   return res;\n }\n-#define INIT_SIGPENDING INTERCEPT_FUNCTION(sigpending);\n+#define INIT_SIGPENDING COMMON_INTERCEPT_FUNCTION(sigpending);\n #else\n #define INIT_SIGPENDING\n #endif\n@@ -2107,7 +2152,7 @@ INTERCEPTOR(int, sigprocmask, int how, __sanitizer_sigset_t *set,\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldset, sizeof(*oldset));\n   return res;\n }\n-#define INIT_SIGPROCMASK INTERCEPT_FUNCTION(sigprocmask);\n+#define INIT_SIGPROCMASK COMMON_INTERCEPT_FUNCTION(sigprocmask);\n #else\n #define INIT_SIGPROCMASK\n #endif\n@@ -2127,21 +2172,724 @@ INTERCEPTOR(char **, backtrace_symbols, void **buffer, int size) {\n   COMMON_INTERCEPTOR_ENTER(ctx, backtrace_symbols, buffer, size);\n   if (buffer && size)\n     COMMON_INTERCEPTOR_READ_RANGE(ctx, buffer, size * sizeof(*buffer));\n-  char ** res = REAL(backtrace_symbols)(buffer, size);\n+  char **res = REAL(backtrace_symbols)(buffer, size);\n   if (res && size) {\n     COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, size * sizeof(*res));\n     for (int i = 0; i < size; ++i)\n       COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res[i], REAL(strlen(res[i])) + 1);\n   }\n   return res;\n }\n-#define INIT_BACKTRACE           \\\n-  INTERCEPT_FUNCTION(backtrace); \\\n-  INTERCEPT_FUNCTION(backtrace_symbols);\n+#define INIT_BACKTRACE                  \\\n+  COMMON_INTERCEPT_FUNCTION(backtrace); \\\n+  COMMON_INTERCEPT_FUNCTION(backtrace_symbols);\n #else\n #define INIT_BACKTRACE\n #endif\n \n+#if SANITIZER_INTERCEPT__EXIT\n+INTERCEPTOR(void, _exit, int status) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, _exit, status);\n+  int status1 = COMMON_INTERCEPTOR_ON_EXIT(ctx);\n+  if (status == 0) status = status1;\n+  REAL(_exit)(status);\n+}\n+#define INIT__EXIT COMMON_INTERCEPT_FUNCTION(_exit);\n+#else\n+#define INIT__EXIT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PHTREAD_MUTEX\n+INTERCEPTOR(int, pthread_mutex_lock, void *m) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_mutex_lock, m);\n+  int res = REAL(pthread_mutex_lock)(m);\n+  if (res == errno_EOWNERDEAD)\n+    COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m);\n+  if (res == 0 || res == errno_EOWNERDEAD)\n+    COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, pthread_mutex_unlock, void *m) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_mutex_unlock, m);\n+  COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m);\n+  return REAL(pthread_mutex_unlock)(m);\n+}\n+\n+#define INIT_PTHREAD_MUTEX_LOCK COMMON_INTERCEPT_FUNCTION(pthread_mutex_lock)\n+#define INIT_PTHREAD_MUTEX_UNLOCK \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_mutex_unlock)\n+#else\n+#define INIT_PTHREAD_MUTEX_LOCK\n+#define INIT_PTHREAD_MUTEX_UNLOCK\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_COND\n+INTERCEPTOR(int, pthread_cond_wait, void *c, void *m) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_cond_wait, c, m);\n+  COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, c, pthread_cond_t_sz);\n+  int res = REAL(pthread_cond_wait)(c, m);\n+  COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, pthread_cond_init, void *c, void *a) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_cond_init, c, a);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, c, pthread_cond_t_sz);\n+  return REAL(pthread_cond_init)(c, a);\n+}\n+\n+INTERCEPTOR(int, pthread_cond_signal, void *c) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_cond_signal, c);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, c, pthread_cond_t_sz);\n+  return REAL(pthread_cond_signal)(c);\n+}\n+\n+INTERCEPTOR(int, pthread_cond_broadcast, void *c) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_cond_broadcast, c);\n+  COMMON_INTERCEPTOR_READ_RANGE(ctx, c, pthread_cond_t_sz);\n+  return REAL(pthread_cond_broadcast)(c);\n+}\n+\n+#define INIT_PTHREAD_COND_WAIT \\\n+  INTERCEPT_FUNCTION_VER(pthread_cond_wait, \"GLIBC_2.3.2\")\n+#define INIT_PTHREAD_COND_INIT \\\n+  INTERCEPT_FUNCTION_VER(pthread_cond_init, \"GLIBC_2.3.2\")\n+#define INIT_PTHREAD_COND_SIGNAL \\\n+  INTERCEPT_FUNCTION_VER(pthread_cond_signal, \"GLIBC_2.3.2\")\n+#define INIT_PTHREAD_COND_BROADCAST \\\n+  INTERCEPT_FUNCTION_VER(pthread_cond_broadcast, \"GLIBC_2.3.2\")\n+#else\n+#define INIT_PTHREAD_COND_WAIT\n+#define INIT_PTHREAD_COND_INIT\n+#define INIT_PTHREAD_COND_SIGNAL\n+#define INIT_PTHREAD_COND_BROADCAST\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETMNTENT || SANITIZER_INTERCEPT_GETMNTENT_R\n+static void write_mntent(void *ctx, __sanitizer_mntent *mnt) {\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt, sizeof(*mnt));\n+  if (mnt->mnt_fsname)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_fsname,\n+                                   REAL(strlen)(mnt->mnt_fsname) + 1);\n+  if (mnt->mnt_dir)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_dir,\n+                                   REAL(strlen)(mnt->mnt_dir) + 1);\n+  if (mnt->mnt_type)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_type,\n+                                   REAL(strlen)(mnt->mnt_type) + 1);\n+  if (mnt->mnt_opts)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_opts,\n+                                   REAL(strlen)(mnt->mnt_opts) + 1);\n+}\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETMNTENT\n+INTERCEPTOR(__sanitizer_mntent *, getmntent, void *fp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getmntent, fp);\n+  __sanitizer_mntent *res = REAL(getmntent)(fp);\n+  if (res) write_mntent(ctx, res);\n+  return res;\n+}\n+#define INIT_GETMNTENT COMMON_INTERCEPT_FUNCTION(getmntent);\n+#else\n+#define INIT_GETMNTENT\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETMNTENT_R\n+INTERCEPTOR(__sanitizer_mntent *, getmntent_r, void *fp,\n+            __sanitizer_mntent *mntbuf, char *buf, int buflen) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getmntent_r, fp, mntbuf, buf, buflen);\n+  __sanitizer_mntent *res = REAL(getmntent_r)(fp, mntbuf, buf, buflen);\n+  if (res) write_mntent(ctx, res);\n+  return res;\n+}\n+#define INIT_GETMNTENT_R COMMON_INTERCEPT_FUNCTION(getmntent_r);\n+#else\n+#define INIT_GETMNTENT_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STATFS\n+INTERCEPTOR(int, statfs, char *path, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, statfs, path, buf);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  int res = REAL(statfs)(path, buf);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs_sz);\n+  return res;\n+}\n+INTERCEPTOR(int, fstatfs, int fd, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fstatfs, fd, buf);\n+  int res = REAL(fstatfs)(fd, buf);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs_sz);\n+  return res;\n+}\n+#define INIT_STATFS                  \\\n+  COMMON_INTERCEPT_FUNCTION(statfs); \\\n+  COMMON_INTERCEPT_FUNCTION(fstatfs);\n+#else\n+#define INIT_STATFS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STATFS64\n+INTERCEPTOR(int, statfs64, char *path, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, statfs64, path, buf);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  int res = REAL(statfs64)(path, buf);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs64_sz);\n+  return res;\n+}\n+INTERCEPTOR(int, fstatfs64, int fd, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fstatfs64, fd, buf);\n+  int res = REAL(fstatfs64)(fd, buf);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs64_sz);\n+  return res;\n+}\n+#define INIT_STATFS64                  \\\n+  COMMON_INTERCEPT_FUNCTION(statfs64); \\\n+  COMMON_INTERCEPT_FUNCTION(fstatfs64);\n+#else\n+#define INIT_STATFS64\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STATVFS\n+INTERCEPTOR(int, statvfs, char *path, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, statvfs, path, buf);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  int res = REAL(statvfs)(path, buf);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n+  return res;\n+}\n+INTERCEPTOR(int, fstatvfs, int fd, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs, fd, buf);\n+  int res = REAL(fstatvfs)(fd, buf);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n+  return res;\n+}\n+#define INIT_STATVFS                  \\\n+  COMMON_INTERCEPT_FUNCTION(statvfs); \\\n+  COMMON_INTERCEPT_FUNCTION(fstatvfs);\n+#else\n+#define INIT_STATVFS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_STATVFS64\n+INTERCEPTOR(int, statvfs64, char *path, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, statvfs64, path, buf);\n+  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n+  int res = REAL(statvfs64)(path, buf);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs64_sz);\n+  return res;\n+}\n+INTERCEPTOR(int, fstatvfs64, int fd, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs64, fd, buf);\n+  int res = REAL(fstatvfs64)(fd, buf);\n+  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs64_sz);\n+  return res;\n+}\n+#define INIT_STATVFS64                  \\\n+  COMMON_INTERCEPT_FUNCTION(statvfs64); \\\n+  COMMON_INTERCEPT_FUNCTION(fstatvfs64);\n+#else\n+#define INIT_STATVFS64\n+#endif\n+\n+#if SANITIZER_INTERCEPT_INITGROUPS\n+INTERCEPTOR(int, initgroups, char *user, u32 group) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, initgroups, user, group);\n+  if (user) COMMON_INTERCEPTOR_READ_RANGE(ctx, user, REAL(strlen)(user) + 1);\n+  int res = REAL(initgroups)(user, group);\n+  return res;\n+}\n+#define INIT_INITGROUPS COMMON_INTERCEPT_FUNCTION(initgroups);\n+#else\n+#define INIT_INITGROUPS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ETHER\n+INTERCEPTOR(char *, ether_ntoa, __sanitizer_ether_addr *addr) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ether_ntoa, addr);\n+  if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n+  char *res = REAL(ether_ntoa)(addr);\n+  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+INTERCEPTOR(__sanitizer_ether_addr *, ether_aton, char *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ether_aton, buf);\n+  if (buf) COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n+  __sanitizer_ether_addr *res = REAL(ether_aton)(buf);\n+  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, sizeof(*res));\n+  return res;\n+}\n+INTERCEPTOR(int, ether_ntohost, char *hostname, __sanitizer_ether_addr *addr) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ether_ntohost, hostname, addr);\n+  if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n+  int res = REAL(ether_ntohost)(hostname, addr);\n+  if (!res && hostname)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n+  return res;\n+}\n+INTERCEPTOR(int, ether_hostton, char *hostname, __sanitizer_ether_addr *addr) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ether_hostton, hostname, addr);\n+  if (hostname)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n+  int res = REAL(ether_hostton)(hostname, addr);\n+  if (!res && addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n+  return res;\n+}\n+INTERCEPTOR(int, ether_line, char *line, __sanitizer_ether_addr *addr,\n+            char *hostname) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ether_line, line, addr, hostname);\n+  if (line) COMMON_INTERCEPTOR_READ_RANGE(ctx, line, REAL(strlen)(line) + 1);\n+  int res = REAL(ether_line)(line, addr, hostname);\n+  if (!res) {\n+    if (addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n+    if (hostname)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n+  }\n+  return res;\n+}\n+#define INIT_ETHER                          \\\n+  COMMON_INTERCEPT_FUNCTION(ether_ntoa);    \\\n+  COMMON_INTERCEPT_FUNCTION(ether_aton);    \\\n+  COMMON_INTERCEPT_FUNCTION(ether_ntohost); \\\n+  COMMON_INTERCEPT_FUNCTION(ether_hostton); \\\n+  COMMON_INTERCEPT_FUNCTION(ether_line);\n+#else\n+#define INIT_ETHER\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ETHER_R\n+INTERCEPTOR(char *, ether_ntoa_r, __sanitizer_ether_addr *addr, char *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ether_ntoa_r, addr, buf);\n+  if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n+  char *res = REAL(ether_ntoa_r)(addr, buf);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+INTERCEPTOR(__sanitizer_ether_addr *, ether_aton_r, char *buf,\n+            __sanitizer_ether_addr *addr) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ether_aton_r, buf, addr);\n+  if (buf) COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n+  __sanitizer_ether_addr *res = REAL(ether_aton_r)(buf, addr);\n+  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, sizeof(*res));\n+  return res;\n+}\n+#define INIT_ETHER_R                       \\\n+  COMMON_INTERCEPT_FUNCTION(ether_ntoa_r); \\\n+  COMMON_INTERCEPT_FUNCTION(ether_aton_r);\n+#else\n+#define INIT_ETHER_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SHMCTL\n+INTERCEPTOR(int, shmctl, int shmid, int cmd, void *buf) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, shmctl, shmid, cmd, buf);\n+  int res = REAL(shmctl)(shmid, cmd, buf);\n+  if (res >= 0) {\n+    unsigned sz = 0;\n+    if (cmd == shmctl_ipc_stat || cmd == shmctl_shm_stat)\n+      sz = sizeof(__sanitizer_shmid_ds);\n+    else if (cmd == shmctl_ipc_info)\n+      sz = struct_shminfo_sz;\n+    else if (cmd == shmctl_shm_info)\n+      sz = struct_shm_info_sz;\n+    if (sz) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, sz);\n+  }\n+  return res;\n+}\n+#define INIT_SHMCTL COMMON_INTERCEPT_FUNCTION(shmctl);\n+#else\n+#define INIT_SHMCTL\n+#endif\n+\n+#if SANITIZER_INTERCEPT_RANDOM_R\n+INTERCEPTOR(int, random_r, void *buf, u32 *result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, random_r, buf, result);\n+  int res = REAL(random_r)(buf, result);\n+  if (!res && result)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+  return res;\n+}\n+#define INIT_RANDOM_R COMMON_INTERCEPT_FUNCTION(random_r);\n+#else\n+#define INIT_RANDOM_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET || \\\n+    SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSSCHED\n+#define INTERCEPTOR_PTHREAD_ATTR_GET(what, sz)                      \\\n+  INTERCEPTOR(int, pthread_attr_get##what, void *attr, void *r) {   \\\n+    void *ctx;                                                      \\\n+    COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_get##what, attr, r); \\\n+    int res = REAL(pthread_attr_get##what)(attr, r);                \\\n+    if (!res && r) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, r, sz);      \\\n+    return res;                                                     \\\n+  }\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET\n+INTERCEPTOR_PTHREAD_ATTR_GET(detachstate, sizeof(int))\n+INTERCEPTOR_PTHREAD_ATTR_GET(guardsize, sizeof(SIZE_T))\n+INTERCEPTOR_PTHREAD_ATTR_GET(schedparam, struct_sched_param_sz)\n+INTERCEPTOR_PTHREAD_ATTR_GET(schedpolicy, sizeof(int))\n+INTERCEPTOR_PTHREAD_ATTR_GET(scope, sizeof(int))\n+INTERCEPTOR_PTHREAD_ATTR_GET(stacksize, sizeof(SIZE_T))\n+INTERCEPTOR(int, pthread_attr_getstack, void *attr, void **addr, SIZE_T *size) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_getstack, attr, addr, size);\n+  int res = REAL(pthread_attr_getstack)(attr, addr, size);\n+  if (!res) {\n+    if (addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n+    if (size) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, size, sizeof(*size));\n+  }\n+  return res;\n+}\n+\n+// We may need to call the real pthread_attr_getstack from the run-time\n+// in sanitizer_common, but we don't want to include the interception headers\n+// there. So, just define this function here.\n+int __sanitizer_pthread_attr_getstack(void *attr, void **addr, SIZE_T *size) {\n+  return REAL(pthread_attr_getstack)(attr, addr, size);\n+}\n+\n+#define INIT_PTHREAD_ATTR_GET                             \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getdetachstate); \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getguardsize);   \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedparam);  \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedpolicy); \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getscope);       \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getstacksize);   \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getstack);\n+#else\n+#define INIT_PTHREAD_ATTR_GET\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED\n+INTERCEPTOR_PTHREAD_ATTR_GET(inheritsched, sizeof(int))\n+\n+#define INIT_PTHREAD_ATTR_GETINHERITSCHED \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getinheritsched);\n+#else\n+#define INIT_PTHREAD_ATTR_GETINHERITSCHED\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP\n+INTERCEPTOR(int, pthread_attr_getaffinity_np, void *attr, SIZE_T cpusetsize,\n+            void *cpuset) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_getaffinity_np, attr, cpusetsize,\n+                           cpuset);\n+  int res = REAL(pthread_attr_getaffinity_np)(attr, cpusetsize, cpuset);\n+  if (!res && cpusetsize && cpuset)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cpuset, cpusetsize);\n+  return res;\n+}\n+\n+#define INIT_PTHREAD_ATTR_GETAFFINITY_NP \\\n+  COMMON_INTERCEPT_FUNCTION(pthread_attr_getaffinity_np);\n+#else\n+#define INIT_PTHREAD_ATTR_GETAFFINITY_NP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_TMPNAM\n+INTERCEPTOR(char *, tmpnam, char *s) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, tmpnam, s);\n+  char *res = REAL(tmpnam)(s);\n+  if (res) {\n+    if (s)\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n+    else\n+      COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  }\n+  return res;\n+}\n+#define INIT_TMPNAM COMMON_INTERCEPT_FUNCTION(tmpnam);\n+#else\n+#define INIT_TMPNAM\n+#endif\n+\n+#if SANITIZER_INTERCEPT_TMPNAM_R\n+INTERCEPTOR(char *, tmpnam_r, char *s) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, tmpnam_r, s);\n+  char *res = REAL(tmpnam_r)(s);\n+  if (res && s) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n+  return res;\n+}\n+#define INIT_TMPNAM_R COMMON_INTERCEPT_FUNCTION(tmpnam_r);\n+#else\n+#define INIT_TMPNAM_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_TEMPNAM\n+INTERCEPTOR(char *, tempnam, char *dir, char *pfx) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, tempnam, dir, pfx);\n+  if (dir) COMMON_INTERCEPTOR_READ_RANGE(ctx, dir, REAL(strlen)(dir) + 1);\n+  if (pfx) COMMON_INTERCEPTOR_READ_RANGE(ctx, pfx, REAL(strlen)(pfx) + 1);\n+  char *res = REAL(tempnam)(dir, pfx);\n+  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  return res;\n+}\n+#define INIT_TEMPNAM COMMON_INTERCEPT_FUNCTION(tempnam);\n+#else\n+#define INIT_TEMPNAM\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP\n+INTERCEPTOR(int, pthread_setname_np, uptr thread, const char *name) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setname_np, thread, name);\n+  COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, name);\n+  return REAL(pthread_setname_np)(thread, name);\n+}\n+#define INIT_PTHREAD_SETNAME_NP COMMON_INTERCEPT_FUNCTION(pthread_setname_np);\n+#else\n+#define INIT_PTHREAD_SETNAME_NP\n+#endif\n+\n+#if SANITIZER_INTERCEPT_SINCOS\n+INTERCEPTOR(void, sincos, double x, double *sin, double *cos) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sincos, x, sin, cos);\n+  REAL(sincos)(x, sin, cos);\n+  if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n+  if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n+}\n+INTERCEPTOR(void, sincosf, float x, float *sin, float *cos) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sincosf, x, sin, cos);\n+  REAL(sincosf)(x, sin, cos);\n+  if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n+  if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n+}\n+INTERCEPTOR(void, sincosl, long double x, long double *sin, long double *cos) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sincosl, x, sin, cos);\n+  REAL(sincosl)(x, sin, cos);\n+  if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n+  if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n+}\n+#define INIT_SINCOS                   \\\n+  COMMON_INTERCEPT_FUNCTION(sincos);  \\\n+  COMMON_INTERCEPT_FUNCTION(sincosf); \\\n+  COMMON_INTERCEPT_FUNCTION(sincosl);\n+#else\n+#define INIT_SINCOS\n+#endif\n+\n+#if SANITIZER_INTERCEPT_REMQUO\n+INTERCEPTOR(double, remquo, double x, double y, int *quo) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, remquo, x, y, quo);\n+  double res = REAL(remquo)(x, y, quo);\n+  if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n+  return res;\n+}\n+INTERCEPTOR(float, remquof, float x, float y, int *quo) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, remquof, x, y, quo);\n+  float res = REAL(remquof)(x, y, quo);\n+  if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n+  return res;\n+}\n+INTERCEPTOR(long double, remquol, long double x, long double y, int *quo) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, remquol, x, y, quo);\n+  long double res = REAL(remquol)(x, y, quo);\n+  if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n+  return res;\n+}\n+#define INIT_REMQUO                   \\\n+  COMMON_INTERCEPT_FUNCTION(remquo);  \\\n+  COMMON_INTERCEPT_FUNCTION(remquof); \\\n+  COMMON_INTERCEPT_FUNCTION(remquol);\n+#else\n+#define INIT_REMQUO\n+#endif\n+\n+#if SANITIZER_INTERCEPT_LGAMMA\n+extern int signgam;\n+INTERCEPTOR(double, lgamma, double x) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, lgamma, x);\n+  double res = REAL(lgamma)(x);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &signgam, sizeof(signgam));\n+  return res;\n+}\n+INTERCEPTOR(float, lgammaf, float x) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, lgammaf, x);\n+  float res = REAL(lgammaf)(x);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &signgam, sizeof(signgam));\n+  return res;\n+}\n+INTERCEPTOR(long double, lgammal, long double x) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, lgammal, x);\n+  long double res = REAL(lgammal)(x);\n+  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &signgam, sizeof(signgam));\n+  return res;\n+}\n+#define INIT_LGAMMA                   \\\n+  COMMON_INTERCEPT_FUNCTION(lgamma);  \\\n+  COMMON_INTERCEPT_FUNCTION(lgammaf); \\\n+  COMMON_INTERCEPT_FUNCTION(lgammal);\n+#else\n+#define INIT_LGAMMA\n+#endif\n+\n+#if SANITIZER_INTERCEPT_LGAMMA_R\n+INTERCEPTOR(double, lgamma_r, double x, int *signp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, lgamma_r, x, signp);\n+  double res = REAL(lgamma_r)(x, signp);\n+  if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n+  return res;\n+}\n+INTERCEPTOR(float, lgammaf_r, float x, int *signp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, lgammaf_r, x, signp);\n+  float res = REAL(lgammaf_r)(x, signp);\n+  if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n+  return res;\n+}\n+INTERCEPTOR(long double, lgammal_r, long double x, int *signp) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, lgammal_r, x, signp);\n+  long double res = REAL(lgammal_r)(x, signp);\n+  if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n+  return res;\n+}\n+#define INIT_LGAMMA_R                   \\\n+  COMMON_INTERCEPT_FUNCTION(lgamma_r);  \\\n+  COMMON_INTERCEPT_FUNCTION(lgammaf_r); \\\n+  COMMON_INTERCEPT_FUNCTION(lgammal_r);\n+#else\n+#define INIT_LGAMMA_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_DRAND48_R\n+INTERCEPTOR(int, drand48_r, void *buffer, double *result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, drand48_r, buffer, result);\n+  int res = REAL(drand48_r)(buffer, result);\n+  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+  return res;\n+}\n+INTERCEPTOR(int, lrand48_r, void *buffer, long *result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, lrand48_r, buffer, result);\n+  int res = REAL(lrand48_r)(buffer, result);\n+  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n+  return res;\n+}\n+#define INIT_DRAND48_R                  \\\n+  COMMON_INTERCEPT_FUNCTION(drand48_r); \\\n+  COMMON_INTERCEPT_FUNCTION(lrand48_r);\n+#else\n+#define INIT_DRAND48_R\n+#endif\n+\n+#if SANITIZER_INTERCEPT_GETLINE\n+INTERCEPTOR(SSIZE_T, getline, char **lineptr, SIZE_T *n, void *stream) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getline, lineptr, n, stream);\n+  SSIZE_T res = REAL(getline)(lineptr, n, stream);\n+  if (res > 0) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *lineptr, res + 1);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(SSIZE_T, getdelim, char **lineptr, SIZE_T *n, int delim,\n+            void *stream) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, getdelim, lineptr, n, delim, stream);\n+  SSIZE_T res = REAL(getdelim)(lineptr, n, delim, stream);\n+  if (res > 0) {\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *lineptr, res + 1);\n+  }\n+  return res;\n+}\n+#define INIT_GETLINE                  \\\n+  COMMON_INTERCEPT_FUNCTION(getline); \\\n+  COMMON_INTERCEPT_FUNCTION(getdelim);\n+#else\n+#define INIT_GETLINE\n+#endif\n+\n+#if SANITIZER_INTERCEPT_ICONV\n+INTERCEPTOR(SIZE_T, iconv, void *cd, char **inbuf, SIZE_T *inbytesleft,\n+            char **outbuf, SIZE_T *outbytesleft) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, iconv, cd, inbuf, inbytesleft, outbuf,\n+                           outbytesleft);\n+  if (inbytesleft)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, inbytesleft, sizeof(*inbytesleft));\n+  if (inbuf && inbytesleft)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, *inbuf, *inbytesleft);\n+  if (outbytesleft)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, outbytesleft, sizeof(*outbytesleft));\n+  void *outbuf_orig = outbuf ? *outbuf : 0;\n+  SIZE_T res = REAL(iconv)(cd, inbuf, inbytesleft, outbuf, outbytesleft);\n+  if (res != (SIZE_T) - 1 && outbuf && *outbuf > outbuf_orig) {\n+    SIZE_T sz = (char *)*outbuf - (char *)outbuf_orig;\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, outbuf_orig, sz);\n+  }\n+  return res;\n+}\n+#define INIT_ICONV COMMON_INTERCEPT_FUNCTION(iconv);\n+#else\n+#define INIT_ICONV\n+#endif\n+\n+#if SANITIZER_INTERCEPT_TIMES\n+INTERCEPTOR(__sanitizer_clock_t, times, void *tms) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, times, tms);\n+  __sanitizer_clock_t res = REAL(times)(tms);\n+  if (res != (__sanitizer_clock_t)-1 && tms)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tms, struct_tms_sz);\n+  return res;\n+}\n+#define INIT_TIMES COMMON_INTERCEPT_FUNCTION(times);\n+#else\n+#define INIT_TIMES\n+#endif\n+\n #define SANITIZER_COMMON_INTERCEPTORS_INIT \\\n   INIT_STRCMP;                             \\\n   INIT_STRNCMP;                            \\\n@@ -2161,6 +2909,7 @@ INTERCEPTOR(char **, backtrace_symbols, void **buffer, int size) {\n   INIT_PWRITEV64;                          \\\n   INIT_PRCTL;                              \\\n   INIT_LOCALTIME_AND_FRIENDS;              \\\n+  INIT_STRPTIME;                           \\\n   INIT_SCANF;                              \\\n   INIT_ISOC99_SCANF;                       \\\n   INIT_FREXP;                              \\\n@@ -2206,6 +2955,7 @@ INTERCEPTOR(char **, backtrace_symbols, void **buffer, int size) {\n   INIT_SCHED_GETAFFINITY;                  \\\n   INIT_STRERROR;                           \\\n   INIT_STRERROR_R;                         \\\n+  INIT_XPG_STRERROR_R;                     \\\n   INIT_SCANDIR;                            \\\n   INIT_SCANDIR64;                          \\\n   INIT_GETGROUPS;                          \\\n@@ -2218,4 +2968,38 @@ INTERCEPTOR(char **, backtrace_symbols, void **buffer, int size) {\n   INIT_SIGSETOPS;                          \\\n   INIT_SIGPENDING;                         \\\n   INIT_SIGPROCMASK;                        \\\n-  INIT_BACKTRACE;\n+  INIT_BACKTRACE;                          \\\n+  INIT__EXIT;                              \\\n+  INIT_PTHREAD_MUTEX_LOCK;                 \\\n+  INIT_PTHREAD_MUTEX_UNLOCK;               \\\n+  INIT_PTHREAD_COND_WAIT;                  \\\n+  INIT_PTHREAD_COND_INIT;                  \\\n+  INIT_PTHREAD_COND_SIGNAL;                \\\n+  INIT_PTHREAD_COND_BROADCAST;             \\\n+  INIT_GETMNTENT;                          \\\n+  INIT_GETMNTENT_R;                        \\\n+  INIT_STATFS;                             \\\n+  INIT_STATFS64;                           \\\n+  INIT_STATVFS;                            \\\n+  INIT_STATVFS64;                          \\\n+  INIT_INITGROUPS;                         \\\n+  INIT_ETHER;                              \\\n+  INIT_ETHER_R;                            \\\n+  INIT_SHMCTL;                             \\\n+  INIT_RANDOM_R;                           \\\n+  INIT_PTHREAD_ATTR_GET;                   \\\n+  INIT_PTHREAD_ATTR_GETINHERITSCHED;       \\\n+  INIT_PTHREAD_ATTR_GETAFFINITY_NP;        \\\n+  INIT_TMPNAM;                             \\\n+  INIT_TMPNAM_R;                           \\\n+  INIT_TEMPNAM;                            \\\n+  INIT_PTHREAD_SETNAME_NP;                 \\\n+  INIT_SINCOS;                             \\\n+  INIT_REMQUO;                             \\\n+  INIT_LGAMMA;                             \\\n+  INIT_LGAMMA_R;                           \\\n+  INIT_DRAND48_R;                          \\\n+  INIT_GETLINE;                            \\\n+  INIT_ICONV;                              \\\n+  INIT_TIMES;                              \\\n+/**/"}, {"sha": "ac8cdae5b8161131221991ab869ff6cc951056cc", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -86,7 +86,7 @@ static void ioctl_table_fill() {\n   _(TIOCSTI, READ, sizeof(char));\n   _(TIOCSWINSZ, READ, struct_winsize_sz);\n \n-#if (SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_MAC\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID)\n   _(SIOCGETSGCNT, WRITE, struct_sioc_sg_req_sz);\n   _(SIOCGETVIFCNT, WRITE, struct_sioc_vif_req_sz);\n #endif"}, {"sha": "75f7d1d1e89da65dbe5331ef07b58397242901ae", "filename": "libsanitizer/sanitizer_common/sanitizer_common_syscalls.inc", "status": "modified", "additions": 145, "deletions": 40, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -23,8 +23,16 @@\n //   COMMON_SYSCALL_POST_WRITE_RANGE\n //          Called in posthook for regions that were written to by the kernel\n //          and are now initialized.\n+//   COMMON_SYSCALL_ACQUIRE(addr)\n+//          Acquire memory visibility from addr.\n+//   COMMON_SYSCALL_RELEASE(addr)\n+//          Release memory visibility to addr.\n //   COMMON_SYSCALL_FD_CLOSE(fd)\n //          Called before closing file descriptor fd.\n+//   COMMON_SYSCALL_FD_ACQUIRE(fd)\n+//          Acquire memory visibility from fd.\n+//   COMMON_SYSCALL_FD_RELEASE(fd)\n+//          Release memory visibility to fd.\n //   COMMON_SYSCALL_PRE_FORK()\n //          Called before fork syscall.\n //   COMMON_SYSCALL_POST_FORK(long res)\n@@ -46,20 +54,34 @@\n #define POST_READ(p, s) COMMON_SYSCALL_POST_READ_RANGE(p, s)\n #define POST_WRITE(p, s) COMMON_SYSCALL_POST_WRITE_RANGE(p, s)\n \n+#ifndef COMMON_SYSCALL_ACQUIRE\n+# define COMMON_SYSCALL_ACQUIRE(addr) ((void)(addr))\n+#endif\n+\n+#ifndef COMMON_SYSCALL_RELEASE\n+# define COMMON_SYSCALL_RELEASE(addr) ((void)(addr))\n+#endif\n+\n #ifndef COMMON_SYSCALL_FD_CLOSE\n-# define COMMON_SYSCALL_FD_CLOSE(fd)\n+# define COMMON_SYSCALL_FD_CLOSE(fd) ((void)(fd))\n+#endif\n+\n+#ifndef COMMON_SYSCALL_FD_ACQUIRE\n+# define COMMON_SYSCALL_FD_ACQUIRE(fd) ((void)(fd))\n+#endif\n+\n+#ifndef COMMON_SYSCALL_FD_RELEASE\n+# define COMMON_SYSCALL_FD_RELEASE(fd) ((void)(fd))\n #endif\n \n #ifndef COMMON_SYSCALL_PRE_FORK\n-# define COMMON_SYSCALL_PRE_FORK()\n+# define COMMON_SYSCALL_PRE_FORK() {}\n #endif\n \n #ifndef COMMON_SYSCALL_POST_FORK\n-# define COMMON_SYSCALL_POST_FORK(res)\n+# define COMMON_SYSCALL_POST_FORK(res) {}\n #endif\n \n-#ifdef SYSCALL_INTERCEPTION\n-\n // FIXME: do some kind of PRE_READ for all syscall arguments (int(s) and such).\n \n extern \"C\" {\n@@ -1245,41 +1267,88 @@ PRE_SYSCALL(flock)(long fd, long cmd) {}\n \n POST_SYSCALL(flock)(long res, long fd, long cmd) {}\n \n-PRE_SYSCALL(io_setup)(long nr_reqs, void *ctx) {}\n+PRE_SYSCALL(io_setup)(long nr_reqs, void **ctx) {\n+  if (ctx) PRE_WRITE(ctx, sizeof(*ctx));\n+}\n \n-POST_SYSCALL(io_setup)(long res, long nr_reqs, void *ctx) {\n+POST_SYSCALL(io_setup)(long res, long nr_reqs, void **ctx) {\n   if (res >= 0) {\n-    if (ctx) POST_WRITE(ctx, sizeof(long));\n+    if (ctx) POST_WRITE(ctx, sizeof(*ctx));\n+    // (*ctx) is actually a pointer to a kernel mapped page, and there are\n+    // people out there who are crazy enough to peek into that page's 32-byte\n+    // header.\n+    if (*ctx) POST_WRITE(*ctx, 32);\n   }\n }\n \n PRE_SYSCALL(io_destroy)(long ctx) {}\n \n POST_SYSCALL(io_destroy)(long res, long ctx) {}\n \n-PRE_SYSCALL(io_getevents)(long ctx_id, long min_nr, long nr, void *events,\n-                          void *timeout) {\n+PRE_SYSCALL(io_getevents)(long ctx_id, long min_nr, long nr,\n+                          __sanitizer_io_event *ioevpp, void *timeout) {\n   if (timeout) PRE_READ(timeout, struct_timespec_sz);\n }\n \n POST_SYSCALL(io_getevents)(long res, long ctx_id, long min_nr, long nr,\n-                           void *events, void *timeout) {\n+                           __sanitizer_io_event *ioevpp, void *timeout) {\n   if (res >= 0) {\n-    if (events) POST_WRITE(events, res * struct_io_event_sz);\n+    if (ioevpp) POST_WRITE(ioevpp, res * sizeof(*ioevpp));\n     if (timeout) POST_WRITE(timeout, struct_timespec_sz);\n   }\n+  for (long i = 0; i < res; i++) {\n+    // We synchronize io_submit -> io_getevents/io_cancel using the\n+    // user-provided data context. Data is not necessary a pointer, it can be\n+    // an int, 0 or whatever; acquire/release will correctly handle this.\n+    // This scheme can lead to false negatives, e.g. when all operations\n+    // synchronize on 0. But there does not seem to be a better solution\n+    // (except wrapping all operations in own context, which is unreliable).\n+    // We can not reliably extract fildes in io_getevents.\n+    COMMON_SYSCALL_ACQUIRE((void*)ioevpp[i].data);\n+  }\n+}\n+\n+PRE_SYSCALL(io_submit)(long ctx_id, long nr, __sanitizer_iocb **iocbpp) {\n+  for (long i = 0; i < nr; ++i) {\n+    uptr op = iocbpp[i]->aio_lio_opcode;\n+    void *data = (void*)iocbpp[i]->aio_data;\n+    void *buf = (void*)iocbpp[i]->aio_buf;\n+    uptr len = (uptr)iocbpp[i]->aio_nbytes;\n+    if (op == iocb_cmd_pwrite && buf && len) {\n+      PRE_READ(buf, len);\n+    } else if (op == iocb_cmd_pread && buf && len) {\n+      POST_WRITE(buf, len);\n+    } else if (op == iocb_cmd_pwritev) {\n+      __sanitizer_iovec *iovec = (__sanitizer_iovec*)iocbpp[i]->aio_buf;\n+      for (uptr v = 0; v < len; v++)\n+        PRE_READ(iovec[i].iov_base, iovec[i].iov_len);\n+    } else if (op == iocb_cmd_preadv) {\n+      __sanitizer_iovec *iovec = (__sanitizer_iovec*)iocbpp[i]->aio_buf;\n+      for (uptr v = 0; v < len; v++)\n+        POST_WRITE(iovec[i].iov_base, iovec[i].iov_len);\n+    }\n+    // See comment in io_getevents.\n+    COMMON_SYSCALL_RELEASE(data);\n+  }\n }\n \n-PRE_SYSCALL(io_submit)(long, long arg1, void *arg2) {}\n-\n-POST_SYSCALL(io_submit)(long res, long, long arg1, void *arg2) {}\n+POST_SYSCALL(io_submit)(long res, long ctx_id, long nr,\n+    __sanitizer_iocb **iocbpp) {}\n \n-PRE_SYSCALL(io_cancel)(long ctx_id, void *iocb, void *result) {}\n+PRE_SYSCALL(io_cancel)(long ctx_id, __sanitizer_iocb *iocb,\n+    __sanitizer_io_event *result) {\n+}\n \n-POST_SYSCALL(io_cancel)(long res, long ctx_id, void *iocb, void *result) {\n-  if (res >= 0) {\n-    if (iocb) POST_WRITE(iocb, struct_iocb_sz);\n-    if (result) POST_WRITE(result, struct_io_event_sz);\n+POST_SYSCALL(io_cancel)(long res, long ctx_id, __sanitizer_iocb *iocb,\n+    __sanitizer_io_event *result) {\n+  if (res == 0) {\n+    if (result) {\n+      // See comment in io_getevents.\n+      COMMON_SYSCALL_ACQUIRE((void*)result->data);\n+      POST_WRITE(result, sizeof(*result));\n+    }\n+    if (iocb)\n+      POST_WRITE(iocb, sizeof(*iocb));\n   }\n }\n \n@@ -2063,21 +2132,21 @@ POST_SYSCALL(shmdt)(long res, void *shmaddr) {\n   }\n }\n \n-PRE_SYSCALL(shmctl)(long shmid, long cmd, void *buf) {}\n-\n-POST_SYSCALL(shmctl)(long res, long shmid, long cmd, void *buf) {\n-  if (res >= 0) {\n-    if (buf) POST_WRITE(buf, struct_shmid_ds_sz);\n-  }\n-}\n-\n PRE_SYSCALL(ipc)(long call, long first, long second, long third, void *ptr,\n                  long fifth) {}\n \n POST_SYSCALL(ipc)(long res, long call, long first, long second, long third,\n                   void *ptr, long fifth) {}\n \n #if !SANITIZER_ANDROID\n+PRE_SYSCALL(shmctl)(long shmid, long cmd, void *buf) {}\n+\n+POST_SYSCALL(shmctl)(long res, long shmid, long cmd, void *buf) {\n+  if (res >= 0) {\n+    if (buf) POST_WRITE(buf, sizeof(__sanitizer_shmid_ds));\n+  }\n+}\n+\n PRE_SYSCALL(mq_open)(const void *name, long oflag, long mode, void *attr) {\n   if (name)\n     PRE_READ(name, __sanitizer::internal_strlen((const char *)name) + 1);\n@@ -2218,9 +2287,49 @@ PRE_SYSCALL(ni_syscall)() {}\n \n POST_SYSCALL(ni_syscall)(long res) {}\n \n-PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {}\n+PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {\n+#if defined(__i386) || defined (__x86_64)\n+  if (data) {\n+    if (request == ptrace_setregs) {\n+      PRE_READ((void *)data, struct_user_regs_struct_sz);\n+    } else if (request == ptrace_setfpregs) {\n+      PRE_READ((void *)data, struct_user_fpregs_struct_sz);\n+    } else if (request == ptrace_setfpxregs) {\n+      PRE_READ((void *)data, struct_user_fpxregs_struct_sz);\n+    } else if (request == ptrace_setsiginfo) {\n+      PRE_READ((void *)data, siginfo_t_sz);\n+    } else if (request == ptrace_setregset) {\n+      __sanitizer_iovec *iov = (__sanitizer_iovec *)data;\n+      PRE_READ(iov->iov_base, iov->iov_len);\n+    }\n+  }\n+#endif\n+}\n \n-POST_SYSCALL(ptrace)(long res, long request, long pid, long addr, long data) {}\n+POST_SYSCALL(ptrace)(long res, long request, long pid, long addr, long data) {\n+#if defined(__i386) || defined (__x86_64)\n+  if (res >= 0 && data) {\n+    // Note that this is different from the interceptor in\n+    // sanitizer_common_interceptors.inc.\n+    // PEEK* requests return resulting values through data pointer.\n+    if (request == ptrace_getregs) {\n+      POST_WRITE((void *)data, struct_user_regs_struct_sz);\n+    } else if (request == ptrace_getfpregs) {\n+      POST_WRITE((void *)data, struct_user_fpregs_struct_sz);\n+    } else if (request == ptrace_getfpxregs) {\n+      POST_WRITE((void *)data, struct_user_fpxregs_struct_sz);\n+    } else if (request == ptrace_getsiginfo) {\n+      POST_WRITE((void *)data, siginfo_t_sz);\n+    } else if (request == ptrace_getregset) {\n+      __sanitizer_iovec *iov = (__sanitizer_iovec *)data;\n+      POST_WRITE(iov->iov_base, iov->iov_len);\n+    } else if (request == ptrace_peekdata || request == ptrace_peektext ||\n+               request == ptrace_peekuser) {\n+      POST_WRITE((void *)data, sizeof(void *));\n+    }\n+  }\n+#endif\n+}\n \n PRE_SYSCALL(add_key)(const void *_type, const void *_description,\n                      const void *_payload, long plen, long destringid) {\n@@ -2648,16 +2757,14 @@ PRE_SYSCALL(syncfs)(long fd) {}\n \n POST_SYSCALL(syncfs)(long res, long fd) {}\n \n-PRE_SYSCALL(perf_event_open)(void *attr_uptr, long pid, long cpu, long group_fd,\n-                             long flags) {}\n-\n-POST_SYSCALL(perf_event_open)(long res, void *attr_uptr, long pid, long cpu,\n-                              long group_fd, long flags) {\n-  if (res >= 0) {\n-    if (attr_uptr) POST_WRITE(attr_uptr, struct_perf_event_attr_sz);\n-  }\n+PRE_SYSCALL(perf_event_open)(__sanitizer_perf_event_attr *attr_uptr, long pid,\n+                             long cpu, long group_fd, long flags) {\n+  if (attr_uptr) PRE_READ(attr_uptr, attr_uptr->size);\n }\n \n+POST_SYSCALL(perf_event_open)(long res, __sanitizer_perf_event_attr *attr_uptr,\n+                              long pid, long cpu, long group_fd, long flags) {}\n+\n PRE_SYSCALL(mmap_pgoff)(long addr, long len, long prot, long flags, long fd,\n                         long pgoff) {}\n \n@@ -2724,8 +2831,6 @@ POST_SYSCALL(vfork)(long res) {\n }\n }  // extern \"C\"\n \n-#endif\n-\n #undef PRE_SYSCALL\n #undef PRE_READ\n #undef PRE_WRITE"}, {"sha": "e87b76c00819a0e9fc9aed62f93b5ced561e0263", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,111 @@\n+//===-- sanitizer_coverage.cc ---------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Sanitizer Coverage.\n+// This file implements run-time support for a poor man's coverage tool.\n+//\n+// Compiler instrumentation:\n+// For every function F the compiler injects the following code:\n+// if (*Guard) {\n+//    __sanitizer_cov(&F);\n+//    *Guard = 1;\n+// }\n+// It's fine to call __sanitizer_cov more than once for a given function.\n+//\n+// Run-time:\n+//  - __sanitizer_cov(pc): record that we've executed a given PC.\n+//  - __sanitizer_cov_dump: dump the coverage data to disk.\n+//  For every module of the current process that has coverage data\n+//  this will create a file module_name.PID.sancov. The file format is simple:\n+//  it's just a sorted sequence of 4-byte offsets in the module.\n+//\n+// Eventually, this coverage implementation should be obsoleted by a more\n+// powerful general purpose Clang/LLVM coverage instrumentation.\n+// Consider this implementation as prototype.\n+//\n+// FIXME: support (or at least test with) dlclose.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_procmaps.h\"\n+#include \"sanitizer_flags.h\"\n+\n+struct CovData {\n+  BlockingMutex mu;\n+  InternalMmapVector<uptr> v;\n+};\n+\n+static uptr cov_data_placeholder[sizeof(CovData) / sizeof(uptr)];\n+COMPILER_CHECK(sizeof(cov_data_placeholder) >= sizeof(CovData));\n+static CovData *cov_data = reinterpret_cast<CovData*>(cov_data_placeholder);\n+\n+namespace __sanitizer {\n+\n+// Simply add the pc into the vector under lock. If the function is called more\n+// than once for a given PC it will be inserted multiple times, which is fine.\n+static void CovAdd(uptr pc) {\n+  BlockingMutexLock lock(&cov_data->mu);\n+  cov_data->v.push_back(pc);\n+}\n+\n+static inline bool CompareLess(const uptr &a, const uptr &b) {\n+  return a < b;\n+}\n+\n+// Dump the coverage on disk.\n+void CovDump() {\n+#if !SANITIZER_WINDOWS\n+  BlockingMutexLock lock(&cov_data->mu);\n+  InternalMmapVector<uptr> &v = cov_data->v;\n+  InternalSort(&v, v.size(), CompareLess);\n+  InternalMmapVector<u32> offsets(v.size());\n+  const uptr *vb = v.data();\n+  const uptr *ve = vb + v.size();\n+  MemoryMappingLayout proc_maps(/*cache_enabled*/false);\n+  uptr mb, me, off, prot;\n+  InternalScopedBuffer<char> module(4096);\n+  InternalScopedBuffer<char> path(4096 * 2);\n+  for (int i = 0;\n+       proc_maps.Next(&mb, &me, &off, module.data(), module.size(), &prot);\n+       i++) {\n+    if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)\n+      continue;\n+    if (vb >= ve) break;\n+    if (mb <= *vb && *vb < me) {\n+      offsets.clear();\n+      const uptr *old_vb = vb;\n+      CHECK_LE(off, *vb);\n+      for (; vb < ve && *vb < me; vb++) {\n+        uptr diff = *vb - (i ? mb : 0) + off;\n+        CHECK_LE(diff, 0xffffffffU);\n+        offsets.push_back(static_cast<u32>(diff));\n+      }\n+      char *module_name = StripModuleName(module.data());\n+      internal_snprintf((char *)path.data(), path.size(), \"%s.%zd.sancov\",\n+                        module_name, internal_getpid());\n+      InternalFree(module_name);\n+      uptr fd = OpenFile(path.data(), true);\n+      internal_write(fd, offsets.data(), offsets.size() * sizeof(u32));\n+      internal_close(fd);\n+      if (common_flags()->verbosity)\n+        Report(\" CovDump: %s: %zd PCs written\\n\", path.data(), vb - old_vb);\n+    }\n+  }\n+#endif  // !SANITIZER_WINDOWS\n+}\n+\n+}  // namespace __sanitizer\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(void *pc) {\n+  CovAdd(reinterpret_cast<uptr>(pc));\n+}\n+SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() { CovDump(); }\n+}  // extern \"C\""}, {"sha": "90bb57dff98049a9732ad873cb97022a2afeba99", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -16,20 +16,40 @@\n \n namespace __sanitizer {\n \n-CommonFlags common_flags_dont_use_directly;\n+void SetCommonFlagsDefaults(CommonFlags *f) {\n+  f->symbolize = true;\n+  f->external_symbolizer_path = 0;\n+  f->strip_path_prefix = \"\";\n+  f->fast_unwind_on_fatal = false;\n+  f->fast_unwind_on_malloc = true;\n+  f->handle_ioctl = false;\n+  f->malloc_context_size = 1;\n+  f->log_path = \"stderr\";\n+  f->verbosity = 0;\n+  f->detect_leaks = false;\n+  f->leak_check_at_exit = true;\n+  f->allocator_may_return_null = false;\n+  f->print_summary = true;\n+}\n \n-void ParseCommonFlagsFromString(const char *str) {\n-  CommonFlags *f = common_flags();\n-  ParseFlag(str, &f->malloc_context_size, \"malloc_context_size\");\n+void ParseCommonFlagsFromString(CommonFlags *f, const char *str) {\n+  ParseFlag(str, &f->symbolize, \"symbolize\");\n+  ParseFlag(str, &f->external_symbolizer_path, \"external_symbolizer_path\");\n   ParseFlag(str, &f->strip_path_prefix, \"strip_path_prefix\");\n   ParseFlag(str, &f->fast_unwind_on_fatal, \"fast_unwind_on_fatal\");\n   ParseFlag(str, &f->fast_unwind_on_malloc, \"fast_unwind_on_malloc\");\n-  ParseFlag(str, &f->symbolize, \"symbolize\");\n   ParseFlag(str, &f->handle_ioctl, \"handle_ioctl\");\n+  ParseFlag(str, &f->malloc_context_size, \"malloc_context_size\");\n   ParseFlag(str, &f->log_path, \"log_path\");\n+  ParseFlag(str, &f->verbosity, \"verbosity\");\n   ParseFlag(str, &f->detect_leaks, \"detect_leaks\");\n   ParseFlag(str, &f->leak_check_at_exit, \"leak_check_at_exit\");\n   ParseFlag(str, &f->allocator_may_return_null, \"allocator_may_return_null\");\n+  ParseFlag(str, &f->print_summary, \"print_summary\");\n+\n+  // Do a sanity check for certain flags.\n+  if (f->malloc_context_size < 1)\n+    f->malloc_context_size = 1;\n }\n \n static bool GetFlagValue(const char *env, const char *name,"}, {"sha": "46ec0928193695431c1caabf6b8cfa3d25d5af84", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -23,7 +23,8 @@ void ParseFlag(const char *env, const char **flag, const char *name);\n struct CommonFlags {\n   // If set, use the online symbolizer from common sanitizer runtime.\n   bool symbolize;\n-  // Path to external symbolizer.\n+  // Path to external symbolizer. If it is NULL, symbolizer will be looked for\n+  // in PATH. If it is empty, external symbolizer will not be started.\n   const char *external_symbolizer_path;\n   // Strips this prefix from file paths in error reports.\n   const char *strip_path_prefix;\n@@ -35,8 +36,12 @@ struct CommonFlags {\n   bool handle_ioctl;\n   // Max number of stack frames kept for each allocation/deallocation.\n   int malloc_context_size;\n-  // Write logs to \"log_path.pid\" instead of stderr.\n+  // Write logs to \"log_path.pid\".\n+  // The special values are \"stdout\" and \"stderr\".\n+  // The default is \"stderr\".\n   const char *log_path;\n+  // Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\n+  int  verbosity;\n   // Enable memory leak detection.\n   bool detect_leaks;\n   // Invoke leak checking in an atexit handler. Has no effect if\n@@ -45,15 +50,17 @@ struct CommonFlags {\n   bool leak_check_at_exit;\n   // If false, the allocator will crash instead of returning 0 on out-of-memory.\n   bool allocator_may_return_null;\n+  // If false, disable printing error summaries in addition to error reports.\n+  bool print_summary;\n };\n \n-extern CommonFlags common_flags_dont_use_directly;\n-\n inline CommonFlags *common_flags() {\n-  return &common_flags_dont_use_directly;\n+  static CommonFlags f;\n+  return &f;\n }\n \n-void ParseCommonFlagsFromString(const char *str);\n+void SetCommonFlagsDefaults(CommonFlags *f);\n+void ParseCommonFlagsFromString(CommonFlags *f, const char *str);\n \n }  // namespace __sanitizer\n "}, {"sha": "0dab7c2f6c7dc060e9fa8f5073ba9837c9a79a5c", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -32,6 +32,12 @@\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n #endif\n \n+#if __LP64__ || defined(_WIN64)\n+#  define SANITIZER_WORDSIZE 64\n+#else\n+#  define SANITIZER_WORDSIZE 32\n+#endif\n+\n // GCC does not understand __has_feature\n #if !defined(__has_feature)\n # define __has_feature(x) 0\n@@ -77,18 +83,20 @@ typedef u64 OFF_T;\n typedef uptr OFF_T;\n #endif\n typedef u64  OFF64_T;\n+\n+#if (SANITIZER_WORDSIZE == 64) || SANITIZER_MAC\n+typedef uptr operator_new_size_type;\n+#else\n+typedef u32 operator_new_size_type;\n+#endif\n }  // namespace __sanitizer\n \n extern \"C\" {\n   // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n+  // The special values are \"stdout\" and \"stderr\".\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __sanitizer_set_report_path(const char *path);\n \n-  // Tell the tools to write their reports to given file descriptor instead of\n-  // stderr.\n-  SANITIZER_INTERFACE_ATTRIBUTE\n-  void __sanitizer_set_report_fd(int fd);\n-\n   // Notify the tools that the sandbox is going to be turned on. The reserved\n   // parameter will be used in the future to hold a structure with functions\n   // that the tools may call to bypass the sandbox.\n@@ -100,6 +108,14 @@ extern \"C\" {\n   // the error message. This function can be overridden by the client.\n   SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n   void __sanitizer_report_error_summary(const char *error_summary);\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump();\n+  SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov(void *pc);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __sanitizer_annotate_contiguous_container(const void *beg,\n+                                                 const void *end,\n+                                                 const void *old_mid,\n+                                                 const void *new_mid);\n }  // extern \"C\"\n \n \n@@ -169,12 +185,6 @@ typedef void* thread_return_t;\n #endif  // _WIN32\n typedef thread_return_t (THREAD_CALLING_CONV *thread_callback_t)(void* arg);\n \n-#if __LP64__ || defined(_WIN64)\n-#  define SANITIZER_WORDSIZE 64\n-#else\n-#  define SANITIZER_WORDSIZE 32\n-#endif\n-\n // NOTE: Functions below must be defined in each run-time.\n namespace __sanitizer {\n void NORETURN Die();"}, {"sha": "53c87555092b86c9ded934de9d6359f3548b2779", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -14,6 +14,16 @@\n \n namespace __sanitizer {\n \n+// Make the compiler think that something is going on there.\n+static inline void break_optimization(void *arg) {\n+#if SANITIZER_WINDOWS\n+  // FIXME: make sure this is actually enough.\n+  __asm;\n+#else\n+  __asm__ __volatile__(\"\" : : \"r\" (arg) : \"memory\");\n+#endif\n+}\n+\n s64 internal_atoll(const char *nptr) {\n   return internal_simple_strtoll(nptr, (char**)0, 10);\n }\n@@ -60,6 +70,16 @@ void *internal_memmove(void *dest, const void *src, uptr n) {\n   return dest;\n }\n \n+// Semi-fast bzero for 16-aligned data. Still far from peak performance.\n+void internal_bzero_aligned16(void *s, uptr n) {\n+  struct S16 { u64 a, b; } ALIGNED(16);\n+  CHECK_EQ((reinterpret_cast<uptr>(s) | n) & 15, 0);\n+  for (S16 *p = reinterpret_cast<S16*>(s), *end = p + n / 16; p < end; p++) {\n+    p->a = p->b = 0;\n+    break_optimization(0);  // Make sure this does not become memset.\n+  }\n+}\n+\n void *internal_memset(void* s, int c, uptr n) {\n   // The next line prevents Clang from making a call to memset() instead of the\n   // loop below."}, {"sha": "ae23bc45e9dd6bbafdc5de4cb73bd485503e9450", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -27,6 +27,8 @@ void *internal_memchr(const void *s, int c, uptr n);\n int internal_memcmp(const void* s1, const void* s2, uptr n);\n void *internal_memcpy(void *dest, const void *src, uptr n);\n void *internal_memmove(void *dest, const void *src, uptr n);\n+// Set [s, s + n) to 0. Both s and n should be 16-aligned.\n+void internal_bzero_aligned16(void *s, uptr n);\n // Should not be used in performance-critical places.\n void *internal_memset(void *s, int c, uptr n);\n char* internal_strchr(const char *s, int c);"}, {"sha": "310e811df1dac6e59da00e8b0b59b05f177d79bb", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.cc", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,103 @@\n+//===-- sanitizer_libignore.cc --------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#if SANITIZER_LINUX\n+\n+#include \"sanitizer_libignore.h\"\n+#include \"sanitizer_flags.h\"\n+#include \"sanitizer_procmaps.h\"\n+\n+namespace __sanitizer {\n+\n+LibIgnore::LibIgnore(LinkerInitialized) {\n+}\n+\n+void LibIgnore::Init(const SuppressionContext &supp) {\n+  BlockingMutexLock lock(&mutex_);\n+  CHECK_EQ(count_, 0);\n+  const uptr n = supp.SuppressionCount();\n+  for (uptr i = 0; i < n; i++) {\n+    const Suppression *s = supp.SuppressionAt(i);\n+    if (s->type != SuppressionLib)\n+      continue;\n+    if (count_ >= kMaxLibs) {\n+      Report(\"%s: too many called_from_lib suppressions (max: %d)\\n\",\n+             SanitizerToolName, kMaxLibs);\n+      Die();\n+    }\n+    Lib *lib = &libs_[count_++];\n+    lib->templ = internal_strdup(s->templ);\n+    lib->name = 0;\n+    lib->loaded = false;\n+  }\n+}\n+\n+void LibIgnore::OnLibraryLoaded(const char *name) {\n+  BlockingMutexLock lock(&mutex_);\n+  // Try to match suppressions with symlink target.\n+  InternalScopedBuffer<char> buf(4096);\n+  if (name != 0 && internal_readlink(name, buf.data(), buf.size() - 1) > 0 &&\n+      buf.data()[0]) {\n+    for (uptr i = 0; i < count_; i++) {\n+      Lib *lib = &libs_[i];\n+      if (!lib->loaded && lib->real_name == 0 &&\n+          TemplateMatch(lib->templ, name))\n+        lib->real_name = internal_strdup(buf.data());\n+    }\n+  }\n+\n+  // Scan suppressions list and find newly loaded and unloaded libraries.\n+  MemoryMappingLayout proc_maps(/*cache_enabled*/false);\n+  InternalScopedBuffer<char> module(4096);\n+  for (uptr i = 0; i < count_; i++) {\n+    Lib *lib = &libs_[i];\n+    bool loaded = false;\n+    proc_maps.Reset();\n+    uptr b, e, off, prot;\n+    while (proc_maps.Next(&b, &e, &off, module.data(), module.size(), &prot)) {\n+      if ((prot & MemoryMappingLayout::kProtectionExecute) == 0)\n+        continue;\n+      if (TemplateMatch(lib->templ, module.data()) ||\n+          (lib->real_name != 0 &&\n+          internal_strcmp(lib->real_name, module.data()) == 0)) {\n+        if (loaded) {\n+          Report(\"%s: called_from_lib suppression '%s' is matched against\"\n+                 \" 2 libraries: '%s' and '%s'\\n\",\n+                 SanitizerToolName, lib->templ, lib->name, module.data());\n+          Die();\n+        }\n+        loaded = true;\n+        if (lib->loaded)\n+          continue;\n+        if (common_flags()->verbosity)\n+          Report(\"Matched called_from_lib suppression '%s' against library\"\n+              \" '%s'\\n\", lib->templ, module.data());\n+        lib->loaded = true;\n+        lib->name = internal_strdup(module.data());\n+        const uptr idx = atomic_load(&loaded_count_, memory_order_relaxed);\n+        code_ranges_[idx].begin = b;\n+        code_ranges_[idx].end = e;\n+        atomic_store(&loaded_count_, idx + 1, memory_order_release);\n+      }\n+    }\n+    if (lib->loaded && !loaded) {\n+      Report(\"%s: library '%s' that was matched against called_from_lib\"\n+             \" suppression '%s' is unloaded\\n\",\n+             SanitizerToolName, lib->name, lib->templ);\n+      Die();\n+    }\n+  }\n+}\n+\n+void LibIgnore::OnLibraryUnloaded() {\n+  OnLibraryLoaded(0);\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // #if SANITIZER_LINUX"}, {"sha": "2089c4bbeeb44341ca67d75a07ba377c28532502", "filename": "libsanitizer/sanitizer_common/sanitizer_libignore.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libignore.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,82 @@\n+//===-- sanitizer_libignore.h -----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// LibIgnore allows to ignore all interceptors called from a particular set\n+// of dynamic libraries. LibIgnore remembers all \"called_from_lib\" suppressions\n+// from the provided SuppressionContext; finds code ranges for the libraries;\n+// and checks whether the provided PC value belongs to the code ranges.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_LIBIGNORE_H\n+#define SANITIZER_LIBIGNORE_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_suppressions.h\"\n+#include \"sanitizer_atomic.h\"\n+#include \"sanitizer_mutex.h\"\n+\n+namespace __sanitizer {\n+\n+class LibIgnore {\n+ public:\n+  explicit LibIgnore(LinkerInitialized);\n+\n+  // Fetches all \"called_from_lib\" suppressions from the SuppressionContext.\n+  void Init(const SuppressionContext &supp);\n+\n+  // Must be called after a new dynamic library is loaded.\n+  void OnLibraryLoaded(const char *name);\n+\n+  // Must be called after a dynamic library is unloaded.\n+  void OnLibraryUnloaded();\n+\n+  // Checks whether the provided PC belongs to one of the ignored libraries.\n+  bool IsIgnored(uptr pc) const;\n+\n+ private:\n+  struct Lib {\n+    char *templ;\n+    char *name;\n+    char *real_name;  // target of symlink\n+    bool loaded;\n+  };\n+\n+  struct LibCodeRange {\n+    uptr begin;\n+    uptr end;\n+  };\n+\n+  static const uptr kMaxLibs = 128;\n+\n+  // Hot part:\n+  atomic_uintptr_t loaded_count_;\n+  LibCodeRange code_ranges_[kMaxLibs];\n+\n+  // Cold part:\n+  BlockingMutex mutex_;\n+  uptr count_;\n+  Lib libs_[kMaxLibs];\n+\n+  // Disallow copying of LibIgnore objects.\n+  LibIgnore(const LibIgnore&);  // not implemented\n+  void operator = (const LibIgnore&);  // not implemented\n+};\n+\n+inline bool LibIgnore::IsIgnored(uptr pc) const {\n+  const uptr n = atomic_load(&loaded_count_, memory_order_acquire);\n+  for (uptr i = 0; i < n; i++) {\n+    if (pc >= code_ranges_[i].begin && pc < code_ranges_[i].end)\n+      return true;\n+  }\n+  return false;\n+}\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_LIBIGNORE_H"}, {"sha": "69c9c1063f0091daede33bd5879a7d14ffe93a4e", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -77,7 +77,8 @@ namespace __sanitizer {\n uptr internal_mmap(void *addr, uptr length, int prot, int flags,\n                     int fd, u64 offset) {\n #if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n-  return internal_syscall(__NR_mmap, (uptr)addr, length, prot, flags, fd, offset);\n+  return internal_syscall(__NR_mmap, (uptr)addr, length, prot, flags, fd,\n+                          offset);\n #else\n   return internal_syscall(__NR_mmap2, addr, length, prot, flags, fd, offset);\n #endif\n@@ -216,7 +217,8 @@ uptr GetTid() {\n }\n \n u64 NanoTime() {\n-  kernel_timeval tv = {};\n+  kernel_timeval tv;\n+  internal_memset(&tv, 0, sizeof(tv));\n   internal_syscall(__NR_gettimeofday, (uptr)&tv, 0);\n   return (u64)tv.tv_sec * 1000*1000*1000 + tv.tv_usec * 1000;\n }\n@@ -309,7 +311,8 @@ void PrepareForSandboxing() {\n   MemoryMappingLayout::CacheMemoryMappings();\n   // Same for /proc/self/exe in the symbolizer.\n #if !SANITIZER_GO\n-  getSymbolizer()->PrepareForSandboxing();\n+  if (Symbolizer *sym = Symbolizer::GetOrNull())\n+    sym->PrepareForSandboxing();\n #endif\n }\n \n@@ -572,7 +575,8 @@ uptr internal_ptrace(int request, int pid, void *addr, void *data) {\n }\n \n uptr internal_waitpid(int pid, int *status, int options) {\n-  return internal_syscall(__NR_wait4, pid, (uptr)status, options, 0 /* rusage */);\n+  return internal_syscall(__NR_wait4, pid, (uptr)status, options,\n+                          0 /* rusage */);\n }\n \n uptr internal_getpid() {\n@@ -600,6 +604,31 @@ uptr internal_sigaltstack(const struct sigaltstack *ss,\n   return internal_syscall(__NR_sigaltstack, (uptr)ss, (uptr)oss);\n }\n \n+uptr internal_sigaction(int signum, const __sanitizer_kernel_sigaction_t *act,\n+    __sanitizer_kernel_sigaction_t *oldact) {\n+  return internal_syscall(__NR_rt_sigaction, signum, act, oldact,\n+      sizeof(__sanitizer_kernel_sigset_t));\n+}\n+\n+uptr internal_sigprocmask(int how, __sanitizer_kernel_sigset_t *set,\n+    __sanitizer_kernel_sigset_t *oldset) {\n+  return internal_syscall(__NR_rt_sigprocmask, (uptr)how, &set->sig[0],\n+      &oldset->sig[0], sizeof(__sanitizer_kernel_sigset_t));\n+}\n+\n+void internal_sigfillset(__sanitizer_kernel_sigset_t *set) {\n+  internal_memset(set, 0xff, sizeof(*set));\n+}\n+\n+void internal_sigdelset(__sanitizer_kernel_sigset_t *set, int signum) {\n+  signum -= 1;\n+  CHECK_GE(signum, 0);\n+  CHECK_LT(signum, sizeof(*set) * 8);\n+  const uptr idx = signum / (sizeof(set->sig[0]) * 8);\n+  const uptr bit = signum % (sizeof(set->sig[0]) * 8);\n+  set->sig[idx] &= ~(1 << bit);\n+}\n+\n // ThreadLister implementation.\n ThreadLister::ThreadLister(int pid)\n   : pid_(pid),\n@@ -775,8 +804,8 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n   child_stack = (char *)child_stack - 2 * sizeof(unsigned long long);\n   ((unsigned long long *)child_stack)[0] = (uptr)fn;\n   ((unsigned long long *)child_stack)[1] = (uptr)arg;\n-  register void *r8 __asm__ (\"r8\") = newtls;\n-  register int *r10 __asm__ (\"r10\") = child_tidptr;\n+  register void *r8 __asm__(\"r8\") = newtls;\n+  register int *r10 __asm__(\"r10\") = child_tidptr;\n   __asm__ __volatile__(\n                        /* %rax = syscall(%rax = __NR_clone,\n                         *                %rdi = flags,"}, {"sha": "6422df142e7a0256822e4dce8f31022d83162549", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -15,6 +15,7 @@\n #if SANITIZER_LINUX\n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_posix.h\"\n \n struct link_map;  // Opaque type returned by dlopen().\n struct sigaltstack;\n@@ -29,6 +30,13 @@ uptr internal_getdents(fd_t fd, struct linux_dirent *dirp, unsigned int count);\n uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n uptr internal_sigaltstack(const struct sigaltstack* ss,\n                           struct sigaltstack* oss);\n+uptr internal_sigaction(int signum, const __sanitizer_kernel_sigaction_t *act,\n+    __sanitizer_kernel_sigaction_t *oldact);\n+uptr internal_sigprocmask(int how, __sanitizer_kernel_sigset_t *set,\n+    __sanitizer_kernel_sigset_t *oldset);\n+void internal_sigfillset(__sanitizer_kernel_sigset_t *set);\n+void internal_sigdelset(__sanitizer_kernel_sigset_t *set, int signum);\n+\n #ifdef __x86_64__\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr);\n@@ -56,7 +64,7 @@ class ThreadLister {\n   int bytes_read_;\n };\n \n-void AdjustStackSizeLinux(void *attr, int verbosity);\n+void AdjustStackSizeLinux(void *attr);\n \n // Exposed for testing.\n uptr ThreadDescriptorSize();\n@@ -74,7 +82,6 @@ void CacheBinaryName();\n \n // Call cb for each region mapped by map.\n void ForEachMappedRegion(link_map *map, void (*cb)(const void *, uptr));\n-\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_LINUX"}, {"sha": "5b70a69abec1ad294108c920ca48c2952d118d9e", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -14,6 +14,7 @@\n #if SANITIZER_LINUX\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n@@ -30,6 +31,12 @@\n #include <link.h>\n #endif\n \n+// This function is defined elsewhere if we intercepted pthread_attr_getstack.\n+SANITIZER_WEAK_ATTRIBUTE\n+int __sanitizer_pthread_attr_getstack(void *attr, void **addr, size_t *size) {\n+  return pthread_attr_getstack((pthread_attr_t*)attr, addr, size);\n+}\n+\n namespace __sanitizer {\n \n void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n@@ -71,7 +78,7 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   CHECK_EQ(pthread_getattr_np(pthread_self(), &attr), 0);\n   uptr stacksize = 0;\n   void *stackaddr = 0;\n-  pthread_attr_getstack(&attr, &stackaddr, (size_t*)&stacksize);\n+  __sanitizer_pthread_attr_getstack(&attr, &stackaddr, (size_t*)&stacksize);\n   pthread_attr_destroy(&attr);\n \n   CHECK_LE(stacksize, kMaxThreadStackSize);  // Sanity check.\n@@ -137,35 +144,33 @@ uptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n #endif\n }\n \n+struct UnwindTraceArg {\n+  StackTrace *stack;\n+  uptr max_depth;\n+};\n+\n _Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n-  StackTrace *b = (StackTrace*)param;\n-  CHECK(b->size < b->max_size);\n+  UnwindTraceArg *arg = (UnwindTraceArg*)param;\n+  CHECK_LT(arg->stack->size, arg->max_depth);\n   uptr pc = Unwind_GetIP(ctx);\n-  b->trace[b->size++] = pc;\n-  if (b->size == b->max_size) return UNWIND_STOP;\n+  arg->stack->trace[arg->stack->size++] = pc;\n+  if (arg->stack->size == arg->max_depth) return UNWIND_STOP;\n   return UNWIND_CONTINUE;\n }\n \n-static bool MatchPc(uptr cur_pc, uptr trace_pc) {\n-  return cur_pc - trace_pc <= 64 || trace_pc - cur_pc <= 64;\n-}\n-\n void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n-  this->size = 0;\n-  this->max_size = max_depth;\n-  if (max_depth > 1) {\n-    _Unwind_Backtrace(Unwind_Trace, this);\n-    // We need to pop a few frames so that pc is on top.\n-    // trace[0] belongs to the current function so we always pop it.\n-    int to_pop = 1;\n-    /**/ if (size > 1 && MatchPc(pc, trace[1])) to_pop = 1;\n-    else if (size > 2 && MatchPc(pc, trace[2])) to_pop = 2;\n-    else if (size > 3 && MatchPc(pc, trace[3])) to_pop = 3;\n-    else if (size > 4 && MatchPc(pc, trace[4])) to_pop = 4;\n-    else if (size > 5 && MatchPc(pc, trace[5])) to_pop = 5;\n-    this->PopStackFrames(to_pop);\n-  }\n-  this->trace[0] = pc;\n+  size = 0;\n+  if (max_depth == 0)\n+    return;\n+  UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n+  _Unwind_Backtrace(Unwind_Trace, &arg);\n+  // We need to pop a few frames so that pc is on top.\n+  uptr to_pop = LocatePcInTrace(pc);\n+  // trace[0] belongs to the current function so we always pop it.\n+  if (to_pop == 0)\n+    to_pop = 1;\n+  PopStackFrames(to_pop);\n+  trace[0] = pc;\n }\n \n #endif  // !SANITIZER_GO\n@@ -265,19 +270,19 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n #endif  // SANITIZER_GO\n }\n \n-void AdjustStackSizeLinux(void *attr_, int verbosity) {\n+void AdjustStackSizeLinux(void *attr_) {\n   pthread_attr_t *attr = (pthread_attr_t *)attr_;\n   uptr stackaddr = 0;\n   size_t stacksize = 0;\n-  pthread_attr_getstack(attr, (void**)&stackaddr, &stacksize);\n+  __sanitizer_pthread_attr_getstack(attr, (void**)&stackaddr, &stacksize);\n   // GLibC will return (0 - stacksize) as the stack address in the case when\n   // stacksize is set, but stackaddr is not.\n   bool stack_set = (stackaddr != 0) && (stackaddr + stacksize != 0);\n   // We place a lot of tool data into TLS, account for that.\n   const uptr minstacksize = GetTlsSize() + 128*1024;\n   if (stacksize < minstacksize) {\n     if (!stack_set) {\n-      if (verbosity && stacksize != 0)\n+      if (common_flags()->verbosity && stacksize != 0)\n         Printf(\"Sanitizer: increasing stacksize %zu->%zu\\n\", stacksize,\n                minstacksize);\n       pthread_attr_setstacksize(attr, minstacksize);"}, {"sha": "288e31ca07879efca4b481d7e8f967da1a179142", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -143,7 +143,11 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n \n const char *GetEnv(const char *name) {\n   char ***env_ptr = _NSGetEnviron();\n-  CHECK(env_ptr);\n+  if (!env_ptr) {\n+    Report(\"_NSGetEnviron() returned NULL. Please make sure __asan_init() is \"\n+           \"called after libSystem_initializer().\\n\");\n+    CHECK(env_ptr);\n+  }\n   char **environ = *env_ptr;\n   CHECK(environ);\n   uptr name_len = internal_strlen(name);"}, {"sha": "d78f43edaaed2c05bfc0998631ff9e2cef0ba3d6", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -38,6 +38,10 @@ class StaticSpinMutex {\n     atomic_store(&state_, 0, memory_order_release);\n   }\n \n+  void CheckLocked() {\n+    CHECK_EQ(atomic_load(&state_, memory_order_relaxed), 1);\n+  }\n+\n  private:\n   atomic_uint8_t state_;\n "}, {"sha": "7231e96878db7162f9af26f91a2410425cc8bfff", "filename": "libsanitizer/sanitizer_common/sanitizer_placement_new.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_placement_new.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -16,15 +16,7 @@\n \n #include \"sanitizer_internal_defs.h\"\n \n-namespace __sanitizer {\n-#if (SANITIZER_WORDSIZE == 64) || SANITIZER_MAC\n-typedef uptr operator_new_ptr_type;\n-#else\n-typedef u32 operator_new_ptr_type;\n-#endif\n-}  // namespace __sanitizer\n-\n-inline void *operator new(__sanitizer::operator_new_ptr_type sz, void *p) {\n+inline void *operator new(__sanitizer::operator_new_size_type sz, void *p) {\n   return p;\n }\n "}, {"sha": "7693fe7ff17cb9a3174d1e9342fab0bb620ed924", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -23,8 +23,15 @@\n \n #if defined(__APPLE__)\n # define SANITIZER_MAC     1\n+# include <TargetConditionals.h>\n+# if TARGET_OS_IPHONE\n+#  define SANITIZER_IOS    1\n+# else\n+#  define SANITIZER_IOS    0\n+# endif\n #else\n # define SANITIZER_MAC     0\n+# define SANITIZER_IOS     0\n #endif\n \n #if defined(_WIN32)"}, {"sha": "b6dcbe9e8082e0c9ab0e0f3f3ad76e8a72d76ffc", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -39,6 +39,12 @@\n # define SI_MAC 0\n #endif\n \n+#if SANITIZER_IOS\n+# define SI_IOS 1\n+#else\n+# define SI_IOS 0\n+#endif\n+\n # define SANITIZER_INTERCEPT_STRCMP 1\n # define SANITIZER_INTERCEPT_STRCASECMP SI_NOT_WINDOWS\n \n@@ -61,6 +67,7 @@\n # define SANITIZER_INTERCEPT_PRCTL   SI_LINUX\n \n # define SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_STRPTIME SI_NOT_WINDOWS\n \n # define SANITIZER_INTERCEPT_SCANF SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_ISOC99_SCANF SI_LINUX\n@@ -111,6 +118,7 @@\n # define SANITIZER_INTERCEPT_SCHED_GETAFFINITY SI_LINUX_NOT_ANDROID\n # define SANITIZER_INTERCEPT_STRERROR SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_STRERROR_R SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_XPG_STRERROR_R SI_LINUX_NOT_ANDROID\n # define SANITIZER_INTERCEPT_SCANDIR SI_LINUX_NOT_ANDROID\n # define SANITIZER_INTERCEPT_SCANDIR64 SI_LINUX_NOT_ANDROID\n # define SANITIZER_INTERCEPT_GETGROUPS SI_NOT_WINDOWS\n@@ -124,5 +132,41 @@\n # define SANITIZER_INTERCEPT_SIGPENDING SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_SIGPROCMASK SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_BACKTRACE SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_GETMNTENT SI_LINUX\n+# define SANITIZER_INTERCEPT_GETMNTENT_R SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_STATFS SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_STATFS64 \\\n+    (SI_MAC && !SI_IOS) || SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_STATVFS SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_STATVFS64 SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_INITGROUPS SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_ETHER SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_ETHER_R SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_SHMCTL \\\n+    (SI_LINUX_NOT_ANDROID && SANITIZER_WORDSIZE == 64)\n+# define SANITIZER_INTERCEPT_RANDOM_R SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_PTHREAD_ATTR_GET SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED \\\n+  SI_MAC || SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_TMPNAM SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_TEMPNAM SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_SINCOS SI_LINUX\n+# define SANITIZER_INTERCEPT_REMQUO SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_LGAMMA SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_LGAMMA_R SI_LINUX\n+# define SANITIZER_INTERCEPT_DRAND48_R SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_ICONV SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_TIMES SI_NOT_WINDOWS\n+\n+// FIXME: getline seems to be available on OSX 10.7\n+# define SANITIZER_INTERCEPT_GETLINE SI_LINUX_NOT_ANDROID\n+\n+# define SANITIZER_INTERCEPT__EXIT SI_LINUX\n+\n+# define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_PTHREAD_COND SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP SI_LINUX_NOT_ANDROID\n \n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "01de9c936c798a19bde3605f337bf13727ddb2d3", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc", "status": "modified", "additions": 66, "deletions": 12, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -14,34 +14,88 @@\n // userspace headers.\n // Most \"normal\" includes go in sanitizer_platform_limits_posix.cc\n \n-#ifdef SYSCALL_INTERCEPTION\n #include \"sanitizer_platform.h\"\n #if SANITIZER_LINUX\n \n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_posix.h\"\n+\n+// For offsetof -> __builtin_offsetof definition.\n+#include <stddef.h>\n+\n+// With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n+// are not defined anywhere in userspace headers. Fake them. This seems to work\n+// fine with newer headers, too.\n+#include <asm/posix_types.h>\n+#define ino_t __kernel_ino_t\n+#define mode_t __kernel_mode_t\n+#define nlink_t __kernel_nlink_t\n+#define uid_t __kernel_uid_t\n+#define gid_t __kernel_gid_t\n+#define off_t __kernel_off_t\n // This header seems to contain the definitions of _kernel_ stat* structs.\n #include <asm/stat.h>\n+#undef ino_t\n+#undef mode_t\n+#undef nlink_t\n+#undef uid_t\n+#undef gid_t\n+#undef off_t\n+\n #include <linux/aio_abi.h>\n \n+#if SANITIZER_ANDROID\n+#include <asm/statfs.h>\n+#else\n+#include <sys/statfs.h>\n+#endif\n+\n #if !SANITIZER_ANDROID\n #include <linux/perf_event.h>\n #endif\n \n namespace __sanitizer {\n-  unsigned struct___old_kernel_stat_sz = sizeof(struct __old_kernel_stat);\n-  unsigned struct_kernel_stat_sz = sizeof(struct stat);\n-  unsigned struct_io_event_sz = sizeof(struct io_event);\n-  unsigned struct_iocb_sz = sizeof(struct iocb);\n+  unsigned struct_statfs64_sz = sizeof(struct statfs64);\n+}  // namespace __sanitizer\n \n-#if !defined(_LP64) && !defined(__x86_64__)\n-  unsigned struct_kernel_stat64_sz = sizeof(struct stat64);\n-#else\n-  unsigned struct_kernel_stat64_sz = 0;\n+#if !defined(__powerpc64__)\n+COMPILER_CHECK(struct___old_kernel_stat_sz == sizeof(struct __old_kernel_stat));\n+#endif\n+\n+COMPILER_CHECK(struct_kernel_stat_sz == sizeof(struct stat));\n+\n+#if defined(__i386__)\n+COMPILER_CHECK(struct_kernel_stat64_sz == sizeof(struct stat64));\n #endif\n \n+CHECK_TYPE_SIZE(io_event);\n+CHECK_SIZE_AND_OFFSET(io_event, data);\n+CHECK_SIZE_AND_OFFSET(io_event, obj);\n+CHECK_SIZE_AND_OFFSET(io_event, res);\n+CHECK_SIZE_AND_OFFSET(io_event, res2);\n+\n #if !SANITIZER_ANDROID\n-  unsigned struct_perf_event_attr_sz = sizeof(struct perf_event_attr);\n+COMPILER_CHECK(sizeof(struct __sanitizer_perf_event_attr) <=\n+               sizeof(struct perf_event_attr));\n+CHECK_SIZE_AND_OFFSET(perf_event_attr, type);\n+CHECK_SIZE_AND_OFFSET(perf_event_attr, size);\n #endif\n-}  // namespace __sanitizer\n \n-#endif  // SANITIZER_LINUX\n+COMPILER_CHECK(iocb_cmd_pread == IOCB_CMD_PREAD);\n+COMPILER_CHECK(iocb_cmd_pwrite == IOCB_CMD_PWRITE);\n+#if !SANITIZER_ANDROID\n+COMPILER_CHECK(iocb_cmd_preadv == IOCB_CMD_PREADV);\n+COMPILER_CHECK(iocb_cmd_pwritev == IOCB_CMD_PWRITEV);\n #endif\n+\n+CHECK_TYPE_SIZE(iocb);\n+CHECK_SIZE_AND_OFFSET(iocb, aio_data);\n+// Skip aio_key, it's weird.\n+CHECK_SIZE_AND_OFFSET(iocb, aio_lio_opcode);\n+CHECK_SIZE_AND_OFFSET(iocb, aio_reqprio);\n+CHECK_SIZE_AND_OFFSET(iocb, aio_fildes);\n+CHECK_SIZE_AND_OFFSET(iocb, aio_buf);\n+CHECK_SIZE_AND_OFFSET(iocb, aio_nbytes);\n+CHECK_SIZE_AND_OFFSET(iocb, aio_offset);\n+\n+#endif  // SANITIZER_LINUX"}, {"sha": "058f40acf236f83a5bfaf3d0296aaaf90a91af95", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 83, "deletions": 26, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -19,6 +19,7 @@\n \n #include <arpa/inet.h>\n #include <dirent.h>\n+#include <errno.h>\n #include <grp.h>\n #include <limits.h>\n #include <net/if.h>\n@@ -42,6 +43,8 @@\n #include <wchar.h>\n \n #if SANITIZER_LINUX\n+#include <mntent.h>\n+#include <netinet/ether.h>\n #include <utime.h>\n #include <sys/mount.h>\n #include <sys/ptrace.h>\n@@ -75,6 +78,7 @@\n #include <sys/mtio.h>\n #include <sys/kd.h>\n #include <sys/shm.h>\n+#include <sys/statvfs.h>\n #include <sys/timex.h>\n #include <sys/user.h>\n #include <sys/ustat.h>\n@@ -87,6 +91,8 @@\n #include <linux/scc.h>\n #include <linux/serial.h>\n #include <sys/msg.h>\n+#include <sys/ipc.h>\n+#include <sys/shm.h>\n #endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n #if SANITIZER_ANDROID\n@@ -100,20 +106,22 @@\n #include <link.h>\n #include <sys/vfs.h>\n #include <sys/epoll.h>\n-// #include <asm/stat.h>\n #include <linux/capability.h>\n #endif // SANITIZER_LINUX\n \n #if SANITIZER_MAC\n-#include <netinet/ip_mroute.h>\n+#include <net/ethernet.h>\n #include <sys/filio.h>\n+#include <sys/mount.h>\n #include <sys/sockio.h>\n #endif\n \n namespace __sanitizer {\n   unsigned struct_utsname_sz = sizeof(struct utsname);\n   unsigned struct_stat_sz = sizeof(struct stat);\n+#if !SANITIZER_IOS\n   unsigned struct_stat64_sz = sizeof(struct stat64);\n+#endif // !SANITIZER_IOS\n   unsigned struct_rusage_sz = sizeof(struct rusage);\n   unsigned struct_tm_sz = sizeof(struct tm);\n   unsigned struct_passwd_sz = sizeof(struct passwd);\n@@ -122,6 +130,7 @@ namespace __sanitizer {\n   unsigned struct_sigaction_sz = sizeof(struct sigaction);\n   unsigned struct_itimerval_sz = sizeof(struct itimerval);\n   unsigned pthread_t_sz = sizeof(pthread_t);\n+  unsigned pthread_cond_t_sz = sizeof(pthread_cond_t);\n   unsigned pid_t_sz = sizeof(pid_t);\n   unsigned timeval_sz = sizeof(timeval);\n   unsigned uid_t_sz = sizeof(uid_t);\n@@ -131,14 +140,18 @@ namespace __sanitizer {\n   unsigned struct_tms_sz = sizeof(struct tms);\n   unsigned struct_sigevent_sz = sizeof(struct sigevent);\n   unsigned struct_sched_param_sz = sizeof(struct sched_param);\n+  unsigned struct_statfs_sz = sizeof(struct statfs);\n+\n+#if SANITIZER_MAC && !SANITIZER_IOS\n+  unsigned struct_statfs64_sz = sizeof(struct statfs64);\n+#endif // SANITIZER_MAC && !SANITIZER_IOS\n \n #if !SANITIZER_ANDROID\n   unsigned ucontext_t_sz = sizeof(ucontext_t);\n #endif // !SANITIZER_ANDROID\n \n #if SANITIZER_LINUX\n   unsigned struct_rlimit_sz = sizeof(struct rlimit);\n-  unsigned struct_statfs_sz = sizeof(struct statfs);\n   unsigned struct_epoll_event_sz = sizeof(struct epoll_event);\n   unsigned struct_sysinfo_sz = sizeof(struct sysinfo);\n   unsigned struct_timespec_sz = sizeof(struct timespec);\n@@ -155,11 +168,11 @@ namespace __sanitizer {\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   unsigned struct_rlimit64_sz = sizeof(struct rlimit64);\n-  unsigned struct_statfs64_sz = sizeof(struct statfs64);\n   unsigned struct_timex_sz = sizeof(struct timex);\n   unsigned struct_msqid_ds_sz = sizeof(struct msqid_ds);\n-  unsigned struct_shmid_ds_sz = sizeof(struct shmid_ds);\n   unsigned struct_mq_attr_sz = sizeof(struct mq_attr);\n+  unsigned struct_statvfs_sz = sizeof(struct statvfs);\n+  unsigned struct_statvfs64_sz = sizeof(struct statvfs64);\n #endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n   uptr sig_ign = (uptr)SIG_IGN;\n@@ -170,6 +183,16 @@ namespace __sanitizer {\n   int e_tabsz = (int)E_TABSZ;\n #endif\n \n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  unsigned struct_shminfo_sz = sizeof(struct shminfo);\n+  unsigned struct_shm_info_sz = sizeof(struct shm_info);\n+  int shmctl_ipc_stat = (int)IPC_STAT;\n+  int shmctl_ipc_info = (int)IPC_INFO;\n+  int shmctl_shm_info = (int)SHM_INFO;\n+  int shmctl_shm_stat = (int)SHM_INFO;\n+#endif\n+\n   int af_inet = (int)AF_INET;\n   int af_inet6 = (int)AF_INET6;\n \n@@ -197,6 +220,9 @@ namespace __sanitizer {\n   unsigned struct_user_fpxregs_struct_sz = sizeof(struct user_fpxregs_struct);\n #endif\n \n+  int ptrace_peektext = PTRACE_PEEKTEXT;\n+  int ptrace_peekdata = PTRACE_PEEKDATA;\n+  int ptrace_peekuser = PTRACE_PEEKUSER;\n   int ptrace_getregs = PTRACE_GETREGS;\n   int ptrace_setregs = PTRACE_SETREGS;\n   int ptrace_getfpregs = PTRACE_GETFPREGS;\n@@ -295,7 +321,7 @@ namespace __sanitizer {\n   unsigned struct_unimapinit_sz = sizeof(struct unimapinit);\n #endif\n \n-#if !SANITIZER_ANDROID\n+#if !SANITIZER_ANDROID && !SANITIZER_MAC\n   unsigned struct_sioc_sg_req_sz = sizeof(struct sioc_sg_req);\n   unsigned struct_sioc_vif_req_sz = sizeof(struct sioc_vif_req);\n #endif\n@@ -346,7 +372,7 @@ namespace __sanitizer {\n   unsigned IOCTL_TIOCSPGRP = TIOCSPGRP;\n   unsigned IOCTL_TIOCSTI = TIOCSTI;\n   unsigned IOCTL_TIOCSWINSZ = TIOCSWINSZ;\n-#if (SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_MAC\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID)\n   unsigned IOCTL_SIOCGETSGCNT = SIOCGETSGCNT;\n   unsigned IOCTL_SIOCGETVIFCNT = SIOCGETVIFCNT;\n #endif\n@@ -733,24 +759,9 @@ namespace __sanitizer {\n   unsigned IOCTL_TIOCSERSETMULTI = TIOCSERSETMULTI;\n   unsigned IOCTL_TIOCSSERIAL = TIOCSSERIAL;\n #endif\n-}  // namespace __sanitizer\n \n-#define CHECK_TYPE_SIZE(TYPE) \\\n-  COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n-\n-#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n-  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *) NULL)->MEMBER) == \\\n-                 sizeof(((CLASS *) NULL)->MEMBER));                \\\n-  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==          \\\n-                 offsetof(CLASS, MEMBER))\n-\n-// For sigaction, which is a function and struct at the same time,\n-// and thus requires explicit \"struct\" in sizeof() expression.\n-#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n-  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *) NULL)->MEMBER) == \\\n-                 sizeof(((struct CLASS *) NULL)->MEMBER));                \\\n-  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==          \\\n-                 offsetof(struct CLASS, MEMBER))\n+  extern const int errno_EOWNERDEAD = EOWNERDEAD;\n+}  // namespace __sanitizer\n \n COMPILER_CHECK(sizeof(__sanitizer_pthread_attr_t) >= sizeof(pthread_attr_t));\n \n@@ -855,7 +866,6 @@ CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_flags);\n CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_restorer);\n #endif\n \n-#ifdef SYSCALL_INTERCEPTION\n #if SANITIZER_LINUX\n CHECK_TYPE_SIZE(__sysctl_args);\n CHECK_SIZE_AND_OFFSET(__sysctl_args, name);\n@@ -873,7 +883,6 @@ CHECK_TYPE_SIZE(__kernel_off_t);\n CHECK_TYPE_SIZE(__kernel_loff_t);\n CHECK_TYPE_SIZE(__kernel_fd_set);\n #endif\n-#endif\n \n #if !SANITIZER_ANDROID\n CHECK_TYPE_SIZE(wordexp_t);\n@@ -882,4 +891,52 @@ CHECK_SIZE_AND_OFFSET(wordexp_t, we_wordv);\n CHECK_SIZE_AND_OFFSET(wordexp_t, we_offs);\n #endif\n \n+CHECK_TYPE_SIZE(tm);\n+CHECK_SIZE_AND_OFFSET(tm, tm_sec);\n+CHECK_SIZE_AND_OFFSET(tm, tm_min);\n+CHECK_SIZE_AND_OFFSET(tm, tm_hour);\n+CHECK_SIZE_AND_OFFSET(tm, tm_mday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_mon);\n+CHECK_SIZE_AND_OFFSET(tm, tm_year);\n+CHECK_SIZE_AND_OFFSET(tm, tm_wday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_yday);\n+CHECK_SIZE_AND_OFFSET(tm, tm_isdst);\n+CHECK_SIZE_AND_OFFSET(tm, tm_gmtoff);\n+CHECK_SIZE_AND_OFFSET(tm, tm_zone);\n+\n+#if SANITIZER_LINUX\n+CHECK_TYPE_SIZE(mntent);\n+CHECK_SIZE_AND_OFFSET(mntent, mnt_fsname);\n+CHECK_SIZE_AND_OFFSET(mntent, mnt_dir);\n+CHECK_SIZE_AND_OFFSET(mntent, mnt_type);\n+CHECK_SIZE_AND_OFFSET(mntent, mnt_opts);\n+CHECK_SIZE_AND_OFFSET(mntent, mnt_freq);\n+CHECK_SIZE_AND_OFFSET(mntent, mnt_passno);\n+#endif\n+\n+CHECK_TYPE_SIZE(ether_addr);\n+\n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+CHECK_TYPE_SIZE(ipc_perm);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, __key);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, uid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, gid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, cuid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, cgid);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, mode);\n+CHECK_SIZE_AND_OFFSET(ipc_perm, __seq);\n+\n+CHECK_TYPE_SIZE(shmid_ds);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_perm);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_segsz);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_atime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_dtime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_ctime);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_cpid);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_lpid);\n+CHECK_SIZE_AND_OFFSET(shmid_ds, shm_nattch);\n+#endif\n+\n+CHECK_TYPE_SIZE(clock_t);\n+\n #endif  // SANITIZER_LINUX || SANITIZER_MAC"}, {"sha": "3bb8dc1114ad691ec50cd6eff9c4423c64c0332e", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 194, "deletions": 13, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -13,19 +13,22 @@\n #ifndef SANITIZER_PLATFORM_LIMITS_POSIX_H\n #define SANITIZER_PLATFORM_LIMITS_POSIX_H\n \n+#include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_platform.h\"\n \n namespace __sanitizer {\n   extern unsigned struct_utsname_sz;\n   extern unsigned struct_stat_sz;\n+#if !SANITIZER_IOS\n   extern unsigned struct_stat64_sz;\n+#endif\n   extern unsigned struct_rusage_sz;\n-  extern unsigned struct_tm_sz;\n   extern unsigned struct_passwd_sz;\n   extern unsigned struct_group_sz;\n   extern unsigned siginfo_t_sz;\n   extern unsigned struct_itimerval_sz;\n   extern unsigned pthread_t_sz;\n+  extern unsigned pthread_cond_t_sz;\n   extern unsigned pid_t_sz;\n   extern unsigned timeval_sz;\n   extern unsigned uid_t_sz;\n@@ -35,30 +38,52 @@ namespace __sanitizer {\n   extern unsigned struct_itimerspec_sz;\n   extern unsigned struct_sigevent_sz;\n   extern unsigned struct_sched_param_sz;\n+  extern unsigned struct_statfs_sz;\n+  extern unsigned struct_statfs64_sz;\n \n #if !SANITIZER_ANDROID\n   extern unsigned ucontext_t_sz;\n #endif // !SANITIZER_ANDROID\n \n #if SANITIZER_LINUX\n-  extern unsigned struct___old_kernel_stat_sz;\n-  extern unsigned struct_kernel_stat_sz;\n-  extern unsigned struct_kernel_stat64_sz;\n-  extern unsigned struct_io_event_sz;\n-  extern unsigned struct_iocb_sz;\n+\n+#if defined(__x86_64__)\n+  const unsigned struct___old_kernel_stat_sz = 32;\n+  const unsigned struct_kernel_stat_sz = 144;\n+  const unsigned struct_kernel_stat64_sz = 0;\n+#elif defined(__i386__)\n+  const unsigned struct___old_kernel_stat_sz = 32;\n+  const unsigned struct_kernel_stat_sz = 64;\n+  const unsigned struct_kernel_stat64_sz = 96;\n+#elif defined(__arm__)\n+  const unsigned struct___old_kernel_stat_sz = 32;\n+  const unsigned struct_kernel_stat_sz = 64;\n+  const unsigned struct_kernel_stat64_sz = 104;\n+#elif defined(__powerpc__) && !defined(__powerpc64__)\n+  const unsigned struct___old_kernel_stat_sz = 32;\n+  const unsigned struct_kernel_stat_sz = 72;\n+  const unsigned struct_kernel_stat64_sz = 104;\n+#elif defined(__powerpc64__)\n+  const unsigned struct___old_kernel_stat_sz = 0;\n+  const unsigned struct_kernel_stat_sz = 144;\n+  const unsigned struct_kernel_stat64_sz = 104;\n+#endif\n+  struct __sanitizer_perf_event_attr {\n+    unsigned type;\n+    unsigned size;\n+    // More fields that vary with the kernel version.\n+  };\n+\n   extern unsigned struct_utimbuf_sz;\n   extern unsigned struct_new_utsname_sz;\n   extern unsigned struct_old_utsname_sz;\n   extern unsigned struct_oldold_utsname_sz;\n   extern unsigned struct_msqid_ds_sz;\n-  extern unsigned struct_shmid_ds_sz;\n   extern unsigned struct_mq_attr_sz;\n-  extern unsigned struct_perf_event_attr_sz;\n   extern unsigned struct_timex_sz;\n   extern unsigned struct_ustat_sz;\n \n   extern unsigned struct_rlimit_sz;\n-  extern unsigned struct_statfs_sz;\n   extern unsigned struct_epoll_event_sz;\n   extern unsigned struct_sysinfo_sz;\n   extern unsigned struct_timespec_sz;\n@@ -67,6 +92,32 @@ namespace __sanitizer {\n   const unsigned old_sigset_t_sz = sizeof(unsigned long);\n   const unsigned struct_kexec_segment_sz = 4 * sizeof(unsigned long);\n \n+  struct __sanitizer_iocb {\n+    u64   aio_data;\n+    u32   aio_key_or_aio_reserved1; // Simply crazy.\n+    u32   aio_reserved1_or_aio_key; // Luckily, we don't need these.\n+    u16   aio_lio_opcode;\n+    s16   aio_reqprio;\n+    u32   aio_fildes;\n+    u64   aio_buf;\n+    u64   aio_nbytes;\n+    s64   aio_offset;\n+    u64   aio_reserved2;\n+    u64   aio_reserved3;\n+  };\n+\n+  struct __sanitizer_io_event {\n+    u64 data;\n+    u64 obj;\n+    u64 res;\n+    u64 res2;\n+  };\n+\n+  const unsigned iocb_cmd_pread = 0;\n+  const unsigned iocb_cmd_pwrite = 1;\n+  const unsigned iocb_cmd_preadv = 7;\n+  const unsigned iocb_cmd_pwritev = 8;\n+\n   struct __sanitizer___sysctl_args {\n     int *name;\n     int nlen;\n@@ -80,8 +131,55 @@ namespace __sanitizer {\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n   extern unsigned struct_rlimit64_sz;\n-  extern unsigned struct_statfs64_sz;\n-#endif // SANITIZER_LINUX && !SANITIZER_ANDROID\n+  extern unsigned struct_statvfs_sz;\n+  extern unsigned struct_statvfs64_sz;\n+\n+  struct __sanitizer_ipc_perm {\n+    int __key;\n+    int uid;\n+    int gid;\n+    int cuid;\n+    int cgid;\n+#ifdef __powerpc64__\n+    unsigned mode;\n+    unsigned __seq;\n+#else\n+    unsigned short mode;\n+    unsigned short __pad1;\n+    unsigned short __seq;\n+    unsigned short __pad2;\n+#endif\n+    uptr __unused1;\n+    uptr __unused2;\n+  };\n+\n+  struct __sanitizer_shmid_ds {\n+    __sanitizer_ipc_perm shm_perm;\n+  #ifndef __powerpc__\n+    uptr shm_segsz;\n+  #endif\n+    uptr shm_atime;\n+  #ifndef _LP64\n+    uptr __unused1;\n+  #endif\n+    uptr shm_dtime;\n+  #ifndef _LP64\n+    uptr __unused2;\n+  #endif\n+    uptr shm_ctime;\n+  #ifndef _LP64\n+    uptr __unused3;\n+  #endif\n+  #ifdef __powerpc__\n+    uptr shm_segsz;\n+  #endif\n+    int shm_cpid;\n+    int shm_lpid;\n+    uptr shm_nattch;\n+    uptr __unused4;\n+    uptr __unused5;\n+  };\n+  #endif  // SANITIZER_LINUX && !SANITIZER_ANDROID\n \n   struct __sanitizer_iovec {\n     void  *iov_base;\n@@ -94,6 +192,35 @@ namespace __sanitizer {\n   typedef unsigned __sanitizer_pthread_key_t;\n #endif\n \n+  struct __sanitizer_ether_addr {\n+    u8 octet[6];\n+  };\n+\n+  struct __sanitizer_tm {\n+    int tm_sec;\n+    int tm_min;\n+    int tm_hour;\n+    int tm_mday;\n+    int tm_mon;\n+    int tm_year;\n+    int tm_wday;\n+    int tm_yday;\n+    int tm_isdst;\n+    long int tm_gmtoff;\n+    const char *tm_zone;\n+  };\n+\n+#if SANITIZER_LINUX\n+  struct __sanitizer_mntent {\n+    char *mnt_fsname;\n+    char *mnt_dir;\n+    char *mnt_type;\n+    char *mnt_opts;\n+    int mnt_freq;\n+    int mnt_passno;\n+  };\n+#endif\n+\n #if SANITIZER_ANDROID || SANITIZER_MAC\n   struct __sanitizer_msghdr {\n     void *msg_name;\n@@ -158,6 +285,8 @@ namespace __sanitizer {\n   };\n #endif\n \n+  typedef long __sanitizer_clock_t;\n+\n #if SANITIZER_LINUX\n #if defined(_LP64) || defined(__x86_64__)\n   typedef unsigned __sanitizer___kernel_uid_t;\n@@ -168,8 +297,15 @@ namespace __sanitizer {\n   typedef unsigned short __sanitizer___kernel_gid_t;\n   typedef long __sanitizer___kernel_off_t;\n #endif\n+\n+#if defined(__powerpc64__)\n+  typedef unsigned int __sanitizer___kernel_old_uid_t;\n+  typedef unsigned int __sanitizer___kernel_old_gid_t;\n+#else\n   typedef unsigned short __sanitizer___kernel_old_uid_t;\n   typedef unsigned short __sanitizer___kernel_old_gid_t;\n+#endif\n+\n   typedef long long __sanitizer___kernel_loff_t;\n   typedef struct {\n     unsigned long fds_bits[1024 / (8 * sizeof(long))];\n@@ -207,6 +343,20 @@ namespace __sanitizer {\n #endif\n   };\n \n+  struct __sanitizer_kernel_sigset_t {\n+    u8 sig[8];\n+  };\n+\n+  struct __sanitizer_kernel_sigaction_t {\n+    union {\n+      void (*sigaction)(int signo, void *info, void *ctx);\n+      void (*handler)(int signo);\n+    };\n+    unsigned long sa_flags;\n+    void (*sa_restorer)(void);\n+    __sanitizer_kernel_sigset_t sa_mask;\n+  };\n+\n   extern uptr sig_ign;\n   extern uptr sig_dfl;\n   extern uptr sa_siginfo;\n@@ -297,6 +447,9 @@ namespace __sanitizer {\n   extern unsigned struct_user_fpregs_struct_sz;\n   extern unsigned struct_user_fpxregs_struct_sz;\n \n+  extern int ptrace_peektext;\n+  extern int ptrace_peekdata;\n+  extern int ptrace_peekuser;\n   extern int ptrace_getregs;\n   extern int ptrace_setregs;\n   extern int ptrace_getfpregs;\n@@ -309,6 +462,15 @@ namespace __sanitizer {\n   extern int ptrace_setregset;\n #endif\n \n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+  extern unsigned struct_shminfo_sz;\n+  extern unsigned struct_shm_info_sz;\n+  extern int shmctl_ipc_stat;\n+  extern int shmctl_ipc_info;\n+  extern int shmctl_shm_info;\n+  extern int shmctl_shm_stat;\n+#endif\n+\n   // ioctl arguments\n   struct __sanitizer_ifconf {\n     int ifc_len;\n@@ -390,7 +552,7 @@ namespace __sanitizer {\n   extern unsigned struct_unimapinit_sz;\n #endif\n \n-#if !SANITIZER_ANDROID\n+#if !SANITIZER_ANDROID && !SANITIZER_MAC\n   extern unsigned struct_sioc_sg_req_sz;\n   extern unsigned struct_sioc_vif_req_sz;\n #endif\n@@ -445,7 +607,7 @@ namespace __sanitizer {\n   extern unsigned IOCTL_TIOCSPGRP;\n   extern unsigned IOCTL_TIOCSTI;\n   extern unsigned IOCTL_TIOCSWINSZ;\n-#if (SANITIZER_LINUX && !SANITIZER_ANDROID) || SANITIZER_MAC\n+#if (SANITIZER_LINUX && !SANITIZER_ANDROID)\n   extern unsigned IOCTL_SIOCGETSGCNT;\n   extern unsigned IOCTL_SIOCGETVIFCNT;\n #endif\n@@ -807,6 +969,25 @@ namespace __sanitizer {\n   extern unsigned IOCTL_TIOCSERSETMULTI;\n   extern unsigned IOCTL_TIOCSSERIAL;\n #endif\n+\n+  extern const int errno_EOWNERDEAD;\n }  // namespace __sanitizer\n \n+#define CHECK_TYPE_SIZE(TYPE) \\\n+  COMPILER_CHECK(sizeof(__sanitizer_##TYPE) == sizeof(TYPE))\n+\n+#define CHECK_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n+  COMPILER_CHECK(sizeof(((__sanitizer_##CLASS *) NULL)->MEMBER) == \\\n+                 sizeof(((CLASS *) NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(__sanitizer_##CLASS, MEMBER) ==          \\\n+                 offsetof(CLASS, MEMBER))\n+\n+// For sigaction, which is a function and struct at the same time,\n+// and thus requires explicit \"struct\" in sizeof() expression.\n+#define CHECK_STRUCT_SIZE_AND_OFFSET(CLASS, MEMBER)                       \\\n+  COMPILER_CHECK(sizeof(((struct __sanitizer_##CLASS *) NULL)->MEMBER) == \\\n+                 sizeof(((struct CLASS *) NULL)->MEMBER));                \\\n+  COMPILER_CHECK(offsetof(struct __sanitizer_##CLASS, MEMBER) ==          \\\n+                 offsetof(struct CLASS, MEMBER))\n+\n #endif"}, {"sha": "ae782ac39cbc0c673d3d1aa01696329f868562ed", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -87,28 +87,6 @@ int internal_isatty(fd_t fd) {\n   return isatty(fd);\n }\n \n-#ifndef SANITIZER_GO\n-void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp,\n-                   uptr stack_top, uptr stack_bottom, bool fast) {\n-#if !SANITIZER_CAN_FAST_UNWIND\n-  fast = false;\n-#endif\n-#if SANITIZER_MAC\n-  // Always unwind fast on Mac.\n-  (void)fast;\n-#else\n-  if (!fast)\n-    return stack->SlowUnwindStack(pc, max_s);\n-#endif  // SANITIZER_MAC\n-  stack->size = 0;\n-  stack->trace[0] = pc;\n-  if (max_s > 1) {\n-    stack->max_size = max_s;\n-    stack->FastUnwindStack(pc, bp, stack_top, stack_bottom);\n-  }\n-}\n-#endif  // SANITIZER_GO\n-\n }  // namespace __sanitizer\n \n #endif"}, {"sha": "08951c7e24733c8c0b0bcd849a128bf633eddc8f", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -193,17 +193,22 @@ void SetPrintfAndReportCallback(void (*callback)(const char *)) {\n   PrintfAndReportCallback = callback;\n }\n \n-#if SANITIZER_SUPPORTS_WEAK_HOOKS\n // Can be overriden in frontend.\n+#if SANITIZER_SUPPORTS_WEAK_HOOKS\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void OnPrint(const char *str) {\n+  (void)str;\n+}\n+#elif defined(SANITIZER_GO) && defined(TSAN_EXTERNAL_HOOKS)\n void OnPrint(const char *str);\n+#else\n+void OnPrint(const char *str) {\n+  (void)str;\n+}\n #endif\n \n static void CallPrintfAndReportCallback(const char *str) {\n-#if SANITIZER_SUPPORTS_WEAK_HOOKS\n-  if (&OnPrint != NULL)\n-    OnPrint(str);\n-#endif\n+  OnPrint(str);\n   if (PrintfAndReportCallback)\n     PrintfAndReportCallback(str);\n }\n@@ -287,4 +292,13 @@ int internal_snprintf(char *buffer, uptr length, const char *format, ...) {\n   return needed_length;\n }\n \n+void InternalScopedString::append(const char *format, ...) {\n+  CHECK_LT(length_, size());\n+  va_list args;\n+  va_start(args, format);\n+  VSNPrintf(data() + length_, size() - length_, format, args);\n+  va_end(args);\n+  length_ += internal_strlen(data() + length_);\n+}\n+\n }  // namespace __sanitizer"}, {"sha": "1e8d056a187c45037bc842fd7f45ac7b8f3d1b2b", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -24,13 +24,15 @@ namespace __sanitizer {\n template<typename Node> class QuarantineCache;\n \n struct QuarantineBatch {\n-  static const uptr kSize = 1024;\n+  static const uptr kSize = 1021;\n   QuarantineBatch *next;\n   uptr size;\n   uptr count;\n   void *batch[kSize];\n };\n \n+COMPILER_CHECK(sizeof(QuarantineBatch) <= (1 << 13));  // 8Kb.\n+\n // The callback interface is:\n // void Callback::Recycle(Node *ptr);\n // void *cb.Allocate(uptr size);\n@@ -121,8 +123,10 @@ class QuarantineCache {\n   }\n \n   void Enqueue(Callback cb, void *ptr, uptr size) {\n-    if (list_.empty() || list_.back()->count == QuarantineBatch::kSize)\n+    if (list_.empty() || list_.back()->count == QuarantineBatch::kSize) {\n       AllocBatch(cb);\n+      size += sizeof(QuarantineBatch);  // Count the batch in Quarantine size.\n+    }\n     QuarantineBatch *b = list_.back();\n     b->batch[b->count++] = ptr;\n     b->size += size;\n@@ -145,9 +149,7 @@ class QuarantineCache {\n       return 0;\n     QuarantineBatch *b = list_.front();\n     list_.pop_front();\n-    // FIXME: should probably add SizeSub method?\n-    // See https://code.google.com/p/thread-sanitizer/issues/detail?id=20\n-    SizeAdd(0 - b->size);\n+    SizeSub(b->size);\n     return b;\n   }\n \n@@ -158,6 +160,9 @@ class QuarantineCache {\n   void SizeAdd(uptr add) {\n     atomic_store(&size_, Size() + add, memory_order_relaxed);\n   }\n+  void SizeSub(uptr sub) {\n+    atomic_store(&size_, Size() - sub, memory_order_relaxed);\n+  }\n \n   NOINLINE QuarantineBatch* AllocBatch(Callback cb) {\n     QuarantineBatch *b = (QuarantineBatch *)cb.Allocate(sizeof(*b));"}, {"sha": "3a9e902537ac9bf261c47987f7f86a493cf9ca42", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 54, "deletions": 150, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -10,21 +10,13 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n #include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n-const char *StripPathPrefix(const char *filepath,\n-                            const char *strip_file_prefix) {\n-  if (filepath == 0) return 0;\n-  const char *prefix_beg = internal_strstr(filepath, strip_file_prefix);\n-  if (prefix_beg)\n-    return prefix_beg + internal_strlen(strip_file_prefix);\n-  return filepath;\n-}\n \n-// ----------------------- StackTrace ----------------------------- {{{1\n uptr StackTrace::GetPreviousInstructionPc(uptr pc) {\n #ifdef __arm__\n   // Cancel Thumb bit.\n@@ -40,32 +32,21 @@ uptr StackTrace::GetPreviousInstructionPc(uptr pc) {\n #endif\n }\n \n-static void PrintStackFramePrefix(uptr frame_num, uptr pc) {\n-  Printf(\"    #%zu 0x%zx\", frame_num, pc);\n-}\n-\n-static void PrintSourceLocation(const char *file, int line, int column,\n-                                const char *strip_file_prefix) {\n-  CHECK(file);\n-  Printf(\" %s\", StripPathPrefix(file, strip_file_prefix));\n-  if (line > 0) {\n-    Printf(\":%d\", line);\n-    if (column > 0)\n-      Printf(\":%d\", column);\n-  }\n-}\n-\n-static void PrintModuleAndOffset(const char *module, uptr offset,\n-                                 const char *strip_file_prefix) {\n-  Printf(\" (%s+0x%zx)\", StripPathPrefix(module, strip_file_prefix), offset);\n+static void PrintStackFramePrefix(InternalScopedString *buffer, uptr frame_num,\n+                                  uptr pc) {\n+  buffer->append(\"    #%zu 0x%zx\", frame_num, pc);\n }\n \n void StackTrace::PrintStack(const uptr *addr, uptr size,\n-                            bool symbolize, const char *strip_file_prefix,\n-                            SymbolizeCallback symbolize_callback ) {\n+                            SymbolizeCallback symbolize_callback) {\n+  if (addr == 0 || size == 0) {\n+    Printf(\"    <empty stack>\\n\\n\");\n+    return;\n+  }\n   MemoryMappingLayout proc_maps(/*cache_enabled*/true);\n   InternalScopedBuffer<char> buff(GetPageSizeCached() * 2);\n   InternalScopedBuffer<AddressInfo> addr_frames(64);\n+  InternalScopedString frame_desc(GetPageSizeCached() * 2);\n   uptr frame_num = 0;\n   for (uptr i = 0; i < size && addr[i]; i++) {\n     // PCs in stack traces are actually the return addresses, that is,\n@@ -76,59 +57,74 @@ void StackTrace::PrintStack(const uptr *addr, uptr size,\n     if (symbolize_callback) {\n       if (symbolize_callback((void*)pc, buff.data(), buff.size())) {\n         addr_frames_num = 1;\n-        PrintStackFramePrefix(frame_num, pc);\n+        frame_desc.clear();\n+        PrintStackFramePrefix(&frame_desc, frame_num, pc);\n         // We can't know anything about the string returned by external\n         // symbolizer, but if it starts with filename, try to strip path prefix\n         // from it.\n-        Printf(\" %s\\n\", StripPathPrefix(buff.data(), strip_file_prefix));\n+        frame_desc.append(\n+            \" %s\",\n+            StripPathPrefix(buff.data(), common_flags()->strip_path_prefix));\n+        Printf(\"%s\\n\", frame_desc.data());\n         frame_num++;\n       }\n     }\n-    if (symbolize && addr_frames_num == 0 && &getSymbolizer) {\n+    if (common_flags()->symbolize && addr_frames_num == 0) {\n       // Use our own (online) symbolizer, if necessary.\n-      addr_frames_num = getSymbolizer()->SymbolizeCode(\n-          pc, addr_frames.data(), addr_frames.size());\n+      if (Symbolizer *sym = Symbolizer::GetOrNull())\n+        addr_frames_num =\n+            sym->SymbolizeCode(pc, addr_frames.data(), addr_frames.size());\n       for (uptr j = 0; j < addr_frames_num; j++) {\n         AddressInfo &info = addr_frames[j];\n-        PrintStackFramePrefix(frame_num, pc);\n+        frame_desc.clear();\n+        PrintStackFramePrefix(&frame_desc, frame_num, pc);\n         if (info.function) {\n-          Printf(\" in %s\", info.function);\n+          frame_desc.append(\" in %s\", info.function);\n         }\n         if (info.file) {\n-          PrintSourceLocation(info.file, info.line, info.column,\n-                              strip_file_prefix);\n+          frame_desc.append(\" \");\n+          PrintSourceLocation(&frame_desc, info.file, info.line, info.column);\n         } else if (info.module) {\n-          PrintModuleAndOffset(info.module, info.module_offset,\n-                               strip_file_prefix);\n+          frame_desc.append(\" \");\n+          PrintModuleAndOffset(&frame_desc, info.module, info.module_offset);\n         }\n-        Printf(\"\\n\");\n-        info.Clear();\n+        Printf(\"%s\\n\", frame_desc.data());\n         frame_num++;\n+        info.Clear();\n       }\n     }\n     if (addr_frames_num == 0) {\n       // If online symbolization failed, try to output at least module and\n       // offset for instruction.\n-      PrintStackFramePrefix(frame_num, pc);\n+      frame_desc.clear();\n+      PrintStackFramePrefix(&frame_desc, frame_num, pc);\n       uptr offset;\n       if (proc_maps.GetObjectNameAndOffset(pc, &offset,\n                                            buff.data(), buff.size(),\n                                            /* protection */0)) {\n-        PrintModuleAndOffset(buff.data(), offset, strip_file_prefix);\n+        frame_desc.append(\" \");\n+        PrintModuleAndOffset(&frame_desc, buff.data(), offset);\n       }\n-      Printf(\"\\n\");\n+      Printf(\"%s\\n\", frame_desc.data());\n       frame_num++;\n     }\n   }\n+  // Always print a trailing empty line after stack trace.\n+  Printf(\"\\n\");\n }\n \n uptr StackTrace::GetCurrentPc() {\n   return GET_CALLER_PC();\n }\n \n void StackTrace::FastUnwindStack(uptr pc, uptr bp,\n-                                 uptr stack_top, uptr stack_bottom) {\n-  CHECK(size == 0 && trace[0] == pc);\n+                                 uptr stack_top, uptr stack_bottom,\n+                                 uptr max_depth) {\n+  if (max_depth == 0) {\n+    size = 0;\n+    return;\n+  }\n+  trace[0] = pc;\n   size = 1;\n   uhwptr *frame = (uhwptr *)bp;\n   uhwptr *prev_frame = frame - 1;\n@@ -138,7 +134,7 @@ void StackTrace::FastUnwindStack(uptr pc, uptr bp,\n          frame < (uhwptr *)stack_top - 2 &&\n          frame > (uhwptr *)stack_bottom &&\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n-         size < max_size) {\n+         size < max_depth) {\n     uhwptr pc1 = frame[1];\n     if (pc1 != pc) {\n       trace[size++] = (uptr) pc1;\n@@ -156,111 +152,19 @@ void StackTrace::PopStackFrames(uptr count) {\n   }\n }\n \n-// On 32-bits we don't compress stack traces.\n-// On 64-bits we compress stack traces: if a given pc differes slightly from\n-// the previous one, we record a 31-bit offset instead of the full pc.\n-SANITIZER_INTERFACE_ATTRIBUTE\n-uptr StackTrace::CompressStack(StackTrace *stack, u32 *compressed, uptr size) {\n-#if SANITIZER_WORDSIZE == 32\n-  // Don't compress, just copy.\n-  uptr res = 0;\n-  for (uptr i = 0; i < stack->size && i < size; i++) {\n-    compressed[i] = stack->trace[i];\n-    res++;\n-  }\n-  if (stack->size < size)\n-    compressed[stack->size] = 0;\n-#else  // 64 bits, compress.\n-  uptr prev_pc = 0;\n-  const uptr kMaxOffset = (1ULL << 30) - 1;\n-  uptr c_index = 0;\n-  uptr res = 0;\n-  for (uptr i = 0, n = stack->size; i < n; i++) {\n-    uptr pc = stack->trace[i];\n-    if (!pc) break;\n-    if ((s64)pc < 0) break;\n-    // Printf(\"C pc[%zu] %zx\\n\", i, pc);\n-    if (prev_pc - pc < kMaxOffset || pc - prev_pc < kMaxOffset) {\n-      uptr offset = (s64)(pc - prev_pc);\n-      offset |= (1U << 31);\n-      if (c_index >= size) break;\n-      // Printf(\"C co[%zu] offset %zx\\n\", i, offset);\n-      compressed[c_index++] = offset;\n-    } else {\n-      uptr hi = pc >> 32;\n-      uptr lo = (pc << 32) >> 32;\n-      CHECK_EQ((hi & (1 << 31)), 0);\n-      if (c_index + 1 >= size) break;\n-      // Printf(\"C co[%zu] hi/lo: %zx %zx\\n\", c_index, hi, lo);\n-      compressed[c_index++] = hi;\n-      compressed[c_index++] = lo;\n-    }\n-    res++;\n-    prev_pc = pc;\n-  }\n-  if (c_index < size)\n-    compressed[c_index] = 0;\n-  if (c_index + 1 < size)\n-    compressed[c_index + 1] = 0;\n-#endif  // SANITIZER_WORDSIZE\n-\n-  // debug-only code\n-#if 0\n-  StackTrace check_stack;\n-  UncompressStack(&check_stack, compressed, size);\n-  if (res < check_stack.size) {\n-    Printf(\"res %zu check_stack.size %zu; c_size %zu\\n\", res,\n-           check_stack.size, size);\n-  }\n-  // |res| may be greater than check_stack.size, because\n-  // UncompressStack(CompressStack(stack)) eliminates the 0x0 frames.\n-  CHECK(res >= check_stack.size);\n-  CHECK_EQ(0, REAL(memcmp)(check_stack.trace, stack->trace,\n-                          check_stack.size * sizeof(uptr)));\n-#endif\n-\n-  return res;\n+static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {\n+  return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;\n }\n \n-SANITIZER_INTERFACE_ATTRIBUTE\n-void StackTrace::UncompressStack(StackTrace *stack,\n-                                 u32 *compressed, uptr size) {\n-#if SANITIZER_WORDSIZE == 32\n-  // Don't uncompress, just copy.\n-  stack->size = 0;\n-  for (uptr i = 0; i < size && i < kStackTraceMax; i++) {\n-    if (!compressed[i]) break;\n-    stack->size++;\n-    stack->trace[i] = compressed[i];\n-  }\n-#else  // 64 bits, uncompress\n-  uptr prev_pc = 0;\n-  stack->size = 0;\n-  for (uptr i = 0; i < size && stack->size < kStackTraceMax; i++) {\n-    u32 x = compressed[i];\n-    uptr pc = 0;\n-    if (x & (1U << 31)) {\n-      // Printf(\"U co[%zu] offset: %x\\n\", i, x);\n-      // this is an offset\n-      s32 offset = x;\n-      offset = (offset << 1) >> 1;  // remove the 31-byte and sign-extend.\n-      pc = prev_pc + offset;\n-      CHECK(pc);\n-    } else {\n-      // CHECK(i + 1 < size);\n-      if (i + 1 >= size) break;\n-      uptr hi = x;\n-      uptr lo = compressed[i+1];\n-      // Printf(\"U co[%zu] hi/lo: %zx %zx\\n\", i, hi, lo);\n-      i++;\n-      pc = (hi << 32) | lo;\n-      if (!pc) break;\n-    }\n-    // Printf(\"U pc[%zu] %zx\\n\", stack->size, pc);\n-    stack->trace[stack->size++] = pc;\n-    prev_pc = pc;\n+uptr StackTrace::LocatePcInTrace(uptr pc) {\n+  // Use threshold to find PC in stack trace, as PC we want to unwind from may\n+  // slightly differ from return address in the actual unwinded stack trace.\n+  const int kPcThreshold = 192;\n+  for (uptr i = 0; i < size; ++i) {\n+    if (MatchPc(pc, trace[i], kPcThreshold))\n+      return i;\n   }\n-#endif  // SANITIZER_WORDSIZE\n+  return 0;\n }\n \n }  // namespace __sanitizer"}, {"sha": "d06db5ffa7a9dc70da4da1d855cf39c6bc951ec1", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -21,58 +21,55 @@ static const uptr kStackTraceMax = 256;\n     defined(__powerpc__) || defined(__powerpc64__) || \\\n     defined(__sparc__) || \\\n     defined(__mips__))\n-#define SANITIZER_CAN_FAST_UNWIND 0\n+# define SANITIZER_CAN_FAST_UNWIND 0\n+#elif SANITIZER_WINDOWS\n+# define SANITIZER_CAN_FAST_UNWIND 0\n #else\n-#define SANITIZER_CAN_FAST_UNWIND 1\n+# define SANITIZER_CAN_FAST_UNWIND 1\n #endif\n \n struct StackTrace {\n   typedef bool (*SymbolizeCallback)(const void *pc, char *out_buffer,\n                                      int out_size);\n+  uptr top_frame_bp;\n   uptr size;\n-  uptr max_size;\n   uptr trace[kStackTraceMax];\n+\n+  // Prints a symbolized stacktrace, followed by an empty line.\n   static void PrintStack(const uptr *addr, uptr size,\n-                         bool symbolize, const char *strip_file_prefix,\n-                         SymbolizeCallback symbolize_callback);\n-  void CopyTo(uptr *dst, uptr dst_size) {\n-    for (uptr i = 0; i < size && i < dst_size; i++)\n-      dst[i] = trace[i];\n-    for (uptr i = size; i < dst_size; i++)\n-      dst[i] = 0;\n-  }\n+                         SymbolizeCallback symbolize_callback = 0);\n \n-  void CopyFrom(uptr *src, uptr src_size) {\n+  void CopyFrom(const uptr *src, uptr src_size) {\n+    top_frame_bp = 0;\n     size = src_size;\n     if (size > kStackTraceMax) size = kStackTraceMax;\n-    for (uptr i = 0; i < size; i++) {\n+    for (uptr i = 0; i < size; i++)\n       trace[i] = src[i];\n-    }\n   }\n \n-  void FastUnwindStack(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom);\n-  void SlowUnwindStack(uptr pc, uptr max_depth);\n+  static bool WillUseFastUnwind(bool request_fast_unwind) {\n+    // Check if fast unwind is available. Fast unwind is the only option on Mac.\n+    if (!SANITIZER_CAN_FAST_UNWIND)\n+      return false;\n+    else if (SANITIZER_MAC)\n+      return true;\n+    return request_fast_unwind;\n+  }\n \n-  void PopStackFrames(uptr count);\n+  void Unwind(uptr max_depth, uptr pc, uptr bp, uptr stack_top,\n+              uptr stack_bottom, bool request_fast_unwind);\n \n   static uptr GetCurrentPc();\n   static uptr GetPreviousInstructionPc(uptr pc);\n \n-  SANITIZER_INTERFACE_ATTRIBUTE\n-  static uptr CompressStack(StackTrace *stack,\n-                            u32 *compressed, uptr size);\n-  SANITIZER_INTERFACE_ATTRIBUTE\n-  static void UncompressStack(StackTrace *stack,\n-                              u32 *compressed, uptr size);\n+ private:\n+  void FastUnwindStack(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom,\n+                       uptr max_depth);\n+  void SlowUnwindStack(uptr pc, uptr max_depth);\n+  void PopStackFrames(uptr count);\n+  uptr LocatePcInTrace(uptr pc);\n };\n \n-\n-const char *StripPathPrefix(const char *filepath,\n-                            const char *strip_file_prefix);\n-\n-void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp,\n-                   uptr stack_top, uptr stack_bottom, bool fast);\n-\n }  // namespace __sanitizer\n \n // Use this macro if you want to print stack trace with the caller"}, {"sha": "ea2f9d07771d92ddb140c6d08cc25795e41c5ad3", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cc", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,26 @@\n+//===-- sanitizer_stacktrace_libcdep.cc -----------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_stacktrace.h\"\n+\n+namespace __sanitizer {\n+\n+void StackTrace::Unwind(uptr max_depth, uptr pc, uptr bp, uptr stack_top,\n+                        uptr stack_bottom, bool request_fast_unwind) {\n+  if (!WillUseFastUnwind(request_fast_unwind))\n+    SlowUnwindStack(pc, max_depth);\n+  else\n+    FastUnwindStack(pc, bp, stack_top, stack_bottom, max_depth);\n+\n+  top_frame_bp = size ? bp : 0;\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "2b3dd29591e8789c4dcc08e9911300cbf1a65197", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc", "status": "modified", "additions": 59, "deletions": 56, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -16,6 +16,8 @@\n \n #include \"sanitizer_stoptheworld.h\"\n \n+#include \"sanitizer_platform_limits_posix.h\"\n+\n #include <errno.h>\n #include <sched.h> // for CLONE_* definitions\n #include <stddef.h>\n@@ -29,7 +31,16 @@\n #endif\n #include <sys/wait.h> // for signal-related stuff\n \n+#ifdef sa_handler\n+# undef sa_handler\n+#endif\n+\n+#ifdef sa_sigaction\n+# undef sa_sigaction\n+#endif\n+\n #include \"sanitizer_common.h\"\n+#include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_linux.h\"\n #include \"sanitizer_mutex.h\"\n@@ -45,30 +56,14 @@\n // clone() interface (we want to share the address space with the caller\n // process, so we prefer clone() over fork()).\n //\n-// We avoid the use of libc for two reasons:\n+// We don't use any libc functions, relying instead on direct syscalls. There\n+// are two reasons for this:\n // 1. calling a library function while threads are suspended could cause a\n // deadlock, if one of the treads happens to be holding a libc lock;\n // 2. it's generally not safe to call libc functions from the tracer task,\n // because clone() does not set up a thread-local storage for it. Any\n // thread-local variables used by libc will be shared between the tracer task\n // and the thread which spawned it.\n-//\n-// We deal with this by replacing libc calls with calls to our own\n-// implementations defined in sanitizer_libc.h and sanitizer_linux.h. However,\n-// there are still some libc functions which are used here:\n-//\n-// * All of the system calls ultimately go through the libc syscall() function.\n-// We're operating under the assumption that syscall()'s implementation does\n-// not acquire any locks or use any thread-local data (except for the errno\n-// variable, which we handle separately).\n-//\n-// * We lack custom implementations of sigfillset() and sigaction(), so we use\n-// the libc versions instead. The same assumptions as above apply.\n-//\n-// * It is safe to call libc functions before the cloned thread is spawned or\n-// after it has exited. The following functions are used in this manner:\n-// sigdelset()\n-// sigprocmask()\n \n COMPILER_CHECK(sizeof(SuspendedThreadID) == sizeof(pid_t));\n \n@@ -103,10 +98,11 @@ bool ThreadSuspender::SuspendThread(SuspendedThreadID thread_id) {\n                        &pterrno)) {\n     // Either the thread is dead, or something prevented us from attaching.\n     // Log this event and move on.\n-    Report(\"Could not attach to thread %d (errno %d).\\n\", thread_id, pterrno);\n+    if (common_flags()->verbosity)\n+      Report(\"Could not attach to thread %d (errno %d).\\n\", thread_id, pterrno);\n     return false;\n   } else {\n-    if (SanitizerVerbosity > 0)\n+    if (common_flags()->verbosity)\n       Report(\"Attached to thread %d.\\n\", thread_id);\n     // The thread is not guaranteed to stop before ptrace returns, so we must\n     // wait on it.\n@@ -116,8 +112,9 @@ bool ThreadSuspender::SuspendThread(SuspendedThreadID thread_id) {\n     if (internal_iserror(waitpid_status, &wperrno)) {\n       // Got a ECHILD error. I don't think this situation is possible, but it\n       // doesn't hurt to report it.\n-      Report(\"Waiting on thread %d failed, detaching (errno %d).\\n\", thread_id,\n-             wperrno);\n+      if (common_flags()->verbosity)\n+        Report(\"Waiting on thread %d failed, detaching (errno %d).\\n\",\n+            thread_id, wperrno);\n       internal_ptrace(PTRACE_DETACH, thread_id, NULL, NULL);\n       return false;\n     }\n@@ -132,13 +129,14 @@ void ThreadSuspender::ResumeAllThreads() {\n     int pterrno;\n     if (!internal_iserror(internal_ptrace(PTRACE_DETACH, tid, NULL, NULL),\n                           &pterrno)) {\n-      if (SanitizerVerbosity > 0)\n+      if (common_flags()->verbosity)\n         Report(\"Detached from thread %d.\\n\", tid);\n     } else {\n       // Either the thread is dead, or we are already detached.\n       // The latter case is possible, for instance, if this function was called\n       // from a signal handler.\n-      Report(\"Could not detach from thread %d (errno %d).\\n\", tid, pterrno);\n+      if (common_flags()->verbosity)\n+        Report(\"Could not detach from thread %d (errno %d).\\n\", tid, pterrno);\n     }\n   }\n }\n@@ -183,15 +181,16 @@ static const int kUnblockedSignals[] = { SIGABRT, SIGILL, SIGFPE, SIGSEGV,\n struct TracerThreadArgument {\n   StopTheWorldCallback callback;\n   void *callback_argument;\n-  // The tracer thread waits on this mutex while the parent finished its\n+  // The tracer thread waits on this mutex while the parent finishes its\n   // preparations.\n   BlockingMutex mutex;\n+  uptr parent_pid;\n };\n \n static DieCallbackType old_die_callback;\n \n // Signal handler to wake up suspended threads when the tracer thread dies.\n-void TracerThreadSignalHandler(int signum, siginfo_t *siginfo, void *) {\n+void TracerThreadSignalHandler(int signum, void *siginfo, void *) {\n   if (thread_suspender_instance != NULL) {\n     if (signum == SIGABRT)\n       thread_suspender_instance->KillAllThreads();\n@@ -222,6 +221,11 @@ static int TracerThread(void* argument) {\n   TracerThreadArgument *tracer_thread_argument =\n       (TracerThreadArgument *)argument;\n \n+  internal_prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n+  // Check if parent is already dead.\n+  if (internal_getppid() != tracer_thread_argument->parent_pid)\n+    internal__exit(4);\n+\n   // Wait for the parent thread to finish preparations.\n   tracer_thread_argument->mutex.Lock();\n   tracer_thread_argument->mutex.Unlock();\n@@ -244,17 +248,18 @@ static int TracerThread(void* argument) {\n   // the mask we inherited from the caller thread.\n   for (uptr signal_index = 0; signal_index < ARRAY_SIZE(kUnblockedSignals);\n        signal_index++) {\n-    struct sigaction new_sigaction;\n+    __sanitizer_kernel_sigaction_t new_sigaction;\n     internal_memset(&new_sigaction, 0, sizeof(new_sigaction));\n-    new_sigaction.sa_sigaction = TracerThreadSignalHandler;\n+    new_sigaction.sigaction = TracerThreadSignalHandler;\n     new_sigaction.sa_flags = SA_ONSTACK | SA_SIGINFO;\n-    sigfillset(&new_sigaction.sa_mask);\n-    sigaction(kUnblockedSignals[signal_index], &new_sigaction, NULL);\n+    internal_sigfillset(&new_sigaction.sa_mask);\n+    internal_sigaction(kUnblockedSignals[signal_index], &new_sigaction, NULL);\n   }\n \n   int exit_code = 0;\n   if (!thread_suspender.SuspendAllThreads()) {\n-    Report(\"Failed suspending threads.\\n\");\n+    if (common_flags()->verbosity)\n+      Report(\"Failed suspending threads.\\n\");\n     exit_code = 3;\n   } else {\n     tracer_thread_argument->callback(thread_suspender.suspended_threads_list(),\n@@ -292,44 +297,36 @@ class ScopedStackSpaceWithGuard {\n   uptr guard_start_;\n };\n \n-NOINLINE static void WipeStack() {\n-  char arr[256];\n-  internal_memset(arr, 0, sizeof(arr));\n-}\n-\n // We have a limitation on the stack frame size, so some stuff had to be moved\n // into globals.\n-static sigset_t blocked_sigset;\n-static sigset_t old_sigset;\n-static struct sigaction old_sigactions[ARRAY_SIZE(kUnblockedSignals)];\n+static __sanitizer_kernel_sigset_t blocked_sigset;\n+static __sanitizer_kernel_sigset_t old_sigset;\n+static __sanitizer_kernel_sigaction_t old_sigactions\n+    [ARRAY_SIZE(kUnblockedSignals)];\n \n class StopTheWorldScope {\n  public:\n   StopTheWorldScope() {\n-    // Glibc's sigaction() has a side-effect where it copies garbage stack\n-    // values into oldact, which can cause false negatives in LSan. As a quick\n-    // workaround we zero some stack space here.\n-    WipeStack();\n     // Block all signals that can be blocked safely, and install\n     // default handlers for the remaining signals.\n     // We cannot allow user-defined handlers to run while the ThreadSuspender\n     // thread is active, because they could conceivably call some libc functions\n     // which modify errno (which is shared between the two threads).\n-    sigfillset(&blocked_sigset);\n+    internal_sigfillset(&blocked_sigset);\n     for (uptr signal_index = 0; signal_index < ARRAY_SIZE(kUnblockedSignals);\n          signal_index++) {\n       // Remove the signal from the set of blocked signals.\n-      sigdelset(&blocked_sigset, kUnblockedSignals[signal_index]);\n+      internal_sigdelset(&blocked_sigset, kUnblockedSignals[signal_index]);\n       // Install the default handler.\n-      struct sigaction new_sigaction;\n+      __sanitizer_kernel_sigaction_t new_sigaction;\n       internal_memset(&new_sigaction, 0, sizeof(new_sigaction));\n-      new_sigaction.sa_handler = SIG_DFL;\n-      sigfillset(&new_sigaction.sa_mask);\n-      sigaction(kUnblockedSignals[signal_index], &new_sigaction,\n+      new_sigaction.handler = SIG_DFL;\n+      internal_sigfillset(&new_sigaction.sa_mask);\n+      internal_sigaction(kUnblockedSignals[signal_index], &new_sigaction,\n                       &old_sigactions[signal_index]);\n     }\n     int sigprocmask_status =\n-        sigprocmask(SIG_BLOCK, &blocked_sigset, &old_sigset);\n+        internal_sigprocmask(SIG_BLOCK, &blocked_sigset, &old_sigset);\n     CHECK_EQ(sigprocmask_status, 0); // sigprocmask should never fail\n     // Make this process dumpable. Processes that are not dumpable cannot be\n     // attached to.\n@@ -347,10 +344,10 @@ class StopTheWorldScope {\n     // Restore the signal handlers.\n     for (uptr signal_index = 0; signal_index < ARRAY_SIZE(kUnblockedSignals);\n          signal_index++) {\n-      sigaction(kUnblockedSignals[signal_index],\n+      internal_sigaction(kUnblockedSignals[signal_index],\n                 &old_sigactions[signal_index], NULL);\n     }\n-    sigprocmask(SIG_SETMASK, &old_sigset, &old_sigset);\n+    internal_sigprocmask(SIG_SETMASK, &old_sigset, &old_sigset);\n   }\n \n  private:\n@@ -363,6 +360,7 @@ void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n   struct TracerThreadArgument tracer_thread_argument;\n   tracer_thread_argument.callback = callback;\n   tracer_thread_argument.callback_argument = argument;\n+  tracer_thread_argument.parent_pid = internal_getpid();\n   const uptr kTracerStackSize = 2 * 1024 * 1024;\n   ScopedStackSpaceWithGuard tracer_stack(kTracerStackSize);\n   // Block the execution of TracerThread until after we have set ptrace\n@@ -375,7 +373,8 @@ void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n       /* child_tidptr */);\n   int local_errno = 0;\n   if (internal_iserror(tracer_pid, &local_errno)) {\n-    Report(\"Failed spawning a tracer thread (errno %d).\\n\", local_errno);\n+    if (common_flags()->verbosity)\n+      Report(\"Failed spawning a tracer thread (errno %d).\\n\", local_errno);\n     tracer_thread_argument.mutex.Unlock();\n   } else {\n     // On some systems we have to explicitly declare that we want to be traced\n@@ -390,8 +389,11 @@ void StopTheWorld(StopTheWorldCallback callback, void *argument) {\n     // At this point, any signal will either be blocked or kill us, so waitpid\n     // should never return (and set errno) while the tracer thread is alive.\n     uptr waitpid_status = internal_waitpid(tracer_pid, NULL, __WALL);\n-    if (internal_iserror(waitpid_status, &local_errno))\n-      Report(\"Waiting on the tracer thread failed (errno %d).\\n\", local_errno);\n+    if (internal_iserror(waitpid_status, &local_errno)) {\n+      if (common_flags()->verbosity)\n+        Report(\"Waiting on the tracer thread failed (errno %d).\\n\",\n+            local_errno);\n+    }\n   }\n }\n \n@@ -432,7 +434,8 @@ int SuspendedThreadsList::GetRegistersAndSP(uptr index,\n   int pterrno;\n   if (internal_iserror(internal_ptrace(PTRACE_GETREGS, tid, NULL, &regs),\n                        &pterrno)) {\n-    Report(\"Could not get registers from thread %d (errno %d).\\n\",\n+    if (common_flags()->verbosity)\n+      Report(\"Could not get registers from thread %d (errno %d).\\n\",\n            tid, pterrno);\n     return -1;\n   }"}, {"sha": "14f13e620815290988108001ed27c9d891340e8f", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -18,7 +18,7 @@\n namespace __sanitizer {\n \n static const char *const kTypeStrings[SuppressionTypeCount] = {\n-  \"none\", \"race\", \"mutex\", \"thread\", \"signal\", \"leak\"\n+  \"none\", \"race\", \"mutex\", \"thread\", \"signal\", \"leak\", \"called_from_lib\"\n };\n \n bool TemplateMatch(char *templ, const char *str) {\n@@ -127,10 +127,15 @@ void SuppressionContext::Parse(const char *str) {\n   }\n }\n \n-uptr SuppressionContext::SuppressionCount() {\n+uptr SuppressionContext::SuppressionCount() const {\n   return suppressions_.size();\n }\n \n+const Suppression *SuppressionContext::SuppressionAt(uptr i) const {\n+  CHECK_LT(i, suppressions_.size());\n+  return &suppressions_[i];\n+}\n+\n void SuppressionContext::GetMatched(\n     InternalMmapVector<Suppression *> *matched) {\n   for (uptr i = 0; i < suppressions_.size(); i++)"}, {"sha": "b4c719cb1874deffe9c21530c046ee30a97fc32c", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -23,6 +23,7 @@ enum SuppressionType {\n   SuppressionThread,\n   SuppressionSignal,\n   SuppressionLeak,\n+  SuppressionLib,\n   SuppressionTypeCount\n };\n \n@@ -38,7 +39,8 @@ class SuppressionContext {\n   SuppressionContext() : suppressions_(1), can_parse_(true) {}\n   void Parse(const char *str);\n   bool Match(const char* str, SuppressionType type, Suppression **s);\n-  uptr SuppressionCount();\n+  uptr SuppressionCount() const;\n+  const Suppression *SuppressionAt(uptr i) const;\n   void GetMatched(InternalMmapVector<Suppression *> *matched);\n \n  private:\n@@ -50,7 +52,6 @@ class SuppressionContext {\n \n const char *SuppressionTypeString(SuppressionType t);\n \n-// Exposed for testing.\n bool TemplateMatch(char *templ, const char *str);\n \n }  // namespace __sanitizer"}, {"sha": "f417b087ae2e9f4dcca3ef1a603d2f4fe8360715", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,61 @@\n+//===-- sanitizer_symbolizer.cc -------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_symbolizer.h\"\n+\n+namespace __sanitizer {\n+\n+Symbolizer *Symbolizer::symbolizer_;\n+StaticSpinMutex Symbolizer::init_mu_;\n+LowLevelAllocator Symbolizer::symbolizer_allocator_;\n+\n+Symbolizer *Symbolizer::GetOrNull() {\n+  SpinMutexLock l(&init_mu_);\n+  return symbolizer_;\n+}\n+\n+Symbolizer *Symbolizer::Get() {\n+  SpinMutexLock l(&init_mu_);\n+  RAW_CHECK_MSG(symbolizer_ != 0, \"Using uninitialized symbolizer!\");\n+  return symbolizer_;\n+}\n+\n+Symbolizer *Symbolizer::Disable() {\n+  CHECK_EQ(0, symbolizer_);\n+  // Initialize a dummy symbolizer.\n+  symbolizer_ = new(symbolizer_allocator_) Symbolizer;\n+  return symbolizer_;\n+}\n+\n+void Symbolizer::AddHooks(Symbolizer::StartSymbolizationHook start_hook,\n+                          Symbolizer::EndSymbolizationHook end_hook) {\n+  CHECK(start_hook_ == 0 && end_hook_ == 0);\n+  start_hook_ = start_hook;\n+  end_hook_ = end_hook;\n+}\n+\n+Symbolizer::Symbolizer() : start_hook_(0), end_hook_(0) {}\n+\n+Symbolizer::SymbolizerScope::SymbolizerScope(const Symbolizer *sym)\n+    : sym_(sym) {\n+  if (sym_->start_hook_)\n+    sym_->start_hook_();\n+}\n+\n+Symbolizer::SymbolizerScope::~SymbolizerScope() {\n+  if (sym_->end_hook_)\n+    sym_->end_hook_();\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "af93de75081bf7ae997e7a5da5d056f02a3c4bf1", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 62, "deletions": 24, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -5,27 +5,21 @@\n //\n //===----------------------------------------------------------------------===//\n //\n-// Symbolizer is intended to be used by both\n-// AddressSanitizer and ThreadSanitizer to symbolize a given\n-// address. It is an analogue of addr2line utility and allows to map\n-// instruction address to a location in source code at run-time.\n+// Symbolizer is used by sanitizers to map instruction address to a location in\n+// source code at run-time. Symbolizer either uses __sanitizer_symbolize_*\n+// defined in the program, or (if they are missing) tries to find and\n+// launch \"llvm-symbolizer\" commandline tool in a separate process and\n+// communicate with it.\n //\n-// Symbolizer is planned to use debug information (in DWARF format)\n-// in a binary via interface defined in \"llvm/DebugInfo/DIContext.h\"\n-//\n-// Symbolizer code should be called from the run-time library of\n-// dynamic tools, and generally should not call memory allocation\n-// routines or other system library functions intercepted by those tools.\n-// Instead, Symbolizer code should use their replacements, defined in\n-// \"compiler-rt/lib/sanitizer_common/sanitizer_libc.h\".\n+// Generally we should try to avoid calling system library functions during\n+// symbolization (and use their replacements from sanitizer_libc.h instead).\n //===----------------------------------------------------------------------===//\n #ifndef SANITIZER_SYMBOLIZER_H\n #define SANITIZER_SYMBOLIZER_H\n \n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n-// WARNING: Do not include system headers here. See details above.\n \n namespace __sanitizer {\n \n@@ -67,8 +61,24 @@ struct DataInfo {\n   uptr size;\n };\n \n-class SymbolizerInterface {\n+class Symbolizer {\n  public:\n+  /// Returns platform-specific implementation of Symbolizer. The symbolizer\n+  /// must be initialized (with init or disable) before calling this function.\n+  static Symbolizer *Get();\n+  /// Returns platform-specific implementation of Symbolizer, or null if not\n+  /// initialized.\n+  static Symbolizer *GetOrNull();\n+  /// Returns platform-specific implementation of Symbolizer.  Will\n+  /// automatically initialize symbolizer as if by calling Init(0) if needed.\n+  static Symbolizer *GetOrInit();\n+  /// Initialize and return the symbolizer, given an optional path to an\n+  /// external symbolizer.  The path argument is only required for legacy\n+  /// reasons as this function will check $PATH for an external symbolizer.  Not\n+  /// thread safe.\n+  static Symbolizer *Init(const char* path_to_external = 0);\n+  /// Initialize the symbolizer in a disabled state.  Not thread safe.\n+  static Symbolizer *Disable();\n   // Fills at most \"max_frames\" elements of \"frames\" with descriptions\n   // for a given address (in all inlined functions). Returns the number\n   // of descriptions actually filled.\n@@ -82,24 +92,52 @@ class SymbolizerInterface {\n   virtual bool IsAvailable() {\n     return false;\n   }\n+  virtual bool IsExternalAvailable() {\n+    return false;\n+  }\n   // Release internal caches (if any).\n   virtual void Flush() {}\n   // Attempts to demangle the provided C++ mangled name.\n   virtual const char *Demangle(const char *name) {\n     return name;\n   }\n   virtual void PrepareForSandboxing() {}\n-  // Starts external symbolizer program in a subprocess. Sanitizer communicates\n-  // with external symbolizer via pipes. If path_to_symbolizer is NULL or empty,\n-  // tries to look for llvm-symbolizer in PATH.\n-  virtual bool InitializeExternal(const char *path_to_symbolizer) {\n-    return false;\n-  }\n-};\n \n-// Returns platform-specific implementation of SymbolizerInterface. It can't be\n-// used from multiple threads simultaneously.\n-SANITIZER_WEAK_ATTRIBUTE SymbolizerInterface *getSymbolizer();\n+  // Allow user to install hooks that would be called before/after Symbolizer\n+  // does the actual file/line info fetching. Specific sanitizers may need this\n+  // to distinguish system library calls made in user code from calls made\n+  // during in-process symbolization.\n+  typedef void (*StartSymbolizationHook)();\n+  typedef void (*EndSymbolizationHook)();\n+  // May be called at most once.\n+  void AddHooks(StartSymbolizationHook start_hook,\n+                EndSymbolizationHook end_hook);\n+\n+ private:\n+  /// Platform-specific function for creating a Symbolizer object.\n+  static Symbolizer *PlatformInit(const char *path_to_external);\n+  /// Create a symbolizer and store it to symbolizer_ without checking if one\n+  /// already exists.  Not thread safe.\n+  static Symbolizer *CreateAndStore(const char *path_to_external);\n+\n+  static Symbolizer *symbolizer_;\n+  static StaticSpinMutex init_mu_;\n+\n+ protected:\n+  Symbolizer();\n+\n+  static LowLevelAllocator symbolizer_allocator_;\n+\n+  StartSymbolizationHook start_hook_;\n+  EndSymbolizationHook end_hook_;\n+  class SymbolizerScope {\n+   public:\n+    explicit SymbolizerScope(const Symbolizer *sym);\n+    ~SymbolizerScope();\n+   private:\n+    const Symbolizer *sym_;\n+  };\n+};\n \n }  // namespace __sanitizer\n "}, {"sha": "5654d1de7d4d9126a04e6da37cbb55ed93dfdb11", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.cc", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,144 @@\n+//===-- sanitizer_symbolizer_libbacktrace.cc ------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+// Libbacktrace implementation of symbolizer parts.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_symbolizer.h\"\n+#include \"sanitizer_symbolizer_libbacktrace.h\"\n+\n+#if SANITIZER_LIBBACKTRACE\n+# include \"backtrace-supported.h\"\n+# if SANITIZER_POSIX && BACKTRACE_SUPPORTED && !BACKTRACE_USES_MALLOC\n+#  include \"backtrace.h\"\n+# else\n+#  define SANITIZER_LIBBACKTRACE 0\n+# endif\n+#endif\n+\n+namespace __sanitizer {\n+\n+#if SANITIZER_LIBBACKTRACE\n+\n+namespace {\n+\n+struct SymbolizeCodeData {\n+  AddressInfo *frames;\n+  uptr n_frames;\n+  uptr max_frames;\n+  const char *module_name;\n+  uptr module_offset;\n+};\n+\n+extern \"C\" {\n+static int SymbolizeCodePCInfoCallback(void *vdata, uintptr_t addr,\n+                                       const char *filename, int lineno,\n+                                       const char *function) {\n+  SymbolizeCodeData *cdata = (SymbolizeCodeData *)vdata;\n+  if (function) {\n+    AddressInfo *info = &cdata->frames[cdata->n_frames++];\n+    info->Clear();\n+    info->FillAddressAndModuleInfo(addr, cdata->module_name,\n+                                   cdata->module_offset);\n+    info->function = internal_strdup(function);\n+    if (filename)\n+      info->file = internal_strdup(filename);\n+    info->line = lineno;\n+    if (cdata->n_frames == cdata->max_frames)\n+      return 1;\n+  }\n+  return 0;\n+}\n+\n+static void SymbolizeCodeCallback(void *vdata, uintptr_t addr,\n+                                  const char *symname, uintptr_t, uintptr_t) {\n+  SymbolizeCodeData *cdata = (SymbolizeCodeData *)vdata;\n+  if (symname) {\n+    AddressInfo *info = &cdata->frames[0];\n+    info->Clear();\n+    info->FillAddressAndModuleInfo(addr, cdata->module_name,\n+                                   cdata->module_offset);\n+    info->function = internal_strdup(symname);\n+    cdata->n_frames = 1;\n+  }\n+}\n+\n+static void SymbolizeDataCallback(void *vdata, uintptr_t, const char *symname,\n+                                  uintptr_t symval, uintptr_t symsize) {\n+  DataInfo *info = (DataInfo *)vdata;\n+  if (symname && symval) {\n+    info->name = internal_strdup(symname);\n+    info->start = symval;\n+    info->size = symsize;\n+  }\n+}\n+\n+static void ErrorCallback(void *, const char *, int) {}\n+}  // extern \"C\"\n+\n+}  // namespace\n+\n+LibbacktraceSymbolizer *LibbacktraceSymbolizer::get(LowLevelAllocator *alloc) {\n+  // State created in backtrace_create_state is leaked.\n+  void *state = (void *)(backtrace_create_state(\"/proc/self/exe\", 0,\n+                                                ErrorCallback, NULL));\n+  if (!state)\n+    return 0;\n+  return new(*alloc) LibbacktraceSymbolizer(state);\n+}\n+\n+uptr LibbacktraceSymbolizer::SymbolizeCode(uptr addr, AddressInfo *frames,\n+                                           uptr max_frames,\n+                                           const char *module_name,\n+                                           uptr module_offset) {\n+  SymbolizeCodeData data;\n+  data.frames = frames;\n+  data.n_frames = 0;\n+  data.max_frames = max_frames;\n+  data.module_name = module_name;\n+  data.module_offset = module_offset;\n+  backtrace_pcinfo((backtrace_state *)state_, addr, SymbolizeCodePCInfoCallback,\n+                   ErrorCallback, &data);\n+  if (data.n_frames)\n+    return data.n_frames;\n+  backtrace_syminfo((backtrace_state *)state_, addr, SymbolizeCodeCallback,\n+                    ErrorCallback, &data);\n+  return data.n_frames;\n+}\n+\n+bool LibbacktraceSymbolizer::SymbolizeData(DataInfo *info) {\n+  backtrace_syminfo((backtrace_state *)state_, info->address,\n+                    SymbolizeDataCallback, ErrorCallback, info);\n+  return true;\n+}\n+\n+#else  // SANITIZER_LIBBACKTRACE\n+\n+LibbacktraceSymbolizer *LibbacktraceSymbolizer::get(LowLevelAllocator *alloc) {\n+  return 0;\n+}\n+\n+uptr LibbacktraceSymbolizer::SymbolizeCode(uptr addr, AddressInfo *frames,\n+                                           uptr max_frames,\n+                                           const char *module_name,\n+                                           uptr module_offset) {\n+  (void)state_;\n+  return 0;\n+}\n+\n+bool LibbacktraceSymbolizer::SymbolizeData(DataInfo *info) {\n+  return false;\n+}\n+\n+#endif  // SANITIZER_LIBBACKTRACE\n+\n+}  // namespace __sanitizer"}, {"sha": "f09cea512689abca0b07235f3024f18b91dd1d59", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.h", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,38 @@\n+//===-- sanitizer_symbolizer_libbacktrace.h -------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+// Header for libbacktrace symbolizer.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_symbolizer.h\"\n+\n+#ifndef SANITIZER_LIBBACKTRACE\n+# define SANITIZER_LIBBACKTRACE 0\n+#endif\n+\n+namespace __sanitizer {\n+\n+class LibbacktraceSymbolizer {\n+ public:\n+  static LibbacktraceSymbolizer *get(LowLevelAllocator *alloc);\n+\n+  uptr SymbolizeCode(uptr addr, AddressInfo *frames, uptr max_frames,\n+                     const char *module_name, uptr module_offset);\n+\n+  bool SymbolizeData(DataInfo *info);\n+\n+ private:\n+  explicit LibbacktraceSymbolizer(void *state) : state_(state) {}\n+\n+  void *state_;  // Leaked.\n+};\n+\n+}  // namespace __sanitizer"}, {"sha": "2d9caaf4e859e2dfee38b248219770c2b8865bf9", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,37 @@\n+//===-- sanitizer_symbolizer_libcdep.cc -----------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_symbolizer.h\"\n+\n+namespace __sanitizer {\n+\n+Symbolizer *Symbolizer::CreateAndStore(const char *path_to_external) {\n+  Symbolizer *platform_symbolizer = PlatformInit(path_to_external);\n+  if (!platform_symbolizer)\n+    return Disable();\n+  symbolizer_ = platform_symbolizer;\n+  return platform_symbolizer;\n+}\n+\n+Symbolizer *Symbolizer::Init(const char *path_to_external) {\n+  CHECK_EQ(0, symbolizer_);\n+  return CreateAndStore(path_to_external);\n+}\n+\n+Symbolizer *Symbolizer::GetOrInit() {\n+  SpinMutexLock l(&init_mu_);\n+  if (symbolizer_ == 0)\n+    return CreateAndStore(0);\n+  return symbolizer_;\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "9f34b64621770a825e84e6d544f49b9749234e1a", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "modified", "additions": 113, "deletions": 95, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -19,6 +19,7 @@\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_procmaps.h\"\n #include \"sanitizer_symbolizer.h\"\n+#include \"sanitizer_symbolizer_libbacktrace.h\"\n \n #include <errno.h>\n #include <stdlib.h>\n@@ -203,19 +204,49 @@ static const char *ExtractUptr(const char *str, const char *delims,\n //   <file_name>:<line_number>:<column_number>\n //   ...\n //   <empty line>\n+// ExternalSymbolizer may not be used from two threads simultaneously.\n class ExternalSymbolizer {\n  public:\n-  ExternalSymbolizer(const char *path, int input_fd, int output_fd)\n+  explicit ExternalSymbolizer(const char *path)\n       : path_(path),\n-        input_fd_(input_fd),\n-        output_fd_(output_fd),\n-        times_restarted_(0) {\n+        input_fd_(kInvalidFd),\n+        output_fd_(kInvalidFd),\n+        times_restarted_(0),\n+        failed_to_start_(false) {\n     CHECK(path_);\n-    CHECK_NE(input_fd_, kInvalidFd);\n-    CHECK_NE(output_fd_, kInvalidFd);\n+    CHECK_NE(path[0], '\\0');\n   }\n \n   char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n+    for (; times_restarted_ < kMaxTimesRestarted; times_restarted_++) {\n+      // Start or restart symbolizer if we failed to send command to it.\n+      if (char *res = SendCommandImpl(is_data, module_name, module_offset))\n+        return res;\n+      Restart();\n+    }\n+    if (!failed_to_start_) {\n+      Report(\"WARNING: Failed to use and restart external symbolizer!\\n\");\n+      failed_to_start_ = true;\n+    }\n+    return 0;\n+  }\n+\n+  void Flush() {\n+  }\n+\n+ private:\n+  bool Restart() {\n+    if (input_fd_ != kInvalidFd)\n+      internal_close(input_fd_);\n+    if (output_fd_ != kInvalidFd)\n+      internal_close(output_fd_);\n+    return StartSymbolizerSubprocess(path_, &input_fd_, &output_fd_);\n+  }\n+\n+  char *SendCommandImpl(bool is_data, const char *module_name,\n+                        uptr module_offset) {\n+    if (input_fd_ == kInvalidFd || output_fd_ == kInvalidFd)\n+      return 0;\n     CHECK(module_name);\n     internal_snprintf(buffer_, kBufferSize, \"%s\\\"%s\\\" 0x%zx\\n\",\n                       is_data ? \"DATA \" : \"\", module_name, module_offset);\n@@ -226,18 +257,6 @@ class ExternalSymbolizer {\n     return buffer_;\n   }\n \n-  bool Restart() {\n-    if (times_restarted_ >= kMaxTimesRestarted) return false;\n-    times_restarted_++;\n-    internal_close(input_fd_);\n-    internal_close(output_fd_);\n-    return StartSymbolizerSubprocess(path_, &input_fd_, &output_fd_);\n-  }\n-\n-  void Flush() {\n-  }\n-\n- private:\n   bool readFromSymbolizer(char *buffer, uptr max_length) {\n     if (max_length == 0)\n       return true;\n@@ -281,10 +300,9 @@ class ExternalSymbolizer {\n \n   static const uptr kMaxTimesRestarted = 5;\n   uptr times_restarted_;\n+  bool failed_to_start_;\n };\n \n-static LowLevelAllocator symbolizer_allocator;  // Linker initialized.\n-\n #if SANITIZER_SUPPORTS_WEAK_HOOKS\n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n@@ -304,11 +322,10 @@ class InternalSymbolizer {\n  public:\n   typedef bool (*SanitizerSymbolizeFn)(const char*, u64, char*, int);\n \n-  static InternalSymbolizer *get() {\n+  static InternalSymbolizer *get(LowLevelAllocator *alloc) {\n     if (__sanitizer_symbolize_code != 0 &&\n         __sanitizer_symbolize_data != 0) {\n-      void *mem = symbolizer_allocator.Allocate(sizeof(InternalSymbolizer));\n-      return new(mem) InternalSymbolizer();\n+      return new(*alloc) InternalSymbolizer();\n     }\n     return 0;\n   }\n@@ -355,7 +372,7 @@ class InternalSymbolizer {\n \n class InternalSymbolizer {\n  public:\n-  static InternalSymbolizer *get() { return 0; }\n+  static InternalSymbolizer *get(LowLevelAllocator *alloc) { return 0; }\n   char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n     return 0;\n   }\n@@ -365,21 +382,36 @@ class InternalSymbolizer {\n \n #endif  // SANITIZER_SUPPORTS_WEAK_HOOKS\n \n-class Symbolizer : public SymbolizerInterface {\n-  // This class has no constructor, as global constructors are forbidden in\n-  // sanitizer_common. It should be linker initialized instead.\n+class POSIXSymbolizer : public Symbolizer {\n  public:\n+  POSIXSymbolizer(ExternalSymbolizer *external_symbolizer,\n+                  InternalSymbolizer *internal_symbolizer,\n+                  LibbacktraceSymbolizer *libbacktrace_symbolizer)\n+      : Symbolizer(),\n+        external_symbolizer_(external_symbolizer),\n+        internal_symbolizer_(internal_symbolizer),\n+        libbacktrace_symbolizer_(libbacktrace_symbolizer) {}\n+\n   uptr SymbolizeCode(uptr addr, AddressInfo *frames, uptr max_frames) {\n+    BlockingMutexLock l(&mu_);\n     if (max_frames == 0)\n       return 0;\n     LoadedModule *module = FindModuleForAddress(addr);\n     if (module == 0)\n       return 0;\n     const char *module_name = module->full_name();\n     uptr module_offset = addr - module->base_address();\n+    // First, try to use libbacktrace symbolizer (if it's available).\n+    if (libbacktrace_symbolizer_ != 0) {\n+      mu_.CheckLocked();\n+      uptr res = libbacktrace_symbolizer_->SymbolizeCode(\n+          addr, frames, max_frames, module_name, module_offset);\n+      if (res > 0)\n+        return res;\n+    }\n     const char *str = SendCommand(false, module_name, module_offset);\n     if (str == 0) {\n-      // External symbolizer was not initialized or failed. Fill only data\n+      // Symbolizer was not initialized or failed. Fill only data\n       // about module name and offset.\n       AddressInfo *info = &frames[0];\n       info->Clear();\n@@ -430,6 +462,7 @@ class Symbolizer : public SymbolizerInterface {\n   }\n \n   bool SymbolizeData(uptr addr, DataInfo *info) {\n+    BlockingMutexLock l(&mu_);\n     LoadedModule *module = FindModuleForAddress(addr);\n     if (module == 0)\n       return false;\n@@ -439,6 +472,11 @@ class Symbolizer : public SymbolizerInterface {\n     info->address = addr;\n     info->module = internal_strdup(module_name);\n     info->module_offset = module_offset;\n+    if (libbacktrace_symbolizer_ != 0) {\n+      mu_.CheckLocked();\n+      if (libbacktrace_symbolizer_->SymbolizeData(info))\n+        return true;\n+    }\n     const char *str = SendCommand(true, module_name, module_offset);\n     if (str == 0)\n       return true;\n@@ -449,84 +487,65 @@ class Symbolizer : public SymbolizerInterface {\n     return true;\n   }\n \n-  bool InitializeExternal(const char *path_to_symbolizer) {\n-    if (!path_to_symbolizer || path_to_symbolizer[0] == '\\0') {\n-      path_to_symbolizer = FindPathToBinary(\"llvm-symbolizer\");\n-      if (!path_to_symbolizer)\n-        return false;\n-    }\n-    int input_fd, output_fd;\n-    if (!StartSymbolizerSubprocess(path_to_symbolizer, &input_fd, &output_fd))\n-      return false;\n-    void *mem = symbolizer_allocator.Allocate(sizeof(ExternalSymbolizer));\n-    external_symbolizer_ = new(mem) ExternalSymbolizer(path_to_symbolizer,\n-                                                       input_fd, output_fd);\n-    return true;\n+  bool IsAvailable() {\n+    return internal_symbolizer_ != 0 || external_symbolizer_ != 0 ||\n+        libbacktrace_symbolizer_ != 0;\n   }\n \n-  bool IsAvailable() {\n-    if (internal_symbolizer_ == 0)\n-      internal_symbolizer_ = InternalSymbolizer::get();\n-    return internal_symbolizer_ || external_symbolizer_;\n+  bool IsExternalAvailable() {\n+    return external_symbolizer_ != 0;\n   }\n \n   void Flush() {\n-    if (internal_symbolizer_)\n+    BlockingMutexLock l(&mu_);\n+    if (internal_symbolizer_ != 0) {\n+      SymbolizerScope sym_scope(this);\n       internal_symbolizer_->Flush();\n-    if (external_symbolizer_)\n+    }\n+    if (external_symbolizer_ != 0)\n       external_symbolizer_->Flush();\n   }\n \n   const char *Demangle(const char *name) {\n-    if (IsAvailable() && internal_symbolizer_ != 0)\n+    BlockingMutexLock l(&mu_);\n+    // Run hooks even if we don't use internal symbolizer, as cxxabi\n+    // demangle may call system functions.\n+    SymbolizerScope sym_scope(this);\n+    if (internal_symbolizer_ != 0)\n       return internal_symbolizer_->Demangle(name);\n     return DemangleCXXABI(name);\n   }\n \n   void PrepareForSandboxing() {\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n+    BlockingMutexLock l(&mu_);\n     // Cache /proc/self/exe on Linux.\n     CacheBinaryName();\n #endif\n   }\n \n  private:\n   char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n+    mu_.CheckLocked();\n     // First, try to use internal symbolizer.\n-    if (!IsAvailable()) {\n-      return 0;\n-    }\n     if (internal_symbolizer_) {\n+      SymbolizerScope sym_scope(this);\n       return internal_symbolizer_->SendCommand(is_data, module_name,\n                                                module_offset);\n     }\n     // Otherwise, fall back to external symbolizer.\n-    if (external_symbolizer_ == 0) {\n-      ReportExternalSymbolizerError(\n-          \"WARNING: Trying to symbolize code, but external \"\n-          \"symbolizer is not initialized!\\n\");\n-      return 0;\n-    }\n-    for (;;) {\n-      char *reply = external_symbolizer_->SendCommand(is_data, module_name,\n-          module_offset);\n-      if (reply)\n-        return reply;\n-      // Try to restart symbolizer subprocess. If we don't succeed, forget\n-      // about it and don't try to use it later.\n-      if (!external_symbolizer_->Restart()) {\n-        ReportExternalSymbolizerError(\n-            \"WARNING: Failed to use and restart external symbolizer!\\n\");\n-        external_symbolizer_ = 0;\n-        return 0;\n-      }\n+    if (external_symbolizer_) {\n+      return external_symbolizer_->SendCommand(is_data, module_name,\n+                                               module_offset);\n     }\n+    return 0;\n   }\n \n   LoadedModule *FindModuleForAddress(uptr address) {\n+    mu_.CheckLocked();\n     bool modules_were_reloaded = false;\n     if (modules_ == 0 || !modules_fresh_) {\n-      modules_ = (LoadedModule*)(symbolizer_allocator.Allocate(\n+      modules_ = (LoadedModule*)(symbolizer_allocator_.Allocate(\n           kMaxNumberOfModuleContexts * sizeof(LoadedModule)));\n       CHECK(modules_);\n       n_modules_ = GetListOfModules(modules_, kMaxNumberOfModuleContexts,\n@@ -553,41 +572,40 @@ class Symbolizer : public SymbolizerInterface {\n     return 0;\n   }\n \n-  void ReportExternalSymbolizerError(const char *msg) {\n-    // Don't use atomics here for now, as SymbolizeCode can't be called\n-    // from multiple threads anyway.\n-    static bool reported;\n-    if (!reported) {\n-      Report(msg);\n-      reported = true;\n-    }\n-  }\n-\n   // 16K loaded modules should be enough for everyone.\n   static const uptr kMaxNumberOfModuleContexts = 1 << 14;\n   LoadedModule *modules_;  // Array of module descriptions is leaked.\n   uptr n_modules_;\n   // If stale, need to reload the modules before looking up addresses.\n   bool modules_fresh_;\n+  BlockingMutex mu_;\n \n-  ExternalSymbolizer *external_symbolizer_;  // Leaked.\n-  InternalSymbolizer *internal_symbolizer_;  // Leaked.\n+  ExternalSymbolizer *external_symbolizer_;        // Leaked.\n+  InternalSymbolizer *const internal_symbolizer_;  // Leaked.\n+  LibbacktraceSymbolizer *libbacktrace_symbolizer_;  // Leaked.\n };\n \n-static ALIGNED(64) char symbolizer_placeholder[sizeof(Symbolizer)];\n-static Symbolizer *symbolizer;\n-\n-SymbolizerInterface *getSymbolizer() {\n-  static atomic_uint8_t initialized;\n-  static StaticSpinMutex init_mu;\n-  if (atomic_load(&initialized, memory_order_acquire) == 0) {\n-    SpinMutexLock l(&init_mu);\n-    if (atomic_load(&initialized, memory_order_relaxed) == 0) {\n-      symbolizer = new(symbolizer_placeholder) Symbolizer();\n-      atomic_store(&initialized, 1, memory_order_release);\n+Symbolizer *Symbolizer::PlatformInit(const char *path_to_external) {\n+  InternalSymbolizer* internal_symbolizer =\n+      InternalSymbolizer::get(&symbolizer_allocator_);\n+  ExternalSymbolizer *external_symbolizer = 0;\n+  LibbacktraceSymbolizer *libbacktrace_symbolizer = 0;\n+\n+  if (!internal_symbolizer) {\n+    libbacktrace_symbolizer =\n+        LibbacktraceSymbolizer::get(&symbolizer_allocator_);\n+    if (!libbacktrace_symbolizer) {\n+      // Find path to llvm-symbolizer if it's not provided.\n+      if (!path_to_external)\n+        path_to_external = FindPathToBinary(\"llvm-symbolizer\");\n+      if (path_to_external && path_to_external[0] != '\\0')\n+        external_symbolizer = new(symbolizer_allocator_)\n+            ExternalSymbolizer(path_to_external);\n     }\n   }\n-  return symbolizer;\n+\n+  return new(symbolizer_allocator_) POSIXSymbolizer(\n+      external_symbolizer, internal_symbolizer, libbacktrace_symbolizer);\n }\n \n }  // namespace __sanitizer"}, {"sha": "446de8af293663f3f4401b52acbe9e2b21b86b62", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -12,16 +12,11 @@\n \n #include \"sanitizer_platform.h\"\n #if SANITIZER_WINDOWS\n-#include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n-static SymbolizerInterface win_symbolizer;  // Linker initialized.\n-\n-SymbolizerInterface *getSymbolizer() {\n-  return &win_symbolizer;\n-}\n+Symbolizer *Symbolizer::PlatformInit(const char *path_to_external) { return 0; }\n \n }  // namespace __sanitizer\n "}, {"sha": "8810c7faa4bf07a70acb303751a0a3053917700b", "filename": "libsanitizer/sanitizer_common/sanitizer_syscall_linux_x86_64.inc", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_syscall_linux_x86_64.inc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -11,31 +11,32 @@\n \n static uptr internal_syscall(u64 nr) {\n   u64 retval;\n-  asm volatile(\"syscall\" : \"=a\"(retval) : \"a\"(nr) : \"rcx\", \"r11\");\n+  asm volatile(\"syscall\" : \"=a\"(retval) : \"a\"(nr) : \"rcx\", \"r11\",\n+               \"memory\", \"cc\");\n   return retval;\n }\n \n template <typename T1>\n static uptr internal_syscall(u64 nr, T1 arg1) {\n   u64 retval;\n   asm volatile(\"syscall\" : \"=a\"(retval) : \"a\"(nr), \"D\"((u64)arg1) :\n-               \"rcx\", \"r11\");\n+               \"rcx\", \"r11\", \"memory\", \"cc\");\n   return retval;\n }\n \n template <typename T1, typename T2>\n static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2) {\n   u64 retval;\n   asm volatile(\"syscall\" : \"=a\"(retval) : \"a\"(nr), \"D\"((u64)arg1),\n-               \"S\"((u64)arg2) : \"rcx\", \"r11\");\n+               \"S\"((u64)arg2) : \"rcx\", \"r11\", \"memory\", \"cc\");\n   return retval;\n }\n \n template <typename T1, typename T2, typename T3>\n static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3) {\n   u64 retval;\n   asm volatile(\"syscall\" : \"=a\"(retval) : \"a\"(nr), \"D\"((u64)arg1),\n-               \"S\"((u64)arg2), \"d\"((u64)arg3) : \"rcx\", \"r11\");\n+               \"S\"((u64)arg2), \"d\"((u64)arg3) : \"rcx\", \"r11\", \"memory\", \"cc\");\n   return retval;\n }\n \n@@ -45,7 +46,7 @@ static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3, T4 arg4) {\n   asm volatile(\"mov %5, %%r10;\"\n                \"syscall\" : \"=a\"(retval) : \"a\"(nr), \"D\"((u64)arg1),\n                \"S\"((u64)arg2), \"d\"((u64)arg3), \"r\"((u64)arg4) :\n-               \"rcx\", \"r11\", \"r10\");\n+               \"rcx\", \"r11\", \"r10\", \"memory\", \"cc\");\n   return retval;\n }\n \n@@ -57,7 +58,7 @@ static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3, T4 arg4,\n                \"mov %6, %%r8;\"\n                \"syscall\" : \"=a\"(retval) : \"a\"(nr), \"D\"((u64)arg1),\n                \"S\"((u64)arg2), \"d\"((u64)arg3), \"r\"((u64)arg4), \"r\"((u64)arg5) :\n-               \"rcx\", \"r11\", \"r10\", \"r8\");\n+               \"rcx\", \"r11\", \"r10\", \"r8\", \"memory\", \"cc\");\n   return retval;\n }\n \n@@ -71,7 +72,8 @@ static uptr internal_syscall(u64 nr, T1 arg1, T2 arg2, T3 arg3, T4 arg4,\n                \"mov %7, %%r9;\"\n                \"syscall\" : \"=a\"(retval) : \"a\"(nr), \"D\"((u64)arg1),\n                \"S\"((u64)arg2), \"d\"((u64)arg3), \"r\"((u64)arg4), \"r\"((u64)arg5),\n-               \"r\"((u64)arg6) : \"rcx\", \"r11\", \"r10\", \"r8\", \"r9\");\n+               \"r\"((u64)arg6) : \"rcx\", \"r11\", \"r10\", \"r8\", \"r9\",\n+               \"memory\", \"cc\");\n   return retval;\n }\n "}, {"sha": "666955f6c9a9178da2b76da82b7ade89cfb49e93", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -198,6 +198,18 @@ void ThreadRegistry::SetThreadName(u32 tid, const char *name) {\n   tctx->SetName(name);\n }\n \n+void ThreadRegistry::SetThreadNameByUserId(uptr user_id, const char *name) {\n+  BlockingMutexLock l(&mtx_);\n+  for (u32 tid = 0; tid < n_contexts_; tid++) {\n+    ThreadContextBase *tctx = threads_[tid];\n+    if (tctx != 0 && tctx->user_id == user_id &&\n+        tctx->status != ThreadStatusInvalid) {\n+      tctx->SetName(name);\n+      return;\n+    }\n+  }\n+}\n+\n void ThreadRegistry::DetachThread(u32 tid) {\n   BlockingMutexLock l(&mtx_);\n   CHECK_LT(tid, n_contexts_);"}, {"sha": "81c270945d3514ec13957e96408ad8082935e046", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -107,6 +107,7 @@ class ThreadRegistry {\n   ThreadContextBase *FindThreadContextByOsIDLocked(uptr os_id);\n \n   void SetThreadName(u32 tid, const char *name);\n+  void SetThreadNameByUserId(uptr user_id, const char *name);\n   void DetachThread(u32 tid);\n   void JoinThread(u32 tid, void *arg);\n   void FinishThread(u32 tid);"}, {"sha": "c48274e36426786e22e4485ac9e4d4f77379ab67", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -213,7 +213,7 @@ u64 NanoTime() {\n \n void Abort() {\n   abort();\n-  _exit(-1);  // abort is not NORETURN on Windows.\n+  internal__exit(-1);  // abort is not NORETURN on Windows.\n }\n \n uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n@@ -303,7 +303,7 @@ uptr internal_sched_yield() {\n }\n \n void internal__exit(int exitcode) {\n-  _exit(exitcode);\n+  ExitProcess(exitcode);\n }\n \n // ---------------------- BlockingMutex ---------------- {{{1\n@@ -374,31 +374,15 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n #endif\n }\n \n-void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp,\n-                   uptr stack_top, uptr stack_bottom, bool fast) {\n-  (void)fast;\n-  (void)stack_top;\n-  (void)stack_bottom;\n-  stack->max_size = max_s;\n-  void *tmp[kStackTraceMax];\n-\n+void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n   // FIXME: CaptureStackBackTrace might be too slow for us.\n   // FIXME: Compare with StackWalk64.\n   // FIXME: Look at LLVMUnhandledExceptionFilter in Signals.inc\n-  uptr cs_ret = CaptureStackBackTrace(1, stack->max_size, tmp, 0);\n-  uptr offset = 0;\n+  size = CaptureStackBackTrace(2, Min(max_depth, kStackTraceMax),\n+                               (void**)trace, 0);\n   // Skip the RTL frames by searching for the PC in the stacktrace.\n-  // FIXME: this doesn't work well for the malloc/free stacks yet.\n-  for (uptr i = 0; i < cs_ret; i++) {\n-    if (pc != (uptr)tmp[i])\n-      continue;\n-    offset = i;\n-    break;\n-  }\n-\n-  stack->size = cs_ret - offset;\n-  for (uptr i = 0; i < stack->size; i++)\n-    stack->trace[i] = (uptr)tmp[i + offset];\n+  uptr pc_location = LocatePcInTrace(pc);\n+  PopStackFrames(pc_location);\n }\n \n void MaybeOpenReportFile() {"}, {"sha": "ca41550f5c6d32daeaa4833dd7b725c6d33593aa", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -23,6 +23,7 @@ tsan_files = \\\n         tsan_rtl.cc \\\n         tsan_stat.cc \\\n         tsan_sync.cc \\\n+\ttsan_ignoreset.cc \\\n         tsan_interceptors.cc \\\n         tsan_md5.cc \\\n         tsan_platform_mac.cc \\"}, {"sha": "0bd16082693e72d926ef1544ccd4daf087d0fc38", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -84,12 +84,12 @@ libtsan_la_DEPENDENCIES =  \\\n am__objects_1 = tsan_clock.lo tsan_interface_atomic.lo tsan_mutex.lo \\\n \ttsan_report.lo tsan_rtl_thread.lo tsan_symbolize.lo \\\n \ttsan_flags.lo tsan_interface.lo tsan_platform_linux.lo \\\n-\ttsan_rtl.lo tsan_stat.lo tsan_sync.lo tsan_interceptors.lo \\\n-\ttsan_md5.lo tsan_platform_mac.lo tsan_rtl_mutex.lo \\\n-\ttsan_suppressions.lo tsan_interface_ann.lo tsan_mman.lo \\\n-\ttsan_rtl_report.lo tsan_fd.lo tsan_interface_java.lo \\\n-\ttsan_mutexset.lo tsan_symbolize_addr2line_linux.lo \\\n-\ttsan_rtl_amd64.lo\n+\ttsan_rtl.lo tsan_stat.lo tsan_sync.lo tsan_ignoreset.lo \\\n+\ttsan_interceptors.lo tsan_md5.lo tsan_platform_mac.lo \\\n+\ttsan_rtl_mutex.lo tsan_suppressions.lo tsan_interface_ann.lo \\\n+\ttsan_mman.lo tsan_rtl_report.lo tsan_fd.lo \\\n+\ttsan_interface_java.lo tsan_mutexset.lo \\\n+\ttsan_symbolize_addr2line_linux.lo tsan_rtl_amd64.lo\n am_libtsan_la_OBJECTS = $(am__objects_1)\n libtsan_la_OBJECTS = $(am_libtsan_la_OBJECTS)\n libtsan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -283,6 +283,7 @@ tsan_files = \\\n         tsan_rtl.cc \\\n         tsan_stat.cc \\\n         tsan_sync.cc \\\n+\ttsan_ignoreset.cc \\\n         tsan_interceptors.cc \\\n         tsan_md5.cc \\\n         tsan_platform_mac.cc \\\n@@ -417,6 +418,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_clock.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_fd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_flags.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_ignoreset.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interceptors.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface_ann.Plo@am__quote@"}, {"sha": "3f20797ff4bcfad3a3e88d1dac244df9a55559dd", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -39,10 +39,8 @@ const int kTidBits = 13;\n const unsigned kMaxTid = 1 << kTidBits;\n const unsigned kMaxTidInClock = kMaxTid * 2;  // This includes msb 'freed' bit.\n const int kClkBits = 42;\n-#ifndef TSAN_GO\n-const int kShadowStackSize = 4 * 1024;\n-const int kTraceStackSize = 256;\n-#endif\n+const uptr kShadowStackSize = 64 * 1024;\n+const uptr kTraceStackSize = 256;\n \n #ifdef TSAN_SHADOW_COUNT\n # if TSAN_SHADOW_COUNT == 2 \\\n@@ -154,6 +152,7 @@ struct MD5Hash {\n MD5Hash md5_hash(const void *data, uptr size);\n \n struct ThreadState;\n+class ThreadContext;\n struct Context;\n struct ReportStack;\n class ReportDesc;"}, {"sha": "b7ac3111c89b9151ac02e7f443b1a56583f8378e", "filename": "libsanitizer/tsan/tsan_fd.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -40,6 +40,11 @@ struct FdContext {\n \n static FdContext fdctx;\n \n+static bool bogusfd(int fd) {\n+  // Apparently a bogus fd value.\n+  return fd < 0 || fd >= kTableSize;\n+}\n+\n static FdSync *allocsync() {\n   FdSync *s = (FdSync*)internal_alloc(MBlockFD, sizeof(FdSync));\n   atomic_store(&s->rc, 1, memory_order_relaxed);\n@@ -67,6 +72,7 @@ static void unref(ThreadState *thr, uptr pc, FdSync *s) {\n }\n \n static FdDesc *fddesc(ThreadState *thr, uptr pc, int fd) {\n+  CHECK_GE(fd, 0);\n   CHECK_LT(fd, kTableSize);\n   atomic_uintptr_t *pl1 = &fdctx.tab[fd / kTableSizeL2];\n   uptr l1 = atomic_load(pl1, memory_order_consume);\n@@ -146,6 +152,8 @@ bool FdLocation(uptr addr, int *fd, int *tid, u32 *stack) {\n }\n \n void FdAcquire(ThreadState *thr, uptr pc, int fd) {\n+  if (bogusfd(fd))\n+    return;\n   FdDesc *d = fddesc(thr, pc, fd);\n   FdSync *s = d->sync;\n   DPrintf(\"#%d: FdAcquire(%d) -> %p\\n\", thr->tid, fd, s);\n@@ -155,6 +163,8 @@ void FdAcquire(ThreadState *thr, uptr pc, int fd) {\n }\n \n void FdRelease(ThreadState *thr, uptr pc, int fd) {\n+  if (bogusfd(fd))\n+    return;\n   FdDesc *d = fddesc(thr, pc, fd);\n   FdSync *s = d->sync;\n   DPrintf(\"#%d: FdRelease(%d) -> %p\\n\", thr->tid, fd, s);\n@@ -165,12 +175,16 @@ void FdRelease(ThreadState *thr, uptr pc, int fd) {\n \n void FdAccess(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdAccess(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   FdDesc *d = fddesc(thr, pc, fd);\n   MemoryRead(thr, pc, (uptr)d, kSizeLog8);\n }\n \n void FdClose(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdClose(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   FdDesc *d = fddesc(thr, pc, fd);\n   // To catch races between fd usage and close.\n   MemoryWrite(thr, pc, (uptr)d, kSizeLog8);\n@@ -185,11 +199,15 @@ void FdClose(ThreadState *thr, uptr pc, int fd) {\n \n void FdFileCreate(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdFileCreate(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   init(thr, pc, fd, &fdctx.filesync);\n }\n \n void FdDup(ThreadState *thr, uptr pc, int oldfd, int newfd) {\n   DPrintf(\"#%d: FdDup(%d, %d)\\n\", thr->tid, oldfd, newfd);\n+  if (bogusfd(oldfd) || bogusfd(newfd))\n+    return;\n   // Ignore the case when user dups not yet connected socket.\n   FdDesc *od = fddesc(thr, pc, oldfd);\n   MemoryRead(thr, pc, (uptr)od, kSizeLog8);\n@@ -207,45 +225,61 @@ void FdPipeCreate(ThreadState *thr, uptr pc, int rfd, int wfd) {\n \n void FdEventCreate(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdEventCreate(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   init(thr, pc, fd, allocsync());\n }\n \n void FdSignalCreate(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdSignalCreate(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   init(thr, pc, fd, 0);\n }\n \n void FdInotifyCreate(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdInotifyCreate(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   init(thr, pc, fd, 0);\n }\n \n void FdPollCreate(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdPollCreate(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   init(thr, pc, fd, allocsync());\n }\n \n void FdSocketCreate(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdSocketCreate(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   // It can be a UDP socket.\n   init(thr, pc, fd, &fdctx.socksync);\n }\n \n void FdSocketAccept(ThreadState *thr, uptr pc, int fd, int newfd) {\n   DPrintf(\"#%d: FdSocketAccept(%d, %d)\\n\", thr->tid, fd, newfd);\n+  if (bogusfd(fd))\n+    return;\n   // Synchronize connect->accept.\n   Acquire(thr, pc, (uptr)&fdctx.connectsync);\n   init(thr, pc, newfd, &fdctx.socksync);\n }\n \n void FdSocketConnecting(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdSocketConnecting(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   // Synchronize connect->accept.\n   Release(thr, pc, (uptr)&fdctx.connectsync);\n }\n \n void FdSocketConnect(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdSocketConnect(%d)\\n\", thr->tid, fd);\n+  if (bogusfd(fd))\n+    return;\n   init(thr, pc, fd, &fdctx.socksync);\n }\n "}, {"sha": "5bcf42e39ea52d249543aaf71b8f6a17250d5c29", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -24,13 +24,43 @@ Flags *flags() {\n // Can be overriden in frontend.\n #ifdef TSAN_EXTERNAL_HOOKS\n void OverrideFlags(Flags *f);\n+extern \"C\" const char* __tsan_default_options();\n #else\n-SANITIZER_INTERFACE_ATTRIBUTE\n void WEAK OverrideFlags(Flags *f) {\n   (void)f;\n }\n+extern \"C\" const char *WEAK __tsan_default_options() {\n+  return \"\";\n+}\n #endif\n \n+static void ParseFlags(Flags *f, const char *env) {\n+  ParseFlag(env, &f->enable_annotations, \"enable_annotations\");\n+  ParseFlag(env, &f->suppress_equal_stacks, \"suppress_equal_stacks\");\n+  ParseFlag(env, &f->suppress_equal_addresses, \"suppress_equal_addresses\");\n+  ParseFlag(env, &f->suppress_java, \"suppress_java\");\n+  ParseFlag(env, &f->report_bugs, \"report_bugs\");\n+  ParseFlag(env, &f->report_thread_leaks, \"report_thread_leaks\");\n+  ParseFlag(env, &f->report_destroy_locked, \"report_destroy_locked\");\n+  ParseFlag(env, &f->report_signal_unsafe, \"report_signal_unsafe\");\n+  ParseFlag(env, &f->report_atomic_races, \"report_atomic_races\");\n+  ParseFlag(env, &f->force_seq_cst_atomics, \"force_seq_cst_atomics\");\n+  ParseFlag(env, &f->suppressions, \"suppressions\");\n+  ParseFlag(env, &f->print_suppressions, \"print_suppressions\");\n+  ParseFlag(env, &f->print_benign, \"print_benign\");\n+  ParseFlag(env, &f->exitcode, \"exitcode\");\n+  ParseFlag(env, &f->halt_on_error, \"halt_on_error\");\n+  ParseFlag(env, &f->atexit_sleep_ms, \"atexit_sleep_ms\");\n+  ParseFlag(env, &f->profile_memory, \"profile_memory\");\n+  ParseFlag(env, &f->flush_memory_ms, \"flush_memory_ms\");\n+  ParseFlag(env, &f->flush_symbolizer_ms, \"flush_symbolizer_ms\");\n+  ParseFlag(env, &f->memory_limit_mb, \"memory_limit_mb\");\n+  ParseFlag(env, &f->stop_on_start, \"stop_on_start\");\n+  ParseFlag(env, &f->running_on_valgrind, \"running_on_valgrind\");\n+  ParseFlag(env, &f->history_size, \"history_size\");\n+  ParseFlag(env, &f->io_sync, \"io_sync\");\n+}\n+\n void InitializeFlags(Flags *f, const char *env) {\n   internal_memset(f, 0, sizeof(*f));\n \n@@ -45,57 +75,35 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->report_signal_unsafe = true;\n   f->report_atomic_races = true;\n   f->force_seq_cst_atomics = false;\n-  f->strip_path_prefix = \"\";\n   f->suppressions = \"\";\n   f->print_suppressions = false;\n   f->print_benign = false;\n   f->exitcode = 66;\n   f->halt_on_error = false;\n-  f->log_path = \"stderr\";\n   f->atexit_sleep_ms = 1000;\n-  f->verbosity = 0;\n   f->profile_memory = \"\";\n   f->flush_memory_ms = 0;\n   f->flush_symbolizer_ms = 5000;\n+  f->memory_limit_mb = 0;\n   f->stop_on_start = false;\n   f->running_on_valgrind = false;\n-  f->external_symbolizer_path = \"\";\n   f->history_size = kGoMode ? 1 : 2;  // There are a lot of goroutines in Go.\n   f->io_sync = 1;\n-  f->allocator_may_return_null = false;\n+\n+  SetCommonFlagsDefaults(f);\n \n   // Let a frontend override.\n   OverrideFlags(f);\n-\n+  ParseFlags(f, __tsan_default_options());\n+  ParseCommonFlagsFromString(f, __tsan_default_options());\n   // Override from command line.\n-  ParseFlag(env, &f->enable_annotations, \"enable_annotations\");\n-  ParseFlag(env, &f->suppress_equal_stacks, \"suppress_equal_stacks\");\n-  ParseFlag(env, &f->suppress_equal_addresses, \"suppress_equal_addresses\");\n-  ParseFlag(env, &f->suppress_java, \"suppress_java\");\n-  ParseFlag(env, &f->report_bugs, \"report_bugs\");\n-  ParseFlag(env, &f->report_thread_leaks, \"report_thread_leaks\");\n-  ParseFlag(env, &f->report_destroy_locked, \"report_destroy_locked\");\n-  ParseFlag(env, &f->report_signal_unsafe, \"report_signal_unsafe\");\n-  ParseFlag(env, &f->report_atomic_races, \"report_atomic_races\");\n-  ParseFlag(env, &f->force_seq_cst_atomics, \"force_seq_cst_atomics\");\n-  ParseFlag(env, &f->strip_path_prefix, \"strip_path_prefix\");\n-  ParseFlag(env, &f->suppressions, \"suppressions\");\n-  ParseFlag(env, &f->print_suppressions, \"print_suppressions\");\n-  ParseFlag(env, &f->print_benign, \"print_benign\");\n-  ParseFlag(env, &f->exitcode, \"exitcode\");\n-  ParseFlag(env, &f->halt_on_error, \"halt_on_error\");\n-  ParseFlag(env, &f->log_path, \"log_path\");\n-  ParseFlag(env, &f->atexit_sleep_ms, \"atexit_sleep_ms\");\n-  ParseFlag(env, &f->verbosity, \"verbosity\");\n-  ParseFlag(env, &f->profile_memory, \"profile_memory\");\n-  ParseFlag(env, &f->flush_memory_ms, \"flush_memory_ms\");\n-  ParseFlag(env, &f->flush_symbolizer_ms, \"flush_symbolizer_ms\");\n-  ParseFlag(env, &f->stop_on_start, \"stop_on_start\");\n-  ParseFlag(env, &f->external_symbolizer_path, \"external_symbolizer_path\");\n-  ParseFlag(env, &f->history_size, \"history_size\");\n-  ParseFlag(env, &f->io_sync, \"io_sync\");\n-  ParseFlag(env, &f->allocator_may_return_null, \"allocator_may_return_null\");\n+  ParseFlags(f, env);\n+  ParseCommonFlagsFromString(f, env);\n+\n+  // Copy back to common flags.\n+  *common_flags() = *f;\n \n+  // Sanity check.\n   if (!f->report_bugs) {\n     f->report_thread_leaks = false;\n     f->report_destroy_locked = false;\n@@ -113,8 +121,6 @@ void InitializeFlags(Flags *f, const char *env) {\n            \" (must be [0..2])\\n\");\n     Die();\n   }\n-\n-  common_flags()->allocator_may_return_null = f->allocator_may_return_null;\n }\n \n }  // namespace __tsan"}, {"sha": "05d11a451c694a4441acdf282d25a478f5cfc584", "filename": "libsanitizer/tsan/tsan_flags.h", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -18,9 +18,11 @@\n // header may be included in the user code, and shouldn't include\n // other headers from TSan or common sanitizer runtime.\n \n+#include \"sanitizer_common/sanitizer_flags.h\"\n+\n namespace __tsan {\n \n-struct Flags {\n+struct Flags : CommonFlags {\n   // Enable dynamic annotations, otherwise they are no-ops.\n   bool enable_annotations;\n   // Supress a race report if we've already output another race report\n@@ -46,8 +48,6 @@ struct Flags {\n   // If set, all atomics are effectively sequentially consistent (seq_cst),\n   // regardless of what user actually specified.\n   bool force_seq_cst_atomics;\n-  // Strip that prefix from file paths in reports.\n-  const char *strip_path_prefix;\n   // Suppressions filename.\n   const char *suppressions;\n   // Print matched suppressions at exit.\n@@ -58,27 +58,22 @@ struct Flags {\n   int exitcode;\n   // Exit after first reported error.\n   bool halt_on_error;\n-  // Write logs to \"log_path.pid\".\n-  // The special values are \"stdout\" and \"stderr\".\n-  // The default is \"stderr\".\n-  const char *log_path;\n   // Sleep in main thread before exiting for that many ms\n   // (useful to catch \"at exit\" races).\n   int atexit_sleep_ms;\n-  // Verbosity level (0 - silent, 1 - a bit of output, 2+ - more output).\n-  int verbosity;\n   // If set, periodically write memory profile to that file.\n   const char *profile_memory;\n   // Flush shadow memory every X ms.\n   int flush_memory_ms;\n   // Flush symbolizer caches every X ms.\n   int flush_symbolizer_ms;\n+  // Resident memory limit in MB to aim at.\n+  // If the process consumes more memory, then TSan will flush shadow memory.\n+  int memory_limit_mb;\n   // Stops on start until __tsan_resume() is called (for debugging).\n   bool stop_on_start;\n   // Controls whether RunningOnValgrind() returns true or false.\n   bool running_on_valgrind;\n-  // Path to external symbolizer.\n-  const char *external_symbolizer_path;\n   // Per-thread history size, controls how many previous memory accesses\n   // are remembered per thread.  Possible values are [0..7].\n   // history_size=0 amounts to 32K memory accesses.  Each next value doubles\n@@ -90,8 +85,6 @@ struct Flags {\n   // 1 - reasonable level of synchronization (write->read)\n   // 2 - global synchronization of all IO operations\n   int io_sync;\n-  // If false, the allocator will crash instead of returning 0 on out-of-memory.\n-  bool allocator_may_return_null;\n };\n \n Flags *flags();"}, {"sha": "f0aec42eb6156f7f104edbc8e9dd801e84526d59", "filename": "libsanitizer/tsan/tsan_ignoreset.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_ignoreset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_ignoreset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_ignoreset.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,45 @@\n+//===-- tsan_ignoreset.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"tsan_ignoreset.h\"\n+\n+namespace __tsan {\n+\n+const uptr IgnoreSet::kMaxSize;\n+\n+IgnoreSet::IgnoreSet()\n+    : size_() {\n+}\n+\n+void IgnoreSet::Add(u32 stack_id) {\n+  if (size_ == kMaxSize)\n+    return;\n+  for (uptr i = 0; i < size_; i++) {\n+    if (stacks_[i] == stack_id)\n+      return;\n+  }\n+  stacks_[size_++] = stack_id;\n+}\n+\n+void IgnoreSet::Reset() {\n+  size_ = 0;\n+}\n+\n+uptr IgnoreSet::Size() const {\n+  return size_;\n+}\n+\n+u32 IgnoreSet::At(uptr i) const {\n+  CHECK_LT(i, size_);\n+  CHECK_LE(size_, kMaxSize);\n+  return stacks_[i];\n+}\n+\n+}  // namespace __tsan"}, {"sha": "5a250b75af5b7e2a1d0cc03049bc35aa2a06afa3", "filename": "libsanitizer/tsan/tsan_ignoreset.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_ignoreset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_ignoreset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_ignoreset.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -0,0 +1,36 @@\n+//===-- tsan_ignoreset.h ----------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// IgnoreSet holds a set of stack traces where ignores were enabled.\n+//===----------------------------------------------------------------------===//\n+#ifndef TSAN_IGNORESET_H\n+#define TSAN_IGNORESET_H\n+\n+#include \"tsan_defs.h\"\n+\n+namespace __tsan {\n+\n+class IgnoreSet {\n+ public:\n+  static const uptr kMaxSize = 16;\n+\n+  IgnoreSet();\n+  void Add(u32 stack_id);\n+  void Reset();\n+  uptr Size() const;\n+  u32 At(uptr i) const;\n+\n+ private:\n+  uptr size_;\n+  u32 stacks_[kMaxSize];\n+};\n+\n+}  // namespace __tsan\n+\n+#endif  // TSAN_IGNORESET_H"}, {"sha": "0574beb91df38f5845734f58e7413e5f54d3c3ff", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 233, "deletions": 141, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -20,6 +20,7 @@\n #include \"interception/interception.h\"\n #include \"tsan_interface.h\"\n #include \"tsan_platform.h\"\n+#include \"tsan_suppressions.h\"\n #include \"tsan_rtl.h\"\n #include \"tsan_mman.h\"\n #include \"tsan_fd.h\"\n@@ -40,9 +41,8 @@ struct ucontext_t {\n \n extern \"C\" int pthread_attr_init(void *attr);\n extern \"C\" int pthread_attr_destroy(void *attr);\n-extern \"C\" int pthread_attr_getdetachstate(void *attr, int *v);\n+DECLARE_REAL(int, pthread_attr_getdetachstate, void *, void *)\n extern \"C\" int pthread_attr_setstacksize(void *attr, uptr stacksize);\n-extern \"C\" int pthread_attr_getstacksize(void *attr, uptr *stacksize);\n extern \"C\" int pthread_key_create(unsigned *key, void (*destructor)(void* v));\n extern \"C\" int pthread_setspecific(unsigned key, const void *v);\n extern \"C\" int pthread_mutexattr_gettype(void *a, int *type);\n@@ -64,6 +64,7 @@ const int PTHREAD_MUTEX_RECURSIVE = 1;\n const int PTHREAD_MUTEX_RECURSIVE_NP = 1;\n const int EINVAL = 22;\n const int EBUSY = 16;\n+const int EOWNERDEAD = 130;\n const int EPOLL_CTL_ADD = 1;\n const int SIGILL = 4;\n const int SIGABRT = 6;\n@@ -124,18 +125,16 @@ struct SignalContext {\n   SignalDesc pending_signals[kSigCount];\n };\n \n-// Used to ignore interceptors coming directly from libjvm.so.\n-atomic_uintptr_t libjvm_begin;\n-atomic_uintptr_t libjvm_end;\n+// The object is 64-byte aligned, because we want hot data to be located in\n+// a single cache line if possible (it's accessed in every interceptor).\n+static ALIGNED(64) char libignore_placeholder[sizeof(LibIgnore)];\n+static LibIgnore *libignore() {\n+  return reinterpret_cast<LibIgnore*>(&libignore_placeholder[0]);\n+}\n \n-static bool libjvm_check(uptr pc) {\n-  uptr begin = atomic_load(&libjvm_begin, memory_order_relaxed);\n-  if (begin != 0 && pc >= begin) {\n-    uptr end = atomic_load(&libjvm_end, memory_order_relaxed);\n-    if (end != 0 && pc < end)\n-      return true;\n-  }\n-  return false;\n+void InitializeLibIgnore() {\n+  libignore()->Init(*GetSuppressionContext());\n+  libignore()->OnLibraryLoaded(0);\n }\n \n }  // namespace __tsan\n@@ -159,13 +158,17 @@ class ScopedInterceptor {\n   ~ScopedInterceptor();\n  private:\n   ThreadState *const thr_;\n+  const uptr pc_;\n   const int in_rtl_;\n+  bool in_ignored_lib_;\n };\n \n ScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n                                      uptr pc)\n     : thr_(thr)\n-    , in_rtl_(thr->in_rtl) {\n+    , pc_(pc)\n+    , in_rtl_(thr->in_rtl)\n+    , in_ignored_lib_(false) {\n   if (thr_->in_rtl == 0) {\n     Initialize(thr);\n     FuncEntry(thr, pc);\n@@ -174,9 +177,18 @@ ScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n   } else {\n     thr_->in_rtl++;\n   }\n+  if (!thr_->in_ignored_lib && libignore()->IsIgnored(pc)) {\n+    in_ignored_lib_ = true;\n+    thr_->in_ignored_lib = true;\n+    ThreadIgnoreBegin(thr_, pc_);\n+  }\n }\n \n ScopedInterceptor::~ScopedInterceptor() {\n+  if (in_ignored_lib_) {\n+    thr_->in_ignored_lib = false;\n+    ThreadIgnoreEnd(thr_, pc_);\n+  }\n   thr_->in_rtl--;\n   if (thr_->in_rtl == 0) {\n     FuncExit(thr_);\n@@ -201,7 +213,7 @@ ScopedInterceptor::~ScopedInterceptor() {\n       Printf(\"FATAL: ThreadSanitizer: failed to intercept %s\\n\", #func); \\\n       Die(); \\\n     } \\\n-    if (thr->in_rtl > 1 || libjvm_check(pc)) \\\n+    if (thr->in_rtl > 1 || thr->in_ignored_lib) \\\n       return REAL(func)(__VA_ARGS__); \\\n /**/\n \n@@ -244,6 +256,28 @@ TSAN_INTERCEPTOR(int, nanosleep, void *req, void *rem) {\n   return res;\n }\n \n+TSAN_INTERCEPTOR(void*, dlopen, const char *filename, int flag) {\n+  SCOPED_INTERCEPTOR_RAW(dlopen, filename, flag);\n+  // dlopen will execute global constructors, so it must be not in rtl.\n+  CHECK_EQ(thr->in_rtl, 1);\n+  thr->in_rtl = 0;\n+  void *res = REAL(dlopen)(filename, flag);\n+  thr->in_rtl = 1;\n+  libignore()->OnLibraryLoaded(filename);\n+  return res;\n+}\n+\n+TSAN_INTERCEPTOR(int, dlclose, void *handle) {\n+  SCOPED_INTERCEPTOR_RAW(dlclose, handle);\n+  // dlclose will execute global destructors, so it must be not in rtl.\n+  CHECK_EQ(thr->in_rtl, 1);\n+  thr->in_rtl = 0;\n+  int res = REAL(dlclose)(handle);\n+  thr->in_rtl = 1;\n+  libignore()->OnLibraryUnloaded();\n+  return res;\n+}\n+\n class AtExitContext {\n  public:\n   AtExitContext()\n@@ -326,9 +360,9 @@ TSAN_INTERCEPTOR(int, __cxa_atexit, void (*f)(void *a), void *arg, void *dso) {\n   if (dso) {\n     // Memory allocation in __cxa_atexit will race with free during exit,\n     // because we do not see synchronization around atexit callback list.\n-    ThreadIgnoreBegin(thr);\n+    ThreadIgnoreBegin(thr, pc);\n     int res = REAL(__cxa_atexit)(f, arg, dso);\n-    ThreadIgnoreEnd(thr);\n+    ThreadIgnoreEnd(thr, pc);\n     return res;\n   }\n   return atexit_ctx->atexit(thr, pc, false, (void(*)())f, arg);\n@@ -439,7 +473,7 @@ TSAN_INTERCEPTOR(void, siglongjmp, uptr *env, int val) {\n }\n \n TSAN_INTERCEPTOR(void*, malloc, uptr size) {\n-  if (cur_thread()->in_symbolizer || libjvm_check(GET_CALLER_PC()))\n+  if (cur_thread()->in_symbolizer)\n     return __libc_malloc(size);\n   void *p = 0;\n   {\n@@ -456,7 +490,7 @@ TSAN_INTERCEPTOR(void*, __libc_memalign, uptr align, uptr sz) {\n }\n \n TSAN_INTERCEPTOR(void*, calloc, uptr size, uptr n) {\n-  if (cur_thread()->in_symbolizer || libjvm_check(GET_CALLER_PC()))\n+  if (cur_thread()->in_symbolizer)\n     return __libc_calloc(size, n);\n   if (__sanitizer::CallocShouldReturnNullDueToOverflow(size, n))\n     return AllocatorReturnNull();\n@@ -472,7 +506,7 @@ TSAN_INTERCEPTOR(void*, calloc, uptr size, uptr n) {\n }\n \n TSAN_INTERCEPTOR(void*, realloc, void *p, uptr size) {\n-  if (cur_thread()->in_symbolizer || libjvm_check(GET_CALLER_PC()))\n+  if (cur_thread()->in_symbolizer)\n     return __libc_realloc(p, size);\n   if (p)\n     invoke_free_hook(p);\n@@ -487,7 +521,7 @@ TSAN_INTERCEPTOR(void*, realloc, void *p, uptr size) {\n TSAN_INTERCEPTOR(void, free, void *p) {\n   if (p == 0)\n     return;\n-  if (cur_thread()->in_symbolizer || libjvm_check(GET_CALLER_PC()))\n+  if (cur_thread()->in_symbolizer)\n     return __libc_free(p);\n   invoke_free_hook(p);\n   SCOPED_INTERCEPTOR_RAW(free, p);\n@@ -497,7 +531,7 @@ TSAN_INTERCEPTOR(void, free, void *p) {\n TSAN_INTERCEPTOR(void, cfree, void *p) {\n   if (p == 0)\n     return;\n-  if (cur_thread()->in_symbolizer || libjvm_check(GET_CALLER_PC()))\n+  if (cur_thread()->in_symbolizer)\n     return __libc_free(p);\n   invoke_free_hook(p);\n   SCOPED_INTERCEPTOR_RAW(cfree, p);\n@@ -506,13 +540,11 @@ TSAN_INTERCEPTOR(void, cfree, void *p) {\n \n TSAN_INTERCEPTOR(uptr, malloc_usable_size, void *p) {\n   SCOPED_INTERCEPTOR_RAW(malloc_usable_size, p);\n-  if (libjvm_check(pc))\n-    return malloc_usable_size(p);\n   return user_alloc_usable_size(thr, pc, p);\n }\n \n #define OPERATOR_NEW_BODY(mangled_name) \\\n-  if (cur_thread()->in_symbolizer || libjvm_check(GET_CALLER_PC())) \\\n+  if (cur_thread()->in_symbolizer) \\\n     return __libc_malloc(size); \\\n   void *p = 0; \\\n   {  \\\n@@ -548,7 +580,7 @@ void *operator new[](__sanitizer::uptr size, std::nothrow_t const&) {\n \n #define OPERATOR_DELETE_BODY(mangled_name) \\\n   if (ptr == 0) return;  \\\n-  if (cur_thread()->in_symbolizer || libjvm_check(GET_CALLER_PC())) \\\n+  if (cur_thread()->in_symbolizer) \\\n     return __libc_free(ptr); \\\n   invoke_free_hook(ptr);  \\\n   SCOPED_INTERCEPTOR_RAW(mangled_name, ptr);  \\\n@@ -682,15 +714,6 @@ TSAN_INTERCEPTOR(const char*, strstr, const char *s1, const char *s2) {\n \n TSAN_INTERCEPTOR(char*, strdup, const char *str) {\n   SCOPED_TSAN_INTERCEPTOR(strdup, str);\n-  if (libjvm_check(pc)) {\n-    // The memory must come from libc malloc,\n-    // and we must not instrument accesses in this case.\n-    uptr n = internal_strlen(str) + 1;\n-    void *p = __libc_malloc(n);\n-    if (p == 0)\n-      return 0;\n-    return (char*)internal_memcpy(p, str, n);\n-  }\n   // strdup will call malloc, so no instrumentation is required here.\n   return REAL(strdup)(str);\n }\n@@ -745,23 +768,23 @@ TSAN_INTERCEPTOR(int, munmap, void *addr, long_t sz) {\n }\n \n TSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {\n-  SCOPED_TSAN_INTERCEPTOR(memalign, align, sz);\n+  SCOPED_INTERCEPTOR_RAW(memalign, align, sz);\n   return user_alloc(thr, pc, sz, align);\n }\n \n TSAN_INTERCEPTOR(void*, valloc, uptr sz) {\n-  SCOPED_TSAN_INTERCEPTOR(valloc, sz);\n+  SCOPED_INTERCEPTOR_RAW(valloc, sz);\n   return user_alloc(thr, pc, sz, GetPageSizeCached());\n }\n \n TSAN_INTERCEPTOR(void*, pvalloc, uptr sz) {\n-  SCOPED_TSAN_INTERCEPTOR(pvalloc, sz);\n+  SCOPED_INTERCEPTOR_RAW(pvalloc, sz);\n   sz = RoundUp(sz, GetPageSizeCached());\n   return user_alloc(thr, pc, sz, GetPageSizeCached());\n }\n \n TSAN_INTERCEPTOR(int, posix_memalign, void **memptr, uptr align, uptr sz) {\n-  SCOPED_TSAN_INTERCEPTOR(posix_memalign, memptr, align, sz);\n+  SCOPED_INTERCEPTOR_RAW(posix_memalign, memptr, align, sz);\n   *memptr = user_alloc(thr, pc, sz, align);\n   return 0;\n }\n@@ -830,7 +853,8 @@ extern \"C\" void *__tsan_thread_start_func(void *arg) {\n   {\n     ThreadState *thr = cur_thread();\n     ScopedInRtl in_rtl;\n-    if (pthread_setspecific(g_thread_finalize_key, (void*)4)) {\n+    if (pthread_setspecific(g_thread_finalize_key,\n+                            (void *)kPthreadDestructorIterations)) {\n       Printf(\"ThreadSanitizer: failed to set thread key\\n\");\n       Die();\n     }\n@@ -850,21 +874,15 @@ extern \"C\" void *__tsan_thread_start_func(void *arg) {\n \n TSAN_INTERCEPTOR(int, pthread_create,\n     void *th, void *attr, void *(*callback)(void*), void * param) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_create, th, attr, callback, param);\n+  SCOPED_INTERCEPTOR_RAW(pthread_create, th, attr, callback, param);\n   __sanitizer_pthread_attr_t myattr;\n   if (attr == 0) {\n     pthread_attr_init(&myattr);\n     attr = &myattr;\n   }\n   int detached = 0;\n-  pthread_attr_getdetachstate(attr, &detached);\n-\n-#if defined(TSAN_DEBUG_OUTPUT)\n-  int verbosity = (TSAN_DEBUG_OUTPUT);\n-#else\n-  int verbosity = 0;\n-#endif\n-  AdjustStackSizeLinux(attr, verbosity);\n+  REAL(pthread_attr_getdetachstate)(attr, &detached);\n+  AdjustStackSizeLinux(attr);\n \n   ThreadParam p;\n   p.callback = callback;\n@@ -884,7 +902,7 @@ TSAN_INTERCEPTOR(int, pthread_create,\n }\n \n TSAN_INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_join, th, ret);\n+  SCOPED_INTERCEPTOR_RAW(pthread_join, th, ret);\n   int tid = ThreadTid(thr, pc, (uptr)th);\n   int res = BLOCK_REAL(pthread_join)(th, ret);\n   if (res == 0) {\n@@ -928,21 +946,13 @@ TSAN_INTERCEPTOR(int, pthread_mutex_destroy, void *m) {\n   return res;\n }\n \n-TSAN_INTERCEPTOR(int, pthread_mutex_lock, void *m) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_lock, m);\n-  int res = REAL(pthread_mutex_lock)(m);\n-  if (res == 0) {\n-    MutexLock(thr, pc, (uptr)m);\n-  }\n-  return res;\n-}\n-\n TSAN_INTERCEPTOR(int, pthread_mutex_trylock, void *m) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_mutex_trylock, m);\n   int res = REAL(pthread_mutex_trylock)(m);\n-  if (res == 0) {\n+  if (res == EOWNERDEAD)\n+    MutexRepair(thr, pc, (uptr)m);\n+  if (res == 0 || res == EOWNERDEAD)\n     MutexLock(thr, pc, (uptr)m);\n-  }\n   return res;\n }\n \n@@ -955,13 +965,6 @@ TSAN_INTERCEPTOR(int, pthread_mutex_timedlock, void *m, void *abstime) {\n   return res;\n }\n \n-TSAN_INTERCEPTOR(int, pthread_mutex_unlock, void *m) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_unlock, m);\n-  MutexUnlock(thr, pc, (uptr)m);\n-  int res = REAL(pthread_mutex_unlock)(m);\n-  return res;\n-}\n-\n TSAN_INTERCEPTOR(int, pthread_spin_init, void *m, int pshared) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_spin_init, m, pshared);\n   int res = REAL(pthread_spin_init)(m, pshared);\n@@ -1084,43 +1087,13 @@ TSAN_INTERCEPTOR(int, pthread_rwlock_unlock, void *m) {\n   return res;\n }\n \n-TSAN_INTERCEPTOR(int, pthread_cond_init, void *c, void *a) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_cond_init, c, a);\n-  MemoryWrite(thr, pc, (uptr)c, kSizeLog1);\n-  int res = REAL(pthread_cond_init)(c, a);\n-  return res;\n-}\n-\n TSAN_INTERCEPTOR(int, pthread_cond_destroy, void *c) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_cond_destroy, c);\n   MemoryWrite(thr, pc, (uptr)c, kSizeLog1);\n   int res = REAL(pthread_cond_destroy)(c);\n   return res;\n }\n \n-TSAN_INTERCEPTOR(int, pthread_cond_signal, void *c) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_cond_signal, c);\n-  MemoryRead(thr, pc, (uptr)c, kSizeLog1);\n-  int res = REAL(pthread_cond_signal)(c);\n-  return res;\n-}\n-\n-TSAN_INTERCEPTOR(int, pthread_cond_broadcast, void *c) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_cond_broadcast, c);\n-  MemoryRead(thr, pc, (uptr)c, kSizeLog1);\n-  int res = REAL(pthread_cond_broadcast)(c);\n-  return res;\n-}\n-\n-TSAN_INTERCEPTOR(int, pthread_cond_wait, void *c, void *m) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_cond_wait, c, m);\n-  MutexUnlock(thr, pc, (uptr)m);\n-  MemoryRead(thr, pc, (uptr)c, kSizeLog1);\n-  int res = REAL(pthread_cond_wait)(c, m);\n-  MutexLock(thr, pc, (uptr)m);\n-  return res;\n-}\n-\n TSAN_INTERCEPTOR(int, pthread_cond_timedwait, void *c, void *m,\n     void *abstime) {\n   SCOPED_TSAN_INTERCEPTOR(pthread_cond_timedwait, c, m, abstime);\n@@ -1158,7 +1131,9 @@ TSAN_INTERCEPTOR(int, pthread_barrier_wait, void *b) {\n }\n \n TSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n-  SCOPED_TSAN_INTERCEPTOR(pthread_once, o, f);\n+  SCOPED_INTERCEPTOR_RAW(pthread_once, o, f);\n+  // Using SCOPED_INTERCEPTOR_RAW, because if we are called from an ignored lib,\n+  // the user callback must be executed with thr->in_rtl == 0.\n   if (o == 0 || f == 0)\n     return EINVAL;\n   atomic_uint32_t *a = static_cast<atomic_uint32_t*>(o);\n@@ -1170,14 +1145,16 @@ TSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n     (*f)();\n     CHECK_EQ(thr->in_rtl, 0);\n     thr->in_rtl = old_in_rtl;\n-    Release(thr, pc, (uptr)o);\n+    if (!thr->in_ignored_lib)\n+      Release(thr, pc, (uptr)o);\n     atomic_store(a, 2, memory_order_release);\n   } else {\n     while (v != 2) {\n       pthread_yield();\n       v = atomic_load(a, memory_order_acquire);\n     }\n-    Acquire(thr, pc, (uptr)o);\n+    if (!thr->in_ignored_lib)\n+      Acquire(thr, pc, (uptr)o);\n   }\n   return 0;\n }\n@@ -1496,22 +1473,28 @@ TSAN_INTERCEPTOR(int, pipe2, int *pipefd, int flags) {\n \n TSAN_INTERCEPTOR(long_t, send, int fd, void *buf, long_t len, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(send, fd, buf, len, flags);\n-  if (fd >= 0)\n+  if (fd >= 0) {\n+    FdAccess(thr, pc, fd);\n     FdRelease(thr, pc, fd);\n+  }\n   int res = REAL(send)(fd, buf, len, flags);\n   return res;\n }\n \n TSAN_INTERCEPTOR(long_t, sendmsg, int fd, void *msg, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(sendmsg, fd, msg, flags);\n-  if (fd >= 0)\n+  if (fd >= 0) {\n+    FdAccess(thr, pc, fd);\n     FdRelease(thr, pc, fd);\n+  }\n   int res = REAL(sendmsg)(fd, msg, flags);\n   return res;\n }\n \n TSAN_INTERCEPTOR(long_t, recv, int fd, void *buf, long_t len, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(recv, fd, buf, len, flags);\n+  if (fd >= 0)\n+    FdAccess(thr, pc, fd);\n   int res = REAL(recv)(fd, buf, len, flags);\n   if (res >= 0 && fd >= 0) {\n     FdAcquire(thr, pc, fd);\n@@ -1556,6 +1539,7 @@ TSAN_INTERCEPTOR(void*, freopen, char *path, char *mode, void *stream) {\n }\n \n TSAN_INTERCEPTOR(int, fclose, void *stream) {\n+  // libc file streams can call user-supplied functions, see fopencookie.\n   {\n     SCOPED_TSAN_INTERCEPTOR(fclose, stream);\n     if (stream) {\n@@ -1568,6 +1552,7 @@ TSAN_INTERCEPTOR(int, fclose, void *stream) {\n }\n \n TSAN_INTERCEPTOR(uptr, fread, void *ptr, uptr size, uptr nmemb, void *f) {\n+  // libc file streams can call user-supplied functions, see fopencookie.\n   {\n     SCOPED_TSAN_INTERCEPTOR(fread, ptr, size, nmemb, f);\n     MemoryAccessRange(thr, pc, (uptr)ptr, size * nmemb, true);\n@@ -1576,6 +1561,7 @@ TSAN_INTERCEPTOR(uptr, fread, void *ptr, uptr size, uptr nmemb, void *f) {\n }\n \n TSAN_INTERCEPTOR(uptr, fwrite, const void *p, uptr size, uptr nmemb, void *f) {\n+  // libc file streams can call user-supplied functions, see fopencookie.\n   {\n     SCOPED_TSAN_INTERCEPTOR(fwrite, p, size, nmemb, f);\n     MemoryAccessRange(thr, pc, (uptr)p, size * nmemb, false);\n@@ -1584,7 +1570,10 @@ TSAN_INTERCEPTOR(uptr, fwrite, const void *p, uptr size, uptr nmemb, void *f) {\n }\n \n TSAN_INTERCEPTOR(int, fflush, void *stream) {\n-  SCOPED_TSAN_INTERCEPTOR(fflush, stream);\n+  // libc file streams can call user-supplied functions, see fopencookie.\n+  {\n+    SCOPED_TSAN_INTERCEPTOR(fflush, stream);\n+  }\n   return REAL(fflush)(stream);\n }\n \n@@ -1617,21 +1606,23 @@ TSAN_INTERCEPTOR(void*, opendir, char *path) {\n \n TSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_ctl, epfd, op, fd, ev);\n-  if (op == EPOLL_CTL_ADD && epfd >= 0) {\n+  if (epfd >= 0)\n+    FdAccess(thr, pc, epfd);\n+  if (epfd >= 0 && fd >= 0)\n+    FdAccess(thr, pc, fd);\n+  if (op == EPOLL_CTL_ADD && epfd >= 0)\n     FdRelease(thr, pc, epfd);\n-  }\n   int res = REAL(epoll_ctl)(epfd, op, fd, ev);\n-  if (fd >= 0)\n-    FdAccess(thr, pc, fd);\n   return res;\n }\n \n TSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_wait, epfd, ev, cnt, timeout);\n+  if (epfd >= 0)\n+    FdAccess(thr, pc, epfd);\n   int res = BLOCK_REAL(epoll_wait)(epfd, ev, cnt, timeout);\n-  if (res > 0 && epfd >= 0) {\n+  if (res > 0 && epfd >= 0)\n     FdAcquire(thr, pc, epfd);\n-  }\n   return res;\n }\n \n@@ -1777,13 +1768,13 @@ TSAN_INTERCEPTOR(int, getaddrinfo, void *node, void *service,\n   // We miss atomic synchronization in getaddrinfo,\n   // and can report false race between malloc and free\n   // inside of getaddrinfo. So ignore memory accesses.\n-  ThreadIgnoreBegin(thr);\n+  ThreadIgnoreBegin(thr, pc);\n   // getaddrinfo calls fopen, which can be intercepted by user.\n   thr->in_rtl--;\n   CHECK_EQ(thr->in_rtl, 0);\n   int res = REAL(getaddrinfo)(node, service, hints, rv);\n   thr->in_rtl++;\n-  ThreadIgnoreEnd(thr);\n+  ThreadIgnoreEnd(thr, pc);\n   return res;\n }\n \n@@ -1818,7 +1809,7 @@ TSAN_INTERCEPTOR(int, munlockall, void) {\n }\n \n TSAN_INTERCEPTOR(int, fork, int fake) {\n-  SCOPED_TSAN_INTERCEPTOR(fork, fake);\n+  SCOPED_INTERCEPTOR_RAW(fork, fake);\n   int pid = REAL(fork)(fake);\n   if (pid == 0) {\n     // child\n@@ -1829,12 +1820,26 @@ TSAN_INTERCEPTOR(int, fork, int fake) {\n   return pid;\n }\n \n+static int OnExit(ThreadState *thr) {\n+  int status = Finalize(thr);\n+  REAL(fflush)(0);\n+  return status;\n+}\n+\n struct TsanInterceptorContext {\n   ThreadState *thr;\n   const uptr caller_pc;\n   const uptr pc;\n };\n \n+static void HandleRecvmsg(ThreadState *thr, uptr pc,\n+    __sanitizer_msghdr *msg) {\n+  int fds[64];\n+  int cnt = ExtractRecvmsgFDs(msg, fds, ARRAY_SIZE(fds));\n+  for (int i = 0; i < cnt; i++)\n+    FdEventCreate(thr, pc, fds[i]);\n+}\n+\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n // Causes interceptor recursion (getpwuid_r() calls fopen())\n #undef SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS\n@@ -1845,31 +1850,66 @@ struct TsanInterceptorContext {\n // Causes interceptor recursion (glob64() calls lstat64())\n #undef SANITIZER_INTERCEPT_GLOB\n \n+#define COMMON_INTERCEPT_FUNCTION(name) INTERCEPT_FUNCTION(name)\n #define COMMON_INTERCEPTOR_UNPOISON_PARAM(ctx, count) \\\n   do {                                                \\\n   } while (false)\n+\n #define COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, size)                    \\\n   MemoryAccessRange(((TsanInterceptorContext *)ctx)->thr,                 \\\n                     ((TsanInterceptorContext *)ctx)->pc, (uptr)ptr, size, \\\n                     true)\n+\n #define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size)                       \\\n   MemoryAccessRange(((TsanInterceptorContext *) ctx)->thr,                  \\\n                     ((TsanInterceptorContext *) ctx)->pc, (uptr) ptr, size, \\\n                     false)\n+\n #define COMMON_INTERCEPTOR_ENTER(ctx, func, ...)      \\\n   SCOPED_TSAN_INTERCEPTOR(func, __VA_ARGS__);         \\\n   TsanInterceptorContext _ctx = {thr, caller_pc, pc}; \\\n   ctx = (void *)&_ctx;                                \\\n   (void) ctx;\n+\n #define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) \\\n   FdAcquire(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n+\n #define COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd) \\\n   FdRelease(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n+\n+#define COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd) \\\n+  FdAccess(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n+\n #define COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, newfd) \\\n   FdSocketAccept(((TsanInterceptorContext *) ctx)->thr, pc, fd, newfd)\n+\n #define COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, name) \\\n   ThreadSetName(((TsanInterceptorContext *) ctx)->thr, name)\n+\n+#define COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, name) \\\n+  CTX()->thread_registry->SetThreadNameByUserId(thread, name)\n+\n #define COMMON_INTERCEPTOR_BLOCK_REAL(name) BLOCK_REAL(name)\n+\n+#define COMMON_INTERCEPTOR_ON_EXIT(ctx) \\\n+  OnExit(((TsanInterceptorContext *) ctx)->thr)\n+\n+#define COMMON_INTERCEPTOR_MUTEX_LOCK(ctx, m) \\\n+  MutexLock(((TsanInterceptorContext *)ctx)->thr, \\\n+            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n+\n+#define COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m) \\\n+  MutexUnlock(((TsanInterceptorContext *)ctx)->thr, \\\n+            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n+\n+#define COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m) \\\n+  MutexRepair(((TsanInterceptorContext *)ctx)->thr, \\\n+            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n+\n+#define COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg) \\\n+  HandleRecvmsg(((TsanInterceptorContext *)ctx)->thr, \\\n+      ((TsanInterceptorContext *)ctx)->pc, msg)\n+\n #include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n \n #define TSAN_SYSCALL() \\\n@@ -1899,10 +1939,33 @@ static void syscall_access_range(uptr pc, uptr p, uptr s, bool write) {\n   MemoryAccessRange(thr, pc, p, s, write);\n }\n \n+static void syscall_acquire(uptr pc, uptr addr) {\n+  TSAN_SYSCALL();\n+  Acquire(thr, pc, addr);\n+  Printf(\"syscall_acquire(%p)\\n\", addr);\n+}\n+\n+static void syscall_release(uptr pc, uptr addr) {\n+  TSAN_SYSCALL();\n+  Printf(\"syscall_release(%p)\\n\", addr);\n+  Release(thr, pc, addr);\n+}\n+\n static void syscall_fd_close(uptr pc, int fd) {\n   TSAN_SYSCALL();\n-  if (fd >= 0)\n-    FdClose(thr, pc, fd);\n+  FdClose(thr, pc, fd);\n+}\n+\n+static USED void syscall_fd_acquire(uptr pc, int fd) {\n+  TSAN_SYSCALL();\n+  FdAcquire(thr, pc, fd);\n+  Printf(\"syscall_fd_acquire(%p)\\n\", fd);\n+}\n+\n+static USED void syscall_fd_release(uptr pc, int fd) {\n+  TSAN_SYSCALL();\n+  Printf(\"syscall_fd_release(%p)\\n\", fd);\n+  FdRelease(thr, pc, fd);\n }\n \n static void syscall_pre_fork(uptr pc) {\n@@ -1921,22 +1984,54 @@ static void syscall_post_fork(uptr pc, int res) {\n \n #define COMMON_SYSCALL_PRE_READ_RANGE(p, s) \\\n   syscall_access_range(GET_CALLER_PC(), (uptr)(p), (uptr)(s), false)\n+\n #define COMMON_SYSCALL_PRE_WRITE_RANGE(p, s) \\\n   syscall_access_range(GET_CALLER_PC(), (uptr)(p), (uptr)(s), true)\n+\n #define COMMON_SYSCALL_POST_READ_RANGE(p, s) \\\n-  do { } while (false)\n+  do {                                       \\\n+    (void)(p);                               \\\n+    (void)(s);                               \\\n+  } while (false)\n+\n #define COMMON_SYSCALL_POST_WRITE_RANGE(p, s) \\\n-  do { } while (false)\n-#define COMMON_SYSCALL_FD_CLOSE(fd) \\\n-  syscall_fd_close(GET_CALLER_PC(), fd)\n+  do {                                        \\\n+    (void)(p);                                \\\n+    (void)(s);                                \\\n+  } while (false)\n+\n+#define COMMON_SYSCALL_ACQUIRE(addr) \\\n+    syscall_acquire(GET_CALLER_PC(), (uptr)(addr))\n+\n+#define COMMON_SYSCALL_RELEASE(addr) \\\n+    syscall_release(GET_CALLER_PC(), (uptr)(addr))\n+\n+#define COMMON_SYSCALL_FD_CLOSE(fd) syscall_fd_close(GET_CALLER_PC(), fd)\n+\n+#define COMMON_SYSCALL_FD_ACQUIRE(fd) syscall_fd_acquire(GET_CALLER_PC(), fd)\n+\n+#define COMMON_SYSCALL_FD_RELEASE(fd) syscall_fd_release(GET_CALLER_PC(), fd)\n+\n #define COMMON_SYSCALL_PRE_FORK() \\\n   syscall_pre_fork(GET_CALLER_PC())\n+\n #define COMMON_SYSCALL_POST_FORK(res) \\\n   syscall_post_fork(GET_CALLER_PC(), res)\n+\n #include \"sanitizer_common/sanitizer_common_syscalls.inc\"\n \n namespace __tsan {\n \n+static void finalize(void *arg) {\n+  ThreadState *thr = cur_thread();\n+  uptr pc = 0;\n+  atexit_ctx->exit(thr, pc);\n+  int status = Finalize(thr);\n+  REAL(fflush)(0);\n+  if (status)\n+    REAL(_exit)(status);\n+}\n+\n void ProcessPendingSignals(ThreadState *thr) {\n   CHECK_EQ(thr->in_rtl, 0);\n   SignalContext *sctx = SigCtx(thr);\n@@ -1986,16 +2081,6 @@ void ProcessPendingSignals(ThreadState *thr) {\n   thr->in_signal_handler = false;\n }\n \n-static void finalize(void *arg) {\n-  ThreadState * thr = cur_thread();\n-  uptr pc = 0;\n-  atexit_ctx->exit(thr, pc);\n-  int status = Finalize(cur_thread());\n-  REAL(fflush)(0);\n-  if (status)\n-    _exit(status);\n-}\n-\n static void unreachable() {\n   Printf(\"FATAL: ThreadSanitizer: unreachable called\\n\");\n   Die();\n@@ -2015,10 +2100,14 @@ void InitializeInterceptors() {\n \n   SANITIZER_COMMON_INTERCEPTORS_INIT;\n \n-  TSAN_INTERCEPT(setjmp);\n-  TSAN_INTERCEPT(_setjmp);\n-  TSAN_INTERCEPT(sigsetjmp);\n-  TSAN_INTERCEPT(__sigsetjmp);\n+  // We can not use TSAN_INTERCEPT to get setjmp addr,\n+  // because it does &setjmp and setjmp is not present in some versions of libc.\n+  using __interception::GetRealFunctionAddress;\n+  GetRealFunctionAddress(\"setjmp\", (uptr*)&REAL(setjmp), 0, 0);\n+  GetRealFunctionAddress(\"_setjmp\", (uptr*)&REAL(_setjmp), 0, 0);\n+  GetRealFunctionAddress(\"sigsetjmp\", (uptr*)&REAL(sigsetjmp), 0, 0);\n+  GetRealFunctionAddress(\"__sigsetjmp\", (uptr*)&REAL(__sigsetjmp), 0, 0);\n+\n   TSAN_INTERCEPT(longjmp);\n   TSAN_INTERCEPT(siglongjmp);\n \n@@ -2057,10 +2146,8 @@ void InitializeInterceptors() {\n \n   TSAN_INTERCEPT(pthread_mutex_init);\n   TSAN_INTERCEPT(pthread_mutex_destroy);\n-  TSAN_INTERCEPT(pthread_mutex_lock);\n   TSAN_INTERCEPT(pthread_mutex_trylock);\n   TSAN_INTERCEPT(pthread_mutex_timedlock);\n-  TSAN_INTERCEPT(pthread_mutex_unlock);\n \n   TSAN_INTERCEPT(pthread_spin_init);\n   TSAN_INTERCEPT(pthread_spin_destroy);\n@@ -2078,12 +2165,8 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(pthread_rwlock_timedwrlock);\n   TSAN_INTERCEPT(pthread_rwlock_unlock);\n \n-  INTERCEPT_FUNCTION_VER(pthread_cond_init, GLIBC_2.3.2);\n-  INTERCEPT_FUNCTION_VER(pthread_cond_destroy, GLIBC_2.3.2);\n-  INTERCEPT_FUNCTION_VER(pthread_cond_signal, GLIBC_2.3.2);\n-  INTERCEPT_FUNCTION_VER(pthread_cond_broadcast, GLIBC_2.3.2);\n-  INTERCEPT_FUNCTION_VER(pthread_cond_wait, GLIBC_2.3.2);\n-  INTERCEPT_FUNCTION_VER(pthread_cond_timedwait, GLIBC_2.3.2);\n+  INTERCEPT_FUNCTION_VER(pthread_cond_destroy, \"GLIBC_2.3.2\");\n+  INTERCEPT_FUNCTION_VER(pthread_cond_timedwait, \"GLIBC_2.3.2\");\n \n   TSAN_INTERCEPT(pthread_barrier_init);\n   TSAN_INTERCEPT(pthread_barrier_destroy);\n@@ -2172,8 +2255,11 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(munlockall);\n \n   TSAN_INTERCEPT(fork);\n+  TSAN_INTERCEPT(dlopen);\n+  TSAN_INTERCEPT(dlclose);\n   TSAN_INTERCEPT(on_exit);\n   TSAN_INTERCEPT(__cxa_atexit);\n+  TSAN_INTERCEPT(_exit);\n \n   // Need to setup it, because interceptors check that the function is resolved.\n   // But atexit is emitted directly into the module, so can't be resolved.\n@@ -2195,9 +2281,15 @@ void InitializeInterceptors() {\n }\n \n void internal_start_thread(void(*func)(void *arg), void *arg) {\n+  // Start the thread with signals blocked, otherwise it can steal users\n+  // signals.\n+  __sanitizer_kernel_sigset_t set, old;\n+  internal_sigfillset(&set);\n+  internal_sigprocmask(SIG_SETMASK, &set, &old);\n   void *th;\n   REAL(pthread_create)(&th, 0, (void*(*)(void *arg))func, arg);\n   REAL(pthread_detach)(th);\n+  internal_sigprocmask(SIG_SETMASK, &old, 0);\n }\n \n }  // namespace __tsan"}, {"sha": "38224f429cd09eb762d3ce9ec6babd69a6da3fd3", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -53,11 +53,11 @@ class ScopedAnnotation {\n     if (!flags()->enable_annotations) \\\n       return; \\\n     ThreadState *thr = cur_thread(); \\\n-    const uptr pc = (uptr)__builtin_return_address(0); \\\n+    const uptr caller_pc = (uptr)__builtin_return_address(0); \\\n     StatInc(thr, StatAnnotation); \\\n     StatInc(thr, Stat##typ); \\\n-    ScopedAnnotation sa(thr, __FUNCTION__, f, l, \\\n-        (uptr)__builtin_return_address(0)); \\\n+    ScopedAnnotation sa(thr, __FUNCTION__, f, l, caller_pc); \\\n+    const uptr pc = __sanitizer::StackTrace::GetCurrentPc(); \\\n     (void)pc; \\\n /**/\n \n@@ -381,22 +381,32 @@ void INTERFACE_ATTRIBUTE AnnotateBenignRace(\n \n void INTERFACE_ATTRIBUTE AnnotateIgnoreReadsBegin(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreReadsBegin);\n-  ThreadIgnoreBegin(thr);\n+  ThreadIgnoreBegin(thr, pc);\n }\n \n void INTERFACE_ATTRIBUTE AnnotateIgnoreReadsEnd(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreReadsEnd);\n-  ThreadIgnoreEnd(thr);\n+  ThreadIgnoreEnd(thr, pc);\n }\n \n void INTERFACE_ATTRIBUTE AnnotateIgnoreWritesBegin(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreWritesBegin);\n-  ThreadIgnoreBegin(thr);\n+  ThreadIgnoreBegin(thr, pc);\n }\n \n void INTERFACE_ATTRIBUTE AnnotateIgnoreWritesEnd(char *f, int l) {\n   SCOPED_ANNOTATION(AnnotateIgnoreWritesEnd);\n-  ThreadIgnoreEnd(thr);\n+  ThreadIgnoreEnd(thr, pc);\n+}\n+\n+void INTERFACE_ATTRIBUTE AnnotateIgnoreSyncBegin(char *f, int l) {\n+  SCOPED_ANNOTATION(AnnotateIgnoreSyncBegin);\n+  ThreadIgnoreSyncBegin(thr, pc);\n+}\n+\n+void INTERFACE_ATTRIBUTE AnnotateIgnoreSyncEnd(char *f, int l) {\n+  SCOPED_ANNOTATION(AnnotateIgnoreSyncEnd);\n+  ThreadIgnoreSyncEnd(thr, pc);\n }\n \n void INTERFACE_ATTRIBUTE AnnotatePublishMemoryRange(\n@@ -429,7 +439,7 @@ void INTERFACE_ATTRIBUTE WTFAnnotateHappensAfter(char *f, int l, uptr addr) {\n void INTERFACE_ATTRIBUTE WTFAnnotateBenignRaceSized(\n     char *f, int l, uptr mem, uptr sz, char *desc) {\n   SCOPED_ANNOTATION(AnnotateBenignRaceSized);\n-  BenignRaceImpl(f, l, mem, 1, desc);\n+  BenignRaceImpl(f, l, mem, sz, desc);\n }\n \n int INTERFACE_ATTRIBUTE RunningOnValgrind() {"}, {"sha": "180d87b79934ff0161d231c645e3f330a8a15f80", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -249,11 +249,10 @@ static T AtomicLoad(ThreadState *thr, uptr pc, const volatile T *a,\n   // Assume the access is atomic.\n   if (!IsAcquireOrder(mo) && sizeof(T) <= sizeof(a)) {\n     MemoryReadAtomic(thr, pc, (uptr)a, SizeLog<T>());\n-    return *a;\n+    return *a;  // as if atomic\n   }\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, false);\n-  thr->clock.set(thr->tid, thr->fast_state.epoch());\n-  thr->clock.acquire(&s->clock);\n+  AcquireImpl(thr, pc, &s->clock);\n   T v = *a;\n   s->mtx.ReadUnlock();\n   __sync_synchronize();\n@@ -271,13 +270,15 @@ static void AtomicStore(ThreadState *thr, uptr pc, volatile T *a, T v,\n   // Strictly saying even relaxed store cuts off release sequence,\n   // so must reset the clock.\n   if (!IsReleaseOrder(mo) && sizeof(T) <= sizeof(a)) {\n-    *a = v;\n+    *a = v;  // as if atomic\n     return;\n   }\n   __sync_synchronize();\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, true);\n-  thr->clock.set(thr->tid, thr->fast_state.epoch());\n-  thr->clock.ReleaseStore(&s->clock);\n+  thr->fast_state.IncrementEpoch();\n+  // Can't increment epoch w/o writing to the trace as well.\n+  TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n+  ReleaseImpl(thr, pc, &s->clock);\n   *a = v;\n   s->mtx.Unlock();\n   // Trainling memory barrier to provide sequential consistency\n@@ -291,13 +292,15 @@ static T AtomicRMW(ThreadState *thr, uptr pc, volatile T *a, T v, morder mo) {\n   SyncVar *s = 0;\n   if (mo != mo_relaxed) {\n     s = CTX()->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, true);\n-    thr->clock.set(thr->tid, thr->fast_state.epoch());\n+    thr->fast_state.IncrementEpoch();\n+    // Can't increment epoch w/o writing to the trace as well.\n+    TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n     if (IsAcqRelOrder(mo))\n-      thr->clock.acq_rel(&s->clock);\n+      AcquireReleaseImpl(thr, pc, &s->clock);\n     else if (IsReleaseOrder(mo))\n-      thr->clock.release(&s->clock);\n+      ReleaseImpl(thr, pc, &s->clock);\n     else if (IsAcquireOrder(mo))\n-      thr->clock.acquire(&s->clock);\n+      AcquireImpl(thr, pc, &s->clock);\n   }\n   v = F(a, v);\n   if (s)\n@@ -355,13 +358,15 @@ static bool AtomicCAS(ThreadState *thr, uptr pc,\n   SyncVar *s = 0;\n   if (mo != mo_relaxed) {\n     s = CTX()->synctab.GetOrCreateAndLock(thr, pc, (uptr)a, true);\n-    thr->clock.set(thr->tid, thr->fast_state.epoch());\n+    thr->fast_state.IncrementEpoch();\n+    // Can't increment epoch w/o writing to the trace as well.\n+    TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n     if (IsAcqRelOrder(mo))\n-      thr->clock.acq_rel(&s->clock);\n+      AcquireReleaseImpl(thr, pc, &s->clock);\n     else if (IsReleaseOrder(mo))\n-      thr->clock.release(&s->clock);\n+      ReleaseImpl(thr, pc, &s->clock);\n     else if (IsAcquireOrder(mo))\n-      thr->clock.acquire(&s->clock);\n+      AcquireImpl(thr, pc, &s->clock);\n   }\n   T cc = *c;\n   T pr = func_cas(a, cc, v);"}, {"sha": "70b5e5fcc653e6be7c0b970e58f69381732df47b", "filename": "libsanitizer/tsan/tsan_interface_java.cc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -94,8 +94,6 @@ class ScopedJavaFunc {\n \n static u64 jctx_buf[sizeof(JavaContext) / sizeof(u64) + 1];\n static JavaContext *jctx;\n-extern atomic_uintptr_t libjvm_begin;\n-extern atomic_uintptr_t libjvm_end;\n \n static BlockDesc *getblock(uptr addr) {\n   uptr i = (addr - jctx->heap_begin) / kHeapAlignment;\n@@ -164,17 +162,6 @@ SyncVar* GetAndRemoveJavaSync(ThreadState *thr, uptr pc, uptr addr) {\n   ScopedJavaFunc scoped(thr, caller_pc); \\\n /**/\n \n-void __tsan_java_preinit(const char *libjvm_path) {\n-  SCOPED_JAVA_FUNC(__tsan_java_preinit);\n-  if (libjvm_path) {\n-    uptr begin, end;\n-    if (GetCodeRangeForFile(libjvm_path, &begin, &end)) {\n-      atomic_store(&libjvm_begin, begin, memory_order_relaxed);\n-      atomic_store(&libjvm_end, end, memory_order_relaxed);\n-    }\n-  }\n-}\n-\n void __tsan_java_init(jptr heap_begin, jptr heap_size) {\n   SCOPED_JAVA_FUNC(__tsan_java_init);\n   DPrintf(\"#%d: java_init(%p, %p)\\n\", thr->tid, heap_begin, heap_size);"}, {"sha": "885ff28975115ed0a48d139e3b009252968cb635", "filename": "libsanitizer/tsan/tsan_interface_java.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_interface_java.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -32,11 +32,7 @@ extern \"C\" {\n \n typedef unsigned long jptr;  // NOLINT\n \n-// Must be called before any other callback from Java, right after dlopen\n-// of JVM shared lib. If libjvm_path is specified, then all interceptors\n-// coming directly from JVM will be ignored.\n-void __tsan_java_preinit(const char *libjvm_path) INTERFACE_ATTRIBUTE;\n-// Must be called after __tsan_java_preinit but before any other callback.\n+// Must be called before any other callback from Java.\n void __tsan_java_init(jptr heap_begin, jptr heap_size) INTERFACE_ATTRIBUTE;\n // Must be called when the application exits.\n // Not necessary the last callback (concurrently running threads are OK)."}, {"sha": "df36b462c60a207eeb8f72996e42511915bec573", "filename": "libsanitizer/tsan/tsan_mutexset.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutexset.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -60,4 +60,4 @@ MutexSet::Desc MutexSet::Get(uptr i) const { return Desc(); }\n \n }  // namespace __tsan\n \n-#endif  // TSAN_REPORT_H\n+#endif  // TSAN_MUTEXSET_H"}, {"sha": "164ee45d6c6be48218f42f37242bbd04ad1b8c06", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -132,17 +132,24 @@ static inline uptr AlternativeAddress(uptr addr) {\n \n void FlushShadowMemory();\n void WriteMemoryProfile(char *buf, uptr buf_size);\n+uptr GetRSS();\n \n const char *InitializePlatform();\n void FinalizePlatform();\n+\n+// The additional page is to catch shadow stack overflow as paging fault.\n+const uptr kTotalTraceSize = (kTraceSize * sizeof(Event) + sizeof(Trace) + 4096\n+    + 4095) & ~4095;\n+\n uptr ALWAYS_INLINE GetThreadTrace(int tid) {\n-  uptr p = kTraceMemBegin + (uptr)(tid * 2) * kTraceSize * sizeof(Event);\n+  uptr p = kTraceMemBegin + (uptr)tid * kTotalTraceSize;\n   DCHECK_LT(p, kTraceMemBegin + kTraceMemSize);\n   return p;\n }\n \n uptr ALWAYS_INLINE GetThreadTraceHeader(int tid) {\n-  uptr p = kTraceMemBegin + (uptr)(tid * 2 + 1) * kTraceSize * sizeof(Event);\n+  uptr p = kTraceMemBegin + (uptr)tid * kTotalTraceSize\n+      + kTraceSize * sizeof(Event);\n   DCHECK_LT(p, kTraceMemBegin + kTraceMemSize);\n   return p;\n }\n@@ -153,6 +160,7 @@ void internal_start_thread(void(*func)(void*), void *arg);\n // Guesses with high probability, may yield both false positives and negatives.\n bool IsGlobalVar(uptr addr);\n int ExtractResolvFDs(void *state, int *fds, int nfd);\n+int ExtractRecvmsgFDs(void *msg, int *fds, int nfd);\n \n }  // namespace __tsan\n "}, {"sha": "fe69430b711c42291499b0bad9608b72029ca600", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -17,6 +17,7 @@\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n+#include \"sanitizer_common/sanitizer_stoptheworld.h\"\n #include \"tsan_platform.h\"\n #include \"tsan_rtl.h\"\n #include \"tsan_flags.h\"\n@@ -31,6 +32,7 @@\n #include <sys/mman.h>\n #include <sys/prctl.h>\n #include <sys/syscall.h>\n+#include <sys/socket.h>\n #include <sys/time.h>\n #include <sys/types.h>\n #include <sys/resource.h>\n@@ -43,6 +45,14 @@\n #include <resolv.h>\n #include <malloc.h>\n \n+#ifdef sa_handler\n+# undef sa_handler\n+#endif\n+\n+#ifdef sa_sigaction\n+# undef sa_sigaction\n+#endif\n+\n extern \"C\" struct mallinfo __libc_mallinfo();\n \n namespace __tsan {\n@@ -104,10 +114,23 @@ void WriteMemoryProfile(char *buf, uptr buf_size) {\n       mi.arena >> 20, mi.hblkhd >> 20, mi.fordblks >> 20, mi.keepcost >> 20);\n }\n \n-void FlushShadowMemory() {\n+uptr GetRSS() {\n+  uptr mem[7] = {};\n+  __sanitizer::GetMemoryProfile(FillProfileCallback, mem, 7);\n+  return mem[6];\n+}\n+\n+\n+void FlushShadowMemoryCallback(\n+    const SuspendedThreadsList &suspended_threads_list,\n+    void *argument) {\n   FlushUnneededShadowMemory(kLinuxShadowBeg, kLinuxShadowEnd - kLinuxShadowBeg);\n }\n \n+void FlushShadowMemory() {\n+  StopTheWorld(FlushShadowMemoryCallback, 0);\n+}\n+\n #ifndef TSAN_GO\n static void ProtectRange(uptr beg, uptr end) {\n   ScopedInRtl in_rtl;\n@@ -323,6 +346,9 @@ bool IsGlobalVar(uptr addr) {\n }\n \n #ifndef TSAN_GO\n+// Extract file descriptors passed to glibc internal __res_iclose function.\n+// This is required to properly \"close\" the fds, because we do not see internal\n+// closes within glibc. The code is a pure hack.\n int ExtractResolvFDs(void *state, int *fds, int nfd) {\n   int cnt = 0;\n   __res_state *statp = (__res_state*)state;\n@@ -332,6 +358,26 @@ int ExtractResolvFDs(void *state, int *fds, int nfd) {\n   }\n   return cnt;\n }\n+\n+// Extract file descriptors passed via UNIX domain sockets.\n+// This is requried to properly handle \"open\" of these fds.\n+// see 'man recvmsg' and 'man 3 cmsg'.\n+int ExtractRecvmsgFDs(void *msgp, int *fds, int nfd) {\n+  int res = 0;\n+  msghdr *msg = (msghdr*)msgp;\n+  struct cmsghdr *cmsg = CMSG_FIRSTHDR(msg);\n+  for (; cmsg; cmsg = CMSG_NXTHDR(msg, cmsg)) {\n+    if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS)\n+      continue;\n+    int n = (cmsg->cmsg_len - CMSG_LEN(0)) / sizeof(fds[0]);\n+    for (int i = 0; i < n; i++) {\n+      fds[res++] = ((int*)CMSG_DATA(cmsg))[i];\n+      if (res == nfd)\n+        return res;\n+    }\n+  }\n+  return res;\n+}\n #endif\n \n "}, {"sha": "f2484166e819cc5be8a51a5459d6511236139a86", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -132,7 +132,7 @@ static void PrintLocation(const ReportLocation *loc) {\n   bool print_stack = false;\n   Printf(\"%s\", d.Location());\n   if (loc->type == ReportLocationGlobal) {\n-    Printf(\"  Location is global '%s' of size %zu at %zx (%s+%p)\\n\\n\",\n+    Printf(\"  Location is global '%s' of size %zu at %p (%s+%p)\\n\\n\",\n                loc->name, loc->size, loc->addr, loc->module, loc->offset);\n   } else if (loc->type == ReportLocationHeap) {\n     char thrbuf[kThreadBufSize];"}, {"sha": "a0f32673fbb7ae55670943acd15e083789943bab", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 75, "deletions": 25, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -37,9 +37,13 @@ THREADLOCAL char cur_thread_placeholder[sizeof(ThreadState)] ALIGNED(64);\n static char ctx_placeholder[sizeof(Context)] ALIGNED(64);\n \n // Can be overriden by a front-end.\n-bool CPP_WEAK OnFinalize(bool failed) {\n+#ifdef TSAN_EXTERNAL_HOOKS\n+bool OnFinalize(bool failed);\n+#else\n+bool WEAK OnFinalize(bool failed) {\n   return failed;\n }\n+#endif\n \n static Context *ctx;\n Context *CTX() {\n@@ -84,7 +88,6 @@ ThreadState::ThreadState(Context *ctx, int tid, int unique_id, u64 epoch,\n   // they may be accessed before the ctor.\n   // , ignore_reads_and_writes()\n   // , in_rtl()\n-  , shadow_stack_pos(&shadow_stack[0])\n #ifndef TSAN_GO\n   , jmp_bufs(MBlockJmpBuf)\n #endif\n@@ -128,17 +131,38 @@ static void BackgroundThread(void *arg) {\n   }\n \n   u64 last_flush = NanoTime();\n+  uptr last_rss = 0;\n   for (int i = 0; ; i++) {\n     SleepForSeconds(1);\n     u64 now = NanoTime();\n \n     // Flush memory if requested.\n-    if (flags()->flush_memory_ms) {\n+    if (flags()->flush_memory_ms > 0) {\n       if (last_flush + flags()->flush_memory_ms * kMs2Ns < now) {\n+        if (flags()->verbosity > 0)\n+          Printf(\"ThreadSanitizer: periodic memory flush\\n\");\n         FlushShadowMemory();\n         last_flush = NanoTime();\n       }\n     }\n+    if (flags()->memory_limit_mb > 0) {\n+      uptr rss = GetRSS();\n+      uptr limit = uptr(flags()->memory_limit_mb) << 20;\n+      if (flags()->verbosity > 0) {\n+        Printf(\"ThreadSanitizer: memory flush check\"\n+               \" RSS=%llu LAST=%llu LIMIT=%llu\\n\",\n+               (u64)rss>>20, (u64)last_rss>>20, (u64)limit>>20);\n+      }\n+      if (2 * rss > limit + last_rss) {\n+        if (flags()->verbosity > 0)\n+          Printf(\"ThreadSanitizer: flushing memory due to RSS\\n\");\n+        FlushShadowMemory();\n+        rss = GetRSS();\n+        if (flags()->verbosity > 0)\n+          Printf(\"ThreadSanitizer: memory flushed RSS=%llu\\n\", (u64)rss>>20);\n+      }\n+      last_rss = rss;\n+    }\n \n     // Write memory profile if requested.\n     if (mprof_fd != kInvalidFd)\n@@ -174,8 +198,10 @@ void MapThreadTrace(uptr addr, uptr size) {\n   DPrintf(\"#0: Mapping trace at %p-%p(0x%zx)\\n\", addr, addr + size, size);\n   CHECK_GE(addr, kTraceMemBegin);\n   CHECK_LE(addr + size, kTraceMemBegin + kTraceMemSize);\n-  if (addr != (uptr)MmapFixedNoReserve(addr, size)) {\n-    Printf(\"FATAL: ThreadSanitizer can not mmap thread trace\\n\");\n+  uptr addr1 = (uptr)MmapFixedNoReserve(addr, size);\n+  if (addr1 != addr) {\n+    Printf(\"FATAL: ThreadSanitizer can not mmap thread trace (%p/%p->%p)\\n\",\n+        addr, size, addr1);\n     Die();\n   }\n }\n@@ -204,23 +230,21 @@ void Initialize(ThreadState *thr) {\n #endif\n   InitializeFlags(&ctx->flags, env);\n   // Setup correct file descriptor for error reports.\n-  if (internal_strcmp(flags()->log_path, \"stdout\") == 0)\n-    __sanitizer_set_report_fd(kStdoutFd);\n-  else if (internal_strcmp(flags()->log_path, \"stderr\") == 0)\n-    __sanitizer_set_report_fd(kStderrFd);\n-  else\n-    __sanitizer_set_report_path(flags()->log_path);\n+  __sanitizer_set_report_path(flags()->log_path);\n   InitializeSuppressions();\n #ifndef TSAN_GO\n+  InitializeLibIgnore();\n   // Initialize external symbolizer before internal threads are started.\n   const char *external_symbolizer = flags()->external_symbolizer_path;\n-  if (external_symbolizer != 0 && external_symbolizer[0] != '\\0') {\n-    if (!getSymbolizer()->InitializeExternal(external_symbolizer)) {\n-      Printf(\"Failed to start external symbolizer: '%s'\\n\",\n-             external_symbolizer);\n-      Die();\n-    }\n+  bool external_symbolizer_started =\n+      Symbolizer::Init(external_symbolizer)->IsExternalAvailable();\n+  if (external_symbolizer != 0 && external_symbolizer[0] != '\\0' &&\n+      !external_symbolizer_started) {\n+    Printf(\"Failed to start external symbolizer: '%s'\\n\",\n+           external_symbolizer);\n+    Die();\n   }\n+  Symbolizer::Get()->AddHooks(EnterSymbolizer, ExitSymbolizer);\n #endif\n   internal_start_thread(&BackgroundThread, 0);\n \n@@ -636,9 +660,9 @@ void FuncEntry(ThreadState *thr, uptr pc) {\n \n   // Shadow stack maintenance can be replaced with\n   // stack unwinding during trace switch (which presumably must be faster).\n-  DCHECK_GE(thr->shadow_stack_pos, &thr->shadow_stack[0]);\n+  DCHECK_GE(thr->shadow_stack_pos, thr->shadow_stack);\n #ifndef TSAN_GO\n-  DCHECK_LT(thr->shadow_stack_pos, &thr->shadow_stack[kShadowStackSize]);\n+  DCHECK_LT(thr->shadow_stack_pos, thr->shadow_stack_end);\n #else\n   if (thr->shadow_stack_pos == thr->shadow_stack_end) {\n     const int sz = thr->shadow_stack_end - thr->shadow_stack;\n@@ -664,26 +688,52 @@ void FuncExit(ThreadState *thr) {\n   thr->fast_state.IncrementEpoch();\n   TraceAddEvent(thr, thr->fast_state, EventTypeFuncExit, 0);\n \n-  DCHECK_GT(thr->shadow_stack_pos, &thr->shadow_stack[0]);\n+  DCHECK_GT(thr->shadow_stack_pos, thr->shadow_stack);\n #ifndef TSAN_GO\n-  DCHECK_LT(thr->shadow_stack_pos, &thr->shadow_stack[kShadowStackSize]);\n+  DCHECK_LT(thr->shadow_stack_pos, thr->shadow_stack_end);\n #endif\n   thr->shadow_stack_pos--;\n }\n \n-void ThreadIgnoreBegin(ThreadState *thr) {\n+void ThreadIgnoreBegin(ThreadState *thr, uptr pc) {\n   DPrintf(\"#%d: ThreadIgnoreBegin\\n\", thr->tid);\n   thr->ignore_reads_and_writes++;\n-  CHECK_GE(thr->ignore_reads_and_writes, 0);\n+  CHECK_GT(thr->ignore_reads_and_writes, 0);\n   thr->fast_state.SetIgnoreBit();\n+#ifndef TSAN_GO\n+  thr->mop_ignore_set.Add(CurrentStackId(thr, pc));\n+#endif\n }\n \n-void ThreadIgnoreEnd(ThreadState *thr) {\n+void ThreadIgnoreEnd(ThreadState *thr, uptr pc) {\n   DPrintf(\"#%d: ThreadIgnoreEnd\\n\", thr->tid);\n   thr->ignore_reads_and_writes--;\n   CHECK_GE(thr->ignore_reads_and_writes, 0);\n-  if (thr->ignore_reads_and_writes == 0)\n+  if (thr->ignore_reads_and_writes == 0) {\n     thr->fast_state.ClearIgnoreBit();\n+#ifndef TSAN_GO\n+    thr->mop_ignore_set.Reset();\n+#endif\n+  }\n+}\n+\n+void ThreadIgnoreSyncBegin(ThreadState *thr, uptr pc) {\n+  DPrintf(\"#%d: ThreadIgnoreSyncBegin\\n\", thr->tid);\n+  thr->ignore_sync++;\n+  CHECK_GT(thr->ignore_sync, 0);\n+#ifndef TSAN_GO\n+  thr->sync_ignore_set.Add(CurrentStackId(thr, pc));\n+#endif\n+}\n+\n+void ThreadIgnoreSyncEnd(ThreadState *thr, uptr pc) {\n+  DPrintf(\"#%d: ThreadIgnoreSyncEnd\\n\", thr->tid);\n+  thr->ignore_sync--;\n+  CHECK_GE(thr->ignore_sync, 0);\n+#ifndef TSAN_GO\n+  if (thr->ignore_sync == 0)\n+    thr->mop_ignore_set.Reset();\n+#endif\n }\n \n bool MD5Hash::operator==(const MD5Hash &other) const {"}, {"sha": "45ed096efb8552a05745050f3252ccce0007ba44", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -27,6 +27,7 @@\n #include \"sanitizer_common/sanitizer_allocator.h\"\n #include \"sanitizer_common/sanitizer_allocator_internal.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libignore.h\"\n #include \"sanitizer_common/sanitizer_suppressions.h\"\n #include \"sanitizer_common/sanitizer_thread_registry.h\"\n #include \"tsan_clock.h\"\n@@ -38,6 +39,7 @@\n #include \"tsan_report.h\"\n #include \"tsan_platform.h\"\n #include \"tsan_mutexset.h\"\n+#include \"tsan_ignoreset.h\"\n \n #if SANITIZER_WORDSIZE != 64\n # error \"ThreadSanitizer is supported only on 64-bit platforms\"\n@@ -409,17 +411,19 @@ struct ThreadState {\n   // We do not distinguish beteween ignoring reads and writes\n   // for better performance.\n   int ignore_reads_and_writes;\n-  uptr *shadow_stack_pos;\n-  u64 *racy_shadow_addr;\n-  u64 racy_state[2];\n+  int ignore_sync;\n+  // Go does not support ignores.\n #ifndef TSAN_GO\n-  // C/C++ uses embed shadow stack of fixed size.\n-  uptr shadow_stack[kShadowStackSize];\n-#else\n-  // Go uses satellite shadow stack with dynamic size.\n+  IgnoreSet mop_ignore_set;\n+  IgnoreSet sync_ignore_set;\n+#endif\n+  // C/C++ uses fixed size shadow stack embed into Trace.\n+  // Go uses malloc-allocated shadow stack with dynamic size.\n   uptr *shadow_stack;\n   uptr *shadow_stack_end;\n-#endif\n+  uptr *shadow_stack_pos;\n+  u64 *racy_shadow_addr;\n+  u64 racy_state[2];\n   MutexSet mset;\n   ThreadClock clock;\n #ifndef TSAN_GO\n@@ -432,13 +436,15 @@ struct ThreadState {\n   const int unique_id;\n   int in_rtl;\n   bool in_symbolizer;\n+  bool in_ignored_lib;\n   bool is_alive;\n   bool is_freeing;\n   bool is_vptr_access;\n   const uptr stk_addr;\n   const uptr stk_size;\n   const uptr tls_addr;\n   const uptr tls_size;\n+  ThreadContext *tctx;\n \n   DeadlockDetector deadlock_detector;\n \n@@ -596,6 +602,7 @@ void MapThreadTrace(uptr addr, uptr size);\n void DontNeedShadowFor(uptr addr, uptr size);\n void InitializeShadowMemory();\n void InitializeInterceptors();\n+void InitializeLibIgnore();\n void InitializeDynamicAnnotations();\n \n void ReportRace(ThreadState *thr);\n@@ -625,6 +632,7 @@ ReportStack *SkipTsanInternalFrames(ReportStack *ent);\n #endif\n \n u32 CurrentStackId(ThreadState *thr, uptr pc);\n+ReportStack *SymbolizeStackId(u32 stack_id);\n void PrintCurrentStack(ThreadState *thr, uptr pc);\n void PrintCurrentStackSlow();  // uses libunwind\n \n@@ -675,8 +683,11 @@ void ALWAYS_INLINE MemoryWriteAtomic(ThreadState *thr, uptr pc,\n void MemoryResetRange(ThreadState *thr, uptr pc, uptr addr, uptr size);\n void MemoryRangeFreed(ThreadState *thr, uptr pc, uptr addr, uptr size);\n void MemoryRangeImitateWrite(ThreadState *thr, uptr pc, uptr addr, uptr size);\n-void ThreadIgnoreBegin(ThreadState *thr);\n-void ThreadIgnoreEnd(ThreadState *thr);\n+\n+void ThreadIgnoreBegin(ThreadState *thr, uptr pc);\n+void ThreadIgnoreEnd(ThreadState *thr, uptr pc);\n+void ThreadIgnoreSyncBegin(ThreadState *thr, uptr pc);\n+void ThreadIgnoreSyncEnd(ThreadState *thr, uptr pc);\n \n void FuncEntry(ThreadState *thr, uptr pc);\n void FuncExit(ThreadState *thr);\n@@ -700,12 +711,17 @@ int  MutexUnlock(ThreadState *thr, uptr pc, uptr addr, bool all = false);\n void MutexReadLock(ThreadState *thr, uptr pc, uptr addr);\n void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr);\n void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr);\n+void MutexRepair(ThreadState *thr, uptr pc, uptr addr);  // call on EOWNERDEAD\n \n void Acquire(ThreadState *thr, uptr pc, uptr addr);\n void AcquireGlobal(ThreadState *thr, uptr pc);\n void Release(ThreadState *thr, uptr pc, uptr addr);\n void ReleaseStore(ThreadState *thr, uptr pc, uptr addr);\n void AfterSleep(ThreadState *thr, uptr pc);\n+void AcquireImpl(ThreadState *thr, uptr pc, SyncClock *c);\n+void ReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c);\n+void ReleaseStoreImpl(ThreadState *thr, uptr pc, SyncClock *c);\n+void AcquireReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c);\n \n // The hacky call uses custom calling convention and an assembly thunk.\n // It is considerably faster that a normal call for the caller\n@@ -718,11 +734,11 @@ void AfterSleep(ThreadState *thr, uptr pc);\n // so we create a reserve stack frame for it (1024b must be enough).\n #define HACKY_CALL(f) \\\n   __asm__ __volatile__(\"sub $1024, %%rsp;\" \\\n-                       \"/*.cfi_adjust_cfa_offset 1024;*/\" \\\n+                       \".cfi_adjust_cfa_offset 1024;\" \\\n                        \".hidden \" #f \"_thunk;\" \\\n                        \"call \" #f \"_thunk;\" \\\n                        \"add $1024, %%rsp;\" \\\n-                       \"/*.cfi_adjust_cfa_offset -1024;*/\" \\\n+                       \".cfi_adjust_cfa_offset -1024;\" \\\n                        ::: \"memory\", \"cc\");\n #else\n #define HACKY_CALL(f) f()"}, {"sha": "d9a3a3baa3fe05cb4ff2fce5b5e71395589278db", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 74, "deletions": 37, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -98,11 +98,8 @@ void MutexLock(ThreadState *thr, uptr pc, uptr addr, int rec) {\n   }\n   if (s->recursion == 0) {\n     StatInc(thr, StatMutexLock);\n-    thr->clock.set(thr->tid, thr->fast_state.epoch());\n-    thr->clock.acquire(&s->clock);\n-    StatInc(thr, StatSyncAcquire);\n-    thr->clock.acquire(&s->read_clock);\n-    StatInc(thr, StatSyncAcquire);\n+    AcquireImpl(thr, pc, &s->clock);\n+    AcquireImpl(thr, pc, &s->read_clock);\n   } else if (!s->is_recursive) {\n     StatInc(thr, StatMutexRecLock);\n   }\n@@ -139,10 +136,7 @@ int MutexUnlock(ThreadState *thr, uptr pc, uptr addr, bool all) {\n     if (s->recursion == 0) {\n       StatInc(thr, StatMutexUnlock);\n       s->owner_tid = SyncVar::kInvalidTid;\n-      thr->clock.set(thr->tid, thr->fast_state.epoch());\n-      thr->fast_synch_epoch = thr->fast_state.epoch();\n-      thr->clock.ReleaseStore(&s->clock);\n-      StatInc(thr, StatSyncRelease);\n+      ReleaseStoreImpl(thr, pc, &s->clock);\n     } else {\n       StatInc(thr, StatMutexRecUnlock);\n     }\n@@ -166,10 +160,8 @@ void MutexReadLock(ThreadState *thr, uptr pc, uptr addr) {\n            addr);\n     PrintCurrentStack(thr, pc);\n   }\n-  thr->clock.set(thr->tid, thr->fast_state.epoch());\n-  thr->clock.acquire(&s->clock);\n+  AcquireImpl(thr, pc, &s->clock);\n   s->last_lock = thr->fast_state.raw();\n-  StatInc(thr, StatSyncAcquire);\n   thr->mset.Add(s->GetId(), false, thr->fast_state.epoch());\n   s->mtx.ReadUnlock();\n }\n@@ -188,10 +180,7 @@ void MutexReadUnlock(ThreadState *thr, uptr pc, uptr addr) {\n            addr);\n     PrintCurrentStack(thr, pc);\n   }\n-  thr->clock.set(thr->tid, thr->fast_state.epoch());\n-  thr->fast_synch_epoch = thr->fast_state.epoch();\n-  thr->clock.release(&s->read_clock);\n-  StatInc(thr, StatSyncRelease);\n+  ReleaseImpl(thr, pc, &s->read_clock);\n   s->mtx.Unlock();\n   thr->mset.Del(s->GetId(), false);\n }\n@@ -209,10 +198,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n     StatInc(thr, StatMutexReadUnlock);\n     thr->fast_state.IncrementEpoch();\n     TraceAddEvent(thr, thr->fast_state, EventTypeRUnlock, s->GetId());\n-    thr->clock.set(thr->tid, thr->fast_state.epoch());\n-    thr->fast_synch_epoch = thr->fast_state.epoch();\n-    thr->clock.release(&s->read_clock);\n-    StatInc(thr, StatSyncRelease);\n+    ReleaseImpl(thr, pc, &s->read_clock);\n   } else if (s->owner_tid == thr->tid) {\n     // Seems to be write unlock.\n     thr->fast_state.IncrementEpoch();\n@@ -222,14 +208,7 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n     if (s->recursion == 0) {\n       StatInc(thr, StatMutexUnlock);\n       s->owner_tid = SyncVar::kInvalidTid;\n-      // FIXME: Refactor me, plz.\n-      // The sequence of events is quite tricky and doubled in several places.\n-      // First, it's a bug to increment the epoch w/o writing to the trace.\n-      // Then, the acquire/release logic can be factored out as well.\n-      thr->clock.set(thr->tid, thr->fast_state.epoch());\n-      thr->fast_synch_epoch = thr->fast_state.epoch();\n-      thr->clock.ReleaseStore(&s->clock);\n-      StatInc(thr, StatSyncRelease);\n+      ReleaseImpl(thr, pc, &s->clock);\n     } else {\n       StatInc(thr, StatMutexRecUnlock);\n     }\n@@ -243,13 +222,23 @@ void MutexReadOrWriteUnlock(ThreadState *thr, uptr pc, uptr addr) {\n   s->mtx.Unlock();\n }\n \n+void MutexRepair(ThreadState *thr, uptr pc, uptr addr) {\n+  Context *ctx = CTX();\n+  CHECK_GT(thr->in_rtl, 0);\n+  DPrintf(\"#%d: MutexRepair %zx\\n\", thr->tid, addr);\n+  SyncVar *s = ctx->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n+  s->owner_tid = SyncVar::kInvalidTid;\n+  s->recursion = 0;\n+  s->mtx.Unlock();\n+}\n+\n void Acquire(ThreadState *thr, uptr pc, uptr addr) {\n   CHECK_GT(thr->in_rtl, 0);\n   DPrintf(\"#%d: Acquire %zx\\n\", thr->tid, addr);\n+  if (thr->ignore_sync)\n+    return;\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, addr, false);\n-  thr->clock.set(thr->tid, thr->fast_state.epoch());\n-  thr->clock.acquire(&s->clock);\n-  StatInc(thr, StatSyncAcquire);\n+  AcquireImpl(thr, pc, &s->clock);\n   s->mtx.ReadUnlock();\n }\n \n@@ -263,6 +252,9 @@ static void UpdateClockCallback(ThreadContextBase *tctx_base, void *arg) {\n }\n \n void AcquireGlobal(ThreadState *thr, uptr pc) {\n+  DPrintf(\"#%d: AcquireGlobal\\n\", thr->tid);\n+  if (thr->ignore_sync)\n+    return;\n   ThreadRegistryLock l(CTX()->thread_registry);\n   CTX()->thread_registry->RunCallbackForEachThreadLocked(\n       UpdateClockCallback, thr);\n@@ -271,20 +263,26 @@ void AcquireGlobal(ThreadState *thr, uptr pc) {\n void Release(ThreadState *thr, uptr pc, uptr addr) {\n   CHECK_GT(thr->in_rtl, 0);\n   DPrintf(\"#%d: Release %zx\\n\", thr->tid, addr);\n+  if (thr->ignore_sync)\n+    return;\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n-  thr->clock.set(thr->tid, thr->fast_state.epoch());\n-  thr->clock.release(&s->clock);\n-  StatInc(thr, StatSyncRelease);\n+  thr->fast_state.IncrementEpoch();\n+  // Can't increment epoch w/o writing to the trace as well.\n+  TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n+  ReleaseImpl(thr, pc, &s->clock);\n   s->mtx.Unlock();\n }\n \n void ReleaseStore(ThreadState *thr, uptr pc, uptr addr) {\n   CHECK_GT(thr->in_rtl, 0);\n   DPrintf(\"#%d: ReleaseStore %zx\\n\", thr->tid, addr);\n+  if (thr->ignore_sync)\n+    return;\n   SyncVar *s = CTX()->synctab.GetOrCreateAndLock(thr, pc, addr, true);\n-  thr->clock.set(thr->tid, thr->fast_state.epoch());\n-  thr->clock.ReleaseStore(&s->clock);\n-  StatInc(thr, StatSyncRelease);\n+  thr->fast_state.IncrementEpoch();\n+  // Can't increment epoch w/o writing to the trace as well.\n+  TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n+  ReleaseStoreImpl(thr, pc, &s->clock);\n   s->mtx.Unlock();\n }\n \n@@ -299,11 +297,50 @@ static void UpdateSleepClockCallback(ThreadContextBase *tctx_base, void *arg) {\n }\n \n void AfterSleep(ThreadState *thr, uptr pc) {\n+  DPrintf(\"#%d: AfterSleep %zx\\n\", thr->tid);\n+  if (thr->ignore_sync)\n+    return;\n   thr->last_sleep_stack_id = CurrentStackId(thr, pc);\n   ThreadRegistryLock l(CTX()->thread_registry);\n   CTX()->thread_registry->RunCallbackForEachThreadLocked(\n       UpdateSleepClockCallback, thr);\n }\n #endif\n \n+void AcquireImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n+  if (thr->ignore_sync)\n+    return;\n+  thr->clock.set(thr->tid, thr->fast_state.epoch());\n+  thr->clock.acquire(c);\n+  StatInc(thr, StatSyncAcquire);\n+}\n+\n+void ReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n+  if (thr->ignore_sync)\n+    return;\n+  thr->clock.set(thr->tid, thr->fast_state.epoch());\n+  thr->fast_synch_epoch = thr->fast_state.epoch();\n+  thr->clock.release(c);\n+  StatInc(thr, StatSyncRelease);\n+}\n+\n+void ReleaseStoreImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n+  if (thr->ignore_sync)\n+    return;\n+  thr->clock.set(thr->tid, thr->fast_state.epoch());\n+  thr->fast_synch_epoch = thr->fast_state.epoch();\n+  thr->clock.ReleaseStore(c);\n+  StatInc(thr, StatSyncRelease);\n+}\n+\n+void AcquireReleaseImpl(ThreadState *thr, uptr pc, SyncClock *c) {\n+  if (thr->ignore_sync)\n+    return;\n+  thr->clock.set(thr->tid, thr->fast_state.epoch());\n+  thr->fast_synch_epoch = thr->fast_state.epoch();\n+  thr->clock.acq_rel(c);\n+  StatInc(thr, StatSyncAcquire);\n+  StatInc(thr, StatSyncRelease);\n+}\n+\n }  // namespace __tsan"}, {"sha": "f2248afeab2375fb349de3dd9f2bd5ac85bd99ff", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 20, "deletions": 38, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -99,6 +99,18 @@ static void StackStripMain(ReportStack *stack) {\n #endif\n }\n \n+#ifndef TSAN_GO\n+ReportStack *SymbolizeStackId(u32 stack_id) {\n+  uptr ssz = 0;\n+  const uptr *stack = StackDepotGet(stack_id, &ssz);\n+  if (stack == 0)\n+    return 0;\n+  StackTrace trace;\n+  trace.Init(stack, ssz);\n+  return SymbolizeStack(trace);\n+}\n+#endif\n+\n static ReportStack *SymbolizeStack(const StackTrace& trace) {\n   if (trace.IsEmpty())\n     return 0;\n@@ -201,13 +213,7 @@ void ScopedReport::AddThread(const ThreadContext *tctx) {\n #ifdef TSAN_GO\n   rt->stack = SymbolizeStack(tctx->creation_stack);\n #else\n-  uptr ssz = 0;\n-  const uptr *stack = StackDepotGet(tctx->creation_stack_id, &ssz);\n-  if (stack) {\n-    StackTrace trace;\n-    trace.Init(stack, ssz);\n-    rt->stack = SymbolizeStack(trace);\n-  }\n+  rt->stack = SymbolizeStackId(tctx->creation_stack_id);\n #endif\n }\n \n@@ -270,13 +276,7 @@ void ScopedReport::AddMutex(const SyncVar *s) {\n   rm->destroyed = false;\n   rm->stack = 0;\n #ifndef TSAN_GO\n-  uptr ssz = 0;\n-  const uptr *stack = StackDepotGet(s->creation_stack_id, &ssz);\n-  if (stack) {\n-    StackTrace trace;\n-    trace.Init(stack, ssz);\n-    rm->stack = SymbolizeStack(trace);\n-  }\n+  rm->stack = SymbolizeStackId(s->creation_stack_id);\n #endif\n }\n \n@@ -308,13 +308,7 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n     loc->type = ReportLocationFD;\n     loc->fd = fd;\n     loc->tid = creat_tid;\n-    uptr ssz = 0;\n-    const uptr *stack = StackDepotGet(creat_stack, &ssz);\n-    if (stack) {\n-      StackTrace trace;\n-      trace.Init(stack, ssz);\n-      loc->stack = SymbolizeStack(trace);\n-    }\n+    loc->stack = SymbolizeStackId(creat_stack);\n     ThreadContext *tctx = FindThreadByUidLocked(creat_tid);\n     if (tctx)\n       AddThread(tctx);\n@@ -335,13 +329,7 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n     loc->file = 0;\n     loc->line = 0;\n     loc->stack = 0;\n-    uptr ssz = 0;\n-    const uptr *stack = StackDepotGet(b->StackId(), &ssz);\n-    if (stack) {\n-      StackTrace trace;\n-      trace.Init(stack, ssz);\n-      loc->stack = SymbolizeStack(trace);\n-    }\n+    loc->stack = SymbolizeStackId(b->StackId());\n     if (tctx)\n       AddThread(tctx);\n     return;\n@@ -365,13 +353,7 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n \n #ifndef TSAN_GO\n void ScopedReport::AddSleep(u32 stack_id) {\n-  uptr ssz = 0;\n-  const uptr *stack = StackDepotGet(stack_id, &ssz);\n-  if (stack) {\n-    StackTrace trace;\n-    trace.Init(stack, ssz);\n-    rep_->sleep = SymbolizeStack(trace);\n-  }\n+  rep_->sleep = SymbolizeStackId(stack_id);\n }\n #endif\n \n@@ -408,7 +390,7 @@ void RestoreStack(int tid, const u64 epoch, StackTrace *stk, MutexSet *mset) {\n   const u64 ebegin = RoundDown(eend, kTracePartSize);\n   DPrintf(\"#%d: RestoreStack epoch=%zu ebegin=%zu eend=%zu partidx=%d\\n\",\n           tid, (uptr)epoch, (uptr)ebegin, (uptr)eend, partidx);\n-  InternalScopedBuffer<uptr> stack(1024);  // FIXME: de-hardcode 1024\n+  InternalScopedBuffer<uptr> stack(kShadowStackSize);\n   for (uptr i = 0; i < hdr->stack0.Size(); i++) {\n     stack[i] = hdr->stack0.Get(i);\n     DPrintf2(\"  #%02lu: pc=%zx\\n\", i, stack[i]);\n@@ -724,8 +706,8 @@ void PrintCurrentStackSlow() {\n #ifndef TSAN_GO\n   __sanitizer::StackTrace *ptrace = new(internal_alloc(MBlockStackTrace,\n       sizeof(__sanitizer::StackTrace))) __sanitizer::StackTrace;\n-  ptrace->SlowUnwindStack(__sanitizer::StackTrace::GetCurrentPc(),\n-      kStackTraceMax);\n+  ptrace->Unwind(kStackTraceMax, __sanitizer::StackTrace::GetCurrentPc(),\n+                 0, 0, 0, false);\n   for (uptr i = 0; i < ptrace->size / 2; i++) {\n     uptr tmp = ptrace->trace[i];\n     ptrace->trace[i] = ptrace->trace[ptrace->size - i - 1];"}, {"sha": "dea669835359f10a9723b2307445ac34107baade", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -39,8 +39,7 @@ void ThreadContext::OnDead() {\n \n void ThreadContext::OnJoined(void *arg) {\n   ThreadState *caller_thr = static_cast<ThreadState *>(arg);\n-  caller_thr->clock.acquire(&sync);\n-  StatInc(caller_thr, StatSyncAcquire);\n+  AcquireImpl(caller_thr, 0, &sync);\n   sync.Reset();\n }\n \n@@ -57,10 +56,7 @@ void ThreadContext::OnCreated(void *arg) {\n   args->thr->fast_state.IncrementEpoch();\n   // Can't increment epoch w/o writing to the trace as well.\n   TraceAddEvent(args->thr, args->thr->fast_state, EventTypeMop, 0);\n-  args->thr->clock.set(args->thr->tid, args->thr->fast_state.epoch());\n-  args->thr->fast_synch_epoch = args->thr->fast_state.epoch();\n-  args->thr->clock.release(&sync);\n-  StatInc(args->thr, StatSyncRelease);\n+  ReleaseImpl(args->thr, 0, &sync);\n #ifdef TSAN_GO\n   creation_stack.ObtainCurrent(args->thr, args->pc);\n #else\n@@ -93,21 +89,23 @@ void ThreadContext::OnStarted(void *arg) {\n   epoch1 = (u64)-1;\n   new(thr) ThreadState(CTX(), tid, unique_id,\n       epoch0, args->stk_addr, args->stk_size, args->tls_addr, args->tls_size);\n-#ifdef TSAN_GO\n+#ifndef TSAN_GO\n+  thr->shadow_stack = &ThreadTrace(thr->tid)->shadow_stack[0];\n+  thr->shadow_stack_pos = thr->shadow_stack;\n+  thr->shadow_stack_end = thr->shadow_stack + kShadowStackSize;\n+#else\n   // Setup dynamic shadow stack.\n   const int kInitStackSize = 8;\n-  args->thr->shadow_stack = (uptr*)internal_alloc(MBlockShadowStack,\n+  thr->shadow_stack = (uptr*)internal_alloc(MBlockShadowStack,\n       kInitStackSize * sizeof(uptr));\n-  args->thr->shadow_stack_pos = thr->shadow_stack;\n-  args->thr->shadow_stack_end = thr->shadow_stack + kInitStackSize;\n+  thr->shadow_stack_pos = thr->shadow_stack;\n+  thr->shadow_stack_end = thr->shadow_stack + kInitStackSize;\n #endif\n #ifndef TSAN_GO\n-  AllocatorThreadStart(args->thr);\n+  AllocatorThreadStart(thr);\n #endif\n-  thr = args->thr;\n   thr->fast_synch_epoch = epoch0;\n-  thr->clock.set(tid, epoch0);\n-  thr->clock.acquire(&sync);\n+  AcquireImpl(thr, 0, &sync);\n   thr->fast_state.SetHistorySize(flags()->history_size);\n   const uptr trace = (epoch0 / kTracePartSize) % TraceParts();\n   Trace *thr_trace = ThreadTrace(thr->tid);\n@@ -126,10 +124,7 @@ void ThreadContext::OnFinished() {\n     thr->fast_state.IncrementEpoch();\n     // Can't increment epoch w/o writing to the trace as well.\n     TraceAddEvent(thr, thr->fast_state, EventTypeMop, 0);\n-    thr->clock.set(thr->tid, thr->fast_state.epoch());\n-    thr->fast_synch_epoch = thr->fast_state.epoch();\n-    thr->clock.release(&sync);\n-    StatInc(thr, StatSyncRelease);\n+    ReleaseImpl(thr, 0, &sync);\n   }\n   epoch1 = thr->fast_state.epoch();\n \n@@ -163,13 +158,34 @@ static void MaybeReportThreadLeak(ThreadContextBase *tctx_base, void *arg) {\n }\n #endif\n \n-static void ThreadCheckIgnore(ThreadState *thr) {\n-  if (thr->ignore_reads_and_writes) {\n-    Printf(\"ThreadSanitizer: thread T%d finished with ignores enabled.\\n\",\n-           thr->tid);\n+#ifndef TSAN_GO\n+static void ReportIgnoresEnabled(ThreadContext *tctx, IgnoreSet *set) {\n+  if (tctx->tid == 0) {\n+    Printf(\"ThreadSanitizer: main thread finished with ignores enabled\\n\");\n+  } else {\n+    Printf(\"ThreadSanitizer: thread T%d %s finished with ignores enabled,\"\n+      \" created at:\\n\", tctx->tid, tctx->name);\n+    PrintStack(SymbolizeStackId(tctx->creation_stack_id));\n+  }\n+  Printf(\"  One of the following ignores was not ended\"\n+      \" (in order of probability)\\n\");\n+  for (uptr i = 0; i < set->Size(); i++) {\n+    Printf(\"  Ignore was enabled at:\\n\");\n+    PrintStack(SymbolizeStackId(set->At(i)));\n   }\n+  Die();\n }\n \n+static void ThreadCheckIgnore(ThreadState *thr) {\n+  if (thr->ignore_reads_and_writes)\n+    ReportIgnoresEnabled(thr->tctx, &thr->mop_ignore_set);\n+  if (thr->ignore_sync)\n+    ReportIgnoresEnabled(thr->tctx, &thr->sync_ignore_set);\n+}\n+#else\n+static void ThreadCheckIgnore(ThreadState *thr) {}\n+#endif\n+\n void ThreadFinalize(ThreadState *thr) {\n   CHECK_GT(thr->in_rtl, 0);\n   ThreadCheckIgnore(thr);\n@@ -209,6 +225,7 @@ int ThreadCreate(ThreadState *thr, uptr pc, uptr uid, bool detached) {\n }\n \n void ThreadStart(ThreadState *thr, int tid, uptr os_id) {\n+  Context *ctx = CTX();\n   CHECK_GT(thr->in_rtl, 0);\n   uptr stk_addr = 0;\n   uptr stk_size = 0;\n@@ -235,8 +252,13 @@ void ThreadStart(ThreadState *thr, int tid, uptr os_id) {\n     }\n   }\n \n+  ThreadRegistry *tr = ctx->thread_registry;\n   OnStartedArgs args = { thr, stk_addr, stk_size, tls_addr, tls_size };\n-  CTX()->thread_registry->StartThread(tid, os_id, &args);\n+  tr->StartThread(tid, os_id, &args);\n+\n+  tr->Lock();\n+  thr->tctx = (ThreadContext*)tr->GetThreadLocked(tid);\n+  tr->Unlock();\n }\n \n void ThreadFinish(ThreadState *thr) {"}, {"sha": "cdd11ca22ae2800aa3c16e58f41e04e9828a40fa", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -140,6 +140,7 @@ void StatOutput(u64 *stat) {\n   name[StatInt_strcasecmp]               = \"  strcasecmp                      \";\n   name[StatInt_strncasecmp]              = \"  strncasecmp                     \";\n   name[StatInt_atexit]                   = \"  atexit                          \";\n+  name[StatInt__exit]                    = \"  _exit                           \";\n   name[StatInt___cxa_guard_acquire]      = \"  __cxa_guard_acquire             \";\n   name[StatInt___cxa_guard_release]      = \"  __cxa_guard_release             \";\n   name[StatInt___cxa_guard_abort]        = \"  __cxa_guard_abort               \";\n@@ -179,6 +180,7 @@ void StatOutput(u64 *stat) {\n   name[StatInt_pthread_barrier_wait]     = \"  pthread_barrier_wait            \";\n   name[StatInt_pthread_once]             = \"  pthread_once                    \";\n   name[StatInt_pthread_getschedparam]    = \"  pthread_getschedparam           \";\n+  name[StatInt_pthread_setname_np]       = \"  pthread_setname_np              \";\n   name[StatInt_sem_init]                 = \"  sem_init                        \";\n   name[StatInt_sem_destroy]              = \"  sem_destroy                     \";\n   name[StatInt_sem_wait]                 = \"  sem_wait                        \";\n@@ -288,6 +290,7 @@ void StatOutput(u64 *stat) {\n   name[StatInt_ctime_r]                  = \"  ctime_r                         \";\n   name[StatInt_asctime]                  = \"  asctime                         \";\n   name[StatInt_asctime_r]                = \"  asctime_r                       \";\n+  name[StatInt_strptime]                 = \"  strptime                        \";\n   name[StatInt_frexp]                    = \"  frexp                           \";\n   name[StatInt_frexpf]                   = \"  frexpf                          \";\n   name[StatInt_frexpl]                   = \"  frexpl                          \";\n@@ -356,6 +359,7 @@ void StatOutput(u64 *stat) {\n   name[StatInt_sched_getaffinity]        = \"  sched_getaffinity               \";\n   name[StatInt_strerror]                 = \"  strerror                        \";\n   name[StatInt_strerror_r]               = \"  strerror_r                      \";\n+  name[StatInt___xpg_strerror_r]         = \"  __xpg_strerror_r                \";\n   name[StatInt_scandir]                  = \"  scandir                         \";\n   name[StatInt_scandir64]                = \"  scandir64                       \";\n   name[StatInt_getgroups]                = \"  getgroups                       \";\n@@ -369,6 +373,59 @@ void StatOutput(u64 *stat) {\n   name[StatInt_sigprocmask]              = \"  sigprocmask                     \";\n   name[StatInt_backtrace]                = \"  backtrace                       \";\n   name[StatInt_backtrace_symbols]        = \"  backtrace_symbols               \";\n+  name[StatInt_dlopen]                   = \"  dlopen                          \";\n+  name[StatInt_dlclose]                  = \"  dlclose                         \";\n+  name[StatInt_getmntent]                = \"  getmntent                       \";\n+  name[StatInt_getmntent_r]              = \"  getmntent_r                     \";\n+  name[StatInt_statfs]                   = \"  statfs                          \";\n+  name[StatInt_statfs64]                 = \"  statfs64                        \";\n+  name[StatInt_fstatfs]                  = \"  fstatfs                         \";\n+  name[StatInt_fstatfs64]                = \"  fstatfs64                       \";\n+  name[StatInt_statvfs]                  = \"  statvfs                         \";\n+  name[StatInt_statvfs64]                = \"  statvfs64                       \";\n+  name[StatInt_fstatvfs]                 = \"  fstatvfs                        \";\n+  name[StatInt_fstatvfs64]               = \"  fstatvfs64                      \";\n+  name[StatInt_initgroups]               = \"  initgroups                      \";\n+  name[StatInt_ether_ntoa]               = \"  ether_ntoa                      \";\n+  name[StatInt_ether_aton]               = \"  ether_aton                      \";\n+  name[StatInt_ether_ntoa_r]             = \"  ether_ntoa_r                    \";\n+  name[StatInt_ether_aton_r]             = \"  ether_aton_r                    \";\n+  name[StatInt_ether_ntohost]            = \"  ether_ntohost                   \";\n+  name[StatInt_ether_hostton]            = \"  ether_hostton                   \";\n+  name[StatInt_ether_line]               = \"  ether_line                      \";\n+  name[StatInt_shmctl]                   = \"  shmctl                          \";\n+  name[StatInt_random_r]                 = \"  random_r                        \";\n+  name[StatInt_tmpnam]                   = \"  tmpnam                          \";\n+  name[StatInt_tmpnam_r]                 = \"  tmpnam_r                        \";\n+  name[StatInt_tempnam]                  = \"  tempnam                         \";\n+  name[StatInt_sincos]                   = \"  sincos                          \";\n+  name[StatInt_sincosf]                  = \"  sincosf                         \";\n+  name[StatInt_sincosl]                  = \"  sincosl                         \";\n+  name[StatInt_remquo]                   = \"  remquo                          \";\n+  name[StatInt_remquof]                  = \"  remquof                         \";\n+  name[StatInt_remquol]                  = \"  remquol                         \";\n+  name[StatInt_lgamma]                   = \"  lgamma                          \";\n+  name[StatInt_lgammaf]                  = \"  lgammaf                         \";\n+  name[StatInt_lgammal]                  = \"  lgammal                         \";\n+  name[StatInt_lgamma_r]                 = \"  lgamma_r                        \";\n+  name[StatInt_lgammaf_r]                = \"  lgammaf_r                       \";\n+  name[StatInt_lgammal_r]                = \"  lgammal_r                       \";\n+  name[StatInt_drand48_r]                = \"  drand48_r                       \";\n+  name[StatInt_lrand48_r]                = \"  lrand48_r                       \";\n+  name[StatInt_getline]                  = \"  getline                         \";\n+  name[StatInt_getdelim]                 = \"  getdelim                        \";\n+  name[StatInt_iconv]                    = \"  iconv                           \";\n+  name[StatInt_times]                    = \"  times                           \";\n+\n+  name[StatInt_pthread_attr_getdetachstate]  = \"  pthread_addr_getdetachstate     \";  // NOLINT\n+  name[StatInt_pthread_attr_getguardsize]    = \"  pthread_addr_getguardsize       \";  // NOLINT\n+  name[StatInt_pthread_attr_getschedparam]   = \"  pthread_addr_getschedparam      \";  // NOLINT\n+  name[StatInt_pthread_attr_getschedpolicy]  = \"  pthread_addr_getschedpolicy     \";  // NOLINT\n+  name[StatInt_pthread_attr_getinheritsched] = \"  pthread_addr_getinheritsched    \";  // NOLINT\n+  name[StatInt_pthread_attr_getscope]        = \"  pthread_addr_getscope           \";  // NOLINT\n+  name[StatInt_pthread_attr_getstacksize]    = \"  pthread_addr_getstacksize       \";  // NOLINT\n+  name[StatInt_pthread_attr_getstack]        = \"  pthread_addr_getstack           \";  // NOLINT\n+  name[StatInt_pthread_attr_getaffinity_np]  = \"  pthread_addr_getaffinity_np     \";  // NOLINT\n \n   name[StatAnnotation]                   = \"Dynamic annotations               \";\n   name[StatAnnotateHappensBefore]        = \"  HappensBefore                   \";\n@@ -400,6 +457,8 @@ void StatOutput(u64 *stat) {\n   name[StatAnnotateIgnoreReadsEnd]       = \"  IgnoreReadsEnd                  \";\n   name[StatAnnotateIgnoreWritesBegin]    = \"  IgnoreWritesBegin               \";\n   name[StatAnnotateIgnoreWritesEnd]      = \"  IgnoreWritesEnd                 \";\n+  name[StatAnnotateIgnoreSyncBegin]      = \"  IgnoreSyncBegin                 \";\n+  name[StatAnnotateIgnoreSyncEnd]        = \"  IgnoreSyncEnd                   \";\n   name[StatAnnotatePublishMemoryRange]   = \"  PublishMemoryRange              \";\n   name[StatAnnotateUnpublishMemoryRange] = \"  UnpublishMemoryRange            \";\n   name[StatAnnotateThreadName]           = \"  ThreadName                      \";"}, {"sha": "998f1cd5e2e8897441ff8bc8bcc25fd236f50f15", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -137,6 +137,7 @@ enum StatType {\n   StatInt_strstr,\n   StatInt_strdup,\n   StatInt_atexit,\n+  StatInt__exit,\n   StatInt___cxa_guard_acquire,\n   StatInt___cxa_guard_release,\n   StatInt___cxa_guard_abort,\n@@ -174,6 +175,7 @@ enum StatType {\n   StatInt_pthread_barrier_wait,\n   StatInt_pthread_once,\n   StatInt_pthread_getschedparam,\n+  StatInt_pthread_setname_np,\n   StatInt_sem_init,\n   StatInt_sem_destroy,\n   StatInt_sem_wait,\n@@ -283,6 +285,7 @@ enum StatType {\n   StatInt_ctime_r,\n   StatInt_asctime,\n   StatInt_asctime_r,\n+  StatInt_strptime,\n   StatInt_frexp,\n   StatInt_frexpf,\n   StatInt_frexpl,\n@@ -351,6 +354,7 @@ enum StatType {\n   StatInt_sched_getaffinity,\n   StatInt_strerror,\n   StatInt_strerror_r,\n+  StatInt___xpg_strerror_r,\n   StatInt_scandir,\n   StatInt_scandir64,\n   StatInt_getgroups,\n@@ -364,6 +368,59 @@ enum StatType {\n   StatInt_sigprocmask,\n   StatInt_backtrace,\n   StatInt_backtrace_symbols,\n+  StatInt_dlopen,\n+  StatInt_dlclose,\n+  StatInt_getmntent,\n+  StatInt_getmntent_r,\n+  StatInt_statfs,\n+  StatInt_statfs64,\n+  StatInt_fstatfs,\n+  StatInt_fstatfs64,\n+  StatInt_statvfs,\n+  StatInt_statvfs64,\n+  StatInt_fstatvfs,\n+  StatInt_fstatvfs64,\n+  StatInt_initgroups,\n+  StatInt_ether_ntoa,\n+  StatInt_ether_aton,\n+  StatInt_ether_ntoa_r,\n+  StatInt_ether_aton_r,\n+  StatInt_ether_ntohost,\n+  StatInt_ether_hostton,\n+  StatInt_ether_line,\n+  StatInt_shmctl,\n+  StatInt_random_r,\n+  StatInt_tmpnam,\n+  StatInt_tmpnam_r,\n+  StatInt_tempnam,\n+  StatInt_sincos,\n+  StatInt_sincosf,\n+  StatInt_sincosl,\n+  StatInt_remquo,\n+  StatInt_remquof,\n+  StatInt_remquol,\n+  StatInt_lgamma,\n+  StatInt_lgammaf,\n+  StatInt_lgammal,\n+  StatInt_lgamma_r,\n+  StatInt_lgammaf_r,\n+  StatInt_lgammal_r,\n+  StatInt_drand48_r,\n+  StatInt_lrand48_r,\n+  StatInt_getline,\n+  StatInt_getdelim,\n+  StatInt_iconv,\n+  StatInt_times,\n+\n+  StatInt_pthread_attr_getdetachstate,\n+  StatInt_pthread_attr_getguardsize,\n+  StatInt_pthread_attr_getschedparam,\n+  StatInt_pthread_attr_getschedpolicy,\n+  StatInt_pthread_attr_getinheritsched,\n+  StatInt_pthread_attr_getscope,\n+  StatInt_pthread_attr_getstacksize,\n+  StatInt_pthread_attr_getstack,\n+  StatInt_pthread_attr_getaffinity_np,\n \n   // Dynamic annotations.\n   StatAnnotation,\n@@ -396,6 +453,8 @@ enum StatType {\n   StatAnnotateIgnoreReadsEnd,\n   StatAnnotateIgnoreWritesBegin,\n   StatAnnotateIgnoreWritesEnd,\n+  StatAnnotateIgnoreSyncBegin,\n+  StatAnnotateIgnoreSyncEnd,\n   StatAnnotatePublishMemoryRange,\n   StatAnnotateUnpublishMemoryRange,\n   StatAnnotateThreadName,"}, {"sha": "fa0c30dc28c94b3cde63eb9007c9cd49d236878e", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -85,6 +85,11 @@ void InitializeSuppressions() {\n #endif\n }\n \n+SuppressionContext *GetSuppressionContext() {\n+  CHECK_NE(g_ctx, 0);\n+  return g_ctx;\n+}\n+\n SuppressionType conv(ReportType typ) {\n   if (typ == ReportTypeRace)\n     return SuppressionRace;"}, {"sha": "2939e9a8b9f29c0652c8dcb741bffae63e0c2c63", "filename": "libsanitizer/tsan/tsan_suppressions.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -20,6 +20,7 @@ void InitializeSuppressions();\n void PrintMatchedSuppressions();\n uptr IsSuppressed(ReportType typ, const ReportStack *stack, Suppression **sp);\n uptr IsSuppressed(ReportType typ, const ReportLocation *loc, Suppression **sp);\n+SuppressionContext *GetSuppressionContext();\n \n }  // namespace __tsan\n "}, {"sha": "c0e794be2d2e80780921f1ea2d29920a5a6f1ac7", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -20,19 +20,17 @@\n \n namespace __tsan {\n \n-struct ScopedInSymbolizer {\n-  ScopedInSymbolizer() {\n-    ThreadState *thr = cur_thread();\n-    CHECK(!thr->in_symbolizer);\n-    thr->in_symbolizer = true;\n-  }\n+void EnterSymbolizer() {\n+  ThreadState *thr = cur_thread();\n+  CHECK(!thr->in_symbolizer);\n+  thr->in_symbolizer = true;\n+}\n \n-  ~ScopedInSymbolizer() {\n-    ThreadState *thr = cur_thread();\n-    CHECK(thr->in_symbolizer);\n-    thr->in_symbolizer = false;\n-  }\n-};\n+void ExitSymbolizer() {\n+  ThreadState *thr = cur_thread();\n+  CHECK(thr->in_symbolizer);\n+  thr->in_symbolizer = false;\n+}\n \n ReportStack *NewReportStackEntry(uptr addr) {\n   ReportStack *ent = (ReportStack*)internal_alloc(MBlockReportStack,\n@@ -42,18 +40,6 @@ ReportStack *NewReportStackEntry(uptr addr) {\n   return ent;\n }\n \n-// Strip module path to make output shorter.\n-static char *StripModuleName(const char *module) {\n-  if (module == 0)\n-    return 0;\n-  const char *short_module_name = internal_strrchr(module, '/');\n-  if (short_module_name)\n-    short_module_name += 1;\n-  else\n-    short_module_name = module;\n-  return internal_strdup(short_module_name);\n-}\n-\n static ReportStack *NewReportStackEntry(const AddressInfo &info) {\n   ReportStack *ent = NewReportStackEntry(info.address);\n   ent->module = StripModuleName(info.module);\n@@ -117,15 +103,14 @@ ReportStack *SymbolizeCode(uptr addr) {\n     ent->col = col;\n     return ent;\n   }\n-  if (!getSymbolizer()->IsAvailable())\n+  if (!Symbolizer::Get()->IsAvailable())\n     return SymbolizeCodeAddr2Line(addr);\n-  ScopedInSymbolizer in_symbolizer;\n   static const uptr kMaxAddrFrames = 16;\n   InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n   for (uptr i = 0; i < kMaxAddrFrames; i++)\n     new(&addr_frames[i]) AddressInfo();\n-  uptr addr_frames_num =\n-      getSymbolizer()->SymbolizeCode(addr, addr_frames.data(), kMaxAddrFrames);\n+  uptr addr_frames_num = Symbolizer::Get()->SymbolizeCode(\n+      addr, addr_frames.data(), kMaxAddrFrames);\n   if (addr_frames_num == 0)\n     return NewReportStackEntry(addr);\n   ReportStack *top = 0;\n@@ -144,11 +129,10 @@ ReportStack *SymbolizeCode(uptr addr) {\n }\n \n ReportLocation *SymbolizeData(uptr addr) {\n-  if (!getSymbolizer()->IsAvailable())\n+  if (!Symbolizer::Get()->IsAvailable())\n     return 0;\n-  ScopedInSymbolizer in_symbolizer;\n   DataInfo info;\n-  if (!getSymbolizer()->SymbolizeData(addr, &info))\n+  if (!Symbolizer::Get()->SymbolizeData(addr, &info))\n     return 0;\n   ReportLocation *ent = (ReportLocation*)internal_alloc(MBlockReportStack,\n                                                         sizeof(ReportLocation));\n@@ -164,10 +148,9 @@ ReportLocation *SymbolizeData(uptr addr) {\n }\n \n void SymbolizeFlush() {\n-  if (!getSymbolizer()->IsAvailable())\n+  if (!Symbolizer::Get()->IsAvailable())\n     return;\n-  ScopedInSymbolizer in_symbolizer;\n-  getSymbolizer()->Flush();\n+  Symbolizer::Get()->Flush();\n }\n \n }  // namespace __tsan"}, {"sha": "892c11c0667c01091bb6ae894191976a7a76f607", "filename": "libsanitizer/tsan/tsan_symbolize.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -16,6 +16,8 @@\n \n namespace __tsan {\n \n+void EnterSymbolizer();\n+void ExitSymbolizer();\n ReportStack *SymbolizeCode(uptr addr);\n ReportLocation *SymbolizeData(uptr addr);\n void SymbolizeFlush();"}, {"sha": "c278a42f3178786f40b8cd4106a6dcf512d4e0ed", "filename": "libsanitizer/tsan/tsan_symbolize_addr2line_linux.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize_addr2line_linux.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -58,7 +58,6 @@ static void NOINLINE InitModule(ModuleDesc *m) {\n   }\n   int pid = fork();\n   if (pid == 0) {\n-    __sanitizer_set_report_fd(STDERR_FILENO);\n     internal_close(STDOUT_FILENO);\n     internal_close(STDIN_FILENO);\n     internal_dup2(outfd[0], STDIN_FILENO);"}, {"sha": "0c5be105f67657a93e2fbe06cd12a7d5fbc34d79", "filename": "libsanitizer/tsan/tsan_sync.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -263,6 +263,11 @@ void StackTrace::ObtainCurrent(ThreadState *thr, uptr toppc) {\n       n_ = c_ - !!toppc;\n     }\n   } else {\n+    // Cap potentially huge stacks.\n+    if (n_ + !!toppc > kTraceStackSize) {\n+      start = n_ - kTraceStackSize + !!toppc;\n+      n_ = kTraceStackSize - !!toppc;\n+    }\n     s_ = (uptr*)internal_alloc(MBlockStackTrace,\n                                (n_ + !!toppc) * sizeof(s_[0]));\n   }"}, {"sha": "93ed8d907e5544ac969f4503d29617e30f886267", "filename": "libsanitizer/tsan/tsan_trace.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Ftsan%2Ftsan_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_trace.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -60,6 +60,11 @@ struct TraceHeader {\n struct Trace {\n   TraceHeader headers[kTraceParts];\n   Mutex mtx;\n+#ifndef TSAN_GO\n+  // Must be last to catch overflow as paging fault.\n+  // Go shadow stack is dynamically allocated.\n+  uptr shadow_stack[kShadowStackSize];\n+#endif\n \n   Trace()\n     : mtx(MutexTypeTrace, StatMtxTrace) {"}, {"sha": "786ffa7254f5ba9fc7887f3b0e6960c1b6b87bf1", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -24,12 +24,21 @@ Location __ubsan::getCallerLocation(uptr CallerLoc) {\n     return Location();\n \n   uptr Loc = StackTrace::GetPreviousInstructionPc(CallerLoc);\n+  return getFunctionLocation(Loc, 0);\n+}\n+\n+Location __ubsan::getFunctionLocation(uptr Loc, const char **FName) {\n+  if (!Loc)\n+    return Location();\n \n   AddressInfo Info;\n-  if (!getSymbolizer()->SymbolizeCode(Loc, &Info, 1) ||\n+  if (!Symbolizer::GetOrInit()->SymbolizeCode(Loc, &Info, 1) ||\n       !Info.module || !*Info.module)\n     return Location(Loc);\n \n+  if (FName && Info.function)\n+    *FName = Info.function;\n+\n   if (!Info.file)\n     return ModuleLocation(Info.module, Info.module_offset);\n \n@@ -66,29 +75,29 @@ static void PrintHex(UIntMax Val) {\n }\n \n static void renderLocation(Location Loc) {\n+  InternalScopedString LocBuffer(1024);\n   switch (Loc.getKind()) {\n   case Location::LK_Source: {\n     SourceLocation SLoc = Loc.getSourceLocation();\n     if (SLoc.isInvalid())\n-      Printf(\"<unknown>:\");\n-    else {\n-      Printf(\"%s:%d:\", SLoc.getFilename(), SLoc.getLine());\n-      if (SLoc.getColumn())\n-        Printf(\"%d:\", SLoc.getColumn());\n-    }\n+      LocBuffer.append(\"<unknown>\");\n+    else\n+      PrintSourceLocation(&LocBuffer, SLoc.getFilename(), SLoc.getLine(),\n+                          SLoc.getColumn());\n     break;\n   }\n   case Location::LK_Module:\n-    Printf(\"%s:0x%zx:\", Loc.getModuleLocation().getModuleName(),\n-           Loc.getModuleLocation().getOffset());\n+    PrintModuleAndOffset(&LocBuffer, Loc.getModuleLocation().getModuleName(),\n+                         Loc.getModuleLocation().getOffset());\n     break;\n   case Location::LK_Memory:\n-    Printf(\"%p:\", Loc.getMemoryLocation());\n+    LocBuffer.append(\"%p\", Loc.getMemoryLocation());\n     break;\n   case Location::LK_Null:\n-    Printf(\"<unknown>:\");\n+    LocBuffer.append(\"<unknown>\");\n     break;\n   }\n+  Printf(\"%s:\", LocBuffer.data());\n }\n \n static void renderText(const char *Message, const Diag::Arg *Args) {\n@@ -108,7 +117,7 @@ static void renderText(const char *Message, const Diag::Arg *Args) {\n         Printf(\"%s\", A.String);\n         break;\n       case Diag::AK_Mangled: {\n-        Printf(\"'%s'\", getSymbolizer()->Demangle(A.String));\n+        Printf(\"'%s'\", Symbolizer::GetOrInit()->Demangle(A.String));\n         break;\n       }\n       case Diag::AK_SInt:"}, {"sha": "0450368756812d5016b281e4a8d0748a0fff6c34", "filename": "libsanitizer/ubsan/ubsan_diag.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_diag.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_diag.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -78,6 +78,12 @@ class Location {\n /// an invalid location or a module location for the caller.\n Location getCallerLocation(uptr CallerLoc = GET_CALLER_PC());\n \n+/// Try to obtain a location for the given function pointer. This might fail,\n+/// and produce either an invalid location or a module location for the caller.\n+/// If FName is non-null and the name of the function is known, set *FName to\n+/// the function name, otherwise *FName is unchanged.\n+Location getFunctionLocation(uptr Loc, const char **FName);\n+\n /// A diagnostic severity level.\n enum DiagLevel {\n   DL_Error, ///< An error."}, {"sha": "dd2e7bbf3e5b86a7b9788eb8a1b82ef45a076585", "filename": "libsanitizer/ubsan/ubsan_handlers.cc", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -244,15 +244,36 @@ void __ubsan::__ubsan_handle_float_cast_overflow_abort(\n \n void __ubsan::__ubsan_handle_load_invalid_value(InvalidValueData *Data,\n                                                 ValueHandle Val) {\n-  // TODO: Add deduplication once a SourceLocation is generated for this check.\n-  Diag(getCallerLocation(), DL_Error,\n+  SourceLocation Loc = Data->Loc.acquire();\n+  if (Loc.isDisabled())\n+    return;\n+\n+  Diag(Loc, DL_Error,\n        \"load of value %0, which is not a valid value for type %1\")\n     << Value(Data->Type, Val) << Data->Type;\n }\n void __ubsan::__ubsan_handle_load_invalid_value_abort(InvalidValueData *Data,\n                                                       ValueHandle Val) {\n-  Diag(getCallerLocation(), DL_Error,\n-       \"load of value %0, which is not a valid value for type %1\")\n-    << Value(Data->Type, Val) << Data->Type;\n+  __ubsan_handle_load_invalid_value(Data, Val);\n+  Die();\n+}\n+\n+void __ubsan::__ubsan_handle_function_type_mismatch(\n+    FunctionTypeMismatchData *Data,\n+    ValueHandle Function) {\n+  const char *FName = \"(unknown)\";\n+\n+  Location Loc = getFunctionLocation(Function, &FName);\n+\n+  Diag(Data->Loc, DL_Error,\n+       \"call to function %0 through pointer to incorrect function type %1\")\n+    << FName << Data->Type;\n+  Diag(Loc, DL_Note, \"%0 defined here\") << FName;\n+}\n+\n+void __ubsan::__ubsan_handle_function_type_mismatch_abort(\n+    FunctionTypeMismatchData *Data,\n+    ValueHandle Function) {\n+  __ubsan_handle_function_type_mismatch(Data, Function);\n   Die();\n }"}, {"sha": "226faadc287362023fbd99a1514e96e13ce4a0e8", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -103,13 +103,22 @@ struct FloatCastOverflowData {\n RECOVERABLE(float_cast_overflow, FloatCastOverflowData *Data, ValueHandle From)\n \n struct InvalidValueData {\n-  // FIXME: SourceLocation Loc;\n+  SourceLocation Loc;\n   const TypeDescriptor &Type;\n };\n \n /// \\brief Handle a load of an invalid value for the type.\n RECOVERABLE(load_invalid_value, InvalidValueData *Data, ValueHandle Val)\n \n+struct FunctionTypeMismatchData {\n+  SourceLocation Loc;\n+  const TypeDescriptor &Type;\n+};\n+\n+RECOVERABLE(function_type_mismatch,\n+            FunctionTypeMismatchData *Data,\n+            ValueHandle Val)\n+\n }\n \n #endif // UBSAN_HANDLERS_H"}, {"sha": "d01009426db0632e6427ac24dbcd96bd7bdfa851", "filename": "libsanitizer/ubsan/ubsan_type_hash.cc", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash.cc?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -83,16 +83,18 @@ namespace abi = __cxxabiv1;\n // reused as needed. The second caching layer is a large hash table with open\n // chaining. We can freely evict from either layer since this is just a cache.\n //\n-// FIXME: Make these hash table accesses thread-safe. The races here are benign\n-//        (worst-case, we could miss a bug or see a slowdown) but we should\n-//        avoid upsetting race detectors.\n+// FIXME: Make these hash table accesses thread-safe. The races here are benign:\n+//        assuming the unsequenced loads and stores don't misbehave too badly,\n+//        the worst case is false negatives or poor cache behavior, not false\n+//        positives or crashes.\n \n /// Find a bucket to store the given hash value in.\n static __ubsan::HashValue *getTypeCacheHashTableBucket(__ubsan::HashValue V) {\n   static const unsigned HashTableSize = 65537;\n-  static __ubsan::HashValue __ubsan_vptr_hash_set[HashTableSize] = { 1 };\n+  static __ubsan::HashValue __ubsan_vptr_hash_set[HashTableSize];\n \n-  unsigned Probe = V & 65535;\n+  unsigned First = (V & 65535) ^ 1;\n+  unsigned Probe = First;\n   for (int Tries = 5; Tries; --Tries) {\n     if (!__ubsan_vptr_hash_set[Probe] || __ubsan_vptr_hash_set[Probe] == V)\n       return &__ubsan_vptr_hash_set[Probe];\n@@ -102,12 +104,12 @@ static __ubsan::HashValue *getTypeCacheHashTableBucket(__ubsan::HashValue V) {\n   }\n   // FIXME: Pick a random entry from the probe sequence to evict rather than\n   //        just taking the first.\n-  return &__ubsan_vptr_hash_set[V];\n+  return &__ubsan_vptr_hash_set[First];\n }\n \n /// A cache of recently-checked hashes. Mini hash table with \"random\" evictions.\n __ubsan::HashValue\n-__ubsan::__ubsan_vptr_type_cache[__ubsan::VptrTypeCacheSize] = { 1 };\n+__ubsan::__ubsan_vptr_type_cache[__ubsan::VptrTypeCacheSize];\n \n /// \\brief Determine whether \\p Derived has a \\p Base base class subobject at\n /// offset \\p Offset."}, {"sha": "6ca0f56c99d01d95a9e6d67e38321d0cb4c59ee8", "filename": "libsanitizer/ubsan/ubsan_value.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_value.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50/libsanitizer%2Fubsan%2Fubsan_value.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.h?ref=df77f0e4ec043bc4fa155efbd5c1c74ce73d2b50", "patch": "@@ -23,8 +23,8 @@\n \n // FIXME: Move this out to a config header.\n #if __SIZEOF_INT128__\n-typedef __int128 s128;\n-typedef unsigned __int128 u128;\n+__extension__ typedef __int128 s128;\n+__extension__ typedef unsigned __int128 u128;\n #define HAVE_INT128_T 1\n #else\n #define HAVE_INT128_T 0"}]}