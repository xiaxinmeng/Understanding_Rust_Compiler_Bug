{"sha": "609570b49e5b138416d6e46531586d4e93c6a429", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA5NTcwYjQ5ZTViMTM4NDE2ZDZlNDY1MzE1ODZkNGU5M2M2YTQyOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-09T00:29:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-09T00:29:14Z"}, "message": "re PR lto/65316 (LTO: Uninitialized memory / ICE with -g -fno-lto-odr-type-merging: in types_same_for_odr, at ipa-devirt.c:465)\n\n\n\tPR lto/65316\n\t* ipa-utils.h (types_odr_comparable): Add strict argument.\n\t* ipa-devirt.c: Fix whitespace;\n\t(odr_hasher): Remove.\n\t(odr_name_hasher, odr_vtable_hasher): New hashers.\n\t(can_be_name_hashed_p): New predicate.\n\t(hash_type_name): remove.\n\t(hash_odr_name): New.\n\t(odr_name_hasher::hash): new.\n\t(can_be_vtable_hashed_p): New.\n\t(hash_odr_vtable): New.\n\t(odr_vtable_hasher::hash): New.\n\t(types_same_for_odr): Add strict parameter.\n\t(types_odr_comparable): Likewise.\n\t(odr_name_hasher::equal): New.\n\t(odr_vtable_hasher::equal): New.\n\t(odr_name_hasher::remove): New.\n\t(odr_hash_type): Change to hash_table<odr_name_hasher>.\n\t(odr_vtable_hash_type): New.\n\t(odr_vtable_hash): New.\n\t(odr_subtypes_equivalent_p): Do strict comparsion.\n\t(add_type_duplicate): Merge type names; cleanup; avoid type\n\tduplicates.\n\t(register_odr_type): Initialize vtable hash.\n\t(build_type_inheritance_graph): Likewise\n\t(get_odr_type): Reorg to use two hashes.\n\t(dump_possible_polymorphic_call_targets): Move sanity check after debug\n\toutput.\n\t(ipa_devirt): Dump type_inheritance_graph.\n\t(types_same_for_odr): Add strict mode.\n\t* g++.dg/lto/pr65316_0.C: New testcase.\n\t* g++.dg/lto/pr65316_1.C: New testcase.\n\nFrom-SVN: r221275", "tree": {"sha": "3c04ffdb9f015763faab98002b1a0ecd3eb1f2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c04ffdb9f015763faab98002b1a0ecd3eb1f2d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/609570b49e5b138416d6e46531586d4e93c6a429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/609570b49e5b138416d6e46531586d4e93c6a429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/609570b49e5b138416d6e46531586d4e93c6a429", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/609570b49e5b138416d6e46531586d4e93c6a429/comments", "author": null, "committer": null, "parents": [{"sha": "e1e8e374f4c3c2fbc4f2b420f5c966f61a65d610", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1e8e374f4c3c2fbc4f2b420f5c966f61a65d610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1e8e374f4c3c2fbc4f2b420f5c966f61a65d610"}], "stats": {"total": 912, "additions": 634, "deletions": 278}, "files": [{"sha": "4c97e87b95079a5ad3534aa6005c4339570c92c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=609570b49e5b138416d6e46531586d4e93c6a429", "patch": "@@ -1,3 +1,36 @@\n+2015-03-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/65316\n+\t* ipa-utils.h (types_odr_comparable): Add strict argument.\n+\t* ipa-devirt.c: Fix whitespace;\n+\t(odr_hasher): Remove.\n+\t(odr_name_hasher, odr_vtable_hasher): New hashers.\n+\t(can_be_name_hashed_p): New predicate.\n+\t(hash_type_name): remove.\n+\t(hash_odr_name): New.\n+\t(odr_name_hasher::hash): new.\n+\t(can_be_vtable_hashed_p): New.\n+\t(hash_odr_vtable): New.\n+\t(odr_vtable_hasher::hash): New.\n+\t(types_same_for_odr): Add strict parameter.\n+\t(types_odr_comparable): Likewise.\n+\t(odr_name_hasher::equal): New.\n+\t(odr_vtable_hasher::equal): New.\n+\t(odr_name_hasher::remove): New.\n+\t(odr_hash_type): Change to hash_table<odr_name_hasher>.\n+\t(odr_vtable_hash_type): New.\n+\t(odr_vtable_hash): New.\n+\t(odr_subtypes_equivalent_p): Do strict comparsion.\n+\t(add_type_duplicate): Merge type names; cleanup; avoid type\n+\tduplicates.\n+\t(register_odr_type): Initialize vtable hash.\n+\t(build_type_inheritance_graph): Likewise\n+\t(get_odr_type): Reorg to use two hashes.\n+\t(dump_possible_polymorphic_call_targets): Move sanity check after debug\n+\toutput.\n+\t(ipa_devirt): Dump type_inheritance_graph.\n+\t(types_same_for_odr): Add strict mode.\n+\n 2015-03-05  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65334"}, {"sha": "a3feb8823ca26c6a7abe3ecd10d9e24703e6c0be", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 450, "deletions": 276, "changes": 726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=609570b49e5b138416d6e46531586d4e93c6a429", "patch": "@@ -61,7 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n        In the case of single inheritance, the virtual table is shared\n        and BINFO_VTABLE of base BINFO is NULL.  In the case of multiple\n        inheritance the individual virtual tables are pointer to by\n-       BINFO_VTABLE of base binfos (that differs of BINFO_VTABLE of \n+       BINFO_VTABLE of base binfos (that differs of BINFO_VTABLE of\n        binfo associated to the base type).\n \n        BINFO lookup for a given base type and offset can be done by\n@@ -88,7 +88,7 @@ along with GCC; see the file COPYING3.  If not see\n      This means that the graph is not complete. Types with no methods are not\n      inserted into the graph.  Also types without virtual methods are not\n      represented at all, though it may be easy to add this.\n-  \n+ \n      The inheritance graph is represented as follows:\n \n        Vertices are structures odr_type.  Every odr_type may correspond\n@@ -213,7 +213,7 @@ static bool odr_violation_reported = false;\n static hash_set<cgraph_node *> *cached_polymorphic_call_targets;\n \n /* The node of type inheritance graph.  For each type unique in\n-   One Definition Rule (ODR) sense, we produce one node linking all \n+   One Definition Rule (ODR) sense, we produce one node linking all\n    main variants of types equivalent to it, bases and derived types.  */\n \n struct GTY(()) odr_type_d\n@@ -272,7 +272,7 @@ type_all_ctors_visible_p (tree t)\n \t && symtab->state >= CONSTRUCTION\n \t /* We can not always use type_all_derivations_known_p.\n \t    For function local types we must assume case where\n-\t    the function is COMDAT and shared in between units. \n+\t    the function is COMDAT and shared in between units.\n \n \t    TODO: These cases are quite easy to get, but we need\n \t    to keep track of C++ privatizing via -Wno-weak\n@@ -299,9 +299,10 @@ type_possibly_instantiated_p (tree t)\n   return vnode && vnode->definition;\n }\n \n-/* One Definition Rule hashtable helpers.  */\n+/* Hash used to unify ODR types based on their mangled name and for anonymous\n+   namespace types.  */\n \n-struct odr_hasher \n+struct odr_name_hasher\n {\n   typedef odr_type_d value_type;\n   typedef union tree_node compare_type;\n@@ -310,6 +311,16 @@ struct odr_hasher\n   static inline void remove (value_type *);\n };\n \n+/* Has used to unify ODR types based on their associated virtual table.\n+   This hash is needed to keep -fno-lto-odr-type-merging to work and contains\n+   only polymorphic types.  Types with mangled names are inserted to both.  */\n+\n+struct odr_vtable_hasher:odr_name_hasher\n+{\n+  static inline hashval_t hash (const value_type *);\n+  static inline bool equal (const value_type *, const compare_type *);\n+};\n+\n /* Return type that was declared with T's name so that T is an\n    qualified variant of it.  */\n \n@@ -323,10 +334,17 @@ main_odr_variant (const_tree t)\n     return TYPE_MAIN_VARIANT (t);\n }\n \n-/* Produce hash based on type name.  */\n+static bool\n+can_be_name_hashed_p (tree t)\n+{\n+  return (!in_lto_p || type_in_anonymous_namespace_p (t)\n+\t  || (TYPE_NAME (t) && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))));\n+}\n+\n+/* Hash type by its ODR name.  */\n \n static hashval_t\n-hash_type_name (tree t)\n+hash_odr_name (const_tree t)\n {\n   gcc_checking_assert (main_odr_variant (t) == t);\n \n@@ -339,65 +357,91 @@ hash_type_name (tree t)\n   if (type_in_anonymous_namespace_p (t))\n     return htab_hash_pointer (t);\n \n-  /* ODR types have name specified.  */\n-  if (TYPE_NAME (t)\n-      && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)))\n-    return IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME (TYPE_NAME (t)));\n+  gcc_checking_assert (TYPE_NAME (t)\n+\t\t       && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t)));\n+  return IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME (TYPE_NAME (t)));\n+}\n \n-  /* For polymorphic types that was compiled with -fno-lto-odr-type-merging\n-     we can simply hash the virtual table.  */\n-  if (TREE_CODE (t) == RECORD_TYPE\n-      && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)))\n-    {\n-      tree v = BINFO_VTABLE (TYPE_BINFO (t));\n-      hashval_t hash = 0;\n+/* Return the computed hashcode for ODR_TYPE.  */\n \n-      if (TREE_CODE (v) == POINTER_PLUS_EXPR)\n-\t{\n-\t  hash = TREE_INT_CST_LOW (TREE_OPERAND (v, 1));\n-\t  v = TREE_OPERAND (TREE_OPERAND (v, 0), 0);\n-\t}\n+inline hashval_t\n+odr_name_hasher::hash (const value_type *odr_type)\n+{\n+  return hash_odr_name (odr_type->type);\n+}\n+\n+static bool\n+can_be_vtable_hashed_p (tree t)\n+{\n+  /* vtable hashing can distinguish only main variants.  */\n+  if (TYPE_MAIN_VARIANT (t) != t)\n+    return false;\n+  /* Anonymous namespace types are always handled by name hash.  */\n+  if (type_in_anonymous_namespace_p (t))\n+    return false;\n+  return (TREE_CODE (t) == RECORD_TYPE\n+\t  && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)));\n+}\n+\n+/* Hash type by assembler name of its vtable.  */\n+\n+static hashval_t\n+hash_odr_vtable (const_tree t)\n+{\n+  tree v = BINFO_VTABLE (TYPE_BINFO (TYPE_MAIN_VARIANT (t)));\n+  inchash::hash hstate;\n+\n+  gcc_checking_assert (in_lto_p);\n+  gcc_checking_assert (!type_in_anonymous_namespace_p (t));\n+  gcc_checking_assert (TREE_CODE (t) == RECORD_TYPE\n+\t\t       && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)));\n+  gcc_checking_assert (main_odr_variant (t) == t);\n \n-      v = DECL_ASSEMBLER_NAME (v);\n-      hash = iterative_hash_hashval_t (hash, htab_hash_pointer (v));\n-      return hash;\n+  if (TREE_CODE (v) == POINTER_PLUS_EXPR)\n+    {\n+      add_expr (TREE_OPERAND (v, 1), hstate);\n+      v = TREE_OPERAND (TREE_OPERAND (v, 0), 0);\n     }\n \n-  /* Builtin types may appear as main variants of ODR types and are unique.\n-     Sanity check we do not get anything that looks non-builtin.  */\n-  gcc_checking_assert (TREE_CODE (t) == INTEGER_TYPE\n-\t\t       || TREE_CODE (t) == VOID_TYPE\n-\t\t       || TREE_CODE (t) == COMPLEX_TYPE\n-\t\t       || TREE_CODE (t) == REAL_TYPE\n-\t\t       || TREE_CODE (t) == POINTER_TYPE);\n-  return htab_hash_pointer (t);\n+  hstate.add_wide_int (IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME (v)));\n+  return hstate.end ();\n }\n \n /* Return the computed hashcode for ODR_TYPE.  */\n \n inline hashval_t\n-odr_hasher::hash (const value_type *odr_type)\n+odr_vtable_hasher::hash (const value_type *odr_type)\n {\n-  return hash_type_name (odr_type->type);\n+  return hash_odr_vtable (odr_type->type);\n }\n \n /* For languages with One Definition Rule, work out if\n    types are the same based on their name.\n- \n+\n    This is non-trivial for LTO where minor differences in\n    the type representation may have prevented type merging\n    to merge two copies of otherwise equivalent type.\n \n    Until we start streaming mangled type names, this function works\n-   only for polymorphic types.  */\n+   only for polymorphic types.\n+\n+   When STRICT is true, we compare types by their names for purposes of\n+   ODR violation warnings.  When strict is false, we consider variants\n+   equivalent, becuase it is all that matters for devirtualization machinery.\n+*/\n \n bool\n-types_same_for_odr (const_tree type1, const_tree type2)\n+types_same_for_odr (const_tree type1, const_tree type2, bool strict)\n {\n   gcc_checking_assert (TYPE_P (type1) && TYPE_P (type2));\n \n   type1 = main_odr_variant (type1);\n   type2 = main_odr_variant (type2);\n+  if (!strict)\n+    {\n+      type1 = TYPE_MAIN_VARIANT (type1);\n+      type2 = TYPE_MAIN_VARIANT (type2);\n+    }\n \n   if (type1 == type2)\n     return true;\n@@ -434,7 +478,8 @@ types_same_for_odr (const_tree type1, const_tree type2)\n       if (TREE_CODE (type1) != TREE_CODE (type2))\n \treturn false;\n       if (TREE_CODE (type1) == RECORD_TYPE\n-\t  && (TYPE_BINFO (type1) == NULL_TREE) != (TYPE_BINFO (type1) == NULL_TREE))\n+\t  && (TYPE_BINFO (type1) == NULL_TREE)\n+\t      != (TYPE_BINFO (type1) == NULL_TREE))\n \treturn false;\n       if (TREE_CODE (type1) == RECORD_TYPE && TYPE_BINFO (type1)\n \t  && (BINFO_VTABLE (TYPE_BINFO (type1)) == NULL_TREE)\n@@ -471,13 +516,16 @@ types_same_for_odr (const_tree type1, const_tree type2)\n /* Return true if we can decide on ODR equivalency.\n \n    In non-LTO it is always decide, in LTO however it depends in the type has\n-   ODR info attached.  */\n+   ODR info attached.\n+\n+   When STRICT is false, compare main variants.  */\n \n bool\n-types_odr_comparable (tree t1, tree t2)\n+types_odr_comparable (tree t1, tree t2, bool strict)\n {\n   return (!in_lto_p\n-\t  || main_odr_variant (t1) == main_odr_variant (t2)\n+\t  || (strict ? main_odr_variant (t1) == main_odr_variant (t2)\n+\t      : TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n \t  || (odr_type_p (t1) && odr_type_p (t2))\n \t  || (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE\n \t      && TYPE_BINFO (t1) && TYPE_BINFO (t2)\n@@ -494,29 +542,63 @@ types_must_be_same_for_odr (tree t1, tree t2)\n   if (types_odr_comparable (t1, t2))\n     return types_same_for_odr (t1, t2);\n   else\n-    return main_odr_variant (t1) == main_odr_variant (t2);\n+    return TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2);\n }\n \n /* Compare types T1 and T2 and return true if they are\n    equivalent.  */\n \n inline bool\n-odr_hasher::equal (const value_type *t1, const compare_type *ct2)\n+odr_name_hasher::equal (const value_type *o1, const compare_type *t2)\n {\n-  tree t2 = const_cast <tree> (ct2);\n+  tree t1 = o1->type;\n \n   gcc_checking_assert (main_odr_variant (t2) == t2);\n-  if (t1->type == t2)\n+  gcc_checking_assert (main_odr_variant (t1) == t1);\n+  if (t1 == t2)\n     return true;\n   if (!in_lto_p)\n     return false;\n-  return types_same_for_odr (t1->type, t2);\n+  /* Check for anonymous namespaces. Those have !TREE_PUBLIC\n+     on the corresponding TYPE_STUB_DECL.  */\n+  if (type_in_anonymous_namespace_p (t1)\n+      || type_in_anonymous_namespace_p (t2))\n+    return false;\n+  gcc_checking_assert (DECL_ASSEMBLER_NAME (TYPE_NAME (t1)));\n+  gcc_checking_assert (DECL_ASSEMBLER_NAME (TYPE_NAME (t2)));\n+  return (DECL_ASSEMBLER_NAME (TYPE_NAME (t1))\n+\t  == DECL_ASSEMBLER_NAME (TYPE_NAME (t2)));\n+}\n+\n+/* Compare types T1 and T2 and return true if they are\n+   equivalent.  */\n+\n+inline bool\n+odr_vtable_hasher::equal (const value_type *o1, const compare_type *t2)\n+{\n+  tree t1 = o1->type;\n+\n+  gcc_checking_assert (main_odr_variant (t2) == t2);\n+  gcc_checking_assert (main_odr_variant (t1) == t1);\n+  gcc_checking_assert (in_lto_p);\n+  t1 = TYPE_MAIN_VARIANT (t1);\n+  t2 = TYPE_MAIN_VARIANT (t2);\n+  if (t1 == t2)\n+    return true;\n+  tree v1 = BINFO_VTABLE (TYPE_BINFO (t1));\n+  tree v2 = BINFO_VTABLE (TYPE_BINFO (t2));\n+  return (operand_equal_p (TREE_OPERAND (v1, 1),\n+\t\t\t   TREE_OPERAND (v2, 1), 0)\n+\t  && DECL_ASSEMBLER_NAME\n+\t\t (TREE_OPERAND (TREE_OPERAND (v1, 0), 0))\n+\t     == DECL_ASSEMBLER_NAME\n+\t\t (TREE_OPERAND (TREE_OPERAND (v2, 0), 0)));\n }\n \n /* Free ODR type V.  */\n \n inline void\n-odr_hasher::remove (value_type *v)\n+odr_name_hasher::remove (value_type *v)\n {\n   v->bases.release ();\n   v->derived_types.release ();\n@@ -527,8 +609,10 @@ odr_hasher::remove (value_type *v)\n \n /* ODR type hash used to look up ODR type based on tree type node.  */\n \n-typedef hash_table<odr_hasher> odr_hash_type;\n+typedef hash_table<odr_name_hasher> odr_hash_type;\n static odr_hash_type *odr_hash;\n+typedef hash_table<odr_vtable_hasher> odr_vtable_hash_type;\n+static odr_vtable_hash_type *odr_vtable_hash;\n \n /* ODR types are also stored into ODR_TYPE vector to allow consistent\n    walking.  Bases appear before derived types.  Vector is garbage collected\n@@ -573,9 +657,9 @@ odr_subtypes_equivalent_p (tree t1, tree t2,\n   /* For ODR types be sure to compare their names.\n      To support -wno-odr-type-merging we allow one type to be non-ODR\n      and other ODR even though it is a violation.  */\n-  if (types_odr_comparable (t1, t2))\n+  if (types_odr_comparable (t1, t2, true))\n     {\n-      if (!types_same_for_odr (t1, t2))\n+      if (!types_same_for_odr (t1, t2, true))\n         return false;\n       /* Limit recursion: If subtypes are ODR types and we know\n          that they are same, be happy.  */\n@@ -681,7 +765,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t{\n \t  /* Extra paranoia; compare the sizes.  We do not have information\n \t     about virtual inheritance offsets, so just be sure that these\n-\t     match.  \n+\t     match. \n \t     Do this as very last check so the not very informative error\n \t     is not output too often.  */\n \t  if (DECL_SIZE (prevailing->decl) != DECL_SIZE (vtable->decl))\n@@ -692,7 +776,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t\t\t      \"one definition rule  \",\n \t\t\t      DECL_CONTEXT (vtable->decl)))\n \t\t{\n-\t\t  inform (DECL_SOURCE_LOCATION \n+\t\t  inform (DECL_SOURCE_LOCATION\n \t\t\t    (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n \t\t\t  \"the conflicting type defined in another translation \"\n \t\t\t  \"unit has virtual table of different size\");\n@@ -718,10 +802,10 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t\t\t      \"one definition rule  \",\n \t\t\t      DECL_CONTEXT (vtable->decl)))\n \t\t{\n-\t\t  inform (DECL_SOURCE_LOCATION \n+\t\t  inform (DECL_SOURCE_LOCATION\n \t\t\t    (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n \t\t\t  \"the conflicting type defined in another translation \"\n-\t\t\t  \"unit virtual table with different RTTI information\");\n+\t\t\t  \"unit with different RTTI information\");\n \t\t}\n \t      return;\n \t    }\n@@ -794,7 +878,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t{\n \t  if (TREE_CODE (ref1->referred->decl) == FUNCTION_DECL)\n \t    {\n-\t      inform (DECL_SOURCE_LOCATION \n+\t      inform (DECL_SOURCE_LOCATION\n \t\t\t(TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n \t\t      \"the conflicting type defined in another translation \"\n \t\t      \"unit\");\n@@ -807,7 +891,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t\t      ref2->referred->decl);\n \t    }\n \t  else\n-\t    inform (DECL_SOURCE_LOCATION \n+\t    inform (DECL_SOURCE_LOCATION\n \t\t      (TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n \t\t    \"the conflicting type defined in another translation \"\n \t\t    \"unit has virtual table table with different contents\");\n@@ -1312,260 +1396,290 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \n /* TYPE is equivalent to VAL by ODR, but its tree representation differs\n    from VAL->type.  This may happen in LTO where tree merging did not merge\n-   all variants of the same type.  It may or may not mean the ODR violation.\n-   Add it to the list of duplicates and warn on some violations.  */\n+   all variants of the same type or due to ODR violation.\n+\n+   Analyze and report ODR violations and add type to duplicate list.\n+   If TYPE is more specified than VAL->type, prevail VAL->type.  Also if\n+   this is first time we see definition of a class return true so the\n+   base types are analyzed.  */\n \n static bool\n add_type_duplicate (odr_type val, tree type)\n {\n   bool build_bases = false;\n+  bool prevail = false;\n+\n   if (!val->types_set)\n     val->types_set = new hash_set<tree>;\n \n   /* Always prefer complete type to be the leader.  */\n \n   if (!COMPLETE_TYPE_P (val->type) && COMPLETE_TYPE_P (type))\n-    build_bases = true;\n+    {\n+      prevail = true;\n+      build_bases = TYPE_BINFO (type);\n+    }\n   else if (COMPLETE_TYPE_P (val->type) && !COMPLETE_TYPE_P (type))\n     ;\n   else if (TREE_CODE (val->type) == ENUMERAL_TYPE\n \t   && TREE_CODE (type) == ENUMERAL_TYPE\n \t   && !TYPE_VALUES (val->type) && TYPE_VALUES (type))\n-    build_bases = true;\n+    prevail = true;\n   else if (TREE_CODE (val->type) == RECORD_TYPE\n \t   && TREE_CODE (type) == RECORD_TYPE\n \t   && TYPE_BINFO (type) && !TYPE_BINFO (val->type))\n-    build_bases = true;\n+    {\n+      gcc_assert (!val->bases.length ());\n+      build_bases = true;\n+      prevail = true;\n+    }\n \n-  if (build_bases)\n+  if (prevail)\n     {\n       tree tmp = type;\n \n       type = val->type;\n       val->type = tmp;\n     }\n \n-  /* See if this duplicate is new.  */\n-  if (!val->types_set->add (type))\n+  val->types_set->add (type);\n+\n+  /* If we now have a mangled name, be sure to record it to val->type\n+     so ODR hash can work.  */\n+\n+  if (can_be_name_hashed_p (type) && !can_be_name_hashed_p (val->type))\n+    SET_DECL_ASSEMBLER_NAME (TYPE_NAME (val->type),\n+\t\t\t     DECL_ASSEMBLER_NAME (TYPE_NAME (type)));\n+\n+  bool merge = true;\n+  bool base_mismatch = false;\n+  unsigned int i;\n+  bool warned = false;\n+  hash_set<type_pair,pair_traits> visited;\n+\n+  gcc_assert (in_lto_p);\n+  vec_safe_push (val->types, type);\n+\n+  /* First we compare memory layout.  */\n+  if (!odr_types_equivalent_p (val->type, type,\n+\t\t\t       !flag_ltrans && !val->odr_violated,\n+\t\t\t       &warned, &visited))\n     {\n-      bool merge = true;\n-      bool base_mismatch = false;\n-      unsigned int i;\n-      bool warned = false;\n-      hash_set<type_pair,pair_traits> visited;\n+      merge = false;\n+      odr_violation_reported = true;\n+      val->odr_violated = true;\n+      if (symtab->dump_file)\n+\t{\n+\t  fprintf (symtab->dump_file, \"ODR violation\\n\");\n \n-      gcc_assert (in_lto_p);\n-      vec_safe_push (val->types, type);\n+\t  print_node (symtab->dump_file, \"\", val->type, 0);\n+\t  putc ('\\n',symtab->dump_file);\n+\t  print_node (symtab->dump_file, \"\", type, 0);\n+\t  putc ('\\n',symtab->dump_file);\n+\t}\n+    }\n \n-      /* First we compare memory layout.  */\n-      if (!odr_types_equivalent_p (val->type, type,\n-\t\t\t\t   !flag_ltrans && !val->odr_violated,\n-\t\t\t\t   &warned, &visited))\n+  /* Next sanity check that bases are the same.  If not, we will end\n+     up producing wrong answers.  */\n+  if (COMPLETE_TYPE_P (type) && COMPLETE_TYPE_P (val->type)\n+      && TREE_CODE (val->type) == RECORD_TYPE\n+      && TREE_CODE (type) == RECORD_TYPE\n+      && TYPE_BINFO (val->type) && TYPE_BINFO (type))\n+    {\n+      if (BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n+\t  != BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)))\n+\t{\n+\t  if (!warned && !val->odr_violated)\n+\t    {\n+\t      tree extra_base;\n+\t      warn_odr (type, val->type, NULL, NULL, !warned, &warned,\n+\t\t\t\"a type with the same name but different \"\n+\t\t\t\"number of polymorphic bases is \"\n+\t\t\t\"defined in another translation unit\");\n+\t      if (BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n+\t\t  > BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)))\n+\t\textra_base = BINFO_BASE_BINFO\n+\t\t\t     (TYPE_BINFO (type),\n+\t\t\t      BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)));\n+\t      else\n+\t\textra_base = BINFO_BASE_BINFO\n+\t\t\t     (TYPE_BINFO (val->type),\n+\t\t\t      BINFO_N_BASE_BINFOS (TYPE_BINFO (type)));\n+\t      inform (DECL_SOURCE_LOCATION\n+\t\t\t(TYPE_NAME (DECL_CONTEXT (extra_base))),\n+\t\t      \"the extra base is defined here \");\n+\t    }\n+\t  base_mismatch = true;\n+\t}\n+      else\n+\tfor (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n+\t  {\n+\t    tree base1 = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n+\t    tree base2 = BINFO_BASE_BINFO (TYPE_BINFO (val->type), i);\n+\t    tree type1 = BINFO_TYPE (base1);\n+\t    tree type2 = BINFO_TYPE (base2);\n+\n+\t    if (types_odr_comparable (type1, type2))\n+\t      {\n+\t\tif (!types_same_for_odr (type1, type2))\n+\t\t  base_mismatch = true;\n+\t      }\n+\t    else\n+\t      {\n+\t\thash_set<type_pair,pair_traits> visited;\n+\t\tif (!odr_types_equivalent_p (type1, type2, false, NULL,\n+\t\t\t\t\t     &visited))\n+\t\t  base_mismatch = true;\n+\t      }\n+\t    if (base_mismatch)\n+\t      {\n+\t\tif (!warned && !val->odr_violated)\n+\t\t  {\n+\t\t    warn_odr (type, val->type, NULL, NULL,\n+\t\t\t      !warned, &warned,\n+\t\t\t      \"a type with the same name but different base \"\n+\t\t\t      \"type is defined in another translation unit\");\n+\t\t    if (warned)\n+\t\t      warn_types_mismatch (type1, type2);\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    if (BINFO_OFFSET (base1) != BINFO_OFFSET (base2))\n+\t      {\n+\t\tbase_mismatch = true;\n+\t\tif (!warned && !val->odr_violated)\n+\t\t  warn_odr (type, val->type, NULL, NULL,\n+\t\t\t    !warned, &warned,\n+\t\t\t    \"a type with the same name but different base \"\n+\t\t\t    \"layout is defined in another translation unit\");\n+\t\tbreak;\n+\t      }\n+\t    /* One of bases is not of complete type.  */\n+\t    if (!TYPE_BINFO (type1) != !TYPE_BINFO (type2))\n+\t      {\n+\t\t/* If we have a polymorphic type info specified for TYPE1\n+\t\t   but not for TYPE2 we possibly missed a base when recording\n+\t\t   VAL->type earlier.\n+\t\t   Be sure this does not happen.  */\n+\t\tgcc_assert (TYPE_BINFO (type2)\n+\t\t\t    || !polymorphic_type_binfo_p (TYPE_BINFO (type1))\n+\t\t\t    || build_bases);\n+\t        break;\n+\t      }\n+\t    /* One base is polymorphic and the other not.\n+\t       This ought to be diagnosed earlier, but do not ICE in the\n+\t       checking bellow.  */\n+\t    else if (TYPE_BINFO (type1)\n+\t\t     && polymorphic_type_binfo_p (TYPE_BINFO (type1))\n+\t\t        != polymorphic_type_binfo_p (TYPE_BINFO (type2)))\n+\t      {\n+\t\tgcc_assert (val->odr_violated);\n+\t\tbase_mismatch = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n+#ifdef ENABLE_CHECKING\n+      /* Sanity check that all bases will be build same way again.  */\n+      if (!base_mismatch && val->bases.length ())\n+\t{\n+\t  unsigned int num_poly_bases = 0;\n+\t  unsigned int j;\n+\n+\t  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n+\t    if (polymorphic_type_binfo_p (BINFO_BASE_BINFO\n+\t\t\t\t\t     (TYPE_BINFO (type), i)))\n+\t      num_poly_bases++;\n+\t  gcc_assert (num_poly_bases == val->bases.length ());\n+\t  for (j = 0, i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n+\t       i++)\n+\t    if (polymorphic_type_binfo_p (BINFO_BASE_BINFO\n+\t\t\t\t\t   (TYPE_BINFO (type), i)))\n+\t      {\n+\t\todr_type base = get_odr_type\n+\t\t\t\t   (BINFO_TYPE\n+\t\t\t\t      (BINFO_BASE_BINFO (TYPE_BINFO (type),\n+\t\t\t\t\t\t\t i)),\n+\t\t\t\t    true);\n+\t\tgcc_assert (val->bases[j] == base);\n+\t\tj++;\n+\t      }\n+\t}\n+#endif\n+      if (base_mismatch)\n \t{\n \t  merge = false;\n \t  odr_violation_reported = true;\n \t  val->odr_violated = true;\n+\n \t  if (symtab->dump_file)\n \t    {\n-\t      fprintf (symtab->dump_file, \"ODR violation\\n\");\n+\t      fprintf (symtab->dump_file, \"ODR base violation\\n\");\n \t    \n \t      print_node (symtab->dump_file, \"\", val->type, 0);\n \t      putc ('\\n',symtab->dump_file);\n \t      print_node (symtab->dump_file, \"\", type, 0);\n \t      putc ('\\n',symtab->dump_file);\n \t    }\n \t}\n+    }\n \n-      /* Next sanity check that bases are the same.  If not, we will end\n-\t up producing wrong answers.  */\n-      if (COMPLETE_TYPE_P (type) && COMPLETE_TYPE_P (val->type)\n-\t  && TREE_CODE (val->type) == RECORD_TYPE\n-\t  && TREE_CODE (type) == RECORD_TYPE\n-\t  && TYPE_BINFO (val->type) && TYPE_BINFO (type))\n-\t{\n-\t  if (BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n-\t      != BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)))\n-\t    {\n-\t      if (!warned && !val->odr_violated)\n-\t\t{\n-\t\t  tree extra_base;\n-\t\t  warn_odr (type, val->type, NULL, NULL, !warned, &warned,\n-\t\t\t    \"a type with the same name but different \"\n-\t\t\t    \"number of polymorphic bases is \"\n-\t\t\t    \"defined in another translation unit\");\n-\t\t  if (BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n-\t\t      > BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)))\n-\t\t    extra_base = BINFO_BASE_BINFO\n-\t\t\t\t (TYPE_BINFO (type),\n-\t\t\t\t  BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)));\n-\t\t  else\n-\t\t    extra_base = BINFO_BASE_BINFO\n-\t\t\t\t (TYPE_BINFO (val->type),\n-\t\t\t\t  BINFO_N_BASE_BINFOS (TYPE_BINFO (type)));\n-\t\t  inform (DECL_SOURCE_LOCATION \n-\t\t\t    (TYPE_NAME (DECL_CONTEXT (extra_base))),\n-\t\t\t  \"the extra base is defined here \");\n-\t\t}\n-\t      base_mismatch = true;\n-\t    }\n-\t  else\n-\t    for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n-\t      {\n-\t\ttree base1 = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n-\t\ttree base2 = BINFO_BASE_BINFO (TYPE_BINFO (val->type), i);\n-\t\ttree type1 = BINFO_TYPE (base1);\n-\t\ttree type2 = BINFO_TYPE (base2);\n-\n-\t\tif (types_odr_comparable (type1, type2))\n-\t\t  {\n-\t\t    if (!types_same_for_odr (type1, type2))\n-\t\t      base_mismatch = true;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    hash_set<type_pair,pair_traits> visited;\n-\t\t    if (!odr_types_equivalent_p (type1, type2, false, NULL,\n-\t\t\t\t\t\t &visited))\n-\t\t      base_mismatch = true;\n-\t\t  }\n-\t\tif (base_mismatch)\n-\t\t  {\n-\t\t    if (!warned && !val->odr_violated)\n-\t\t      {\n-\t\t\twarn_odr (type, val->type, NULL, NULL,\n-\t\t\t\t  !warned, &warned,\n-\t\t\t\t  \"a type with the same name but different base \"\n-\t\t\t\t  \"type is defined in another translation unit\");\n-\t\t\tif (warned)\n-\t\t\t  warn_types_mismatch (type1, type2);\n-\t\t      }\n-\t\t    break;\n-\t\t  }\n-\t\tif (BINFO_OFFSET (base1) != BINFO_OFFSET (base2))\n-\t\t  {\n-\t\t    base_mismatch = true;\n-\t\t    if (!warned && !val->odr_violated)\n-\t\t      warn_odr (type, val->type, NULL, NULL,\n-\t\t\t\t!warned, &warned,\n-\t\t\t\t\"a type with the same name but different base \"\n-\t\t\t\t\"layout is defined in another translation unit\");\n-\t\t    break;\n-\t\t  }\n-\t\t/* One base is polymorphic and the other not.\n-\t\t   This ought to be diagnosed earlier, but do not ICE in the\n-\t \t   checking bellow.  */\n-\t\tif (!TYPE_BINFO (type1) != !TYPE_BINFO (type2)\n-\t\t    || (TYPE_BINFO (type1)\n-\t\t\t&& polymorphic_type_binfo_p (TYPE_BINFO (type1))\n-\t\t           != polymorphic_type_binfo_p (TYPE_BINFO (type2))))\n-\t\t  {\n-\t\t    base_mismatch = true;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-#ifdef ENABLE_CHECKING\n-\t  /* Sanity check that all bases will be build same way again.  */\n-\t  if (!base_mismatch && val->bases.length ())\n-\t    {\n-\t      unsigned int num_poly_bases = 0;\n-\t      unsigned int j;\n-\n-\t      for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n-\t\tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO\n-\t\t\t\t\t\t (TYPE_BINFO (type), i)))\n-\t\t  num_poly_bases++;\n-\t      gcc_assert (num_poly_bases == val->bases.length ());\n-\t      for (j = 0, i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n-\t\t   i++)\n-\t\tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO \n-\t\t\t\t\t       (TYPE_BINFO (type), i)))\n-\t\t  {\n-\t\t    odr_type base = get_odr_type\n-\t\t\t\t       (BINFO_TYPE\n-\t\t\t\t\t  (BINFO_BASE_BINFO (TYPE_BINFO (type),\n-\t\t\t\t\t\t\t     i)),\n-\t\t\t\t\ttrue);\n-\t\t    gcc_assert (val->bases[j] == base);\n-\t\t    j++;\n-\t\t  }\n-\t    }\n-#endif\n-\t  if (base_mismatch)\n-\t    {\n-\t      merge = false;\n-\t      odr_violation_reported = true;\n-\t      val->odr_violated = true;\n+  /* Regularize things a little.  During LTO same types may come with\n+     different BINFOs.  Either because their virtual table was\n+     not merged by tree merging and only later at decl merging or\n+     because one type comes with external vtable, while other\n+     with internal.  We want to merge equivalent binfos to conserve\n+     memory and streaming overhead.\n+\n+     The external vtables are more harmful: they contain references\n+     to external declarations of methods that may be defined in the\n+     merged LTO unit.  For this reason we absolutely need to remove\n+     them and replace by internal variants. Not doing so will lead\n+     to incomplete answers from possible_polymorphic_call_targets.\n+\n+     FIXME: disable for now; because ODR types are now build during\n+     streaming in, the variants do not need to be linked to the type,\n+     yet.  We need to do the merging in cleanup pass to be implemented\n+     soon.  */\n+  if (!flag_ltrans && merge\n+      && 0\n+      && TREE_CODE (val->type) == RECORD_TYPE\n+      && TREE_CODE (type) == RECORD_TYPE\n+      && TYPE_BINFO (val->type) && TYPE_BINFO (type)\n+      && TYPE_MAIN_VARIANT (type) == type\n+      && TYPE_MAIN_VARIANT (val->type) == val->type\n+      && BINFO_VTABLE (TYPE_BINFO (val->type))\n+      && BINFO_VTABLE (TYPE_BINFO (type)))\n+    {\n+      tree master_binfo = TYPE_BINFO (val->type);\n+      tree v1 = BINFO_VTABLE (master_binfo);\n+      tree v2 = BINFO_VTABLE (TYPE_BINFO (type));\n \n-\t      if (symtab->dump_file)\n-\t\t{\n-\t\t  fprintf (symtab->dump_file, \"ODR base violation\\n\");\n-\t\t\n-\t\t  print_node (symtab->dump_file, \"\", val->type, 0);\n-\t\t  putc ('\\n',symtab->dump_file);\n-\t\t  print_node (symtab->dump_file, \"\", type, 0);\n-\t\t  putc ('\\n',symtab->dump_file);\n-\t\t}\n-\t    }\n+      if (TREE_CODE (v1) == POINTER_PLUS_EXPR)\n+\t{\n+\t  gcc_assert (TREE_CODE (v2) == POINTER_PLUS_EXPR\n+\t\t      && operand_equal_p (TREE_OPERAND (v1, 1),\n+\t\t\t\t\t  TREE_OPERAND (v2, 1), 0));\n+\t  v1 = TREE_OPERAND (TREE_OPERAND (v1, 0), 0);\n+\t  v2 = TREE_OPERAND (TREE_OPERAND (v2, 0), 0);\n \t}\n+      gcc_assert (DECL_ASSEMBLER_NAME (v1)\n+\t\t  == DECL_ASSEMBLER_NAME (v2));\n \n-      /* Regularize things a little.  During LTO same types may come with\n-\t different BINFOs.  Either because their virtual table was\n-\t not merged by tree merging and only later at decl merging or\n-\t because one type comes with external vtable, while other\n-\t with internal.  We want to merge equivalent binfos to conserve\n-\t memory and streaming overhead.\n-\n-\t The external vtables are more harmful: they contain references\n-\t to external declarations of methods that may be defined in the\n-\t merged LTO unit.  For this reason we absolutely need to remove\n-\t them and replace by internal variants. Not doing so will lead\n-         to incomplete answers from possible_polymorphic_call_targets.\n-\n-\t FIXME: disable for now; because ODR types are now build during\n-\t streaming in, the variants do not need to be linked to the type,\n-\t yet.  We need to do the merging in cleanup pass to be implemented\n-\t soon.  */\n-      if (!flag_ltrans && merge\n-\t  && 0\n-\t  && TREE_CODE (val->type) == RECORD_TYPE\n-\t  && TREE_CODE (type) == RECORD_TYPE\n-\t  && TYPE_BINFO (val->type) && TYPE_BINFO (type)\n-\t  && TYPE_MAIN_VARIANT (type) == type\n-\t  && TYPE_MAIN_VARIANT (val->type) == val->type\n-\t  && BINFO_VTABLE (TYPE_BINFO (val->type))\n-\t  && BINFO_VTABLE (TYPE_BINFO (type)))\n+      if (DECL_EXTERNAL (v1) && !DECL_EXTERNAL (v2))\n \t{\n-\t  tree master_binfo = TYPE_BINFO (val->type);\n-\t  tree v1 = BINFO_VTABLE (master_binfo);\n-\t  tree v2 = BINFO_VTABLE (TYPE_BINFO (type));\n+\t  unsigned int i;\n \n-\t  if (TREE_CODE (v1) == POINTER_PLUS_EXPR)\n+\t  set_type_binfo (val->type, TYPE_BINFO (type));\n+\t  for (i = 0; i < val->types->length (); i++)\n \t    {\n-\t      gcc_assert (TREE_CODE (v2) == POINTER_PLUS_EXPR\n-\t\t\t  && operand_equal_p (TREE_OPERAND (v1, 1),\n-\t\t\t\t\t      TREE_OPERAND (v2, 1), 0));\n-\t      v1 = TREE_OPERAND (TREE_OPERAND (v1, 0), 0);\n-\t      v2 = TREE_OPERAND (TREE_OPERAND (v2, 0), 0);\n+\t      if (TYPE_BINFO ((*val->types)[i])\n+\t\t  == master_binfo)\n+\t\tset_type_binfo ((*val->types)[i], TYPE_BINFO (type));\n \t    }\n-\t  gcc_assert (DECL_ASSEMBLER_NAME (v1)\n-\t\t      == DECL_ASSEMBLER_NAME (v2));\n-\n-\t  if (DECL_EXTERNAL (v1) && !DECL_EXTERNAL (v2))\n-\t    {\n-\t      unsigned int i;\n-\n-\t      set_type_binfo (val->type, TYPE_BINFO (type));\n-\t      for (i = 0; i < val->types->length (); i++)\n-\t\t{\n-\t\t  if (TYPE_BINFO ((*val->types)[i])\n-\t\t      == master_binfo)\n-\t\t    set_type_binfo ((*val->types)[i], TYPE_BINFO (type));\n-\t\t}\n-\t      BINFO_TYPE (TYPE_BINFO (type)) = val->type;\n-\t    }\n-\t  else\n-\t    set_type_binfo (type, master_binfo);\n+\t  BINFO_TYPE (TYPE_BINFO (type)) = val->type;\n \t}\n+      else\n+\tset_type_binfo (type, master_binfo);\n     }\n   return build_bases;\n }\n@@ -1576,30 +1690,78 @@ add_type_duplicate (odr_type val, tree type)\n odr_type\n get_odr_type (tree type, bool insert)\n {\n-  odr_type_d **slot;\n-  odr_type val;\n+  odr_type_d **slot = NULL;\n+  odr_type_d **vtable_slot = NULL;\n+  odr_type val = NULL;\n   hashval_t hash;\n   bool build_bases = false;\n   bool insert_to_odr_array = false;\n   int base_id = -1;\n \n   type = main_odr_variant (type);\n \n-  hash = hash_type_name (type);\n-  slot = odr_hash->find_slot_with_hash (type, hash,\n-\t\t\t\t\tinsert ? INSERT : NO_INSERT);\n-  if (!slot)\n+  gcc_checking_assert (can_be_name_hashed_p (type)\n+\t\t       || can_be_vtable_hashed_p (type));\n+\n+  /* Lookup entry, first try name hash, fallback to vtable hash.  */\n+  if (can_be_name_hashed_p (type))\n+    {\n+      hash = hash_odr_name (type);\n+      slot = odr_hash->find_slot_with_hash (type, hash,\n+\t\t\t\t\t    insert ? INSERT : NO_INSERT);\n+    }\n+  if ((!slot || !*slot) && in_lto_p && can_be_vtable_hashed_p (type))\n+    {\n+      hash = hash_odr_vtable (type);\n+      vtable_slot = odr_vtable_hash->find_slot_with_hash (type, hash,\n+\t\t\t\t\t           insert ? INSERT : NO_INSERT);\n+    }\n+\n+  if (!slot && !vtable_slot)\n     return NULL;\n \n   /* See if we already have entry for type.  */\n-  if (*slot)\n+  if ((slot && *slot) || (vtable_slot && *vtable_slot))\n     {\n-      val = *slot;\n+      if (slot && *slot)\n+\t{\n+\t  val = *slot;\n+#ifdef ENABLE_CHECKING\n+\t  if (in_lto_p && can_be_vtable_hashed_p (type))\n+\t    {\n+\t      hash = hash_odr_vtable (type);\n+\t      vtable_slot = odr_vtable_hash->find_slot_with_hash (type, hash,\n+\t\t\t\t\t\t                  NO_INSERT);\n+\t      gcc_assert (!vtable_slot || *vtable_slot == *slot);\n+\t      vtable_slot = NULL;\n+\t    }\n+#endif\n+\t}\n+      else if (*vtable_slot)\n+\tval = *vtable_slot;\n \n-      /* With LTO we need to support multiple tree representation of\n-\t the same ODR type.  */\n-      if (val->type != type)\n-        build_bases = add_type_duplicate (val, type);\n+      if (val->type != type\n+\t  && (!val->types_set || !val->types_set->add (type)))\n+\t{\n+\t  gcc_assert (insert);\n+\t  /* We have type duplicate, but it may introduce vtable name or\n+ \t     mangled name; be sure to keep hashes in sync.  */\n+\t  if (in_lto_p && can_be_vtable_hashed_p (type)\n+\t      && (!vtable_slot || !*vtable_slot))\n+\t    {\n+\t      if (!vtable_slot)\n+\t\t{\n+\t\t  hash = hash_odr_vtable (type);\n+\t\t  vtable_slot = odr_vtable_hash->find_slot_with_hash\n+\t\t\t     (type, hash, INSERT);\n+\t\t  gcc_checking_assert (!*vtable_slot || *vtable_slot == val);\n+\t\t}\n+\t      *vtable_slot = val;\n+\t    }\n+\t  if (slot && !*slot)\n+\t    *slot = val;\n+\t  build_bases = add_type_duplicate (val, type);\n+\t}\n     }\n   else\n     {\n@@ -1610,7 +1772,10 @@ get_odr_type (tree type, bool insert)\n       val->anonymous_namespace = type_in_anonymous_namespace_p (type);\n       build_bases = COMPLETE_TYPE_P (val->type);\n       insert_to_odr_array = true;\n-      *slot = val;\n+      if (slot)\n+        *slot = val;\n+      if (vtable_slot)\n+\t*vtable_slot = val;\n     }\n \n   if (build_bases && TREE_CODE (type) == RECORD_TYPE && TYPE_BINFO (type)\n@@ -1664,7 +1829,11 @@ void\n register_odr_type (tree type)\n {\n   if (!odr_hash)\n-    odr_hash = new odr_hash_type (23);\n+    {\n+      odr_hash = new odr_hash_type (23);\n+      if (in_lto_p)\n+        odr_vtable_hash = new odr_vtable_hash_type (23);\n+    }\n   /* Arrange things to be nicer and insert main variants first.  */\n   if (odr_type_p (TYPE_MAIN_VARIANT (type)))\n     get_odr_type (TYPE_MAIN_VARIANT (type), true);\n@@ -1784,6 +1953,8 @@ build_type_inheritance_graph (void)\n   timevar_push (TV_IPA_INHERITANCE);\n   inheritance_dump_file = dump_begin (TDI_inheritance, &flags);\n   odr_hash = new odr_hash_type (23);\n+  if (in_lto_p)\n+    odr_vtable_hash = new odr_vtable_hash_type (23);\n \n   /* We reconstruct the graph starting of types of all methods seen in the\n      the unit.  */\n@@ -2839,12 +3010,12 @@ dump_possible_polymorphic_call_targets (FILE *f,\n   targets = possible_polymorphic_call_targets (otr_type, otr_token,\n \t\t\t\t\t       ctx,\n \t\t\t\t\t       &final, NULL, true);\n-  gcc_assert (targets.length () <= len);\n   if (targets.length () != len)\n     {\n       fprintf (f, \"  Speculative targets:\");\n       dump_targets (f, targets);\n     }\n+  gcc_assert (targets.length () <= len);\n   fprintf (f, \"\\n\");\n }\n \n@@ -3044,6 +3215,9 @@ ipa_devirt (void)\n   if (!odr_types_ptr)\n     return 0;\n \n+  if (dump_file)\n+    dump_type_inheritance_graph (dump_file);\n+\n   /* We can output -Wsuggest-final-methods and -Wsuggest-final-types warnings.\n      This is implemented by setting up final_warning_records that are updated\n      by get_polymorphic_call_targets."}, {"sha": "d302456ae94568e42307006768460ff2de42304e", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=609570b49e5b138416d6e46531586d4e93c6a429", "patch": "@@ -80,7 +80,7 @@ bool type_known_to_have_no_deriavations_p (tree);\n bool contains_polymorphic_type_p (const_tree);\n void register_odr_type (tree);\n bool types_must_be_same_for_odr (tree, tree);\n-bool types_odr_comparable (tree, tree);\n+bool types_odr_comparable (tree, tree, bool strict = false);\n cgraph_node *try_speculative_devirtualization (tree, HOST_WIDE_INT,\n \t\t\t\t\t       ipa_polymorphic_call_context);\n "}, {"sha": "50fc5d64d9e1eda245b9198daafc66fe016f03cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=609570b49e5b138416d6e46531586d4e93c6a429", "patch": "@@ -1,3 +1,9 @@\n+2015-03-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/65316\n+\t* g++.dg/lto/pr65316_0.C: New testcase.\n+\t* g++.dg/lto/pr65316_1.C: New testcase.\n+\n 2015-03-08  John David Anglin  <danglin@gcc.gnu.org>\n \n \tPR target/62247"}, {"sha": "cccd0db7d8ee75a8e252a3216488360edb886efc", "filename": "gcc/testsuite/g++.dg/lto/pr65316_0.C", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65316_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65316_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65316_0.C?ref=609570b49e5b138416d6e46531586d4e93c6a429", "patch": "@@ -0,0 +1,142 @@\n+// { dg-lto-do link }\n+// { dg-lto-options { { -flto -std=c++11 -g2 -fno-lto-odr-type-merging -O2 } } }\n+// { dg-extra-ld-options \"-r -nostdlib -O2 -fno-lto-odr-type-merging\" }\n+namespace std\n+{\n+  typedef long unsigned int size_t;\n+}\n+extern \"C\"\n+{\n+  typedef struct\n+  {\n+  } __mbstate_t;\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < class _CharT > struct char_traits;\n+}\n+\n+typedef __mbstate_t mbstate_t;\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _CharT, typename _Traits =\n+    char_traits < _CharT > >class basic_ostream;\n+  typedef basic_ostream < char >ostream;\n+}\n+\n+using namespace std;\n+class Cstring\n+{\n+public:\n+  Cstring (const char *str, int l = 0);\n+};\n+extern ostream & operator << (ostream & os, const Cstring & string);\n+class Foo_Log_Handler\n+{\n+  virtual int write_message (const char *msg, size_t msg_len, int channel,\n+\t\t\t     int level) = 0;\n+};\n+class Foo_Log_Handler_Stream:public Foo_Log_Handler\n+{\n+  virtual int write_message (const char *msg, size_t msg_len, int channel,\n+\t\t\t     int level) override;\n+  Cstring m_filename;\n+};\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template <> struct char_traits <char >\n+  {\n+    typedef mbstate_t state_type;\n+  };\n+  enum _Ios_Fmtflags\n+  {\n+  };\n+  enum _Ios_Iostate\n+  {\n+  };\n+  class ios_base\n+  {\n+  public:\n+    typedef _Ios_Iostate iostate;\n+  };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _CharT > class __ctype_abstract_base\n+  {\n+  };\n+  template < typename _CharT > class ctype\n+  {\n+  public:\n+    typedef char char_type;\n+    mutable char _M_widen_ok;\n+    char_type widen (char __c) const\n+    {\n+      if (_M_widen_ok)\n+\treturn this->do_widen (__c);\n+    }\n+    virtual char_type do_widen (char __c) const\n+    {\n+    }\n+  };\n+  template < typename _Facet >\n+    inline const _Facet & __check_facet (const _Facet * __f)\n+  {\n+  }\n+template < typename _CharT, typename _Traits > class basic_ios:public\n+    ios_base\n+  {\n+    typedef _CharT char_type;\n+    typedef ctype < _CharT > __ctype_type;\n+    const __ctype_type *_M_ctype;\n+  public:\n+    iostate rdstate ()const\n+    {\n+    }\n+    bool good () const\n+    {\n+    }\n+    char_type widen (char __c) const\n+    {\n+      return __check_facet (_M_ctype).widen (__c);\n+    }\n+  };\n+template < typename _CharT, typename _Traits > class basic_ostream:virtual public basic_ios < _CharT,\n+    _Traits\n+    >\n+  {\n+  public:\n+    typedef _CharT char_type;\n+    typedef _Traits traits_type;\n+    typedef basic_ostream < _CharT, _Traits > __ostream_type;\n+    __ostream_type & operator<< (__ostream_type & (*__pf) (__ostream_type &))\n+    {\n+      return __pf (*this);\n+    }\n+    __ostream_type & put (char_type __c);\n+  };\n+  template < typename _CharT,\n+    typename _Traits > inline basic_ostream < _CharT,\n+    _Traits > &endl (basic_ostream < _CharT, _Traits > &__os)\n+  {\n+    return flush (__os.put (__os.widen ('\\n')));\n+  }\n+  template < typename _CharT,\n+    typename _Traits > inline basic_ostream < _CharT,\n+    _Traits > &flush (basic_ostream < _CharT, _Traits > &__os)\n+  {\n+  }\n+  extern ostream cerr;\n+}\n+\n+int\n+Foo_Log_Handler_Stream::write_message (const char *msg, size_t msg_len, int,\n+\t\t\t\t\t int level)\n+{\n+  {\n+    {\n+      cerr << \"FATAL: cannot write into log file: \" << m_filename << endl;\n+    }\n+  }\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/g++.dg/lto/pr65316_1.C", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65316_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65316_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65316_1.C?ref=609570b49e5b138416d6e46531586d4e93c6a429"}, {"sha": "4fcc272c756d897e40fbb02b129e99c893a27486", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/609570b49e5b138416d6e46531586d4e93c6a429/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=609570b49e5b138416d6e46531586d4e93c6a429", "patch": "@@ -4470,7 +4470,8 @@ extern tree block_ultimate_origin (const_tree);\n extern tree get_binfo_at_offset (tree, HOST_WIDE_INT, tree);\n extern bool virtual_method_call_p (tree);\n extern tree obj_type_ref_class (tree ref);\n-extern bool types_same_for_odr (const_tree type1, const_tree type2);\n+extern bool types_same_for_odr (const_tree type1, const_tree type2,\n+\t\t\t\tbool strict=false);\n extern bool contains_bitfld_component_ref_p (const_tree);\n extern bool type_in_anonymous_namespace_p (const_tree);\n extern bool block_may_fallthru (const_tree);"}]}