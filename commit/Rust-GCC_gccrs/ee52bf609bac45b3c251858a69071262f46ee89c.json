{"sha": "ee52bf609bac45b3c251858a69071262f46ee89c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU1MmJmNjA5YmFjNDViM2MyNTE4NThhNjkwNzEyNjJmNDZlZTg5Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-06-10T19:37:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2021-06-10T21:41:23Z"}, "message": "libgo: update to Go1.16.5 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/326772", "tree": {"sha": "4c079eab4884dc9c32e6f62fe9e2f0ff0d784306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c079eab4884dc9c32e6f62fe9e2f0ff0d784306"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee52bf609bac45b3c251858a69071262f46ee89c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee52bf609bac45b3c251858a69071262f46ee89c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee52bf609bac45b3c251858a69071262f46ee89c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee52bf609bac45b3c251858a69071262f46ee89c/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00d07ec6e12451acc7a290cd93be03bed50cb666", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00d07ec6e12451acc7a290cd93be03bed50cb666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00d07ec6e12451acc7a290cd93be03bed50cb666"}], "stats": {"total": 914, "additions": 782, "deletions": 132}, "files": [{"sha": "f16fb9facc32b9bee18dbecbe2b47059e7eaf9b3", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -1,4 +1,4 @@\n-5a801b15699cced5203af5c7339b375cd55ecbac\n+bcafcb3c39530bb325514d6377747eb3127d1a03\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ac842716022809916900094eafcd04f95df9630c", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -1,4 +1,4 @@\n-9baddd3f21230c55f0ad2a10f5f20579dcf0a0bb\n+7677616a263e8ded606cc8297cb67ddc667a876e\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "e336ec201bfc2a52e2a1b0e0d07364842c8da603", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -1 +1 @@\n-go1.16.3\n+go1.16.5"}, {"sha": "ddef2b7b5a5176e1785c9e400407b85d4dfd1c0f", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -99,7 +99,15 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \t\treturn err\n \t}\n \tz.r = r\n-\tz.File = make([]*File, 0, end.directoryRecords)\n+\t// Since the number of directory records is not validated, it is not\n+\t// safe to preallocate z.File without first checking that the specified\n+\t// number of files is reasonable, since a malformed archive may\n+\t// indicate it contains up to 1 << 128 - 1 files. Since each file has a\n+\t// header which will be _at least_ 30 bytes we can safely preallocate\n+\t// if (data size / 30) >= end.directoryRecords.\n+\tif (uint64(size)-end.directorySize)/30 >= end.directoryRecords {\n+\t\tz.File = make([]*File, 0, end.directoryRecords)\n+\t}\n \tz.Comment = end.comment\n \trs := io.NewSectionReader(r, 0, size)\n \tif _, err = rs.Seek(int64(end.directoryOffset), io.SeekStart); err != nil {\n@@ -628,10 +636,11 @@ func (b *readBuf) sub(n int) readBuf {\n }\n \n // A fileListEntry is a File and its ename.\n-// If file == nil, the fileListEntry describes a directory, without metadata.\n+// If file == nil, the fileListEntry describes a directory without metadata.\n type fileListEntry struct {\n-\tname string\n-\tfile *File // nil for directories\n+\tname  string\n+\tfile  *File\n+\tisDir bool\n }\n \n type fileInfoDirEntry interface {\n@@ -640,20 +649,26 @@ type fileInfoDirEntry interface {\n }\n \n func (e *fileListEntry) stat() fileInfoDirEntry {\n-\tif e.file != nil {\n+\tif !e.isDir {\n \t\treturn headerFileInfo{&e.file.FileHeader}\n \t}\n \treturn e\n }\n \n // Only used for directories.\n-func (f *fileListEntry) Name() string       { _, elem, _ := split(f.name); return elem }\n-func (f *fileListEntry) Size() int64        { return 0 }\n-func (f *fileListEntry) ModTime() time.Time { return time.Time{} }\n-func (f *fileListEntry) Mode() fs.FileMode  { return fs.ModeDir | 0555 }\n-func (f *fileListEntry) Type() fs.FileMode  { return fs.ModeDir }\n-func (f *fileListEntry) IsDir() bool        { return true }\n-func (f *fileListEntry) Sys() interface{}   { return nil }\n+func (f *fileListEntry) Name() string      { _, elem, _ := split(f.name); return elem }\n+func (f *fileListEntry) Size() int64       { return 0 }\n+func (f *fileListEntry) Mode() fs.FileMode { return fs.ModeDir | 0555 }\n+func (f *fileListEntry) Type() fs.FileMode { return fs.ModeDir }\n+func (f *fileListEntry) IsDir() bool       { return true }\n+func (f *fileListEntry) Sys() interface{}  { return nil }\n+\n+func (f *fileListEntry) ModTime() time.Time {\n+\tif f.file == nil {\n+\t\treturn time.Time{}\n+\t}\n+\treturn f.file.FileHeader.Modified.UTC()\n+}\n \n func (f *fileListEntry) Info() (fs.FileInfo, error) { return f, nil }\n \n@@ -673,15 +688,32 @@ func toValidName(name string) string {\n func (r *Reader) initFileList() {\n \tr.fileListOnce.Do(func() {\n \t\tdirs := make(map[string]bool)\n+\t\tknownDirs := make(map[string]bool)\n \t\tfor _, file := range r.File {\n+\t\t\tisDir := len(file.Name) > 0 && file.Name[len(file.Name)-1] == '/'\n \t\t\tname := toValidName(file.Name)\n \t\t\tfor dir := path.Dir(name); dir != \".\"; dir = path.Dir(dir) {\n \t\t\t\tdirs[dir] = true\n \t\t\t}\n-\t\t\tr.fileList = append(r.fileList, fileListEntry{name, file})\n+\t\t\tentry := fileListEntry{\n+\t\t\t\tname:  name,\n+\t\t\t\tfile:  file,\n+\t\t\t\tisDir: isDir,\n+\t\t\t}\n+\t\t\tr.fileList = append(r.fileList, entry)\n+\t\t\tif isDir {\n+\t\t\t\tknownDirs[name] = true\n+\t\t\t}\n \t\t}\n \t\tfor dir := range dirs {\n-\t\t\tr.fileList = append(r.fileList, fileListEntry{dir + \"/\", nil})\n+\t\t\tif !knownDirs[dir] {\n+\t\t\t\tentry := fileListEntry{\n+\t\t\t\t\tname:  dir,\n+\t\t\t\t\tfile:  nil,\n+\t\t\t\t\tisDir: true,\n+\t\t\t\t}\n+\t\t\t\tr.fileList = append(r.fileList, entry)\n+\t\t\t}\n \t\t}\n \n \t\tsort.Slice(r.fileList, func(i, j int) bool { return fileEntryLess(r.fileList[i].name, r.fileList[j].name) })\n@@ -705,7 +737,7 @@ func (r *Reader) Open(name string) (fs.File, error) {\n \tif e == nil || !fs.ValidPath(name) {\n \t\treturn nil, &fs.PathError{Op: \"open\", Path: name, Err: fs.ErrNotExist}\n \t}\n-\tif e.file == nil || strings.HasSuffix(e.file.Name, \"/\") {\n+\tif e.isDir {\n \t\treturn &openDir{e, r.openReadDir(name), 0}, nil\n \t}\n \trc, err := e.file.Open()\n@@ -730,7 +762,7 @@ func split(name string) (dir, elem string, isDir bool) {\n \treturn name[:i], name[i+1:], isDir\n }\n \n-var dotFile = &fileListEntry{name: \"./\"}\n+var dotFile = &fileListEntry{name: \"./\", isDir: true}\n \n func (r *Reader) openLookup(name string) *fileListEntry {\n \tif name == \".\" {"}, {"sha": "471be27bb1004f698c071196f2d63da617377a34", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -1073,12 +1073,62 @@ func TestIssue12449(t *testing.T) {\n }\n \n func TestFS(t *testing.T) {\n-\tz, err := OpenReader(\"testdata/unix.zip\")\n+\tfor _, test := range []struct {\n+\t\tfile string\n+\t\twant []string\n+\t}{\n+\t\t{\n+\t\t\t\"testdata/unix.zip\",\n+\t\t\t[]string{\"hello\", \"dir/bar\", \"readonly\"},\n+\t\t},\n+\t\t{\n+\t\t\t\"testdata/subdir.zip\",\n+\t\t\t[]string{\"a/b/c\"},\n+\t\t},\n+\t} {\n+\t\tt.Run(test.file, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\tz, err := OpenReader(test.file)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tdefer z.Close()\n+\t\t\tif err := fstest.TestFS(z, test.want...); err != nil {\n+\t\t\t\tt.Error(err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func TestFSModTime(t *testing.T) {\n+\tt.Parallel()\n+\tz, err := OpenReader(\"testdata/subdir.zip\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tif err := fstest.TestFS(z, \"hello\", \"dir/bar\", \"dir/empty\", \"readonly\"); err != nil {\n-\t\tt.Fatal(err)\n+\tdefer z.Close()\n+\n+\tfor _, test := range []struct {\n+\t\tname string\n+\t\twant time.Time\n+\t}{\n+\t\t{\n+\t\t\t\"a\",\n+\t\t\ttime.Date(2021, 4, 19, 12, 29, 56, 0, timeZone(-7*time.Hour)).UTC(),\n+\t\t},\n+\t\t{\n+\t\t\t\"a/b/c\",\n+\t\t\ttime.Date(2021, 4, 19, 12, 29, 59, 0, timeZone(-7*time.Hour)).UTC(),\n+\t\t},\n+\t} {\n+\t\tfi, err := fs.Stat(z, test.name)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: %v\", test.name, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif got := fi.ModTime(); !got.Equal(test.want) {\n+\t\t\tt.Errorf(\"%s: got modtime %v, want %v\", test.name, got, test.want)\n+\t\t}\n \t}\n }\n \n@@ -1116,3 +1166,62 @@ func TestCVE202127919(t *testing.T) {\n \t\tt.Errorf(\"Error reading file: %v\", err)\n \t}\n }\n+\n+func TestCVE202133196(t *testing.T) {\n+\t// Archive that indicates it has 1 << 128 -1 files,\n+\t// this would previously cause a panic due to attempting\n+\t// to allocate a slice with 1 << 128 -1 elements.\n+\tdata := []byte{\n+\t\t0x50, 0x4b, 0x03, 0x04, 0x14, 0x00, 0x08, 0x08,\n+\t\t0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x02,\n+\t\t0x03, 0x62, 0x61, 0x65, 0x03, 0x04, 0x00, 0x00,\n+\t\t0xff, 0xff, 0x50, 0x4b, 0x07, 0x08, 0xbe, 0x20,\n+\t\t0x5c, 0x6c, 0x09, 0x00, 0x00, 0x00, 0x03, 0x00,\n+\t\t0x00, 0x00, 0x50, 0x4b, 0x01, 0x02, 0x14, 0x00,\n+\t\t0x14, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0xbe, 0x20, 0x5c, 0x6c, 0x09, 0x00,\n+\t\t0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x01, 0x02, 0x03, 0x50, 0x4b, 0x06, 0x06, 0x2c,\n+\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d,\n+\t\t0x00, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n+\t\t0xff, 0xff, 0xff, 0x31, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x50, 0x4b, 0x06, 0x07, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00,\n+\t\t0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x50,\n+\t\t0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0xff,\n+\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+\t\t0xff, 0xff, 0xff, 0x00, 0x00,\n+\t}\n+\t_, err := NewReader(bytes.NewReader(data), int64(len(data)))\n+\tif err != ErrFormat {\n+\t\tt.Fatalf(\"unexpected error, got: %v, want: %v\", err, ErrFormat)\n+\t}\n+\n+\t// Also check that an archive containing a handful of empty\n+\t// files doesn't cause an issue\n+\tb := bytes.NewBuffer(nil)\n+\tw := NewWriter(b)\n+\tfor i := 0; i < 5; i++ {\n+\t\t_, err := w.Create(\"\")\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Writer.Create failed: %s\", err)\n+\t\t}\n+\t}\n+\tif err := w.Close(); err != nil {\n+\t\tt.Fatalf(\"Writer.Close failed: %s\", err)\n+\t}\n+\tr, err := NewReader(bytes.NewReader(b.Bytes()), int64(b.Len()))\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewReader failed: %s\", err)\n+\t}\n+\tif len(r.File) != 5 {\n+\t\tt.Errorf(\"Archive has unexpected number of files, got %d, want 5\", len(r.File))\n+\t}\n+}"}, {"sha": "324d06b48d19e59fa5e5875bf006bdc31c097090", "filename": "libgo/go/archive/zip/testdata/subdir.zip", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fsubdir.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fsubdir.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fsubdir.zip?ref=ee52bf609bac45b3c251858a69071262f46ee89c"}, {"sha": "a602bb9bbe9d50f6ea0d10812756ae69a11f0566", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -86,9 +86,11 @@ func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \tif !modload.HasModRoot() && len(args) == 0 {\n \t\tbase.Fatalf(\"go mod download: no modules specified (see 'go help mod download')\")\n \t}\n-\tif len(args) == 0 {\n+\thaveExplicitArgs := len(args) > 0\n+\tif !haveExplicitArgs {\n \t\targs = []string{\"all\"}\n-\t} else if modload.HasModRoot() {\n+\t}\n+\tif modload.HasModRoot() {\n \t\tmodload.LoadModFile(ctx) // to fill Target\n \t\ttargetAtUpgrade := modload.Target.Path + \"@upgrade\"\n \t\ttargetAtPatch := modload.Target.Path + \"@patch\"\n@@ -137,7 +139,20 @@ func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \tlistRetractions := false\n \ttype token struct{}\n \tsem := make(chan token, runtime.GOMAXPROCS(0))\n-\tfor _, info := range modload.ListModules(ctx, args, listU, listVersions, listRetractions) {\n+\tinfos := modload.ListModules(ctx, args, listU, listVersions, listRetractions)\n+\tif !haveExplicitArgs {\n+\t\t// 'go mod download' is sometimes run without arguments to pre-populate\n+\t\t// the module cache. It may fetch modules that aren't needed to build\n+\t\t// packages in the main mdoule. This is usually not intended, so don't save\n+\t\t// sums for downloaded modules (golang.org/issue/45332).\n+\t\t// TODO(golang.org/issue/45551): For now, save sums needed to load the\n+\t\t// build list (same as 1.15 behavior). In the future, report an error if\n+\t\t// go.mod or go.sum need to be updated after loading the build list.\n+\t\tmodload.WriteGoMod()\n+\t\tmodload.DisallowWriteGoMod()\n+\t}\n+\n+\tfor _, info := range infos {\n \t\tif info.Replace != nil {\n \t\t\tinfo = info.Replace\n \t\t}\n@@ -187,6 +202,13 @@ func runDownload(ctx context.Context, cmd *base.Command, args []string) {\n \t\tbase.ExitIfErrors()\n \t}\n \n-\t// Update go.mod and especially go.sum if needed.\n-\tmodload.WriteGoMod()\n+\t// If there were explicit arguments, update go.mod and especially go.sum.\n+\t// 'go mod download mod@version' is a useful way to add a sum without using\n+\t// 'go get mod@version', which may have other side effects. We print this in\n+\t// some error message hints.\n+\t//\n+\t// Don't save sums for 'go mod download' without arguments; see comment above.\n+\tif haveExplicitArgs {\n+\t\tmodload.WriteGoMod()\n+\t}\n }"}, {"sha": "67f90b123c3721bb2a8b87d64942766e852c7c77", "filename": "libgo/go/cmd/go/internal/modcmd/tidy.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -61,6 +61,8 @@ func runTidy(ctx context.Context, cmd *base.Command, args []string) {\n \tmodload.ForceUseModules = true\n \tmodload.RootMode = modload.NeedRoot\n \n+\tmodload.CheckTidyVersion(ctx, tidyE)\n+\n \tmodload.LoadPackages(ctx, modload.PackageOpts{\n \t\tTags:                     imports.AnyTags(),\n \t\tResolveMissingImports:    true,"}, {"sha": "0ed985384d8f8dcf7e6eaf9d95c706f3fed9ffa0", "filename": "libgo/go/cmd/go/internal/modload/buildlist.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuildlist.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -11,10 +11,13 @@ import (\n \t\"cmd/go/internal/mvs\"\n \t\"context\"\n \t\"fmt\"\n+\t\"go/build\"\n \t\"os\"\n \t\"strings\"\n \n+\t\"golang.org/x/mod/modfile\"\n \t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n // buildList is the list of modules to use for building packages.\n@@ -226,6 +229,33 @@ func ReloadBuildList() []module.Version {\n \treturn capVersionSlice(buildList)\n }\n \n+// CheckTidyVersion reports an error to stderr if the Go version indicated by\n+// the go.mod file is not supported by this version of the 'go' command.\n+//\n+// If allowError is false, such an error terminates the program.\n+func CheckTidyVersion(ctx context.Context, allowError bool) {\n+\tLoadModFile(ctx)\n+\tif index.goVersionV == \"\" {\n+\t\treturn\n+\t}\n+\n+\ttags := build.Default.ReleaseTags\n+\tmaxGo := tags[len(tags)-1]\n+\tif !strings.HasPrefix(maxGo, \"go\") || !modfile.GoVersionRE.MatchString(maxGo[2:]) {\n+\t\tbase.Fatalf(\"go: unrecognized go version %q\", maxGo)\n+\t}\n+\tmax := maxGo[2:]\n+\n+\tif semver.Compare(index.goVersionV, \"v\"+max) > 0 {\n+\t\thave := index.goVersionV[1:]\n+\t\tif allowError {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go mod tidy: go.mod file indicates go %s, but maximum supported version is %s\\n\", have, max)\n+\t\t} else {\n+\t\t\tbase.Fatalf(\"go mod tidy: go.mod file indicates go %s, but maximum supported version is %s\\n\", have, max)\n+\t\t}\n+\t}\n+}\n+\n // TidyBuildList trims the build list to the minimal requirements needed to\n // retain the same versions of all packages from the preceding call to\n // LoadPackages."}, {"sha": "7982cccea100c0a523aa9e668ed45aa2d6dfada6", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_sampler_v1.2.1.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.2.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.2.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_sampler_v1.2.1.txt?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -5,7 +5,7 @@ module \"rsc.io/sampler\"\n \n require \"golang.org/x/text\" v0.0.0-20170915032832-14c0d48ead0c\n -- .info --\n-{\"Version\":\"v1.2.1\",\"Name\":\"cac3af4f8a0ab40054fa6f8d423108a63a1255bb\",\"Short\":\"cac3af4f8a0a\",\"Time\":\"2018-02-13T18:16:22Z\"}EOF\n+{\"Version\":\"v1.2.1\",\"Name\":\"cac3af4f8a0ab40054fa6f8d423108a63a1255bb\",\"Short\":\"cac3af4f8a0a\",\"Time\":\"2018-02-13T18:16:22Z\"}\n -- hello.go --\n // Copyright 2018 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style"}, {"sha": "c2b72b2a02cab8f681872c637d1d9990c9131db5", "filename": "libgo/go/cmd/go/testdata/script/mod_download.txt", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -107,13 +107,28 @@ stderr '^go mod download: skipping argument m that resolves to the main module\\n\n ! go mod download m@latest\n stderr '^go mod download: m@latest: malformed module path \"m\": missing dot in first path element$'\n \n-# download updates go.mod and populates go.sum\n+# download without arguments updates go.mod and go.sum after loading the\n+# build list, but does not save sums for downloaded zips.\n cd update\n+cp go.mod.orig go.mod\n ! exists go.sum\n go mod download\n+cmp go.mod.update go.mod\n+cmp go.sum.update go.sum\n+cp go.mod.orig go.mod\n+rm go.sum\n+\n+# download with arguments (even \"all\") does update go.mod and go.sum.\n+go mod download rsc.io/sampler\n+cmp go.mod.update go.mod\n grep '^rsc.io/sampler v1.3.0 ' go.sum\n-go list -m rsc.io/sampler\n-stdout '^rsc.io/sampler v1.3.0$'\n+cp go.mod.orig go.mod\n+rm go.sum\n+\n+go mod download all\n+cmp go.mod.update go.mod\n+grep '^rsc.io/sampler v1.3.0 ' go.sum\n+cd ..\n \n # allow go mod download without go.mod\n env GO111MODULE=auto\n@@ -131,7 +146,7 @@ stderr 'get '$GOPROXY\n -- go.mod --\n module m\n \n--- update/go.mod --\n+-- update/go.mod.orig --\n module m\n \n go 1.16\n@@ -140,3 +155,16 @@ require (\n \trsc.io/quote v1.5.2\n \trsc.io/sampler v1.2.1 // older version than in build list\n )\n+-- update/go.mod.update --\n+module m\n+\n+go 1.16\n+\n+require (\n+\trsc.io/quote v1.5.2\n+\trsc.io/sampler v1.3.0 // older version than in build list\n+)\n+-- update/go.sum.update --\n+golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n+rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0=\n+rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA="}, {"sha": "c53669353794ade0e4eb2039d0f91f48a89ad1d2", "filename": "libgo/go/cmd/go/testdata/script/mod_get_trailing_slash.txt", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -1,6 +1,3 @@\n-# Populate go.sum\n-go mod download\n-\n # go list should succeed to load a package ending with \".go\" if the path does\n # not correspond to an existing local file. Listing a pattern ending with\n # \".go/\" should try to list a package regardless of whether a file exists at the\n@@ -31,3 +28,10 @@ module m\n go 1.13\n \n require example.com/dotgo.go v1.0.0\n+-- go.sum --\n+example.com/dotgo.go v1.0.0 h1:XKJfs0V8x2PvY2tX8bJBCEbCDLnt15ma2onwhVpew/I=\n+example.com/dotgo.go v1.0.0/go.mod h1:Qi6z/X3AC5vHiuMt6HF2ICx3KhIBGrMdrA7YoPDKqR0=\n+-- use.go --\n+package use\n+\n+import _ \"example.com/dotgo.go\""}, {"sha": "a75f86ed7c5729d3c4b55734ae48b33f2f68170b", "filename": "libgo/go/cmd/go/testdata/script/mod_query.txt", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_query.txt?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -1,9 +1,7 @@\n env GO111MODULE=on\n \n-# Populate go.sum.\n # TODO(golang.org/issue/41297): we shouldn't need go.sum. None of the commands\n # below depend on the build list.\n-go mod download\n \n go list -m -versions rsc.io/quote\n stdout '^rsc.io/quote v1.0.0 v1.1.0 v1.2.0 v1.2.1 v1.3.0 v1.4.0 v1.5.0 v1.5.1 v1.5.2 v1.5.3-pre1$'\n@@ -36,6 +34,9 @@ stdout 'no matching versions for query \">v1.5.3\"'\n module x\n require rsc.io/quote v1.0.0\n \n+-- go.sum --\n+rsc.io/quote v1.0.0 h1:kQ3IZQzPTiDJxSZI98YaWgxFEhlNdYASHvh+MplbViw=\n+rsc.io/quote v1.0.0/go.mod h1:v83Ri/njykPcgJltBc/gEkJTmjTsNgtO1Y7vyIK1CQA=\n -- use.go --\n package use\n "}, {"sha": "d05ad2a3174f8ed5066299fb25516d131e654a08", "filename": "libgo/go/cmd/go/testdata/script/mod_readonly.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -89,7 +89,7 @@ stderr '^no required module provides package rsc.io/quote; to add it:\\n\\tgo get\n -- go.mod --\n module m\n \n-go 1.20\n+go 1.16\n \n -- x.go --\n package x\n@@ -104,7 +104,7 @@ require (\n -- go.mod.redundant --\n module m\n \n-go 1.20\n+go 1.16\n \n require (\n \trsc.io/quote v1.5.2\n@@ -114,7 +114,7 @@ require (\n -- go.mod.indirect --\n module m\n \n-go 1.20\n+go 1.16\n \n require (\n \trsc.io/quote v1.5.2 // indirect\n@@ -124,7 +124,7 @@ require (\n -- go.mod.untidy --\n module m\n \n-go 1.20\n+go 1.16\n \n require (\n \trsc.io/sampler v1.3.0 // indirect"}, {"sha": "798677b68c13459fc4feea646cd799e55a71cab9", "filename": "libgo/go/go.mod", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo.mod?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -4,7 +4,7 @@ go 1.16\n \n require (\n \tgolang.org/x/crypto v0.0.0-20201016220609-9e8e0b390897\n-\tgolang.org/x/net v0.0.0-20201209123823-ac852fbbde11\n+\tgolang.org/x/net v0.0.0-20210428183300-3f4a416c7d3b\n \tgolang.org/x/sys v0.0.0-20201204225414-ed752295db88 // indirect\n \tgolang.org/x/text v0.3.4 // indirect\n )"}, {"sha": "c79aa73f28bb9a522de0d653b01637083c631e85", "filename": "libgo/go/golang.org/x/net/http/httpguts/httplex.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Fhttp%2Fhttpguts%2Fhttplex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Fhttp%2Fhttpguts%2Fhttplex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fnet%2Fhttp%2Fhttpguts%2Fhttplex.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -137,11 +137,13 @@ func trimOWS(x string) string {\n // contains token amongst its comma-separated tokens, ASCII\n // case-insensitively.\n func headerValueContainsToken(v string, token string) bool {\n-\tv = trimOWS(v)\n-\tif comma := strings.IndexByte(v, ','); comma != -1 {\n-\t\treturn tokenEqual(trimOWS(v[:comma]), token) || headerValueContainsToken(v[comma+1:], token)\n+\tfor comma := strings.IndexByte(v, ','); comma != -1; comma = strings.IndexByte(v, ',') {\n+\t\tif tokenEqual(trimOWS(v[:comma]), token) {\n+\t\t\treturn true\n+\t\t}\n+\t\tv = v[comma+1:]\n \t}\n-\treturn tokenEqual(v, token)\n+\treturn tokenEqual(trimOWS(v), token)\n }\n \n // lowerASCII returns the ASCII lowercase version of b."}, {"sha": "ac3c8bd11f8a86756c7753c72d0454a0b9132937", "filename": "libgo/go/math/big/ratconv.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fmath%2Fbig%2Fratconv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fmath%2Fbig%2Fratconv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fratconv.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -51,7 +51,8 @@ func (z *Rat) Scan(s fmt.ScanState, ch rune) error {\n // An optional base-10 ``e'' or base-2 ``p'' (or their upper-case variants)\n // exponent may be provided as well, except for hexadecimal floats which\n // only accept an (optional) ``p'' exponent (because an ``e'' or ``E'' cannot\n-// be distinguished from a mantissa digit).\n+// be distinguished from a mantissa digit). If the exponent's absolute value\n+// is too large, the operation may fail.\n // The entire string, not just a prefix, must be valid for success. If the\n // operation failed, the value of z is undefined but the returned value is nil.\n func (z *Rat) SetString(s string) (*Rat, bool) {\n@@ -169,6 +170,9 @@ func (z *Rat) SetString(s string) (*Rat, bool) {\n \t\tif n < 0 {\n \t\t\tn = -n\n \t\t}\n+\t\tif n > 1e6 {\n+\t\t\treturn nil, false // avoid excessively large exponents\n+\t\t}\n \t\tpow5 := z.b.abs.expNN(natFive, nat(nil).setWord(Word(n)), nil) // use underlying array of z.b.abs\n \t\tif exp5 > 0 {\n \t\t\tz.a.abs = z.a.abs.mul(z.a.abs, pow5)\n@@ -181,15 +185,12 @@ func (z *Rat) SetString(s string) (*Rat, bool) {\n \t}\n \n \t// apply exp2 contributions\n+\tif exp2 < -1e7 || exp2 > 1e7 {\n+\t\treturn nil, false // avoid excessively large exponents\n+\t}\n \tif exp2 > 0 {\n-\t\tif int64(uint(exp2)) != exp2 {\n-\t\t\tpanic(\"exponent too large\")\n-\t\t}\n \t\tz.a.abs = z.a.abs.shl(z.a.abs, uint(exp2))\n \t} else if exp2 < 0 {\n-\t\tif int64(uint(-exp2)) != -exp2 {\n-\t\t\tpanic(\"exponent too large\")\n-\t\t}\n \t\tz.b.abs = z.b.abs.shl(z.b.abs, uint(-exp2))\n \t}\n "}, {"sha": "15d206cb386ab41dd0e79c2e5e01869413158763", "filename": "libgo/go/math/big/ratconv_test.go", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fmath%2Fbig%2Fratconv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fmath%2Fbig%2Fratconv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fratconv_test.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -589,3 +589,28 @@ func TestIssue31184(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestIssue45910(t *testing.T) {\n+\tvar x Rat\n+\tfor _, test := range []struct {\n+\t\tinput string\n+\t\twant  bool\n+\t}{\n+\t\t{\"1e-1000001\", false},\n+\t\t{\"1e-1000000\", true},\n+\t\t{\"1e+1000000\", true},\n+\t\t{\"1e+1000001\", false},\n+\n+\t\t{\"0p1000000000000\", true},\n+\t\t{\"1p-10000001\", false},\n+\t\t{\"1p-10000000\", true},\n+\t\t{\"1p+10000000\", true},\n+\t\t{\"1p+10000001\", false},\n+\t\t{\"1.770p02041010010011001001\", false}, // test case from issue\n+\t} {\n+\t\t_, got := x.SetString(test.input)\n+\t\tif got != test.want {\n+\t\t\tt.Errorf(\"SetString(%s) got ok = %v; want %v\", test.input, got, test.want)\n+\t\t}\n+\t}\n+}"}, {"sha": "3c9ada365c4a70d2e8358023b6fc94c01ab74acb", "filename": "libgo/go/net/dnsclient_unix_test.go", "status": "modified", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -1798,3 +1798,161 @@ func TestPTRandNonPTR(t *testing.T) {\n \t\tt.Errorf(\"names = %q; want %q\", names, want)\n \t}\n }\n+\n+func TestCVE202133195(t *testing.T) {\n+\tfake := fakeDNSServer{\n+\t\trh: func(n, _ string, q dnsmessage.Message, _ time.Time) (dnsmessage.Message, error) {\n+\t\t\tr := dnsmessage.Message{\n+\t\t\t\tHeader: dnsmessage.Header{\n+\t\t\t\t\tID:                 q.Header.ID,\n+\t\t\t\t\tResponse:           true,\n+\t\t\t\t\tRCode:              dnsmessage.RCodeSuccess,\n+\t\t\t\t\tRecursionAvailable: true,\n+\t\t\t\t},\n+\t\t\t\tQuestions: q.Questions,\n+\t\t\t}\n+\t\t\tswitch q.Questions[0].Type {\n+\t\t\tcase dnsmessage.TypeCNAME:\n+\t\t\t\tr.Answers = []dnsmessage.Resource{}\n+\t\t\tcase dnsmessage.TypeA: // CNAME lookup uses a A/AAAA as a proxy\n+\t\t\t\tr.Answers = append(r.Answers,\n+\t\t\t\t\tdnsmessage.Resource{\n+\t\t\t\t\t\tHeader: dnsmessage.ResourceHeader{\n+\t\t\t\t\t\t\tName:   dnsmessage.MustNewName(\"<html>.golang.org.\"),\n+\t\t\t\t\t\t\tType:   dnsmessage.TypeA,\n+\t\t\t\t\t\t\tClass:  dnsmessage.ClassINET,\n+\t\t\t\t\t\t\tLength: 4,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tBody: &dnsmessage.AResource{\n+\t\t\t\t\t\t\tA: TestAddr,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t)\n+\t\t\tcase dnsmessage.TypeSRV:\n+\t\t\t\tn := q.Questions[0].Name\n+\t\t\t\tif n.String() == \"_hdr._tcp.golang.org.\" {\n+\t\t\t\t\tn = dnsmessage.MustNewName(\"<html>.golang.org.\")\n+\t\t\t\t}\n+\t\t\t\tr.Answers = append(r.Answers,\n+\t\t\t\t\tdnsmessage.Resource{\n+\t\t\t\t\t\tHeader: dnsmessage.ResourceHeader{\n+\t\t\t\t\t\t\tName:   n,\n+\t\t\t\t\t\t\tType:   dnsmessage.TypeSRV,\n+\t\t\t\t\t\t\tClass:  dnsmessage.ClassINET,\n+\t\t\t\t\t\t\tLength: 4,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tBody: &dnsmessage.SRVResource{\n+\t\t\t\t\t\t\tTarget: dnsmessage.MustNewName(\"<html>.golang.org.\"),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t)\n+\t\t\tcase dnsmessage.TypeMX:\n+\t\t\t\tr.Answers = append(r.Answers,\n+\t\t\t\t\tdnsmessage.Resource{\n+\t\t\t\t\t\tHeader: dnsmessage.ResourceHeader{\n+\t\t\t\t\t\t\tName:   dnsmessage.MustNewName(\"<html>.golang.org.\"),\n+\t\t\t\t\t\t\tType:   dnsmessage.TypeMX,\n+\t\t\t\t\t\t\tClass:  dnsmessage.ClassINET,\n+\t\t\t\t\t\t\tLength: 4,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tBody: &dnsmessage.MXResource{\n+\t\t\t\t\t\t\tMX: dnsmessage.MustNewName(\"<html>.golang.org.\"),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t)\n+\t\t\tcase dnsmessage.TypeNS:\n+\t\t\t\tr.Answers = append(r.Answers,\n+\t\t\t\t\tdnsmessage.Resource{\n+\t\t\t\t\t\tHeader: dnsmessage.ResourceHeader{\n+\t\t\t\t\t\t\tName:   dnsmessage.MustNewName(\"<html>.golang.org.\"),\n+\t\t\t\t\t\t\tType:   dnsmessage.TypeNS,\n+\t\t\t\t\t\t\tClass:  dnsmessage.ClassINET,\n+\t\t\t\t\t\t\tLength: 4,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tBody: &dnsmessage.NSResource{\n+\t\t\t\t\t\t\tNS: dnsmessage.MustNewName(\"<html>.golang.org.\"),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t)\n+\t\t\tcase dnsmessage.TypePTR:\n+\t\t\t\tr.Answers = append(r.Answers,\n+\t\t\t\t\tdnsmessage.Resource{\n+\t\t\t\t\t\tHeader: dnsmessage.ResourceHeader{\n+\t\t\t\t\t\t\tName:   dnsmessage.MustNewName(\"<html>.golang.org.\"),\n+\t\t\t\t\t\t\tType:   dnsmessage.TypePTR,\n+\t\t\t\t\t\t\tClass:  dnsmessage.ClassINET,\n+\t\t\t\t\t\t\tLength: 4,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tBody: &dnsmessage.PTRResource{\n+\t\t\t\t\t\t\tPTR: dnsmessage.MustNewName(\"<html>.golang.org.\"),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t)\n+\t\t\t}\n+\t\t\treturn r, nil\n+\t\t},\n+\t}\n+\n+\tr := Resolver{PreferGo: true, Dial: fake.DialContext}\n+\t// Change the default resolver to match our manipulated resolver\n+\toriginalDefault := DefaultResolver\n+\tDefaultResolver = &r\n+\tdefer func() { DefaultResolver = originalDefault }()\n+\t// Redirect host file lookups.\n+\tdefer func(orig string) { testHookHostsPath = orig }(testHookHostsPath)\n+\ttestHookHostsPath = \"testdata/hosts\"\n+\n+\t_, err := r.LookupCNAME(context.Background(), \"golang.org\")\n+\tif expected := \"lookup golang.org: CNAME target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"Resolver.LookupCNAME returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\t_, err = LookupCNAME(\"golang.org\")\n+\tif expected := \"lookup golang.org: CNAME target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"LookupCNAME returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\n+\t_, _, err = r.LookupSRV(context.Background(), \"target\", \"tcp\", \"golang.org\")\n+\tif expected := \"lookup golang.org: SRV target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"Resolver.LookupSRV returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\t_, _, err = LookupSRV(\"target\", \"tcp\", \"golang.org\")\n+\tif expected := \"lookup golang.org: SRV target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"LookupSRV returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\n+\t_, _, err = r.LookupSRV(context.Background(), \"hdr\", \"tcp\", \"golang.org\")\n+\tif expected := \"lookup golang.org: SRV header name is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"Resolver.LookupSRV returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\t_, _, err = LookupSRV(\"hdr\", \"tcp\", \"golang.org\")\n+\tif expected := \"lookup golang.org: SRV header name is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"LookupSRV returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\n+\t_, err = r.LookupMX(context.Background(), \"golang.org\")\n+\tif expected := \"lookup golang.org: MX target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"Resolver.LookupMX returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\t_, err = LookupMX(\"golang.org\")\n+\tif expected := \"lookup golang.org: MX target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"LookupMX returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\n+\t_, err = r.LookupNS(context.Background(), \"golang.org\")\n+\tif expected := \"lookup golang.org: NS target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"Resolver.LookupNS returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\t_, err = LookupNS(\"golang.org\")\n+\tif expected := \"lookup golang.org: NS target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"LookupNS returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\n+\t_, err = r.LookupAddr(context.Background(), \"192.0.2.42\")\n+\tif expected := \"lookup 192.0.2.42: PTR target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"Resolver.LookupAddr returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+\t_, err = LookupAddr(\"192.0.2.42\")\n+\tif expected := \"lookup 192.0.2.42: PTR target is invalid\"; err == nil || err.Error() != expected {\n+\t\tt.Errorf(\"LookupAddr returned unexpected error, got %q, want %q\", err, expected)\n+\t}\n+}"}, {"sha": "ccb84562e0a70d2720f6d426dff31dc87a5b4e50", "filename": "libgo/go/net/http/httputil/reverseproxy.go", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -248,22 +248,18 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t// important is \"Connection\" because we want a persistent\n \t// connection, regardless of what the client sent to us.\n \tfor _, h := range hopHeaders {\n-\t\thv := outreq.Header.Get(h)\n-\t\tif hv == \"\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif h == \"Te\" && hv == \"trailers\" {\n-\t\t\t// Issue 21096: tell backend applications that\n-\t\t\t// care about trailer support that we support\n-\t\t\t// trailers. (We do, but we don't go out of\n-\t\t\t// our way to advertise that unless the\n-\t\t\t// incoming client request thought it was\n-\t\t\t// worth mentioning)\n-\t\t\tcontinue\n-\t\t}\n \t\toutreq.Header.Del(h)\n \t}\n \n+\t// Issue 21096: tell backend applications that care about trailer support\n+\t// that we support trailers. (We do, but we don't go out of our way to\n+\t// advertise that unless the incoming client request thought it was worth\n+\t// mentioning.) Note that we look at req.Header, not outreq.Header, since\n+\t// the latter has passed through removeConnectionHeaders.\n+\tif httpguts.HeaderValuesContainsToken(req.Header[\"Te\"], \"trailers\") {\n+\t\toutreq.Header.Set(\"Te\", \"trailers\")\n+\t}\n+\n \t// After stripping all the hop-by-hop connection headers above, add back any\n \t// necessary for protocol upgrades, such as for websockets.\n \tif reqUpType != \"\" {"}, {"sha": "3211463bcbcd2860eb1fa9178f9a2a4f5cfa6273", "filename": "libgo/go/net/http/httputil/reverseproxy_test.go", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy_test.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -90,8 +90,9 @@ func TestReverseProxy(t *testing.T) {\n \n \tgetReq, _ := http.NewRequest(\"GET\", frontend.URL, nil)\n \tgetReq.Host = \"some-name\"\n-\tgetReq.Header.Set(\"Connection\", \"close\")\n-\tgetReq.Header.Set(\"Te\", \"trailers\")\n+\tgetReq.Header.Set(\"Connection\", \"close, TE\")\n+\tgetReq.Header.Add(\"Te\", \"foo\")\n+\tgetReq.Header.Add(\"Te\", \"bar, trailers\")\n \tgetReq.Header.Set(\"Proxy-Connection\", \"should be deleted\")\n \tgetReq.Header.Set(\"Upgrade\", \"foo\")\n \tgetReq.Close = true\n@@ -235,6 +236,64 @@ func TestReverseProxyStripHeadersPresentInConnection(t *testing.T) {\n \t}\n }\n \n+func TestReverseProxyStripEmptyConnection(t *testing.T) {\n+\t// See Issue 46313.\n+\tconst backendResponse = \"I am the backend\"\n+\n+\t// someConnHeader is some arbitrary header to be declared as a hop-by-hop header\n+\t// in the Request's Connection header.\n+\tconst someConnHeader = \"X-Some-Conn-Header\"\n+\n+\tbackend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tif c := r.Header.Values(\"Connection\"); len(c) != 0 {\n+\t\t\tt.Errorf(\"handler got header %q = %v; want empty\", \"Connection\", c)\n+\t\t}\n+\t\tif c := r.Header.Get(someConnHeader); c != \"\" {\n+\t\t\tt.Errorf(\"handler got header %q = %q; want empty\", someConnHeader, c)\n+\t\t}\n+\t\tw.Header().Add(\"Connection\", \"\")\n+\t\tw.Header().Add(\"Connection\", someConnHeader)\n+\t\tw.Header().Set(someConnHeader, \"should be deleted\")\n+\t\tio.WriteString(w, backendResponse)\n+\t}))\n+\tdefer backend.Close()\n+\tbackendURL, err := url.Parse(backend.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tproxyHandler := NewSingleHostReverseProxy(backendURL)\n+\tfrontend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tproxyHandler.ServeHTTP(w, r)\n+\t\tif c := r.Header.Get(someConnHeader); c != \"should be deleted\" {\n+\t\t\tt.Errorf(\"handler modified header %q = %q; want %q\", someConnHeader, c, \"should be deleted\")\n+\t\t}\n+\t}))\n+\tdefer frontend.Close()\n+\n+\tgetReq, _ := http.NewRequest(\"GET\", frontend.URL, nil)\n+\tgetReq.Header.Add(\"Connection\", \"\")\n+\tgetReq.Header.Add(\"Connection\", someConnHeader)\n+\tgetReq.Header.Set(someConnHeader, \"should be deleted\")\n+\tres, err := frontend.Client().Do(getReq)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Get: %v\", err)\n+\t}\n+\tdefer res.Body.Close()\n+\tbodyBytes, err := io.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Fatalf(\"reading body: %v\", err)\n+\t}\n+\tif got, want := string(bodyBytes), backendResponse; got != want {\n+\t\tt.Errorf(\"got body %q; want %q\", got, want)\n+\t}\n+\tif c := res.Header.Get(\"Connection\"); c != \"\" {\n+\t\tt.Errorf(\"handler got header %q = %q; want empty\", \"Connection\", c)\n+\t}\n+\tif c := res.Header.Get(someConnHeader); c != \"\" {\n+\t\tt.Errorf(\"handler got header %q = %q; want empty\", someConnHeader, c)\n+\t}\n+}\n+\n func TestXForwardedFor(t *testing.T) {\n \tconst prevForwardedFor = \"client ip\"\n \tconst backendResponse = \"I am the backend\""}, {"sha": "d0202c0e0074ef392771ef016400872e66acef10", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -5318,7 +5318,6 @@ func TestMissingStatusNoPanic(t *testing.T) {\n \n \tln := newLocalListener(t)\n \taddr := ln.Addr().String()\n-\tshutdown := make(chan bool, 1)\n \tdone := make(chan bool)\n \tfullAddrURL := fmt.Sprintf(\"http://%s\", addr)\n \traw := \"HTTP/1.1 400\\r\\n\" +\n@@ -5330,10 +5329,7 @@ func TestMissingStatusNoPanic(t *testing.T) {\n \t\t\"Aloha Olaa\"\n \n \tgo func() {\n-\t\tdefer func() {\n-\t\t\tln.Close()\n-\t\t\tclose(done)\n-\t\t}()\n+\t\tdefer close(done)\n \n \t\tconn, _ := ln.Accept()\n \t\tif conn != nil {\n@@ -5364,7 +5360,7 @@ func TestMissingStatusNoPanic(t *testing.T) {\n \t\tt.Errorf(\"got=%v want=%q\", err, want)\n \t}\n \n-\tclose(shutdown)\n+\tln.Close()\n \t<-done\n }\n "}, {"sha": "0660268249bc765186a4443273bd111266e8a280", "filename": "libgo/go/net/lookup.go", "status": "modified", "additions": 98, "deletions": 13, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fnet%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -389,8 +389,11 @@ func (r *Resolver) LookupPort(ctx context.Context, network, service string) (por\n // LookupCNAME does not return an error if host does not\n // contain DNS \"CNAME\" records, as long as host resolves to\n // address records.\n+//\n+// The returned canonical name is validated to be a properly\n+// formatted presentation-format domain name.\n func LookupCNAME(host string) (cname string, err error) {\n-\treturn DefaultResolver.lookupCNAME(context.Background(), host)\n+\treturn DefaultResolver.LookupCNAME(context.Background(), host)\n }\n \n // LookupCNAME returns the canonical name for the given host.\n@@ -403,8 +406,18 @@ func LookupCNAME(host string) (cname string, err error) {\n // LookupCNAME does not return an error if host does not\n // contain DNS \"CNAME\" records, as long as host resolves to\n // address records.\n-func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string, err error) {\n-\treturn r.lookupCNAME(ctx, host)\n+//\n+// The returned canonical name is validated to be a properly\n+// formatted presentation-format domain name.\n+func (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error) {\n+\tcname, err := r.lookupCNAME(ctx, host)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif !isDomainName(cname) {\n+\t\treturn \"\", &DNSError{Err: \"CNAME target is invalid\", Name: host}\n+\t}\n+\treturn cname, nil\n }\n \n // LookupSRV tries to resolve an SRV query of the given service,\n@@ -416,8 +429,11 @@ func (r *Resolver) LookupCNAME(ctx context.Context, host string) (cname string,\n // That is, it looks up _service._proto.name. To accommodate services\n // publishing SRV records under non-standard names, if both service\n // and proto are empty strings, LookupSRV looks up name directly.\n+//\n+// The returned service names are validated to be properly\n+// formatted presentation-format domain names.\n func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error) {\n-\treturn DefaultResolver.lookupSRV(context.Background(), service, proto, name)\n+\treturn DefaultResolver.LookupSRV(context.Background(), service, proto, name)\n }\n \n // LookupSRV tries to resolve an SRV query of the given service,\n@@ -429,28 +445,82 @@ func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err err\n // That is, it looks up _service._proto.name. To accommodate services\n // publishing SRV records under non-standard names, if both service\n // and proto are empty strings, LookupSRV looks up name directly.\n-func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (cname string, addrs []*SRV, err error) {\n-\treturn r.lookupSRV(ctx, service, proto, name)\n+//\n+// The returned service names are validated to be properly\n+// formatted presentation-format domain names.\n+func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error) {\n+\tcname, addrs, err := r.lookupSRV(ctx, service, proto, name)\n+\tif err != nil {\n+\t\treturn \"\", nil, err\n+\t}\n+\tif cname != \"\" && !isDomainName(cname) {\n+\t\treturn \"\", nil, &DNSError{Err: \"SRV header name is invalid\", Name: name}\n+\t}\n+\tfor _, addr := range addrs {\n+\t\tif addr == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !isDomainName(addr.Target) {\n+\t\t\treturn \"\", nil, &DNSError{Err: \"SRV target is invalid\", Name: name}\n+\t\t}\n+\t}\n+\treturn cname, addrs, nil\n }\n \n // LookupMX returns the DNS MX records for the given domain name sorted by preference.\n+//\n+// The returned mail server names are validated to be properly\n+// formatted presentation-format domain names.\n func LookupMX(name string) ([]*MX, error) {\n-\treturn DefaultResolver.lookupMX(context.Background(), name)\n+\treturn DefaultResolver.LookupMX(context.Background(), name)\n }\n \n // LookupMX returns the DNS MX records for the given domain name sorted by preference.\n+//\n+// The returned mail server names are validated to be properly\n+// formatted presentation-format domain names.\n func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error) {\n-\treturn r.lookupMX(ctx, name)\n+\trecords, err := r.lookupMX(ctx, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor _, mx := range records {\n+\t\tif mx == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !isDomainName(mx.Host) {\n+\t\t\treturn nil, &DNSError{Err: \"MX target is invalid\", Name: name}\n+\t\t}\n+\t}\n+\treturn records, nil\n }\n \n // LookupNS returns the DNS NS records for the given domain name.\n+//\n+// The returned name server names are validated to be properly\n+// formatted presentation-format domain names.\n func LookupNS(name string) ([]*NS, error) {\n-\treturn DefaultResolver.lookupNS(context.Background(), name)\n+\treturn DefaultResolver.LookupNS(context.Background(), name)\n }\n \n // LookupNS returns the DNS NS records for the given domain name.\n+//\n+// The returned name server names are validated to be properly\n+// formatted presentation-format domain names.\n func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error) {\n-\treturn r.lookupNS(ctx, name)\n+\trecords, err := r.lookupNS(ctx, name)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor _, ns := range records {\n+\t\tif ns == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif !isDomainName(ns.Host) {\n+\t\t\treturn nil, &DNSError{Err: \"NS target is invalid\", Name: name}\n+\t\t}\n+\t}\n+\treturn records, nil\n }\n \n // LookupTXT returns the DNS TXT records for the given domain name.\n@@ -466,14 +536,29 @@ func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)\n // LookupAddr performs a reverse lookup for the given address, returning a list\n // of names mapping to that address.\n //\n+// The returned names are validated to be properly formatted presentation-format\n+// domain names.\n+//\n // When using the host C library resolver, at most one result will be\n // returned. To bypass the host resolver, use a custom Resolver.\n func LookupAddr(addr string) (names []string, err error) {\n-\treturn DefaultResolver.lookupAddr(context.Background(), addr)\n+\treturn DefaultResolver.LookupAddr(context.Background(), addr)\n }\n \n // LookupAddr performs a reverse lookup for the given address, returning a list\n // of names mapping to that address.\n-func (r *Resolver) LookupAddr(ctx context.Context, addr string) (names []string, err error) {\n-\treturn r.lookupAddr(ctx, addr)\n+//\n+// The returned names are validated to be properly formatted presentation-format\n+// domain names.\n+func (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error) {\n+\tnames, err := r.lookupAddr(ctx, addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor _, name := range names {\n+\t\tif !isDomainName(name) {\n+\t\t\treturn nil, &DNSError{Err: \"PTR target is invalid\", Name: addr}\n+\t\t}\n+\t}\n+\treturn names, nil\n }"}, {"sha": "1f89780c455f04f56a0232fdb5f3e61f13618623", "filename": "libgo/go/os/signal/signal_test.go", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsignal%2Fsignal_test.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"os\"\n \t\"os/exec\"\n \t\"runtime\"\n+\t\"runtime/trace\"\n \t\"strconv\"\n \t\"sync\"\n \t\"syscall\"\n@@ -853,3 +854,44 @@ func TestNotifyContextStringer(t *testing.T) {\n \t\tt.Errorf(\"c.String() = %q, want %q\", got, want)\n \t}\n }\n+\n+// #44193 test signal handling while stopping and starting the world.\n+func TestSignalTrace(t *testing.T) {\n+\tdone := make(chan struct{})\n+\tquit := make(chan struct{})\n+\tc := make(chan os.Signal, 1)\n+\tNotify(c, syscall.SIGHUP)\n+\n+\t// Source and sink for signals busy loop unsynchronized with\n+\t// trace starts and stops. We are ultimately validating that\n+\t// signals and runtime.(stop|start)TheWorldGC are compatible.\n+\tgo func() {\n+\t\tdefer close(done)\n+\t\tdefer Stop(c)\n+\t\tpid := syscall.Getpid()\n+\t\tfor {\n+\t\t\tselect {\n+\t\t\tcase <-quit:\n+\t\t\t\treturn\n+\t\t\tdefault:\n+\t\t\t\tsyscall.Kill(pid, syscall.SIGHUP)\n+\t\t\t}\n+\t\t\twaitSig(t, c, syscall.SIGHUP)\n+\t\t}\n+\t}()\n+\n+\tfor i := 0; i < 100; i++ {\n+\t\tbuf := new(bytes.Buffer)\n+\t\tif err := trace.Start(buf); err != nil {\n+\t\t\tt.Fatalf(\"[%d] failed to start tracing: %v\", i, err)\n+\t\t}\n+\t\ttime.After(1 * time.Microsecond)\n+\t\ttrace.Stop()\n+\t\tsize := buf.Len()\n+\t\tif size == 0 {\n+\t\t\tt.Fatalf(\"[%d] trace is empty\", i)\n+\t\t}\n+\t}\n+\tclose(quit)\n+\t<-done\n+}"}, {"sha": "73d7aaaf9f82c0e13c65d30513c8afb8f2331fa1", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -279,7 +279,8 @@ func testCPUProfile(t *testing.T, matches matchFunc, need []string, avoid []stri\n \n \tbroken := false\n \tswitch runtime.GOOS {\n-\tcase \"darwin\", \"ios\", \"dragonfly\", \"netbsd\", \"illumos\", \"solaris\":\n+\t// See https://golang.org/issue/45170 for AIX.\n+\tcase \"darwin\", \"ios\", \"dragonfly\", \"netbsd\", \"illumos\", \"solaris\", \"aix\":\n \t\tbroken = true\n \tcase \"openbsd\":\n \t\tif runtime.GOARCH == \"arm\" || runtime.GOARCH == \"arm64\" {"}, {"sha": "037e7798a3827db5fb26a705e084476e63d9b319", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -1287,6 +1287,9 @@ func mPark() {\n \tg := getg()\n \tfor {\n \t\tnotesleep(&g.m.park)\n+\t\t// Note, because of signal handling by this parked m,\n+\t\t// a preemptive mDoFixup() may actually occur via\n+\t\t// mDoFixupAndOSYield(). (See golang.org/issue/44193)\n \t\tnoteclear(&g.m.park)\n \t\tif !mDoFixup() {\n \t\t\treturn\n@@ -1949,9 +1952,21 @@ var mFixupRace struct {\n // mDoFixup runs any outstanding fixup function for the running m.\n // Returns true if a fixup was outstanding and actually executed.\n //\n+// Note: to avoid deadlocks, and the need for the fixup function\n+// itself to be async safe, signals are blocked for the working m\n+// while it holds the mFixup lock. (See golang.org/issue/44193)\n+//\n //go:nosplit\n func mDoFixup() bool {\n \t_g_ := getg()\n+\tif used := atomic.Load(&_g_.m.mFixup.used); used == 0 {\n+\t\treturn false\n+\t}\n+\n+\t// slow path - if fixup fn is used, block signals and lock.\n+\tvar sigmask sigset\n+\tsigsave(&sigmask)\n+\tsigblock(false)\n \tlock(&_g_.m.mFixup.lock)\n \tfn := _g_.m.mFixup.fn\n \tif fn != nil {\n@@ -1972,9 +1987,20 @@ func mDoFixup() bool {\n \t\tfn(false)\n \t}\n \tunlock(&_g_.m.mFixup.lock)\n+\tmsigrestore(sigmask)\n \treturn fn != nil\n }\n \n+// mDoFixupAndOSYield is called when an m is unable to send a signal\n+// because the allThreadsSyscall mechanism is in progress. That is, an\n+// mPark() has been interrupted with this signal handler so we need to\n+// ensure the fixup is executed from this context.\n+//go:nosplit\n+func mDoFixupAndOSYield() {\n+\tmDoFixup()\n+\tosyield()\n+}\n+\n // templateThread is a thread in a known-good state that exists solely\n // to start new threads in known-good states when the calling thread\n // may not be in a good state."}, {"sha": "1879b829be7275bec01466ca71feea3e2be19d12", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -584,10 +584,13 @@ type m struct {\n \tsyscalltick   uint32\n \tfreelink      *m // on sched.freem\n \n-\t// mFixup is used to synchronize OS related m state (credentials etc)\n-\t// use mutex to access.\n+\t// mFixup is used to synchronize OS related m state\n+\t// (credentials etc) use mutex to access. To avoid deadlocks\n+\t// an atomic.Load() of used being zero in mDoFixupFn()\n+\t// guarantees fn is nil.\n \tmFixup struct {\n \t\tlock mutex\n+\t\tused uint32\n \t\tfn   func(bool) bool\n \t}\n "}, {"sha": "7ca755740d27b3ec85a6c05e005e30fc7cc6f655", "filename": "libgo/go/runtime/sigqueue.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fruntime%2Fsigqueue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsigqueue.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -119,7 +119,7 @@ Send:\n \t\t\t}\n \t\tcase sigFixup:\n \t\t\t// nothing to do - we need to wait for sigIdle.\n-\t\t\tosyield()\n+\t\t\tmDoFixupAndOSYield()\n \t\t}\n \t}\n "}, {"sha": "57052338d0aaa5b2890d9eb0b39d3f71f2a24881", "filename": "libgo/go/time/zoneinfo.go", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Ftime%2Fzoneinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Ftime%2Fzoneinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -178,7 +178,7 @@ func (l *Location) lookup(sec int64) (name string, offset int, start, end int64)\n \t// If we're at the end of the known zone transitions,\n \t// try the extend string.\n \tif lo == len(tx)-1 && l.extend != \"\" {\n-\t\tif ename, eoffset, estart, eend, ok := tzset(l.extend, end, sec); ok {\n+\t\tif ename, eoffset, estart, eend, _, ok := tzset(l.extend, end, sec); ok {\n \t\t\treturn ename, eoffset, estart, eend\n \t\t}\n \t}\n@@ -244,7 +244,7 @@ func (l *Location) firstZoneUsed() bool {\n // We call this a tzset string since in C the function tzset reads TZ.\n // The return values are as for lookup, plus ok which reports whether the\n // parse succeeded.\n-func tzset(s string, initEnd, sec int64) (name string, offset int, start, end int64, ok bool) {\n+func tzset(s string, initEnd, sec int64) (name string, offset int, start, end int64, isDST, ok bool) {\n \tvar (\n \t\tstdName, dstName     string\n \t\tstdOffset, dstOffset int\n@@ -255,7 +255,7 @@ func tzset(s string, initEnd, sec int64) (name string, offset int, start, end in\n \t\tstdOffset, s, ok = tzsetOffset(s)\n \t}\n \tif !ok {\n-\t\treturn \"\", 0, 0, 0, false\n+\t\treturn \"\", 0, 0, 0, false, false\n \t}\n \n \t// The numbers in the tzset string are added to local time to get UTC,\n@@ -265,7 +265,7 @@ func tzset(s string, initEnd, sec int64) (name string, offset int, start, end in\n \n \tif len(s) == 0 || s[0] == ',' {\n \t\t// No daylight savings time.\n-\t\treturn stdName, stdOffset, initEnd, omega, true\n+\t\treturn stdName, stdOffset, initEnd, omega, false, true\n \t}\n \n \tdstName, s, ok = tzsetName(s)\n@@ -278,7 +278,7 @@ func tzset(s string, initEnd, sec int64) (name string, offset int, start, end in\n \t\t}\n \t}\n \tif !ok {\n-\t\treturn \"\", 0, 0, 0, false\n+\t\treturn \"\", 0, 0, 0, false, false\n \t}\n \n \tif len(s) == 0 {\n@@ -287,19 +287,19 @@ func tzset(s string, initEnd, sec int64) (name string, offset int, start, end in\n \t}\n \t// The TZ definition does not mention ';' here but tzcode accepts it.\n \tif s[0] != ',' && s[0] != ';' {\n-\t\treturn \"\", 0, 0, 0, false\n+\t\treturn \"\", 0, 0, 0, false, false\n \t}\n \ts = s[1:]\n \n \tvar startRule, endRule rule\n \tstartRule, s, ok = tzsetRule(s)\n \tif !ok || len(s) == 0 || s[0] != ',' {\n-\t\treturn \"\", 0, 0, 0, false\n+\t\treturn \"\", 0, 0, 0, false, false\n \t}\n \ts = s[1:]\n \tendRule, s, ok = tzsetRule(s)\n \tif !ok || len(s) > 0 {\n-\t\treturn \"\", 0, 0, 0, false\n+\t\treturn \"\", 0, 0, 0, false, false\n \t}\n \n \tyear, _, _, yday := absDate(uint64(sec+unixToInternal+internalToAbsolute), false)\n@@ -313,22 +313,27 @@ func tzset(s string, initEnd, sec int64) (name string, offset int, start, end in\n \n \tstartSec := int64(tzruleTime(year, startRule, stdOffset))\n \tendSec := int64(tzruleTime(year, endRule, dstOffset))\n+\tdstIsDST, stdIsDST := true, false\n+\t// Note: this is a flipping of \"DST\" and \"STD\" while retaining the labels\n+\t// This happens in southern hemispheres. The labelling here thus is a little\n+\t// inconsistent with the goal.\n \tif endSec < startSec {\n \t\tstartSec, endSec = endSec, startSec\n \t\tstdName, dstName = dstName, stdName\n \t\tstdOffset, dstOffset = dstOffset, stdOffset\n+\t\tstdIsDST, dstIsDST = dstIsDST, stdIsDST\n \t}\n \n \t// The start and end values that we return are accurate\n \t// close to a daylight savings transition, but are otherwise\n \t// just the start and end of the year. That suffices for\n \t// the only caller that cares, which is Date.\n \tif ysec < startSec {\n-\t\treturn stdName, stdOffset, abs, startSec + abs, true\n+\t\treturn stdName, stdOffset, abs, startSec + abs, stdIsDST, true\n \t} else if ysec >= endSec {\n-\t\treturn stdName, stdOffset, endSec + abs, abs + 365*secondsPerDay, true\n+\t\treturn stdName, stdOffset, endSec + abs, abs + 365*secondsPerDay, stdIsDST, true\n \t} else {\n-\t\treturn dstName, dstOffset, startSec + abs, endSec + abs, true\n+\t\treturn dstName, dstOffset, startSec + abs, endSec + abs, dstIsDST, true\n \t}\n }\n "}, {"sha": "c8c725697b09d4d9e032f44a1574cbbbdbff5bf7", "filename": "libgo/go/time/zoneinfo_read.go", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_read.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -249,8 +249,8 @@ func LoadLocationFromTZData(name string, data []byte) (*Location, error) {\n \t\t// This also avoids a panic later when we add and then use a fake transition (golang.org/issue/29437).\n \t\treturn nil, badData\n \t}\n-\tzone := make([]zone, nzone)\n-\tfor i := range zone {\n+\tzones := make([]zone, nzone)\n+\tfor i := range zones {\n \t\tvar ok bool\n \t\tvar n uint32\n \t\tif n, ok = zonedata.big4(); !ok {\n@@ -259,22 +259,22 @@ func LoadLocationFromTZData(name string, data []byte) (*Location, error) {\n \t\tif uint32(int(n)) != n {\n \t\t\treturn nil, badData\n \t\t}\n-\t\tzone[i].offset = int(int32(n))\n+\t\tzones[i].offset = int(int32(n))\n \t\tvar b byte\n \t\tif b, ok = zonedata.byte(); !ok {\n \t\t\treturn nil, badData\n \t\t}\n-\t\tzone[i].isDST = b != 0\n+\t\tzones[i].isDST = b != 0\n \t\tif b, ok = zonedata.byte(); !ok || int(b) >= len(abbrev) {\n \t\t\treturn nil, badData\n \t\t}\n-\t\tzone[i].name = byteString(abbrev[b:])\n+\t\tzones[i].name = byteString(abbrev[b:])\n \t\tif runtime.GOOS == \"aix\" && len(name) > 8 && (name[:8] == \"Etc/GMT+\" || name[:8] == \"Etc/GMT-\") {\n \t\t\t// There is a bug with AIX 7.2 TL 0 with files in Etc,\n \t\t\t// GMT+1 will return GMT-1 instead of GMT+1 or -01.\n \t\t\tif name != \"Etc/GMT+0\" {\n \t\t\t\t// GMT+0 is OK\n-\t\t\t\tzone[i].name = name[4:]\n+\t\t\t\tzones[i].name = name[4:]\n \t\t\t}\n \t\t}\n \t}\n@@ -297,7 +297,7 @@ func LoadLocationFromTZData(name string, data []byte) (*Location, error) {\n \t\t\t}\n \t\t}\n \t\ttx[i].when = n\n-\t\tif int(txzones[i]) >= len(zone) {\n+\t\tif int(txzones[i]) >= len(zones) {\n \t\t\treturn nil, badData\n \t\t}\n \t\ttx[i].index = txzones[i]\n@@ -316,7 +316,7 @@ func LoadLocationFromTZData(name string, data []byte) (*Location, error) {\n \t}\n \n \t// Committed to succeed.\n-\tl := &Location{zone: zone, tx: tx, name: name, extend: extend}\n+\tl := &Location{zone: zones, tx: tx, name: name, extend: extend}\n \n \t// Fill in the cache with information about right now,\n \t// since that will be the most common lookup.\n@@ -325,33 +325,43 @@ func LoadLocationFromTZData(name string, data []byte) (*Location, error) {\n \t\tif tx[i].when <= sec && (i+1 == len(tx) || sec < tx[i+1].when) {\n \t\t\tl.cacheStart = tx[i].when\n \t\t\tl.cacheEnd = omega\n-\t\t\tzoneIdx := tx[i].index\n+\t\t\tl.cacheZone = &l.zone[tx[i].index]\n \t\t\tif i+1 < len(tx) {\n \t\t\t\tl.cacheEnd = tx[i+1].when\n \t\t\t} else if l.extend != \"\" {\n \t\t\t\t// If we're at the end of the known zone transitions,\n \t\t\t\t// try the extend string.\n-\t\t\t\tif name, _, estart, eend, ok := tzset(l.extend, l.cacheEnd, sec); ok {\n+\t\t\t\tif name, offset, estart, eend, isDST, ok := tzset(l.extend, l.cacheEnd, sec); ok {\n \t\t\t\t\tl.cacheStart = estart\n \t\t\t\t\tl.cacheEnd = eend\n-\t\t\t\t\t// Find the zone that is returned by tzset,\n-\t\t\t\t\t// the last transition is not always the correct zone.\n-\t\t\t\t\tfor i, z := range l.zone {\n-\t\t\t\t\t\tif z.name == name {\n-\t\t\t\t\t\t\tzoneIdx = uint8(i)\n-\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t// Find the zone that is returned by tzset to avoid allocation if possible.\n+\t\t\t\t\tif zoneIdx := findZone(l.zone, name, offset, isDST); zoneIdx != -1 {\n+\t\t\t\t\t\tl.cacheZone = &l.zone[zoneIdx]\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tl.cacheZone = &zone{\n+\t\t\t\t\t\t\tname:   name,\n+\t\t\t\t\t\t\toffset: offset,\n+\t\t\t\t\t\t\tisDST:  isDST,\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tl.cacheZone = &l.zone[zoneIdx]\n \t\t\tbreak\n \t\t}\n \t}\n \n \treturn l, nil\n }\n \n+func findZone(zones []zone, name string, offset int, isDST bool) int {\n+\tfor i, z := range zones {\n+\t\tif z.name == name && z.offset == offset && z.isDST == isDST {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\treturn -1\n+}\n+\n // loadTzinfoFromDirOrZip returns the contents of the file with the given name\n // in dir. dir can either be an uncompressed zip file, or a directory.\n func loadTzinfoFromDirOrZip(dir, name string) ([]byte, error) {"}, {"sha": "a9b4f077856da30b875f6fa185209e18d50caa76", "filename": "libgo/go/time/zoneinfo_test.go", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Ftime%2Fzoneinfo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Ftime%2Fzoneinfo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_test.go?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -192,30 +192,42 @@ func TestMalformedTZData(t *testing.T) {\n var slimTests = []struct {\n \tzoneName   string\n \ttzData     string\n+\tdate       func(*time.Location) time.Time\n \twantName   string\n \twantOffset int\n }{\n \t{\n \t\t// 2020b slim tzdata for Europe/Berlin.\n \t\tzoneName:   \"Europe/Berlin\",\n \t\ttzData:     \"TZif2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00TZif2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00<\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x12\\xff\\xff\\xff\\xffo\\xa2a\\xf8\\xff\\xff\\xff\\xff\\x9b\\f\\x17`\\xff\\xff\\xff\\xff\\x9b\\xd5\\xda\\xf0\\xff\\xff\\xff\\xff\\x9c\u066e\\x90\\xff\\xff\\xff\\xff\\x9d\\xa4\\xb5\\x90\\xff\\xff\\xff\\xff\\x9e\\xb9\\x90\\x90\\xff\\xff\\xff\\xff\\x9f\\x84\\x97\\x90\\xff\\xff\\xff\\xff\\xc8\\tq\\x90\\xff\\xff\\xff\\xff\\xcc\\xe7K\\x10\\xff\\xff\\xff\\xff\u0369\\x17\\x90\\xff\\xff\\xff\\xff\\u03a2C\\x10\\xff\\xff\\xff\\xff\u03d24\\x10\\xff\\xff\\xff\\xff\u0402%\\x10\\xff\\xff\\xff\\xff\\xd1r\\x16\\x10\\xff\\xff\\xff\\xff\u0476\\x96\\x00\\xff\\xff\\xff\\xff\\xd2X\\xbe\\x80\\xff\\xff\\xff\\xff\u04a1O\\x10\\xff\\xff\\xff\\xff\\xd3c\\x1b\\x90\\xff\\xff\\xff\\xff\\xd4K#\\x90\\xff\\xff\\xff\\xff\\xd59\\xd1 \\xff\\xff\\xff\\xff\\xd5g\\xe7\\x90\\xff\\xff\\xff\\xff\u0568s\\x00\\xff\\xff\\xff\\xff\\xd6)\\xb4\\x10\\xff\\xff\\xff\\xff\\xd7,\\x1a\\x10\\xff\\xff\\xff\\xff\\xd8\\t\\x96\\x10\\xff\\xff\\xff\\xff\\xd9\\x02\\xc1\\x90\\xff\\xff\\xff\\xff\\xd9\\xe9x\\x10\\x00\\x00\\x00\\x00\\x13MD\\x10\\x00\\x00\\x00\\x00\\x143\\xfa\\x90\\x00\\x00\\x00\\x00\\x15#\\xeb\\x90\\x00\\x00\\x00\\x00\\x16\\x13\u0710\\x00\\x00\\x00\\x00\\x17\\x03\u0350\\x00\\x00\\x00\\x00\\x17\\xf3\\xbe\\x90\\x00\\x00\\x00\\x00\\x18\u3bd0\\x00\\x00\\x00\\x00\\x19\u04e0\\x90\\x00\\x00\\x00\\x00\\x1a\u00d1\\x90\\x00\\x00\\x00\\x00\\x1b\\xbc\\xbd\\x10\\x00\\x00\\x00\\x00\\x1c\\xac\\xae\\x10\\x00\\x00\\x00\\x00\\x1d\\x9c\\x9f\\x10\\x00\\x00\\x00\\x00\\x1e\\x8c\\x90\\x10\\x00\\x00\\x00\\x00\\x1f|\\x81\\x10\\x00\\x00\\x00\\x00 lr\\x10\\x00\\x00\\x00\\x00!\\\\c\\x10\\x00\\x00\\x00\\x00\\\"LT\\x10\\x00\\x00\\x00\\x00#<E\\x10\\x00\\x00\\x00\\x00$,6\\x10\\x00\\x00\\x00\\x00%\\x1c'\\x10\\x00\\x00\\x00\\x00&\\f\\x18\\x10\\x00\\x00\\x00\\x00'\\x05C\\x90\\x00\\x00\\x00\\x00'\\xf54\\x90\\x00\\x00\\x00\\x00(\\xe5%\\x90\\x00\\x00\\x00\\x00)\\xd5\\x16\\x90\\x00\\x00\\x00\\x00*\\xc5\\a\\x90\\x00\\x00\\x00\\x00+\\xb4\\xf8\\x90\\x00\\x00\\x00\\x00,\\xa4\\xe9\\x90\\x00\\x00\\x00\\x00-\\x94\u0690\\x00\\x00\\x00\\x00.\\x84\u02d0\\x00\\x00\\x00\\x00/t\\xbc\\x90\\x00\\x00\\x00\\x000d\\xad\\x90\\x00\\x00\\x00\\x001]\\xd9\\x10\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x03\\x01\\x02\\x01\\x02\\x01\\x03\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x00\\x00\\f\\x88\\x00\\x00\\x00\\x00\\x1c \\x01\\x04\\x00\\x00\\x0e\\x10\\x00\\t\\x00\\x00*0\\x01\\rLMT\\x00CEST\\x00CET\\x00CEMT\\x00\\nCET-1CEST,M3.5.0,M10.5.0/3\\n\",\n+\t\tdate:       func(loc *time.Location) time.Time { return time.Date(2020, time.October, 29, 15, 30, 0, 0, loc) },\n \t\twantName:   \"CET\",\n \t\twantOffset: 3600,\n \t},\n \t{\n \t\t// 2021a slim tzdata for America/Nuuk.\n \t\tzoneName:   \"America/Nuuk\",\n \t\ttzData:     \"TZif3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00TZif3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\\"\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\f\\xff\\xff\\xff\\xff\\x9b\\x80h\\x00\\x00\\x00\\x00\\x00\\x13M|P\\x00\\x00\\x00\\x00\\x143\\xfa\\x90\\x00\\x00\\x00\\x00\\x15#\\xeb\\x90\\x00\\x00\\x00\\x00\\x16\\x13\u0710\\x00\\x00\\x00\\x00\\x17\\x03\u0350\\x00\\x00\\x00\\x00\\x17\\xf3\\xbe\\x90\\x00\\x00\\x00\\x00\\x18\u3bd0\\x00\\x00\\x00\\x00\\x19\u04e0\\x90\\x00\\x00\\x00\\x00\\x1a\u00d1\\x90\\x00\\x00\\x00\\x00\\x1b\\xbc\\xbd\\x10\\x00\\x00\\x00\\x00\\x1c\\xac\\xae\\x10\\x00\\x00\\x00\\x00\\x1d\\x9c\\x9f\\x10\\x00\\x00\\x00\\x00\\x1e\\x8c\\x90\\x10\\x00\\x00\\x00\\x00\\x1f|\\x81\\x10\\x00\\x00\\x00\\x00 lr\\x10\\x00\\x00\\x00\\x00!\\\\c\\x10\\x00\\x00\\x00\\x00\\\"LT\\x10\\x00\\x00\\x00\\x00#<E\\x10\\x00\\x00\\x00\\x00$,6\\x10\\x00\\x00\\x00\\x00%\\x1c'\\x10\\x00\\x00\\x00\\x00&\\f\\x18\\x10\\x00\\x00\\x00\\x00'\\x05C\\x90\\x00\\x00\\x00\\x00'\\xf54\\x90\\x00\\x00\\x00\\x00(\\xe5%\\x90\\x00\\x00\\x00\\x00)\\xd5\\x16\\x90\\x00\\x00\\x00\\x00*\\xc5\\a\\x90\\x00\\x00\\x00\\x00+\\xb4\\xf8\\x90\\x00\\x00\\x00\\x00,\\xa4\\xe9\\x90\\x00\\x00\\x00\\x00-\\x94\u0690\\x00\\x00\\x00\\x00.\\x84\u02d0\\x00\\x00\\x00\\x00/t\\xbc\\x90\\x00\\x00\\x00\\x000d\\xad\\x90\\x00\\x00\\x00\\x001]\\xd9\\x10\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\xff\\xff\u03c0\\x00\\x00\\xff\\xff\\xd5\\xd0\\x00\\x04\\xff\\xff\\xe3\\xe0\\x01\\bLMT\\x00-03\\x00-02\\x00\\n<-03>3<-02>,M3.5.0/-2,M10.5.0/-1\\n\",\n+\t\tdate:       func(loc *time.Location) time.Time { return time.Date(2020, time.October, 29, 15, 30, 0, 0, loc) },\n \t\twantName:   \"-03\",\n \t\twantOffset: -10800,\n \t},\n \t{\n \t\t// 2021a slim tzdata for Asia/Gaza.\n \t\tzoneName:   \"Asia/Gaza\",\n \t\ttzData:     \"TZif3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00TZif3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00s\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x15\\xff\\xff\\xff\\xff}\\xbdJ\\xb0\\xff\\xff\\xff\\xff\\xc8Y\\xcf\\x00\\xff\\xff\\xff\\xff\\xc8\\xfa\\xa6\\x00\\xff\\xff\\xff\\xff\\xc98\\x9c\\x80\\xff\\xff\\xff\\xff\\xcc\\xe5\\xeb\\x80\\xff\\xff\\xff\\xff\u036c\\xfe\\x00\\xff\\xff\\xff\\xff\\xce\\xc7\\x1f\\x00\\xff\\xff\\xff\\xff\u03cf\\x83\\x00\\xff\\xff\\xff\\xff\u0429\\xa4\\x00\\xff\\xff\\xff\\xff\u0444}\\x00\\xff\\xff\\xff\\xff\u048a\u05c0\\xff\\xff\\xff\\xff\\xd3e\\xb0\\x80\\xff\\xff\\xff\\xff\\xd4l\\v\\x00\\xff\\xff\\xff\\xff\\xe86c`\\xff\\xff\\xff\\xff\\xe8\\xf4-P\\xff\\xff\\xff\\xff\\xea\\v\\xb9`\\xff\\xff\\xff\\xff\\xea\\xd5`\\xd0\\xff\\xff\\xff\\xff\\xeb\\xec\\xfa\\xf0\\xff\\xff\\xff\\xff\\xec\\xb5m\\x00\\xff\\xff\\xff\\xff\\xed\\xcf\\u007f\\xf0\\xff\\xff\\xff\\xff\\xee\\x97\\xf2\\x00\\xff\\xff\\xff\\xff\ufc33p\\xff\\xff\\xff\\xff\\xf0y%\\x80\\xff\\xff\\xff\\xff\\xf1\\x91\\xe6\\xf0\\xff\\xff\\xff\\xff\\xf2ZY\\x00\\xff\\xff\\xff\\xff\\xf3s\\x1ap\\xff\\xff\\xff\\xff\\xf4;\\x8c\\x80\\xff\\xff\\xff\\xff\\xf5U\\x9fp\\xff\\xff\\xff\\xff\\xf6\\x1e\\x11\\x80\\xff\\xff\\xff\\xff\\xf76\\xd2\\xf0\\xff\\xff\\xff\\xff\\xf7\\xffE\\x00\\xff\\xff\\xff\\xff\\xf9\\x18\\x06p\\xff\\xff\\xff\\xff\\xf9\\xe1\\xca\\x00\\xff\\xff\\xff\\xff\\xfa\\xf99\\xf0\\xff\\xff\\xff\\xff\\xfb'BP\\x00\\x00\\x00\\x00\\b|\\x8b\\xe0\\x00\\x00\\x00\\x00\\b\\xfd\\xb0\\xd0\\x00\\x00\\x00\\x00\\t\\xf6\\xea`\\x00\\x00\\x00\\x00\\n\\xa63\\xd0\\x00\\x00\\x00\\x00\\x13\\xe9\\xfc`\\x00\\x00\\x00\\x00\\x14![`\\x00\\x00\\x00\\x00\\x1a\\xfa\\xc6`\\x00\\x00\\x00\\x00\\x1b\\x8en`\\x00\\x00\\x00\\x00\\x1c\\xbe\\xf8\\xe0\\x00\\x00\\x00\\x00\\x1dw|\\xd0\\x00\\x00\\x00\\x00\\x1e\\xcc\\xff`\\x00\\x00\\x00\\x00\\x1f`\\x99P\\x00\\x00\\x00\\x00 \\x82\\xb1`\\x00\\x00\\x00\\x00!I\\xb5\\xd0\\x00\\x00\\x00\\x00\\\"^\\x9e\\xe0\\x00\\x00\\x00\\x00# ]P\\x00\\x00\\x00\\x00$Z0`\\x00\\x00\\x00\\x00%\\x00?P\\x00\\x00\\x00\\x00&\\v\\xed\\xe0\\x00\\x00\\x00\\x00&\\xd6\\xe6\\xd0\\x00\\x00\\x00\\x00'\\xeb\\xcf\\xe0\\x00\\x00\\x00\\x00(\\xc0\\x03P\\x00\\x00\\x00\\x00)\\xd4\\xec`\\x00\\x00\\x00\\x00*\\xa9\\x1f\\xd0\\x00\\x00\\x00\\x00+\\xbbe\\xe0\\x00\\x00\\x00\\x00,\\x89\\x01\\xd0\\x00\\x00\\x00\\x00-\\x9bG\\xe0\\x00\\x00\\x00\\x00._\\xa9P\\x00\\x00\\x00\\x00/{)\\xe0\\x00\\x00\\x00\\x000H\\xc5\\xd0\\x00\\x00\\x00\\x000\\xe7\\a\\xe0\\x00\\x00\\x00\\x001dF`\\x00\\x00\\x00\\x002A\\xc2`\\x00\\x00\\x00\\x003D(`\\x00\\x00\\x00\\x004!\\xa4`\\x00\\x00\\x00\\x005$\\n`\\x00\\x00\\x00\\x006\\x01\\x86`\\x00\\x00\\x00\\x007\\x16a`\\x00\\x00\\x00\\x008\\x06DP\\x00\\x00\\x00\\x008\\xff}\\xe0\\x00\\x00\\x00\\x009\\xef`\\xd0\\x00\\x00\\x00\\x00:\\xdf_\\xe0\\x00\\x00\\x00\\x00;\\xcfB\\xd0\\x00\\x00\\x00\\x00<\\xbfA\\xe0\\x00\\x00\\x00\\x00=\\xaf$\\xd0\\x00\\x00\\x00\\x00>\\x9f#\\xe0\\x00\\x00\\x00\\x00?\\x8f\\x06\\xd0\\x00\\x00\\x00\\x00@\\u007f\\x05\\xe0\\x00\\x00\\x00\\x00A\\\\\\x81\\xe0\\x00\\x00\\x00\\x00B^\\xe7\\xe0\\x00\\x00\\x00\\x00CA\\xb7\\xf0\\x00\\x00\\x00\\x00D-\\xa6`\\x00\\x00\\x00\\x00E\\x12\\xfdP\\x00\\x00\\x00\\x00F\\x0e\\xd9\\xe0\\x00\\x00\\x00\\x00F\\xe8op\\x00\\x00\\x00\\x00G\\xec\\x18\\xe0\\x00\\x00\\x00\\x00H\\xb7\\x11\\xd0\\x00\\x00\\x00\\x00I\\xcb\\xfa\\xe0\\x00\\x00\\x00\\x00J\\xa0<`\\x00\\x00\\x00\\x00K\\xad.\\x9c\\x00\\x00\\x00\\x00La\\xbd\\xd0\\x00\\x00\\x00\\x00M\\x94\\xf9\\x9c\\x00\\x00\\x00\\x00N5\\xc2P\\x00\\x00\\x00\\x00Ot\\xdb`\\x00\\x00\\x00\\x00P[\\x91\\xe0\\x00\\x00\\x00\\x00QT\\xbd`\\x00\\x00\\x00\\x00RD\\xa0P\\x00\\x00\\x00\\x00S4\\x9f`\\x00\\x00\\x00\\x00TIlP\\x00\\x00\\x00\\x00U\\x15\\xd2\\xe0\\x00\\x00\\x00\\x00V)\\\\`\\x00\\x00\\x00\\x00V\\xf5\\xc2\\xf0\\x00\\x00\\x00\\x00X\\x13\\xca`\\x00\\x00\\x00\\x00X\u0564\\xf0\\x00\\x00\\x00\\x00Y\\xf3\\xac`\\x00\\x00\\x00\\x00Z\\xb5\\x86\\xf0\\x00\\x00\\x00\\x00[\u04ce`\\x00\\x00\\x00\\x00\\\\\\x9dC\\xe0\\x00\\x00\\x00\\x00]\\xb3bP\\x00\\x00\\x00\\x00^~w`\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x02\\x01\\x00\\x00 P\\x00\\x00\\x00\\x00*0\\x01\\x04\\x00\\x00\\x1c \\x00\\t\\x00\\x00*0\\x01\\r\\x00\\x00\\x1c \\x00\\x11LMT\\x00EEST\\x00EET\\x00IDT\\x00IST\\x00\\nEET-2EEST,M3.4.4/48,M10.4.4/49\\n\",\n+\t\tdate:       func(loc *time.Location) time.Time { return time.Date(2020, time.October, 29, 15, 30, 0, 0, loc) },\n \t\twantName:   \"EET\",\n \t\twantOffset: 7200,\n \t},\n+\t{\n+\t\t// 2021a slim tzdata for Europe/Dublin.\n+\t\tzoneName:   \"Europe/Dublin\",\n+\t\ttzData:     \"TZif2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00TZif2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x91\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x14\\xff\\xff\\xff\\xffW\\xd1\\n\\xdc\\xff\\xff\\xff\\xff\\x9b&\\xb3\\x91\\xff\\xff\\xff\\xff\\x9b\\xd6\\x0b\\x11\\xff\\xff\\xff\\xff\\x9c\\xcf0\\xa0\\xff\\xff\\xff\\xff\\x9d\\xa4\\xc3\\xa0\\xff\\xff\\xff\\xff\\x9e\\x9c\\x9d\\xa0\\xff\\xff\\xff\\xff\\x9f\\x97\\x1a\\xa0\\xff\\xff\\xff\\xff\\xa0\\x85\\xba\\x20\\xff\\xff\\xff\\xff\\xa1v\\xfc\\xa0\\xff\\xff\\xff\\xff\\xa2e\\x9c\\x20\\xff\\xff\\xff\\xff\\xa3{\\xc8\\xa0\\xff\\xff\\xff\\xff\\xa4N\\xb8\\xa0\\xff\\xff\\xff\\xff\\xa5?\\xfb\\x20\\xff\\xff\\xff\\xff\\xa6%`\\x20\\xff\\xff\\xff\\xff\\xa7'\\xc6\\x20\\xff\\xff\\xff\\xff\\xa8*,\\x20\\xff\\xff\\xff\\xff\\xa8\\xeb\\xf8\\xa0\\xff\\xff\\xff\\xff\\xaa\\x00\\xd3\\xa0\\xff\\xff\\xff\\xff\\xaa\\xd5\\x15\\x20\\xff\\xff\\xff\\xff\\xab\\xe9\\xf0\\x20\\xff\\xff\\xff\\xff\\xac\\xc7l\\x20\\xff\\xff\\xff\\xff\\xad\\xc9\\xd2\\x20\\xff\\xff\\xff\\xff\\xae\\xa7N\\x20\\xff\\xff\\xff\\xff\\xaf\\xa0y\\xa0\\xff\\xff\\xff\\xff\\xb0\\x870\\x20\\xff\\xff\\xff\\xff\\xb1\\x92\\xd0\\xa0\\xff\\xff\\xff\\xff\\xb2pL\\xa0\\xff\\xff\\xff\\xff\\xb3r\\xb2\\xa0\\xff\\xff\\xff\\xff\\xb4P.\\xa0\\xff\\xff\\xff\\xff\\xb5IZ\\x20\\xff\\xff\\xff\\xff\\xb60\\x10\\xa0\\xff\\xff\\xff\\xff\\xb72v\\xa0\\xff\\xff\\xff\\xff\\xb8\\x0f\\xf2\\xa0\\xff\\xff\\xff\\xff\\xb9\\x12X\\xa0\\xff\\xff\\xff\\xff\\xb9\\xef\\xd4\\xa0\\xff\\xff\\xff\\xff\\xba\\xe9\\x00\\x20\\xff\\xff\\xff\\xff\\xbb\\xd8\\xf1\\x20\\xff\\xff\\xff\\xff\\xbc\\xdbW\\x20\\xff\\xff\\xff\\xff\\xbd\\xb8\\xd3\\x20\\xff\\xff\\xff\\xff\\xbe\\xb1\\xfe\\xa0\\xff\\xff\\xff\\xff\\xbf\\x98\\xb5\\x20\\xff\\xff\\xff\\xff\\xc0\\x9b\\x1b\\x20\\xff\\xff\\xff\\xff\\xc1x\\x97\\x20\\xff\\xff\\xff\\xff\\xc2z\\xfd\\x20\\xff\\xff\\xff\\xff\\xc3Xy\\x20\\xff\\xff\\xff\\xff\\xc4Q\\xa4\\xa0\\xff\\xff\\xff\\xff\\xc58[\\x20\\xff\\xff\\xff\\xff\\xc6:\\xc1\\x20\\xff\\xff\\xff\\xff\\xc7X\\xd6\\xa0\\xff\\xff\\xff\\xff\\xc7\\xda\\x09\\xa0\\xff\\xff\\xff\\xff\\xd4I\\xe0\\x20\\xff\\xff\\xff\\xff\\xd5\\x1e!\\xa0\\xff\\xff\\xff\\xff\\xd6N\\xac\\x20\\xff\\xff\\xff\\xff\\xd7,(\\x20\\xff\\xff\\xff\\xff\\xd8.\\x8e\\x20\\xff\\xff\\xff\\xff\\xd8\\xf9\\x95\\x20\\xff\\xff\\xff\\xff\\xda\\x0ep\\x20\\xff\\xff\\xff\\xff\\xda\\xeb\\xec\\x20\\xff\\xff\\xff\\xff\\xdb\\xe5\\x17\\xa0\\xff\\xff\\xff\\xff\\xdc\\xcb\\xce\\x20\\xff\\xff\\xff\\xff\\xdd\\xc4\\xf9\\xa0\\xff\\xff\\xff\\xff\\xde\\xb4\\xea\\xa0\\xff\\xff\\xff\\xff\\xdf\\xae\\x16\\x20\\xff\\xff\\xff\\xff\\xe0\\x94\\xcc\\xa0\\xff\\xff\\xff\\xff\\xe1rH\\xa0\\xff\\xff\\xff\\xff\\xe2kt\\x20\\xff\\xff\\xff\\xff\\xe3R*\\xa0\\xff\\xff\\xff\\xff\\xe4T\\x90\\xa0\\xff\\xff\\xff\\xff\\xe52\\x0c\\xa0\\xff\\xff\\xff\\xff\\xe6=\\xad\\x20\\xff\\xff\\xff\\xff\\xe7\\x1b)\\x20\\xff\\xff\\xff\\xff\\xe8\\x14T\\xa0\\xff\\xff\\xff\\xff\\xe8\\xfb\\x0b\\x20\\xff\\xff\\xff\\xff\\xe9\\xfdq\\x20\\xff\\xff\\xff\\xff\\xea\\xda\\xed\\x20\\xff\\xff\\xff\\xff\\xeb\\xddS\\x20\\xff\\xff\\xff\\xff\\xec\\xba\\xcf\\x20\\xff\\xff\\xff\\xff\\xed\\xb3\\xfa\\xa0\\xff\\xff\\xff\\xff\\xee\\x9a\\xb1\\x20\\xff\\xff\\xff\\xff\\xef\\x81g\\xa0\\xff\\xff\\xff\\xff\\xf0\\x9f}\\x20\\xff\\xff\\xff\\xff\\xf1aI\\xa0\\xff\\xff\\xff\\xff\\xf2\\x7f_\\x20\\xff\\xff\\xff\\xff\\xf3Jf\\x20\\xff\\xff\\xff\\xff\\xf4_A\\x20\\xff\\xff\\xff\\xff\\xf5!\\x0d\\xa0\\xff\\xff\\xff\\xff\\xf6?#\\x20\\xff\\xff\\xff\\xff\\xf7\\x00\\xef\\xa0\\xff\\xff\\xff\\xff\\xf8\\x1f\\x05\\x20\\xff\\xff\\xff\\xff\\xf8\\xe0\\xd1\\xa0\\xff\\xff\\xff\\xff\\xf9\\xfe\\xe7\\x20\\xff\\xff\\xff\\xff\\xfa\\xc0\\xb3\\xa0\\xff\\xff\\xff\\xff\\xfb\\xe8\\x03\\xa0\\xff\\xff\\xff\\xff\\xfc{\\xab\\xa0\\xff\\xff\\xff\\xff\\xfd\\xc7\\xbbp\\x00\\x00\\x00\\x00\\x03p\\xc6\\x20\\x00\\x00\\x00\\x00\\x04)X\\x20\\x00\\x00\\x00\\x00\\x05P\\xa8\\x20\\x00\\x00\\x00\\x00\\x06\\x09:\\x20\\x00\\x00\\x00\\x00\\x070\\x8a\\x20\\x00\\x00\\x00\\x00\\x07\\xe9\\x1c\\x20\\x00\\x00\\x00\\x00\\x09\\x10l\\x20\\x00\\x00\\x00\\x00\\x09\\xc8\\xfe\\x20\\x00\\x00\\x00\\x00\\n\\xf0N\\x20\\x00\\x00\\x00\\x00\\x0b\\xb2\\x1a\\xa0\\x00\\x00\\x00\\x00\\x0c\\xd00\\x20\\x00\\x00\\x00\\x00\\x0d\\x91\\xfc\\xa0\\x00\\x00\\x00\\x00\\x0e\\xb0\\x12\\x20\\x00\\x00\\x00\\x00\\x0fq\\xde\\xa0\\x00\\x00\\x00\\x00\\x10\\x99.\\xa0\\x00\\x00\\x00\\x00\\x11Q\\xc0\\xa0\\x00\\x00\\x00\\x00\\x12y\\x10\\xa0\\x00\\x00\\x00\\x00\\x131\\xa2\\xa0\\x00\\x00\\x00\\x00\\x14X\\xf2\\xa0\\x00\\x00\\x00\\x00\\x15#\\xeb\\x90\\x00\\x00\\x00\\x00\\x168\\xc6\\x90\\x00\\x00\\x00\\x00\\x17\\x03\\xcd\\x90\\x00\\x00\\x00\\x00\\x18\\x18\\xa8\\x90\\x00\\x00\\x00\\x00\\x18\\xe3\\xaf\\x90\\x00\\x00\\x00\\x00\\x19\\xf8\\x8a\\x90\\x00\\x00\\x00\\x00\\x1a\\xc3\\x91\\x90\\x00\\x00\\x00\\x00\\x1b\\xe1\\xa7\\x10\\x00\\x00\\x00\\x00\\x1c\\xac\\xae\\x10\\x00\\x00\\x00\\x00\\x1d\\xc1\\x89\\x10\\x00\\x00\\x00\\x00\\x1e\\x8c\\x90\\x10\\x00\\x00\\x00\\x00\\x1f\\xa1k\\x10\\x00\\x00\\x00\\x00\\x20lr\\x10\\x00\\x00\\x00\\x00!\\x81M\\x10\\x00\\x00\\x00\\x00\\x22LT\\x10\\x00\\x00\\x00\\x00#a/\\x10\\x00\\x00\\x00\\x00$,6\\x10\\x00\\x00\\x00\\x00%JK\\x90\\x00\\x00\\x00\\x00&\\x0c\\x18\\x10\\x00\\x00\\x00\\x00'*-\\x90\\x00\\x00\\x00\\x00'\\xf54\\x90\\x00\\x00\\x00\\x00)\\n\\x0f\\x90\\x00\\x00\\x00\\x00)\\xd5\\x16\\x90\\x00\\x00\\x00\\x00*\\xe9\\xf1\\x90\\x00\\x00\\x00\\x00+\\xb4\\xf8\\x90\\x00\\x00\\x00\\x00,\\xc9\\xd3\\x90\\x00\\x00\\x00\\x00-\\x94\\xda\\x90\\x00\\x00\\x00\\x00.\\xa9\\xb5\\x90\\x00\\x00\\x00\\x00/t\\xbc\\x90\\x00\\x00\\x00\\x000\\x89\\x97\\x90\\x00\\x00\\x00\\x001]\\xd9\\x10\\x01\\x02\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x03\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x04\\x05\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\x06\\x07\\xff\\xff\\xfa$\\x00\\x00\\xff\\xff\\xfa\\x0f\\x00\\x04\\x00\\x00\\x08\\x1f\\x01\\x08\\x00\\x00\\x0e\\x10\\x01\\x0c\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x0e\\x10\\x01\\x08\\x00\\x00\\x00\\x00\\x01\\x10\\x00\\x00\\x0e\\x10\\x00\\x08LMT\\x00DMT\\x00IST\\x00BST\\x00GMT\\x00\\nIST-1GMT0,M10.5.0,M3.5.0/1\\n\",\n+\t\tdate:       func(loc *time.Location) time.Time { return time.Date(2021, time.April, 2, 11, 12, 13, 0, loc) },\n+\t\twantName:   \"IST\",\n+\t\twantOffset: 3600,\n+\t},\n }\n \n func TestLoadLocationFromTZDataSlim(t *testing.T) {\n@@ -225,7 +237,7 @@ func TestLoadLocationFromTZDataSlim(t *testing.T) {\n \t\t\tt.Fatal(err)\n \t\t}\n \n-\t\td := time.Date(2020, time.October, 29, 15, 30, 0, 0, reference)\n+\t\td := test.date(reference)\n \t\ttzName, tzOffset := d.Zone()\n \t\tif tzName != test.wantName {\n \t\t\tt.Errorf(\"Zone name == %s, want %s\", tzName, test.wantName)\n@@ -245,20 +257,21 @@ func TestTzset(t *testing.T) {\n \t\toff   int\n \t\tstart int64\n \t\tend   int64\n+\t\tisDST bool\n \t\tok    bool\n \t}{\n-\t\t{\"\", 0, 0, \"\", 0, 0, 0, false},\n-\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2159200800, \"PDT\", -7 * 60 * 60, 2152173600, 2172733200, true},\n-\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2152173599, \"PST\", -8 * 60 * 60, 2145916800, 2152173600, true},\n-\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2152173600, \"PDT\", -7 * 60 * 60, 2152173600, 2172733200, true},\n-\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2152173601, \"PDT\", -7 * 60 * 60, 2152173600, 2172733200, true},\n-\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2172733199, \"PDT\", -7 * 60 * 60, 2152173600, 2172733200, true},\n-\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2172733200, \"PST\", -8 * 60 * 60, 2172733200, 2177452800, true},\n-\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2172733201, \"PST\", -8 * 60 * 60, 2172733200, 2177452800, true},\n+\t\t{\"\", 0, 0, \"\", 0, 0, 0, false, false},\n+\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2159200800, \"PDT\", -7 * 60 * 60, 2152173600, 2172733200, true, true},\n+\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2152173599, \"PST\", -8 * 60 * 60, 2145916800, 2152173600, false, true},\n+\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2152173600, \"PDT\", -7 * 60 * 60, 2152173600, 2172733200, true, true},\n+\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2152173601, \"PDT\", -7 * 60 * 60, 2152173600, 2172733200, true, true},\n+\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2172733199, \"PDT\", -7 * 60 * 60, 2152173600, 2172733200, true, true},\n+\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2172733200, \"PST\", -8 * 60 * 60, 2172733200, 2177452800, false, true},\n+\t\t{\"PST8PDT,M3.2.0,M11.1.0\", 0, 2172733201, \"PST\", -8 * 60 * 60, 2172733200, 2177452800, false, true},\n \t} {\n-\t\tname, off, start, end, ok := time.Tzset(test.inStr, test.inEnd, test.inSec)\n-\t\tif name != test.name || off != test.off || start != test.start || end != test.end || ok != test.ok {\n-\t\t\tt.Errorf(\"tzset(%q, %d, %d) = %q, %d, %d, %d, %t, want %q, %d, %d, %d, %t\", test.inStr, test.inEnd, test.inSec, name, off, start, end, ok, test.name, test.off, test.start, test.end, test.ok)\n+\t\tname, off, start, end, isDST, ok := time.Tzset(test.inStr, test.inEnd, test.inSec)\n+\t\tif name != test.name || off != test.off || start != test.start || end != test.end || isDST != test.isDST || ok != test.ok {\n+\t\t\tt.Errorf(\"tzset(%q, %d, %d) = %q, %d, %d, %d, %t, %t, want %q, %d, %d, %d, %t, %t\", test.inStr, test.inEnd, test.inSec, name, off, start, end, isDST, ok, test.name, test.off, test.start, test.end, test.isDST, test.ok)\n \t\t}\n \t}\n }"}, {"sha": "b18d36639a1426843acc678f626f21e995909c83", "filename": "libgo/go/vendor/modules.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fvendor%2Fmodules.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee52bf609bac45b3c251858a69071262f46ee89c/libgo%2Fgo%2Fvendor%2Fmodules.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fvendor%2Fmodules.txt?ref=ee52bf609bac45b3c251858a69071262f46ee89c", "patch": "@@ -8,7 +8,7 @@ golang.org/x/crypto/curve25519\n golang.org/x/crypto/hkdf\n golang.org/x/crypto/internal/subtle\n golang.org/x/crypto/poly1305\n-# golang.org/x/net v0.0.0-20201209123823-ac852fbbde11\n+# golang.org/x/net v0.0.0-20210428183300-3f4a416c7d3b\n ## explicit\n golang.org/x/net/dns/dnsmessage\n golang.org/x/net/http/httpguts"}]}