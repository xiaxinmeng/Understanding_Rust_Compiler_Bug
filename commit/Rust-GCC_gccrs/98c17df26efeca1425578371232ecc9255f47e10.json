{"sha": "98c17df26efeca1425578371232ecc9255f47e10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThjMTdkZjI2ZWZlY2ExNDI1NTc4MzcxMjMyZWNjOTI1NWY0N2UxMA==", "commit": {"author": {"name": "Graham Stott", "email": "grahams@redhat.com", "date": "2000-12-22T01:25:23Z"}, "committer": {"name": "Graham Stott", "email": "grahams@gcc.gnu.org", "date": "2000-12-22T01:25:23Z"}, "message": "reload.c (update_auto_inc_notes): New, broken out from ...\n\n\n        * reload.c (update_auto_inc_notes): New, broken out from ...\n        (find_reloads_address_1): ... use here, also correct possible\n        use of uninitialised reloadnum.\n\nFrom-SVN: r38441", "tree": {"sha": "53defda72c7c835bcdbe9c92edb1f11d16d22c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53defda72c7c835bcdbe9c92edb1f11d16d22c60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98c17df26efeca1425578371232ecc9255f47e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c17df26efeca1425578371232ecc9255f47e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c17df26efeca1425578371232ecc9255f47e10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c17df26efeca1425578371232ecc9255f47e10/comments", "author": null, "committer": null, "parents": [{"sha": "98e6e789f681fb753bc737b28d252039ea4e951a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e6e789f681fb753bc737b28d252039ea4e951a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e6e789f681fb753bc737b28d252039ea4e951a"}], "stats": {"total": 64, "additions": 42, "deletions": 22}, "files": [{"sha": "e39574550b8e65e2c9ad97f6937260e598f15a65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c17df26efeca1425578371232ecc9255f47e10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c17df26efeca1425578371232ecc9255f47e10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98c17df26efeca1425578371232ecc9255f47e10", "patch": "@@ -1,3 +1,9 @@\n+2000-12-22  Graham Stott  <grahams@redhat.com>\n+\n+\t* reload.c (update_auto_inc_notes): New, broken out from ...\n+        (find_reloads_address_1): ... use here, also correct possible\n+        use of uninitialised reloadnum.\n+\n 2000-12-21  David O'Brien  <obrien@FreeBSD.org>\n \n \t* config/freebsd.h (LIB_SPEC): remove -kthread option.\n@@ -22,7 +28,7 @@\n \t* varasm.c (output_addressed_constants): Use language specific\n \texpander on unknown nodes.\n \n-2000-12-21  Graham Stott <grahams@redhat.com>\n+2000-12-21  Graham Stott  <grahams@redhat.com>\n \n \t* combine.c (distribute_notes): Handle REG_NON_LOCAL_GOTO notes.\n "}, {"sha": "54598343815673b5b4e9be638d6588a2d2ee9b54", "filename": "gcc/reload.c", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98c17df26efeca1425578371232ecc9255f47e10/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98c17df26efeca1425578371232ecc9255f47e10/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=98c17df26efeca1425578371232ecc9255f47e10", "patch": "@@ -263,6 +263,7 @@ static int find_reloads_address\tPARAMS ((enum machine_mode, rtx *, rtx, rtx *,\n \t\t\t\t       int, enum reload_type, int, rtx));\n static rtx subst_reg_equivs\tPARAMS ((rtx, rtx));\n static rtx subst_indexed_address PARAMS ((rtx));\n+static void update_auto_inc_notes PARAMS ((rtx, int, int));\n static int find_reloads_address_1 PARAMS ((enum machine_mode, rtx, int, rtx *,\n \t\t\t\t\t int, enum reload_type,int, rtx));\n static void find_reloads_address_part PARAMS ((rtx, rtx *, enum reg_class,\n@@ -4990,6 +4991,32 @@ subst_indexed_address (addr)\n   return addr;\n }\n \f\n+/* Update the REG_INC notes for an insn.  It updates all REG_INC\n+   notes for the instruction which refer to REGNO the to refer\n+   to the reload number.\n+\n+   INSN is the insn for which any REG_INC notes need updating.\n+\n+   REGNO is the register number which has been reloaded.\n+\n+   RELOADNUM is the reload number.  */\n+\n+static void\n+update_auto_inc_notes (insn, regno, reloadnum)\n+     rtx insn ATTRIBUTE_UNUSED;\n+     int regno ATTRIBUTE_UNUSED;\n+     int reloadnum ATTRIBUTE_UNUSED;\n+{\n+#ifdef AUTO_INC_DEC\n+  rtx link;\n+\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    if (REG_NOTE_KIND (link) == REG_INC\n+        && REGNO (XEXP (link, 0)) == regno)\n+      push_replacement (&XEXP (link, 0), reloadnum, VOIDmode);\n+#endif\n+}\n+\f\n /* Record the pseudo registers we must reload into hard registers in a\n    subexpression of a would-be memory address, X referring to a value\n    in mode MODE.  (This function is not called if the address we find\n@@ -5159,7 +5186,6 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \n \tif (REG_P (XEXP (op1, 0)))\n \t  {\n-\t    rtx link;\n \t    int regno = REGNO (XEXP (op1, 0));\n \t    int reloadnum;\n \n@@ -5194,7 +5220,9 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\t\t     &XEXP (op1, 0), BASE_REG_CLASS,\n \t\t\t\t\t     GET_MODE (x), GET_MODE (x), 0,\n \t\t\t\t\t     0, opnum, RELOAD_OTHER);\n-\t\t    goto reg_inc;\n+\n+\t\t    update_auto_inc_notes (this_insn, regno, reloadnum);\n+\t\t    return 0;\n \t\t  }\n \t      }\n \n@@ -5209,14 +5237,10 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\t\t BASE_REG_CLASS,\n \t\t\t\t\t GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t\t opnum, RELOAD_OTHER);\n-\t      }\n \n-\t    /* Update the REG_INC notes.  */\n-\t  reg_inc:\n-\t    for (link = REG_NOTES (this_insn); link; link = XEXP (link, 1))\n-\t      if (REG_NOTE_KIND (link) == REG_INC\n-\t\t  && REGNO (XEXP (link, 0)) == regno)\n-\t\tpush_replacement (&XEXP (link, 0), reloadnum, VOIDmode);\n+\t\tupdate_auto_inc_notes (this_insn, regno, reloadnum);\n+\t\treturn 0;\n+\t      }\n \t  }\n \telse\n \t  abort ();\n@@ -5277,9 +5301,6 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t       || !(context ? REGNO_OK_FOR_INDEX_P (regno)\n \t\t    : REGNO_MODE_OK_FOR_BASE_P (regno, mode))))\n \t    {\n-#ifdef AUTO_INC_DEC\n-\t      register rtx link;\n-#endif\n \t      int reloadnum;\n \n \t      /* If we can output the register afterwards, do so, this\n@@ -5331,15 +5352,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t  value = 1;\n \t\t}\n \n-#ifdef AUTO_INC_DEC\n-\t      /* Update the REG_INC notes.  */\n-\n-\t      for (link = REG_NOTES (this_insn);\n-\t\t   link; link = XEXP (link, 1))\n-\t\tif (REG_NOTE_KIND (link) == REG_INC\n-\t\t    && REGNO (XEXP (link, 0)) == REGNO (XEXP (x_orig, 0)))\n-\t\t  push_replacement (&XEXP (link, 0), reloadnum, VOIDmode);\n-#endif\n+\t      update_auto_inc_notes (this_insn, REGNO (XEXP (x_orig, 0)),\n+\t\t\t\t     reloadnum);\n \t    }\n \t  return value;\n \t}"}]}