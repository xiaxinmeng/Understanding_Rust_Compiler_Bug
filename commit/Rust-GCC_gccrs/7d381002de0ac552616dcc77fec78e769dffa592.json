{"sha": "7d381002de0ac552616dcc77fec78e769dffa592", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QzODEwMDJkZTBhYzU1MjYxNmRjYzc3ZmVjNzhlNzY5ZGZmYTU5Mg==", "commit": {"author": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2004-09-27T22:24:35Z"}, "committer": {"name": "Matt Austern", "email": "austern@gcc.gnu.org", "date": "2004-09-27T22:24:35Z"}, "message": "Fix implicit extern \"C\" breakage introduced by tokenization patch.\n\n\t* cp/parser.c (struct cp_token): new one-bit field , implicit_extern_c\n\t(cp_lexer_get_preprocessor_token): Set implicit_extern_c for\n\ttokens that come from headers that are implicitly extern \"C\".\n\t(struct cp_parser): new one-bit field, implicit_extern_c.\n\t(cp_parser_new): Set parser's implicit_extern_c to false.\n\t(cp_parser_translation_unit): Pop lang context if we were in a\n\theader that was implicitly extern \"C\".\n\t(cp_parser_declaration_seq_opt): Push/pop lang context as\n\trequired by the token's and parser's implicit_extern_c.\n\nFrom-SVN: r88203", "tree": {"sha": "eaabda6d357ad0b18ff320a27dd73bc59f30f80b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaabda6d357ad0b18ff320a27dd73bc59f30f80b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d381002de0ac552616dcc77fec78e769dffa592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d381002de0ac552616dcc77fec78e769dffa592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d381002de0ac552616dcc77fec78e769dffa592", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d381002de0ac552616dcc77fec78e769dffa592/comments", "author": null, "committer": null, "parents": [{"sha": "49f41d064339dd31bedd24ed1311fc8bd6c720e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49f41d064339dd31bedd24ed1311fc8bd6c720e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49f41d064339dd31bedd24ed1311fc8bd6c720e7"}], "stats": {"total": 97, "additions": 84, "deletions": 13}, "files": [{"sha": "6da00c46ce5811f22866b2d236f55a9e1d24ffe2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d381002de0ac552616dcc77fec78e769dffa592/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d381002de0ac552616dcc77fec78e769dffa592/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7d381002de0ac552616dcc77fec78e769dffa592", "patch": "@@ -1,3 +1,49 @@\n+2004-09-27  Matt Austern  <austern@apple.com>\n+\n+\t* cp/parser.c (struct cp_token): new one-bit field , implicit_extern_c\n+\t(cp_lexer_get_preprocessor_token): Set implicit_extern_c for\n+\ttokens that come from headers that are implicitly extern \"C\".\n+\t(struct cp_parser): new one-bit field, implicit_extern_c.\n+\t(cp_parser_new): Set parser's implicit_extern_c to false.\n+\t(cp_parser_translation_unit): Pop lang context if we were in a\n+\theader that was implicitly extern \"C\".\n+\t(cp_parser_declaration_seq_opt): Push/pop lang context as\n+\trequired by the token's and parser's implicit_extern_c.\n+\t\n+2004-09-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/17585\n+\t* cp-tree.h (shared_member_p): Declare.\n+\t* search.c (shared_member_p): Give it external linkage.\n+\t* semantics.c (finish_qualified_id_expr): Use it.\n+\t(finish_id_expression): Likewise.\n+\n+\tPR c++/17585\n+\t* semantics.c (finish_id_expression): Do not add \"this->\" to\n+\tstatic member functions.\n+\n+2004-09-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/17681\n+\t* error.c (dump_type): Change TREE_VEC case into TREE_BINFO.\n+\n+\t* class.c (struct count_depth_data): Remove.\n+\t(dfs_depth_post, dfs_depth_q): Remove.\n+\t(find_final_overrider): Use number of vbase classes as depth\n+\tbound.\n+\t\n+\t* cp-tree.h (types_overlap_p): Remove.\n+\t* search.c (struct overlap_info): Remove.\n+\t(dfs_check_overlap, dfs_no_overlap_yet, types_overlap_p): Remove.\n+\t\n+\t* pt.c (GTB_VIA_VIRTUAL, GTB_IGNORE_TYPE): Remove.\n+\t(get_template_base_recursive): Remove. Replace with ...\n+\t(get_template_base_r): ... this.\n+\t(struct get_template_base_data_s): New.\n+\t(get_template_base): Use get_template_base_r via dfs_walk.  Always\n+\treturn NULL on failure.\n+\t(unify): Remove error_mark_node check from get_template_base result.\n+\n 2004-09-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/17585"}, {"sha": "184ae5434e4e35190b05c6dbfc57ee4be938602d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d381002de0ac552616dcc77fec78e769dffa592/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d381002de0ac552616dcc77fec78e769dffa592/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7d381002de0ac552616dcc77fec78e769dffa592", "patch": "@@ -55,6 +55,8 @@ typedef struct cp_token GTY (())\n   unsigned char flags;\n   /* True if this token is from a system header. */\n   BOOL_BITFIELD in_system_header : 1;\n+  /* True if this token is from a context where it is implicitly extern \"C\" */\n+  BOOL_BITFIELD implicit_extern_c : 1;\n   /* The value associated with this token, if any.  */\n   tree value;\n   /* The location at which this token was found.  */\n@@ -418,6 +420,7 @@ static void\n cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n                                  cp_token *token)\n {\n+  static int is_extern_c = 0;\n   bool done;\n \n   done = false;\n@@ -445,6 +448,13 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n   token->location = input_location;\n   token->in_system_header = in_system_header;\n \n+  /* On some systems, some header files are surrounded by an \n+     implicit extern \"C\" block.  Set a flag in the token if it\n+     comes from such a header. */\n+  is_extern_c += pending_lang_change;\n+  pending_lang_change = 0;\n+  token->implicit_extern_c = is_extern_c > 0;\n+\n   /* Check to see if this token is a keyword.  */\n   if (token->type == CPP_NAME\n       && C_IS_RESERVED_WORD (token->value))\n@@ -1317,6 +1327,10 @@ typedef struct cp_parser GTY(())\n      alternatives.  */\n   bool in_type_id_in_expr_p;\n \n+  /* TRUE if we are currently in a header file where declarations are\n+     implicitly extern \"C\". */\n+  bool implicit_extern_c;\n+\n   /* TRUE if strings in expressions should be translated to the execution\n      character set.  */\n   bool translate_strings_p;\n@@ -2425,6 +2439,9 @@ cp_parser_new (void)\n   /* We are not parsing a type-id inside an expression.  */\n   parser->in_type_id_in_expr_p = false;\n \n+  /* Declarations aren't implicitly extern \"C\". */\n+  parser->implicit_extern_c = false;\n+\n   /* String literals should be translated to the execution character set.  */\n   parser->translate_strings_p = true;\n \n@@ -2625,6 +2642,14 @@ cp_parser_translation_unit (cp_parser* parser)\n \t  cp_lexer_destroy (parser->lexer);\n \t  parser->lexer = NULL;\n \n+\t  /* This file might have been a context that's implicitly extern\n+\t     \"C\".  If so, pop the lang context.  (Only relevant for PCH.) */\n+\t  if (parser->implicit_extern_c)\n+\t    {\n+\t      pop_lang_context ();\n+\t      parser->implicit_extern_c = false;\n+\t    }\n+\n \t  /* Finish up.  */\n \t  finish_translation_unit ();\n \n@@ -6634,6 +6659,19 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n \t  continue;\n \t}\n \n+      /* If we're entering or exiting a region that's implicitly\n+\t extern \"C\", modify the lang context appropriately. */\n+      if (!parser->implicit_extern_c && token->implicit_extern_c)\n+\t{\n+\t  push_lang_context (lang_name_c);\n+\t  parser->implicit_extern_c = true;\n+\t}\n+      else if (parser->implicit_extern_c && !token->implicit_extern_c)\n+\t{\n+\t  pop_lang_context ();\n+\t  parser->implicit_extern_c = false;\n+\t}\n+\n       if (token->type == CPP_PRAGMA)\n \t{\n \t  /* A top-level declaration can consist solely of a #pragma.\n@@ -6644,19 +6682,6 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n \t  continue;\n \t}\n \n-      /* The C lexer modifies PENDING_LANG_CHANGE when it wants the\n-\t parser to enter or exit implicit `extern \"C\"' blocks.  */\n-      while (pending_lang_change > 0)\n-\t{\n-\t  push_lang_context (lang_name_c);\n-\t  --pending_lang_change;\n-\t}\n-      while (pending_lang_change < 0)\n-\t{\n-\t  pop_lang_context ();\n-\t  ++pending_lang_change;\n-\t}\n-\n       /* Parse the declaration itself.  */\n       cp_parser_declaration (parser);\n     }"}]}