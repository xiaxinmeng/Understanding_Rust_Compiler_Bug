{"sha": "fa76d9e04ebf753eee8e6dffb45430579c31ebf3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE3NmQ5ZTA0ZWJmNzUzZWVlOGU2ZGZmYjQ1NDMwNTc5YzMxZWJmMw==", "commit": {"author": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2000-01-26T23:38:20Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2000-01-26T23:38:20Z"}, "message": "calls.c (special_function_p): New argument fork_or_exec.\n\n\t* calls.c (special_function_p): New argument fork_or_exec.\n\t(expand_call): When profile_arc_flag is set and the function\n\tis in the fork_or_exec group, call __bb_fork_func first.\n\t* libgcc2.c, _bb module (__bb_fork_func): New function.\n\t(__bb_exit_func): If fcntl F_SETLKW is available, use it to lock\n\toutput file.\n\t* config/svr4.h (TARGET_HAS_F_SETLKW): Define.\n\t* tree.h (special_function_p): Update prototype.\n\nFrom-SVN: r31636", "tree": {"sha": "8b4db574b812ef5991986ffdcd38e0b493de8a3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b4db574b812ef5991986ffdcd38e0b493de8a3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa76d9e04ebf753eee8e6dffb45430579c31ebf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa76d9e04ebf753eee8e6dffb45430579c31ebf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa76d9e04ebf753eee8e6dffb45430579c31ebf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa76d9e04ebf753eee8e6dffb45430579c31ebf3/comments", "author": null, "committer": null, "parents": [{"sha": "e09d24ffb12aff104ba1f584c420445aac4c1873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09d24ffb12aff104ba1f584c420445aac4c1873", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09d24ffb12aff104ba1f584c420445aac4c1873"}], "stats": {"total": 36, "additions": 34, "deletions": 2}, "files": [{"sha": "84fdd606604e5842ea91effda3ffee10fef27649", "filename": "gcc/calls.c", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa76d9e04ebf753eee8e6dffb45430579c31ebf3/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa76d9e04ebf753eee8e6dffb45430579c31ebf3/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=fa76d9e04ebf753eee8e6dffb45430579c31ebf3", "patch": "@@ -536,16 +536,18 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n    space from the stack such as alloca.  */\n \n void\n-special_function_p (fndecl, returns_twice, is_longjmp,\n+special_function_p (fndecl, returns_twice, is_longjmp, fork_or_exec,\n \t\t    is_malloc, may_be_alloca)\n      tree fndecl;\n      int *returns_twice;\n      int *is_longjmp;\n+     int *fork_or_exec;\n      int *is_malloc;\n      int *may_be_alloca;\n {\n   *returns_twice = 0;\n   *is_longjmp = 0;\n+  *fork_or_exec = 0;\n   *may_be_alloca = 0;\n \n   /* The function decl may have the `malloc' attribute.  */\n@@ -607,6 +609,21 @@ special_function_p (fndecl, returns_twice, is_longjmp,\n       else if (tname[0] == 'l' && tname[1] == 'o'\n \t       && ! strcmp (tname, \"longjmp\"))\n \t*is_longjmp = 1;\n+\n+      else if ((tname[0] == 'f' && tname[1] == 'o'\n+\t\t&& ! strcmp (tname, \"fork\"))\n+\t       /* Linux specific: __clone.  check NAME to insist on the\n+\t\t  leading underscores, to avoid polluting the ISO / POSIX\n+\t\t  namespace.  */\n+\t       || (name[0] == '_' && name[1] == '_'\n+\t\t   && ! strcmp (tname, \"clone\"))\n+\t       || (tname[0] == 'e' && tname[1] == 'x' && tname[2] == 'e'\n+\t\t   && tname[3] == 'c' && (tname[4] == 'l' || tname[4] == 'v')\n+\t\t   && (tname[5] == '\\0'\n+\t\t       || ((tname[5] == 'p' || tname[5] == 'e')\n+\t\t\t   && tname[6] == '\\0'))))\n+\t*fork_or_exec = 1;\n+\n       /* Do not add any more malloc-like functions to this list,\n          instead mark them as malloc functions using the malloc attribute.\n          Note, realloc is not suitable for attribute malloc since\n@@ -1646,6 +1663,9 @@ expand_call (exp, target, ignore)\n   int returns_twice;\n   /* Nonzero if this is a call to `longjmp'.  */\n   int is_longjmp;\n+  /* Nonzero if this is a syscall that makes a new process in the image of\n+     the current one.  */\n+  int fork_or_exec;\n   /* Nonzero if this is a call to an inline function.  */\n   int is_integrable = 0;\n   /* Nonzero if this is a call to a `const' function.\n@@ -1903,7 +1923,7 @@ expand_call (exp, target, ignore)\n \n   /* See if this is a call to a function that can return more than once\n      or a call to longjmp or malloc.  */\n-  special_function_p (fndecl, &returns_twice, &is_longjmp,\n+  special_function_p (fndecl, &returns_twice, &is_longjmp, &fork_or_exec,\n \t\t      &is_malloc, &may_be_alloca);\n \n   if (may_be_alloca)\n@@ -1928,6 +1948,18 @@ expand_call (exp, target, ignore)\n       || (pending_stack_adjust > 0 && may_be_alloca))\n     do_pending_stack_adjust ();\n \n+  if (profile_arc_flag && fork_or_exec)\n+    {\n+\t/* A fork duplicates the profile information, and an exec discards\n+\t   it.  We can't rely on fork/exec to be paired.  So write out the\n+\t   profile information we have gathered so far, and clear it.  */\n+      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__bb_fork_func\"), 0,\n+\t\t\t VOIDmode, 0);\n+\n+      /* ??? When __clone is called with CLONE_VM set, profiling is\n+         subject to race conditions, just as with multithreaded programs.  */\n+    }\n+\n   /* Push the temporary stack slot level so that we can free any temporaries\n      we make.  */\n   push_temp_slots ();"}]}