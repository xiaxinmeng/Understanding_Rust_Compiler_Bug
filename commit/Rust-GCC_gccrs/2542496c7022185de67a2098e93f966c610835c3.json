{"sha": "2542496c7022185de67a2098e93f966c610835c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU0MjQ5NmM3MDIyMTg1ZGU2N2EyMDk4ZTkzZjk2NmM2MTA4MzVjMw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-03-02T11:58:02Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2010-03-02T11:58:02Z"}, "message": "re PR fortran/43180 (Bad results without temporary copy of intent(in) argument)\n\n2010-03-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43180\n\t* trans-array.c (gfc_conv_array_parameter): A full array of\n\tderived type need not be restricted to a symbol without an\n\tarray spec to use the call to gfc_conv_expr_descriptor.\n\n\tPR fortran/43173\n\t* trans-array.c (gfc_conv_array_parameter): Contiguous refs to\n\tallocatable arrays do not need temporaries.\n\n2010-03-02  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/43180\n\t* gfortran.dg/internal_pack_10.f90: New test.\n\n\tPR fortran/43173\n\t* gfortran.dg/internal_pack_11.f90: New test.\n\nFrom-SVN: r157163", "tree": {"sha": "822cb28ea2dcad6f2050a6923d4526c2f85af09e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/822cb28ea2dcad6f2050a6923d4526c2f85af09e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2542496c7022185de67a2098e93f966c610835c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2542496c7022185de67a2098e93f966c610835c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2542496c7022185de67a2098e93f966c610835c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2542496c7022185de67a2098e93f966c610835c3/comments", "author": null, "committer": null, "parents": [{"sha": "61226dc8a6eb0371d39f437813fbb3279d87f723", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61226dc8a6eb0371d39f437813fbb3279d87f723", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61226dc8a6eb0371d39f437813fbb3279d87f723"}], "stats": {"total": 108, "additions": 92, "deletions": 16}, "files": [{"sha": "12c71921e78dbba70e031d284763a900046d3969", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2542496c7022185de67a2098e93f966c610835c3", "patch": "@@ -1,3 +1,14 @@\n+2010-03-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43180\n+\t* trans-array.c (gfc_conv_array_parameter): A full array of\n+\tderived type need not be restricted to a symbol without an\n+\tarray spec to use the call to gfc_conv_expr_descriptor.\n+\n+\tPR fortran/43173\n+\t* trans-array.c (gfc_conv_array_parameter): Contiguous refs to\n+\tallocatable arrays do not need temporaries.\n+\n 2010-03-01  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/43199"}, {"sha": "c8728899c6d5195f29d042571f5d24b9a307e092", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=2542496c7022185de67a2098e93f966c610835c3", "patch": "@@ -5472,6 +5472,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n   bool this_array_result;\n   bool contiguous;\n   bool no_pack;\n+  bool array_constructor;\n+  bool good_allocatable;\n   gfc_symbol *sym;\n   stmtblock_t block;\n   gfc_ref *ref;\n@@ -5513,7 +5515,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n       if (sym->ts.type == BT_CHARACTER)\n \tse->string_length = sym->ts.u.cl->backend_decl;\n \n-      if (sym->ts.type == BT_DERIVED && !sym->as)\n+      if (sym->ts.type == BT_DERIVED)\n \t{\n \t  gfc_conv_expr_descriptor (se, expr, ss);\n \t  se->expr = gfc_conv_array_data (se->expr);\n@@ -5550,8 +5552,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n         }\n     }\n \n-  /* There is no need to pack and unpack the array, if it is an array\n-     constructor or contiguous and not deferred or assumed shape.  */\n+  /* There is no need to pack and unpack the array, if it is contiguous\n+     and not deferred or assumed shape.  */\n   no_pack = ((sym && sym->as\n \t\t  && !sym->attr.pointer\n \t\t  && sym->as->type != AS_DEFERRED\n@@ -5561,21 +5563,17 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \t\t  && ref->u.ar.as->type != AS_DEFERRED\n \t\t  && ref->u.ar.as->type != AS_ASSUMED_SHAPE));\n \n-  no_pack = g77 && !this_array_result\n-\t\t&& (expr->expr_type == EXPR_ARRAY || (contiguous && no_pack));\n+  no_pack = g77 && !this_array_result && contiguous && no_pack;\n \n-  if (no_pack)\n-    {\n-      gfc_conv_expr_descriptor (se, expr, ss);\n-      if (expr->ts.type == BT_CHARACTER)\n-\tse->string_length = expr->ts.u.cl->backend_decl;\n-      if (size)\n-\tarray_parameter_size (se->expr, expr, size);\n-      se->expr = gfc_conv_array_data (se->expr);\n-      return;\n-    }\n+  /* Array constructors are always contiguous and do not need packing.  */\n+  array_constructor = g77 && !this_array_result && expr->expr_type == EXPR_ARRAY;\n+\n+  /* Same is true of contiguous sections from allocatable variables.  */\n+  good_allocatable = (g77 && !this_array_result && contiguous\n+\t\t\t&& expr->symtree\n+\t\t\t&& expr->symtree->n.sym->attr.allocatable);\n \n-  if (expr->expr_type == EXPR_ARRAY && g77)\n+  if (no_pack || array_constructor || good_allocatable)\n     {\n       gfc_conv_expr_descriptor (se, expr, ss);\n       if (expr->ts.type == BT_CHARACTER)"}, {"sha": "2b0b742a08249aa2c76f410f4b01d3983216d060", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2542496c7022185de67a2098e93f966c610835c3", "patch": "@@ -1,3 +1,11 @@\n+2010-03-02  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/43180\n+\t* gfortran.dg/internal_pack_10.f90: New test.\n+\n+\tPR fortran/43173\n+\t* gfortran.dg/internal_pack_11.f90: New test.\n+\n 2010-03-02  Reza Yazdani  <reza.yazdani@amd.com>\n \n \tPR middle-end/42640"}, {"sha": "8d972f44c181321a3d3328d1e180e1e2c31d1ac3", "filename": "gcc/testsuite/gfortran.dg/internal_pack_10.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_10.f90?ref=2542496c7022185de67a2098e93f966c610835c3", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+! Test the fix for PR43180, in which patch which reduced the use of\n+! internal_pack/unpack messed up the passing of ru(1)%c as the actual\n+! argument at line 23 in this testcase.\n+!\n+! Contributed by Harald Anlauf <anlauf@gmx.de>\n+! further reduced by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module mo_obs_rules\n+  type t_set\n+     integer :: use = 42\n+  end type t_set\n+  type t_rules\n+     character(len=40) :: comment\n+     type(t_set)       :: c (1)\n+  end type t_rules\n+  type (t_rules), save :: ru (1)\n+contains\n+  subroutine get_rule (c)\n+    type(t_set) :: c (:)\n+    ru(1)%c(:)%use = 99\n+    if (any (c(:)%use .ne. 42)) call abort\n+    call set_set_v (ru(1)%c, c)\n+    if (any (c(:)%use .ne. 99)) call abort\n+  contains\n+    subroutine set_set_v (src, dst)\n+      type(t_set), intent(in)    :: src(1)\n+      type(t_set), intent(inout) :: dst(1)\n+    if (any (src%use .ne. 99)) call abort\n+    if (any (dst%use .ne. 42)) call abort\n+      dst = src\n+    end subroutine set_set_v\n+  end subroutine get_rule\n+end module mo_obs_rules\n+\n+program test\n+  use mo_obs_rules\n+  type(t_set) :: c (1)\n+  call get_rule (c)\n+end program test\n+! { dg-final { cleanup-modules \"mo_obs_rules\" } }"}, {"sha": "8f573b4fd95ebc82cdfaa4727d2664e6d6ec6d63", "filename": "gcc/testsuite/gfortran.dg/internal_pack_11.f90", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2542496c7022185de67a2098e93f966c610835c3/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finternal_pack_11.f90?ref=2542496c7022185de67a2098e93f966c610835c3", "patch": "@@ -0,0 +1,18 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! Test the fix for PR43173, where unnecessary calls to internal_pack/unpack\n+! were being produced below. These references are contiguous and so do not\n+! need a temporary.\n+!\n+! Contributed Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+  REAL, allocatable :: ot(:)\n+  integer :: time_steps\n+\n+  call foo (ot) ! OK, no temporary\n+  call foo (ot(0:5:1)) ! Was an unnecessary temporary\n+  call foo (ot(0:time_steps)) ! Was an unnecessary temporary\n+  end\n+! { dg-final { scan-tree-dump-times \"unpack\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}