{"sha": "d000f0d9253425e43228238cebfe3ad57c2c1c10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAwMGYwZDkyNTM0MjVlNDMyMjgyMzhjZWJmZTNhZDU3YzJjMWMxMA==", "commit": {"author": {"name": "Shujing Zhao", "email": "pearly.zhao@oracle.com", "date": "2009-05-27T06:55:00Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2009-05-27T06:55:00Z"}, "message": "m32r.c: Use REG_P, MEM_P and CONST_INT_P where applicable.\n\n        * config/m32r/m32r.c: Use REG_P, MEM_P and CONST_INT_P where\n        applicable.\n        * config/m32r/m32r.h: Ditto.\n        * config/m32r/m32r.md: Ditto.\n        * config/m32r/predicates.md: Ditto.\n\nFrom-SVN: r147899", "tree": {"sha": "18826ff2c38cf60857c01f3bac96bb73bc42d88f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18826ff2c38cf60857c01f3bac96bb73bc42d88f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d000f0d9253425e43228238cebfe3ad57c2c1c10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d000f0d9253425e43228238cebfe3ad57c2c1c10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d000f0d9253425e43228238cebfe3ad57c2c1c10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d000f0d9253425e43228238cebfe3ad57c2c1c10/comments", "author": null, "committer": null, "parents": [{"sha": "0c5bf15a355b19e3911c66c0ec03cfb625e6d15a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5bf15a355b19e3911c66c0ec03cfb625e6d15a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5bf15a355b19e3911c66c0ec03cfb625e6d15a"}], "stats": {"total": 171, "additions": 89, "deletions": 82}, "files": [{"sha": "dc0cd37f40259e0104319a2142f9254883375ed1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d000f0d9253425e43228238cebfe3ad57c2c1c10", "patch": "@@ -1,8 +1,15 @@\n+2009-05-27  Shujing Zhao  <pearly.zhao@oracle.com>\n+\n+\t* config/m32r/m32r.c: Use REG_P, MEM_P and CONST_INT_P where\n+\tapplicable.\n+\t* config/m32r/m32r.h: Ditto.\n+\t* config/m32r/m32r.md: Ditto.\n+\t* config/m32r/predicates.md: Ditto.\n+\n 2009-05-27  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* cgraph.c (dump_cgraph_node): Honor -fdump-noaddr.\n \n-\n 2009-05-26  Basile Starynkevitch  <basile@starynkevitch.net>\n \n \t* doc/plugins.texi"}, {"sha": "87f62933d8c1ef99463ef9d9a2715c7faccaa206", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=d000f0d9253425e43228238cebfe3ad57c2c1c10", "patch": "@@ -488,7 +488,7 @@ m32r_init_expanders (void)\n int\n call_operand (rtx op, enum machine_mode mode)\n {\n-  if (GET_CODE (op) != MEM)\n+  if (!MEM_P (op))\n     return 0;\n   op = XEXP (op, 0);\n   return call_address_operand (op, mode);\n@@ -563,7 +563,7 @@ addr32_operand (rtx op, enum machine_mode mode)\n   else if (GET_CODE (op) == CONST\n \t   && GET_CODE (XEXP (op, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n-\t   && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT\n+\t   && CONST_INT_P (XEXP (XEXP (op, 0), 1))\n \t   && ! flag_pic)\n     sym = XEXP (XEXP (op, 0), 0);\n   else\n@@ -632,7 +632,7 @@ easy_df_const (rtx op)\n int\n memreg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  return GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG;\n+  return REG_P (op) && MEM_P (XEXP (op, 0));\n }\n \n /* Return nonzero if TYPE must be passed by indirect reference.  */\n@@ -734,7 +734,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t\t  code = EQ;\n \t\t  break;\n \t\tcase GT:\n-\t\t  if (GET_CODE (y) == CONST_INT)\n+\t\t  if (CONST_INT_P (y))\n \t\t    tmp = gen_rtx_PLUS (SImode, y, const1_rtx);\n \t\t  else\n \t\t    emit_insn (gen_addsi3 (tmp, y, constm1_rtx));\n@@ -774,7 +774,7 @@ gen_compare (enum rtx_code code, rtx x, rtx y, int need_compare)\n \t\t  code = EQ;\n \t\t  break;\n \t\tcase GTU:\n-\t\t  if (GET_CODE (y) == CONST_INT)\n+\t\t  if (CONST_INT_P (y))\n \t\t    tmp = gen_rtx_PLUS (SImode, y, const1_rtx);\n \t\t  else\n \t\t    emit_insn (gen_addsi3 (tmp, y, constm1_rtx));\n@@ -881,7 +881,7 @@ gen_cond_store (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n \t  emit_insn (gen_seq_insn_m32rx (op0, op1, op2));\n \t  return true;\n \t}\n-      if (GET_CODE (op2) == CONST_INT && INTVAL (op2) == 0)\n+      if (CONST_INT_P (op2) && INTVAL (op2) == 0)\n \t{\n \t  emit_insn (gen_seq_zero_insn (op0, op1));\n \t  return true;\n@@ -894,7 +894,7 @@ gen_cond_store (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n       return true;\n \n     case NE:\n-      if (GET_CODE (op2) != CONST_INT\n+      if (!CONST_INT_P (op2)\n \t  || (INTVAL (op2) != 0 && satisfies_constraint_K (op2)))\n \t{\n \t  rtx reg;\n@@ -971,7 +971,7 @@ gen_cond_store (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n       if (!register_operand (op1, mode))\n \top1 = force_reg (mode, op1);\n \n-      if (GET_CODE (op2) == CONST_INT)\n+      if (CONST_INT_P (op2))\n \t{\n \t  HOST_WIDE_INT value = INTVAL (op2);\n \t  if (value >= 2147483647)\n@@ -1025,12 +1025,12 @@ gen_split_move_double (rtx operands[])\n     alter_subreg (&src);\n \n   start_sequence ();\n-  if (GET_CODE (dest) == REG)\n+  if (REG_P (dest))\n     {\n       int dregno = REGNO (dest);\n \n       /* Reg = reg.  */\n-      if (GET_CODE (src) == REG)\n+      if (REG_P (src))\n \t{\n \t  int sregno = REGNO (src);\n \n@@ -1049,7 +1049,7 @@ gen_split_move_double (rtx operands[])\n \t}\n \n       /* Reg = constant.  */\n-      else if (GET_CODE (src) == CONST_INT || GET_CODE (src) == CONST_DOUBLE)\n+      else if (CONST_INT_P (src) || GET_CODE (src) == CONST_DOUBLE)\n \t{\n \t  rtx words[2];\n \t  split_double (src, &words[0], &words[1]);\n@@ -1063,7 +1063,7 @@ gen_split_move_double (rtx operands[])\n \t}\n \n       /* Reg = mem.  */\n-      else if (GET_CODE (src) == MEM)\n+      else if (MEM_P (src))\n \t{\n \t  /* If the high-address word is used in the address, we must load it\n \t     last.  Otherwise, load it first.  */\n@@ -1107,7 +1107,7 @@ gen_split_move_double (rtx operands[])\n \tst r1,r3; st r2,+r3; addi r3,-4\n \n      which saves 2 bytes and doesn't force longword alignment.  */\n-  else if (GET_CODE (dest) == MEM && GET_CODE (src) == REG)\n+  else if (REG_P (dest) && MEM_P (src))\n     {\n       emit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t      adjust_address (dest, SImode, 0),\n@@ -1654,9 +1654,9 @@ m32r_expand_epilogue (void)\n \n       /* If the last insn was a BARRIER, we don't have to write any code\n \t because a jump (aka return) was put there.  */\n-      if (insn && GET_CODE (insn) == NOTE)\n+      if (insn && NOTE_P (insn))\n \tinsn = prev_nonnote_insn (insn);\n-      if (insn && GET_CODE (insn) == BARRIER)\n+      if (insn && BARRIER_P (insn))\n \tnoepilogue = TRUE;\n     }\n \n@@ -1778,7 +1778,7 @@ m32r_legitimate_pic_operand_p (rtx x)\n       && GET_CODE (XEXP (x, 0)) == PLUS\n       && (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n           || GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF)\n-      && (GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT))\n+      && (CONST_INT_P (XEXP (XEXP (x, 0), 1))))\n     return 0;\n \n   return 1;\n@@ -1857,7 +1857,7 @@ m32r_legitimize_pic_address (rtx orig, rtx reg)\n       else\n         return orig;\n \n-      if (GET_CODE (offset) == CONST_INT)\n+      if (CONST_INT_P (offset))\n         {\n           if (INT16_P (INTVAL (offset)))\n             return plus_constant (base, INTVAL (offset));\n@@ -1925,14 +1925,14 @@ m32r_print_operand (FILE * file, rtx x, int code)\n       /* The 's' and 'p' codes are used by output_block_move() to\n \t indicate post-increment 's'tores and 'p're-increment loads.  */\n     case 's':\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfprintf (file, \"@+%s\", reg_names [REGNO (x)]);\n       else\n \toutput_operand_lossage (\"invalid operand to %%s code\");\n       return;\n \n     case 'p':\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfprintf (file, \"@%s+\", reg_names [REGNO (x)]);\n       else\n \toutput_operand_lossage (\"invalid operand to %%p code\");\n@@ -1941,9 +1941,9 @@ m32r_print_operand (FILE * file, rtx x, int code)\n     case 'R' :\n       /* Write second word of DImode or DFmode reference,\n \t register or memory.  */\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \tfputs (reg_names[REGNO (x)+1], file);\n-      else if (GET_CODE (x) == MEM)\n+      else if (MEM_P (x))\n \t{\n \t  fprintf (file, \"@(\");\n \t  /* Handle possible auto-increment.  Since it is pre-increment and\n@@ -1963,15 +1963,15 @@ m32r_print_operand (FILE * file, rtx x, int code)\n \n     case 'H' : /* High word.  */\n     case 'L' : /* Low word.  */\n-      if (GET_CODE (x) == REG)\n+      if (REG_P (x))\n \t{\n \t  /* L = least significant word, H = most significant word.  */\n \t  if ((WORDS_BIG_ENDIAN != 0) ^ (code == 'L'))\n \t    fputs (reg_names[REGNO (x)], file);\n \t  else\n \t    fputs (reg_names[REGNO (x)+1], file);\n \t}\n-      else if (GET_CODE (x) == CONST_INT\n+      else if (CONST_INT_P (x)\n \t       || GET_CODE (x) == CONST_DOUBLE)\n \t{\n \t  rtx first, second;\n@@ -2045,7 +2045,7 @@ m32r_print_operand (FILE * file, rtx x, int code)\n     case 'U' :\n       /* ??? wip */\n       /* Output a load/store with update indicator if appropriate.  */\n-      if (GET_CODE (x) == MEM)\n+      if (MEM_P (x))\n \t{\n \t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n \t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n@@ -2057,15 +2057,15 @@ m32r_print_operand (FILE * file, rtx x, int code)\n \n     case 'N' :\n       /* Print a constant value negated.  */\n-      if (GET_CODE (x) == CONST_INT)\n+      if (CONST_INT_P (x))\n \toutput_addr_const (file, GEN_INT (- INTVAL (x)));\n       else\n \toutput_operand_lossage (\"invalid operand to %%N code\");\n       return;\n \n     case 'X' :\n       /* Print a const_int in hex.  Used in comments.  */\n-      if (GET_CODE (x) == CONST_INT)\n+      if (CONST_INT_P (x))\n \tfprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (x));\n       return;\n \n@@ -2092,21 +2092,21 @@ m32r_print_operand (FILE * file, rtx x, int code)\n       addr = XEXP (x, 0);\n       if (GET_CODE (addr) == PRE_INC)\n \t{\n-\t  if (GET_CODE (XEXP (addr, 0)) != REG)\n+\t  if (!REG_P (XEXP (addr, 0)))\n \t    fatal_insn (\"pre-increment address is not a register\", x);\n \n \t  fprintf (file, \"@+%s\", reg_names[REGNO (XEXP (addr, 0))]);\n \t}\n       else if (GET_CODE (addr) == PRE_DEC)\n \t{\n-\t  if (GET_CODE (XEXP (addr, 0)) != REG)\n+\t  if (!REG_P (XEXP (addr, 0)))\n \t    fatal_insn (\"pre-decrement address is not a register\", x);\n \n \t  fprintf (file, \"@-%s\", reg_names[REGNO (XEXP (addr, 0))]);\n \t}\n       else if (GET_CODE (addr) == POST_INC)\n \t{\n-\t  if (GET_CODE (XEXP (addr, 0)) != REG)\n+\t  if (!REG_P (XEXP (addr, 0)))\n \t    fatal_insn (\"post-increment address is not a register\", x);\n \n \t  fprintf (file, \"@%s+\", reg_names[REGNO (XEXP (addr, 0))]);\n@@ -2156,13 +2156,13 @@ m32r_print_operand_address (FILE * file, rtx addr)\n       break;\n \n     case PLUS :\n-      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\n+      if (CONST_INT_P (XEXP (addr, 0)))\n \toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\n-      else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+      else if (CONST_INT_P (XEXP (addr, 1)))\n \toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\n       else\n \tbase = XEXP (addr, 0), index = XEXP (addr, 1);\n-      if (GET_CODE (base) == REG)\n+      if (REG_P (base))\n \t{\n \t  /* Print the offset first (if present) to conform to the manual.  */\n \t  if (index == 0)\n@@ -2172,7 +2172,7 @@ m32r_print_operand_address (FILE * file, rtx addr)\n \t      fputs (reg_names[REGNO (base)], file);\n \t    }\n \t  /* The chip doesn't support this, but left in for generality.  */\n-\t  else if (GET_CODE (index) == REG)\n+\t  else if (REG_P (index))\n \t    fprintf (file, \"%s,%s\",\n \t\t     reg_names[REGNO (base)], reg_names[REGNO (index)]);\n \t  /* Not sure this can happen, but leave in for now.  */\n@@ -2187,7 +2187,7 @@ m32r_print_operand_address (FILE * file, rtx addr)\n \t}\n       else if (GET_CODE (base) == LO_SUM)\n \t{\n-\t  gcc_assert (!index && GET_CODE (XEXP (base, 0)) == REG);\n+\t  gcc_assert (!index && REG_P (XEXP (base, 0)));\n \t  if (small_data_operand (XEXP (base, 1), VOIDmode))\n \t    fputs (\"sda(\", file);\n \t  else\n@@ -2201,7 +2201,7 @@ m32r_print_operand_address (FILE * file, rtx addr)\n       break;\n \n     case LO_SUM :\n-      if (GET_CODE (XEXP (addr, 0)) != REG)\n+      if (!REG_P (XEXP (addr, 0)))\n \tfatal_insn (\"lo_sum not of register\", addr);\n       if (small_data_operand (XEXP (addr, 1), VOIDmode))\n \tfputs (\"sda(\", file);\n@@ -2236,8 +2236,8 @@ int\n zero_and_one (rtx operand1, rtx operand2)\n {\n   return\n-       GET_CODE (operand1) == CONST_INT\n-    && GET_CODE (operand2) == CONST_INT\n+       CONST_INT_P (operand1)\n+    && CONST_INT_P (operand2)\n     && (  ((INTVAL (operand1) == 0) && (INTVAL (operand2) == 1))\n \t||((INTVAL (operand1) == 1) && (INTVAL (operand2) == 0)));\n }\n@@ -2257,7 +2257,7 @@ emit_cond_move (rtx * operands, rtx insn ATTRIBUTE_UNUSED)\n   buffer [0] = 0;\n \n   /* Destination must be a register.  */\n-  gcc_assert (GET_CODE (operands [0]) == REG);\n+  gcc_assert (REG_P (operands [0]));\n   gcc_assert (conditional_move_operand (operands [2], SImode));\n   gcc_assert (conditional_move_operand (operands [3], SImode));\n \n@@ -2291,13 +2291,13 @@ m32r_not_same_reg (rtx a, rtx b)\n   while (GET_CODE (a) == SUBREG)\n     a = SUBREG_REG (a);\n \n-  if (GET_CODE (a) == REG)\n+  if (REG_P (a))\n     reg_a = REGNO (a);\n \n   while (GET_CODE (b) == SUBREG)\n     b = SUBREG_REG (b);\n \n-  if (GET_CODE (b) == REG)\n+  if (REG_P (b))\n     reg_b = REGNO (b);\n \n   return reg_a != reg_b;\n@@ -2361,7 +2361,7 @@ m32r_expand_block_move (rtx operands[])\n   rtx           orig_src  = operands[1];\n   rtx           bytes_rtx = operands[2];\n   rtx           align_rtx = operands[3];\n-  int           constp    = GET_CODE (bytes_rtx) == CONST_INT;\n+  int           constp    = CONST_INT_P (bytes_rtx);\n   HOST_WIDE_INT bytes     = constp ? INTVAL (bytes_rtx) : 0;\n   int           align     = INTVAL (align_rtx);\n   int           leftover;"}, {"sha": "61c322048d9880386f55a2a19bb6f1dcd8e0e455", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=d000f0d9253425e43228238cebfe3ad57c2c1c10", "patch": "@@ -1059,7 +1059,7 @@ L2:     .word STATIC\n #define CONSTANT_ADDRESS_P(X)   \\\n   (    GET_CODE (X) == LABEL_REF  \\\n    ||  GET_CODE (X) == SYMBOL_REF \\\n-   ||  GET_CODE (X) == CONST_INT  \\\n+   ||  CONST_INT_P (X)  \\\n    || (GET_CODE (X) == CONST      \\\n        && ! (flag_pic && ! m32r_legitimate_pic_operand_p (X))))\n \n@@ -1073,7 +1073,7 @@ L2:     .word STATIC\n   (! (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n       && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n       && (GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF || GET_CODE (XEXP (XEXP (X, 0), 0)) == LABEL_REF) \\\n-      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n+      && CONST_INT_P (XEXP (XEXP (X, 0), 1))\t\t\t\\\n       && (unsigned HOST_WIDE_INT) INTVAL (XEXP (XEXP (X, 0), 1)) > 32767))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n@@ -1120,7 +1120,7 @@ L2:     .word STATIC\n \n /* Local to this file.  */\n #define RTX_OK_FOR_OFFSET_P(X) \\\n-  (GET_CODE (X) == CONST_INT && INT16_P (INTVAL (X)))\n+  (CONST_INT_P (X) && INT16_P (INTVAL (X)))\n \n /* Local to this file.  */\n #define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X)\t\t\t\\\n@@ -1142,15 +1142,15 @@ L2:     .word STATIC\n #define LOAD_POSTINC_P(MODE, X)\t\t\t\t\t\\\n   (((MODE) == SImode || (MODE) == SFmode)\t\t\t\\\n    && GET_CODE (X) == POST_INC\t\t\t\t\t\\\n-   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+   && REG_P (XEXP (X, 0))\t\t\t\t\\\n    && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n \n /* Local to this file.  */\n /* Is this an increment/decrement and store operation.  */\n #define STORE_PREINC_PREDEC_P(MODE, X)\t\t\t\t\\\n   (((MODE) == SImode || (MODE) == SFmode)\t\t\t\\\n    && (GET_CODE (X) == PRE_INC || GET_CODE (X) == PRE_DEC)\t\\\n-   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+   && REG_P (XEXP (X, 0))\t\t\t\t\\\n    && RTX_OK_FOR_BASE_P (XEXP (X, 0)))\n \n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\"}, {"sha": "ec0d61f294c7e85b165bd3812dae2c15ebe8fe1a", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=d000f0d9253425e43228238cebfe3ad57c2c1c10", "patch": "@@ -250,7 +250,7 @@\n   /* Everything except mem = const or mem = mem can be done easily.\n      Objects in the small data area are handled too.  */\n \n-  if (GET_CODE (operands[0]) == MEM)\n+  if (MEM_P (operands[0]))\n     operands[1] = force_reg (QImode, operands[1]);\n }\")\n \n@@ -289,7 +289,7 @@\n \n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n-  if (GET_CODE (operands[0]) == MEM)\n+  if (MEM_P (operands[0]))\n     operands[1] = force_reg (HImode, operands[1]);\n }\")\n \n@@ -341,7 +341,7 @@\n \n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n-  if (GET_CODE (operands[0]) == MEM)\n+  if (MEM_P (operands[0]))\n     operands[1] = force_reg (SImode, operands[1]);\n \n   /* Small Data Area reference?  */\n@@ -367,7 +367,7 @@\n   \"register_operand (operands[0], SImode) || register_operand (operands[1], SImode)\"\n   \"*\n {\n-  if (GET_CODE (operands[0]) == REG || GET_CODE (operands[1]) == SUBREG)\n+  if (REG_P (operands[0]) || GET_CODE (operands[1]) == SUBREG)\n     {\n       switch (GET_CODE (operands[1]))\n \t{\n@@ -409,8 +409,8 @@\n \t}\n     }\n \n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && (GET_CODE (operands[1]) == REG || GET_CODE (operands[1]) == SUBREG))\n+  else if (MEM_P (operands[0])\n+\t   && (REG_P (operands[1]) || GET_CODE (operands[1]) == SUBREG))\n     {\n       if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n \t  && XEXP (XEXP (operands[0], 0), 0) == stack_pointer_rtx)\n@@ -585,7 +585,7 @@\n \n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n-  if (GET_CODE (operands[0]) == MEM)\n+  if (MEM_P (operands[0]))\n     operands[1] = force_reg (DImode, operands[1]);\n }\")\n \n@@ -626,7 +626,7 @@\n \n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n-  if (GET_CODE (operands[0]) == MEM)\n+  if (MEM_P (operands[0]))\n     operands[1] = force_reg (SFmode, operands[1]);\n }\")\n \n@@ -678,7 +678,7 @@\n \n   /* Everything except mem = const or mem = mem can be done easily.  */\n \n-  if (GET_CODE (operands[0]) == MEM)\n+  if (MEM_P (operands[0]))\n     operands[1] = force_reg (DFmode, operands[1]);\n }\")\n \n@@ -1036,7 +1036,7 @@\n       && satisfies_constraint_I (operands[2]))\n     return \\\"#\\\";\n \n-  else if (GET_CODE (operands[2]) == CONST_INT)\n+  else if (CONST_INT_P (operands[2]))\n     return \\\"and3 %0,%1,%#%X2\\\";\n \n   return \\\"and %0,%2\\\";\n@@ -1067,7 +1067,7 @@\n       && satisfies_constraint_I (operands[2]))\n     return \\\"#\\\";\n \n-  else if (GET_CODE (operands[2]) == CONST_INT)\n+  else if (CONST_INT_P (operands[2]))\n     return \\\"or3 %0,%1,%#%X2\\\";\n \n   return \\\"or %0,%2\\\";\n@@ -1098,7 +1098,7 @@\n       && satisfies_constraint_I (operands[2]))\n     return \\\"#\\\";\n \n-  else if (GET_CODE (operands[2]) == CONST_INT)\n+  else if (CONST_INT_P (operands[2]))\n     return \\\"xor3 %0,%1,%#%X2\\\";\n \n   return \\\"xor %0,%2\\\";\n@@ -1588,15 +1588,15 @@\n   rtx op3 = operands[3];\n   HOST_WIDE_INT value;\n \n-  if (GET_CODE (op2) == REG && GET_CODE (op3) == REG\n+  if (REG_P (op2) && REG_P (op3)\n       && REGNO (op2) == REGNO (op3))\n     {\n       op1 = operands[2];\n       op2 = operands[1];\n     }\n \n   start_sequence ();\n-  if (GET_CODE (op1) == REG && GET_CODE (op3) == REG\n+  if (REG_P (op1) && REG_P (op3)\n       && REGNO (op1) != REGNO (op3))\n     {\n       emit_move_insn (op3, op1);"}, {"sha": "4b3c5fea1e1aa40ba1aacf2426edbf0fff87641f", "filename": "gcc/config/m32r/predicates.md", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2Fconfig%2Fm32r%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d000f0d9253425e43228238cebfe3ad57c2c1c10/gcc%2Fconfig%2Fm32r%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fpredicates.md?ref=d000f0d9253425e43228238cebfe3ad57c2c1c10", "patch": "@@ -22,10 +22,10 @@\n (define_predicate \"reg_or_zero_operand\"\n   (match_code \"reg,subreg,const_int\")\n {\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+  if (REG_P (op) || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n \n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n \n   return INTVAL (op) == 0;\n@@ -75,11 +75,11 @@\n     return FALSE;\n \n   x = XEXP (op, 0);\n-  if (GET_CODE (x) != REG || REGNO (x) != CARRY_REGNUM)\n+  if (!REG_P (x) || REGNO (x) != CARRY_REGNUM)\n     return FALSE;\n \n   x = XEXP (op, 1);\n-  if (GET_CODE (x) != CONST_INT || INTVAL (x) != 0)\n+  if (!CONST_INT_P (x) || INTVAL (x) != 0)\n     return FALSE;\n \n   return TRUE;\n@@ -119,7 +119,7 @@\n     case SUBREG :\n       /* (subreg (mem ...) ...) can occur here if the inner part was once a\n \t pseudo-reg and is now a stack slot.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+      if (MEM_P (SUBREG_REG (op)))\n \treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n       else\n \treturn register_operand (op, mode);\n@@ -175,7 +175,7 @@\n     case SUBREG :\n       /* (subreg (mem ...) ...) can occur here if the inner part was once a\n \t pseudo-reg and is now a stack slot.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+      if (MEM_P (SUBREG_REG (op)))\n \treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n       else\n \treturn register_operand (op, mode);\n@@ -205,7 +205,7 @@\n     case SUBREG :\n       /* (subreg (mem ...) ...) can occur here if the inner part was once a\n \t pseudo-reg and is now a stack slot.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM)\n+      if (MEM_P (SUBREG_REG (op)))\n \treturn move_double_src_operand (SUBREG_REG (op), mode);\n       else\n \treturn register_operand (op, mode);\n@@ -226,7 +226,7 @@\n (define_predicate \"two_insn_const_operand\"\n   (match_code \"const_int\")\n {\n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n   if (satisfies_constraint_J (op)\n       || satisfies_constraint_M (op)\n@@ -257,7 +257,7 @@\n (define_predicate \"int8_operand\"\n   (match_code \"const_int\")\n {\n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n   return satisfies_constraint_I (op);\n })\n@@ -267,7 +267,7 @@\n (define_predicate \"uint16_operand\"\n   (match_code \"const_int\")\n {\n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n   return satisfies_constraint_K (op);\n })\n@@ -277,9 +277,9 @@\n (define_predicate \"reg_or_int16_operand\"\n   (match_code \"reg,subreg,const_int\")\n {\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+  if (REG_P (op) || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n   return satisfies_constraint_J (op);\n })\n@@ -289,9 +289,9 @@\n (define_predicate \"reg_or_uint16_operand\"\n   (match_code \"reg,subreg,const_int\")\n {\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+  if (REG_P (op) || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n   return satisfies_constraint_K (op);\n })\n@@ -302,9 +302,9 @@\n (define_predicate \"reg_or_cmp_int16_operand\"\n   (match_code \"reg,subreg,const_int\")\n {\n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+  if (REG_P (op) || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n   return satisfies_constraint_P (op);\n })\n@@ -319,10 +319,10 @@\n {\n   HOST_WIDE_INT value;\n \n-  if (GET_CODE (op) == REG || GET_CODE (op) == SUBREG)\n+  if (REG_P (op) || GET_CODE (op) == SUBREG)\n     return register_operand (op, mode);\n \n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n \n   value = INTVAL (op);\n@@ -335,7 +335,7 @@\n (define_predicate \"cmp_int16_operand\"\n   (match_code \"const_int\")\n {\n-  if (GET_CODE (op) != CONST_INT)\n+  if (!CONST_INT_P (op))\n     return 0;\n   return satisfies_constraint_P (op);\n })\n@@ -384,7 +384,7 @@\n (define_predicate \"small_insn_p\"\n   (match_code \"insn,call_insn,jump_insn\")\n {\n-  if (GET_CODE (op) == CONST_INT && INTVAL (op) == 0)\n+  if (CONST_INT_P (op) && INTVAL (op) == 0)\n     return 1;\n \n   if (! INSN_P (op))\n@@ -399,7 +399,7 @@\n (define_predicate \"m32r_block_immediate_operand\"\n   (match_code \"const_int\")\n {\n-  if (GET_CODE (op) != CONST_INT\n+  if (!CONST_INT_P (op)\n       || INTVAL (op) > MAX_MOVE_BYTES\n       || INTVAL (op) <= 0)\n     return 0;"}]}