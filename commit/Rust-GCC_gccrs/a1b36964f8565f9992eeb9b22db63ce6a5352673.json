{"sha": "a1b36964f8565f9992eeb9b22db63ce6a5352673", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFiMzY5NjRmODU2NWY5OTkyZWViOWIyMmRiNjNjZTZhNTM1MjY3Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-09T20:29:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-07-09T20:29:36Z"}, "message": "pa.c (compute_movstrsi_length): Return length in bytes.\n\n        * pa.c (compute_movstrsi_length): Return length in bytes.\n        (pa_adjust_insn_length): Return adjustment in bytes.\n        (output_cbranch): Handle lengths as bytes.\n        (output_bb, output_dbra, output_movb): Likewise.\n\nFrom-SVN: r4890", "tree": {"sha": "d9b99741516b2b0a213d199997aed027f51cf463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9b99741516b2b0a213d199997aed027f51cf463"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1b36964f8565f9992eeb9b22db63ce6a5352673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1b36964f8565f9992eeb9b22db63ce6a5352673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1b36964f8565f9992eeb9b22db63ce6a5352673", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1b36964f8565f9992eeb9b22db63ce6a5352673/comments", "author": null, "committer": null, "parents": [{"sha": "2af5b845e6d7d20577d3207665e86399cd5fc647", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2af5b845e6d7d20577d3207665e86399cd5fc647", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2af5b845e6d7d20577d3207665e86399cd5fc647"}], "stats": {"total": 76, "additions": 38, "deletions": 38}, "files": [{"sha": "2841ead1cc1a5b93e82c317b28407d8c50f6b8ec", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1b36964f8565f9992eeb9b22db63ce6a5352673/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1b36964f8565f9992eeb9b22db63ce6a5352673/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a1b36964f8565f9992eeb9b22db63ce6a5352673", "patch": "@@ -1524,7 +1524,7 @@ compute_movstrsi_length (insn)\n \n \t  /* Count last store or partial store.  */\n \t  insn_count += 1;\n-\t  return insn_count;\n+\t  return insn_count * 4;\n \t}\n \n       if (align >= 2 && n_bytes >= 2)\n@@ -1543,7 +1543,7 @@ compute_movstrsi_length (insn)\n \t  /* ??? final store from loop.  */\n \t  insn_count += 1;\n \n-\t  return insn_count;\n+\t  return insn_count * 4;\n \t}\n \n       /* First load.  */\n@@ -1556,7 +1556,7 @@ compute_movstrsi_length (insn)\n       /* Final store.  */\n       insn_count += 1;\n \n-      return insn_count;\n+      return insn_count * 4;\n     }\n \n   if (align != 4)\n@@ -1580,7 +1580,7 @@ compute_movstrsi_length (insn)\n     }\n   else\n     insn_count += 4;\n-  return insn_count;\n+  return insn_count * 4;\n }\n \f\n \n@@ -2511,11 +2511,11 @@ pa_adjust_insn_length (insn, length)\n \n       if (GET_CODE (XVECEXP (pat, 0, 0)) == CALL\n \t  && GET_CODE (XEXP (XEXP (XVECEXP (pat, 0, 0), 0), 0)) == SYMBOL_REF)\n-\treturn 1;\n+\treturn 4;\n       else if (GET_CODE (XVECEXP (pat, 0, 0)) == SET\n \t       && GET_CODE (XEXP (XEXP (XEXP (XVECEXP (pat, 0, 0), 1), 0), 0))\n \t\t  == SYMBOL_REF)\n-\treturn 1;\n+\treturn 4;\n       else\n \treturn 0;\n     }\n@@ -2525,33 +2525,33 @@ pa_adjust_insn_length (insn, length)\n \t   && GET_CODE (pat) != USE\n \t   && GET_CODE (pat) != CLOBBER\n \t   && get_attr_type (insn) == TYPE_MILLI)\n-    return 1;\n+    return 4;\n   /* Block move pattern.  */\n   else if (GET_CODE (insn) == INSN\n \t   && GET_CODE (pat) == PARALLEL\n \t   && GET_CODE (XEXP (XVECEXP (pat, 0, 0), 0)) == MEM\n \t   && GET_CODE (XEXP (XVECEXP (pat, 0, 0), 1)) == MEM\n \t   && GET_MODE (XEXP (XVECEXP (pat, 0, 0), 0)) == BLKmode\n \t   && GET_MODE (XEXP (XVECEXP (pat, 0, 0), 1)) == BLKmode)\n-    return compute_movstrsi_length (insn) - 1;\n+    return compute_movstrsi_length (insn) - 4;\n   /* Conditional branch with an unfilled delay slot.  */\n   else if (GET_CODE (insn) == JUMP_INSN && ! simplejump_p (insn))\n     {\n       /* Adjust a short backwards conditional with an unfilled delay slot.  */\n       if (GET_CODE (pat) == SET\n-\t  && length == 1\n+\t  && length == 4\n \t  && ! forward_branch_p (insn))\n-\treturn 1;\n+\treturn 4;\n       /* Adjust dbra insn with short backwards conditional branch with\n \t unfilled delay slot -- only for case where counter is in a \n \t general register register. */\n       else if (GET_CODE (pat) == PARALLEL\n \t       && GET_CODE (XVECEXP (pat, 0, 1)) == SET\n \t       && GET_CODE (XEXP (XVECEXP (pat, 0, 1), 0)) == REG\n  \t       && ! FP_REG_P (XEXP (XVECEXP (pat, 0, 1), 0)) \n-\t       && length == 1\n+\t       && length == 4\n \t       && ! forward_branch_p (insn))\n-\treturn 1;\n+\treturn 4;\n       else\n \treturn 0;\n     }\n@@ -3266,20 +3266,20 @@ output_cbranch (operands, nullify, length, negated, insn)\n   \n   /* If this is a long branch with its delay slot unfilled, set `nullify'\n      as it can nullify the delay slot and save a nop.  */\n-  if (length == 2 && dbr_sequence_length () == 0)\n+  if (length == 8 && dbr_sequence_length () == 0)\n     nullify = 1;\n \n   /* If this is a short forward conditional branch which did not get\n      its delay slot filled, the delay slot can still be nullified.  */\n-  if (! nullify && length == 1 && dbr_sequence_length () == 0)\n+  if (! nullify && length == 4 && dbr_sequence_length () == 0)\n     nullify = forward_branch_p (insn);\n \n   /* A forward branch over a single nullified insn can be done with a \n      comclr instruction.  This avoids a single cycle penalty due to\n      mis-predicted branch if we fall through (branch not taken).  */\n-  if (length == 1\n+  if (length == 4\n       && next_real_insn (insn) != 0\n-      && get_attr_length (next_real_insn (insn)) == 1\n+      && get_attr_length (next_real_insn (insn)) == 4\n       && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))\n       && nullify)\n     useskip = 1;\n@@ -3288,7 +3288,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n     {\n       /* All short conditional branches except backwards with an unfilled\n \t delay slot.  */\n-      case 1:\n+      case 4:\n \tif (useskip)\n \t  strcpy (buf, \"com%I2clr,\");\n \telse\n@@ -3308,7 +3308,7 @@ output_cbranch (operands, nullify, length, negated, insn)\n      /* All long conditionals.  Note an short backward branch with an \n \tunfilled delay slot is treated just like a long backward branch\n \twith an unfilled delay slot.  */\n-      case 2:\n+      case 8:\n \t/* Handle weird backwards branch with a filled delay slot\n \t   with is nullified.  */\n \tif (dbr_sequence_length () != 0\n@@ -3367,21 +3367,21 @@ output_bb (operands, nullify, length, negated, insn, which)\n   \n   /* If this is a long branch with its delay slot unfilled, set `nullify'\n      as it can nullify the delay slot and save a nop.  */\n-  if (length == 2 && dbr_sequence_length () == 0)\n+  if (length == 8 && dbr_sequence_length () == 0)\n     nullify = 1;\n \n   /* If this is a short forward conditional branch which did not get\n      its delay slot filled, the delay slot can still be nullified.  */\n-  if (! nullify && length == 1 && dbr_sequence_length () == 0)\n+  if (! nullify && length == 4 && dbr_sequence_length () == 0)\n     nullify = forward_branch_p (insn);\n \n   /* A forward branch over a single nullified insn can be done with a \n      extrs instruction.  This avoids a single cycle penalty due to\n      mis-predicted branch if we fall through (branch not taken).  */\n \n-  if (length == 1\n+  if (length == 4\n       && next_real_insn (insn) != 0\n-      && get_attr_length (next_real_insn (insn)) == 1\n+      && get_attr_length (next_real_insn (insn)) == 4\n       && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))\n       && nullify)\n     useskip = 1;\n@@ -3391,7 +3391,7 @@ output_bb (operands, nullify, length, negated, insn, which)\n \n       /* All short conditional branches except backwards with an unfilled\n \t delay slot.  */\n-      case 1:\n+      case 4:\n \tif (useskip)\n \t  strcpy (buf, \"extrs,\");\n \telse \n@@ -3416,7 +3416,7 @@ output_bb (operands, nullify, length, negated, insn, which)\n      /* All long conditionals.  Note an short backward branch with an \n \tunfilled delay slot is treated just like a long backward branch\n \twith an unfilled delay slot.  */\n-      case 2:\n+      case 8:\n \t/* Handle weird backwards branch with a filled delay slot\n \t   with is nullified.  */\n \tif (dbr_sequence_length () != 0\n@@ -3498,20 +3498,20 @@ output_dbra (operands, insn, which_alternative)\n \n       /* If this is a long branch with its delay slot unfilled, set `nullify'\n \t as it can nullify the delay slot and save a nop.  */\n-      if (length == 2 && dbr_sequence_length () == 0)\n+      if (length == 8 && dbr_sequence_length () == 0)\n \tnullify = 1;\n \n       /* If this is a short forward conditional branch which did not get\n \t its delay slot filled, the delay slot can still be nullified.  */\n-      if (! nullify && length == 1 && dbr_sequence_length () == 0)\n+      if (! nullify && length == 4 && dbr_sequence_length () == 0)\n \tnullify = forward_branch_p (insn);\n \n       /* Handle short versions first.  */\n-      if (length == 1 && nullify)\n+      if (length == 4 && nullify)\n \treturn \"addib,%C2,n %1,%0,%3\";\n-      else if (length == 1 && ! nullify)\n+      else if (length == 4 && ! nullify)\n \treturn \"addib,%C2 %1,%0,%3\";\n-      else if (length == 2)\n+      else if (length == 8)\n \t{\n \t  /* Handle weird backwards branch with a fulled delay slot \n \t     which is nullified.  */\n@@ -3537,7 +3537,7 @@ output_dbra (operands, insn, which_alternative)\n \t the FP register from MEM from within the branch's delay slot.  */ \n       output_asm_insn (\"fstws %0,-16(0,%%r30)\\n\\tldw -16(0,%%r30),%4\",operands);\n       output_asm_insn (\"ldo %1(%4),%4\\n\\tstw %4,-16(0,%%r30)\", operands);\n-      if (get_attr_length (insn) == 6)\n+      if (get_attr_length (insn) == 24)\n \treturn \"comb,%S2 0,%4,%3\\n\\tfldws -16(0,%%r30),%0\";\n       else\n \treturn \"comclr,%B2 0,%4,0\\n\\tbl %3,0\\n\\tfldws -16(0,%%r30),%0\";\n@@ -3548,7 +3548,7 @@ output_dbra (operands, insn, which_alternative)\n       /* Reload loop counter from memory, the store back to memory\n \t happens in the branch's delay slot.   */\n       output_asm_insn (\"ldw %0,%4\", operands);\n-      if (get_attr_length (insn) == 3)\n+      if (get_attr_length (insn) == 12)\n \treturn \"addib,%C2 %1,%4,%3\\n\\tstw %4,%0\";\n       else\n \treturn \"addi,%N2 %1,%4,%0\\n\\tbl %3,0\\n\\tstw %4,%0\";\n@@ -3594,20 +3594,20 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \n       /* If this is a long branch with its delay slot unfilled, set `nullify'\n \t as it can nullify the delay slot and save a nop.  */\n-      if (length == 2 && dbr_sequence_length () == 0)\n+      if (length == 8 && dbr_sequence_length () == 0)\n \tnullify = 1;\n \n       /* If this is a short forward conditional branch which did not get\n \t its delay slot filled, the delay slot can still be nullified.  */\n-      if (! nullify && length == 1 && dbr_sequence_length () == 0)\n+      if (! nullify && length == 4 && dbr_sequence_length () == 0)\n \tnullify = forward_branch_p (insn);\n \n       /* Handle short versions first.  */\n-      if (length == 1 && nullify)\n+      if (length == 4 && nullify)\n \treturn \"movb,%C2,n %1,%0,%3\";\n-      else if (length == 1 && ! nullify)\n+      else if (length == 4 && ! nullify)\n \treturn \"movb,%C2 %1,%0,%3\";\n-      else if (length == 2)\n+      else if (length == 8)\n \t{\n \t  /* Handle weird backwards branch with a fulled delay slot \n \t     which is nullified.  */\n@@ -3632,7 +3632,7 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n \t increment the GR, store the GR into MEM, and finally reload\n \t the FP register from MEM from within the branch's delay slot.  */ \n       output_asm_insn (\"fstws %1,-16(0,%%r30)\",operands);\n-      if (get_attr_length (insn) == 3)\n+      if (get_attr_length (insn) == 12)\n \treturn \"comb,%S2 0,%1,%3\\n\\tfldws -16(0,%%r30),%0\";\n       else\n \treturn \"comclr,%B2 0,%1,0\\n\\tbl %3,0\\n\\tfldws -16(0,%%r30),%0\";\n@@ -3642,7 +3642,7 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n     {\n       /* Reload loop counter from memory, the store back to memory\n \t happens in the branch's delay slot.   */\n-      if (get_attr_length (insn) == 2)\n+      if (get_attr_length (insn) == 8)\n \treturn \"comb,%S2 0,%1,%3\\n\\tstw %1,%0\";\n       else\n \treturn \"comclr,%B2 0,%1,0\\n\\tbl %3,0\\n\\tstw %1,%0\";"}]}