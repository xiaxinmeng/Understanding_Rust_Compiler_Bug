{"sha": "002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAyZWU0ZDEyZjU2YjAxNjRlZjIyNGNjOGM2ZmFkMzQ3YjhkOTVjNg==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2013-10-02T19:22:07Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-10-02T19:22:07Z"}, "message": "compiler: Use backend interface for numeric expressions.\n\n\t* go-gcc.cc: Include \"real.h\" and \"realmpfr.h\".\n\t(Backend::integer_constant_expression): New function.\n\t(Backend::float_constant_expression): New function.\n\t(Backend::complex_constant_expression): New function.\n\nFrom-SVN: r203127", "tree": {"sha": "e61073212ff346a00a7e58f9b6b0cc315482e7f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e61073212ff346a00a7e58f9b6b0cc315482e7f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/comments", "author": null, "committer": null, "parents": [{"sha": "99206ca90b8e53db1461366ac4ee4116a2673056", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99206ca90b8e53db1461366ac4ee4116a2673056", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99206ca90b8e53db1461366ac4ee4116a2673056"}], "stats": {"total": 310, "additions": 187, "deletions": 123}, "files": [{"sha": "0c9340600b03cc06a7041235c06d3c4e2af7f178", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "patch": "@@ -1,3 +1,10 @@\n+2013-10-02  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc: Include \"real.h\" and \"realmpfr.h\".\n+\t(Backend::integer_constant_expression): New function.\n+\t(Backend::float_constant_expression): New function.\n+\t(Backend::complex_constant_expression): New function.\n+\n 2013-09-30  Chris Manghane  <cmang@google.com>\n \n \t* go-gcc.cc (Backend::error_expression): New function."}, {"sha": "55b60ade21d48e8952c80fd51f2b531fa1ae5178", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "patch": "@@ -29,6 +29,8 @@\n #include \"gimple.h\"\n #include \"toplev.h\"\n #include \"output.h\"\n+#include \"real.h\"\n+#include \"realmpfr.h\"\n \n #include \"go-c.h\"\n \n@@ -218,6 +220,15 @@ class Gcc_backend : public Backend\n   Bexpression*\n   indirect_expression(Bexpression* expr, bool known_valid, Location);\n \n+  Bexpression*\n+  integer_constant_expression(Btype* btype, mpz_t val);\n+\n+  Bexpression*\n+  float_constant_expression(Btype* btype, mpfr_t val);\n+\n+  Bexpression*\n+  complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag);\n+\n   // Statements.\n \n   Bstatement*\n@@ -882,6 +893,62 @@ Gcc_backend::indirect_expression(Bexpression* expr, bool known_valid,\n   return tree_to_expr(ret);\n }\n \n+// Return a typed value as a constant integer.\n+\n+Bexpression*\n+Gcc_backend::integer_constant_expression(Btype* btype, mpz_t val)\n+{\n+  tree t = btype->get_tree();\n+  if (t == error_mark_node)\n+    return this->error_expression();\n+\n+  tree ret = double_int_to_tree(t, mpz_get_double_int(t, val, true));\n+  return tree_to_expr(ret);\n+}\n+\n+// Return a typed value as a constant floating-point number.\n+\n+Bexpression*\n+Gcc_backend::float_constant_expression(Btype* btype, mpfr_t val)\n+{\n+  tree t = btype->get_tree();\n+  tree ret;\n+  if (t == error_mark_node)\n+    return this->error_expression();\n+\n+  REAL_VALUE_TYPE r1;\n+  real_from_mpfr(&r1, val, t, GMP_RNDN);\n+  REAL_VALUE_TYPE r2;\n+  real_convert(&r2, TYPE_MODE(t), &r1);\n+  ret = build_real(t, r2);\n+  return tree_to_expr(ret);\n+}\n+\n+// Return a typed real and imaginary value as a constant complex number.\n+\n+Bexpression*\n+Gcc_backend::complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag)\n+{\n+  tree t = btype->get_tree();\n+  tree ret;\n+  if (t == error_mark_node)\n+    return this->error_expression();\n+\n+  REAL_VALUE_TYPE r1;\n+  real_from_mpfr(&r1, real, TREE_TYPE(t), GMP_RNDN);\n+  REAL_VALUE_TYPE r2;\n+  real_convert(&r2, TYPE_MODE(TREE_TYPE(t)), &r1);\n+\n+  REAL_VALUE_TYPE r3;\n+  real_from_mpfr(&r3, imag, TREE_TYPE(t), GMP_RNDN);\n+  REAL_VALUE_TYPE r4;\n+  real_convert(&r4, TYPE_MODE(TREE_TYPE(t)), &r3);\n+\n+  ret = build_complex(t, build_real(TREE_TYPE(t), r2),\n+                      build_real(TREE_TYPE(t), r4));\n+  return tree_to_expr(ret);\n+}\n+\n // An expression as a statement.\n \n Bstatement*"}, {"sha": "d0abdd7f7989808b7ba1d1a6524221f156f72d48", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "patch": "@@ -7,6 +7,9 @@\n #ifndef GO_BACKEND_H\n #define GO_BACKEND_H\n \n+#include <gmp.h>\n+#include <mpfr.h>\n+\n // Pointers to these types are created by the backend, passed to the\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n@@ -247,6 +250,18 @@ class Backend\n   virtual Bexpression*\n   indirect_expression(Bexpression* expr, bool known_valid, Location) = 0;\n \n+  // Return an expression for the multi-precision integer VAL in BTYPE.\n+  virtual Bexpression*\n+  integer_constant_expression(Btype* btype, mpz_t val) = 0;\n+\n+  // Return an expression for the floating point value VAL in BTYPE.\n+  virtual Bexpression*\n+  float_constant_expression(Btype* btype, mpfr_t val) = 0;\n+\n+  // Return an expression for the complex value REAL/IMAG in BTYPE.\n+  virtual Bexpression*\n+  complex_constant_expression(Btype* btype, mpfr_t real, mpfr_t imag) = 0;\n+\n   // Statements.\n \n   // Create an error statement.  This is used for cases which should"}, {"sha": "67bec710df5e51310db315dad671d1c696524278", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 90, "deletions": 110, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "patch": "@@ -610,102 +610,57 @@ Expression::get_tree(Translate_context* context)\n   return this->do_get_tree(context);\n }\n \n-// Return a tree for VAL in TYPE.\n-\n-tree\n-Expression::integer_constant_tree(mpz_t val, tree type)\n+// Return a backend expression for VAL.\n+Bexpression*\n+Expression::backend_numeric_constant_expression(Translate_context* context,\n+                                                Numeric_constant* val)\n {\n-  if (type == error_mark_node)\n-    return error_mark_node;\n-  else if (TREE_CODE(type) == INTEGER_TYPE)\n-    return double_int_to_tree(type,\n-\t\t\t      mpz_get_double_int(type, val, true));\n-  else if (TREE_CODE(type) == REAL_TYPE)\n-    {\n-      mpfr_t fval;\n-      mpfr_init_set_z(fval, val, GMP_RNDN);\n-      tree ret = Expression::float_constant_tree(fval, type);\n-      mpfr_clear(fval);\n-      return ret;\n-    }\n-  else if (TREE_CODE(type) == COMPLEX_TYPE)\n-    {\n-      mpfr_t fval;\n-      mpfr_init_set_z(fval, val, GMP_RNDN);\n-      tree real = Expression::float_constant_tree(fval, TREE_TYPE(type));\n-      mpfr_clear(fval);\n-      tree imag = build_real_from_int_cst(TREE_TYPE(type),\n-\t\t\t\t\t  integer_zero_node);\n-      return build_complex(type, real, imag);\n-    }\n-  else\n-    go_unreachable();\n-}\n-\n-// Return a tree for VAL in TYPE.\n+  Gogo* gogo = context->gogo();\n+  Type* type = val->type();\n+  if (type == NULL)\n+    return gogo->backend()->error_expression();\n \n-tree\n-Expression::float_constant_tree(mpfr_t val, tree type)\n-{\n-  if (type == error_mark_node)\n-    return error_mark_node;\n-  else if (TREE_CODE(type) == INTEGER_TYPE)\n+  Btype* btype = type->get_backend(gogo);\n+  Bexpression* ret;\n+  if (type->integer_type() != NULL)\n     {\n       mpz_t ival;\n-      mpz_init(ival);\n-      mpfr_get_z(ival, val, GMP_RNDN);\n-      tree ret = Expression::integer_constant_tree(ival, type);\n+      if (!val->to_int(&ival))\n+        {\n+          go_assert(saw_errors());\n+          return gogo->backend()->error_expression();\n+        }\n+      ret = gogo->backend()->integer_constant_expression(btype, ival);\n       mpz_clear(ival);\n-      return ret;\n     }\n-  else if (TREE_CODE(type) == REAL_TYPE)\n+  else if (type->float_type() != NULL)\n     {\n-      REAL_VALUE_TYPE r1;\n-      real_from_mpfr(&r1, val, type, GMP_RNDN);\n-      REAL_VALUE_TYPE r2;\n-      real_convert(&r2, TYPE_MODE(type), &r1);\n-      return build_real(type, r2);\n+      mpfr_t fval;\n+      if (!val->to_float(&fval))\n+        {\n+          go_assert(saw_errors());\n+          return gogo->backend()->error_expression();\n+        }\n+      ret = gogo->backend()->float_constant_expression(btype, fval);\n+      mpfr_clear(fval);\n     }\n-  else if (TREE_CODE(type) == COMPLEX_TYPE)\n+  else if (type->complex_type() != NULL)\n     {\n-      REAL_VALUE_TYPE r1;\n-      real_from_mpfr(&r1, val, TREE_TYPE(type), GMP_RNDN);\n-      REAL_VALUE_TYPE r2;\n-      real_convert(&r2, TYPE_MODE(TREE_TYPE(type)), &r1);\n-      tree imag = build_real_from_int_cst(TREE_TYPE(type),\n-\t\t\t\t\t  integer_zero_node);\n-      return build_complex(type, build_real(TREE_TYPE(type), r2), imag);\n+      mpfr_t real;\n+      mpfr_t imag;\n+      if (!val->to_complex(&real, &imag))\n+        {\n+          go_assert(saw_errors());\n+          return gogo->backend()->error_expression();\n+        }\n+      ret = gogo->backend()->complex_constant_expression(btype, real, imag);\n+      mpfr_clear(real);\n+      mpfr_clear(imag);\n     }\n   else\n     go_unreachable();\n-}\n \n-// Return a tree for REAL/IMAG in TYPE.\n-\n-tree\n-Expression::complex_constant_tree(mpfr_t real, mpfr_t imag, tree type)\n-{\n-  if (type == error_mark_node)\n-    return error_mark_node;\n-  else if (TREE_CODE(type) == INTEGER_TYPE || TREE_CODE(type) == REAL_TYPE)\n-    return Expression::float_constant_tree(real, type);\n-  else if (TREE_CODE(type) == COMPLEX_TYPE)\n-    {\n-      REAL_VALUE_TYPE r1;\n-      real_from_mpfr(&r1, real, TREE_TYPE(type), GMP_RNDN);\n-      REAL_VALUE_TYPE r2;\n-      real_convert(&r2, TYPE_MODE(TREE_TYPE(type)), &r1);\n-\n-      REAL_VALUE_TYPE r3;\n-      real_from_mpfr(&r3, imag, TREE_TYPE(type), GMP_RNDN);\n-      REAL_VALUE_TYPE r4;\n-      real_convert(&r4, TYPE_MODE(TREE_TYPE(type)), &r3);\n-\n-      return build_complex(type, build_real(TREE_TYPE(type), r2),\n-\t\t\t   build_real(TREE_TYPE(type), r4));\n-    }\n-  else\n-    go_unreachable();\n+  return ret;\n }\n \n // Return a tree which evaluates to true if VAL, of arbitrary integer\n@@ -1998,21 +1953,18 @@ Integer_expression::do_check_types(Gogo*)\n tree\n Integer_expression::do_get_tree(Translate_context* context)\n {\n-  Gogo* gogo = context->gogo();\n-  tree type;\n+  Type* resolved_type = NULL;\n   if (this->type_ != NULL && !this->type_->is_abstract())\n-    type = type_to_tree(this->type_->get_backend(gogo));\n+    resolved_type = this->type_;\n   else if (this->type_ != NULL && this->type_->float_type() != NULL)\n     {\n       // We are converting to an abstract floating point type.\n-      Type* ftype = Type::lookup_float_type(\"float64\");\n-      type = type_to_tree(ftype->get_backend(gogo));\n+      resolved_type = Type::lookup_float_type(\"float64\");\n     }\n   else if (this->type_ != NULL && this->type_->complex_type() != NULL)\n     {\n       // We are converting to an abstract complex type.\n-      Type* ctype = Type::lookup_complex_type(\"complex128\");\n-      type = type_to_tree(ctype->get_backend(gogo));\n+      resolved_type = Type::lookup_complex_type(\"complex128\");\n     }\n   else\n     {\n@@ -2023,16 +1975,23 @@ Integer_expression::do_get_tree(Translate_context* context)\n       int bits = mpz_sizeinbase(this->val_, 2);\n       Type* int_type = Type::lookup_integer_type(\"int\");\n       if (bits < int_type->integer_type()->bits())\n-\ttype = type_to_tree(int_type->get_backend(gogo));\n+\tresolved_type = int_type;\n       else if (bits < 64)\n-\t{\n-\t  Type* t = Type::lookup_integer_type(\"int64\");\n-\t  type = type_to_tree(t->get_backend(gogo));\n-\t}\n+        resolved_type = Type::lookup_integer_type(\"int64\");\n       else\n-\ttype = long_long_integer_type_node;\n+        {\n+          if (!saw_errors())\n+            error_at(this->location(),\n+                     \"unknown type for large integer constant\");\n+          Bexpression* ret = context->gogo()->backend()->error_expression();\n+          return expr_to_tree(ret);\n+        }\n     }\n-  return Expression::integer_constant_tree(this->val_, type);\n+  Numeric_constant nc;\n+  nc.set_int(resolved_type, this->val_);\n+  Bexpression* ret =\n+      Expression::backend_numeric_constant_expression(context, &nc);\n+  return expr_to_tree(ret);\n }\n \n // Write VAL to export data.\n@@ -2286,24 +2245,32 @@ Float_expression::do_check_types(Gogo*)\n tree\n Float_expression::do_get_tree(Translate_context* context)\n {\n-  Gogo* gogo = context->gogo();\n-  tree type;\n+  Type* resolved_type;\n   if (this->type_ != NULL && !this->type_->is_abstract())\n-    type = type_to_tree(this->type_->get_backend(gogo));\n+    resolved_type = this->type_;\n   else if (this->type_ != NULL && this->type_->integer_type() != NULL)\n     {\n       // We have an abstract integer type.  We just hope for the best.\n-      type = type_to_tree(Type::lookup_integer_type(\"int\")->get_backend(gogo));\n+      resolved_type = Type::lookup_integer_type(\"int\");\n+    }\n+  else if (this->type_ != NULL && this->type_->complex_type() != NULL)\n+    {\n+      // We are converting to an abstract complex type.\n+      resolved_type = Type::lookup_complex_type(\"complex128\");\n     }\n   else\n     {\n       // If we still have an abstract type here, then this is being\n       // used in a constant expression which didn't get reduced.  We\n       // just use float64 and hope for the best.\n-      Type* ft = Type::lookup_float_type(\"float64\");\n-      type = type_to_tree(ft->get_backend(gogo));\n+      resolved_type = Type::lookup_float_type(\"float64\");\n     }\n-  return Expression::float_constant_tree(this->val_, type);\n+\n+  Numeric_constant nc;\n+  nc.set_float(resolved_type, this->val_);\n+  Bexpression* ret =\n+      Expression::backend_numeric_constant_expression(context, &nc);\n+  return expr_to_tree(ret);\n }\n \n // Write a floating point number to a string dump.\n@@ -2463,19 +2430,32 @@ Complex_expression::do_check_types(Gogo*)\n tree\n Complex_expression::do_get_tree(Translate_context* context)\n {\n-  Gogo* gogo = context->gogo();\n-  tree type;\n+  Type* resolved_type;\n   if (this->type_ != NULL && !this->type_->is_abstract())\n-    type = type_to_tree(this->type_->get_backend(gogo));\n+    resolved_type = this->type_;\n+  else if (this->type_ != NULL && this->type_->integer_type() != NULL)\n+    {\n+      // We are converting to an abstract integer type.\n+      resolved_type = Type::lookup_integer_type(\"int\");\n+    }\n+  else if (this->type_ != NULL && this->type_->float_type() != NULL)\n+    {\n+      // We are converting to an abstract float type.\n+      resolved_type = Type::lookup_float_type(\"float64\");\n+    }\n   else\n     {\n       // If we still have an abstract type here, this this is being\n       // used in a constant expression which didn't get reduced.  We\n       // just use complex128 and hope for the best.\n-      Type* ct = Type::lookup_complex_type(\"complex128\");\n-      type = type_to_tree(ct->get_backend(gogo));\n+      resolved_type = Type::lookup_complex_type(\"complex128\");\n     }\n-  return Expression::complex_constant_tree(this->real_, this->imag_, type);\n+\n+  Numeric_constant nc;\n+  nc.set_complex(resolved_type, this->real_, this->imag_);\n+  Bexpression* ret =\n+      Expression::backend_numeric_constant_expression(context, &nc);\n+  return expr_to_tree(ret);\n }\n \n // Write REAL/IMAG to export data."}, {"sha": "b4cca5453b08dae173980900eed44c24cc37e634", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "patch": "@@ -652,17 +652,10 @@ class Expression\n \t\t  Type* left_type, tree left_tree, Type* right_type,\n \t\t  tree right_tree, Location);\n \n-  // Return a tree for the multi-precision integer VAL in TYPE.\n-  static tree\n-  integer_constant_tree(mpz_t val, tree type);\n-\n-  // Return a tree for the floating point value VAL in TYPE.\n-  static tree\n-  float_constant_tree(mpfr_t val, tree type);\n-\n-  // Return a tree for the complex value REAL/IMAG in TYPE.\n-  static tree\n-  complex_constant_tree(mpfr_t real, mpfr_t imag, tree type);\n+  // Return the backend expression for the numeric constant VAL.\n+  static Bexpression*\n+  backend_numeric_constant_expression(Translate_context*,\n+                                      Numeric_constant* val);\n \n   // Export the expression.  This is only used for constants.  It will\n   // be used for things like values of named constants and sizes of"}, {"sha": "e1d68e743455db8672b0d2e13453662ad65e1947", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/002ee4d12f56b0164ef224cc8c6fad347b8d95c6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=002ee4d12f56b0164ef224cc8c6fad347b8d95c6", "patch": "@@ -5665,8 +5665,10 @@ Array_type::get_length_tree(Gogo* gogo)\n \t    t = Type::lookup_integer_type(\"int\");\n \t  else if (t->is_abstract())\n \t    t = t->make_non_abstract_type();\n-\t  tree tt = type_to_tree(t->get_backend(gogo));\n-\t  this->length_tree_ = Expression::integer_constant_tree(val, tt);\n+          Btype* btype = t->get_backend(gogo);\n+          Bexpression* iexpr =\n+              gogo->backend()->integer_constant_expression(btype, val);\n+\t  this->length_tree_ = expr_to_tree(iexpr);\n \t  mpz_clear(val);\n \t}\n       else"}]}