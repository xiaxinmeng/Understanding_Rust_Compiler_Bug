{"sha": "8cf781f088f95c3fd8eff9cacc2acece01b5b2ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNmNzgxZjA4OGY5NWMzZmQ4ZWZmOWNhY2MyYWNlY2UwMWI1YjJlZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-04-24T22:24:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-04-24T22:24:01Z"}, "message": "re PR tree-optimization/31605 (VRP eliminates a useful test due with conversion from unsigned int to int)\n\n./:\tPR tree-optimization/31605\n\t* tree-vrp.c (set_value_range): Check that min and max are not\n\tboth overflow infinities.\n\t(set_value_range_to_value): New static function.\n\t(extract_range_from_binary_expr): Call set_value_range_to_value.\n\t(extract_range_from_cond_expr): Likewise.\n\t(extract_range_from_expr): Likewise.\n\t(extract_range_from_unary_expr): Likewise.  Don't create a range\n\twhich overflows on both sides.\n\t(vrp_meet): Check for a useless range.\n\t(vrp_visit_phi_node): If we see a constant which looks like an\n\toverflow infinity, turn off the TREE_OVERFLOW flag.\ntestsuite/:\n\tPR tree-optimizatoin/31605\n\t* gcc.c-torture/execute/pr31605.c: New test.\n\nFrom-SVN: r124128", "tree": {"sha": "5fe0e9d7ed36ef904ad6816fdcc49e207c008253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fe0e9d7ed36ef904ad6816fdcc49e207c008253"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee/comments", "author": null, "committer": null, "parents": [{"sha": "1e9ecf6da40abb1e294b71e60ae66ae34f93e0fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e9ecf6da40abb1e294b71e60ae66ae34f93e0fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e9ecf6da40abb1e294b71e60ae66ae34f93e0fd"}], "stats": {"total": 96, "additions": 89, "deletions": 7}, "files": [{"sha": "ba37f732c2a536f999bfb24a72830fa0b10c7322", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cf781f088f95c3fd8eff9cacc2acece01b5b2ee", "patch": "@@ -1,3 +1,18 @@\n+2007-04-24  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR tree-optimization/31605\n+\t* tree-vrp.c (set_value_range): Check that min and max are not\n+\tboth overflow infinities.\n+\t(set_value_range_to_value): New static function.\n+\t(extract_range_from_binary_expr): Call set_value_range_to_value.\n+\t(extract_range_from_cond_expr): Likewise.\n+\t(extract_range_from_expr): Likewise.\n+\t(extract_range_from_unary_expr): Likewise.  Don't create a range\n+\twhich overflows on both sides.\n+\t(vrp_meet): Check for a useless range.\n+\t(vrp_visit_phi_node): If we see a constant which looks like an\n+\toverflow infinity, turn off the TREE_OVERFLOW flag.\n+\n 2007-04-24  Ian Lance Taylor  <iant@google.com>\n \n \t* flow.c (elim_reg_cond): Handle a comparison of a subreg."}, {"sha": "cc0033e62b8d6ae109ad774e079e097296f457ae", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8cf781f088f95c3fd8eff9cacc2acece01b5b2ee", "patch": "@@ -1,3 +1,8 @@\n+2007-04-24  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR tree-optimizatoin/31605\n+\t* gcc.c-torture/execute/pr31605.c: New test.\n+\n 2007-04-24  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/31587"}, {"sha": "12a57ac1ea68a28835c8b8e90c632d8b6c7901e0", "filename": "gcc/testsuite/gcc.c-torture/execute/pr31605.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr31605.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr31605.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr31605.c?ref=8cf781f088f95c3fd8eff9cacc2acece01b5b2ee", "patch": "@@ -0,0 +1,13 @@\n+void put_field (unsigned int start, unsigned int len)\n+{\n+  int cur_bitshift = ((start + len) % 8) - 8;\n+  if (cur_bitshift > -8)\n+    exit (0);\n+}\n+\n+int\n+main ()\n+{\n+  put_field (0, 1);\n+  abort ();\n+}"}, {"sha": "78675e723241214f1ba53d2ff8e75d2a269df407", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf781f088f95c3fd8eff9cacc2acece01b5b2ee/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8cf781f088f95c3fd8eff9cacc2acece01b5b2ee", "patch": "@@ -272,6 +272,10 @@ set_value_range (value_range_t *vr, enum value_range_type t, tree min,\n \n       cmp = compare_values (min, max);\n       gcc_assert (cmp == 0 || cmp == -1 || cmp == -2);\n+\n+      if (needs_overflow_infinity (TREE_TYPE (min)))\n+\tgcc_assert (!is_overflow_infinity (min)\n+\t\t    || !is_overflow_infinity (max));\n     }\n \n   if (t == VR_UNDEFINED || t == VR_VARYING)\n@@ -320,6 +324,23 @@ set_value_range_to_varying (value_range_t *vr)\n     bitmap_clear (vr->equiv);\n }\n \n+/* Set value range VR to a single value.  This function is only called\n+   with values we get from statements, and exists to clear the\n+   TREE_OVERFLOW flag so that we don't think we have an overflow\n+   infinity when we shouldn't.  */\n+\n+static inline void\n+set_value_range_to_value (value_range_t *vr, tree val)\n+{\n+  gcc_assert (is_gimple_min_invariant (val));\n+  if (is_overflow_infinity (val))\n+    {\n+      val = copy_node (val);\n+      TREE_OVERFLOW (val) = 0;\n+    }\n+  set_value_range (vr, VR_RANGE, val, val, NULL);\n+}\n+\n /* Set value range VR to a non-negative range of type TYPE.\n    OVERFLOW_INFINITY indicates whether to use a overflow infinity\n    rather than TYPE_MAX_VALUE; this should be true if we determine\n@@ -1646,15 +1667,15 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n-    set_value_range (&vr0, VR_RANGE, op0, op0, NULL);\n+    set_value_range_to_value (&vr0, op0);\n   else\n     set_value_range_to_varying (&vr0);\n \n   op1 = TREE_OPERAND (expr, 1);\n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *(get_value_range (op1));\n   else if (is_gimple_min_invariant (op1))\n-    set_value_range (&vr1, VR_RANGE, op1, op1, NULL);\n+    set_value_range_to_value (&vr1, op1);\n   else\n     set_value_range_to_varying (&vr1);\n \n@@ -2053,7 +2074,7 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n-    set_value_range (&vr0, VR_RANGE, op0, op0, NULL);\n+    set_value_range_to_value (&vr0, op0);\n   else\n     set_value_range_to_varying (&vr0);\n \n@@ -2185,7 +2206,9 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n \tmin = fold_unary_to_constant (code, TREE_TYPE (expr), vr0.max);\n       else if (needs_overflow_infinity (TREE_TYPE (expr)))\n \t{\n-\t  if (supports_overflow_infinity (TREE_TYPE (expr)))\n+\t  if (supports_overflow_infinity (TREE_TYPE (expr))\n+\t      && !is_overflow_infinity (vr0.min)\n+\t      && vr0.min != TYPE_MIN_VALUE (TREE_TYPE (expr)))\n \t    min = positive_overflow_infinity (TREE_TYPE (expr));\n \t  else\n \t    {\n@@ -2361,6 +2384,18 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n       if (needs_overflow_infinity (TREE_TYPE (expr)))\n \t{\n \t  gcc_assert (code != NEGATE_EXPR && code != ABS_EXPR);\n+\n+\t  /* If both sides have overflowed, we don't know\n+\t     anything.  */\n+\t  if ((is_overflow_infinity (vr0.min)\n+\t       || TREE_OVERFLOW (min))\n+\t      && (is_overflow_infinity (vr0.max)\n+\t\t  || TREE_OVERFLOW (max)))\n+\t    {\n+\t      set_value_range_to_varying (vr);\n+\t      return;\n+\t    }\n+\n \t  if (is_overflow_infinity (vr0.min))\n \t    min = vr0.min;\n \t  else if (TREE_OVERFLOW (min))\n@@ -2422,15 +2457,15 @@ extract_range_from_cond_expr (value_range_t *vr, tree expr)\n   if (TREE_CODE (op0) == SSA_NAME)\n     vr0 = *(get_value_range (op0));\n   else if (is_gimple_min_invariant (op0))\n-    set_value_range (&vr0, VR_RANGE, op0, op0, NULL);\n+    set_value_range_to_value (&vr0, op0);\n   else\n     set_value_range_to_varying (&vr0);\n \n   op1 = COND_EXPR_ELSE (expr);\n   if (TREE_CODE (op1) == SSA_NAME)\n     vr1 = *(get_value_range (op1));\n   else if (is_gimple_min_invariant (op1))\n-    set_value_range (&vr1, VR_RANGE, op1, op1, NULL);\n+    set_value_range_to_value (&vr1, op1);\n   else\n     set_value_range_to_varying (&vr1);\n \n@@ -2494,7 +2529,7 @@ extract_range_from_expr (value_range_t *vr, tree expr)\n   else if (TREE_CODE_CLASS (code) == tcc_comparison)\n     extract_range_from_comparison (vr, expr);\n   else if (is_gimple_min_invariant (expr))\n-    set_value_range (vr, VR_RANGE, expr, expr, NULL);\n+    set_value_range_to_value (vr, expr);\n   else\n     set_value_range_to_varying (vr);\n \n@@ -5106,6 +5141,14 @@ vrp_meet (value_range_t *vr0, value_range_t *vr1)\n       else\n \tgoto give_up;\n \n+      /* Check for useless ranges.  */\n+      if (INTEGRAL_TYPE_P (TREE_TYPE (min))\n+\t  && ((min == TYPE_MIN_VALUE (TREE_TYPE (min))\n+\t       || is_overflow_infinity (min))\n+\t      && (max == TYPE_MAX_VALUE (TREE_TYPE (max))\n+\t\t  || is_overflow_infinity (max))))\n+\tgoto give_up;\n+\n       /* The resulting set of equivalences is the intersection of\n \t the two sets.  */\n       if (vr0->equiv && vr1->equiv && vr0->equiv != vr1->equiv)\n@@ -5235,6 +5278,12 @@ vrp_visit_phi_node (tree phi)\n \t    }\n \t  else\n \t    {\n+\t      if (is_overflow_infinity (arg))\n+\t\t{\n+\t\t  arg = copy_node (arg);\n+\t\t  TREE_OVERFLOW (arg) = 0;\n+\t\t}\n+\n \t      vr_arg.type = VR_RANGE;\n \t      vr_arg.min = arg;\n \t      vr_arg.max = arg;"}]}