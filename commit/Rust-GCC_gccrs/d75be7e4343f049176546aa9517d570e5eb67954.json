{"sha": "d75be7e4343f049176546aa9517d570e5eb67954", "node_id": "C_kwDOANBUbNoAKGQ3NWJlN2U0MzQzZjA0OTE3NjU0NmFhOTUxN2Q1NzBlNWViNjc5NTQ", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-06T19:01:24Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-10-13T15:28:47Z"}, "message": "Add partial equivalence recognition to cast and bitwise and.\n\nThis provides the hooks that will register partial equivalencies for\ncasts and bitwise AND operations with the appropriate bit pattern.\n\n\t* range-op.cc (operator_cast::lhs_op1_relation): New.\n\t(operator_bitwise_and::lhs_op1_relation): New.", "tree": {"sha": "17b72024e1e02ff563a341d78bd2df13c9250a7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17b72024e1e02ff563a341d78bd2df13c9250a7b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d75be7e4343f049176546aa9517d570e5eb67954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75be7e4343f049176546aa9517d570e5eb67954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d75be7e4343f049176546aa9517d570e5eb67954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75be7e4343f049176546aa9517d570e5eb67954/comments", "author": null, "committer": null, "parents": [{"sha": "aa05838b0536422256e0c477c57f1ea1d2915e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa05838b0536422256e0c477c57f1ea1d2915e92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa05838b0536422256e0c477c57f1ea1d2915e92"}], "stats": {"total": 65, "additions": 65, "deletions": 0}, "files": [{"sha": "cf7f0dcd670835bb764e8ed5da7b86953e17ca56", "filename": "gcc/range-op.cc", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75be7e4343f049176546aa9517d570e5eb67954/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75be7e4343f049176546aa9517d570e5eb67954/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=d75be7e4343f049176546aa9517d570e5eb67954", "patch": "@@ -2417,6 +2417,10 @@ class operator_cast: public range_operator\n \t\t\t  const irange &lhs,\n \t\t\t  const irange &op2,\n \t\t\t  relation_kind rel = VREL_VARYING) const;\n+  virtual relation_kind lhs_op1_relation (const irange &lhs,\n+\t\t\t\t\t  const irange &op1,\n+\t\t\t\t\t  const irange &op2,\n+\t\t\t\t\t  relation_kind) const;\n private:\n   bool truncating_cast_p (const irange &inner, const irange &outer) const;\n   bool inside_domain_p (const wide_int &min, const wide_int &max,\n@@ -2425,6 +2429,35 @@ class operator_cast: public range_operator\n \t\t\t   const irange &outer) const;\n } op_convert;\n \n+// Add a partial equivalence between the LHS and op1 for casts.\n+\n+relation_kind\n+operator_cast::lhs_op1_relation (const irange &lhs,\n+\t\t\t\t const irange &op1,\n+\t\t\t\t const irange &op2 ATTRIBUTE_UNUSED,\n+\t\t\t\t relation_kind) const\n+{\n+  if (lhs.undefined_p () || op1.undefined_p ())\n+    return VREL_VARYING;\n+  unsigned lhs_prec = TYPE_PRECISION (lhs.type ());\n+  unsigned op1_prec = TYPE_PRECISION (op1.type ());\n+  // If the result gets sign extended into a larger type check first if this\n+  // qualifies as a partial equivalence.\n+  if (TYPE_SIGN (op1.type ()) == SIGNED && lhs_prec > op1_prec)\n+    {\n+      // If the result is sign extended, and the LHS is larger than op1,\n+      // check if op1's range can be negative as the sign extention will\n+      // cause the upper bits to be 1 instead of 0, invalidating the PE.\n+      int_range<3> negs = range_negatives (op1.type ());\n+      negs.intersect (op1);\n+      if (!negs.undefined_p ())\n+\treturn VREL_VARYING;\n+    }\n+\n+  unsigned prec = MIN (lhs_prec, op1_prec);\n+  return bits_to_pe (prec);\n+}\n+\n // Return TRUE if casting from INNER to OUTER is a truncating cast.\n \n inline bool\n@@ -2739,6 +2772,10 @@ class operator_bitwise_and : public range_operator\n \t\t        const wide_int &lh_ub,\n \t\t        const wide_int &rh_lb,\n \t\t        const wide_int &rh_ub) const;\n+  virtual relation_kind lhs_op1_relation (const irange &lhs,\n+\t\t\t\t\t  const irange &op1,\n+\t\t\t\t\t  const irange &op2,\n+\t\t\t\t\t  relation_kind) const;\n private:\n   void simple_op1_range_solver (irange &r, tree type,\n \t\t\t\tconst irange &lhs,\n@@ -2784,6 +2821,34 @@ wi_optimize_signed_bitwise_op (irange &r, tree type,\n   return true;\n }\n \n+// An AND of 8,16, 32 or 64 bits can produce a partial equivalence between\n+// the LHS and op1.\n+\n+relation_kind\n+operator_bitwise_and::lhs_op1_relation (const irange &lhs,\n+\t\t\t\t const irange &op1,\n+\t\t\t\t const irange &op2,\n+\t\t\t\t relation_kind) const\n+{\n+  if (lhs.undefined_p () || op1.undefined_p () || op2.undefined_p ())\n+    return VREL_VARYING;\n+  if (!op2.singleton_p ())\n+    return VREL_VARYING;\n+  // if val == 0xff or 0xFFFF OR 0Xffffffff OR 0Xffffffffffffffff, return TRUE\n+  int prec1 = TYPE_PRECISION (op1.type ());\n+  int prec2 = TYPE_PRECISION (op2.type ());\n+  int mask_prec = 0;\n+  wide_int mask = op2.lower_bound ();\n+  if (wi::eq_p (mask, wi::mask (8, false, prec2)))\n+    mask_prec = 8;\n+  else if (wi::eq_p (mask, wi::mask (16, false, prec2)))\n+    mask_prec = 16;\n+  else if (wi::eq_p (mask, wi::mask (32, false, prec2)))\n+    mask_prec = 32;\n+  else if (wi::eq_p (mask, wi::mask (64, false, prec2)))\n+    mask_prec = 64;\n+  return bits_to_pe (MIN (prec1, mask_prec));\n+}\n \n // Optimize BIT_AND_EXPR and BIT_IOR_EXPR in terms of a mask if\n // possible.  Basically, see if we can optimize:"}]}