{"sha": "4669743bd255d2ab4ff33672e8843a914e5c1d35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY2OTc0M2JkMjU1ZDJhYjRmZjMzNjcyZTg4NDNhOTE0ZTVjMWQzNQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2019-07-10T09:02:55Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-10T09:02:55Z"}, "message": "[Ada] Spurious run-time error with 64-bit modular types\n\nAs a lexical element an integer literal has type Universal_Integer, i.e\nis compatible with any integer type. This is semantically consistent and\nsimplifies type checking and subsequent constant folding when\napplicable.  An exception is caused by 64-bit modular types, whose upper\nbound is not representable in a non-static context that will use 64-bit\nintegers at run-time. For such cases we need to preserve the information\nthat the analyzed literal has that modular type. For simplicity we\npreseve the information for all integer literals that result from a\nmodular operation.  This happens after prior analysis (or construction)\nof the literal, and after type checking and resolution.\n\n2019-07-10  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch2.adb (Analyze_Integer_Literal): Preserve the type of\n\tthe literal if prior analysis determined that its type is a\n\tmodular integer type.\n\ngcc/testsuite/\n\n\t* gnat.dg/modular5.adb: New testcase.\n\nFrom-SVN: r273352", "tree": {"sha": "96e179791fdde784f987de9c6a842e0f35cd889c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96e179791fdde784f987de9c6a842e0f35cd889c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4669743bd255d2ab4ff33672e8843a914e5c1d35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4669743bd255d2ab4ff33672e8843a914e5c1d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4669743bd255d2ab4ff33672e8843a914e5c1d35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4669743bd255d2ab4ff33672e8843a914e5c1d35/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ccba4bf136ef7012e7387119a86da56575802c4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccba4bf136ef7012e7387119a86da56575802c4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccba4bf136ef7012e7387119a86da56575802c4f"}], "stats": {"total": 57, "additions": 56, "deletions": 1}, "files": [{"sha": "94fab7f557832c49bbf9186982db473a6bfb521a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4669743bd255d2ab4ff33672e8843a914e5c1d35/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4669743bd255d2ab4ff33672e8843a914e5c1d35/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4669743bd255d2ab4ff33672e8843a914e5c1d35", "patch": "@@ -1,3 +1,9 @@\n+2019-07-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch2.adb (Analyze_Integer_Literal): Preserve the type of\n+\tthe literal if prior analysis determined that its type is a\n+\tmodular integer type.\n+\n 2019-07-10  Doug Rupp  <rupp@adacore.com>\n \n \t* init.c: Do not attempt to re-arm guard page on x86_64-vx7(r2)."}, {"sha": "0a282d443d9e2fd9a198734808b29bf66cb13f95", "filename": "gcc/ada/sem_ch2.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4669743bd255d2ab4ff33672e8843a914e5c1d35/gcc%2Fada%2Fsem_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4669743bd255d2ab4ff33672e8843a914e5c1d35/gcc%2Fada%2Fsem_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch2.adb?ref=4669743bd255d2ab4ff33672e8843a914e5c1d35", "patch": "@@ -24,12 +24,14 @@\n ------------------------------------------------------------------------------\n \n with Atree;    use Atree;\n+with Einfo;    use Einfo;\n with Namet;    use Namet;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Dim;  use Sem_Dim;\n+--  with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n with Uintp;    use Uintp;\n@@ -83,7 +85,24 @@ package body Sem_Ch2 is\n \n    procedure Analyze_Integer_Literal (N : Node_Id) is\n    begin\n-      Set_Etype (N, Universal_Integer);\n+      --  As a lexical element, an integer literal has type Universal_Integer,\n+      --  i.e., is compatible with any integer type. This is semantically\n+      --  consistent and simplifies type checking and subsequent constant\n+      --  folding when needed. An exception is caused by 64-bit modular types,\n+      --  whose upper bound is not representable in a nonstatic context that\n+      --  will use 64-bit integers at run time. For such cases, we need to\n+      --  preserve the information that the analyzed literal has that modular\n+      --  type. For simplicity, we preserve the information for all integer\n+      --  literals that result from a modular operation. This happens after\n+      --  prior analysis (or construction) of the literal, and after type\n+      --  checking and resolution.\n+\n+      if No (Etype (N))\n+        or else not Is_Modular_Integer_Type (Etype (N))\n+      then\n+         Set_Etype (N, Universal_Integer);\n+      end if;\n+\n       Set_Is_Static_Expression (N);\n    end Analyze_Integer_Literal;\n "}, {"sha": "a953397db9390f50f63c2bad3dad009d3047f35b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4669743bd255d2ab4ff33672e8843a914e5c1d35/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4669743bd255d2ab4ff33672e8843a914e5c1d35/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4669743bd255d2ab4ff33672e8843a914e5c1d35", "patch": "@@ -1,3 +1,7 @@\n+2019-07-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat.dg/modular5.adb: New testcase.\n+\n 2019-07-10  Ed Schonberg  <schonberg@adacore.com>\n \n \t* gnat.dg/limited3.adb, gnat.dg/limited3_pkg.adb,"}, {"sha": "7fcf59ce849ffb689269260db2e45a28347bf881", "filename": "gcc/testsuite/gnat.dg/modular5.adb", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4669743bd255d2ab4ff33672e8843a914e5c1d35/gcc%2Ftestsuite%2Fgnat.dg%2Fmodular5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4669743bd255d2ab4ff33672e8843a914e5c1d35/gcc%2Ftestsuite%2Fgnat.dg%2Fmodular5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fmodular5.adb?ref=4669743bd255d2ab4ff33672e8843a914e5c1d35", "patch": "@@ -0,0 +1,26 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnata\" }\n+\n+procedure Modular5 is\n+   type U64 is mod 2 ** 64;\n+   Maybe    : Boolean := 2 ** 10 < U64'Succ (U64'last - 1);\n+   For_Sure : Boolean := U64'(18446744073709551615) > 2;\n+   Ditto    : Boolean := 18446744073709551615 > 2;\n+\n+   generic\n+      type TG is mod <>;\n+   package PG is\n+     X : TG;\n+      pragma Assert (for all K in 1 .. 2 => 2 ** K <= TG'Last);\n+      pragma Assert (for all K in 1 .. 2 => 2 ** K <= TG'Last - 1);\n+\n+     Maybe    : Boolean := 2 ** 10 < TG'Succ (TG'last - 1);\n+     For_Sure : Boolean := TG'(18446744073709551615) > 2;\n+   end PG;\n+\n+   package IG is new PG (U64);\n+\n+begin\n+   pragma Assert (for all K in 1 .. 2 => 2 ** K <= U64'Last);\n+   pragma Assert (for all K in 1 .. 2 => 2 ** K <= U64'Last - 1);\n+end Modular5;"}]}