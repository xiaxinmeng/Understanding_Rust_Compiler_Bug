{"sha": "f8332e52a498df480f72303de32ad0751ad899fe", "node_id": "C_kwDOANBUbNoAKGY4MzMyZTUyYTQ5OGRmNDgwZjcyMzAzZGUzMmFkMDc1MWFkODk5ZmU", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-27T14:56:18Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-03-10T17:05:27Z"}, "message": "Use 'GOMP_MAP_VARS_TARGET' for OpenACC compute constructs [PR90596]\n\nThereby considerably simplify the device plugins' 'GOMP_OFFLOAD_openacc_exec',\n'GOMP_OFFLOAD_openacc_async_exec' functions: in terms of lines of code, but in\nparticular conceptually: no more device memory allocation, host to device data\ncopying, device memory deallocation -- 'GOMP_MAP_VARS_TARGET' does all that for\nus.\n\nThis depends on commit 2b2340e236c0bba8aaca358ea25a5accd8249fbd\n\"Allow libgomp 'cbuf' buffering with OpenACC 'async' for 'ephemeral' data\",\nwhere I said that \"a use will emerge later\", which is this one here.\n\n\tPR libgomp/90596\n\tlibgomp/\n\t* target.c (gomp_map_vars_internal): Allow for\n\t'param_kind == GOMP_MAP_VARS_OPENACC | GOMP_MAP_VARS_TARGET'.\n\t* oacc-parallel.c (GOACC_parallel_keyed): Pass\n\t'GOMP_MAP_VARS_TARGET' to 'goacc_map_vars'.\n\t* plugin/plugin-gcn.c (alloc_by_agent, gcn_exec)\n\t(GOMP_OFFLOAD_openacc_exec, GOMP_OFFLOAD_openacc_async_exec):\n\tAdjust, simplify.\n\t(gomp_offload_free): Remove.\n\t* plugin/plugin-nvptx.c (nvptx_exec, GOMP_OFFLOAD_openacc_exec)\n\t(GOMP_OFFLOAD_openacc_async_exec): Adjust, simplify.\n\t(cuda_free_argmem): Remove.\n\t* testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c:\n\tAdjust.", "tree": {"sha": "78eb3ca7cb7351b8eb5cc74f338b4bd9b6d4ec69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78eb3ca7cb7351b8eb5cc74f338b4bd9b6d4ec69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8332e52a498df480f72303de32ad0751ad899fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8332e52a498df480f72303de32ad0751ad899fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8332e52a498df480f72303de32ad0751ad899fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8332e52a498df480f72303de32ad0751ad899fe/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14f5e56a8a766c6f48c2a07b301fce2db1a19a3c"}], "stats": {"total": 282, "additions": 44, "deletions": 238}, "files": [{"sha": "363e6656982584bf269921be2c0f957182aa8ac9", "filename": "libgomp/oacc-parallel.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Foacc-parallel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Foacc-parallel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-parallel.c?ref=f8332e52a498df480f72303de32ad0751ad899fe", "patch": "@@ -108,8 +108,6 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n   va_list ap;\n   struct goacc_thread *thr;\n   struct gomp_device_descr *acc_dev;\n-  struct target_mem_desc *tgt;\n-  void **devaddrs;\n   unsigned int i;\n   struct splay_tree_key_s k;\n   splay_tree_key tgt_fn_key;\n@@ -290,8 +288,10 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n \n   goacc_aq aq = get_goacc_asyncqueue (async);\n \n-  tgt = goacc_map_vars (acc_dev, aq, mapnum, hostaddrs, NULL, sizes, kinds,\n-\t\t\ttrue, 0);\n+  struct target_mem_desc *tgt\n+    = goacc_map_vars (acc_dev, aq, mapnum, hostaddrs, NULL, sizes, kinds, true,\n+\t\t      GOMP_MAP_VARS_TARGET);\n+\n   if (profiling_p)\n     {\n       prof_info.event_type = acc_ev_enter_data_end;\n@@ -301,10 +301,7 @@ GOACC_parallel_keyed (int flags_m, void (*fn) (void *),\n \t\t\t\t&api_info);\n     }\n \n-  devaddrs = gomp_alloca (sizeof (void *) * mapnum);\n-  for (i = 0; i < mapnum; i++)\n-    devaddrs[i] = (void *) gomp_map_val (tgt, hostaddrs, i);\n-\n+  void **devaddrs = (void **) tgt->tgt_start;\n   if (aq == NULL)\n     acc_dev->openacc.exec_func (tgt_fn, mapnum, hostaddrs, devaddrs, dims,\n \t\t\t\ttgt);"}, {"sha": "347803762eb9ddc99cc95fc95140ba2a74ac9f12", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 9, "deletions": 38, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=f8332e52a498df480f72303de32ad0751ad899fe", "patch": "@@ -1833,13 +1833,6 @@ alloc_by_agent (struct agent_info *agent, size_t size)\n {\n   GCN_DEBUG (\"Allocating %zu bytes on device %d\\n\", size, agent->device_id);\n \n-  /* Zero-size allocations are invalid, so in order to return a valid pointer\n-     we need to pass a valid size.  One source of zero-size allocations is\n-     kernargs for kernels that have no inputs or outputs (the kernel may\n-     only use console output, for example).  */\n-  if (size == 0)\n-    size = 4;\n-\n   void *ptr;\n   hsa_status_t status = hsa_fns.hsa_memory_allocate_fn (agent->data_region,\n \t\t\t\t\t\t\tsize, &ptr);\n@@ -2989,15 +2982,6 @@ copy_data (void *data_)\n   free (data);\n }\n \n-/* Free device data.  This is intended for use as an async callback event.  */\n-\n-static void\n-gomp_offload_free (void *ptr)\n-{\n-  GCN_DEBUG (\"Async thread ?:?: Freeing %p\\n\", ptr);\n-  GOMP_OFFLOAD_free (0, ptr);\n-}\n-\n /* Request an asynchronous data copy, to or from a device, on a given queue.\n    The event will be registered as a callback.  */\n \n@@ -3064,7 +3048,7 @@ wait_queue (struct goacc_asyncqueue *aq)\n /* Execute an OpenACC kernel, synchronously or asynchronously.  */\n \n static void\n-gcn_exec (struct kernel_info *kernel, size_t mapnum,\n+gcn_exec (struct kernel_info *kernel,\n \t  void **devaddrs, unsigned *dims, void *targ_mem_desc, bool async,\n \t  struct goacc_asyncqueue *aq)\n {\n@@ -3074,11 +3058,6 @@ gcn_exec (struct kernel_info *kernel, size_t mapnum,\n   /* If we get here then this must be an OpenACC kernel.  */\n   kernel->kind = KIND_OPENACC;\n \n-  /* devaddrs must be double-indirect on the target.  */\n-  void **ind_da = alloc_by_agent (kernel->agent, sizeof (void*) * mapnum);\n-  for (size_t i = 0; i < mapnum; i++)\n-    hsa_fns.hsa_memory_copy_fn (&ind_da[i], &devaddrs[i], sizeof (void *));\n-\n   struct hsa_kernel_description *hsa_kernel_desc = NULL;\n   for (unsigned i = 0; i < kernel->module->image_desc->kernel_count; i++)\n     {\n@@ -3190,9 +3169,9 @@ gcn_exec (struct kernel_info *kernel, size_t mapnum,\n     }\n \n   if (!async)\n-    run_kernel (kernel, ind_da, &kla, NULL, false);\n+    run_kernel (kernel, devaddrs, &kla, NULL, false);\n   else\n-    queue_push_launch (aq, kernel, ind_da, &kla);\n+    queue_push_launch (aq, kernel, devaddrs, &kla);\n \n   if (profiling_dispatch_p)\n     {\n@@ -3202,16 +3181,6 @@ gcn_exec (struct kernel_info *kernel, size_t mapnum,\n \t\t\t\t\t    &enqueue_launch_event_info,\n \t\t\t\t\t    api_info);\n     }\n-\n-  if (!async)\n-    gomp_offload_free (ind_da);\n-  else\n-    {\n-      if (DEBUG_QUEUES)\n-\tGCN_DEBUG (\"queue_push_callback %d:%d gomp_offload_free, %p\\n\",\n-\t\t   aq->agent->device_id, aq->id, ind_da);\n-      queue_push_callback (aq, gomp_offload_free, ind_da);\n-    }\n }\n \n /* }}}  */\n@@ -3884,28 +3853,30 @@ GOMP_OFFLOAD_async_run (int device, void *tgt_fn, void *tgt_vars,\n    already-loaded KERNEL.  */\n \n void\n-GOMP_OFFLOAD_openacc_exec (void (*fn_ptr) (void *), size_t mapnum,\n+GOMP_OFFLOAD_openacc_exec (void (*fn_ptr) (void *),\n+\t\t\t   size_t mapnum __attribute__((unused)),\n \t\t\t   void **hostaddrs __attribute__((unused)),\n \t\t\t   void **devaddrs, unsigned *dims,\n \t\t\t   void *targ_mem_desc)\n {\n   struct kernel_info *kernel = (struct kernel_info *) fn_ptr;\n \n-  gcn_exec (kernel, mapnum, devaddrs, dims, targ_mem_desc, false, NULL);\n+  gcn_exec (kernel, devaddrs, dims, targ_mem_desc, false, NULL);\n }\n \n /* Run an asynchronous OpenACC kernel on the specified queue.  */\n \n void\n-GOMP_OFFLOAD_openacc_async_exec (void (*fn_ptr) (void *), size_t mapnum,\n+GOMP_OFFLOAD_openacc_async_exec (void (*fn_ptr) (void *),\n+\t\t\t\t size_t mapnum __attribute__((unused)),\n \t\t\t\t void **hostaddrs __attribute__((unused)),\n \t\t\t\t void **devaddrs,\n \t\t\t\t unsigned *dims, void *targ_mem_desc,\n \t\t\t\t struct goacc_asyncqueue *aq)\n {\n   struct kernel_info *kernel = (struct kernel_info *) fn_ptr;\n \n-  gcn_exec (kernel, mapnum, devaddrs, dims, targ_mem_desc, true, aq);\n+  gcn_exec (kernel, devaddrs, dims, targ_mem_desc, true, aq);\n }\n \n /* Create a new asynchronous thread and queue for running future kernels.  */"}, {"sha": "b3481c408c90b824e290ebceaf1907589dd15f0a", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 11, "deletions": 143, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=f8332e52a498df480f72303de32ad0751ad899fe", "patch": "@@ -742,7 +742,7 @@ link_ptx (CUmodule *module, const struct targ_ptx_obj *ptx_objs,\n }\n \n static void\n-nvptx_exec (void (*fn), size_t mapnum, unsigned *dims, void *targ_mem_desc,\n+nvptx_exec (void (*fn), unsigned *dims, void *targ_mem_desc,\n \t    CUdeviceptr dp, CUstream stream)\n {\n   struct targ_fn_descriptor *targ_fn = (struct targ_fn_descriptor *) fn;\n@@ -1528,70 +1528,16 @@ GOMP_OFFLOAD_free (int ord, void *ptr)\n }\n \n void\n-GOMP_OFFLOAD_openacc_exec (void (*fn) (void *), size_t mapnum,\n+GOMP_OFFLOAD_openacc_exec (void (*fn) (void *),\n+\t\t\t   size_t mapnum  __attribute__((unused)),\n \t\t\t   void **hostaddrs __attribute__((unused)),\n \t\t\t   void **devaddrs,\n \t\t\t   unsigned *dims, void *targ_mem_desc)\n {\n-  GOMP_PLUGIN_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n+  GOMP_PLUGIN_debug (0, \"nvptx %s\\n\", __FUNCTION__);\n \n-  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();\n-  acc_prof_info *prof_info = thr->prof_info;\n-  acc_event_info data_event_info;\n-  acc_api_info *api_info = thr->api_info;\n-  bool profiling_p = __builtin_expect (prof_info != NULL, false);\n-\n-  void **hp = NULL;\n-  CUdeviceptr dp = 0;\n-\n-  if (mapnum > 0)\n-    {\n-      size_t s = mapnum * sizeof (void *);\n-      hp = alloca (s);\n-      for (int i = 0; i < mapnum; i++)\n-\thp[i] = devaddrs[i];\n-      CUDA_CALL_ASSERT (cuMemAlloc, &dp, s);\n-      if (profiling_p)\n-\tgoacc_profiling_acc_ev_alloc (thr, (void *) dp, s);\n-    }\n-\n-  /* Copy the (device) pointers to arguments to the device (dp and hp might in\n-     fact have the same value on a unified-memory system).  */\n-  if (mapnum > 0)\n-    {\n-      if (profiling_p)\n-\t{\n-\t  prof_info->event_type = acc_ev_enqueue_upload_start;\n-\n-\t  data_event_info.data_event.event_type = prof_info->event_type;\n-\t  data_event_info.data_event.valid_bytes\n-\t    = _ACC_DATA_EVENT_INFO_VALID_BYTES;\n-\t  data_event_info.data_event.parent_construct\n-\t    = acc_construct_parallel;\n-\t  data_event_info.data_event.implicit = 1; /* Always implicit.  */\n-\t  data_event_info.data_event.tool_info = NULL;\n-\t  data_event_info.data_event.var_name = NULL;\n-\t  data_event_info.data_event.bytes = mapnum * sizeof (void *);\n-\t  data_event_info.data_event.host_ptr = hp;\n-\t  data_event_info.data_event.device_ptr = (const void *) dp;\n-\n-\t  api_info->device_api = acc_device_api_cuda;\n-\n-\t  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,\n-\t\t\t\t\t\tapi_info);\n-\t}\n-      CUDA_CALL_ASSERT (cuMemcpyHtoD, dp, (void *) hp,\n-\t\t\tmapnum * sizeof (void *));\n-      if (profiling_p)\n-\t{\n-\t  prof_info->event_type = acc_ev_enqueue_upload_end;\n-\t  data_event_info.data_event.event_type = prof_info->event_type;\n-\t  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,\n-\t\t\t\t\t\tapi_info);\n-\t}\n-    }\n-\n-  nvptx_exec (fn, mapnum, dims, targ_mem_desc, dp, NULL);\n+  CUdeviceptr dp = (CUdeviceptr) devaddrs;\n+  nvptx_exec (fn, dims, targ_mem_desc, dp, NULL);\n \n   CUresult r = CUDA_CALL_NOCHECK (cuStreamSynchronize, NULL);\n   const char *maybe_abort_msg = \"(perhaps abort was called)\";\n@@ -1600,98 +1546,20 @@ GOMP_OFFLOAD_openacc_exec (void (*fn) (void *), size_t mapnum,\n \t\t       maybe_abort_msg);\n   else if (r != CUDA_SUCCESS)\n     GOMP_PLUGIN_fatal (\"cuStreamSynchronize error: %s\", cuda_error (r));\n-\n-  CUDA_CALL_ASSERT (cuMemFree, dp);\n-  if (profiling_p)\n-    goacc_profiling_acc_ev_free (thr, (void *) dp);\n-}\n-\n-static void\n-cuda_free_argmem (void *ptr)\n-{\n-  void **block = (void **) ptr;\n-  nvptx_free (block[0], (struct ptx_device *) block[1]);\n-  free (block);\n }\n \n void\n-GOMP_OFFLOAD_openacc_async_exec (void (*fn) (void *), size_t mapnum,\n+GOMP_OFFLOAD_openacc_async_exec (void (*fn) (void *),\n+\t\t\t\t size_t mapnum __attribute__((unused)),\n \t\t\t\t void **hostaddrs __attribute__((unused)),\n \t\t\t\t void **devaddrs,\n \t\t\t\t unsigned *dims, void *targ_mem_desc,\n \t\t\t\t struct goacc_asyncqueue *aq)\n {\n-  GOMP_PLUGIN_debug (0, \"  %s: prepare mappings\\n\", __FUNCTION__);\n-\n-  struct goacc_thread *thr = GOMP_PLUGIN_goacc_thread ();\n-  acc_prof_info *prof_info = thr->prof_info;\n-  acc_event_info data_event_info;\n-  acc_api_info *api_info = thr->api_info;\n-  bool profiling_p = __builtin_expect (prof_info != NULL, false);\n-\n-  void **hp = NULL;\n-  CUdeviceptr dp = 0;\n-  void **block = NULL;\n-\n-  if (mapnum > 0)\n-    {\n-      size_t s = mapnum * sizeof (void *);\n-      block = (void **) GOMP_PLUGIN_malloc (2 * sizeof (void *) + s);\n-      hp = block + 2;\n-      for (int i = 0; i < mapnum; i++)\n-\thp[i] = devaddrs[i];\n-      CUDA_CALL_ASSERT (cuMemAlloc, &dp, s);\n-      if (profiling_p)\n-\tgoacc_profiling_acc_ev_alloc (thr, (void *) dp, s);\n-    }\n-\n-  /* Copy the (device) pointers to arguments to the device (dp and hp might in\n-     fact have the same value on a unified-memory system).  */\n-  if (mapnum > 0)\n-    {\n-      if (profiling_p)\n-\t{\n-\t  prof_info->event_type = acc_ev_enqueue_upload_start;\n-\n-\t  data_event_info.data_event.event_type = prof_info->event_type;\n-\t  data_event_info.data_event.valid_bytes\n-\t    = _ACC_DATA_EVENT_INFO_VALID_BYTES;\n-\t  data_event_info.data_event.parent_construct\n-\t    = acc_construct_parallel;\n-\t  data_event_info.data_event.implicit = 1; /* Always implicit.  */\n-\t  data_event_info.data_event.tool_info = NULL;\n-\t  data_event_info.data_event.var_name = NULL;\n-\t  data_event_info.data_event.bytes = mapnum * sizeof (void *);\n-\t  data_event_info.data_event.host_ptr = hp;\n-\t  data_event_info.data_event.device_ptr = (const void *) dp;\n-\n-\t  api_info->device_api = acc_device_api_cuda;\n-\n-\t  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,\n-\t\t\t\t\t\tapi_info);\n-\t}\n-\n-      CUDA_CALL_ASSERT (cuMemcpyHtoDAsync, dp, (void *) hp,\n-\t\t\tmapnum * sizeof (void *), aq->cuda_stream);\n-      block[0] = (void *) dp;\n-\n-      struct nvptx_thread *nvthd =\n-\t(struct nvptx_thread *) GOMP_PLUGIN_acc_thread ();\n-      block[1] = (void *) nvthd->ptx_dev;\n-\n-      if (profiling_p)\n-\t{\n-\t  prof_info->event_type = acc_ev_enqueue_upload_end;\n-\t  data_event_info.data_event.event_type = prof_info->event_type;\n-\t  GOMP_PLUGIN_goacc_profiling_dispatch (prof_info, &data_event_info,\n-\t\t\t\t\t\tapi_info);\n-\t}\n-    }\n-\n-  nvptx_exec (fn, mapnum, dims, targ_mem_desc, dp, aq->cuda_stream);\n+  GOMP_PLUGIN_debug (0, \"nvptx %s\\n\", __FUNCTION__);\n \n-  if (mapnum > 0)\n-    GOMP_OFFLOAD_openacc_async_queue_callback (aq, cuda_free_argmem, block);\n+  CUdeviceptr dp = (CUdeviceptr) devaddrs;\n+  nvptx_exec (fn, dims, targ_mem_desc, dp, aq->cuda_stream);\n }\n \n void *"}, {"sha": "90b4204133a7559d37f72e181e640c5ef3acad13", "filename": "libgomp/target.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=f8332e52a498df480f72303de32ad0751ad899fe", "patch": "@@ -983,13 +983,13 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n   cbuf.chunk_cnt = -1;\n   cbuf.use_cnt = 0;\n   cbuf.buf = NULL;\n-  if (mapnum > 1 || pragma_kind == GOMP_MAP_VARS_TARGET)\n+  if (mapnum > 1 || (pragma_kind & GOMP_MAP_VARS_TARGET))\n     {\n       size_t chunks_size = (mapnum + 1) * sizeof (struct gomp_coalesce_chunk);\n       cbuf.chunks = (struct gomp_coalesce_chunk *) gomp_alloca (chunks_size);\n       cbuf.chunk_cnt = 0;\n     }\n-  if (pragma_kind == GOMP_MAP_VARS_TARGET)\n+  if (pragma_kind & GOMP_MAP_VARS_TARGET)\n     {\n       size_t align = 4 * sizeof (void *);\n       tgt_align = align;\n@@ -1262,7 +1262,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n       tgt->tgt_start = (uintptr_t) tgt->to_free;\n       tgt->tgt_end = tgt->tgt_start + sizes[0];\n     }\n-  else if (not_found_cnt || pragma_kind == GOMP_MAP_VARS_TARGET)\n+  else if (not_found_cnt || (pragma_kind & GOMP_MAP_VARS_TARGET))\n     {\n       /* Allocate tgt_align aligned tgt_size block of memory.  */\n       /* FIXME: Perhaps change interface to allocate properly aligned\n@@ -1300,7 +1300,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n     }\n \n   tgt_size = 0;\n-  if (pragma_kind == GOMP_MAP_VARS_TARGET)\n+  if (pragma_kind & GOMP_MAP_VARS_TARGET)\n     tgt_size = mapnum * sizeof (void *);\n \n   tgt->array = NULL;\n@@ -1738,7 +1738,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t  }\n     }\n \n-  if (pragma_kind == GOMP_MAP_VARS_TARGET)\n+  if (pragma_kind & GOMP_MAP_VARS_TARGET)\n     {\n       for (i = 0; i < mapnum; i++)\n \t{"}, {"sha": "9b4493ddb7f6cc3fbf78e8e26b8e1f140e5b899a", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/acc_prof-parallel-1.c", "status": "modified", "additions": 14, "deletions": 44, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-parallel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8332e52a498df480f72303de32ad0751ad899fe/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-parallel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Facc_prof-parallel-1.c?ref=f8332e52a498df480f72303de32ad0751ad899fe", "patch": "@@ -203,9 +203,7 @@ static void cb_alloc (acc_prof_info *prof_info, acc_event_info *event_info, acc_\n # error TODO\n #else\n   assert (state == 4\n-\t  || state == 6\n-\t  || state == 104\n-\t  || state == 106);\n+\t  || state == 104);\n   STATE_OP (state, ++);\n \n   if (state == 5\n@@ -217,13 +215,6 @@ static void cb_alloc (acc_prof_info *prof_info, acc_event_info *event_info, acc_\n       assert (tool_info->nested->event_info.other_event.event_type == acc_ev_enter_data_start);\n       assert (tool_info->nested->nested == NULL);\n     }\n-  else if (state == 7\n-\t   || state == 107)\n-    {\n-      assert (tool_info != NULL);\n-      assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n-      assert (tool_info->nested == NULL);\n-    }\n   else\n     abort ();\n #endif\n@@ -268,17 +259,10 @@ static void cb_free (acc_prof_info *prof_info, acc_event_info *event_info, acc_a\n #if DEVICE_INIT_INSIDE_COMPUTE_CONSTRUCT\n # error TODO\n #else\n-  assert (state == 9\n-\t  || state == 11);\n+  assert (state == 9);\n   STATE_OP (state, ++);\n \n   if (state == 10)\n-    {\n-      assert (tool_info != NULL);\n-      assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n-      assert (tool_info->nested == NULL);\n-    }\n-  else if (state == 12)\n     {\n       assert (tool_info != NULL);\n       assert (tool_info->event_info.other_event.event_type == acc_ev_compute_construct_start);\n@@ -449,19 +433,9 @@ static void cb_exit_data_start (acc_prof_info *prof_info, acc_event_info *event_\n {\n   DEBUG_printf (\"%s\\n\", __FUNCTION__);\n \n+  assert (state == 8\n #if ASYNC_EXIT_DATA\n-  if (acc_async != acc_async_sync)\n-    {\n-      /* Compensate for the deferred 'acc_ev_free'.  */\n-      state += 1;\n-    }\n-#else\n-# error TODO\n-#endif\n-\n-  assert (state == 10\n-#if ASYNC_EXIT_DATA\n-\t  || state == 110\n+\t  || state == 108\n #endif\n \t  );\n   STATE_OP (state, ++);\n@@ -525,9 +499,9 @@ static void cb_exit_data_end (acc_prof_info *prof_info, acc_event_info *event_in\n {\n   DEBUG_printf (\"%s\\n\", __FUNCTION__);\n \n-  assert (state == 12\n+  assert (state == 10\n #if ASYNC_EXIT_DATA\n-\t  || state == 112\n+\t  || state == 110\n #endif\n \t  );\n   STATE_OP (state, ++);\n@@ -654,13 +628,9 @@ static void cb_compute_construct_end (acc_prof_info *prof_info, acc_event_info *\n     {\n       /* Compensate for the missing 'acc_ev_enter_data_end'.  */\n       state += 1;\n-      /* Compensate for the missing 'acc_ev_alloc'.  */\n-      state += 1;\n       /* Compensate for the missing 'acc_ev_enqueue_launch_start' and\n \t 'acc_ev_enqueue_launch_end'.  */\n       state += 2;\n-      /* Compensate for the missing 'acc_ev_free'.  */\n-      state += 1;\n       /* Compensate for the missing 'acc_ev_exit_data_start'.  */\n       state += 1;\n       /* Compensate for the missing 'acc_ev_free'.  */\n@@ -676,8 +646,8 @@ static void cb_compute_construct_end (acc_prof_info *prof_info, acc_event_info *\n       state += 2;\n     }\n #endif\n-  assert (state == 13\n-\t  || state == 113);\n+  assert (state == 11\n+\t  || state == 111);\n   STATE_OP (state, ++);\n \n   assert (tool_info != NULL);\n@@ -731,8 +701,8 @@ static void cb_enqueue_launch_start (acc_prof_info *prof_info, acc_event_info *e\n \n   assert (acc_device_type != acc_device_host);\n \n-  assert (state == 7\n-\t  || state == 107);\n+  assert (state == 6\n+\t  || state == 106);\n   STATE_OP (state, ++);\n \n   assert (tool_info != NULL);\n@@ -800,8 +770,8 @@ static void cb_enqueue_launch_end (acc_prof_info *prof_info, acc_event_info *eve\n \n   assert (acc_device_type != acc_device_host);\n \n-  assert (state == 8\n-\t  || state == 108);\n+  assert (state == 7\n+\t  || state == 107);\n   STATE_OP (state, ++);\n \n   assert (tool_info != NULL);\n@@ -891,7 +861,7 @@ int main()\n     }\n     assert (state_init == 5);\n   }\n-  assert (state == 14);\n+  assert (state == 12);\n \n   STATE_OP (state, = 100);\n \n@@ -908,7 +878,7 @@ int main()\n #pragma acc wait\n     assert (state_init == 105);\n   }\n-  assert (state == 114);\n+  assert (state == 112);\n \n   return 0;\n }"}]}