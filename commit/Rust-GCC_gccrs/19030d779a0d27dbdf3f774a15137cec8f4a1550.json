{"sha": "19030d779a0d27dbdf3f774a15137cec8f4a1550", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkwMzBkNzc5YTBkMjdkYmRmM2Y3NzRhMTUxMzdjZWM4ZjRhMTU1MA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-02-11T02:12:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-02-11T02:12:53Z"}, "message": "re PR c++/41896 ([c++0x] Segfault because of a nested lambda function)\n\n\tPR c++/41896\n\t* semantics.c (outer_lambda_capture_p): Revert.\n\t(add_capture): Only finish_member_declaration if\n\twe're in the lambda class.\n\t(register_capture_members): New.\n\t* cp-tree.h: Declare it.\n\t* parser.c (cp_parser_lambda_expression): Call it.\n\nFrom-SVN: r156678", "tree": {"sha": "c026a8558e03de540d0342d079d43fa8908967e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c026a8558e03de540d0342d079d43fa8908967e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19030d779a0d27dbdf3f774a15137cec8f4a1550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19030d779a0d27dbdf3f774a15137cec8f4a1550", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19030d779a0d27dbdf3f774a15137cec8f4a1550", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19030d779a0d27dbdf3f774a15137cec8f4a1550/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94d7ad5fa7705d68d6c05207a871397d9ec2a6ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d7ad5fa7705d68d6c05207a871397d9ec2a6ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94d7ad5fa7705d68d6c05207a871397d9ec2a6ee"}], "stats": {"total": 41, "additions": 34, "deletions": 7}, "files": [{"sha": "f42f59e5ce6d2c0662abb1ac5cdc7d8090507e21", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19030d779a0d27dbdf3f774a15137cec8f4a1550/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19030d779a0d27dbdf3f774a15137cec8f4a1550/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=19030d779a0d27dbdf3f774a15137cec8f4a1550", "patch": "@@ -1,3 +1,13 @@\n+2010-02-10  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/41896\n+\t* semantics.c (outer_lambda_capture_p): Revert.\n+\t(add_capture): Only finish_member_declaration if\n+\twe're in the lambda class.\n+\t(register_capture_members): New.\n+\t* cp-tree.h: Declare it.\n+\t* parser.c (cp_parser_lambda_expression): Call it.\n+\n 2010-02-10  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/41896"}, {"sha": "f32c6e86e5c73d875d815a1c803b3e3e0728e549", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19030d779a0d27dbdf3f774a15137cec8f4a1550/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19030d779a0d27dbdf3f774a15137cec8f4a1550/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=19030d779a0d27dbdf3f774a15137cec8f4a1550", "patch": "@@ -5193,6 +5193,7 @@ extern tree lambda_function\t\t\t(tree);\n extern void apply_lambda_return_type            (tree, tree);\n extern tree add_capture                         (tree, tree, tree, bool, bool);\n extern tree add_default_capture                 (tree, tree, tree);\n+extern void register_capture_members\t\t(tree);\n extern tree lambda_expr_this_capture            (tree);\n extern void maybe_add_lambda_conv_op            (tree);\n "}, {"sha": "690f2c05eb0028c6c701da4697d960f08969d924", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19030d779a0d27dbdf3f774a15137cec8f4a1550/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19030d779a0d27dbdf3f774a15137cec8f4a1550/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=19030d779a0d27dbdf3f774a15137cec8f4a1550", "patch": "@@ -7072,22 +7072,26 @@ cp_parser_lambda_expression (cp_parser* parser)\n      it now.  */\n   push_deferring_access_checks (dk_no_deferred);\n \n+  cp_parser_lambda_introducer (parser, lambda_expr);\n+\n   type = begin_lambda_type (lambda_expr);\n \n   record_lambda_scope (lambda_expr);\n \n   /* Do this again now that LAMBDA_EXPR_EXTRA_SCOPE is set.  */\n   determine_visibility (TYPE_NAME (type));\n \n+  /* Now that we've started the type, add the capture fields for any\n+     explicit captures.  */\n+  register_capture_members (LAMBDA_EXPR_CAPTURE_LIST (lambda_expr));\n+\n   {\n     /* Inside the class, surrounding template-parameter-lists do not apply.  */\n     unsigned int saved_num_template_parameter_lists\n         = parser->num_template_parameter_lists;\n \n     parser->num_template_parameter_lists = 0;\n \n-    cp_parser_lambda_introducer (parser, lambda_expr);\n-\n     /* By virtue of defining a local class, a lambda expression has access to\n        the private variables of enclosing classes.  */\n "}, {"sha": "985e2c0f4648c79ad6b0d359217937aed44fb7f9", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19030d779a0d27dbdf3f774a15137cec8f4a1550/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19030d779a0d27dbdf3f774a15137cec8f4a1550/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=19030d779a0d27dbdf3f774a15137cec8f4a1550", "patch": "@@ -2714,9 +2714,8 @@ outer_lambda_capture_p (tree decl)\n {\n   return (TREE_CODE (decl) == FIELD_DECL\n \t  && LAMBDA_TYPE_P (DECL_CONTEXT (decl))\n-\t  /* Using current_class_type here causes problems with uses in a\n-\t     nested lambda-introducer; see 41896.  */\n-\t  && DECL_CONTEXT (current_function_decl) != DECL_CONTEXT (decl));\n+\t  && (!current_class_type\n+\t      || !DERIVED_FROM_P (DECL_CONTEXT (decl), current_class_type)));\n }\n \n /* ID_EXPRESSION is a representation of parsed, but unprocessed,\n@@ -5690,8 +5689,9 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n        always visible.  */\n     DECL_NORMAL_CAPTURE_P (member) = true;\n \n-  /* Add it to the appropriate closure class.  */\n-  finish_member_declaration (member);\n+  /* Add it to the appropriate closure class if we've started it.  */\n+  if (current_class_type && current_class_type == TREE_TYPE (lambda))\n+    finish_member_declaration (member);\n \n   LAMBDA_EXPR_CAPTURE_LIST (lambda)\n     = tree_cons (member, initializer, LAMBDA_EXPR_CAPTURE_LIST (lambda));\n@@ -5706,6 +5706,18 @@ add_capture (tree lambda, tree id, tree initializer, bool by_reference_p,\n   return member;\n }\n \n+/* Register all the capture members on the list CAPTURES, which is the\n+   LAMBDA_EXPR_CAPTURE_LIST for the lambda after the introducer.  */\n+\n+void register_capture_members (tree captures)\n+{\n+  if (captures)\n+    {\n+      register_capture_members (TREE_CHAIN (captures));\n+      finish_member_declaration (TREE_PURPOSE (captures));\n+    }\n+}\n+\n /* Given a FIELD_DECL decl belonging to a closure type, return a\n    COMPONENT_REF of it relative to the 'this' parameter of the op() for\n    that type.  */"}]}