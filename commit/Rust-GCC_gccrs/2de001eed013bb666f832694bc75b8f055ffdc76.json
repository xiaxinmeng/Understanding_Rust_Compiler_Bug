{"sha": "2de001eed013bb666f832694bc75b8f055ffdc76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRlMDAxZWVkMDEzYmI2NjZmODMyNjk0YmM3NWI4ZjA1NWZmZGM3Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-07-06T08:15:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-07-06T08:15:28Z"}, "message": "[6/7] Explicitly classify vector loads and stores\n\nThis is the main patch in the series.  It adds a new enum and routines\nfor classifying a vector load or store implementation.\n\nOriginally there were three motivations:\n\n      (1) Reduce cut-&-paste\n\n      (2) Make the chosen vectorisation strategy more obvious.  At the\n          moment this is derived implicitly from various other bits of\n          state (GROUPED, STRIDED, SLP, etc.)\n\n      (3) Decouple the vectorisation strategy from those other bits of state,\n          so that there can be a choice of implementation for a given scalar\n          statement.  The specific problem here is that we class:\n\n              for (...)\n                {\n                  ... = a[i * x];\n                  ... = a[i * x + 1];\n                }\n\n          as \"strided and grouped\" but:\n\n              for (...)\n                {\n                  ... = a[i * 7];\n                  ... = a[i * 7 + 1];\n                }\n\n          as \"non-strided and grouped\".  Before the patch, \"strided and\n          grouped\" loads would always try to use separate scalar loads\n          while \"non-strided and grouped\" loads would always try to use\n          load-and-permute.  But load-and-permute is never supported for\n          a group size of 7, so the effect was that the first loop was\n          vectorisable and the second wasn't.  It seemed odd that not\n          knowing x (but accepting it could be 7) would allow more\n          optimisation opportunities than knowing x is 7.\n\nUnfortunately, it looks like we underestimate the cost of separate\nscalar accesses on at least aarch64, so I've disabled (3) for now;\nsee the \"if\" statement at the end of get_load_store_type.  I think\nthe patch still does (1) and (2), so that's the justification for\nit in its current form.  It also means that (3) is now simply a\ncase of removing the FIXME code, once the cost model problems have\nbeen sorted out.  (I did wonder about adding a --param, but that\nseems overkill.  I hope to get back to this during GCC 7 stage 1.)\n\nTested on aarch64-linux-gnu and x86_64-linux-gnu.\n\ngcc/\n\t* tree-vectorizer.h (vect_memory_access_type): New enum.\n\t(_stmt_vec_info): Add a memory_access_type field.\n\t(STMT_VINFO_MEMORY_ACCESS_TYPE): New macro.\n\t(vect_model_store_cost): Take an access type instead of a boolean.\n\t(vect_model_load_cost): Likewise.\n\t* tree-vect-slp.c (vect_analyze_slp_cost_1): Update calls to\n\tvect_model_store_cost and vect_model_load_cost.\n\t* tree-vect-stmts.c (vec_load_store_type): New enum.\n\t(vect_model_store_cost): Take an access type instead of a\n\tstore_lanes_p boolean.  Simplify tests.\n\t(vect_model_load_cost): Likewise, but for load_lanes_p.\n\t(get_group_load_store_type, get_load_store_type): New functions.\n\t(vectorizable_store): Use get_load_store_type.  Record the access\n\ttype in STMT_VINFO_MEMORY_ACCESS_TYPE.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_mask_load_store): Likewise.  Replace is_store\n\tvariable with vls_type.\n\nFrom-SVN: r238038", "tree": {"sha": "3d3efc52fc8ace351e1981643b2b914a2edab7fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d3efc52fc8ace351e1981643b2b914a2edab7fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2de001eed013bb666f832694bc75b8f055ffdc76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de001eed013bb666f832694bc75b8f055ffdc76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de001eed013bb666f832694bc75b8f055ffdc76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de001eed013bb666f832694bc75b8f055ffdc76/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4fb8ba9d357297206678a3e3eacf9292148eafb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb8ba9d357297206678a3e3eacf9292148eafb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb8ba9d357297206678a3e3eacf9292148eafb5"}], "stats": {"total": 581, "additions": 382, "deletions": 199}, "files": [{"sha": "2e309344c066e0c70c8078d3610c677c71ba98f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de001eed013bb666f832694bc75b8f055ffdc76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de001eed013bb666f832694bc75b8f055ffdc76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2de001eed013bb666f832694bc75b8f055ffdc76", "patch": "@@ -1,3 +1,23 @@\n+2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (vect_memory_access_type): New enum.\n+\t(_stmt_vec_info): Add a memory_access_type field.\n+\t(STMT_VINFO_MEMORY_ACCESS_TYPE): New macro.\n+\t(vect_model_store_cost): Take an access type instead of a boolean.\n+\t(vect_model_load_cost): Likewise.\n+\t* tree-vect-slp.c (vect_analyze_slp_cost_1): Update calls to\n+\tvect_model_store_cost and vect_model_load_cost.\n+\t* tree-vect-stmts.c (vec_load_store_type): New enum.\n+\t(vect_model_store_cost): Take an access type instead of a\n+\tstore_lanes_p boolean.  Simplify tests.\n+\t(vect_model_load_cost): Likewise, but for load_lanes_p.\n+\t(get_group_load_store_type, get_load_store_type): New functions.\n+\t(vectorizable_store): Use get_load_store_type.  Record the access\n+\ttype in STMT_VINFO_MEMORY_ACCESS_TYPE.\n+\t(vectorizable_load): Likewise.\n+\t(vectorizable_mask_load_store): Likewise.  Replace is_store\n+\tvariable with vls_type.\n+\n 2016-07-06  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vect_grouped_load_supported): Add a"}, {"sha": "4de8593308c15127ef0137fb0f2ad3c310f6100f", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de001eed013bb666f832694bc75b8f055ffdc76/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de001eed013bb666f832694bc75b8f055ffdc76/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2de001eed013bb666f832694bc75b8f055ffdc76", "patch": "@@ -1490,9 +1490,13 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n   stmt_info = vinfo_for_stmt (stmt);\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n+      vect_memory_access_type memory_access_type\n+\t= (STMT_VINFO_STRIDED_P (stmt_info)\n+\t   ? VMAT_STRIDED_SLP\n+\t   : VMAT_CONTIGUOUS);\n       if (DR_IS_WRITE (STMT_VINFO_DATA_REF (stmt_info)))\n-\tvect_model_store_cost (stmt_info, ncopies_for_cost, false,\n-\t\t\t       vect_uninitialized_def,\n+\tvect_model_store_cost (stmt_info, ncopies_for_cost,\n+\t\t\t       memory_access_type, vect_uninitialized_def,\n \t\t\t       node, prologue_cost_vec, body_cost_vec);\n       else\n \t{\n@@ -1515,8 +1519,9 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t      ncopies_for_cost *= SLP_INSTANCE_UNROLLING_FACTOR (instance);\n \t    }\n \t  /* Record the cost for the vector loads.  */\n-\t  vect_model_load_cost (stmt_info, ncopies_for_cost, false,\n-\t\t\t\tnode, prologue_cost_vec, body_cost_vec);\n+\t  vect_model_load_cost (stmt_info, ncopies_for_cost,\n+\t\t\t\tmemory_access_type, node, prologue_cost_vec,\n+\t\t\t\tbody_cost_vec);\n \t  return;\n \t}\n     }"}, {"sha": "16bec2b4d350be59d81b6346af415f464b46bb21", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 318, "deletions": 192, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de001eed013bb666f832694bc75b8f055ffdc76/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de001eed013bb666f832694bc75b8f055ffdc76/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2de001eed013bb666f832694bc75b8f055ffdc76", "patch": "@@ -52,6 +52,14 @@ along with GCC; see the file COPYING3.  If not see\n /* For lang_hooks.types.type_for_mode.  */\n #include \"langhooks.h\"\n \n+/* Says whether a statement is a load, a store of a vectorized statement\n+   result, or a store of an invariant value.  */\n+enum vec_load_store_type {\n+  VLS_LOAD,\n+  VLS_STORE,\n+  VLS_STORE_INVARIANT\n+};\n+\n /* Return the vectorized type for the given statement.  */\n \n tree\n@@ -873,8 +881,8 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n \n void\n vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n-\t\t       bool store_lanes_p, enum vect_def_type dt,\n-\t\t       slp_tree slp_node,\n+\t\t       vect_memory_access_type memory_access_type,\n+\t\t       enum vect_def_type dt, slp_tree slp_node,\n \t\t       stmt_vector_for_cost *prologue_cost_vec,\n \t\t       stmt_vector_for_cost *body_cost_vec)\n {\n@@ -903,14 +911,9 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   /* We assume that the cost of a single store-lanes instruction is\n      equivalent to the cost of GROUP_SIZE separate stores.  If a grouped\n      access is instead being provided by a permute-and-store operation,\n-     include the cost of the permutes.\n-\n-     For SLP, the caller has already counted the permutation, if any.  */\n-  if (grouped_access_p\n-      && first_stmt_p\n-      && !store_lanes_p\n-      && !STMT_VINFO_STRIDED_P (stmt_info)\n-      && !slp_node)\n+     include the cost of the permutes.  */\n+  if (first_stmt_p\n+      && memory_access_type == VMAT_CONTIGUOUS_PERMUTE)\n     {\n       /* Uses a high and low interleave or shuffle operations for each\n \t needed permute.  */\n@@ -927,17 +930,16 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   /* Costs of the stores.  */\n-  if (STMT_VINFO_STRIDED_P (stmt_info) && !slp_node)\n-    {\n-      /* N scalar stores plus extracting the elements.  */\n-      inside_cost += record_stmt_cost (body_cost_vec,\n-\t\t\t\t       ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n-\t\t\t\t       scalar_store, stmt_info, 0, vect_body);\n-    }\n+  if (memory_access_type == VMAT_ELEMENTWISE)\n+    /* N scalar stores plus extracting the elements.  */\n+    inside_cost += record_stmt_cost (body_cost_vec,\n+\t\t\t\t     ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t     scalar_store, stmt_info, 0, vect_body);\n   else\n     vect_get_store_cost (dr, ncopies, &inside_cost, body_cost_vec);\n \n-  if (STMT_VINFO_STRIDED_P (stmt_info))\n+  if (memory_access_type == VMAT_ELEMENTWISE\n+      || memory_access_type == VMAT_STRIDED_SLP)\n     inside_cost += record_stmt_cost (body_cost_vec,\n \t\t\t\t     ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n \t\t\t\t     vec_to_scalar, stmt_info, 0, vect_body);\n@@ -1011,7 +1013,8 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \n void\n vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n-\t\t      bool load_lanes_p, slp_tree slp_node,\n+\t\t      vect_memory_access_type memory_access_type,\n+\t\t      slp_tree slp_node,\n \t\t      stmt_vector_for_cost *prologue_cost_vec,\n \t\t      stmt_vector_for_cost *body_cost_vec)\n {\n@@ -1036,14 +1039,9 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n   /* We assume that the cost of a single load-lanes instruction is\n      equivalent to the cost of GROUP_SIZE separate loads.  If a grouped\n      access is instead being provided by a load-and-permute operation,\n-     include the cost of the permutes.\n-\n-     For SLP, the caller has already counted the permutation, if any.  */\n-  if (grouped_access_p\n-      && first_stmt_p\n-      && !load_lanes_p\n-      && !STMT_VINFO_STRIDED_P (stmt_info)\n-      && !slp_node)\n+     include the cost of the permutes.  */\n+  if (first_stmt_p\n+      && memory_access_type == VMAT_CONTIGUOUS_PERMUTE)\n     {\n       /* Uses an even and odd extract operations or shuffle operations\n \t for each needed permute.  */\n@@ -1059,7 +1057,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n     }\n \n   /* The loads themselves.  */\n-  if (STMT_VINFO_STRIDED_P (stmt_info) && !slp_node)\n+  if (memory_access_type == VMAT_ELEMENTWISE)\n     {\n       /* N scalar loads plus gathering them into a vector.  */\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -1071,7 +1069,8 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n     vect_get_load_cost (dr, ncopies, first_stmt_p,\n \t\t\t&inside_cost, &prologue_cost, \n \t\t\tprologue_cost_vec, body_cost_vec, true);\n-  if (STMT_VINFO_STRIDED_P (stmt_info))\n+  if (memory_access_type == VMAT_ELEMENTWISE\n+      || memory_access_type == VMAT_STRIDED_SLP)\n     inside_cost += record_stmt_cost (body_cost_vec, ncopies, vec_construct,\n \t\t\t\t     stmt_info, 0, vect_body);\n \n@@ -1674,6 +1673,209 @@ static tree permute_vec_elements (tree, tree, tree, gimple *,\n \t\t\t\t  gimple_stmt_iterator *);\n \n \n+/* A subroutine of get_load_store_type, with a subset of the same\n+   arguments.  Handle the case where STMT is part of a grouped load\n+   or store.\n+\n+   For stores, the statements in the group are all consecutive\n+   and there is no gap at the end.  For loads, the statements in the\n+   group might not be consecutive; there can be gaps between statements\n+   as well as at the end.  */\n+\n+static bool\n+get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n+\t\t\t   vec_load_store_type vls_type,\n+\t\t\t   vect_memory_access_type *memory_access_type)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  vec_info *vinfo = stmt_info->vinfo;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n+  gimple *first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n+  unsigned int group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+  bool single_element_p = (stmt == first_stmt\n+\t\t\t   && !GROUP_NEXT_ELEMENT (stmt_info));\n+  unsigned HOST_WIDE_INT gap = GROUP_GAP (vinfo_for_stmt (first_stmt));\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+  /* True if the vectorized statements would access beyond the last\n+     statement in the group.  */\n+  bool overrun_p = false;\n+\n+  /* True if we can cope with such overrun by peeling for gaps, so that\n+     there is at least one final scalar iteration after the vector loop.  */\n+  bool can_overrun_p = (vls_type == VLS_LOAD && loop_vinfo && !loop->inner);\n+\n+  /* There can only be a gap at the end of the group if the stride is\n+     known at compile time.  */\n+  gcc_assert (!STMT_VINFO_STRIDED_P (stmt_info) || gap == 0);\n+\n+  /* Stores can't yet have gaps.  */\n+  gcc_assert (slp || vls_type == VLS_LOAD || gap == 0);\n+\n+  if (slp)\n+    {\n+      if (STMT_VINFO_STRIDED_P (stmt_info))\n+\t{\n+\t  /* Try to use consecutive accesses of GROUP_SIZE elements,\n+\t     separated by the stride, until we have a complete vector.\n+\t     Fall back to scalar accesses if that isn't possible.  */\n+\t  if (nunits % group_size == 0)\n+\t    *memory_access_type = VMAT_STRIDED_SLP;\n+\t  else\n+\t    *memory_access_type = VMAT_ELEMENTWISE;\n+\t}\n+      else\n+\t{\n+\t  overrun_p = loop_vinfo && gap != 0;\n+\t  if (overrun_p && vls_type != VLS_LOAD)\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"Grouped store with gaps requires\"\n+\t\t\t       \" non-consecutive accesses\\n\");\n+\t      return false;\n+\t    }\n+\t  if (overrun_p && !can_overrun_p)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Peeling for outer loop is not supported\\n\");\n+\t      return false;\n+\t    }\n+\t  *memory_access_type = VMAT_CONTIGUOUS;\n+\t}\n+    }\n+  else\n+    {\n+      /* We can always handle this case using elementwise accesses,\n+\t but see if something more efficient is available.  */\n+      *memory_access_type = VMAT_ELEMENTWISE;\n+\n+      /* If there is a gap at the end of the group then these optimizations\n+\t would access excess elements in the last iteration.  */\n+      bool would_overrun_p = (gap != 0);\n+      if (!STMT_VINFO_STRIDED_P (stmt_info)\n+\t  && (can_overrun_p || !would_overrun_p))\n+\t{\n+\t  /* First try using LOAD/STORE_LANES.  */\n+\t  if (vls_type == VLS_LOAD\n+\t      ? vect_load_lanes_supported (vectype, group_size)\n+\t      : vect_store_lanes_supported (vectype, group_size))\n+\t    {\n+\t      *memory_access_type = VMAT_LOAD_STORE_LANES;\n+\t      overrun_p = would_overrun_p;\n+\t    }\n+\n+\t  /* If that fails, try using permuting loads.  */\n+\t  if (*memory_access_type == VMAT_ELEMENTWISE\n+\t      && (vls_type == VLS_LOAD\n+\t\t  ? vect_grouped_load_supported (vectype, single_element_p,\n+\t\t\t\t\t\t group_size)\n+\t\t  : vect_grouped_store_supported (vectype, group_size)))\n+\t    {\n+\t      *memory_access_type = VMAT_CONTIGUOUS_PERMUTE;\n+\t      overrun_p = would_overrun_p;\n+\t    }\n+\t}\n+    }\n+\n+  if (vls_type != VLS_LOAD && first_stmt == stmt)\n+    {\n+      /* STMT is the leader of the group. Check the operands of all the\n+\t stmts of the group.  */\n+      gimple *next_stmt = GROUP_NEXT_ELEMENT (stmt_info);\n+      while (next_stmt)\n+\t{\n+\t  gcc_assert (gimple_assign_single_p (next_stmt));\n+\t  tree op = gimple_assign_rhs1 (next_stmt);\n+\t  gimple *def_stmt;\n+\t  enum vect_def_type dt;\n+\t  if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"use not simple.\\n\");\n+\t      return false;\n+\t    }\n+\t  next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t}\n+    }\n+\n+  if (overrun_p)\n+    {\n+      gcc_assert (can_overrun_p);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"Data access with gaps requires scalar \"\n+\t\t\t \"epilogue loop\\n\");\n+      LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = true;\n+    }\n+\n+  return true;\n+}\n+\n+/* Analyze load or store statement STMT of type VLS_TYPE.  Return true\n+   if there is a memory access type that the vectorized form can use,\n+   storing it in *MEMORY_ACCESS_TYPE if so.  If we decide to use gathers\n+   or scatters, fill in GS_INFO accordingly.\n+\n+   SLP says whether we're performing SLP rather than loop vectorization.\n+   VECTYPE is the vector type that the vectorized statements will use.  */\n+\n+static bool\n+get_load_store_type (gimple *stmt, tree vectype, bool slp,\n+\t\t     vec_load_store_type vls_type,\n+\t\t     vect_memory_access_type *memory_access_type,\n+\t\t     gather_scatter_info *gs_info)\n+{\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  vec_info *vinfo = stmt_info->vinfo;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+    {\n+      *memory_access_type = VMAT_GATHER_SCATTER;\n+      gimple *def_stmt;\n+      if (!vect_check_gather_scatter (stmt, loop_vinfo, gs_info))\n+\tgcc_unreachable ();\n+      else if (!vect_is_simple_use (gs_info->offset, vinfo, &def_stmt,\n+\t\t\t\t    &gs_info->offset_dt,\n+\t\t\t\t    &gs_info->offset_vectype))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"%s index use not simple.\\n\",\n+\t\t\t     vls_type == VLS_LOAD ? \"gather\" : \"scatter\");\n+\t  return false;\n+\t}\n+    }\n+  else if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+    {\n+      if (!get_group_load_store_type (stmt, vectype, slp, vls_type,\n+\t\t\t\t      memory_access_type))\n+\treturn false;\n+    }\n+  else if (STMT_VINFO_STRIDED_P (stmt_info))\n+    {\n+      gcc_assert (!slp);\n+      *memory_access_type = VMAT_ELEMENTWISE;\n+    }\n+  else\n+    *memory_access_type = VMAT_CONTIGUOUS;\n+\n+  /* FIXME: At the moment the cost model seems to underestimate the\n+     cost of using elementwise accesses.  This check preserves the\n+     traditional behavior until that can be fixed.  */\n+  if (*memory_access_type == VMAT_ELEMENTWISE\n+      && !STMT_VINFO_STRIDED_P (stmt_info))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not falling back to elementwise accesses\\n\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n /* Function vectorizable_mask_load_store.\n \n    Check if STMT performs a conditional load or store that can be vectorized.\n@@ -1705,7 +1907,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   int i, j;\n   bool inv_p;\n   gather_scatter_info gs_info;\n-  bool is_store;\n+  vec_load_store_type vls_type;\n   tree mask;\n   gimple *def_stmt;\n   enum vect_def_type dt;\n@@ -1716,7 +1918,6 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n   gcc_assert (ncopies >= 1);\n \n-  is_store = gimple_call_internal_fn (stmt) == IFN_MASK_STORE;\n   mask = gimple_call_arg (stmt, 2);\n \n   if (TREE_CODE (TREE_TYPE (mask)) != BOOLEAN_TYPE)\n@@ -1743,12 +1944,6 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   elem_type = TREE_TYPE (vectype);\n \n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    return false;\n-\n-  if (STMT_VINFO_STRIDED_P (stmt_info))\n-    return false;\n-\n   if (TREE_CODE (mask) != SSA_NAME)\n     return false;\n \n@@ -1762,27 +1957,26 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n       || TYPE_VECTOR_SUBPARTS (mask_vectype) != TYPE_VECTOR_SUBPARTS (vectype))\n     return false;\n \n-  if (is_store)\n+  if (gimple_call_internal_fn (stmt) == IFN_MASK_STORE)\n     {\n       tree rhs = gimple_call_arg (stmt, 3);\n       if (!vect_is_simple_use (rhs, loop_vinfo, &def_stmt, &dt, &rhs_vectype))\n \treturn false;\n+      if (dt == vect_constant_def || dt == vect_external_def)\n+\tvls_type = VLS_STORE_INVARIANT;\n+      else\n+\tvls_type = VLS_STORE;\n     }\n+  else\n+    vls_type = VLS_LOAD;\n \n-  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n-    {\n-      gimple *def_stmt;\n-      if (!vect_check_gather_scatter (stmt, loop_vinfo, &gs_info))\n-\tgcc_unreachable ();\n-      if (!vect_is_simple_use (gs_info.offset, loop_vinfo, &def_stmt,\n-\t\t\t       &gs_info.offset_dt, &gs_info.offset_vectype))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"gather index use not simple.\");\n-\t  return false;\n-\t}\n+  vect_memory_access_type memory_access_type;\n+  if (!get_load_store_type (stmt, vectype, false, vls_type,\n+\t\t\t    &memory_access_type, &gs_info))\n+    return false;\n \n+  if (memory_access_type == VMAT_GATHER_SCATTER)\n+    {\n       tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n       tree masktype\n \t= TREE_VALUE (TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arglist))));\n@@ -1794,32 +1988,43 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  return false;\n \t}\n     }\n+  else if (memory_access_type != VMAT_CONTIGUOUS)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"unsupported access type for masked %s.\\n\",\n+\t\t\t vls_type == VLS_LOAD ? \"load\" : \"store\");\n+      return false;\n+    }\n   else if (tree_int_cst_compare (nested_in_vect_loop\n \t\t\t\t ? STMT_VINFO_DR_STEP (stmt_info)\n \t\t\t\t : DR_STEP (dr), size_zero_node) <= 0)\n     return false;\n   else if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n \t   || !can_vec_mask_load_store_p (TYPE_MODE (vectype),\n \t\t\t\t\t  TYPE_MODE (mask_vectype),\n-\t\t\t\t\t  !is_store)\n+\t\t\t\t\t  vls_type == VLS_LOAD)\n \t   || (rhs_vectype\n \t       && !useless_type_conversion_p (vectype, rhs_vectype)))\n     return false;\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n+      STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) = memory_access_type;\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n-      if (is_store)\n-\tvect_model_store_cost (stmt_info, ncopies, false, dt,\n-\t\t\t       NULL, NULL, NULL);\n+      if (vls_type == VLS_LOAD)\n+\tvect_model_load_cost (stmt_info, ncopies, memory_access_type,\n+\t\t\t      NULL, NULL, NULL);\n       else\n-\tvect_model_load_cost (stmt_info, ncopies, false, NULL, NULL, NULL);\n+\tvect_model_store_cost (stmt_info, ncopies, memory_access_type,\n+\t\t\t       dt, NULL, NULL, NULL);\n       return true;\n     }\n+  gcc_assert (memory_access_type == STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info));\n \n   /** Transform.  **/\n \n-  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+  if (memory_access_type == VMAT_GATHER_SCATTER)\n     {\n       tree vec_oprnd0 = NULL_TREE, op;\n       tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n@@ -1993,7 +2198,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n       gsi_replace (gsi, new_stmt, true);\n       return true;\n     }\n-  else if (is_store)\n+  else if (vls_type != VLS_LOAD)\n     {\n       tree vec_rhs = NULL_TREE, vec_mask = NULL_TREE;\n       prev_stmt_info = NULL;\n@@ -2102,7 +2307,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t}\n     }\n \n-  if (!is_store)\n+  if (vls_type == VLS_LOAD)\n     {\n       /* Ensure that even with -fno-tree-dce the scalar MASK_LOAD is removed\n \t from the IL.  */\n@@ -5188,9 +5393,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   gimple *ptr_incr = NULL;\n   int ncopies;\n   int j;\n-  gimple *next_stmt, *first_stmt = NULL;\n-  bool grouped_store = false;\n-  bool store_lanes_p = false;\n+  gimple *next_stmt, *first_stmt;\n+  bool grouped_store;\n   unsigned int group_size, i;\n   vec<tree> dr_chain = vNULL;\n   vec<tree> oprnds = vNULL;\n@@ -5208,6 +5412,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   enum vect_def_type scatter_src_dt = vect_unknown_def_type;\n   gimple *new_stmt;\n   int vf;\n+  vec_load_store_type vls_type;\n \n   if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n@@ -5280,6 +5485,11 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       return false;\n     }\n \n+  if (dt == vect_constant_def || dt == vect_external_def)\n+    vls_type = VLS_STORE_INVARIANT;\n+  else\n+    vls_type = VLS_STORE;\n+\n   if (rhs_vectype && !useless_type_conversion_p (vectype, rhs_vectype))\n     return false;\n \n@@ -5309,7 +5519,6 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n       if (negative)\n \t{\n-\t  gcc_assert (!grouped_store);\n \t  alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n \t  if (alignment_support_scheme != dr_aligned\n \t      && alignment_support_scheme != dr_unaligned_supported)\n@@ -5331,70 +5540,28 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n     }\n \n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    {\n-      grouped_store = true;\n-      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n-      group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-      if (!slp && !STMT_VINFO_STRIDED_P (stmt_info))\n-\t{\n-\t  if (vect_store_lanes_supported (vectype, group_size))\n-\t    store_lanes_p = true;\n-\t  else if (!vect_grouped_store_supported (vectype, group_size))\n-\t    return false;\n-\t}\n-\n-      if (first_stmt == stmt)\n-\t{\n-          /* STMT is the leader of the group. Check the operands of all the\n-             stmts of the group.  */\n-          next_stmt = GROUP_NEXT_ELEMENT (stmt_info);\n-          while (next_stmt)\n-            {\n-\t      gcc_assert (gimple_assign_single_p (next_stmt));\n-\t      op = gimple_assign_rhs1 (next_stmt);\n-              if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt))\n-                {\n-                  if (dump_enabled_p ())\n-                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                     \"use not simple.\\n\");\n-                  return false;\n-                }\n-              next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n-            }\n-        }\n-    }\n-\n-  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n-    {\n-      gimple *def_stmt;\n-      if (!vect_check_gather_scatter (stmt, loop_vinfo, &gs_info))\n-\tgcc_unreachable ();\n-      if (!vect_is_simple_use (gs_info.offset, vinfo, &def_stmt,\n-\t\t\t       &gs_info.offset_dt, &gs_info.offset_vectype))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"scatter index use not simple.\");\n-\t  return false;\n-\t}\n-    }\n+  vect_memory_access_type memory_access_type;\n+  if (!get_load_store_type (stmt, vectype, slp, vls_type,\n+\t\t\t    &memory_access_type, &gs_info))\n+    return false;\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n+      STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) = memory_access_type;\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n       /* The SLP costs are calculated during SLP analysis.  */\n       if (!PURE_SLP_STMT (stmt_info))\n-\tvect_model_store_cost (stmt_info, ncopies, store_lanes_p, dt,\n+\tvect_model_store_cost (stmt_info, ncopies, memory_access_type, dt,\n \t\t\t       NULL, NULL, NULL);\n       return true;\n     }\n+  gcc_assert (memory_access_type == STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info));\n \n   /** Transform.  **/\n \n   ensure_base_align (stmt_info, dr);\n \n-  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+  if (memory_access_type == VMAT_GATHER_SCATTER)\n     {\n       tree vec_oprnd0 = NULL_TREE, vec_oprnd1 = NULL_TREE, op, src;\n       tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n@@ -5534,8 +5701,10 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       return true;\n     }\n \n+  grouped_store = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n   if (grouped_store)\n     {\n+      first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n       first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n       group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n \n@@ -5581,7 +5750,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"transform store. ncopies = %d\\n\", ncopies);\n \n-  if (STMT_VINFO_STRIDED_P (stmt_info))\n+  if (memory_access_type == VMAT_ELEMENTWISE\n+      || memory_access_type == VMAT_STRIDED_SLP)\n     {\n       gimple_stmt_iterator incr_gsi;\n       bool insert_after;\n@@ -5773,14 +5943,14 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   gcc_assert (alignment_support_scheme);\n   /* Targets with store-lane instructions must not require explicit\n      realignment.  */\n-  gcc_assert (!store_lanes_p\n+  gcc_assert (memory_access_type != VMAT_LOAD_STORE_LANES\n \t      || alignment_support_scheme == dr_aligned\n \t      || alignment_support_scheme == dr_unaligned_supported);\n \n   if (negative)\n     offset = size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1);\n \n-  if (store_lanes_p)\n+  if (memory_access_type == VMAT_LOAD_STORE_LANES)\n     aggr_type = build_array_type_nelts (elem_type, vec_num * nunits);\n   else\n     aggr_type = vectype;\n@@ -5918,7 +6088,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t\t\t\t\t   TYPE_SIZE_UNIT (aggr_type));\n \t}\n \n-      if (store_lanes_p)\n+      if (memory_access_type == VMAT_LOAD_STORE_LANES)\n \t{\n \t  tree vec_array;\n \n@@ -6202,7 +6372,6 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   gphi *phi = NULL;\n   vec<tree> dr_chain = vNULL;\n   bool grouped_load = false;\n-  bool load_lanes_p = false;\n   gimple *first_stmt;\n   gimple *first_stmt_for_drptr = NULL;\n   bool inv_p;\n@@ -6311,48 +6480,11 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     {\n       grouped_load = true;\n       /* FORNOW */\n-      gcc_assert (!nested_in_vect_loop && !STMT_VINFO_GATHER_SCATTER_P (stmt_info));\n+      gcc_assert (!nested_in_vect_loop);\n+      gcc_assert (!STMT_VINFO_GATHER_SCATTER_P (stmt_info));\n \n       first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n       group_size = GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-      bool single_element_p = (first_stmt == stmt\n-\t\t\t       && !GROUP_NEXT_ELEMENT (stmt_info));\n-\n-      if (!slp && !STMT_VINFO_STRIDED_P (stmt_info))\n-\t{\n-\t  if (vect_load_lanes_supported (vectype, group_size))\n-\t    load_lanes_p = true;\n-\t  else if (!vect_grouped_load_supported (vectype, single_element_p,\n-\t\t\t\t\t\t group_size))\n-\t    return false;\n-\t}\n-\n-      if (single_element_p)\n-\t{\n-\t  /* Single-element interleaving requires peeling for gaps.  */\n-\t  gcc_assert (GROUP_GAP (stmt_info));\n-\t}\n-\n-      /* If there is a gap in the end of the group then we access excess\n-\t elements in the last iteration and thus need to peel that off.  */\n-      if (loop_vinfo\n-\t  && ! STMT_VINFO_STRIDED_P (stmt_info)\n-\t  && GROUP_GAP (vinfo_for_stmt (first_stmt)) != 0)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"Data access with gaps requires scalar \"\n-\t\t\t     \"epilogue loop\\n\");\n-\t  if (loop->inner)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"Peeling for outer loop is not supported\\n\");\n-\t      return false;\n-\t    }\n-\n-\t  LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = true;\n-\t}\n \n       if (slp && SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n \tslp_perm = true;\n@@ -6398,24 +6530,13 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n     }\n \n+  vect_memory_access_type memory_access_type;\n+  if (!get_load_store_type (stmt, vectype, slp, VLS_LOAD,\n+\t\t\t    &memory_access_type, &gs_info))\n+    return false;\n \n-  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n-    {\n-      gimple *def_stmt;\n-      if (!vect_check_gather_scatter (stmt, loop_vinfo, &gs_info))\n-\tgcc_unreachable ();\n-      if (!vect_is_simple_use (gs_info.offset, vinfo, &def_stmt,\n-\t\t\t       &gs_info.offset_dt, &gs_info.offset_vectype))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"gather index use not simple.\\n\");\n-\t  return false;\n-\t}\n-    }\n-  else if (STMT_VINFO_STRIDED_P (stmt_info))\n-    ;\n-  else\n+  if (!STMT_VINFO_GATHER_SCATTER_P (stmt_info)\n+      && !STMT_VINFO_STRIDED_P (stmt_info))\n     {\n       negative = tree_int_cst_compare (nested_in_vect_loop\n \t\t\t\t       ? STMT_VINFO_DR_STEP (stmt_info)\n@@ -6461,14 +6582,20 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n+      if (!slp)\n+\tSTMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) = memory_access_type;\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n       /* The SLP costs are calculated during SLP analysis.  */\n       if (!PURE_SLP_STMT (stmt_info))\n-\tvect_model_load_cost (stmt_info, ncopies, load_lanes_p,\n+\tvect_model_load_cost (stmt_info, ncopies, memory_access_type,\n \t\t\t      NULL, NULL, NULL);\n       return true;\n     }\n \n+  if (!slp)\n+    gcc_assert (memory_access_type\n+\t\t== STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info));\n+\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"transform load. ncopies = %d\\n\", ncopies);\n@@ -6477,7 +6604,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \n   ensure_base_align (stmt_info, dr);\n \n-  if (STMT_VINFO_GATHER_SCATTER_P (stmt_info))\n+  if (memory_access_type == VMAT_GATHER_SCATTER)\n     {\n       tree vec_oprnd0 = NULL_TREE, op;\n       tree arglist = TYPE_ARG_TYPES (TREE_TYPE (gs_info.decl));\n@@ -6644,7 +6771,9 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n       return true;\n     }\n-  else if (STMT_VINFO_STRIDED_P (stmt_info))\n+\n+  if (memory_access_type == VMAT_ELEMENTWISE\n+      || memory_access_type == VMAT_STRIDED_SLP)\n     {\n       gimple_stmt_iterator incr_gsi;\n       bool insert_after;\n@@ -6711,26 +6840,23 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       int lnel = 1;\n       tree ltype = TREE_TYPE (vectype);\n       auto_vec<tree> dr_chain;\n-      if (slp)\n+      if (memory_access_type == VMAT_STRIDED_SLP)\n \t{\n-\t  if (group_size < nunits\n-\t      && nunits % group_size == 0)\n+\t  nloads = nunits / group_size;\n+\t  if (group_size < nunits)\n \t    {\n-\t      nloads = nunits / group_size;\n \t      lnel = group_size;\n \t      ltype = build_vector_type (TREE_TYPE (vectype), group_size);\n-\t      ltype = build_aligned_type (ltype,\n-\t\t\t\t\t  TYPE_ALIGN (TREE_TYPE (vectype)));\n \t    }\n-\t  else if (group_size >= nunits\n-\t\t   && group_size % nunits == 0)\n+\t  else\n \t    {\n-\t      nloads = 1;\n \t      lnel = nunits;\n \t      ltype = vectype;\n-\t      ltype = build_aligned_type (ltype,\n-\t\t\t\t\t  TYPE_ALIGN (TREE_TYPE (vectype)));\n \t    }\n+\t  ltype = build_aligned_type (ltype, TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t}\n+      if (slp)\n+\t{\n \t  /* For SLP permutation support we need to load the whole group,\n \t     not only the number of vector stmts the permutation result\n \t     fits in.  */\n@@ -6862,7 +6988,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   gcc_assert (alignment_support_scheme);\n   /* Targets with load-lane instructions must not require explicit\n      realignment.  */\n-  gcc_assert (!load_lanes_p\n+  gcc_assert (memory_access_type != VMAT_LOAD_STORE_LANES\n \t      || alignment_support_scheme == dr_aligned\n \t      || alignment_support_scheme == dr_unaligned_supported);\n \n@@ -6997,7 +7123,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n   if (negative)\n     offset = size_int (-TYPE_VECTOR_SUBPARTS (vectype) + 1);\n \n-  if (load_lanes_p)\n+  if (memory_access_type == VMAT_LOAD_STORE_LANES)\n     aggr_type = build_array_type_nelts (elem_type, vec_num * nunits);\n   else\n     aggr_type = vectype;\n@@ -7060,7 +7186,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       if (grouped_load || slp_perm)\n \tdr_chain.create (vec_num);\n \n-      if (load_lanes_p)\n+      if (memory_access_type == VMAT_LOAD_STORE_LANES)\n \t{\n \t  tree vec_array;\n \n@@ -7330,7 +7456,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n         {\n           if (grouped_load)\n   \t    {\n-\t      if (!load_lanes_p)\n+\t      if (memory_access_type != VMAT_LOAD_STORE_LANES)\n \t\tvect_transform_grouped_load (stmt, dr_chain, group_size, gsi);\n \t      *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n \t    }"}, {"sha": "ef69b7e8a1f2caa6258b4f1818baf7325c959434", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2de001eed013bb666f832694bc75b8f055ffdc76/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2de001eed013bb666f832694bc75b8f055ffdc76/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=2de001eed013bb666f832694bc75b8f055ffdc76", "patch": "@@ -481,6 +481,33 @@ enum slp_vect_type {\n   hybrid\n };\n \n+/* Describes how we're going to vectorize an individual load or store,\n+   or a group of loads or stores.  */\n+enum vect_memory_access_type {\n+  /* A simple contiguous access.  */\n+  VMAT_CONTIGUOUS,\n+\n+  /* A simple contiguous access in which the elements need to be permuted\n+     after loading or before storing.  Only used for loop vectorization;\n+     SLP uses separate permutes.  */\n+  VMAT_CONTIGUOUS_PERMUTE,\n+\n+  /* An access that uses IFN_LOAD_LANES or IFN_STORE_LANES.  */\n+  VMAT_LOAD_STORE_LANES,\n+\n+  /* An access in which each scalar element is loaded or stored\n+     individually.  */\n+  VMAT_ELEMENTWISE,\n+\n+  /* A hybrid of VMAT_CONTIGUOUS and VMAT_ELEMENTWISE, used for grouped\n+     SLP accesses.  Each unrolled iteration uses a contiguous load\n+     or store for the whole group, but the groups from separate iterations\n+     are combined in the same way as for VMAT_ELEMENTWISE.  */\n+  VMAT_STRIDED_SLP,\n+\n+  /* The access uses gather loads or scatter stores.  */\n+  VMAT_GATHER_SCATTER\n+};\n \n typedef struct data_reference *dr_p;\n \n@@ -598,6 +625,10 @@ typedef struct _stmt_vec_info {\n   /* True if this is an access with loop-invariant stride.  */\n   bool strided_p;\n \n+  /* Classifies how the load or store is going to be implemented\n+     for loop vectorization.  */\n+  vect_memory_access_type memory_access_type;\n+\n   /* For both loads and stores.  */\n   bool simd_lane_access_p;\n \n@@ -655,6 +686,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_DATA_REF(S)             (S)->data_ref_info\n #define STMT_VINFO_GATHER_SCATTER_P(S)\t   (S)->gather_scatter_p\n #define STMT_VINFO_STRIDED_P(S)\t   \t   (S)->strided_p\n+#define STMT_VINFO_MEMORY_ACCESS_TYPE(S)   (S)->memory_access_type\n #define STMT_VINFO_SIMD_LANE_ACCESS_P(S)   (S)->simd_lane_access_p\n #define STMT_VINFO_VEC_REDUCTION_TYPE(S)   (S)->v_reduc_type\n \n@@ -1002,12 +1034,12 @@ extern void free_stmt_vec_info (gimple *stmt);\n extern void vect_model_simple_cost (stmt_vec_info, int, enum vect_def_type *,\n                                     stmt_vector_for_cost *,\n \t\t\t\t    stmt_vector_for_cost *);\n-extern void vect_model_store_cost (stmt_vec_info, int, bool,\n+extern void vect_model_store_cost (stmt_vec_info, int, vect_memory_access_type,\n \t\t\t\t   enum vect_def_type, slp_tree,\n \t\t\t\t   stmt_vector_for_cost *,\n \t\t\t\t   stmt_vector_for_cost *);\n-extern void vect_model_load_cost (stmt_vec_info, int, bool, slp_tree,\n-\t\t\t\t  stmt_vector_for_cost *,\n+extern void vect_model_load_cost (stmt_vec_info, int, vect_memory_access_type,\n+\t\t\t\t  slp_tree, stmt_vector_for_cost *,\n \t\t\t\t  stmt_vector_for_cost *);\n extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n \t\t\t\t  enum vect_cost_for_stmt, stmt_vec_info,"}]}