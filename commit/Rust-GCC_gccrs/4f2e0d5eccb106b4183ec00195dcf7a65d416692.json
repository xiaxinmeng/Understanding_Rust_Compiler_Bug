{"sha": "4f2e0d5eccb106b4183ec00195dcf7a65d416692", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGYyZTBkNWVjY2IxMDZiNDE4M2VjMDAxOTVkY2Y3YTY1ZDQxNjY5Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-02-16T22:55:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-02-16T22:55:33Z"}, "message": "re PR middle-end/19920 (build broken on several targets due to recent 'DC' type update to libgcc2)\n\n        PR 19920\n        * libgcc2.c (WORD_SIZE): Remove all definitions; replace uses\n        with W_TYPE_SIZE.\n        (HIGH_WORD_COEFF, HIGH_HALFWORD_COEFF): Remove all definitions;\n        replace uses with Wtype_MAXp1_F.\n        (L_fixunstfdi, L_fixtfdi, L_floatditf, L_fixunsxfdi, L_fixxfdi,\n        L_floatdixf, L_fixunsxfsi, L_fixunsdfdi, L_floatdidf, L_fixunsdfsi,\n        L_powidf2, L_powixf2, L_powitf2, L_muldc3, L_divdc3, L_mulxc3,\n        L_divxc3, L_multc3, L_divtc3): Protect with HAVE_DFMODE, HAVE_XFMODE,\n        and HAVE_TFMODE as appropriate.\n        (__fixunssfDI): Provide an implementation that doesn't need DFmode.\n        (__floatdisf): Likewise.\n        * libgcc2.h (LIBGCC2_DOUBLE_TYPE_SIZE): New.\n        (HAVE_DFMODE, HAVE_XFMODE, HAVE_TFMODE): New.\n        (Wtype_MAXp1_F): New.\n        (DFtype, DCtype, __fixdfdi, __floatdidf, __fixunsdfSI, __fixunsdfDI,\n        __powidf2, __divdc3, __muldc3): Protect with HAVE_DFMODE.\n\nFrom-SVN: r95121", "tree": {"sha": "2c8f7da1df0ca3c8c4ec10b9017f84b06b17368b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c8f7da1df0ca3c8c4ec10b9017f84b06b17368b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f2e0d5eccb106b4183ec00195dcf7a65d416692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2e0d5eccb106b4183ec00195dcf7a65d416692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f2e0d5eccb106b4183ec00195dcf7a65d416692", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2e0d5eccb106b4183ec00195dcf7a65d416692/comments", "author": null, "committer": null, "parents": [{"sha": "9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f7bf991d001ab714d0b04b1ed6bdc103ff97dbc"}], "stats": {"total": 307, "additions": 200, "deletions": 107}, "files": [{"sha": "ea3a1c6618529506517668e6b8c26c6aee13237b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e0d5eccb106b4183ec00195dcf7a65d416692/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e0d5eccb106b4183ec00195dcf7a65d416692/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4f2e0d5eccb106b4183ec00195dcf7a65d416692", "patch": "@@ -1,3 +1,23 @@\n+2005-02-16  Richard Henderson  <rth@redhat.com>\n+\n+\tPR 19920\n+\t* libgcc2.c (WORD_SIZE): Remove all definitions; replace uses\n+\twith W_TYPE_SIZE.\n+\t(HIGH_WORD_COEFF, HIGH_HALFWORD_COEFF): Remove all definitions;\n+\treplace uses with Wtype_MAXp1_F.\n+\t(L_fixunstfdi, L_fixtfdi, L_floatditf, L_fixunsxfdi, L_fixxfdi,\n+\tL_floatdixf, L_fixunsxfsi, L_fixunsdfdi, L_floatdidf, L_fixunsdfsi,\n+\tL_powidf2, L_powixf2, L_powitf2, L_muldc3, L_divdc3, L_mulxc3,\n+\tL_divxc3, L_multc3, L_divtc3): Protect with HAVE_DFMODE, HAVE_XFMODE,\n+\tand HAVE_TFMODE as appropriate.\n+\t(__fixunssfDI): Provide an implementation that doesn't need DFmode.\n+\t(__floatdisf): Likewise.\n+\t* libgcc2.h (LIBGCC2_DOUBLE_TYPE_SIZE): New.\n+\t(HAVE_DFMODE, HAVE_XFMODE, HAVE_TFMODE): New.\n+\t(Wtype_MAXp1_F): New.\n+\t(DFtype, DCtype, __fixdfdi, __floatdidf, __fixunsdfSI, __fixunsdfDI,\n+\t__powidf2, __divdc3, __muldc3): Protect with HAVE_DFMODE.\n+\n 2005-02-16  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* PR target/19162"}, {"sha": "9bdb1c71228ffa3b072a2f4ef04e3c348dc26783", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 148, "deletions": 97, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e0d5eccb106b4183ec00195dcf7a65d416692/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e0d5eccb106b4183ec00195dcf7a65d416692/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=4f2e0d5eccb106b4183ec00195dcf7a65d416692", "patch": "@@ -148,13 +148,12 @@ __subvDI3 (DWtype a, DWtype b)\n #endif\n \f\n #ifdef L_mulvsi3\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n Wtype\n __mulvSI3 (Wtype a, Wtype b)\n {\n   const DWtype w = (DWtype) a * (DWtype) b;\n \n-  if ((Wtype) (w >> WORD_SIZE) != (Wtype) w >> (WORD_SIZE - 1))\n+  if ((Wtype) (w >> W_TYPE_SIZE) != (Wtype) w >> (W_TYPE_SIZE - 1))\n     abort ();\n \n   return w;\n@@ -273,7 +272,6 @@ __absvDI2 (DWtype a)\n #endif\n \f\n #ifdef L_mulvdi3\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n DWtype\n __mulvDI3 (DWtype u, DWtype v)\n {\n@@ -282,10 +280,10 @@ __mulvDI3 (DWtype u, DWtype v)\n   const DWunion uu = {.ll = u};\n   const DWunion vv = {.ll = v};\n \n-  if (__builtin_expect (uu.s.high == uu.s.low >> (WORD_SIZE - 1), 1))\n+  if (__builtin_expect (uu.s.high == uu.s.low >> (W_TYPE_SIZE - 1), 1))\n     {\n       /* u fits in a single Wtype.  */\n-      if (__builtin_expect (vv.s.high == vv.s.low >> (WORD_SIZE - 1), 1))\n+      if (__builtin_expect (vv.s.high == vv.s.low >> (W_TYPE_SIZE - 1), 1))\n \t{\n \t  /* v fits in a single Wtype as well.  */\n \t  /* A single multiplication.  No overflow risk.  */\n@@ -304,7 +302,7 @@ __mulvDI3 (DWtype u, DWtype v)\n \t  if (uu.s.low < 0)\n \t    w1.ll -= vv.ll;\n \t  w1.ll += (UWtype) w0.s.high;\n-\t  if (__builtin_expect (w1.s.high == w1.s.low >> (WORD_SIZE - 1), 1))\n+\t  if (__builtin_expect (w1.s.high == w1.s.low >> (W_TYPE_SIZE - 1), 1))\n \t    {\n \t      w0.s.high = w1.s.low;\n \t      return w0.ll;\n@@ -313,7 +311,7 @@ __mulvDI3 (DWtype u, DWtype v)\n     }\n   else\n     {\n-      if (__builtin_expect (vv.s.high == vv.s.low >> (WORD_SIZE - 1), 1))\n+      if (__builtin_expect (vv.s.high == vv.s.low >> (W_TYPE_SIZE - 1), 1))\n \t{\n \t  /* v fits into a single Wtype.  */\n \t  /* Two multiplications.  */\n@@ -327,7 +325,7 @@ __mulvDI3 (DWtype u, DWtype v)\n \t  if (vv.s.low < 0)\n \t    w1.ll -= uu.ll;\n \t  w1.ll += (UWtype) w0.s.high;\n-\t  if (__builtin_expect (w1.s.high == w1.s.low >> (WORD_SIZE - 1), 1))\n+\t  if (__builtin_expect (w1.s.high == w1.s.low >> (W_TYPE_SIZE - 1), 1))\n \t    {\n \t      w0.s.high = w1.s.low;\n \t      return w0.ll;\n@@ -1157,22 +1155,19 @@ __ucmpdi2 (DWtype a, DWtype b)\n }\n #endif\n \f\n-#if defined(L_fixunstfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n-\n+#if defined(L_fixunstfdi) && defined(HAVE_TFMODE)\n DWtype\n __fixunstfDI (TFtype a)\n {\n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n-  const TFtype b = (a / HIGH_WORD_COEFF);\n+  const TFtype b = (a / Wtype_MAXp1_F);\n   /* Convert that to fixed (but not to DWtype!),\n      and shift it into the high word.  */\n   UDWtype v = (UWtype) b;\n-  v <<= WORD_SIZE;\n+  v <<= W_TYPE_SIZE;\n   /* Remove high part from the TFtype, leaving the low part as flonum.  */\n   a -= (TFtype)v;\n   /* Convert that to fixed (but not to DWtype!) and add it in.\n@@ -1186,7 +1181,7 @@ __fixunstfDI (TFtype a)\n }\n #endif\n \n-#if defined(L_fixtfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n+#if defined(L_fixtfdi) && defined(HAVE_TFMODE)\n DWtype\n __fixtfdi (TFtype a)\n {\n@@ -1196,22 +1191,19 @@ __fixtfdi (TFtype a)\n }\n #endif\n \n-#if defined(L_fixunsxfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80)\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n-\n+#if defined(L_fixunsxfdi) && defined(HAVE_XFMODE)\n DWtype\n __fixunsxfDI (XFtype a)\n {\n   if (a < 0)\n     return 0;\n \n   /* Compute high word of result, as a flonum.  */\n-  const XFtype b = (a / HIGH_WORD_COEFF);\n+  const XFtype b = (a / Wtype_MAXp1_F);\n   /* Convert that to fixed (but not to DWtype!),\n      and shift it into the high word.  */\n   UDWtype v = (UWtype) b;\n-  v <<= WORD_SIZE;\n+  v <<= W_TYPE_SIZE;\n   /* Remove high part from the XFtype, leaving the low part as flonum.  */\n   a -= (XFtype)v;\n   /* Convert that to fixed (but not to DWtype!) and add it in.\n@@ -1225,7 +1217,7 @@ __fixunsxfDI (XFtype a)\n }\n #endif\n \n-#if defined(L_fixxfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80)\n+#if defined(L_fixxfdi) && defined(HAVE_XFMODE)\n DWtype\n __fixxfdi (XFtype a)\n {\n@@ -1235,29 +1227,26 @@ __fixxfdi (XFtype a)\n }\n #endif\n \n-#ifdef L_fixunsdfdi\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n-\n+#if defined(L_fixunsdfdi) && defined(HAVE_DFMODE)\n DWtype\n __fixunsdfDI (DFtype a)\n {\n   /* Get high part of result.  The division here will just moves the radix\n      point and will not cause any rounding.  Then the conversion to integral\n      type chops result as desired.  */\n-  const UWtype hi = a / HIGH_WORD_COEFF;\n+  const UWtype hi = a / Wtype_MAXp1_F;\n \n   /* Get low part of result.  Convert `hi' to floating type and scale it back,\n      then subtract this from the number being converted.  This leaves the low\n      part.  Convert that to integral type.  */\n-  const UWtype lo = (a - ((DFtype) hi) * HIGH_WORD_COEFF);\n+  const UWtype lo = a - (DFtype) hi * Wtype_MAXp1_F;\n \n   /* Assemble result from the two parts.  */\n-  return ((UDWtype) hi << WORD_SIZE) | lo;\n+  return ((UDWtype) hi << W_TYPE_SIZE) | lo;\n }\n #endif\n \n-#ifdef L_fixdfdi\n+#if defined(L_fixdfdi) && defined(HAVE_DFMODE)\n DWtype\n __fixdfdi (DFtype a)\n {\n@@ -1268,29 +1257,66 @@ __fixdfdi (DFtype a)\n #endif\n \n #ifdef L_fixunssfdi\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n-#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n-\n DWtype\n-__fixunssfDI (SFtype original_a)\n+__fixunssfDI (SFtype a)\n {\n+#if defined(HAVE_DFMODE)\n   /* Convert the SFtype to a DFtype, because that is surely not going\n      to lose any bits.  Some day someone else can write a faster version\n      that avoids converting to DFtype, and verify it really works right.  */\n-  const DFtype a = original_a;\n+  const DFtype dfa = a;\n \n   /* Get high part of result.  The division here will just moves the radix\n      point and will not cause any rounding.  Then the conversion to integral\n      type chops result as desired.  */\n-  const UWtype hi = a / HIGH_WORD_COEFF;\n+  const UWtype hi = dfa / Wtype_MAXp1_F;\n \n   /* Get low part of result.  Convert `hi' to floating type and scale it back,\n      then subtract this from the number being converted.  This leaves the low\n      part.  Convert that to integral type.  */\n-  const UWtype lo = (a - ((DFtype) hi) * HIGH_WORD_COEFF);\n+  const UWtype lo = dfa - (DFtype) hi * Wtype_MAXp1_F;\n \n   /* Assemble result from the two parts.  */\n-  return ((UDWtype) hi << WORD_SIZE) | lo;\n+  return ((UDWtype) hi << W_TYPE_SIZE) | lo;\n+#elif FLT_MANT_DIG < W_TYPE_SIZE\n+  if (a < 1)\n+    return 0;\n+  if (a < Wtype_MAXp1_F)\n+    return (UWtype)a;\n+  if (a < Wtype_MAXp1_F * Wtype_MAXp1_F)\n+    {\n+      /* Since we know that there are fewer significant bits in the SFmode\n+\t quantity than in a word, we know that we can convert out all the\n+\t signficant bits in one step, and thus avoid losing bits.  */\n+\n+      /* ??? This following loop essentially performs frexpf.  If we could\n+\t use the real libm function, or poke at the actual bits of the fp\n+\t format, it would be significantly faster.  */\n+\n+      UWtype shift = 0, counter;\n+      SFtype msb;\n+\n+      a /= Wtype_MAXp1_F;\n+      for (counter = W_TYPE_SIZE / 2; counter != 0; counter >>= 1)\n+\t{\n+\t  SFtype counterf = (UWtype)1 << counter;\n+\t  if (a >= counterf)\n+\t    {\n+\t      shift |= counter;\n+\t      a /= counterf;\n+\t    }\n+\t}\n+\n+      /* Rescale into the range of one word, extract the bits of that\n+\t one word, and shift the result into position.  */\n+      a *= Wtype_MAXp1_F;\n+      counter = a;\n+      return (DWtype)counter << shift;\n+    }\n+  return -1;\n+#else\n+# error\n+#endif\n }\n #endif\n \n@@ -1304,79 +1330,72 @@ __fixsfdi (SFtype a)\n }\n #endif\n \n-#if defined(L_floatdixf) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80)\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n-\n+#if defined(L_floatdixf) && defined(HAVE_XFMODE)\n XFtype\n __floatdixf (DWtype u)\n {\n-  XFtype d = (Wtype) (u >> WORD_SIZE);\n-  d *= HIGH_HALFWORD_COEFF;\n-  d *= HIGH_HALFWORD_COEFF;\n-  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n-\n+  XFtype d = (Wtype) (u >> W_TYPE_SIZE);\n+  d *= Wtype_MAXp1_F;\n+  d += (UWtype)u;\n   return d;\n }\n #endif\n \n-#if defined(L_floatditf) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n-\n+#if defined(L_floatditf) && defined(HAVE_TFMODE)\n TFtype\n __floatditf (DWtype u)\n {\n-  TFtype d = (Wtype) (u >> WORD_SIZE);\n-  d *= HIGH_HALFWORD_COEFF;\n-  d *= HIGH_HALFWORD_COEFF;\n-  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n-\n+  TFtype d = (Wtype) (u >> W_TYPE_SIZE);\n+  d *= Wtype_MAXp1_F;\n+  d += (UWtype)u;\n   return d;\n }\n #endif\n \n-#ifdef L_floatdidf\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n-\n+#if defined(L_floatdidf) && defined(HAVE_DFMODE)\n DFtype\n __floatdidf (DWtype u)\n {\n-  DFtype d = (Wtype) (u >> WORD_SIZE);\n-  d *= HIGH_HALFWORD_COEFF;\n-  d *= HIGH_HALFWORD_COEFF;\n-  d += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n-\n+  DFtype d = (Wtype) (u >> W_TYPE_SIZE);\n+  d *= Wtype_MAXp1_F;\n+  d += (UWtype)u;\n   return d;\n }\n #endif\n \n #ifdef L_floatdisf\n-#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n-#define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))\n-#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n-\n-#define DI_SIZE (sizeof (DWtype) * BITS_PER_UNIT)\n-#define DF_SIZE DBL_MANT_DIG\n+#define DI_SIZE (W_TYPE_SIZE * 2)\n #define SF_SIZE FLT_MANT_DIG\n \n SFtype\n __floatdisf (DWtype u)\n {\n+#if SF_SIZE >= W_TYPE_SIZE\n+  /* When the word size is small, we never get any rounding error.  */\n+  SFtype f = (Wtype) (u >> W_TYPE_SIZE);\n+  f *= Wtype_MAXp1_F;\n+  f += (UWtype)u;\n+  return f;\n+#elif defined(HAVE_DFMODE)\n+\n+#if LIBGCC2_DOUBLE_TYPE_SIZE == 64\n+#define DF_SIZE DBL_MANT_DIG\n+#elif LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 64\n+#define DF_SIZE LDBL_MANT_DIG\n+#else\n+# error\n+#endif\n+\n+#define REP_BIT ((UDWtype) 1 << (DI_SIZE - DF_SIZE))\n+\n   /* Protect against double-rounding error.\n-     Represent any low-order bits, that might be truncated in DFmode,\n-     by a bit that won't be lost.  The bit can go in anywhere below the\n-     rounding position of the SFmode.  A fixed mask and bit position\n-     handles all usual configurations.  It doesn't handle the case\n-     of 128-bit DImode, however.  */\n+     Represent any low-order bits, that might be truncated by a bit that\n+     won't be lost.  The bit can go in anywhere below the rounding position\n+     of the SFmode.  A fixed mask and bit position handles all usual\n+     configurations.  It doesn't handle the case of 128-bit DImode, however.  */\n   if (DF_SIZE < DI_SIZE\n       && DF_SIZE > (DI_SIZE - DF_SIZE + SF_SIZE))\n     {\n-#define REP_BIT ((UDWtype) 1 << (DI_SIZE - DF_SIZE))\n       if (! (- ((DWtype) 1 << DF_SIZE) < u\n \t     && u < ((DWtype) 1 << DF_SIZE)))\n \t{\n@@ -1387,19 +1406,52 @@ __floatdisf (DWtype u)\n \t    }\n \t}\n     }\n-  /* Do the calculation in DFmode\n-     so that we don't lose any of the precision of the high word\n-     while multiplying it.  */\n-  DFtype f = (Wtype) (u >> WORD_SIZE);\n-  f *= HIGH_HALFWORD_COEFF;\n-  f *= HIGH_HALFWORD_COEFF;\n-  f += (UWtype) (u & (HIGH_WORD_COEFF - 1));\n \n+  /* Do the calculation in DFmode so that we don't lose any of the\n+     precision of the high word while multiplying it.  */\n+  DFtype f = (Wtype) (u >> W_TYPE_SIZE);\n+  f *= Wtype_MAXp1_F;\n+  f += (UWtype)u;\n   return (SFtype) f;\n+#else\n+  /* Finally, the word size is larger than the number of bits in SFmode,\n+     and we've got no DFmode.  The only way to avoid double rounding is\n+     to special case the extraction.  */\n+\n+  /* If there are no high bits set, fall back to one conversion.  */\n+  if ((Wtype)u == u)\n+    return (SFtype)(Wtype)u;\n+\n+  /* Otherwise, find the power of two.  */\n+  Wtype hi = u >> W_TYPE_SIZE;\n+  if (hi < 0)\n+    hi = -hi;\n+\n+  UWtype count, shift;\n+  count_leading_zeros (count, hi);\n+\n+  /* No leading bits means u == minimum.  */\n+  if (count == 0)\n+    return -(Wtype_MAXp1_F * Wtype_MAXp1_F / 2);\n+\n+  shift = W_TYPE_SIZE - count;\n+\n+  /* Shift down the most significant bits.  */\n+  hi = u >> shift;\n+\n+  /* If we lost any nonzero bits, set the lsb to ensure correct rounding.  */\n+  if (u & ((1 << shift) - 1))\n+    hi |= 1;\n+\n+  /* Convert the one word of data, and rescale.  */\n+  SFtype f = hi;\n+  f *= (UWtype)1 << shift;\n+  return f;\n+#endif\n }\n #endif\n \n-#if defined(L_fixunsxfsi) && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80\n+#if defined(L_fixunsxfsi) && defined(HAVE_XFMODE)\n /* Reenable the normal types, in case limits.h needs them.  */\n #undef char\n #undef short\n@@ -1421,7 +1473,7 @@ __fixunsxfSI (XFtype a)\n }\n #endif\n \n-#ifdef L_fixunsdfsi\n+#if defined(L_fixunsdfsi) && defined(HAVE_DFMODE)\n /* Reenable the normal types, in case limits.h needs them.  */\n #undef char\n #undef short\n@@ -1468,9 +1520,10 @@ __fixunssfSI (SFtype a)\n /* Integer power helper used from __builtin_powi for non-constant\n    exponents.  */\n \n-#if defined(L_powisf2) || defined(L_powidf2) \\\n-    || (defined(L_powixf2) && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80) \\\n-    || (defined(L_powitf2) && LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n+#if defined(L_powisf2) \\\n+    || (defined(L_powidf2) && defined(HAVE_DFMODE)) \\\n+    || (defined(L_powixf2) && defined(HAVE_XFMODE)) \\\n+    || (defined(L_powitf2) && defined(HAVE_TFMODE))\n # if defined(L_powisf2)\n #  define TYPE SFtype\n #  define NAME __powisf2\n@@ -1502,11 +1555,9 @@ NAME (TYPE x, Wtype m)\n #endif\n \f\n #if defined(L_mulsc3) || defined(L_divsc3) \\\n-    || defined(L_muldc3) || defined(L_divdc3) \\\n-    || (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80 \\\n-\t&& (defined(L_mulxc3) || defined(L_divxc3))) \\\n-    || (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128 \\\n-\t&& (defined(L_multc3) || defined(L_divtc3)))\n+    || ((defined(L_muldc3) || defined(L_divdc3)) && defined(HAVE_DFMODE)) \\\n+    || ((defined(L_mulxc3) || defined(L_divxc3)) && defined(HAVE_XFMODE)) \\\n+    || ((defined(L_multc3) || defined(L_divtc3)) && defined(HAVE_TFMODE))\n \n #undef float\n #undef double"}, {"sha": "0a08f51195ed522f0ce65f40d9634e1e1a804993", "filename": "gcc/libgcc2.h", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2e0d5eccb106b4183ec00195dcf7a65d416692/gcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2e0d5eccb106b4183ec00195dcf7a65d416692/gcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.h?ref=4f2e0d5eccb106b4183ec00195dcf7a65d416692", "patch": "@@ -51,6 +51,9 @@ extern short int __get_eh_table_version (struct exception_descriptor *);\n #define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n #endif\n \n+#ifndef LIBGCC2_DOUBLE_TYPE_SIZE\n+#define LIBGCC2_DOUBLE_TYPE_SIZE DOUBLE_TYPE_SIZE\n+#endif\n #ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n #define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n #endif\n@@ -91,15 +94,20 @@ typedef unsigned int UTItype\t__attribute__ ((mode (TI)));\n #if BITS_PER_UNIT == 8\n \n typedef \tfloat SFtype\t__attribute__ ((mode (SF)));\n-typedef\t\tfloat DFtype\t__attribute__ ((mode (DF)));\n typedef _Complex float SCtype\t__attribute__ ((mode (SC)));\n-typedef _Complex float DCtype\t__attribute__ ((mode (DC)));\n \n+#if LIBGCC2_DOUBLE_TYPE_SIZE == 64 || LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 64\n+#define HAVE_DFMODE\n+typedef\t\tfloat DFtype\t__attribute__ ((mode (DF)));\n+typedef _Complex float DCtype\t__attribute__ ((mode (DC)));\n+#endif\n #if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80\n+#define HAVE_XFMODE\n typedef\t\tfloat XFtype\t__attribute__ ((mode (XF)));\n typedef _Complex float XCtype\t__attribute__ ((mode (XC)));\n #endif\n #if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\n+#define HAVE_TFMODE\n typedef\t\tfloat TFtype\t__attribute__ ((mode (TF)));\n typedef _Complex float TCtype\t__attribute__ ((mode (TC)));\n #endif\n@@ -200,6 +208,18 @@ typedef int word_type __attribute__ ((mode (__word__)));\n #define Wtype_MAX ((Wtype)(((UWtype)1 << (W_TYPE_SIZE - 1)) - 1))\n #define Wtype_MIN (- Wtype_MAX - 1)\n \n+#if W_TYPE_SIZE == 8\n+# define Wtype_MAXp1_F\t0x1p8f\n+#elif W_TYPE_SIZE == 16\n+# define Wtype_MAXp1_F\t0x1p16f\n+#elif W_TYPE_SIZE == 32\n+# define Wtype_MAXp1_F\t0x1p32f\n+#elif W_TYPE_SIZE == 64\n+# define Wtype_MAXp1_F\t0x1p64f\n+#else\n+# error \"expand the table\"\n+#endif\n+\n #define __muldi3\t__NDW(mul,3)\n #define __divdi3\t__NDW(div,3)\n #define __udivdi3\t__NDW(udiv,3)\n@@ -301,23 +321,25 @@ extern SItype __negvsi2 (SItype);\n #endif /* COMPAT_SIMODE_TRAPPING_ARITHMETIC */\n \n #if BITS_PER_UNIT == 8\n-extern DWtype __fixdfdi (DFtype);\n extern DWtype __fixsfdi (SFtype);\n-extern DFtype __floatdidf (DWtype);\n extern SFtype __floatdisf (DWtype);\n-extern UWtype __fixunsdfSI (DFtype);\n extern UWtype __fixunssfSI (SFtype);\n-extern DWtype __fixunsdfDI (DFtype);\n extern DWtype __fixunssfDI (SFtype);\n extern SFtype __powisf2 (SFtype, Wtype);\n-extern DFtype __powidf2 (DFtype, Wtype);\n-\n extern SCtype __divsc3 (SFtype, SFtype, SFtype, SFtype);\n extern SCtype __mulsc3 (SFtype, SFtype, SFtype, SFtype);\n+\n+#ifdef HAVE_DFMODE\n+extern DWtype __fixdfdi (DFtype);\n+extern DFtype __floatdidf (DWtype);\n+extern UWtype __fixunsdfSI (DFtype);\n+extern DWtype __fixunsdfDI (DFtype);\n+extern DFtype __powidf2 (DFtype, Wtype);\n extern DCtype __divdc3 (DFtype, DFtype, DFtype, DFtype);\n extern DCtype __muldc3 (DFtype, DFtype, DFtype, DFtype);\n+#endif\n \n-#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 80\n+#ifdef HAVE_XFMODE\n extern DWtype __fixxfdi (XFtype);\n extern DWtype __fixunsxfDI (XFtype);\n extern XFtype __floatdixf (DWtype);\n@@ -327,7 +349,7 @@ extern XCtype __divxc3 (XFtype, XFtype, XFtype, XFtype);\n extern XCtype __mulxc3 (XFtype, XFtype, XFtype, XFtype);\n #endif\n \n-#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\n+#ifdef HAVE_TFMODE\n extern DWtype __fixunstfDI (TFtype);\n extern DWtype __fixtfdi (TFtype);\n extern TFtype __floatditf (DWtype);"}]}