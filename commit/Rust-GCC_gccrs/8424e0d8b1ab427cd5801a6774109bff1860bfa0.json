{"sha": "8424e0d8b1ab427cd5801a6774109bff1860bfa0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQyNGUwZDhiMWFiNDI3Y2Q1ODAxYTY3NzQxMDliZmYxODYwYmZhMA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-05T19:45:25Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-05T19:45:25Z"}, "message": "re PR fortran/30003 ([4.1 only] Expressions with side effects in array references)\n\n2006-12-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/30003\n\t* trans-array.c (gfc_trans_create_temp_array): Set the section\n\tends to zero.\n\t(gfc_conv_array_transpose): Likewise.\n\t(gfc_conv_section_startstride): Declare an expression for end,\n\tset it from a the array reference and evaluate it for the info\n\tstructure. Zero the ends in the ss structure and set end, used\n\tin the bounds check, from the info structure.\n\ttrans.h: Add and end array to the gfc_ss_info structure.\n\n2006-12-05  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/30003\n\t* gfortran.dg/allocatable_function_1.f90: Increase the number\n\tof expected calls of free to 10; the lhs section reference is\n\tnow evaluated so there is another call to bar.  Change the\n\tcomment appropriately.\n\t* gfortran.dg/array_section_1.f90: New test.\n\nFrom-SVN: r119556", "tree": {"sha": "79bc0a98d7c614c8fe8cd8d4071da59b5d4aac4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79bc0a98d7c614c8fe8cd8d4071da59b5d4aac4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8424e0d8b1ab427cd5801a6774109bff1860bfa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8424e0d8b1ab427cd5801a6774109bff1860bfa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8424e0d8b1ab427cd5801a6774109bff1860bfa0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8424e0d8b1ab427cd5801a6774109bff1860bfa0/comments", "author": null, "committer": null, "parents": [{"sha": "742163c039877dd51fa4cf99e8f616ac48c804a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/742163c039877dd51fa4cf99e8f616ac48c804a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/742163c039877dd51fa4cf99e8f616ac48c804a3"}], "stats": {"total": 95, "additions": 90, "deletions": 5}, "files": [{"sha": "34ea1e5e17a5a22ea2d8cd3dc4c122e2d6cfe69a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8424e0d8b1ab427cd5801a6774109bff1860bfa0", "patch": "@@ -1,3 +1,15 @@\n+2006-12-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/30003\n+\t* trans-array.c (gfc_trans_create_temp_array): Set the section\n+\tends to zero.\n+\t(gfc_conv_array_transpose): Likewise.\n+\t(gfc_conv_section_startstride): Declare an expression for end,\n+\tset it from a the array reference and evaluate it for the info\n+\tstructure. Zero the ends in the ss structure and set end, used\n+\tin the bounds check, from the info structure.\n+\ttrans.h: Add and end array to the gfc_ss_info structure.\n+\n 2006-12-05  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/29912"}, {"sha": "bfd0600b58257ad2e22a2568802c63579799c20e", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=8424e0d8b1ab427cd5801a6774109bff1860bfa0", "patch": "@@ -618,6 +618,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post,\n \n       info->delta[dim] = gfc_index_zero_node;\n       info->start[dim] = gfc_index_zero_node;\n+      info->end[dim] = gfc_index_zero_node;\n       info->stride[dim] = gfc_index_one_node;\n       info->dim[dim] = dim;\n     }\n@@ -783,6 +784,7 @@ gfc_conv_array_transpose (gfc_se * se, gfc_expr * expr)\n     {\n       dest_info->delta[n] = gfc_index_zero_node;\n       dest_info->start[n] = gfc_index_zero_node;\n+      dest_info->end[n] = gfc_index_zero_node;\n       dest_info->stride[n] = gfc_index_one_node;\n       dest_info->dim[n] = n;\n \n@@ -2449,6 +2451,7 @@ static void\n gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n {\n   gfc_expr *start;\n+  gfc_expr *end;\n   gfc_expr *stride;\n   tree desc;\n   gfc_se se;\n@@ -2464,13 +2467,15 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n     {\n       /* We use a zero-based index to access the vector.  */\n       info->start[n] = gfc_index_zero_node;\n+      info->end[n] = gfc_index_zero_node;\n       info->stride[n] = gfc_index_one_node;\n       return;\n     }\n \n   gcc_assert (info->ref->u.ar.dimen_type[dim] == DIMEN_RANGE);\n   desc = info->descriptor;\n   start = info->ref->u.ar.start[dim];\n+  end = info->ref->u.ar.end[dim];\n   stride = info->ref->u.ar.stride[dim];\n \n   /* Calculate the start of the range.  For vector subscripts this will\n@@ -2490,6 +2495,24 @@ gfc_conv_section_startstride (gfc_loopinfo * loop, gfc_ss * ss, int n)\n     }\n   info->start[n] = gfc_evaluate_now (info->start[n], &loop->pre);\n \n+  /* Similarly calculate the end.  Although this is not used in the\n+     scalarizer, it is needed when checking bounds and where the end\n+     is an expression with side-effects.  */\n+  if (end)\n+    {\n+      /* Specified section start.  */\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_type (&se, end, gfc_array_index_type);\n+      gfc_add_block_to_block (&loop->pre, &se.pre);\n+      info->end[n] = se.expr;\n+    }\n+  else\n+    {\n+      /* No upper bound specified so use the bound of the array.  */\n+      info->end[n] = gfc_conv_array_ubound (desc, dim);\n+    }\n+  info->end[n] = gfc_evaluate_now (info->end[n], &loop->pre);\n+\n   /* Calculate the stride.  */\n   if (stride == NULL)\n     info->stride[n] = gfc_index_one_node;\n@@ -2582,6 +2605,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t  for (n = 0; n < ss->data.info.dimen; n++)\n \t    {\n \t      ss->data.info.start[n] = gfc_index_zero_node;\n+\t      ss->data.info.end[n] = gfc_index_zero_node;\n \t      ss->data.info.stride[n] = gfc_index_one_node;\n \t    }\n \t  break;\n@@ -2635,7 +2659,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t         than it is here, with all the trees.  */\n \t      lbound = gfc_conv_array_lbound (desc, dim);\n \t      ubound = gfc_conv_array_ubound (desc, dim);\n-\t      end = gfc_conv_section_upper_bound (ss, n, &block);\n+\t      end = info->end[n];\n \n \t      /* Zero stride is not allowed.  */\n \t      tmp = fold_build2 (EQ_EXPR, boolean_type_node, info->stride[n],"}, {"sha": "d16a5df83d211de6a5b338f2acbc2a6e096e1326", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=8424e0d8b1ab427cd5801a6774109bff1860bfa0", "patch": "@@ -107,6 +107,7 @@ typedef struct gfc_ss_info\n      start is used in the calculation of these.  Indexed by scalarizer\n      dimension.  */\n   tree start[GFC_MAX_DIMENSIONS];\n+  tree end[GFC_MAX_DIMENSIONS];\n   tree stride[GFC_MAX_DIMENSIONS];\n   tree delta[GFC_MAX_DIMENSIONS];\n "}, {"sha": "dc199b6aac07cbba13e0fa90629d578d519a1ad8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8424e0d8b1ab427cd5801a6774109bff1860bfa0", "patch": "@@ -1,3 +1,12 @@\n+2006-12-05  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/30003\n+\t* gfortran.dg/allocatable_function_1.f90: Increase the number\n+\tof expected calls of free to 10; the lhs section reference is\n+\tnow evaluated so there is another call to bar.  Change the\n+\tcomment appropriately.\n+\t* gfortran.dg/array_section_1.f90: New test.\n+\n 2006-12-05  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/29912"}, {"sha": "fc3b983ad1d43e5b629ab222f4d4935c14545b46", "filename": "gcc/testsuite/gfortran.dg/allocatable_function_1.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_function_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_function_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_function_1.f90?ref=8424e0d8b1ab427cd5801a6774109bff1860bfa0", "patch": "@@ -65,9 +65,9 @@ end function foo2\n ! 1 _gfortran_internal_free\n     if (.not.all(2*bar(size(a)) + 5 == [ 7, 9, 11 ])) call abort()\n \n-! The first reference never happens because the rhs determines the loop size.\n-! Thus there is no subsequent _gfortran_internal_free.\n-! 2 _gfortran_internal_free's\n+! Although the rhs determines the loop size, the lhs reference is\n+! evaluated, in case it has side-effects or is needed for bounds checking.\n+! 3 _gfortran_internal_free's\n     a(1:size (bar (3))) = 2*bar(size(a)) + 2 + a(size (bar (3)))\n     if (.not.all(a == [ 7, 9, 11 ])) call abort()\n \n@@ -107,6 +107,6 @@ function bar (n) result(b)\n     end function bar\n \n end program alloc_fun\n-! { dg-final { scan-tree-dump-times \"free\" 9 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"free\" 10 \"original\" } }\n ! { dg-final { cleanup-tree-dump \"original\" } }\n ! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "4d5eedf2ae14da14cc128bb95456edb91e01ed47", "filename": "gcc/testsuite/gfortran.dg/array_section_1.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_section_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8424e0d8b1ab427cd5801a6774109bff1860bfa0/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_section_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_section_1.f90?ref=8424e0d8b1ab427cd5801a6774109bff1860bfa0", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! Tests the fix for PR30003, in which the 'end' of an array section\n+! would not be evaluated at all if it was on the lhs of an assignment\n+! or would be evaluated many times if bound checking were on.\n+!\n+! Contributed by Erik Edelmann <eedelmann@gcc.gnu.org>\n+!\n+    implicit none\n+    integer :: a(5), b(3), cnt\n+\n+    b = [ 1, 2, 3 ]\n+! Check the lhs references\n+    cnt = 0\n+    a(bar(1):3) = b\n+    if (cnt /= 1) call abort ()\n+    cnt = 0\n+    a(1:bar(3)) = b\n+    if (cnt /= 1) call abort ()\n+    cnt = 0\n+    a(1:3:bar(1)) = b\n+    if (cnt /= 1) call abort ()\n+! Check the rhs references\n+    cnt = 0\n+    a(1:3) = b(bar(1):3)\n+    if (cnt /= 1) call abort ()\n+    cnt = 0\n+    a(1:3) = b(1:bar(3))\n+    if (cnt /= 1) call abort ()\n+    cnt = 0\n+    a(1:3) = b(1:3:bar(1))\n+    if (cnt /= 1) call abort ()\n+contains\n+    integer function bar(n)\n+        integer, intent(in) :: n\n+        cnt = cnt + 1\n+        bar = n\n+    end function bar\n+end"}]}