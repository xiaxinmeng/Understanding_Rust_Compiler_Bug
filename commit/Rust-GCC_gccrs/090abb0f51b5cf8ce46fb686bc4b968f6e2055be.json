{"sha": "090abb0f51b5cf8ce46fb686bc4b968f6e2055be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkwYWJiMGY1MWI1Y2Y4Y2U0NmZiNjg2YmM0Yjk2OGY2ZTIwNTViZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-07T09:17:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-07T09:18:15Z"}, "message": "Fix problematic conversion to boolean type\n\nThe new ranger exposed a problematic conversion to boolean type.\n\ngcc/ada/ChangeLog:\n\t* gcc-interface/utils.c (convert) <INTEGER_TYPE>: Call fold_convert\n\tin the cases where convert_to_integer is not called.\n\t<BOOLEAN_TYPE>: Call fold_convert instead of convert_to_integer.", "tree": {"sha": "9a282e3945c6eb09c674d59bc95d61f05808f1c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a282e3945c6eb09c674d59bc95d61f05808f1c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/090abb0f51b5cf8ce46fb686bc4b968f6e2055be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/090abb0f51b5cf8ce46fb686bc4b968f6e2055be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/090abb0f51b5cf8ce46fb686bc4b968f6e2055be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/090abb0f51b5cf8ce46fb686bc4b968f6e2055be/comments", "author": null, "committer": null, "parents": [{"sha": "bf615bf65a0035cac3d4ac229e6413aad3b1d44a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf615bf65a0035cac3d4ac229e6413aad3b1d44a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf615bf65a0035cac3d4ac229e6413aad3b1d44a"}], "stats": {"total": 16, "additions": 9, "deletions": 7}, "files": [{"sha": "1d49db9fb1b56fc12eae74fa6ffde80253644df8", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/090abb0f51b5cf8ce46fb686bc4b968f6e2055be/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/090abb0f51b5cf8ce46fb686bc4b968f6e2055be/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=090abb0f51b5cf8ce46fb686bc4b968f6e2055be", "patch": "@@ -4930,10 +4930,6 @@ convert (tree type, tree expr)\n \t\t\t\t\t  convert (TREE_TYPE (type),\n \t\t\t\t\t\t   TYPE_MIN_VALUE (type))));\n \n-      /* ... fall through ... */\n-\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n       /* If we are converting an additive expression to an integer type\n \t with lower precision, be wary of the optimization that can be\n \t applied by convert_to_integer.  There are 2 problematic cases:\n@@ -4945,8 +4941,7 @@ convert (tree type, tree expr)\n \t     intermediate conversion that changes the sign could\n \t     be inserted and thus introduce an artificial overflow\n \t     at compile time when the placeholder is substituted.  */\n-      if (code == INTEGER_TYPE\n-\t  && ecode == INTEGER_TYPE\n+      if (ecode == INTEGER_TYPE\n \t  && TYPE_PRECISION (type) < TYPE_PRECISION (etype)\n \t  && (TREE_CODE (expr) == PLUS_EXPR || TREE_CODE (expr) == MINUS_EXPR))\n \t{\n@@ -4955,11 +4950,18 @@ convert (tree type, tree expr)\n \t  if ((TREE_CODE (TREE_TYPE (op0)) == INTEGER_TYPE\n \t       && TYPE_BIASED_REPRESENTATION_P (TREE_TYPE (op0)))\n \t      || CONTAINS_PLACEHOLDER_P (expr))\n-\t    return build1 (NOP_EXPR, type, expr);\n+\t    return fold_convert (type, expr);\n \t}\n \n+      /* ... fall through ... */\n+\n+    case ENUMERAL_TYPE:\n       return fold (convert_to_integer (type, expr));\n \n+    case BOOLEAN_TYPE:\n+      /* Do not use convert_to_integer with boolean types.  */\n+      return fold_convert_loc (EXPR_LOCATION (expr), type, expr);\n+\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n       /* If converting between two thin pointers, adjust if needed to account"}]}