{"sha": "9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWYzODgwZDFlY2Y0NmEyYTFhNWJkMjdhOGQyYmM0MTA0YTliZGQ3NA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2015-04-10T12:03:35Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2015-04-10T12:03:35Z"}, "message": "trans-stmt.c (gfc_trans_lock_unlock): Implement -fcoarray=lib version; reject not-yet-implemented variants.\n\n2015-04-10  Tobias Burnus  <burnus@net-b.de>\n\ngcc/fortran/\n\t* trans-stmt.c (gfc_trans_lock_unlock): Implement -fcoarray=lib\n\tversion; reject not-yet-implemented variants.\n\t* trans-types.c (gfc_get_derived_type): For lock_type with\n\t-fcoarray=lib, use a void pointer as type.\n\t* trans.c (gfc_allocate_using_lib, gfc_allocate_allocatable):\n\tHandle lock_type with -fcoarray=lib.\n\ngcc/testsuite/\n\t* gfortran.dg/coarray_lock_6.f90: New.\n\t* gfortran.dg/coarray_lock_7.f90: New.\n\t* gfortran.dg/coarray/lock_2.f90: New.\n\nFrom-SVN: r221973", "tree": {"sha": "4b0b922eb75c016e5b0c6256c024a7e35a063e14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b0b922eb75c016e5b0c6256c024a7e35a063e14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "44c57c2f9049c9fa53817b71110cf0cee00675b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44c57c2f9049c9fa53817b71110cf0cee00675b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44c57c2f9049c9fa53817b71110cf0cee00675b6"}], "stats": {"total": 344, "additions": 335, "deletions": 9}, "files": [{"sha": "4419b21c90dbb3809d5782a6f4bb727939e0a876", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "patch": "@@ -1,3 +1,12 @@\n+2015-04-10  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* trans-stmt.c (gfc_trans_lock_unlock): Implement -fcoarray=lib\n+\tversion; reject not-yet-implemented variants.\n+\t* trans-types.c (gfc_get_derived_type): For lock_type with\n+\t-fcoarray=lib, use a void pointer as type.\n+\t* trans.c (gfc_allocate_using_lib, gfc_allocate_allocatable):\n+\tHandle lock_type with -fcoarray=lib.\n+\n 2015-04-10  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/56674"}, {"sha": "91d2a85db682eada50a06c3aeafb4f3dd071ab8f", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 135, "deletions": 5, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "patch": "@@ -682,26 +682,26 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n \n \n tree\n-gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op type ATTRIBUTE_UNUSED)\n+gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)\n {\n   gfc_se se, argse;\n-  tree stat = NULL_TREE, lock_acquired = NULL_TREE;\n+  tree stat = NULL_TREE, stat2 = NULL_TREE;\n+  tree lock_acquired = NULL_TREE, lock_acquired2 = NULL_TREE;\n \n   /* Short cut: For single images without STAT= or LOCK_ACQUIRED\n      return early. (ERRMSG= is always untouched for -fcoarray=single.)  */\n   if (!code->expr2 && !code->expr4 && flag_coarray != GFC_FCOARRAY_LIB)\n     return NULL_TREE;\n \n-  gfc_init_se (&se, NULL);\n-  gfc_start_block (&se.pre);\n-\n   if (code->expr2)\n     {\n       gcc_assert (code->expr2->expr_type == EXPR_VARIABLE);\n       gfc_init_se (&argse, NULL);\n       gfc_conv_expr_val (&argse, code->expr2);\n       stat = argse.expr;\n     }\n+  else if (flag_coarray == GFC_FCOARRAY_LIB)\n+    stat = null_pointer_node;\n \n   if (code->expr4)\n     {\n@@ -710,6 +710,136 @@ gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op type ATTRIBUTE_UNUSED)\n       gfc_conv_expr_val (&argse, code->expr4);\n       lock_acquired = argse.expr;\n     }\n+  else if (flag_coarray == GFC_FCOARRAY_LIB)\n+    lock_acquired = null_pointer_node;\n+\n+  gfc_start_block (&se.pre);\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    {\n+      tree tmp, token, image_index, errmsg, errmsg_len;\n+      tree index = size_zero_node;\n+      tree caf_decl = gfc_get_tree_for_caf_expr (code->expr1);\n+\n+      if (code->expr1->symtree->n.sym->ts.type != BT_DERIVED\n+\t  || code->expr1->symtree->n.sym->ts.u.derived->from_intmod\n+\t     != INTMOD_ISO_FORTRAN_ENV\n+\t  || code->expr1->symtree->n.sym->ts.u.derived->intmod_sym_id\n+\t     != ISOFORTRAN_LOCK_TYPE)\n+\t{\n+\t  gfc_error (\"Sorry, the lock component of derived type at %L is not \"\n+\t\t     \"yet supported\", &code->expr1->where);\n+\t  return NULL_TREE;\n+\t}\n+\n+      gfc_get_caf_token_offset (&token, NULL, caf_decl, NULL_TREE, code->expr1);\n+\n+      if (gfc_is_coindexed (code->expr1))\n+\timage_index = gfc_caf_get_image_index (&se.pre, code->expr1, caf_decl);\n+      else\n+\timage_index = integer_zero_node;\n+\n+      /* For arrays, obtain the array index.  */\n+      if (gfc_expr_attr (code->expr1).dimension)\n+\t{\n+\t  tree desc, tmp, extent, lbound, ubound;\n+          gfc_array_ref *ar, ar2;\n+          int i;\n+\n+\t  /* TODO: Extend this, once DT components are supported.  */\n+\t  ar = &code->expr1->ref->u.ar;\n+\t  ar2 = *ar;\n+\t  memset (ar, '\\0', sizeof (*ar));\n+\t  ar->as = ar2.as;\n+\t  ar->type = AR_FULL;\n+\n+\t  gfc_init_se (&argse, NULL);\n+\t  argse.descriptor_only = 1;\n+\t  gfc_conv_expr_descriptor (&argse, code->expr1);\n+\t  gfc_add_block_to_block (&se.pre, &argse.pre);\n+\t  desc = argse.expr;\n+\t  *ar = ar2;\n+\n+\t  extent = integer_one_node;\n+\t  for (i = 0; i < ar->dimen; i++)\n+\t    {\n+\t      gfc_init_se (&argse, NULL);\n+\t      gfc_conv_expr_type (&argse, ar->start[i], integer_type_node);\n+\t      gfc_add_block_to_block (&argse.pre, &argse.pre);\n+\t      lbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     integer_type_node, argse.expr,\n+\t\t\t\t     fold_convert(integer_type_node, lbound));\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t     integer_type_node, extent, tmp);\n+\t      index = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t       integer_type_node, index, tmp);\n+\t      if (i < ar->dimen - 1)\n+\t\t{\n+\t\t  ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);\n+\t\t  tmp = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+\t\t  tmp = fold_convert (integer_type_node, tmp);\n+\t\t  extent = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t\t    integer_type_node, extent, tmp);\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* errmsg.  */\n+      if (code->expr3)\n+\t{\n+\t  gfc_init_se (&argse, NULL);\n+\t  gfc_conv_expr (&argse, code->expr3);\n+\t  gfc_add_block_to_block (&se.pre, &argse.pre);\n+\t  errmsg = argse.expr;\n+\t  errmsg_len = fold_convert (integer_type_node, argse.string_length);\n+\t}\n+      else\n+\t{\n+\t  errmsg = null_pointer_node;\n+\t  errmsg_len = integer_zero_node;\n+\t}\n+\n+      if (stat != null_pointer_node && TREE_TYPE (stat) != integer_type_node)\n+\t{\n+\t  stat2 = stat;\n+\t  stat = gfc_create_var (integer_type_node, \"stat\");\n+\t}\n+\n+      if (lock_acquired != null_pointer_node\n+\t  && TREE_TYPE (lock_acquired) != integer_type_node)\n+\t{\n+\t  lock_acquired2 = lock_acquired;\n+\t  lock_acquired = gfc_create_var (integer_type_node, \"acquired\");\n+\t}\n+\n+      if (op == EXEC_LOCK)\n+\ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_lock, 7,\n+                                   token, index, image_index,\n+\t\t\t\t   lock_acquired != null_pointer_node\n+\t\t\t\t   ? gfc_build_addr_expr (NULL, lock_acquired)\n+\t\t\t\t   : lock_acquired,\n+\t\t\t\t   stat != null_pointer_node\n+\t\t\t\t   ? gfc_build_addr_expr (NULL, stat) : stat,\n+\t\t\t\t   errmsg, errmsg_len);\n+      else\n+\ttmp = build_call_expr_loc (input_location, gfor_fndecl_caf_unlock, 6,\n+                                   token, index, image_index,\n+\t\t\t\t   stat != null_pointer_node\n+\t\t\t\t   ? gfc_build_addr_expr (NULL, stat) : stat,\n+\t\t\t\t   errmsg, errmsg_len);\n+      gfc_add_expr_to_block (&se.pre, tmp);\n+\n+      if (stat2 != NULL_TREE)\n+\tgfc_add_modify (&se.pre, stat2,\n+\t\t\tfold_convert (TREE_TYPE (stat2), stat));\n+\n+      if (lock_acquired2 != NULL_TREE)\n+\tgfc_add_modify (&se.pre, lock_acquired2,\n+\t\t\tfold_convert (TREE_TYPE (lock_acquired2),\n+\t\t\t\t      lock_acquired));\n+\n+      return gfc_finish_block (&se.pre);\n+    }\n \n   if (stat != NULL_TREE)\n     gfc_add_modify (&se.pre, stat, build_int_cst (TREE_TYPE (stat), 0));"}, {"sha": "0ad8ac2075842a5cda9f0b87052a4c542acfc7f5", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "patch": "@@ -2376,7 +2376,10 @@ gfc_get_derived_type (gfc_symbol * derived)\n   gfc_dt_list *dt;\n   gfc_namespace *ns;\n \n-  if (derived->attr.unlimited_polymorphic)\n+  if (derived->attr.unlimited_polymorphic\n+      || (flag_coarray == GFC_FCOARRAY_LIB\n+\t  && derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t  && derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE))\n     return ptr_type_node;\n \n   if (derived && derived->attr.flavor == FL_PROCEDURE"}, {"sha": "549e921b3fb73953cba19d0998c418f3261cabf4", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "patch": "@@ -700,7 +700,8 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n     }  */\n static void\n gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n-\t\t\ttree token, tree status, tree errmsg, tree errlen)\n+\t\t\ttree token, tree status, tree errmsg, tree errlen,\n+\t\t\tbool lock_var)\n {\n   tree tmp, pstat;\n \n@@ -730,7 +731,8 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n \t\t\t      MAX_EXPR, size_type_node, size,\n \t\t\t      build_int_cst (size_type_node, 1)),\n \t     build_int_cst (integer_type_node,\n-\t\t\t    GFC_CAF_COARRAY_ALLOC),\n+\t\t\t    lock_var ? GFC_CAF_LOCK_ALLOC\n+\t\t\t\t     : GFC_CAF_COARRAY_ALLOC),\n \t     token, pstat, errmsg, errlen);\n \n   tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n@@ -787,9 +789,22 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size, tree token,\n       && gfc_expr_attr (expr).codimension)\n     {\n       tree cond;\n+      bool lock_var = expr->ts.type == BT_DERIVED\n+\t\t      && expr->ts.u.derived->from_intmod\n+\t\t\t == INTMOD_ISO_FORTRAN_ENV\n+\t\t      && expr->ts.u.derived->intmod_sym_id\n+\t\t         == ISOFORTRAN_LOCK_TYPE;\n+      /* In the front end, we represent the lock variable as pointer. However,\n+\t the FE only passes the pointer around and leaves the actual\n+\t representation to the library. Hence, we have to convert back to the\n+\t number of elements.  */\n+      if (lock_var)\n+\tsize = fold_build2_loc (input_location, TRUNC_DIV_EXPR, size_type_node,\n+\t\t\t\tsize, TYPE_SIZE_UNIT (ptr_type_node));\n \n       gfc_allocate_using_lib (&alloc_block, mem, size, token, status,\n-\t\t\t      errmsg, errlen);\n+\t\t\t      errmsg, errlen, lock_var);\n+\n       if (status != NULL_TREE)\n \t{\n \t  TREE_USED (label_finish) = 1;"}, {"sha": "ae89b6a590250cbaa9f2d0130e4999afb71df151", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "patch": "@@ -1,3 +1,9 @@\n+2015-04-10  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/coarray_lock_6.f90: New.\n+\t* gfortran.dg/coarray_lock_7.f90: New.\n+\t* gfortran.dg/coarray/lock_2.f90: New.\n+\n 2015-04-10  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/56674"}, {"sha": "3afd8246ff4a8db8791eace76445e065253fcea2", "filename": "gcc/testsuite/gfortran.dg/coarray/lock_2.f90", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Flock_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Flock_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Flock_2.f90?ref=9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "patch": "@@ -0,0 +1,89 @@\n+! { dg-do run }\n+!\n+! LOCK/UNLOCK check\n+!\n+! PR fortran/18918\n+!\n+\n+use iso_fortran_env\n+implicit none\n+\n+type(lock_type), allocatable :: lock1[:]\n+type(lock_type), allocatable :: lock2(:,:)[:]\n+type(lock_type) :: lock3(4)[*]\n+integer :: stat\n+logical :: acquired\n+\n+allocate(lock1[*])\n+allocate(lock2(2,2)[*])\n+\n+LOCK(lock1)\n+UNLOCK(lock1)\n+\n+LOCK(lock2(1,1))\n+LOCK(lock2(2,2))\n+UNLOCK(lock2(1,1))\n+UNLOCK(lock2(2,2))\n+\n+LOCK(lock3(3))\n+LOCK(lock3(4))\n+UNLOCK(lock3(3))\n+UNLOCK(lock3(4))\n+\n+stat = 99\n+LOCK(lock1, stat=stat)\n+if (stat /= 0) call abort()\n+\n+LOCK(lock2(1,1), stat=stat)\n+if (stat /= 0) call abort()\n+LOCK(lock2(2,2), stat=stat)\n+if (stat /= 0) call abort()\n+\n+LOCK(lock3(3), stat=stat)\n+if (stat /= 0) call abort()\n+LOCK(lock3(4), stat=stat)\n+if (stat /= 0) call abort()\n+\n+stat = 99\n+UNLOCK(lock1, stat=stat)\n+if (stat /= 0) call abort()\n+\n+UNLOCK(lock2(1,1), stat=stat)\n+if (stat /= 0) call abort()\n+UNLOCK(lock2(2,2), stat=stat)\n+if (stat /= 0) call abort()\n+\n+UNLOCK(lock3(3), stat=stat)\n+if (stat /= 0) call abort()\n+UNLOCK(lock3(4), stat=stat)\n+if (stat /= 0) call abort()\n+\n+if (this_image() == 1) then\n+  acquired = .false.\n+  LOCK (lock1[this_image()], acquired_lock=acquired)\n+  if (.not. acquired) call abort()\n+\n+  acquired = .false.\n+  LOCK (lock2(1,1)[this_image()], acquired_lock=acquired)\n+  if (.not. acquired) call abort()\n+\n+  acquired = .false.\n+  LOCK (lock2(2,2)[this_image()], acquired_lock=acquired)\n+  if (.not. acquired) call abort()\n+\n+  acquired = .false.\n+  LOCK (lock3(3)[this_image()], acquired_lock=acquired)\n+  if (.not. acquired) call abort()\n+\n+  acquired = .false.\n+  LOCK (lock3(4)[this_image()], acquired_lock=acquired)\n+  if (.not. acquired) call abort()\n+\n+  UNLOCK (lock1[1])\n+  UNLOCK (lock2(1,1)[1])\n+  UNLOCK (lock2(2,2)[1])\n+  UNLOCK (lock3(3)[1])\n+  UNLOCK (lock3(4)[1])\n+end if\n+end\n+"}, {"sha": "f1f674e987cee1241c58f23611c05a9bb38c3b9b", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_6.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_6.f90?ref=9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=lib\" }\n+!\n+!\n+use iso_fortran_env\n+implicit none\n+\n+type t1\n+  type(lock_type), allocatable :: x[:]\n+end type t1\n+\n+type t2\n+  type(lock_type) :: x\n+end type t2\n+\n+type(t1) :: a\n+type(t2) :: b[*]\n+!class(lock_type), allocatable :: cl[:]\n+\n+lock(a%x) ! { dg-error \"the lock component of derived type at \\\\(1\\\\) is not yet supported\" }\n+lock(b%x) ! { dg-error \"the lock component of derived type at \\\\(1\\\\) is not yet supported\" }\n+!lock(cl)\n+\n+unlock(a%x) ! { dg-error \"the lock component of derived type at \\\\(1\\\\) is not yet supported\" }\n+unlock(b%x) ! { dg-error \"the lock component of derived type at \\\\(1\\\\) is not yet supported\" }\n+!unlock(cl)\n+end"}, {"sha": "d489b84598eeb1936bd860adea86674d6cd006ca", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_7.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_7.f90?ref=9f3880d1ecf46a2a1a5bd27a8d2bc4104a9bdd74", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original -fcoarray=lib\" }\n+!\n+use iso_fortran_env\n+implicit none\n+\n+type(lock_type) :: one[*]\n+type(lock_type) :: two(5,5)[*]\n+type(lock_type), allocatable :: three[:]\n+type(lock_type), allocatable :: four(:)[:]\n+integer :: ii\n+logical :: ll\n+\n+allocate(three[*], stat=ii)\n+allocate(four(7)[*], stat=ii)\n+\n+lock(one)\n+unlock(one)\n+\n+lock(two(3,3), stat=ii)\n+unlock(two(2,3), stat=ii)\n+\n+lock(three[4], acquired_lock=ll)\n+unlock(three[7], stat=ii)\n+\n+lock(four(1)[6], acquired_lock=ll, stat=ii)\n+unlock(four(2)[7])\n+end\n+\n+! { dg-final { scan-tree-dump-times \"one = \\\\(void \\\\* \\\\* restrict\\\\) _gfortran_caf_register \\\\(1, 2, \\\\(void \\\\* \\\\*\\\\) &caf_token.., 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"two = \\\\(void \\\\*\\\\\\[25\\\\\\] \\\\* restrict\\\\) _gfortran_caf_register \\\\(25, 2, \\\\(void \\\\* \\\\*\\\\) &caf_token.., 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"three.data = \\\\(void \\\\* restrict\\\\) _gfortran_caf_register \\\\(1, 3, &three.token, &stat.., 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"four.data = \\\\(void \\\\* restrict\\\\) _gfortran_caf_register \\\\(7, 3, &four.token, &stat.., 0B, 0\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(caf_token.., 0, 0, 0B, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_unlock \\\\(caf_token.., 0, 0, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(caf_token.., \\\\(3 - \\\\(integer\\\\(kind=4\\\\)\\\\) parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ \\\\(integer\\\\(kind=4\\\\)\\\\) MAX_EXPR <\\\\(parm...dim\\\\\\[0\\\\\\].ubound - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ 1, 0> \\\\* \\\\(3 - \\\\(integer\\\\(kind=4\\\\)\\\\) parm...dim\\\\\\[1\\\\\\].lbound\\\\), 0, 0B, &ii, 0B, 0\\\\);|_gfortran_caf_lock \\\\(caf_token.1, \\\\(3 - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ MAX_EXPR <\\\\(parm...dim\\\\\\[0\\\\\\].ubound - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ 1, 0> \\\\* \\\\(3 - parm...dim\\\\\\[1\\\\\\].lbound\\\\), 0, 0B, &ii, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_unlock \\\\(caf_token.., \\\\(2 - \\\\(integer\\\\(kind=4\\\\)\\\\) parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ \\\\(integer\\\\(kind=4\\\\)\\\\) MAX_EXPR <\\\\(parm...dim\\\\\\[0\\\\\\].ubound - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ 1, 0> \\\\* \\\\(3 - \\\\(integer\\\\(kind=4\\\\)\\\\) parm...dim\\\\\\[1\\\\\\].lbound\\\\), 0, &ii, 0B, 0\\\\);|_gfortran_caf_unlock \\\\(caf_token.., \\\\(2 - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ MAX_EXPR <\\\\(parm...dim\\\\\\[0\\\\\\].ubound - parm...dim\\\\\\[0\\\\\\].lbound\\\\) \\\\+ 1, 0> \\\\* \\\\(3 - parm...dim\\\\\\[1\\\\\\].lbound\\\\), 0, &ii, 0B, 0\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(three.token, 0, 5 - \\\\(integer\\\\(kind=4\\\\)\\\\) three.dim\\\\\\[0\\\\\\].lbound, &acquired.8, 0B, 0B, 0\\\\);|_gfortran_caf_lock \\\\(three.token, 0, 5 - three.dim\\\\\\[0\\\\\\].lbound, &acquired.., 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_unlock \\\\(three.token, 0, 8 - \\\\(integer\\\\(kind=4\\\\)\\\\) three.dim\\\\\\[0\\\\\\].lbound, &ii, 0B, 0\\\\);|_gfortran_caf_unlock \\\\(three.token, 0, 8 - three.dim\\\\\\[0\\\\\\].lbound, &ii, 0B, 0\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_lock \\\\(four.token, 1 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[0\\\\\\].lbound, 7 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[1\\\\\\].lbound, &acquired.., &ii, 0B, 0\\\\);|_gfortran_caf_lock \\\\(four.token, 1 - four.dim\\\\\\[0\\\\\\].lbound, 7 - four.dim\\\\\\[1\\\\\\].lbound, &acquired.., &ii, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_unlock \\\\(four.token, 2 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[0\\\\\\].lbound, 8 - \\\\(integer\\\\(kind=4\\\\)\\\\) four.dim\\\\\\[1\\\\\\].lbound, 0B, 0B, 0\\\\);|_gfortran_caf_unlock \\\\(four.token, 2 - four.dim\\\\\\[0\\\\\\].lbound, 8 - four.dim\\\\\\[1\\\\\\].lbound, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}