{"sha": "0903fcab883e00dd589e7fec4f26dca9b61b4a29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDkwM2ZjYWI4ODNlMDBkZDU4OWU3ZmVjNGYyNmRjYTliNjFiNGEyOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-01-20T00:05:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-01-20T00:05:32Z"}, "message": "i386-protos.h (ix86_compute_frame_size): Remove prototype.\n\n\t* i386-protos.h (ix86_compute_frame_size): Remove prototype.\n\t(ix86_initial_elimination_offset): Declare.\n\t* i386.c (ix86_nsaved_regs): Break out from ...\n\t(ix86_can_use_return_insn_p): ... here.\n\t(ix86_emit_save_regs): Break out from ...\n\t(ix86_expand_prologue): ... here.\n\t(ix86_emit_epilogue_esp_adjustment, ix86_emit_restore_regs): Break\n\tout from ...\n\t(ix86_expand_epilogue): ... here.\n\t(ix86_compute_frame_size): Make static, add prototype.\n\t(ix86_initial_elimination_offset): Break out from ...\n\t* i386.h (INITIAL_ELIMINATION_OFFSET): ... here.\n\nFrom-SVN: r31529", "tree": {"sha": "1ce8978bec4ca26b9c70b20e0ed5b0ec02d3bde3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ce8978bec4ca26b9c70b20e0ed5b0ec02d3bde3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0903fcab883e00dd589e7fec4f26dca9b61b4a29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0903fcab883e00dd589e7fec4f26dca9b61b4a29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0903fcab883e00dd589e7fec4f26dca9b61b4a29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0903fcab883e00dd589e7fec4f26dca9b61b4a29/comments", "author": null, "committer": null, "parents": [{"sha": "e774613011781485fcb8cebacd4296792f5572fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e774613011781485fcb8cebacd4296792f5572fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e774613011781485fcb8cebacd4296792f5572fe"}], "stats": {"total": 273, "additions": 173, "deletions": 100}, "files": [{"sha": "6118c7b8baa56623eb5e2cbd3b164a3d5c7b270e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0903fcab883e00dd589e7fec4f26dca9b61b4a29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0903fcab883e00dd589e7fec4f26dca9b61b4a29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0903fcab883e00dd589e7fec4f26dca9b61b4a29", "patch": "@@ -1,3 +1,18 @@\n+Thu Jan 20 01:01:23 MET 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386-protos.h (ix86_compute_frame_size): Remove prototype.\n+\t(ix86_initial_elimination_offset): Declare.\n+\t* i386.c (ix86_nsaved_regs): Break out from ...\n+\t(ix86_can_use_return_insn_p): ... here.\n+\t(ix86_emit_save_regs): Break out from ...\n+\t(ix86_expand_prologue): ... here.\n+\t(ix86_emit_epilogue_esp_adjustment, ix86_emit_restore_regs): Break\n+\tout from ...\n+\t(ix86_expand_epilogue): ... here.\n+\t(ix86_compute_frame_size): Make static, add prototype.\n+\t(ix86_initial_elimination_offset): Break out from ...\n+\t* i386.h (INITIAL_ELIMINATION_OFFSET): ... here.\n+\n 2000-01-19  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* recog.h (OUT_FCN): Delete."}, {"sha": "02ef4d08da628d2370790c45926e0168fda7a378", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0903fcab883e00dd589e7fec4f26dca9b61b4a29/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0903fcab883e00dd589e7fec4f26dca9b61b4a29/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=0903fcab883e00dd589e7fec4f26dca9b61b4a29", "patch": "@@ -27,7 +27,7 @@ extern int ix86_can_use_return_insn_p PARAMS ((void));\n \n extern void asm_output_function_prefix PARAMS ((FILE *, char *));\n extern void load_pic_register PARAMS ((void));\n-extern HOST_WIDE_INT ix86_compute_frame_size PARAMS ((HOST_WIDE_INT, int *));\n+extern HOST_WIDE_INT ix86_initial_elimination_offset PARAMS((int, int));\n extern void ix86_expand_prologue PARAMS ((void));\n extern void ix86_expand_epilogue PARAMS ((void));\n "}, {"sha": "ccb439f749f074fbf7f5b5585452dbd9af4f5e38", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 156, "deletions": 75, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0903fcab883e00dd589e7fec4f26dca9b61b4a29/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0903fcab883e00dd589e7fec4f26dca9b61b4a29/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0903fcab883e00dd589e7fec4f26dca9b61b4a29", "patch": "@@ -325,6 +325,11 @@ static void ix86_init_machine_status PARAMS ((struct function *));\n static void ix86_mark_machine_status PARAMS ((struct function *));\n static void ix86_split_to_parts PARAMS ((rtx, rtx *, enum machine_mode));\n static int ix86_safe_length_prefix PARAMS ((rtx));\n+static HOST_WIDE_INT ix86_compute_frame_size PARAMS((HOST_WIDE_INT, int *));\n+static int ix86_nsaved_regs PARAMS((void));\n+static void ix86_emit_save_regs PARAMS((void));\n+static void ix86_emit_restore_regs PARAMS((void));\n+static void ix86_emit_epilogue_esp_adjustment PARAMS((int));\n \n struct ix86_address\n {\n@@ -1434,13 +1439,6 @@ symbolic_reference_mentioned_p (op)\n int\n ix86_can_use_return_insn_p ()\n {\n-  int regno;\n-  int nregs = 0;\n-  int reglimit = (frame_pointer_needed\n-\t\t  ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n-  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n-\t\t\t\t  || current_function_uses_const_pool);\n-\n #ifdef NON_SAVING_SETJMP\n   if (NON_SAVING_SETJMP && current_function_calls_setjmp)\n     return 0;\n@@ -1449,12 +1447,7 @@ ix86_can_use_return_insn_p ()\n   if (! reload_completed)\n     return 0;\n \n-  for (regno = reglimit - 1; regno >= 0; regno--)\n-    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n-\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n-      nregs++;\n-\n-  return nregs == 0 || ! frame_pointer_needed;\n+  return ix86_nsaved_regs () == 0 || ! frame_pointer_needed;\n }\n \f\n static char *pic_label_name;\n@@ -1547,6 +1540,61 @@ gen_push (arg)\n \t\t      arg);\n }\n \n+/* Return number of registers to be saved on the stack.  */\n+\n+static int\n+ix86_nsaved_regs ()\n+{\n+  int nregs = 0;\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n+\t\t\t\t  || current_function_uses_const_pool);\n+  int limit = (frame_pointer_needed\n+\t       ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+  int regno;\n+\n+  for (regno = limit - 1; regno >= 0; regno--)\n+    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n+\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+      {\n+\tnregs ++;\n+      }\n+  return nregs;\n+}\n+\n+/* Return the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+HOST_WIDE_INT\n+ix86_initial_elimination_offset (from, to)\n+     int from;\n+     int to;\n+{\n+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n+    return 8;\t\t\t/* Skip saved PC and previous frame pointer */\n+  else\n+    {\n+      int nregs;\n+      int poffset;\n+      int offset;\n+      int preferred_alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n+      HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (),\n+\t\t\t\t\t\t     &nregs);\n+\n+      offset = (tsize + nregs * UNITS_PER_WORD);\n+\n+      poffset = 4;\n+      if (frame_pointer_needed)\n+\tpoffset += UNITS_PER_WORD;\n+\n+      if (from == ARG_POINTER_REGNUM)\n+\toffset += poffset;\n+      else\n+\toffset -= ((poffset + preferred_alignment - 1)\n+\t\t   & -preferred_alignment) - poffset;\n+      return offset;\n+    }\n+}\n+\n /* Compute the size of local storage taking into consideration the\n    desired stack alignment which is to be maintained.  Also determine\n    the number of registers saved below the local storage.  */\n@@ -1608,13 +1656,33 @@ ix86_compute_frame_size (size, nregs_on_stack)\n   return size + padding;\n }\n \n+/* Emit code to save registers in the prologue.  */\n+\n+static void\n+ix86_emit_save_regs ()\n+{\n+  register int regno;\n+  int limit;\n+  rtx insn;\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n+\t\t\t\t  || current_function_uses_const_pool);\n+  limit = (frame_pointer_needed\n+\t   ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+\n+  for (regno = limit - 1; regno >= 0; regno--)\n+    if ((regs_ever_live[regno] && !call_used_regs[regno])\n+\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+      {\n+\tinsn = emit_insn (gen_push (gen_rtx_REG (SImode, regno)));\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+      }\n+}\n+\n /* Expand the prologue into a bunch of separate insns. */\n \n void\n ix86_expand_prologue ()\n {\n-  register int regno;\n-  int limit;\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n   HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (), (int *)0);\n@@ -1664,15 +1732,7 @@ ix86_expand_prologue ()\n \t\t\t     CALL_INSN_FUNCTION_USAGE (insn));\n     }\n \n-  limit = (frame_pointer_needed ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n-  for (regno = limit - 1; regno >= 0; regno--)\n-    if ((regs_ever_live[regno] && ! call_used_regs[regno])\n-\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n-      {\n-\tinsn = emit_insn (gen_push (gen_rtx_REG (SImode, regno)));\n-\tRTX_FRAME_RELATED_P (insn) = 1;\n-      }\n-\n+  ix86_emit_save_regs ();\n #ifdef SUBTARGET_PROLOGUE\n   SUBTARGET_PROLOGUE;\n #endif  \n@@ -1687,14 +1747,80 @@ ix86_expand_prologue ()\n     emit_insn (gen_blockage ());\n }\n \n+/* Emit code to pop all registers from stack.  */\n+\n+static void\n+ix86_emit_restore_regs ()\n+{\n+  int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n+\t\t\t\t  || current_function_uses_const_pool);\n+  int limit = (frame_pointer_needed\n+\t       ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n+  int regno;\n+\n+  for (regno = 0; regno < limit; regno++)\n+    if ((regs_ever_live[regno] && !call_used_regs[regno])\n+\t|| (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n+      {\n+\temit_insn (gen_popsi1 (gen_rtx_REG (SImode, regno)));\n+      }\n+}\n+\n+/* Emit code to add TSIZE to esp value.  Use POP instruction when\n+   profitable.  */\n+\n+static void\n+ix86_emit_epilogue_esp_adjustment (tsize)\n+     int tsize;\n+{\n+  /* Intel's docs say that for 4 or 8 bytes of stack frame one should\n+     use `pop' and not `add'.  */\n+  int use_pop = tsize == 4;\n+  rtx edx = 0, ecx;\n+\n+  /* Use two pops only for the Pentium processors.  */\n+  if (tsize == 8 && !TARGET_386 && !TARGET_486)\n+    {\n+      rtx retval = current_function_return_rtx;\n+\n+      edx = gen_rtx_REG (SImode, 1);\n+\n+      /* This case is a bit more complex.  Since we cannot pop into\n+         %ecx twice we need a second register.  But this is only\n+         available if the return value is not of DImode in which\n+         case the %edx register is not available.  */\n+      use_pop = (retval == NULL\n+\t\t || !reg_overlap_mentioned_p (edx, retval));\n+    }\n+\n+  if (use_pop)\n+    {\n+      ecx = gen_rtx_REG (SImode, 2);\n+\n+      /* We have to prevent the two pops here from being scheduled.\n+         GCC otherwise would try in some situation to put other\n+         instructions in between them which has a bad effect.  */\n+      emit_insn (gen_blockage ());\n+      emit_insn (gen_popsi1 (ecx));\n+      if (tsize == 8)\n+\temit_insn (gen_popsi1 (edx));\n+    }\n+  else\n+    {\n+      /* If there is no frame pointer, we must still release the frame. */\n+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t     GEN_INT (tsize)));\n+    }\n+}\n+\n /* Restore function stack, frame, and registers. */\n \n void\n ix86_expand_epilogue ()\n {\n-  register int regno;\n-  register int limit;\n+  int regno;\n   int nregs;\n+  int limit;\n   int pic_reg_used = flag_pic && (current_function_uses_pic_offset_table\n \t\t\t\t  || current_function_uses_const_pool);\n   int sp_valid = !frame_pointer_needed || current_function_sp_is_unchanging;\n@@ -1710,9 +1836,6 @@ ix86_expand_epilogue ()\n      less work than reloading sp and popping the register.  Otherwise,\n      restore sp (if necessary) and pop the registers. */\n \n-  limit = (frame_pointer_needed\n-\t   ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n-\n   if (nregs > 1 || sp_valid)\n     {\n       if ( !sp_valid )\n@@ -1724,15 +1847,12 @@ ix86_expand_epilogue ()\n \t  emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, addr_offset));\n \t}\n \n-      for (regno = 0; regno < limit; regno++)\n-\tif ((regs_ever_live[regno] && ! call_used_regs[regno])\n-\t    || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n-\t  {\n-\t    emit_insn (gen_popsi1 (gen_rtx_REG (SImode, regno)));\n-\t  }\n+      ix86_emit_restore_regs ();\n     }\n   else\n     {\n+      limit = (frame_pointer_needed\n+\t       ? FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n       for (regno = 0; regno < limit; regno++)\n \tif ((regs_ever_live[regno] && ! call_used_regs[regno])\n \t    || (regno == PIC_OFFSET_TABLE_REGNUM && pic_reg_used))\n@@ -1756,46 +1876,7 @@ ix86_expand_epilogue ()\n \t}\n     }\n   else if (tsize)\n-    {\n-      /* Intel's docs say that for 4 or 8 bytes of stack frame one should\n-\t use `pop' and not `add'.  */\n-      int use_pop = tsize == 4;\n-      rtx edx = 0, ecx;\n-\n-      /* Use two pops only for the Pentium processors.  */\n-      if (tsize == 8 && !TARGET_386 && !TARGET_486)\n-\t{\n-\t  rtx retval = current_function_return_rtx;\n-\n-\t  edx = gen_rtx_REG (SImode, 1);\n-\n-\t  /* This case is a bit more complex.  Since we cannot pop into\n-\t     %ecx twice we need a second register.  But this is only\n-\t     available if the return value is not of DImode in which\n-\t     case the %edx register is not available.  */\n-\t  use_pop = (retval == NULL\n-\t\t     || ! reg_overlap_mentioned_p (edx, retval));\n-\t}\n-\n-      if (use_pop)\n-\t{\n-\t  ecx = gen_rtx_REG (SImode, 2);\n-\n-\t  /* We have to prevent the two pops here from being scheduled.\n-\t     GCC otherwise would try in some situation to put other\n-\t     instructions in between them which has a bad effect.  */\n-\t  emit_insn (gen_blockage ());\n-\t  emit_insn (gen_popsi1 (ecx));\n-\t  if (tsize == 8)\n-\t    emit_insn (gen_popsi1 (edx));\n-\t}\n-      else\n-\t{\n-\t  /* If there is no frame pointer, we must still release the frame. */\n-\t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t GEN_INT (tsize)));\n-\t}\n-    }\n+    ix86_emit_epilogue_esp_adjustment (tsize);\n \n #ifdef FUNCTION_BLOCK_PROFILER_EXIT\n   if (profile_block_flag == 2)"}, {"sha": "f7d08bb405fe4616da051ff008a7190cdb337878", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0903fcab883e00dd589e7fec4f26dca9b61b4a29/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0903fcab883e00dd589e7fec4f26dca9b61b4a29/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0903fcab883e00dd589e7fec4f26dca9b61b4a29", "patch": "@@ -1419,30 +1419,7 @@ do {\t\t\t\t\t\t\t\t\\\n    its replacement, at the start of a routine.  */\n \n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\t\\\n-    (OFFSET) = 8;\t/* Skip saved PC and previous frame pointer */\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      int nregs;\t\t\t\t\t\t\t\\\n-      int offset;\t\t\t\t\t\t\t\\\n-      int preferred_alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT; \\\n-      HOST_WIDE_INT tsize = ix86_compute_frame_size (get_frame_size (),\t\\\n-\t\t\t\t\t\t     &nregs);\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      (OFFSET) = (tsize + nregs * UNITS_PER_WORD);\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      offset = 4;\t\t\t\t\t\t\t\\\n-      if (frame_pointer_needed)\t\t\t\t\t\t\\\n-\toffset += UNITS_PER_WORD;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-      if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\t\\\n-\t(OFFSET) += offset;\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t(OFFSET) -= ((offset + preferred_alignment - 1)\t\t\t\\\n-\t\t     & -preferred_alignment) - offset;\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n+  (OFFSET) = ix86_initial_elimination_offset (FROM, TO)\n \f\n /* Addressing modes, and classification of registers for them.  */\n "}]}