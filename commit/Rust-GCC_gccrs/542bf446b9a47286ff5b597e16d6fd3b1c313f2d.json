{"sha": "542bf446b9a47286ff5b597e16d6fd3b1c313f2d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQyYmY0NDZiOWE0NzI4NmZmNWI1OTdlMTZkNmZkM2IxYzMxM2YyZA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-01-20T12:31:46Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-01-20T12:31:46Z"}, "message": "re PR target/49868 (Implement named address space to place/access data in flash memory)\n\n\tPR target/49868\n\tPR target/50887\n\t* doc/extend.texi (Named Address Spaces): Split into subsections.\n\t(AVR Named Address Spaces): New subsection.\n\t(M32C Named Address Spaces): New subsection.\n\t(RL78 Named Address Spaces): New subsection.\n\t(SPU Named Address Spaces): New subsection.\n\t(Variable Attributes): New anchor \"AVR Variable Attributes\".\n\t(AVR Variable Attributes): Rewrite and avoid wording\n\t\"address space\" in this context.\n\t* doc/invoke.texi (AVR Options): Rewrite and add documentation\n\tfor -maccumulate-args, -mbranch-cost=, -mrelax, -mshort-calls.\n\t(AVR Built-in Macros): New subsubsection therein.\n\t* doc/md.texi (AVR constraints): Remove \"C04\", \"R\".\n\nFrom-SVN: r183336", "tree": {"sha": "8e2b282a8761800179be0e0e740ef6c92b92a6a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e2b282a8761800179be0e0e740ef6c92b92a6a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/542bf446b9a47286ff5b597e16d6fd3b1c313f2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/542bf446b9a47286ff5b597e16d6fd3b1c313f2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/542bf446b9a47286ff5b597e16d6fd3b1c313f2d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/542bf446b9a47286ff5b597e16d6fd3b1c313f2d/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070"}], "stats": {"total": 518, "additions": 446, "deletions": 72}, "files": [{"sha": "a2aba48b93a597ba5ac44a61c872590781fd69fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542bf446b9a47286ff5b597e16d6fd3b1c313f2d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542bf446b9a47286ff5b597e16d6fd3b1c313f2d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=542bf446b9a47286ff5b597e16d6fd3b1c313f2d", "patch": "@@ -1,3 +1,20 @@\n+2012-01-20  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49868\n+\tPR target/50887\n+\t* doc/extend.texi (Named Address Spaces): Split into subsections.\n+\t(AVR Named Address Spaces): New subsection.\n+\t(M32C Named Address Spaces): New subsection.\n+\t(RL78 Named Address Spaces): New subsection.\n+\t(SPU Named Address Spaces): New subsection.\n+\t(Variable Attributes): New anchor \"AVR Variable Attributes\".\n+\t(AVR Variable Attributes): Rewrite and avoid wording\n+\t\"address space\" in this context.\n+\t* doc/invoke.texi (AVR Options): Rewrite and add documentation\n+\tfor -maccumulate-args, -mbranch-cost=, -mrelax, -mshort-calls.\n+\t(AVR Built-in Macros): New subsubsection therein.\n+\t* doc/md.texi (AVR constraints): Remove \"C04\", \"R\".\n+\n 2012-01-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/51903"}, {"sha": "dbc2ed682a1971d2bbd8997e0f9b09d98c4a3363", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 209, "deletions": 24, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542bf446b9a47286ff5b597e16d6fd3b1c313f2d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542bf446b9a47286ff5b597e16d6fd3b1c313f2d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=542bf446b9a47286ff5b597e16d6fd3b1c313f2d", "patch": "@@ -1215,15 +1215,207 @@ Pragmas to control overflow and rounding behaviors are not implemented.\n Fixed-point types are supported by the DWARF2 debug information format.\n \n @node Named Address Spaces\n-@section Named address spaces\n-@cindex named address spaces\n+@section Named Address Spaces\n+@cindex Named Address Spaces\n \n As an extension, the GNU C compiler supports named address spaces as\n defined in the N1275 draft of ISO/IEC DTR 18037.  Support for named\n address spaces in GCC will evolve as the draft technical report\n changes.  Calling conventions for any target might also change.  At\n-present, only the SPU, M32C, and RL78 targets support other address\n-spaces.  On the SPU target, for example, variables may be declared as\n+present, only the AVR, SPU, M32C, and RL78 targets support address\n+spaces other than the generic address space.\n+\n+Address space identifiers may be used exactly like any other C type\n+qualifier (e.g., @code{const} or @code{volatile}).  See the N1275\n+document for more details.\n+\n+@anchor{AVR Named Address Spaces}\n+@subsection AVR Named Address Spaces\n+\n+On the AVR target, there are several address spaces that can be used\n+in order to put read-only data into the flash memory and access that\n+data by means of the special instructions @code{LPM} or @code{ELPM}\n+needed to read from flash.\n+\n+Per default, any data including read-only data is located in RAM so\n+that address spaces are needed to locate read-only data in flash memory\n+@emph{and} to generate the right instructions to access the data\n+without using (inline) assembler code.\n+\n+@table @code\n+@item __pgm\n+@cindex @code{__pgm} AVR Named Address Spaces\n+The @code{__pgm} qualifier will locate data in the\n+@code{.progmem.data} section. Data will be read using the @code{LPM}\n+instruction. Pointers to this address space are 16 bits wide.\n+\n+@item __pgm1\n+@item __pgm2\n+@item __pgm3\n+@item __pgm4\n+@item __pgm5\n+@cindex @code{__pgm1} AVR Named Address Spaces\n+@cindex @code{__pgm2} AVR Named Address Spaces\n+@cindex @code{__pgm3} AVR Named Address Spaces\n+@cindex @code{__pgm4} AVR Named Address Spaces\n+@cindex @code{__pgm5} AVR Named Address Spaces\n+These are 16-bit address spaces locating data in section\n+@code{.progmem@var{N}.data} where @var{N} refers to\n+address space @code{__pgm@var{N}}.\n+The compiler will set the @code{RAMPZ} segment register approptiately \n+before reading data by means of the @code{ELPM} instruction.\n+\n+On devices with less 64kiB flash segments as indicated by the address\n+space, the compiler will cut down the segment number to a number the\n+device actually supports. Counting starts at @code{0}\n+for space @code{__pgm}. For example, if you access address space\n+@code{__pgm3} on an ATmega128 device with two 64@tie{}kiB flash segments,\n+the compiler will generate a read from @code{__pgm1}, i.e.@: it\n+will load @code{RAMPZ} with@tie{}@code{1} before reading.\n+\n+@item __pgmx\n+@cindex @code{__pgmx} AVR Named Address Spaces\n+This is a 24-bit address space that linearizes flash and RAM:\n+If the high bit of the address is set, data is read from\n+RAM using the lower two bytes as RAM address.\n+If the high bit of the address is clear, data is read from flash\n+with @code{RAMPZ} set according to the high byte of the address.\n+\n+Objects in this address space will be located in @code{.progmem.data}.\n+@end table\n+\n+For each named address space supported by avr-gcc there is an equally\n+named but uppercase built-in macro defined. \n+The purpose is to facilitate testing if respective address space\n+support is available or not:\n+\n+@example\n+#ifdef __PGM\n+const __pgm int var = 1;\n+\n+int read_i (void)\n+@{\n+    return i;\n+@}\n+#else\n+#include <avr/pgmspace.h> /* From avr-libc */\n+\n+const int var PROGMEM = 1;\n+\n+int read_i (void)\n+@{\n+    return (int) pgm_read_word (&i);\n+@}\n+#endif /* __PGM */\n+@end example\n+\n+Notice that attribute @ref{AVR Variable Attributes,@code{progmem}}\n+locates data in flash but\n+accesses to these data will be to generic address space, i.e.@: RAM,\n+so that you need special access functions like @code{pgm_read_byte}\n+from @w{@uref{http://nongnu.org/avr-libc/user-manual,avr-libc}}.\n+\n+@b{Limitations and caveats}\n+\n+@itemize\n+@item\n+Reading across the 64@tie{}KiB section boundary of\n+the @code{__pgm} or @code{__pgm@var{N}} address spaces\n+will show undefined behaviour. The only address space that\n+supports reading across the 64@tie{}KiB flash segment boundaries is\n+@code{__pgmx}.\n+\n+@item\n+If you use one if the @code{__pgm@var{N}} address spaces\n+you will have to arrange your linker skript to locate the\n+@code{.progmem@var{N}.data} sections according to your needs.\n+\n+@item\n+Any data or pointers to the AVR address spaces spaces must\n+also be qualified as @code{const}, i.e.@: as read-only data.\n+This still applies if the data in one of these address\n+spaces like software version number or lookup tables are intended to\n+be changed after load time by, say, a boot loader. In this case\n+the right qualification is @code{const} @code{volatile} so that the compiler\n+must not optimize away known values or insert them\n+as immediates into operands of instructions.\n+\n+@item\n+Code like the following is not yet supported because of missing\n+support in avr-binutils,\n+see @w{@uref{http://sourceware.org/PR13503,PR13503}}.\n+@example\n+extern const __pgmx char foo;\n+const __pgmx void *pfoo = &foo;\n+@end example\n+The code will throw an assembler warning and the high byte of\n+@code{pfoo} will be initialized with @code{0}, i.e.@: the\n+initialization will be as if @code{foo} was located in the first\n+64@tie{}KiB chunk of flash.\n+\n+@item\n+Address arithmetic for the @code{__pgmx} address space is carried out\n+as 16-bit signed integer arithmetic. This means that in the following\n+code array positions with offsets @code{idx}@tie{}>@tie{}8191 are\n+inaccessible.\n+\n+@example\n+extern const __pgmx long lookup[];\n+\n+long read_lookup (unsigned idx)\n+@{\n+    return lookup[idx];\n+@}\n+@end example\n+\n+@end itemize\n+\n+@b{Example}\n+\n+@example\n+char my_read (const __pgm ** p)\n+@{\n+    /* p is a pointer to RAM that points to a pointer to flash.\n+       The first indirection of p will read that flash pointer\n+       from RAM and the second indirection reads a char from this\n+       flash address.  */\n+\n+    return **p;\n+@}\n+\n+/* Locate array[] in flash memory */\n+const __pgm int array[] = @{ 3, 5, 7, 11, 13, 17, 19 @};\n+\n+int i = 1;\n+\n+int main (void)\n+@{\n+   /* Return 17 by reading from flash memory */\n+   return array[array[i]];\n+@}\n+@end example\n+\n+@subsection M32C Named Address Spaces\n+@cindex @code{__far} M32C Named Address Spaces\n+\n+On the M32C target, with the R8C and M16C cpu variants, variables\n+qualified with @code{__far} are accessed using 32-bit addresses in\n+order to access memory beyond the first 64@tie{}Ki bytes.  If\n+@code{__far} is used with the M32CM or M32C cpu variants, it has no\n+effect.\n+\n+@subsection RL78 Named Address Spaces\n+@cindex @code{__far} RL78 Named Address Spaces\n+\n+On the RL78 target, variables qualified with @code{__far} are accessed\n+with 32-bit pointers (20-bit addresses) rather than the default 16-bit\n+addresses.  Non-far variables are assumed to appear in the topmost\n+64@tie{}KiB of the address space.\n+\n+@subsection SPU Named Address Spaces\n+@cindex @code{__ea} SPU Named Address Spaces\n+\n+On the SPU target variables may be declared as\n belonging to another address space by qualifying the type with the\n @code{__ea} address space identifier:\n \n@@ -1236,20 +1428,6 @@ special code to access this variable.  It may use runtime library\n support, or generate special machine instructions to access that address\n space.\n \n-The @code{__ea} identifier may be used exactly like any other C type\n-qualifier (e.g., @code{const} or @code{volatile}).  See the N1275\n-document for more details.\n-\n-On the M32C target, with the R8C and M16C cpu variants, variables\n-qualified with @code{__far} are accessed using 32-bit addresses in\n-order to access memory beyond the first 64k bytes.  If @code{__far} is\n-used with the M32CM or M32C cpu variants, it has no effect.\n-\n-On the RL78 target, variables qualified with @code{__far} are accessed\n-with 32-bit pointers (20-bit addresses) rather than the default 16-bit\n-addresses.  Non-far variables are assumed to appear in the topmost 64\n-kB of the address space.\n-\n @node Zero Length\n @section Arrays of Length Zero\n @cindex arrays of length zero\n@@ -4563,17 +4741,24 @@ The @code{dllexport} attribute is described in @ref{Function Attributes}.\n \n @end table\n \n+@anchor{AVR Variable Attributes}\n @subsection AVR Variable Attributes\n \n @table @code\n @item progmem\n @cindex @code{progmem} AVR variable attribute\n-The @code{progmem} attribute is used on the AVR to place data in the program\n-memory address space (flash). This is accomplished by putting\n-respective variables into a section whose name starts with @code{.progmem}.\n-\n-AVR is a Harvard architecture processor and data and reas only data\n-normally resides in the data memory address space (RAM).\n+The @code{progmem} attribute is used on the AVR to place read-only\n+data in the non-volatile program memory (flash). The @code{progmem}\n+attribute accomplishes this by putting respective variables into a\n+section whose name starts with @code{.progmem}.\n+\n+This attrubute wirks similar to the @code{section} attribute\n+but adds additional checking. Notice that just like the\n+@code{section} attribute, @code{progmem} affects the location\n+of the data but not how this data is accessed.\n+\n+AVR is a Harvard architecture processor and data and read-only data\n+normally resides in the data memory (RAM).\n @end table\n \n @subsection Blackfin Variable Attributes"}, {"sha": "3b36c37ffbe2ef29ac6eb433c6bc1a58eec61e8f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 220, "deletions": 42, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542bf446b9a47286ff5b597e16d6fd3b1c313f2d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542bf446b9a47286ff5b597e16d6fd3b1c313f2d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=542bf446b9a47286ff5b597e16d6fd3b1c313f2d", "patch": "@@ -495,8 +495,9 @@ Objective-C and Objective-C++ Dialects}.\n -mfix-cortex-m3-ldrd}\n \n @emph{AVR Options}\n-@gccoptlist{-mmcu=@var{mcu}  -mno-interrupts @gol\n--mcall-prologues  -mtiny-stack  -mint8  -mstrict-X}\n+@gccoptlist{-mmcu=@var{mcu} -maccumulate-args -mbranch-cost=@var{cost} @gol\n+-mcall-prologues -mint8 -mno-interrupts -mrelax -mshort-calls @gol\n+-mstrict-X -mtiny-stack}\n \n @emph{Blackfin Options}\n @gccoptlist{-mcpu=@var{cpu}@r{[}-@var{sirevision}@r{]} @gol\n@@ -10897,41 +10898,99 @@ These options are defined for AVR implementations:\n @table @gcctabopt\n @item -mmcu=@var{mcu}\n @opindex mmcu\n-Specify ATMEL AVR instruction set or MCU type.\n+Specify Atmel AVR instruction set architectures (ISA) or MCU type.\n \n-Instruction set avr1 is for the minimal AVR core, not supported by the C\n-compiler, only for assembler programs (MCU types: at90s1200, attiny10,\n-attiny11, attiny12, attiny15, attiny28).\n+For a complete list of @var{mcu} values that are supported by avr-gcc,\n+see the compiler output when called with the @code{--help=target}\n+command line option.\n+The default for this option is@tie{}@code{avr2}.\n \n-Instruction set avr2 (default) is for the classic AVR core with up to\n-8K program memory space (MCU types: at90s2313, at90s2323, attiny22,\n-at90s2333, at90s2343, at90s4414, at90s4433, at90s4434, at90s8515,\n-at90c8534, at90s8535).\n+avr-gcc supports the following AVR devices and ISAs:\n \n-Instruction set avr3 is for the classic AVR core with up to 128K program\n-memory space (MCU types: atmega103, atmega603, at43usb320, at76c711).\n+@table @code\n \n-Instruction set avr4 is for the enhanced AVR core with up to 8K program\n-memory space (MCU types: atmega8, atmega83, atmega85).\n+@item avr1\n+This ISA is implemented by the minimal AVR core and supported\n+for assembler only.\n+@*@var{mcu}@tie{}= @code{at90s1200},\n+@code{attiny10}, @code{attiny11}, @code{attiny12}, @code{attiny15},\n+@code{attiny28}.\n+\n+@item avr2\n+``Classic'' devices with up to 8@tie{}KiB of program memory.\n+@*@var{mcu}@tie{}= @code{at90s2313}, @code{attiny26}, @code{at90c8534},\n+@dots{}\n+\n+@item avr25\n+``Classic'' devices with up to 8@tie{}KiB of program memory and with\n+the @code{MOVW} instruction.\n+@*@var{mcu}@tie{}= @code{attiny2313}, @code{attiny261}, @code{attiny24},\n+@dots{}\n+\n+@item avr3\n+``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory.\n+@*@var{mcu}@tie{}= @code{at43usb355}, @code{at76c711}.\n+\n+@item avr31\n+``Classic'' devices with 128@tie{}KiB of program memory.\n+@*@var{mcu}@tie{}= @code{atmega103}, @code{at43usb320}.\n+\n+@item avr35\n+``Classic'' devices with 16@tie{}KiB up to 64@tie{}KiB of program\n+memory and with the @code{MOVW} instruction.\n+@*@var{mcu}@tie{}= @code{at90usb162}, @code{atmega8u2},\n+@code{attiny167}, @dots{}\n+\n+@item avr4\n+``Enhanced'' devices with up to 8@tie{}KiB of program memory.\n+@*@var{mcu}@tie{}= @code{atmega8}, @code{atmega88}, @code{at90pwm81},\n+@dots{}\n+\n+@item avr5\n+``Enhanced'' devices with 16@tie{}KiB up to 64@tie{}KiB of program memory.\n+@*@var{mcu}@tie{}= @code{atmega16}, @code{atmega6490}, @code{at90can64},\n+@dots{}\n+\n+@item avr51\n+``Enhanced'' devices with 128@tie{}KiB of program memory.\n+@*@var{mcu}@tie{}= @code{atmega128}, @code{at90can128}, @code{at90usb1287},\n+@dots{}\n+\n+@item avr6\n+``Enhanced'' devices with 3-byte PC, i.e.@: with at least 256@tie{}KiB\n+of program memory.\n+@*@var{mcu}@tie{}= @code{atmega2560}, @code{atmega2561}.\n \n-Instruction set avr5 is for the enhanced AVR core with up to 128K program\n-memory space (MCU types: atmega16, atmega161, atmega163, atmega32, atmega323,\n-atmega64, atmega128, at43usb355, at94k).\n+@end table\n \n-@item -mno-interrupts\n-@opindex mno-interrupts\n-Generated code is not compatible with hardware interrupts.\n-Code size will be smaller.\n+\n+@item -maccumulate-args\n+@opindex maccumulate-args\n+Accumulate outgoing function arguments and acquire/release the needed\n+stack space for outgoing function arguments once in function\n+prologue/epilogue.  Without this option, outgoing arguments are pushed\n+before calling a function and popped afterwards.\n+\n+Popping the arguments after the function call can be expensive on\n+AVR so that accumulating the stack space might lead to smaller\n+executables because areguments need not to be removed from the\n+stack after such a function call.\n+\n+This option can lead to reduced code size for functions that get\n+their arguments on the stack like functions that perform several\n+calls to printf-like functions.\n+\n+@item -mbranch-cost=@var{cost}\n+@opindex mbranch-cost\n+Set the branch costs for conditional branch instructions to\n+@var{cost}.  Reasonable values for @var{cost} are small, non-negative\n+integers. The default branch cost is 0.\n \n @item -mcall-prologues\n @opindex mcall-prologues\n Functions prologues/epilogues expanded as call to appropriate\n subroutines.  Code size will be smaller.\n \n-@item -mtiny-stack\n-@opindex mtiny-stack\n-Change only the low 8 bits of the stack pointer.\n-\n @item -mint8\n @opindex mint8\n Assume int to be 8 bit integer.  This affects the sizes of all types: A\n@@ -10940,38 +10999,69 @@ and long long will be 4 bytes.  Please note that this option does not\n comply to the C standards, but it will provide you with smaller code\n size.\n \n+@item -mno-interrupts\n+@opindex mno-interrupts\n+Generated code is not compatible with hardware interrupts.\n+Code size will be smaller.\n+\n+@item -mrelax\n+@opindex mrelax\n+Try to replace @code{CALL} resp.@: @code{JMP} instruction by the shorter\n+@code{RCALL} resp.@: @code{RJMP} instruction if applicable.\n+Setting @code{-mrelax} just adds the @code{--relax} option to the\n+linker command line when the linker is called.\n+\n+Jump relaxing is performed by the linker because jump offsets are not\n+known before code is located. Therefore, the assembler code generated by the\n+compiler will be the same, but the instructions in the executable may\n+differ from instructions in the assembler code.\n+\n+@item -mshort-calls\n+@opindex mshort-calls\n+Use @code{RCALL}/@code{RJMP} instructions even on devices with\n+16@tie{}KiB or more of program memory, i.e.@: on devices that\n+have the @code{CALL} and @code{JMP} instructions.\n+See also the @code{-mrelax} command line option.\n+\n @item -mstrict-X\n @opindex mstrict-X\n-Use register @code{X} in a way proposed by the hardware.  This means\n+Use address register @code{X} in a way proposed by the hardware.  This means\n that @code{X} will only be used in indirect, post-increment or\n pre-decrement addressing.\n \n Without this option, the @code{X} register may be used in the same way\n as @code{Y} or @code{Z} which then is emulated by additional\n instructions.  \n For example, loading a value with @code{X+const} addressing with a\n-small @code{const <= 63} to a register @var{Rn} will be printed as\n+small non-negative @code{const < 64} to a register @var{Rn} will be\n+performed as\n+\n @example\n-adiw r26, const\n-ld   @var{Rn}, X\n-sbiw r26, const\n+adiw r26, const   ; X += const\n+ld   @var{Rn}, X        ; @var{Rn} = *X\n+sbiw r26, const   ; X -= const\n @end example\n+\n+@item -mtiny-stack\n+@opindex mtiny-stack\n+Only use the lower 8@tie{}bits of the stack pointer and assume that the high\n+byte of SP is always zero.\n @end table\n \n-@subsubsection @code{EIND} and Devices with more than 128k Bytes of Flash\n+@subsubsection @code{EIND} and Devices with more than 128 Ki Bytes of Flash\n \n-Pointers in the implementation are 16 bits wide.\n+Pointers in the implementation are 16@tie{}bits wide.\n The address of a function or label is represented as word address so\n-that indirect jumps and calls can address any code address in the\n-range of 64k words.\n+that indirect jumps and calls can target any code address in the\n+range of 64@tie{}Ki words.\n \n-In order to faciliate indirect jump on devices with more than 128k\n+In order to facilitate indirect jump on devices with more than 128@tie{}Ki\n bytes of program memory space, there is a special function register called\n @code{EIND} that serves as most significant part of the target address\n when @code{EICALL} or @code{EIJMP} instructions are used.\n \n-Indirect jumps and calls on these devices are handled as follows and\n-are subject to some limitations:\n+Indirect jumps and calls on these devices are handled as follows by\n+the compiler and are subject to some limitations:\n \n @itemize @bullet\n \n@@ -10986,19 +11076,20 @@ For the impact of avr-libc on @code{EIND}, see the\n \n @item\n The compiler uses @code{EIND} implicitely in @code{EICALL}/@code{EIJMP}\n-instructions or might read @code{EIND} directly.\n+instructions or might read @code{EIND} directly in order to emulate an\n+indirect call/jump by means of a @code{RET} instruction.\n \n @item\n The compiler assumes that @code{EIND} never changes during the startup\n-code or run of the application. In particular, @code{EIND} is not\n+code or during the application. In particular, @code{EIND} is not\n saved/restored in function or interrupt service routine\n prologue/epilogue.\n \n @item\n It is legitimate for user-specific startup code to set up @code{EIND}\n early, for example by means of initialization code located in\n-section @code{.init3}, and thus prior to general startup code that\n-initializes RAM and calls constructors.\n+section @code{.init3}. Such code runs prior to general startup code\n+that initializes RAM and calls constructors.\n \n @item\n For indirect calls to functions and computed goto, the linker will\n@@ -11053,7 +11144,8 @@ int main (void)\n @}\n @end example\n \n-Instead, a stub has to be set up:\n+Instead, a stub has to be set up, i.e.@: the function has to be called\n+through a symbol (@code{func_4} in the example):\n \n @example\n int main (void)\n@@ -11069,6 +11161,92 @@ and the application be linked with @code{-Wl,--defsym,func_4=0x4}.\n Alternatively, @code{func_4} can be defined in the linker script.\n @end itemize\n \n+@subsubsection AVR Built-in Macros\n+\n+avr-gcc defines several built-in macros so that the user code can test\n+for presence of absence of features.  Almost any of the following\n+built-in macros are deduced from device capabilities and thus\n+triggered by the @code{-mmcu=} command line option.\n+\n+For even more AVR-specific built-in macros see\n+@ref{AVR Named Address Spaces} and @ref{AVR Built-in Functions}.\n+\n+@table @code\n+\n+@item __AVR_@var{Device}__\n+Setting @code{-mmcu=@var{device}} defines this built-in macro that reflects\n+the device's name. For example, @code{-mmcu=atmega8} will define the\n+built-in macro @code{__AVR_ATmega8__}, @code{-mmcu=attiny261a} defines\n+@code{__AVR_ATtiny261A__}, etc.\n+\n+The built-in macros' names follow\n+the scheme @code{__AVR_@var{Device}__} where @var{Device} is\n+the device name as from the AVR user manual. The difference between\n+@var{Device} in the built-in macro and @var{device} in\n+@code{-mmcu=@var{device}} is that the latter is always lower case.\n+\n+@item __AVR_HAVE_RAMPZ__\n+@item __AVR_HAVE_ELPM__\n+The device has the @code{RAMPZ} special function register and thus the\n+@code{ELPM} instruction.\n+\n+@item __AVR_HAVE_ELPMX__\n+The device has the @code{ELPM R@var{n},Z} and @code{ELPM\n+R@var{n},Z+} instructions.\n+\n+@item __AVR_HAVE_MOVW__\n+The device has the @code{MOVW} instruction to perform 16-bit\n+register-register moves.\n+\n+@item __AVR_HAVE_LPMX__\n+The device has the @code{LPM R@var{n},Z} and @code{LPM\n+R@var{n},Z+} instructions.\n+\n+@item __AVR_HAVE_MUL__\n+The device has a hardware multiplier. \n+\n+@item __AVR_HAVE_JMP_CALL__\n+The device has the @code{JMP} and @code{CALL} instructions.\n+This is the case for devices with at least 16@tie{}KiB of program\n+memory and if @code{-mshort-calls} is not set.\n+\n+@item __AVR_HAVE_EIJMP_EICALL__\n+@item __AVR_3_BYTE_PC__\n+The device has the @code{EIJMP} and @code{EICALL} instructions.\n+This is the case for devices with at least 256@tie{}KiB of program memory.\n+This also means that the program counter\n+(PC) is 3@tie{}bytes wide.\n+\n+@item __AVR_2_BYTE_PC__\n+The program counter (PC) is 2@tie{}bytes wide. This is the case for devices\n+with up to 128@tie{}KiB of program memory.\n+\n+@item __AVR_HAVE_8BIT_SP__\n+@item __AVR_HAVE_16BIT_SP__\n+The stack pointer (SP) is 8@tie{}bits resp. 16@tie{}bits wide.\n+The definition of these macros is affected by @code{-mtiny-stack}.\n+\n+@item __NO_INTERRUPTS__\n+This macro reflects the @code{-mno-interrupts} command line option.\n+\n+@item __AVR_ERRATA_SKIP__\n+@item __AVR_ERRATA_SKIP_JMP_CALL__\n+Some AVR devices (AT90S8515, ATmega103) must not skip 32-bit\n+instructions because of a hardware erratum.  Skip instructions are\n+@code{SBRS}, @code{SBRC}, @code{SBIS}, @code{SBIC} and @code{CPSE}.\n+The second macro is only defined if @code{__AVR_HAVE_JMP_CALL__} is also\n+set.\n+\n+@item __AVR_SFR_OFFSET__=@var{offset}\n+Instructions that can address I/O special function registers directly\n+like @code{IN}, @code{OUT}, @code{SBI}, etc.@: may use a different\n+address as if addressed by an instruction to access RAM like @code{LD}\n+or @code{STS}. This offset depends on the device architecture and has\n+to be subtracted from the RAM address in order to get the\n+respective I/O@tie{}address.\n+\n+@end table\n+\n @node Blackfin Options\n @subsection Blackfin Options\n @cindex Blackfin Options"}, {"sha": "bcfd4204cbac90b5851a0d2eca1aa9f849f61eb4", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/542bf446b9a47286ff5b597e16d6fd3b1c313f2d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/542bf446b9a47286ff5b597e16d6fd3b1c313f2d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=542bf446b9a47286ff5b597e16d6fd3b1c313f2d", "patch": "@@ -1768,14 +1768,8 @@ Constant integer 1\n @item G\n A floating point constant 0.0\n \n-@item R\n-Integer constant in the range @minus{}6 @dots{} 5.\n-\n @item Q\n A memory address based on Y or Z pointer with displacement.\n-\n-@item C04\n-Constant integer 4\n @end table\n \n @item Epiphany---@file{config/epiphany/constraints.md}"}]}