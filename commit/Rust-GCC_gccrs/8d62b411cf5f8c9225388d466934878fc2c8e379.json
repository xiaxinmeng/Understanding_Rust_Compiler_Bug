{"sha": "8d62b411cf5f8c9225388d466934878fc2c8e379", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ2MmI0MTFjZjVmOGM5MjI1Mzg4ZDQ2NjkzNDg3OGZjMmM4ZTM3OQ==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@issan.informatik.uni-dortmund.de", "date": "1998-06-12T01:26:05Z"}, "committer": {"name": "Andreas Schwab", "email": "schwab@gcc.gnu.org", "date": "1998-06-12T01:26:05Z"}, "message": "expr.c (do_jump, [...]): When comparing complex prevent operands from being evaluated twice.\n\n\t* expr.c (do_jump, case EQ_EXPR, NE_EXPR): When comparing complex\n\tprevent operands from being evaluated twice.\n\nFrom-SVN: r20440", "tree": {"sha": "efa1becff2dee8ed7616a79c5cb11b2fe8ddad5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efa1becff2dee8ed7616a79c5cb11b2fe8ddad5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d62b411cf5f8c9225388d466934878fc2c8e379", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d62b411cf5f8c9225388d466934878fc2c8e379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d62b411cf5f8c9225388d466934878fc2c8e379", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d62b411cf5f8c9225388d466934878fc2c8e379/comments", "author": null, "committer": null, "parents": [{"sha": "b91feb181159a1c381fed21e3ef691436fe26a04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b91feb181159a1c381fed21e3ef691436fe26a04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b91feb181159a1c381fed21e3ef691436fe26a04"}], "stats": {"total": 85, "additions": 49, "deletions": 36}, "files": [{"sha": "96dc22cbc95b22ec836aa0af98101db49edced95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d62b411cf5f8c9225388d466934878fc2c8e379/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d62b411cf5f8c9225388d466934878fc2c8e379/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d62b411cf5f8c9225388d466934878fc2c8e379", "patch": "@@ -1,3 +1,8 @@\n+Fri Jun 12 10:23:36 1998  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n+\n+\t* expr.c (do_jump, case EQ_EXPR, NE_EXPR): When comparing complex\n+\tprevent operands from being evaluated twice.\n+\n Fri Jun 12 00:50:27 1998  Sergey Okhapkin <sos@prospect.com.ru>\n \n \t* toplev.c (lang_options): Add -remap as a preprocessor option."}, {"sha": "657737f63e0dfa39dad5cc55eb37ed5083ea5e03", "filename": "gcc/expr.c", "status": "modified", "additions": 44, "deletions": 36, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d62b411cf5f8c9225388d466934878fc2c8e379/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d62b411cf5f8c9225388d466934878fc2c8e379/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8d62b411cf5f8c9225388d466934878fc2c8e379", "patch": "@@ -10007,24 +10007,28 @@ do_jump (exp, if_false_label, if_true_label)\n \t  do_jump (TREE_OPERAND (exp, 0), if_true_label, if_false_label);\n \telse if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_COMPLEX_FLOAT\n \t\t || GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_COMPLEX_INT)\n-\t  do_jump\n-\t    (fold\n-\t     (build (TRUTH_ANDIF_EXPR, TREE_TYPE (exp),\n-\t\t     fold (build (EQ_EXPR, TREE_TYPE (exp),\n-\t\t\t\t  fold (build1 (REALPART_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (inner_type),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 0))),\n-\t\t\t\t  fold (build1 (REALPART_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (inner_type),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 1))))),\n-\t\t     fold (build (EQ_EXPR, TREE_TYPE (exp),\n-\t\t\t\t  fold (build1 (IMAGPART_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (inner_type),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 0))),\n-\t\t\t\t  fold (build1 (IMAGPART_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (inner_type),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 1))))))),\n-\t     if_false_label, if_true_label);\n+\t  {\n+\t    tree exp0 = save_expr (TREE_OPERAND (exp, 0));\n+\t    tree exp1 = save_expr (TREE_OPERAND (exp, 1));\n+\t    do_jump\n+\t      (fold\n+\t       (build (TRUTH_ANDIF_EXPR, TREE_TYPE (exp),\n+\t\t       fold (build (EQ_EXPR, TREE_TYPE (exp),\n+\t\t\t\t    fold (build1 (REALPART_EXPR,\n+\t\t\t\t\t\t  TREE_TYPE (inner_type),\n+\t\t\t\t\t\t  exp0)),\n+\t\t\t\t    fold (build1 (REALPART_EXPR,\n+\t\t\t\t\t\t  TREE_TYPE (inner_type),\n+\t\t\t\t\t\t  exp1)))),\n+\t\t       fold (build (EQ_EXPR, TREE_TYPE (exp),\n+\t\t\t\t    fold (build1 (IMAGPART_EXPR,\n+\t\t\t\t\t\t  TREE_TYPE (inner_type),\n+\t\t\t\t\t\t  exp0)),\n+\t\t\t\t    fold (build1 (IMAGPART_EXPR,\n+\t\t\t\t\t\t  TREE_TYPE (inner_type),\n+\t\t\t\t\t\t  exp1)))))),\n+\t       if_false_label, if_true_label);\n+\t  }\n \telse if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n \t\t && !can_compare_p (TYPE_MODE (inner_type)))\n \t  do_jump_by_parts_equality (exp, if_false_label, if_true_label);\n@@ -10041,24 +10045,28 @@ do_jump (exp, if_false_label, if_true_label)\n \t  do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n \telse if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_COMPLEX_FLOAT\n \t\t || GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_COMPLEX_INT)\n-\t  do_jump\n-\t    (fold\n-\t     (build (TRUTH_ORIF_EXPR, TREE_TYPE (exp),\n-\t\t     fold (build (NE_EXPR, TREE_TYPE (exp),\n-\t\t\t\t  fold (build1 (REALPART_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (inner_type),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 0))),\n-\t\t\t\t  fold (build1 (REALPART_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (inner_type),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 1))))),\n-\t\t     fold (build (NE_EXPR, TREE_TYPE (exp),\n-\t\t\t\t  fold (build1 (IMAGPART_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (inner_type),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 0))),\n-\t\t\t\t  fold (build1 (IMAGPART_EXPR,\n-\t\t\t\t\t\tTREE_TYPE (inner_type),\n-\t\t\t\t\t\tTREE_OPERAND (exp, 1))))))),\n-\t     if_false_label, if_true_label);\n+\t  {\n+\t    tree exp0 = save_expr (TREE_OPERAND (exp, 0));\n+\t    tree exp1 = save_expr (TREE_OPERAND (exp, 1));\n+\t    do_jump\n+\t      (fold\n+\t       (build (TRUTH_ORIF_EXPR, TREE_TYPE (exp),\n+\t\t       fold (build (NE_EXPR, TREE_TYPE (exp),\n+\t\t\t\t    fold (build1 (REALPART_EXPR,\n+\t\t\t\t\t\t  TREE_TYPE (inner_type),\n+\t\t\t\t\t\t  exp0)),\n+\t\t\t\t    fold (build1 (REALPART_EXPR,\n+\t\t\t\t\t\t  TREE_TYPE (inner_type),\n+\t\t\t\t\t\t  exp1)))),\n+\t\t       fold (build (NE_EXPR, TREE_TYPE (exp),\n+\t\t\t\t    fold (build1 (IMAGPART_EXPR,\n+\t\t\t\t\t\t  TREE_TYPE (inner_type),\n+\t\t\t\t\t\t  exp0)),\n+\t\t\t\t    fold (build1 (IMAGPART_EXPR,\n+\t\t\t\t\t\t  TREE_TYPE (inner_type),\n+\t\t\t\t\t\t  exp1)))))),\n+\t       if_false_label, if_true_label);\n+\t  }\n \telse if (GET_MODE_CLASS (TYPE_MODE (inner_type)) == MODE_INT\n \t\t && !can_compare_p (TYPE_MODE (inner_type)))\n \t  do_jump_by_parts_equality (exp, if_true_label, if_false_label);"}]}