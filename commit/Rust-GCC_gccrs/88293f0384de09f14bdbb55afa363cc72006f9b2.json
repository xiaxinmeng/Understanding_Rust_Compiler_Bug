{"sha": "88293f0384de09f14bdbb55afa363cc72006f9b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgyOTNmMDM4NGRlMDlmMTRiZGJiNTVhZmEzNjNjYzcyMDA2ZjliMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-01-25T10:51:47Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-01-25T10:51:47Z"}, "message": "utils.c (convert_to_fat_pointer): Un-obfuscate the conversion from a thin pointer with a shifted value.\n\n\t* gcc-interface/utils.c (convert_to_fat_pointer): Un-obfuscate the\n\tconversion from a thin pointer with a shifted value.\n\t* gcc-interface/utils2.c (gnat_build_constructor): Propagate the\n\tread-only flag from the values onto the result.\n\t(gnat_invariant_expr): Accept read-only CONSTRUCTORs.\n\nFrom-SVN: r207073", "tree": {"sha": "9af0986644e6850485cbac6372243960c42ad5af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9af0986644e6850485cbac6372243960c42ad5af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88293f0384de09f14bdbb55afa363cc72006f9b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88293f0384de09f14bdbb55afa363cc72006f9b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88293f0384de09f14bdbb55afa363cc72006f9b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88293f0384de09f14bdbb55afa363cc72006f9b2/comments", "author": null, "committer": null, "parents": [{"sha": "ae56e44284592b1e8cca35f870e0240e65e141c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae56e44284592b1e8cca35f870e0240e65e141c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae56e44284592b1e8cca35f870e0240e65e141c5"}], "stats": {"total": 75, "additions": 48, "deletions": 27}, "files": [{"sha": "2ef6bbe6777ad7ca07aecc0d82150f7e57d98197", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88293f0384de09f14bdbb55afa363cc72006f9b2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88293f0384de09f14bdbb55afa363cc72006f9b2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=88293f0384de09f14bdbb55afa363cc72006f9b2", "patch": "@@ -1,3 +1,11 @@\n+2014-01-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils.c (convert_to_fat_pointer): Un-obfuscate the\n+\tconversion from a thin pointer with a shifted value.\n+\t* gcc-interface/utils2.c (gnat_build_constructor): Propagate the\n+\tread-only flag from the values onto the result.\n+\t(gnat_invariant_expr): Accept read-only CONSTRUCTORs.\n+\n 2014-01-25  Tristan Gingold  <gingold@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): Always build a variable"}, {"sha": "014fe361b76d333500ee17ab505e0f6c3386971e", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88293f0384de09f14bdbb55afa363cc72006f9b2/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88293f0384de09f14bdbb55afa363cc72006f9b2/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=88293f0384de09f14bdbb55afa363cc72006f9b2", "patch": "@@ -4352,7 +4352,7 @@ convert_to_fat_pointer (tree type, tree expr)\n   tree template_type = TREE_TYPE (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (type))));\n   tree p_array_type = TREE_TYPE (TYPE_FIELDS (type));\n   tree etype = TREE_TYPE (expr);\n-  tree template_tree;\n+  tree template_addr;\n   vec<constructor_elt, va_gc> *v;\n   vec_alloc (v, 2);\n \n@@ -4395,31 +4395,43 @@ convert_to_fat_pointer (tree type, tree expr)\n       tree field = TYPE_FIELDS (TREE_TYPE (etype));\n \n       expr = gnat_protect_expr (expr);\n-      if (TREE_CODE (expr) == ADDR_EXPR)\n-\texpr = TREE_OPERAND (expr, 0);\n-      else\n+\n+      /* If we have a TYPE_UNCONSTRAINED_ARRAY attached to the RECORD_TYPE,\n+\t the thin pointer value has been shifted so we shift it back to get\n+\t the template address.  */\n+      if (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (etype)))\n \t{\n-\t  /* If we have a TYPE_UNCONSTRAINED_ARRAY attached to the RECORD_TYPE,\n-\t     the thin pointer value has been shifted so we first need to shift\n-\t     it back to get the template address.  */\n-\t  if (TYPE_UNCONSTRAINED_ARRAY (TREE_TYPE (etype)))\n-\t    expr\n-\t      = build_binary_op (POINTER_PLUS_EXPR, etype, expr,\n-\t\t\t\t fold_build1 (NEGATE_EXPR, sizetype,\n-\t\t\t\t\t      byte_position\n-\t\t\t\t\t      (DECL_CHAIN (field))));\n-\t  expr = build1 (INDIRECT_REF, TREE_TYPE (etype), expr);\n+\t  template_addr\n+\t    = build_binary_op (POINTER_PLUS_EXPR, etype, expr,\n+\t\t\t       fold_build1 (NEGATE_EXPR, sizetype,\n+\t\t\t\t\t    byte_position\n+\t\t\t\t\t    (DECL_CHAIN (field))));\n+\t  template_addr\n+\t    = fold_convert (TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (type))),\n+\t\t\t    template_addr);\n \t}\n \n-      template_tree = build_component_ref (expr, NULL_TREE, field, false);\n-      expr = build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t     build_component_ref (expr, NULL_TREE,\n-\t\t\t\t\t\t  DECL_CHAIN (field), false));\n+      /* Otherwise we explicitly take the address of the fields.  */\n+      else\n+\t{\n+\t  expr = build_unary_op (INDIRECT_REF, NULL_TREE, expr);\n+\t  template_addr\n+\t    = build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t      build_component_ref (expr, NULL_TREE, field,\n+\t\t\t\t\t\t   false));\n+\t  expr = build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\t\t build_component_ref (expr, NULL_TREE,\n+\t\t\t\t\t\t      DECL_CHAIN (field),\n+\t\t\t\t\t\t      false));\n+\t}\n     }\n \n   /* Otherwise, build the constructor for the template.  */\n   else\n-    template_tree = build_template (template_type, TREE_TYPE (etype), expr);\n+    template_addr\n+      = build_unary_op (ADDR_EXPR, NULL_TREE,\n+\t\t\tbuild_template (template_type, TREE_TYPE (etype),\n+\t\t\t\t\texpr));\n \n   /* The final result is a constructor for the fat pointer.\n \n@@ -4433,11 +4445,8 @@ convert_to_fat_pointer (tree type, tree expr)\n \n      Note that the call to \"build_template\" above is still fine because it\n      will only refer to the provided TEMPLATE_TYPE in this case.  */\n-  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type),\n-\t\t\t  convert (p_array_type, expr));\n-  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)),\n-\t\t\t  build_unary_op (ADDR_EXPR, NULL_TREE,\n-\t\t\t\t\t  template_tree));\n+  CONSTRUCTOR_APPEND_ELT (v, TYPE_FIELDS (type), convert (p_array_type, expr));\n+  CONSTRUCTOR_APPEND_ELT (v, DECL_CHAIN (TYPE_FIELDS (type)), template_addr);\n   return gnat_build_constructor (type, v);\n }\n \f"}, {"sha": "e716bdcf02b2330b3504e3bd63ff8e60204c9e5c", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88293f0384de09f14bdbb55afa363cc72006f9b2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88293f0384de09f14bdbb55afa363cc72006f9b2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=88293f0384de09f14bdbb55afa363cc72006f9b2", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2014, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -1850,6 +1850,7 @@ tree\n gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n {\n   bool allconstant = (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST);\n+  bool read_only = true;\n   bool side_effects = false;\n   tree result, obj, val;\n   unsigned int n_elmts;\n@@ -1867,6 +1868,9 @@ gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n \t  || !initializer_constant_valid_p (val, TREE_TYPE (val)))\n \tallconstant = false;\n \n+      if (!TREE_READONLY (val))\n+\tread_only = false;\n+\n       if (TREE_SIDE_EFFECTS (val))\n \tside_effects = true;\n     }\n@@ -1881,7 +1885,7 @@ gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n   CONSTRUCTOR_NO_CLEARING (result) = 1;\n   TREE_CONSTANT (result) = TREE_STATIC (result) = allconstant;\n   TREE_SIDE_EFFECTS (result) = side_effects;\n-  TREE_READONLY (result) = TYPE_READONLY (type) || allconstant;\n+  TREE_READONLY (result) = TYPE_READONLY (type) || read_only || allconstant;\n   return result;\n }\n \f\n@@ -2814,7 +2818,7 @@ gnat_invariant_expr (tree expr)\n   if (!TREE_READONLY (t))\n     return NULL_TREE;\n \n-  if (TREE_CODE (t) == PARM_DECL)\n+  if (TREE_CODE (t) == CONSTRUCTOR || TREE_CODE (t) == PARM_DECL)\n     return fold_convert (type, expr);\n \n   if (TREE_CODE (t) == VAR_DECL"}]}