{"sha": "dc3b932e33b703b0163fd6383f26e6c44fe68c6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMzYjkzMmUzM2I3MDNiMDE2M2ZkNjM4M2YyNmU2YzQ0ZmU2OGM2YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-06-28T19:41:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-06-28T19:41:24Z"}, "message": "Make the TEMPLATE_ID_EXPR location a range.\n\n\t* parser.c (cp_parser_template_id): Use the range location on the\n\tTEMPLATE_ID_EXPR.\n\nFrom-SVN: r249751", "tree": {"sha": "34f085f919f4262cf12a16c6e6b69ffc0cb1420a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34f085f919f4262cf12a16c6e6b69ffc0cb1420a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc3b932e33b703b0163fd6383f26e6c44fe68c6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3b932e33b703b0163fd6383f26e6c44fe68c6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc3b932e33b703b0163fd6383f26e6c44fe68c6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3b932e33b703b0163fd6383f26e6c44fe68c6a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2a4754f59786550a11706d807753c1747968ed01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a4754f59786550a11706d807753c1747968ed01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a4754f59786550a11706d807753c1747968ed01"}], "stats": {"total": 41, "additions": 21, "deletions": 20}, "files": [{"sha": "7f611727536942f8ae5a279b432b1db118c41f6d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3b932e33b703b0163fd6383f26e6c44fe68c6a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3b932e33b703b0163fd6383f26e6c44fe68c6a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dc3b932e33b703b0163fd6383f26e6c44fe68c6a", "patch": "@@ -1,5 +1,8 @@\n 2017-06-28  Jason Merrill  <jason@redhat.com>\n \n+\t* parser.c (cp_parser_template_id): Use the range location on the\n+\tTEMPLATE_ID_EXPR.\n+\n \tPR c++/81204 - parse error with dependent template-name\n \t* parser.c (cp_parser_lookup_name): Disqualify function templates\n \tafter lookup."}, {"sha": "246af7623be9d837070dd4750efc69df0877c46a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc3b932e33b703b0163fd6383f26e6c44fe68c6a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc3b932e33b703b0163fd6383f26e6c44fe68c6a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=dc3b932e33b703b0163fd6383f26e6c44fe68c6a", "patch": "@@ -15522,17 +15522,17 @@ cp_parser_template_id (cp_parser *parser,\n \n   /* If the next token corresponds to a template-id, there is no need\n      to reparse it.  */\n-  next_token = cp_lexer_peek_token (parser->lexer);\n-  if (next_token->type == CPP_TEMPLATE_ID)\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  if (token->type == CPP_TEMPLATE_ID)\n     {\n       cp_lexer_consume_token (parser->lexer);\n-      return saved_checks_value (next_token->u.tree_check_value);\n+      return saved_checks_value (token->u.tree_check_value);\n     }\n \n   /* Avoid performing name lookup if there is no possibility of\n      finding a template-id.  */\n-  if ((next_token->type != CPP_NAME && next_token->keyword != RID_OPERATOR)\n-      || (next_token->type == CPP_NAME\n+  if ((token->type != CPP_NAME && token->keyword != RID_OPERATOR)\n+      || (token->type == CPP_NAME\n \t  && !cp_parser_nth_token_starts_template_argument_list_p\n \t       (parser, 2)))\n     {\n@@ -15623,9 +15623,19 @@ cp_parser_template_id (cp_parser *parser,\n       arguments = cp_parser_enclosed_template_argument_list (parser);\n     }\n \n+  /* Set the location to be of the form:\n+     template-name < template-argument-list [opt] >\n+     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+     with caret == start at the start of the template-name,\n+     ranging until the closing '>'.  */\n+  location_t finish_loc\n+    = get_finish (cp_lexer_previous_token (parser->lexer)->location);\n+  location_t combined_loc\n+    = make_location (token->location, token->location, finish_loc);\n+\n   /* Build a representation of the specialization.  */\n   if (identifier_p (templ))\n-    template_id = build_min_nt_loc (next_token->location,\n+    template_id = build_min_nt_loc (combined_loc,\n \t\t\t\t    TEMPLATE_ID_EXPR,\n \t\t\t\t    templ, arguments);\n   else if (DECL_TYPE_TEMPLATE_P (templ)\n@@ -15652,7 +15662,7 @@ cp_parser_template_id (cp_parser *parser,\n     {\n       template_id = lookup_template_variable (templ, arguments);\n       if (TREE_CODE (template_id) == TEMPLATE_ID_EXPR)\n-\tSET_EXPR_LOCATION (template_id, next_token->location);\n+\tSET_EXPR_LOCATION (template_id, combined_loc);\n     }\n   else\n     {\n@@ -15664,7 +15674,7 @@ cp_parser_template_id (cp_parser *parser,\n \n       template_id = lookup_template_function (templ, arguments);\n       if (TREE_CODE (template_id) == TEMPLATE_ID_EXPR)\n-\tSET_EXPR_LOCATION (template_id, next_token->location);\n+\tSET_EXPR_LOCATION (template_id, combined_loc);\n     }\n \n   /* If parsing tentatively, replace the sequence of tokens that makes\n@@ -15680,20 +15690,8 @@ cp_parser_template_id (cp_parser *parser,\n \t   && cp_parser_parsing_tentatively (parser)\n \t   && parser->in_declarator_p))\n     {\n-      cp_token *token = cp_lexer_token_at (parser->lexer, start_of_id);\n-\n       /* Reset the contents of the START_OF_ID token.  */\n       token->type = CPP_TEMPLATE_ID;\n-\n-      /* Update the location to be of the form:\n-\t   template-name < template-argument-list [opt] >\n-\t   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\t with caret == start at the start of the template-name,\n-\t ranging until the closing '>'.  */\n-      location_t finish_loc\n-\t= get_finish (cp_lexer_previous_token (parser->lexer)->location);\n-      location_t combined_loc\n-\t= make_location (token->location, token->location, finish_loc);\n       token->location = combined_loc;\n \n       /* We must mark the lookup as kept, so we don't throw it away on"}]}