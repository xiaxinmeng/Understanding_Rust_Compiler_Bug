{"sha": "5f240ec46eaea80964f62124351e64cda949592e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyNDBlYzQ2ZWFlYTgwOTY0ZjYyMTI0MzUxZTY0Y2RhOTQ5NTkyZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-06-30T21:11:28Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-06-30T21:11:28Z"}, "message": "tree-ssa-loop-ch.c: New file.\n\n\t* tree-ssa-loop-ch.c: New file.\n\t* Makefile.in (tree-ssa-loop-ch.o): Add.\n\t(tree-into-ssa.o): Add GGC_H dependency.\n\t* tree-cfg.c (tree_duplicate_bb): Copy virtual arguments.\n\t* tree-flow.h (rewrite_into_ssa): Declaration changed.\n\t(rewrite_ssa_into_ssa, compute_global_livein, duplicate_ssa_name):\n\tDeclare.\n\t* tree-into-ssa.c: Include ggc.h.\n\t(struct def_blocks_d): Add phi_blocks field.\n\t(struct mark_def_sites_global_data): Add names_to_rename field.\n\t(struct ssa_name_info): New.\n\t(compute_global_livein): Export.\n\t(set_def_block, insert_phi_nodes, mark_def_sites, set_livein_block,\n\tinsert_phi_nodes_1, rewrite_finalize_block, insert_phi_nodes_for,\n\tregister_new_def, get_reaching_def, def_blocks_free,\n\tget_def_blocks_for, rewrite_into_ssa): Modified to work with\n\trewrite_ssa_into_ssa.\n\t(get_ssa_name_ann, get_phi_state, set_phi_state, get_current_def,\n\tset_current_def, ssa_mark_def_sites_initialize_block,\n\tssa_mark_phi_uses, ssa_mark_def_sites, duplicate_ssa_name,\n\tssa_register_new_def, ssa_rewrite_initialize_block,\n\tssa_rewrite_phi_arguments, ssa_rewrite_finalize_block,\n\tssa_rewrite_stmt, rewrite_ssa_into_ssa, rewrite_all_into_ssa): New\n\tfunctions.\n\t(pass_build_ssa): Call rewrite_all_into_ssa.\n\t* tree-optimize.c (execute_todo, execute_one_pass,\n\ttree_rest_of_compilation): Allocate vars_to_rename only once.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Provide parameter\n\tto rewrite_into_ssa.\n\t* tree-ssa-loop.c (should_duplicate_loop_header_p,\n\tmark_defs_for_rewrite, duplicate_blocks, do_while_loop_p,\n\tcopy_loop_headers, gate_ch, pass_ch): Moved to tree-ssa-loop-ch.c.\n\tUse rewrite_ssa_into_ssa.\n\t* tree-ssa-operands.c (copy_virtual_operands): New function.\n\t* tree-ssa-operands.h (copy_virtual_operands): Declare.\n\t* tree.h (struct tree_ssa_name): Add aux field.\n\t(SSA_NAME_AUX): New macro to access it.\n\nFrom-SVN: r83932", "tree": {"sha": "4c5126e282f3640784ee7d2bb37012cbef9d3ff5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c5126e282f3640784ee7d2bb37012cbef9d3ff5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f240ec46eaea80964f62124351e64cda949592e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f240ec46eaea80964f62124351e64cda949592e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f240ec46eaea80964f62124351e64cda949592e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f240ec46eaea80964f62124351e64cda949592e/comments", "author": null, "committer": null, "parents": [{"sha": "43e7557b6e0632e056b517ff41ab1c7161fed9e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e7557b6e0632e056b517ff41ab1c7161fed9e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e7557b6e0632e056b517ff41ab1c7161fed9e6"}], "stats": {"total": 1603, "additions": 1201, "deletions": 402}, "files": [{"sha": "1cf4e55d1bd69708a6fe95a6c6b19ea110dd680d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -1,3 +1,43 @@\n+2004-06-30  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* tree-ssa-loop-ch.c: New file.\n+\t* Makefile.in (tree-ssa-loop-ch.o): Add.\n+\t(tree-into-ssa.o): Add GGC_H dependency.\n+\t* tree-cfg.c (tree_duplicate_bb): Copy virtual arguments.\n+\t* tree-flow.h (rewrite_into_ssa): Declaration changed.\n+\t(rewrite_ssa_into_ssa, compute_global_livein, duplicate_ssa_name):\n+\tDeclare.\n+\t* tree-into-ssa.c: Include ggc.h.\n+\t(struct def_blocks_d): Add phi_blocks field.\n+\t(struct mark_def_sites_global_data): Add names_to_rename field.\n+\t(struct ssa_name_info): New.\n+\t(compute_global_livein): Export.\n+\t(set_def_block, insert_phi_nodes, mark_def_sites, set_livein_block,\n+\tinsert_phi_nodes_1, rewrite_finalize_block, insert_phi_nodes_for,\n+\tregister_new_def, get_reaching_def, def_blocks_free,\n+\tget_def_blocks_for, rewrite_into_ssa): Modified to work with\n+\trewrite_ssa_into_ssa.\n+\t(get_ssa_name_ann, get_phi_state, set_phi_state, get_current_def,\n+\tset_current_def, ssa_mark_def_sites_initialize_block,\n+\tssa_mark_phi_uses, ssa_mark_def_sites, duplicate_ssa_name,\n+\tssa_register_new_def, ssa_rewrite_initialize_block,\n+\tssa_rewrite_phi_arguments, ssa_rewrite_finalize_block,\n+\tssa_rewrite_stmt, rewrite_ssa_into_ssa, rewrite_all_into_ssa): New\n+\tfunctions.\n+\t(pass_build_ssa): Call rewrite_all_into_ssa.\n+\t* tree-optimize.c (execute_todo, execute_one_pass,\n+\ttree_rest_of_compilation): Allocate vars_to_rename only once.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Provide parameter\n+\tto rewrite_into_ssa.\n+\t* tree-ssa-loop.c (should_duplicate_loop_header_p,\n+\tmark_defs_for_rewrite, duplicate_blocks, do_while_loop_p,\n+\tcopy_loop_headers, gate_ch, pass_ch): Moved to tree-ssa-loop-ch.c.\n+\tUse rewrite_ssa_into_ssa.\n+\t* tree-ssa-operands.c (copy_virtual_operands): New function.\n+\t* tree-ssa-operands.h (copy_virtual_operands): Declare.\n+\t* tree.h (struct tree_ssa_name): Add aux field.\n+\t(SSA_NAME_AUX): New macro to access it.\n+\n 2004-05-28 Aaron W. LaFramboise <aaronraolete36@aaronwl.com>\n \n \t* prefix.c (lookup_key): Cast buffer to LPBYTE."}, {"sha": "aebfc5fd7b4b9f42b2b3c8f0d3f2b5e222c85023", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -898,7 +898,7 @@ OBJS-common = \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n  cfgrtl.o combine.o conflict.o convert.o coverage.o cse.o cselib.o \t   \\\n- dbxout.o ddg.o loop-invariant.o\t\t\t\t\t   \\\n+ dbxout.o ddg.o tree-ssa-loop-ch.o loop-invariant.o\t\t\t   \\\n  debug.o df.o diagnostic.o dojump.o dominance.o loop-doloop.o\t\t   \\\n  dwarf2asm.o dwarf2out.o emit-rtl.o except.o explow.o loop-iv.o\t\t   \\\n  expmed.o expr.o final.o flow.o fold-const.o function.o gcse.o\t\t   \\\n@@ -1598,7 +1598,8 @@ tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n    errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n-   $(TM_H) coretypes.h $(TREE_DUMP_H) langhooks.h domwalk.h tree-pass.h\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) langhooks.h domwalk.h tree-pass.h \\\n+   $(GGC_H)\n tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n    errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n@@ -1674,6 +1675,10 @@ tree-ssa-loop.o : tree-ssa-loop.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(FLAGS_H) tree-inline.h\n+tree-ssa-loop-ch.o : tree-ssa-loop-ch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) tree-inline.h \\\n+   output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   tree-pass.h flags.h\n tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h $(FLAGS_H) \\\n    function.h $(TIMEVAR_H) tree-alias-common.h convert.h $(TM_H) coretypes.h \\"}, {"sha": "940df86bbac5fe5d1644008d98f8bdf2713ff5e3", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -4283,11 +4283,18 @@ tree_duplicate_bb (basic_block bb)\n   for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n     {\n       tree stmt = bsi_stmt (bsi);\n+      tree copy;\n \n       if (TREE_CODE (stmt) == LABEL_EXPR)\n \tcontinue;\n \n-      bsi_insert_after (&bsi_tgt, unshare_expr (stmt), BSI_NEW_STMT);\n+      copy = unshare_expr (stmt);\n+\n+      /* Copy also the virtual operands.  */\n+      get_stmt_ann (copy);\n+      copy_virtual_operands (copy, stmt);\n+      \n+      bsi_insert_after (&bsi_tgt, copy, BSI_NEW_STMT);\n     }\n \n   return new_bb;"}, {"sha": "8d8f58a9eeb5362e0e5ede6d75c6cdae06071b47", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -575,7 +575,11 @@ extern void register_new_def (tree, varray_type *);\n extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *);\n \n /* In tree-into-ssa.c  */\n-extern void rewrite_into_ssa (void);\n+extern void rewrite_into_ssa (bool);\n+extern void rewrite_ssa_into_ssa (bitmap);\n+\n+void compute_global_livein (bitmap, bitmap);\n+tree duplicate_ssa_name (tree, tree);\n \n /* In tree-ssa-ccp.c  */\n bool fold_stmt (tree *);"}, {"sha": "027a90b39f031cd1036479ab58f711c33128dc73", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 739, "deletions": 58, "changes": 797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -47,6 +47,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-pass.h\"\n #include \"cfgloop.h\"\n #include \"domwalk.h\"\n+#include \"ggc.h\"\n \n /* This file builds the SSA form for a function as described in:\n    R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and K. Zadeck. Efficiently\n@@ -66,6 +67,9 @@ struct def_blocks_d\n      Ith block contains a definition of VAR.  */\n   bitmap def_blocks;\n \n+  /* Blocks that contain a phi node for VAR. */\n+  bitmap phi_blocks;\n+\n   /* Blocks where VAR is live-on-entry.  Similar semantics as\n      DEF_BLOCKS.  */\n   bitmap livein_blocks;\n@@ -88,13 +92,28 @@ struct mark_def_sites_global_data\n      solely to avoid the overhead of allocating and deallocating\n      the bitmap.  */\n   sbitmap kills;\n+\n+  /* Bitmap of names to rename.  */\n+  sbitmap names_to_rename;\n };\n \n struct rewrite_block_data\n {\n   varray_type block_defs;\n };\n \n+/* Information stored for ssa names.  */\n+\n+struct ssa_name_info\n+{\n+  /* This field indicates whether or not the variable may need PHI nodes.\n+     See the enum's definition for more detailed information about the\n+     states.  */\n+  ENUM_BITFIELD (need_phi_state) need_phi_state : 2;\n+\n+  /* The actual definition of the ssa name.  */\n+  tree current_def;\n+};\n \n /* Local functions.  */\n static void rewrite_finalize_block (struct dom_walk_data *, basic_block);\n@@ -106,12 +125,11 @@ static void mark_def_sites (struct dom_walk_data *walk_data,\n \t\t\t    basic_block bb, block_stmt_iterator);\n static void mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n \t\t\t\t\t     basic_block bb);\n-static void compute_global_livein (bitmap, bitmap);\n-static void set_def_block (tree, basic_block);\n+static void set_def_block (tree, basic_block, bool, bool);\n static void set_livein_block (tree, basic_block);\n-static bool prepare_use_operand_for_rename (use_operand_p op_p, size_t *uid_p);\n+static bool prepare_use_operand_for_rename (use_operand_p, size_t *uid_p);\n static bool prepare_def_operand_for_rename (tree def, size_t *uid_p);\n-static void insert_phi_nodes (bitmap *);\n+static void insert_phi_nodes (bitmap *, bitmap);\n static void rewrite_stmt (struct dom_walk_data *, basic_block,\n \t\t\t  block_stmt_iterator);\n static inline void rewrite_operand (use_operand_p);\n@@ -125,6 +143,61 @@ static inline struct def_blocks_d *get_def_blocks_for (tree);\n static inline struct def_blocks_d *find_def_blocks_for (tree);\n static void htab_statistics (FILE *, htab_t);\n \n+/* Get the information associated with NAME.  */\n+\n+static inline struct ssa_name_info *\n+get_ssa_name_ann (tree name)\n+{\n+  if (!SSA_NAME_AUX (name))\n+    SSA_NAME_AUX (name) = xcalloc (1, sizeof (struct ssa_name_info));\n+\n+  return SSA_NAME_AUX (name);\n+}\n+\n+/* Gets phi_state field for VAR.  */\n+\n+static inline enum need_phi_state\n+get_phi_state (tree var)\n+{\n+  if (TREE_CODE (var) == SSA_NAME)\n+    return get_ssa_name_ann (var)->need_phi_state;\n+  else\n+    return var_ann (var)->need_phi_state;\n+}\n+\n+/* Sets phi_state field for VAR to STATE.  */\n+\n+static inline void\n+set_phi_state (tree var, enum need_phi_state state)\n+{\n+  if (TREE_CODE (var) == SSA_NAME)\n+    get_ssa_name_ann (var)->need_phi_state = state;\n+  else\n+    var_ann (var)->need_phi_state = state;\n+}\n+\n+/* Return the current definition for VAR.  */\n+\n+static inline tree\n+get_current_def (tree var)\n+{\n+  if (TREE_CODE (var) == SSA_NAME)\n+    return get_ssa_name_ann (var)->current_def;\n+  else\n+    return var_ann (var)->current_def;\n+}\n+\n+/* Sets current definition of VAR to DEF.  */\n+\n+static inline void\n+set_current_def (tree var, tree def)\n+{\n+  if (TREE_CODE (var) == SSA_NAME)\n+    get_ssa_name_ann (var)->current_def = def;\n+  else\n+    var_ann (var)->current_def = def;\n+}\n+\n /* Compute global livein information given the set of blockx where\n    an object is locally live at the start of the block (LIVEIN)\n    and the set of blocks where the object is defined (DEF_BLOCKS).\n@@ -133,14 +206,14 @@ static void htab_statistics (FILE *, htab_t);\n    to include global livein (i.e., it modifies the underlying bitmap\n    for LIVEIN).  */\n \n-static void\n+void\n compute_global_livein (bitmap livein, bitmap def_blocks)\n {\n   basic_block bb, *worklist, *tos;\n   int i;\n \n   tos = worklist\n-    = (basic_block *) xmalloc (sizeof (basic_block) * (last_basic_block + 1));\n+    = (basic_block *) xmalloc (sizeof (basic_block) * (n_basic_blocks + 1));\n \n   EXECUTE_IF_SET_IN_BITMAP (livein, 0, i,\n     {\n@@ -189,6 +262,63 @@ mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n   sbitmap_zero (kills);\n }\n \n+/* Block initialization routine for mark_def_sites.  Clear the \n+   KILLS bitmap at the start of each block.  */\n+\n+static void\n+ssa_mark_def_sites_initialize_block (struct dom_walk_data *walk_data,\n+\t\t\t\t     basic_block bb)\n+{\n+  struct mark_def_sites_global_data *gd = walk_data->global_data;\n+  sbitmap kills = gd->kills;\n+  tree phi, def;\n+  unsigned def_uid;\n+\n+  sbitmap_zero (kills);\n+\n+  for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+    {\n+      def = PHI_RESULT (phi);\n+      def_uid = SSA_NAME_VERSION (def);\n+\n+      if (!TEST_BIT (gd->names_to_rename, def_uid))\n+\tcontinue;\n+\n+      set_def_block (def, bb, true, true);\n+      SET_BIT (kills, def_uid);\n+    }\n+}\n+\n+/* Marks ssa names used as arguments of phis at the end of BB.  */\n+\n+static void\n+ssa_mark_phi_uses (struct dom_walk_data *walk_data, basic_block bb)\n+{\n+  struct mark_def_sites_global_data *gd = walk_data->global_data;\n+  sbitmap kills = gd->kills;\n+  edge e;\n+  tree phi, use;\n+  unsigned uid;\n+\n+  for (e = bb->succ; e; e = e->succ_next)\n+    {\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      for (phi = phi_nodes (e->dest); phi; phi = TREE_CHAIN (phi))\n+\t{\n+\t  use = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t  if (TREE_CODE (use) != SSA_NAME)\n+\t    continue;\n+\n+\t  uid = SSA_NAME_VERSION (use);\n+\n+\t  if (TEST_BIT (gd->names_to_rename, uid)\n+\t      && !TEST_BIT (kills, uid))\n+\t    set_livein_block (use, bb);\n+\t}\n+    }\n+}\n \n /* Call back for walk_dominator_tree used to collect definition sites\n    for every variable in the function.  For every statement S in block\n@@ -245,7 +375,8 @@ mark_def_sites (struct dom_walk_data *walk_data,\n     {\n       use_operand_p use_p = VUSE_OP_PTR (vuses, i);\n \n-      if (prepare_use_operand_for_rename (use_p, &uid))\n+      if (prepare_use_operand_for_rename (use_p, &uid)\n+\t  && !TEST_BIT (kills, uid))\n \tset_livein_block (USE_FROM_PTR (use_p), bb);\n     }\n \n@@ -266,7 +397,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n \t    SET_V_MAY_DEF_RESULT (v_may_defs, i, USE_FROM_PTR (use_p));\n \t    \n           set_livein_block (USE_FROM_PTR (use_p), bb);\n-\t  set_def_block (V_MAY_DEF_RESULT (v_may_defs, i), bb);\n+\t  set_def_block (V_MAY_DEF_RESULT (v_may_defs, i), bb, false, false);\n \t}\n     }\n \n@@ -278,7 +409,7 @@ mark_def_sites (struct dom_walk_data *walk_data,\n \n       if (prepare_def_operand_for_rename (def, &uid))\n \t{\n-\t  set_def_block (def, bb);\n+\t  set_def_block (def, bb, false, false);\n \t  SET_BIT (kills, uid);\n \t}\n     }\n@@ -292,29 +423,135 @@ mark_def_sites (struct dom_walk_data *walk_data,\n \n       if (prepare_def_operand_for_rename (def, &uid))\n \t{\n-\t  set_def_block (def, bb);\n+\t  set_def_block (def, bb, false, false);\n \t  SET_BIT (kills, uid);\n \t}\n     }\n }\n \n+/* Ditto, but works over ssa names.  */\n+\n+static void\n+ssa_mark_def_sites (struct dom_walk_data *walk_data,\n+\t\t    basic_block bb,\n+\t\t    block_stmt_iterator bsi)\n+{\n+  struct mark_def_sites_global_data *gd = walk_data->global_data;\n+  sbitmap kills = gd->kills;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n+  vuse_optype vuses;\n+  def_optype defs;\n+  use_optype uses;\n+  size_t i, uid, def_uid;\n+  tree stmt, use, def;\n+  stmt_ann_t ann;\n+\n+  /* Mark all the blocks that have definitions for each variable in the\n+     names_to_rename bitmap.  */\n+  stmt = bsi_stmt (bsi);\n+  get_stmt_operands (stmt);\n+  ann = stmt_ann (stmt);\n+\n+  /* If a variable is used before being set, then the variable is live\n+     across a block boundary, so mark it live-on-entry to BB.  */\n+  uses = USE_OPS (ann);\n+  for (i = 0; i < NUM_USES (uses); i++)\n+    {\n+      use = USE_OP (uses, i);\n+      uid = SSA_NAME_VERSION (use);\n+\n+      if (TEST_BIT (gd->names_to_rename, uid)\n+\t  && !TEST_BIT (kills, uid))\n+\tset_livein_block (use, bb);\n+    }\n+\t  \n+  /* Similarly for virtual uses.  */\n+  vuses = VUSE_OPS (ann);\n+  for (i = 0; i < NUM_VUSES (vuses); i++)\n+    {\n+      use = VUSE_OP (vuses, i);\n+      uid = SSA_NAME_VERSION (use);\n+\n+      if (TEST_BIT (gd->names_to_rename, uid)\n+\t  && !TEST_BIT (kills, uid))\n+\tset_livein_block (use, bb);\n+    }\n+\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    {\n+      use = V_MAY_DEF_OP (v_may_defs, i);\n+      uid = SSA_NAME_VERSION (use);\n+\n+      if (TEST_BIT (gd->names_to_rename, uid)\n+\t  && !TEST_BIT (kills, uid))\n+\tset_livein_block (use, bb);\n+    }\n+\n+  /* Now process the definition made by this statement.  Mark the\n+     variables in KILLS.  */\n+  defs = DEF_OPS (ann);\n+  for (i = 0; i < NUM_DEFS (defs); i++)\n+    {\n+      def = DEF_OP (defs, i);\n+      def_uid = SSA_NAME_VERSION (def);\n+\n+      if (TEST_BIT (gd->names_to_rename, def_uid))\n+\t{\n+\t  set_def_block (def, bb, false, true);\n+\t  SET_BIT (kills, def_uid);\n+\t}\n+    }\n+\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    {\n+      def = V_MAY_DEF_RESULT (v_may_defs, i);\n+      def_uid = SSA_NAME_VERSION (def);\n+\n+      if (TEST_BIT (gd->names_to_rename, def_uid))\n+\t{\n+\t  set_def_block (def, bb, false, true);\n+\t  SET_BIT (kills, def_uid);\n+\t}\n+    }\n \n-/* Mark block BB as the definition site for variable VAR.  */\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    {\n+      def = V_MUST_DEF_OP (v_must_defs, i);\n+      def_uid = SSA_NAME_VERSION (def);\n+\n+      if (TEST_BIT (gd->names_to_rename, def_uid))\n+\t{\n+\t  set_def_block (def, bb, false, true);\n+\t  SET_BIT (kills, def_uid);\n+\t}\n+    }\n+}\n+\n+/* Mark block BB as the definition site for variable VAR.  PHI_P is true if\n+   VAR is defined by a phi node.  SSA_P is true if we are called from\n+   rewrite_ssa_into_ssa.  */\n \n static void\n-set_def_block (tree var, basic_block bb)\n+set_def_block (tree var, basic_block bb, bool phi_p, bool ssa_p)\n {\n   struct def_blocks_d *db_p;\n   enum need_phi_state state;\n \n-  if (TREE_CODE (var) == SSA_NAME)\n+  if (!ssa_p\n+      && TREE_CODE (var) == SSA_NAME)\n     var = SSA_NAME_VAR (var);\n \n-  state = var_ann (var)->need_phi_state;\n+  state = get_phi_state (var);\n   db_p = get_def_blocks_for (var);\n \n   /* Set the bit corresponding to the block where VAR is defined.  */\n   bitmap_set_bit (db_p->def_blocks, bb->index);\n+  if (phi_p)\n+    bitmap_set_bit (db_p->phi_blocks, bb->index);\n \n   /* Keep track of whether or not we may need to insert phi nodes.\n \n@@ -329,9 +566,9 @@ set_def_block (tree var, basic_block bb)\n      definition(s).  In this case we may need a PHI node, so enter\n      state NEED_PHI_STATE_MAYBE.  */\n   if (state == NEED_PHI_STATE_UNKNOWN)\n-    var_ann (var)->need_phi_state = NEED_PHI_STATE_NO;\n+    set_phi_state (var, NEED_PHI_STATE_NO);\n   else\n-    var_ann (var)->need_phi_state = NEED_PHI_STATE_MAYBE;\n+    set_phi_state (var, NEED_PHI_STATE_MAYBE);\n }\n \n \n@@ -341,7 +578,7 @@ static void\n set_livein_block (tree var, basic_block bb)\n {\n   struct def_blocks_d *db_p;\n-  enum need_phi_state state = var_ann (var)->need_phi_state;\n+  enum need_phi_state state = get_phi_state (var);\n \n   db_p = get_def_blocks_for (var);\n \n@@ -361,10 +598,10 @@ set_livein_block (tree var, basic_block bb)\n       if (def_block_index == -1\n \t  || ! dominated_by_p (CDI_DOMINATORS, bb,\n \t                       BASIC_BLOCK (def_block_index)))\n-\tvar_ann (var)->need_phi_state = NEED_PHI_STATE_MAYBE;\n+\tset_phi_state (var, NEED_PHI_STATE_MAYBE);\n     }\n   else\n-    var_ann (var)->need_phi_state = NEED_PHI_STATE_MAYBE;\n+    set_phi_state (var, NEED_PHI_STATE_MAYBE);\n }\n \n \n@@ -414,26 +651,27 @@ prepare_def_operand_for_rename (tree def, size_t *uid_p)\n }\n \n /* Helper for insert_phi_nodes.  If VAR needs PHI nodes, insert them\n-   at the dominance frontier (DFS) of blocks defining VAR.  */\n+   at the dominance frontier (DFS) of blocks defining VAR.\n+   WORK_STACK is the varray used to implement the worklist of basic\n+   blocks.  */\n \n static inline\n void insert_phi_nodes_1 (tree var, bitmap *dfs, varray_type *work_stack)\n {\n-  var_ann_t ann = var_ann (var);\n-  if (ann->need_phi_state != NEED_PHI_STATE_NO)\n+  if (get_phi_state (var) != NEED_PHI_STATE_NO)\n     insert_phi_nodes_for (var, dfs, work_stack);\n }\n \n-\n /* Insert PHI nodes at the dominance frontier of blocks with variable\n    definitions.  DFS contains the dominance frontier information for\n    the flowgraph.  PHI nodes will only be inserted at the dominance\n    frontier of definition blocks for variables whose NEED_PHI_STATE\n    annotation is marked as ``maybe'' or ``unknown'' (computed by\n-   mark_def_sites).  */\n+   mark_def_sites).  If NAMES_TO_RENAME is not NULL, do the same but\n+   for ssa name rewriting.  */\n \n static void\n-insert_phi_nodes (bitmap *dfs)\n+insert_phi_nodes (bitmap *dfs, bitmap names_to_rename)\n {\n   size_t i;\n   varray_type work_stack;\n@@ -442,19 +680,29 @@ insert_phi_nodes (bitmap *dfs)\n \n   /* Array WORK_STACK is a stack of CFG blocks.  Each block that contains\n      an assignment or PHI node will be pushed to this stack.  */\n-  VARRAY_BB_INIT (work_stack, last_basic_block, \"work_stack\");\n+  VARRAY_GENERIC_PTR_NOGC_INIT (work_stack, last_basic_block, \"work_stack\");\n \n   /* Iterate over all variables in VARS_TO_RENAME.  For each variable, add\n      to the work list all the blocks that have a definition for the\n      variable.  PHI nodes will be added to the dominance frontier blocks of\n      each definition block.  */\n-  if (vars_to_rename)\n+  if (names_to_rename)\n+    {\n+      EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i,\n+\t{\n+\t  if (ssa_name (i))\n+\t    insert_phi_nodes_1 (ssa_name (i), dfs, &work_stack);\n+\t});\n+    }\n+  else if (vars_to_rename)\n     EXECUTE_IF_SET_IN_BITMAP (vars_to_rename, 0, i,\n \tinsert_phi_nodes_1 (referenced_var (i), dfs, &work_stack));\n   else\n     for (i = 0; i < num_referenced_vars; i++)\n       insert_phi_nodes_1 (referenced_var (i), dfs, &work_stack);\n \n+  VARRAY_FREE (work_stack);\n+\n   timevar_pop (TV_TREE_INSERT_PHI_NODES);\n }\n \n@@ -534,6 +782,81 @@ rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n     }\n }\n \n+/* Register DEF (an SSA_NAME) to be a new definition for the original\n+   ssa name VAR and push VAR's current reaching definition\n+   into the stack pointed by BLOCK_DEFS_P.  */\n+\n+static void\n+ssa_register_new_def (tree var, tree def, varray_type *block_defs_p)\n+{\n+  tree currdef;\n+   \n+  /* If this variable is set in a single basic block and all uses are\n+     dominated by the set(s) in that single basic block, then there is\n+     nothing to do.  TODO we should not be called at all, and just\n+     keep the original name.  */\n+  if (get_phi_state (var) == NEED_PHI_STATE_NO)\n+    {\n+      set_current_def (var, def);\n+      return;\n+    }\n+\n+  currdef = get_current_def (var);\n+  if (! *block_defs_p)\n+    VARRAY_TREE_INIT (*block_defs_p, 20, \"block_defs\");\n+\n+  /* Push the current reaching definition into *BLOCK_DEFS_P.  This stack is\n+     later used by the dominator tree callbacks to restore the reaching\n+     definitions for all the variables defined in the block after a recursive\n+     visit to all its immediately dominated blocks.  */\n+  VARRAY_PUSH_TREE (*block_defs_p, var);\n+  VARRAY_PUSH_TREE (*block_defs_p, currdef);\n+\n+  /* Set the current reaching definition for VAR to be DEF.  */\n+  set_current_def (var, def);\n+}\n+\n+/* Ditto, for rewriting ssa names.  */\n+\n+static void\n+ssa_rewrite_initialize_block (struct dom_walk_data *walk_data, basic_block bb)\n+{\n+  tree phi, new_name;\n+  struct rewrite_block_data *bd\n+    = (struct rewrite_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n+  sbitmap names_to_rename = walk_data->global_data;\n+  edge e;\n+  bool abnormal_phi;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\n\\nRenaming block #%d\\n\\n\", bb->index);\n+\n+  for (e = bb->pred; e; e = e->pred_next)\n+    if (e->flags & EDGE_ABNORMAL)\n+      break;\n+  abnormal_phi = (e != NULL);\n+\n+  /* Step 1.  Register new definitions for every PHI node in the block.\n+     Conceptually, all the PHI nodes are executed in parallel and each PHI\n+     node introduces a new version for the associated variable.  */\n+  for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+    {\n+      tree result = PHI_RESULT (phi);\n+\n+      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (result)))\n+\t{\n+\t  new_name = duplicate_ssa_name (result, phi);\n+\t  SET_PHI_RESULT (phi, new_name);\n+\n+\t  if (abnormal_phi)\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_name) = 1;\n+\t}\n+      else\n+\tnew_name = result;\n+\n+      ssa_register_new_def (result, new_name, &bd->block_defs);\n+    }\n+}\n \n /* SSA Rewriting Step 3.  Visit all the successor blocks of BB looking for\n    PHI nodes.  For every PHI node found, add a new argument containing the\n@@ -550,7 +873,7 @@ rewrite_add_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     {\n       tree phi;\n \n-      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n+      for (phi = phi_nodes (e->dest); phi; phi = TREE_CHAIN (phi))\n \t{\n \t  tree currdef;\n \n@@ -566,6 +889,38 @@ rewrite_add_phi_arguments (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n     }\n }\n \n+/* Ditto, for ssa name rewriting.  */\n+\n+static void\n+ssa_rewrite_phi_arguments (struct dom_walk_data *walk_data, basic_block bb)\n+{\n+  edge e;\n+  sbitmap names_to_rename = walk_data->global_data;\n+  use_operand_p op;\n+\n+  for (e = bb->succ; e; e = e->succ_next)\n+    {\n+      tree phi;\n+\n+      if (e->dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      for (phi = phi_nodes (e->dest); phi; phi = TREE_CHAIN (phi))\n+\t{\n+\t  op = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);\n+\t  if (TREE_CODE (USE_FROM_PTR (op)) != SSA_NAME)\n+\t    continue;\n+\n+\t  if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (op))))\n+\t    continue;\n+\n+\t  SET_USE (op, get_reaching_def (USE_FROM_PTR (op)));\n+\t  if (e->flags & EDGE_ABNORMAL)\n+\t    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (USE_FROM_PTR (op)) = 1;\n+\t}\n+    }\n+}\n+\n /* SSA Rewriting Step 5.  Restore the current reaching definition for each\n    variable referenced in the block (in reverse order).  */\n \n@@ -595,10 +950,33 @@ rewrite_finalize_block (struct dom_walk_data *walk_data,\n \t  var = tmp;\n \t}\n \n-      var_ann (var)->current_def = saved_def;\n+      set_current_def (var, saved_def);\n     }\n }\n \n+/* Ditto, for rewriting ssa names.  */\n+\n+static void\n+ssa_rewrite_finalize_block (struct dom_walk_data *walk_data,\n+\t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n+{\n+  struct rewrite_block_data *bd\n+    = (struct rewrite_block_data *)VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n+\n+  /* Step 5.  Restore the current reaching definition for each variable\n+     referenced in the block (in reverse order).  */\n+  while (bd->block_defs && VARRAY_ACTIVE_SIZE (bd->block_defs) > 0)\n+    {\n+      tree var;\n+      tree saved_def = VARRAY_TOP_TREE (bd->block_defs);\n+      VARRAY_POP (bd->block_defs);\n+      \n+      var = VARRAY_TOP_TREE (bd->block_defs);\n+      VARRAY_POP (bd->block_defs);\n+\n+      set_current_def (var, saved_def);\n+    }\n+}\n \n /* Dump SSA information to FILE.  */\n \n@@ -666,14 +1044,18 @@ htab_statistics (FILE *file, htab_t htab)\n \n \n /* Insert PHI nodes for variable VAR using the dominance frontier\n-   information given in DFS.  */\n+   information given in DFS.  WORK_STACK is the varray used to\n+   implement the worklist of basic blocks.  */\n \n static void\n insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n {\n   struct def_blocks_d *def_map;\n   bitmap phi_insertion_points;\n   int bb_index;\n+  edge e;\n+  tree phi;\n+  basic_block bb;\n \n   def_map = find_def_blocks_for (var);\n   if (def_map == NULL)\n@@ -683,7 +1065,7 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n \n   EXECUTE_IF_SET_IN_BITMAP (def_map->def_blocks, 0, bb_index,\n     {\n-      VARRAY_PUSH_BB (*work_stack, BASIC_BLOCK (bb_index));\n+      VARRAY_PUSH_GENERIC_PTR_NOGC (*work_stack, BASIC_BLOCK (bb_index));\n     });\n \n   /* Pop a block off the worklist, add every block that appears in\n@@ -700,10 +1082,11 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n      We now always use fully pruned SSA form.  */\n   while (VARRAY_ACTIVE_SIZE (*work_stack) > 0)\n     {\n-      basic_block bb = VARRAY_TOP_BB (*work_stack);\n-      int bb_index = bb->index;\n       int dfs_index;\n \n+      bb = VARRAY_TOP_GENERIC_PTR_NOGC (*work_stack);\n+      bb_index = bb->index;\n+\n       VARRAY_POP (*work_stack);\n       \n       EXECUTE_IF_AND_COMPL_IN_BITMAP (dfs[bb_index],\n@@ -712,21 +1095,36 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n \t{\n \t  basic_block bb = BASIC_BLOCK (dfs_index);\n \n-\t  VARRAY_PUSH_BB (*work_stack, bb);\n+\t  VARRAY_PUSH_GENERIC_PTR_NOGC (*work_stack, bb);\n \t  bitmap_set_bit (phi_insertion_points, dfs_index);\n \t});\n     }\n \n+  /* Remove the blocks where we already have the phis.  */\n+  bitmap_operation (phi_insertion_points, phi_insertion_points,\n+\t\t    def_map->phi_blocks, BITMAP_AND_COMPL);\n+\n   /* Now compute global livein for this variable.  Note this modifies\n      def_map->livein_blocks.  */\n   compute_global_livein (def_map->livein_blocks, def_map->def_blocks);\n \n   /* And insert the PHI nodes.  */\n   EXECUTE_IF_AND_IN_BITMAP (phi_insertion_points, def_map->livein_blocks,\n \t\t\t    0, bb_index,\n-    {\n-      create_phi_node (var, BASIC_BLOCK (bb_index));\n-    });\n+    do\n+      {\n+\tbb = BASIC_BLOCK (bb_index);\n+\n+\tphi = create_phi_node (var, bb);\n+\n+\t/* If we are rewriting ssa names, add also the phi arguments.  */\n+\tif (TREE_CODE (var) == SSA_NAME)\n+\t  {\n+\t    for (e = bb->pred; e; e = e->pred_next)\n+\t      add_phi_arg (&phi, var, e);\n+\t  }\n+      }\n+    while (0));\n \n   BITMAP_XFREE (phi_insertion_points);\n }\n@@ -827,8 +1225,114 @@ rewrite_stmt (struct dom_walk_data *walk_data,\n     \n }\n \n+/* Ditto, for rewriting ssa names.  */\n \n-/* Replace the use operand pointed by OP_P with its immediate reaching\n+static void\n+ssa_rewrite_stmt (struct dom_walk_data *walk_data,\n+\t\t  basic_block bb ATTRIBUTE_UNUSED,\n+\t\t  block_stmt_iterator si)\n+{\n+  size_t i;\n+  stmt_ann_t ann;\n+  tree stmt, var;\n+  use_operand_p use_p;\n+  def_operand_p def_p;\n+  vuse_optype vuses;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n+  def_optype defs;\n+  use_optype uses;\n+  struct rewrite_block_data *bd;\n+  sbitmap names_to_rename = walk_data->global_data;\n+\n+  bd = VARRAY_TOP_GENERIC_PTR (walk_data->block_data_stack);\n+\n+  stmt = bsi_stmt (si);\n+  ann = stmt_ann (stmt);\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Renaming statement \");\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+#if defined ENABLE_CHECKING\n+  /* We have just scanned the code for operands.  No statement should\n+     be modified.  */\n+  if (ann->modified)\n+    abort ();\n+#endif\n+\n+  defs = DEF_OPS (ann);\n+  uses = USE_OPS (ann);\n+  vuses = VUSE_OPS (ann);\n+  v_may_defs = V_MAY_DEF_OPS (ann);\n+  v_must_defs = V_MUST_DEF_OPS (ann);\n+\n+  /* Step 1.  Rewrite USES and VUSES in the statement.  */\n+  for (i = 0; i < NUM_USES (uses); i++)\n+    {\n+      use_p = USE_OP_PTR (uses, i);\n+      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n+\tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n+    }\n+\n+  /* Rewrite virtual uses in the statement.  */\n+  for (i = 0; i < NUM_VUSES (vuses); i++)\n+    {\n+      use_p = VUSE_OP_PTR (vuses, i);\n+      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n+\tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n+    }\n+\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    {\n+      use_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n+      if (TEST_BIT (names_to_rename, SSA_NAME_VERSION (USE_FROM_PTR (use_p))))\n+\tSET_USE (use_p, get_reaching_def (USE_FROM_PTR (use_p)));\n+    }\n+\n+  /* Step 2.  Register the statement's DEF and VDEF operands.  */\n+  for (i = 0; i < NUM_DEFS (defs); i++)\n+    {\n+      def_p = DEF_OP_PTR (defs, i);\n+      var = DEF_FROM_PTR (def_p);\n+\n+      if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (var)))\n+\tcontinue;\n+\n+      SET_DEF (def_p, duplicate_ssa_name (var, stmt));\n+      ssa_register_new_def (var, DEF_FROM_PTR (def_p), &bd->block_defs);\n+    }\n+\n+  /* Register new virtual definitions made by the statement.  */\n+  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+    {\n+      def_p = V_MAY_DEF_RESULT_PTR (v_may_defs, i);\n+      var = DEF_FROM_PTR (def_p);\n+\n+      if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (var)))\n+\tcontinue;\n+\n+      SET_DEF (def_p, duplicate_ssa_name (var, stmt));\n+      ssa_register_new_def (var, DEF_FROM_PTR (def_p), &bd->block_defs);\n+    }\n+\n+  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+    {\n+      def_p = V_MUST_DEF_OP_PTR (v_must_defs, i);\n+      var = DEF_FROM_PTR (def_p);\n+\n+      if (!TEST_BIT (names_to_rename, SSA_NAME_VERSION (var)))\n+\tcontinue;\n+\n+      SET_DEF (def_p, duplicate_ssa_name (var, stmt));\n+      ssa_register_new_def (var, DEF_FROM_PTR (def_p), &bd->block_defs);\n+    }\n+}\n+\n+/* Replace the operand pointed by OP_P with its immediate reaching\n    definition.  */\n \n static inline void\n@@ -838,7 +1342,6 @@ rewrite_operand (use_operand_p op_p)\n     SET_USE (op_p, get_reaching_def (USE_FROM_PTR (op_p)));\n }\n \n-\n /* Register DEF (an SSA_NAME) to be a new definition for its underlying\n    variable (SSA_NAME_VAR (DEF)) and push VAR's current reaching definition\n    into the stack pointed by BLOCK_DEFS_P.  */\n@@ -857,13 +1360,13 @@ register_new_def (tree def, varray_type *block_defs_p)\n      This is the same test to prune the set of variables which may\n      need PHI nodes.  So we just use that information since it's already\n      computed and available for us to use.  */\n-  if (var_ann (var)->need_phi_state == NEED_PHI_STATE_NO)\n+  if (get_phi_state (var) == NEED_PHI_STATE_NO)\n     {\n-      var_ann (var)->current_def = def;\n+      set_current_def (var, def);\n       return;\n     }\n \n-  currdef = var_ann (var)->current_def;\n+  currdef = get_current_def (var);\n   if (! *block_defs_p)\n     VARRAY_TREE_INIT (*block_defs_p, 20, \"block_defs\");\n \n@@ -875,10 +1378,9 @@ register_new_def (tree def, varray_type *block_defs_p)\n   VARRAY_PUSH_TREE (*block_defs_p, currdef ? currdef : var);\n \n   /* Set the current reaching definition for VAR to be DEF.  */\n-  var_ann (var)->current_def = def;\n+  set_current_def (var, def);\n }\n \n-\n /* Return the current definition for variable VAR.  If none is found,\n    create a new SSA name to act as the zeroth definition for VAR.  If VAR\n    is call clobbered and there exists a more recent definition of\n@@ -888,23 +1390,28 @@ register_new_def (tree def, varray_type *block_defs_p)\n static tree\n get_reaching_def (tree var)\n {\n-  tree default_d, currdef_var;\n+  tree default_d, currdef_var, avar;\n   \n   /* Lookup the current reaching definition for VAR.  */\n   default_d = NULL_TREE;\n-  currdef_var = var_ann (var)->current_def;\n+  currdef_var = get_current_def (var);\n \n   /* If there is no reaching definition for VAR, create and register a\n      default definition for it (if needed).  */\n   if (currdef_var == NULL_TREE)\n     {\n-      default_d = default_def (var);\n+      if (TREE_CODE (var) == SSA_NAME)\n+\tavar = SSA_NAME_VAR (var);\n+      else\n+\tavar = var;\n+\n+      default_d = default_def (avar);\n       if (default_d == NULL_TREE)\n \t{\n-\t  default_d = make_ssa_name (var, build_empty_stmt ());\n-\t  set_default_def (var, default_d);\n+\t  default_d = make_ssa_name (avar, build_empty_stmt ());\n+\t  set_default_def (avar, default_d);\n \t}\n-      var_ann (var)->current_def = default_d;\n+      set_current_def (var, default_d);\n     }\n \n   /* Return the current reaching definition for VAR, or the default\n@@ -936,6 +1443,7 @@ def_blocks_free (void *p)\n {\n   struct def_blocks_d *entry = p;\n   BITMAP_XFREE (entry->def_blocks);\n+  BITMAP_XFREE (entry->phi_blocks);\n   BITMAP_XFREE (entry->livein_blocks);\n   free (entry);\n }\n@@ -1002,6 +1510,7 @@ get_def_blocks_for (tree var)\n       db_p = xmalloc (sizeof (*db_p));\n       db_p->var = var;\n       db_p->def_blocks = BITMAP_XMALLOC ();\n+      db_p->phi_blocks = BITMAP_XMALLOC ();\n       db_p->livein_blocks = BITMAP_XMALLOC ();\n       *slot = (void *) db_p;\n     }\n@@ -1081,22 +1590,38 @@ invalidate_name_tags (bitmap vars_to_rename)\n       (rewrite_stmt).\n \n    Steps 3 and 5 are done using the dominator tree walker\n-   (walk_dominator_tree).  */\n+   (walk_dominator_tree).\n+\n+   ALL is true if all variables should be renamed (otherwise just those\n+   mentioned in vars_to_rename are taken into account).  */\n \n void\n-rewrite_into_ssa (void)\n+rewrite_into_ssa (bool all)\n {\n   bitmap *dfs;\n   basic_block bb;\n   struct dom_walk_data walk_data;\n   struct mark_def_sites_global_data mark_def_sites_global_data;\n-  unsigned int i;\n+  bitmap old_vars_to_rename = vars_to_rename;\n+  unsigned i;\n   \n   timevar_push (TV_TREE_SSA_OTHER);\n \n-  /* Initialize the array of variables to rename.  */\n-  if (vars_to_rename != NULL)\n+  if (all)\n+    vars_to_rename = NULL;\n+  else\n     {\n+      /* Initialize the array of variables to rename.  */\n+ \n+      if (vars_to_rename == NULL)\n+\tabort ();\n+\n+      if (bitmap_first_set_bit (vars_to_rename) < 0)\n+\t{\n+\t  timevar_pop (TV_TREE_SSA_OTHER);\n+\t  return;\n+\t}\n+      \n       invalidate_name_tags (vars_to_rename);\n \n       /* Now remove all the existing PHI nodes (if any) for the variables\n@@ -1125,7 +1650,7 @@ rewrite_into_ssa (void)\n     }\n \n   for (i = 0; i < num_referenced_vars; i++)\n-    var_ann (referenced_var (i))->current_def = NULL;\n+    set_current_def (referenced_var (i), NULL_TREE);\n \n   /* Ensure that the dominance information is OK.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n@@ -1167,7 +1692,7 @@ rewrite_into_ssa (void)\n   sbitmap_free (mark_def_sites_global_data.kills);\n \n   /* Insert PHI nodes at dominance frontiers of definition blocks.  */\n-  insert_phi_nodes (dfs);\n+  insert_phi_nodes (dfs, NULL);\n \n   /* Rewrite all the basic blocks in the program.  */\n   timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n@@ -1211,14 +1736,170 @@ rewrite_into_ssa (void)\n \n   htab_delete (def_blocks);\n \n+  vars_to_rename = old_vars_to_rename;\n   timevar_pop (TV_TREE_SSA_OTHER);\n }\n \n+/* The ssa names in NAMES_TO_RENAME may have more than one definition;\n+   add phi nodes and rewrite them to fix this.  */\n+\n+void\n+rewrite_ssa_into_ssa (bitmap names_to_rename)\n+{\n+  bitmap *dfs;\n+  basic_block bb;\n+  struct dom_walk_data walk_data;\n+  struct mark_def_sites_global_data mark_def_sites_global_data;\n+  unsigned i;\n+  sbitmap snames_to_rename;\n+  tree name;\n+  \n+  if (bitmap_first_set_bit (names_to_rename) < 0)\n+    return;\n+\n+  timevar_push (TV_TREE_SSA_OTHER);\n+\n+  /* Allocate memory for the DEF_BLOCKS hash table.  */\n+  def_blocks = htab_create (num_ssa_names,\n+\t\t\t    def_blocks_hash, def_blocks_eq, def_blocks_free);\n+\n+  /* Initialize dominance frontier and immediate dominator bitmaps. \n+     Also count the number of predecessors for each block.  Doing so\n+     can save significant time during PHI insertion for large graphs.  */\n+  dfs = (bitmap *) xmalloc (last_basic_block * sizeof (bitmap *));\n+  FOR_EACH_BB (bb)\n+    {\n+      edge e;\n+      int count = 0;\n+\n+      for (e = bb->pred; e; e = e->pred_next)\n+\tcount++;\n+\n+      bb_ann (bb)->num_preds = count;\n+      dfs[bb->index] = BITMAP_XMALLOC ();\n+    }\n+\n+  /* Ensure that the dominance information is OK.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  /* Compute dominance frontiers.  */\n+  compute_dominance_frontiers (dfs);\n+\n+  /* Setup callbacks for the generic dominator tree walker to find and\n+     mark definition sites.  */\n+  walk_data.walk_stmts_backward = false;\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data = NULL;\n+  walk_data.before_dom_children_before_stmts\n+\t  = ssa_mark_def_sites_initialize_block;\n+  walk_data.before_dom_children_walk_stmts = ssa_mark_def_sites;\n+  walk_data.before_dom_children_after_stmts = ssa_mark_phi_uses; \n+  walk_data.after_dom_children_before_stmts =  NULL;\n+  walk_data.after_dom_children_walk_stmts =  NULL;\n+  walk_data.after_dom_children_after_stmts =  NULL;\n+\n+  snames_to_rename = sbitmap_alloc (num_ssa_names);\n+  sbitmap_zero (snames_to_rename);\n+  EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i,\n+\t\t\t    SET_BIT (snames_to_rename, i));\n+\n+  mark_def_sites_global_data.kills = sbitmap_alloc (num_ssa_names);\n+  mark_def_sites_global_data.names_to_rename = snames_to_rename;\n+  walk_data.global_data = &mark_def_sites_global_data;\n+\n+  /* We do not have any local data.  */\n+  walk_data.block_local_data_size = 0;\n+\n+  /* Initialize the dominator walker.  */\n+  init_walk_dominator_tree (&walk_data);\n+\n+  /* Recursively walk the dominator tree.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+\n+  /* Finalize the dominator walker.  */\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  /* We no longer need this bitmap, clear and free it.  */\n+  sbitmap_free (mark_def_sites_global_data.kills);\n+\n+  for (i = 0; i < num_ssa_names; i++)\n+    if (ssa_name (i))\n+      set_current_def (ssa_name (i), NULL_TREE);\n+\n+  /* Insert PHI nodes at dominance frontiers of definition blocks.  */\n+  insert_phi_nodes (dfs, names_to_rename);\n+\n+  /* Rewrite all the basic blocks in the program.  */\n+  timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n+\n+  /* Setup callbacks for the generic dominator tree walker.  */\n+  walk_data.walk_stmts_backward = false;\n+  walk_data.dom_direction = CDI_DOMINATORS;\n+  walk_data.initialize_block_local_data\n+\t  = rewrite_initialize_block_local_data;\n+  walk_data.before_dom_children_before_stmts = ssa_rewrite_initialize_block;\n+  walk_data.before_dom_children_walk_stmts = ssa_rewrite_stmt;\n+  walk_data.before_dom_children_after_stmts = ssa_rewrite_phi_arguments;\n+  walk_data.after_dom_children_before_stmts = NULL;\n+  walk_data.after_dom_children_walk_stmts =  NULL;\n+  walk_data.after_dom_children_after_stmts =  ssa_rewrite_finalize_block;\n+  walk_data.global_data = snames_to_rename;\n+  walk_data.block_local_data_size = sizeof (struct rewrite_block_data);\n+\n+  /* Initialize the dominator walker.  */\n+  init_walk_dominator_tree (&walk_data);\n+\n+  /* Recursively walk the dominator tree rewriting each statement in\n+     each basic block.  */\n+  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+\n+  /* Finalize the dominator walker.  */\n+  fini_walk_dominator_tree (&walk_data);\n+\n+  sbitmap_free (snames_to_rename);\n+\n+  timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n+\n+  /* Debugging dumps.  */\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    {\n+      dump_dfa_stats (dump_file);\n+      dump_tree_ssa_stats (dump_file);\n+    }\n+\n+  /* Free allocated memory.  */\n+  FOR_EACH_BB (bb)\n+    BITMAP_XFREE (dfs[bb->index]);\n+  free (dfs);\n+\n+  htab_delete (def_blocks);\n+\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      name = ssa_name (i);\n+      if (!name\n+\t  || !SSA_NAME_AUX (name))\n+\tcontinue;\n+\n+      free (SSA_NAME_AUX (name));\n+      SSA_NAME_AUX (name) = NULL;\n+    }\n+  timevar_pop (TV_TREE_SSA_OTHER);\n+}\n+\n+/* Rewrites all variables into ssa.  */\n+\n+static void\n+rewrite_all_into_ssa (void)\n+{\n+  rewrite_into_ssa (true);\n+}\n+\n struct tree_opt_pass pass_build_ssa = \n {\n   \"ssa\",\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n-  rewrite_into_ssa,\t\t\t/* execute */\n+  rewrite_all_into_ssa,\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */"}, {"sha": "00ddc20827f857274b251f62a0d83bf4d85ca9f5", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -349,9 +349,8 @@ execute_todo (unsigned int flags)\n {\n   if (flags & TODO_rename_vars)\n     {\n-      if (bitmap_first_set_bit (vars_to_rename) >= 0)\n-\trewrite_into_ssa ();\n-      BITMAP_XFREE (vars_to_rename);\n+      rewrite_into_ssa (false);\n+      bitmap_clear (vars_to_rename);\n     }\n \n   if ((flags & TODO_dump_func) && dump_file)\n@@ -407,10 +406,6 @@ execute_one_pass (struct tree_opt_pass *pass)\n   if (pass->tv_id)\n     timevar_push (pass->tv_id);\n \n-  /* If the pass is requesting ssa variable renaming, allocate the bitmap.  */\n-  if (pass->todo_flags_finish & TODO_rename_vars)\n-    vars_to_rename = BITMAP_XMALLOC ();\n-\n   /* Do it!  */\n   if (pass->execute)\n     pass->execute ();\n@@ -509,6 +504,9 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n \t}\n     }\n \n+  if (!vars_to_rename)\n+    vars_to_rename = BITMAP_XMALLOC ();\n+\n   /* If this is a nested function, protect the local variables in the stack\n      above us from being collected while we're compiling this function.  */\n   if (nested_p)"}, {"sha": "36b513b557186f957b1999e6461d0098e9364c75", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -631,7 +631,7 @@ tree_ssa_dominator_optimize (void)\n       if (cfg_altered\n \t  && bitmap_first_set_bit (vars_to_rename) >= 0)\n \t{\n-\t  rewrite_into_ssa ();\n+\t  rewrite_into_ssa (false);\n \t  bitmap_clear (vars_to_rename);\n \n \t  /* The into SSA translation may have created new SSA_NAMES whic"}, {"sha": "5794a86cd6c67ad27d2dea6ab8d816d7d52d9827", "filename": "gcc/tree-ssa-loop-ch.c", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -0,0 +1,349 @@\n+/* Loop header copying on trees.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-pass.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-inline.h\"\n+#include \"flags.h\"\n+#include \"tree-inline.h\"\n+\n+/* Duplicates headers of loops if they are small enough, so that the statements\n+   in the loop body are always executed when the loop is entered.  This\n+   increases effectivity of code motion optimizations, and reduces the need\n+   for loop preconditioning.  */\n+\n+/* Check whether we should duplicate HEADER of LOOP.  At most *LIMIT\n+   instructions should be duplicated, limit is decreased by the actual\n+   amount.  */\n+\n+static bool\n+should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n+\t\t\t\tint *limit)\n+{\n+  block_stmt_iterator bsi;\n+  tree last;\n+\n+  /* Do not copy one block more than once (we do not really want to do\n+     loop peeling here).  */\n+  if (header->aux)\n+    return false;\n+\n+  if (!header->succ)\n+    abort ();\n+  if (!header->succ->succ_next)\n+    return false;\n+  if (header->succ->succ_next->succ_next)\n+    return false;\n+  if (flow_bb_inside_loop_p (loop, header->succ->dest)\n+      && flow_bb_inside_loop_p (loop, header->succ->succ_next->dest))\n+    return false;\n+\n+  /* If this is not the original loop header, we want it to have just\n+     one predecessor in order to match the && pattern.  */\n+  if (header != loop->header\n+      && header->pred->pred_next)\n+    return false;\n+\n+  last = last_stmt (header);\n+  if (TREE_CODE (last) != COND_EXPR)\n+    return false;\n+\n+  /* Approximately copy the conditions that used to be used in jump.c --\n+     at most 20 insns and no calls.  */\n+  for (bsi = bsi_start (header); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      last = bsi_stmt (bsi);\n+\n+      if (TREE_CODE (last) == LABEL_EXPR)\n+\tcontinue;\n+\n+      if (get_call_expr_in (last))\n+\treturn false;\n+\n+      *limit -= estimate_num_insns (last);\n+      if (*limit < 0)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Marks variables defined in basic block BB for rewriting.  */\n+\n+static void\n+mark_defs_for_rewrite (basic_block bb)\n+{\n+  tree stmt, var;\n+  block_stmt_iterator bsi;\n+  stmt_ann_t ann;\n+  def_optype defs;\n+  v_may_def_optype v_may_defs;\n+  v_must_def_optype v_must_defs;\n+  unsigned i;\n+\n+  for (stmt = phi_nodes (bb); stmt; stmt = TREE_CHAIN (stmt))\n+    {\n+      var = PHI_RESULT (stmt);\n+      bitmap_set_bit (vars_to_rename, SSA_NAME_VERSION (var));\n+    }\n+\n+  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+    {\n+      stmt = bsi_stmt (bsi);\n+      get_stmt_operands (stmt);\n+      ann = stmt_ann (stmt);\n+\n+      defs = DEF_OPS (ann);\n+      for (i = 0; i < NUM_DEFS (defs); i++)\n+\t{\n+\t  var = DEF_OP (defs, i);\n+\t  bitmap_set_bit (vars_to_rename, SSA_NAME_VERSION (var));\n+\t}\n+\n+      v_may_defs = V_MAY_DEF_OPS (ann);\n+      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+\t{\n+\t  var = V_MAY_DEF_RESULT (v_may_defs, i);\n+\t  bitmap_set_bit (vars_to_rename, SSA_NAME_VERSION (var));\n+\t}\n+\n+      v_must_defs = V_MUST_DEF_OPS (ann);\n+      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+\t{\n+\t  var = V_MUST_DEF_OP (v_must_defs, i);\n+\t  bitmap_set_bit (vars_to_rename, SSA_NAME_VERSION (var));\n+\t}\n+    }\n+}\n+\n+/* Duplicates destinations of edges in BBS_TO_DUPLICATE.  */\n+\n+static void\n+duplicate_blocks (varray_type bbs_to_duplicate)\n+{\n+  unsigned i;\n+  edge preheader_edge, e, e1;\n+  basic_block header, new_header;\n+  tree phi, new_phi, var;\n+\n+  /* TODO: It should be quite easy to keep the dominance information\n+     up-to-date.  */\n+  free_dominance_info (CDI_DOMINATORS);\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (bbs_to_duplicate); i++)\n+    {\n+      preheader_edge = VARRAY_GENERIC_PTR_NOGC (bbs_to_duplicate, i);\n+      header = preheader_edge->dest;\n+\n+      /* It is sufficient to rewrite the definitions, since the uses of\n+\t the operands defined outside of the duplicated basic block are\n+\t still valid (every basic block that dominates the original block\n+\t also dominates the duplicate).  */\n+      mark_defs_for_rewrite (header);\n+    }\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (bbs_to_duplicate); i++)\n+    {\n+      preheader_edge = VARRAY_GENERIC_PTR_NOGC (bbs_to_duplicate, i);\n+      header = preheader_edge->dest;\n+\n+      if (!header->aux)\n+\tabort ();\n+      header->aux = NULL;\n+\n+      new_header = duplicate_block (header, preheader_edge);\n+\n+      /* Create the phi nodes on on entry to new_header.  */\n+      for (phi = phi_nodes (header), var = PENDING_STMT (preheader_edge);\n+\t   phi;\n+\t   phi = TREE_CHAIN (phi), var = TREE_CHAIN (var))\n+\t{\n+\t  new_phi = create_phi_node (PHI_RESULT (phi), new_header);\n+\t  add_phi_arg (&new_phi, TREE_VALUE (var), preheader_edge);\n+\t}\n+      PENDING_STMT (preheader_edge) = NULL;\n+\n+      /* Add the phi arguments to the outgoing edges.  */\n+      for (e = header->succ; e; e = e->succ_next)\n+\t{\n+\t  for (e1 = new_header->succ; e1->dest != e->dest; e1 = e1->succ_next)\n+\t    continue;\n+\n+\t  for (phi = phi_nodes (e->dest); phi; phi = TREE_CHAIN (phi))\n+\t    {\n+\t      tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n+\t      add_phi_arg (&phi, def, e1);\n+\t    }\n+\t}\n+    }\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  rewrite_ssa_into_ssa (vars_to_rename);\n+  bitmap_clear (vars_to_rename);\n+}\n+\n+/* Checks whether LOOP is a do-while style loop.  */\n+\n+static bool\n+do_while_loop_p (struct loop *loop)\n+{\n+  tree stmt = last_stmt (loop->latch);\n+\n+  /* If the latch of the loop is not empty, it is not a do-while loop.  */\n+  if (stmt\n+      && TREE_CODE (stmt) != LABEL_EXPR)\n+    return false;\n+\n+  /* If the header contains just a condition, it is not a do-while loop.  */\n+  stmt = last_and_only_stmt (loop->header);\n+  if (stmt\n+      && TREE_CODE (stmt) == COND_EXPR)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* For all loops, copy the condition at the end of the loop body in front\n+   of the loop.  This is beneficial since it increases efficiency of\n+   code motion optimizations.  It also saves one jump on entry to the loop.  */\n+\n+static void\n+copy_loop_headers (void)\n+{\n+  struct loops *loops;\n+  unsigned i;\n+  struct loop *loop;\n+  basic_block header;\n+  edge preheader_edge;\n+  varray_type bbs_to_duplicate = NULL;\n+\n+  loops = loop_optimizer_init (dump_file);\n+  if (!loops)\n+    return;\n+  \n+  /* We do not try to keep the information about irreducible regions\n+     up-to-date.  */\n+  loops->state &= ~LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_structure (loops);\n+#endif\n+\n+  for (i = 1; i < loops->num; i++)\n+    {\n+      /* Copy at most 20 insns.  */\n+      int limit = 20;\n+\n+      loop = loops->parray[i];\n+      preheader_edge = loop_preheader_edge (loop);\n+      header = preheader_edge->dest;\n+\n+      /* If the loop is already a do-while style one (either because it was\n+\t written as such, or because jump threading transformed it into one),\n+\t we might be in fact peeling the first iteration of the loop.  This\n+\t in general is not a good idea.  */\n+      if (do_while_loop_p (loop))\n+\tcontinue;\n+\n+      /* Iterate the header copying up to limit; this takes care of the cases\n+\t like while (a && b) {...}, where we want to have both of the conditions\n+\t copied.  TODO -- handle while (a || b) - like cases, by not requiring\n+\t the header to have just a single successor and copying up to\n+\t postdominator. \n+\t \n+\t We do not really copy the blocks immediately, so that we do not have\n+\t to worry about updating loop structures, and also so that we do not\n+\t have to rewrite variables out of and into ssa form for each block.\n+\t Instead we just record the block into worklist and duplicate all of\n+\t them at once.  */\n+      while (should_duplicate_loop_header_p (header, loop, &limit))\n+\t{\n+\t  if (!bbs_to_duplicate)\n+\t    VARRAY_GENERIC_PTR_NOGC_INIT (bbs_to_duplicate, 10,\n+\t\t\t\t\t  \"bbs_to_duplicate\");\n+\t  VARRAY_PUSH_GENERIC_PTR_NOGC (bbs_to_duplicate, preheader_edge);\n+\t  header->aux = &header->aux;\n+\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Scheduled basic block %d for duplication.\\n\",\n+\t\t     header->index);\n+\n+\t  /* Find a successor of header that is inside a loop; i.e. the new\n+\t     header after the condition is copied.  */\n+\t  if (flow_bb_inside_loop_p (loop, header->succ->dest))\n+\t    preheader_edge = header->succ;\n+\t  else\n+\t    preheader_edge = header->succ->succ_next;\n+\t  header = preheader_edge->dest;\n+\t}\n+    }\n+\n+  loop_optimizer_finalize (loops, NULL);\n+\n+  if (bbs_to_duplicate)\n+    {\n+      duplicate_blocks (bbs_to_duplicate);\n+      VARRAY_FREE (bbs_to_duplicate);\n+    }\n+\n+  /* Run cleanup_tree_cfg here regardless of whether we have done anything, so\n+     that we cleanup the blocks created in order to get the loops into a\n+     canonical shape.  */\n+  cleanup_tree_cfg ();\n+}\n+\n+static bool\n+gate_ch (void)\n+{\n+  return flag_tree_ch != 0;\n+}\n+\n+struct tree_opt_pass pass_ch = \n+{\n+  \"ch\",\t\t\t\t\t/* name */\n+  gate_ch,\t\t\t\t/* gate */\n+  copy_loop_headers,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_CH,\t\t\t\t/* tv_id */\n+  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  (TODO_dump_func\n+   | TODO_verify_ssa)\t\t\t/* todo_flags_finish */\n+};"}, {"sha": "4ceb2820b3841b88379cfd8ab2a85fc634129e4f", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 0, "deletions": 332, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -39,335 +39,3 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-inline.h\"\n \n \n-/* Check whether we should duplicate HEADER of LOOP.  At most *LIMIT\n-   instructions should be duplicated, limit is decreased by the actual\n-   amount.  */\n-\n-static bool\n-should_duplicate_loop_header_p (basic_block header, struct loop *loop,\n-\t\t\t\tint *limit)\n-{\n-  block_stmt_iterator bsi;\n-  tree last;\n-\n-  /* Do not copy one block more than once (we do not really want to do\n-     loop peeling here).  */\n-  if (header->aux)\n-    return false;\n-\n-  if (!header->succ)\n-    abort ();\n-  if (!header->succ->succ_next)\n-    return false;\n-  if (header->succ->succ_next->succ_next)\n-    return false;\n-  if (flow_bb_inside_loop_p (loop, header->succ->dest)\n-      && flow_bb_inside_loop_p (loop, header->succ->succ_next->dest))\n-    return false;\n-\n-  /* If this is not the original loop header, we want it to have just\n-     one predecessor in order to match the && pattern.  */\n-  if (header != loop->header\n-      && header->pred->pred_next)\n-    return false;\n-\n-  last = last_stmt (header);\n-  if (TREE_CODE (last) != COND_EXPR)\n-    return false;\n-\n-  /* Approximately copy the conditions that used to be used in jump.c --\n-     at most 20 insns and no calls.  */\n-  for (bsi = bsi_start (header); !bsi_end_p (bsi); bsi_next (&bsi))\n-    {\n-      last = bsi_stmt (bsi);\n-\n-      if (TREE_CODE (last) == LABEL_EXPR)\n-\tcontinue;\n-\n-      if (get_call_expr_in (last))\n-\treturn false;\n-\n-      *limit -= estimate_num_insns (last);\n-      if (*limit < 0)\n-\treturn false;\n-    }\n-\n-  return true;\n-}\n-\n-/* Marks variables defined in basic block BB for rewriting.  */\n-\n-static void\n-mark_defs_for_rewrite (basic_block bb)\n-{\n-  tree stmt, var;\n-  block_stmt_iterator bsi;\n-  stmt_ann_t ann;\n-  def_optype defs;\n-  v_may_def_optype v_may_defs;\n-  vuse_optype vuses;\n-  v_must_def_optype v_must_defs;\n-  unsigned i;\n-\n-  for (stmt = phi_nodes (bb); stmt; stmt = PHI_CHAIN (stmt))\n-    {\n-      var = SSA_NAME_VAR (PHI_RESULT (stmt));\n-      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\n-      /* If we have a type_mem_tag, add it as well.  Due to rewriting the\n-\t variable out of ssa, we lose its name tag, so we use type_mem_tag\n-\t instead.  */\n-      var = var_ann (var)->type_mem_tag;\n-      if (var)\n-\tbitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-    }\n-\n-  for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-    {\n-      stmt = bsi_stmt (bsi);\n-      get_stmt_operands (stmt);\n-      ann = stmt_ann (stmt);\n-\n-      defs = DEF_OPS (ann);\n-      for (i = 0; i < NUM_DEFS (defs); i++)\n-\t{\n-\t  var = SSA_NAME_VAR (DEF_OP (defs, i));\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\n-\t  /* If we have a type_mem_tag, add it as well.  Due to rewriting the\n-\t     variable out of ssa, we lose its name tag, so we use type_mem_tag\n-\t     instead.  */\n-\t  var = var_ann (var)->type_mem_tag;\n-\t  if (var)\n-\t    bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-\n-      v_may_defs = V_MAY_DEF_OPS (ann);\n-      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-\t{\n-\t  var = SSA_NAME_VAR (V_MAY_DEF_RESULT (v_may_defs, i));\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-\t\n-      v_must_defs = V_MUST_DEF_OPS (ann);\n-      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n-\t{\n-\t  var = SSA_NAME_VAR (V_MUST_DEF_OP (v_must_defs, i));\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-\n-      /* We also need to rewrite vuses, since we will copy the statements\n-\t and the ssa versions could not be recovered in the copy.  We do\n-\t not have to do this for operands of V_MAY_DEFS explicitly, since\n-\t they have the same underlying variable as the results.  */\n-      vuses = VUSE_OPS (ann);\n-      for (i = 0; i < NUM_VUSES (vuses); i++)\n-\t{\n-\t  var = SSA_NAME_VAR (VUSE_OP (vuses, i));\n-\t  bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t}\n-    }\n-}\n-\n-/* Duplicates destinations of edges in BBS_TO_DUPLICATE.  */\n-\n-static void\n-duplicate_blocks (varray_type bbs_to_duplicate)\n-{\n-  unsigned i;\n-  edge preheader_edge, e, e1;\n-  basic_block header, new_header;\n-  tree phi;\n-  size_t old_num_referenced_vars = num_referenced_vars;\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (bbs_to_duplicate); i++)\n-    {\n-      preheader_edge = VARRAY_GENERIC_PTR_NOGC (bbs_to_duplicate, i);\n-      header = preheader_edge->dest;\n-\n-      /* It is sufficient to rewrite the definitions, since the uses of\n-\t the operands defined outside of the duplicated basic block are\n-\t still valid (every basic block that dominates the original block\n-\t also dominates the duplicate).  */\n-      mark_defs_for_rewrite (header);\n-    }\n-\n-  rewrite_vars_out_of_ssa (vars_to_rename);\n-\n-  for (i = old_num_referenced_vars; i < num_referenced_vars; i++)\n-    {\n-      bitmap_set_bit (vars_to_rename, i);\n-      var_ann (referenced_var (i))->out_of_ssa_tag = 0;\n-    }\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (bbs_to_duplicate); i++)\n-    {\n-      preheader_edge = VARRAY_GENERIC_PTR_NOGC (bbs_to_duplicate, i);\n-      header = preheader_edge->dest;\n-\n-      /* We might have split the edge into the loop header when we have\n-\t eliminated the phi nodes, so find the edge to that we want to\n-\t copy the header.  */\n-      while (!header->aux)\n-\t{\n-\t  preheader_edge = header->succ;\n-\t  header = preheader_edge->dest;\n-\t}\n-      header->aux = NULL;\n-\n-      new_header = duplicate_block (header, preheader_edge);\n-\n-      /* Add the phi arguments to the outgoing edges.  */\n-      for (e = header->succ; e; e = e->succ_next)\n-\t{\n-\t  for (e1 = new_header->succ; e1->dest != e->dest; e1 = e1->succ_next)\n-\t    continue;\n-\n-\t  for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-\t    {\n-\t      tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);\n-\t      add_phi_arg (&phi, def, e1);\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Checks whether LOOP is a do-while style loop.  */\n-\n-static bool\n-do_while_loop_p (struct loop *loop)\n-{\n-  tree stmt = last_stmt (loop->latch);\n-\n-  /* If the latch of the loop is not empty, it is not a do-while loop.  */\n-  if (stmt\n-      && TREE_CODE (stmt) != LABEL_EXPR)\n-    return false;\n-\n-  /* If the header contains just a condition, it is not a do-while loop.  */\n-  stmt = last_and_only_stmt (loop->header);\n-  if (stmt\n-      && TREE_CODE (stmt) == COND_EXPR)\n-    return false;\n-\n-  return true;\n-}\n-\n-/* For all loops, copy the condition at the end of the loop body in front\n-   of the loop.  This is beneficial since it increases effectivity of\n-   code motion optimizations.  It also saves one jump on entry to the loop.  */\n-\n-static void\n-copy_loop_headers (void)\n-{\n-  struct loops *loops;\n-  unsigned i;\n-  struct loop *loop;\n-  basic_block header;\n-  edge preheader_edge;\n-  varray_type bbs_to_duplicate = NULL;\n-\n-  loops = loop_optimizer_init (dump_file);\n-  if (!loops)\n-    return;\n-  \n-  /* We are not going to need or update dominators.  */\n-  free_dominance_info (CDI_DOMINATORS);\n-\n-  create_preheaders (loops, CP_SIMPLE_PREHEADERS);\n-\n-  /* We do not try to keep the information about irreducible regions\n-     up-to-date.  */\n-  loops->state &= ~LOOPS_HAVE_MARKED_IRREDUCIBLE_REGIONS;\n-\n-#ifdef ENABLE_CHECKING\n-  verify_loop_structure (loops);\n-#endif\n-\n-  for (i = 1; i < loops->num; i++)\n-    {\n-      /* Copy at most 20 insns.  */\n-      int limit = 20;\n-\n-      loop = loops->parray[i];\n-      preheader_edge = loop_preheader_edge (loop);\n-      header = preheader_edge->dest;\n-\n-      /* If the loop is already a do-while style one (either because it was\n-\t written as such, or because jump threading transformed it into one),\n-\t we might be in fact peeling the first iteration of the loop.  This\n-\t in general is not a good idea.  */\n-      if (do_while_loop_p (loop))\n-\tcontinue;\n-\n-      /* Iterate the header copying up to limit; this takes care of the cases\n-\t like while (a && b) {...}, where we want to have both of the conditions\n-\t copied.  TODO -- handle while (a || b) - like cases, by not requiring\n-\t the header to have just a single successor and copying up to\n-\t postdominator. \n-\t \n-\t We do not really copy the blocks immediately, so that we do not have\n-\t to worry about updating loop structures, and also so that we do not\n-\t have to rewrite variables out of and into ssa form for each block.\n-\t Instead we just record the block into worklist and duplicate all of\n-\t them at once.  */\n-      while (should_duplicate_loop_header_p (header, loop, &limit))\n-\t{\n-\t  if (!bbs_to_duplicate)\n-\t    VARRAY_GENERIC_PTR_NOGC_INIT (bbs_to_duplicate, 10,\n-\t\t\t\t\t  \"bbs_to_duplicate\");\n-\t  VARRAY_PUSH_GENERIC_PTR_NOGC (bbs_to_duplicate, preheader_edge);\n-\t  header->aux = &header->aux;\n-\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file,\n-\t\t     \"Scheduled basic block %d for duplication.\\n\",\n-\t\t     header->index);\n-\n-\t  /* Find a successor of header that is inside a loop; i.e. the new\n-\t     header after the condition is copied.  */\n-\t  if (flow_bb_inside_loop_p (loop, header->succ->dest))\n-\t    preheader_edge = header->succ;\n-\t  else\n-\t    preheader_edge = header->succ->succ_next;\n-\t  header = preheader_edge->dest;\n-\t}\n-    }\n-\n-  loop_optimizer_finalize (loops, NULL);\n-\n-  if (bbs_to_duplicate)\n-    {\n-      duplicate_blocks (bbs_to_duplicate);\n-      VARRAY_FREE (bbs_to_duplicate);\n-    }\n-\n-  /* Run cleanup_tree_cfg here regardless of whether we have done anything, so\n-     that we cleanup the blocks created in order to get the loops into a\n-     canonical shape.  */\n-  cleanup_tree_cfg ();\n-}\n-\n-static bool\n-gate_ch (void)\n-{\n-  return flag_tree_ch != 0;\n-}\n-\n-struct tree_opt_pass pass_ch = \n-{\n-  \"ch\",\t\t\t\t\t/* name */\n-  gate_ch,\t\t\t\t/* gate */\n-  copy_loop_headers,\t\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  TV_TREE_CH,\t\t\t\t/* tv_id */\n-  PROP_cfg | PROP_ssa,\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  (TODO_rename_vars\n-   | TODO_dump_func\n-   | TODO_verify_ssa)\t\t\t/* todo_flags_finish */\n-};"}, {"sha": "c44189f0a9fc7820be3f87a125adf1d1e9bda759", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -1446,4 +1446,43 @@ add_call_read_ops (tree stmt, voperands_t prev_vops)\n     }\n }\n \n+/* Copies virtual operands from SRC to DST.  */\n+\n+void\n+copy_virtual_operands (tree dst, tree src)\n+{\n+  vuse_optype vuses = STMT_VUSE_OPS (src);\n+  v_may_def_optype v_may_defs = STMT_V_MAY_DEF_OPS (src);\n+  v_must_def_optype v_must_defs = STMT_V_MUST_DEF_OPS (src);\n+  vuse_optype *vuses_new = &stmt_ann (dst)->vuse_ops;\n+  v_may_def_optype *v_may_defs_new = &stmt_ann (dst)->v_may_def_ops;\n+  v_must_def_optype *v_must_defs_new = &stmt_ann (dst)->v_must_def_ops;\n+  unsigned i;\n+\n+  if (vuses)\n+    {\n+      *vuses_new = allocate_vuse_optype (NUM_VUSES (vuses));\n+      for (i = 0; i < NUM_VUSES (vuses); i++)\n+\tSET_VUSE_OP (*vuses_new, i, VUSE_OP (vuses, i));\n+    }\n+\n+  if (v_may_defs)\n+    {\n+      *v_may_defs_new = allocate_v_may_def_optype (NUM_V_MAY_DEFS (v_may_defs));\n+      for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n+\t{\n+\t  SET_V_MAY_DEF_OP (*v_may_defs_new, i, V_MAY_DEF_OP (v_may_defs, i));\n+\t  SET_V_MAY_DEF_RESULT (*v_may_defs_new, i, \n+\t\t\t\tV_MAY_DEF_RESULT (v_may_defs, i));\n+\t}\n+    }\n+\n+  if (v_must_defs)\n+    {\n+      *v_must_defs_new = allocate_v_must_def_optype (NUM_V_MUST_DEFS (v_must_defs));\n+      for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+\tSET_V_MUST_DEF_OP (*v_must_defs_new, i, V_MUST_DEF_OP (v_must_defs, i));\n+    }\n+}\n+\n #include \"gt-tree-ssa-operands.h\""}, {"sha": "625334109dcd2ea67de7b17fc9ec64ff994da942", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -164,5 +164,6 @@ extern void get_stmt_operands (tree);\n extern void remove_vuses (tree);\n extern void remove_v_may_defs (tree);\n extern void remove_v_must_defs (tree);\n+extern void copy_virtual_operands (tree, tree);\n \n #endif  /* GCC_TREE_SSA_OPERANDS_H  */"}, {"sha": "37534ca822f76033020645ecba2bc5e691da43f6", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f240ec46eaea80964f62124351e64cda949592e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5f240ec46eaea80964f62124351e64cda949592e", "patch": "@@ -1235,6 +1235,10 @@ struct tree_exp GTY(())\n #define SSA_NAME_VALUE(N) \\\n    SSA_NAME_CHECK (N)->ssa_name.value_handle\n \n+/* Auxiliary pass-specific data.  */\n+#define SSA_NAME_AUX(N) \\\n+   SSA_NAME_CHECK (N)->ssa_name.aux\n+   \n #ifndef _TREE_FLOW_H\n struct ptr_info_def;\n #endif\n@@ -1254,6 +1258,9 @@ struct tree_ssa_name GTY(())\n \n   /* Value for SSA name used by GVN.  */ \n   tree GTY((skip)) value_handle;\n+\n+  /* Auxiliary information stored with the ssa name.  */\n+  PTR GTY((skip)) aux;\n };\n \f\n /* In a PHI_NODE node.  */"}]}