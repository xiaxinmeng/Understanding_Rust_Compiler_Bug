{"sha": "18fa3240db054b98ef9464cbcedb186d819217fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThmYTMyNDBkYjA1NGI5OGVmOTQ2NGNiY2VkYjE4NmQ4MTkyMTdmZA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2007-03-07T07:27:25Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2007-03-07T07:27:25Z"}, "message": "ffi.h.in (ffi_closure_alloc, [...]): New.\n\nlibffi/ChangeLog:\n* include/ffi.h.in (ffi_closure_alloc, ffi_closure_free): New.\n(ffi_prep_closure_loc): New.\n(ffi_prep_raw_closure_loc): New.\n(ffi_prep_java_raw_closure_loc): New.\n* src/closures.c: New file.\n* src/dlmalloc.c [FFI_MMAP_EXEC_WRIT] (struct malloc_segment):\nReplace sflags with exec_offset.\n[FFI_MMAP_EXEC_WRIT] (mmap_exec_offset, add_segment_exec_offset,\nsub_segment_exec_offset): New macros.\n(get_segment_flags, set_segment_flags, check_segment_merge): New\nmacros.\n(is_mmapped_segment, is_extern_segment): Use get_segment_flags.\n(add_segment, sys_alloc, create_mspace, create_mspace_with_base,\ndestroy_mspace): Use new macros.\n(sys_alloc): Silence warning.\n* Makefile.am (libffi_la_SOURCES): Add src/closures.c.\n* Makefile.in: Rebuilt.\n* src/prep_cif [FFI_CLOSURES] (ffi_prep_closure): Implement in\nterms of ffi_prep_closure_loc.\n* src/raw_api.c (ffi_prep_raw_closure_loc): Renamed and adjusted\nfrom...\n(ffi_prep_raw_closure): ... this.  Re-implement in terms of the\nrenamed version.\n* src/java_raw_api (ffi_prep_java_raw_closure_loc): Renamed and\nadjusted from...\n(ffi_prep_java_raw_closure): ... this.  Re-implement in terms of\nthe renamed version.\n* src/alpha/ffi.c (ffi_prep_closure_loc): Renamed from\n(ffi_prep_closure): ... this.\n* src/pa/ffi.c: Likewise.\n* src/cris/ffi.c: Likewise.  Adjust.\n* src/frv/ffi.c: Likewise.\n* src/ia64/ffi.c: Likewise.\n* src/mips/ffi.c: Likewise.\n* src/powerpc/ffi_darwin.c: Likewise.\n* src/s390/ffi.c: Likewise.\n* src/sh/ffi.c: Likewise.\n* src/sh64/ffi.c: Likewise.\n* src/sparc/ffi.c: Likewise.\n* src/x86/ffi64.c: Likewise.\n* src/x86/ffi.c: Likewise.\n(FFI_INIT_TRAMPOLINE): Adjust.\n(ffi_prep_raw_closure_loc): Renamed and adjusted from...\n(ffi_prep_raw_closure): ... this.\n* src/powerpc/ffi.c (ffi_prep_closure_loc): Renamed from\n(ffi_prep_closure): ... this.\n(flush_icache): Adjust.\nboehm-gc/ChangeLog:\n* include/gc.h (GC_REGISTER_FINALIZER_UNREACHABLE): New.\n(GC_register_finalizer_unreachable): Declare.\n(GC_debug_register_finalizer_unreachable): Declare.\n* finalize.c (GC_unreachable_finalize_mark_proc): New.\n(GC_register_finalizer_unreachable): New.\n(GC_finalize): Handle it.\n* dbg_mlc.c (GC_debug_register_finalizer_unreachable): New.\n(GC_debug_register_finalizer_no_order): Fix whitespace.\nlibjava/ChangeLog:\n* include/jvm.h (_Jv_ClosureListFinalizer): New.\n(_Jv_Linker::create_error_method): Adjust.\n* boehm.cc (_Jv_ClosureListFinalizer): New.\n* nogc.cc (_Jv_ClosureListFinalizer): New.\n* java/lang/Class.h (class _Jv_ClosureList): New.\n(class java::lang::Class): Declare it as friend.\n* java/lang/natClass.cc (_Jv_ClosureList::releaseClosures): New.\n(_Jv_ClosureList::registerClousure): New.\n* include/execution.h (_Jv_ExecutionEngine): Add get_closure_list.\n(_Jv_CompiledEngine::do_get_closure_list): New.\n(_Jv_CompiledEngine::_Jv_CompiledEngine): Use it.\n(_Jv_IndirectCompiledClass): Add closures.\n(_Jv_IndirectCompiledEngine::get_aux_info): New.\n(_Jv_IndirectCompiledEngine::do_allocate_field_initializers): Use\nit.\n(_Jv_IndirectCompiledEngine::do_get_closure_list): New.\n(_Jv_IndirectCompiledEngine::_Jv_IndirectCompiledEngine): Use it.\n(_Jv_InterpreterEngine::do_get_closure_list): Declare.\n(_Jv_InterpreterEngine::_Jv_InterpreterEngine): Use it.\n* interpret.cc (FFI_PREP_RAW_CLOSURE): Use _loc variants.\n(node_closure): Add closure list.\n(_Jv_InterpMethod::ncode): Add jclass argument.  Use\nffi_closure_alloc and the separate code pointer.  Register the\nclosure for finalization.\n(_Jv_JNIMethod::ncode): Likewise.\n(_Jv_InterpreterEngine::do_create_ncode): Pass klass to ncode.\n(_Jv_InterpreterEngine::do_get_closure_list): New.\n* include/java-interp.h (_Jv_InterpMethod::ncode): Adjust.\n(_Jv_InterpClass): Add closures field.\n(_Jv_JNIMethod::ncode): Adjust.\n* defineclass.cc (_Jv_ClassReader::handleCodeAttribute): Adjust.\n(_Jv_ClassReader::handleMethodsEnd): Likewise.\n* link.cc (struct method_closure): Add closure list.\n(_Jv_Linker::create_error_method): Add jclass argument.  Use\nffi_closure_alloc and the separate code pointer.  Register the\nclosure for finalization.\n(_Jv_Linker::link_symbol_table): Remove outdated comment about\nsharing of otable and atable.  Adjust.\n* java/lang/reflect/natVMProxy.cc (ncode_closure): Add closure\nlist.\n(ncode): Add jclass argument.  Use ffi_closure_alloc and the\nseparate code pointer.  Register the closure for finalization.\n(java::lang::reflect::VMProxy::generateProxyClass): Adjust.\n* testsuite/libjava.jar/TestClosureGC.java: New.\n* testsuite/libjava.jar/TestClosureGC.out: New.\n* testsuite/libjava.jar/TestClosureGC.xfail: New.\n* testsuite/libjava.jar/TestClosureGC.jar: New.\n\nFrom-SVN: r122652", "tree": {"sha": "65dc1e16680788d96a4fb13f1406c83419164f7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65dc1e16680788d96a4fb13f1406c83419164f7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18fa3240db054b98ef9464cbcedb186d819217fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fa3240db054b98ef9464cbcedb186d819217fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18fa3240db054b98ef9464cbcedb186d819217fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18fa3240db054b98ef9464cbcedb186d819217fd/comments", "author": null, "committer": null, "parents": [{"sha": "dd77833100a12f219e7278685059dd82196c78f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd77833100a12f219e7278685059dd82196c78f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd77833100a12f219e7278685059dd82196c78f4"}], "stats": {"total": 1523, "additions": 1325, "deletions": 198}, "files": [{"sha": "89cabf0e88af46f0eb00483bc0af3cc911822fac", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,3 +1,14 @@\n+2007-03-07  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* include/gc.h (GC_REGISTER_FINALIZER_UNREACHABLE): New.\n+\t(GC_register_finalizer_unreachable): Declare.\n+\t(GC_debug_register_finalizer_unreachable): Declare.\n+\t* finalize.c (GC_unreachable_finalize_mark_proc): New.\n+\t(GC_register_finalizer_unreachable): New.\n+\t(GC_finalize): Handle it.\n+\t* dbg_mlc.c (GC_debug_register_finalizer_unreachable): New.\n+\t(GC_debug_register_finalizer_no_order): Fix whitespace.\n+\n 2007-03-01  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* Makefile.am: Add dummy install-pdf target."}, {"sha": "061a6a537b76d213dfc756a5bcc9d84c00279d55", "filename": "boehm-gc/dbg_mlc.c", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -3,6 +3,7 @@\n  * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n  * Copyright (c) 1999-2004 Hewlett-Packard Development Company, L.P.\n+ * Copyright (C) 2007 Free Software Foundation, Inc\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -1118,8 +1119,8 @@ GC_PTR *ocd;\n     if (0 == base) return;\n     if ((ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n-\t  \"GC_debug_register_finalizer_no_order called with non-base-pointer 0x%lx\\n\",\n-\t  obj);\n+\t    \"GC_debug_register_finalizer_no_order called with non-base-pointer 0x%lx\\n\",\n+\t    obj);\n     }\n     if (0 == fn) {\n       GC_register_finalizer_no_order(base, 0, 0, &my_old_fn, &my_old_cd);\n@@ -1129,7 +1130,41 @@ GC_PTR *ocd;\n \t\t\t\t     &my_old_cd);\n     }\n     store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);\n- }\n+}\n+\n+# ifdef __STDC__\n+    void GC_debug_register_finalizer_unreachable\n+    \t\t\t\t    (GC_PTR obj, GC_finalization_proc fn,\n+    \t\t\t\t     GC_PTR cd, GC_finalization_proc *ofn,\n+\t\t\t\t     GC_PTR *ocd)\n+# else\n+    void GC_debug_register_finalizer_unreachable\n+    \t\t\t\t    (obj, fn, cd, ofn, ocd)\n+    GC_PTR obj;\n+    GC_finalization_proc fn;\n+    GC_PTR cd;\n+    GC_finalization_proc *ofn;\n+    GC_PTR *ocd;\n+# endif\n+{\n+    GC_finalization_proc my_old_fn;\n+    GC_PTR my_old_cd;\n+    ptr_t base = GC_base(obj);\n+    if (0 == base) return;\n+    if ((ptr_t)obj - base != sizeof(oh)) {\n+        GC_err_printf1(\n+\t    \"GC_debug_register_finalizer_unreachable called with non-base-pointer 0x%lx\\n\",\n+\t    obj);\n+    }\n+    if (0 == fn) {\n+      GC_register_finalizer_unreachable(base, 0, 0, &my_old_fn, &my_old_cd);\n+    } else {\n+      GC_register_finalizer_unreachable(base, GC_debug_invoke_finalizer,\n+    \t\t\t    \t     GC_make_closure(fn,cd), &my_old_fn,\n+\t\t\t\t     &my_old_cd);\n+    }\n+    store_old(obj, my_old_fn, (struct closure *)my_old_cd, ofn, ocd);\n+}\n \n # ifdef __STDC__\n     void GC_debug_register_finalizer_ignore_self"}, {"sha": "484d421d1d68c2e6659612acd49c87e04e825a0e", "filename": "boehm-gc/finalize.c", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -2,6 +2,7 @@\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright (C) 2007 Free Software Foundation, Inc\n \n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -315,6 +316,14 @@ ptr_t p;\n {\n }\n \n+/* Possible finalization_marker procedures.  Note that mark stack\t*/\n+/* overflow is handled by the caller, and is not a disaster.\t\t*/\n+GC_API void GC_unreachable_finalize_mark_proc(p)\n+ptr_t p;\n+{\n+    return GC_normal_finalize_mark_proc(p);\n+}\n+\n \n \n /* Register a finalization function.  See gc.h for details.\t*/\n@@ -511,6 +520,23 @@ finalization_mark_proc * mp;\n     \t\t\t\tocd, GC_null_finalize_mark_proc);\n }\n \n+# if defined(__STDC__)\n+    void GC_register_finalizer_unreachable(void * obj,\n+\t\t\t       GC_finalization_proc fn, void * cd,\n+\t\t\t       GC_finalization_proc *ofn, void ** ocd)\n+# else\n+    void GC_register_finalizer_unreachable(obj, fn, cd, ofn, ocd)\n+    GC_PTR obj;\n+    GC_finalization_proc fn;\n+    GC_PTR cd;\n+    GC_finalization_proc * ofn;\n+    GC_PTR * ocd;\n+# endif\n+{\n+    GC_register_finalizer_inner(obj, fn, cd, ofn,\n+    \t\t\t\tocd, GC_unreachable_finalize_mark_proc);\n+}\n+\n #ifndef NO_DEBUGGING\n void GC_dump_finalization()\n {\n@@ -638,9 +664,44 @@ void GC_finalize()\n   \t    if (curr_fo -> fo_mark_proc == GC_null_finalize_mark_proc) {\n   \t        GC_MARK_FO(real_ptr, GC_normal_finalize_mark_proc);\n   \t    }\n-  \t    GC_set_mark_bit(real_ptr);\n+\t    if (curr_fo -> fo_mark_proc != GC_unreachable_finalize_mark_proc) {\n+\t\tGC_set_mark_bit(real_ptr);\n+\t    }\n   \t}\n       }\n+\n+      /* now revive finalize-when-unreachable objects reachable from\n+\t other finalizable objects */\n+      curr_fo = GC_finalize_now;\n+      prev_fo = 0;\n+      while (curr_fo != 0) {\n+\tnext_fo = fo_next(curr_fo);\n+\tif (curr_fo -> fo_mark_proc == GC_unreachable_finalize_mark_proc) {\n+\t  real_ptr = (ptr_t)curr_fo -> fo_hidden_base;\n+\t  if (!GC_is_marked(real_ptr)) {\n+\t      GC_set_mark_bit(real_ptr);\n+\t  } else {\n+\t      if (prev_fo == 0)\n+\t\tGC_finalize_now = next_fo;\n+\t      else\n+\t\tfo_set_next(prev_fo, next_fo);\n+\n+              curr_fo -> fo_hidden_base =\n+              \t\t(word) HIDE_POINTER(curr_fo -> fo_hidden_base);\n+              GC_words_finalized -=\n+                 \tALIGNED_WORDS(curr_fo -> fo_object_size)\n+              \t\t+ ALIGNED_WORDS(sizeof(struct finalizable_object));\n+\n+\t      i = HASH2(real_ptr, log_fo_table_size);\n+\t      fo_set_next (curr_fo, fo_head[i]);\n+\t      GC_fo_entries++;\n+\t      fo_head[i] = curr_fo;\n+\t      curr_fo = prev_fo;\n+\t  }\n+\t}\n+\tprev_fo = curr_fo;\n+\tcurr_fo = next_fo;\n+      }\n   }\n \n   /* Remove dangling disappearing links. */"}, {"sha": "c6c553d8427516640ca6126fab2977146b946e8c", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -3,6 +3,7 @@\n  * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n  * Copyright 1996-1999 by Silicon Graphics.  All rights reserved.\n  * Copyright 1999 by Hewlett-Packard Company.  All rights reserved.\n+ * Copyright (C) 2007 Free Software Foundation, Inc\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -602,6 +603,8 @@ GC_API GC_PTR GC_debug_realloc_replacement\n \tGC_debug_register_finalizer_ignore_self(p, f, d, of, od)\n #   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n \tGC_debug_register_finalizer_no_order(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_UNREACHABLE(p, f, d, of, od) \\\n+\tGC_debug_register_finalizer_unreachable(p, f, d, of, od)\n #   define GC_MALLOC_STUBBORN(sz) GC_debug_malloc_stubborn(sz, GC_EXTRAS);\n #   define GC_CHANGE_STUBBORN(p) GC_debug_change_stubborn(p)\n #   define GC_END_STUBBORN_CHANGE(p) GC_debug_end_stubborn_change(p)\n@@ -624,6 +627,8 @@ GC_API GC_PTR GC_debug_realloc_replacement\n \tGC_register_finalizer_ignore_self(p, f, d, of, od)\n #   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n \tGC_register_finalizer_no_order(p, f, d, of, od)\n+#   define GC_REGISTER_FINALIZER_UNREACHABLE(p, f, d, of, od) \\\n+\tGC_register_finalizer_unreachable(p, f, d, of, od)\n #   define GC_MALLOC_STUBBORN(sz) GC_malloc_stubborn(sz)\n #   define GC_CHANGE_STUBBORN(p) GC_change_stubborn(p)\n #   define GC_END_STUBBORN_CHANGE(p) GC_end_stubborn_change(p)\n@@ -716,6 +721,19 @@ GC_API void GC_debug_register_finalizer_no_order\n \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n \t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n \n+/* This is a special finalizer that is useful when an object's  */\n+/* finalizer must be run when the object is known to be no      */\n+/* longer reachable, not even from other finalizable objects.   */\n+/* This can be used in combination with finalizer_no_order so   */\n+/* as to release resources that must not be released while an   */\n+/* object can still be brought back to life by other            */\n+/* finalizers.                                                  */\n+GC_API void GC_register_finalizer_unreachable\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n+GC_API void GC_debug_register_finalizer_unreachable\n+\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n \n /* The following routine may be used to break cycles between\t*/\n /* finalizable objects, thus causing cyclic finalizable\t\t*/"}, {"sha": "7118b67869590f58a8eb70b385d15a8b9a220572", "filename": "libffi/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,3 +1,53 @@\n+2007-03-07  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* include/ffi.h.in (ffi_closure_alloc, ffi_closure_free): New.\n+\t(ffi_prep_closure_loc): New.\n+\t(ffi_prep_raw_closure_loc): New.\n+\t(ffi_prep_java_raw_closure_loc): New.\n+\t* src/closures.c: New file.\n+\t* src/dlmalloc.c [FFI_MMAP_EXEC_WRIT] (struct malloc_segment):\n+\tReplace sflags with exec_offset.\n+\t[FFI_MMAP_EXEC_WRIT] (mmap_exec_offset, add_segment_exec_offset,\n+\tsub_segment_exec_offset): New macros.\n+\t(get_segment_flags, set_segment_flags, check_segment_merge): New\n+\tmacros.\n+\t(is_mmapped_segment, is_extern_segment): Use get_segment_flags.\n+\t(add_segment, sys_alloc, create_mspace, create_mspace_with_base,\n+\tdestroy_mspace): Use new macros.\n+\t(sys_alloc): Silence warning.\n+\t* Makefile.am (libffi_la_SOURCES): Add src/closures.c.\n+\t* Makefile.in: Rebuilt.\n+\t* src/prep_cif [FFI_CLOSURES] (ffi_prep_closure): Implement in\n+\tterms of ffi_prep_closure_loc.\n+\t* src/raw_api.c (ffi_prep_raw_closure_loc): Renamed and adjusted\n+\tfrom...\n+\t(ffi_prep_raw_closure): ... this.  Re-implement in terms of the\n+\trenamed version.\n+\t* src/java_raw_api (ffi_prep_java_raw_closure_loc): Renamed and\n+\tadjusted from...\n+\t(ffi_prep_java_raw_closure): ... this.  Re-implement in terms of\n+\tthe renamed version.\n+\t* src/alpha/ffi.c (ffi_prep_closure_loc): Renamed from\n+\t(ffi_prep_closure): ... this.\n+\t* src/pa/ffi.c: Likewise.\n+\t* src/cris/ffi.c: Likewise.  Adjust.\n+\t* src/frv/ffi.c: Likewise.\n+\t* src/ia64/ffi.c: Likewise.\n+\t* src/mips/ffi.c: Likewise.\n+\t* src/powerpc/ffi_darwin.c: Likewise.\n+\t* src/s390/ffi.c: Likewise.\n+\t* src/sh/ffi.c: Likewise.\n+\t* src/sh64/ffi.c: Likewise.\n+\t* src/sparc/ffi.c: Likewise.\n+\t* src/x86/ffi64.c: Likewise.\n+\t* src/x86/ffi.c: Likewise.\n+\t(FFI_INIT_TRAMPOLINE): Adjust.\n+\t(ffi_prep_raw_closure_loc): Renamed and adjusted from...\n+\t(ffi_prep_raw_closure): ... this.\n+\t* src/powerpc/ffi.c (ffi_prep_closure_loc): Renamed from\n+\t(ffi_prep_closure): ... this.\n+\t(flush_icache): Adjust.\n+\n 2007-03-07  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* src/dlmalloc.c: New file, imported version 2.8.3 of Doug"}, {"sha": "36fa5fcaf2f59c743319124dc2564a7003a93e6a", "filename": "libffi/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -78,7 +78,7 @@ toolexeclib_LTLIBRARIES = libffi.la\n noinst_LTLIBRARIES = libffi_convenience.la\n \n libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n-\t\tsrc/raw_api.c src/java_raw_api.c\n+\t\tsrc/raw_api.c src/java_raw_api.c src/closures.c\n \n nodist_libffi_la_SOURCES =\n "}, {"sha": "3a3e33fdff06bd73046960fc08721dd4056b393f", "filename": "libffi/Makefile.in", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -92,7 +92,7 @@ LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)\n libffi_la_LIBADD =\n am__dirstamp = $(am__leading_dot)dirstamp\n am_libffi_la_OBJECTS = src/debug.lo src/prep_cif.lo src/types.lo \\\n-\tsrc/raw_api.lo src/java_raw_api.lo\n+\tsrc/raw_api.lo src/java_raw_api.lo src/closures.lo\n @MIPS_IRIX_TRUE@am__objects_1 = src/mips/ffi.lo src/mips/o32.lo \\\n @MIPS_IRIX_TRUE@\tsrc/mips/n32.lo\n @MIPS_LINUX_TRUE@am__objects_2 = src/mips/ffi.lo src/mips/o32.lo\n@@ -141,7 +141,7 @@ libffi_la_OBJECTS = $(am_libffi_la_OBJECTS) \\\n \t$(nodist_libffi_la_OBJECTS)\n libffi_convenience_la_LIBADD =\n am__objects_24 = src/debug.lo src/prep_cif.lo src/types.lo \\\n-\tsrc/raw_api.lo src/java_raw_api.lo\n+\tsrc/raw_api.lo src/java_raw_api.lo src/closures.lo\n am_libffi_convenience_la_OBJECTS = $(am__objects_24)\n am__objects_25 = $(am__objects_1) $(am__objects_2) $(am__objects_3) \\\n \t$(am__objects_4) $(am__objects_5) $(am__objects_6) \\\n@@ -416,7 +416,7 @@ MAKEOVERRIDES =\n toolexeclib_LTLIBRARIES = libffi.la\n noinst_LTLIBRARIES = libffi_convenience.la\n libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n-\t\tsrc/raw_api.c src/java_raw_api.c\n+\t\tsrc/raw_api.c src/java_raw_api.c src/closures.c\n \n nodist_libffi_la_SOURCES = $(am__append_1) $(am__append_2) \\\n \t$(am__append_3) $(am__append_4) $(am__append_5) \\\n@@ -534,6 +534,7 @@ src/prep_cif.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n src/types.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n src/raw_api.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n src/java_raw_api.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n+src/closures.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)\n src/mips/$(am__dirstamp):\n \t@$(mkdir_p) src/mips\n \t@: > src/mips/$(am__dirstamp)\n@@ -729,6 +730,8 @@ mostlyclean-compile:\n \t-rm -f src/arm/ffi.lo\n \t-rm -f src/arm/sysv.$(OBJEXT)\n \t-rm -f src/arm/sysv.lo\n+\t-rm -f src/closures.$(OBJEXT)\n+\t-rm -f src/closures.lo\n \t-rm -f src/cris/ffi.$(OBJEXT)\n \t-rm -f src/cris/ffi.lo\n \t-rm -f src/cris/sysv.$(OBJEXT)\n@@ -827,6 +830,7 @@ mostlyclean-compile:\n distclean-compile:\n \t-rm -f *.tab.c\n \n+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/closures.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/debug.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/java_raw_api.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/prep_cif.Plo@am__quote@"}, {"sha": "be32981d53fc5608f1d115bf516a7c4b0ea44cf9", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------*-C-*-\n-   libffi @VERSION@ - Copyright (c) 1996-2003  Red Hat, Inc.\n+   libffi @VERSION@ - Copyright (c) 1996-2003, 2007  Red Hat, Inc.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -228,12 +228,22 @@ typedef struct {\n   void      *user_data;\n } ffi_closure __attribute__((aligned (8)));\n \n+void *ffi_closure_alloc (size_t size, void **code);\n+void ffi_closure_free (void *);\n+\n ffi_status\n ffi_prep_closure (ffi_closure*,\n \t\t  ffi_cif *,\n \t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n \t\t  void *user_data);\n \n+ffi_status\n+ffi_prep_closure_loc (ffi_closure*,\n+\t\t      ffi_cif *,\n+\t\t      void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t      void *user_data,\n+\t\t      void*codeloc);\n+\n typedef struct {\n   char tramp[FFI_TRAMPOLINE_SIZE];\n \n@@ -261,12 +271,26 @@ ffi_prep_raw_closure (ffi_raw_closure*,\n \t\t      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n \t\t      void *user_data);\n \n+ffi_status\n+ffi_prep_raw_closure_loc (ffi_raw_closure*,\n+\t\t\t  ffi_cif *cif,\n+\t\t\t  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t\t  void *user_data,\n+\t\t\t  void *codeloc);\n+\n ffi_status\n ffi_prep_java_raw_closure (ffi_raw_closure*,\n \t\t           ffi_cif *cif,\n \t\t           void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n \t\t           void *user_data);\n \n+ffi_status\n+ffi_prep_java_raw_closure_loc (ffi_raw_closure*,\n+\t\t\t       ffi_cif *cif,\n+\t\t\t       void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t\t       void *user_data,\n+\t\t\t       void *codeloc);\n+\n #endif /* FFI_CLOSURES */\n \n /* ---- Public interface definition -------------------------------------- */"}, {"sha": "d139423f90e56ca7352e35900aebfaca3732d106", "filename": "libffi/src/alpha/ffi.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Falpha%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Falpha%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Falpha%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1998, 2001 Red Hat, Inc.\n+   ffi.c - Copyright (c) 1998, 2001, 2007 Red Hat, Inc.\n    \n    Alpha Foreign Function Interface \n \n@@ -146,10 +146,11 @@ ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n \n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   unsigned int *tramp;\n "}, {"sha": "99be5acfd79ab45cad1f3d378153fd9257d5bc0f", "filename": "libffi/src/closures.c", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fclosures.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fclosures.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fclosures.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -0,0 +1,513 @@\n+/* -----------------------------------------------------------------------\n+   closures.c - Copyright (c) 2007  Red Hat, Inc.\n+\n+   Code to allocate and deallocate memory for closures.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#ifndef FFI_MMAP_EXEC_WRIT\n+# if __gnu_linux__\n+/* This macro indicates it may be forbidden to map anonymous memory\n+   with both write and execute permission.  Code compiled when this\n+   option is defined will attempt to map such pages once, but if it\n+   fails, it falls back to creating a temporary file in a writable and\n+   executable filesystem and mapping pages from it into separate\n+   locations in the virtual memory space, one location writable and\n+   another executable.  */\n+#  define FFI_MMAP_EXEC_WRIT 1\n+# endif\n+#endif\n+\n+#if FFI_CLOSURES\n+\n+# if FFI_MMAP_EXEC_WRIT\n+\n+#define USE_LOCKS 1\n+#define USE_DL_PREFIX 1\n+#define USE_BUILTIN_FFS 1\n+\n+/* We need to use mmap, not sbrk.  */\n+#define HAVE_MORECORE 0\n+\n+/* We could, in theory, support mremap, but it wouldn't buy us anything.  */\n+#define HAVE_MREMAP 0\n+\n+/* We have no use for this, so save some code and data.  */\n+#define NO_MALLINFO 1\n+\n+/* We need all allocations to be in regular segments, otherwise we\n+   lose track of the corresponding code address.  */\n+#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T\n+\n+/* Don't allocate more than a page unless needed.  */\n+#define DEFAULT_GRANULARITY ((size_t)malloc_getpagesize)\n+\n+#if FFI_CLOSURE_TEST\n+/* Don't release single pages, to avoid a worst-case scenario of\n+   continuously allocating and releasing single pages, but release\n+   pairs of pages, which should do just as well given that allocations\n+   are likely to be small.  */\n+#define DEFAULT_TRIM_THRESHOLD ((size_t)malloc_getpagesize)\n+#endif\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <errno.h>\n+#include <unistd.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include <mntent.h>\n+#include <sys/param.h>\n+#include <pthread.h>\n+\n+/* We don't want sys/mman.h to be included after we redefine mmap and\n+   dlmunmap.  */\n+#include <sys/mman.h>\n+#define LACKS_SYS_MMAN_H 1\n+\n+#define MAYBE_UNUSED __attribute__((__unused__))\n+\n+/* Declare all functions defined in dlmalloc.c as static.  */\n+static void *dlmalloc(size_t);\n+static void dlfree(void*);\n+static void *dlcalloc(size_t, size_t) MAYBE_UNUSED;\n+static void *dlrealloc(void *, size_t) MAYBE_UNUSED;\n+static void *dlmemalign(size_t, size_t) MAYBE_UNUSED;\n+static void *dlvalloc(size_t) MAYBE_UNUSED;\n+static int dlmallopt(int, int) MAYBE_UNUSED;\n+static size_t dlmalloc_footprint(void) MAYBE_UNUSED;\n+static size_t dlmalloc_max_footprint(void) MAYBE_UNUSED;\n+static void** dlindependent_calloc(size_t, size_t, void**) MAYBE_UNUSED;\n+static void** dlindependent_comalloc(size_t, size_t*, void**) MAYBE_UNUSED;\n+static void *dlpvalloc(size_t) MAYBE_UNUSED;\n+static int dlmalloc_trim(size_t) MAYBE_UNUSED;\n+static size_t dlmalloc_usable_size(void*) MAYBE_UNUSED;\n+static void dlmalloc_stats(void) MAYBE_UNUSED;\n+\n+/* Use these for mmap and munmap within dlmalloc.c.  */\n+static void *dlmmap(void *, size_t, int, int, int, off_t);\n+static int dlmunmap(void *, size_t);\n+\n+#define mmap dlmmap\n+#define munmap dlmunmap\n+\n+#include \"dlmalloc.c\"\n+\n+#undef mmap\n+#undef munmap\n+\n+/* A mutex used to synchronize access to *exec* variables in this file.  */\n+static pthread_mutex_t open_temp_exec_file_mutex = PTHREAD_MUTEX_INITIALIZER;\n+\n+/* A file descriptor of a temporary file from which we'll map\n+   executable pages.  */\n+static int execfd = -1;\n+\n+/* The amount of space already allocated from the temporary file.  */\n+static size_t execsize = 0;\n+\n+/* Open a temporary file name, and immediately unlink it.  */\n+static int\n+open_temp_exec_file_name (char *name)\n+{\n+  int fd = mkstemp (name);\n+\n+  if (fd != -1)\n+    unlink (name);\n+\n+  return fd;\n+}\n+\n+/* Open a temporary file in the named directory.  */\n+static int\n+open_temp_exec_file_dir (const char *dir)\n+{\n+  static const char suffix[] = \"/ffiXXXXXX\";\n+  int lendir = strlen (dir);\n+  char *tempname = __builtin_alloca (lendir + sizeof (suffix));\n+\n+  if (!tempname)\n+    return -1;\n+\n+  memcpy (tempname, dir, lendir);\n+  memcpy (tempname + lendir, suffix, sizeof (suffix));\n+\n+  return open_temp_exec_file_name (tempname);\n+}\n+\n+/* Open a temporary file in the directory in the named environment\n+   variable.  */\n+static int\n+open_temp_exec_file_env (const char *envvar)\n+{\n+  const char *value = getenv (envvar);\n+\n+  if (!value)\n+    return -1;\n+\n+  return open_temp_exec_file_dir (value);\n+}\n+\n+/* Open a temporary file in an executable and writable mount point\n+   listed in the mounts file.  Subsequent calls with the same mounts\n+   keep searching for mount points in the same file.  Providing NULL\n+   as the mounts file closes the file.  */\n+static int\n+open_temp_exec_file_mnt (const char *mounts)\n+{\n+  static const char *last_mounts;\n+  static FILE *last_mntent;\n+\n+  if (mounts != last_mounts)\n+    {\n+      if (last_mntent)\n+\tendmntent (last_mntent);\n+\n+      last_mounts = mounts;\n+\n+      if (mounts)\n+\tlast_mntent = setmntent (mounts, \"r\");\n+      else\n+\tlast_mntent = NULL;\n+    }\n+\n+  if (!last_mntent)\n+    return -1;\n+\n+  for (;;)\n+    {\n+      int fd;\n+      struct mntent mnt;\n+      char buf[MAXPATHLEN * 3];\n+\n+      if (getmntent_r (last_mntent, &mnt, buf, sizeof (buf)))\n+\treturn -1;\n+\n+      if (hasmntopt (&mnt, \"ro\")\n+\t  || hasmntopt (&mnt, \"noexec\")\n+\t  || access (mnt.mnt_dir, W_OK))\n+\tcontinue;\n+\n+      fd = open_temp_exec_file_dir (mnt.mnt_dir);\n+\n+      if (fd != -1)\n+\treturn fd;\n+    }\n+}\n+\n+/* Instructions to look for a location to hold a temporary file that\n+   can be mapped in for execution.  */\n+static struct\n+{\n+  int (*func)(const char *);\n+  const char *arg;\n+  int repeat;\n+} open_temp_exec_file_opts[] = {\n+  { open_temp_exec_file_env, \"TMPDIR\", 0 },\n+  { open_temp_exec_file_dir, \"/tmp\", 0 },\n+  { open_temp_exec_file_dir, \"/var/tmp\", 0 },\n+  { open_temp_exec_file_dir, \"/dev/shm\", 0 },\n+  { open_temp_exec_file_env, \"HOME\", 0 },\n+  { open_temp_exec_file_mnt, \"/etc/mtab\", 1 },\n+  { open_temp_exec_file_mnt, \"/proc/mounts\", 1 },\n+};\n+\n+/* Current index into open_temp_exec_file_opts.  */\n+static int open_temp_exec_file_opts_idx = 0;\n+\n+/* Reset a current multi-call func, then advances to the next entry.\n+   If we're at the last, go back to the first and return nonzero,\n+   otherwise return zero.  */\n+static int\n+open_temp_exec_file_opts_next (void)\n+{\n+  if (open_temp_exec_file_opts[open_temp_exec_file_opts_idx].repeat)\n+    open_temp_exec_file_opts[open_temp_exec_file_opts_idx].func (NULL);\n+\n+  open_temp_exec_file_opts_idx++;\n+  if (open_temp_exec_file_opts_idx\n+      == (sizeof (open_temp_exec_file_opts)\n+\t  / sizeof (*open_temp_exec_file_opts)))\n+    {\n+      open_temp_exec_file_opts_idx = 0;\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return a file descriptor of a temporary zero-sized file in a\n+   writable and exexutable filesystem.  */\n+static int\n+open_temp_exec_file (void)\n+{\n+  int fd;\n+\n+  do\n+    {\n+      fd = open_temp_exec_file_opts[open_temp_exec_file_opts_idx].func\n+\t(open_temp_exec_file_opts[open_temp_exec_file_opts_idx].arg);\n+\n+      if (!open_temp_exec_file_opts[open_temp_exec_file_opts_idx].repeat\n+\t  || fd == -1)\n+\t{\n+\t  if (open_temp_exec_file_opts_next ())\n+\t    break;\n+\t}\n+    }\n+  while (fd == -1);\n+\n+  return fd;\n+}\n+\n+/* Map in a chunk of memory from the temporary exec file into separate\n+   locations in the virtual memory address space, one writable and one\n+   executable.  Returns the address of the writable portion, after\n+   storing an offset to the corresponding executable portion at the\n+   last word of the requested chunk.  */\n+static void *\n+dlmmap_locked (void *start, size_t length, int prot, int flags, off_t offset)\n+{\n+  void *ptr;\n+\n+  if (execfd == -1)\n+    {\n+      open_temp_exec_file_opts_idx = 0;\n+    retry_open:\n+      execfd = open_temp_exec_file ();\n+      if (execfd == -1)\n+\treturn MFAIL;\n+    }\n+\n+  offset = execsize;\n+\n+  if (ftruncate (execfd, offset + length))\n+    return MFAIL;\n+\n+  flags &= ~(MAP_PRIVATE | MAP_ANONYMOUS);\n+  flags |= MAP_SHARED;\n+\n+  ptr = mmap (NULL, length, (prot & ~PROT_WRITE) | PROT_EXEC,\n+\t      flags, execfd, offset);\n+  if (ptr == MFAIL)\n+    {\n+      if (!offset)\n+\t{\n+\t  close (execfd);\n+\t  goto retry_open;\n+\t}\n+      ftruncate (execfd, offset);\n+      return MFAIL;\n+    }\n+  else if (!offset\n+\t   && open_temp_exec_file_opts[open_temp_exec_file_opts_idx].repeat)\n+    open_temp_exec_file_opts_next ();\n+\n+  start = mmap (start, length, prot, flags, execfd, offset);\n+\n+  if (start == MFAIL)\n+    {\n+      munmap (ptr, length);\n+      ftruncate (execfd, offset);\n+      return start;\n+    }\n+\n+  mmap_exec_offset ((char *)start, length) = (char*)ptr - (char*)start;\n+\n+  execsize += length;\n+\n+  return start;\n+}\n+\n+/* Map in a writable and executable chunk of memory if possible.\n+   Failing that, fall back to dlmmap_locked.  */\n+static void *\n+dlmmap (void *start, size_t length, int prot,\n+\tint flags, int fd, off_t offset)\n+{\n+  void *ptr;\n+\n+  assert (start == NULL && length % malloc_getpagesize == 0\n+\t  && prot == (PROT_READ | PROT_WRITE)\n+\t  && flags == (MAP_PRIVATE | MAP_ANONYMOUS)\n+\t  && fd == -1 && offset == 0);\n+\n+#if FFI_CLOSURE_TEST\n+  printf (\"mapping in %zi\\n\", length);\n+#endif\n+\n+  if (execfd == -1)\n+    {\n+      ptr = mmap (start, length, prot | PROT_EXEC, flags, fd, offset);\n+\n+      if (ptr != MFAIL || (errno != EPERM && errno != EACCES))\n+\t/* Cool, no need to mess with separate segments.  */\n+\treturn ptr;\n+\n+      /* If MREMAP_DUP is ever introduced and implemented, try mmap\n+\t with ((prot & ~PROT_WRITE) | PROT_EXEC) and mremap with\n+\t MREMAP_DUP and prot at this point.  */\n+    }\n+\n+  if (execsize == 0 || execfd == -1)\n+    {\n+      pthread_mutex_lock (&open_temp_exec_file_mutex);\n+      ptr = dlmmap_locked (start, length, prot, flags, offset);\n+      pthread_mutex_unlock (&open_temp_exec_file_mutex);\n+\n+      return ptr;\n+    }\n+\n+  return dlmmap_locked (start, length, prot, flags, offset);\n+}\n+\n+/* Release memory at the given address, as well as the corresponding\n+   executable page if it's separate.  */\n+static int\n+dlmunmap (void *start, size_t length)\n+{\n+  /* We don't bother decreasing execsize or truncating the file, since\n+     we can't quite tell whether we're unmapping the end of the file.\n+     We don't expect frequent deallocation anyway.  If we did, we\n+     could locate pages in the file by writing to the pages being\n+     deallocated and checking that the file contents change.\n+     Yuck.  */\n+  msegmentptr seg = segment_holding (gm, start);\n+  void *code;\n+\n+#if FFI_CLOSURE_TEST\n+  printf (\"unmapping %zi\\n\", length);\n+#endif\n+\n+  if (seg && (code = add_segment_exec_offset (start, seg)) != start)\n+    {\n+      int ret = munmap (code, length);\n+      if (ret)\n+\treturn ret;\n+    }\n+\n+  return munmap (start, length);\n+}\n+\n+#if FFI_CLOSURE_FREE_CODE\n+/* Return segment holding given code address.  */\n+static msegmentptr\n+segment_holding_code (mstate m, char* addr)\n+{\n+  msegmentptr sp = &m->seg;\n+  for (;;) {\n+    if (addr >= add_segment_exec_offset (sp->base, sp)\n+\t&& addr < add_segment_exec_offset (sp->base, sp) + sp->size)\n+      return sp;\n+    if ((sp = sp->next) == 0)\n+      return 0;\n+  }\n+}\n+#endif\n+\n+/* Allocate a chunk of memory with the given size.  Returns a pointer\n+   to the writable address, and sets *CODE to the executable\n+   corresponding virtual address.  */\n+void *\n+ffi_closure_alloc (size_t size, void **code)\n+{\n+  void *ptr;\n+\n+  if (!code)\n+    return NULL;\n+\n+  ptr = dlmalloc (size);\n+\n+  if (ptr)\n+    {\n+      msegmentptr seg = segment_holding (gm, ptr);\n+\n+      *code = add_segment_exec_offset (ptr, seg);\n+    }\n+\n+  return ptr;\n+}\n+\n+/* Release a chunk of memory allocated with ffi_closure_alloc.  If\n+   FFI_CLOSURE_FREE_CODE is nonzero, the given address can be the\n+   writable or the executable address given.  Otherwise, only the\n+   writable address can be provided here.  */\n+void\n+ffi_closure_free (void *ptr)\n+{\n+#if FFI_CLOSURE_FREE_CODE\n+  msegmentptr seg = segment_holding_code (gm, ptr);\n+\n+  if (seg)\n+    ptr = sub_segment_exec_offset (ptr, seg);\n+#endif\n+\n+  dlfree (ptr);\n+}\n+\n+\n+#if FFI_CLOSURE_TEST\n+/* Do some internal sanity testing to make sure allocation and\n+   deallocation of pages are working as intended.  */\n+int main ()\n+{\n+  void *p[3];\n+#define GET(idx, len) do { p[idx] = dlmalloc (len); printf (\"allocated %zi for p[%i]\\n\", (len), (idx)); } while (0)\n+#define PUT(idx) do { printf (\"freeing p[%i]\\n\", (idx)); dlfree (p[idx]); } while (0)\n+  GET (0, malloc_getpagesize / 2);\n+  GET (1, 2 * malloc_getpagesize - 64 * sizeof (void*));\n+  PUT (1);\n+  GET (1, 2 * malloc_getpagesize);\n+  GET (2, malloc_getpagesize / 2);\n+  PUT (1);\n+  PUT (0);\n+  PUT (2);\n+  return 0;\n+}\n+#endif /* FFI_CLOSURE_TEST */\n+# else /* ! FFI_MMAP_EXEC_WRIT */\n+\n+/* On many systems, memory returned by malloc is writable and\n+   executable, so just use it.  */\n+\n+#include <stdlib.h>\n+\n+void *\n+ffi_closure_alloc (size_t size, void **code)\n+{\n+  if (!code)\n+    return NULL;\n+\n+  return *code = malloc (size);\n+}\n+\n+void\n+ffi_closure_free (void *ptr)\n+{\n+  free (ptr);\n+}\n+\n+# endif /* ! FFI_MMAP_EXEC_WRIT */\n+#endif /* FFI_CLOSURES */"}, {"sha": "e9c39530c22137a0add323527d3085fb4ae69e9c", "filename": "libffi/src/cris/ffi.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fcris%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fcris%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fcris%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -2,6 +2,7 @@\n    ffi.c - Copyright (c) 1998 Cygnus Solutions\n            Copyright (c) 2004 Simon Posnjak\n \t   Copyright (c) 2005 Axis Communications AB\n+\t   Copyright (C) 2007 Free Software Foundation, Inc.\n \n    CRIS Foreign Function Interface\n \n@@ -360,10 +361,11 @@ ffi_prep_closure_inner (void **params, ffi_closure* closure)\n /* API function: Prepare the trampoline.  */\n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif *, void *, void **, void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif *, void *, void **, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   void *innerfn = ffi_prep_closure_inner;\n   FFI_ASSERT (cif->abi == FFI_SYSV);\n@@ -375,7 +377,7 @@ ffi_prep_closure (ffi_closure* closure,\n   memcpy (closure->tramp + ffi_cris_trampoline_fn_offset,\n \t  &innerfn, sizeof (void *));\n   memcpy (closure->tramp + ffi_cris_trampoline_closure_offset,\n-\t  &closure, sizeof (void *));\n+\t  &codeloc, sizeof (void *));\n \n   return FFI_OK;\n }"}, {"sha": "c95e64a7e37c3d229567c7f723f2a5bbe753db65", "filename": "libffi/src/dlmalloc.c", "status": "modified", "additions": 48, "deletions": 10, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fdlmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fdlmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fdlmalloc.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1879,11 +1879,47 @@ struct malloc_segment {\n   char*        base;             /* base address */\n   size_t       size;             /* allocated size */\n   struct malloc_segment* next;   /* ptr to next segment */\n+#if FFI_MMAP_EXEC_WRIT\n+  /* The mmap magic is supposed to store the address of the executable\n+     segment at the very end of the requested block.  */\n+\n+# define mmap_exec_offset(b,s) (*(ptrdiff_t*)((b)+(s)-sizeof(ptrdiff_t)))\n+\n+  /* We can only merge segments if their corresponding executable\n+     segments are at identical offsets.  */\n+# define check_segment_merge(S,b,s) \\\n+  (mmap_exec_offset((b),(s)) == (S)->exec_offset)\n+\n+# define add_segment_exec_offset(p,S) ((char*)(p) + (S)->exec_offset)\n+# define sub_segment_exec_offset(p,S) ((char*)(p) - (S)->exec_offset)\n+\n+  /* The removal of sflags only works with HAVE_MORECORE == 0.  */\n+\n+# define get_segment_flags(S)   (IS_MMAPPED_BIT)\n+# define set_segment_flags(S,v) \\\n+  (((v) != IS_MMAPPED_BIT) ? (ABORT, (v)) :\t\t\t\t\\\n+   (((S)->exec_offset =\t\t\t\t\t\t\t\\\n+     mmap_exec_offset((S)->base, (S)->size)),\t\t\t\t\\\n+    (mmap_exec_offset((S)->base + (S)->exec_offset, (S)->size) !=\t\\\n+     (S)->exec_offset) ? (ABORT, (v)) :\t\t\t\t\t\\\n+   (mmap_exec_offset((S)->base, (S)->size) = 0), (v)))\n+\n+  /* We use an offset here, instead of a pointer, because then, when\n+     base changes, we don't have to modify this.  On architectures\n+     with segmented addresses, this might not work.  */\n+  ptrdiff_t    exec_offset;\n+#else\n+\n+# define get_segment_flags(S)   ((S)->sflags)\n+# define set_segment_flags(S,v) ((S)->sflags = (v))\n+# define check_segment_merge(S,b,s) (1)\n+\n   flag_t       sflags;           /* mmap and extern flag */\n+#endif\n };\n \n-#define is_mmapped_segment(S)  ((S)->sflags & IS_MMAPPED_BIT)\n-#define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT)\n+#define is_mmapped_segment(S)  (get_segment_flags(S) & IS_MMAPPED_BIT)\n+#define is_extern_segment(S)   (get_segment_flags(S) & EXTERN_BIT)\n \n typedef struct malloc_segment  msegment;\n typedef struct malloc_segment* msegmentptr;\n@@ -3290,7 +3326,7 @@ static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {\n   *ss = m->seg; /* Push current record */\n   m->seg.base = tbase;\n   m->seg.size = tsize;\n-  m->seg.sflags = mmapped;\n+  set_segment_flags(&m->seg, mmapped);\n   m->seg.next = ss;\n \n   /* Insert trailing fenceposts */\n@@ -3393,7 +3429,7 @@ static void* sys_alloc(mstate m, size_t nb) {\n             if (end != CMFAIL)\n               asize += esize;\n             else {            /* Can't use; try to release */\n-              CALL_MORECORE(-asize);\n+              (void)CALL_MORECORE(-asize);\n               br = CMFAIL;\n             }\n           }\n@@ -3450,7 +3486,7 @@ static void* sys_alloc(mstate m, size_t nb) {\n     if (!is_initialized(m)) { /* first-time initialization */\n       m->seg.base = m->least_addr = tbase;\n       m->seg.size = tsize;\n-      m->seg.sflags = mmap_flag;\n+      set_segment_flags(&m->seg, mmap_flag);\n       m->magic = mparams.magic;\n       init_bins(m);\n       if (is_global(m)) \n@@ -3469,7 +3505,8 @@ static void* sys_alloc(mstate m, size_t nb) {\n         sp = sp->next;\n       if (sp != 0 &&\n           !is_extern_segment(sp) &&\n-          (sp->sflags & IS_MMAPPED_BIT) == mmap_flag &&\n+\t  check_segment_merge(sp, tbase, tsize) &&\n+          (get_segment_flags(sp) & IS_MMAPPED_BIT) == mmap_flag &&\n           segment_holds(sp, m->top)) { /* append */\n         sp->size += tsize;\n         init_top(m, m->top, m->topsize + tsize);\n@@ -3482,7 +3519,8 @@ static void* sys_alloc(mstate m, size_t nb) {\n           sp = sp->next;\n         if (sp != 0 &&\n             !is_extern_segment(sp) &&\n-            (sp->sflags & IS_MMAPPED_BIT) == mmap_flag) {\n+\t    check_segment_merge(sp, tbase, tsize) &&\n+            (get_segment_flags(sp) & IS_MMAPPED_BIT) == mmap_flag) {\n           char* oldbase = sp->base;\n           sp->base = tbase;\n           sp->size += tsize;\n@@ -4397,7 +4435,7 @@ mspace create_mspace(size_t capacity, int locked) {\n     char* tbase = (char*)(CALL_MMAP(tsize));\n     if (tbase != CMFAIL) {\n       m = init_user_mstate(tbase, tsize);\n-      m->seg.sflags = IS_MMAPPED_BIT;\n+      set_segment_flags(&m->seg, IS_MMAPPED_BIT);\n       set_lock(m, locked);\n     }\n   }\n@@ -4412,7 +4450,7 @@ mspace create_mspace_with_base(void* base, size_t capacity, int locked) {\n   if (capacity > msize + TOP_FOOT_SIZE &&\n       capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {\n     m = init_user_mstate((char*)base, capacity);\n-    m->seg.sflags = EXTERN_BIT;\n+    set_segment_flags(&m->seg, EXTERN_BIT);\n     set_lock(m, locked);\n   }\n   return (mspace)m;\n@@ -4426,7 +4464,7 @@ size_t destroy_mspace(mspace msp) {\n     while (sp != 0) {\n       char* base = sp->base;\n       size_t size = sp->size;\n-      flag_t flag = sp->sflags;\n+      flag_t flag = get_segment_flags(sp);\n       sp = sp->next;\n       if ((flag & IS_MMAPPED_BIT) && !(flag & EXTERN_BIT) &&\n           CALL_MUNMAP(base, size) == 0)"}, {"sha": "e9dc67625612d656529e16918d1d7ac1a3c3148a", "filename": "libffi/src/frv/ffi.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Ffrv%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Ffrv%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ffrv%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n    ffi.c - Copyright (c) 2004  Anthony Green\n+   Copyright (C) 2007  Free Software Foundation, Inc.\n    \n    FR-V Foreign Function Interface \n \n@@ -243,14 +244,15 @@ void ffi_closure_eabi (unsigned arg1, unsigned arg2, unsigned arg3,\n }\n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n   unsigned long fn = (long) ffi_closure_eabi;\n-  unsigned long cls = (long) closure;\n+  unsigned long cls = (long) codeloc;\n #ifdef __FRV_FDPIC__\n   register void *got __asm__(\"gr15\");\n #endif\n@@ -259,7 +261,7 @@ ffi_prep_closure (ffi_closure* closure,\n   fn = (unsigned long) ffi_closure_eabi;\n \n #ifdef __FRV_FDPIC__\n-  tramp[0] = &tramp[2];\n+  tramp[0] = &((unsigned int *)codeloc)[2];\n   tramp[1] = got;\n   tramp[2] = 0x8cfc0000 + (fn  & 0xffff); /* setlos lo(fn), gr6    */\n   tramp[3] = 0x8efc0000 + (cls & 0xffff); /* setlos lo(cls), gr7   */\n@@ -281,7 +283,8 @@ ffi_prep_closure (ffi_closure* closure,\n \n   /* Cache flushing.  */\n   for (i = 0; i < FFI_TRAMPOLINE_SIZE; i++)\n-    __asm__ volatile (\"dcf @(%0,%1)\\n\\tici @(%0,%1)\" :: \"r\" (tramp), \"r\" (i));\n+    __asm__ volatile (\"dcf @(%0,%1)\\n\\tici @(%2,%1)\" :: \"r\" (tramp), \"r\" (i),\n+\t\t      \"r\" (codeloc));\n \n   return FFI_OK;\n }"}, {"sha": "09021def3a44716fa6c9cd3cab31d242459ede46", "filename": "libffi/src/ia64/ffi.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fia64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fia64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fia64%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1998 Red Hat, Inc.\n+   ffi.c - Copyright (c) 1998, 2007 Red Hat, Inc.\n \t   Copyright (c) 2000 Hewlett Packard Company\n    \n    IA64 Foreign Function Interface \n@@ -400,10 +400,11 @@ ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n extern void ffi_closure_unix ();\n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   /* The layout of a function descriptor.  A C function pointer really \n      points to one of these.  */\n@@ -430,7 +431,7 @@ ffi_prep_closure (ffi_closure* closure,\n \n   tramp->code_pointer = fd->code_pointer;\n   tramp->real_gp = fd->gp;\n-  tramp->fake_gp = (UINT64)(PTR64)closure;\n+  tramp->fake_gp = (UINT64)(PTR64)codeloc;\n   closure->cif = cif;\n   closure->user_data = user_data;\n   closure->fun = fun;"}, {"sha": "9c00d37ed052a5e70f52f3dcce7decf26ec32b5c", "filename": "libffi/src/java_raw_api.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fjava_raw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fjava_raw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fjava_raw_api.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   java_raw_api.c - Copyright (c) 1999  Red Hat, Inc.\n+   java_raw_api.c - Copyright (c) 1999, 2007  Red Hat, Inc.\n \n    Cloned from raw_api.c\n \n@@ -307,22 +307,20 @@ ffi_java_translate_args (ffi_cif *cif, void *rvalue,\n   ffi_java_raw_to_rvalue (cif, rvalue);\n }\n \n-/* Again, here is the generic version of ffi_prep_raw_closure, which\n- * will install an intermediate \"hub\" for translation of arguments from\n- * the pointer-array format, to the raw format */\n-\n ffi_status\n-ffi_prep_java_raw_closure (ffi_raw_closure* cl,\n-\t\t      ffi_cif *cif,\n-\t\t      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n-\t\t      void *user_data)\n+ffi_prep_java_raw_closure_loc (ffi_raw_closure* cl,\n+\t\t\t       ffi_cif *cif,\n+\t\t\t       void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t\t       void *user_data,\n+\t\t\t       void *codeloc)\n {\n   ffi_status status;\n \n-  status = ffi_prep_closure ((ffi_closure*) cl,\n-\t\t\t     cif,\n-\t\t\t     &ffi_java_translate_args,\n-\t\t\t     (void*)cl);\n+  status = ffi_prep_closure_loc ((ffi_closure*) cl,\n+\t\t\t\t cif,\n+\t\t\t\t &ffi_java_translate_args,\n+\t\t\t\t codeloc,\n+\t\t\t\t codeloc);\n   if (status == FFI_OK)\n     {\n       cl->fun       = fun;\n@@ -332,6 +330,19 @@ ffi_prep_java_raw_closure (ffi_raw_closure* cl,\n   return status;\n }\n \n+/* Again, here is the generic version of ffi_prep_raw_closure, which\n+ * will install an intermediate \"hub\" for translation of arguments from\n+ * the pointer-array format, to the raw format */\n+\n+ffi_status\n+ffi_prep_java_raw_closure (ffi_raw_closure* cl,\n+\t\t\t   ffi_cif *cif,\n+\t\t\t   void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t\t   void *user_data)\n+{\n+  return ffi_prep_java_raw_closure_loc (cl, cif, fun, user_data, cl);\n+}\n+\n #endif /* FFI_CLOSURES */\n #endif /* !FFI_NATIVE_RAW_API */\n #endif /* !FFI_NO_RAW_API */"}, {"sha": "e5446807c09ec930553bddbcb36dc0fa07a1b32f", "filename": "libffi/src/mips/ffi.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fmips%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fmips%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fmips%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1996 Red Hat, Inc.\n+   ffi.c - Copyright (c) 1996, 2007 Red Hat, Inc.\n    \n    MIPS Foreign Function Interface \n \n@@ -497,14 +497,15 @@ extern void ffi_closure_O32(void);\n #endif /* FFI_MIPS_O32 */\n \n ffi_status\n-ffi_prep_closure (ffi_closure *closure,\n-\t\t  ffi_cif *cif,\n-\t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure *closure,\n+\t\t      ffi_cif *cif,\n+\t\t      void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n   unsigned int fn;\n-  unsigned int ctx = (unsigned int) closure;\n+  unsigned int ctx = (unsigned int) codeloc;\n \n #if defined(FFI_MIPS_O32)\n   FFI_ASSERT(cif->abi == FFI_O32 || cif->abi == FFI_O32_SOFT_FLOAT);\n@@ -525,7 +526,7 @@ ffi_prep_closure (ffi_closure *closure,\n   closure->user_data = user_data;\n \n   /* XXX this is available on Linux, but anything else? */\n-  cacheflush (tramp, FFI_TRAMPOLINE_SIZE, ICACHE);\n+  cacheflush (codeloc, FFI_TRAMPOLINE_SIZE, ICACHE);\n \n   return FFI_OK;\n }"}, {"sha": "8f1789bace0e43467f49e1fe6f3988a10052f241", "filename": "libffi/src/pa/ffi.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fpa%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fpa%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpa%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -613,10 +613,11 @@ ffi_status ffi_closure_inner_pa32(ffi_closure *closure, UINT32 *stack)\n extern void ffi_closure_pa32(void);\n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   UINT32 *tramp = (UINT32 *)(closure->tramp);\n #ifdef PA_HPUX"}, {"sha": "8c30c64fd750662f306fe127465953e15d936a65", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n    ffi.c - Copyright (c) 1998 Geoffrey Keating\n+   Copyright (C) 2007 Free Software Foundation, Inc\n \n    PowerPC Foreign Function Interface\n \n@@ -834,35 +835,35 @@ ffi_call(ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n #define MIN_CACHE_LINE_SIZE 8\n \n static void\n-flush_icache (char *addr1, int size)\n+flush_icache (char *wraddr, char *xaddr, int size)\n {\n   int i;\n-  char * addr;\n   for (i = 0; i < size; i += MIN_CACHE_LINE_SIZE)\n     {\n       addr = addr1 + i;\n-      __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\"\n-\t\t\t: : \"r\" (addr) : \"memory\");\n+      __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%1;\"\n+\t\t\t: : \"r\" (xaddr + i), \"r\" (wraddr + i) : \"memory\");\n     }\n-  addr = addr1 + size - 1;\n-  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%0;\" \"sync;\" \"isync;\"\n-\t\t    : : \"r\"(addr) : \"memory\");\n+  __asm__ volatile (\"icbi 0,%0;\" \"dcbf 0,%1;\" \"sync;\" \"isync;\"\n+\t\t    : : \"r\"(xaddr + size - 1), \"r\"(wraddr + size - 1)\n+\t\t    : \"memory\");\n }\n #endif\n \n ffi_status\n-ffi_prep_closure (ffi_closure *closure,\n-\t\t  ffi_cif *cif,\n-\t\t  void (*fun) (ffi_cif *, void *, void **, void *),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure *closure,\n+\t\t      ffi_cif *cif,\n+\t\t      void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n #ifdef POWERPC64\n   void **tramp = (void **) &closure->tramp[0];\n \n   FFI_ASSERT (cif->abi == FFI_LINUX64);\n   /* Copy function address and TOC from ffi_closure_LINUX64.  */\n   memcpy (tramp, (char *) ffi_closure_LINUX64, 16);\n-  tramp[2] = (void *) closure;\n+  tramp[2] = (void *) codeloc;\n #else\n   unsigned int *tramp;\n \n@@ -878,10 +879,10 @@ ffi_prep_closure (ffi_closure *closure,\n   tramp[8] = 0x7c0903a6;  /*   mtctr   r0 */\n   tramp[9] = 0x4e800420;  /*   bctr */\n   *(void **) &tramp[2] = (void *) ffi_closure_SYSV; /* function */\n-  *(void **) &tramp[3] = (void *) closure;          /* context */\n+  *(void **) &tramp[3] = (void *) codeloc;          /* context */\n \n   /* Flush the icache.  */\n-  flush_icache (&closure->tramp[0],FFI_TRAMPOLINE_SIZE);\n+  flush_icache (tramp, codeloc, FFI_TRAMPOLINE_SIZE);\n #endif\n \n   closure->cif = cif;"}, {"sha": "6d1b73e7f758136afcda31df2b53730aee38dd89", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -3,7 +3,7 @@\n \n    Copyright (C) 1998 Geoffrey Keating\n    Copyright (C) 2001 John Hornkvist\n-   Copyright (C) 2002, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2006, 2007 Free Software Foundation, Inc.\n \n    FFI support for Darwin and AIX.\n    \n@@ -528,10 +528,11 @@ SP current -->    +---------------------------------------+ 176 <- parent frame\n \n */\n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   unsigned int *tramp;\n   struct ffi_aix_trampoline_struct *tramp_aix;\n@@ -553,14 +554,14 @@ ffi_prep_closure (ffi_closure* closure,\n       tramp[8] = 0x816b0004;  /*   lwz     r11,4(r11) static chain  */\n       tramp[9] = 0x4e800420;  /*   bctr  */\n       tramp[2] = (unsigned long) ffi_closure_ASM; /* function  */\n-      tramp[3] = (unsigned long) closure; /* context  */\n+      tramp[3] = (unsigned long) codeloc; /* context  */\n \n       closure->cif = cif;\n       closure->fun = fun;\n       closure->user_data = user_data;\n \n       /* Flush the icache. Only necessary on Darwin.  */\n-      flush_range(&closure->tramp[0],FFI_TRAMPOLINE_SIZE);\n+      flush_range(codeloc, FFI_TRAMPOLINE_SIZE);\n \n       break;\n \n@@ -573,7 +574,7 @@ ffi_prep_closure (ffi_closure* closure,\n \n       tramp_aix->code_pointer = fd->code_pointer;\n       tramp_aix->toc = fd->toc;\n-      tramp_aix->static_chain = closure;\n+      tramp_aix->static_chain = codeloc;\n       closure->cif = cif;\n       closure->fun = fun;\n       closure->user_data = user_data;"}, {"sha": "b6bc52a39999c26cbbc6498dc9bffabce324debe", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   prep_cif.c - Copyright (c) 1996, 1998  Red Hat, Inc.\n+   prep_cif.c - Copyright (c) 1996, 1998, 2007  Red Hat, Inc.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -158,3 +158,16 @@ ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi, unsigned int nargs,\n   return ffi_prep_cif_machdep(cif);\n }\n #endif /* not __CRIS__ */\n+\n+#if FFI_CLOSURES\n+\n+ffi_status\n+ffi_prep_closure (ffi_closure* closure,\n+\t\t  ffi_cif* cif,\n+\t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t  void *user_data)\n+{\n+  return ffi_prep_closure_loc (closure, cif, fun, user_data, closure);\n+}\n+\n+#endif"}, {"sha": "b3ca511463e3f1654a78f35d00921397e2c9c577", "filename": "libffi/src/raw_api.c", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fraw_api.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fraw_api.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fraw_api.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -209,22 +209,20 @@ ffi_translate_args (ffi_cif *cif, void *rvalue,\n   (*cl->fun) (cif, rvalue, raw, cl->user_data);\n }\n \n-/* Again, here is the generic version of ffi_prep_raw_closure, which\n- * will install an intermediate \"hub\" for translation of arguments from\n- * the pointer-array format, to the raw format */\n-\n ffi_status\n-ffi_prep_raw_closure (ffi_raw_closure* cl,\n-\t\t      ffi_cif *cif,\n-\t\t      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n-\t\t      void *user_data)\n+ffi_prep_raw_closure_loc (ffi_raw_closure* cl,\n+\t\t\t  ffi_cif *cif,\n+\t\t\t  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t\t  void *user_data,\n+\t\t\t  void *codeloc)\n {\n   ffi_status status;\n \n-  status = ffi_prep_closure ((ffi_closure*) cl,\n-\t\t\t     cif,\n-\t\t\t     &ffi_translate_args,\n-\t\t\t     (void*)cl);\n+  status = ffi_prep_closure_loc ((ffi_closure*) cl,\n+\t\t\t\t cif,\n+\t\t\t\t &ffi_translate_args,\n+\t\t\t\t codeloc,\n+\t\t\t\t codeloc);\n   if (status == FFI_OK)\n     {\n       cl->fun       = fun;\n@@ -236,4 +234,22 @@ ffi_prep_raw_closure (ffi_raw_closure* cl,\n \n #endif /* FFI_CLOSURES */\n #endif /* !FFI_NATIVE_RAW_API */\n+\n+#if FFI_CLOSURES\n+\n+/* Again, here is the generic version of ffi_prep_raw_closure, which\n+ * will install an intermediate \"hub\" for translation of arguments from\n+ * the pointer-array format, to the raw format */\n+\n+ffi_status\n+ffi_prep_raw_closure (ffi_raw_closure* cl,\n+\t\t      ffi_cif *cif,\n+\t\t      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t      void *user_data)\n+{\n+  return ffi_prep_raw_closure_loc (cl, cif, fun, user_data, cl);\n+}\n+\n+#endif /* FFI_CLOSURES */\n+\n #endif /* !FFI_NO_RAW_API */"}, {"sha": "d17f790541959e6c8c54aee0f34053e9549447e9", "filename": "libffi/src/s390/ffi.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fs390%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fs390%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2000 Software AG\n+   ffi.c - Copyright (c) 2000, 2007 Software AG\n  \n    S390 Foreign Function Interface\n  \n@@ -736,17 +736,18 @@ ffi_closure_helper_SYSV (ffi_closure *closure,\n \n /*====================================================================*/\n /*                                                                    */\n-/* Name     - ffi_prep_closure.                                       */\n+/* Name     - ffi_prep_closure_loc.                                   */\n /*                                                                    */\n /* Function - Prepare a FFI closure.                                  */\n /*                                                                    */\n /*====================================================================*/\n  \n ffi_status\n-ffi_prep_closure (ffi_closure *closure,\n-                  ffi_cif *cif,\n-                  void (*fun) (ffi_cif *, void *, void **, void *),\n-                  void *user_data)\n+ffi_prep_closure_loc (ffi_closure *closure,\n+\t\t      ffi_cif *cif,\n+\t\t      void (*fun) (ffi_cif *, void *, void **, void *),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   FFI_ASSERT (cif->abi == FFI_SYSV);\n \n@@ -755,15 +756,15 @@ ffi_prep_closure (ffi_closure *closure,\n   *(short *)&closure->tramp [2] = 0x9801;   /* lm %r0,%r1,6(%r1) */\n   *(short *)&closure->tramp [4] = 0x1006;\n   *(short *)&closure->tramp [6] = 0x07f1;   /* br %r1 */\n-  *(long  *)&closure->tramp [8] = (long)closure;\n+  *(long  *)&closure->tramp [8] = (long)codeloc;\n   *(long  *)&closure->tramp[12] = (long)&ffi_closure_SYSV;\n #else\n   *(short *)&closure->tramp [0] = 0x0d10;   /* basr %r1,0 */\n   *(short *)&closure->tramp [2] = 0xeb01;   /* lmg %r0,%r1,14(%r1) */\n   *(short *)&closure->tramp [4] = 0x100e;\n   *(short *)&closure->tramp [6] = 0x0004;\n   *(short *)&closure->tramp [8] = 0x07f1;   /* br %r1 */\n-  *(long  *)&closure->tramp[16] = (long)closure;\n+  *(long  *)&closure->tramp[16] = (long)codeloc;\n   *(long  *)&closure->tramp[24] = (long)&ffi_closure_SYSV;\n #endif \n  "}, {"sha": "0cb8c72ccf6db040d61419ab5dfc2717778e787e", "filename": "libffi/src/sh/ffi.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fsh%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fsh%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2002, 2003, 2004, 2005, 2006 Kaz Kojima\n+   ffi.c - Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007 Kaz Kojima\n    \n    SuperH Foreign Function Interface \n \n@@ -452,10 +452,11 @@ extern void __ic_invalidate (void *line);\n #endif\n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   unsigned int *tramp;\n   unsigned short insn;\n@@ -475,7 +476,7 @@ ffi_prep_closure (ffi_closure* closure,\n   tramp[0] = 0xd102d301;\n   tramp[1] = 0x412b0000 | insn;\n #endif\n-  *(void **) &tramp[2] = (void *)closure;          /* ctx */\n+  *(void **) &tramp[2] = (void *)codeloc;          /* ctx */\n   *(void **) &tramp[3] = (void *)ffi_closure_SYSV; /* funaddr */\n \n   closure->cif = cif;\n@@ -484,7 +485,7 @@ ffi_prep_closure (ffi_closure* closure,\n \n #if defined(__SH4__)\n   /* Flush the icache.  */\n-  __ic_invalidate(&closure->tramp[0]);\n+  __ic_invalidate(codeloc);\n #endif\n \n   return FFI_OK;"}, {"sha": "9886883d327ede58f41c1ddbc0b122f108409eac", "filename": "libffi/src/sh64/ffi.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fsh64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fsh64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsh64%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2003, 2004, 2006 Kaz Kojima\n+   ffi.c - Copyright (c) 2003, 2004, 2006, 2007 Kaz Kojima\n    \n    SuperH SHmedia Foreign Function Interface \n \n@@ -283,10 +283,11 @@ extern void ffi_closure_SYSV (void);\n extern void __ic_invalidate (void *line);\n \n ffi_status\n-ffi_prep_closure (ffi_closure *closure,\n-\t\t  ffi_cif *cif,\n-\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure *closure,\n+\t\t      ffi_cif *cif,\n+\t\t      void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   unsigned int *tramp;\n \n@@ -310,16 +311,17 @@ ffi_prep_closure (ffi_closure *closure,\n   tramp[2] = 0xcc000010 | (((UINT32) ffi_closure_SYSV) >> 16) << 10;\n   tramp[3] = 0xc8000010 | (((UINT32) ffi_closure_SYSV) & 0xffff) << 10;\n   tramp[4] = 0x6bf10600;\n-  tramp[5] = 0xcc000010 | (((UINT32) closure) >> 16) << 10;\n-  tramp[6] = 0xc8000010 | (((UINT32) closure) & 0xffff) << 10;\n+  tramp[5] = 0xcc000010 | (((UINT32) codeloc) >> 16) << 10;\n+  tramp[6] = 0xc8000010 | (((UINT32) codeloc) & 0xffff) << 10;\n   tramp[7] = 0x4401fff0;\n \n   closure->cif = cif;\n   closure->fun = fun;\n   closure->user_data = user_data;\n \n   /* Flush the icache.  */\n-  asm volatile (\"ocbwb %0,0; synco; icbi %0,0; synci\" : : \"r\" (tramp));\n+  asm volatile (\"ocbwb %0,0; synco; icbi %1,0; synci\" : : \"r\" (tramp),\n+\t\t\"r\"(codeloc));\n \n   return FFI_OK;\n }"}, {"sha": "a10fe811dad71b396e4bef4ccb50a7e4cdd4e6c1", "filename": "libffi/src/sparc/ffi.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fsparc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fsparc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fsparc%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1996, 2003, 2004 Red Hat, Inc.\n+   ffi.c - Copyright (c) 1996, 2003, 2004, 2007 Red Hat, Inc.\n    \n    SPARC Foreign Function Interface \n \n@@ -425,10 +425,11 @@ extern void ffi_closure_v8(void);\n #endif\n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n   unsigned long fn;\n@@ -443,7 +444,7 @@ ffi_prep_closure (ffi_closure* closure,\n   tramp[3] = 0x01000000;\t/* nop\t\t\t*/\n   *((unsigned long *) &tramp[4]) = fn;\n #else\n-  unsigned long ctx = (unsigned long) closure;\n+  unsigned long ctx = (unsigned long) codeloc;\n   FFI_ASSERT (cif->abi == FFI_V8);\n   fn = (unsigned long) ffi_closure_v8;\n   tramp[0] = 0x03000000 | fn >> 10;\t/* sethi %hi(fn), %g1\t*/"}, {"sha": "b6d42a889d3bcea3a897e0f06a6bf79dd378207a", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 1996, 1998, 1999, 2001  Red Hat, Inc.\n+   ffi.c - Copyright (c) 1996, 1998, 1999, 2001, 2007  Red Hat, Inc.\n            Copyright (c) 2002  Ranjit Mathew\n            Copyright (c) 2002  Bo Thorsen\n            Copyright (c) 2002  Roger Sayle\n@@ -302,7 +302,7 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n ({ unsigned char *__tramp = (unsigned char*)(TRAMP); \\\n    unsigned int  __fun = (unsigned int)(FUN); \\\n    unsigned int  __ctx = (unsigned int)(CTX); \\\n-   unsigned int  __dis = __fun - ((unsigned int) __tramp + FFI_TRAMPOLINE_SIZE); \\\n+   unsigned int  __dis = __fun - (__ctx + FFI_TRAMPOLINE_SIZE); \\\n    *(unsigned char*) &__tramp[0] = 0xb8; \\\n    *(unsigned int*)  &__tramp[1] = __ctx; /* movl __ctx, %eax */ \\\n    *(unsigned char *)  &__tramp[5] = 0xe9; \\\n@@ -313,16 +313,17 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n /* the cif must already be prep'ed */\n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*,void*,void**,void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*,void*,void**,void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   FFI_ASSERT (cif->abi == FFI_SYSV);\n \n   FFI_INIT_TRAMPOLINE (&closure->tramp[0], \\\n \t\t       &ffi_closure_SYSV,  \\\n-\t\t       (void*)closure);\n+\t\t       codeloc);\n     \n   closure->cif  = cif;\n   closure->user_data = user_data;\n@@ -336,10 +337,11 @@ ffi_prep_closure (ffi_closure* closure,\n #if !FFI_NO_RAW_API\n \n ffi_status\n-ffi_prep_raw_closure (ffi_raw_closure* closure,\n-\t\t      ffi_cif* cif,\n-\t\t      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n-\t\t      void *user_data)\n+ffi_prep_raw_closure_loc (ffi_raw_closure* closure,\n+\t\t\t  ffi_cif* cif,\n+\t\t\t  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),\n+\t\t\t  void *user_data,\n+\t\t\t  void *codeloc)\n {\n   int i;\n \n@@ -358,7 +360,7 @@ ffi_prep_raw_closure (ffi_raw_closure* closure,\n   \n \n   FFI_INIT_TRAMPOLINE (&closure->tramp[0], &ffi_closure_raw_SYSV,\n-\t\t       (void*)closure);\n+\t\t       codeloc);\n     \n   closure->cif  = cif;\n   closure->user_data = user_data;"}, {"sha": "0bb18c6ac4431e25ff6fe4a1b94d5696b2b84c71", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   ffi.c - Copyright (c) 2002  Bo Thorsen <bo@suse.de>\n+   ffi.c - Copyright (c) 2002, 2007  Bo Thorsen <bo@suse.de>\n    \n    x86-64 Foreign Function Interface \n \n@@ -433,10 +433,11 @@ ffi_call (ffi_cif *cif, void (*fn)(), void *rvalue, void **avalue)\n extern void ffi_closure_unix64(void);\n \n ffi_status\n-ffi_prep_closure (ffi_closure* closure,\n-\t\t  ffi_cif* cif,\n-\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n-\t\t  void *user_data)\n+ffi_prep_closure_loc (ffi_closure* closure,\n+\t\t      ffi_cif* cif,\n+\t\t      void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t      void *user_data,\n+\t\t      void *codeloc)\n {\n   volatile unsigned short *tramp;\n \n@@ -445,7 +446,7 @@ ffi_prep_closure (ffi_closure* closure,\n   tramp[0] = 0xbb49;\t\t/* mov <code>, %r11\t*/\n   *(void * volatile *) &tramp[1] = ffi_closure_unix64;\n   tramp[5] = 0xba49;\t\t/* mov <data>, %r10\t*/\n-  *(void * volatile *) &tramp[6] = closure;\n+  *(void * volatile *) &tramp[6] = codeloc;\n \n   /* Set the carry bit iff the function uses any sse registers.\n      This is clc or stc, together with the first byte of the jmp.  */"}, {"sha": "23bf0a401f656fb61954f942a5946d8645e7683b", "filename": "libjava/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,3 +1,53 @@\n+2007-03-07  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* include/jvm.h (_Jv_ClosureListFinalizer): New.\n+\t(_Jv_Linker::create_error_method): Adjust.\n+\t* boehm.cc (_Jv_ClosureListFinalizer): New.\n+\t* nogc.cc (_Jv_ClosureListFinalizer): New.\n+\t* java/lang/Class.h (class _Jv_ClosureList): New.\n+\t(class java::lang::Class): Declare it as friend.\n+\t* java/lang/natClass.cc (_Jv_ClosureList::releaseClosures): New.\n+\t(_Jv_ClosureList::registerClousure): New.\n+\t* include/execution.h (_Jv_ExecutionEngine): Add get_closure_list.\n+\t(_Jv_CompiledEngine::do_get_closure_list): New.\n+\t(_Jv_CompiledEngine::_Jv_CompiledEngine): Use it.\n+\t(_Jv_IndirectCompiledClass): Add closures.\n+\t(_Jv_IndirectCompiledEngine::get_aux_info): New.\n+\t(_Jv_IndirectCompiledEngine::do_allocate_field_initializers): Use\n+\tit.\n+\t(_Jv_IndirectCompiledEngine::do_get_closure_list): New.\n+\t(_Jv_IndirectCompiledEngine::_Jv_IndirectCompiledEngine): Use it.\n+\t(_Jv_InterpreterEngine::do_get_closure_list): Declare.\n+\t(_Jv_InterpreterEngine::_Jv_InterpreterEngine): Use it.\n+\t* interpret.cc (FFI_PREP_RAW_CLOSURE): Use _loc variants.\n+\t(node_closure): Add closure list.\n+\t(_Jv_InterpMethod::ncode): Add jclass argument.  Use\n+\tffi_closure_alloc and the separate code pointer.  Register the\n+\tclosure for finalization.\n+\t(_Jv_JNIMethod::ncode): Likewise.\n+\t(_Jv_InterpreterEngine::do_create_ncode): Pass klass to ncode.\n+\t(_Jv_InterpreterEngine::do_get_closure_list): New.\n+\t* include/java-interp.h (_Jv_InterpMethod::ncode): Adjust.\n+\t(_Jv_InterpClass): Add closures field.\n+\t(_Jv_JNIMethod::ncode): Adjust.\n+\t* defineclass.cc (_Jv_ClassReader::handleCodeAttribute): Adjust.\n+\t(_Jv_ClassReader::handleMethodsEnd): Likewise.\n+\t* link.cc (struct method_closure): Add closure list.\n+\t(_Jv_Linker::create_error_method): Add jclass argument.  Use\n+\tffi_closure_alloc and the separate code pointer.  Register the\n+\tclosure for finalization.\n+\t(_Jv_Linker::link_symbol_table): Remove outdated comment about\n+\tsharing of otable and atable.  Adjust.\n+\t* java/lang/reflect/natVMProxy.cc (ncode_closure): Add closure\n+\tlist.\n+\t(ncode): Add jclass argument.  Use ffi_closure_alloc and the\n+\tseparate code pointer.  Register the closure for finalization.\n+\t(java::lang::reflect::VMProxy::generateProxyClass): Adjust.\n+\t* testsuite/libjava.jar/TestClosureGC.java: New.\n+\t* testsuite/libjava.jar/TestClosureGC.out: New.\n+\t* testsuite/libjava.jar/TestClosureGC.xfail: New.\n+\t* testsuite/libjava.jar/TestClosureGC.jar: New.\n+\n 2007-03-06  Kyle Galloway  <kgallowa@redhat.com>\n \n \t* classpath/gnu/classpath/jdwp/exception/AbsentInformationException.java: New file."}, {"sha": "66860dd50daaeab5ed71a43a21530f56836154a3", "filename": "libjava/boehm.cc", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,6 +1,6 @@\n // boehm.cc - interface between libjava and Boehm GC.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation\n \n    This file is part of libgcj.\n@@ -380,6 +380,29 @@ _Jv_AllocRawObj (jsize size)\n   return (void *) GC_MALLOC (size ? size : 1);\n }\n \n+typedef _Jv_ClosureList *closure_list_pointer;\n+\n+/* Release closures in a _Jv_ClosureList.  */\n+static void\n+finalize_closure_list (GC_PTR obj, GC_PTR)\n+{\n+  _Jv_ClosureList **clpp = (_Jv_ClosureList **)obj;\n+  _Jv_ClosureList::releaseClosures (clpp);\n+}\n+\n+/* Allocate a double-indirect pointer to a _Jv_ClosureList that will\n+   get garbage-collected after this double-indirect pointer becomes\n+   unreachable by any other objects, including finalizable ones.  */\n+_Jv_ClosureList **\n+_Jv_ClosureListFinalizer ()\n+{\n+  _Jv_ClosureList **clpp;\n+  clpp = (_Jv_ClosureList **)_Jv_AllocBytes (sizeof (*clpp));\n+  GC_REGISTER_FINALIZER_UNREACHABLE (clpp, finalize_closure_list,\n+\t\t\t\t     NULL, NULL, NULL);\n+  return clpp;\n+}\n+\n static void\n call_finalizer (GC_PTR obj, GC_PTR client_data)\n {"}, {"sha": "0f0da77d6ebb6a472f4970a11fa68ed83726dbc8", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,6 +1,7 @@\n // defineclass.cc - defining a class from .class format.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -1695,7 +1696,7 @@ void _Jv_ClassReader::handleCodeAttribute\n       // call a static method of an interpreted class from precompiled\n       // code without first resolving the class (that will happen\n       // during class initialization instead).\n-      method->self->ncode = method->ncode ();\n+      method->self->ncode = method->ncode (def);\n     }\n }\n \n@@ -1740,7 +1741,7 @@ void _Jv_ClassReader::handleMethodsEnd ()\n \t\t  // interpreted class from precompiled code without\n \t\t  // first resolving the class (that will happen\n \t\t  // during class initialization instead).\n-\t\t  method->ncode = m->ncode ();\n+\t\t  method->ncode = m->ncode (def);\n \t\t}\n \t    }\n \t}"}, {"sha": "eac6133c5b735294f81eafe5639ca597b5c2c4de", "filename": "libjava/include/execution.h", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Finclude%2Fexecution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Finclude%2Fexecution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fexecution.h?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,6 +1,6 @@\n // execution.h - Execution engines. -*- c++ -*-\n \n-/* Copyright (C) 2004, 2006  Free Software Foundation\n+/* Copyright (C) 2004, 2006, 2007  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -29,6 +29,7 @@ struct _Jv_ExecutionEngine\n   _Jv_ResolvedMethod *(*resolve_method) (_Jv_Method *, jclass,\n \t\t\t\t\t jboolean);\n   void (*post_miranda_hook) (jclass);\n+  _Jv_ClosureList **(*get_closure_list) (jclass);\n };\n \n // This handles gcj-compiled code except that compiled with\n@@ -77,6 +78,11 @@ struct _Jv_CompiledEngine : public _Jv_ExecutionEngine\n     // Not needed.\n   }\n \n+  static _Jv_ClosureList **do_get_closure_list (jclass)\n+  {\n+    return NULL;\n+  }\n+\n   _Jv_CompiledEngine ()\n   {\n     unregister = do_unregister;\n@@ -87,6 +93,7 @@ struct _Jv_CompiledEngine : public _Jv_ExecutionEngine\n     create_ncode = do_create_ncode;\n     resolve_method = do_resolve_method;\n     post_miranda_hook = do_post_miranda_hook;\n+    get_closure_list = do_get_closure_list;\n   }\n \n   // These operators make it so we don't have to link in libstdc++.\n@@ -105,6 +112,7 @@ class _Jv_IndirectCompiledClass\n {\n public:\n   void **field_initializers;\n+  _Jv_ClosureList **closures;\n };\n \n // This handles gcj-compiled code compiled with -findirect-classes.\n@@ -114,14 +122,32 @@ struct _Jv_IndirectCompiledEngine : public _Jv_CompiledEngine\n   {\n     allocate_static_fields = do_allocate_static_fields;\n     allocate_field_initializers = do_allocate_field_initializers;\n+    get_closure_list = do_get_closure_list;\n   }\n   \n+  static _Jv_IndirectCompiledClass *get_aux_info (jclass klass)\n+  {\n+    _Jv_IndirectCompiledClass *aux =\n+      (_Jv_IndirectCompiledClass*)klass->aux_info;\n+    if (!aux)\n+      {\n+\taux = (_Jv_IndirectCompiledClass*)\n+\t  _Jv_AllocRawObj (sizeof (_Jv_IndirectCompiledClass));\n+\tklass->aux_info = aux;\n+      }\n+\n+    return aux;\n+  }\n+\n   static void do_allocate_field_initializers (jclass klass)\n   {\n-    _Jv_IndirectCompiledClass *aux \n-      =  (_Jv_IndirectCompiledClass*)\n-        _Jv_AllocRawObj (sizeof (_Jv_IndirectCompiledClass));\n-    klass->aux_info = aux;\n+    _Jv_IndirectCompiledClass *aux = get_aux_info (klass);\n+    if (!aux)\n+      {\n+\taux = (_Jv_IndirectCompiledClass*)\n+\t  _Jv_AllocRawObj (sizeof (_Jv_IndirectCompiledClass));\n+\tklass->aux_info = aux;\n+      }\n \n     aux->field_initializers = (void **)_Jv_Malloc (klass->field_count \n \t\t\t\t\t\t   * sizeof (void*));    \n@@ -172,6 +198,16 @@ struct _Jv_IndirectCompiledEngine : public _Jv_CompiledEngine\n       } \n     _Jv_Free (aux->field_initializers);\n   }\n+\n+  static _Jv_ClosureList **do_get_closure_list (jclass klass)\n+  {\n+    _Jv_IndirectCompiledClass *aux = get_aux_info (klass);\n+\n+    if (!aux->closures)\n+      aux->closures = _Jv_ClosureListFinalizer ();\n+\n+    return aux->closures;\n+  }\n };\n \n \n@@ -203,6 +239,8 @@ class _Jv_InterpreterEngine : public _Jv_ExecutionEngine\n \n   static void do_post_miranda_hook (jclass);\n \n+  static _Jv_ClosureList **do_get_closure_list (jclass klass);\n+\n   _Jv_InterpreterEngine ()\n   {\n     unregister = do_unregister;\n@@ -213,6 +251,7 @@ class _Jv_InterpreterEngine : public _Jv_ExecutionEngine\n     create_ncode = do_create_ncode;\n     resolve_method = do_resolve_method;\n     post_miranda_hook = do_post_miranda_hook;\n+    get_closure_list = do_get_closure_list;\n   }\n \n   // These operators make it so we don't have to link in libstdc++."}, {"sha": "c294cc81896517d88225e26f6613bd51b1f37ab0", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -202,7 +202,7 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   }\n \n   // return the method's invocation pointer (a stub).\n-  void *ncode ();\n+  void *ncode (jclass);\n   void compile (const void * const *);\n \n   static void run_normal (ffi_cif*, void*, ffi_raw*, void*);\n@@ -293,6 +293,7 @@ class _Jv_InterpClass\n   _Jv_MethodBase **interpreted_methods;\n   _Jv_ushort     *field_initializers;\n   jstring source_file_name;\n+  _Jv_ClosureList **closures;\n \n   friend class _Jv_ClassReader;\n   friend class _Jv_InterpMethod;\n@@ -341,7 +342,7 @@ class _Jv_JNIMethod : public _Jv_MethodBase\n   // This function is used when making a JNI call from the interpreter.\n   static void call (ffi_cif *, void *, ffi_raw *, void *);\n \n-  void *ncode ();\n+  void *ncode (jclass);\n \n   friend class _Jv_ClassReader;\n   friend class _Jv_InterpreterEngine;"}, {"sha": "02974e8c7ea08ee5841b92793c6363b9c69a53af", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -288,7 +288,7 @@ class _Jv_Linker\n  \t\t\t\t\t\t    _Jv_Utf8Const *method_signature,\n \t\t\t\t\t\t    jclass *found_class,\n \t\t\t\t\t\t    bool check_perms = true);\n-  static void *create_error_method(_Jv_Utf8Const *);\n+  static void *create_error_method(_Jv_Utf8Const *, jclass);\n \n   /* The least significant bit of the signature pointer in a symbol\n      table is set to 1 by the compiler if the reference is \"special\",\n@@ -341,6 +341,10 @@ void *_Jv_AllocBytes (jsize size) __attribute__((__malloc__));\n /* Allocate space for a new non-Java object, which does not have the usual \n    Java object header but may contain pointers to other GC'ed objects.  */\n void *_Jv_AllocRawObj (jsize size) __attribute__((__malloc__));\n+/* Allocate a double-indirect pointer to a _Jv_ClosureList such that\n+   the _Jv_ClosureList gets automatically finalized when it is no\n+   longer reachable, not even by other finalizable objects.  */\n+_Jv_ClosureList **_Jv_ClosureListFinalizer (void) __attribute__((__malloc__));\n /* Explicitly throw an out-of-memory exception.\t*/\n void _Jv_ThrowNoMemory() __attribute__((__noreturn__));\n /* Allocate an object with a single pointer.  The first word is reserved"}, {"sha": "ac23b060240ef020c950743eaecfeea6a53ee1f7", "filename": "libjava/interpret.cc", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1255,10 +1255,10 @@ _Jv_init_cif (_Jv_Utf8Const* signature,\n }\n \n #if FFI_NATIVE_RAW_API\n-#   define FFI_PREP_RAW_CLOSURE ffi_prep_raw_closure\n+#   define FFI_PREP_RAW_CLOSURE ffi_prep_raw_closure_loc\n #   define FFI_RAW_SIZE ffi_raw_size\n #else\n-#   define FFI_PREP_RAW_CLOSURE ffi_prep_java_raw_closure\n+#   define FFI_PREP_RAW_CLOSURE ffi_prep_java_raw_closure_loc\n #   define FFI_RAW_SIZE ffi_java_raw_size\n #endif\n \n@@ -1269,14 +1269,15 @@ _Jv_init_cif (_Jv_Utf8Const* signature,\n \n typedef struct {\n   ffi_raw_closure  closure;\n+  _Jv_ClosureList list;\n   ffi_cif   cif;\n   ffi_type *arg_types[0];\n } ncode_closure;\n \n typedef void (*ffi_closure_fun) (ffi_cif*,void*,ffi_raw*,void*);\n \n void *\n-_Jv_InterpMethod::ncode ()\n+_Jv_InterpMethod::ncode (jclass klass)\n {\n   using namespace java::lang::reflect;\n \n@@ -1286,9 +1287,12 @@ _Jv_InterpMethod::ncode ()\n   jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n   int arg_count = _Jv_count_arguments (self->signature, staticp);\n \n+  void *code;\n   ncode_closure *closure =\n-    (ncode_closure*)_Jv_AllocBytes (sizeof (ncode_closure)\n-\t\t\t\t\t+ arg_count * sizeof (ffi_type*));\n+    (ncode_closure*)ffi_closure_alloc (sizeof (ncode_closure)\n+\t\t\t\t       + arg_count * sizeof (ffi_type*),\n+\t\t\t\t       &code);\n+  closure->list.registerClosure (klass, closure);\n \n   _Jv_init_cif (self->signature,\n \t\targ_count,\n@@ -1341,9 +1345,11 @@ _Jv_InterpMethod::ncode ()\n   FFI_PREP_RAW_CLOSURE (&closure->closure,\n \t\t        &closure->cif, \n \t\t        fun,\n-\t\t        (void*)this);\n+\t\t        (void*)this,\n+\t\t\tcode);\n+\n+  self->ncode = code;\n \n-  self->ncode = (void*)closure;\n   return self->ncode;\n }\n \n@@ -1540,7 +1546,7 @@ _Jv_InterpMethod::set_insn (jlong index, pc_t insn)\n }\n \n void *\n-_Jv_JNIMethod::ncode ()\n+_Jv_JNIMethod::ncode (jclass klass)\n {\n   using namespace java::lang::reflect;\n \n@@ -1550,9 +1556,12 @@ _Jv_JNIMethod::ncode ()\n   jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n   int arg_count = _Jv_count_arguments (self->signature, staticp);\n \n+  void *code;\n   ncode_closure *closure =\n-    (ncode_closure*)_Jv_AllocBytes (sizeof (ncode_closure)\n-\t\t\t\t    + arg_count * sizeof (ffi_type*));\n+    (ncode_closure*)ffi_closure_alloc (sizeof (ncode_closure)\n+\t\t\t\t       + arg_count * sizeof (ffi_type*),\n+\t\t\t\t       &code);\n+  closure->list.registerClosure (klass, closure);\n \n   ffi_type *rtype;\n   _Jv_init_cif (self->signature,\n@@ -1594,9 +1603,10 @@ _Jv_JNIMethod::ncode ()\n   FFI_PREP_RAW_CLOSURE (&closure->closure,\n \t\t\t&closure->cif, \n \t\t\tfun,\n-\t\t\t(void*) this);\n+\t\t\t(void*) this,\n+\t\t\tcode);\n \n-  self->ncode = (void *) closure;\n+  self->ncode = code;\n   return self->ncode;\n }\n \n@@ -1657,16 +1667,27 @@ _Jv_InterpreterEngine::do_create_ncode (jclass klass)\n \t  // cases.  Well, we can't, because we don't allocate these\n \t  // objects using `new', and thus they don't get a vtable.\n \t  _Jv_JNIMethod *jnim = reinterpret_cast<_Jv_JNIMethod *> (imeth);\n-\t  klass->methods[i].ncode = jnim->ncode ();\n+\t  klass->methods[i].ncode = jnim->ncode (klass);\n \t}\n       else if (imeth != 0)\t\t// it could be abstract\n \t{\n \t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (imeth);\n-\t  klass->methods[i].ncode = im->ncode ();\n+\t  klass->methods[i].ncode = im->ncode (klass);\n \t}\n     }\n }\n \n+_Jv_ClosureList **\n+_Jv_InterpreterEngine::do_get_closure_list (jclass klass)\n+{\n+  _Jv_InterpClass *iclass = (_Jv_InterpClass *) klass->aux_info;\n+\n+  if (!iclass->closures)\n+    iclass->closures = _Jv_ClosureListFinalizer ();\n+\n+  return iclass->closures;\n+}\n+\n void\n _Jv_InterpreterEngine::do_allocate_static_fields (jclass klass,\n \t\t\t\t\t\t  int pointer_size,"}, {"sha": "80c410009ea08f7c2374731efb6d192c54353f5a", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -105,6 +105,15 @@ class _Jv_InterpClass;\n class _Jv_InterpMethod;\n #endif\n \n+class _Jv_ClosureList\n+{\n+  _Jv_ClosureList *next;\n+  void *ptr;\n+public:\n+  void registerClosure (jclass klass, void *ptr);\n+  static void releaseClosures (_Jv_ClosureList **closures);\n+};\n+\n struct _Jv_Constants\n {\n   jint size;\n@@ -632,6 +641,7 @@ class java::lang::Class : public java::lang::Object\n   friend class ::_Jv_CompiledEngine;\n   friend class ::_Jv_IndirectCompiledEngine;\n   friend class ::_Jv_InterpreterEngine;\n+  friend class ::_Jv_ClosureList;\n \n   friend void ::_Jv_sharedlib_register_hook (jclass klass);\n "}, {"sha": "79fa59989d34b29427a4b336de9c0046eae1216e", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -670,6 +670,28 @@ java::lang::Class::finalize (void)\n   engine->unregister(this);\n }\n \n+void\n+_Jv_ClosureList::releaseClosures (_Jv_ClosureList **closures)\n+{\n+  if (!closures)\n+    return;\n+\n+  while (_Jv_ClosureList *current = *closures)\n+    {\n+      *closures = current->next;\n+      ffi_closure_free (current->ptr);\n+    }\n+}\n+\n+void\n+_Jv_ClosureList::registerClosure (jclass klass, void *ptr)\n+{\n+  _Jv_ClosureList **closures = klass->engine->get_closure_list (klass);\n+  this->ptr = ptr;\n+  this->next = *closures;\n+  *closures = this;\n+}\n+\n // This implements the initialization process for a class.  From Spec\n // section 12.4.2.\n void"}, {"sha": "5704049909a4ff7b36909b60131f3dcacb6aac4a", "filename": "libjava/java/lang/reflect/natVMProxy.cc", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fjava%2Flang%2Freflect%2FnatVMProxy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fjava%2Flang%2Freflect%2FnatVMProxy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatVMProxy.cc?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,6 +1,6 @@\n // natVMProxy.cc -- Implementation of VMProxy methods.\n \n-/* Copyright (C) 2006\n+/* Copyright (C) 2006, 2007\n    Free Software Foundation\n \n    This file is part of libgcj.\n@@ -66,7 +66,7 @@ using namespace java::lang::reflect;\n using namespace java::lang;\n \n typedef void (*closure_fun) (ffi_cif*, void*, void**, void*);\n-static void *ncode (_Jv_Method *self, closure_fun fun);\n+static void *ncode (jclass klass, _Jv_Method *self, closure_fun fun);\n static void run_proxy (ffi_cif*, void*, void**, void*);\n \n typedef jobject invoke_t (jobject, Proxy *, Method *, JArray< jobject > *);\n@@ -165,7 +165,7 @@ java::lang::reflect::VMProxy::generateProxyClass\n       // the interfaces of which it is a proxy will also be reachable,\n       // so this is safe.\n       method = imethod;\n-      method.ncode = ncode (&method, run_proxy);\n+      method.ncode = ncode (klass, &method, run_proxy);\n       method.accflags &= ~Modifier::ABSTRACT;\n     }\n \n@@ -289,6 +289,7 @@ unbox (jobject o, jclass klass, void *rvalue, FFI_TYPE type)\n \n typedef struct {\n   ffi_closure  closure;\n+  _Jv_ClosureList list;\n   ffi_cif   cif;\n   _Jv_Method *self;\n   ffi_type *arg_types[0];\n@@ -366,16 +367,19 @@ run_proxy (ffi_cif *cif,\n // the address of its closure.\n \n static void *\n-ncode (_Jv_Method *self, closure_fun fun)\n+ncode (jclass klass, _Jv_Method *self, closure_fun fun)\n {\n   using namespace java::lang::reflect;\n \n   jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n   int arg_count = _Jv_count_arguments (self->signature, staticp);\n \n+  void *code;\n   ncode_closure *closure =\n-    (ncode_closure*)_Jv_AllocBytes (sizeof (ncode_closure)\n-\t\t\t\t    + arg_count * sizeof (ffi_type*));\n+    (ncode_closure*)ffi_closure_alloc (sizeof (ncode_closure)\n+\t\t\t\t       + arg_count * sizeof (ffi_type*),\n+\t\t\t\t       &code);\n+  closure->list.registerClosure (klass, closure);\n \n   _Jv_init_cif (self->signature,\n \t\targ_count,\n@@ -387,11 +391,12 @@ ncode (_Jv_Method *self, closure_fun fun)\n \n   JvAssert ((self->accflags & Modifier::NATIVE) == 0);\n \n-  ffi_prep_closure (&closure->closure,\n-\t\t    &closure->cif, \n-\t\t    fun,\n-\t\t    (void*)closure);\n+  ffi_prep_closure_loc (&closure->closure,\n+\t\t\t&closure->cif,\n+\t\t\tfun,\n+\t\t\tcode,\n+\t\t\tcode);\n \n-  self->ncode = (void*)closure;\n+  self->ncode = code;\n   return self->ncode;\n }"}, {"sha": "4ea548ec905881ff96594452e9ae0fb50512309a", "filename": "libjava/link.cc", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1022,15 +1022,17 @@ struct method_closure\n   // be the same as the address of the overall structure.  This is due\n   // to disabling interior pointers in the GC.\n   ffi_closure closure;\n+  _Jv_ClosureList list;\n   ffi_cif cif;\n   ffi_type *arg_types[1];\n };\n \n void *\n-_Jv_Linker::create_error_method (_Jv_Utf8Const *class_name)\n+_Jv_Linker::create_error_method (_Jv_Utf8Const *class_name, jclass klass)\n {\n+  void *code;\n   method_closure *closure\n-    = (method_closure *) _Jv_AllocBytes(sizeof (method_closure));\n+    = (method_closure *)ffi_closure_alloc (sizeof (method_closure), &code);\n \n   closure->arg_types[0] = &ffi_type_void;\n \n@@ -1042,13 +1044,18 @@ _Jv_Linker::create_error_method (_Jv_Utf8Const *class_name)\n                        1,\n                        &ffi_type_void,\n \t\t       closure->arg_types) == FFI_OK\n-      && ffi_prep_closure (&closure->closure,\n-                           &closure->cif,\n-\t\t\t   _Jv_ThrowNoClassDefFoundErrorTrampoline,\n-\t\t\t   class_name) == FFI_OK)\n-    return &closure->closure;\n+      && ffi_prep_closure_loc (&closure->closure,\n+\t\t\t       &closure->cif,\n+\t\t\t       _Jv_ThrowNoClassDefFoundErrorTrampoline,\n+\t\t\t       class_name,\n+\t\t\t       code) == FFI_OK)\n+    {\n+      closure->list.registerClosure (klass, closure);\n+      return code;\n+    }\n   else\n     {\n+      ffi_closure_free (closure);\n       java::lang::StringBuffer *buffer = new java::lang::StringBuffer();\n       buffer->append(JvNewStringLatin1(\"Error setting up FFI closure\"\n \t\t\t\t       \" for static method of\"\n@@ -1059,7 +1066,7 @@ _Jv_Linker::create_error_method (_Jv_Utf8Const *class_name)\n }\n #else\n void *\n-_Jv_Linker::create_error_method (_Jv_Utf8Const *)\n+_Jv_Linker::create_error_method (_Jv_Utf8Const *, jclass)\n {\n   // Codepath for platforms which do not support (or want) libffi.\n   // You have to accept that it is impossible to provide the name\n@@ -1090,8 +1097,6 @@ static bool debug_link = false;\n // at the corresponding position in the virtual method offset table\n // (klass->otable). \n \n-// The same otable and atable may be shared by many classes.\n-\n // This must be called while holding the class lock.\n \n void\n@@ -1242,13 +1247,15 @@ _Jv_Linker::link_symbol_table (jclass klass)\n       // NullPointerException\n       klass->atable->addresses[index] = NULL;\n \n+      bool use_error_method = false;\n+\n       // If the target class is missing we prepare a function call\n       // that throws a NoClassDefFoundError and store the address of\n       // that newly prepared method in the atable. The user can run\n       // code in classes where the missing class is part of the\n       // execution environment as long as it is never referenced.\n       if (target_class == NULL)\n-        klass->atable->addresses[index] = create_error_method(sym.class_name);\n+\tuse_error_method = true;\n       // We're looking for a static field or a static method, and we\n       // can tell which is needed by looking at the signature.\n       else if (signature->first() == '(' && signature->len() >= 2)\n@@ -1296,12 +1303,16 @@ _Jv_Linker::link_symbol_table (jclass klass)\n \t\t}\n \t    }\n \t  else\n+\t    use_error_method = true;\n+\n+\t  if (use_error_method)\n \t    klass->atable->addresses[index]\n-              = create_error_method(sym.class_name);\n+\t      = create_error_method(sym.class_name, klass);\n \n \t  continue;\n \t}\n \n+\n       // Try fields only if the target class exists.\n       if (target_class != NULL)\n       {"}, {"sha": "126e4de5c2b559b5178150ba39f3bf5aa07f928f", "filename": "libjava/nogc.cc", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fnogc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Fnogc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fnogc.cc?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -1,6 +1,7 @@\n // nogc.cc - Implement null garbage collector.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2006  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2006, 2007\n+   Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -71,6 +72,14 @@ _Jv_AllocRawObj (jsize size)\n   return calloc (size, 1);\n }\n \n+_Jv_ClosureList **\n+_Jv_ClosureListFinalizer ()\n+{\n+  _Jv_ClosureList **clpp;\n+  clpp = (_Jv_ClosureList **)_Jv_AllocBytes (sizeof (*clpp));\n+  return clpp;\n+}\n+\n void\n _Jv_RegisterFinalizer (void *, _Jv_FinalizerFunc *)\n {"}, {"sha": "60d948ad58be8eb0cefe8d75cb0562f5b6e28516", "filename": "libjava/testsuite/libjava.jar/TestClosureGC.jar", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.jar", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.jar", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.jar?ref=18fa3240db054b98ef9464cbcedb186d819217fd"}, {"sha": "69a325a9994987d835cf48d941a23a1352201b7f", "filename": "libjava/testsuite/libjava.jar/TestClosureGC.java", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.java?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -0,0 +1,116 @@\n+/* Verify that libffi closures aren't deallocated too early.\n+\n+   Copyright (C) 2007 Free Software Foundation, Inc\n+   Contributed by Alexandre Oliva <aoliva@redhat.com>\n+\n+   If libffi closures are released too early, we lose.\n+ */\n+\n+import java.util.HashSet;\n+\n+public class TestClosureGC {\n+    public static String objId (Object obj) {\n+\treturn obj + \"/\"\n+\t    + Integer.toHexString(obj.getClass().getClassLoader().hashCode());\n+    }\n+    public static class cld extends java.net.URLClassLoader {\n+\tstatic final Object obj = new cl0();\n+\tpublic cld () throws Exception {\n+\t    super(new java.net.URL[] { });\n+\t    /* System.out.println (objId (this) + \" created\"); */\n+\t}\n+\tpublic void finalize () {\n+\t    /* System.out.println (objId (this) + \" finalized\"); */\n+\t}\n+\tpublic String toString () {\n+\t    return this.getClass().getName() + \"@\"\n+\t\t+ Integer.toHexString (hashCode ());\n+\t}\n+\tpublic Class loadClass (String name) throws ClassNotFoundException {\n+\t    try {\n+\t\tjava.io.InputStream IS = getSystemResourceAsStream\n+\t\t    (name + \".class\");\n+\t\tint maxsz = 1024, readsz = 0;\n+\t\tbyte buf[] = new byte[maxsz];\n+\t\tfor(;;) {\n+\t\t    int readnow = IS.read (buf, readsz, maxsz - readsz);\n+\t\t    if (readnow <= 0)\n+\t\t\tbreak;\n+\t\t    readsz += readnow;\n+\t\t    if (readsz == maxsz) {\n+\t\t\tbyte newbuf[] = new byte[maxsz *= 2];\n+\t\t\tSystem.arraycopy (buf, 0, newbuf, 0, readsz);\n+\t\t\tbuf = newbuf;\n+\t\t    }\n+\t\t}\n+\t\treturn defineClass (name, buf, 0, readsz);\n+\t    } catch (Exception e) {\n+\t\treturn super.loadClass (name);\n+\t    }\n+\t}\n+    }\n+    public static class cl0 {\n+\tpublic cl0 () {\n+\t    /* System.out.println (objId (this) + \" created\"); */\n+\t}\n+\tpublic void finalize () {\n+\t    /* System.out.println (objId (this) + \" finalized\"); */\n+\t}\n+    }\n+    public static class cl1 {\n+\tfinal HashSet hs;\n+\tstatic final Object obj = new cl0();\n+\tpublic cl1 (final HashSet hs) {\n+\t    this.hs = hs;\n+\t    /* System.out.println (objId (this) + \" created\"); */\n+\t}\n+\tpublic void finalize () {\n+\t    /* System.out.println (objId (this) + \" finalized\"); */\n+\t}\n+    }\n+    public static class cl2 {\n+\tfinal HashSet hs;\n+\tstatic final Object obj = new cl0();\n+\tpublic cl2 (final HashSet hs) {\n+\t    this.hs = hs;\n+\t    /* System.out.println (objId (this) + \" created\"); */\n+\t}\n+\tpublic void finalize () {\n+\t    /* System.out.println (objId (this) + \" finalized\"); */\n+\t    hs.add(this);\n+\t    hs.add(new cl0());\n+\t}\n+    }\n+    static final HashSet hs = new HashSet();\n+    static final Object obj = new cl0();\n+    public static void main(String[] argv) throws Exception {\n+\t{\n+\t    Class[] hscs = { HashSet.class };\n+\t    Object[] hsos = { hs };\n+\t    new cld().loadClass (\"TestClosureGC$cl1\").\n+\t\tgetConstructor (hscs).newInstance (hsos);\n+\t    new cld().loadClass (\"TestClosureGC$cl2\").\n+\t\tgetConstructor (hscs).newInstance (hsos);\n+\t    new cld().loadClass (\"TestClosureGC$cl1\").\n+\t\tgetConstructor (hscs).newInstance (hsos);\n+\t    new cld().loadClass (\"TestClosureGC$cl1\").\n+\t\tgetConstructor (hscs).newInstance (hsos);\n+\t}\n+\tfor (int i = 1; i <= 5; i++) {\n+\t    /* System.out.println (\"Will run GC and finalization \" + i); */\n+\t    System.gc ();\n+\t    Thread.sleep (100);\n+\t    System.runFinalization ();\n+\t    Thread.sleep (100);\n+\t    if (hs.isEmpty ())\n+\t\tcontinue;\n+\t    java.util.Iterator it = hs.iterator ();\n+\t    while (it.hasNext ()) {\n+\t\tObject obj = it.next();\n+\t\t/* System.out.println (objId (obj) + \" in ht, removing\"); */\n+\t\tit.remove ();\n+\t    }\n+\t}\n+\tSystem.out.println (\"ok\");\n+    }\n+}"}, {"sha": "9766475a4185a151dc9d56d614ffb9aaea3bfd42", "filename": "libjava/testsuite/libjava.jar/TestClosureGC.out", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.out?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -0,0 +1 @@\n+ok"}, {"sha": "963b35a7c703e0fe6bece30be9676803160f0ea9", "filename": "libjava/testsuite/libjava.jar/TestClosureGC.xfail", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.xfail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18fa3240db054b98ef9464cbcedb186d819217fd/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.xfail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jar%2FTestClosureGC.xfail?ref=18fa3240db054b98ef9464cbcedb186d819217fd", "patch": "@@ -0,0 +1 @@\n+main=TestClosureGC"}]}