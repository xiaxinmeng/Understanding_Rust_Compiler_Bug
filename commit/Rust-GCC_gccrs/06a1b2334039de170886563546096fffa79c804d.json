{"sha": "06a1b2334039de170886563546096fffa79c804d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZhMWIyMzM0MDM5ZGUxNzA4ODY1NjM1NDYwOTZmZmZhNzljODA0ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-07-04T18:51:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-07-04T18:51:02Z"}, "message": "re PR debug/81278 (-fcompare-debug failure (length))\n\n\tPR debug/81278\n\t* tree-vrp.c (compare_assert_loc): Turn into a function template\n\twith stable template parameter.  Only test if a->e is NULL,\n\t!a->e == !b->e has been verified already.  Use e == NULL or\n\te != NULL instead of e or ! e tests.  If stable is true, don't use\n\titerative_hash_expr, on the other side allow a or b or both NULL\n\tand sort the NULLs last.\n\t(process_assert_insertions): Sort using compare_assert_loc<false>\n\tinstead of compare_assert_loc, later sort using\n\tcompare_assert_loc<true> before calling process_assert_insertions_for\n\tin a loop.  Use break instead of continue once seen NULL pointer.\n\nFrom-SVN: r249975", "tree": {"sha": "0174d2500cde815a5d8c154caefe473443bc47e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0174d2500cde815a5d8c154caefe473443bc47e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06a1b2334039de170886563546096fffa79c804d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a1b2334039de170886563546096fffa79c804d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06a1b2334039de170886563546096fffa79c804d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a1b2334039de170886563546096fffa79c804d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "242ae26aefeddb4f42001672bcca0a33ae71afaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/242ae26aefeddb4f42001672bcca0a33ae71afaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/242ae26aefeddb4f42001672bcca0a33ae71afaa"}], "stats": {"total": 68, "additions": 59, "deletions": 9}, "files": [{"sha": "d57f764b42de35dd3576ee91088ca4933d518416", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a1b2334039de170886563546096fffa79c804d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a1b2334039de170886563546096fffa79c804d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06a1b2334039de170886563546096fffa79c804d", "patch": "@@ -1,3 +1,17 @@\n+2017-07-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/81278\n+\t* tree-vrp.c (compare_assert_loc): Turn into a function template\n+\twith stable template parameter.  Only test if a->e is NULL,\n+\t!a->e == !b->e has been verified already.  Use e == NULL or\n+\te != NULL instead of e or ! e tests.  If stable is true, don't use\n+\titerative_hash_expr, on the other side allow a or b or both NULL\n+\tand sort the NULLs last.\n+\t(process_assert_insertions): Sort using compare_assert_loc<false>\n+\tinstead of compare_assert_loc, later sort using\n+\tcompare_assert_loc<true> before calling process_assert_insertions_for\n+\tin a loop.  Use break instead of continue once seen NULL pointer.\n+\n 2017-07-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* config/arm/driver-arm.c (arm_cpu_table): Add entry for ARM"}, {"sha": "28205f197518969badc634248bd2b759c83cd4a8", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a1b2334039de170886563546096fffa79c804d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a1b2334039de170886563546096fffa79c804d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=06a1b2334039de170886563546096fffa79c804d", "patch": "@@ -6393,20 +6393,37 @@ process_assert_insertions_for (tree name, assert_locus *loc)\n   gcc_unreachable ();\n }\n \n-/* Qsort helper for sorting assert locations.  */\n+/* Qsort helper for sorting assert locations.  If stable is true, don't\n+   use iterative_hash_expr because it can be unstable for -fcompare-debug,\n+   on the other side some pointers might be NULL.  */\n \n+template <bool stable>\n static int\n compare_assert_loc (const void *pa, const void *pb)\n {\n   assert_locus * const a = *(assert_locus * const *)pa;\n   assert_locus * const b = *(assert_locus * const *)pb;\n-  if (! a->e && b->e)\n+\n+  /* If stable, some asserts might be optimized away already, sort\n+     them last.  */\n+  if (stable)\n+    {\n+      if (a == NULL)\n+\treturn b != NULL;\n+      else if (b == NULL)\n+\treturn -1;\n+    }\n+\n+  if (a->e == NULL && b->e != NULL)\n     return 1;\n-  else if (a->e && ! b->e)\n+  else if (a->e != NULL && b->e == NULL)\n     return -1;\n \n+  /* After the above checks, we know that (a->e == NULL) == (b->e == NULL),\n+     no need to test both a->e and b->e.  */\n+\n   /* Sort after destination index.  */\n-  if (! a->e && ! b->e)\n+  if (a->e == NULL)\n     ;\n   else if (a->e->dest->index > b->e->dest->index)\n     return 1;\n@@ -6419,11 +6436,27 @@ compare_assert_loc (const void *pa, const void *pb)\n   else if (a->comp_code < b->comp_code)\n     return -1;\n \n+  hashval_t ha, hb;\n+\n+  /* E.g. if a->val is ADDR_EXPR of a VAR_DECL, iterative_hash_expr\n+     uses DECL_UID of the VAR_DECL, so sorting might differ between\n+     -g and -g0.  When doing the removal of redundant assert exprs\n+     and commonization to successors, this does not matter, but for\n+     the final sort needs to be stable.  */\n+  if (stable)\n+    {\n+      ha = 0;\n+      hb = 0;\n+    }\n+  else\n+    {\n+      ha = iterative_hash_expr (a->expr, iterative_hash_expr (a->val, 0));\n+      hb = iterative_hash_expr (b->expr, iterative_hash_expr (b->val, 0));\n+    }\n+\n   /* Break the tie using hashing and source/bb index.  */\n-  hashval_t ha = iterative_hash_expr (a->expr, iterative_hash_expr (a->val, 0));\n-  hashval_t hb = iterative_hash_expr (b->expr, iterative_hash_expr (b->val, 0));\n   if (ha == hb)\n-    return (a->e && b->e\n+    return (a->e != NULL\n \t    ? a->e->src->index - b->e->src->index\n \t    : a->bb->index - b->bb->index);\n   return ha - hb;\n@@ -6452,7 +6485,7 @@ process_assert_insertions (void)\n       auto_vec<assert_locus *, 16> asserts;\n       for (; loc; loc = loc->next)\n \tasserts.safe_push (loc);\n-      asserts.qsort (compare_assert_loc);\n+      asserts.qsort (compare_assert_loc<false>);\n \n       /* Push down common asserts to successors and remove redundant ones.  */\n       unsigned ecnt = 0;\n@@ -6506,11 +6539,14 @@ process_assert_insertions (void)\n \t    }\n \t}\n \n+      /* The asserts vector sorting above might be unstable for\n+\t -fcompare-debug, sort again to ensure a stable sort.  */\n+      asserts.qsort (compare_assert_loc<true>);\n       for (unsigned j = 0; j < asserts.length (); ++j)\n \t{\n \t  loc = asserts[j];\n \t  if (! loc)\n-\t    continue;\n+\t    break;\n \t  update_edges_p |= process_assert_insertions_for (ssa_name (i), loc);\n \t  num_asserts++;\n \t  free (loc);"}]}