{"sha": "c5be964a423f952e2ec16e2152ae504639bf8f07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzViZTk2NGE0MjNmOTUyZTJlYzE2ZTIxNTJhZTUwNDYzOWJmOGYwNw==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2014-11-13T20:41:38Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2014-11-13T20:41:38Z"}, "message": "libsanitizer merge from upstream r221802\n\nFrom-SVN: r217518", "tree": {"sha": "5275c09e09235f15fe0ae824d5bbef4151a7d1f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5275c09e09235f15fe0ae824d5bbef4151a7d1f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5be964a423f952e2ec16e2152ae504639bf8f07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5be964a423f952e2ec16e2152ae504639bf8f07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5be964a423f952e2ec16e2152ae504639bf8f07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5be964a423f952e2ec16e2152ae504639bf8f07/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47bf94b79a5c4937a7f922c681fa556154dcb2d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47bf94b79a5c4937a7f922c681fa556154dcb2d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47bf94b79a5c4937a7f922c681fa556154dcb2d3"}], "stats": {"total": 3200, "additions": 1992, "deletions": 1208}, "files": [{"sha": "52d969d99e19cb8512d9b8a62f63efdacb23dd7f", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -1,3 +1,26 @@\n+2014-11-13  Kostya Serebryany  <kcc@google.com>\n+\n+\t* All source files: Merge from upstream r221802.\n+\t* sanitizer_common/sanitizer_symbolizer_libbacktrace.cc\n+\t(LibbacktraceSymbolizer::SymbolizeData): Replace 'address'\n+\twith 'start' to follow the new interface.\n+\t* asan/Makefile.am (AM_CXXFLAGS): Added -std=c++11.\n+\t* interception/Makefile.am (AM_CXXFLAGS): Added -std=c++11.\n+\t* libbacktrace/Makefile.am (AM_CXXFLAGS): Added -std=c++11.\n+\t* lsan/Makefile.am (AM_CXXFLAGS): Added -std=c++11.\n+\t* sanitizer_common/Makefile.am (sanitizer_common_files): Added new\n+\tfiles.\n+\t(AM_CXXFLAGS): Added -std=c++11.\n+\t* tsan/Makefile.am (AM_CXXFLAGS): Added -std=c++11.\n+\t* ubsan/Makefile.am (AM_CXXFLAGS): Added -std=c++11.\n+\t* asan/Makefile.in: Regenerate.\n+\t* interception/Makefile.in: Regenerate.\n+\t* libbacktrace/Makefile.in: Regenerate.\n+\t* lsan/Makefile.in: Regenerate.\n+\t* sanitizer_common/Makefile.in: Regenerate.\n+\t* tsan/Makefile.in: Regenerate.\n+\t* ubsan/Makefile.in: Regenerate.\n+\n 2014-11-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR target/63610"}, {"sha": "ef893cb306efdb15980e706af0c9c5ac148e6820", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -1,4 +1,4 @@\n-218156\n+221802\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "b421776b99a63c34ff72c3bfc28368d95ac3c9a7", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -9,6 +9,7 @@ DEFS += -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT\n endif\n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fno-rtti -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -fno-ipa-icf\n AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+AM_CXXFLAGS += -std=c++11\n ACLOCAL_AMFLAGS = -I $(top_srcdir) -I $(top_srcdir)/config\n \n toolexeclib_LTLIBRARIES = libasan.la"}, {"sha": "54ae86a5c49e8d983403b095d3aecc966ec4f82b", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -270,7 +270,7 @@ AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n \t-Wno-long-long -fPIC -fno-builtin -fno-exceptions -fno-rtti \\\n \t-fomit-frame-pointer -funwind-tables -fvisibility=hidden \\\n \t-Wno-variadic-macros -fno-ipa-icf \\\n-\t$(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+\t$(LIBSTDCXX_RAW_CXX_CXXFLAGS) -std=c++11\n ACLOCAL_AMFLAGS = -I $(top_srcdir) -I $(top_srcdir)/config\n toolexeclib_LTLIBRARIES = libasan.la\n nodist_toolexeclib_HEADERS = libasan_preinit.o"}, {"sha": "d2f30af30d61eb1f8eb8fb030bc2960d83019c0e", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -43,8 +43,8 @@ class AsanChunkView {\n   uptr AllocTid();\n   uptr FreeTid();\n   bool Eq(const AsanChunkView &c) const { return chunk_ == c.chunk_; }\n-  void GetAllocStack(StackTrace *stack);\n-  void GetFreeStack(StackTrace *stack);\n+  StackTrace GetAllocStack();\n+  StackTrace GetFreeStack();\n   bool AddrIsInside(uptr addr, uptr access_size, sptr *offset) {\n     if (addr >= Beg() && (addr + access_size) <= End()) {\n       *offset = addr - Beg();\n@@ -137,20 +137,20 @@ struct AsanThreadLocalMallocStorage {\n   AsanThreadLocalMallocStorage() {}\n };\n \n-void *asan_memalign(uptr alignment, uptr size, StackTrace *stack,\n+void *asan_memalign(uptr alignment, uptr size, BufferedStackTrace *stack,\n                     AllocType alloc_type);\n-void asan_free(void *ptr, StackTrace *stack, AllocType alloc_type);\n-void asan_sized_free(void *ptr, uptr size, StackTrace *stack,\n+void asan_free(void *ptr, BufferedStackTrace *stack, AllocType alloc_type);\n+void asan_sized_free(void *ptr, uptr size, BufferedStackTrace *stack,\n                      AllocType alloc_type);\n \n-void *asan_malloc(uptr size, StackTrace *stack);\n-void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack);\n-void *asan_realloc(void *p, uptr size, StackTrace *stack);\n-void *asan_valloc(uptr size, StackTrace *stack);\n-void *asan_pvalloc(uptr size, StackTrace *stack);\n+void *asan_malloc(uptr size, BufferedStackTrace *stack);\n+void *asan_calloc(uptr nmemb, uptr size, BufferedStackTrace *stack);\n+void *asan_realloc(void *p, uptr size, BufferedStackTrace *stack);\n+void *asan_valloc(uptr size, BufferedStackTrace *stack);\n+void *asan_pvalloc(uptr size, BufferedStackTrace *stack);\n \n int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n-                          StackTrace *stack);\n+                        BufferedStackTrace *stack);\n uptr asan_malloc_usable_size(void *ptr, uptr pc, uptr bp);\n \n uptr asan_mz_size(const void *ptr);"}, {"sha": "33d9fea70cb67145576cbcc6bfc44e8a97bda2db", "filename": "libsanitizer/asan/asan_allocator2.cc", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_allocator2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_allocator2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator2.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -180,20 +180,19 @@ uptr AsanChunkView::UsedSize() { return chunk_->UsedSize(); }\n uptr AsanChunkView::AllocTid() { return chunk_->alloc_tid; }\n uptr AsanChunkView::FreeTid() { return chunk_->free_tid; }\n \n-static void GetStackTraceFromId(u32 id, StackTrace *stack) {\n+static StackTrace GetStackTraceFromId(u32 id) {\n   CHECK(id);\n-  uptr size = 0;\n-  const uptr *trace = StackDepotGet(id, &size);\n-  CHECK(trace);\n-  stack->CopyFrom(trace, size);\n+  StackTrace res = StackDepotGet(id);\n+  CHECK(res.trace);\n+  return res;\n }\n \n-void AsanChunkView::GetAllocStack(StackTrace *stack) {\n-  GetStackTraceFromId(chunk_->alloc_context_id, stack);\n+StackTrace AsanChunkView::GetAllocStack() {\n+  return GetStackTraceFromId(chunk_->alloc_context_id);\n }\n \n-void AsanChunkView::GetFreeStack(StackTrace *stack) {\n-  GetStackTraceFromId(chunk_->free_context_id, stack);\n+StackTrace AsanChunkView::GetFreeStack() {\n+  return GetStackTraceFromId(chunk_->free_context_id);\n }\n \n struct QuarantineCallback;\n@@ -261,7 +260,7 @@ void ReInitializeAllocator() {\n   quarantine.Init((uptr)flags()->quarantine_size, kMaxThreadLocalQuarantine);\n }\n \n-static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n+static void *Allocate(uptr size, uptr alignment, BufferedStackTrace *stack,\n                       AllocType alloc_type, bool can_fill) {\n   if (UNLIKELY(!asan_inited))\n     AsanInitFromRtl();\n@@ -353,7 +352,7 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n     meta[1] = chunk_beg;\n   }\n \n-  m->alloc_context_id = StackDepotPut(stack->trace, stack->size);\n+  m->alloc_context_id = StackDepotPut(*stack);\n \n   uptr size_rounded_down_to_granularity = RoundDownTo(size, SHADOW_GRANULARITY);\n   // Unpoison the bulk of the memory region.\n@@ -389,15 +388,16 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n   return res;\n }\n \n-static void ReportInvalidFree(void *ptr, u8 chunk_state, StackTrace *stack) {\n+static void ReportInvalidFree(void *ptr, u8 chunk_state,\n+                              BufferedStackTrace *stack) {\n   if (chunk_state == CHUNK_QUARANTINE)\n     ReportDoubleFree((uptr)ptr, stack);\n   else\n     ReportFreeNotMalloced((uptr)ptr, stack);\n }\n \n-static void AtomicallySetQuarantineFlag(AsanChunk *m,\n-                                        void *ptr, StackTrace *stack) {\n+static void AtomicallySetQuarantineFlag(AsanChunk *m, void *ptr,\n+                                        BufferedStackTrace *stack) {\n   u8 old_chunk_state = CHUNK_ALLOCATED;\n   // Flip the chunk_state atomically to avoid race on double-free.\n   if (!atomic_compare_exchange_strong((atomic_uint8_t*)m, &old_chunk_state,\n@@ -408,8 +408,8 @@ static void AtomicallySetQuarantineFlag(AsanChunk *m,\n \n // Expects the chunk to already be marked as quarantined by using\n // AtomicallySetQuarantineFlag.\n-static void QuarantineChunk(AsanChunk *m, void *ptr,\n-                            StackTrace *stack, AllocType alloc_type) {\n+static void QuarantineChunk(AsanChunk *m, void *ptr, BufferedStackTrace *stack,\n+                            AllocType alloc_type) {\n   CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n \n   if (m->alloc_type != alloc_type && flags()->alloc_dealloc_mismatch)\n@@ -421,7 +421,7 @@ static void QuarantineChunk(AsanChunk *m, void *ptr,\n     CHECK_EQ(m->free_tid, kInvalidTid);\n   AsanThread *t = GetCurrentThread();\n   m->free_tid = t ? t->tid() : 0;\n-  m->free_context_id = StackDepotPut(stack->trace, stack->size);\n+  m->free_context_id = StackDepotPut(*stack);\n   // Poison the region.\n   PoisonShadow(m->Beg(),\n                RoundUpTo(m->UsedSize(), SHADOW_GRANULARITY),\n@@ -445,7 +445,7 @@ static void QuarantineChunk(AsanChunk *m, void *ptr,\n   }\n }\n \n-static void Deallocate(void *ptr, uptr delete_size, StackTrace *stack,\n+static void Deallocate(void *ptr, uptr delete_size, BufferedStackTrace *stack,\n                        AllocType alloc_type) {\n   uptr p = reinterpret_cast<uptr>(ptr);\n   if (p == 0) return;\n@@ -462,7 +462,8 @@ static void Deallocate(void *ptr, uptr delete_size, StackTrace *stack,\n   QuarantineChunk(m, ptr, stack, alloc_type);\n }\n \n-static void *Reallocate(void *old_ptr, uptr new_size, StackTrace *stack) {\n+static void *Reallocate(void *old_ptr, uptr new_size,\n+                        BufferedStackTrace *stack) {\n   CHECK(old_ptr && new_size);\n   uptr p = reinterpret_cast<uptr>(old_ptr);\n   uptr chunk_beg = p - kChunkHeaderSize;\n@@ -575,25 +576,25 @@ void PrintInternalAllocatorStats() {\n   allocator.PrintStats();\n }\n \n-void *asan_memalign(uptr alignment, uptr size, StackTrace *stack,\n+void *asan_memalign(uptr alignment, uptr size, BufferedStackTrace *stack,\n                     AllocType alloc_type) {\n   return Allocate(size, alignment, stack, alloc_type, true);\n }\n \n-void asan_free(void *ptr, StackTrace *stack, AllocType alloc_type) {\n+void asan_free(void *ptr, BufferedStackTrace *stack, AllocType alloc_type) {\n   Deallocate(ptr, 0, stack, alloc_type);\n }\n \n-void asan_sized_free(void *ptr, uptr size, StackTrace *stack,\n+void asan_sized_free(void *ptr, uptr size, BufferedStackTrace *stack,\n                      AllocType alloc_type) {\n   Deallocate(ptr, size, stack, alloc_type);\n }\n \n-void *asan_malloc(uptr size, StackTrace *stack) {\n+void *asan_malloc(uptr size, BufferedStackTrace *stack) {\n   return Allocate(size, 8, stack, FROM_MALLOC, true);\n }\n \n-void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack) {\n+void *asan_calloc(uptr nmemb, uptr size, BufferedStackTrace *stack) {\n   if (CallocShouldReturnNullDueToOverflow(size, nmemb))\n     return AllocatorReturnNull();\n   void *ptr = Allocate(nmemb * size, 8, stack, FROM_MALLOC, false);\n@@ -604,7 +605,7 @@ void *asan_calloc(uptr nmemb, uptr size, StackTrace *stack) {\n   return ptr;\n }\n \n-void *asan_realloc(void *p, uptr size, StackTrace *stack) {\n+void *asan_realloc(void *p, uptr size, BufferedStackTrace *stack) {\n   if (p == 0)\n     return Allocate(size, 8, stack, FROM_MALLOC, true);\n   if (size == 0) {\n@@ -614,11 +615,11 @@ void *asan_realloc(void *p, uptr size, StackTrace *stack) {\n   return Reallocate(p, size, stack);\n }\n \n-void *asan_valloc(uptr size, StackTrace *stack) {\n+void *asan_valloc(uptr size, BufferedStackTrace *stack) {\n   return Allocate(size, GetPageSizeCached(), stack, FROM_MALLOC, true);\n }\n \n-void *asan_pvalloc(uptr size, StackTrace *stack) {\n+void *asan_pvalloc(uptr size, BufferedStackTrace *stack) {\n   uptr PageSize = GetPageSizeCached();\n   size = RoundUpTo(size, PageSize);\n   if (size == 0) {\n@@ -629,7 +630,7 @@ void *asan_pvalloc(uptr size, StackTrace *stack) {\n }\n \n int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n-                        StackTrace *stack) {\n+                        BufferedStackTrace *stack) {\n   void *ptr = Allocate(size, alignment, stack, FROM_MALLOC, true);\n   CHECK(IsAligned((uptr)ptr, alignment));\n   *memptr = ptr;"}, {"sha": "3efad658a4c982d16d973367aadf59ba11f0d3b2", "filename": "libsanitizer/asan/asan_debugging.cc", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_debugging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_debugging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_debugging.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -15,31 +15,88 @@\n #include \"asan_flags.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n+#include \"asan_report.h\"\n #include \"asan_thread.h\"\n \n namespace __asan {\n \n+void GetInfoForStackVar(uptr addr, AddressDescription *descr, AsanThread *t) {\n+  descr->name[0] = 0;\n+  descr->region_address = 0;\n+  descr->region_size = 0;\n+  descr->region_kind = \"stack\";\n+\n+  AsanThread::StackFrameAccess access;\n+  if (!t->GetStackFrameAccessByAddr(addr, &access))\n+    return;\n+  InternalMmapVector<StackVarDescr> vars(16);\n+  if (!ParseFrameDescription(access.frame_descr, &vars)) {\n+    return;\n+  }\n+\n+  for (uptr i = 0; i < vars.size(); i++) {\n+    if (access.offset <= vars[i].beg + vars[i].size) {\n+      internal_strncat(descr->name, vars[i].name_pos,\n+                       Min(descr->name_size, vars[i].name_len));\n+      descr->region_address = addr - (access.offset - vars[i].beg);\n+      descr->region_size = vars[i].size;\n+      return;\n+    }\n+  }\n+}\n+\n+void GetInfoForHeapAddress(uptr addr, AddressDescription *descr) {\n+  AsanChunkView chunk = FindHeapChunkByAddress(addr);\n+\n+  descr->name[0] = 0;\n+  descr->region_address = 0;\n+  descr->region_size = 0;\n+\n+  if (!chunk.IsValid()) {\n+    descr->region_kind = \"heap-invalid\";\n+    return;\n+  }\n+\n+  descr->region_address = chunk.Beg();\n+  descr->region_size = chunk.UsedSize();\n+  descr->region_kind = \"heap\";\n+}\n+\n+void AsanLocateAddress(uptr addr, AddressDescription *descr) {\n+  if (DescribeAddressIfShadow(addr, descr, /* print */ false)) {\n+    return;\n+  }\n+  if (GetInfoForAddressIfGlobal(addr, descr)) {\n+    return;\n+  }\n+  asanThreadRegistry().Lock();\n+  AsanThread *thread = FindThreadByStackAddress(addr);\n+  asanThreadRegistry().Unlock();\n+  if (thread) {\n+    GetInfoForStackVar(addr, descr, thread);\n+    return;\n+  }\n+  GetInfoForHeapAddress(addr, descr);\n+}\n+\n uptr AsanGetStack(uptr addr, uptr *trace, uptr size, u32 *thread_id,\n                   bool alloc_stack) {\n   AsanChunkView chunk = FindHeapChunkByAddress(addr);\n   if (!chunk.IsValid()) return 0;\n \n-  StackTrace stack;\n+  StackTrace stack(nullptr, 0);\n   if (alloc_stack) {\n     if (chunk.AllocTid() == kInvalidTid) return 0;\n-    chunk.GetAllocStack(&stack);\n+    stack = chunk.GetAllocStack();\n     if (thread_id) *thread_id = chunk.AllocTid();\n   } else {\n     if (chunk.FreeTid() == kInvalidTid) return 0;\n-    chunk.GetFreeStack(&stack);\n+    stack = chunk.GetFreeStack();\n     if (thread_id) *thread_id = chunk.FreeTid();\n   }\n \n   if (trace && size) {\n-    if (size > kStackTraceMax)\n-      size = kStackTraceMax;\n-    if (size > stack.size)\n-      size = stack.size;\n+    size = Min(size, Min(stack.size, kStackTraceMax));\n     for (uptr i = 0; i < size; i++)\n       trace[i] = StackTrace::GetPreviousInstructionPc(stack.trace[i]);\n \n@@ -53,6 +110,16 @@ uptr AsanGetStack(uptr addr, uptr *trace, uptr size, u32 *thread_id,\n \n using namespace __asan;\n \n+SANITIZER_INTERFACE_ATTRIBUTE\n+const char *__asan_locate_address(uptr addr, char *name, uptr name_size,\n+                                  uptr *region_address, uptr *region_size) {\n+  AddressDescription descr = { name, name_size, 0, 0, 0 };\n+  AsanLocateAddress(addr, &descr);\n+  if (region_address) *region_address = descr.region_address;\n+  if (region_size) *region_size = descr.region_size;\n+  return descr.region_kind;\n+}\n+\n SANITIZER_INTERFACE_ATTRIBUTE\n uptr __asan_get_alloc_stack(uptr addr, uptr *trace, uptr size, u32 *thread_id) {\n   return AsanGetStack(addr, trace, size, thread_id, /* alloc_stack */ true);"}, {"sha": "0b6a9857be0fa39fbc484fd3b4d14b91cc7fd101", "filename": "libsanitizer/asan/asan_flags.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -63,6 +63,7 @@ struct Flags {\n   int detect_invalid_pointer_pairs;\n   bool detect_container_overflow;\n   int detect_odr_violation;\n+  bool dump_instruction_bytes;\n };\n \n extern Flags asan_flags_dont_use_directly;"}, {"sha": "ee2ecdcc95751c38b037d9ab83eec6c5f5745076", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 39, "deletions": 5, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -69,6 +69,14 @@ ALWAYS_INLINE void PoisonRedZones(const Global &g) {\n   }\n }\n \n+const uptr kMinimalDistanceFromAnotherGlobal = 64;\n+\n+bool IsAddressNearGlobal(uptr addr, const __asan_global &g) {\n+  if (addr <= g.beg - kMinimalDistanceFromAnotherGlobal) return false;\n+  if (addr >= g.beg + g.size_with_redzone) return false;\n+  return true;\n+}\n+\n static void ReportGlobal(const Global &g, const char *prefix) {\n   Report(\"%s Global[%p]: beg=%p size=%zu/%zu name=%s module=%s dyn_init=%zu\\n\",\n          prefix, &g, (void *)g.beg, g.size, g.size_with_redzone, g.name,\n@@ -80,19 +88,45 @@ static void ReportGlobal(const Global &g, const char *prefix) {\n   }\n }\n \n-bool DescribeAddressIfGlobal(uptr addr, uptr size) {\n+static bool DescribeOrGetInfoIfGlobal(uptr addr, uptr size, bool print,\n+                                      Global *output_global) {\n   if (!flags()->report_globals) return false;\n   BlockingMutexLock lock(&mu_for_globals);\n   bool res = false;\n   for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n     const Global &g = *l->g;\n-    if (flags()->report_globals >= 2)\n-      ReportGlobal(g, \"Search\");\n-    res |= DescribeAddressRelativeToGlobal(addr, size, g);\n+    if (print) {\n+      if (flags()->report_globals >= 2)\n+        ReportGlobal(g, \"Search\");\n+      res |= DescribeAddressRelativeToGlobal(addr, size, g);\n+    } else {\n+      if (IsAddressNearGlobal(addr, g)) {\n+        CHECK(output_global);\n+        *output_global = g;\n+        return true;\n+      }\n+    }\n   }\n   return res;\n }\n \n+bool DescribeAddressIfGlobal(uptr addr, uptr size) {\n+  return DescribeOrGetInfoIfGlobal(addr, size, /* print */ true,\n+                                   /* output_global */ nullptr);\n+}\n+\n+bool GetInfoForAddressIfGlobal(uptr addr, AddressDescription *descr) {\n+  Global g = {};\n+  if (DescribeOrGetInfoIfGlobal(addr, /* size */ 1, /* print */ false, &g)) {\n+    internal_strncpy(descr->name, g.name, descr->name_size);\n+    descr->region_address = g.beg;\n+    descr->region_size = g.size;\n+    descr->region_kind = \"global\";\n+    return true;\n+  }\n+  return false;\n+}\n+\n u32 FindRegistrationSite(const Global *g) {\n   CHECK(global_registration_site_vector);\n   for (uptr i = 0, n = global_registration_site_vector->size(); i < n; i++) {\n@@ -181,7 +215,7 @@ using namespace __asan;  // NOLINT\n void __asan_register_globals(__asan_global *globals, uptr n) {\n   if (!flags()->report_globals) return;\n   GET_STACK_TRACE_FATAL_HERE;\n-  u32 stack_id = StackDepotPut(stack.trace, stack.size);\n+  u32 stack_id = StackDepotPut(stack);\n   BlockingMutexLock lock(&mu_for_globals);\n   if (!global_registration_site_vector)\n     global_registration_site_vector ="}, {"sha": "939327eb8a4d892b34537fa58719f13ff1f02f94", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -88,6 +88,28 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_describe_address(uptr addr);\n \n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  int __asan_report_present();\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_get_report_pc();\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_get_report_bp();\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_get_report_sp();\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_get_report_address();\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  int __asan_get_report_access_type();\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  uptr __asan_get_report_access_size();\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  const char * __asan_get_report_description();\n+\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  const char * __asan_locate_address(uptr addr, char *name, uptr name_size,\n+                                     uptr *region_address, uptr *region_size);\n+\n   SANITIZER_INTERFACE_ATTRIBUTE\n   uptr __asan_get_alloc_stack(uptr addr, uptr *trace, uptr size,\n                               u32 *thread_id);\n@@ -149,6 +171,10 @@ extern \"C\" {\n   void __asan_poison_cxx_array_cookie(uptr p);\n   SANITIZER_INTERFACE_ATTRIBUTE\n   uptr __asan_load_cxx_array_cookie(uptr *p);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_poison_intra_object_redzone(uptr p, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_unpoison_intra_object_redzone(uptr p, uptr size);\n }  // extern \"C\"\n \n #endif  // ASAN_INTERFACE_INTERNAL_H"}, {"sha": "8911575d84a05e4d65cca511e565d0197958b7aa", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -133,6 +133,7 @@ const int kAsanStackUseAfterScopeMagic = 0xf8;\n const int kAsanGlobalRedzoneMagic = 0xf9;\n const int kAsanInternalHeapMagic = 0xfe;\n const int kAsanArrayCookieMagic = 0xac;\n+const int kAsanIntraObjectRedzone = 0xbb;\n \n static const uptr kCurrentStackFrameMagic = 0x41B58AB3;\n static const uptr kRetiredStackFrameMagic = 0x45E0360E;"}, {"sha": "70823bdef9244e68643c2f9853edf7bceda2463b", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -295,7 +295,7 @@ using namespace __asan;  // NOLINT\n // The caller retains control of the allocated context.\n extern \"C\"\n asan_block_context_t *alloc_asan_context(void *ctxt, dispatch_function_t func,\n-                                         StackTrace *stack) {\n+                                         BufferedStackTrace *stack) {\n   asan_block_context_t *asan_ctxt =\n       (asan_block_context_t*) asan_malloc(sizeof(asan_block_context_t), stack);\n   asan_ctxt->block = ctxt;"}, {"sha": "907704d7fc989c7dc5ffd57ca08fa78fec2dd8af", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -58,11 +58,11 @@\n // || `[0x00000000, 0x1fffffff]` || LowMem     ||\n //\n // Default Linux/MIPS mapping:\n-// || `[0x2aaa8000, 0xffffffff]` || HighMem    ||\n-// || `[0x0fffd000, 0x2aaa7fff]` || HighShadow ||\n-// || `[0x0bffd000, 0x0fffcfff]` || ShadowGap  ||\n-// || `[0x0aaa8000, 0x0bffcfff]` || LowShadow  ||\n-// || `[0x00000000, 0x0aaa7fff]` || LowMem     ||\n+// || `[0x2aaa0000, 0xffffffff]` || HighMem    ||\n+// || `[0x0fff4000, 0x2aa9ffff]` || HighShadow ||\n+// || `[0x0bff4000, 0x0fff3fff]` || ShadowGap  ||\n+// || `[0x0aaa0000, 0x0bff3fff]` || LowShadow  ||\n+// || `[0x00000000, 0x0aa9ffff]` || LowMem     ||\n //\n // Shadow mapping on FreeBSD/x86-64 with SHADOW_OFFSET == 0x400000000000:\n // || `[0x500000000000, 0x7fffffffffff]` || HighMem    ||\n@@ -84,7 +84,8 @@ static const u64 kIosShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kDefaultShadowOffset64 = 1ULL << 44;\n static const u64 kDefaultShort64bitShadowOffset = 0x7FFF8000;  // < 2G.\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n-static const u64 kMIPS32_ShadowOffset32 = 0x0aaa8000;\n+static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n+static const u64 kMIPS64_ShadowOffset64 = 1ULL << 36;\n static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kFreeBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n@@ -114,6 +115,8 @@ static const u64 kFreeBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n #    define SHADOW_OFFSET kFreeBSD_ShadowOffset64\n #  elif SANITIZER_MAC\n #   define SHADOW_OFFSET kDefaultShadowOffset64\n+#  elif defined(__mips64)\n+#   define SHADOW_OFFSET kMIPS64_ShadowOffset64\n #  else\n #   define SHADOW_OFFSET kDefaultShort64bitShadowOffset\n #  endif"}, {"sha": "c0f3991c1f321fb1275442a7be1325ab732cef35", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -59,6 +59,27 @@ void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n     FlushUnneededShadowMemory(shadow_beg, shadow_end - shadow_beg);\n }\n \n+void AsanPoisonOrUnpoisonIntraObjectRedzone(uptr ptr, uptr size, bool poison) {\n+  uptr end = ptr + size;\n+  if (common_flags()->verbosity) {\n+    Printf(\"__asan_%spoison_intra_object_redzone [%p,%p) %zd\\n\",\n+           poison ? \"\" : \"un\", ptr, end, size);\n+    if (common_flags()->verbosity >= 2)\n+      PRINT_CURRENT_STACK();\n+  }\n+  CHECK(size);\n+  CHECK_LE(size, 4096);\n+  CHECK(IsAligned(end, SHADOW_GRANULARITY));\n+  if (!IsAligned(ptr, SHADOW_GRANULARITY)) {\n+    *(u8 *)MemToShadow(ptr) =\n+        poison ? static_cast<u8>(ptr % SHADOW_GRANULARITY) : 0;\n+    ptr |= SHADOW_GRANULARITY - 1;\n+    ptr++;\n+  }\n+  for (; ptr < end; ptr += SHADOW_GRANULARITY)\n+    *(u8*)MemToShadow(ptr) = poison ? kAsanIntraObjectRedzone : 0;\n+}\n+\n }  // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n@@ -250,7 +271,8 @@ uptr __asan_load_cxx_array_cookie(uptr *p) {\n            \"expect a double-free report\\n\");\n     return 0;\n   }\n-  // FIXME: apparently it can be something else; need to find a reproducer.\n+  // The cookie may remain unpoisoned if e.g. it comes from a custom\n+  // operator new defined inside a class.\n   return *p;\n }\n \n@@ -372,6 +394,17 @@ int __sanitizer_verify_contiguous_container(const void *beg_p,\n       return 0;\n   return 1;\n }\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_poison_intra_object_redzone(uptr ptr, uptr size) {\n+  AsanPoisonOrUnpoisonIntraObjectRedzone(ptr, size, true);\n+}\n+\n+extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n+void __asan_unpoison_intra_object_redzone(uptr ptr, uptr size) {\n+  AsanPoisonOrUnpoisonIntraObjectRedzone(ptr, size, false);\n+}\n+\n // --- Implementation of LSan-specific functions --- {{{1\n namespace __lsan {\n bool WordIsPoisoned(uptr addr) {"}, {"sha": "06d24d4e0ee885e4ff7811ba7a6cbacd44f1201d", "filename": "libsanitizer/asan/asan_posix.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -31,6 +31,7 @@\n namespace __asan {\n \n void AsanOnSIGSEGV(int, void *siginfo, void *context) {\n+  ScopedDeadlySignal signal_scope(GetCurrentThread());\n   uptr addr = (uptr)((siginfo_t*)siginfo)->si_addr;\n   int code = (int)((siginfo_t*)siginfo)->si_code;\n   // Write the first message using the bullet-proof write.\n@@ -39,12 +40,12 @@ void AsanOnSIGSEGV(int, void *siginfo, void *context) {\n   GetPcSpBp(context, &pc, &sp, &bp);\n \n   // Access at a reasonable offset above SP, or slightly below it (to account\n-  // for x86_64 redzone, ARM push of multiple registers, etc) is probably a\n-  // stack overflow.\n+  // for x86_64 or PowerPC redzone, ARM push of multiple registers, etc) is\n+  // probably a stack overflow.\n   // We also check si_code to filter out SEGV caused by something else other\n   // then hitting the guard page or unmapped memory, like, for example,\n   // unaligned memory access.\n-  if (addr + 128 > sp && addr < sp + 0xFFFF &&\n+  if (addr + 512 > sp && addr < sp + 0xFFFF &&\n       (code == si_SEGV_MAPERR || code == si_SEGV_ACCERR))\n     ReportStackOverflow(pc, sp, bp, context, addr);\n   else"}, {"sha": "fcccb70ff8b32166614697874842bce279bd31ee", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 171, "deletions": 95, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -29,6 +29,19 @@ static char *error_message_buffer = 0;\n static uptr error_message_buffer_pos = 0;\n static uptr error_message_buffer_size = 0;\n \n+struct ReportData {\n+  uptr pc;\n+  uptr sp;\n+  uptr bp;\n+  uptr addr;\n+  bool is_write;\n+  uptr access_size;\n+  const char *description;\n+};\n+\n+static bool report_happened = false;\n+static ReportData report_data = {};\n+\n void AppendToErrorMessageBuffer(const char *buffer) {\n   if (error_message_buffer) {\n     uptr length = internal_strlen(buffer);\n@@ -79,20 +92,31 @@ class Decorator: public __sanitizer::SanitizerCommonDecorator {\n         return Red();\n       case kAsanInternalHeapMagic:\n         return Yellow();\n+      case kAsanIntraObjectRedzone:\n+        return Yellow();\n       default:\n         return Default();\n     }\n   }\n   const char *EndShadowByte() { return Default(); }\n+  const char *MemoryByte() { return Magenta(); }\n+  const char *EndMemoryByte() { return Default(); }\n };\n \n // ---------------------- Helper functions ----------------------- {{{1\n \n-static void PrintShadowByte(InternalScopedString *str, const char *before,\n-                            u8 byte, const char *after = \"\\n\") {\n+static void PrintMemoryByte(InternalScopedString *str, const char *before,\n+    u8 byte, bool in_shadow, const char *after = \"\\n\") {\n   Decorator d;\n-  str->append(\"%s%s%x%x%s%s\", before, d.ShadowByte(byte), byte >> 4, byte & 15,\n-              d.EndShadowByte(), after);\n+  str->append(\"%s%s%x%x%s%s\", before,\n+              in_shadow ? d.ShadowByte(byte) : d.MemoryByte(),\n+              byte >> 4, byte & 15,\n+              in_shadow ? d.EndShadowByte() : d.EndMemoryByte(), after);\n+}\n+\n+static void PrintShadowByte(InternalScopedString *str, const char *before,\n+    u8 byte, const char *after = \"\\n\") {\n+  PrintMemoryByte(str, before, byte, /*in_shadow*/true, after);\n }\n \n static void PrintShadowBytes(InternalScopedString *str, const char *before,\n@@ -144,9 +168,27 @@ static void PrintLegend(InternalScopedString *str) {\n                   kAsanContiguousContainerOOBMagic);\n   PrintShadowByte(str, \"  Array cookie:            \",\n                   kAsanArrayCookieMagic);\n+  PrintShadowByte(str, \"  Intra object redzone:    \",\n+                  kAsanIntraObjectRedzone);\n   PrintShadowByte(str, \"  ASan internal:           \", kAsanInternalHeapMagic);\n }\n \n+void MaybeDumpInstructionBytes(uptr pc) {\n+  if (!flags()->dump_instruction_bytes || (pc < GetPageSizeCached()))\n+    return;\n+  InternalScopedString str(1024);\n+  str.append(\"First 16 instruction bytes at pc: \");\n+  if (IsAccessibleMemoryRange(pc, 16)) {\n+    for (int i = 0; i < 16; ++i) {\n+      PrintMemoryByte(&str, \"\", ((u8 *)pc)[i], /*in_shadow*/false, \" \");\n+    }\n+    str.append(\"\\n\");\n+  } else {\n+    str.append(\"unaccessible\\n\");\n+  }\n+  Report(\"%s\", str.data());\n+}\n+\n static void PrintShadowMemoryForAddress(uptr addr) {\n   if (!AddrIsInMem(addr)) return;\n   uptr shadow_addr = MemToShadow(addr);\n@@ -235,9 +277,7 @@ static void PrintGlobalLocation(InternalScopedString *str,\n \n bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n                                      const __asan_global &g) {\n-  static const uptr kMinimalDistanceFromAnotherGlobal = 64;\n-  if (addr <= g.beg - kMinimalDistanceFromAnotherGlobal) return false;\n-  if (addr >= g.beg + g.size_with_redzone) return false;\n+  if (!IsAddressNearGlobal(addr, g)) return false;\n   InternalScopedString str(4096);\n   Decorator d;\n   str.append(\"%s\", d.Location());\n@@ -263,21 +303,20 @@ bool DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n   return true;\n }\n \n-bool DescribeAddressIfShadow(uptr addr) {\n+bool DescribeAddressIfShadow(uptr addr, AddressDescription *descr, bool print) {\n   if (AddrIsInMem(addr))\n     return false;\n-  static const char kAddrInShadowReport[] =\n-      \"Address %p is located in the %s.\\n\";\n-  if (AddrIsInShadowGap(addr)) {\n-    Printf(kAddrInShadowReport, addr, \"shadow gap area\");\n-    return true;\n-  }\n-  if (AddrIsInHighShadow(addr)) {\n-    Printf(kAddrInShadowReport, addr, \"high shadow area\");\n-    return true;\n-  }\n-  if (AddrIsInLowShadow(addr)) {\n-    Printf(kAddrInShadowReport, addr, \"low shadow area\");\n+  const char *area_type = nullptr;\n+  if (AddrIsInShadowGap(addr)) area_type = \"shadow gap\";\n+  else if (AddrIsInHighShadow(addr)) area_type = \"high shadow\";\n+  else if (AddrIsInLowShadow(addr)) area_type = \"low shadow\";\n+  if (area_type != nullptr) {\n+    if (print) {\n+      Printf(\"Address %p is located in the %s area.\\n\", addr, area_type);\n+    } else {\n+      CHECK(descr);\n+      descr->region_kind = area_type;\n+    }\n     return true;\n   }\n   CHECK(0 && \"Address is not in memory and not in shadow?\");\n@@ -304,16 +343,15 @@ const char *ThreadNameWithParenthesis(u32 tid, char buff[],\n   return ThreadNameWithParenthesis(t, buff, buff_len);\n }\n \n-void PrintAccessAndVarIntersection(const char *var_name,\n-                                   uptr var_beg, uptr var_size,\n-                                   uptr addr, uptr access_size,\n-                                   uptr prev_var_end, uptr next_var_beg) {\n-  uptr var_end = var_beg + var_size;\n+static void PrintAccessAndVarIntersection(const StackVarDescr &var, uptr addr,\n+                                          uptr access_size, uptr prev_var_end,\n+                                          uptr next_var_beg) {\n+  uptr var_end = var.beg + var.size;\n   uptr addr_end = addr + access_size;\n   const char *pos_descr = 0;\n-  // If the variable [var_beg, var_end) is the nearest variable to the\n+  // If the variable [var.beg, var_end) is the nearest variable to the\n   // current memory access, indicate it in the log.\n-  if (addr >= var_beg) {\n+  if (addr >= var.beg) {\n     if (addr_end <= var_end)\n       pos_descr = \"is inside\";  // May happen if this is a use-after-return.\n     else if (addr < var_end)\n@@ -322,14 +360,20 @@ void PrintAccessAndVarIntersection(const char *var_name,\n              next_var_beg - addr_end >= addr - var_end)\n       pos_descr = \"overflows\";\n   } else {\n-    if (addr_end > var_beg)\n+    if (addr_end > var.beg)\n       pos_descr = \"partially underflows\";\n     else if (addr >= prev_var_end &&\n-             addr - prev_var_end >= var_beg - addr_end)\n+             addr - prev_var_end >= var.beg - addr_end)\n       pos_descr = \"underflows\";\n   }\n   InternalScopedString str(1024);\n-  str.append(\"    [%zd, %zd) '%s'\", var_beg, var_beg + var_size, var_name);\n+  str.append(\"    [%zd, %zd)\", var.beg, var_end);\n+  // Render variable name.\n+  str.append(\" '\");\n+  for (uptr i = 0; i < var.name_len; ++i) {\n+    str.append(\"%c\", var.name_pos[i]);\n+  }\n+  str.append(\"'\");\n   if (pos_descr) {\n     Decorator d;\n     // FIXME: we may want to also print the size of the access here,\n@@ -344,9 +388,14 @@ void PrintAccessAndVarIntersection(const char *var_name,\n \n bool ParseFrameDescription(const char *frame_descr,\n                            InternalMmapVector<StackVarDescr> *vars) {\n+  CHECK(frame_descr);\n   char *p;\n+  // This string is created by the compiler and has the following form:\n+  // \"n alloc_1 alloc_2 ... alloc_n\"\n+  // where alloc_i looks like \"offset size len ObjectName\".\n   uptr n_objects = (uptr)internal_simple_strtoll(frame_descr, &p, 10);\n-  CHECK_GT(n_objects, 0);\n+  if (n_objects == 0)\n+    return false;\n \n   for (uptr i = 0; i < n_objects; i++) {\n     uptr beg  = (uptr)internal_simple_strtoll(p, &p, 10);\n@@ -367,48 +416,43 @@ bool ParseFrameDescription(const char *frame_descr,\n bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n   AsanThread *t = FindThreadByStackAddress(addr);\n   if (!t) return false;\n-  const uptr kBufSize = 4095;\n-  char buf[kBufSize];\n-  uptr offset = 0;\n-  uptr frame_pc = 0;\n-  char tname[128];\n-  const char *frame_descr = t->GetFrameNameByAddr(addr, &offset, &frame_pc);\n-\n-#ifdef __powerpc64__\n-  // On PowerPC64, the address of a function actually points to a\n-  // three-doubleword data structure with the first field containing\n-  // the address of the function's code.\n-  frame_pc = *reinterpret_cast<uptr *>(frame_pc);\n-#endif\n \n-  // This string is created by the compiler and has the following form:\n-  // \"n alloc_1 alloc_2 ... alloc_n\"\n-  // where alloc_i looks like \"offset size len ObjectName \".\n-  CHECK(frame_descr);\n   Decorator d;\n+  char tname[128];\n   Printf(\"%s\", d.Location());\n-  Printf(\"Address %p is located in stack of thread T%d%s \"\n-         \"at offset %zu in frame\\n\",\n-         addr, t->tid(),\n-         ThreadNameWithParenthesis(t->tid(), tname, sizeof(tname)),\n-         offset);\n+  Printf(\"Address %p is located in stack of thread T%d%s\", addr, t->tid(),\n+         ThreadNameWithParenthesis(t->tid(), tname, sizeof(tname)));\n+\n+  // Try to fetch precise stack frame for this access.\n+  AsanThread::StackFrameAccess access;\n+  if (!t->GetStackFrameAccessByAddr(addr, &access)) {\n+    Printf(\"%s\\n\", d.EndLocation());\n+    return true;\n+  }\n+  Printf(\" at offset %zu in frame%s\\n\", access.offset, d.EndLocation());\n+\n   // Now we print the frame where the alloca has happened.\n   // We print this frame as a stack trace with one element.\n   // The symbolizer may print more than one frame if inlining was involved.\n   // The frame numbers may be different than those in the stack trace printed\n   // previously. That's unfortunate, but I have no better solution,\n   // especially given that the alloca may be from entirely different place\n   // (e.g. use-after-scope, or different thread's stack).\n-  StackTrace alloca_stack;\n-  alloca_stack.trace[0] = frame_pc + 16;\n-  alloca_stack.size = 1;\n+#if defined(__powerpc64__) && defined(__BIG_ENDIAN__)\n+  // On PowerPC64 ELFv1, the address of a function actually points to a\n+  // three-doubleword data structure with the first field containing\n+  // the address of the function's code.\n+  access.frame_pc = *reinterpret_cast<uptr *>(access.frame_pc);\n+#endif\n+  access.frame_pc += 16;\n   Printf(\"%s\", d.EndLocation());\n+  StackTrace alloca_stack(&access.frame_pc, 1);\n   alloca_stack.Print();\n \n   InternalMmapVector<StackVarDescr> vars(16);\n-  if (!ParseFrameDescription(frame_descr, &vars)) {\n+  if (!ParseFrameDescription(access.frame_descr, &vars)) {\n     Printf(\"AddressSanitizer can't parse the stack frame \"\n-           \"descriptor: |%s|\\n\", frame_descr);\n+           \"descriptor: |%s|\\n\", access.frame_descr);\n     // 'addr' is a stack address, so return true even if we can't parse frame\n     return true;\n   }\n@@ -418,13 +462,9 @@ bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n \n   // Report all objects in this frame.\n   for (uptr i = 0; i < n_objects; i++) {\n-    buf[0] = 0;\n-    internal_strncat(buf, vars[i].name_pos,\n-                     static_cast<uptr>(Min(kBufSize, vars[i].name_len)));\n     uptr prev_var_end = i ? vars[i - 1].beg + vars[i - 1].size : 0;\n     uptr next_var_beg = i + 1 < n_objects ? vars[i + 1].beg : ~(0UL);\n-    PrintAccessAndVarIntersection(buf, vars[i].beg, vars[i].size,\n-                                  offset, access_size,\n+    PrintAccessAndVarIntersection(vars[i], access.offset, access_size,\n                                   prev_var_end, next_var_beg);\n   }\n   Printf(\"HINT: this may be a false positive if your program uses \"\n@@ -476,8 +516,7 @@ void DescribeHeapAddress(uptr addr, uptr access_size) {\n   asanThreadRegistry().CheckLocked();\n   AsanThreadContext *alloc_thread =\n       GetThreadContextByTidLocked(chunk.AllocTid());\n-  StackTrace alloc_stack;\n-  chunk.GetAllocStack(&alloc_stack);\n+  StackTrace alloc_stack = chunk.GetAllocStack();\n   char tname[128];\n   Decorator d;\n   AsanThreadContext *free_thread = 0;\n@@ -487,8 +526,7 @@ void DescribeHeapAddress(uptr addr, uptr access_size) {\n            free_thread->tid,\n            ThreadNameWithParenthesis(free_thread, tname, sizeof(tname)),\n            d.EndAllocation());\n-    StackTrace free_stack;\n-    chunk.GetFreeStack(&free_stack);\n+    StackTrace free_stack = chunk.GetFreeStack();\n     free_stack.Print();\n     Printf(\"%spreviously allocated by thread T%d%s here:%s\\n\",\n            d.Allocation(), alloc_thread->tid,\n@@ -538,9 +576,7 @@ void DescribeThread(AsanThreadContext *context) {\n       \" created by T%d%s here:\\n\", context->parent_tid,\n       ThreadNameWithParenthesis(context->parent_tid, tname, sizeof(tname)));\n   Printf(\"%s\", str.data());\n-  uptr stack_size;\n-  const uptr *stack_trace = StackDepotGet(context->stack_id, &stack_size);\n-  StackTrace::PrintStack(stack_trace, stack_size);\n+  StackDepotGet(context->stack_id).Print();\n   // Recursively described parent thread if needed.\n   if (flags()->print_full_thread_history) {\n     AsanThreadContext *parent_context =\n@@ -555,7 +591,7 @@ void DescribeThread(AsanThreadContext *context) {\n // immediately after printing error report.\n class ScopedInErrorReport {\n  public:\n-  ScopedInErrorReport() {\n+  explicit ScopedInErrorReport(ReportData *report = nullptr) {\n     static atomic_uint32_t num_calls;\n     static u32 reporting_thread_tid;\n     if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) != 0) {\n@@ -575,6 +611,8 @@ class ScopedInErrorReport {\n       // Die() to bypass any additional checks.\n       internal__exit(flags()->exitcode);\n     }\n+    if (report) report_data = *report;\n+    report_happened = true;\n     ASAN_ON_ERROR();\n     // Make sure the registry and sanitizer report mutexes are locked while\n     // we're printing an error report.\n@@ -634,11 +672,12 @@ void ReportSIGSEGV(const char *description, uptr pc, uptr sp, uptr bp,\n   Printf(\"%s\", d.EndWarning());\n   GET_STACK_TRACE_SIGNAL(pc, bp, context);\n   stack.Print();\n+  MaybeDumpInstructionBytes(pc);\n   Printf(\"AddressSanitizer can not provide additional info.\\n\");\n   ReportErrorSummary(\"SEGV\", &stack);\n }\n \n-void ReportDoubleFree(uptr addr, StackTrace *free_stack) {\n+void ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n@@ -657,7 +696,7 @@ void ReportDoubleFree(uptr addr, StackTrace *free_stack) {\n }\n \n void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n-                                 StackTrace *free_stack) {\n+                                 BufferedStackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n@@ -680,7 +719,7 @@ void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n          \"ASAN_OPTIONS=new_delete_type_mismatch=0\\n\");\n }\n \n-void ReportFreeNotMalloced(uptr addr, StackTrace *free_stack) {\n+void ReportFreeNotMalloced(uptr addr, BufferedStackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n@@ -697,7 +736,7 @@ void ReportFreeNotMalloced(uptr addr, StackTrace *free_stack) {\n   ReportErrorSummary(\"bad-free\", &stack);\n }\n \n-void ReportAllocTypeMismatch(uptr addr, StackTrace *free_stack,\n+void ReportAllocTypeMismatch(uptr addr, BufferedStackTrace *free_stack,\n                              AllocType alloc_type,\n                              AllocType dealloc_type) {\n   static const char *alloc_names[] =\n@@ -720,7 +759,7 @@ void ReportAllocTypeMismatch(uptr addr, StackTrace *free_stack,\n          \"ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n\");\n }\n \n-void ReportMallocUsableSizeNotOwned(uptr addr, StackTrace *stack) {\n+void ReportMallocUsableSizeNotOwned(uptr addr, BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n@@ -733,7 +772,8 @@ void ReportMallocUsableSizeNotOwned(uptr addr, StackTrace *stack) {\n   ReportErrorSummary(\"bad-malloc_usable_size\", stack);\n }\n \n-void ReportSanitizerGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n+void ReportSanitizerGetAllocatedSizeNotOwned(uptr addr,\n+                                             BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n@@ -746,9 +786,10 @@ void ReportSanitizerGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack) {\n   ReportErrorSummary(\"bad-__sanitizer_get_allocated_size\", stack);\n }\n \n-void ReportStringFunctionMemoryRangesOverlap(\n-    const char *function, const char *offset1, uptr length1,\n-    const char *offset2, uptr length2, StackTrace *stack) {\n+void ReportStringFunctionMemoryRangesOverlap(const char *function,\n+                                             const char *offset1, uptr length1,\n+                                             const char *offset2, uptr length2,\n+                                             BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   char bug_type[100];\n@@ -765,7 +806,7 @@ void ReportStringFunctionMemoryRangesOverlap(\n }\n \n void ReportStringFunctionSizeOverflow(uptr offset, uptr size,\n-                                      StackTrace *stack) {\n+                                      BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Decorator d;\n   const char *bug_type = \"negative-size-param\";\n@@ -779,7 +820,7 @@ void ReportStringFunctionSizeOverflow(uptr offset, uptr size,\n \n void ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end,\n                                                   uptr old_mid, uptr new_mid,\n-                                                  StackTrace *stack) {\n+                                                  BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Report(\"ERROR: AddressSanitizer: bad parameters to \"\n          \"__sanitizer_annotate_contiguous_container:\\n\"\n@@ -809,12 +850,9 @@ void ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n   if (stack_id1 && stack_id2) {\n     Printf(\"These globals were registered at these points:\\n\");\n     Printf(\"  [1]:\\n\");\n-    uptr stack_size;\n-    const uptr *stack_trace = StackDepotGet(stack_id1, &stack_size);\n-    StackTrace::PrintStack(stack_trace, stack_size);\n+    StackDepotGet(stack_id1).Print();\n     Printf(\"  [2]:\\n\");\n-    stack_trace = StackDepotGet(stack_id2, &stack_size);\n-    StackTrace::PrintStack(stack_trace, stack_size);\n+    StackDepotGet(stack_id2).Print();\n   }\n   Report(\"HINT: if you don't care about these warnings you may set \"\n          \"ASAN_OPTIONS=detect_odr_violation=0\\n\");\n@@ -854,8 +892,8 @@ static INLINE void CheckForInvalidPointerPair(void *p1, void *p2) {\n }\n // ----------------------- Mac-specific reports ----------------- {{{1\n \n-void WarnMacFreeUnallocated(\n-    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack) {\n+void WarnMacFreeUnallocated(uptr addr, uptr zone_ptr, const char *zone_name,\n+                            BufferedStackTrace *stack) {\n   // Just print a warning here.\n   Printf(\"free_common(%p) -- attempting to free unallocated memory.\\n\"\n              \"AddressSanitizer is ignoring this error on Mac OS now.\\n\",\n@@ -865,8 +903,8 @@ void WarnMacFreeUnallocated(\n   DescribeHeapAddress(addr, 1);\n }\n \n-void ReportMacMzReallocUnknown(\n-    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack) {\n+void ReportMacMzReallocUnknown(uptr addr, uptr zone_ptr, const char *zone_name,\n+                               BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Printf(\"mz_realloc(%p) -- attempting to realloc unallocated memory.\\n\"\n              \"This is an unrecoverable problem, exiting now.\\n\",\n@@ -876,8 +914,8 @@ void ReportMacMzReallocUnknown(\n   DescribeHeapAddress(addr, 1);\n }\n \n-void ReportMacCfReallocUnknown(\n-    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack) {\n+void ReportMacCfReallocUnknown(uptr addr, uptr zone_ptr, const char *zone_name,\n+                               BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n   Printf(\"cf_realloc(%p) -- attempting to realloc unallocated memory.\\n\"\n              \"This is an unrecoverable problem, exiting now.\\n\",\n@@ -894,8 +932,6 @@ using namespace __asan;  // NOLINT\n \n void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n                          uptr access_size) {\n-  ScopedInErrorReport in_report;\n-\n   // Determine the error type.\n   const char *bug_descr = \"unknown-crash\";\n   if (AddrIsInMem(addr)) {\n@@ -941,8 +977,16 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n       case kAsanGlobalRedzoneMagic:\n         bug_descr = \"global-buffer-overflow\";\n         break;\n+      case kAsanIntraObjectRedzone:\n+        bug_descr = \"intra-object-overflow\";\n+        break;\n     }\n   }\n+\n+  ReportData report = { pc, sp, bp, addr, (bool)is_write, access_size,\n+                        bug_descr };\n+  ScopedInErrorReport in_report(&report);\n+\n   Decorator d;\n   Printf(\"%s\", d.Warning());\n   Report(\"ERROR: AddressSanitizer: %s on address \"\n@@ -984,6 +1028,38 @@ void __asan_describe_address(uptr addr) {\n   asanThreadRegistry().Unlock();\n }\n \n+int __asan_report_present() {\n+  return report_happened ? 1 : 0;\n+}\n+\n+uptr __asan_get_report_pc() {\n+  return report_data.pc;\n+}\n+\n+uptr __asan_get_report_bp() {\n+  return report_data.bp;\n+}\n+\n+uptr __asan_get_report_sp() {\n+  return report_data.sp;\n+}\n+\n+uptr __asan_get_report_address() {\n+  return report_data.addr;\n+}\n+\n+int __asan_get_report_access_type() {\n+  return report_data.is_write ? 1 : 0;\n+}\n+\n+uptr __asan_get_report_access_size() {\n+  return report_data.access_size;\n+}\n+\n+const char *__asan_get_report_description() {\n+  return report_data.description;\n+}\n+\n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_ptr_sub(void *a, void *b) {"}, {"sha": "b31b86dd08b3e3fc515db76e992a1f46be0cb0c5", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -23,13 +23,24 @@ struct StackVarDescr {\n   uptr name_len;\n };\n \n+struct AddressDescription {\n+  char *name;\n+  uptr name_size;\n+  uptr region_address;\n+  uptr region_size;\n+  const char *region_kind;\n+};\n+\n // The following functions prints address description depending\n // on the memory type (shadow/heap/stack/global).\n void DescribeHeapAddress(uptr addr, uptr access_size);\n bool DescribeAddressIfGlobal(uptr addr, uptr access_size);\n bool DescribeAddressRelativeToGlobal(uptr addr, uptr access_size,\n                                      const __asan_global &g);\n-bool DescribeAddressIfShadow(uptr addr);\n+bool IsAddressNearGlobal(uptr addr, const __asan_global &g);\n+bool GetInfoForAddressIfGlobal(uptr addr, AddressDescription *descr);\n+bool DescribeAddressIfShadow(uptr addr, AddressDescription *descr = nullptr,\n+                             bool print = true);\n bool ParseFrameDescription(const char *frame_descr,\n                            InternalMmapVector<StackVarDescr> *vars);\n bool DescribeAddressIfStack(uptr addr, uptr access_size);\n@@ -44,35 +55,41 @@ void NORETURN\n void NORETURN ReportSIGSEGV(const char *description, uptr pc, uptr sp, uptr bp,\n                             void *context, uptr addr);\n void NORETURN ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n-                                          StackTrace *free_stack);\n-void NORETURN ReportDoubleFree(uptr addr, StackTrace *free_stack);\n-void NORETURN ReportFreeNotMalloced(uptr addr, StackTrace *free_stack);\n-void NORETURN ReportAllocTypeMismatch(uptr addr, StackTrace *free_stack,\n+                                          BufferedStackTrace *free_stack);\n+void NORETURN ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack);\n+void NORETURN ReportFreeNotMalloced(uptr addr, BufferedStackTrace *free_stack);\n+void NORETURN ReportAllocTypeMismatch(uptr addr, BufferedStackTrace *free_stack,\n                                       AllocType alloc_type,\n                                       AllocType dealloc_type);\n-void NORETURN ReportMallocUsableSizeNotOwned(uptr addr,\n-                                             StackTrace *stack);\n void NORETURN\n-ReportSanitizerGetAllocatedSizeNotOwned(uptr addr, StackTrace *stack);\n-void NORETURN ReportStringFunctionMemoryRangesOverlap(\n-    const char *function, const char *offset1, uptr length1,\n-    const char *offset2, uptr length2, StackTrace *stack);\n+    ReportMallocUsableSizeNotOwned(uptr addr, BufferedStackTrace *stack);\n+void NORETURN\n+    ReportSanitizerGetAllocatedSizeNotOwned(uptr addr,\n+                                            BufferedStackTrace *stack);\n void NORETURN\n-ReportStringFunctionSizeOverflow(uptr offset, uptr size, StackTrace *stack);\n+    ReportStringFunctionMemoryRangesOverlap(const char *function,\n+                                            const char *offset1, uptr length1,\n+                                            const char *offset2, uptr length2,\n+                                            BufferedStackTrace *stack);\n+void NORETURN ReportStringFunctionSizeOverflow(uptr offset, uptr size,\n+                                               BufferedStackTrace *stack);\n void NORETURN\n-ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end, uptr old_mid,\n-                                             uptr new_mid, StackTrace *stack);\n+    ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end,\n+                                                 uptr old_mid, uptr new_mid,\n+                                                 BufferedStackTrace *stack);\n \n void NORETURN\n ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n                    const __asan_global *g2, u32 stack_id2);\n \n // Mac-specific errors and warnings.\n-void WarnMacFreeUnallocated(\n-    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack);\n-void NORETURN ReportMacMzReallocUnknown(\n-    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack);\n-void NORETURN ReportMacCfReallocUnknown(\n-    uptr addr, uptr zone_ptr, const char *zone_name, StackTrace *stack);\n+void WarnMacFreeUnallocated(uptr addr, uptr zone_ptr, const char *zone_name,\n+                            BufferedStackTrace *stack);\n+void NORETURN ReportMacMzReallocUnknown(uptr addr, uptr zone_ptr,\n+                                        const char *zone_name,\n+                                        BufferedStackTrace *stack);\n+void NORETURN ReportMacCfReallocUnknown(uptr addr, uptr zone_ptr,\n+                                        const char *zone_name,\n+                                        BufferedStackTrace *stack);\n \n }  // namespace __asan"}, {"sha": "2c599047dac2951ddbc53b50267abc05421eb71b", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -65,7 +65,7 @@ static void AsanCheckFailed(const char *file, int line, const char *cond,\n   Report(\"AddressSanitizer CHECK failed: %s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\", file,\n          line, cond, (uptr)v1, (uptr)v2);\n   // FIXME: check for infinite recursion without a thread-local counter here.\n-  PRINT_CURRENT_STACK();\n+  PRINT_CURRENT_STACK_CHECK();\n   Die();\n }\n \n@@ -228,6 +228,9 @@ static void ParseFlagsFromString(Flags *f, const char *str) {\n             \"If >=2, detect violation of One-Definition-Rule (ODR); \"\n             \"If ==1, detect ODR-violation only if the two variables \"\n             \"have different sizes\");\n+\n+  ParseFlag(str, &f->dump_instruction_bytes, \"dump_instruction_bytes\",\n+      \"If true, dump 16 bytes starting at the instruction that caused SEGV\");\n }\n \n void InitializeFlags(Flags *f, const char *env) {\n@@ -281,6 +284,7 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->detect_invalid_pointer_pairs = 0;\n   f->detect_container_overflow = true;\n   f->detect_odr_violation = 2;\n+  f->dump_instruction_bytes = false;\n \n   // Override from compile definition.\n   ParseFlagsFromString(f, MaybeUseAsanDefaultOptionsCompileDefinition());"}, {"sha": "640c4cf4f7b71f5702d088d46bbd9df48f60aff2", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -23,15 +23,20 @@ namespace __asan {\n // The pc will be in the position 0 of the resulting stack trace.\n // The bp may refer to the current frame or to the caller's frame.\n ALWAYS_INLINE\n-void GetStackTraceWithPcBpAndContext(StackTrace *stack, uptr max_depth, uptr pc,\n-                                     uptr bp, void *context, bool fast) {\n+void GetStackTraceWithPcBpAndContext(BufferedStackTrace *stack, uptr max_depth,\n+                                     uptr pc, uptr bp, void *context,\n+                                     bool fast) {\n #if SANITIZER_WINDOWS\n   stack->Unwind(max_depth, pc, bp, context, 0, 0, fast);\n #else\n   AsanThread *t;\n   stack->size = 0;\n   if (LIKELY(asan_inited)) {\n     if ((t = GetCurrentThread()) && !t->isUnwinding()) {\n+      // On FreeBSD the slow unwinding that leverages _Unwind_Backtrace()\n+      // yields the call stack of the signal's handler and not of the code\n+      // that raised the signal (as it does on Linux).\n+      if (SANITIZER_FREEBSD && t->isInDeadlySignal()) fast = true;\n       uptr stack_top = t->stack_top();\n       uptr stack_bottom = t->stack_bottom();\n       ScopedUnwinding unwind_scope(t);\n@@ -51,14 +56,14 @@ void GetStackTraceWithPcBpAndContext(StackTrace *stack, uptr max_depth, uptr pc,\n // don't want stack trace to contain functions from ASan internals.\n \n #define GET_STACK_TRACE(max_size, fast)                                        \\\n-  StackTrace stack;                                                            \\\n+  BufferedStackTrace stack;                                                    \\\n   if (max_size <= 2) {                                                         \\\n     stack.size = max_size;                                                     \\\n     if (max_size > 0) {                                                        \\\n       stack.top_frame_bp = GET_CURRENT_FRAME();                                \\\n-      stack.trace[0] = StackTrace::GetCurrentPc();                             \\\n+      stack.trace_buffer[0] = StackTrace::GetCurrentPc();                      \\\n       if (max_size > 1)                                                        \\\n-        stack.trace[1] = GET_CALLER_PC();                                      \\\n+        stack.trace_buffer[1] = GET_CALLER_PC();                               \\\n     }                                                                          \\\n   } else {                                                                     \\\n     GetStackTraceWithPcBpAndContext(&stack, max_size,                          \\\n@@ -67,18 +72,21 @@ void GetStackTraceWithPcBpAndContext(StackTrace *stack, uptr max_depth, uptr pc,\n   }\n \n #define GET_STACK_TRACE_FATAL(pc, bp)                                          \\\n-  StackTrace stack;                                                            \\\n+  BufferedStackTrace stack;                                                    \\\n   GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, 0,           \\\n                                   common_flags()->fast_unwind_on_fatal)\n \n #define GET_STACK_TRACE_SIGNAL(pc, bp, context)                                \\\n-  StackTrace stack;                                                            \\\n+  BufferedStackTrace stack;                                                    \\\n   GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, context,     \\\n                                   common_flags()->fast_unwind_on_fatal)\n \n #define GET_STACK_TRACE_FATAL_HERE                                \\\n   GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_fatal)\n \n+#define GET_STACK_TRACE_CHECK_HERE                                \\\n+  GET_STACK_TRACE(kStackTraceMax, common_flags()->fast_unwind_on_check)\n+\n #define GET_STACK_TRACE_THREAD                                    \\\n   GET_STACK_TRACE(kStackTraceMax, true)\n \n@@ -94,4 +102,10 @@ void GetStackTraceWithPcBpAndContext(StackTrace *stack, uptr max_depth, uptr pc,\n     stack.Print();              \\\n   }\n \n+#define PRINT_CURRENT_STACK_CHECK() \\\n+  {                                 \\\n+    GET_STACK_TRACE_CHECK_HERE;     \\\n+    stack.Print();                  \\\n+  }\n+\n #endif  // ASAN_STACK_H"}, {"sha": "95ca67200905b3e1b662cc334bac229f661aa63d", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -28,7 +28,7 @@ namespace __asan {\n void AsanThreadContext::OnCreated(void *arg) {\n   CreateThreadContextArgs *args = static_cast<CreateThreadContextArgs*>(arg);\n   if (args->stack)\n-    stack_id = StackDepotPut(args->stack->trace, args->stack->size);\n+    stack_id = StackDepotPut(*args->stack);\n   thread = args->thread;\n   thread->set_context(this);\n }\n@@ -196,17 +196,18 @@ void AsanThread::ClearShadowForThreadStackAndTLS() {\n     PoisonShadow(tls_begin_, tls_end_ - tls_begin_, 0);\n }\n \n-const char *AsanThread::GetFrameNameByAddr(uptr addr, uptr *offset,\n-                                           uptr *frame_pc) {\n+bool AsanThread::GetStackFrameAccessByAddr(uptr addr,\n+                                           StackFrameAccess *access) {\n   uptr bottom = 0;\n   if (AddrIsInStack(addr)) {\n     bottom = stack_bottom();\n   } else if (has_fake_stack()) {\n     bottom = fake_stack()->AddrIsInFakeStack(addr);\n     CHECK(bottom);\n-    *offset = addr - bottom;\n-    *frame_pc = ((uptr*)bottom)[2];\n-    return  (const char *)((uptr*)bottom)[1];\n+    access->offset = addr - bottom;\n+    access->frame_pc = ((uptr*)bottom)[2];\n+    access->frame_descr = (const char *)((uptr*)bottom)[1];\n+    return true;\n   }\n   uptr aligned_addr = addr & ~(SANITIZER_WORDSIZE/8 - 1);  // align addr.\n   u8 *shadow_ptr = (u8*)MemToShadow(aligned_addr);\n@@ -223,15 +224,15 @@ const char *AsanThread::GetFrameNameByAddr(uptr addr, uptr *offset,\n   }\n \n   if (shadow_ptr < shadow_bottom) {\n-    *offset = 0;\n-    return \"UNKNOWN\";\n+    return false;\n   }\n \n   uptr* ptr = (uptr*)SHADOW_TO_MEM((uptr)(shadow_ptr + 1));\n   CHECK(ptr[0] == kCurrentStackFrameMagic);\n-  *offset = addr - (uptr)ptr;\n-  *frame_pc = ptr[2];\n-  return (const char*)ptr[1];\n+  access->offset = addr - (uptr)ptr;\n+  access->frame_pc = ptr[2];\n+  access->frame_descr = (const char*)ptr[1];\n+  return true;\n }\n \n static bool ThreadStackContainsAddress(ThreadContextBase *tctx_base,"}, {"sha": "f5ea53d051ff31d9cd1cf5acccc055a0c0422990", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -69,7 +69,12 @@ class AsanThread {\n   AsanThreadContext *context() { return context_; }\n   void set_context(AsanThreadContext *context) { context_ = context; }\n \n-  const char *GetFrameNameByAddr(uptr addr, uptr *offset, uptr *frame_pc);\n+  struct StackFrameAccess {\n+    uptr offset;\n+    uptr frame_pc;\n+    const char *frame_descr;\n+  };\n+  bool GetStackFrameAccessByAddr(uptr addr, StackFrameAccess *access);\n \n   bool AddrIsInStack(uptr addr) {\n     return addr >= stack_bottom_ && addr < stack_top_;\n@@ -101,6 +106,10 @@ class AsanThread {\n   bool isUnwinding() const { return unwinding_; }\n   void setUnwinding(bool b) { unwinding_ = b; }\n \n+  // True if we are in a deadly signal handler.\n+  bool isInDeadlySignal() const { return in_deadly_signal_; }\n+  void setInDeadlySignal(bool b) { in_deadly_signal_ = b; }\n+\n   AsanThreadLocalMallocStorage &malloc_storage() { return malloc_storage_; }\n   AsanStats &stats() { return stats_; }\n \n@@ -126,6 +135,7 @@ class AsanThread {\n   AsanThreadLocalMallocStorage malloc_storage_;\n   AsanStats stats_;\n   bool unwinding_;\n+  bool in_deadly_signal_;\n };\n \n // ScopedUnwinding is a scope for stacktracing member of a context\n@@ -140,6 +150,20 @@ class ScopedUnwinding {\n   AsanThread *thread;\n };\n \n+// ScopedDeadlySignal is a scope for handling deadly signals.\n+class ScopedDeadlySignal {\n+ public:\n+  explicit ScopedDeadlySignal(AsanThread *t) : thread(t) {\n+    if (thread) thread->setInDeadlySignal(true);\n+  }\n+  ~ScopedDeadlySignal() {\n+    if (thread) thread->setInDeadlySignal(false);\n+  }\n+\n+ private:\n+  AsanThread *thread;\n+};\n+\n struct CreateThreadContextArgs {\n   AsanThread *thread;\n   StackTrace *stack;"}, {"sha": "023fa29c60f8c17f570d0c4b4e04d06357deab1d", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -53,13 +53,39 @@ extern \"C\" {\n   // Otherwise returns 0.\n   int __asan_address_is_poisoned(void const volatile *addr);\n \n-  // If at least on byte in [beg, beg+size) is poisoned, return the address\n+  // If at least one byte in [beg, beg+size) is poisoned, return the address\n   // of the first such byte. Otherwise return 0.\n   void *__asan_region_is_poisoned(void *beg, size_t size);\n \n   // Print the description of addr (useful when debugging in gdb).\n   void __asan_describe_address(void *addr);\n \n+  // Useful for calling from a debugger to get information about an ASan error.\n+  // Returns 1 if an error has been (or is being) reported, otherwise returns 0.\n+  int __asan_report_present();\n+\n+  // Useful for calling from a debugger to get information about an ASan error.\n+  // If an error has been (or is being) reported, the following functions return\n+  // the pc, bp, sp, address, access type (0 = read, 1 = write), access size and\n+  // bug description (e.g. \"heap-use-after-free\"). Otherwise they return 0.\n+  void *__asan_get_report_pc();\n+  void *__asan_get_report_bp();\n+  void *__asan_get_report_sp();\n+  void *__asan_get_report_address();\n+  int __asan_get_report_access_type();\n+  size_t __asan_get_report_access_size();\n+  const char *__asan_get_report_description();\n+\n+  // Useful for calling from the debugger to get information about a pointer.\n+  // Returns the category of the given pointer as a constant string.\n+  // Possible return values are \"global\", \"stack\", \"stack-fake\", \"heap\",\n+  // \"heap-invalid\", \"shadow-low\", \"shadow-gap\", \"shadow-high\", \"unknown\".\n+  // If global or stack, tries to also return the variable name, address and\n+  // size. If heap, tries to return the chunk address and size. 'name' should\n+  // point to an allocated buffer of size 'name_size'.\n+  const char *__asan_locate_address(void *addr, char *name, size_t name_size,\n+                                    void **region_address, size_t *region_size);\n+\n   // Useful for calling from the debugger to get the allocation stack trace\n   // and thread ID for a heap address. Stores up to 'size' frames into 'trace',\n   // returns the number of stored frames or 0 on error."}, {"sha": "3aba519327eb68765462dfbf9a51349780d62f1a", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -103,7 +103,7 @@ extern \"C\" {\n                                                  const void *end,\n                                                  const void *old_mid,\n                                                  const void *new_mid);\n-  // Returns true if the contiguous container [beg, end) ir properly poisoned\n+  // Returns true if the contiguous container [beg, end) is properly poisoned\n   // (e.g. with __sanitizer_annotate_contiguous_container), i.e. if\n   //  - [beg, mid) is addressable,\n   //  - [mid, end) is unaddressable."}, {"sha": "87ee5d517d4ebdf180f27e51ae9b0cd9019a7e95", "filename": "libsanitizer/interception/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finterception%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finterception%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.am?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -6,6 +6,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fno-rtti -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros\n AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+AM_CXXFLAGS += -std=c++11\n ACLOCAL_AMFLAGS = -I m4\n \n noinst_LTLIBRARIES = libinterception.la"}, {"sha": "3bb0f12ba504e7b7255b071962124dc6d5fa3d5f", "filename": "libsanitizer/interception/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finterception%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finterception%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.in?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -225,7 +225,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n \t-Wno-long-long -fPIC -fno-builtin -fno-exceptions -fno-rtti \\\n \t-fomit-frame-pointer -funwind-tables -fvisibility=hidden \\\n-\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS) -std=c++11\n ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libinterception.la\n interception_files = \\"}, {"sha": "f9c2e9b3ad84c7570e02827c976a463823effe54", "filename": "libsanitizer/interception/interception_win.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finterception%2Finterception_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Finterception%2Finterception_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -180,7 +180,10 @@ bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func) {\n }\n \n static const void **InterestingDLLsAvailable() {\n-  const char *InterestingDLLs[] = { \"kernel32.dll\", \"msvcr120.dll\", NULL };\n+  const char *InterestingDLLs[] = {\"kernel32.dll\",\n+                                   \"msvcr110.dll\", // VS2012\n+                                   \"msvcr120.dll\", // VS2013\n+                                   NULL};\n   static void *result[ARRAY_SIZE(InterestingDLLs)] = { 0 };\n   if (!result[0]) {\n     for (size_t i = 0, j = 0; InterestingDLLs[i]; ++i) {"}, {"sha": "ec386f4e28bcd654ac042d37665ae2032c4465bd", "filename": "libsanitizer/libbacktrace/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flibbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flibbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flibbacktrace%2FMakefile.am?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -40,6 +40,7 @@ C_WARN_FLAGS = $(WARN_FLAGS) -Wstrict-prototypes -Wmissing-prototypes -Wold-styl\n CXX_WARN_FLAGS = $(WARN_FLAGS) -Wno-unused-parameter\n AM_CFLAGS = $(C_WARN_FLAGS)\n AM_CXXFLAGS = $(CXX_WARN_FLAGS) -fno-rtti -fno-exceptions\n+AM_CXXFLAGS += -std=c++11\n \n noinst_LTLIBRARIES = libsanitizer_libbacktrace.la\n "}, {"sha": "a924978776e08682a1c45fda946d96ba1a4582c1", "filename": "libsanitizer/libbacktrace/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flibbacktrace%2FMakefile.in?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -270,7 +270,7 @@ WARN_FLAGS = -W -Wall -Wwrite-strings -Wmissing-format-attribute \\\n C_WARN_FLAGS = $(WARN_FLAGS) -Wstrict-prototypes -Wmissing-prototypes -Wold-style-definition\n CXX_WARN_FLAGS = $(WARN_FLAGS) -Wno-unused-parameter\n AM_CFLAGS = $(C_WARN_FLAGS)\n-AM_CXXFLAGS = $(CXX_WARN_FLAGS) -fno-rtti -fno-exceptions\n+AM_CXXFLAGS = $(CXX_WARN_FLAGS) -fno-rtti -fno-exceptions -std=c++11\n noinst_LTLIBRARIES = libsanitizer_libbacktrace.la\n libsanitizer_libbacktrace_la_SOURCES = \\\n \t../../libbacktrace/backtrace.h \\"}, {"sha": "2db6ba2e7622cfec71d2b4eef9693b61a59eea05", "filename": "libsanitizer/lsan/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.am?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -6,6 +6,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fno-rtti -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros\n AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+AM_CXXFLAGS += -std=c++11\n ACLOCAL_AMFLAGS = -I m4\n \n noinst_LTLIBRARIES = libsanitizer_lsan.la"}, {"sha": "8ab9c685659805c49c9319c8c60c09e6e738da84", "filename": "libsanitizer/lsan/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.in?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -260,7 +260,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n \t-Wno-long-long -fPIC -fno-builtin -fno-exceptions -fno-rtti \\\n \t-fomit-frame-pointer -funwind-tables -fvisibility=hidden \\\n-\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS) -std=c++11\n ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libsanitizer_lsan.la\n @LSAN_SUPPORTED_TRUE@toolexeclib_LTLIBRARIES = liblsan.la"}, {"sha": "ee2fc02cf0824762c810cc62c0f32b4d3baf4a20", "filename": "libsanitizer/lsan/lsan.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2Flsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2Flsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -13,17 +13,17 @@\n #include \"sanitizer_common/sanitizer_flags.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n \n-#define GET_STACK_TRACE(max_size, fast)                                     \\\n-  StackTrace stack;                                                         \\\n-  {                                                                         \\\n-    uptr stack_top = 0, stack_bottom = 0;                                   \\\n-    ThreadContext *t;                                                       \\\n-    if (fast && (t = CurrentThreadContext())) {                             \\\n-      stack_top = t->stack_end();                                           \\\n-      stack_bottom = t->stack_begin();                                      \\\n-    }                                                                       \\\n-    stack.Unwind(max_size, StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(), \\\n-                 /* context */ 0, stack_top, stack_bottom, fast);           \\\n+#define GET_STACK_TRACE(max_size, fast)                                        \\\n+  BufferedStackTrace stack;                                                    \\\n+  {                                                                            \\\n+    uptr stack_top = 0, stack_bottom = 0;                                      \\\n+    ThreadContext *t;                                                          \\\n+    if (fast && (t = CurrentThreadContext())) {                                \\\n+      stack_top = t->stack_end();                                              \\\n+      stack_bottom = t->stack_begin();                                         \\\n+    }                                                                          \\\n+    stack.Unwind(max_size, StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(),    \\\n+                 /* context */ 0, stack_top, stack_bottom, fast);              \\\n   }\n \n #define GET_STACK_TRACE_FATAL \\"}, {"sha": "2d406a0f8520f79ac926753cd5570ff04e61e06c", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -61,7 +61,7 @@ static void RegisterAllocation(const StackTrace &stack, void *p, uptr size) {\n   ChunkMetadata *m = Metadata(p);\n   CHECK(m);\n   m->tag = DisabledInThisThread() ? kIgnored : kDirectlyLeaked;\n-  m->stack_trace_id = StackDepotPut(stack.trace, stack.size);\n+  m->stack_trace_id = StackDepotPut(stack);\n   m->requested_size = size;\n   atomic_store(reinterpret_cast<atomic_uint8_t *>(m), 1, memory_order_relaxed);\n }"}, {"sha": "aa79a7e41c626ea0bbf5344332039a9ba59afbc2", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -353,9 +353,7 @@ static void ClassifyAllChunks(SuspendedThreadsList const &suspended_threads) {\n \n static void PrintStackTraceById(u32 stack_trace_id) {\n   CHECK(stack_trace_id);\n-  uptr size = 0;\n-  const uptr *trace = StackDepotGet(stack_trace_id, &size);\n-  StackTrace::PrintStack(trace, size);\n+  StackDepotGet(stack_trace_id).Print();\n }\n \n // ForEachChunk callback. Aggregates information about unreachable chunks into\n@@ -370,10 +368,9 @@ static void CollectLeaksCb(uptr chunk, void *arg) {\n     uptr resolution = flags()->resolution;\n     u32 stack_trace_id = 0;\n     if (resolution > 0) {\n-      uptr size = 0;\n-      const uptr *trace = StackDepotGet(m.stack_trace_id(), &size);\n-      size = Min(size, resolution);\n-      stack_trace_id = StackDepotPut(trace, size);\n+      StackTrace stack = StackDepotGet(m.stack_trace_id());\n+      stack.size = Min(stack.size, resolution);\n+      stack_trace_id = StackDepotPut(stack);\n     } else {\n       stack_trace_id = m.stack_trace_id();\n     }\n@@ -449,8 +446,11 @@ void DoLeakCheck() {\n     PrintMatchedSuppressions();\n   if (unsuppressed_count > 0) {\n     param.leak_report.PrintSummary();\n-    if (flags()->exitcode)\n+    if (flags()->exitcode) {\n+      if (common_flags()->coverage)\n+        __sanitizer_cov_dump();\n       internal__exit(flags()->exitcode);\n+    }\n   }\n }\n \n@@ -482,11 +482,10 @@ static Suppression *GetSuppressionForAddr(uptr addr) {\n }\n \n static Suppression *GetSuppressionForStack(u32 stack_trace_id) {\n-  uptr size = 0;\n-  const uptr *trace = StackDepotGet(stack_trace_id, &size);\n-  for (uptr i = 0; i < size; i++) {\n-    Suppression *s =\n-        GetSuppressionForAddr(StackTrace::GetPreviousInstructionPc(trace[i]));\n+  StackTrace stack = StackDepotGet(stack_trace_id);\n+  for (uptr i = 0; i < stack.size; i++) {\n+    Suppression *s = GetSuppressionForAddr(\n+        StackTrace::GetPreviousInstructionPc(stack.trace[i]));\n     if (s) return s;\n   }\n   return 0;"}, {"sha": "b17156ce6bbc35f3dce8101e74ae247b42b91d26", "filename": "libsanitizer/lsan/lsan_common_linux.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2Flsan_common_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Flsan%2Flsan_common_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -92,11 +92,10 @@ void ProcessGlobalRegions(Frontier *frontier) {\n \n static uptr GetCallerPC(u32 stack_id, StackDepotReverseMap *map) {\n   CHECK(stack_id);\n-  uptr size = 0;\n-  const uptr *trace = map->Get(stack_id, &size);\n+  StackTrace stack = map->Get(stack_id);\n   // The top frame is our malloc/calloc/etc. The next frame is the caller.\n-  if (size >= 2)\n-    return trace[1];\n+  if (stack.size >= 2)\n+    return stack.trace[1];\n   return 0;\n }\n "}, {"sha": "c5da0c15119bccf7cf28167c43feee92982532f4", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -6,6 +6,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fno-rtti -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros\n AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+AM_CXXFLAGS += -std=c++11\n if LIBBACKTRACE_SUPPORTED\n AM_CXXFLAGS += -DSANITIZER_LIBBACKTRACE -DSANITIZER_CP_DEMANGLE \\\n \t       -I $(top_srcdir)/../libbacktrace \\\n@@ -44,6 +45,7 @@ sanitizer_common_files = \\\n \tsanitizer_stackdepot.cc \\\n \tsanitizer_stacktrace.cc \\\n \tsanitizer_stacktrace_libcdep.cc \\\n+\tsanitizer_stacktrace_printer.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n \tsanitizer_suppressions.cc \\\n \tsanitizer_symbolizer.cc \\"}, {"sha": "db02613eb812b21ab8fb55ec64c6dac8c0386997", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -78,6 +78,7 @@ am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n \tsanitizer_procmaps_linux.lo sanitizer_procmaps_mac.lo \\\n \tsanitizer_stackdepot.lo sanitizer_stacktrace.lo \\\n \tsanitizer_stacktrace_libcdep.lo \\\n+\tsanitizer_stacktrace_printer.lo \\\n \tsanitizer_stoptheworld_linux_libcdep.lo \\\n \tsanitizer_suppressions.lo sanitizer_symbolizer.lo \\\n \tsanitizer_symbolizer_libbacktrace.lo \\\n@@ -252,7 +253,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n \t-Wno-long-long -fPIC -fno-builtin -fno-exceptions -fno-rtti \\\n \t-fomit-frame-pointer -funwind-tables -fvisibility=hidden \\\n-\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS) \\\n+\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS) -std=c++11 \\\n \t$(am__append_1)\n ACLOCAL_AMFLAGS = -I m4\n noinst_LTLIBRARIES = libsanitizer_common.la\n@@ -283,6 +284,7 @@ sanitizer_common_files = \\\n \tsanitizer_stackdepot.cc \\\n \tsanitizer_stacktrace.cc \\\n \tsanitizer_stacktrace_libcdep.cc \\\n+\tsanitizer_stacktrace_printer.cc \\\n \tsanitizer_stoptheworld_linux_libcdep.cc \\\n \tsanitizer_suppressions.cc \\\n \tsanitizer_symbolizer.cc \\\n@@ -414,6 +416,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stacktrace_printer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stoptheworld_linux_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_suppressions.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer.Plo@am__quote@"}, {"sha": "dd5539a208716f0ad8c1022d5957d5bf0e38ff74", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -459,6 +459,11 @@ class SizeClassAllocator64 {\n     }\n   }\n \n+  static uptr AdditionalSize() {\n+    return RoundUpTo(sizeof(RegionInfo) * kNumClassesRounded,\n+                     GetPageSizeCached());\n+  }\n+\n   typedef SizeClassMap SizeClassMapT;\n   static const uptr kNumClasses = SizeClassMap::kNumClasses;\n   static const uptr kNumClassesRounded = SizeClassMap::kNumClassesRounded;\n@@ -488,11 +493,6 @@ class SizeClassAllocator64 {\n   };\n   COMPILER_CHECK(sizeof(RegionInfo) >= kCacheLineSize);\n \n-  static uptr AdditionalSize() {\n-    return RoundUpTo(sizeof(RegionInfo) * kNumClassesRounded,\n-                     GetPageSizeCached());\n-  }\n-\n   RegionInfo *GetRegionInfo(uptr class_id) {\n     CHECK_LT(class_id, kNumClasses);\n     RegionInfo *regions = reinterpret_cast<RegionInfo*>(kSpaceBeg + kSpaceSize);\n@@ -1013,12 +1013,15 @@ class LargeMmapAllocator {\n     if (map_size < size) return AllocatorReturnNull();  // Overflow.\n     uptr map_beg = reinterpret_cast<uptr>(\n         MmapOrDie(map_size, \"LargeMmapAllocator\"));\n+    CHECK(IsAligned(map_beg, page_size_));\n     MapUnmapCallback().OnMap(map_beg, map_size);\n     uptr map_end = map_beg + map_size;\n     uptr res = map_beg + page_size_;\n     if (res & (alignment - 1))  // Align.\n       res += alignment - (res & (alignment - 1));\n-    CHECK_EQ(0, res & (alignment - 1));\n+    CHECK(IsAligned(res, alignment));\n+    CHECK(IsAligned(res, page_size_));\n+    CHECK_GE(res + size, map_beg);\n     CHECK_LE(res + size, map_end);\n     Header *h = GetHeader(res);\n     h->size = size;"}, {"sha": "f06efffb3257a0c72a7b45db4b41abbdb3c8f0bb", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -153,23 +153,12 @@ const char *StripPathPrefix(const char *filepath,\n   return pos;\n }\n \n-void PrintSourceLocation(InternalScopedString *buffer, const char *file,\n-                         int line, int column) {\n-  CHECK(file);\n-  buffer->append(\"%s\",\n-                 StripPathPrefix(file, common_flags()->strip_path_prefix));\n-  if (line > 0) {\n-    buffer->append(\":%d\", line);\n-    if (column > 0)\n-      buffer->append(\":%d\", column);\n-  }\n-}\n-\n-void PrintModuleAndOffset(InternalScopedString *buffer, const char *module,\n-                          uptr offset) {\n-  buffer->append(\"(%s+0x%zx)\",\n-                 StripPathPrefix(module, common_flags()->strip_path_prefix),\n-                 offset);\n+const char *StripModuleName(const char *module) {\n+  if (module == 0)\n+    return 0;\n+  if (const char *slash_pos = internal_strrchr(module, '/'))\n+    return slash_pos + 1;\n+  return module;\n }\n \n void ReportErrorSummary(const char *error_message) {\n@@ -215,17 +204,6 @@ bool LoadedModule::containsAddress(uptr address) const {\n   return false;\n }\n \n-char *StripModuleName(const char *module) {\n-  if (module == 0)\n-    return 0;\n-  const char *short_module_name = internal_strrchr(module, '/');\n-  if (short_module_name)\n-    short_module_name += 1;\n-  else\n-    short_module_name = module;\n-  return internal_strdup(short_module_name);\n-}\n-\n static atomic_uintptr_t g_total_mmaped;\n \n void IncreaseTotalMmap(uptr size) {"}, {"sha": "a8924913872fcd7e1fc7bf49ef84e094b43d5025", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -170,10 +170,8 @@ bool IsAccessibleMemoryRange(uptr beg, uptr size);\n // Error report formatting.\n const char *StripPathPrefix(const char *filepath,\n                             const char *strip_file_prefix);\n-void PrintSourceLocation(InternalScopedString *buffer, const char *file,\n-                         int line, int column);\n-void PrintModuleAndOffset(InternalScopedString *buffer,\n-                          const char *module, uptr offset);\n+// Strip the directories from the module name.\n+const char *StripModuleName(const char *module);\n \n // OS\n void DisableCoreDumperIfNecessary();\n@@ -207,9 +205,6 @@ void SleepForMillis(int millis);\n u64 NanoTime();\n int Atexit(void (*function)(void));\n void SortArray(uptr *array, uptr size);\n-// Strip the directories from the module name, return a new string allocated\n-// with internal_strdup.\n-char *StripModuleName(const char *module);\n \n // Exit\n void NORETURN Abort();"}, {"sha": "10f321838e82b097194b65a45372c79b0022f4e6", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -39,6 +39,10 @@\n #define va_copy(dst, src) ((dst) = (src))\n #endif // _WIN32\n \n+#if SANITIZER_FREEBSD\n+#define pthread_setname_np pthread_set_name_np\n+#endif\n+\n #ifndef COMMON_INTERCEPTOR_INITIALIZE_RANGE\n #define COMMON_INTERCEPTOR_INITIALIZE_RANGE(p, size) {}\n #endif"}, {"sha": "214e8a98d0f5ed60b2b098aac1b359e85545dad6", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep.cc", "status": "modified", "additions": 95, "deletions": 2, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -36,6 +36,7 @@\n #include \"sanitizer_mutex.h\"\n #include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_symbolizer.h\"\n #include \"sanitizer_flags.h\"\n \n atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n@@ -61,6 +62,9 @@ class CoverageData {\n   void AfterFork(int child_pid);\n   void Extend(uptr npcs);\n   void Add(uptr pc);\n+  void IndirCall(uptr caller, uptr callee, uptr callee_cache[],\n+                 uptr cache_size);\n+  void DumpCallerCalleePairs();\n \n   uptr *data();\n   uptr size();\n@@ -83,6 +87,14 @@ class CoverageData {\n   uptr pc_array_mapped_size;\n   // Descriptor of the file mapped pc array.\n   int pc_fd;\n+\n+  // Caller-Callee (cc) array, size and current index.\n+  static const uptr kCcArrayMaxSize = FIRST_32_SECOND_64(1 << 18, 1 << 24);\n+  uptr **cc_array;\n+  atomic_uintptr_t cc_array_index;\n+  atomic_uintptr_t cc_array_size;\n+\n+\n   StaticSpinMutex mu;\n \n   void DirectOpen();\n@@ -116,6 +128,11 @@ void CoverageData::Init() {\n     atomic_store(&pc_array_size, kPcArrayMaxSize, memory_order_relaxed);\n     atomic_store(&pc_array_index, 0, memory_order_relaxed);\n   }\n+\n+  cc_array = reinterpret_cast<uptr **>(MmapNoReserveOrDie(\n+      sizeof(uptr *) * kCcArrayMaxSize, \"CovInit::cc_array\"));\n+  atomic_store(&cc_array_size, kCcArrayMaxSize, memory_order_relaxed);\n+  atomic_store(&cc_array_index, 0, memory_order_relaxed);\n }\n \n void CoverageData::ReInit() {\n@@ -184,6 +201,38 @@ void CoverageData::Add(uptr pc) {\n   pc_array[idx] = pc;\n }\n \n+// Registers a pair caller=>callee.\n+// When a given caller is seen for the first time, the callee_cache is added\n+// to the global array cc_array, callee_cache[0] is set to caller and\n+// callee_cache[1] is set to cache_size.\n+// Then we are trying to add callee to callee_cache [2,cache_size) if it is\n+// not there yet.\n+// If the cache is full we drop the callee (may want to fix this later).\n+void CoverageData::IndirCall(uptr caller, uptr callee, uptr callee_cache[],\n+                             uptr cache_size) {\n+  if (!cc_array) return;\n+  atomic_uintptr_t *atomic_callee_cache =\n+      reinterpret_cast<atomic_uintptr_t *>(callee_cache);\n+  uptr zero = 0;\n+  if (atomic_compare_exchange_strong(&atomic_callee_cache[0], &zero, caller,\n+                                     memory_order_seq_cst)) {\n+    uptr idx = atomic_fetch_add(&cc_array_index, 1, memory_order_relaxed);\n+    CHECK_LT(idx * sizeof(uptr),\n+             atomic_load(&cc_array_size, memory_order_acquire));\n+    callee_cache[1] = cache_size;\n+    cc_array[idx] = callee_cache;\n+  }\n+  CHECK_EQ(atomic_load(&atomic_callee_cache[0], memory_order_relaxed), caller);\n+  for (uptr i = 2; i < cache_size; i++) {\n+    uptr was = 0;\n+    if (atomic_compare_exchange_strong(&atomic_callee_cache[i], &was, callee,\n+                                       memory_order_seq_cst))\n+      return;\n+    if (was == callee)  // Already have this callee.\n+      return;\n+  }\n+}\n+\n uptr *CoverageData::data() {\n   return pc_array;\n }\n@@ -266,6 +315,45 @@ static int CovOpenFile(bool packed, const char* name) {\n   return fd;\n }\n \n+// This function dumps the caller=>callee pairs into a file as a sequence of\n+// lines like \"module_name offset\".\n+void CoverageData::DumpCallerCalleePairs() {\n+  uptr max_idx = atomic_load(&cc_array_index, memory_order_relaxed);\n+  if (!max_idx) return;\n+  auto sym = Symbolizer::GetOrInit();\n+  if (!sym)\n+    return;\n+  InternalScopedString out(32 << 20);\n+  uptr total = 0;\n+  for (uptr i = 0; i < max_idx; i++) {\n+    uptr *cc_cache = cc_array[i];\n+    CHECK(cc_cache);\n+    uptr caller = cc_cache[0];\n+    uptr n_callees = cc_cache[1];\n+    const char *caller_module_name = \"<unknown>\";\n+    uptr caller_module_address = 0;\n+    sym->GetModuleNameAndOffsetForPC(caller, &caller_module_name,\n+                                     &caller_module_address);\n+    for (uptr j = 2; j < n_callees; j++) {\n+      uptr callee = cc_cache[j];\n+      if (!callee) break;\n+      total++;\n+      const char *callee_module_name = \"<unknown>\";\n+      uptr callee_module_address = 0;\n+      sym->GetModuleNameAndOffsetForPC(callee, &callee_module_name,\n+                                       &callee_module_address);\n+      out.append(\"%s 0x%zx\\n%s 0x%zx\\n\", caller_module_name,\n+                 caller_module_address, callee_module_name,\n+                 callee_module_address);\n+    }\n+  }\n+  int fd = CovOpenFile(false, \"caller-callee\");\n+  if (fd < 0) return;\n+  internal_write(fd, out.data(), out.length());\n+  internal_close(fd);\n+  VReport(1, \" CovDump: %zd caller-callee pairs written\\n\", total);\n+}\n+\n // Dump the coverage on disk.\n static void CovDump() {\n   if (!common_flags()->coverage || common_flags()->coverage_direct) return;\n@@ -297,7 +385,7 @@ static void CovDump() {\n         CHECK_LE(diff, 0xffffffffU);\n         offsets.push_back(static_cast<u32>(diff));\n       }\n-      char *module_name = StripModuleName(module.data());\n+      const char *module_name = StripModuleName(module.data());\n       if (cov_sandboxed) {\n         if (cov_fd >= 0) {\n           CovWritePacked(internal_getpid(), module_name, offsets.data(),\n@@ -317,11 +405,11 @@ static void CovDump() {\n                   vb - old_vb);\n         }\n       }\n-      InternalFree(module_name);\n     }\n   }\n   if (cov_fd >= 0)\n     internal_close(cov_fd);\n+  coverage_data.DumpCallerCalleePairs();\n #endif  // !SANITIZER_WINDOWS\n }\n \n@@ -357,6 +445,11 @@ extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov() {\n   coverage_data.Add(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()));\n }\n+SANITIZER_INTERFACE_ATTRIBUTE void\n+__sanitizer_cov_indir_call16(uptr callee, uptr callee_cache16[]) {\n+  coverage_data.IndirCall(StackTrace::GetPreviousInstructionPc(GET_CALLER_PC()),\n+                          callee, callee_cache16, 16);\n+}\n SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_dump() { CovDump(); }\n SANITIZER_INTERFACE_ATTRIBUTE void __sanitizer_cov_init() {\n   coverage_data.Init();"}, {"sha": "b88814b8167cbe70572836d23434da985316690e", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_mapping_libcdep.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -78,7 +78,7 @@ void CovUpdateMapping(uptr caller_pc) {\n \n   text.append(\"%d\\n\", sizeof(uptr) * 8);\n   for (int i = 0; i < n_modules; ++i) {\n-    char *module_name = StripModuleName(modules[i].full_name());\n+    const char *module_name = StripModuleName(modules[i].full_name());\n     for (unsigned j = 0; j < modules[i].n_ranges(); ++j) {\n       if (modules[i].address_range_executable(j)) {\n         uptr start = modules[i].address_range_start(j);\n@@ -89,7 +89,6 @@ void CovUpdateMapping(uptr caller_pc) {\n           cached_mapping.SetModuleRange(start, end);\n       }\n     }\n-    InternalFree(module_name);\n   }\n \n   int err;"}, {"sha": "d7e7118212e30b95d78e2a070a303bb6685995d5", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -37,6 +37,7 @@ void SetCommonFlagsDefaults(CommonFlags *f) {\n   f->external_symbolizer_path = 0;\n   f->allow_addr2line = false;\n   f->strip_path_prefix = \"\";\n+  f->fast_unwind_on_check = false;\n   f->fast_unwind_on_fatal = false;\n   f->fast_unwind_on_malloc = true;\n   f->handle_ioctl = false;\n@@ -64,6 +65,8 @@ void SetCommonFlagsDefaults(CommonFlags *f) {\n   f->suppressions = \"\";\n   f->print_suppressions = true;\n   f->disable_coredump = (SANITIZER_WORDSIZE == 64);\n+  f->symbolize_inline_frames = true;\n+  f->stack_trace_format = \"DEFAULT\";\n }\n \n void ParseCommonFlagsFromString(CommonFlags *f, const char *str) {\n@@ -79,6 +82,9 @@ void ParseCommonFlagsFromString(CommonFlags *f, const char *str) {\n       \"unavailable.\");\n   ParseFlag(str, &f->strip_path_prefix, \"strip_path_prefix\",\n       \"Strips this prefix from file paths in error reports.\");\n+  ParseFlag(str, &f->fast_unwind_on_check, \"fast_unwind_on_check\",\n+      \"If available, use the fast frame-pointer-based unwinder on \"\n+      \"internal CHECK failures.\");\n   ParseFlag(str, &f->fast_unwind_on_fatal, \"fast_unwind_on_fatal\",\n       \"If available, use the fast frame-pointer-based unwinder on fatal \"\n       \"errors.\");\n@@ -152,6 +158,12 @@ void ParseCommonFlagsFromString(CommonFlags *f, const char *str) {\n       \"Disable core dumping. By default, disable_core=1 on 64-bit to avoid \"\n       \"dumping a 16T+ core file. Ignored on OSes that don't dump core by\"\n       \"default and for sanitizers that don't reserve lots of virtual memory.\");\n+  ParseFlag(str, &f->symbolize_inline_frames, \"symbolize_inline_frames\",\n+            \"Print inlined frames in stacktraces. Defaults to true.\");\n+  ParseFlag(str, &f->stack_trace_format, \"stack_trace_format\",\n+            \"Format string used to render stack frames. \"\n+            \"See sanitizer_stacktrace_printer.h for the format description. \"\n+            \"Use DEFAULT to get default format.\");\n \n   // Do a sanity check for certain flags.\n   if (f->malloc_context_size < 1)"}, {"sha": "b7a501318117753c49f8af3403533d2ce05561aa", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -30,6 +30,7 @@ struct CommonFlags {\n   const char *external_symbolizer_path;\n   bool allow_addr2line;\n   const char *strip_path_prefix;\n+  bool fast_unwind_on_check;\n   bool fast_unwind_on_fatal;\n   bool fast_unwind_on_malloc;\n   bool handle_ioctl;\n@@ -58,6 +59,8 @@ struct CommonFlags {\n   const char *suppressions;\n   bool print_suppressions;\n   bool disable_coredump;\n+  bool symbolize_inline_frames;\n+  const char *stack_trace_format;\n };\n \n inline CommonFlags *common_flags() {"}, {"sha": "17b931cb535d52f39bf6540956e91cb620382390", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -158,7 +158,7 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   // pthread_get_stacksize_np() returns an incorrect stack size for the main\n   // thread on Mavericks. See\n   // https://code.google.com/p/address-sanitizer/issues/detail?id=261\n-  if ((GetMacosVersion() == MACOS_VERSION_MAVERICKS) && at_initialization &&\n+  if ((GetMacosVersion() >= MACOS_VERSION_MAVERICKS) && at_initialization &&\n       stacksize == (1 << 19))  {\n     struct rlimit rl;\n     CHECK_EQ(getrlimit(RLIMIT_STACK, &rl), 0);\n@@ -295,6 +295,7 @@ MacosVersion GetMacosVersionInternal() {\n         case '1': return MACOS_VERSION_LION;\n         case '2': return MACOS_VERSION_MOUNTAIN_LION;\n         case '3': return MACOS_VERSION_MAVERICKS;\n+        case '4': return MACOS_VERSION_YOSEMITE;\n         default: return MACOS_VERSION_UNKNOWN;\n       }\n     }"}, {"sha": "47739f71c3c62309f214323dc7891e96dfd72666", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -23,7 +23,8 @@ enum MacosVersion {\n   MACOS_VERSION_SNOW_LEOPARD,\n   MACOS_VERSION_LION,\n   MACOS_VERSION_MOUNTAIN_LION,\n-  MACOS_VERSION_MAVERICKS\n+  MACOS_VERSION_MAVERICKS,\n+  MACOS_VERSION_YOSEMITE,\n };\n \n MacosVersion GetMacosVersion();"}, {"sha": "7064b7166b0df10032e1829f5a7d5fe68e699b7a", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -47,7 +47,7 @@\n # define SANITIZER_WINDOWS 0\n #endif\n \n-#if defined(__ANDROID__) || defined(ANDROID)\n+#if defined(__ANDROID__)\n # define SANITIZER_ANDROID 1\n #else\n # define SANITIZER_ANDROID 0\n@@ -79,7 +79,7 @@\n // For such platforms build this code with -DSANITIZER_CAN_USE_ALLOCATOR64=0 or\n // change the definition of SANITIZER_CAN_USE_ALLOCATOR64 here.\n #ifndef SANITIZER_CAN_USE_ALLOCATOR64\n-# if defined(__aarch64__)\n+# if defined(__aarch64__) || defined(__mips64)\n #  define SANITIZER_CAN_USE_ALLOCATOR64 0\n # else\n #  define SANITIZER_CAN_USE_ALLOCATOR64 (SANITIZER_WORDSIZE == 64)\n@@ -107,4 +107,10 @@\n # endif\n #endif\n \n+#ifdef __mips__\n+# define SANITIZER_POINTER_FORMAT_LENGTH FIRST_32_SECOND_64(8, 10)\n+#else\n+# define SANITIZER_POINTER_FORMAT_LENGTH FIRST_32_SECOND_64(8, 12)\n+#endif\n+\n #endif // SANITIZER_PLATFORM_H"}, {"sha": "fc2d7ba990c492dc5d03ce12283802b5d4129f13", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -204,7 +204,8 @@\n #define SANITIZER_INTERCEPT__EXIT SI_LINUX || SI_FREEBSD\n \n #define SANITIZER_INTERCEPT_PHTREAD_MUTEX SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP \\\n+  SI_FREEBSD || SI_LINUX_NOT_ANDROID\n \n #define SANITIZER_INTERCEPT_TLS_GET_ADDR SI_LINUX_NOT_ANDROID\n \n@@ -226,7 +227,8 @@\n #define SANITIZER_INTERCEPT_OBSTACK SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_FFLUSH SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_FCLOSE SI_NOT_WINDOWS\n-#define SANITIZER_INTERCEPT_DLOPEN_DLCLOSE SI_LINUX_NOT_ANDROID || SI_MAC\n+#define SANITIZER_INTERCEPT_DLOPEN_DLCLOSE \\\n+    SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_MAC\n #define SANITIZER_INTERCEPT_GETPASS SI_LINUX_NOT_ANDROID || SI_MAC\n #define SANITIZER_INTERCEPT_TIMERFD SI_LINUX_NOT_ANDROID\n "}, {"sha": "8779d8adf7274ac09d530f3577a203468f12d1b4", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -36,7 +36,6 @@\n #define uid_t __kernel_uid_t\n #define gid_t __kernel_gid_t\n #define off_t __kernel_off_t\n-#define time_t __kernel_time_t\n // This header seems to contain the definitions of _kernel_ stat* structs.\n #include <asm/stat.h>\n #undef ino_t\n@@ -61,7 +60,7 @@ namespace __sanitizer {\n }  // namespace __sanitizer\n \n #if !defined(__powerpc64__) && !defined(__x86_64__) && !defined(__aarch64__)\\\n-                            && !defined(__mips__) && !defined(__sparc__)\n+                            && !defined(__mips__)\n COMPILER_CHECK(struct___old_kernel_stat_sz == sizeof(struct __old_kernel_stat));\n #endif\n "}, {"sha": "13d908e9f8c3ef5b5e93e1601a8600a27372a26e", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -13,7 +13,19 @@\n \n #include \"sanitizer_platform.h\"\n #if SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_MAC\n-\n+// Tests in this file assume that off_t-dependent data structures match the\n+// libc ABI. For example, struct dirent here is what readdir() function (as\n+// exported from libc) returns, and not the user-facing \"dirent\", which\n+// depends on _FILE_OFFSET_BITS setting.\n+// To get this \"true\" dirent definition, we undefine _FILE_OFFSET_BITS below.\n+#ifdef _FILE_OFFSET_BITS\n+#undef _FILE_OFFSET_BITS\n+#endif\n+#if SANITIZER_FREEBSD\n+#define _WANT_RTENTRY\n+#include <sys/param.h>\n+#include <sys/socketvar.h>\n+#endif\n #include <arpa/inet.h>\n #include <dirent.h>\n #include <errno.h>\n@@ -551,7 +563,9 @@ namespace __sanitizer {\n   unsigned IOCTL_PPPIOCSMAXCID = PPPIOCSMAXCID;\n   unsigned IOCTL_PPPIOCSMRU = PPPIOCSMRU;\n   unsigned IOCTL_PPPIOCSXASYNCMAP = PPPIOCSXASYNCMAP;\n+  unsigned IOCTL_SIOCADDRT = SIOCADDRT;\n   unsigned IOCTL_SIOCDARP = SIOCDARP;\n+  unsigned IOCTL_SIOCDELRT = SIOCDELRT;\n   unsigned IOCTL_SIOCDRARP = SIOCDRARP;\n   unsigned IOCTL_SIOCGARP = SIOCGARP;\n   unsigned IOCTL_SIOCGIFENCAP = SIOCGIFENCAP;\n@@ -637,8 +651,6 @@ namespace __sanitizer {\n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n   unsigned IOCTL_MTIOCGET = MTIOCGET;\n   unsigned IOCTL_MTIOCTOP = MTIOCTOP;\n-  unsigned IOCTL_SIOCADDRT = SIOCADDRT;\n-  unsigned IOCTL_SIOCDELRT = SIOCDELRT;\n   unsigned IOCTL_SNDCTL_DSP_GETBLKSIZE = SNDCTL_DSP_GETBLKSIZE;\n   unsigned IOCTL_SNDCTL_DSP_GETFMTS = SNDCTL_DSP_GETFMTS;\n   unsigned IOCTL_SNDCTL_DSP_NONBLOCK = SNDCTL_DSP_NONBLOCK;"}, {"sha": "139fe0a1821563ee44a15cd3334e1c0c05ab85c5", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 3, "deletions": 58, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -72,14 +72,6 @@ namespace __sanitizer {\n   const unsigned struct_kernel_stat_sz = 144;\n   #endif\n   const unsigned struct_kernel_stat64_sz = 104;\n-#elif defined(__sparc__) && defined(__arch64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n-  const unsigned struct_kernel_stat_sz = 104;\n-  const unsigned struct_kernel_stat64_sz = 144;\n-#elif defined(__sparc__) && !defined(__arch64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n-  const unsigned struct_kernel_stat_sz = 64;\n-  const unsigned struct_kernel_stat64_sz = 104;\n #endif\n   struct __sanitizer_perf_event_attr {\n     unsigned type;\n@@ -102,7 +94,7 @@ namespace __sanitizer {\n \n #if defined(__powerpc64__)\n   const unsigned struct___old_kernel_stat_sz = 0;\n-#elif !defined(__sparc__)\n+#else\n   const unsigned struct___old_kernel_stat_sz = 32;\n #endif\n \n@@ -181,18 +173,6 @@ namespace __sanitizer {\n     unsigned short __pad1;\n     unsigned long __unused1;\n     unsigned long __unused2;\n-#elif defined(__sparc__)\n-# if defined(__arch64__)\n-    unsigned mode;\n-    unsigned short __pad1;\n-# else\n-    unsigned short __pad1;\n-    unsigned short mode;\n-    unsigned short __pad2;\n-# endif\n-    unsigned short __seq;\n-    unsigned long long __unused1;\n-    unsigned long long __unused2;\n #else\n     unsigned short mode;\n     unsigned short __pad1;\n@@ -210,26 +190,6 @@ namespace __sanitizer {\n \n   struct __sanitizer_shmid_ds {\n     __sanitizer_ipc_perm shm_perm;\n-  #if defined(__sparc__)\n-  # if !defined(__arch64__)\n-    u32 __pad1;\n-  # endif\n-    long shm_atime;\n-  # if !defined(__arch64__)\n-    u32 __pad2;\n-  # endif\n-    long shm_dtime;\n-  # if !defined(__arch64__)\n-    u32 __pad3;\n-  # endif\n-    long shm_ctime;\n-    uptr shm_segsz;\n-    int shm_cpid;\n-    int shm_lpid;\n-    unsigned long shm_nattch;\n-    unsigned long __glibc_reserved1;\n-    unsigned long __glibc_reserved2;\n-  #else    \n   #ifndef __powerpc__\n     uptr shm_segsz;\n   #elif !defined(__powerpc64__)\n@@ -267,7 +227,6 @@ namespace __sanitizer {\n     uptr __unused4;\n     uptr __unused5;\n   #endif\n-#endif\n   };\n #elif SANITIZER_FREEBSD\n   struct __sanitizer_ipc_perm {\n@@ -511,7 +470,7 @@ namespace __sanitizer {\n   typedef long __sanitizer___kernel_off_t;\n #endif\n \n-#if defined(__powerpc__) || defined(__aarch64__) || defined(__mips__)\n+#if defined(__powerpc__) || defined(__mips__)\n   typedef unsigned int __sanitizer___kernel_old_uid_t;\n   typedef unsigned int __sanitizer___kernel_old_gid_t;\n #else\n@@ -564,13 +523,9 @@ namespace __sanitizer {\n #else\n     __sanitizer_sigset_t sa_mask;\n #ifndef __mips__\n-#if defined(__sparc__)\n-    unsigned long sa_flags;\n-#else\n     int sa_flags;\n #endif\n #endif\n-#endif\n #if SANITIZER_LINUX\n     void (*sa_restorer)();\n #endif\n@@ -790,7 +745,7 @@ struct __sanitizer_obstack {\n \n #define IOC_NRBITS 8\n #define IOC_TYPEBITS 8\n-#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__) || defined(__sparc__)\n+#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__)\n #define IOC_SIZEBITS 13\n #define IOC_DIRBITS 3\n #define IOC_NONE 1U\n@@ -820,17 +775,7 @@ struct __sanitizer_obstack {\n #define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n #define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n #define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n-\n-#if defined(__sparc__)\n-// In sparc the 14 bits SIZE field overlaps with the\n-// least significant bit of DIR, so either IOC_READ or\n-// IOC_WRITE shall be 1 in order to get a non-zero SIZE.\n-# define IOC_SIZE(nr)                       \\\n-  ((((((nr) >> 29) & 0x7) & (4U|2U)) == 0)? \\\n-   0 : (((nr) >> 16) & 0x3fff))\n-#else\n #define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n-#endif\n \n   extern unsigned struct_arpreq_sz;\n   extern unsigned struct_ifreq_sz;"}, {"sha": "229870e00dc34db6d3d9ede7ff7978afb33cd2ff", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -82,9 +82,12 @@ uptr GetMaxVirtualAddress() {\n   // one of 0x00000fffffffffffUL and 0x00003fffffffffffUL.\n   // Note that with 'ulimit -s unlimited' the stack is moved away from the top\n   // of the address space, so simply checking the stack address is not enough.\n-  return (1ULL << 44) - 1;  // 0x00000fffffffffffUL\n+  // This should (does) work for both PowerPC64 Endian modes.\n+  return (1ULL << (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1)) - 1;\n # elif defined(__aarch64__)\n   return (1ULL << 39) - 1;\n+# elif defined(__mips64)\n+  return (1ULL << 40) - 1;\n # else\n   return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n # endif"}, {"sha": "599f2c5d7c6136b0d86afda763b8fbb91e17f5bd", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -111,7 +111,7 @@ static int AppendPointer(char **buff, const char *buff_end, u64 ptr_value) {\n   int result = 0;\n   result += AppendString(buff, buff_end, -1, \"0x\");\n   result += AppendUnsigned(buff, buff_end, ptr_value, 16,\n-                           (SANITIZER_WORDSIZE == 64) ? 12 : 8, true);\n+                           SANITIZER_POINTER_FORMAT_LENGTH, true);\n   return result;\n }\n "}, {"sha": "a3c9c0677e247a908de4868b0081f81850e50769", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.cc", "status": "modified", "additions": 38, "deletions": 51, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -16,31 +16,6 @@\n \n namespace __sanitizer {\n \n-struct StackDepotDesc {\n-  const uptr *stack;\n-  uptr size;\n-  u32 hash() const {\n-    // murmur2\n-    const u32 m = 0x5bd1e995;\n-    const u32 seed = 0x9747b28c;\n-    const u32 r = 24;\n-    u32 h = seed ^ (size * sizeof(uptr));\n-    for (uptr i = 0; i < size; i++) {\n-      u32 k = stack[i];\n-      k *= m;\n-      k ^= k >> r;\n-      k *= m;\n-      h *= m;\n-      h ^= k;\n-    }\n-    h ^= h >> 13;\n-    h *= m;\n-    h ^= h >> 15;\n-    return h;\n-  }\n-  bool is_valid() { return size > 0 && stack; }\n-};\n-\n struct StackDepotNode {\n   StackDepotNode *link;\n   u32 id;\n@@ -56,28 +31,49 @@ struct StackDepotNode {\n   static const u32 kUseCountMask = (1 << kUseCountBits) - 1;\n   static const u32 kHashMask = ~kUseCountMask;\n \n-  typedef StackDepotDesc args_type;\n+  typedef StackTrace args_type;\n   bool eq(u32 hash, const args_type &args) const {\n     u32 hash_bits =\n         atomic_load(&hash_and_use_count, memory_order_relaxed) & kHashMask;\n     if ((hash & kHashMask) != hash_bits || args.size != size) return false;\n     uptr i = 0;\n     for (; i < size; i++) {\n-      if (stack[i] != args.stack[i]) return false;\n+      if (stack[i] != args.trace[i]) return false;\n     }\n     return true;\n   }\n   static uptr storage_size(const args_type &args) {\n     return sizeof(StackDepotNode) + (args.size - 1) * sizeof(uptr);\n   }\n+  static u32 hash(const args_type &args) {\n+    // murmur2\n+    const u32 m = 0x5bd1e995;\n+    const u32 seed = 0x9747b28c;\n+    const u32 r = 24;\n+    u32 h = seed ^ (args.size * sizeof(uptr));\n+    for (uptr i = 0; i < args.size; i++) {\n+      u32 k = args.trace[i];\n+      k *= m;\n+      k ^= k >> r;\n+      k *= m;\n+      h *= m;\n+      h ^= k;\n+    }\n+    h ^= h >> 13;\n+    h *= m;\n+    h ^= h >> 15;\n+    return h;\n+  }\n+  static bool is_valid(const args_type &args) {\n+    return args.size > 0 && args.trace;\n+  }\n   void store(const args_type &args, u32 hash) {\n     atomic_store(&hash_and_use_count, hash & kHashMask, memory_order_relaxed);\n     size = args.size;\n-    internal_memcpy(stack, args.stack, size * sizeof(uptr));\n+    internal_memcpy(stack, args.trace, size * sizeof(uptr));\n   }\n   args_type load() const {\n-    args_type ret = {&stack[0], size};\n-    return ret;\n+    return args_type(&stack[0], size);\n   }\n   StackDepotHandle get_handle() { return StackDepotHandle(this); }\n \n@@ -97,8 +93,6 @@ void StackDepotHandle::inc_use_count_unsafe() {\n       StackDepotNode::kUseCountMask;\n   CHECK_LT(prev + 1, StackDepotNode::kMaxUseCount);\n }\n-uptr StackDepotHandle::size() { return node_->size; }\n-uptr *StackDepotHandle::stack() { return &node_->stack[0]; }\n \n // FIXME(dvyukov): this single reserved bit is used in TSan.\n typedef StackDepotBase<StackDepotNode, 1, StackDepotNode::kTabSizeLog>\n@@ -109,21 +103,17 @@ StackDepotStats *StackDepotGetStats() {\n   return theDepot.GetStats();\n }\n \n-u32 StackDepotPut(const uptr *stack, uptr size) {\n-  StackDepotDesc desc = {stack, size};\n-  StackDepotHandle h = theDepot.Put(desc);\n+u32 StackDepotPut(StackTrace stack) {\n+  StackDepotHandle h = theDepot.Put(stack);\n   return h.valid() ? h.id() : 0;\n }\n \n-StackDepotHandle StackDepotPut_WithHandle(const uptr *stack, uptr size) {\n-  StackDepotDesc desc = {stack, size};\n-  return theDepot.Put(desc);\n+StackDepotHandle StackDepotPut_WithHandle(StackTrace stack) {\n+  return theDepot.Put(stack);\n }\n \n-const uptr *StackDepotGet(u32 id, uptr *size) {\n-  StackDepotDesc desc = theDepot.Get(id);\n-  *size = desc.size;\n-  return desc.stack;\n+StackTrace StackDepotGet(u32 id) {\n+  return theDepot.Get(id);\n }\n \n void StackDepotLockAll() {\n@@ -154,18 +144,15 @@ StackDepotReverseMap::StackDepotReverseMap()\n   InternalSort(&map_, map_.size(), IdDescPair::IdComparator);\n }\n \n-const uptr *StackDepotReverseMap::Get(u32 id, uptr *size) {\n-  if (!map_.size()) return 0;\n+StackTrace StackDepotReverseMap::Get(u32 id) {\n+  if (!map_.size())\n+    return StackTrace();\n   IdDescPair pair = {id, 0};\n   uptr idx = InternalBinarySearch(map_, 0, map_.size(), pair,\n                                   IdDescPair::IdComparator);\n-  if (idx > map_.size()) {\n-    *size = 0;\n-    return 0;\n-  }\n-  StackDepotNode *desc = map_[idx].desc;\n-  *size = desc->size;\n-  return desc->stack;\n+  if (idx > map_.size())\n+    return StackTrace();\n+  return map_[idx].desc->load();\n }\n \n }  // namespace __sanitizer"}, {"sha": "aad9bfb8d358f5b1f8ce8b1924b5e2875d953823", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepot.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepot.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -13,6 +13,7 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_stacktrace.h\"\n \n namespace __sanitizer {\n \n@@ -26,17 +27,15 @@ struct StackDepotHandle {\n   u32 id();\n   int use_count();\n   void inc_use_count_unsafe();\n-  uptr size();\n-  uptr *stack();\n };\n \n const int kStackDepotMaxUseCount = 1U << 20;\n \n StackDepotStats *StackDepotGetStats();\n-u32 StackDepotPut(const uptr *stack, uptr size);\n-StackDepotHandle StackDepotPut_WithHandle(const uptr *stack, uptr size);\n+u32 StackDepotPut(StackTrace stack);\n+StackDepotHandle StackDepotPut_WithHandle(StackTrace stack);\n // Retrieves a stored stack trace by the id.\n-const uptr *StackDepotGet(u32 id, uptr *size);\n+StackTrace StackDepotGet(u32 id);\n \n void StackDepotLockAll();\n void StackDepotUnlockAll();\n@@ -48,7 +47,7 @@ void StackDepotUnlockAll();\n class StackDepotReverseMap {\n  public:\n   StackDepotReverseMap();\n-  const uptr *Get(u32 id, uptr *size);\n+  StackTrace Get(u32 id);\n \n  private:\n   struct IdDescPair {"}, {"sha": "05b63092b8051b57dedff99f50cd27fb4f2dc3c9", "filename": "libsanitizer/sanitizer_common/sanitizer_stackdepotbase.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stackdepotbase.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -95,8 +95,8 @@ typename StackDepotBase<Node, kReservedBits, kTabSizeLog>::handle_type\n StackDepotBase<Node, kReservedBits, kTabSizeLog>::Put(args_type args,\n                                                       bool *inserted) {\n   if (inserted) *inserted = false;\n-  if (!args.is_valid()) return handle_type();\n-  uptr h = args.hash();\n+  if (!Node::is_valid(args)) return handle_type();\n+  uptr h = Node::hash(args);\n   atomic_uintptr_t *p = &tab[h % kTabSize];\n   uptr v = atomic_load(p, memory_order_consume);\n   Node *s = (Node *)(v & ~1);"}, {"sha": "9b99b5bb201e3236a18f8735495e5b5bbe352efd", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -23,7 +23,7 @@ uptr StackTrace::GetPreviousInstructionPc(uptr pc) {\n #if defined(__powerpc__) || defined(__powerpc64__)\n   // PCs are always 4 byte aligned.\n   return pc - 4;\n-#elif defined(__sparc__)\n+#elif defined(__sparc__) || defined(__mips__)\n   return pc - 8;\n #else\n   return pc - 1;\n@@ -34,6 +34,15 @@ uptr StackTrace::GetCurrentPc() {\n   return GET_CALLER_PC();\n }\n \n+void BufferedStackTrace::Init(const uptr *pcs, uptr cnt, uptr extra_top_pc) {\n+  size = cnt + !!extra_top_pc;\n+  CHECK_LE(size, kStackTraceMax);\n+  internal_memcpy(trace_buffer, pcs, cnt * sizeof(trace_buffer[0]));\n+  if (extra_top_pc)\n+    trace_buffer[cnt] = extra_top_pc;\n+  top_frame_bp = 0;\n+}\n+\n // Check if given pointer points into allocated stack area.\n static inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {\n   return frame > stack_bottom && frame < stack_top - 2 * sizeof (uhwptr);\n@@ -49,48 +58,56 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   if (!IsValidFrame(bp, stack_top, stack_bottom)) return 0;\n   uhwptr *bp_prev = (uhwptr *)bp;\n   if (IsValidFrame((uptr)bp_prev[0], stack_top, stack_bottom)) return bp_prev;\n-  return bp_prev - 1;\n+  // The next frame pointer does not look right. This could be a GCC frame, step\n+  // back by 1 word and try again.\n+  if (IsValidFrame((uptr)bp_prev[-1], stack_top, stack_bottom))\n+    return bp_prev - 1;\n+  // Nope, this does not look right either. This means the frame after next does\n+  // not have a valid frame pointer, but we can still extract the caller PC.\n+  // Unfortunately, there is no way to decide between GCC and LLVM frame\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n }\n \n-void StackTrace::FastUnwindStack(uptr pc, uptr bp,\n-                                 uptr stack_top, uptr stack_bottom,\n-                                 uptr max_depth) {\n+void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n+                                         uptr stack_bottom, uptr max_depth) {\n   CHECK_GE(max_depth, 2);\n-  trace[0] = pc;\n+  trace_buffer[0] = pc;\n   size = 1;\n   if (stack_top < 4096) return;  // Sanity check for stack top.\n   uhwptr *frame = GetCanonicFrame(bp, stack_top, stack_bottom);\n-  uhwptr *prev_frame = 0;\n+  // Lowest possible address that makes sense as the next frame pointer.\n+  // Goes up as we walk the stack.\n+  uptr bottom = stack_bottom;\n   // Avoid infinite loop when frame == frame[0] by using frame > prev_frame.\n-  while (frame > prev_frame &&\n-         IsValidFrame((uptr)frame, stack_top, stack_bottom) &&\n+  while (IsValidFrame((uptr)frame, stack_top, bottom) &&\n          IsAligned((uptr)frame, sizeof(*frame)) &&\n          size < max_depth) {\n     uhwptr pc1 = frame[1];\n     if (pc1 != pc) {\n-      trace[size++] = (uptr) pc1;\n+      trace_buffer[size++] = (uptr) pc1;\n     }\n-    prev_frame = frame;\n-    frame = GetCanonicFrame((uptr)frame[0], stack_top, stack_bottom);\n+    bottom = (uptr)frame;\n+    frame = GetCanonicFrame((uptr)frame[0], stack_top, bottom);\n   }\n }\n \n static bool MatchPc(uptr cur_pc, uptr trace_pc, uptr threshold) {\n   return cur_pc - trace_pc <= threshold || trace_pc - cur_pc <= threshold;\n }\n \n-void StackTrace::PopStackFrames(uptr count) {\n+void BufferedStackTrace::PopStackFrames(uptr count) {\n   CHECK_LT(count, size);\n   size -= count;\n   for (uptr i = 0; i < size; ++i) {\n-    trace[i] = trace[i + count];\n+    trace_buffer[i] = trace_buffer[i + count];\n   }\n }\n \n-uptr StackTrace::LocatePcInTrace(uptr pc) {\n+uptr BufferedStackTrace::LocatePcInTrace(uptr pc) {\n   // Use threshold to find PC in stack trace, as PC we want to unwind from may\n   // slightly differ from return address in the actual unwinded stack trace.\n   const int kPcThreshold = 288;"}, {"sha": "31495cfc56883271c73b8e1f200e0670e6a0ad8a", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -27,44 +27,49 @@ static const uptr kStackTraceMax = 256;\n # define SANITIZER_CAN_FAST_UNWIND 1\n #endif\n \n+// Fast unwind is the only option on Mac for now; we will need to\n+// revisit this macro when slow unwind works on Mac, see\n+// https://code.google.com/p/address-sanitizer/issues/detail?id=137\n+#if SANITIZER_MAC\n+# define SANITIZER_CAN_SLOW_UNWIND 0\n+#else\n+# define SANITIZER_CAN_SLOW_UNWIND 1\n+#endif\n+\n struct StackTrace {\n-  typedef bool (*SymbolizeCallback)(const void *pc, char *out_buffer,\n-                                     int out_size);\n-  uptr top_frame_bp;\n+  const uptr *trace;\n   uptr size;\n-  uptr trace[kStackTraceMax];\n \n-  // Prints a symbolized stacktrace, followed by an empty line.\n-  static void PrintStack(const uptr *addr, uptr size);\n-  void Print() const {\n-    PrintStack(trace, size);\n-  }\n+  StackTrace() : trace(nullptr), size(0) {}\n+  StackTrace(const uptr *trace, uptr size) : trace(trace), size(size) {}\n \n-  void CopyFrom(const uptr *src, uptr src_size) {\n-    top_frame_bp = 0;\n-    size = src_size;\n-    if (size > kStackTraceMax) size = kStackTraceMax;\n-    for (uptr i = 0; i < size; i++)\n-      trace[i] = src[i];\n-  }\n+  // Prints a symbolized stacktrace, followed by an empty line.\n+  void Print() const;\n \n   static bool WillUseFastUnwind(bool request_fast_unwind) {\n-    // Check if fast unwind is available. Fast unwind is the only option on Mac.\n-    // It is also the only option on FreeBSD as the slow unwinding that\n-    // leverages _Unwind_Backtrace() yields the call stack of the signal's\n-    // handler and not of the code that raised the signal (as it does on Linux).\n     if (!SANITIZER_CAN_FAST_UNWIND)\n       return false;\n-    else if (SANITIZER_MAC != 0 || SANITIZER_FREEBSD != 0)\n+    else if (!SANITIZER_CAN_SLOW_UNWIND)\n       return true;\n     return request_fast_unwind;\n   }\n \n-  void Unwind(uptr max_depth, uptr pc, uptr bp, void *context, uptr stack_top,\n-              uptr stack_bottom, bool request_fast_unwind);\n-\n   static uptr GetCurrentPc();\n   static uptr GetPreviousInstructionPc(uptr pc);\n+  typedef bool (*SymbolizeCallback)(const void *pc, char *out_buffer,\n+                                    int out_size);\n+};\n+\n+// StackTrace that owns the buffer used to store the addresses.\n+struct BufferedStackTrace : public StackTrace {\n+  uptr trace_buffer[kStackTraceMax];\n+  uptr top_frame_bp;  // Optional bp of a top frame.\n+\n+  BufferedStackTrace() : StackTrace(trace_buffer, 0), top_frame_bp(0) {}\n+\n+  void Init(const uptr *pcs, uptr cnt, uptr extra_top_pc = 0);\n+  void Unwind(uptr max_depth, uptr pc, uptr bp, void *context, uptr stack_top,\n+              uptr stack_bottom, bool request_fast_unwind);\n \n  private:\n   void FastUnwindStack(uptr pc, uptr bp, uptr stack_top, uptr stack_bottom,\n@@ -74,6 +79,9 @@ struct StackTrace {\n                                   uptr max_depth);\n   void PopStackFrames(uptr count);\n   uptr LocatePcInTrace(uptr pc);\n+\n+  BufferedStackTrace(const BufferedStackTrace &);\n+  void operator=(const BufferedStackTrace &);\n };\n \n }  // namespace __sanitizer"}, {"sha": "2d55b73f03a4d8cfa6c182bdff00d94a94e6dd43", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cc", "status": "modified", "additions": 19, "deletions": 37, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -10,68 +10,50 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_placement_new.h\"\n #include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_stacktrace_printer.h\"\n #include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n-static void PrintStackFramePrefix(InternalScopedString *buffer, uptr frame_num,\n-                                  uptr pc) {\n-  buffer->append(\"    #%zu 0x%zx\", frame_num, pc);\n-}\n-\n-void StackTrace::PrintStack(const uptr *addr, uptr size) {\n-  if (addr == 0 || size == 0) {\n+void StackTrace::Print() const {\n+  if (trace == nullptr || size == 0) {\n     Printf(\"    <empty stack>\\n\\n\");\n     return;\n   }\n-  InternalScopedBuffer<char> buff(GetPageSizeCached() * 2);\n-  InternalScopedBuffer<AddressInfo> addr_frames(64);\n+  const int kMaxAddrFrames = 64;\n+  InternalScopedBuffer<AddressInfo> addr_frames(kMaxAddrFrames);\n+  for (uptr i = 0; i < kMaxAddrFrames; i++)\n+    new(&addr_frames[i]) AddressInfo();\n   InternalScopedString frame_desc(GetPageSizeCached() * 2);\n   uptr frame_num = 0;\n-  for (uptr i = 0; i < size && addr[i]; i++) {\n+  for (uptr i = 0; i < size && trace[i]; i++) {\n     // PCs in stack traces are actually the return addresses, that is,\n     // addresses of the next instructions after the call.\n-    uptr pc = GetPreviousInstructionPc(addr[i]);\n+    uptr pc = GetPreviousInstructionPc(trace[i]);\n     uptr addr_frames_num = Symbolizer::GetOrInit()->SymbolizePC(\n-        pc, addr_frames.data(), addr_frames.size());\n+        pc, addr_frames.data(), kMaxAddrFrames);\n     if (addr_frames_num == 0) {\n-      frame_desc.clear();\n-      PrintStackFramePrefix(&frame_desc, frame_num, pc);\n-      frame_desc.append(\" (<unknown module>)\");\n-      Printf(\"%s\\n\", frame_desc.data());\n-      frame_num++;\n-      continue;\n+      addr_frames[0].address = pc;\n+      addr_frames_num = 1;\n     }\n     for (uptr j = 0; j < addr_frames_num; j++) {\n       AddressInfo &info = addr_frames[j];\n       frame_desc.clear();\n-      PrintStackFramePrefix(&frame_desc, frame_num, pc);\n-      if (info.function) {\n-        frame_desc.append(\" in %s\", info.function);\n-        // Print offset in function if we don't know the source file.\n-        if (!info.file && info.function_offset != AddressInfo::kUnknown)\n-          frame_desc.append(\"+0x%zx\", info.function_offset);\n-      }\n-      if (info.file) {\n-        frame_desc.append(\" \");\n-        PrintSourceLocation(&frame_desc, info.file, info.line, info.column);\n-      } else if (info.module) {\n-        frame_desc.append(\" \");\n-        PrintModuleAndOffset(&frame_desc, info.module, info.module_offset);\n-      }\n+      RenderFrame(&frame_desc, common_flags()->stack_trace_format, frame_num++,\n+                  info, common_flags()->strip_path_prefix);\n       Printf(\"%s\\n\", frame_desc.data());\n-      frame_num++;\n       info.Clear();\n     }\n   }\n   // Always print a trailing empty line after stack trace.\n   Printf(\"\\n\");\n }\n \n-void StackTrace::Unwind(uptr max_depth, uptr pc, uptr bp, void *context,\n-                        uptr stack_top, uptr stack_bottom,\n-                        bool request_fast_unwind) {\n+void BufferedStackTrace::Unwind(uptr max_depth, uptr pc, uptr bp, void *context,\n+                                uptr stack_top, uptr stack_bottom,\n+                                bool request_fast_unwind) {\n   top_frame_bp = (max_depth > 0) ? bp : 0;\n   // Avoid doing any work for small max_depth.\n   if (max_depth == 0) {\n@@ -80,7 +62,7 @@ void StackTrace::Unwind(uptr max_depth, uptr pc, uptr bp, void *context,\n   }\n   if (max_depth == 1) {\n     size = 1;\n-    trace[0] = pc;\n+    trace_buffer[0] = pc;\n     return;\n   }\n   if (!WillUseFastUnwind(request_fast_unwind)) {"}, {"sha": "300b4904c54bee33402e9df8ca7d4daff53648de", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.cc", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -0,0 +1,130 @@\n+//===-- sanitizer_common.cc -----------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between sanitizers' run-time libraries.\n+//\n+//===----------------------------------------------------------------------===//\n+#include \"sanitizer_stacktrace_printer.h\"\n+\n+namespace __sanitizer {\n+\n+static const char *StripFunctionName(const char *function, const char *prefix) {\n+  if (function == 0) return 0;\n+  if (prefix == 0) return function;\n+  uptr prefix_len = internal_strlen(prefix);\n+  if (0 == internal_strncmp(function, prefix, prefix_len))\n+    return function + prefix_len;\n+  return function;\n+}\n+\n+static const char kDefaultFormat[] = \"    #%n %p %F %L\";\n+\n+void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n+                 const AddressInfo &info, const char *strip_path_prefix,\n+                 const char *strip_func_prefix) {\n+  if (0 == internal_strcmp(format, \"DEFAULT\"))\n+    format = kDefaultFormat;\n+  for (const char *p = format; *p != '\\0'; p++) {\n+    if (*p != '%') {\n+      buffer->append(\"%c\", *p);\n+      continue;\n+    }\n+    p++;\n+    switch (*p) {\n+    case '%':\n+      buffer->append(\"%%\");\n+      break;\n+    // Frame number and all fields of AddressInfo structure.\n+    case 'n':\n+      buffer->append(\"%zu\", frame_no);\n+      break;\n+    case 'p':\n+      buffer->append(\"0x%zx\", info.address);\n+      break;\n+    case 'm':\n+      buffer->append(\"%s\", StripPathPrefix(info.module, strip_path_prefix));\n+      break;\n+    case 'o':\n+      buffer->append(\"0x%zx\", info.module_offset);\n+      break;\n+    case 'f':\n+      buffer->append(\"%s\", StripFunctionName(info.function, strip_func_prefix));\n+      break;\n+    case 'q':\n+      buffer->append(\"0x%zx\", info.function_offset != AddressInfo::kUnknown\n+                                  ? info.function_offset\n+                                  : 0x0);\n+      break;\n+    case 's':\n+      buffer->append(\"%s\", StripPathPrefix(info.file, strip_path_prefix));\n+      break;\n+    case 'l':\n+      buffer->append(\"%d\", info.line);\n+      break;\n+    case 'c':\n+      buffer->append(\"%d\", info.column);\n+      break;\n+    // Smarter special cases.\n+    case 'F':\n+      // Function name and offset, if file is unknown.\n+      if (info.function) {\n+        buffer->append(\"in %s\",\n+                       StripFunctionName(info.function, strip_func_prefix));\n+        if (!info.file && info.function_offset != AddressInfo::kUnknown)\n+          buffer->append(\"+0x%zx\", info.function_offset);\n+      }\n+      break;\n+    case 'S':\n+      // File/line information.\n+      RenderSourceLocation(buffer, info.file, info.line, info.column,\n+                           strip_path_prefix);\n+      break;\n+    case 'L':\n+      // Source location, or module location.\n+      if (info.file) {\n+        RenderSourceLocation(buffer, info.file, info.line, info.column,\n+                             strip_path_prefix);\n+      } else if (info.module) {\n+        RenderModuleLocation(buffer, info.module, info.module_offset,\n+                             strip_path_prefix);\n+      } else {\n+        buffer->append(\"(<unknown module>)\");\n+      }\n+      break;\n+    case 'M':\n+      // Module basename and offset, or PC.\n+      if (info.module)\n+        buffer->append(\"(%s+%p)\", StripModuleName(info.module),\n+                       (void *)info.module_offset);\n+      else\n+        buffer->append(\"(%p)\", (void *)info.address);\n+      break;\n+    default:\n+      Report(\"Unsupported specifier in stack frame format: %c (0x%zx)!\\n\",\n+             *p, *p);\n+      Die();\n+    }\n+  }\n+}\n+\n+void RenderSourceLocation(InternalScopedString *buffer, const char *file,\n+                          int line, int column, const char *strip_path_prefix) {\n+  buffer->append(\"%s\", StripPathPrefix(file, strip_path_prefix));\n+  if (line > 0) {\n+    buffer->append(\":%d\", line);\n+    if (column > 0)\n+      buffer->append(\":%d\", column);\n+  }\n+}\n+\n+void RenderModuleLocation(InternalScopedString *buffer, const char *module,\n+                          uptr offset, const char *strip_path_prefix) {\n+  buffer->append(\"(%s+0x%zx)\", StripPathPrefix(module, strip_path_prefix),\n+                 offset);\n+}\n+\n+}  // namespace __sanitizer"}, {"sha": "54e2fb024df24d84c4a11f7e5e9d5c569a436f8a", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -0,0 +1,60 @@\n+//===-- sanitizer_stacktrace_printer.h --------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between sanitizers' run-time libraries.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_STACKTRACE_PRINTER_H\n+#define SANITIZER_STACKTRACE_PRINTER_H\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_symbolizer.h\"\n+\n+namespace __sanitizer {\n+\n+// Render the contents of \"info\" structure, which represents the contents of\n+// stack frame \"frame_no\" and appends it to the \"buffer\". \"format\" is a\n+// string with placeholders, which is copied to the output with\n+// placeholders substituted with the contents of \"info\". For example,\n+// format string\n+//   \"  frame %n: function %F at %S\"\n+// will be turned into\n+//   \"  frame 10: function foo::bar() at my/file.cc:10\"\n+// You may additionally pass \"strip_path_prefix\" to strip prefixes of paths to\n+// source files and modules, and \"strip_func_prefix\" to strip prefixes of\n+// function names.\n+// Here's the full list of available placeholders:\n+//   %% - represents a '%' character;\n+//   %n - frame number (copy of frame_no);\n+//   %p - PC in hex format;\n+//   %m - path to module (binary or shared object);\n+//   %o - offset in the module in hex format;\n+//   %f - function name;\n+//   %q - offset in the function in hex format (*if available*);\n+//   %s - path to source file;\n+//   %l - line in the source file;\n+//   %c - column in the source file;\n+//   %F - if function is known to be <foo>, prints \"in <foo>\", possibly\n+//        followed by the offset in this function, but only if source file\n+//        is unknown;\n+//   %S - prints file/line/column information;\n+//   %L - prints location information: file/line/column, if it is known, or\n+//        module+offset if it is known, or (<unknown module>) string.\n+//   %M - prints module basename and offset, if it is known, or PC.\n+void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n+                 const AddressInfo &info, const char *strip_path_prefix = \"\",\n+                 const char *strip_func_prefix = \"\");\n+\n+void RenderSourceLocation(InternalScopedString *buffer, const char *file,\n+                          int line, int column, const char *strip_path_prefix);\n+\n+void RenderModuleLocation(InternalScopedString *buffer, const char *module,\n+                          uptr offset, const char *strip_path_prefix);\n+\n+}  // namespace __sanitizer\n+\n+#endif  // SANITIZER_STACKTRACE_PRINTER_H"}, {"sha": "2ff99372da95214cfb64b10a68179698c2d4afda", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -59,13 +59,23 @@ struct AddressInfo {\n   }\n };\n \n+// For now, DataInfo is used to describe global variable.\n struct DataInfo {\n-  uptr address;\n   char *module;\n   uptr module_offset;\n   char *name;\n   uptr start;\n   uptr size;\n+\n+  DataInfo() {\n+    internal_memset(this, 0, sizeof(DataInfo));\n+  }\n+\n+  void Clear() {\n+    InternalFree(module);\n+    InternalFree(name);\n+    internal_memset(this, 0, sizeof(DataInfo));\n+  }\n };\n \n class Symbolizer {"}, {"sha": "905079475b87bd0349d896e691142d17610b2b5c", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libbacktrace.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libbacktrace.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -166,7 +166,7 @@ uptr LibbacktraceSymbolizer::SymbolizeCode(uptr addr, AddressInfo *frames,\n }\n \n bool LibbacktraceSymbolizer::SymbolizeData(DataInfo *info) {\n-  backtrace_syminfo((backtrace_state *)state_, info->address,\n+  backtrace_syminfo((backtrace_state *)state_, info->start,\n                     SymbolizeDataCallback, ErrorCallback, info);\n   return true;\n }"}, {"sha": "ccd2d70f0f074abfd0cd7e9c518157fb4f0484dd", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -339,12 +339,19 @@ class LLVMSymbolizerProcess : public SymbolizerProcess {\n     const char* const kSymbolizerArch = \"--default-arch=x86_64\";\n #elif defined(__i386__)\n     const char* const kSymbolizerArch = \"--default-arch=i386\";\n-#elif defined(__powerpc64__)\n+#elif defined(__powerpc64__) && defined(__BIG_ENDIAN__)\n     const char* const kSymbolizerArch = \"--default-arch=powerpc64\";\n+#elif defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)\n+    const char* const kSymbolizerArch = \"--default-arch=powerpc64le\";\n #else\n     const char* const kSymbolizerArch = \"--default-arch=unknown\";\n #endif\n-    execl(path_to_binary, path_to_binary, kSymbolizerArch, (char *)0);\n+\n+    const char *const inline_flag = common_flags()->symbolize_inline_frames\n+                                        ? \"--inlining=true\"\n+                                        : \"--inlining=false\";\n+    execl(path_to_binary, path_to_binary, inline_flag, kSymbolizerArch,\n+          (char *)0);\n   }\n };\n \n@@ -580,8 +587,7 @@ class POSIXSymbolizer : public Symbolizer {\n       return false;\n     const char *module_name = module->full_name();\n     uptr module_offset = addr - module->base_address();\n-    internal_memset(info, 0, sizeof(*info));\n-    info->address = addr;\n+    info->Clear();\n     info->module = internal_strdup(module_name);\n     info->module_offset = module_offset;\n     // First, try to use libbacktrace symbolizer (if it's available)."}, {"sha": "b2ca931e9d9039a4ec3b797928f51a775e66256a", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_posix_libcdep.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_posix_libcdep.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -93,35 +93,35 @@ uptr Unwind_GetIP(struct _Unwind_Context *ctx) {\n }\n \n struct UnwindTraceArg {\n-  StackTrace *stack;\n+  BufferedStackTrace *stack;\n   uptr max_depth;\n };\n \n _Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n   UnwindTraceArg *arg = (UnwindTraceArg*)param;\n   CHECK_LT(arg->stack->size, arg->max_depth);\n   uptr pc = Unwind_GetIP(ctx);\n-  arg->stack->trace[arg->stack->size++] = pc;\n+  arg->stack->trace_buffer[arg->stack->size++] = pc;\n   if (arg->stack->size == arg->max_depth) return UNWIND_STOP;\n   return UNWIND_CONTINUE;\n }\n \n-void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n+void BufferedStackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n   CHECK_GE(max_depth, 2);\n   size = 0;\n   UnwindTraceArg arg = {this, Min(max_depth + 1, kStackTraceMax)};\n   _Unwind_Backtrace(Unwind_Trace, &arg);\n   // We need to pop a few frames so that pc is on top.\n   uptr to_pop = LocatePcInTrace(pc);\n-  // trace[0] belongs to the current function so we always pop it.\n-  if (to_pop == 0)\n+  // trace_buffer[0] belongs to the current function so we always pop it.\n+  if (to_pop == 0 && size > 1)\n     to_pop = 1;\n   PopStackFrames(to_pop);\n-  trace[0] = pc;\n+  trace_buffer[0] = pc;\n }\n \n-void StackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n-                                            uptr max_depth) {\n+void BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n+                                                    uptr max_depth) {\n   CHECK_GE(max_depth, 2);\n   if (!unwind_backtrace_signal_arch) {\n     SlowUnwindStack(pc, max_depth);\n@@ -143,7 +143,7 @@ void StackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n   // +2 compensate for libcorkscrew unwinder returning addresses of call\n   // instructions instead of raw return addresses.\n   for (sptr i = 0; i < res; ++i)\n-    trace[size++] = frames[i].absolute_pc + 2;\n+    trace_buffer[size++] = frames[i].absolute_pc + 2;\n }\n \n }  // namespace __sanitizer"}, {"sha": "fbccef19cb102d34115cd26c2fa1eb7208023333", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -442,7 +442,7 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n }\n \n #if !SANITIZER_GO\n-void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n+void BufferedStackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n   CHECK_GE(max_depth, 2);\n   // FIXME: CaptureStackBackTrace might be too slow for us.\n   // FIXME: Compare with StackWalk64.\n@@ -457,8 +457,8 @@ void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n   PopStackFrames(pc_location);\n }\n \n-void StackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n-                                            uptr max_depth) {\n+void BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n+                                                    uptr max_depth) {\n   CONTEXT ctx = *(CONTEXT *)context;\n   STACKFRAME64 stack_frame;\n   memset(&stack_frame, 0, sizeof(stack_frame));\n@@ -481,7 +481,7 @@ void StackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n                      &stack_frame, &ctx, NULL, &SymFunctionTableAccess64,\n                      &SymGetModuleBase64, NULL) &&\n          size < Min(max_depth, kStackTraceMax)) {\n-    trace[size++] = (uptr)stack_frame.AddrPC.Offset;\n+    trace_buffer[size++] = (uptr)stack_frame.AddrPC.Offset;\n   }\n }\n #endif  // #if !SANITIZER_GO"}, {"sha": "3896a8b9b4e97f0e765b3db1966dbf8b65762b08", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -6,6 +6,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fno-rtti -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros\n AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+AM_CXXFLAGS += -std=c++11\n ACLOCAL_AMFLAGS = -I m4\n \n toolexeclib_LTLIBRARIES = libtsan.la"}, {"sha": "32e454fe291aca0fb157c4938658e1a4a32635c6", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -276,7 +276,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n \t-Wno-long-long -fPIC -fno-builtin -fno-exceptions -fno-rtti \\\n \t-fomit-frame-pointer -funwind-tables -fvisibility=hidden \\\n-\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS) -std=c++11\n ACLOCAL_AMFLAGS = -I m4\n toolexeclib_LTLIBRARIES = libtsan.la\n tsan_files = \\"}, {"sha": "076de73c9beb62aa0686a1b74b1063eec7549e27", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -41,7 +41,6 @@ const unsigned kMaxTidInClock = kMaxTid * 2;  // This includes msb 'freed' bit.\n const int kClkBits = 42;\n const unsigned kMaxTidReuse = (1 << (64 - kClkBits)) - 1;\n const uptr kShadowStackSize = 64 * 1024;\n-const uptr kTraceStackSize = 256;\n \n #ifdef TSAN_SHADOW_COUNT\n # if TSAN_SHADOW_COUNT == 2 \\\n@@ -172,7 +171,6 @@ struct Context;\n struct ReportStack;\n class ReportDesc;\n class RegionAlloc;\n-class StackTrace;\n \n // Descriptor of user's memory block.\n struct MBlock {"}, {"sha": "10582035f24c7254e3468ac90d4a6e139ac1b070", "filename": "libsanitizer/tsan/tsan_fd.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -46,7 +46,8 @@ static bool bogusfd(int fd) {\n }\n \n static FdSync *allocsync(ThreadState *thr, uptr pc) {\n-  FdSync *s = (FdSync*)user_alloc(thr, pc, sizeof(FdSync));\n+  FdSync *s = (FdSync*)user_alloc(thr, pc, sizeof(FdSync), kDefaultAlignment,\n+      false);\n   atomic_store(&s->rc, 1, memory_order_relaxed);\n   return s;\n }\n@@ -63,7 +64,7 @@ static void unref(ThreadState *thr, uptr pc, FdSync *s) {\n       CHECK_NE(s, &fdctx.globsync);\n       CHECK_NE(s, &fdctx.filesync);\n       CHECK_NE(s, &fdctx.socksync);\n-      user_free(thr, pc, s);\n+      user_free(thr, pc, s, false);\n     }\n   }\n }\n@@ -76,13 +77,13 @@ static FdDesc *fddesc(ThreadState *thr, uptr pc, int fd) {\n   if (l1 == 0) {\n     uptr size = kTableSizeL2 * sizeof(FdDesc);\n     // We need this to reside in user memory to properly catch races on it.\n-    void *p = user_alloc(thr, pc, size);\n+    void *p = user_alloc(thr, pc, size, kDefaultAlignment, false);\n     internal_memset(p, 0, size);\n     MemoryResetRange(thr, (uptr)&fddesc, (uptr)p, size);\n     if (atomic_compare_exchange_strong(pl1, &l1, (uptr)p, memory_order_acq_rel))\n       l1 = (uptr)p;\n     else\n-      user_free(thr, pc, p);\n+      user_free(thr, pc, p, false);\n   }\n   return &((FdDesc*)l1)[fd % kTableSizeL2];  // NOLINT\n }"}, {"sha": "6059f2771baae199eecbb84395136b2845447d76", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -97,6 +97,7 @@ void InitializeFlags(Flags *f, const char *env) {\n   cf->allow_addr2line = true;\n   cf->detect_deadlocks = true;\n   cf->print_suppressions = false;\n+  cf->stack_trace_format = \"    #%n %f %S %M\";\n \n   // Let a frontend override.\n   ParseFlags(f, __tsan_default_options());"}, {"sha": "7f1b6e45a8d512a69051eaa950d441753bb6c213", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 249, "deletions": 121, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -27,6 +27,16 @@\n \n using namespace __tsan;  // NOLINT\n \n+#if SANITIZER_FREEBSD\n+#define __errno_location __error\n+#define __libc_malloc __malloc\n+#define __libc_realloc __realloc\n+#define __libc_calloc __calloc\n+#define __libc_free __free\n+#define stdout __stdoutp\n+#define stderr __stderrp\n+#endif\n+\n const int kSigCount = 65;\n \n struct my_siginfo_t {\n@@ -60,7 +70,9 @@ extern \"C\" void *__libc_malloc(uptr size);\n extern \"C\" void *__libc_calloc(uptr size, uptr n);\n extern \"C\" void *__libc_realloc(void *ptr, uptr size);\n extern \"C\" void __libc_free(void *ptr);\n+#if !SANITIZER_FREEBSD\n extern \"C\" int mallopt(int param, int value);\n+#endif\n extern __sanitizer_FILE *stdout, *stderr;\n const int PTHREAD_MUTEX_RECURSIVE = 1;\n const int PTHREAD_MUTEX_RECURSIVE_NP = 1;\n@@ -91,19 +103,19 @@ typedef void (*sighandler_t)(int sig);\n \n #define errno (*__errno_location())\n \n-// 16K loaded modules should be enough for everyone.\n-static const uptr kMaxModules = 1 << 14;\n-static LoadedModule *modules;\n-static uptr nmodules;\n-\n struct sigaction_t {\n   union {\n     sighandler_t sa_handler;\n     void (*sa_sigaction)(int sig, my_siginfo_t *siginfo, void *uctx);\n   };\n+#if SANITIZER_FREEBSD\n+  int sa_flags;\n+  __sanitizer_sigset_t sa_mask;\n+#else\n   __sanitizer_sigset_t sa_mask;\n   int sa_flags;\n   void (*sa_restorer)();\n+#endif\n };\n \n const sighandler_t SIG_DFL = (sighandler_t)0;\n@@ -202,7 +214,7 @@ ScopedInterceptor::~ScopedInterceptor() {\n     ThreadState *thr = cur_thread(); \\\n     const uptr caller_pc = GET_CALLER_PC(); \\\n     ScopedInterceptor si(thr, #func, caller_pc); \\\n-    const uptr pc = __sanitizer::StackTrace::GetCurrentPc(); \\\n+    const uptr pc = StackTrace::GetCurrentPc(); \\\n     (void)pc; \\\n /**/\n \n@@ -218,7 +230,11 @@ ScopedInterceptor::~ScopedInterceptor() {\n \n #define TSAN_INTERCEPTOR(ret, func, ...) INTERCEPTOR(ret, func, __VA_ARGS__)\n #define TSAN_INTERCEPT(func) INTERCEPT_FUNCTION(func)\n-#define TSAN_INTERCEPT_VER(func, ver) INTERCEPT_FUNCTION_VER(func, ver)\n+#if SANITIZER_FREEBSD\n+# define TSAN_INTERCEPT_VER(func, ver) INTERCEPT_FUNCTION(func)\n+#else\n+# define TSAN_INTERCEPT_VER(func, ver) INTERCEPT_FUNCTION_VER(func, ver)\n+#endif\n \n #define BLOCK_REAL(name) (BlockingCall(thr), REAL(name))\n \n@@ -271,104 +287,76 @@ TSAN_INTERCEPTOR(int, nanosleep, void *req, void *rem) {\n   return res;\n }\n \n-class AtExitContext {\n- public:\n-  AtExitContext()\n-    : mtx_(MutexTypeAtExit, StatMtxAtExit)\n-    , stack_(MBlockAtExit) {\n-  }\n-\n-  typedef void(*atexit_cb_t)();\n-\n-  int atexit(ThreadState *thr, uptr pc, bool is_on_exit,\n-             atexit_cb_t f, void *arg, void *dso) {\n-    Lock l(&mtx_);\n-    Release(thr, pc, (uptr)this);\n-    atexit_t *a = stack_.PushBack();\n-    a->cb = f;\n-    a->arg = arg;\n-    a->dso = dso;\n-    a->is_on_exit = is_on_exit;\n-    return 0;\n-  }\n-\n-  void exit(ThreadState *thr, uptr pc) {\n-    for (;;) {\n-      atexit_t a = {};\n-      {\n-        Lock l(&mtx_);\n-        if (stack_.Size() != 0) {\n-          a = stack_[stack_.Size() - 1];\n-          stack_.PopBack();\n-          Acquire(thr, pc, (uptr)this);\n-        }\n-      }\n-      if (a.cb == 0)\n-        break;\n-      VPrintf(2, \"#%d: executing atexit func %p(%p) dso=%p\\n\",\n-          thr->tid, a.cb, a.arg, a.dso);\n-      if (a.is_on_exit)\n-        ((void(*)(int status, void *arg))a.cb)(0, a.arg);\n-      else\n-        ((void(*)(void *arg, void *dso))a.cb)(a.arg, a.dso);\n-    }\n-  }\n-\n- private:\n-  struct atexit_t {\n-    atexit_cb_t cb;\n-    void *arg;\n-    void *dso;\n-    bool is_on_exit;\n-  };\n-\n-  static const int kMaxAtExit = 1024;\n-  Mutex mtx_;\n-  Vector<atexit_t> stack_;\n+// The sole reason tsan wraps atexit callbacks is to establish synchronization\n+// between callback setup and callback execution.\n+struct AtExitCtx {\n+  void (*f)();\n+  void *arg;\n };\n \n-static AtExitContext *atexit_ctx;\n+static void at_exit_wrapper(void *arg) {\n+  ThreadState *thr = cur_thread();\n+  uptr pc = 0;\n+  Acquire(thr, pc, (uptr)arg);\n+  AtExitCtx *ctx = (AtExitCtx*)arg;\n+  ((void(*)(void *arg))ctx->f)(ctx->arg);\n+  __libc_free(ctx);\n+}\n+\n+static int setup_at_exit_wrapper(ThreadState *thr, uptr pc, void(*f)(),\n+      void *arg, void *dso);\n \n TSAN_INTERCEPTOR(int, atexit, void (*f)()) {\n   if (cur_thread()->in_symbolizer)\n     return 0;\n   // We want to setup the atexit callback even if we are in ignored lib\n   // or after fork.\n   SCOPED_INTERCEPTOR_RAW(atexit, f);\n-  return atexit_ctx->atexit(thr, pc, false, (void(*)())f, 0, 0);\n+  return setup_at_exit_wrapper(thr, pc, (void(*)())f, 0, 0);\n }\n \n-TSAN_INTERCEPTOR(int, on_exit, void(*f)(int, void*), void *arg) {\n+TSAN_INTERCEPTOR(int, __cxa_atexit, void (*f)(void *a), void *arg, void *dso) {\n   if (cur_thread()->in_symbolizer)\n     return 0;\n-  SCOPED_TSAN_INTERCEPTOR(on_exit, f, arg);\n-  return atexit_ctx->atexit(thr, pc, true, (void(*)())f, arg, 0);\n+  SCOPED_TSAN_INTERCEPTOR(__cxa_atexit, f, arg, dso);\n+  return setup_at_exit_wrapper(thr, pc, (void(*)())f, arg, dso);\n }\n \n-bool IsSaticModule(void *dso) {\n-  if (modules == 0)\n-    return false;\n-  for (uptr i = 0; i < nmodules; i++) {\n-    if (modules[i].containsAddress((uptr)dso))\n-      return true;\n-  }\n-  return false;\n+static int setup_at_exit_wrapper(ThreadState *thr, uptr pc, void(*f)(),\n+      void *arg, void *dso) {\n+  AtExitCtx *ctx = (AtExitCtx*)__libc_malloc(sizeof(AtExitCtx));\n+  ctx->f = f;\n+  ctx->arg = arg;\n+  Release(thr, pc, (uptr)ctx);\n+  // Memory allocation in __cxa_atexit will race with free during exit,\n+  // because we do not see synchronization around atexit callback list.\n+  ThreadIgnoreBegin(thr, pc);\n+  int res = REAL(__cxa_atexit)(at_exit_wrapper, ctx, dso);\n+  ThreadIgnoreEnd(thr, pc);\n+  return res;\n }\n \n-TSAN_INTERCEPTOR(int, __cxa_atexit, void (*f)(void *a), void *arg, void *dso) {\n+static void on_exit_wrapper(int status, void *arg) {\n+  ThreadState *thr = cur_thread();\n+  uptr pc = 0;\n+  Acquire(thr, pc, (uptr)arg);\n+  AtExitCtx *ctx = (AtExitCtx*)arg;\n+  ((void(*)(int status, void *arg))ctx->f)(status, ctx->arg);\n+  __libc_free(ctx);\n+}\n+\n+TSAN_INTERCEPTOR(int, on_exit, void(*f)(int, void*), void *arg) {\n   if (cur_thread()->in_symbolizer)\n     return 0;\n-  SCOPED_TSAN_INTERCEPTOR(__cxa_atexit, f, arg, dso);\n-  // If it's the main executable or a statically loaded library,\n-  // we will call the callback.\n-  if (dso == 0 || IsSaticModule(dso))\n-    return atexit_ctx->atexit(thr, pc, false, (void(*)())f, arg, dso);\n-\n-  // Dynamically load module, don't know when to call the callback for it.\n+  SCOPED_TSAN_INTERCEPTOR(on_exit, f, arg);\n+  AtExitCtx *ctx = (AtExitCtx*)__libc_malloc(sizeof(AtExitCtx));\n+  ctx->f = (void(*)())f;\n+  ctx->arg = arg;\n+  Release(thr, pc, (uptr)ctx);\n   // Memory allocation in __cxa_atexit will race with free during exit,\n   // because we do not see synchronization around atexit callback list.\n   ThreadIgnoreBegin(thr, pc);\n-  int res = REAL(__cxa_atexit)(f, arg, dso);\n+  int res = REAL(on_exit)(on_exit_wrapper, ctx);\n   ThreadIgnoreEnd(thr, pc);\n   return res;\n }\n@@ -406,7 +394,11 @@ static void SetJmp(ThreadState *thr, uptr sp, uptr mangled_sp) {\n }\n \n static void LongJmp(ThreadState *thr, uptr *env) {\n+#if SANITIZER_FREEBSD\n+  uptr mangled_sp = env[2];\n+#else\n   uptr mangled_sp = env[6];\n+#endif  // SANITIZER_FREEBSD\n   // Find the saved buf by mangled_sp.\n   for (uptr i = 0; i < thr->jmp_bufs.Size(); i++) {\n     JmpBuf *buf = &thr->jmp_bufs[i];\n@@ -751,6 +743,7 @@ TSAN_INTERCEPTOR(void*, mmap, void *addr, long_t sz, int prot,\n   return res;\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(void*, mmap64, void *addr, long_t sz, int prot,\n                            int flags, int fd, u64 off) {\n   SCOPED_TSAN_INTERCEPTOR(mmap64, addr, sz, prot, flags, fd, off);\n@@ -764,6 +757,10 @@ TSAN_INTERCEPTOR(void*, mmap64, void *addr, long_t sz, int prot,\n   }\n   return res;\n }\n+#define TSAN_MAYBE_INTERCEPT_MMAP64 TSAN_INTERCEPT(mmap64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_MMAP64\n+#endif\n \n TSAN_INTERCEPTOR(int, munmap, void *addr, long_t sz) {\n   SCOPED_TSAN_INTERCEPTOR(munmap, addr, sz);\n@@ -772,10 +769,15 @@ TSAN_INTERCEPTOR(int, munmap, void *addr, long_t sz) {\n   return res;\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(memalign, align, sz);\n   return user_alloc(thr, pc, sz, align);\n }\n+#define TSAN_MAYBE_INTERCEPT_MEMALIGN TSAN_INTERCEPT(memalign)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_MEMALIGN\n+#endif\n \n TSAN_INTERCEPTOR(void*, aligned_alloc, uptr align, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(memalign, align, sz);\n@@ -787,11 +789,16 @@ TSAN_INTERCEPTOR(void*, valloc, uptr sz) {\n   return user_alloc(thr, pc, sz, GetPageSizeCached());\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(void*, pvalloc, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(pvalloc, sz);\n   sz = RoundUp(sz, GetPageSizeCached());\n   return user_alloc(thr, pc, sz, GetPageSizeCached());\n }\n+#define TSAN_MAYBE_INTERCEPT_PVALLOC TSAN_INTERCEPT(pvalloc)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_PVALLOC\n+#endif\n \n TSAN_INTERCEPTOR(int, posix_memalign, void **memptr, uptr align, uptr sz) {\n   SCOPED_INTERCEPTOR_RAW(posix_memalign, memptr, align, sz);\n@@ -863,11 +870,13 @@ extern \"C\" void *__tsan_thread_start_func(void *arg) {\n     ThreadState *thr = cur_thread();\n     // Thread-local state is not initialized yet.\n     ScopedIgnoreInterceptors ignore;\n+    ThreadIgnoreBegin(thr, 0);\n     if (pthread_setspecific(g_thread_finalize_key,\n                             (void *)kPthreadDestructorIterations)) {\n       Printf(\"ThreadSanitizer: failed to set thread key\\n\");\n       Die();\n     }\n+    ThreadIgnoreEnd(thr, 0);\n     while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n       pthread_yield();\n     atomic_store(&p->tid, 0, memory_order_release);\n@@ -1336,73 +1345,135 @@ TSAN_INTERCEPTOR(int, sem_getvalue, void *s, int *sval) {\n   return res;\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, __xstat, int version, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__xstat, version, path, buf);\n   return REAL(__xstat)(version, path, buf);\n }\n+#define TSAN_MAYBE_INTERCEPT___XSTAT TSAN_INTERCEPT(__xstat)\n+#else\n+#define TSAN_MAYBE_INTERCEPT___XSTAT\n+#endif\n \n TSAN_INTERCEPTOR(int, stat, const char *path, void *buf) {\n+#if SANITIZER_FREEBSD\n+  SCOPED_TSAN_INTERCEPTOR(stat, path, buf);\n+  return REAL(stat)(path, buf);\n+#else\n   SCOPED_TSAN_INTERCEPTOR(__xstat, 0, path, buf);\n   return REAL(__xstat)(0, path, buf);\n+#endif\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, __xstat64, int version, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__xstat64, version, path, buf);\n   return REAL(__xstat64)(version, path, buf);\n }\n+#define TSAN_MAYBE_INTERCEPT___XSTAT64 TSAN_INTERCEPT(__xstat64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT___XSTAT64\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, stat64, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__xstat64, 0, path, buf);\n   return REAL(__xstat64)(0, path, buf);\n }\n+#define TSAN_MAYBE_INTERCEPT_STAT64 TSAN_INTERCEPT(stat64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_STAT64\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, __lxstat, int version, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__lxstat, version, path, buf);\n   return REAL(__lxstat)(version, path, buf);\n }\n+#define TSAN_MAYBE_INTERCEPT___LXSTAT TSAN_INTERCEPT(__lxstat)\n+#else\n+#define TSAN_MAYBE_INTERCEPT___LXSTAT\n+#endif\n \n TSAN_INTERCEPTOR(int, lstat, const char *path, void *buf) {\n+#if SANITIZER_FREEBSD\n+  SCOPED_TSAN_INTERCEPTOR(lstat, path, buf);\n+  return REAL(lstat)(path, buf);\n+#else\n   SCOPED_TSAN_INTERCEPTOR(__lxstat, 0, path, buf);\n   return REAL(__lxstat)(0, path, buf);\n+#endif\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, __lxstat64, int version, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__lxstat64, version, path, buf);\n   return REAL(__lxstat64)(version, path, buf);\n }\n+#define TSAN_MAYBE_INTERCEPT___LXSTAT64 TSAN_INTERCEPT(__lxstat64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT___LXSTAT64\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, lstat64, const char *path, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__lxstat64, 0, path, buf);\n   return REAL(__lxstat64)(0, path, buf);\n }\n+#define TSAN_MAYBE_INTERCEPT_LSTAT64 TSAN_INTERCEPT(lstat64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_LSTAT64\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, __fxstat, int version, int fd, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__fxstat, version, fd, buf);\n   if (fd > 0)\n     FdAccess(thr, pc, fd);\n   return REAL(__fxstat)(version, fd, buf);\n }\n+#define TSAN_MAYBE_INTERCEPT___FXSTAT TSAN_INTERCEPT(__fxstat)\n+#else\n+#define TSAN_MAYBE_INTERCEPT___FXSTAT\n+#endif\n \n TSAN_INTERCEPTOR(int, fstat, int fd, void *buf) {\n+#if SANITIZER_FREEBSD\n+  SCOPED_TSAN_INTERCEPTOR(fstat, fd, buf);\n+  if (fd > 0)\n+    FdAccess(thr, pc, fd);\n+  return REAL(fstat)(fd, buf);\n+#else\n   SCOPED_TSAN_INTERCEPTOR(__fxstat, 0, fd, buf);\n   if (fd > 0)\n     FdAccess(thr, pc, fd);\n   return REAL(__fxstat)(0, fd, buf);\n+#endif\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, __fxstat64, int version, int fd, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__fxstat64, version, fd, buf);\n   if (fd > 0)\n     FdAccess(thr, pc, fd);\n   return REAL(__fxstat64)(version, fd, buf);\n }\n+#define TSAN_MAYBE_INTERCEPT___FXSTAT64 TSAN_INTERCEPT(__fxstat64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT___FXSTAT64\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, fstat64, int fd, void *buf) {\n   SCOPED_TSAN_INTERCEPTOR(__fxstat64, 0, fd, buf);\n   if (fd > 0)\n     FdAccess(thr, pc, fd);\n   return REAL(__fxstat64)(0, fd, buf);\n }\n+#define TSAN_MAYBE_INTERCEPT_FSTAT64 TSAN_INTERCEPT(fstat64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_FSTAT64\n+#endif\n \n TSAN_INTERCEPTOR(int, open, const char *name, int flags, int mode) {\n   SCOPED_TSAN_INTERCEPTOR(open, name, flags, mode);\n@@ -1412,13 +1483,18 @@ TSAN_INTERCEPTOR(int, open, const char *name, int flags, int mode) {\n   return fd;\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, open64, const char *name, int flags, int mode) {\n   SCOPED_TSAN_INTERCEPTOR(open64, name, flags, mode);\n   int fd = REAL(open64)(name, flags, mode);\n   if (fd >= 0)\n     FdFileCreate(thr, pc, fd);\n   return fd;\n }\n+#define TSAN_MAYBE_INTERCEPT_OPEN64 TSAN_INTERCEPT(open64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_OPEN64\n+#endif\n \n TSAN_INTERCEPTOR(int, creat, const char *name, int mode) {\n   SCOPED_TSAN_INTERCEPTOR(creat, name, mode);\n@@ -1428,13 +1504,18 @@ TSAN_INTERCEPTOR(int, creat, const char *name, int mode) {\n   return fd;\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, creat64, const char *name, int mode) {\n   SCOPED_TSAN_INTERCEPTOR(creat64, name, mode);\n   int fd = REAL(creat64)(name, mode);\n   if (fd >= 0)\n     FdFileCreate(thr, pc, fd);\n   return fd;\n }\n+#define TSAN_MAYBE_INTERCEPT_CREAT64 TSAN_INTERCEPT(creat64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_CREAT64\n+#endif\n \n TSAN_INTERCEPTOR(int, dup, int oldfd) {\n   SCOPED_TSAN_INTERCEPTOR(dup, oldfd);\n@@ -1460,14 +1541,20 @@ TSAN_INTERCEPTOR(int, dup3, int oldfd, int newfd, int flags) {\n   return newfd2;\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, eventfd, unsigned initval, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(eventfd, initval, flags);\n   int fd = REAL(eventfd)(initval, flags);\n   if (fd >= 0)\n     FdEventCreate(thr, pc, fd);\n   return fd;\n }\n+#define TSAN_MAYBE_INTERCEPT_EVENTFD TSAN_INTERCEPT(eventfd)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_EVENTFD\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, signalfd, int fd, void *mask, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(signalfd, fd, mask, flags);\n   if (fd >= 0)\n@@ -1477,22 +1564,36 @@ TSAN_INTERCEPTOR(int, signalfd, int fd, void *mask, int flags) {\n     FdSignalCreate(thr, pc, fd);\n   return fd;\n }\n+#define TSAN_MAYBE_INTERCEPT_SIGNALFD TSAN_INTERCEPT(signalfd)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_SIGNALFD\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, inotify_init, int fake) {\n   SCOPED_TSAN_INTERCEPTOR(inotify_init, fake);\n   int fd = REAL(inotify_init)(fake);\n   if (fd >= 0)\n     FdInotifyCreate(thr, pc, fd);\n   return fd;\n }\n+#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT TSAN_INTERCEPT(inotify_init)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, inotify_init1, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(inotify_init1, flags);\n   int fd = REAL(inotify_init1)(flags);\n   if (fd >= 0)\n     FdInotifyCreate(thr, pc, fd);\n   return fd;\n }\n+#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1 TSAN_INTERCEPT(inotify_init1)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1\n+#endif\n \n TSAN_INTERCEPTOR(int, socket, int domain, int type, int protocol) {\n   SCOPED_TSAN_INTERCEPTOR(socket, domain, type, protocol);\n@@ -1535,21 +1636,31 @@ TSAN_INTERCEPTOR(int, listen, int fd, int backlog) {\n   return res;\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, epoll_create, int size) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_create, size);\n   int fd = REAL(epoll_create)(size);\n   if (fd >= 0)\n     FdPollCreate(thr, pc, fd);\n   return fd;\n }\n+#define TSAN_MAYBE_INTERCEPT_EPOLL_CREATE TSAN_INTERCEPT(epoll_create)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_EPOLL_CREATE\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, epoll_create1, int flags) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_create1, flags);\n   int fd = REAL(epoll_create1)(flags);\n   if (fd >= 0)\n     FdPollCreate(thr, pc, fd);\n   return fd;\n }\n+#define TSAN_MAYBE_INTERCEPT_EPOLL_CREATE1 TSAN_INTERCEPT(epoll_create1)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_EPOLL_CREATE1\n+#endif\n \n TSAN_INTERCEPTOR(int, close, int fd) {\n   SCOPED_TSAN_INTERCEPTOR(close, fd);\n@@ -1558,14 +1669,20 @@ TSAN_INTERCEPTOR(int, close, int fd) {\n   return REAL(close)(fd);\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, __close, int fd) {\n   SCOPED_TSAN_INTERCEPTOR(__close, fd);\n   if (fd >= 0)\n     FdClose(thr, pc, fd);\n   return REAL(__close)(fd);\n }\n+#define TSAN_MAYBE_INTERCEPT___CLOSE TSAN_INTERCEPT(__close)\n+#else\n+#define TSAN_MAYBE_INTERCEPT___CLOSE\n+#endif\n \n // glibc guts\n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(void, __res_iclose, void *state, bool free_addr) {\n   SCOPED_TSAN_INTERCEPTOR(__res_iclose, state, free_addr);\n   int fds[64];\n@@ -1576,6 +1693,10 @@ TSAN_INTERCEPTOR(void, __res_iclose, void *state, bool free_addr) {\n   }\n   REAL(__res_iclose)(state, free_addr);\n }\n+#define TSAN_MAYBE_INTERCEPT___RES_ICLOSE TSAN_INTERCEPT(__res_iclose)\n+#else\n+#define TSAN_MAYBE_INTERCEPT___RES_ICLOSE\n+#endif\n \n TSAN_INTERCEPTOR(int, pipe, int *pipefd) {\n   SCOPED_TSAN_INTERCEPTOR(pipe, pipefd);\n@@ -1642,6 +1763,7 @@ TSAN_INTERCEPTOR(void*, tmpfile, int fake) {\n   return res;\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(void*, tmpfile64, int fake) {\n   SCOPED_TSAN_INTERCEPTOR(tmpfile64, fake);\n   void *res = REAL(tmpfile64)(fake);\n@@ -1652,6 +1774,10 @@ TSAN_INTERCEPTOR(void*, tmpfile64, int fake) {\n   }\n   return res;\n }\n+#define TSAN_MAYBE_INTERCEPT_TMPFILE64 TSAN_INTERCEPT(tmpfile64)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_TMPFILE64\n+#endif\n \n TSAN_INTERCEPTOR(uptr, fread, void *ptr, uptr size, uptr nmemb, void *f) {\n   // libc file streams can call user-supplied functions, see fopencookie.\n@@ -1698,6 +1824,7 @@ TSAN_INTERCEPTOR(void*, opendir, char *path) {\n   return res;\n }\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_ctl, epfd, op, fd, ev);\n   if (epfd >= 0)\n@@ -1709,7 +1836,12 @@ TSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n   int res = REAL(epoll_ctl)(epfd, op, fd, ev);\n   return res;\n }\n+#define TSAN_MAYBE_INTERCEPT_EPOLL_CTL TSAN_INTERCEPT(epoll_ctl)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_EPOLL_CTL\n+#endif\n \n+#if !SANITIZER_FREEBSD\n TSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {\n   SCOPED_TSAN_INTERCEPTOR(epoll_wait, epfd, ev, cnt, timeout);\n   if (epfd >= 0)\n@@ -1719,6 +1851,10 @@ TSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {\n     FdAcquire(thr, pc, epfd);\n   return res;\n }\n+#define TSAN_MAYBE_INTERCEPT_EPOLL_WAIT TSAN_INTERCEPT(epoll_wait)\n+#else\n+#define TSAN_MAYBE_INTERCEPT_EPOLL_WAIT\n+#endif\n \n namespace __tsan {\n \n@@ -1746,12 +1882,12 @@ static void CallUserSignalHandler(ThreadState *thr, bool sync, bool acquire,\n   // from rtl_generic_sighandler) we have not yet received the reraised\n   // signal; and it looks too fragile to intercept all ways to reraise a signal.\n   if (flags()->report_bugs && !sync && sig != SIGTERM && errno != 99) {\n-    __tsan::StackTrace stack;\n-    stack.ObtainCurrent(thr, pc);\n+    VarSizeStackTrace stack;\n+    ObtainCurrentStack(thr, pc, &stack);\n     ThreadRegistryLock l(ctx->thread_registry);\n     ScopedReport rep(ReportTypeErrnoInSignal);\n     if (!IsFiredSuppression(ctx, rep, stack)) {\n-      rep.AddStack(&stack, true);\n+      rep.AddStack(stack, true);\n       OutputReport(thr, rep);\n     }\n   }\n@@ -2226,8 +2362,6 @@ namespace __tsan {\n \n static void finalize(void *arg) {\n   ThreadState *thr = cur_thread();\n-  uptr pc = 0;\n-  atexit_ctx->exit(thr, pc);\n   int status = Finalize(thr);\n   // Make sure the output is not lost.\n   // Flushing all the streams here may freeze the process if a child thread is\n@@ -2250,8 +2384,10 @@ void InitializeInterceptors() {\n   REAL(memcmp) = internal_memcmp;\n \n   // Instruct libc malloc to consume less memory.\n+#if !SANITIZER_FREEBSD\n   mallopt(1, 0);  // M_MXFAST\n   mallopt(-3, 32*1024);  // M_MMAP_THRESHOLD\n+#endif\n \n   InitializeCommonInterceptors();\n \n@@ -2273,11 +2409,11 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(free);\n   TSAN_INTERCEPT(cfree);\n   TSAN_INTERCEPT(mmap);\n-  TSAN_INTERCEPT(mmap64);\n+  TSAN_MAYBE_INTERCEPT_MMAP64;\n   TSAN_INTERCEPT(munmap);\n-  TSAN_INTERCEPT(memalign);\n+  TSAN_MAYBE_INTERCEPT_MEMALIGN;\n   TSAN_INTERCEPT(valloc);\n-  TSAN_INTERCEPT(pvalloc);\n+  TSAN_MAYBE_INTERCEPT_PVALLOC;\n   TSAN_INTERCEPT(posix_memalign);\n \n   TSAN_INTERCEPT(strlen);\n@@ -2340,38 +2476,38 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(sem_getvalue);\n \n   TSAN_INTERCEPT(stat);\n-  TSAN_INTERCEPT(__xstat);\n-  TSAN_INTERCEPT(stat64);\n-  TSAN_INTERCEPT(__xstat64);\n+  TSAN_MAYBE_INTERCEPT___XSTAT;\n+  TSAN_MAYBE_INTERCEPT_STAT64;\n+  TSAN_MAYBE_INTERCEPT___XSTAT64;\n   TSAN_INTERCEPT(lstat);\n-  TSAN_INTERCEPT(__lxstat);\n-  TSAN_INTERCEPT(lstat64);\n-  TSAN_INTERCEPT(__lxstat64);\n+  TSAN_MAYBE_INTERCEPT___LXSTAT;\n+  TSAN_MAYBE_INTERCEPT_LSTAT64;\n+  TSAN_MAYBE_INTERCEPT___LXSTAT64;\n   TSAN_INTERCEPT(fstat);\n-  TSAN_INTERCEPT(__fxstat);\n-  TSAN_INTERCEPT(fstat64);\n-  TSAN_INTERCEPT(__fxstat64);\n+  TSAN_MAYBE_INTERCEPT___FXSTAT;\n+  TSAN_MAYBE_INTERCEPT_FSTAT64;\n+  TSAN_MAYBE_INTERCEPT___FXSTAT64;\n   TSAN_INTERCEPT(open);\n-  TSAN_INTERCEPT(open64);\n+  TSAN_MAYBE_INTERCEPT_OPEN64;\n   TSAN_INTERCEPT(creat);\n-  TSAN_INTERCEPT(creat64);\n+  TSAN_MAYBE_INTERCEPT_CREAT64;\n   TSAN_INTERCEPT(dup);\n   TSAN_INTERCEPT(dup2);\n   TSAN_INTERCEPT(dup3);\n-  TSAN_INTERCEPT(eventfd);\n-  TSAN_INTERCEPT(signalfd);\n-  TSAN_INTERCEPT(inotify_init);\n-  TSAN_INTERCEPT(inotify_init1);\n+  TSAN_MAYBE_INTERCEPT_EVENTFD;\n+  TSAN_MAYBE_INTERCEPT_SIGNALFD;\n+  TSAN_MAYBE_INTERCEPT_INOTIFY_INIT;\n+  TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1;\n   TSAN_INTERCEPT(socket);\n   TSAN_INTERCEPT(socketpair);\n   TSAN_INTERCEPT(connect);\n   TSAN_INTERCEPT(bind);\n   TSAN_INTERCEPT(listen);\n-  TSAN_INTERCEPT(epoll_create);\n-  TSAN_INTERCEPT(epoll_create1);\n+  TSAN_MAYBE_INTERCEPT_EPOLL_CREATE;\n+  TSAN_MAYBE_INTERCEPT_EPOLL_CREATE1;\n   TSAN_INTERCEPT(close);\n-  TSAN_INTERCEPT(__close);\n-  TSAN_INTERCEPT(__res_iclose);\n+  TSAN_MAYBE_INTERCEPT___CLOSE;\n+  TSAN_MAYBE_INTERCEPT___RES_ICLOSE;\n   TSAN_INTERCEPT(pipe);\n   TSAN_INTERCEPT(pipe2);\n \n@@ -2381,16 +2517,16 @@ void InitializeInterceptors() {\n \n   TSAN_INTERCEPT(unlink);\n   TSAN_INTERCEPT(tmpfile);\n-  TSAN_INTERCEPT(tmpfile64);\n+  TSAN_MAYBE_INTERCEPT_TMPFILE64;\n   TSAN_INTERCEPT(fread);\n   TSAN_INTERCEPT(fwrite);\n   TSAN_INTERCEPT(abort);\n   TSAN_INTERCEPT(puts);\n   TSAN_INTERCEPT(rmdir);\n   TSAN_INTERCEPT(opendir);\n \n-  TSAN_INTERCEPT(epoll_ctl);\n-  TSAN_INTERCEPT(epoll_wait);\n+  TSAN_MAYBE_INTERCEPT_EPOLL_CTL;\n+  TSAN_MAYBE_INTERCEPT_EPOLL_WAIT;\n \n   TSAN_INTERCEPT(sigaction);\n   TSAN_INTERCEPT(signal);\n@@ -2413,9 +2549,6 @@ void InitializeInterceptors() {\n   // Need to setup it, because interceptors check that the function is resolved.\n   // But atexit is emitted directly into the module, so can't be resolved.\n   REAL(atexit) = (int(*)(void(*)()))unreachable;\n-  atexit_ctx = new(internal_alloc(MBlockAtExit, sizeof(AtExitContext)))\n-      AtExitContext();\n-\n   if (REAL(__cxa_atexit)(&finalize, 0, 0)) {\n     Printf(\"ThreadSanitizer: failed to setup atexit callback\\n\");\n     Die();\n@@ -2427,11 +2560,6 @@ void InitializeInterceptors() {\n   }\n \n   FdInit();\n-\n-  // Remember list of loaded libraries for atexit interceptors.\n-  modules = (LoadedModule*)MmapOrDie(sizeof(*modules)*kMaxModules,\n-      \"LoadedModule\");\n-  nmodules = GetListOfModules(modules, kMaxModules, 0);\n }\n \n void *internal_start_thread(void(*func)(void *arg), void *arg) {"}, {"sha": "b44e56898d66ddb90c3ed189c5e032b5ff06a5d4", "filename": "libsanitizer/tsan/tsan_interface_ann.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_ann.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -52,7 +52,7 @@ class ScopedAnnotation {\n     StatInc(thr, StatAnnotation); \\\n     StatInc(thr, Stat##typ); \\\n     ScopedAnnotation sa(thr, __func__, f, l, caller_pc); \\\n-    const uptr pc = __sanitizer::StackTrace::GetCurrentPc(); \\\n+    const uptr pc = StackTrace::GetCurrentPc(); \\\n     (void)pc; \\\n /**/\n \n@@ -452,4 +452,6 @@ const char INTERFACE_ATTRIBUTE* ThreadSanitizerQuery(const char *query) {\n \n void INTERFACE_ATTRIBUTE\n AnnotateMemoryIsInitialized(char *f, int l, uptr mem, uptr sz) {}\n+void INTERFACE_ATTRIBUTE\n+AnnotateMemoryIsUninitialized(char *f, int l, uptr mem, uptr sz) {}\n }  // extern \"C\""}, {"sha": "15fc21c46277de65310caf80c0da8d138b0a794c", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -472,7 +472,7 @@ static void AtomicFence(ThreadState *thr, uptr pc, morder mo) {\n \n #define SCOPED_ATOMIC(func, ...) \\\n     const uptr callpc = (uptr)__builtin_return_address(0); \\\n-    uptr pc = __sanitizer::StackTrace::GetCurrentPc(); \\\n+    uptr pc = StackTrace::GetCurrentPc(); \\\n     mo = flags()->force_seq_cst_atomics ? (morder)mo_seq_cst : mo; \\\n     ThreadState *const thr = cur_thread(); \\\n     if (thr->ignore_interceptors) \\"}, {"sha": "6e1ec6de359bdc4c8398211a5b5a2d62e5930c78", "filename": "libsanitizer/tsan/tsan_interface_java.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -59,7 +59,7 @@ static JavaContext *jctx;\n #define SCOPED_JAVA_FUNC(func) \\\n   ThreadState *thr = cur_thread(); \\\n   const uptr caller_pc = GET_CALLER_PC(); \\\n-  const uptr pc = __sanitizer::StackTrace::GetCurrentPc(); \\\n+  const uptr pc = StackTrace::GetCurrentPc(); \\\n   (void)pc; \\\n   ScopedJavaFunc scoped(thr, caller_pc); \\\n /**/"}, {"sha": "d89610a2cc3b54e732387abd7f7cc4247ecad622", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -64,33 +64,35 @@ static void SignalUnsafeCall(ThreadState *thr, uptr pc) {\n   if (atomic_load(&thr->in_signal_handler, memory_order_relaxed) == 0 ||\n       !flags()->report_signal_unsafe)\n     return;\n-  StackTrace stack;\n-  stack.ObtainCurrent(thr, pc);\n+  VarSizeStackTrace stack;\n+  ObtainCurrentStack(thr, pc, &stack);\n   ThreadRegistryLock l(ctx->thread_registry);\n   ScopedReport rep(ReportTypeSignalUnsafe);\n   if (!IsFiredSuppression(ctx, rep, stack)) {\n-    rep.AddStack(&stack, true);\n+    rep.AddStack(stack, true);\n     OutputReport(thr, rep);\n   }\n }\n \n-void *user_alloc(ThreadState *thr, uptr pc, uptr sz, uptr align) {\n+void *user_alloc(ThreadState *thr, uptr pc, uptr sz, uptr align, bool signal) {\n   if ((sz >= (1ull << 40)) || (align >= (1ull << 40)))\n     return AllocatorReturnNull();\n   void *p = allocator()->Allocate(&thr->alloc_cache, sz, align);\n   if (p == 0)\n     return 0;\n   if (ctx && ctx->initialized)\n     OnUserAlloc(thr, pc, (uptr)p, sz, true);\n-  SignalUnsafeCall(thr, pc);\n+  if (signal)\n+    SignalUnsafeCall(thr, pc);\n   return p;\n }\n \n-void user_free(ThreadState *thr, uptr pc, void *p) {\n+void user_free(ThreadState *thr, uptr pc, void *p, bool signal) {\n   if (ctx && ctx->initialized)\n     OnUserFree(thr, pc, (uptr)p, true);\n   allocator()->Deallocate(&thr->alloc_cache, p);\n-  SignalUnsafeCall(thr, pc);\n+  if (signal)\n+    SignalUnsafeCall(thr, pc);\n }\n \n void OnUserAlloc(ThreadState *thr, uptr pc, uptr p, uptr sz, bool write) {"}, {"sha": "fe020af9d2d8a5249c201acc7f843f6bd7a16277", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -24,9 +24,9 @@ void AllocatorPrintStats();\n \n // For user allocations.\n void *user_alloc(ThreadState *thr, uptr pc, uptr sz,\n-                 uptr align = kDefaultAlignment);\n+                 uptr align = kDefaultAlignment, bool signal = true);\n // Does not accept NULL.\n-void user_free(ThreadState *thr, uptr pc, void *p);\n+void user_free(ThreadState *thr, uptr pc, void *p, bool signal = true);\n void *user_realloc(ThreadState *thr, uptr pc, void *p, uptr sz);\n void *user_alloc_aligned(ThreadState *thr, uptr pc, uptr sz, uptr align);\n uptr user_alloc_usable_size(const void *p);"}, {"sha": "35837d2132aeda1734f0a17e134d2eebbc2c3419", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 197, "deletions": 97, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -10,143 +10,247 @@\n // Platform-specific code.\n //===----------------------------------------------------------------------===//\n \n+#ifndef TSAN_PLATFORM_H\n+#define TSAN_PLATFORM_H\n+\n+#if !defined(__LP64__) && !defined(_WIN64)\n+# error \"Only 64-bit is supported\"\n+#endif\n+\n+#include \"tsan_defs.h\"\n+#include \"tsan_trace.h\"\n+\n+namespace __tsan {\n+\n+#if !defined(TSAN_GO)\n+\n /*\n-C++ linux memory layout:\n-0000 0000 0000 - 03c0 0000 0000: protected\n-03c0 0000 0000 - 1000 0000 0000: shadow\n-1000 0000 0000 - 3000 0000 0000: protected\n+C/C++ on linux and freebsd\n+0000 0000 1000 - 0100 0000 0000: main binary and/or MAP_32BIT mappings\n+0100 0000 0000 - 0200 0000 0000: -\n+0200 0000 0000 - 1000 0000 0000: shadow\n+1000 0000 0000 - 3000 0000 0000: -\n 3000 0000 0000 - 4000 0000 0000: metainfo (memory blocks and sync objects)\n-4000 0000 0000 - 6000 0000 0000: protected\n+4000 0000 0000 - 6000 0000 0000: -\n 6000 0000 0000 - 6200 0000 0000: traces\n 6200 0000 0000 - 7d00 0000 0000: -\n 7d00 0000 0000 - 7e00 0000 0000: heap\n-7e00 0000 0000 - 7fff ffff ffff: modules and main thread stack\n+7e00 0000 0000 - 7e80 0000 0000: -\n+7e80 0000 0000 - 8000 0000 0000: modules and main thread stack\n+*/\n \n-Go linux and darwin memory layout:\n-0000 0000 0000 - 0000 1000 0000: executable\n-0000 1000 0000 - 00f8 0000 0000: -\n+const uptr kMetaShadowBeg = 0x300000000000ull;\n+const uptr kMetaShadowEnd = 0x400000000000ull;\n+const uptr kTraceMemBeg   = 0x600000000000ull;\n+const uptr kTraceMemEnd   = 0x620000000000ull;\n+const uptr kShadowBeg     = 0x020000000000ull;\n+const uptr kShadowEnd     = 0x100000000000ull;\n+const uptr kHeapMemBeg    = 0x7d0000000000ull;\n+const uptr kHeapMemEnd    = 0x7e0000000000ull;\n+const uptr kLoAppMemBeg   = 0x000000001000ull;\n+const uptr kLoAppMemEnd   = 0x010000000000ull;\n+const uptr kHiAppMemBeg   = 0x7e8000000000ull;\n+const uptr kHiAppMemEnd   = 0x800000000000ull;\n+const uptr kAppMemMsk     = 0x7c0000000000ull;\n+const uptr kAppMemXor     = 0x020000000000ull;\n+\n+ALWAYS_INLINE\n+bool IsAppMem(uptr mem) {\n+  return (mem >= kHeapMemBeg && mem < kHeapMemEnd) ||\n+         (mem >= kLoAppMemBeg && mem < kLoAppMemEnd) ||\n+         (mem >= kHiAppMemBeg && mem < kHiAppMemEnd);\n+}\n+\n+ALWAYS_INLINE\n+bool IsShadowMem(uptr mem) {\n+  return mem >= kShadowBeg && mem <= kShadowEnd;\n+}\n+\n+ALWAYS_INLINE\n+bool IsMetaMem(uptr mem) {\n+  return mem >= kMetaShadowBeg && mem <= kMetaShadowEnd;\n+}\n+\n+ALWAYS_INLINE\n+uptr MemToShadow(uptr x) {\n+  DCHECK(IsAppMem(x));\n+  return (((x) & ~(kAppMemMsk | (kShadowCell - 1)))\n+      ^ kAppMemXor) * kShadowCnt;\n+}\n+\n+ALWAYS_INLINE\n+u32 *MemToMeta(uptr x) {\n+  DCHECK(IsAppMem(x));\n+  return (u32*)(((((x) & ~(kAppMemMsk | (kMetaShadowCell - 1)))\n+      ^ kAppMemXor) / kMetaShadowCell * kMetaShadowSize) | kMetaShadowBeg);\n+}\n+\n+ALWAYS_INLINE\n+uptr ShadowToMem(uptr s) {\n+  CHECK(IsShadowMem(s));\n+  if (s >= MemToShadow(kLoAppMemBeg) && s <= MemToShadow(kLoAppMemEnd - 1))\n+    return (s / kShadowCnt) ^ kAppMemXor;\n+  else\n+    return ((s / kShadowCnt) ^ kAppMemXor) | kAppMemMsk;\n+}\n+\n+static USED uptr UserRegions[] = {\n+  kLoAppMemBeg, kLoAppMemEnd,\n+  kHiAppMemBeg, kHiAppMemEnd,\n+  kHeapMemBeg,  kHeapMemEnd,\n+};\n+\n+#elif defined(TSAN_GO) && !SANITIZER_WINDOWS\n+\n+/* Go on linux, darwin and freebsd\n+0000 0000 1000 - 0000 1000 0000: executable\n+0000 1000 0000 - 00c0 0000 0000: -\n 00c0 0000 0000 - 00e0 0000 0000: heap\n-00e0 0000 0000 - 1000 0000 0000: -\n-1000 0000 0000 - 1380 0000 0000: shadow\n-1460 0000 0000 - 2000 0000 0000: -\n+00e0 0000 0000 - 2000 0000 0000: -\n+2000 0000 0000 - 2380 0000 0000: shadow\n+2380 0000 0000 - 3000 0000 0000: -\n 3000 0000 0000 - 4000 0000 0000: metainfo (memory blocks and sync objects)\n 4000 0000 0000 - 6000 0000 0000: -\n 6000 0000 0000 - 6200 0000 0000: traces\n-6200 0000 0000 - 7fff ffff ffff: -\n+6200 0000 0000 - 8000 0000 0000: -\n+*/\n+\n+const uptr kMetaShadowBeg = 0x300000000000ull;\n+const uptr kMetaShadowEnd = 0x400000000000ull;\n+const uptr kTraceMemBeg   = 0x600000000000ull;\n+const uptr kTraceMemEnd   = 0x620000000000ull;\n+const uptr kShadowBeg     = 0x200000000000ull;\n+const uptr kShadowEnd     = 0x238000000000ull;\n+const uptr kAppMemBeg     = 0x000000001000ull;\n+const uptr kAppMemEnd     = 0x00e000000000ull;\n+\n+ALWAYS_INLINE\n+bool IsAppMem(uptr mem) {\n+  return mem >= kAppMemBeg && mem < kAppMemEnd;\n+}\n+\n+ALWAYS_INLINE\n+bool IsShadowMem(uptr mem) {\n+  return mem >= kShadowBeg && mem <= kShadowEnd;\n+}\n+\n+ALWAYS_INLINE\n+bool IsMetaMem(uptr mem) {\n+  return mem >= kMetaShadowBeg && mem <= kMetaShadowEnd;\n+}\n+\n+ALWAYS_INLINE\n+uptr MemToShadow(uptr x) {\n+  DCHECK(IsAppMem(x));\n+  return ((x & ~(kShadowCell - 1)) * kShadowCnt) | kShadowBeg;\n+}\n \n-Go windows memory layout:\n-0000 0000 0000 - 0000 1000 0000: executable\n+ALWAYS_INLINE\n+u32 *MemToMeta(uptr x) {\n+  DCHECK(IsAppMem(x));\n+  return (u32*)(((x & ~(kMetaShadowCell - 1)) / \\\n+      kMetaShadowCell * kMetaShadowSize) | kMetaShadowBeg);\n+}\n+\n+ALWAYS_INLINE\n+uptr ShadowToMem(uptr s) {\n+  CHECK(IsShadowMem(s));\n+  return (s & ~kShadowBeg) / kShadowCnt;\n+}\n+\n+static USED uptr UserRegions[] = {\n+  kAppMemBeg, kAppMemEnd,\n+};\n+\n+#elif defined(TSAN_GO) && SANITIZER_WINDOWS\n+\n+/* Go on windows\n+0000 0000 1000 - 0000 1000 0000: executable\n 0000 1000 0000 - 00f8 0000 0000: -\n 00c0 0000 0000 - 00e0 0000 0000: heap\n 00e0 0000 0000 - 0100 0000 0000: -\n-0100 0000 0000 - 0560 0000 0000: shadow\n+0100 0000 0000 - 0380 0000 0000: shadow\n+0380 0000 0000 - 0560 0000 0000: -\n 0560 0000 0000 - 0760 0000 0000: traces\n 0760 0000 0000 - 07d0 0000 0000: metainfo (memory blocks and sync objects)\n-07d0 0000 0000 - 07ff ffff ffff: -\n+07d0 0000 0000 - 8000 0000 0000: -\n */\n \n-#ifndef TSAN_PLATFORM_H\n-#define TSAN_PLATFORM_H\n-\n-#include \"tsan_defs.h\"\n-#include \"tsan_trace.h\"\n-\n-#if defined(__LP64__) || defined(_WIN64)\n-namespace __tsan {\n-\n-#if defined(TSAN_GO)\n-static const uptr kLinuxAppMemBeg = 0x000000000000ULL;\n-static const uptr kLinuxAppMemEnd = 0x04dfffffffffULL;\n-# if SANITIZER_WINDOWS\n-static const uptr kLinuxShadowMsk = 0x010000000000ULL;\n-static const uptr kMetaShadow     = 0x076000000000ULL;\n-static const uptr kMetaSize       = 0x007000000000ULL;\n-# else  // if SANITIZER_WINDOWS\n-static const uptr kLinuxShadowMsk = 0x200000000000ULL;\n-static const uptr kMetaShadow     = 0x300000000000ULL;\n-static const uptr kMetaSize       = 0x100000000000ULL;\n-# endif  // if SANITIZER_WINDOWS\n-#else  // defined(TSAN_GO)\n-static const uptr kMetaShadow     = 0x300000000000ULL;\n-static const uptr kMetaSize       = 0x100000000000ULL;\n-static const uptr kLinuxAppMemBeg = 0x7cf000000000ULL;\n-static const uptr kLinuxAppMemEnd = 0x7fffffffffffULL;\n-#endif\n+const uptr kMetaShadowBeg = 0x076000000000ull;\n+const uptr kMetaShadowEnd = 0x07d000000000ull;\n+const uptr kTraceMemBeg   = 0x056000000000ull;\n+const uptr kTraceMemEnd   = 0x076000000000ull;\n+const uptr kShadowBeg     = 0x010000000000ull;\n+const uptr kShadowEnd     = 0x038000000000ull;\n+const uptr kAppMemBeg     = 0x000000001000ull;\n+const uptr kAppMemEnd     = 0x00e000000000ull;\n \n-static const uptr kLinuxAppMemMsk = 0x7c0000000000ULL;\n+ALWAYS_INLINE\n+bool IsAppMem(uptr mem) {\n+  return mem >= kAppMemBeg && mem < kAppMemEnd;\n+}\n \n-#if SANITIZER_WINDOWS\n-const uptr kTraceMemBegin = 0x056000000000ULL;\n-#else\n-const uptr kTraceMemBegin = 0x600000000000ULL;\n-#endif\n-const uptr kTraceMemSize = 0x020000000000ULL;\n-\n-// This has to be a macro to allow constant initialization of constants below.\n-#ifndef TSAN_GO\n-#define MemToShadow(addr) \\\n-    ((((uptr)addr) & ~(kLinuxAppMemMsk | (kShadowCell - 1))) * kShadowCnt)\n-#define MemToMeta(addr) \\\n-    (u32*)(((((uptr)addr) & ~(kLinuxAppMemMsk | (kMetaShadowCell - 1))) \\\n-    / kMetaShadowCell * kMetaShadowSize) | kMetaShadow)\n-#else\n-#define MemToShadow(addr) \\\n-    (((((uptr)addr) & ~(kShadowCell - 1)) * kShadowCnt) | kLinuxShadowMsk)\n-#define MemToMeta(addr) \\\n-    (u32*)(((((uptr)addr) & ~(kMetaShadowCell - 1)) \\\n-    / kMetaShadowCell * kMetaShadowSize) | kMetaShadow)\n-#endif\n+ALWAYS_INLINE\n+bool IsShadowMem(uptr mem) {\n+  return mem >= kShadowBeg && mem <= kShadowEnd;\n+}\n \n-static const uptr kLinuxShadowBeg = MemToShadow(kLinuxAppMemBeg);\n-static const uptr kLinuxShadowEnd =\n-    MemToShadow(kLinuxAppMemEnd) | 0xff;\n+ALWAYS_INLINE\n+bool IsMetaMem(uptr mem) {\n+  return mem >= kMetaShadowBeg && mem <= kMetaShadowEnd;\n+}\n \n-static inline bool IsAppMem(uptr mem) {\n-#if defined(TSAN_GO)\n-  return mem <= kLinuxAppMemEnd;\n-#else\n-  return mem >= kLinuxAppMemBeg && mem <= kLinuxAppMemEnd;\n-#endif\n+ALWAYS_INLINE\n+uptr MemToShadow(uptr x) {\n+  DCHECK(IsAppMem(x));\n+  return ((x & ~(kShadowCell - 1)) * kShadowCnt) | kShadowBeg;\n }\n \n-static inline bool IsShadowMem(uptr mem) {\n-  return mem >= kLinuxShadowBeg && mem <= kLinuxShadowEnd;\n+ALWAYS_INLINE\n+u32 *MemToMeta(uptr x) {\n+  DCHECK(IsAppMem(x));\n+  return (u32*)(((x & ~(kMetaShadowCell - 1)) / \\\n+      kMetaShadowCell * kMetaShadowSize) | kMetaShadowEnd);\n }\n \n-static inline uptr ShadowToMem(uptr shadow) {\n-  CHECK(IsShadowMem(shadow));\n-#ifdef TSAN_GO\n-  return (shadow & ~kLinuxShadowMsk) / kShadowCnt;\n-#else\n-  return (shadow / kShadowCnt) | kLinuxAppMemMsk;\n-#endif\n+ALWAYS_INLINE\n+uptr ShadowToMem(uptr s) {\n+  CHECK(IsShadowMem(s));\n+  // FIXME(dvyukov): this is most likely wrong as the mapping is not bijection.\n+  return (x & ~kShadowBeg) / kShadowCnt;\n }\n \n-void FlushShadowMemory();\n-void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive);\n-uptr GetRSS();\n+static USED uptr UserRegions[] = {\n+  kAppMemBeg, kAppMemEnd,\n+};\n \n-void InitializePlatform();\n-void FinalizePlatform();\n+#else\n+# error \"Unknown platform\"\n+#endif\n \n // The additional page is to catch shadow stack overflow as paging fault.\n // Windows wants 64K alignment for mmaps.\n const uptr kTotalTraceSize = (kTraceSize * sizeof(Event) + sizeof(Trace)\n     + (64 << 10) + (64 << 10) - 1) & ~((64 << 10) - 1);\n \n uptr ALWAYS_INLINE GetThreadTrace(int tid) {\n-  uptr p = kTraceMemBegin + (uptr)tid * kTotalTraceSize;\n-  DCHECK_LT(p, kTraceMemBegin + kTraceMemSize);\n+  uptr p = kTraceMemBeg + (uptr)tid * kTotalTraceSize;\n+  DCHECK_LT(p, kTraceMemEnd);\n   return p;\n }\n \n uptr ALWAYS_INLINE GetThreadTraceHeader(int tid) {\n-  uptr p = kTraceMemBegin + (uptr)tid * kTotalTraceSize\n+  uptr p = kTraceMemBeg + (uptr)tid * kTotalTraceSize\n       + kTraceSize * sizeof(Event);\n-  DCHECK_LT(p, kTraceMemBegin + kTraceMemSize);\n+  DCHECK_LT(p, kTraceMemEnd);\n   return p;\n }\n \n+void InitializePlatform();\n+void FlushShadowMemory();\n+void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive);\n+uptr GetRSS();\n+\n void *internal_start_thread(void(*func)(void*), void *arg);\n void internal_join_thread(void *th);\n \n@@ -162,8 +266,4 @@ int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n \n }  // namespace __tsan\n \n-#else  // defined(__LP64__) || defined(_WIN64)\n-# error \"Only 64-bit is supported\"\n-#endif\n-\n #endif  // TSAN_PLATFORM_H"}, {"sha": "32591316ea22b18f49de59c683744ce5b945ff43", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 73, "deletions": 76, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -7,7 +7,7 @@\n //\n // This file is a part of ThreadSanitizer (TSan), a race detector.\n //\n-// Linux-specific code.\n+// Linux- and FreeBSD-specific code.\n //===----------------------------------------------------------------------===//\n \n \n@@ -18,6 +18,7 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_procmaps.h\"\n #include \"sanitizer_common/sanitizer_stoptheworld.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n #include \"tsan_platform.h\"\n #include \"tsan_rtl.h\"\n #include \"tsan_flags.h\"\n@@ -60,6 +61,9 @@ void *__libc_stack_end = 0;\n \n namespace __tsan {\n \n+static uptr g_data_start;\n+static uptr g_data_end;\n+\n const uptr kPageSize = 4096;\n \n enum {\n@@ -74,35 +78,41 @@ enum {\n   MemCount  = 8,\n };\n \n-void FillProfileCallback(uptr start, uptr rss, bool file,\n+void FillProfileCallback(uptr p, uptr rss, bool file,\n                          uptr *mem, uptr stats_size) {\n   mem[MemTotal] += rss;\n-  start >>= 40;\n-  if (start < 0x10)\n+  if (p >= kShadowBeg && p < kShadowEnd)\n     mem[MemShadow] += rss;\n-  else if (start >= 0x20 && start < 0x30)\n-    mem[file ? MemFile : MemMmap] += rss;\n-  else if (start >= 0x30 && start < 0x40)\n+  else if (p >= kMetaShadowBeg && p < kMetaShadowEnd)\n     mem[MemMeta] += rss;\n-  else if (start >= 0x7e)\n+#ifndef TSAN_GO\n+  else if (p >= kHeapMemBeg && p < kHeapMemEnd)\n+    mem[MemHeap] += rss;\n+  else if (p >= kLoAppMemBeg && p < kLoAppMemEnd)\n     mem[file ? MemFile : MemMmap] += rss;\n-  else if (start >= 0x60 && start < 0x62)\n+  else if (p >= kHiAppMemBeg && p < kHiAppMemEnd)\n+    mem[file ? MemFile : MemMmap] += rss;\n+#else\n+  else if (p >= kAppMemBeg && p < kAppMemEnd)\n+    mem[file ? MemFile : MemMmap] += rss;\n+#endif\n+  else if (p >= kTraceMemBeg && p < kTraceMemEnd)\n     mem[MemTrace] += rss;\n-  else if (start >= 0x7d && start < 0x7e)\n-    mem[MemHeap] += rss;\n   else\n     mem[MemOther] += rss;\n }\n \n void WriteMemoryProfile(char *buf, uptr buf_size, uptr nthread, uptr nlive) {\n   uptr mem[MemCount] = {};\n   __sanitizer::GetMemoryProfile(FillProfileCallback, mem, 7);\n+  StackDepotStats *stacks = StackDepotGetStats();\n   internal_snprintf(buf, buf_size,\n       \"RSS %zd MB: shadow:%zd meta:%zd file:%zd mmap:%zd\"\n-      \" trace:%zd heap:%zd other:%zd nthr=%zd/%zd\\n\",\n+      \" trace:%zd heap:%zd other:%zd stacks=%zd[%zd] nthr=%zd/%zd\\n\",\n       mem[MemTotal] >> 20, mem[MemShadow] >> 20, mem[MemMeta] >> 20,\n       mem[MemFile] >> 20, mem[MemMmap] >> 20, mem[MemTrace] >> 20,\n       mem[MemHeap] >> 20, mem[MemOther] >> 20,\n+      stacks->allocated >> 20, stacks->n_uniq_ids,\n       nlive, nthread);\n }\n \n@@ -137,7 +147,7 @@ uptr GetRSS() {\n void FlushShadowMemoryCallback(\n     const SuspendedThreadsList &suspended_threads_list,\n     void *argument) {\n-  FlushUnneededShadowMemory(kLinuxShadowBeg, kLinuxShadowEnd - kLinuxShadowBeg);\n+  FlushUnneededShadowMemory(kShadowBeg, kShadowEnd - kShadowBeg);\n }\n #endif\n \n@@ -218,12 +228,12 @@ static void MapRodata() {\n \n void InitializeShadowMemory() {\n   // Map memory shadow.\n-  uptr shadow = (uptr)MmapFixedNoReserve(kLinuxShadowBeg,\n-    kLinuxShadowEnd - kLinuxShadowBeg);\n-  if (shadow != kLinuxShadowBeg) {\n+  uptr shadow = (uptr)MmapFixedNoReserve(kShadowBeg,\n+    kShadowEnd - kShadowBeg);\n+  if (shadow != kShadowBeg) {\n     Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n     Printf(\"FATAL: Make sure to compile with -fPIE and \"\n-               \"to link with -pie (%p, %p).\\n\", shadow, kLinuxShadowBeg);\n+               \"to link with -pie (%p, %p).\\n\", shadow, kShadowBeg);\n     Die();\n   }\n   // This memory range is used for thread stacks and large user mmaps.\n@@ -235,78 +245,42 @@ void InitializeShadowMemory() {\n       0x10000000000ULL * kShadowMultiplier, MADV_NOHUGEPAGE);\n #endif\n   DPrintf(\"memory shadow: %zx-%zx (%zuGB)\\n\",\n-      kLinuxShadowBeg, kLinuxShadowEnd,\n-      (kLinuxShadowEnd - kLinuxShadowBeg) >> 30);\n+      kShadowBeg, kShadowEnd,\n+      (kShadowEnd - kShadowBeg) >> 30);\n \n   // Map meta shadow.\n-  if (MemToMeta(kLinuxAppMemBeg) < (u32*)kMetaShadow) {\n-    Printf(\"ThreadSanitizer: bad meta shadow (%p -> %p < %p)\\n\",\n-        kLinuxAppMemBeg, MemToMeta(kLinuxAppMemBeg), kMetaShadow);\n-    Die();\n-  }\n-  if (MemToMeta(kLinuxAppMemEnd) >= (u32*)(kMetaShadow + kMetaSize)) {\n-    Printf(\"ThreadSanitizer: bad meta shadow (%p -> %p >= %p)\\n\",\n-        kLinuxAppMemEnd, MemToMeta(kLinuxAppMemEnd), kMetaShadow + kMetaSize);\n-    Die();\n-  }\n-  uptr meta = (uptr)MmapFixedNoReserve(kMetaShadow, kMetaSize);\n-  if (meta != kMetaShadow) {\n+  uptr meta_size = kMetaShadowEnd - kMetaShadowBeg;\n+  uptr meta = (uptr)MmapFixedNoReserve(kMetaShadowBeg, meta_size);\n+  if (meta != kMetaShadowBeg) {\n     Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n     Printf(\"FATAL: Make sure to compile with -fPIE and \"\n-               \"to link with -pie (%p, %p).\\n\", meta, kMetaShadow);\n+               \"to link with -pie (%p, %p).\\n\", meta, kMetaShadowBeg);\n     Die();\n   }\n   DPrintf(\"meta shadow: %zx-%zx (%zuGB)\\n\",\n-      kMetaShadow, kMetaShadow + kMetaSize, kMetaSize >> 30);\n-\n-  // Protect gaps.\n-  const uptr kClosedLowBeg  = 0x200000;\n-  const uptr kClosedLowEnd  = kLinuxShadowBeg - 1;\n-  const uptr kClosedMidBeg = kLinuxShadowEnd + 1;\n-  const uptr kClosedMidEnd = min(min(kLinuxAppMemBeg, kTraceMemBegin),\n-      kMetaShadow);\n-\n-  ProtectRange(kClosedLowBeg, kClosedLowEnd);\n-  ProtectRange(kClosedMidBeg, kClosedMidEnd);\n-  VPrintf(2, \"kClosedLow   %zx-%zx (%zuGB)\\n\",\n-      kClosedLowBeg, kClosedLowEnd, (kClosedLowEnd - kClosedLowBeg) >> 30);\n-  VPrintf(2, \"kClosedMid   %zx-%zx (%zuGB)\\n\",\n-      kClosedMidBeg, kClosedMidEnd, (kClosedMidEnd - kClosedMidBeg) >> 30);\n-  VPrintf(2, \"app mem: %zx-%zx (%zuGB)\\n\",\n-      kLinuxAppMemBeg, kLinuxAppMemEnd,\n-      (kLinuxAppMemEnd - kLinuxAppMemBeg) >> 30);\n-  VPrintf(2, \"stack: %zx\\n\", (uptr)&shadow);\n+      meta, meta + meta_size, meta_size >> 30);\n \n   MapRodata();\n }\n-#endif\n-\n-static uptr g_data_start;\n-static uptr g_data_end;\n-\n-#ifndef TSAN_GO\n-static void CheckPIE() {\n-  // Ensure that the binary is indeed compiled with -pie.\n-  MemoryMappingLayout proc_maps(true);\n-  uptr start, end;\n-  if (proc_maps.Next(&start, &end,\n-                     /*offset*/0, /*filename*/0, /*filename_size*/0,\n-                     /*protection*/0)) {\n-    if ((u64)start < kLinuxAppMemBeg) {\n-      Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory (\"\n-             \"something is mapped at 0x%zx < 0x%zx)\\n\",\n-             start, kLinuxAppMemBeg);\n-      Printf(\"FATAL: Make sure to compile with -fPIE\"\n-             \" and to link with -pie.\\n\");\n-      Die();\n-    }\n-  }\n-}\n \n static void InitDataSeg() {\n   MemoryMappingLayout proc_maps(true);\n   uptr start, end, offset;\n   char name[128];\n+#if SANITIZER_FREEBSD\n+  // On FreeBSD BSS is usually the last block allocated within the\n+  // low range and heap is the last block allocated within the range\n+  // 0x800000000-0x8ffffffff.\n+  while (proc_maps.Next(&start, &end, &offset, name, ARRAY_SIZE(name),\n+                        /*protection*/ 0)) {\n+    DPrintf(\"%p-%p %p %s\\n\", start, end, offset, name);\n+    if ((start & 0xffff00000000ULL) == 0 && (end & 0xffff00000000ULL) == 0 &&\n+        name[0] == '\\0') {\n+      g_data_start = start;\n+      g_data_end = end;\n+    }\n+  }\n+#else\n   bool prev_is_data = false;\n   while (proc_maps.Next(&start, &end, &offset, name, ARRAY_SIZE(name),\n                         /*protection*/ 0)) {\n@@ -322,12 +296,35 @@ static void InitDataSeg() {\n       g_data_end = end;\n     prev_is_data = is_data;\n   }\n+#endif\n   DPrintf(\"guessed data_start=%p data_end=%p\\n\",  g_data_start, g_data_end);\n   CHECK_LT(g_data_start, g_data_end);\n   CHECK_GE((uptr)&g_data_start, g_data_start);\n   CHECK_LT((uptr)&g_data_start, g_data_end);\n }\n \n+static void CheckAndProtect() {\n+  // Ensure that the binary is indeed compiled with -pie.\n+  MemoryMappingLayout proc_maps(true);\n+  uptr p, end;\n+  while (proc_maps.Next(&p, &end, 0, 0, 0, 0)) {\n+    if (IsAppMem(p))\n+      continue;\n+    if (p >= kHeapMemEnd &&\n+        p < kHeapMemEnd + PrimaryAllocator::AdditionalSize())\n+      continue;\n+    if (p >= 0xf000000000000000ull)  // vdso\n+      break;\n+    Printf(\"FATAL: ThreadSanitizer: unexpected memory mapping %p-%p\\n\", p, end);\n+    Die();\n+  }\n+\n+  ProtectRange(kLoAppMemEnd, kShadowBeg);\n+  ProtectRange(kShadowEnd, kMetaShadowBeg);\n+  ProtectRange(kMetaShadowEnd, kTraceMemBeg);\n+  ProtectRange(kTraceMemEnd, kHeapMemBeg);\n+  ProtectRange(kHeapMemEnd + PrimaryAllocator::AdditionalSize(), kHiAppMemBeg);\n+}\n #endif  // #ifndef TSAN_GO\n \n void InitializePlatform() {\n@@ -363,7 +360,7 @@ void InitializePlatform() {\n   }\n \n #ifndef TSAN_GO\n-  CheckPIE();\n+  CheckAndProtect();\n   InitTlsSize();\n   InitDataSeg();\n #endif\n@@ -426,4 +423,4 @@ int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n \n }  // namespace __tsan\n \n-#endif  // SANITIZER_LINUX\n+#endif  // SANITIZER_LINUX || SANITIZER_FREEBSD"}, {"sha": "2091318a674aefad59cf0da8b1eb866ebbca60bf", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -54,31 +54,27 @@ uptr GetRSS() {\n \n #ifndef TSAN_GO\n void InitializeShadowMemory() {\n-  uptr shadow = (uptr)MmapFixedNoReserve(kLinuxShadowBeg,\n-    kLinuxShadowEnd - kLinuxShadowBeg);\n-  if (shadow != kLinuxShadowBeg) {\n+  uptr shadow = (uptr)MmapFixedNoReserve(kShadowBeg,\n+    kShadowEnd - kShadowBeg);\n+  if (shadow != kShadowBeg) {\n     Printf(\"FATAL: ThreadSanitizer can not mmap the shadow memory\\n\");\n     Printf(\"FATAL: Make sure to compile with -fPIE and \"\n            \"to link with -pie.\\n\");\n     Die();\n   }\n-  DPrintf(\"kLinuxShadow %zx-%zx (%zuGB)\\n\",\n-      kLinuxShadowBeg, kLinuxShadowEnd,\n-      (kLinuxShadowEnd - kLinuxShadowBeg) >> 30);\n-  DPrintf(\"kLinuxAppMem %zx-%zx (%zuGB)\\n\",\n-      kLinuxAppMemBeg, kLinuxAppMemEnd,\n-      (kLinuxAppMemEnd - kLinuxAppMemBeg) >> 30);\n+  DPrintf(\"kShadow %zx-%zx (%zuGB)\\n\",\n+      kShadowBeg, kShadowEnd,\n+      (kShadowEnd - kShadowBeg) >> 30);\n+  DPrintf(\"kAppMem %zx-%zx (%zuGB)\\n\",\n+      kAppMemBeg, kAppMemEnd,\n+      (kAppMemEnd - kAppMemBeg) >> 30);\n }\n #endif\n \n void InitializePlatform() {\n   DisableCoreDumperIfNecessary();\n }\n \n-void FinalizePlatform() {\n-  fflush(0);\n-}\n-\n #ifndef TSAN_GO\n int call_pthread_cancel_with_cleanup(int(*fn)(void *c, void *m,\n     void *abstime), void *c, void *m, void *abstime,"}, {"sha": "3f81c54e3ebe8827955563b399848ea1915a67f7", "filename": "libsanitizer/tsan/tsan_platform_windows.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -36,10 +36,6 @@ uptr GetRSS() {\n void InitializePlatform() {\n }\n \n-void FinalizePlatform() {\n-  fflush(0);\n-}\n-\n }  // namespace __tsan\n \n #endif  // SANITIZER_WINDOWS"}, {"sha": "6feab81383fe2f68d6da081b62923a9b9a399db7", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -11,10 +11,30 @@\n #include \"tsan_report.h\"\n #include \"tsan_platform.h\"\n #include \"tsan_rtl.h\"\n+#include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_report_decorator.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace_printer.h\"\n \n namespace __tsan {\n \n+ReportStack::ReportStack() : next(nullptr), info(), suppressable(false) {}\n+\n+ReportStack *ReportStack::New(uptr addr) {\n+  void *mem = internal_alloc(MBlockReportStack, sizeof(ReportStack));\n+  ReportStack *res = new(mem) ReportStack();\n+  res->info.address = addr;\n+  return res;\n+}\n+\n+ReportLocation::ReportLocation(ReportLocationType type)\n+    : type(type), global(), heap_chunk_start(0), heap_chunk_size(0), tid(0),\n+      fd(0), suppressable(false), stack(nullptr) {}\n+\n+ReportLocation *ReportLocation::New(ReportLocationType type) {\n+  void *mem = internal_alloc(MBlockReportStack, sizeof(ReportLocation));\n+  return new(mem) ReportLocation(type);\n+}\n+\n class Decorator: public __sanitizer::SanitizerCommonDecorator {\n  public:\n   Decorator() : SanitizerCommonDecorator() { }\n@@ -68,6 +88,8 @@ static const char *ReportTypeString(ReportType typ) {\n     return \"data race on vptr (ctor/dtor vs virtual call)\";\n   if (typ == ReportTypeUseAfterFree)\n     return \"heap-use-after-free\";\n+  if (typ == ReportTypeVptrUseAfterFree)\n+    return \"heap-use-after-free (virtual call vs free)\";\n   if (typ == ReportTypeThreadLeak)\n     return \"thread leak\";\n   if (typ == ReportTypeMutexDestroyLocked)\n@@ -94,14 +116,11 @@ void PrintStack(const ReportStack *ent) {\n     Printf(\"    [failed to restore the stack]\\n\\n\");\n     return;\n   }\n-  for (int i = 0; ent; ent = ent->next, i++) {\n-    Printf(\"    #%d %s %s:%d\", i, ent->func, ent->file, ent->line);\n-    if (ent->col)\n-      Printf(\":%d\", ent->col);\n-    if (ent->module && ent->offset)\n-      Printf(\" (%s+%p)\\n\", ent->module, (void*)ent->offset);\n-    else\n-      Printf(\" (%p)\\n\", (void*)ent->pc);\n+  for (int i = 0; ent && ent->info.address; ent = ent->next, i++) {\n+    InternalScopedString res(2 * GetPageSizeCached());\n+    RenderFrame(&res, common_flags()->stack_trace_format, i, ent->info,\n+                common_flags()->strip_path_prefix, \"__interceptor_\");\n+    Printf(\"%s\\n\", res.data());\n   }\n   Printf(\"\\n\");\n }\n@@ -143,12 +162,15 @@ static void PrintLocation(const ReportLocation *loc) {\n   bool print_stack = false;\n   Printf(\"%s\", d.Location());\n   if (loc->type == ReportLocationGlobal) {\n+    const DataInfo &global = loc->global;\n     Printf(\"  Location is global '%s' of size %zu at %p (%s+%p)\\n\\n\",\n-               loc->name, loc->size, loc->addr, loc->module, loc->offset);\n+           global.name, global.size, global.start,\n+           StripModuleName(global.module), global.module_offset);\n   } else if (loc->type == ReportLocationHeap) {\n     char thrbuf[kThreadBufSize];\n     Printf(\"  Location is heap block of size %zu at %p allocated by %s:\\n\",\n-        loc->size, loc->addr, thread_name(thrbuf, loc->tid));\n+           loc->heap_chunk_size, loc->heap_chunk_start,\n+           thread_name(thrbuf, loc->tid));\n     print_stack = true;\n   } else if (loc->type == ReportLocationStack) {\n     Printf(\"  Location is stack of %s.\\n\\n\", thread_name(thrbuf, loc->tid));\n@@ -301,8 +323,10 @@ void PrintReport(const ReportDesc *rep) {\n   if (rep->typ == ReportTypeThreadLeak && rep->count > 1)\n     Printf(\"  And %d more similar thread leaks.\\n\\n\", rep->count - 1);\n \n-  if (ReportStack *ent = SkipTsanInternalFrames(ChooseSummaryStack(rep)))\n-    ReportErrorSummary(rep_typ_str, ent->file, ent->line, ent->func);\n+  if (ReportStack *ent = SkipTsanInternalFrames(ChooseSummaryStack(rep))) {\n+    const AddressInfo &info = ent->info;\n+    ReportErrorSummary(rep_typ_str, info.file, info.line, info.function);\n+  }\n \n   Printf(\"==================\\n\");\n }\n@@ -317,8 +341,9 @@ void PrintStack(const ReportStack *ent) {\n     return;\n   }\n   for (int i = 0; ent; ent = ent->next, i++) {\n-    Printf(\"  %s()\\n      %s:%d +0x%zx\\n\",\n-        ent->func, ent->file, ent->line, (void*)ent->offset);\n+    const AddressInfo &info = ent->info;\n+    Printf(\"  %s()\\n      %s:%d +0x%zx\\n\", info.function, info.file, info.line,\n+           (void *)info.module_offset);\n   }\n }\n "}, {"sha": "3d99c7a7c24fb627eeba977085758ac4b01fc73d", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -11,6 +11,7 @@\n #ifndef TSAN_REPORT_H\n #define TSAN_REPORT_H\n \n+#include \"sanitizer_common/sanitizer_symbolizer.h\"\n #include \"tsan_defs.h\"\n #include \"tsan_vector.h\"\n \n@@ -20,6 +21,7 @@ enum ReportType {\n   ReportTypeRace,\n   ReportTypeVptrRace,\n   ReportTypeUseAfterFree,\n+  ReportTypeVptrUseAfterFree,\n   ReportTypeThreadLeak,\n   ReportTypeMutexDestroyLocked,\n   ReportTypeMutexDoubleLock,\n@@ -33,14 +35,12 @@ enum ReportType {\n \n struct ReportStack {\n   ReportStack *next;\n-  char *module;\n-  uptr offset;\n-  uptr pc;\n-  char *func;\n-  char *file;\n-  int line;\n-  int col;\n+  AddressInfo info;\n   bool suppressable;\n+  static ReportStack *New(uptr addr);\n+\n+ private:\n+  ReportStack();\n };\n \n struct ReportMopMutex {\n@@ -70,17 +70,17 @@ enum ReportLocationType {\n \n struct ReportLocation {\n   ReportLocationType type;\n-  uptr addr;\n-  uptr size;\n-  char *module;\n-  uptr offset;\n+  DataInfo global;\n+  uptr heap_chunk_start;\n+  uptr heap_chunk_size;\n   int tid;\n   int fd;\n-  char *name;\n-  char *file;\n-  int line;\n   bool suppressable;\n   ReportStack *stack;\n+\n+  static ReportLocation *New(ReportLocationType type);\n+ private:\n+  explicit ReportLocation(ReportLocationType type);\n };\n \n struct ReportThread {"}, {"sha": "bf971b62da4c52728150b187769061a00bb1e645", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -259,8 +259,8 @@ void MapShadow(uptr addr, uptr size) {\n \n void MapThreadTrace(uptr addr, uptr size) {\n   DPrintf(\"#0: Mapping trace at %p-%p(0x%zx)\\n\", addr, addr + size, size);\n-  CHECK_GE(addr, kTraceMemBegin);\n-  CHECK_LE(addr + size, kTraceMemBegin + kTraceMemSize);\n+  CHECK_GE(addr, kTraceMemBeg);\n+  CHECK_LE(addr + size, kTraceMemEnd);\n   CHECK_EQ(addr, addr & ~((64 << 10) - 1));  // windows wants 64K alignment\n   uptr addr1 = (uptr)MmapFixedNoReserve(addr, size);\n   if (addr1 != addr) {\n@@ -270,6 +270,28 @@ void MapThreadTrace(uptr addr, uptr size) {\n   }\n }\n \n+static void CheckShadowMapping() {\n+  for (uptr i = 0; i < ARRAY_SIZE(UserRegions); i += 2) {\n+    const uptr beg = UserRegions[i];\n+    const uptr end = UserRegions[i + 1];\n+    VPrintf(3, \"checking shadow region %p-%p\\n\", beg, end);\n+    for (uptr p0 = beg; p0 <= end; p0 += (end - beg) / 4) {\n+      for (int x = -1; x <= 1; x++) {\n+        const uptr p = p0 + x;\n+        if (p < beg || p >= end)\n+          continue;\n+        const uptr s = MemToShadow(p);\n+        VPrintf(3, \"  checking pointer %p -> %p\\n\", p, s);\n+        CHECK(IsAppMem(p));\n+        CHECK(IsShadowMem(s));\n+        CHECK_EQ(p & ~(kShadowCell - 1), ShadowToMem(s));\n+        const uptr m = (uptr)MemToMeta(p);\n+        CHECK(IsMetaMem(m));\n+      }\n+    }\n+  }\n+}\n+\n void Initialize(ThreadState *thr) {\n   // Thread safe because done before all threads exist.\n   static bool is_initialized = false;\n@@ -289,6 +311,7 @@ void Initialize(ThreadState *thr) {\n   InitializeAllocator();\n #endif\n   InitializeInterceptors();\n+  CheckShadowMapping();\n   InitializePlatform();\n   InitializeMutex();\n   InitializeDynamicAnnotations();\n@@ -437,8 +460,8 @@ u32 CurrentStackId(ThreadState *thr, uptr pc) {\n     thr->shadow_stack_pos[0] = pc;\n     thr->shadow_stack_pos++;\n   }\n-  u32 id = StackDepotPut(thr->shadow_stack,\n-                         thr->shadow_stack_pos - thr->shadow_stack);\n+  u32 id = StackDepotPut(\n+      StackTrace(thr->shadow_stack, thr->shadow_stack_pos - thr->shadow_stack));\n   if (pc != 0)\n     thr->shadow_stack_pos--;\n   return id;\n@@ -451,7 +474,7 @@ void TraceSwitch(ThreadState *thr) {\n   unsigned trace = (thr->fast_state.epoch() / kTracePartSize) % TraceParts();\n   TraceHeader *hdr = &thr_trace->headers[trace];\n   hdr->epoch0 = thr->fast_state.epoch();\n-  hdr->stack0.ObtainCurrent(thr, 0);\n+  ObtainCurrentStack(thr, 0, &hdr->stack0);\n   hdr->mset0 = thr->mset;\n   thr->nomalloc--;\n }\n@@ -690,6 +713,8 @@ ALWAYS_INLINE\n bool ContainsSameAccess(u64 *s, u64 a, u64 sync_epoch, bool is_write) {\n #if defined(__SSE3__) && TSAN_SHADOW_COUNT == 4\n   bool res = ContainsSameAccessFast(s, a, sync_epoch, is_write);\n+  // NOTE: this check can fail if the shadow is concurrently mutated\n+  // by other threads.\n   DCHECK_EQ(res, ContainsSameAccessSlow(s, a, sync_epoch, is_write));\n   return res;\n #else"}, {"sha": "3f7873165cd9b4ef2d2397a0f86df917eb2b269e", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -51,11 +51,8 @@\n namespace __tsan {\n \n #ifndef TSAN_GO\n-const uptr kAllocatorSpace = 0x7d0000000000ULL;\n-const uptr kAllocatorSize  =  0x10000000000ULL;  // 1T.\n-\n struct MapUnmapCallback;\n-typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, 0,\n+typedef SizeClassAllocator64<kHeapMemBeg, kHeapMemEnd - kHeapMemBeg, 0,\n     DefaultSizeClassMap, MapUnmapCallback> PrimaryAllocator;\n typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n typedef LargeMmapAllocator<MapUnmapCallback> SecondaryAllocator;\n@@ -499,9 +496,9 @@ class ScopedReport {\n   explicit ScopedReport(ReportType typ);\n   ~ScopedReport();\n \n-  void AddMemoryAccess(uptr addr, Shadow s, const StackTrace *stack,\n+  void AddMemoryAccess(uptr addr, Shadow s, StackTrace stack,\n                        const MutexSet *mset);\n-  void AddStack(const StackTrace *stack, bool suppressable = false);\n+  void AddStack(StackTrace stack, bool suppressable = false);\n   void AddThread(const ThreadContext *tctx, bool suppressable = false);\n   void AddThread(int unique_tid, bool suppressable = false);\n   void AddUniqueTid(int unique_tid);\n@@ -525,7 +522,20 @@ class ScopedReport {\n   void operator = (const ScopedReport&);\n };\n \n-void RestoreStack(int tid, const u64 epoch, StackTrace *stk, MutexSet *mset);\n+void RestoreStack(int tid, const u64 epoch, VarSizeStackTrace *stk,\n+                  MutexSet *mset);\n+\n+template<typename StackTraceTy>\n+void ObtainCurrentStack(ThreadState *thr, uptr toppc, StackTraceTy *stack) {\n+  uptr size = thr->shadow_stack_pos - thr->shadow_stack;\n+  uptr start = 0;\n+  if (size + !!toppc > kStackTraceMax) {\n+    start = size + !!toppc - kStackTraceMax;\n+    size = kStackTraceMax - !!toppc;\n+  }\n+  stack->Init(&thr->shadow_stack[start], size, toppc);\n+}\n+\n \n void StatAggregate(u64 *dst, u64 *src);\n void StatOutput(u64 *stat);\n@@ -552,9 +562,8 @@ void ForkChildAfter(ThreadState *thr, uptr pc);\n \n void ReportRace(ThreadState *thr);\n bool OutputReport(ThreadState *thr, const ScopedReport &srep);\n-bool IsFiredSuppression(Context *ctx,\n-                        const ScopedReport &srep,\n-                        const StackTrace &trace);\n+bool IsFiredSuppression(Context *ctx, const ScopedReport &srep,\n+                        StackTrace trace);\n bool IsExpectedReport(uptr addr, uptr size);\n void PrintMatchedBenignRaces();\n bool FrameIsInternal(const ReportStack *frame);\n@@ -575,7 +584,7 @@ ReportStack *SkipTsanInternalFrames(ReportStack *ent);\n u32 CurrentStackId(ThreadState *thr, uptr pc);\n ReportStack *SymbolizeStackId(u32 stack_id);\n void PrintCurrentStack(ThreadState *thr, uptr pc);\n-void PrintCurrentStackSlow();  // uses libunwind\n+void PrintCurrentStackSlow(uptr pc);  // uses libunwind\n \n void Initialize(ThreadState *thr);\n int Finalize(ThreadState *thr);"}, {"sha": "6df36a500a719228f5fba2ff3e2a2960c2b3a23a", "filename": "libsanitizer/tsan/tsan_rtl_amd64.S", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -170,10 +170,15 @@ setjmp:\n   CFI_ADJUST_CFA_OFFSET(8)\n   CFI_REL_OFFSET(%rdi, 0)\n   // obtain %rsp\n+#if defined(__FreeBSD__)\n+  lea 8(%rsp), %rdi\n+  mov %rdi, %rsi\n+#else\n   lea 16(%rsp), %rdi\n   mov %rdi, %rsi\n   xor %fs:0x30, %rsi  // magic mangling of rsp (see libc setjmp)\n   rol $0x11, %rsi\n+#endif\n   // call tsan interceptor\n   call __tsan_setjmp\n   // restore env parameter\n@@ -197,10 +202,15 @@ _setjmp:\n   CFI_ADJUST_CFA_OFFSET(8)\n   CFI_REL_OFFSET(%rdi, 0)\n   // obtain %rsp\n+#if defined(__FreeBSD__)\n+  lea 8(%rsp), %rdi\n+  mov %rdi, %rsi\n+#else\n   lea 16(%rsp), %rdi\n   mov %rdi, %rsi\n   xor %fs:0x30, %rsi  // magic mangling of rsp (see libc setjmp)\n   rol $0x11, %rsi\n+#endif\n   // call tsan interceptor\n   call __tsan_setjmp\n   // restore env parameter\n@@ -231,10 +241,15 @@ sigsetjmp:\n   sub $8, %rsp\n   CFI_ADJUST_CFA_OFFSET(8)\n   // obtain %rsp\n+#if defined(__FreeBSD__)\n+  lea 24(%rsp), %rdi\n+  mov %rdi, %rsi\n+#else\n   lea 32(%rsp), %rdi\n   mov %rdi, %rsi\n   xor %fs:0x30, %rsi  // magic mangling of rsp (see libc setjmp)\n   rol $0x11, %rsi\n+#endif\n   // call tsan interceptor\n   call __tsan_setjmp\n   // unalign stack frame\n@@ -272,10 +287,15 @@ __sigsetjmp:\n   sub $8, %rsp\n   CFI_ADJUST_CFA_OFFSET(8)\n   // obtain %rsp\n+#if defined(__FreeBSD__)\n+  lea 24(%rsp), %rdi\n+  mov %rdi, %rsi\n+#else\n   lea 32(%rsp), %rdi\n   mov %rdi, %rsi\n   xor %fs:0x30, %rsi  // magic mangling of rsp (see libc setjmp)\n   rol $0x11, %rsi\n+#endif\n   // call tsan interceptor\n   call __tsan_setjmp\n   // unalign stack frame\n@@ -296,7 +316,7 @@ __sigsetjmp:\n   CFI_ENDPROC\n .size __sigsetjmp, .-__sigsetjmp\n \n-#ifdef __linux__\n+#if defined(__FreeBSD__) || defined(__linux__)\n /* We do not need executable stack.  */\n .section        .note.GNU-stack,\"\",@progbits\n #endif"}, {"sha": "d731b4bfb594770c6bf2608e71a39194d3c1df21", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -57,9 +57,9 @@ static void ReportMutexMisuse(ThreadState *thr, uptr pc, ReportType typ,\n   ThreadRegistryLock l(ctx->thread_registry);\n   ScopedReport rep(typ);\n   rep.AddMutex(mid);\n-  StackTrace trace;\n-  trace.ObtainCurrent(thr, pc);\n-  rep.AddStack(&trace, true);\n+  VarSizeStackTrace trace;\n+  ObtainCurrentStack(thr, pc, &trace);\n+  rep.AddStack(trace, true);\n   rep.AddLocation(addr, 1);\n   OutputReport(thr, rep);\n }\n@@ -122,12 +122,12 @@ void MutexDestroy(ThreadState *thr, uptr pc, uptr addr) {\n     ThreadRegistryLock l(ctx->thread_registry);\n     ScopedReport rep(ReportTypeMutexDestroyLocked);\n     rep.AddMutex(mid);\n-    StackTrace trace;\n-    trace.ObtainCurrent(thr, pc);\n-    rep.AddStack(&trace);\n+    VarSizeStackTrace trace;\n+    ObtainCurrentStack(thr, pc, &trace);\n+    rep.AddStack(trace);\n     FastState last(last_lock);\n     RestoreStack(last.tid(), last.epoch(), &trace, 0);\n-    rep.AddStack(&trace, true);\n+    rep.AddStack(trace, true);\n     rep.AddLocation(addr, 1);\n     OutputReport(thr, rep);\n   }\n@@ -470,21 +470,17 @@ void ReportDeadlock(ThreadState *thr, uptr pc, DDReport *r) {\n     rep.AddUniqueTid((int)r->loop[i].thr_ctx);\n     rep.AddThread((int)r->loop[i].thr_ctx);\n   }\n-  InternalScopedBuffer<StackTrace> stacks(2 * DDReport::kMaxLoopSize);\n   uptr dummy_pc = 0x42;\n   for (int i = 0; i < r->n; i++) {\n-    uptr size;\n     for (int j = 0; j < (flags()->second_deadlock_stack ? 2 : 1); j++) {\n       u32 stk = r->loop[i].stk[j];\n       if (stk) {\n-        const uptr *trace = StackDepotGet(stk, &size);\n-        stacks[i].Init(const_cast<uptr *>(trace), size);\n+        rep.AddStack(StackDepotGet(stk), true);\n       } else {\n         // Sometimes we fail to extract the stack trace (FIXME: investigate),\n         // but we should still produce some stack trace in the report.\n-        stacks[i].Init(&dummy_pc, 1);\n+        rep.AddStack(StackTrace(&dummy_pc, 1), true);\n       }\n-      rep.AddStack(&stacks[i], true);\n     }\n   }\n   OutputReport(thr, rep);"}, {"sha": "11ec8381de6e2ce05a58ec466f9126077cb0f229", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 81, "deletions": 93, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -28,7 +28,7 @@ namespace __tsan {\n \n using namespace __sanitizer;  // NOLINT\n \n-static ReportStack *SymbolizeStack(const StackTrace& trace);\n+static ReportStack *SymbolizeStack(StackTrace trace);\n \n void TsanCheckFailed(const char *file, int line, const char *cond,\n                      u64 v1, u64 v2) {\n@@ -39,7 +39,7 @@ void TsanCheckFailed(const char *file, int line, const char *cond,\n   Printf(\"FATAL: ThreadSanitizer CHECK failed: \"\n          \"%s:%d \\\"%s\\\" (0x%zx, 0x%zx)\\n\",\n          file, line, cond, (uptr)v1, (uptr)v2);\n-  PrintCurrentStackSlow();\n+  PrintCurrentStackSlow(StackTrace::GetCurrentPc());\n   Die();\n }\n \n@@ -57,27 +57,16 @@ bool WEAK OnReport(const ReportDesc *rep, bool suppressed) {\n static void StackStripMain(ReportStack *stack) {\n   ReportStack *last_frame = 0;\n   ReportStack *last_frame2 = 0;\n-  const char *prefix = \"__interceptor_\";\n-  uptr prefix_len = internal_strlen(prefix);\n-  const char *path_prefix = common_flags()->strip_path_prefix;\n-  uptr path_prefix_len = internal_strlen(path_prefix);\n-  char *pos;\n   for (ReportStack *ent = stack; ent; ent = ent->next) {\n-    if (ent->func && 0 == internal_strncmp(ent->func, prefix, prefix_len))\n-      ent->func += prefix_len;\n-    if (ent->file && (pos = internal_strstr(ent->file, path_prefix)))\n-      ent->file = pos + path_prefix_len;\n-    if (ent->file && ent->file[0] == '.' && ent->file[1] == '/')\n-      ent->file += 2;\n     last_frame2 = last_frame;\n     last_frame = ent;\n   }\n \n   if (last_frame2 == 0)\n     return;\n-  const char *last = last_frame->func;\n+  const char *last = last_frame->info.function;\n #ifndef TSAN_GO\n-  const char *last2 = last_frame2->func;\n+  const char *last2 = last_frame2->info.function;\n   // Strip frame above 'main'\n   if (last2 && 0 == internal_strcmp(last2, \"main\")) {\n     last_frame2->next = 0;\n@@ -105,39 +94,36 @@ static void StackStripMain(ReportStack *stack) {\n ReportStack *SymbolizeStackId(u32 stack_id) {\n   if (stack_id == 0)\n     return 0;\n-  uptr ssz = 0;\n-  const uptr *stack = StackDepotGet(stack_id, &ssz);\n-  if (stack == 0)\n-    return 0;\n-  StackTrace trace;\n-  trace.Init(stack, ssz);\n-  return SymbolizeStack(trace);\n+  StackTrace stack = StackDepotGet(stack_id);\n+  if (stack.trace == nullptr)\n+    return nullptr;\n+  return SymbolizeStack(stack);\n }\n \n-static ReportStack *SymbolizeStack(const StackTrace& trace) {\n-  if (trace.IsEmpty())\n+static ReportStack *SymbolizeStack(StackTrace trace) {\n+  if (trace.size == 0)\n     return 0;\n   ReportStack *stack = 0;\n-  for (uptr si = 0; si < trace.Size(); si++) {\n-    const uptr pc = trace.Get(si);\n+  for (uptr si = 0; si < trace.size; si++) {\n+    const uptr pc = trace.trace[si];\n #ifndef TSAN_GO\n     // We obtain the return address, that is, address of the next instruction,\n     // so offset it by 1 byte.\n-    const uptr pc1 = __sanitizer::StackTrace::GetPreviousInstructionPc(pc);\n+    const uptr pc1 = StackTrace::GetPreviousInstructionPc(pc);\n #else\n     // FIXME(dvyukov): Go sometimes uses address of a function as top pc.\n     uptr pc1 = pc;\n-    if (si != trace.Size() - 1)\n+    if (si != trace.size - 1)\n       pc1 -= 1;\n #endif\n     ReportStack *ent = SymbolizeCode(pc1);\n     CHECK_NE(ent, 0);\n     ReportStack *last = ent;\n     while (last->next) {\n-      last->pc = pc;  // restore original pc for report\n+      last->info.address = pc;  // restore original pc for report\n       last = last->next;\n     }\n-    last->pc = pc;  // restore original pc for report\n+    last->info.address = pc;  // restore original pc for report\n     last->next = stack;\n     stack = ent;\n   }\n@@ -160,14 +146,14 @@ ScopedReport::~ScopedReport() {\n   DestroyAndFree(rep_);\n }\n \n-void ScopedReport::AddStack(const StackTrace *stack, bool suppressable) {\n+void ScopedReport::AddStack(StackTrace stack, bool suppressable) {\n   ReportStack **rs = rep_->stacks.PushBack();\n-  *rs = SymbolizeStack(*stack);\n+  *rs = SymbolizeStack(stack);\n   (*rs)->suppressable = suppressable;\n }\n \n-void ScopedReport::AddMemoryAccess(uptr addr, Shadow s,\n-    const StackTrace *stack, const MutexSet *mset) {\n+void ScopedReport::AddMemoryAccess(uptr addr, Shadow s, StackTrace stack,\n+                                   const MutexSet *mset) {\n   void *mem = internal_alloc(MBlockReportMop, sizeof(ReportMop));\n   ReportMop *mop = new(mem) ReportMop;\n   rep_->mops.PushBack(mop);\n@@ -176,7 +162,7 @@ void ScopedReport::AddMemoryAccess(uptr addr, Shadow s,\n   mop->size = s.size();\n   mop->write = s.IsWrite();\n   mop->atomic = s.IsAtomic();\n-  mop->stack = SymbolizeStack(*stack);\n+  mop->stack = SymbolizeStack(stack);\n   if (mop->stack)\n     mop->stack->suppressable = true;\n   for (uptr i = 0; i < mset->Size(); i++) {\n@@ -315,13 +301,11 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n   int creat_tid = -1;\n   u32 creat_stack = 0;\n   if (FdLocation(addr, &fd, &creat_tid, &creat_stack)) {\n-    void *mem = internal_alloc(MBlockReportLoc, sizeof(ReportLocation));\n-    ReportLocation *loc = new(mem) ReportLocation();\n-    rep_->locs.PushBack(loc);\n-    loc->type = ReportLocationFD;\n+    ReportLocation *loc = ReportLocation::New(ReportLocationFD);\n     loc->fd = fd;\n     loc->tid = creat_tid;\n     loc->stack = SymbolizeStackId(creat_stack);\n+    rep_->locs.PushBack(loc);\n     ThreadContext *tctx = FindThreadByUidLocked(creat_tid);\n     if (tctx)\n       AddThread(tctx);\n@@ -336,33 +320,25 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n   }\n   if (b != 0) {\n     ThreadContext *tctx = FindThreadByTidLocked(b->tid);\n-    void *mem = internal_alloc(MBlockReportLoc, sizeof(ReportLocation));\n-    ReportLocation *loc = new(mem) ReportLocation();\n-    rep_->locs.PushBack(loc);\n-    loc->type = ReportLocationHeap;\n-    loc->addr = (uptr)allocator()->GetBlockBegin((void*)addr);\n-    loc->size = b->siz;\n+    ReportLocation *loc = ReportLocation::New(ReportLocationHeap);\n+    loc->heap_chunk_start = (uptr)allocator()->GetBlockBegin((void *)addr);\n+    loc->heap_chunk_size = b->siz;\n     loc->tid = tctx ? tctx->tid : b->tid;\n-    loc->name = 0;\n-    loc->file = 0;\n-    loc->line = 0;\n-    loc->stack = 0;\n     loc->stack = SymbolizeStackId(b->stk);\n+    rep_->locs.PushBack(loc);\n     if (tctx)\n       AddThread(tctx);\n     return;\n   }\n   bool is_stack = false;\n   if (ThreadContext *tctx = IsThreadStackOrTls(addr, &is_stack)) {\n-    void *mem = internal_alloc(MBlockReportLoc, sizeof(ReportLocation));\n-    ReportLocation *loc = new(mem) ReportLocation();\n-    rep_->locs.PushBack(loc);\n-    loc->type = is_stack ? ReportLocationStack : ReportLocationTLS;\n+    ReportLocation *loc =\n+        ReportLocation::New(is_stack ? ReportLocationStack : ReportLocationTLS);\n     loc->tid = tctx->tid;\n+    rep_->locs.PushBack(loc);\n     AddThread(tctx);\n   }\n-  ReportLocation *loc = SymbolizeData(addr);\n-  if (loc) {\n+  if (ReportLocation *loc = SymbolizeData(addr)) {\n     loc->suppressable = true;\n     rep_->locs.PushBack(loc);\n     return;\n@@ -384,7 +360,8 @@ const ReportDesc *ScopedReport::GetReport() const {\n   return rep_;\n }\n \n-void RestoreStack(int tid, const u64 epoch, StackTrace *stk, MutexSet *mset) {\n+void RestoreStack(int tid, const u64 epoch, VarSizeStackTrace *stk,\n+                  MutexSet *mset) {\n   // This function restores stack trace and mutex set for the thread/epoch.\n   // It does so by getting stack trace and mutex set at the beginning of\n   // trace part, and then replaying the trace till the given epoch.\n@@ -409,13 +386,13 @@ void RestoreStack(int tid, const u64 epoch, StackTrace *stk, MutexSet *mset) {\n   DPrintf(\"#%d: RestoreStack epoch=%zu ebegin=%zu eend=%zu partidx=%d\\n\",\n           tid, (uptr)epoch, (uptr)ebegin, (uptr)eend, partidx);\n   InternalScopedBuffer<uptr> stack(kShadowStackSize);\n-  for (uptr i = 0; i < hdr->stack0.Size(); i++) {\n-    stack[i] = hdr->stack0.Get(i);\n+  for (uptr i = 0; i < hdr->stack0.size; i++) {\n+    stack[i] = hdr->stack0.trace[i];\n     DPrintf2(\"  #%02lu: pc=%zx\\n\", i, stack[i]);\n   }\n   if (mset)\n     *mset = hdr->mset0;\n-  uptr pos = hdr->stack0.Size();\n+  uptr pos = hdr->stack0.size;\n   Event *events = (Event*)GetThreadTrace(tid);\n   for (uptr i = ebegin; i <= eend; i++) {\n     Event ev = events[i];\n@@ -450,13 +427,13 @@ void RestoreStack(int tid, const u64 epoch, StackTrace *stk, MutexSet *mset) {\n   stk->Init(stack.data(), pos);\n }\n \n-static bool HandleRacyStacks(ThreadState *thr, const StackTrace (&traces)[2],\n-    uptr addr_min, uptr addr_max) {\n+static bool HandleRacyStacks(ThreadState *thr, VarSizeStackTrace traces[2],\n+                             uptr addr_min, uptr addr_max) {\n   bool equal_stack = false;\n   RacyStacks hash;\n   if (flags()->suppress_equal_stacks) {\n-    hash.hash[0] = md5_hash(traces[0].Begin(), traces[0].Size() * sizeof(uptr));\n-    hash.hash[1] = md5_hash(traces[1].Begin(), traces[1].Size() * sizeof(uptr));\n+    hash.hash[0] = md5_hash(traces[0].trace, traces[0].size * sizeof(uptr));\n+    hash.hash[1] = md5_hash(traces[1].trace, traces[1].size * sizeof(uptr));\n     for (uptr i = 0; i < ctx->racy_stacks.Size(); i++) {\n       if (hash == ctx->racy_stacks[i]) {\n         DPrintf(\"ThreadSanitizer: suppressing report as doubled (stack)\\n\");\n@@ -489,12 +466,12 @@ static bool HandleRacyStacks(ThreadState *thr, const StackTrace (&traces)[2],\n   return false;\n }\n \n-static void AddRacyStacks(ThreadState *thr, const StackTrace (&traces)[2],\n-    uptr addr_min, uptr addr_max) {\n+static void AddRacyStacks(ThreadState *thr, VarSizeStackTrace traces[2],\n+                          uptr addr_min, uptr addr_max) {\n   if (flags()->suppress_equal_stacks) {\n     RacyStacks hash;\n-    hash.hash[0] = md5_hash(traces[0].Begin(), traces[0].Size() * sizeof(uptr));\n-    hash.hash[1] = md5_hash(traces[1].Begin(), traces[1].Size() * sizeof(uptr));\n+    hash.hash[0] = md5_hash(traces[0].trace, traces[0].size * sizeof(uptr));\n+    hash.hash[1] = md5_hash(traces[1].trace, traces[1].size * sizeof(uptr));\n     ctx->racy_stacks.PushBack(hash);\n   }\n   if (flags()->suppress_equal_addresses) {\n@@ -535,15 +512,14 @@ bool OutputReport(ThreadState *thr, const ScopedReport &srep) {\n   return true;\n }\n \n-bool IsFiredSuppression(Context *ctx,\n-                        const ScopedReport &srep,\n-                        const StackTrace &trace) {\n+bool IsFiredSuppression(Context *ctx, const ScopedReport &srep,\n+                        StackTrace trace) {\n   for (uptr k = 0; k < ctx->fired_suppressions.size(); k++) {\n     if (ctx->fired_suppressions[k].type != srep.GetReport()->typ)\n       continue;\n-    for (uptr j = 0; j < trace.Size(); j++) {\n+    for (uptr j = 0; j < trace.size; j++) {\n       FiredSuppression *s = &ctx->fired_suppressions[k];\n-      if (trace.Get(j) == s->pc) {\n+      if (trace.trace[j] == s->pc) {\n         if (s->supp)\n           s->supp->hit_count++;\n         return true;\n@@ -570,10 +546,13 @@ static bool IsFiredSuppression(Context *ctx,\n }\n \n bool FrameIsInternal(const ReportStack *frame) {\n-  return frame != 0 && frame->file != 0\n-      && (internal_strstr(frame->file, \"tsan_interceptors.cc\") ||\n-          internal_strstr(frame->file, \"sanitizer_common_interceptors.inc\") ||\n-          internal_strstr(frame->file, \"tsan_interface_\"));\n+  if (frame == 0)\n+    return false;\n+  const char *file = frame->info.file;\n+  return file != 0 &&\n+         (internal_strstr(file, \"tsan_interceptors.cc\") ||\n+          internal_strstr(file, \"sanitizer_common_interceptors.inc\") ||\n+          internal_strstr(file, \"tsan_interface_\"));\n }\n \n static bool RaceBetweenAtomicAndFree(ThreadState *thr) {\n@@ -625,17 +604,19 @@ void ReportRace(ThreadState *thr) {\n   ThreadRegistryLock l0(ctx->thread_registry);\n \n   ReportType typ = ReportTypeRace;\n-  if (thr->is_vptr_access)\n+  if (thr->is_vptr_access && freed)\n+    typ = ReportTypeVptrUseAfterFree;\n+  else if (thr->is_vptr_access)\n     typ = ReportTypeVptrRace;\n   else if (freed)\n     typ = ReportTypeUseAfterFree;\n   ScopedReport rep(typ);\n   if (IsFiredSuppression(ctx, rep, addr))\n     return;\n   const uptr kMop = 2;\n-  StackTrace traces[kMop];\n+  VarSizeStackTrace traces[kMop];\n   const uptr toppc = TraceTopPC(thr);\n-  traces[0].ObtainCurrent(thr, toppc);\n+  ObtainCurrentStack(thr, toppc, &traces[0]);\n   if (IsFiredSuppression(ctx, rep, traces[0]))\n     return;\n   InternalScopedBuffer<MutexSet> mset2(1);\n@@ -650,7 +631,7 @@ void ReportRace(ThreadState *thr) {\n \n   for (uptr i = 0; i < kMop; i++) {\n     Shadow s(thr->racy_state[i]);\n-    rep.AddMemoryAccess(addr, s, &traces[i],\n+    rep.AddMemoryAccess(addr, s, traces[i],\n                         i == 0 ? &thr->mset : mset2.data());\n   }\n \n@@ -680,26 +661,33 @@ void ReportRace(ThreadState *thr) {\n }\n \n void PrintCurrentStack(ThreadState *thr, uptr pc) {\n-  StackTrace trace;\n-  trace.ObtainCurrent(thr, pc);\n+  VarSizeStackTrace trace;\n+  ObtainCurrentStack(thr, pc, &trace);\n   PrintStack(SymbolizeStack(trace));\n }\n \n-void PrintCurrentStackSlow() {\n+void PrintCurrentStackSlow(uptr pc) {\n #ifndef TSAN_GO\n-  __sanitizer::StackTrace *ptrace = new(internal_alloc(MBlockStackTrace,\n-      sizeof(__sanitizer::StackTrace))) __sanitizer::StackTrace;\n-  ptrace->Unwind(kStackTraceMax, __sanitizer::StackTrace::GetCurrentPc(), 0, 0,\n-                 0, 0, false);\n+  BufferedStackTrace *ptrace =\n+      new(internal_alloc(MBlockStackTrace, sizeof(BufferedStackTrace)))\n+          BufferedStackTrace();\n+  ptrace->Unwind(kStackTraceMax, pc, 0, 0, 0, 0, false);\n   for (uptr i = 0; i < ptrace->size / 2; i++) {\n-    uptr tmp = ptrace->trace[i];\n-    ptrace->trace[i] = ptrace->trace[ptrace->size - i - 1];\n-    ptrace->trace[ptrace->size - i - 1] = tmp;\n+    uptr tmp = ptrace->trace_buffer[i];\n+    ptrace->trace_buffer[i] = ptrace->trace_buffer[ptrace->size - i - 1];\n+    ptrace->trace_buffer[ptrace->size - i - 1] = tmp;\n   }\n-  StackTrace trace;\n-  trace.Init(ptrace->trace, ptrace->size);\n-  PrintStack(SymbolizeStack(trace));\n+  PrintStack(SymbolizeStack(*ptrace));\n #endif\n }\n \n }  // namespace __tsan\n+\n+using namespace __tsan;\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_print_stack_trace() {\n+  PrintCurrentStackSlow(StackTrace::GetCurrentPc());\n+}\n+}  // extern \"C\""}, {"sha": "3734e0e4975bda589ce01f00ad3e028831ba986b", "filename": "libsanitizer/tsan/tsan_stack_trace.cc", "status": "modified", "additions": 21, "deletions": 87, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_stack_trace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_stack_trace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stack_trace.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -8,103 +8,37 @@\n // This file is a part of ThreadSanitizer (TSan), a race detector.\n //\n //===----------------------------------------------------------------------===//\n-//#include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"tsan_stack_trace.h\"\n #include \"tsan_rtl.h\"\n #include \"tsan_mman.h\"\n \n namespace __tsan {\n \n-StackTrace::StackTrace()\n-    : n_()\n-    , s_()\n-    , c_() {\n-}\n-\n-StackTrace::StackTrace(uptr *buf, uptr cnt)\n-    : n_()\n-    , s_(buf)\n-    , c_(cnt) {\n-  CHECK_NE(buf, 0);\n-  CHECK_NE(cnt, 0);\n-}\n-\n-StackTrace::~StackTrace() {\n-  Reset();\n-}\n+VarSizeStackTrace::VarSizeStackTrace()\n+    : StackTrace(nullptr, 0), trace_buffer(nullptr) {}\n \n-void StackTrace::Reset() {\n-  if (s_ && !c_) {\n-    CHECK_NE(n_, 0);\n-    internal_free(s_);\n-    s_ = 0;\n-  }\n-  n_ = 0;\n+VarSizeStackTrace::~VarSizeStackTrace() {\n+  ResizeBuffer(0);\n }\n \n-void StackTrace::Init(const uptr *pcs, uptr cnt) {\n-  Reset();\n-  if (cnt == 0)\n-    return;\n-  if (c_) {\n-    CHECK_NE(s_, 0);\n-    CHECK_LE(cnt, c_);\n-  } else {\n-    s_ = (uptr*)internal_alloc(MBlockStackTrace, cnt * sizeof(s_[0]));\n-  }\n-  n_ = cnt;\n-  internal_memcpy(s_, pcs, cnt * sizeof(s_[0]));\n-}\n-\n-void StackTrace::ObtainCurrent(ThreadState *thr, uptr toppc) {\n-  Reset();\n-  n_ = thr->shadow_stack_pos - thr->shadow_stack;\n-  if (n_ + !!toppc == 0)\n-    return;\n-  uptr start = 0;\n-  if (c_) {\n-    CHECK_NE(s_, 0);\n-    if (n_ + !!toppc > c_) {\n-      start = n_ - c_ + !!toppc;\n-      n_ = c_ - !!toppc;\n-    }\n-  } else {\n-    // Cap potentially huge stacks.\n-    if (n_ + !!toppc > kTraceStackSize) {\n-      start = n_ - kTraceStackSize + !!toppc;\n-      n_ = kTraceStackSize - !!toppc;\n-    }\n-    s_ = (uptr*)internal_alloc(MBlockStackTrace,\n-                               (n_ + !!toppc) * sizeof(s_[0]));\n-  }\n-  for (uptr i = 0; i < n_; i++)\n-    s_[i] = thr->shadow_stack[start + i];\n-  if (toppc) {\n-    s_[n_] = toppc;\n-    n_++;\n+void VarSizeStackTrace::ResizeBuffer(uptr new_size) {\n+  if (trace_buffer) {\n+    internal_free(trace_buffer);\n   }\n-}\n-\n-void StackTrace::CopyFrom(const StackTrace& other) {\n-  Reset();\n-  Init(other.Begin(), other.Size());\n-}\n-\n-bool StackTrace::IsEmpty() const {\n-  return n_ == 0;\n-}\n-\n-uptr StackTrace::Size() const {\n-  return n_;\n-}\n-\n-uptr StackTrace::Get(uptr i) const {\n-  CHECK_LT(i, n_);\n-  return s_[i];\n-}\n-\n-const uptr *StackTrace::Begin() const {\n-  return s_;\n+  trace_buffer =\n+      (new_size > 0)\n+          ? (uptr *)internal_alloc(MBlockStackTrace,\n+                                   new_size * sizeof(trace_buffer[0]))\n+          : nullptr;\n+  trace = trace_buffer;\n+  size = new_size;\n+}\n+\n+void VarSizeStackTrace::Init(const uptr *pcs, uptr cnt, uptr extra_top_pc) {\n+  ResizeBuffer(cnt + !!extra_top_pc);\n+  internal_memcpy(trace_buffer, pcs, cnt * sizeof(trace_buffer[0]));\n+  if (extra_top_pc)\n+    trace_buffer[cnt] = extra_top_pc;\n }\n \n }  // namespace __tsan"}, {"sha": "b097a9b2696631078304404d8dad37c2e2f27266", "filename": "libsanitizer/tsan/tsan_stack_trace.h", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_stack_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_stack_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stack_trace.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -11,40 +11,25 @@\n #ifndef TSAN_STACK_TRACE_H\n #define TSAN_STACK_TRACE_H\n \n-//#include \"sanitizer_common/sanitizer_atomic.h\"\n-//#include \"sanitizer_common/sanitizer_common.h\"\n-//#include \"sanitizer_common/sanitizer_deadlock_detector_interface.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"tsan_defs.h\"\n-//#include \"tsan_clock.h\"\n-//#include \"tsan_mutex.h\"\n-//#include \"tsan_dense_alloc.h\"\n \n namespace __tsan {\n \n-class StackTrace {\n- public:\n-  StackTrace();\n-  // Initialized the object in \"static mode\",\n-  // in this mode it never calls malloc/free but uses the provided buffer.\n-  StackTrace(uptr *buf, uptr cnt);\n-  ~StackTrace();\n-  void Reset();\n-\n-  void Init(const uptr *pcs, uptr cnt);\n-  void ObtainCurrent(ThreadState *thr, uptr toppc);\n-  bool IsEmpty() const;\n-  uptr Size() const;\n-  uptr Get(uptr i) const;\n-  const uptr *Begin() const;\n-  void CopyFrom(const StackTrace& other);\n+// StackTrace which calls malloc/free to allocate the buffer for\n+// addresses in stack traces.\n+struct VarSizeStackTrace : public StackTrace {\n+  uptr *trace_buffer;  // Owned.\n+\n+  VarSizeStackTrace();\n+  ~VarSizeStackTrace();\n+  void Init(const uptr *pcs, uptr cnt, uptr extra_top_pc = 0);\n \n  private:\n-  uptr n_;\n-  uptr *s_;\n-  const uptr c_;\n+  void ResizeBuffer(uptr new_size);\n \n-  StackTrace(const StackTrace&);\n-  void operator = (const StackTrace&);\n+  VarSizeStackTrace(const VarSizeStackTrace &);\n+  void operator=(const VarSizeStackTrace &);\n };\n \n }  // namespace __tsan"}, {"sha": "76460d90d92e981911a7fb1579cdc96efee1b843", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -58,6 +58,8 @@ SuppressionType conv(ReportType typ) {\n     return SuppressionRace;\n   else if (typ == ReportTypeUseAfterFree)\n     return SuppressionRace;\n+  else if (typ == ReportTypeVptrUseAfterFree)\n+    return SuppressionRace;\n   else if (typ == ReportTypeThreadLeak)\n     return SuppressionThread;\n   else if (typ == ReportTypeMutexDestroyLocked)\n@@ -89,13 +91,14 @@ uptr IsSuppressed(ReportType typ, const ReportStack *stack, Suppression **sp) {\n     return 0;\n   Suppression *s;\n   for (const ReportStack *frame = stack; frame; frame = frame->next) {\n-    if (SuppressionContext::Get()->Match(frame->func, stype, &s) ||\n-        SuppressionContext::Get()->Match(frame->file, stype, &s) ||\n-        SuppressionContext::Get()->Match(frame->module, stype, &s)) {\n+    const AddressInfo &info = frame->info;\n+    if (SuppressionContext::Get()->Match(info.function, stype, &s) ||\n+        SuppressionContext::Get()->Match(info.file, stype, &s) ||\n+        SuppressionContext::Get()->Match(info.module, stype, &s)) {\n       DPrintf(\"ThreadSanitizer: matched suppression '%s'\\n\", s->templ);\n       s->hit_count++;\n       *sp = s;\n-      return frame->pc;\n+      return info.address;\n     }\n   }\n   return 0;\n@@ -109,13 +112,13 @@ uptr IsSuppressed(ReportType typ, const ReportLocation *loc, Suppression **sp) {\n   if (stype == SuppressionNone)\n     return 0;\n   Suppression *s;\n-  if (SuppressionContext::Get()->Match(loc->name, stype, &s) ||\n-      SuppressionContext::Get()->Match(loc->file, stype, &s) ||\n-      SuppressionContext::Get()->Match(loc->module, stype, &s)) {\n+  const DataInfo &global = loc->global;\n+  if (SuppressionContext::Get()->Match(global.name, stype, &s) ||\n+      SuppressionContext::Get()->Match(global.module, stype, &s)) {\n       DPrintf(\"ThreadSanitizer: matched suppression '%s'\\n\", s->templ);\n       s->hit_count++;\n       *sp = s;\n-      return loc->addr;\n+      return global.start;\n   }\n   return 0;\n }"}, {"sha": "795f838991b63e92041d1fabbc6795787581e4f9", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 11, "deletions": 54, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -34,38 +34,6 @@ void ExitSymbolizer() {\n   thr->ignore_interceptors--;\n }\n \n-ReportStack *NewReportStackEntry(uptr addr) {\n-  ReportStack *ent = (ReportStack*)internal_alloc(MBlockReportStack,\n-                                                  sizeof(ReportStack));\n-  internal_memset(ent, 0, sizeof(*ent));\n-  ent->pc = addr;\n-  return ent;\n-}\n-\n-static ReportStack *NewReportStackEntry(const AddressInfo &info) {\n-  ReportStack *ent = NewReportStackEntry(info.address);\n-  ent->module = StripModuleName(info.module);\n-  ent->offset = info.module_offset;\n-  if (info.function)\n-    ent->func = internal_strdup(info.function);\n-  if (info.file)\n-    ent->file = internal_strdup(info.file);\n-  ent->line = info.line;\n-  ent->col = info.column;\n-  return ent;\n-}\n-\n-\n-  ReportStack *next;\n-  char *module;\n-  uptr offset;\n-  uptr pc;\n-  char *func;\n-  char *file;\n-  int line;\n-  int col;\n-\n-\n // Denotes fake PC values that come from JIT/JAVA/etc.\n // For such PC values __tsan_symbolize_external() will be called.\n const uptr kExternalPCBit = 1ULL << 60;\n@@ -93,16 +61,14 @@ ReportStack *SymbolizeCode(uptr addr) {\n     static char func_buf[1024];\n     static char file_buf[1024];\n     int line, col;\n+    ReportStack *ent = ReportStack::New(addr);\n     if (!__tsan_symbolize_external(addr, func_buf, sizeof(func_buf),\n                                   file_buf, sizeof(file_buf), &line, &col))\n-      return NewReportStackEntry(addr);\n-    ReportStack *ent = NewReportStackEntry(addr);\n-    ent->module = 0;\n-    ent->offset = 0;\n-    ent->func = internal_strdup(func_buf);\n-    ent->file = internal_strdup(file_buf);\n-    ent->line = line;\n-    ent->col = col;\n+      return ent;\n+    ent->info.function = internal_strdup(func_buf);\n+    ent->info.file = internal_strdup(file_buf);\n+    ent->info.line = line;\n+    ent->info.column = col;\n     return ent;\n   }\n   static const uptr kMaxAddrFrames = 16;\n@@ -112,13 +78,12 @@ ReportStack *SymbolizeCode(uptr addr) {\n   uptr addr_frames_num = Symbolizer::GetOrInit()->SymbolizePC(\n       addr, addr_frames.data(), kMaxAddrFrames);\n   if (addr_frames_num == 0)\n-    return NewReportStackEntry(addr);\n+    return ReportStack::New(addr);\n   ReportStack *top = 0;\n   ReportStack *bottom = 0;\n   for (uptr i = 0; i < addr_frames_num; i++) {\n-    ReportStack *cur_entry = NewReportStackEntry(addr_frames[i]);\n-    CHECK(cur_entry);\n-    addr_frames[i].Clear();\n+    ReportStack *cur_entry = ReportStack::New(addr);\n+    cur_entry->info = addr_frames[i];\n     if (i == 0)\n       top = cur_entry;\n     else\n@@ -132,16 +97,8 @@ ReportLocation *SymbolizeData(uptr addr) {\n   DataInfo info;\n   if (!Symbolizer::GetOrInit()->SymbolizeData(addr, &info))\n     return 0;\n-  ReportLocation *ent = (ReportLocation*)internal_alloc(MBlockReportStack,\n-                                                        sizeof(ReportLocation));\n-  internal_memset(ent, 0, sizeof(*ent));\n-  ent->type = ReportLocationGlobal;\n-  ent->module = StripModuleName(info.module);\n-  ent->offset = info.module_offset;\n-  if (info.name)\n-    ent->name = internal_strdup(info.name);\n-  ent->addr = info.start;\n-  ent->size = info.size;\n+  ReportLocation *ent = ReportLocation::New(ReportLocationGlobal);\n+  ent->global = info;\n   return ent;\n }\n "}, {"sha": "8eceb634a53d618f7854fa4aa7751541ae8f56b5", "filename": "libsanitizer/tsan/tsan_trace.h", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Ftsan%2Ftsan_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_trace.h?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -40,21 +40,15 @@ enum EventType {\n typedef u64 Event;\n \n struct TraceHeader {\n-  StackTrace stack0;  // Start stack for the trace.\n-  u64        epoch0;  // Start epoch for the trace.\n-  MutexSet   mset0;\n-#ifndef TSAN_GO\n-  uptr       stack0buf[kTraceStackSize];\n-#endif\n-\n-  TraceHeader()\n #ifndef TSAN_GO\n-      : stack0(stack0buf, kTraceStackSize)\n+  BufferedStackTrace stack0;  // Start stack for the trace.\n #else\n-      : stack0()\n+  VarSizeStackTrace stack0;\n #endif\n-      , epoch0() {\n-  }\n+  u64        epoch0;  // Start epoch for the trace.\n+  MutexSet   mset0;\n+\n+  TraceHeader() : stack0(), epoch0() {}\n };\n \n struct Trace {"}, {"sha": "ae167679cbb6c805afec4570298ef6540953821a", "filename": "libsanitizer/ubsan/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.am?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -6,6 +6,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DPIC\n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fno-rtti -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros\n AM_CXXFLAGS += $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+AM_CXXFLAGS += -std=c++11\n ACLOCAL_AMFLAGS = -I m4\n \n toolexeclib_LTLIBRARIES = libubsan.la"}, {"sha": "543e4f1e4ce1b4eb6720ae86e78b181632eb6391", "filename": "libsanitizer/ubsan/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.in?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -256,7 +256,7 @@ gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n \t-Wno-long-long -fPIC -fno-builtin -fno-exceptions -fno-rtti \\\n \t-fomit-frame-pointer -funwind-tables -fvisibility=hidden \\\n-\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS)\n+\t-Wno-variadic-macros $(LIBSTDCXX_RAW_CXX_CXXFLAGS) -std=c++11\n ACLOCAL_AMFLAGS = -I m4\n toolexeclib_LTLIBRARIES = libubsan.la\n ubsan_files = \\"}, {"sha": "028ac1a9b97e3b4c85b76520bd977f8a7f03161b", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -14,6 +14,7 @@\n #include \"ubsan_flags.h\"\n #include \"sanitizer_common/sanitizer_report_decorator.h\"\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace_printer.h\"\n #include \"sanitizer_common/sanitizer_symbolizer.h\"\n #include <stdio.h>\n \n@@ -31,7 +32,7 @@ static void MaybePrintStackTrace(uptr pc, uptr bp) {\n   // under ASan).\n   if (StackTrace::WillUseFastUnwind(false))\n     return;\n-  StackTrace stack;\n+  BufferedStackTrace stack;\n   stack.Unwind(kStackTraceMax, pc, bp, 0, 0, 0, false);\n   stack.Print();\n }\n@@ -44,12 +45,12 @@ static void MaybeReportErrorSummary(Location Loc) {\n   if (Loc.isSourceLocation()) {\n     SourceLocation SLoc = Loc.getSourceLocation();\n     if (!SLoc.isInvalid()) {\n-      ReportErrorSummary(\"runtime-error\", SLoc.getFilename(), SLoc.getLine(),\n-                         \"\");\n+      ReportErrorSummary(\"undefined-behavior\", SLoc.getFilename(),\n+                         SLoc.getLine(), \"\");\n       return;\n     }\n   }\n-  ReportErrorSummary(\"runtime-error\");\n+  ReportErrorSummary(\"undefined-behavior\");\n }\n \n namespace {\n@@ -127,14 +128,16 @@ static void renderLocation(Location Loc) {\n     if (SLoc.isInvalid())\n       LocBuffer.append(\"<unknown>\");\n     else\n-      PrintSourceLocation(&LocBuffer, SLoc.getFilename(), SLoc.getLine(),\n-                          SLoc.getColumn());\n+      RenderSourceLocation(&LocBuffer, SLoc.getFilename(), SLoc.getLine(),\n+                           SLoc.getColumn(), common_flags()->strip_path_prefix);\n     break;\n   }\n-  case Location::LK_Module:\n-    PrintModuleAndOffset(&LocBuffer, Loc.getModuleLocation().getModuleName(),\n-                         Loc.getModuleLocation().getOffset());\n+  case Location::LK_Module: {\n+    ModuleLocation MLoc = Loc.getModuleLocation();\n+    RenderModuleLocation(&LocBuffer, MLoc.getModuleName(), MLoc.getOffset(),\n+                         common_flags()->strip_path_prefix);\n     break;\n+  }\n   case Location::LK_Memory:\n     LocBuffer.append(\"%p\", Loc.getMemoryLocation());\n     break;"}, {"sha": "770d3c28a4a9138d53ff300f8d45bcf0a8dd05c2", "filename": "libsanitizer/ubsan/ubsan_handlers.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -28,10 +28,10 @@ static bool ignoreReport(SourceLocation SLoc, ReportOptions Opts) {\n }\n \n namespace __ubsan {\n-  const char *TypeCheckKinds[] = {\n+const char *TypeCheckKinds[] = {\n     \"load of\", \"store to\", \"reference binding to\", \"member access within\",\n-    \"member call on\", \"constructor call on\", \"downcast of\", \"downcast of\"\n-  };\n+    \"member call on\", \"constructor call on\", \"downcast of\", \"downcast of\",\n+    \"upcast of\", \"cast to virtual base of\"};\n }\n \n static void handleTypeMismatchImpl(TypeMismatchData *Data, ValueHandle Pointer,"}, {"sha": "8758f6c84c5c09d8bb13b680492c28344648a750", "filename": "libsanitizer/ubsan/ubsan_type_hash.cc", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5be964a423f952e2ec16e2152ae504639bf8f07/libsanitizer%2Fubsan%2Fubsan_type_hash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash.cc?ref=c5be964a423f952e2ec16e2152ae504639bf8f07", "patch": "@@ -113,15 +113,16 @@ __ubsan::__ubsan_vptr_type_cache[__ubsan::VptrTypeCacheSize];\n \n /// \\brief Determine whether \\p Derived has a \\p Base base class subobject at\n /// offset \\p Offset.\n-static bool isDerivedFromAtOffset(const abi::__class_type_info *Derived,\n+static bool isDerivedFromAtOffset(sptr Object,\n+                                  const abi::__class_type_info *Derived,\n                                   const abi::__class_type_info *Base,\n                                   sptr Offset) {\n   if (Derived->__type_name == Base->__type_name)\n     return Offset == 0;\n \n   if (const abi::__si_class_type_info *SI =\n         dynamic_cast<const abi::__si_class_type_info*>(Derived))\n-    return isDerivedFromAtOffset(SI->__base_type, Base, Offset);\n+    return isDerivedFromAtOffset(Object, SI->__base_type, Base, Offset);\n \n   const abi::__vmi_class_type_info *VTI =\n     dynamic_cast<const abi::__vmi_class_type_info*>(Derived);\n@@ -136,13 +137,13 @@ static bool isDerivedFromAtOffset(const abi::__class_type_info *Derived,\n     sptr OffsetHere = VTI->base_info[base].__offset_flags >>\n                       abi::__base_class_type_info::__offset_shift;\n     if (VTI->base_info[base].__offset_flags &\n-          abi::__base_class_type_info::__virtual_mask)\n-      // For now, just punt on virtual bases and say 'yes'.\n-      // FIXME: OffsetHere is the offset in the vtable of the virtual base\n-      //        offset. Read the vbase offset out of the vtable and use it.\n-      return true;\n-    if (isDerivedFromAtOffset(VTI->base_info[base].__base_type,\n-                              Base, Offset - OffsetHere))\n+          abi::__base_class_type_info::__virtual_mask) {\n+      sptr VTable = *reinterpret_cast<const sptr *>(Object);\n+      OffsetHere = *reinterpret_cast<const sptr *>(VTable + OffsetHere);\n+    }\n+    if (isDerivedFromAtOffset(Object + OffsetHere,\n+                              VTI->base_info[base].__base_type, Base,\n+                              Offset - OffsetHere))\n       return true;\n   }\n \n@@ -151,14 +152,15 @@ static bool isDerivedFromAtOffset(const abi::__class_type_info *Derived,\n \n /// \\brief Find the derived-most dynamic base class of \\p Derived at offset\n /// \\p Offset.\n-static const abi::__class_type_info *findBaseAtOffset(\n-    const abi::__class_type_info *Derived, sptr Offset) {\n+static const abi::__class_type_info *\n+findBaseAtOffset(sptr Object, const abi::__class_type_info *Derived,\n+                 sptr Offset) {\n   if (!Offset)\n     return Derived;\n \n   if (const abi::__si_class_type_info *SI =\n         dynamic_cast<const abi::__si_class_type_info*>(Derived))\n-    return findBaseAtOffset(SI->__base_type, Offset);\n+    return findBaseAtOffset(Object, SI->__base_type, Offset);\n \n   const abi::__vmi_class_type_info *VTI =\n     dynamic_cast<const abi::__vmi_class_type_info*>(Derived);\n@@ -170,12 +172,13 @@ static const abi::__class_type_info *findBaseAtOffset(\n     sptr OffsetHere = VTI->base_info[base].__offset_flags >>\n                       abi::__base_class_type_info::__offset_shift;\n     if (VTI->base_info[base].__offset_flags &\n-          abi::__base_class_type_info::__virtual_mask)\n-      // FIXME: Can't handle virtual bases yet.\n-      continue;\n-    if (const abi::__class_type_info *Base =\n-          findBaseAtOffset(VTI->base_info[base].__base_type,\n-                           Offset - OffsetHere))\n+          abi::__base_class_type_info::__virtual_mask) {\n+      sptr VTable = *reinterpret_cast<const sptr *>(Object);\n+      OffsetHere = *reinterpret_cast<const sptr *>(VTable + OffsetHere);\n+    }\n+    if (const abi::__class_type_info *Base = findBaseAtOffset(\n+            Object + OffsetHere, VTI->base_info[base].__base_type,\n+            Offset - OffsetHere))\n       return Base;\n   }\n \n@@ -227,7 +230,8 @@ bool __ubsan::checkDynamicType(void *Object, void *Type, HashValue Hash) {\n     return false;\n \n   abi::__class_type_info *Base = (abi::__class_type_info*)Type;\n-  if (!isDerivedFromAtOffset(Derived, Base, -Vtable->Offset))\n+  if (!isDerivedFromAtOffset(reinterpret_cast<sptr>(Object), Derived, Base,\n+                             -Vtable->Offset))\n     return false;\n \n   // Success. Cache this result.\n@@ -241,8 +245,9 @@ __ubsan::DynamicTypeInfo __ubsan::getDynamicTypeInfo(void *Object) {\n   if (!Vtable)\n     return DynamicTypeInfo(0, 0, 0);\n   const abi::__class_type_info *ObjectType = findBaseAtOffset(\n-    static_cast<const abi::__class_type_info*>(Vtable->TypeInfo),\n-    -Vtable->Offset);\n+      reinterpret_cast<sptr>(Object),\n+      static_cast<const abi::__class_type_info *>(Vtable->TypeInfo),\n+      -Vtable->Offset);\n   return DynamicTypeInfo(Vtable->TypeInfo->__type_name, -Vtable->Offset,\n                          ObjectType ? ObjectType->__type_name : \"<unknown>\");\n }"}]}