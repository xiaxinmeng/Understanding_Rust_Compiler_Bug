{"sha": "b5755e2ba523ae36cb5f033ec1dd29d4cda71c09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU3NTVlMmJhNTIzYWUzNmNiNWYwMzNlYzFkZDI5ZDRjZGE3MWMwOQ==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-06-06T10:38:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:38:29Z"}, "message": "mlib.ads, mlib.adb (Build_Library): Do not use hard-coded directory separator...\n\n2007-04-20  Vincent Celier  <celier@adacore.com>\n\n\t* mlib.ads, mlib.adb (Build_Library): Do not use hard-coded directory\n\tseparator, use instead the proper host directory separator.\n\t(Copy_ALI_Files): Make sure that an already existing ALI file in the\n\tALI copy dir is writable, before doing the copy.\n\n\t* mlib-utl.ads, mlib-utl.adb: \n\t(Gcc): If length of command line is too long, put the list of object\n\tfiles in a response file, if this is supported by the platform.\n\t(Ar): If invocation of the archive builder is allowed to be done in\n\tchunks and building it in one shot would go above an OS dependent\n\tlimit on the number of characters on the command line, build the archive\n\tin chunks.\n\nFrom-SVN: r125435", "tree": {"sha": "8aaae1b1f0d5ee967a99f3a84e73a2967488926f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8aaae1b1f0d5ee967a99f3a84e73a2967488926f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "da4d406dcb68d1de187d81c93ae50864cc3f8fb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da4d406dcb68d1de187d81c93ae50864cc3f8fb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da4d406dcb68d1de187d81c93ae50864cc3f8fb0"}], "stats": {"total": 433, "additions": 360, "deletions": 73}, "files": [{"sha": "3352591b0f2565109b05bde270574af5f93a5a3e", "filename": "gcc/ada/mlib-utl.adb", "status": "modified", "additions": 334, "deletions": 56, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09/gcc%2Fada%2Fmlib-utl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09/gcc%2Fada%2Fmlib-utl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-utl.adb?ref=b5755e2ba523ae36cb5f033ec1dd29d4cda71c09", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2002-2006, AdaCore                     --\n+--                     Copyright (C) 2002-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,26 +26,51 @@\n \n with MLib.Fil; use MLib.Fil;\n with MLib.Tgt; use MLib.Tgt;\n-\n-with Namet;    use Namet;\n with Opt;\n with Osint;\n with Output;   use Output;\n \n-with GNAT;     use GNAT;\n+with Interfaces.C.Strings; use Interfaces.C.Strings;\n+\n+with System;\n \n package body MLib.Utl is\n \n    Gcc_Name : constant String := Osint.Program_Name (\"gcc\").all;\n-   Gcc_Exec : OS_Lib.String_Access;\n+   --  Default value of the \"gcc\" executable used in procedure Gcc\n+\n+   Gcc_Exec : String_Access;\n+   --  The full path name of the \"gcc\" executable\n+\n+   Ar_Name : String_Access;\n+   --  The name of the archive builder for the platform, set when procedure Ar\n+   --  is called for the first time.\n+\n+   Ar_Exec : String_Access;\n+   --  The full path name of the archive builder\n+\n+   Ar_Options : String_List_Access;\n+   --  The minimum options used when invoking the archive builder\n+\n+   Ar_Append_Options : String_List_Access;\n+   --  The options to be used when invoking the archive builder to add chunks\n+   --  of object files, when building the archive in chunks.\n \n-   Ar_Name    : OS_Lib.String_Access;\n-   Ar_Exec    : OS_Lib.String_Access;\n-   Ar_Options : OS_Lib.String_List_Access;\n+   Opt_Length : Natural := 0;\n+   --  The max number of options for the Archive_Builder\n \n-   Ranlib_Name    : OS_Lib.String_Access;\n-   Ranlib_Exec    : OS_Lib.String_Access := null;\n-   Ranlib_Options : OS_Lib.String_List_Access := null;\n+   Initial_Size : Natural := 0;\n+   --  The minimum number of bytes for the invocation of the Archive Builder\n+   --  (without name of the archive or object files).\n+\n+   Ranlib_Name : String_Access;\n+   --  The name of the archive indexer for the platform, if there is one\n+\n+   Ranlib_Exec : String_Access := null;\n+   --  The full path name of the archive indexer\n+\n+   Ranlib_Options : String_List_Access := null;\n+   --  The options to be used when invoking the archive indexer, if any\n \n    --------\n    -- Ar --\n@@ -55,19 +80,70 @@ package body MLib.Utl is\n       Full_Output_File : constant String :=\n                              Ext_To (Output_File, Archive_Ext);\n \n-      Arguments   : OS_Lib.Argument_List_Access;\n+      Arguments   : Argument_List_Access;\n+      Last_Arg    : Natural := 0;\n       Success     : Boolean;\n       Line_Length : Natural := 0;\n \n+      Maximum_Size : Integer;\n+      pragma Import (C, Maximum_Size, \"__gnat_link_max\");\n+      --  Maximum number of bytes to put in an invocation of the\n+      --  Archive_Builder.\n+\n+      Size : Integer;\n+      --  The number of bytes for the invocation of the archive builder\n+\n+      Current_Object : Natural;\n+\n+      procedure Display;\n+      --  Display an invocation of the Archive Builder\n+\n+      -------------\n+      -- Display --\n+      -------------\n+\n+      procedure Display is\n+      begin\n+         if not Opt.Quiet_Output then\n+            Write_Str (Ar_Name.all);\n+            Line_Length := Ar_Name'Length;\n+\n+            for J in 1 .. Last_Arg loop\n+\n+               --  Make sure the Output buffer does not overflow\n+\n+               if Line_Length + 1 + Arguments (J)'Length > Buffer_Max then\n+                  Write_Eol;\n+                  Line_Length := 0;\n+               end if;\n+\n+               Write_Char (' ');\n+\n+               --  Only output the first object files when not in verbose mode\n+\n+               if (not Opt.Verbose_Mode) and then J = Opt_Length + 3 then\n+                  Write_Str (\"...\");\n+                  exit;\n+               end if;\n+\n+               Write_Str (Arguments (J).all);\n+               Line_Length := Line_Length + 1 + Arguments (J)'Length;\n+            end loop;\n+\n+            Write_Eol;\n+         end if;\n+\n+      end Display;\n+\n    begin\n       if Ar_Exec = null then\n          Ar_Name := Osint.Program_Name (Archive_Builder);\n-         Ar_Exec := OS_Lib.Locate_Exec_On_Path (Ar_Name.all);\n+         Ar_Exec := Locate_Exec_On_Path (Ar_Name.all);\n \n          if Ar_Exec = null then\n             Free (Ar_Name);\n             Ar_Name := new String'(Archive_Builder);\n-            Ar_Exec := OS_Lib.Locate_Exec_On_Path (Ar_Name.all);\n+            Ar_Exec := Locate_Exec_On_Path (Ar_Name.all);\n          end if;\n \n          if Ar_Exec = null then\n@@ -80,17 +156,37 @@ package body MLib.Utl is\n \n          Ar_Options := Archive_Builder_Options;\n \n+         Initial_Size := 0;\n+         for J in Ar_Options'Range loop\n+            Initial_Size := Initial_Size + Ar_Options (J)'Length + 1;\n+         end loop;\n+\n+         Ar_Append_Options := Archive_Builder_Append_Options;\n+\n+         Opt_Length := Ar_Options'Length;\n+\n+         if Ar_Append_Options /= null then\n+            Opt_Length := Natural'Max (Ar_Append_Options'Length, Opt_Length);\n+\n+            Size := 0;\n+            for J in Ar_Append_Options'Range loop\n+               Size := Size + Ar_Append_Options (J)'Length + 1;\n+            end loop;\n+\n+            Initial_Size := Integer'Max (Initial_Size, Size);\n+         end if;\n+\n          --  ranlib\n \n          Ranlib_Name := Osint.Program_Name (Archive_Indexer);\n \n          if Ranlib_Name'Length > 0 then\n-            Ranlib_Exec := OS_Lib.Locate_Exec_On_Path (Ranlib_Name.all);\n+            Ranlib_Exec := Locate_Exec_On_Path (Ranlib_Name.all);\n \n             if Ranlib_Exec = null then\n                Free (Ranlib_Name);\n                Ranlib_Name := new String'(Archive_Indexer);\n-               Ranlib_Exec := OS_Lib.Locate_Exec_On_Path (Ranlib_Name.all);\n+               Ranlib_Exec := Locate_Exec_On_Path (Ranlib_Name.all);\n             end if;\n \n             if Ranlib_Exec /= null and then Opt.Verbose_Mode then\n@@ -103,43 +199,77 @@ package body MLib.Utl is\n       end if;\n \n       Arguments :=\n-        new String_List (1 .. 1 + Ar_Options'Length + Objects'Length);\n+        new String_List (1 .. 1 + Opt_Length + Objects'Length);\n       Arguments (1 .. Ar_Options'Length) := Ar_Options.all; --  \"ar cr ...\"\n       Arguments (Ar_Options'Length + 1) := new String'(Full_Output_File);\n-      Arguments (Ar_Options'Length + 2 .. Arguments'Last) := Objects;\n \n       Delete_File (Full_Output_File);\n \n-      if not Opt.Quiet_Output then\n-         Write_Str (Ar_Name.all);\n-         Line_Length := Ar_Name'Length;\n+      Size := Initial_Size + Full_Output_File'Length + 1;\n \n-         for J in Arguments'Range loop\n+      --  Check the full size of a call of the archive builder with all the\n+      --  object files.\n \n-            --  Make sure the Output buffer does not overflow\n+      for J in Objects'Range loop\n+         Size := Size + Objects (J)'Length + 1;\n+      end loop;\n \n-            if Line_Length + 1 + Arguments (J)'Length > Buffer_Max then\n-               Write_Eol;\n-               Line_Length := 0;\n-            end if;\n+      --  If the size is not too large or if it is not possible to build the\n+      --  archive in chunks, build the archive in a single invocation.\n \n-            Write_Char (' ');\n+      if Size <= Maximum_Size or else Ar_Append_Options = null then\n+         Last_Arg := Ar_Options'Length + 1 + Objects'Length;\n+         Arguments (Ar_Options'Length + 2 .. Last_Arg) := Objects;\n \n-            --  Only output the first object files when not in verbose mode\n+         Display;\n \n-            if (not Opt.Verbose_Mode) and then J = Ar_Options'Length + 3 then\n-               Write_Str (\"...\");\n-               exit;\n-            end if;\n+         Spawn (Ar_Exec.all, Arguments (1 .. Last_Arg), Success);\n \n-            Write_Str  (Arguments (J).all);\n-            Line_Length := Line_Length + 1 + Arguments (J)'Length;\n+      else\n+         --  Build the archive in several invocation, making sure to not\n+         --  go over the maximum size for each invocation.\n+\n+         Last_Arg := Ar_Options'Length + 1;\n+         Current_Object := Objects'First;\n+         Size := Initial_Size + Full_Output_File'Length + 1;\n+\n+         --  First invocation\n+\n+         while Current_Object <= Objects'Last loop\n+            Size := Size + Objects (Current_Object)'Length + 1;\n+            exit when Size > Maximum_Size;\n+            Last_Arg := Last_Arg + 1;\n+            Arguments (Last_Arg) := Objects (Current_Object);\n+            Current_Object := Current_Object + 1;\n          end loop;\n \n-         Write_Eol;\n-      end if;\n+         Display;\n+\n+         Spawn (Ar_Exec.all, Arguments (1 .. Last_Arg), Success);\n+\n+         Arguments (1 .. Ar_Append_Options'Length) := Ar_Append_Options.all;\n+         Arguments\n+           (Ar_Append_Options'Length + 1) := new String'(Full_Output_File);\n \n-      OS_Lib.Spawn (Ar_Exec.all, Arguments.all, Success);\n+         --  Appending invocation(s)\n+\n+         Big_Loop : while Success and then Current_Object <= Objects'Last loop\n+            Last_Arg := Ar_Append_Options'Length + 1;\n+            Size := Initial_Size + Full_Output_File'Length + 1;\n+\n+            Inner_Loop : while Current_Object <= Objects'Last loop\n+               Size := Size + Objects (Current_Object)'Length + 1;\n+               exit Inner_Loop when Size > Maximum_Size;\n+               Last_Arg := Last_Arg + 1;\n+               Arguments (Last_Arg) := Objects (Current_Object);\n+               Current_Object := Current_Object + 1;\n+            end loop Inner_Loop;\n+\n+            Display;\n+\n+            Spawn (Ar_Exec.all, Arguments (1 .. Last_Arg), Success);\n+         end loop Big_Loop;\n+      end if;\n \n       if not Success then\n          Fail (Ar_Name.all, \" execution error.\");\n@@ -154,7 +284,7 @@ package body MLib.Utl is\n             Write_Line (Arguments (Ar_Options'Length + 1).all);\n          end if;\n \n-         OS_Lib.Spawn\n+         Spawn\n            (Ranlib_Exec.all,\n             Ranlib_Options.all & (Arguments (Ar_Options'Length + 1)),\n             Success);\n@@ -174,7 +304,7 @@ package body MLib.Utl is\n       Success : Boolean;\n \n    begin\n-      OS_Lib.Delete_File (File'Address, Success);\n+      Delete_File (File'Address, Success);\n \n       if Opt.Verbose_Mode then\n          if Success then\n@@ -199,32 +329,86 @@ package body MLib.Utl is\n       Options_2   : Argument_List;\n       Driver_Name : Name_Id := No_Name)\n    is\n+      Link_Bytes : Integer := 0;\n+      --  Projected number of bytes for the linker command line\n+\n+      Link_Max : Integer;\n+      pragma Import (C, Link_Max, \"__gnat_link_max\");\n+      --  Maximum number of bytes on the command line supported by the OS\n+      --  linker. Passed this limit the response file mechanism must be used\n+      --  if supported.\n+\n+      Object_List_File_Supported : Boolean;\n+      for Object_List_File_Supported'Size use Character'Size;\n+      pragma Import\n+        (C, Object_List_File_Supported, \"__gnat_objlist_file_supported\");\n+      --  Predicate indicating whether the linker has an option whereby the\n+      --  names of object files can be passed to the linker in a file.\n+\n+      Object_File_Option_Ptr : Interfaces.C.Strings.chars_ptr;\n+      pragma Import (C, Object_File_Option_Ptr, \"__gnat_object_file_option\");\n+      --  Pointer to a string representing the linker option which specifies\n+      --  the response file.\n+\n+      Using_GNU_Linker : Boolean;\n+      for Using_GNU_Linker'Size use Character'Size;\n+      pragma Import (C, Using_GNU_Linker, \"__gnat_using_gnu_linker\");\n+      --  Predicate indicating whether this target uses the GNU linker. In\n+      --  this case we must output a GNU linker compatible response file.\n+\n+      Opening : aliased constant String := \"\"\"\";\n+      Closing : aliased constant String := '\"' & ASCII.LF;\n+      --  Needed to quote object paths in object list files when GNU linker\n+      --  is used.\n+\n+      Tname    : String_Access;\n+      Tname_FD : File_Descriptor := Invalid_FD;\n+      --  Temporary file used by linker to pass list of object files on\n+      --  certain systems with limitations on size of arguments.\n+\n+      Closing_Status : Boolean;\n+      --  For call to Close\n+\n       Arguments :\n-        OS_Lib.Argument_List\n+        Argument_List\n           (1 .. 7 + Objects'Length + Options'Length + Options_2'Length);\n \n       A       : Natural := 0;\n       Success : Boolean;\n \n-      Out_Opt : constant OS_Lib.String_Access :=\n-                  new String'(\"-o\");\n-      Out_V   : constant OS_Lib.String_Access :=\n-                  new String'(Output_File);\n-      Lib_Dir : constant OS_Lib.String_Access :=\n-                  new String'(\"-L\" & Lib_Directory);\n-      Lib_Opt : constant OS_Lib.String_Access :=\n-                  new String'(Dynamic_Option);\n+      Out_Opt : constant String_Access := new String'(\"-o\");\n+      Out_V   : constant String_Access := new String'(Output_File);\n+      Lib_Dir : constant String_Access := new String'(\"-L\" & Lib_Directory);\n+      Lib_Opt : constant String_Access := new String'(Dynamic_Option);\n \n-      Driver    : String_Access;\n+      Driver : String_Access;\n \n       type Object_Position is (First, Second, Last);\n \n       Position : Object_Position;\n \n+      procedure Write_RF (A : System.Address; N : Integer);\n+      --  Write a string to the response file and check if it was successful.\n+      --  Fail the program if it was not successful (disk full).\n+\n+      --------------\n+      -- Write_RF --\n+      --------------\n+\n+      procedure Write_RF (A : System.Address; N : Integer) is\n+         Status : Integer;\n+      begin\n+         Status := Write (Tname_FD, A, N);\n+\n+         if Status /= N then\n+            Fail (\"cannot generate response file to link library: disk full\");\n+         end if;\n+      end Write_RF;\n+\n    begin\n       if Driver_Name = No_Name then\n          if Gcc_Exec = null then\n-            Gcc_Exec := OS_Lib.Locate_Exec_On_Path (Gcc_Name);\n+            Gcc_Exec := Locate_Exec_On_Path (Gcc_Name);\n \n             if Gcc_Exec = null then\n                Fail (Gcc_Name, \" not found in path\");\n@@ -234,30 +418,40 @@ package body MLib.Utl is\n          Driver := Gcc_Exec;\n \n       else\n-         Driver := OS_Lib.Locate_Exec_On_Path (Get_Name_String (Driver_Name));\n+         Driver := Locate_Exec_On_Path (Get_Name_String (Driver_Name));\n \n          if Driver = null then\n             Fail (Get_Name_String (Driver_Name), \" not found in path\");\n          end if;\n       end if;\n \n+      Link_Bytes := 0;\n+\n       if Lib_Opt'Length /= 0 then\n          A := A + 1;\n          Arguments (A) := Lib_Opt;\n+         Link_Bytes := Link_Bytes + Lib_Opt'Length + 1;\n       end if;\n \n       A := A + 1;\n       Arguments (A) := Out_Opt;\n+      Link_Bytes := Link_Bytes + Out_Opt'Length + 1;\n \n       A := A + 1;\n       Arguments (A) := Out_V;\n+      Link_Bytes := Link_Bytes + Out_V'Length + 1;\n \n       A := A + 1;\n       Arguments (A) := Lib_Dir;\n+      Link_Bytes := Link_Bytes + Lib_Dir'Length + 1;\n \n       A := A + Options'Length;\n       Arguments (A - Options'Length + 1 .. A) := Options;\n \n+      for J in Options'Range loop\n+         Link_Bytes := Link_Bytes + Options (J)'Length + 1;\n+      end loop;\n+\n       if not Opt.Quiet_Output then\n          Write_Str (Driver.all);\n \n@@ -290,18 +484,102 @@ package body MLib.Utl is\n          Write_Eol;\n       end if;\n \n-      A := A + Objects'Length;\n-      Arguments (A - Objects'Length + 1 .. A) := Objects;\n+      for J in Objects'Range loop\n+         Link_Bytes := Link_Bytes + Objects (J)'Length + 1;\n+      end loop;\n+\n+      for J in Options_2'Range loop\n+         Link_Bytes := Link_Bytes + Options_2 (J)'Length + 1;\n+      end loop;\n+\n+      if Object_List_File_Supported and then Link_Bytes > Link_Max then\n+         --  Create a temporary file containing the object files, one object\n+         --  file per line for maximal compatibility with linkers supporting\n+         --  this option.\n+\n+         Create_Temp_File (Tname_FD, Tname);\n+\n+         --  If target is using the GNU linker we must add a special header\n+         --  and footer in the response file.\n+\n+         --  The syntax is : INPUT (object1.o object2.o ... )\n+\n+         --  Because the GNU linker does not like name with characters such\n+         --  as '!', we must put the object paths between double quotes.\n+\n+         if Using_GNU_Linker then\n+            declare\n+               GNU_Header : aliased constant String := \"INPUT (\";\n+\n+            begin\n+               Write_RF (GNU_Header'Address, GNU_Header'Length);\n+            end;\n+         end if;\n+\n+         for J in Objects'Range loop\n+            --  Opening quote for GNU linker\n+\n+            if Using_GNU_Linker then\n+               Write_RF (Opening'Address, 1);\n+            end if;\n+\n+            Write_RF\n+                (Objects (J).all'Address, Objects (J).all'Length);\n+\n+            --  Closing quote for GNU linker\n+\n+            if Using_GNU_Linker then\n+               Write_RF (Closing'Address, 2);\n+\n+            else\n+               Write_RF (ASCII.LF'Address, 1);\n+            end if;\n+         end loop;\n+\n+         --  Handle GNU linker response file footer\n+\n+         if Using_GNU_Linker then\n+            declare\n+               GNU_Footer : aliased constant String := \")\";\n+\n+            begin\n+               Write_RF (GNU_Footer'Address, GNU_Footer'Length);\n+            end;\n+         end if;\n+\n+         Close (Tname_FD, Closing_Status);\n+\n+         if not Closing_Status then\n+            Fail (\"cannot generate response file to link library: disk full\");\n+         end if;\n+\n+         A := A + 1;\n+         Arguments (A) :=\n+           new String'(Value (Object_File_Option_Ptr) & Tname.all);\n+\n+      else\n+         A := A + Objects'Length;\n+         Arguments (A - Objects'Length + 1 .. A) := Objects;\n+      end if;\n \n       A := A + Options_2'Length;\n       Arguments (A - Options_2'Length + 1 .. A) := Options_2;\n \n-      OS_Lib.Spawn (Driver.all, Arguments (1 .. A), Success);\n+      Spawn (Driver.all, Arguments (1 .. A), Success);\n+\n+      if Tname /= null then\n+         Delete_File (Tname.all, Closing_Status);\n+\n+         if not Closing_Status then\n+            Write_Str (\"warning: could not delete response file \"\"\");\n+            Write_Str (Tname.all);\n+            Write_Line (\"\"\" to link library\");\n+         end if;\n+      end if;\n \n       if not Success then\n          if Driver_Name = No_Name then\n             Fail (Gcc_Name, \" execution error\");\n-\n          else\n             Fail (Get_Name_String (Driver_Name), \" execution error\");\n          end if;"}, {"sha": "d0476b03e500f0dd3962e4247ec7d55165c8d9cf", "filename": "gcc/ada/mlib-utl.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09/gcc%2Fada%2Fmlib-utl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09/gcc%2Fada%2Fmlib-utl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-utl.ads?ref=b5755e2ba523ae36cb5f033ec1dd29d4cda71c09", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2006, AdaCore                     --\n+--                     Copyright (C) 2001-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,8 +30,8 @@\n package MLib.Utl is\n \n    procedure Delete_File (Filename : String);\n-   --  Delete the file Filename\n-   --  Why is this different from the standard OS_Lib routine???\n+   --  Delete the file Filename and output the name of the deleted file in\n+   --  verbose mode.\n \n    procedure Gcc\n      (Output_File : String;"}, {"sha": "d2aeaab3e8b64ae232e3063b287d5c360d8f30d3", "filename": "gcc/ada/mlib.adb", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09/gcc%2Fada%2Fmlib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09/gcc%2Fada%2Fmlib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.adb?ref=b5755e2ba523ae36cb5f033ec1dd29d4cda71c09", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2006, AdaCore                     --\n+--                     Copyright (C) 1999-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,7 +30,6 @@ with Interfaces.C.Strings;\n with Hostparm;\n with Opt;\n with Output; use Output;\n-with Namet;  use Namet;\n \n with MLib.Utl; use MLib.Utl;\n \n@@ -59,7 +58,8 @@ package body MLib is\n          Write_Line (Output_File);\n       end if;\n \n-      Ar (Output_Dir & \"/lib\" & Output_File & \".a\", Objects => Ofiles);\n+      Ar (Output_Dir & Directory_Separator &\n+          \"lib\" & Output_File & \".a\", Objects => Ofiles);\n    end Build_Library;\n \n    ------------------------\n@@ -97,7 +97,7 @@ package body MLib is\n \n    procedure Copy_ALI_Files\n      (Files      : Argument_List;\n-      To         : Name_Id;\n+      To         : Path_Name_Type;\n       Interfaces : String_List)\n    is\n       Success      : Boolean := False;\n@@ -130,6 +130,10 @@ package body MLib is\n \n          for Index in Files'Range loop\n             Verbose_Copy (Index);\n+            Set_Writable\n+              (To_Dir &\n+               Directory_Separator &\n+               Base_Name (Files (Index).all));\n             Copy_File\n               (Files (Index).all,\n                To_Dir,\n@@ -169,15 +173,19 @@ package body MLib is\n                if Is_Interface then\n                   Success := False;\n                   Verbose_Copy (Index);\n+                  Set_Writable\n+                    (To_Dir &\n+                     Directory_Separator &\n+                     Base_Name (Files (Index).all));\n \n                   declare\n-                     FD         : File_Descriptor;\n-                     Len        : Integer;\n-                     Actual_Len : Integer;\n-                     S          : String_Access;\n-                     Curr       : Natural;\n+                     FD           : File_Descriptor;\n+                     Len          : Integer;\n+                     Actual_Len   : Integer;\n+                     S            : String_Access;\n+                     Curr         : Natural;\n                      P_Line_Found : Boolean;\n-                     Status     : Boolean;\n+                     Status       : Boolean;\n \n                   begin\n                      --  Open the file"}, {"sha": "2c020fdda70a168153287a1b72e538e3f943255a", "filename": "gcc/ada/mlib.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09/gcc%2Fada%2Fmlib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b5755e2ba523ae36cb5f033ec1dd29d4cda71c09/gcc%2Fada%2Fmlib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib.ads?ref=b5755e2ba523ae36cb5f033ec1dd29d4cda71c09", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1999-2005, AdaCore                     --\n+--                     Copyright (C) 1999-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,9 +27,10 @@\n --  This package provides the core high level routines used by GNATMLIB\n --  and GNATMAKE to build libraries\n \n+with Namet; use Namet;\n+with Osint; use Osint;\n+\n with GNAT.OS_Lib; use GNAT.OS_Lib;\n-with Osint;       use Osint;\n-with Types;       use Types;\n \n package MLib is\n \n@@ -60,7 +61,7 @@ package MLib is\n \n    procedure Copy_ALI_Files\n      (Files      : Argument_List;\n-      To         : Name_Id;\n+      To         : Path_Name_Type;\n       Interfaces : String_List);\n    --  Copy all ALI files Files to directory To.\n    --  Mark Interfaces ALI files as interfaces, if any."}]}