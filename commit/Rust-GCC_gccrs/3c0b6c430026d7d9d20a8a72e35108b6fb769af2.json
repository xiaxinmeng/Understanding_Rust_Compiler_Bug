{"sha": "3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MwYjZjNDMwMDI2ZDdkOWQyMGE4YTcyZTM1MTA4YjZmYjc2OWFmMg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-02-15T22:09:45Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-02-15T22:09:45Z"}, "message": "tree.c (init_ttree): Add STRUCT_FIELD_TAG handling.\n\n2006-02-15 Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree.c (init_ttree): Add STRUCT_FIELD_TAG handling.\n\t(tree_code_size): Ditto.\n\t* tree.h (struct tree_memory_tag): Remove parent_var.\n\t(struct tree_struct_field_tag): New.\n\t(SFT_OFFSET): New.\n\t(SFT_SIZE): New.\n\t(union tree_node): Add sft member.\n\t* tree-ssa-alias.c (get_tmt_for): Don't handle TYPE_READONLY\n\tspecially here.\n\t(create_sft): Add size and offset argument, set SFT_OFFSET and\n\tSFT_SIZE.\n\t(create_overlap_variables_for): Update for SFT_OFFSET/SFT_SIZE.\n\t* treestruct.def: Add TS_STRUCT_FIELD_TAG.\n\t* tree-flow-inline.h (get_subvar_at): Update for\n\tSFT_OFFSET/SFT_SIZE.\n\t(var_can_have_subvars): Ditto.\n\t(overlap_subvar): Ditto.\n\t* print-tree.c (print_node): Print out interesting things for\n\tSFT's.\n\t* tree-flow.h (struct subvar): Remove offset and size members.\n\t* tree-ssa-operands.c (get_expr_operands): Update for\n\tget_indirect_ref_operands changes.\n\t(get_indirect_ref_operands): Call add_virtual_operand instead of\n\tadd_stmt_operand.  Only recurse on base var if requested.\n\t(access_can_touch_variable): New function.\n\t(add_stmt_operand): Split virtual operand handling into ...\n\t(add_virtual_operand): Here.  Add offset, size, and for_clobber\n\targuments.  Prune alias sets.\n\t(add_call_clobber_ops): Call add_virtual_operand.\n\nFrom-SVN: r111120", "tree": {"sha": "da2b2114c7702693918635be6c7ae1407c8010c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da2b2114c7702693918635be6c7ae1407c8010c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cce283c7fed0191170b94eedffe1c95472ca5c9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cce283c7fed0191170b94eedffe1c95472ca5c9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cce283c7fed0191170b94eedffe1c95472ca5c9e"}], "stats": {"total": 501, "additions": 379, "deletions": 122}, "files": [{"sha": "50477ba7a2e8040962623eb75158201776ce25f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "patch": "@@ -1,3 +1,35 @@\n+2006-02-15 Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree.c (init_ttree): Add STRUCT_FIELD_TAG handling.\n+\t(tree_code_size): Ditto.\n+\t* tree.h (struct tree_memory_tag): Remove parent_var.\n+\t(struct tree_struct_field_tag): New.\n+\t(SFT_OFFSET): New.\n+\t(SFT_SIZE): New.\n+\t(union tree_node): Add sft member.\n+\t* tree-ssa-alias.c (get_tmt_for): Don't handle TYPE_READONLY\n+\tspecially here.\n+\t(create_sft): Add size and offset argument, set SFT_OFFSET and\n+\tSFT_SIZE.\n+\t(create_overlap_variables_for): Update for SFT_OFFSET/SFT_SIZE.\n+\t* treestruct.def: Add TS_STRUCT_FIELD_TAG.\n+\t* tree-flow-inline.h (get_subvar_at): Update for\n+\tSFT_OFFSET/SFT_SIZE.\n+\t(var_can_have_subvars): Ditto.\n+\t(overlap_subvar): Ditto.\n+\t* print-tree.c (print_node): Print out interesting things for\n+\tSFT's.\n+\t* tree-flow.h (struct subvar): Remove offset and size members.\n+\t* tree-ssa-operands.c (get_expr_operands): Update for\n+\tget_indirect_ref_operands changes.\n+\t(get_indirect_ref_operands): Call add_virtual_operand instead of\n+\tadd_stmt_operand.  Only recurse on base var if requested.\n+\t(access_can_touch_variable): New function.\n+\t(add_stmt_operand): Split virtual operand handling into ...\n+\t(add_virtual_operand): Here.  Add offset, size, and for_clobber\n+\targuments.  Prune alias sets.\n+\t(add_call_clobber_ops): Call add_virtual_operand.\n+\t\n 2006-02-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/26300"}, {"sha": "02e5c7b9c61be2039768828f0e1afac0f3906332", "filename": "gcc/print-tree.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "patch": "@@ -510,6 +510,15 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t  && DECL_HAS_VALUE_EXPR_P (node))\n \tprint_node (file, \"value-expr\", DECL_VALUE_EXPR (node), indent + 4);\n \n+      if (TREE_CODE (node) == STRUCT_FIELD_TAG)\n+\t{\n+\t  fprintf (file, \" sft size \" HOST_WIDE_INT_PRINT_DEC, \n+\t\t   SFT_SIZE (node));\n+\t  fprintf (file, \" sft offset \" HOST_WIDE_INT_PRINT_DEC,\n+\t\t   SFT_OFFSET (node));\n+\t  print_node_brief (file, \"parent var\", SFT_PARENT_VAR (node), \n+\t\t\t    indent + 4);\n+\t}\n       /* Print the decl chain only if decl is at second level.  */\n       if (indent == 4)\n \tprint_node (file, \"chain\", TREE_CHAIN (node), indent + 4);"}, {"sha": "6a37b863c4c40d1ff348f83dcf57d5667115bcb5", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "patch": "@@ -1450,7 +1450,7 @@ get_subvar_at (tree var, unsigned HOST_WIDE_INT offset)\n   subvar_t sv;\n \n   for (sv = get_subvars_for_var (var); sv; sv = sv->next)\n-    if (sv->offset == offset)\n+    if (SFT_OFFSET (sv->var) == offset)\n       return sv->var;\n \n   return NULL_TREE;\n@@ -1491,7 +1491,7 @@ var_can_have_subvars (tree v)\n \n static inline bool\n overlap_subvar (unsigned HOST_WIDE_INT offset, unsigned HOST_WIDE_INT size,\n-\t\tsubvar_t sv,  bool *exact)\n+\t\ttree sv,  bool *exact)\n {\n   /* There are three possible cases of overlap.\n      1. We can have an exact overlap, like so:   \n@@ -1511,17 +1511,19 @@ overlap_subvar (unsigned HOST_WIDE_INT offset, unsigned HOST_WIDE_INT size,\n \n   if (exact)\n     *exact = false;\n-  if (offset == sv->offset && size == sv->size)\n+  if (offset == SFT_OFFSET (sv) && size == SFT_SIZE (sv))\n     {\n       if (exact)\n \t*exact = true;\n       return true;\n     }\n-  else if (offset >= sv->offset && offset < (sv->offset + sv->size))\n+  else if (offset >= SFT_OFFSET (sv) \n+\t   && offset < (SFT_OFFSET (sv) + SFT_SIZE (sv)))\n     {\n       return true;\n     }\n-  else if (offset < sv->offset && (size > sv->offset - offset))\n+  else if (offset < SFT_OFFSET (sv) \n+\t   && (size > SFT_OFFSET (sv) - offset))\n     {\n       return true;\n     }"}, {"sha": "864835b28c93e31ad89a74bcea746ec3b32afd50", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "patch": "@@ -149,12 +149,6 @@ struct subvar GTY(())\n   /* Fake variable.  */\n   tree var;\n \n-  /* Offset inside structure.  */\n-  unsigned HOST_WIDE_INT offset;\n-\n-  /* Size of the field.  */\n-  unsigned HOST_WIDE_INT size;\n-\n   /* Next subvar for this structure.  */\n   subvar_t next;\n };\n@@ -610,7 +604,7 @@ extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n static inline bool var_can_have_subvars (tree);\n static inline bool overlap_subvar (unsigned HOST_WIDE_INT,\n \t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   subvar_t, bool *);\n+\t\t\t\t   tree, bool *);\n \n /* Call-back function for walk_use_def_chains().  At each reaching\n    definition, a function with this prototype is called.  */"}, {"sha": "b262fd0f0fd81a367ab7d9a45ecd6cf9d1cc2869", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "patch": "@@ -2061,8 +2061,7 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n     {\n       struct alias_map_d *curr = ai->pointers[i];\n       tree curr_tag = var_ann (curr->var)->type_mem_tag;\n-      if (tag_set == curr->set\n-\t  && TYPE_READONLY (tag_type) == TYPE_READONLY (TREE_TYPE (curr_tag)))\n+      if (tag_set == curr->set)\n \t{\n \t  tag = curr_tag;\n \t  break;\n@@ -2099,10 +2098,6 @@ get_tmt_for (tree ptr, struct alias_info *ai)\n      pointed-to type.  */\n   gcc_assert (tag_set == get_alias_set (tag));\n \n-  /* If PTR's pointed-to type is read-only, then TAG's type must also\n-     be read-only.  */\n-  gcc_assert (TYPE_READONLY (tag_type) == TYPE_READONLY (TREE_TYPE (tag)));\n-\n   return tag;\n }\n \n@@ -2749,11 +2744,12 @@ get_or_create_used_part_for (size_t uid)\n }\n \n \n-/* Create and return a structure sub-variable for field type FIELD of\n-   variable VAR.  */\n+/* Create and return a structure sub-variable for field type FIELD at\n+   offset OFFSET, with size SIZE, of variable VAR.  */\n \n static tree\n-create_sft (tree var, tree field)\n+create_sft (tree var, tree field, unsigned HOST_WIDE_INT offset,\n+\t    unsigned HOST_WIDE_INT size)\n {\n   var_ann_t ann;\n   tree subvar = create_tag_raw (STRUCT_FIELD_TAG, field, \"SFT\");\n@@ -2771,7 +2767,8 @@ create_sft (tree var, tree field)\n   ann->type_mem_tag = NULL;  \t\n   add_referenced_tmp_var (subvar);\n   SFT_PARENT_VAR (subvar) = var;\n-\n+  SFT_OFFSET (subvar) = offset;\n+  SFT_SIZE (subvar) = size;\n   return subvar;\n }\n \n@@ -2882,19 +2879,17 @@ create_overlap_variables_for (tree var)\n \t\t  && currfotype == lastfotype))\n \t    continue;\n \t  sv = GGC_NEW (struct subvar);\n-\t  sv->offset = fo->offset;\n-\t  sv->size = fosize;\n \t  sv->next = *subvars;\n-\t  sv->var = create_sft (var, fo->type);\n+\t  sv->var = create_sft (var, fo->type, fo->offset, fosize);\n \n \t  if (dump_file)\n \t    {\n \t      fprintf (dump_file, \"structure field tag %s created for var %s\",\n \t\t       get_name (sv->var), get_name (var));\n \t      fprintf (dump_file, \" offset \" HOST_WIDE_INT_PRINT_DEC,\n-\t\t       sv->offset);\n+\t\t       SFT_OFFSET (sv->var));\n \t      fprintf (dump_file, \" size \" HOST_WIDE_INT_PRINT_DEC,\n-\t\t       sv->size);\n+\t\t       SFT_SIZE (sv->var));\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \t  "}, {"sha": "2d0e71cf3727c6ec9885d590183cf2dc95a8bde1", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 296, "deletions": 92, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "patch": "@@ -128,7 +128,8 @@ static unsigned operand_memory_index;\n \n static void get_expr_operands (tree, tree *, int);\n static void get_asm_expr_operands (tree);\n-static void get_indirect_ref_operands (tree, tree, int);\n+static void get_indirect_ref_operands (tree, tree, int, tree, HOST_WIDE_INT,\n+\t\t\t\t       HOST_WIDE_INT, bool);\n static void get_tmr_operands (tree, tree, int);\n static void get_call_expr_operands (tree, tree);\n static inline void append_def (tree *);\n@@ -138,6 +139,9 @@ static void append_v_must_def (tree);\n static void add_call_clobber_ops (tree, tree);\n static void add_call_read_ops (tree, tree);\n static void add_stmt_operand (tree *, stmt_ann_t, int);\n+static void add_virtual_operand (tree, stmt_ann_t, int, tree,\n+\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT, \n+\t\t\t\t bool);\n static void build_ssa_operands (tree stmt);\n                                                                                 \n static def_optype_p free_defs = NULL;\n@@ -1123,7 +1127,8 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \n     case ALIGN_INDIRECT_REF:\n     case INDIRECT_REF:\n-      get_indirect_ref_operands (stmt, expr, flags);\n+      get_indirect_ref_operands (stmt, expr, flags, NULL_TREE,\n+\t\t\t\t 0, -1, true);\n       return;\n \n     case TARGET_MEM_REF:\n@@ -1165,7 +1170,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t    for (sv = svars; sv; sv = sv->next)\n \t      {\n \t\tbool exact;\t\t\n-\t\tif (overlap_subvar (offset, maxsize, sv, &exact))\n+\t\tif (overlap_subvar (offset, maxsize, sv->var, &exact))\n \t\t  {\n \t            int subvar_flags = flags;\n \t\t    none = false;\n@@ -1178,6 +1183,12 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t    if (!none)\n \t      flags |= opf_no_vops;\n \t  }\n+\telse if (TREE_CODE (ref) == INDIRECT_REF)\n+\t  {\n+\t    get_indirect_ref_operands (stmt, ref, flags, expr, \n+\t\t\t\t       offset, maxsize, false);\n+\t    flags |= opf_no_vops;\n+\t  }\n \n \t/* Even if we found subvars above we need to ensure to see\n \t   immediate uses for d in s.a[d].  In case of s.a having\n@@ -1416,10 +1427,24 @@ get_asm_expr_operands (tree stmt)\n }\n \n /* A subroutine of get_expr_operands to handle INDIRECT_REF,\n-   ALIGN_INDIRECT_REF and MISALIGNED_INDIRECT_REF.  */\n+   ALIGN_INDIRECT_REF and MISALIGNED_INDIRECT_REF.  \n+   STMT is the statement being processed, EXPR is the INDIRECT_REF\n+   that got us here.  FLAGS is as in get_expr_operands.\n+   FULL_REF contains the full pointer dereference expression, if we\n+   have it, or NULL otherwise.\n+   OFFSET and SIZE are the location of the access inside the\n+   dereferenced pointer, if known.\n+   RECURSE_ON_BASE should be set to true if we want to continue\n+   calling get_expr_operands on the base pointer, and false if\n+   something else will do it for us.\n+\n+*/\n \n static void\n-get_indirect_ref_operands (tree stmt, tree expr, int flags)\n+get_indirect_ref_operands (tree stmt, tree expr, int flags,\n+\t\t\t   tree full_ref,\n+\t\t\t   HOST_WIDE_INT offset, HOST_WIDE_INT size,\n+\t\t\t   bool recurse_on_base)\n {\n   tree *pptr = &TREE_OPERAND (expr, 0);\n   tree ptr = *pptr;\n@@ -1438,7 +1463,8 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags)\n \t  && pi->name_mem_tag)\n \t{\n \t  /* PTR has its own memory tag.  Use it.  */\n-\t  add_stmt_operand (&pi->name_mem_tag, s_ann, flags);\n+\t  add_virtual_operand (pi->name_mem_tag, s_ann, flags,\n+\t\t\t       full_ref, offset, size, false);\n \t}\n       else\n \t{\n@@ -1464,8 +1490,10 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags)\n \t  if (TREE_CODE (ptr) == SSA_NAME)\n \t    ptr = SSA_NAME_VAR (ptr);\n \t  v_ann = var_ann (ptr);\n+\n \t  if (v_ann->type_mem_tag)\n-\t    add_stmt_operand (&v_ann->type_mem_tag, s_ann, flags);\n+\t    add_virtual_operand (v_ann->type_mem_tag, s_ann, flags,\n+\t\t\t\t full_ref, offset, size, false);\n \t}\n     }\n \n@@ -1483,7 +1511,8 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags)\n     gcc_unreachable ();\n \n   /* Add a USE operand for the base pointer.  */\n-  get_expr_operands (stmt, pptr, opf_none);\n+  if (recurse_on_base)\n+    get_expr_operands (stmt, pptr, opf_none);\n }\n \n /* A subroutine of get_expr_operands to handle TARGET_MEM_REF.  */\n@@ -1528,7 +1557,7 @@ get_tmr_operands (tree stmt, tree expr, int flags)\n   for (sv = svars; sv; sv = sv->next)\n     {\n       bool exact;\t\t\n-      if (overlap_subvar (offset, maxsize, sv, &exact))\n+      if (overlap_subvar (offset, maxsize, sv->var, &exact))\n \t{\n \t  int subvar_flags = flags;\n \t  if (!exact || size != maxsize)\n@@ -1580,30 +1609,151 @@ get_call_expr_operands (tree stmt, tree expr)\n \n }\n \n+/* REF is a tree that contains the entire pointer dereference\n+   expression, if available, or NULL otherwise.  ALIAS is the variable\n+   we are asking if REF can access.  OFFSET and SIZE come from the\n+   memory access expression that generated this virtual operand.\n+   FOR_CLOBBER is true is this is adding a virtual operand for a call\n+   clobber.  */\n+\n+static bool\n+access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n+\t\t\t   HOST_WIDE_INT size)\n+{  \n+  bool offsetgtz = offset > 0;\n+  unsigned HOST_WIDE_INT uoffset = (unsigned HOST_WIDE_INT) offset;\n+  tree base = ref ? get_base_address (ref) : NULL;\n+\n+  /* If ALIAS is an SFT, it can't be touched if the offset     \n+     and size of the access is not overlapping with the SFT offset and\n+     size.    This is only true if we are accessing through a pointer\n+     to a type that is the same as SFT_PARENT_VAR.  Otherwise, we may\n+     be accessing through a pointer to some substruct of the\n+     structure, and if we try to prune there, we will have the wrong\n+     offset, and get the wrong answer.\n+     i.e., we can't prune without more work if we have something like\n+     struct gcc_target\n+     {\n+       struct asm_out\n+       {\n+         const char *byte_op;\n+\t struct asm_int_op\n+\t {    \n+\t   const char *hi;\n+\t } aligned_op;\n+       } asm_out;\n+     } targetm;\n+     \n+     foo = &targetm.asm_out.aligned_op;\n+     return foo->hi;\n+\n+     SFT.1, which represents hi, will have SFT_OFFSET=32 because in\n+     terms of SFT_PARENT_VAR, that is where it is.\n+     However, the access through the foo pointer will be at offset 0.\n+  */\n+  if (size != -1\n+      && TREE_CODE (alias) == STRUCT_FIELD_TAG\n+      && base\n+      && TREE_TYPE (base) == TREE_TYPE (SFT_PARENT_VAR (alias))\n+      && !overlap_subvar (offset, size, alias, NULL))\n+    {\n+#ifdef ACCESS_DEBUGGING\n+      fprintf (stderr, \"Access to \");\n+      print_generic_expr (stderr, ref, 0);\n+      fprintf (stderr, \" may not touch \");\n+      print_generic_expr (stderr, alias, 0);\n+      fprintf (stderr, \" in function %s\\n\", get_name (current_function_decl));\n+#endif\n+      return false;\n+    }\n+  /* Without strict aliasing, it is impossible for a component access\n+     through a pointer to touch a random variable, unless that\n+     variable *is* a structure or a pointer.\n \n-/* Add *VAR_P to the appropriate operand array for INFO.  FLAGS is as in\n-   get_expr_operands.  If *VAR_P is a GIMPLE register, it will be added to\n-   the statement's real operands, otherwise it is added to virtual\n-   operands.  */\n+     \n+     IE given p->c, and some random global variable b,\n+     there is no legal way that p->c could be an access to b.\n+     \n+     Without strict aliasing on, we consider it legal to do something\n+     like:\n+     struct foos { int l; };\n+     int foo;\n+     static struct foos *getfoo(void);\n+     int main (void)\n+     {\n+       struct foos *f = getfoo();\n+       f->l = 1;\n+       foo = 2;\n+       if (f->l == 1)\n+         abort();\n+       exit(0);\n+     }\n+     static struct foos *getfoo(void)     \n+     { return (struct foos *)&foo; }\n+     \n+     (taken from 20000623-1.c)\n+  */\n+  else if (ref \n+\t   && flag_strict_aliasing\n+\t   && TREE_CODE (ref) != INDIRECT_REF\n+\t   && !MTAG_P (alias)\n+\t   && !AGGREGATE_TYPE_P (TREE_TYPE (alias))\n+\t   && !TREE_CODE (TREE_TYPE (alias)) == COMPLEX_TYPE\n+\t   && !POINTER_TYPE_P (TREE_TYPE (alias)))\n+    {\n+#ifdef ACCESS_DEBUGGING\n+      fprintf (stderr, \"Access to \");\n+      print_generic_expr (stderr, ref, 0);\n+      fprintf (stderr, \" may not touch \");\n+      print_generic_expr (stderr, alias, 0);\n+      fprintf (stderr, \" in function %s\\n\", get_name (current_function_decl));\n+#endif\n+      return false;\n+    }\n+  /* If the offset of the access is greater than the size of one of\n+     the possible aliases, it can't be touching that alias, because it\n+     would be past the end of the structure.  */\n+  else if (ref\n+\t   && flag_strict_aliasing\n+\t   && TREE_CODE (ref) != INDIRECT_REF\n+\t   && !MTAG_P (alias)\n+\t   && !POINTER_TYPE_P (TREE_TYPE (alias))\n+\t   && offsetgtz\n+\t   && DECL_SIZE (alias)\n+\t   && TREE_CODE (DECL_SIZE (alias)) == INTEGER_CST\n+\t   && uoffset > TREE_INT_CST_LOW (DECL_SIZE (alias)))\n+    {\n+#ifdef ACCESS_DEBUGGING\n+      fprintf (stderr, \"Access to \");\n+      print_generic_expr (stderr, ref, 0);\n+      fprintf (stderr, \" may not touch \");\n+      print_generic_expr (stderr, alias, 0);\n+      fprintf (stderr, \" in function %s\\n\", get_name (current_function_decl));\n+#endif\n+      return false;\n+    }\t   \n+  return true;\n+}\n \n-static void\n-add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n+/* Add VAR to the virtual operands array. FLAGS is as in\n+   get_expr_operands.  FULL_REF is a tree that contains the entire\n+   pointer dereference expression, if available, or NULL otherwise.\n+   OFFSET and SIZE come from the memory access expression that\n+   generated this virtual operand.  FOR_CLOBBER is true is this is\n+   adding a virtual operand for a call clobber.  */\n+\n+static void \n+add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n+\t\t     tree full_ref, HOST_WIDE_INT offset,\n+\t\t     HOST_WIDE_INT size, bool for_clobber)\n {\n-  bool is_real_op;\n-  tree var, sym;\n+  VEC(tree,gc) *aliases;\n+  tree sym;\n   var_ann_t v_ann;\n-\n-  var = *var_p;\n-  gcc_assert (SSA_VAR_P (var));\n-\n-  is_real_op = is_gimple_reg (var);\n-  /* If this is a real operand, the operand is either ssa name or decl.\n-     Virtual operands may only be decls.  */\n-  gcc_assert (is_real_op || DECL_P (var));\n-\n+  \n   sym = (TREE_CODE (var) == SSA_NAME ? SSA_NAME_VAR (var) : var);\n   v_ann = var_ann (sym);\n-\n+  \n   /* Mark statements with volatile operands.  Optimizers should back\n      off from statements having volatile operands.  */\n   if (TREE_THIS_VOLATILE (sym) && s_ann)\n@@ -1623,93 +1773,146 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n      at runtime, then the program is ill formed.  If the statement is\n      not executed then all is well.  At the very least, we cannot ICE.  */\n   if ((flags & opf_non_specific) && unmodifiable_var_p (var))\n-    {\n-      gcc_assert (!is_real_op);\n-      flags &= ~(opf_is_def | opf_kill_def);\n-    }\n+    flags &= ~(opf_is_def | opf_kill_def);\n+  \n \n-  if (is_real_op)\n+  /* The variable is not a GIMPLE register.  Add it (or its aliases) to\n+     virtual operands, unless the caller has specifically requested\n+     not to add virtual operands (used when adding operands inside an\n+     ADDR_EXPR expression).  */\n+  if (flags & opf_no_vops)\n+    return;\n+  \n+  aliases = v_ann->may_aliases;\n+  if (aliases == NULL)\n     {\n-      /* The variable is a GIMPLE register.  Add it to real operands.  */\n+      /* The variable is not aliased or it is an alias tag.  */\n       if (flags & opf_is_def)\n-\tappend_def (var_p);\n+\t{\n+\t  if (flags & opf_kill_def)\n+\t    {\n+\t      /* Only regular variables or struct fields may get a\n+\t\t V_MUST_DEF operand.  */\n+\t      gcc_assert (!MTAG_P (var)\n+\t\t\t  || TREE_CODE (var) == STRUCT_FIELD_TAG);\n+\t      /* V_MUST_DEF for non-aliased, non-GIMPLE register \n+\t\t variable definitions.  */\n+\t      append_v_must_def (var);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Add a V_MAY_DEF for call-clobbered variables and\n+\t\t memory tags.  */\n+\t      append_v_may_def (var);\n+\t    }\n+\t}\n       else\n-\tappend_use (var_p);\n+\tappend_vuse (var);\n     }\n   else\n     {\n-      VEC(tree,gc) *aliases;\n-\n-      /* The variable is not a GIMPLE register.  Add it (or its aliases) to\n-\t virtual operands, unless the caller has specifically requested\n-\t not to add virtual operands (used when adding operands inside an\n-\t ADDR_EXPR expression).  */\n-      if (flags & opf_no_vops)\n-\treturn;\n+      unsigned i;\n+      tree al;\n+      \n+      /* The variable is aliased.  Add its aliases to the virtual\n+\t operands.  */\n+      gcc_assert (VEC_length (tree, aliases) != 0);\n+      \n+      if (flags & opf_is_def)\n+\t{\n+\t  \n+\t  bool none_added = true;\n \n-      aliases = v_ann->may_aliases;\n+\t  for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\t    {\n+\t      if (!access_can_touch_variable (full_ref, al, offset, size))\n+\t\tcontinue;\n+\t      \n+\t      none_added = false;\n+\t      append_v_may_def (al);\n+\t    }\n \n-      if (aliases == NULL)\n-\t{\n-\t  /* The variable is not aliased or it is an alias tag.  */\n-\t  if (flags & opf_is_def)\n+\t  /* If the variable is also an alias tag, add a virtual\n+\t     operand for it, otherwise we will miss representing\n+\t     references to the members of the variable's alias set.\t     \n+\t     This fixes the bug in gcc.c-torture/execute/20020503-1.c.\n+\t     \n+\t     It is also necessary to add bare defs on clobbers for\n+\t     TMT's, so that bare TMT uses caused by pruning all the\n+\t     aliases will link up properly with calls.   */\n+\t  if (v_ann->is_alias_tag || none_added\n+\t      || (TREE_CODE (var) == TYPE_MEMORY_TAG && for_clobber))\n \t    {\n-\t      if (flags & opf_kill_def)\n-\t\t{\n-\t\t  /* Only regular variables or struct fields may get a\n-\t\t     V_MUST_DEF operand.  */\n-\t\t  gcc_assert (!MTAG_P (var)\n-\t\t\t      || TREE_CODE (var) == STRUCT_FIELD_TAG);\n-\t\t  /* V_MUST_DEF for non-aliased, non-GIMPLE register \n-\t\t    variable definitions.  */\n-\t\t  append_v_must_def (var);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Add a V_MAY_DEF for call-clobbered variables and\n-\t\t     memory tags.  */\n-\t\t  append_v_may_def (var);\n-\t\t}\n+\t      /* We should never end up with adding no aliases of an\n+\t\t NMT, as that would imply we got the set wrong.  */\n+\t      gcc_assert (!(none_added && TREE_CODE (var) == NAME_MEMORY_TAG));\n+\t      \n+\t      append_v_may_def (var);\n \t    }\n-\t  else\n-\t    append_vuse (var);\n \t}\n       else\n \t{\n-\t  unsigned i;\n-\t  tree al;\n-\n-\t  /* The variable is aliased.  Add its aliases to the virtual\n-\t     operands.  */\n-\t  gcc_assert (VEC_length (tree, aliases) != 0);\n-\n-\t  if (flags & opf_is_def)\n+\t  bool none_added = true;\n+\t  for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n \t    {\n-\t      /* If the variable is also an alias tag, add a virtual\n-\t\t operand for it, otherwise we will miss representing\n-\t\t references to the members of the variable's alias set.\n-\t\t This fixes the bug in gcc.c-torture/execute/20020503-1.c.  */\n-\t      if (v_ann->is_alias_tag)\n-\t\tappend_v_may_def (var);\n-\n-\t      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n-\t\tappend_v_may_def (al);\n+\t      if (!access_can_touch_variable (full_ref, al, offset, size))\n+\t\tcontinue;\n+\t      none_added = false;\n+\t      append_vuse (al);\n \t    }\n-\t  else\n+\n+\t  /* Similarly, append a virtual uses for VAR itself, when\n+\t     it is an alias tag.  */\n+\t  if (v_ann->is_alias_tag || none_added)\n \t    {\n-\t      /* Similarly, append a virtual uses for VAR itself, when\n-\t\t it is an alias tag.  */\n-\t      if (v_ann->is_alias_tag)\n-\t\tappend_vuse (var);\n+\t      gcc_assert (!(none_added && TREE_CODE (var) == NAME_MEMORY_TAG));\n \n-\t      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n-\t\tappend_vuse (al);\n+\t      append_vuse (var);\n \t    }\n \t}\n     }\n }\n \n-  \n+/* Add *VAR_P to the appropriate operand array for INFO.  FLAGS is as in\n+   get_expr_operands.  If *VAR_P is a GIMPLE register, it will be added to\n+   the statement's real operands, otherwise it is added to virtual\n+   operands.  */\n+\n+static void\n+add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n+{\n+  bool is_real_op;\n+  tree var, sym;\n+  var_ann_t v_ann;\n+\n+  var = *var_p;\n+  gcc_assert (SSA_VAR_P (var));\n+\n+  is_real_op = is_gimple_reg (var);\n+  /* If this is a real operand, the operand is either ssa name or decl.\n+     Virtual operands may only be decls.  */\n+  gcc_assert (is_real_op || DECL_P (var));\n+\n+  sym = (TREE_CODE (var) == SSA_NAME ? SSA_NAME_VAR (var) : var);\n+  v_ann = var_ann (sym);\n+\n+  /* Mark statements with volatile operands.  Optimizers should back\n+     off from statements having volatile operands.  */\n+  if (TREE_THIS_VOLATILE (sym) && s_ann)\n+    s_ann->has_volatile_ops = true;\n+\n+  if (is_real_op)\n+    {\n+      /* The variable is a GIMPLE register.  Add it to real operands.  */\n+      if (flags & opf_is_def)\n+\tappend_def (var_p);\n+      else\n+\tappend_use (var_p);\n+    }\n+  else\n+    add_virtual_operand (var, s_ann, flags, NULL_TREE, 0, -1, false);\n+}\n+\n /* Add the base address of REF to the set *ADDRESSES_TAKEN.  If\n    *ADDRESSES_TAKEN is NULL, a new set is created.  REF may be\n    a single variable whose address has been taken or any other valid\n@@ -1836,7 +2039,8 @@ add_call_clobber_ops (tree stmt, tree callee)\n \t    clobber_stats.static_read_clobbers_avoided++;\n \t}\n       else\n-\tadd_stmt_operand (&var, s_ann, opf_is_def);\n+\tadd_virtual_operand (var, s_ann, opf_is_def, \n+\t\t\t     NULL, 0, -1, true);\n     }\n   \n }"}, {"sha": "0a3d606905898f93b9637cd94371a11900760bf7", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "patch": "@@ -276,6 +276,8 @@ init_ttree (void)\n   tree_contains_struct[NAME_MEMORY_TAG][TS_MEMORY_TAG] = 1;\n   tree_contains_struct[TYPE_MEMORY_TAG][TS_MEMORY_TAG] = 1;\n \n+  tree_contains_struct[STRUCT_FIELD_TAG][TS_STRUCT_FIELD_TAG] = 1;\n+\n   tree_contains_struct[VAR_DECL][TS_DECL_WITH_VIS] = 1;\n   tree_contains_struct[FUNCTION_DECL][TS_DECL_WITH_VIS] = 1;\n   tree_contains_struct[TYPE_DECL][TS_DECL_WITH_VIS] = 1;\n@@ -335,8 +337,9 @@ tree_code_size (enum tree_code code)\n \t    return sizeof (struct tree_function_decl);\n \t  case NAME_MEMORY_TAG:\n \t  case TYPE_MEMORY_TAG:\n-\t  case STRUCT_FIELD_TAG:\n \t    return sizeof (struct tree_memory_tag);\n+\t  case STRUCT_FIELD_TAG:\n+\t    return sizeof (struct tree_struct_field_tag);\n \t  default:\n \t    return sizeof (struct tree_decl_non_common);\n \t  }"}, {"sha": "f0cb29d05650e728f0931ad1e4a1dfce5ce9e80a", "filename": "gcc/tree.h", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "patch": "@@ -2309,12 +2309,28 @@ struct tree_decl_minimal GTY(())\n struct tree_memory_tag GTY(())\n {\n   struct tree_decl_minimal common;\n-  tree parent_var;\n   unsigned int is_global:1;\n };\n \n #define MTAG_GLOBAL(NODE) (TREE_MEMORY_TAG_CHECK (NODE)->mtag.is_global)\n-#define SFT_PARENT_VAR(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->mtag.parent_var)\n+\n+struct tree_struct_field_tag GTY(())\n+{\n+  struct tree_memory_tag common;\n+  \n+  /* Parent variable.  */\n+  tree parent_var;\n+ \n+  /* Offset inside structure.  */\n+  unsigned HOST_WIDE_INT offset;\n+\n+  /* Size of the field.  */\n+  unsigned HOST_WIDE_INT size;\n+\n+};\n+#define SFT_PARENT_VAR(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.parent_var)\n+#define SFT_OFFSET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.offset)\n+#define SFT_SIZE(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.size)\n \n /* For any sort of a ..._DECL node, this points to the original (abstract)\n    decl node which this decl is an instance of, or else it is NULL indicating\n@@ -3124,6 +3140,7 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_value_handle GTY ((tag (\"TS_VALUE_HANDLE\"))) value_handle;\n   struct tree_constructor GTY ((tag (\"TS_CONSTRUCTOR\"))) constructor;\n   struct tree_memory_tag GTY ((tag (\"TS_MEMORY_TAG\"))) mtag;\n+  struct tree_struct_field_tag GTY ((tag (\"TS_STRUCT_FIELD_TAG\"))) sft; \n   struct tree_omp_clause GTY ((tag (\"TS_OMP_CLAUSE\"))) omp_clause;\n };\n \f"}, {"sha": "b826be65242c477df3002d3e4cefd8b666ea357d", "filename": "gcc/treestruct.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c0b6c430026d7d9d20a8a72e35108b6fb769af2/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=3c0b6c430026d7d9d20a8a72e35108b6fb769af2", "patch": "@@ -60,4 +60,5 @@ DEFTREESTRUCT(TS_STATEMENT_LIST, \"statement list\")\n DEFTREESTRUCT(TS_VALUE_HANDLE, \"value handle\")\n DEFTREESTRUCT(TS_CONSTRUCTOR, \"constructor\")\n DEFTREESTRUCT(TS_MEMORY_TAG, \"memory tag\")\n+DEFTREESTRUCT(TS_STRUCT_FIELD_TAG, \"struct field tag\")\n DEFTREESTRUCT(TS_OMP_CLAUSE, \"omp clause\")"}]}