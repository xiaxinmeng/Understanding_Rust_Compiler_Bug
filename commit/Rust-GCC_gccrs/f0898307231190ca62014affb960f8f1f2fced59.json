{"sha": "f0898307231190ca62014affb960f8f1f2fced59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA4OTgzMDcyMzExOTBjYTYyMDE0YWZmYjk2MGY4ZjFmMmZjZWQ1OQ==", "commit": {"author": {"name": "Sergey Grechanik", "email": "mouseentity@ispras.ru", "date": "2011-08-11T11:53:51Z"}, "committer": {"name": "Alexander Monakov", "email": "amonakov@gcc.gnu.org", "date": "2011-08-11T11:53:51Z"}, "message": "sched-deps.c (sched_get_condition_with_rev): Rename to ...\n\n2011-08-11  Sergey Grechanik  <mouseentity@ispras.ru>\n\t    Alexander Monakov  <amonakov@ispras.ru>\n\n\t* sched-deps.c (sched_get_condition_with_rev): Rename to ...\n\t(sched_get_condition_with_rev_uncached): ... this.  Factor out\n\tcondition caching logic into ...\n\t(sched_get_condition_with_rev): ... this.  Reimplement.  Do not\n\tattempt to use cache for instructions with zero luid.\n\t(sched_analyze_insn): Use INSN_CACHED_COND instead of INSN_COND.\n\t* sched-int.h (INSN_COND): Rename to INSN_CACHED_COND.\n\n\nCo-Authored-By: Alexander Monakov <amonakov@ispras.ru>\n\nFrom-SVN: r177657", "tree": {"sha": "5353ca6b284d07d91d9df7b8a04a2242b23de59e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5353ca6b284d07d91d9df7b8a04a2242b23de59e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0898307231190ca62014affb960f8f1f2fced59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0898307231190ca62014affb960f8f1f2fced59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0898307231190ca62014affb960f8f1f2fced59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0898307231190ca62014affb960f8f1f2fced59/comments", "author": null, "committer": null, "parents": [{"sha": "0d9439b07cce79ee8e822481f75331dc70399826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9439b07cce79ee8e822481f75331dc70399826", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d9439b07cce79ee8e822481f75331dc70399826"}], "stats": {"total": 84, "additions": 54, "deletions": 30}, "files": [{"sha": "0ea71d9693208853a96c9a2261d5ba432432acf1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0898307231190ca62014affb960f8f1f2fced59/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0898307231190ca62014affb960f8f1f2fced59/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0898307231190ca62014affb960f8f1f2fced59", "patch": "@@ -1,3 +1,14 @@\n+2011-08-11  Sergey Grechanik  <mouseentity@ispras.ru>\n+\t    Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* sched-deps.c (sched_get_condition_with_rev): Rename to ...\n+\t(sched_get_condition_with_rev_uncached): ... this.  Factor out\n+\tcondition caching logic into ...\n+\t(sched_get_condition_with_rev): ... this.  Reimplement.  Do not\n+\tattempt to use cache for instructions with zero luid.\n+\t(sched_analyze_insn): Use INSN_CACHED_COND instead of INSN_COND.\n+\t* sched-int.h (INSN_COND): Rename to INSN_CACHED_COND.\n+\n 2011-08-11  Sergey Grechanik  <mouseentity@ispras.ru>\n \n \t* sel-sched-ir.c (get_seqno_of_a_pred): Rename to"}, {"sha": "2961ccab2f46e73005e68fa2471dafb96d0363df", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0898307231190ca62014affb960f8f1f2fced59/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0898307231190ca62014affb960f8f1f2fced59/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=f0898307231190ca62014affb960f8f1f2fced59", "patch": "@@ -499,49 +499,29 @@ deps_may_trap_p (const_rtx mem)\n \n /* Find the condition under which INSN is executed.  If REV is not NULL,\n    it is set to TRUE when the returned comparison should be reversed\n-   to get the actual condition.\n-   We only do actual work the first time we come here for an insn; the\n-   results are cached in INSN_COND and INSN_REVERSE_COND.  */\n+   to get the actual condition.  */\n static rtx\n-sched_get_condition_with_rev (const_rtx insn, bool *rev)\n+sched_get_condition_with_rev_uncached (const_rtx insn, bool *rev)\n {\n   rtx pat = PATTERN (insn);\n   rtx src;\n \n-  if (INSN_COND (insn) == const_true_rtx)\n-    return NULL_RTX;\n-\n-  if (INSN_COND (insn) != NULL_RTX)\n-    {\n-      if (rev)\n-\t*rev = INSN_REVERSE_COND (insn);\n-      return INSN_COND (insn);\n-    }\n-\n-  INSN_COND (insn) = const_true_rtx;\n-  INSN_REVERSE_COND (insn) = false;\n   if (pat == 0)\n     return 0;\n \n   if (rev)\n     *rev = false;\n \n   if (GET_CODE (pat) == COND_EXEC)\n-    {\n-      INSN_COND (insn) = COND_EXEC_TEST (pat);\n-      return COND_EXEC_TEST (pat);\n-    }\n+    return COND_EXEC_TEST (pat);\n \n   if (!any_condjump_p (insn) || !onlyjump_p (insn))\n     return 0;\n \n   src = SET_SRC (pc_set (insn));\n \n   if (XEXP (src, 2) == pc_rtx)\n-    {\n-      INSN_COND (insn) = XEXP (src, 0);\n-      return XEXP (src, 0);\n-    }\n+    return XEXP (src, 0);\n   else if (XEXP (src, 1) == pc_rtx)\n     {\n       rtx cond = XEXP (src, 0);\n@@ -552,14 +532,47 @@ sched_get_condition_with_rev (const_rtx insn, bool *rev)\n \n       if (rev)\n \t*rev = true;\n-      INSN_COND (insn) = cond;\n-      INSN_REVERSE_COND (insn) = true;\n       return cond;\n     }\n \n   return 0;\n }\n \n+/* Caching variant of sched_get_condition_with_rev_uncached.\n+   We only do actual work the first time we come here for an insn; the\n+   results are cached in INSN_CACHED_COND and INSN_REVERSE_COND.  */\n+static rtx\n+sched_get_condition_with_rev (const_rtx insn, bool *rev)\n+{\n+  bool tmp;\n+\n+  if (INSN_LUID (insn) == 0)\n+    return sched_get_condition_with_rev_uncached (insn, rev);\n+\n+  if (INSN_CACHED_COND (insn) == const_true_rtx)\n+    return NULL_RTX;\n+\n+  if (INSN_CACHED_COND (insn) != NULL_RTX)\n+    {\n+      if (rev)\n+\t*rev = INSN_REVERSE_COND (insn);\n+      return INSN_CACHED_COND (insn);\n+    }\n+\n+  INSN_CACHED_COND (insn) = sched_get_condition_with_rev_uncached (insn, &tmp);\n+  INSN_REVERSE_COND (insn) = tmp;\n+\n+  if (INSN_CACHED_COND (insn) == NULL_RTX)\n+    {\n+      INSN_CACHED_COND (insn) = const_true_rtx;\n+      return NULL_RTX;\n+    }\n+\n+  if (rev)\n+    *rev = INSN_REVERSE_COND (insn);\n+  return INSN_CACHED_COND (insn);\n+}\n+\n /* True when we can find a condition under which INSN is executed.  */\n static bool\n sched_has_condition_p (const_rtx insn)\n@@ -2910,9 +2923,9 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \t      for (list = reg_last->uses; list; list = XEXP (list, 1))\n \t\t{\n \t\t  rtx other = XEXP (list, 0);\n-\t\t  if (INSN_COND (other) != const_true_rtx\n-\t\t      && refers_to_regno_p (i, i + 1, INSN_COND (other), NULL))\n-\t\t    INSN_COND (other) = const_true_rtx;\n+\t\t  if (INSN_CACHED_COND (other) != const_true_rtx\n+\t\t      && refers_to_regno_p (i, i + 1, INSN_CACHED_COND (other), NULL))\n+\t\t    INSN_CACHED_COND (other) = const_true_rtx;\n \t\t}\n \t    }\n \t}"}, {"sha": "1e5c71e4e714a0a29623e9beacf7751eab80c1c6", "filename": "gcc/sched-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0898307231190ca62014affb960f8f1f2fced59/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0898307231190ca62014affb960f8f1f2fced59/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=f0898307231190ca62014affb960f8f1f2fced59", "patch": "@@ -875,7 +875,7 @@ extern VEC(haifa_deps_insn_data_def, heap) *h_d_i_d;\n #define INSN_RESOLVED_FORW_DEPS(INSN) (HDID (INSN)->resolved_forw_deps)\n #define INSN_HARD_BACK_DEPS(INSN) (HDID (INSN)->hard_back_deps)\n #define INSN_SPEC_BACK_DEPS(INSN) (HDID (INSN)->spec_back_deps)\n-#define INSN_COND(INSN)\t(HDID (INSN)->cond)\n+#define INSN_CACHED_COND(INSN)\t(HDID (INSN)->cond)\n #define INSN_REVERSE_COND(INSN) (HDID (INSN)->reverse_cond)\n #define CANT_MOVE(INSN)\t(HDID (INSN)->cant_move)\n #define CANT_MOVE_BY_LUID(LUID)\t(VEC_index (haifa_deps_insn_data_def, h_d_i_d, \\"}]}