{"sha": "e4511ca2e9ecdb51d41b64452398f8e2df575668", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ1MTFjYTJlOWVjZGI1MWQ0MWI2NDQ1MjM5OGY4ZTJkZjU3NTY2OA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-06-22T21:57:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-06-22T21:57:01Z"}, "message": "Avoid taking the address of something just because it's in parens.\n\n\t* constexpr.c (same_type_ignoring_tlq_and_bounds_p): New.\n\t(cxx_fold_indirect_ref): Use it.\n\t(cxx_eval_constant_expression) [VIEW_CONVERT_EXPR]: Use it.\n\t* cp-tree.h (REF_PARENTHESIZED_P): Allow VIEW_CONVERT_EXPR.\n\t* semantics.c (force_paren_expr): Use VIEW_CONVERT_EXPR instead of\n\tstatic_cast to reference type.\n\t(maybe_undo_parenthesized_ref): Handle VIEW_CONVERT_EXPR.\n\nFrom-SVN: r261971", "tree": {"sha": "2dbc5f08013ebca3a6f5a11a3a562b29f0d8ab9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dbc5f08013ebca3a6f5a11a3a562b29f0d8ab9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4511ca2e9ecdb51d41b64452398f8e2df575668", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4511ca2e9ecdb51d41b64452398f8e2df575668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4511ca2e9ecdb51d41b64452398f8e2df575668", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4511ca2e9ecdb51d41b64452398f8e2df575668/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "73607ff9ec812d546fcd89e136dac482d9684371", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73607ff9ec812d546fcd89e136dac482d9684371", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73607ff9ec812d546fcd89e136dac482d9684371"}], "stats": {"total": 68, "additions": 41, "deletions": 27}, "files": [{"sha": "8c7b19b1754e41c4cbd03a513d06c405bc1a8ad8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4511ca2e9ecdb51d41b64452398f8e2df575668/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4511ca2e9ecdb51d41b64452398f8e2df575668/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e4511ca2e9ecdb51d41b64452398f8e2df575668", "patch": "@@ -1,3 +1,14 @@\n+2018-06-22  Jason Merrill  <jason@redhat.com>\n+\n+\tAvoid taking the address of something just because it's in parens.\n+\t* constexpr.c (same_type_ignoring_tlq_and_bounds_p): New.\n+\t(cxx_fold_indirect_ref): Use it.\n+\t(cxx_eval_constant_expression) [VIEW_CONVERT_EXPR]: Use it.\n+\t* cp-tree.h (REF_PARENTHESIZED_P): Allow VIEW_CONVERT_EXPR.\n+\t* semantics.c (force_paren_expr): Use VIEW_CONVERT_EXPR instead of\n+\tstatic_cast to reference type.\n+\t(maybe_undo_parenthesized_ref): Handle VIEW_CONVERT_EXPR.\n+\n 2018-06-21  Jason Merrill  <jason@redhat.com>\n \n \t* pt.c (tsubst) [TEMPLATE_TYPE_PARM]: Use TEMPLATE_PARM_DESCENDANTS."}, {"sha": "dea2a4e57b3c55b6384cc6e15c311642df38be89", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4511ca2e9ecdb51d41b64452398f8e2df575668/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4511ca2e9ecdb51d41b64452398f8e2df575668/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=e4511ca2e9ecdb51d41b64452398f8e2df575668", "patch": "@@ -3076,6 +3076,23 @@ cxx_eval_vec_init (const constexpr_ctx *ctx, tree t,\n     return r;\n }\n \n+/* Like same_type_ignoring_top_level_qualifiers_p, but also handle the case\n+   where the desired type is an array of unknown bounds because the variable\n+   has had its bounds deduced since the wrapping expression was created.  */\n+\n+static bool\n+same_type_ignoring_tlq_and_bounds_p (tree type1, tree type2)\n+{\n+  while (TREE_CODE (type1) == ARRAY_TYPE\n+\t && TREE_CODE (type2) == ARRAY_TYPE\n+\t && (!TYPE_DOMAIN (type1) || !TYPE_DOMAIN (type2)))\n+    {\n+      type1 = TREE_TYPE (type1);\n+      type2 = TREE_TYPE (type2);\n+    }\n+  return same_type_ignoring_top_level_qualifiers_p (type1, type2);\n+}\n+\n /* A less strict version of fold_indirect_ref_1, which requires cv-quals to\n    match.  We want to be less strict for simple *& folding; if we have a\n    non-const temporary that we access through a const pointer, that should\n@@ -3108,15 +3125,7 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n       if (TREE_CODE (op) == CONST_DECL)\n \treturn DECL_INITIAL (op);\n       /* *&p => p;  make sure to handle *&\"str\"[cst] here.  */\n-      if (same_type_ignoring_top_level_qualifiers_p (optype, type)\n-\t  /* Also handle the case where the desired type is an array of unknown\n-\t     bounds because the variable has had its bounds deduced since the\n-\t     ADDR_EXPR was created.  */\n-\t  || (TREE_CODE (type) == ARRAY_TYPE\n-\t      && TREE_CODE (optype) == ARRAY_TYPE\n-\t      && TYPE_DOMAIN (type) == NULL_TREE\n-\t      && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (optype),\n-\t\t\t\t\t\t\t    TREE_TYPE (type))))\n+      if (same_type_ignoring_tlq_and_bounds_p (optype, type))\n \t{\n \t  tree fop = fold_read_from_constant_string (op);\n \t  if (fop)\n@@ -4676,7 +4685,11 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t     conversion.  */\n \t  return fold (t);\n \n-\tif (tcode == UNARY_PLUS_EXPR)\n+\t/* Handle an array's bounds having been deduced after we built\n+\t   the wrapping expression.  */\n+\tif (same_type_ignoring_tlq_and_bounds_p (type, TREE_TYPE (op)))\n+\t  r = op;\n+\telse if (tcode == UNARY_PLUS_EXPR)\n \t  r = fold_convert (TREE_TYPE (t), op);\n \telse\n \t  r = fold_build1 (tcode, type, op);"}, {"sha": "f16f00c40ded1fc07804527edbdbe37560d5c0e3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4511ca2e9ecdb51d41b64452398f8e2df575668/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4511ca2e9ecdb51d41b64452398f8e2df575668/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e4511ca2e9ecdb51d41b64452398f8e2df575668", "patch": "@@ -399,7 +399,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       TARGET_EXPR_DIRECT_INIT_P (in TARGET_EXPR)\n       FNDECL_USED_AUTO (in FUNCTION_DECL)\n       DECLTYPE_FOR_LAMBDA_PROXY (in DECLTYPE_TYPE)\n-      REF_PARENTHESIZED_P (in COMPONENT_REF, INDIRECT_REF, SCOPE_REF)\n+      REF_PARENTHESIZED_P (in COMPONENT_REF, INDIRECT_REF, SCOPE_REF, VIEW_CONVERT_EXPR)\n       AGGR_INIT_ZERO_FIRST (in AGGR_INIT_EXPR)\n       CONSTRUCTOR_MUTABLE_POISON (in CONSTRUCTOR)\n       OVL_HIDDEN_P (in OVERLOAD)\n@@ -3676,7 +3676,7 @@ struct GTY(()) lang_decl {\n    of the time in C++14 mode.  */\n \n #define REF_PARENTHESIZED_P(NODE) \\\n-  TREE_LANG_FLAG_2 (TREE_CHECK3 ((NODE), COMPONENT_REF, INDIRECT_REF, SCOPE_REF))\n+  TREE_LANG_FLAG_2 (TREE_CHECK4 ((NODE), COMPONENT_REF, INDIRECT_REF, SCOPE_REF, VIEW_CONVERT_EXPR))\n \n /* Nonzero if this AGGR_INIT_EXPR provides for initialization via a\n    constructor call, rather than an ordinary function call.  */"}, {"sha": "da75f30885f8c71af76e72557af54c8185285de4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4511ca2e9ecdb51d41b64452398f8e2df575668/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4511ca2e9ecdb51d41b64452398f8e2df575668/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e4511ca2e9ecdb51d41b64452398f8e2df575668", "patch": "@@ -1720,23 +1720,10 @@ force_paren_expr (tree expr)\n     REF_PARENTHESIZED_P (expr) = true;\n   else if (processing_template_decl)\n     expr = build1 (PAREN_EXPR, TREE_TYPE (expr), expr);\n-  else if (VAR_P (expr) && DECL_HARD_REGISTER (expr))\n-    /* We can't bind a hard register variable to a reference.  */;\n   else\n     {\n-      cp_lvalue_kind kind = lvalue_kind (expr);\n-      if ((kind & ~clk_class) != clk_none)\n-\t{\n-\t  tree type = unlowered_expr_type (expr);\n-\t  bool rval = !!(kind & clk_rvalueref);\n-\t  type = cp_build_reference_type (type, rval);\n-\t  /* This inhibits warnings in, eg, cxx_mark_addressable\n-\t     (c++/60955).  */\n-\t  warning_sentinel s (extra_warnings);\n-\t  expr = build_static_cast (type, expr, tf_error);\n-\t  if (expr != error_mark_node)\n-\t    REF_PARENTHESIZED_P (expr) = true;\n-\t}\n+      expr = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (expr), expr);\n+      REF_PARENTHESIZED_P (expr) = true;\n     }\n \n   return expr;\n@@ -1765,6 +1752,9 @@ maybe_undo_parenthesized_ref (tree t)\n     }\n   else if (TREE_CODE (t) == PAREN_EXPR)\n     t = TREE_OPERAND (t, 0);\n+  else if (TREE_CODE (t) == VIEW_CONVERT_EXPR\n+\t   && REF_PARENTHESIZED_P (t))\n+    t = TREE_OPERAND (t, 0);\n \n   return t;\n }"}]}