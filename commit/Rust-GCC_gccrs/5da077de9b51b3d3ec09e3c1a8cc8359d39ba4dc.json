{"sha": "5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWRhMDc3ZGU5YjUxYjNkM2VjMDllM2MxYThjYzgzNTlkMzliYTRkYw==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@codesourcery.com", "date": "1999-09-18T18:16:44Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-18T18:16:44Z"}, "message": "rtl.h (global_rtx_index): New enum.\n\n        * rtl.h (global_rtx_index): New enum.\n        (global_rtl): Change to array of rtx.\n        (pc_rtx, cc0_rtx): Redefine accordingly.\n        (cc0_rtx, stack_pointer_rtx, frame_pointer_rtx): Likewise.\n        (hard_frame_pointer_rtx, arg_pointer_rtx): Likewise.\n        (virtual_incoming_args_rtx, virtual_stack_vars_rtx): Likewise.\n        (virtual_outgoing_args_rtx, virtual_cfa): Likewise.\n        (const_int_rtx): Change to array of rtx.\n        (const0_rtx, const1_rtx, const2_rtx, constm1_rtx): Redefine\n        accordingly.\n        * emit-rtl.c (global_rtl): Change to array of rtx.\n        (const_int_rtx): Change to aray of rtx.\n        (gen_rtx_CONST_INT): Redefine accordingly.\n        (init_emit_once): Allocate and initialize global_rtl.  Likewise\n        for const_int_rtx.  Add both as GC roots.\n        * genattrtab.c (global_rtl): Update declaration.\n\nFrom-SVN: r29500", "tree": {"sha": "e1d713ac042501080771e2019559c03759274d81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1d713ac042501080771e2019559c03759274d81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc/comments", "author": null, "committer": null, "parents": [{"sha": "711b552c22af933cd3122dc0c9b5012e1cc1e705", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/711b552c22af933cd3122dc0c9b5012e1cc1e705", "html_url": "https://github.com/Rust-GCC/gccrs/commit/711b552c22af933cd3122dc0c9b5012e1cc1e705"}], "stats": {"total": 345, "additions": 174, "deletions": 171}, "files": [{"sha": "39b001ccc9b2f8c6dfcfd29172e869b9f8dfc890", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc", "patch": "@@ -1,3 +1,22 @@\n+Sat Sep 18 11:15:58 1999  Alex Samuel  <samuel@codesourcery.com>\n+\n+\t* rtl.h (global_rtx_index): New enum.\n+\t(global_rtl): Change to array of rtx.\n+\t(pc_rtx, cc0_rtx): Redefine accordingly.\n+\t(cc0_rtx, stack_pointer_rtx, frame_pointer_rtx): Likewise.\n+\t(hard_frame_pointer_rtx, arg_pointer_rtx): Likewise.\n+\t(virtual_incoming_args_rtx, virtual_stack_vars_rtx): Likewise.\n+\t(virtual_outgoing_args_rtx, virtual_cfa): Likewise.\n+\t(const_int_rtx): Change to array of rtx.\n+\t(const0_rtx, const1_rtx, const2_rtx, constm1_rtx): Redefine\n+\taccordingly. \n+\t* emit-rtl.c (global_rtl): Change to array of rtx.\n+\t(const_int_rtx): Change to aray of rtx.\n+\t(gen_rtx_CONST_INT): Redefine accordingly.\n+\t(init_emit_once): Allocate and initialize global_rtl.  Likewise\n+\tfor const_int_rtx.  Add both as GC roots.\n+\t* genattrtab.c (global_rtl): Update declaration.\n+\n 1999-09-17  Ulrich Drepper  <drepper@cygnus.com>\n \n \t* Makefile (USER_H): Add iso646.h back."}, {"sha": "56886fb280f873d8fd5cc4d11c6beb27b9ecc39f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 91, "deletions": 114, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc", "patch": "@@ -84,28 +84,7 @@ static int no_line_numbers;\n    All of these except perhaps the floating-point CONST_DOUBLEs\n    are unique; no other rtx-object will be equal to any of these.  */\n \n-/* Avoid warnings by initializing the `fld' field.  Since its a union,\n-   bypass problems with KNR compilers by only doing so when __GNUC__. */\n-#ifdef __GNUC__\n-#define FLDI , {{0}}\n-#else\n-#define FLDI\n-#endif\n-\n-struct _global_rtl global_rtl =\n-{\n-  {PC, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI },  /* pc_rtx */\n-  {CC0, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* cc0_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* stack_pointer_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* frame_pointer_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* hard_frame_pointer_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* arg_pointer_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_incoming_args_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_stack_vars_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_stack_dynamic_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_outgoing_args_rtx */\n-  {REG, VOIDmode, 0, 0, 0, 0, 0, 0, 0, 0, 0 FLDI }, /* virtual_cfa_rtx */\n-};\n+rtx global_rtl[GR_MAX];\n \n /* We record floating-point CONST_DOUBLEs in each floating-point mode for\n    the values of 0, 1, and 2.  For the integer entries and VOIDmode, we\n@@ -153,7 +132,7 @@ rtx return_address_pointer_rtx;\t/* (REG:Pmode RETURN_ADDRESS_POINTER_REGNUM) */\n    to save space during the compilation and simplify comparisons of\n    integers.  */\n \n-struct rtx_def const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n+rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n \n /* start_sequence and gen_sequence can make a lot of rtx expressions which are\n    shortly thrown away.  We use two mechanisms to prevent this waste:\n@@ -197,7 +176,7 @@ gen_rtx_CONST_INT (mode, arg)\n      HOST_WIDE_INT arg;\n {\n   if (arg >= - MAX_SAVED_CONST_INT && arg <= MAX_SAVED_CONST_INT)\n-    return &const_int_rtx[arg + MAX_SAVED_CONST_INT];\n+    return const_int_rtx[arg + MAX_SAVED_CONST_INT];\n \n #if STORE_FLAG_VALUE != 1 && STORE_FLAG_VALUE != -1\n   if (const_true_rtx && arg == STORE_FLAG_VALUE)\n@@ -3515,6 +3494,89 @@ init_emit_once (line_numbers)\n \n   no_line_numbers = ! line_numbers;\n \n+  /* Assign register numbers to the globally defined register rtx.\n+     This must be done at runtime because the register number field\n+     is in a union and some compilers can't initialize unions.  */\n+\n+  pc_rtx = gen_rtx (PC, VOIDmode);\n+  cc0_rtx = gen_rtx (CC0, VOIDmode);\n+  stack_pointer_rtx = gen_rtx_raw_REG (Pmode, STACK_POINTER_REGNUM);\n+  frame_pointer_rtx = gen_rtx_raw_REG (Pmode, FRAME_POINTER_REGNUM);\n+  if (hard_frame_pointer_rtx == 0)\n+    hard_frame_pointer_rtx = gen_rtx_raw_REG (Pmode, \n+\t\t\t\t\t      HARD_FRAME_POINTER_REGNUM);\n+  if (arg_pointer_rtx == 0)\n+    arg_pointer_rtx = gen_rtx_raw_REG (Pmode, ARG_POINTER_REGNUM);\n+  virtual_incoming_args_rtx = \n+    gen_rtx_raw_REG (Pmode, VIRTUAL_INCOMING_ARGS_REGNUM);\n+  virtual_stack_vars_rtx = \n+    gen_rtx_raw_REG (Pmode, VIRTUAL_STACK_VARS_REGNUM);\n+  virtual_stack_dynamic_rtx = \n+    gen_rtx_raw_REG (Pmode, VIRTUAL_STACK_DYNAMIC_REGNUM);\n+  virtual_outgoing_args_rtx = \n+    gen_rtx_raw_REG (Pmode, VIRTUAL_OUTGOING_ARGS_REGNUM); \n+  virtual_cfa_rtx = gen_rtx_raw_REG (Pmode, VIRTUAL_CFA_REGNUM);\n+\n+  /* These rtx must be roots if GC is enabled.  */\n+  if (ggc_p)\n+    ggc_add_rtx_root (global_rtl, GR_MAX);\n+\n+#ifdef RETURN_ADDRESS_POINTER_REGNUM\n+  return_address_pointer_rtx\n+    = gen_rtx_raw_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM);\n+#endif\n+\n+#ifdef STRUCT_VALUE\n+  struct_value_rtx = STRUCT_VALUE;\n+#else\n+  struct_value_rtx = gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM);\n+#endif\n+\n+#ifdef STRUCT_VALUE_INCOMING\n+  struct_value_incoming_rtx = STRUCT_VALUE_INCOMING;\n+#else\n+#ifdef STRUCT_VALUE_INCOMING_REGNUM\n+  struct_value_incoming_rtx\n+    = gen_rtx_REG (Pmode, STRUCT_VALUE_INCOMING_REGNUM);\n+#else\n+  struct_value_incoming_rtx = struct_value_rtx;\n+#endif\n+#endif\n+\n+#ifdef STATIC_CHAIN_REGNUM\n+  static_chain_rtx = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n+\n+#ifdef STATIC_CHAIN_INCOMING_REGNUM\n+  if (STATIC_CHAIN_INCOMING_REGNUM != STATIC_CHAIN_REGNUM)\n+    static_chain_incoming_rtx\n+      = gen_rtx_REG (Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n+  else\n+#endif\n+    static_chain_incoming_rtx = static_chain_rtx;\n+#endif\n+\n+#ifdef STATIC_CHAIN\n+  static_chain_rtx = STATIC_CHAIN;\n+\n+#ifdef STATIC_CHAIN_INCOMING\n+  static_chain_incoming_rtx = STATIC_CHAIN_INCOMING;\n+#else\n+  static_chain_incoming_rtx = static_chain_rtx;\n+#endif\n+#endif\n+\n+#ifdef PIC_OFFSET_TABLE_REGNUM\n+  pic_offset_table_rtx = gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n+#endif\n+\n+#ifdef INIT_EXPANDERS\n+  /* This is to initialize save_machine_status and restore_machine_status before\n+     the first call to push_function_context_to.  This is needed by the Chill\n+     front end which calls push_function_context_to before the first cal to\n+     init_function_start.  */\n+  INIT_EXPANDERS;\n+#endif\n+\n   /* Compute the word and byte modes.  */\n \n   byte_mode = VOIDmode;\n@@ -3552,15 +3614,14 @@ init_emit_once (line_numbers)\n   /* Don't use gen_rtx here since gen_rtx in this case\n      tries to use these variables.  */\n   for (i = - MAX_SAVED_CONST_INT; i <= MAX_SAVED_CONST_INT; i++)\n-    {\n-      PUT_CODE (&const_int_rtx[i + MAX_SAVED_CONST_INT], CONST_INT);\n-      PUT_MODE (&const_int_rtx[i + MAX_SAVED_CONST_INT], VOIDmode);\n-      INTVAL (&const_int_rtx[i + MAX_SAVED_CONST_INT]) = i;\n-    }\n+    const_int_rtx[i + MAX_SAVED_CONST_INT] = \n+      gen_rtx_raw_CONST_INT (VOIDmode, i);\n+  if (ggc_p)\n+    ggc_add_rtx_root (const_int_rtx, 2 * MAX_SAVED_CONST_INT + 1);\n \n   if (STORE_FLAG_VALUE >= - MAX_SAVED_CONST_INT\n       && STORE_FLAG_VALUE <= MAX_SAVED_CONST_INT)\n-    const_true_rtx = &const_int_rtx[STORE_FLAG_VALUE + MAX_SAVED_CONST_INT];\n+    const_true_rtx = const_int_rtx[STORE_FLAG_VALUE + MAX_SAVED_CONST_INT];\n   else\n     const_true_rtx = gen_rtx_CONST_INT (VOIDmode, STORE_FLAG_VALUE);\n \n@@ -3603,90 +3664,6 @@ init_emit_once (line_numbers)\n     if (GET_MODE_CLASS (mode) == MODE_CC)\n       const_tiny_rtx[0][(int) mode] = const0_rtx;\n \n-  /* Assign register numbers to the globally defined register rtx.\n-     This must be done at runtime because the register number field\n-     is in a union and some compilers can't initialize unions.  */\n-\n-  REGNO (stack_pointer_rtx) = STACK_POINTER_REGNUM;\n-  PUT_MODE (stack_pointer_rtx, Pmode);\n-  REGNO (frame_pointer_rtx) = FRAME_POINTER_REGNUM;\n-  PUT_MODE (frame_pointer_rtx, Pmode);\n-#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n-  REGNO (hard_frame_pointer_rtx) = HARD_FRAME_POINTER_REGNUM;\n-  PUT_MODE (hard_frame_pointer_rtx, Pmode);\n-#endif\n-#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM && HARD_FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-  REGNO (arg_pointer_rtx) = ARG_POINTER_REGNUM;\n-  PUT_MODE (arg_pointer_rtx, Pmode);\n-#endif\n-\n-  REGNO (virtual_incoming_args_rtx) = VIRTUAL_INCOMING_ARGS_REGNUM;\n-  PUT_MODE (virtual_incoming_args_rtx, Pmode);\n-  REGNO (virtual_stack_vars_rtx) = VIRTUAL_STACK_VARS_REGNUM;\n-  PUT_MODE (virtual_stack_vars_rtx, Pmode);\n-  REGNO (virtual_stack_dynamic_rtx) = VIRTUAL_STACK_DYNAMIC_REGNUM;\n-  PUT_MODE (virtual_stack_dynamic_rtx, Pmode);\n-  REGNO (virtual_outgoing_args_rtx) = VIRTUAL_OUTGOING_ARGS_REGNUM;\n-  PUT_MODE (virtual_outgoing_args_rtx, Pmode);\n-  REGNO (virtual_cfa_rtx) = VIRTUAL_CFA_REGNUM;\n-  PUT_MODE (virtual_cfa_rtx, Pmode);\n-\n-#ifdef RETURN_ADDRESS_POINTER_REGNUM\n-  return_address_pointer_rtx\n-    = gen_rtx_raw_REG (Pmode, RETURN_ADDRESS_POINTER_REGNUM);\n-#endif\n-\n-#ifdef STRUCT_VALUE\n-  struct_value_rtx = STRUCT_VALUE;\n-#else\n-  struct_value_rtx = gen_rtx_REG (Pmode, STRUCT_VALUE_REGNUM);\n-#endif\n-\n-#ifdef STRUCT_VALUE_INCOMING\n-  struct_value_incoming_rtx = STRUCT_VALUE_INCOMING;\n-#else\n-#ifdef STRUCT_VALUE_INCOMING_REGNUM\n-  struct_value_incoming_rtx\n-    = gen_rtx_REG (Pmode, STRUCT_VALUE_INCOMING_REGNUM);\n-#else\n-  struct_value_incoming_rtx = struct_value_rtx;\n-#endif\n-#endif\n-\n-#ifdef STATIC_CHAIN_REGNUM\n-  static_chain_rtx = gen_rtx_REG (Pmode, STATIC_CHAIN_REGNUM);\n-\n-#ifdef STATIC_CHAIN_INCOMING_REGNUM\n-  if (STATIC_CHAIN_INCOMING_REGNUM != STATIC_CHAIN_REGNUM)\n-    static_chain_incoming_rtx\n-      = gen_rtx_REG (Pmode, STATIC_CHAIN_INCOMING_REGNUM);\n-  else\n-#endif\n-    static_chain_incoming_rtx = static_chain_rtx;\n-#endif\n-\n-#ifdef STATIC_CHAIN\n-  static_chain_rtx = STATIC_CHAIN;\n-\n-#ifdef STATIC_CHAIN_INCOMING\n-  static_chain_incoming_rtx = STATIC_CHAIN_INCOMING;\n-#else\n-  static_chain_incoming_rtx = static_chain_rtx;\n-#endif\n-#endif\n-\n-#ifdef PIC_OFFSET_TABLE_REGNUM\n-  pic_offset_table_rtx = gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM);\n-#endif\n-\n-#ifdef INIT_EXPANDERS\n-  /* This is to initialize save_machine_status and restore_machine_status before\n-     the first call to push_function_context_to.  This is needed by the Chill\n-     front end which calls push_function_context_to before the first cal to\n-     init_function_start.  */\n-  INIT_EXPANDERS;\n-#endif\n-\n   ggc_add_rtx_root (&const_tiny_rtx[0][0], sizeof(const_tiny_rtx)/sizeof(rtx));\n \n   ggc_add_rtx_root (&const_true_rtx, 1);"}, {"sha": "b02f2e0a22c9c8c484ae7df5cac6d6cb5aa5eff6", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc", "patch": "@@ -354,7 +354,7 @@ int optimize = 0;\n /* These are referenced by rtlanal.c and hence need to be defined somewhere.\n    They won't actually be used.  */\n \n-struct _global_rtl global_rtl;\n+rtx global_rtl[GR_MAX];\n rtx pic_offset_table_rtx;\n \n static void attr_hash_add_rtx\tPROTO((int, rtx));"}, {"sha": "59043eadaeaec83b4ff664af5fc922ac7b4ca974", "filename": "gcc/rtl.h", "status": "modified", "additions": 63, "deletions": 56, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=5da077de9b51b3d3ec09e3c1a8cc8359d39ba4dc", "patch": "@@ -1167,17 +1167,13 @@ extern rtx get_first_nonparm_insn\tPROTO((void));\n extern void split_block_insns\t\tPROTO((int, int));\n extern void update_flow_info\t\tPROTO((rtx, rtx, rtx, rtx));\n \n-/* Standard pieces of rtx, to be substituted directly into things.  */\n-#define pc_rtx\t\t(&global_rtl.pc_val)\n-#define cc0_rtx\t\t(&global_rtl.cc0_val)\n-\n #define MAX_SAVED_CONST_INT 64\n-extern struct rtx_def const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n+extern rtx const_int_rtx[MAX_SAVED_CONST_INT * 2 + 1];\n \n-#define const0_rtx\t(&const_int_rtx[MAX_SAVED_CONST_INT])\n-#define const1_rtx\t(&const_int_rtx[MAX_SAVED_CONST_INT+1])\n-#define const2_rtx\t(&const_int_rtx[MAX_SAVED_CONST_INT+2])\n-#define constm1_rtx\t(&const_int_rtx[MAX_SAVED_CONST_INT-1])\n+#define const0_rtx\t(const_int_rtx[MAX_SAVED_CONST_INT])\n+#define const1_rtx\t(const_int_rtx[MAX_SAVED_CONST_INT+1])\n+#define const2_rtx\t(const_int_rtx[MAX_SAVED_CONST_INT+2])\n+#define constm1_rtx\t(const_int_rtx[MAX_SAVED_CONST_INT-1])\n extern rtx const_true_rtx;\n \n extern rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n@@ -1192,24 +1188,64 @@ extern rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n #define CONST1_RTX(MODE) (const_tiny_rtx[1][(int) (MODE)])\n #define CONST2_RTX(MODE) (const_tiny_rtx[2][(int) (MODE)])\n \n-extern struct _global_rtl\n+/* If HARD_FRAME_POINTER_REGNUM is defined, then a special dummy reg\n+   is used to represent the frame pointer.  This is because the\n+   hard frame pointer and the automatic variables are separated by an amount\n+   that cannot be determined until after register allocation.  We can assume\n+   that in this case ELIMINABLE_REGS will be defined, one action of which\n+   will be to eliminate FRAME_POINTER_REGNUM into HARD_FRAME_POINTER_REGNUM. */\n+#ifndef HARD_FRAME_POINTER_REGNUM\n+#define HARD_FRAME_POINTER_REGNUM FRAME_POINTER_REGNUM\n+#endif\n+\n+/* Index labels for global_rtl.  */\n+enum global_rtl_index\n {\n-  struct rtx_def pc_val, cc0_val;\n-  struct rtx_def stack_pointer_val, frame_pointer_val;\n-  struct rtx_def hard_frame_pointer_val;\n-  struct rtx_def arg_pointer_val;\n-  struct rtx_def virtual_incoming_args_val;\n-  struct rtx_def virtual_stack_vars_val;\n-  struct rtx_def virtual_stack_dynamic_val;\n-  struct rtx_def virtual_outgoing_args_val;\n-  struct rtx_def virtual_cfa_val;\n-} global_rtl;\n+  GR_PC,\n+  GR_CC0,\n+  GR_STACK_POINTER,\n+  GR_FRAME_POINTER,\n+/* For register elimination to work properly these hard_frame_pointer_rtx,\n+   frame_pointer_rtx, and arg_pointer_rtx must be the same if they refer to\n+   the same register.  */\n+#if FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n+  GR_ARG_POINTER = GR_FRAME_POINTER,\n+#endif\n+#if HARD_FRAME_POINTER_REGNUM == FRAME_POINTER_REGNUM\n+  GR_HARD_FRAME_POINTER = GR_FRAME_POINTER,\n+#else\n+  GR_HARD_FRAME_POINTER,\n+#endif\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+#if HARD_FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n+  GR_ARG_POINTER = GR_HARD_FRAME_POINTER,\n+#else\n+  GR_ARG_POINTER,\n+#endif\n+#endif\n+  GR_VIRTUAL_INCOMING_ARGS,\n+  GR_VIRTUAL_STACK_ARGS,\n+  GR_VIRTUAL_STACK_DYNAMIC,\n+  GR_VIRTUAL_OUTGOING_ARGS,\n+  GR_VIRTUAL_CFA,\n+\n+  GR_MAX\n+};\n+\n+/* Pointers to standard pieces of rtx are stored here.  */\n+extern rtx global_rtl[GR_MAX];\n+\n+/* Standard pieces of rtx, to be substituted directly into things.  */\n+#define pc_rtx                  (global_rtl[GR_PC])\n+#define cc0_rtx                 (global_rtl[GR_CC0])\n \n /* All references to certain hard regs, except those created\n    by allocating pseudo regs into them (when that's possible),\n    go through these unique rtx objects.  */\n-#define stack_pointer_rtx\t(&global_rtl.stack_pointer_val)\n-#define frame_pointer_rtx\t(&global_rtl.frame_pointer_val)\n+#define stack_pointer_rtx       (global_rtl[GR_STACK_POINTER])\n+#define frame_pointer_rtx       (global_rtl[GR_FRAME_POINTER])\n+#define hard_frame_pointer_rtx\t(global_rtl[GR_HARD_FRAME_POINTER])\n+#define arg_pointer_rtx\t\t(global_rtl[GR_ARG_POINTER])\n \n extern rtx pic_offset_table_rtx;\n extern rtx struct_value_rtx;\n@@ -1239,35 +1275,6 @@ extern rtx gen_rtx_MEM PROTO((enum machine_mode, rtx));\n    and without prototypes.  */\n #define GEN_INT(N)  gen_rtx_CONST_INT (VOIDmode, (HOST_WIDE_INT) (N))\n \n-/* If HARD_FRAME_POINTER_REGNUM is defined, then a special dummy reg\n-   is used to represent the frame pointer.  This is because the\n-   hard frame pointer and the automatic variables are separated by an amount\n-   that cannot be determined until after register allocation.  We can assume\n-   that in this case ELIMINABLE_REGS will be defined, one action of which\n-   will be to eliminate FRAME_POINTER_REGNUM into HARD_FRAME_POINTER_REGNUM. */\n-#ifndef HARD_FRAME_POINTER_REGNUM\n-#define HARD_FRAME_POINTER_REGNUM FRAME_POINTER_REGNUM\n-#endif\n-\n-/* For register elimination to work properly these hard_frame_pointer_rtx,\n-   frame_pointer_rtx, and arg_pointer_rtx must be the same if they refer to\n-   the same register.  */\n-#if HARD_FRAME_POINTER_REGNUM == FRAME_POINTER_REGNUM\n-#define hard_frame_pointer_rtx\t(&global_rtl.frame_pointer_val)\n-#else\n-#define hard_frame_pointer_rtx\t(&global_rtl.hard_frame_pointer_val)\n-#endif\n-\n-#if FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n-#define arg_pointer_rtx\t\t(&global_rtl.frame_pointer_val)\n-#else\n-#if HARD_FRAME_POINTER_REGNUM == ARG_POINTER_REGNUM\n-#define arg_pointer_rtx\t\t(&global_rtl.hard_frame_pointer_val)\n-#else\n-#define arg_pointer_rtx\t\t(&global_rtl.arg_pointer_val)\n-#endif\n-#endif\n-\n /* Virtual registers are used during RTL generation to refer to locations into\n    the stack frame when the actual location isn't known until RTL generation\n    is complete.  The routine instantiate_virtual_regs replaces these with\n@@ -1280,31 +1287,31 @@ extern rtx gen_rtx_MEM PROTO((enum machine_mode, rtx));\n    either by the caller or by the callee when pretending it was passed by the\n    caller.  */\n \n-#define virtual_incoming_args_rtx (&global_rtl.virtual_incoming_args_val)\n+#define virtual_incoming_args_rtx       (global_rtl[GR_VIRTUAL_INCOMING_ARGS])\n \n #define VIRTUAL_INCOMING_ARGS_REGNUM\t(FIRST_VIRTUAL_REGISTER)\n \n /* If FRAME_GROWS_DOWNWARD, this points to immediately above the first\n    variable on the stack.  Otherwise, it points to the first variable on\n    the stack.  */\n \n-#define virtual_stack_vars_rtx\t(&global_rtl.virtual_stack_vars_val)\n+#define virtual_stack_vars_rtx\t        (global_rtl[GR_VIRTUAL_STACK_ARGS])\n \n #define VIRTUAL_STACK_VARS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 1)\n \n /* This points to the location of dynamically-allocated memory on the stack\n    immediately after the stack pointer has been adjusted by the amount\n    desired.  */\n \n-#define virtual_stack_dynamic_rtx\t(&global_rtl.virtual_stack_dynamic_val)\n+#define virtual_stack_dynamic_rtx\t(global_rtl[GR_VIRTUAL_STACK_DYNAMIC])\n \n #define VIRTUAL_STACK_DYNAMIC_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 2)\n \n /* This points to the location in the stack at which outgoing arguments should\n    be written when the stack is pre-pushed (arguments pushed using push\n    insns always use sp).  */\n \n-#define virtual_outgoing_args_rtx\t(&global_rtl.virtual_outgoing_args_val)\n+#define virtual_outgoing_args_rtx\t(global_rtl[GR_VIRTUAL_OUTGOING_ARGS])\n \n #define VIRTUAL_OUTGOING_ARGS_REGNUM\t((FIRST_VIRTUAL_REGISTER) + 3)\n \n@@ -1314,7 +1321,7 @@ extern rtx gen_rtx_MEM PROTO((enum machine_mode, rtx));\n    frame pointer nor stack pointer are necessarily fixed relative to \n    the CFA until after reload.  */\n \n-#define virtual_cfa_rtx\t\t\t(&global_rtl.virtual_cfa_val)\n+#define virtual_cfa_rtx\t\t\t(global_rtl[GR_VIRTUAL_CFA])\n \n #define VIRTUAL_CFA_REGNUM\t\t((FIRST_VIRTUAL_REGISTER) + 4)\n "}]}