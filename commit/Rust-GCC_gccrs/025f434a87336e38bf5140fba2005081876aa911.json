{"sha": "025f434a87336e38bf5140fba2005081876aa911", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI1ZjQzNGE4NzMzNmUzOGJmNTE0MGZiYTIwMDUwODE4NzZhYTkxMQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-11-05T06:04:10Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-11-05T06:28:28Z"}, "message": "rs6000: Use direct move for char/short vector CTOR [PR96933]\n\nThis patch is to make vector CTOR with char/short leverage direct\nmove instructions when they are available.  With one constructed\ntest case, it can speed up 145% for char and 190% for short on P9.\n\nTested SPEC2017 x264_r at -Ofast on P9, it gets 1.61% speedup\n(but based on unexpected SLP see PR96789).\n\nBootstrapped/regtested on powerpc64{,le}-linux-gnu P8 and\npowerpc64le-linux-gnu P9.\n\ngcc/ChangeLog:\n\n\tPR target/96933\n\t* config/rs6000/rs6000.c (rs6000_expand_vector_init): Use direct move\n\tinstructions for vector construction with char/short types.\n\t* config/rs6000/rs6000.md (p8_mtvsrwz_v16qisi2): New define_insn.\n\t(p8_mtvsrd_v16qidi2): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/96933\n\t* gcc.target/powerpc/pr96933-1.c: New test.\n\t* gcc.target/powerpc/pr96933-2.c: New test.\n\t* gcc.target/powerpc/pr96933-3.c: New test.\n\t* gcc.target/powerpc/pr96933-4.c: New test.\n\t* gcc.target/powerpc/pr96933.h: New test.\n\t* gcc.target/powerpc/pr96933-run.h: New test.", "tree": {"sha": "021b7f0061e50d898c54a847da764f73b600c9b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/021b7f0061e50d898c54a847da764f73b600c9b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/025f434a87336e38bf5140fba2005081876aa911", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/025f434a87336e38bf5140fba2005081876aa911", "html_url": "https://github.com/Rust-GCC/gccrs/commit/025f434a87336e38bf5140fba2005081876aa911", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/025f434a87336e38bf5140fba2005081876aa911/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35c125cb6ac47fa97aa5ee22f987a38e63adad08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35c125cb6ac47fa97aa5ee22f987a38e63adad08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35c125cb6ac47fa97aa5ee22f987a38e63adad08"}], "stats": {"total": 351, "additions": 349, "deletions": 2}, "files": [{"sha": "e613353d0c9baba043d410f99967822454e6a279", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 177, "deletions": 2, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025f434a87336e38bf5140fba2005081876aa911/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025f434a87336e38bf5140fba2005081876aa911/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=025f434a87336e38bf5140fba2005081876aa911", "patch": "@@ -6522,11 +6522,11 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n {\n   machine_mode mode = GET_MODE (target);\n   machine_mode inner_mode = GET_MODE_INNER (mode);\n-  int n_elts = GET_MODE_NUNITS (mode);\n+  unsigned int n_elts = GET_MODE_NUNITS (mode);\n   int n_var = 0, one_var = -1;\n   bool all_same = true, all_const_zero = true;\n   rtx x, mem;\n-  int i;\n+  unsigned int i;\n \n   for (i = 0; i < n_elts; ++i)\n     {\n@@ -6792,6 +6792,181 @@ rs6000_expand_vector_init (rtx target, rtx vals)\n       return;\n     }\n \n+  if (TARGET_DIRECT_MOVE && (mode == V16QImode || mode == V8HImode))\n+    {\n+      rtx op[16];\n+      /* Force the values into word_mode registers.  */\n+      for (i = 0; i < n_elts; i++)\n+\t{\n+\t  rtx tmp = force_reg (GET_MODE_INNER (mode), XVECEXP (vals, 0, i));\n+\t  if (TARGET_64BIT)\n+\t    {\n+\t      op[i] = gen_reg_rtx (DImode);\n+\t      emit_insn (gen_zero_extendqidi2 (op[i], tmp));\n+\t    }\n+\t  else\n+\t    {\n+\t      op[i] = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_zero_extendqisi2 (op[i], tmp));\n+\t    }\n+\t}\n+\n+      /* Take unsigned char big endianness on 64bit as example for below\n+\t construction, the input values are: A, B, C, D, ..., O, P.  */\n+\n+      if (TARGET_DIRECT_MOVE_128)\n+\t{\n+\t  /* Move to VSX register with vec_concat, each has 2 values.\n+\t     eg: vr1[0] = { xxxxxxxA, xxxxxxxB };\n+\t\t vr1[1] = { xxxxxxxC, xxxxxxxD };\n+\t\t ...\n+\t\t vr1[7] = { xxxxxxxO, xxxxxxxP };  */\n+\t  rtx vr1[8];\n+\t  for (i = 0; i < n_elts / 2; i++)\n+\t    {\n+\t      vr1[i] = gen_reg_rtx (V2DImode);\n+\t      emit_insn (gen_vsx_concat_v2di (vr1[i], op[i * 2],\n+\t\t\t\t\t      op[i * 2 + 1]));\n+\t    }\n+\n+\t  /* Pack vectors with 2 values into vectors with 4 values.\n+\t     eg: vr2[0] = { xxxAxxxB, xxxCxxxD };\n+\t\t vr2[1] = { xxxExxxF, xxxGxxxH };\n+\t\t vr2[1] = { xxxIxxxJ, xxxKxxxL };\n+\t\t vr2[3] = { xxxMxxxN, xxxOxxxP };  */\n+\t  rtx vr2[4];\n+\t  for (i = 0; i < n_elts / 4; i++)\n+\t    {\n+\t      vr2[i] = gen_reg_rtx (V4SImode);\n+\t      emit_insn (gen_altivec_vpkudum (vr2[i], vr1[i * 2],\n+\t\t\t\t\t      vr1[i * 2 + 1]));\n+\t    }\n+\n+\t  /* Pack vectors with 4 values into vectors with 8 values.\n+\t     eg: vr3[0] = { xAxBxCxD, xExFxGxH };\n+\t\t vr3[1] = { xIxJxKxL, xMxNxOxP };  */\n+\t  rtx vr3[2];\n+\t  for (i = 0; i < n_elts / 8; i++)\n+\t    {\n+\t      vr3[i] = gen_reg_rtx (V8HImode);\n+\t      emit_insn (gen_altivec_vpkuwum (vr3[i], vr2[i * 2],\n+\t\t\t\t\t      vr2[i * 2 + 1]));\n+\t    }\n+\n+\t  /* If it's V8HImode, it's done and return it. */\n+\t  if (mode == V8HImode)\n+\t    {\n+\t      emit_insn (gen_rtx_SET (target, vr3[0]));\n+\t      return;\n+\t    }\n+\n+\t  /* Pack vectors with 8 values into 16 values.  */\n+\t  rtx res = gen_reg_rtx (V16QImode);\n+\t  emit_insn (gen_altivec_vpkuhum (res, vr3[0], vr3[1]));\n+\t  emit_insn (gen_rtx_SET (target, res));\n+\t}\n+      else\n+\t{\n+\t  rtx (*merge_v16qi) (rtx, rtx, rtx) = NULL;\n+\t  rtx (*merge_v8hi) (rtx, rtx, rtx) = NULL;\n+\t  rtx (*merge_v4si) (rtx, rtx, rtx) = NULL;\n+\t  rtx perm_idx;\n+\n+\t  /* Set up some common gen routines and values.  */\n+\t  if (BYTES_BIG_ENDIAN)\n+\t    {\n+\t      if (mode == V16QImode)\n+\t\t{\n+\t\t  merge_v16qi = gen_altivec_vmrghb;\n+\t\t  merge_v8hi = gen_altivec_vmrglh;\n+\t\t}\n+\t      else\n+\t\tmerge_v8hi = gen_altivec_vmrghh;\n+\n+\t      merge_v4si = gen_altivec_vmrglw;\n+\t      perm_idx = GEN_INT (3);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (mode == V16QImode)\n+\t\t{\n+\t\t  merge_v16qi = gen_altivec_vmrglb;\n+\t\t  merge_v8hi = gen_altivec_vmrghh;\n+\t\t}\n+\t      else\n+\t\tmerge_v8hi = gen_altivec_vmrglh;\n+\n+\t      merge_v4si = gen_altivec_vmrghw;\n+\t      perm_idx = GEN_INT (0);\n+\t    }\n+\n+\t  /* Move to VSX register with direct move.\n+\t     eg: vr_qi[0] = { xxxxxxxA, xxxxxxxx };\n+\t\t vr_qi[1] = { xxxxxxxB, xxxxxxxx };\n+\t\t ...\n+\t\t vr_qi[15] = { xxxxxxxP, xxxxxxxx };  */\n+\t  rtx vr_qi[16];\n+\t  for (i = 0; i < n_elts; i++)\n+\t    {\n+\t      vr_qi[i] = gen_reg_rtx (V16QImode);\n+\t      if (TARGET_64BIT)\n+\t\temit_insn (gen_p8_mtvsrd_v16qidi2 (vr_qi[i], op[i]));\n+\t      else\n+\t\temit_insn (gen_p8_mtvsrwz_v16qisi2 (vr_qi[i], op[i]));\n+\t    }\n+\n+\t  /* Merge/move to vector short.\n+\t     eg: vr_hi[0] = { xxxxxxxx, xxxxxxAB };\n+\t\t vr_hi[1] = { xxxxxxxx, xxxxxxCD };\n+\t\t ...\n+\t\t vr_hi[7] = { xxxxxxxx, xxxxxxOP };  */\n+\t  rtx vr_hi[8];\n+\t  for (i = 0; i < 8; i++)\n+\t    {\n+\t      rtx tmp = vr_qi[i];\n+\t      if (mode == V16QImode)\n+\t\t{\n+\t\t  tmp = gen_reg_rtx (V16QImode);\n+\t\t  emit_insn (merge_v16qi (tmp, vr_qi[2 * i], vr_qi[2 * i + 1]));\n+\t\t}\n+\t      vr_hi[i] = gen_reg_rtx (V8HImode);\n+\t      emit_move_insn (vr_hi[i], gen_lowpart (V8HImode, tmp));\n+\t    }\n+\n+\t  /* Merge vector short to vector int.\n+\t     eg: vr_si[0] = { xxxxxxxx, xxxxABCD };\n+\t\t vr_si[1] = { xxxxxxxx, xxxxEFGH };\n+\t\t ...\n+\t\t vr_si[3] = { xxxxxxxx, xxxxMNOP };  */\n+\t  rtx vr_si[4];\n+\t  for (i = 0; i < 4; i++)\n+\t    {\n+\t      rtx tmp = gen_reg_rtx (V8HImode);\n+\t      emit_insn (merge_v8hi (tmp, vr_hi[2 * i], vr_hi[2 * i + 1]));\n+\t      vr_si[i] = gen_reg_rtx (V4SImode);\n+\t      emit_move_insn (vr_si[i], gen_lowpart (V4SImode, tmp));\n+\t    }\n+\n+\t  /* Merge vector int to vector long.\n+\t     eg: vr_di[0] = { xxxxxxxx, ABCDEFGH };\n+\t\t vr_di[1] = { xxxxxxxx, IJKLMNOP };  */\n+\t  rtx vr_di[2];\n+\t  for (i = 0; i < 2; i++)\n+\t    {\n+\t      rtx tmp = gen_reg_rtx (V4SImode);\n+\t      emit_insn (merge_v4si (tmp, vr_si[2 * i], vr_si[2 * i + 1]));\n+\t      vr_di[i] = gen_reg_rtx (V2DImode);\n+\t      emit_move_insn (vr_di[i], gen_lowpart (V2DImode, tmp));\n+\t    }\n+\n+\t  rtx res = gen_reg_rtx (V2DImode);\n+\t  emit_insn (gen_vsx_xxpermdi_v2di (res, vr_di[0], vr_di[1], perm_idx));\n+\t  emit_insn (gen_rtx_SET (target, gen_lowpart (mode, res)));\n+\t}\n+\n+      return;\n+    }\n+\n   /* Construct the vector in memory one field at a time\n      and load the whole vector.  */\n   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));"}, {"sha": "acbf1303ab2b5315ed41f6f8ba38633e99a4a888", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025f434a87336e38bf5140fba2005081876aa911/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025f434a87336e38bf5140fba2005081876aa911/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=025f434a87336e38bf5140fba2005081876aa911", "patch": "@@ -8713,6 +8713,22 @@\n   \"mtvsrwz %x0,%1\"\n   [(set_attr \"type\" \"mtvsr\")])\n \n+(define_insn \"p8_mtvsrwz_v16qisi2\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=wa\")\n+    (unspec:V16QI [(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\t  UNSPEC_P8V_MTVSRWZ))]\n+  \"!TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"mtvsrwz %x0,%1\"\n+  [(set_attr \"type\" \"mtvsr\")])\n+\n+(define_insn \"p8_mtvsrd_v16qidi2\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=wa\")\n+    (unspec:V16QI [(match_operand:DI 1 \"register_operand\" \"r\")]\n+\t\t  UNSPEC_P8V_MTVSRD))]\n+  \"TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n+  \"mtvsrd %x0,%1\"\n+  [(set_attr \"type\" \"mtvsr\")])\n+\n (define_insn_and_split \"reload_fpr_from_gpr<mode>\"\n   [(set (match_operand:FMOVE64X 0 \"register_operand\" \"=d\")\n \t(unspec:FMOVE64X [(match_operand:FMOVE64X 1 \"register_operand\" \"r\")]"}, {"sha": "3b63865b3b8c81bd5f384ab68dde8f2592f71efc", "filename": "gcc/testsuite/gcc.target/powerpc/pr96933-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-1.c?ref=025f434a87336e38bf5140fba2005081876aa911", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power9\" } */\n+\n+/* Test vector constructions with char/short type values whether use 128bit\n+   direct move instructions mtvsrdd on Power9 or later, rather than transfering\n+   with memory store/load with stb/sth and vector load.  */\n+\n+#include \"pr96933.h\"\n+\n+/* { dg-final { scan-assembler-times {\\mmtvsrdd\\M} 24 } } */\n+/* { dg-final { scan-assembler-times {\\mvpkudum\\M} 12 } } */\n+/* { dg-final { scan-assembler-not {\\mstb\\M} } } */\n+/* { dg-final { scan-assembler-not {\\msth\\M} } } */"}, {"sha": "cef8fbd4f3583b10267b9b49351c703faed5a22b", "filename": "gcc/testsuite/gcc.target/powerpc/pr96933-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-2.c?ref=025f434a87336e38bf5140fba2005081876aa911", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power8\" } */\n+\n+/* Test vector constructions with char/short type values whether use direct\n+   move instructions like mtvsrd/mtvsrwz on Power8, rather than transfering\n+   with memory store/load with stb/sth and vector load.  */\n+\n+#include \"pr96933.h\"\n+\n+/* { dg-final { scan-assembler-times {\\mmtvsrd\\M} 48 {target lp64 } } } */\n+/* { dg-final { scan-assembler-times {\\mmtvsrwz\\M} 48 {target {! lp64 } } } } */\n+/* { dg-final { scan-assembler-times {\\mxxpermdi\\M} 4 } } */\n+/* { dg-final { scan-assembler-not {\\mstb\\M} } } */\n+/* { dg-final { scan-assembler-not {\\msth\\M} } } */"}, {"sha": "3e5709ab0d45291dfeb5d0a2cfce726f76cc05dc", "filename": "gcc/testsuite/gcc.target/powerpc/pr96933-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-3.c?ref=025f434a87336e38bf5140fba2005081876aa911", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power8\" } */\n+\n+/* Test vector constructions with char/short run successfully on Power8.  */\n+\n+#include <stdlib.h>\n+#include \"pr96933.h\"\n+#include \"pr96933-run.h\"\n+"}, {"sha": "5a1c3d0c85772bb4b1e4a40003b6d0c6a1eb44f8", "filename": "gcc/testsuite/gcc.target/powerpc/pr96933-4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-4.c?ref=025f434a87336e38bf5140fba2005081876aa911", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target p9vector_hw } */\n+/* { dg-options \"-O2 -mdejagnu-cpu=power9\" } */\n+\n+/* Test vector constructions with char/short run successfully on Power9.  */\n+\n+#include <stdlib.h>\n+#include \"pr96933.h\"\n+#include \"pr96933-run.h\"\n+"}, {"sha": "7fa8dac639c0c94b2302b38a3a3128b106f367e1", "filename": "gcc/testsuite/gcc.target/powerpc/pr96933-run.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-run.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-run.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933-run.h?ref=025f434a87336e38bf5140fba2005081876aa911", "patch": "@@ -0,0 +1,56 @@\n+/* Test function for pr96933-{3,4}.c run result verification.  */\n+\n+int\n+main ()\n+{\n+  unsigned char uc[16];\n+  signed char sc[16];\n+\n+  for (int i = 0; i < 16; i++)\n+    {\n+      uc[i] = (unsigned char) (i * 2 + 1);\n+      sc[i] = (signed char) ((i % 2 == 0) ? (i + 1) : -i);\n+    }\n+\n+  vector unsigned char ucv\n+    = test_uchar (uc[0], uc[1], uc[2], uc[3], uc[4], uc[5], uc[6], uc[7], uc[8],\n+\t\t  uc[9], uc[10], uc[11], uc[12], uc[13], uc[14], uc[15]);\n+  vector signed char scv\n+    = test_schar (sc[0], sc[1], sc[2], sc[3], sc[4], sc[5], sc[6], sc[7], sc[8],\n+\t\t  sc[9], sc[10], sc[11], sc[12], sc[13], sc[14], sc[15]);\n+\n+  for (int i = 0; i < 16; i++)\n+    {\n+      unsigned char uexp = (unsigned char) (i * 2 + 1);\n+      signed char sexp = (signed char) ((i % 2 == 0) ? (i + 1) : -i);\n+      if (ucv[i] != uexp)\n+\tabort ();\n+      if (scv[i] != sexp)\n+\tabort ();\n+    }\n+\n+  unsigned short us[8];\n+  signed short ss[8];\n+  for (int i = 0; i < 8; i++)\n+    {\n+      us[i] = (unsigned short) (i * 2 + 1);\n+      ss[i] = (signed short) ((i % 2 == 0) ? (i + 1) : -i);\n+    }\n+\n+  vector unsigned short usv\n+    = test_ushort (us[0], us[1], us[2], us[3], us[4], us[5], us[6], us[7]);\n+  vector signed short ssv\n+    = test_sshort (ss[0], ss[1], ss[2], ss[3], ss[4], ss[5], ss[6], ss[7]);\n+\n+  for (int i = 0; i < 8; i++)\n+    {\n+      unsigned short uexp = (unsigned short) (i * 2 + 1);\n+      signed short sexp = (signed short) ((i % 2 == 0) ? (i + 1) : -i);\n+      if (usv[i] != uexp)\n+\tabort ();\n+      if (ssv[i] != sexp)\n+\tabort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "4bc2b941e615354fc3e271b0427a440310548e1c", "filename": "gcc/testsuite/gcc.target/powerpc/pr96933.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/025f434a87336e38bf5140fba2005081876aa911/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr96933.h?ref=025f434a87336e38bf5140fba2005081876aa911", "patch": "@@ -0,0 +1,50 @@\n+/* Source file for pr96933-*.c testing, this mainly contains 4\n+   functions as below:\n+\n+     - test_uchar  // vector unsigned char\n+     - test_schar  // vector signed char\n+     - test_ushort // vector unsigned short\n+     - test_sshort // vector signed short\n+*/\n+\n+__attribute__ ((noipa)) vector unsigned char\n+test_uchar (unsigned char c1, unsigned char c2, unsigned char c3,\n+\t    unsigned char c4, unsigned char c5, unsigned char c6,\n+\t    unsigned char c7, unsigned char c8, unsigned char c9,\n+\t    unsigned char c10, unsigned char c11, unsigned char c12,\n+\t    unsigned char c13, unsigned char c14, unsigned char c15,\n+\t    unsigned char c16)\n+{\n+  vector unsigned char v\n+    = {c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16};\n+  return v;\n+}\n+\n+__attribute__ ((noipa)) vector signed char\n+test_schar (signed char c1, signed char c2, signed char c3, signed char c4,\n+\t    signed char c5, signed char c6, signed char c7, signed char c8,\n+\t    signed char c9, signed char c10, signed char c11, signed char c12,\n+\t    signed char c13, signed char c14, signed char c15, signed char c16)\n+{\n+  vector signed char v\n+    = {c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15, c16};\n+  return v;\n+}\n+\n+__attribute__ ((noipa)) vector unsigned short\n+test_ushort (unsigned short c1, unsigned short c2, unsigned short c3,\n+\t     unsigned short c4, unsigned short c5, unsigned short c6,\n+\t     unsigned short c7, unsigned short c8)\n+{\n+  vector unsigned short v = {c1, c2, c3, c4, c5, c6, c7, c8};\n+  return v;\n+}\n+\n+__attribute__ ((noipa)) vector signed short\n+test_sshort (signed short c1, signed short c2, signed short c3,\n+\t     signed short c4, signed short c5, signed short c6,\n+\t     signed short c7, signed short c8)\n+{\n+  vector signed short v = {c1, c2, c3, c4, c5, c6, c7, c8};\n+  return v;\n+}"}]}