{"sha": "ec25526966761fb80b027fc17431911f91a95ee6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMyNTUyNjk2Njc2MWZiODBiMDI3ZmMxNzQzMTkxMWY5MWE5NWVlNg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-03-02T01:49:15Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-03-02T01:49:15Z"}, "message": "84th Cygnus<->FSF merge\n\nFrom-SVN: r11399", "tree": {"sha": "94f63e4769a710a8a499da49367a802f8de421cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94f63e4769a710a8a499da49367a802f8de421cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec25526966761fb80b027fc17431911f91a95ee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec25526966761fb80b027fc17431911f91a95ee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec25526966761fb80b027fc17431911f91a95ee6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec25526966761fb80b027fc17431911f91a95ee6/comments", "author": null, "committer": null, "parents": [{"sha": "9725066d7d42464a95415862668c0b96f740cac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9725066d7d42464a95415862668c0b96f740cac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9725066d7d42464a95415862668c0b96f740cac7"}], "stats": {"total": 228, "additions": 192, "deletions": 36}, "files": [{"sha": "471bd9b2a1c2868b5affd71f113bb4a543ffa218", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ec25526966761fb80b027fc17431911f91a95ee6", "patch": "@@ -1,5 +1,80 @@\n+Fri Mar  1 13:09:33 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_class_template): If we don't have a pattern\n+ \tyet, that's OK.\n+\t(coerce_template_parms): If we see a local class, bail.\n+\n+\t* decl.c (grok_reference_init): Make sure there's a type before\n+ \tchecking its code.\n+\n+\t* pt.c (do_function_instantiation): Avoid crashing on invalid decls.\n+\t(push_template_decl): Ditto.\n+\n+\t* parse.y (named_class_head): Set\n+ \tCLASSTYPE_TEMPLATE_SPECIALIZATION here if we have basetypes.\n+\n+\t* decl.c (xref_tag): Diagnose redeclaration of template\n+ \ttype-parameter name.\n+\n+\t* error.c (dump_type): Handle anonymous template type parms.\n+\n+\t* pt.c (instantiate_template): Use TYPE_MAIN_DECL instead of\n+ \tTYPE_STUB_DECL.\n+\t(coerce_template_parms): Ditto.\n+\n+Thu Feb 29 16:26:01 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* class.c (instantiate_type, case {ARRAY,INDIRECT}_REF,\n+\tcase ADDR_EXPR): Don't modify rhs if a subinstantiation fails.\n+\n+Thu Feb 29 08:20:25 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_template): Take the MAIN_VARIANT of the type\n+ \tbefore trying to get its STUB_DECL.\n+\t(coerce_template_parms): Ditto.\n+\n+\t* parse.y (template_type_parm): If they didn't use 'class',\n+ \tpretend they did after giving an error.\n+\n+\t* pt.c (coerce_template_parms): Diagnose use of local class.\n+\n+\t* decl.c (grok_reference_init): Use instantiate_type.\n+\n+\t* error.c (dump_expr): Handle TEMPLATE_DECLs.\n+\n+\t* parse.y (named_class_head): Diagnose mismatching types and tags.\n+\n+\t* decl.c (pushdecl): Type decls and class templates clash with\n+ \tartificial type decls, not hide them.\n+\n+\t* decl.c (redeclaration_error_message): Diagnose redefinition of\n+ \ttemplates properly.\n+\t(duplicate_decls): Diagnose disallowed overloads for template\n+\tfunctions, too.\n+\n+\t* decl.c (start_decl): Call complete_type before checking for a\n+ \tdestructor.\n+\n+\t* pt.c (tsubst): Use tsubst_expr on the elts of a VEC.\n+\n+\t* decl.c (xref_tag): A TEMPLATE_TYPE_PARM is a match.\n+\n Wed Feb 28 09:28:44 1996  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* decl.c (grok_op_properties): Don't check for operator++(int) in\n+ \ta template.\n+\n+\t* tree.c (perm_manip): Return a copy of variable and function\n+ \tdecls with external linkage.\n+\n+\t* tree.def: Change some of the min tree codes to type \"1\".\n+\t* pt.c (uses_template_parms): Handle 'e's, return 1 for LOOKUP_EXPRs.\n+\t* method.c (build_overload_int): Emit something arbitrary for\n+ \tanything but an INTEGER_CST if we're in a template.\n+\n+\t* decl.c (cp_finish_decl): Call complete_type before deciding\n+ \twhether or not to lay out the decl.\n+\n \t* lex.c (do_identifier): Check for DECL_INITIAL before using it.\n \n Tue Feb 27 16:35:32 1996  Jason Merrill  <jason@yorick.cygnus.com>"}, {"sha": "e5ce5baa224ef70c034b6c76f2411143a937a237", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ec25526966761fb80b027fc17431911f91a95ee6", "patch": "@@ -4842,9 +4842,12 @@ root_lang_context_p ()\n \f\n /* Type instantiation routines.  */\n \n-/* This function will instantiate the type of the expression given\n-   in RHS to match the type of LHSTYPE.  If LHSTYPE is NULL_TREE,\n-   or other errors exist, the TREE_TYPE of RHS will be ERROR_MARK_NODE.\n+/* This function will instantiate the type of the expression given in\n+   RHS to match the type of LHSTYPE.  If errors exist, then return\n+   error_mark_node.  If only complain is COMPLAIN is set.  If we are\n+   not complaining, never modify rhs, as overload resolution wants to\n+   try many possible instantiations, in hopes that at least one will\n+   work.\n \n    This function is used in build_modify_expr, convert_arguments,\n    build_c_cast, and compute_conversion_costs.  */\n@@ -4880,14 +4883,18 @@ instantiate_type (lhstype, rhs, complain)\n \n     case INDIRECT_REF:\n     case ARRAY_REF:\n-      TREE_TYPE (rhs) = lhstype;\n-      lhstype = build_pointer_type (lhstype);\n-      TREE_OPERAND (rhs, 0)\n-\t= instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n-      if (TREE_OPERAND (rhs, 0) == error_mark_node)\n-\treturn error_mark_node;\n+      {\n+\ttree new_rhs;\n \n-      return rhs;\n+\tnew_rhs = instantiate_type (build_pointer_type (lhstype),\n+\t\t\t\t    TREE_OPERAND (rhs, 0), complain);\n+\tif (new_rhs == error_mark_node)\n+\t  return error_mark_node;\n+\n+\tTREE_TYPE (rhs) = lhstype;\n+\tTREE_OPERAND (rhs, 0) = new_rhs;\n+\treturn rhs;\n+      }\n \n     case NOP_EXPR:\n       rhs = copy_node (TREE_OPERAND (rhs, 0));\n@@ -5262,13 +5269,12 @@ instantiate_type (lhstype, rhs, complain)\n \t    error (\"type for resolving address of overloaded function must be pointer type\");\n \t  return error_mark_node;\n \t}\n-      TREE_TYPE (rhs) = lhstype;\n-      lhstype = TREE_TYPE (lhstype);\n       {\n-\ttree fn = instantiate_type (lhstype, TREE_OPERAND (rhs, 0), complain);\n+\ttree fn = instantiate_type (TREE_TYPE (lhstype), TREE_OPERAND (rhs, 0), complain);\n \tif (fn == error_mark_node)\n \t  return error_mark_node;\n \tmark_addressable (fn);\n+\tTREE_TYPE (rhs) = lhstype;\n \tTREE_OPERAND (rhs, 0) = fn;\n \tTREE_CONSTANT (rhs) = staticp (fn);\n       }"}, {"sha": "d965783188a8dfd6a745143cb04fcd122f9e3d54", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=ec25526966761fb80b027fc17431911f91a95ee6", "patch": "@@ -116,9 +116,9 @@ DEFTREECODE (USING_DECL, \"using_decl\", \"d\", 0)\n \n DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", \"e\", 2)\n DEFTREECODE (MODOP_EXPR, \"modop_expr\", \"e\", 3)\n-DEFTREECODE (CAST_EXPR, \"cast_expr\", \"e\", 1)\n-DEFTREECODE (REINTERPRET_CAST_EXPR, \"reinterpret_cast_expr\", \"e\", 1)\n-DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", \"e\", 1)\n+DEFTREECODE (CAST_EXPR, \"cast_expr\", \"1\", 1)\n+DEFTREECODE (REINTERPRET_CAST_EXPR, \"reinterpret_cast_expr\", \"1\", 1)\n+DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", \"1\", 1)\n DEFTREECODE (ARROW_EXPR, \"arrow_expr\", \"e\", 1)\n DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", \"e\", 2)\n "}, {"sha": "8d1d8cda336b76bec16c1f997232e7e2ef5d3a28", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ec25526966761fb80b027fc17431911f91a95ee6", "patch": "@@ -2501,6 +2501,14 @@ duplicate_decls (newdecl, olddecl)\n \t      cp_error_at (\"conflicts with previous declaration `%#D'\",\n \t\t\t   olddecl);\n \t    }\n+\t  else if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == FUNCTION_DECL\n+\t\t   && TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL\n+\t\t   && compparms (TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl))),\n+\t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))), 3))\n+\t    {\n+\t      cp_error (\"new declaration `%#D'\", newdecl);\n+\t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n+\t    }\n \t  return 0;\n \t}\n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n@@ -3044,8 +3052,15 @@ pushdecl (x)\n \t    }\n \t  else if (TREE_CODE (t) != TREE_CODE (x))\n \t    {\n-\t      if ((TREE_CODE (t) == TYPE_DECL && DECL_ARTIFICIAL (t))\n-\t\t  || (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)))\n+\t      if ((TREE_CODE (t) == TYPE_DECL && DECL_ARTIFICIAL (t)\n+\t\t   && TREE_CODE (x) != TYPE_DECL\n+\t\t   && ! (TREE_CODE (x) == TEMPLATE_DECL\n+\t\t\t && TREE_CODE (DECL_TEMPLATE_RESULT (x)) == TYPE_DECL))\n+\t\t  || (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n+\t\t      && TREE_CODE (t) != TYPE_DECL\n+\t\t      && ! (TREE_CODE (t) == TEMPLATE_DECL\n+\t\t\t    && (TREE_CODE (DECL_TEMPLATE_RESULT (t))\n+\t\t\t\t== TYPE_DECL))))\n \t\t{\n \t\t  /* We do nothing special here, because C++ does such nasty\n \t\t     things with TYPE_DECLs.  Instead, just let the TYPE_DECL\n@@ -3714,7 +3729,12 @@ redeclaration_error_message (newdecl, olddecl)\n     }\n   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n     {\n-      if (DECL_INITIAL (olddecl) && DECL_INITIAL (newdecl))\n+      if ((TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL\n+\t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (newdecl))\n+\t   && DECL_INITIAL (DECL_TEMPLATE_RESULT (olddecl)))\n+\t  || (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL\n+\t      && TYPE_SIZE (TREE_TYPE (newdecl))\n+\t      && TYPE_SIZE (TREE_TYPE (olddecl))))\n \treturn \"redefinition of `%#D'\";\n       return 0;\n     }\n@@ -5737,7 +5757,7 @@ start_decl (declarator, declspecs, initialized, raises)\n \n   /* Don't lose if destructors must be executed at file-level.  */\n   if (! current_template_parms && TREE_STATIC (decl)\n-      && TYPE_NEEDS_DESTRUCTOR (type)\n+      && TYPE_NEEDS_DESTRUCTOR (complete_type (type))\n       && !TREE_PERMANENT (decl))\n     {\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n@@ -6029,6 +6049,10 @@ grok_reference_init (decl, type, init, cleanupp)\n       return;\n     }\n \n+  if (TREE_TYPE (init) && TREE_CODE (TREE_TYPE (init)) == UNKNOWN_TYPE)\n+    /* decay_conversion is probably wrong for references to functions.  */\n+    init = decay_conversion (instantiate_type (TREE_TYPE (type), init, 1));\n+\n   if (TREE_CODE (init) == TREE_LIST)\n     init = build_compound_expr (init);\n \n@@ -6417,7 +6441,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n       if (DECL_SIZE (decl) == NULL_TREE\n-\t  && TYPE_SIZE (TREE_TYPE (decl)) != NULL_TREE)\n+\t  && TYPE_SIZE (complete_type (TREE_TYPE (decl))) != NULL_TREE)\n \tlayout_decl (decl, 0);\n \n       if (TREE_STATIC (decl) && DECL_SIZE (decl) == NULL_TREE)\n@@ -10152,6 +10176,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t    {\n \t      if ((name == ansi_opname[(int) POSTINCREMENT_EXPR]\n \t\t   || name == ansi_opname[(int) POSTDECREMENT_EXPR])\n+\t\t  && ! current_template_parms\n \t\t  && TREE_VALUE (TREE_CHAIN (argtypes)) != integer_type_node)\n \t\t{\n \t\t  if (methodp)\n@@ -10259,11 +10284,16 @@ xref_tag (code_type_node, name, binfo, globalize)\n     }\n   else\n     t = IDENTIFIER_TYPE_VALUE (name);\n-  if (t && TREE_CODE (t) != code)\n+  if (t && TREE_CODE (t) != code && TREE_CODE (t) != TEMPLATE_TYPE_PARM)\n     t = NULL_TREE;\n \n   if (! globalize)\n     {\n+      if (pedantic && t && TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n+\t{\n+\t  cp_pedwarn (\"redeclaration of template type-parameter `%T'\", name);\n+\t  cp_pedwarn_at (\"  previously declared here\", t);\n+\t}\n       /* If we know we are defining this tag, only look it up in this scope\n        * and don't try to find it as a type. */\n       if (t && TYPE_CONTEXT(t) && TREE_MANGLED (name))"}, {"sha": "99f72fba9dfa6b4bd9505b2160f6e68f861d6388", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=ec25526966761fb80b027fc17431911f91a95ee6", "patch": "@@ -209,7 +209,10 @@ dump_type (t, v)\n       break;\n \n     case TEMPLATE_TYPE_PARM:\n-      OB_PUTID (TYPE_IDENTIFIER (t));\n+      if (TYPE_IDENTIFIER (t))\n+\tOB_PUTID (TYPE_IDENTIFIER (t));\n+      else\n+\tOB_PUTS (\"{anonymous template type parm}\");\n       break;\n \n       /* This is not always necessary for pointers and such, but doing this\n@@ -941,6 +944,7 @@ dump_expr (t, nop)\n     case FIELD_DECL:\n     case CONST_DECL:\n     case FUNCTION_DECL:\n+    case TEMPLATE_DECL:\n       dump_decl (t, -1);\n       break;\n "}, {"sha": "6b45ff4008e62a8720651700fc6d9377cb8e1da3", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=ec25526966761fb80b027fc17431911f91a95ee6", "patch": "@@ -364,7 +364,8 @@ build_overload_int (value)\n \tOB_PUTC ('_');\n       return;\n     }\n-  else if (uses_template_parms (value))\n+  else if (current_template_parms\n+\t   && TREE_CODE (value) != INTEGER_CST)\n     /* We don't ever want this output, but it's inconvenient not to\n        be able to build the string.  This should cause assembler\n        errors we'll notice.  */"}, {"sha": "c53bef3b6be69cd8daeebaeef908f7f5846e5a6e", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=ec25526966761fb80b027fc17431911f91a95ee6", "patch": "@@ -427,7 +427,10 @@ template_type_parm:\n \t\t  if (TREE_PURPOSE ($$) == signature_type_node)\n \t\t    sorry (\"signature as template type parameter\");\n \t\t  else if (TREE_PURPOSE ($$) != class_type_node)\n-\t\t    pedwarn (\"template type parameters must use the keyword `class'\");\n+\t\t    {\n+\t\t      pedwarn (\"template type parameters must use the keyword `class'\");\n+\t\t      TREE_PURPOSE ($$) = class_type_node;\n+\t\t    }\n \t\t}\n \t| aggr identifier\n \t\t{ $$ = build_tree_list ($1, $2); goto ttpa; }\n@@ -2129,8 +2132,24 @@ named_class_head:\n \t| named_complex_class_head_sans_basetype maybe_base_class_list\n \t\t{ \n \t\t  $$ = TREE_TYPE ($1);\n+\t\t  if (TREE_INT_CST_LOW (current_aggr) == union_type \n+\t\t      && TREE_CODE ($$) != UNION_TYPE)\n+\t\t    cp_pedwarn (\"`union' tag used in declaring `%#T'\", $$);\n+\t\t  else if (TREE_CODE ($$) == UNION_TYPE\n+\t\t\t   && TREE_INT_CST_LOW (current_aggr) != union_type)\n+\t\t    cp_pedwarn (\"non-`union' tag used in declaring `%#T'\", $$);\n \t\t  if ($2)\n-\t\t    xref_basetypes (current_aggr, $1, $$, $2); \n+\t\t    {\n+\t\t      if (IS_AGGR_TYPE ($$) && CLASSTYPE_USE_TEMPLATE ($$))\n+\t\t        {\n+\t\t          if (CLASSTYPE_IMPLICIT_INSTANTIATION ($$)\n+\t\t\t      && TYPE_SIZE ($$) == NULL_TREE)\n+\t\t\t    SET_CLASSTYPE_TEMPLATE_SPECIALIZATION ($$);\n+\t\t\t  else if (CLASSTYPE_TEMPLATE_INSTANTIATION ($$))\n+\t\t\t    cp_error (\"specialization after instantiation of `%T'\", $$);\n+\t\t\t}\n+\t\t      xref_basetypes (current_aggr, $1, $$, $2); \n+\t\t    }\n \t\t}\n \t;\n "}, {"sha": "02e2822144e428ed5e447ca186766ab101498e00", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ec25526966761fb80b027fc17431911f91a95ee6", "patch": "@@ -253,6 +253,8 @@ push_template_decl (decl)\n       CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (tmpl)) = info;\n       DECL_NAME (decl) = classtype_mangled_name (TREE_TYPE (decl));\n     }\n+  else if (! DECL_LANG_SPECIFIC (decl))\n+    cp_error (\"template declaration of `%#D'\", decl);\n   else\n     DECL_TEMPLATE_INFO (decl) = info;\n }\n@@ -352,12 +354,24 @@ coerce_template_parms (parms, arglist, in_decl)\n \t  continue;\n \t}\n       if (is_type)\n-\tval = groktypename (arg);\n+\t{\n+\t  val = groktypename (arg);\n+\t  if (! current_template_parms)\n+\t    {\n+\t      tree t = target_type (val);\n+\t      if (IS_AGGR_TYPE (t)\n+\t\t  && decl_function_context (TYPE_MAIN_DECL (t)))\n+\t\t{\n+\t\t  cp_error (\"type `%T' composed from a local class is not a valid template-argument\", val);\n+\t\t  return error_mark_node;\n+\t\t}\n+\t    }\n+\t}\n       else\n \t{\n \t  tree t = tsubst (TREE_TYPE (parm), &TREE_VEC_ELT (vec, 0),\n \t\t\t   TREE_VEC_LENGTH (vec), in_decl);\n-\t  if (current_template_parms && uses_template_parms (arg))\n+\t  if (current_template_parms)\n \t    val = arg;\n \t  else\n \t    val = digest_init (t, arg, (tree *) 0);\n@@ -844,6 +858,7 @@ uses_template_parms (t)\n       /* NOTREACHED */\n       return 0;\n \n+    case LOOKUP_EXPR:\n     case TYPENAME_TYPE:\n       return 1;\n \n@@ -857,7 +872,7 @@ uses_template_parms (t)\n \t{\n \tcase '1':\n \tcase '2':\n-\tcase '3':\n+\tcase 'e':\n \tcase '<':\n \t  {\n \t    int i;\n@@ -980,11 +995,7 @@ instantiate_class_template (type)\n   pattern = TREE_TYPE (template);\n \n   if (TYPE_SIZE (pattern) == NULL_TREE)\n-    {\n-      cp_error_at (\"no definition available for `%#D'\", template);\n-      cp_error (\"  trying to instantiate `%#T'\", type);\n-      return error_mark_node;\n-    }\n+    return type;\n \n   TYPE_BEING_DEFINED (type) = 1;\n \n@@ -1608,7 +1619,7 @@ tsubst (t, args, nargs, in_decl)\n \n \tfor (i = 0; i < len; i++)\n \t  {\n-\t    elts[i] = tsubst_copy (TREE_VEC_ELT (t, i), args, nargs, in_decl);\n+\t    elts[i] = tsubst_expr (TREE_VEC_ELT (t, i), args, nargs, in_decl);\n \t    if (elts[i] != TREE_VEC_ELT (t, i))\n \t      need_new = 1;\n \t  }\n@@ -2287,7 +2298,7 @@ instantiate_template (tmpl, targ_ptr)\n       if (TREE_CODE_CLASS (TREE_CODE (t)) == 't')\n \t{\n \t  tree nt = target_type (t);\n-\t  if (IS_AGGR_TYPE (nt) && decl_function_context (TYPE_STUB_DECL (nt)))\n+\t  if (IS_AGGR_TYPE (nt) && decl_function_context (TYPE_MAIN_DECL (nt)))\n \t    {\n \t      cp_error (\"type `%T' composed from a local class is not a valid template-argument\", t);\n \t      cp_error (\"  trying to instantiate `%D'\", tmpl);\n@@ -2696,6 +2707,12 @@ do_function_instantiation (declspecs, declarator, storage)\n   tree result = NULL_TREE;\n   int extern_p = 0;\n \n+  if (! DECL_LANG_SPECIFIC (decl))\n+    {\n+      cp_error (\"explicit instantiation of non-template `%#D'\", decl);\n+      return;\n+    }\n+\n   /* If we've already seen this template instance, use it.  */\n   if (name = DECL_ASSEMBLER_NAME (decl),\n       fn = IDENTIFIER_GLOBAL_VALUE (name),"}, {"sha": "8fbd59bcc9c3c403b22f0b47703d3da23025b495", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec25526966761fb80b027fc17431911f91a95ee6/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=ec25526966761fb80b027fc17431911f91a95ee6", "patch": "@@ -1625,6 +1625,10 @@ perm_manip (t)\n {\n   if (TREE_PERMANENT (t))\n     return t;\n+  /* Support `void f () { extern int i; A<&i> a; }' */\n+  if ((TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == FUNCTION_DECL)\n+      && TREE_PUBLIC (t))\n+    return copy_node (t);\n   return NULL_TREE;\n }\n "}]}