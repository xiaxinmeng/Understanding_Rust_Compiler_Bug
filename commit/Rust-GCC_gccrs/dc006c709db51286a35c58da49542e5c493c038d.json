{"sha": "dc006c709db51286a35c58da49542e5c493c038d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwMDZjNzA5ZGI1MTI4NmEzNWM1OGRhNDk1NDJlNWM0OTNjMDM4ZA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2006-01-04T16:34:52Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-01-04T16:34:52Z"}, "message": "lambda-code.c (can_put_in_inner_loop): Relax restrictions.\n\n2006-01-04  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* lambda-code.c (can_put_in_inner_loop): Relax\n\trestrictions.\n\t(can_put_after_inner_loop): New function.\n\t(can_convert_to_perfect_nest): Use can_put_after_inner_loop as well.\n\t(perfect_nestify): Change to make copies and modify uses.\n\nFrom-SVN: r109337", "tree": {"sha": "ebc033b9b67710f150a7a565c73db6c4da44a365", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebc033b9b67710f150a7a565c73db6c4da44a365"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc006c709db51286a35c58da49542e5c493c038d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc006c709db51286a35c58da49542e5c493c038d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc006c709db51286a35c58da49542e5c493c038d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc006c709db51286a35c58da49542e5c493c038d/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc4071dd66fd4d093dc3fe3592ea879c2996868b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4071dd66fd4d093dc3fe3592ea879c2996868b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4071dd66fd4d093dc3fe3592ea879c2996868b"}], "stats": {"total": 95, "additions": 67, "deletions": 28}, "files": [{"sha": "18e615175bbc55683f4783e48d83290a3d396430", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc006c709db51286a35c58da49542e5c493c038d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc006c709db51286a35c58da49542e5c493c038d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc006c709db51286a35c58da49542e5c493c038d", "patch": "@@ -1,3 +1,11 @@\n+2006-01-04  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* lambda-code.c (can_put_in_inner_loop): Relax\n+\trestrictions.\n+\t(can_put_after_inner_loop): New function.\n+\t(can_convert_to_perfect_nest): Use can_put_after_inner_loop as well.\n+\t(perfect_nestify): Change to make copies and modify uses.\n+\n 2006-01-04  Richard Henderson  <rth@redhat.com>\n \n \tMerge from gomp branch:"}, {"sha": "c19ea6cfa549369d9a22454c64a75651a7999cbd", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 59, "deletions": 28, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc006c709db51286a35c58da49542e5c493c038d/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc006c709db51286a35c58da49542e5c493c038d/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=dc006c709db51286a35c58da49542e5c493c038d", "patch": "@@ -2201,23 +2201,20 @@ exit_phi_for_loop_p (struct loop *loop, tree stmt)\n   return true;\n }\n \n-/* Return true if STMT can be put back into INNER, a loop by moving it to the \n-   beginning of that loop.  */\n+/* Return true if STMT can be put back into the loop INNER, by\n+   copying it to the beginning of that loop and changing the uses.  */\n \n static bool\n can_put_in_inner_loop (struct loop *inner, tree stmt)\n {\n   imm_use_iterator imm_iter;\n   use_operand_p use_p;\n-  basic_block use_bb = NULL;\n   \n   gcc_assert (TREE_CODE (stmt) == MODIFY_EXPR);\n   if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS)\n       || !expr_invariant_in_loop_p (inner, TREE_OPERAND (stmt, 1)))\n     return false;\n   \n-  /* We require that the basic block of all uses be the same, or the use be an\n-     exit phi.  */\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, TREE_OPERAND (stmt, 0))\n     {\n       if (!exit_phi_for_loop_p (inner, USE_STMT (use_p)))\n@@ -2226,17 +2223,39 @@ can_put_in_inner_loop (struct loop *inner, tree stmt)\n \n \t  if (!flow_bb_inside_loop_p (inner, immbb))\n \t    return false;\n-\t  if (use_bb == NULL)\n-\t    use_bb = immbb;\n-\t  else if (immbb != use_bb)\n+\t}\n+    }\n+  return true;  \n+}\n+\n+/* Return true if STMT can be put *after* the inner loop of LOOP.  */\n+static bool\n+can_put_after_inner_loop (struct loop *loop, tree stmt)\n+{\n+  imm_use_iterator imm_iter;\n+  use_operand_p use_p;\n+\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+    return false;\n+  \n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, TREE_OPERAND (stmt, 0))\n+    {\n+      if (!exit_phi_for_loop_p (loop, USE_STMT (use_p)))\n+\t{\n+\t  basic_block immbb = bb_for_stmt (USE_STMT (use_p));\n+\t  \n+\t  if (!dominated_by_p (CDI_DOMINATORS,\n+\t\t\t       immbb,\n+\t\t\t       loop->inner->header)\n+\t      && !can_put_in_inner_loop (loop->inner, stmt))\n \t    return false;\n \t}\n     }\n   return true;\n-  \n }\n \n \n+\n /* Return TRUE if LOOP is an imperfect nest that we can convert to a perfect\n    one.  LOOPIVS is a vector of induction variables, one per loop.  \n    ATM, we only handle imperfect nests of depth 2, where all of the statements\n@@ -2277,18 +2296,20 @@ can_convert_to_perfect_nest (struct loop *loop,\n \t\tif (stmt_uses_op (stmt, iv))\n \t\t  goto fail;\n \t      \n-\t      /* If this is a simple operation like a cast that is invariant\n-\t\t in the inner loop, only used there, and we can place it\n-\t\t there, then it's not going to hurt us.\n-\t\t This means that we will propagate casts and other cheap\n-\t\t invariant operations *back*\n-\t\t into the inner loop if we can interchange the loop, on the\n-\t\t theory that we are going to gain a lot more by interchanging\n-\t\t the loop than we are by leaving some invariant code there for\n-\t\t some other pass to clean up.  */\n+\t      /* If this is a simple operation like a cast that is\n+\t\t invariant in the inner loop, or after the inner loop,\n+\t\t then see if we can place it back where it came from.\n+\t\t This means that we will propagate casts and other\n+\t\t cheap invariant operations *back* into or after\n+\t\t the inner loop if we can interchange the loop, on the\n+\t\t theory that we are going to gain a lot more by\n+\t\t interchanging the loop than we are by leaving some\n+\t\t invariant code there for some other pass to clean\n+\t\t up.  */\n \t      if (TREE_CODE (stmt) == MODIFY_EXPR\n \t\t  && is_gimple_cast (TREE_OPERAND (stmt, 1))\n-\t\t  && can_put_in_inner_loop (loop->inner, stmt))\n+\t\t  && (can_put_in_inner_loop (loop->inner, stmt)\n+\t\t      || can_put_after_inner_loop (loop, stmt)))\n \t\tcontinue;\n \n \t      /* Otherwise, if the bb of a statement we care about isn't\n@@ -2515,23 +2536,33 @@ perfect_nestify (struct loops *loops,\n \t\t\tbsi_prev (&bsi);\n \t\t      continue;\n \t\t    }\n-\t\t  /* Move this statement back into the inner loop.\n-\t\t     This looks a bit confusing, but we are really just\n-\t\t     finding the first non-exit phi use and moving the\n-\t\t     statement to the beginning of that use's basic\n-\t\t     block.  */\n+\t\t  \n+\t\t  /* Make copies of this statement to put it back next\n+\t\t     to its uses. */\n \t\t  FOR_EACH_IMM_USE_SAFE (use_p, imm_iter, \n \t\t\t\t\t TREE_OPERAND (stmt, 0))\n \t\t    {\n \t\t      tree imm_stmt = USE_STMT (use_p);\n \t\t      if (!exit_phi_for_loop_p (loop->inner, imm_stmt))\n \t\t\t{\n-\t\t\t  block_stmt_iterator tobsi = bsi_after_labels (bb_for_stmt (imm_stmt));\n-\t\t\t  bsi_move_after (&bsi, &tobsi);\n-\t\t\t  update_stmt (stmt);\n-\t\t\t  BREAK_FROM_SAFE_IMM_USE (imm_iter);\n+\t\t\t  block_stmt_iterator tobsi;\n+\t\t\t  tree newname;\n+\t\t\t  tree newstmt;\n+\t\t\t \n+\t\t\t  newstmt  = unshare_expr (stmt);\n+\t\t\t  tobsi = bsi_after_labels (bb_for_stmt (imm_stmt));\n+\t\t\t  newname = TREE_OPERAND (newstmt, 0);\n+\t\t\t  newname = SSA_NAME_VAR (newname);\n+\t\t\t  newname = make_ssa_name (newname, newstmt);\n+\t\t\t  TREE_OPERAND (newstmt, 0) = newname;\n+\t\t\t  SET_USE (use_p, TREE_OPERAND (newstmt, 0));\n+\t\t\t  bsi_insert_after (&tobsi, newstmt, BSI_SAME_STMT);\n+\t\t\t  update_stmt (newstmt);\n+\t\t\t  update_stmt (imm_stmt);\n \t\t\t} \n \t\t    }\n+\t\t  if (!bsi_end_p (bsi))\n+\t\t    bsi_prev (&bsi);\t\t\t  \n \t\t}\n \t    }\n \t  else"}]}