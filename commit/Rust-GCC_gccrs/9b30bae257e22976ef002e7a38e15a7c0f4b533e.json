{"sha": "9b30bae257e22976ef002e7a38e15a7c0f4b533e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIzMGJhZTI1N2UyMjk3NmVmMDAyZTdhMzhlMTVhN2MwZjRiNTMzZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-01T19:19:43Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-04-01T19:19:43Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r661", "tree": {"sha": "acb37316efdfd65a734d4835b39dc03954b25d94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acb37316efdfd65a734d4835b39dc03954b25d94"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b30bae257e22976ef002e7a38e15a7c0f4b533e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b30bae257e22976ef002e7a38e15a7c0f4b533e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b30bae257e22976ef002e7a38e15a7c0f4b533e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b30bae257e22976ef002e7a38e15a7c0f4b533e/comments", "author": null, "committer": null, "parents": [{"sha": "31c0c8ea75ce298775eb3ad8f4b52e61cd9e2ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31c0c8ea75ce298775eb3ad8f4b52e61cd9e2ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31c0c8ea75ce298775eb3ad8f4b52e61cd9e2ce5"}], "stats": {"total": 170, "additions": 168, "deletions": 2}, "files": [{"sha": "7a2aa5c7bc2b0ad9896261e9694cdd17828de425", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 168, "deletions": 2, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b30bae257e22976ef002e7a38e15a7c0f4b533e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b30bae257e22976ef002e7a38e15a7c0f4b533e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9b30bae257e22976ef002e7a38e15a7c0f4b533e", "patch": "@@ -33,6 +33,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"recog.h\"\n #include \"expr.h\"\n #include \"obstack.h\"\n+#include \"tree.h\"\n+\n+extern char *language_string;\n \n #define min(A,B)\t((A) < (B) ? (A) : (B))\n #define max(A,B)\t((A) > (B) ? (A) : (B))\n@@ -1328,8 +1331,171 @@ output_epilog (file, size)\n \tfprintf (file, \"\\tbr\\n\");\n     }\n \n-  /* ??? Need to output a traceback table here when -g was given for complete\n-     debugging output.  */\n+  /* Output a traceback table here.  See /usr/include/sys/debug.h for info\n+     on its format.  */\n+  {\n+    char *fname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+    int fixed_parms, float_parms, parm_info;\n+    int i;\n+\n+    /* Need label immediately before tbtab, so we can compute its offset\n+       from the function start.  */\n+    if (*fname == '*')\n+      ++fname;\n+    fprintf (file, \"L..tbtab_\");\n+    ASM_OUTPUT_LABEL (file, fname);\n+\n+    /* The .tbtab psuedo-op can only be used for the first eight\n+       expressions, since it can't handle the possibly variable length\n+       fields that follow.  However, if you omit the optional fields,\n+       the assembler outputs zeros for all optional fields anyways, giving each\n+       variable length field is minimum length (as defined in sys/debug.h).\n+       Thus we can not use the .tbtab psuedo-op at all.  */\n+\n+    /* An all-zero word flags the start of the tbtab, for debuggers that have\n+       to find it by searching forward from the entry point or from the\n+       current pc.  */\n+    fprintf (file, \"\\t.long 0\\n\");\n+\n+    /* Tbtab format type.  Use format type 0.  */\n+    fprintf (file, \"\\t.byte 0\\n\");\n+\n+    /* Language type.  Unfortunately, there doesn't seem to be any official way\n+       to get this info, so we use language_string.  C is 0.  C++ is 9.\n+       No number defined for Obj-C, but it doesn't have its own\n+       language_string, so we can't detect it anyways.  */\n+    if (! strcmp (language_string, \"GNU C\"))\n+      i = 0;\n+    else if (! strcmp (language_string, \"GNU C++\"))\n+      i = 9;\n+    else\n+      abort ();\n+    fprintf (file, \"\\t.byte %d\\n\", i);\n+\n+    /* 8 single bit fields: global linkage (not set for C extern linkage,\n+       apparently a PL/I convention?), out-of-line epilogue/prologue, offset\n+       from start of procedure stored in tbtab, internal function, function\n+       has controlled storage, function has no toc, function uses fp,\n+       function logs/aborts fp operations.  */\n+    /* Assume that fp operations are used if any fp reg must be saved.  */\n+    fprintf (file, \"\\t.byte %d\\n\", (1 << 5) | ((first_fp_reg != 64) << 1));\n+\n+    /* 6 bitfields: function is interrupt handler, name present in proc table,\n+       function calls alloca, on condition directives (controls stack walks,\n+       3 bits), saves condition reg, saves link reg.  */\n+    /* The `function calls alloca' bit seems to be set whenever reg 31 is\n+       set up as a frame pointer, even when there is no alloca call.  */\n+    fprintf (file, \"\\t.byte %d\\n\",\n+\t     ((1 << 6) | (frame_pointer_needed << 5)\n+\t      | (must_save_cr () << 1) | (regs_ever_live[65])));\n+\n+    /* 3 bitfields: saves backchain, spare bit, number of fpr saved\n+       (6 bits).  */\n+    fprintf (file, \"\\t.byte %d\\n\",\n+\t     (must_push << 7) | (64 - first_fp_reg_to_save ()));\n+\n+    /* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */\n+    fprintf (file, \"\\t.byte %d\\n\", (32 - first_reg_to_save ()));\n+\n+    {\n+      /* Compute the parameter info from the function decl argument list.  */\n+      tree decl;\n+      int next_parm_info_bit;\n+\n+      next_parm_info_bit = 31;\n+      parm_info = 0;\n+      fixed_parms = 0;\n+      float_parms = 0;\n+\n+      for (decl = DECL_ARGUMENTS (current_function_decl);\n+\t   decl; decl = TREE_CHAIN (decl))\n+\t{\n+\t  rtx parameter = DECL_INCOMING_RTL (decl);\n+\t  enum machine_mode mode = GET_MODE (parameter);\n+\n+\t  if (GET_CODE (parameter) == REG)\n+\t    {\n+\t      if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\t\t{\n+\t\t  int bits;\n+\n+\t\t  float_parms++;\n+\n+\t\t  if (mode == SFmode)\n+\t\t    bits = 0x2;\n+\t\t  else if (mode == DFmode)\n+\t\t    bits = 0x3;\n+\t\t  else\n+\t\t    abort ();\n+\n+\t\t  /* If only one bit will fit, don't or in this entry.  */\n+\t\t  if (next_parm_info_bit > 0)\n+\t\t    parm_info |= (bits << (next_parm_info_bit - 1));\n+\t\t  next_parm_info_bit -= 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  fixed_parms += ((GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1))\n+\t\t\t\t  / UNITS_PER_WORD);\n+\t\t  next_parm_info_bit -= 1;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    /* Number of fixed point parameters.  */\n+    /* This is actually the number of words of fixed point parameters; thus\n+       an 8 byte struct counts as 2; and thus the maximum value is 8.  */\n+    fprintf (file, \"\\t.byte %d\\n\", fixed_parms);\n+\n+    /* 2 bitfields: number of floating point parameters (7 bits), parameters\n+       all on stack.  */\n+    /* This is actually the number of fp registers that hold parameters;\n+       and thus the maximum value is 13.  */\n+    /* Set parameters on stack bit if parameters are not in their original\n+       registers, irregardless of whether they are on the stack?  Xlc\n+       seems to set the bit when not optimizing.  */\n+    fprintf (file, \"\\t.byte %d\\n\", ((float_parms << 1) | (! optimize)));\n+\n+    /* Optional fields follow.  Some are variable length.  */\n+\n+    /* Parameter types, left adjusted bit fields: 0 fixed, 10 single float,\n+       11 double float.  */\n+    /* There is an entry for each parameter in a register, in the order that\n+       they occur in the parameter list.  Any intervening arguments on the\n+       stack are ignored.  If the list overflows a long (max possible length\n+       34 bits) then completely leave off all elements that don't fit.  */\n+    /* Only emit this long if there was at least one parameter.  */\n+    if (fixed_parms || float_parms)\n+      fprintf (file, \"\\t.long %d\\n\", parm_info);\n+\n+    /* Offset from start of code to tb table.  */\n+    fprintf (file, \"\\t.long L..tbtab_\");\n+    RS6000_OUTPUT_BASENAME (file, fname);\n+    fprintf (file, \"-.\");\n+    RS6000_OUTPUT_BASENAME (file, fname);\n+    fprintf (file, \"\\n\");\n+\n+    /* Interrupt handler mask.  */\n+    /* Omit this long, since we never set the iterrupt handler bit above.  */\n+\n+    /* Number of CTL (controlled storage) anchors.  */\n+    /* Omit this long, since the has_ctl bit is never set above.  */\n+\n+    /* Displacement into stack of each CTL anchor.  */\n+    /* Omit this list of longs, because there are no CTL anchors.  */\n+\n+    /* Length of function name.  */\n+    fprintf (file, \"\\t.short %d\\n\", strlen (fname));\n+\n+    /* Function name.  */\n+    assemble_string (fname, strlen (fname));\n+\n+    /* Register for alloca automatic storage; this is always reg 31.\n+       Only emit this if the alloca bit was set above.  */\n+    if (frame_pointer_needed)\n+      fprintf (file, \"\\t.byte 31\\n\");\n+  }\n }\n \f\n /* Output a TOC entry.  We derive the entry name from what is"}]}