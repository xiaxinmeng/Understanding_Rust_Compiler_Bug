{"sha": "90c28d48360b5975f18c0d56abbbed0f4407c328", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBjMjhkNDgzNjBiNTk3NWYxOGMwZDU2YWJiYmVkMGY0NDA3YzMyOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-26T21:30:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2004-06-26T21:30:01Z"}, "message": "ada-tree.def (DECL_STMT): Deleted.\n\n2004-06-26  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n        * ada-tree.def (DECL_STMT): Deleted.\n        * ada-tree.h (IS_ADA_STMT): Now test against STMT_STMT.\n        (DECL_STMT_VAR): Deleted.\n        * decl.c: add_decl_stmt now add_decl_expr.\n        * gigi.h: Likewise.\n        * trans.c: Likewise.\n        (gnat_gimplify_type_sizes, gnat_gimplify_one_sizepos): Deleted.\n        (gnat_to_gnu, case N_Subprogram_Body): Set cfun->function_end_locus.\n        (add_stmt): Only handle padded type here.\n        (add_stmt_with_node): Allow gnat_node to not be present.\n        (gnat_gimplify_stmt, case USE_STMT): Set *STMT_P to null.\n        (gnat_gimplify_stmt, case DECL_STMT): Deleted.\n        (gnat_stabilize_reference_1): If COMPONENT_REF of fat pointer,\n        make a SAVE_EXPR for the entire fat pointer.\n        * utils.c (pushdecl): Walk a DECL_EXPR in global case.\n        (create_index_type): Make a DECL_EXPR.\n        (end_subprog_body): Don't call allocate_struct_function here but\n        do clear cfn.\n\nFrom-SVN: r83722", "tree": {"sha": "d4c12f27f6c4ae8c019dd1f2b4fb297731113d90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4c12f27f6c4ae8c019dd1f2b4fb297731113d90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90c28d48360b5975f18c0d56abbbed0f4407c328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90c28d48360b5975f18c0d56abbbed0f4407c328", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90c28d48360b5975f18c0d56abbbed0f4407c328", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90c28d48360b5975f18c0d56abbbed0f4407c328/comments", "author": null, "committer": null, "parents": [{"sha": "350fae6628af14c2e760694d39baec5f7858057c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350fae6628af14c2e760694d39baec5f7858057c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/350fae6628af14c2e760694d39baec5f7858057c"}], "stats": {"total": 143, "additions": 64, "deletions": 79}, "files": [{"sha": "fe68c633f2c78878e83f45192d89602f86dc1230", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=90c28d48360b5975f18c0d56abbbed0f4407c328", "patch": "@@ -49,9 +49,6 @@ DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", 'r', 1)\n /* Here are the tree codes for the statement types known to Ada.  These\n    must be at the end of this file to allow IS_ADA_STMT to work.  */\n \n-/* This defines the variable in DECL_STMT_VAR.  */\n-DEFTREECODE (DECL_STMT, \"decl_stmt\", 's', 1)\n-\n /* This is how record_code_position and insert_code_for work.  The former\n    makes this tree node, whose operand is a statement.  The latter inserts\n    the actual statements into this node.  Gimplification consists of"}, {"sha": "ca099b8462dd53cbad3c1a582c55ea6492e6f902", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=90c28d48360b5975f18c0d56abbbed0f4407c328", "patch": "@@ -262,9 +262,8 @@ struct lang_type GTY(()) {union lang_tree_node t; };\n    Start by defining which tree codes are used for statements.  */\n #define IS_STMT(NODE)\t\t(TREE_CODE_CLASS (TREE_CODE (NODE)) == 's')\n #define IS_ADA_STMT(NODE)\t(IS_STMT (NODE)\t\t\t\t\\\n-\t\t\t\t && TREE_CODE (NODE) >= DECL_STMT)\n+\t\t\t\t && TREE_CODE (NODE) >= STMT_STMT)\n \n-#define DECL_STMT_VAR(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, DECL_STMT, 0)\n #define STMT_STMT_STMT(NODE)\tTREE_OPERAND_CHECK_CODE (NODE, STMT_STMT, 0)\n #define LOOP_STMT_TOP_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 0)\n #define LOOP_STMT_BOT_COND(NODE) TREE_OPERAND_CHECK_CODE (NODE, LOOP_STMT, 1)"}, {"sha": "0fd4c2b22c502b1836305699339976e1887c8909", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=90c28d48360b5975f18c0d56abbbed0f4407c328", "patch": "@@ -959,7 +959,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t NULL_TREE, gnu_new_type, gnu_expr,\n \t\t\t\t 0, 0, 0, 0, 0);\n \t    annotate_decl_with_node (gnu_new_var, gnat_entity);\n-\t    add_decl_stmt (gnu_new_var, gnat_entity);\n+\t    add_decl_expr (gnu_new_var, gnat_entity);\n \n \t    if (gnu_expr != 0)\n \t      add_stmt_with_node\n@@ -1041,7 +1041,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (Present (Address_Clause (gnat_entity)) && used_by_ref)\n \t  DECL_POINTER_ALIAS_SET (gnu_decl) = 0;\n \n-\tadd_decl_stmt (gnu_decl, gnat_entity);\n+\tadd_decl_expr (gnu_decl, gnat_entity);\n \n \tif (definition && DECL_SIZE (gnu_decl) != 0\n \t    && get_block_jmpbuf_decl ()\n@@ -1071,7 +1071,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t gnu_expr, 0, Is_Public (gnat_entity), 0,\n \t\t\t\t static_p, 0);\n \n-\t    add_decl_stmt (gnu_corr_var, gnat_entity);\n+\t    add_decl_expr (gnu_corr_var, gnat_entity);\n \t    SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, gnu_corr_var);\n \t  }\n \n@@ -1154,7 +1154,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      = create_var_decl (get_entity_name (gnat_literal),\n \t\t\t\t 0, gnu_type, gnu_value, 1, 0, 0, 0, 0);\n \n-\t    add_decl_stmt (gnu_literal, gnat_literal);\n+\t    add_decl_expr (gnu_literal, gnat_literal);\n \t    save_gnu_tree (gnat_literal, gnu_literal, 0);\n \t    gnu_literal_list = tree_cons (DECL_NAME (gnu_literal),\n \t\t\t\t\t  gnu_value, gnu_literal_list);\n@@ -3627,7 +3627,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t gnu_address, 0, Is_Public (gnat_entity),\n \t\t\t\t extern_flag, 0, 0);\n \t    DECL_BY_REF_P (gnu_decl) = 1;\n-\t    add_decl_stmt (gnu_decl, gnat_entity);\n+\t    add_decl_expr (gnu_decl, gnat_entity);\n \t  }\n \n \telse if (kind == E_Subprogram_Type)\n@@ -3925,7 +3925,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       else\n \tTREE_TYPE (gnu_decl) = gnu_type;\n \n-      add_decl_stmt (gnu_decl, gnat_entity);\n+      add_decl_expr (gnu_decl, gnat_entity);\n     }\n \n   if (IN (kind, Type_Kind) && ! TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl)))\n@@ -4545,7 +4545,7 @@ elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n \t\t\t   NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr, 1,\n \t\t\t   Is_Public (gnat_entity), ! definition, 0, 0);\n       annotate_decl_with_node (gnu_decl, gnat_entity);\n-      add_decl_stmt (gnu_decl, gnat_entity);\n+      add_decl_expr (gnu_decl, gnat_entity);\n     }\n \n   /* We only need to use this variable if we are in global context since GCC\n@@ -4824,7 +4824,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t    = create_var_decl (concat_id_with_name (name, \"XVZ\"), NULL_TREE,\n \t\t\t       sizetype, TYPE_SIZE (record), 0, 0, 0, 0, 0);\n \n-\t  add_decl_stmt (gnu_xvz, gnat_entity);\n+\t  add_decl_expr (gnu_xvz, gnat_entity);\n \t}\n     }\n "}, {"sha": "6e64aa4b4a50cd06a6c887e560a6d8a1cd4cb219", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=90c28d48360b5975f18c0d56abbbed0f4407c328", "patch": "@@ -91,7 +91,7 @@ extern void set_block_for_group (tree);\n \n /* Add a declaration statement for GNU_DECL to the current BLOCK_STMT node.\n    Get SLOC from Entity_Id.  */\n-extern void add_decl_stmt (tree, Entity_Id);\n+extern void add_decl_expr (tree, Entity_Id);\n \n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */"}, {"sha": "a7c108515376a859d7f15a736642422d8649aa24", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 47, "deletions": 61, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=90c28d48360b5975f18c0d56abbbed0f4407c328", "patch": "@@ -133,8 +133,6 @@ static tree build_stmt_group (List_Id, bool);\n static void push_stack (tree *, tree, tree);\n static void pop_stack (tree *);\n static enum gimplify_status gnat_gimplify_stmt (tree *);\n-static tree gnat_gimplify_type_sizes (tree);\n-static void gnat_gimplify_one_sizepos (tree *, tree *);\n static void gnat_expand_body_1 (tree, bool);\n static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n@@ -729,7 +727,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t       NULL_TREE, TREE_TYPE (gnu_expr),\n \t\t\t\t       gnu_expr, 0, Is_Public (gnat_temp), 0,\n \t\t\t\t       0, 0);\n-\t\t  add_decl_stmt (gnu_expr, gnat_temp);\n+\t\t  add_decl_expr (gnu_expr, gnat_temp);\n \t\t}\n \t      else\n \t\tgnu_expr = maybe_variable (gnu_expr);\n@@ -2598,7 +2596,16 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tpop_stack (&gnu_return_label_stack);\n \tif (!type_annotate_only)\n-\t  add_decl_stmt (current_function_decl, gnat_node);\n+\t  add_decl_expr (current_function_decl, gnat_node);\n+\n+\t/* Initialize the information node for the function and set the\n+\t   end location.  */\n+\tallocate_struct_function (current_function_decl);\n+\tSloc_to_locus\n+\t  ((Present (End_Label (Handled_Statement_Sequence (gnat_node)))\n+\t    ? Sloc (End_Label (Handled_Statement_Sequence (gnat_node)))\n+\t    : Sloc (gnat_node)),\n+\t   &cfun->function_end_locus);\n \n \tend_subprog_body (gnu_result);\n \n@@ -3284,8 +3291,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t NULL_TREE, jmpbuf_type,\n \t\t\t\t NULL_TREE, 0, 0, 0, 0, 0);\n \n-\t    add_decl_stmt (gnu_jmpsave_decl, gnat_node);\n-\t    add_decl_stmt (gnu_jmpbuf_decl, gnat_node);\n+\t    add_decl_expr (gnu_jmpsave_decl, gnat_node);\n+\t    add_decl_expr (gnu_jmpbuf_decl, gnat_node);\n \t    set_block_jmpbuf_decl (gnu_jmpbuf_decl);\n \n \t    /* When we exit this block, restore the saved value.  */\n@@ -3334,7 +3341,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t build_pointer_type (except_type_node),\n \t\t\t\t\t build_call_0_expr (get_excptr_decl),\n \t\t\t\t\t 0, 0, 0, 0, 0));\n-\t    add_decl_stmt (TREE_VALUE (gnu_except_ptr_stack), gnat_node);\n+\t    add_decl_expr (TREE_VALUE (gnu_except_ptr_stack), gnat_node);\n \n \t    /* Generate code for each handler. The N_Exception_Handler case\n \t       below does the real work and returns a COND_EXPR for each\n@@ -3597,7 +3604,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t       ptr_type_node, gnu_current_exc_ptr,\n \t\t\t       0, 0, 0, 0, 0);\n \n-\t  add_decl_stmt (gnu_incoming_exc_ptr, gnat_node);\n+\t  add_decl_expr (gnu_incoming_exc_ptr, gnat_node);\n \t  add_stmt_with_node (build_call_1_expr (begin_handler_decl,\n \t\t\t\t\t\t gnu_incoming_exc_ptr),\n \t\t\t      gnat_node);\n@@ -4023,26 +4030,23 @@ add_stmt (tree gnu_stmt)\n {\n   append_to_statement_list (gnu_stmt, &current_stmt_group->stmt_list);\n \n-  /* If this is a DECL_STMT for a variable with DECL_INITIAL set,\n-     generate the assignment statement too.  */\n-  if (TREE_CODE (gnu_stmt) == DECL_STMT\n-      && TREE_CODE (DECL_STMT_VAR (gnu_stmt)) == VAR_DECL\n-      && DECL_INITIAL (DECL_STMT_VAR (gnu_stmt)))\n+  /* If this is a DECL_EXPR for a variable with DECL_INITIAL set\n+     and decl has a padded type, convert it to the unpadded type so the\n+     assignment is done properly.  In other case, the gimplification\n+     of the DECL_EXPR will deal with DECL_INITIAL.  */\n+  if (TREE_CODE (gnu_stmt) == DECL_EXPR\n+      && TREE_CODE (DECL_EXPR_DECL (gnu_stmt)) == VAR_DECL\n+      && DECL_INITIAL (DECL_EXPR_DECL (gnu_stmt))\n+      && TREE_CODE (TREE_TYPE (DECL_EXPR_DECL (gnu_stmt))) == RECORD_TYPE\n+      && TYPE_IS_PADDING_P (TREE_TYPE (DECL_EXPR_DECL (gnu_stmt))))\n     {\n-      tree gnu_decl = DECL_STMT_VAR (gnu_stmt);\n-      tree gnu_lhs = gnu_decl;\n-      tree gnu_assign_stmt;\n-\n-      /* If decl has a padded type, convert it to the unpadded type so the\n-\t assignment is done properly.  */\n-      if (TREE_CODE (TREE_TYPE (gnu_lhs)) == RECORD_TYPE\n-\t  && TYPE_IS_PADDING_P (TREE_TYPE (gnu_lhs)))\n-\tgnu_lhs\n-\t  = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_lhs))), gnu_lhs);\n-\n-      gnu_assign_stmt\n+      tree gnu_decl = DECL_EXPR_DECL (gnu_stmt);\n+      tree gnu_lhs\n+\t= convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_decl))), gnu_decl);\n+      tree gnu_assign_stmt\n \t= build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t   gnu_lhs, DECL_INITIAL (gnu_decl));\n+\n       DECL_INITIAL (gnu_decl) = 0;\n \n       annotate_with_locus (gnu_assign_stmt, DECL_SOURCE_LOCATION (gnu_decl));\n@@ -4055,15 +4059,16 @@ add_stmt (tree gnu_stmt)\n void\n add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node)\n {\n-  annotate_with_node (gnu_stmt, gnat_node);\n+  if (Present (gnat_node))\n+    annotate_with_node (gnu_stmt, gnat_node);\n   add_stmt (gnu_stmt);\n }\n \n /* Add a declaration statement for GNU_DECL to the current statement group.\n    Get SLOC from Entity_Id.  */\n \n void\n-add_decl_stmt (tree gnu_decl, Entity_Id gnat_entity)\n+add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n {\n   /* If this is a variable that Gigi is to ignore, we may have been given\n      an ERROR_MARK.  So test for it.  We also might have been given a\n@@ -4074,7 +4079,7 @@ add_decl_stmt (tree gnu_decl, Entity_Id gnat_entity)\n \t  && TREE_CODE (TREE_TYPE (gnu_decl)) == UNCONSTRAINED_ARRAY_TYPE))\n     return;\n \n-  add_stmt_with_node (build (DECL_STMT, void_type_node, gnu_decl),\n+  add_stmt_with_node (build (DECL_EXPR, void_type_node, gnu_decl),\n \t\t      gnat_entity);\n }\n \n@@ -4273,39 +4278,9 @@ gnat_gimplify_stmt (tree *stmt_p)\n       return GS_OK;\n \n     case USE_STMT:\n-      *stmt_p = alloc_stmt_list ();\n+      *stmt_p = NULL_TREE;\n       return GS_ALL_DONE;\n \n-    case DECL_STMT:\n-      {\n-\ttree var = DECL_STMT_VAR (stmt);\n-\n-\t*stmt_p = NULL_TREE;\n-\tif (TREE_CODE (var) == TYPE_DECL)\n-\t  gimplify_type_sizes (TREE_TYPE (var), stmt_p);\n-\telse if (TREE_CODE (var) == VAR_DECL)\n-\t  {\n-\t    gimplify_one_sizepos (&DECL_SIZE (var), stmt_p);\n-\t    gimplify_one_sizepos (&DECL_SIZE_UNIT (var), stmt_p);\n-\n-\t    if (!DECL_EXTERNAL (var) && !TREE_CONSTANT (DECL_SIZE_UNIT (var)))\n-\t      {\n-\t\tDECL_DEFER_OUTPUT (var) = 1;\n-\t\tappend_to_statement_list\n-\t\t  (build_function_call_expr\n-\t\t   (implicit_built_in_decls[BUILT_IN_STACK_ALLOC],\n-\t\t    tree_cons (NULL_TREE,\n-\t\t\t       build1 (ADDR_EXPR,\n-\t\t\t\t       build_pointer_type (TREE_TYPE (var)),\n-\t\t\t\t       var),\n-\t\t\t       tree_cons (NULL_TREE, DECL_SIZE_UNIT (var),\n-\t\t\t\t\t  NULL_TREE))),\n-\t\t   stmt_p);\n-\t      }\n-\t  }\n-\treturn GS_ALL_DONE;\n-      }\n-\n     case LOOP_STMT:\n       {\n \ttree gnu_start_label = create_artificial_label ();\n@@ -5493,9 +5468,20 @@ gnat_stabilize_reference_1 (tree e, int force)\n     case 's':\n     case 'e':\n     case 'r':\n-      if (TREE_SIDE_EFFECTS (e) || force)\n+      /* If this is a COMPONENT_REF of a fat pointer, save the entire\n+\t fat pointer.  This may be more efficient, but will also allow\n+\t us to more easily find the match for the PLACEHOLDER_EXPR.  */\n+      if (code == COMPONENT_REF\n+\t  && TYPE_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (e, 0))))\n+\tresult = build (COMPONENT_REF, type,\n+\t\t\tgnat_stabilize_reference_1 (TREE_OPERAND (e, 0),\n+\t\t\t\t\t\t    force),\n+\t\t\tTREE_OPERAND (e, 1), TREE_OPERAND (e, 2));\n+      else if (TREE_SIDE_EFFECTS (e) || force)\n \treturn save_expr (e);\n-      return e;\n+      else\n+\treturn e;\n+      break;\n \n     case 'c':\n       /* Constants need no processing.  In fact, we should never reach"}, {"sha": "53823e8f2f66b919de954ab8a34d5cff6a660e31", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90c28d48360b5975f18c0d56abbbed0f4407c328/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=90c28d48360b5975f18c0d56abbbed0f4407c328", "patch": "@@ -365,8 +365,12 @@ pushdecl (tree decl)\n      that are part of sizes and positions.  */\n   if (global_bindings_p () && TREE_CODE (decl) != PARM_DECL)\n     {\n+      /* Make a DECL_EXPR so we'll walk into the appropriate fields of\n+\t the type or decl.  */\n+      tree decl_expr = build1 (DECL_EXPR, void_type_node, decl);\n+\n       DECL_CONTEXT (decl) = 0;\n-      walk_tree (&decl, mark_visited, NULL, NULL);\n+      walk_tree (&decl_expr, mark_visited, NULL, NULL);\n     }\n   else\n     DECL_CONTEXT (decl) = current_function_decl;\n@@ -1271,6 +1275,7 @@ create_index_type (tree min, tree max, tree index)\n     type = copy_type (type);\n \n   SET_TYPE_INDEX_TYPE (type, index);\n+  add_decl_expr (create_type_decl (NULL_TREE, type, NULL, 1, 0), Empty);\n   return type;\n }\n \f\n@@ -1899,9 +1904,6 @@ end_subprog_body (tree body)\n   DECL_INLINE (fndecl)\n     = DECL_DECLARED_INLINE_P (fndecl) || flag_inline_trees == 2;\n \n-  /* Initialize the RTL code for the function.  */\n-  allocate_struct_function (fndecl);\n-\n   /* We handle pending sizes via the elaboration of types, so we don't\n      need to save them.  */\n   get_pending_sizes ();\n@@ -1912,6 +1914,7 @@ end_subprog_body (tree body)\n   DECL_SAVED_TREE (fndecl) = body;\n \n   current_function_decl = DECL_CONTEXT (fndecl);\n+  cfun = NULL;\n \n   /* If we're only annotating types, don't actually compile this function.  */\n   if (type_annotate_only)"}]}