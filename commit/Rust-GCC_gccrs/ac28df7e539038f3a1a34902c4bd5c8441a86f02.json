{"sha": "ac28df7e539038f3a1a34902c4bd5c8441a86f02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMyOGRmN2U1MzkwMzhmM2ExYTM0OTAyYzRiZDVjODQ0MWE4NmYwMg==", "commit": {"author": {"name": "Renlin Li", "email": "renlin.li@arm.com", "date": "2018-11-16T14:36:40Z"}, "committer": {"name": "Renlin Li", "email": "renlin@gcc.gnu.org", "date": "2018-11-16T14:36:40Z"}, "message": "[Patch][libstdc++.exp] Update the usage of cached result.\n\nThis patch replaces the usage of cached results with a global dictionary.\n\nAdditionally, check_v3_target_namedlocale is updated to check on every variant.\nOriginally, it is only checked once.\n\n\ngcc/libstdc++-v3/:\n2018-11-16  Renlin Li  <renlin.li@arm.com>\n\t    Tejas Belagod  <tejas.belagod@arm.com>\n\n\ttestsuite/lib/libstdc++.exp (check_v3_target_prop_cached): New proc.\n\t(check_v3_target): Use check_v3_target_prop_cached.\n\n\nCo-Authored-By: Tejas Belagod <tejas.belagod@arm.com>\n\nFrom-SVN: r266209", "tree": {"sha": "f9e0cef1307c92f1e5d0f3636c34d882d7dcf132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9e0cef1307c92f1e5d0f3636c34d882d7dcf132"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac28df7e539038f3a1a34902c4bd5c8441a86f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac28df7e539038f3a1a34902c4bd5c8441a86f02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac28df7e539038f3a1a34902c4bd5c8441a86f02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac28df7e539038f3a1a34902c4bd5c8441a86f02/comments", "author": null, "committer": null, "parents": [{"sha": "a0b48080020f344b3d594f31546c714564a061c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0b48080020f344b3d594f31546c714564a061c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0b48080020f344b3d594f31546c714564a061c7"}], "stats": {"total": 939, "additions": 225, "deletions": 714}, "files": [{"sha": "b2e58dff78edfa6973c53115ccb7faaf2f6c3ec2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac28df7e539038f3a1a34902c4bd5c8441a86f02/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac28df7e539038f3a1a34902c4bd5c8441a86f02/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ac28df7e539038f3a1a34902c4bd5c8441a86f02", "patch": "@@ -1,3 +1,9 @@\n+2018-11-16  Renlin Li  <renlin.li@arm.com>\n+\t    Tejas Belagod  <tejas.belagod@arm.com>\n+\n+\ttestsuite/lib/libstdc++.exp (check_v3_target_prop_cached): New proc.\n+\t(check_v3_target): Use the check_v3_target_prop_cached.\n+\n 2018-11-15  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* scripts/check_performance: Allow tests to choose a -std flag."}, {"sha": "7047b8f7b2233911445abaed54337bc46b37b7e5", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 219, "deletions": 714, "changes": 933, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac28df7e539038f3a1a34902c4bd5c8441a86f02/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac28df7e539038f3a1a34902c4bd5c8441a86f02/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=ac28df7e539038f3a1a34902c4bd5c8441a86f02", "patch": "@@ -688,31 +688,38 @@ proc v3-build_support { } {\n     }\n }\n \n-proc check_v3_target_fileio { } {\n-    global et_fileio_saved\n-    global et_fileio_target_name\n-    global tool\n-    global srcdir\n+# Implement an target check for property PROP by invoking\n+# the Tcl command ARGS and seeing if it returns true.\n \n-    if { ![info exists et_fileio_target_name] } {\n-\tset et_fileio_target_name \"\"\n-    }\n+proc check_v3_target_prop_cached { prop args } {\n+    global et_cache\n \n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_fileio_target_name } {\n-\tverbose \"check_v3_target_fileio: `$et_fileio_target_name'\" 2\n-\tset et_fileio_target_name $current_target\n-\tif [info exists et_fileio_saved] {\n-\t    verbose \"check_v3_target_fileio: removing cached result\" 2\n-\t    unset et_fileio_saved\n+    set target [current_target_name]\n+    if {![info exists et_cache($prop,$target)]} {\n+\tverbose \"check_v3_target_prop_cached $prop: checking $target\" 2\n+\tif {[string is true -strict $args] || [string is false -strict $args]} {\n+\t    error {check_v3_target_prop_cached condition already evaluated; did you pass [...] instead of the expected {...}?}\n+\t} else {\n+\t    set code [catch {uplevel eval $args} result]\n+\t    if {$code != 0 && $code != 2} {\n+\t\tverbose \"check_v3_target_prop_cached $prop: evaluation failed for $target\" 2\n+\t\treturn -code $code $result\n+\t    }\n+\t    set et_cache($prop,$target) $result\n \t}\n+    } else {\n+\tverbose \"check_v3_target_prop_cached $prop $target: using cached result\" 2\n     }\n \n-    if [info exists et_fileio_saved] {\n-\tverbose \"check_v3_target_fileio: using cached result\" 2\n-    } else {\n-\tset et_fileio_saved 0\n+    set value $et_cache($prop,$target)\n+    verbose \"check_v3_target_prop_cached $prop: returning $value for $target\" 2\n+    return $value\n+}\n+\n+proc check_v3_target_fileio { } {\n+    return [check_v3_target_prop_cached et_fileio {\n+\tglobal tool\n+\tglobal srcdir\n \n \t# Set up, compile, and execute a C++ test program that tries to use\n \t# the file functions\n@@ -766,41 +773,19 @@ proc check_v3_target_fileio { } {\n \t    verbose \"check_v3_target_fileio: status is <$status>\" 2\n \n \t    if { $status == \"pass\" } {\n-\t\tset et_fileio_saved 1\n+\t\treturn 1\n \t    }\n \t} else {\n \t    verbose \"check_v3_target_fileio: compilation failed\" 2\n \t}\n-    }\n-    return $et_fileio_saved\n+\treturn 0\n+    }]\n }\n \n # Eventually we want C90/C99 determining and switching from this.\n proc check_v3_target_c_std { } {\n-    global et_c_std_saved\n-    global et_c_std_target_name\n-    global tool\n-\n-    if { ![info exists et_c_std_target_name] } {\n-\tset et_c_std_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_c_std_target_name } {\n-\tverbose \"check_v3_target_c_std: `$et_c_std_target_name'\" 2\n-\tset et_c_std_target_name $current_target\n-\tif [info exists et_c_std_saved] {\n-\t    verbose \"check_v3_target_c_std: removing cached result\" 2\n-\t    unset et_c_std_saved\n-\t}\n-    }\n-\n-    if [info exists et_c_std_saved] {\n-\tverbose \"check_v3_target_c_std: using cached result\" 2\n-    } else {\n-\tset et_c_std_saved 0\n-\n+    return [check_v3_target_prop_cached et_c_std {\n+\tglobal tool\n \t# Set up, compile, and execute a C++ test program that tries to use\n \t# C99 functionality.\n \t# For math bits, could use check_effective_target_c99_math.\n@@ -832,13 +817,13 @@ proc check_v3_target_c_std { } {\n \t    verbose \"check_v3_target_c_std: status is <$status>\" 2\n \n \t    if { $status == \"pass\" } {\n-\t\tset et_c_std_saved 1\n+\t\treturn 1\n \t    }\n \t} else {\n \t    verbose \"check_v3_target_c_std: compilation failed\" 2\n \t}\n-    }\n-    return $et_c_std_saved\n+\treturn 0\n+    }]\n }\n \n proc check_v3_target_sharedlib { } {\n@@ -847,30 +832,8 @@ proc check_v3_target_sharedlib { } {\n }\n \n proc check_v3_target_time { } {\n-    global et_time_saved\n-    global et_time_target_name\n-    global tool\n-\n-    if { ![info exists et_time_target_name] } {\n-\tset et_time_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_time_target_name } {\n-\tverbose \"check_v3_target_time: `$et_time_target_name'\" 2\n-\tset et_time_target_name $current_target\n-\tif [info exists et_time_saved] {\n-\t    verbose \"check_v3_target_time: removing cached result\" 2\n-\t    unset et_time_saved\n-\t}\n-    }\n-\n-    if [info exists et_time_saved] {\n-\tverbose \"check_v3_target_time: using cached result\" 2\n-    } else {\n-\tset et_time_saved 0\n-\n+    return [check_v3_target_prop_cached et_target_time {\n+\tglobal tool\n \t# Set up and compile a C++ test program that tries to use\n \t# the time function\n \tset src time[pid].cc\n@@ -890,113 +853,87 @@ proc check_v3_target_time { } {\n \tif [string match \"\" $lines] {\n \t    # No error message, compilation succeeded.\n \t    verbose \"check_v3_target_time: compilation succeeded\" 2\n-\t    set et_time_saved 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_time: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    return $et_time_saved\n+    }]\n }\n \n proc check_v3_target_namedlocale { args } {\n-    global et_namedlocale\n-    global tool\n-\n-    set et_namedlocale 0\n-\n-    # Set up, compile, and execute a C++ test program that tries to use\n-    # the required named locale.\n-    set exe nlocale[pid].x\n-\n-    if ![file exists ./$exe] {\n-      set src nlocale[pid].cc\n-\n-      set f [open $src \"w\"]\n-      puts $f \"#include <locale>\"\n-      puts $f \"#include <cstdio>\"\n-      puts $f \"#include <cstring>\"\n-      puts $f \"using namespace std;\"\n-      puts $f \"char *transform_locale(const char *name)\"\n-      puts $f \"{\"\n-      puts $f \"    char *result = new char\\[50\\];\"\n-      puts $f \"    strcpy(result, name);\"\n-      puts $f \"#if defined __FreeBSD__ || defined __DragonFly__ || defined __NetBSD__\"\n-      puts $f \"    /* fall-through */\"\n-      puts $f \"#else\"\n-      puts $f \"    if (strstr(result, \\\"ISO8859-15\\\")) {\"\n-      puts $f \"        strcat(result, \\\"@euro\\\");\"\n-      puts $f \"    }\"\n-      puts $f \"#endif\"\n-      puts $f \"    return result;\"\n-      puts $f \"}\"\n-      puts $f \"int main (int argc, char** argv)\"\n-      puts $f \"{\"\n-      puts $f \"  if (argc < 2)\"\n-      puts $f \"  {\"\n-      puts $f \"    printf(\\\"locale support test not supported\\\\n\\\");\"\n-      puts $f \"    return 1;\"\n-      puts $f \"  }\"\n-      puts $f \"  const char *namedloc = transform_locale(*(argv + 1));\"\n-      puts $f \"  try\"\n-      puts $f \"  {\"\n-      puts $f \"    locale((const char*)namedloc);\"\n-      puts $f \"    delete\\[\\] namedloc;\"\n-      puts $f \"    return 0;\"\n-      puts $f \"  }\"\n-      puts $f \"  catch(...)\"\n-      puts $f \"  {\"\n-      puts $f \"    printf(\\\"locale '%s' not supported\\\\n\\\", namedloc);\"\n-      puts $f \"    delete\\[\\] namedloc;\"\n-      puts $f \"    return 1;\"\n-      puts $f \"  }\"\n-      puts $f \"}\"\n-      close $f\n-\n-      set lines [v3_target_compile $src $exe executable \"\"]\n-      file delete $src\n-\n-      if ![string match \"\" $lines] {\n-\tverbose \"check_v3_target_namedlocale: compilation failed\" 2\n-\treturn $et_namedlocale\n-      }\n-      # else No error message, compilation succeeded.\n-    }\n-\n-    set result [${tool}_load \"./$exe\" \"$args\" \"\"]\n-    set status [lindex $result 0]\n+    set key \"et_namedlocale $args\"\n+    return [check_v3_target_prop_cached $key {\n+\tglobal tool\n+\t# Set up, compile, and execute a C++ test program that tries to use\n+\t# the required named locale.\n+\tset exe nlocale[pid].x\n+\tset src nlocale[pid].cc\n \n-    verbose \"check_v3_target_namedlocale <$args>: status is <$status>\" 2\n+\tset f [open $src \"w\"]\n+\tputs $f \"#include <locale>\"\n+\tputs $f \"#include <cstdio>\"\n+\tputs $f \"#include <cstring>\"\n+\tputs $f \"using namespace std;\"\n+\tputs $f \"char *transform_locale(const char *name)\"\n+\tputs $f \"{\"\n+\tputs $f \"    char *result = new char\\[50\\];\"\n+\tputs $f \"    strcpy(result, name);\"\n+\tputs $f \"#if defined __FreeBSD__ || defined __DragonFly__ || defined __NetBSD__\"\n+\tputs $f \"    /* fall-through */\"\n+\tputs $f \"#else\"\n+\tputs $f \"    if (strstr(result, \\\"ISO8859-15\\\")) {\"\n+\tputs $f \"        strcat(result, \\\"@euro\\\");\"\n+\tputs $f \"    }\"\n+\tputs $f \"#endif\"\n+\tputs $f \"    return result;\"\n+\tputs $f \"}\"\n+\tputs $f \"int main (int argc, char** argv)\"\n+\tputs $f \"{\"\n+\tputs $f \"  if (argc < 2)\"\n+\tputs $f \"  {\"\n+\tputs $f \"    printf(\\\"locale support test not supported\\\\n\\\");\"\n+\tputs $f \"    return 1;\"\n+\tputs $f \"  }\"\n+\tputs $f \"  const char *namedloc = transform_locale(*(argv + 1));\"\n+\tputs $f \"  try\"\n+\tputs $f \"  {\"\n+\tputs $f \"    locale((const char*)namedloc);\"\n+\tputs $f \"    delete\\[\\] namedloc;\"\n+\tputs $f \"    return 0;\"\n+\tputs $f \"  }\"\n+\tputs $f \"  catch(...)\"\n+\tputs $f \"  {\"\n+\tputs $f \"    printf(\\\"locale '%s' not supported\\\\n\\\", namedloc);\"\n+\tputs $f \"    delete\\[\\] namedloc;\"\n+\tputs $f \"    return 1;\"\n+\tputs $f \"  }\"\n+\tputs $f \"}\"\n+\tclose $f\n \n-    if { $status == \"pass\" } {\n-      set et_namedlocale 1\n-    }\n-    return $et_namedlocale\n-}\n+\tset lines [v3_target_compile $src $exe executable \"\"]\n+\tfile delete $src\n \n-proc check_v3_target_debug_mode { } {\n-    global et_debug_mode\n-    global tool\n+\tif ![string match \"\" $lines] {\n+\t  verbose \"check_v3_target_namedlocale: compilation failed\" 2\n+\t  return 0\n+\t}\n \n-    if { ![info exists et_debug_mode_target_name] } {\n-\tset et_debug_mode_target_name \"\"\n-    }\n+\tset result [${tool}_load \"./$exe\" \"$args\" \"\"]\n+\tset status [lindex $result 0]\n \n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_debug_mode_target_name } {\n-\tverbose \"check_v3_target_debug_mode: `$et_debug_mode_target_name'\" 2\n-\tset et_debug_mode_target_name $current_target\n-\tif [info exists et_debug_mode] {\n-\t    verbose \"check_v3_target_debug_mode: removing cached result\" 2\n-\t    unset et_debug_mode\n-\t}\n-    }\n+\tverbose \"check_v3_target_namedlocale <$args>: status is <$status>\" 2\n \n-    if [info exists et_debug_mode] {\n-\tverbose \"check_v3_target_debug_mode: using cached result\" 2\n-    } else {\n-\tset et_debug_mode 0\n+\tif { $status == \"pass\" } {\n+\t    return 1\n+\t  }\n+\treturn 0\n+    }]\n+}\n \n+proc check_v3_target_debug_mode { } {\n+    return [check_v3_target_prop_cached et_debug_mode {\n+\tglobal tool\n \t# Set up and preprocess a C++ test program that depends\n \t# on debug mode activated.\n \tset src debug_mode[pid].cc\n@@ -1012,37 +949,15 @@ proc check_v3_target_debug_mode { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_debug_mode 1\n+\t    return 1\n \t}\n-    }\n-    verbose \"check_v3_target_debug_mode: $et_debug_mode\" 2\n-    return $et_debug_mode\n+\treturn 0\n+    }]\n }\n \n proc check_v3_target_profile_mode { } {\n-    global et_profile_mode\n-    global tool\t\n-\n-    if { ![info exists et_profile_mode_target_name] } {\n-\tset et_profile_mode_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_profile_mode_target_name } {\n-\tverbose \"check_v3_target_profile_mode: `$et_profile_mode_target_name'\" 2\n-\tset et_profile_mode_target_name $current_target\n-\tif [info exists et_profile_mode] {\n-\t    verbose \"check_v3_target_profile_mode: removing cached result\" 2\n-\t    unset et_profile_mode\n-\t}\n-    }\n-\n-    if [info exists et_profile_mode] {\n-\tverbose \"check_v3_target_profile_mode: using cached result\" 2\n-    } else {\n-\tset et_profile_mode 0\n-\n+    return [check_v3_target_prop_cached et_profile_mode {\n+\tglobal tool\n \t# Set up and preprocess a C++ test program that depends\n \t# on profile mode activated.\n \tset src profile_mode[pid].cc\n@@ -1058,37 +973,15 @@ proc check_v3_target_profile_mode { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_profile_mode 1\n+\t    return 1\n \t}\n-    }\n-    verbose \"check_v3_target_profile_mode: $et_profile_mode\" 2\n-    return $et_profile_mode\n+\treturn 0\n+    }]\n }\n \n proc check_v3_target_normal_mode { } {\n-    global et_normal_mode\n-    global tool\n-\n-    if { ![info exists et_normal_mode_target_name] } {\n-\tset et_normal_mode_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_normal_mode_target_name } {\n-\tverbose \"check_v3_target_normal_mode: `$et_normal_mode_target_name'\" 2\n-\tset et_normal_mode_target_name $current_target\n-\tif [info exists et_normal_mode] {\n-\t    verbose \"check_v3_target_normal_mode: removing cached result\" 2\n-\t    unset et_normal_mode\n-\t}\n-    }\n-\n-    if [info exists et_normal_mode] {\n-\tverbose \"check_v3_target_normal_mode: using cached result\" 2\n-    } else {\n-\tset et_normal_mode 0\n-\n+    return [check_v3_target_prop_cached et_normal_mode {\n+\tglobal tool\n \t# Set up and compile a C++ test program that depends\n \t# on normal mode activated.\n \tset src normal_mode[pid].cc\n@@ -1107,37 +1000,15 @@ proc check_v3_target_normal_mode { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, compilation succeeded.\n-\t    set et_normal_mode 1\n+\t    return 1\n \t}\n-    }\n-    verbose \"check_v3_target_normal_mode: $et_normal_mode\" 2\n-    return $et_normal_mode\n+\treturn 0\n+    }]\n }\n \n proc check_v3_target_normal_namespace { } {\n-    global et_normal_namespace\n-    global tool\n-\n-    if { ![info exists et_normal_namespace_target_name] } {\n-\tset et_normal_namespace_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_normal_namespace_target_name } {\n-\tverbose \"check_v3_target_normal_namespace: `$et_normal_namespace_target_name'\" 2\n-\tset et_normal_namespace_target_name $current_target\n-\tif [info exists et_normal_namespace] {\n-\t    verbose \"check_v3_target_normal_namespace: removing cached result\" 2\n-\t    unset et_normal_namespace\n-\t}\n-    }\n-\n-    if [info exists et_normal_namespace] {\n-\tverbose \"check_v3_target_normal_namespace: using cached result\" 2\n-    } else {\n-\tset et_normal_namespace 0\n-\n+    return [check_v3_target_prop_cached et_normal_namespace {\n+\tglobal tool\n \t# Set up and compile a C++ test program that depends\n \t# on normal std namespace.\n \tset src normal_namespace[pid].cc\n@@ -1154,76 +1025,28 @@ proc check_v3_target_normal_namespace { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, compilation succeeded.\n-\t    set et_normal_namespace 1\n+\t    return 1\n \t}\n-    }\n-    verbose \"check_v3_target_normal_namespace: $et_normal_namespace\" 2\n-    return $et_normal_namespace\n+\treturn 0\n+    }]\n }\n \n proc check_v3_target_parallel_mode { } {\n-    global cxxflags\n-    global v3-libgomp\n-    global et_parallel_mode\n-\n-    global tool\n-\n-    if { ![info exists et_parallel_mode_target_name] } {\n-\tset et_parallel_mode_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_parallel_mode_target_name } {\n-\tverbose \"check_v3_target_parallel_mode: `$et_parallel_mode_target_name'\" 2\n-\tset et_parallel_mode_target_name $current_target\n-\tif [info exists et_parallel_mode] {\n-\t    verbose \"check_v3_target_parallel_mode: removing cached result\" 2\n-\t    unset et_parallel_mode\n-\t}\n-    }\n-\n-    if [info exists et_parallel_mode] {\n-\tverbose \"check_v3_target_parallel_mode: using cached result\" 2\n-    } else {\n-\tset et_parallel_mode 0\n-\n+    return [check_v3_target_prop_cached et_parallel_mode {\n+\tglobal cxxflags\n+\tglobal v3-libgomp\n \t# If 'make check-parallel' is running the test succeeds.\n \tif { ${v3-libgomp} == 1 && [regexp \"libgomp\" $cxxflags] } {\n-\t    set et_parallel_mode 1\n+\t    return1 1\n \t}\n-    }\n-    verbose \"check_v3_target_parallel_mode: $et_parallel_mode\" 2\n-    return $et_parallel_mode\n+\treturn 0\n+    }]\n }\n \n proc check_v3_target_cstdint { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_cstdint\n-\n-    global tool\n-\n-    if { ![info exists et_cstdint_target_name] } {\n-\tset et_cstdint_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_cstdint_target_name } {\n-\tverbose \"check_v3_target_cstdint: `$et_cstdint_target_name'\" 2\n-\tset et_cstdint_target_name $current_target\n-\tif [info exists et_cstdint] {\n-\t    verbose \"check_v3_target_cstdint: removing cached result\" 2\n-\t    unset et_cstdint\n-\t}\n-    }\n-\n-    if [info exists et_cstdint] {\n-\tverbose \"check_v3_target_cstdint: using cached result\" 2\n-    } else {\n-\tset et_cstdint 0\n-\n+    return [check_v3_target_prop_cached et_cstdint {\n+\tglobal DEFAULT_CXXFLAGS\n+\tglobal cxxflags\n \t# Set up and preprocess a C++0x test program that depends\n \t# on the C99 stdint facilities to be available.\n \tset src cstdint[pid].cc\n@@ -1244,42 +1067,18 @@ proc check_v3_target_cstdint { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocess succeeded.\n-\t    set et_cstdint 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_cstdint: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_cstdint: $et_cstdint\" 2\n-    return $et_cstdint\n+    }]\n }\n \n proc check_v3_target_cmath { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_c99_math\n-\n-    global tool\n-\n-    if { ![info exists et_c99_math_target_name] } {\n-\tset et_c99_math_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_c99_math_target_name } {\n-\tverbose \"check_v3_target_c99_math: `$et_c99_math_target_name'\" 2\n-\tset et_c99_math_target_name $current_target\n-\tif [info exists et_c99_math] {\n-\t    verbose \"check_v3_target_c99_math: removing cached result\" 2\n-\t    unset et_c99_math\n-\t}\n-    }\n-\n-    if [info exists et_c99_math] {\n-\tverbose \"check_v3_target_c99_math: using cached result\" 2\n-    } else {\n-\tset et_c99_math 0\n-\n+    return [check_v3_target_prop_cached et_c99_math {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \t# Set up and preprocess a C++0x test program that depends\n \t# on the C99 math facilities to be available.\n \tset src c99_math[pid].cc\n@@ -1300,41 +1099,18 @@ proc check_v3_target_cmath { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocess succeeded.\n-\t    set et_c99_math 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_c99_math: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_c99_math: $et_c99_math\" 2\n-    return $et_c99_math\n+    }]\n }\n \n proc check_v3_target_thread_fence { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_thread_fence\n-\n-    global tool\n-\n-    if { ![info exists et_thread_fence_target_name] } {\n-\tset et_thread_fence_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_thread_fence_target_name } {\n-\tverbose \"check_v3_target_thread_fence: `$et_thread_fence_target_name'\" 2\n-\tset et_thread_fence_target_name $current_target\n-\tif [info exists et_thread_fence] {\n-\t    verbose \"check_v3_target_thread_fence: removing cached result\" 2\n-\t    unset et_thread_fence\n-\t}\n-    }\n-\n-    if [info exists et_thread_fence] {\n-\tverbose \"check_v3_target_thread_fence: using cached result\" 2\n-    } else {\n-\tset et_thread_fence 0\n+    return [check_v3_target_prop_cached et_thread_fence {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \n \t# Set up and preprocess a C++11 test program that depends\n \t# on the thread fence to be available.\n@@ -1356,41 +1132,18 @@ proc check_v3_target_thread_fence { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, linking succeeded.\n-\t    set et_thread_fence 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_thread_fence: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_thread_fence: $et_thread_fence\" 2\n-    return $et_thread_fence\n+    }]\n }\n \n proc check_v3_target_atomic_builtins { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_atomic_builtins\n-\n-    global tool\n-\n-    if { ![info exists et_atomic_builtins_target_name] } {\n-\tset et_atomic_builtins_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_atomic_builtins_target_name } {\n-\tverbose \"check_v3_target_atomic_builtins: `$et_atomic_builtins_target_name'\" 2\n-\tset et_atomic_builtins_target_name $current_target\n-\tif [info exists et_atomic_builtins] {\n-\t    verbose \"check_v3_target_atomic_builtins: removing cached result\" 2\n-\t    unset et_atomic_builtins\n-\t}\n-    }\n-\n-    if [info exists et_atomic_builtins] {\n-\tverbose \"check_v3_target_atomic_builtins: using cached result\" 2\n-    } else {\n-\tset et_atomic_builtins 0\n+    return [check_v3_target_prop_cached et_atomic_builtins {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \n \t# Set up and preprocess a C++11 test program that depends\n \t# on the atomic builtin facilities to be available.\n@@ -1414,41 +1167,18 @@ proc check_v3_target_atomic_builtins { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocess succeeded.\n-\t    set et_atomic_builtins 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_atomic_builtins: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_atomic_builtins: $et_atomic_builtins\" 2\n-    return $et_atomic_builtins\n+    }]\n }\n \n proc check_v3_target_gthreads { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_gthreads\n-\n-    global tool\n-\n-    if { ![info exists et_gthreads_target_name] } {\n-\tset et_gthreads_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_gthreads_target_name } {\n-\tverbose \"check_v3_target_gthreads: `$et_gthreads_target_name'\" 2\n-\tset et_gthreads_target_name $current_target\n-\tif [info exists et_gthreads] {\n-\t    verbose \"check_v3_target_gthreads: removing cached result\" 2\n-\t    unset et_gthreads\n-\t}\n-    }\n-\n-    if [info exists et_gthreads] {\n-\tverbose \"check_v3_target_gthreads: using cached result\" 2\n-    } else {\n-\tset et_gthreads 0\n+    return [check_v3_target_prop_cached et_gthreads {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \n \t# Set up and preprocess a C++0x test program that depends\n \t# on the gthreads facilities to be available.\n@@ -1470,42 +1200,18 @@ proc check_v3_target_gthreads { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_gthreads 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_gthreads: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_gthreads: $et_gthreads\" 2\n-    return $et_gthreads\n+    }]\n }\n \n proc check_v3_target_gthreads_timed { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_gthreads_timed\n-\n-    global tool\n-\n-    if { ![info exists et_gthreads_timed_target_name] } {\n-\tset et_gthreads_timed_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_gthreads_timed_target_name } {\n-\tverbose \"check_v3_target_gthreads_timed: `$et_gthreads_timed_target_name'\" 2\n-\tset et_gthreads_timed_target_name $current_target\n-\tif [info exists et_gthreads_timed] {\n-\t    verbose \"check_v3_target_gthreads_timed: removing cached result\" 2\n-\t    unset et_gthreads_timed\n-\t}\n-    }\n-\n-    if [info exists et_gthreads_timed] {\n-\tverbose \"check_v3_target_gthreads_timed: using cached result\" 2\n-    } else {\n-\tset et_gthreads_timed 0\n-\n+    return [check_v3_target_prop_cached et_gthreads_timed {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \t# Set up and preprocess a C++0x test program that depends\n \t# on the gthreads timed mutex facilities to be available.\n \tset src gthreads_timed[pid].cc\n@@ -1529,43 +1235,18 @@ proc check_v3_target_gthreads_timed { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_gthreads_timed 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_gthreads_timed: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_gthreads_timed: $et_gthreads_timed\" 2\n-    return $et_gthreads_timed\n+    }]\n }\n \n-\n proc check_v3_target_sleep { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_sleep\n-\n-    global tool\n-\n-    if { ![info exists et_sleep_target_name] } {\n-\tset et_sleep_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_sleep_target_name } {\n-\tverbose \"check_v3_target_sleep: `$et_sleep_target_name'\" 2\n-\tset et_sleep_target_name $current_target\n-\tif [info exists et_sleep] {\n-\t    verbose \"check_v3_target_sleep: removing cached result\" 2\n-\t    unset et_sleep\n-\t}\n-    }\n-\n-    if [info exists et_sleep] {\n-\tverbose \"check_v3_target_sleep: using cached result\" 2\n-    } else {\n-\tset et_sleep 0\n-\t\n+    return [check_v3_target_prop_cached et_sleep {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \t# Set up and preprocess a C++11 test program that depends\n \t# on the sleep facilities to be available.\n \tset src sleep[pid].cc\n@@ -1588,41 +1269,18 @@ proc check_v3_target_sleep { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_sleep 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_sleep: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_sleep: $et_sleep\" 2\n-    return $et_sleep\n+    }]\n }\n \n proc check_v3_target_sched_yield { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_sched_yield\n-\n-    global tool\n-\n-    if { ![info exists et_sched_yield_target_name] } {\n-\tset et_sched_yield_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_sched_yield_target_name } {\n-\tverbose \"check_v3_target_sched_yield: `$et_sched_yield_target_name'\" 2\n-\tset et_sched_yield_target_name $current_target\n-\tif [info exists et_sched_yield] {\n-\t    verbose \"check_v3_target_sched_yield: removing cached result\" 2\n-\t    unset et_sched_yield\n-\t}\n-    }\n-\n-    if [info exists et_sched_yield] {\n-\tverbose \"check_v3_target_sched_yield: using cached result\" 2\n-    } else {\n-\tset et_sched_yield 0\n+    return [check_v3_target_prop_cached et_sched_yield {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \n \t# Set up and preprocess a C++0x test program that depends\n \t# on the sched_yield facility to be available.\n@@ -1644,42 +1302,18 @@ proc check_v3_target_sched_yield { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_sched_yield 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_sched_yield: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_sched_yield: $et_sched_yield\" 2\n-    return $et_sched_yield\n+    }]\n }\n \n proc check_v3_target_string_conversions { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_string_conversions\n-\n-    global tool\n-\n-    if { ![info exists et_string_conversions_target_name] } {\n-\tset et_string_conversions_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_string_conversions_target_name } {\n-\tverbose \"check_v3_target_string_conversions: `$et_string_conversions_target_name'\" 2\n-\tset et_string_conversions_target_name $current_target\n-\tif [info exists et_string_conversions] {\n-\t    verbose \"check_v3_target_string_conversions: removing cached result\" 2\n-\t    unset et_string_conversions\n-\t}\n-    }\n-\n-    if [info exists et_string_conversions] {\n-\tverbose \"check_v3_target_string_conversions: using cached result\" 2\n-    } else {\n-\tset et_string_conversions 0\n-\t\n+    return [check_v3_target_prop_cached et_string_conversions {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \t# Set up and preprocess a C++0x test program that depends\n \t# on the string_conversions facilities to be available.\n \tset src string_conversions[pid].cc\n@@ -1700,42 +1334,18 @@ proc check_v3_target_string_conversions { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_string_conversions 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_string_conversions: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_string_conversions: $et_string_conversions\" 2\n-    return $et_string_conversions\n+    }]\n }\n \n proc check_v3_target_swprintf { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_swprintf\n-\n-    global tool\n-\n-    if { ![info exists et_swprintf_target_name] } {\n-\tset et_swprintf_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_swprintf_target_name } {\n-\tverbose \"check_v3_target_swprintf: `$et_swprintf_target_name'\" 2\n-\tset et_swprintf_target_name $current_target\n-\tif [info exists et_swprintf] {\n-\t    verbose \"check_v3_target_swprintf: removing cached result\" 2\n-\t    unset et_swprintf\n-\t}\n-    }\n-\n-    if [info exists et_swprintf] {\n-\tverbose \"check_v3_target_swprintf: using cached result\" 2\n-    } else {\n-\tset et_swprintf 0\n-\t\n+    return [check_v3_target_prop_cached et_swprintf {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \t# Set up and preprocess a C++0x test program that depends\n \t# on a standard swprintf function to be available.\n \tset src swprintf[pid].cc\n@@ -1756,42 +1366,18 @@ proc check_v3_target_swprintf { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_swprintf 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_swprintf: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_swprintf: $et_swprintf\" 2\n-    return $et_swprintf\n+    }]\n }\n \n proc check_v3_target_binary_io { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_binary_io\n-\n-    global tool\n-\n-    if { ![info exists et_binary_io_target_name] } {\n-\tset et_binary_io_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_binary_io_target_name } {\n-\tverbose \"check_v3_target_binary_io: `$et_binary_io_target_name'\" 2\n-\tset et_binary_io_target_name $current_target\n-\tif [info exists et_binary_io] {\n-\t    verbose \"check_v3_target_binary_io: removing cached result\" 2\n-\t    unset et_binary_io\n-\t}\n-    }\n-\n-    if [info exists et_binary_io] {\n-\tverbose \"check_v3_target_binary_io: using cached result\" 2\n-    } else {\n-\tset et_binary_io 0\n-\t\n+    return [check_v3_target_prop_cached et_binary_io {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \t# Set up and preprocess a C++0x test program that depends\n \t# on text and binary I/O being the same.\n \tset src binary_io[pid].cc\n@@ -1812,42 +1398,18 @@ proc check_v3_target_binary_io { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_binary_io 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_binary_io: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_binary_io: $et_binary_io\" 2\n-    return $et_binary_io\n+    }]\n }\n \n proc check_v3_target_nprocs { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_nprocs\n-\n-    global tool\n-\n-    if { ![info exists et_nprocs_target_name] } {\n-\tset et_nprocs_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_nprocs_target_name } {\n-\tverbose \"check_v3_target_nprocs: `$et_nprocs_target_name'\" 2\n-\tset et_nprocs_target_name $current_target\n-\tif [info exists et_nprocs] {\n-\t    verbose \"check_v3_target_nprocs: removing cached result\" 2\n-\t    unset et_nprocs\n-\t}\n-    }\n-\n-    if [info exists et_nprocs] {\n-\tverbose \"check_v3_target_nprocs: using cached result\" 2\n-    } else {\n-\tset et_nprocs 0\n-\n+    return [check_v3_target_prop_cached et_nprocs {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \t# Set up and preprocess a C++0x test program that depends\n \t# on either get_nprocs or sysconf to be available.\n \tset src nprocs[pid].cc\n@@ -1873,27 +1435,18 @@ proc check_v3_target_nprocs { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocess succeeded.\n-\t    set et_nprocs 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_nprocs: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_nprocs: $et_nprocs\" 2\n-    return $et_nprocs\n+    }]\n }\n \n proc check_v3_target_static_libstdcxx { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_static_libstdcxx\n-\n-    global tool\n-\n-    if [info exists et_static_libstdcxx] {\n-\tverbose \"check_v3_target_static_libstdcxx: using cached result\" 2\n-    } else {\n-\tset et_static_libstdcxx 0\n-\n+    return [check_v3_target_prop_cached et_static_libstdcxx {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \t# Set up and link a C++0x test program that depends\n \t# on static linking\n \tset src static-maybe[pid].cc\n@@ -1916,42 +1469,18 @@ proc check_v3_target_static_libstdcxx { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, link succeeded.\n-\t    set et_static_libstdcxx 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_static_libstdcxx: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_static_libstdcxx: $et_static_libstdcxx\" 2\n-    return $et_static_libstdcxx\n+    }]\n }\n \n proc check_v3_target_little_endian { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_little_endian\n-\n-    global tool\n-\n-    if { ![info exists et_little_endian_target_name] } {\n-\tset et_little_endian_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_little_endian_target_name } {\n-\tverbose \"check_v3_target_little_endian: `$et_little_endian_target_name'\" 2\n-\tset et_little_endian_target_name $current_target\n-\tif [info exists et_little_endian] {\n-\t    verbose \"check_v3_target_little_endian: removing cached result\" 2\n-\t    unset et_little_endian\n-\t}\n-    }\n-\n-    if [info exists et_little_endian] {\n-\tverbose \"check_v3_target_little_endian: using cached result\" 2\n-    } else {\n-\tset et_little_endian 0\n-\t\n+    return [check_v3_target_prop_cached et_little_endian {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \tset src little_endian[pid].cc\n \n \tset f [open $src \"w\"]\n@@ -1969,43 +1498,20 @@ proc check_v3_target_little_endian { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_little_endian 1\n+\t    return 1\n \t} else {\n \t    verbose \"check_v3_target_little_endian: compilation failed\" 2\n+\t    return 0\n \t}\n-    }\n-    verbose \"check_v3_target_little_endian: $et_little_endian\" 2\n-    return $et_little_endian\n+    }]\n }\n \n # Return 1 if the Filesystem TS is supported, 0 otherwise.\n # Cache the result.\n proc check_v3_target_filesystem_ts { } {\n-    global cxxflags\n-    global DEFAULT_CXXFLAGS\n-    global et_filesystem_ts\n-    global tool\n-\n-    if { ![info exists et_filesystem_ts_target_name] } {\n-\tset et_filesystem_ts_target_name \"\"\n-    }\n-\n-    # If the target has changed since we set the cached value, clear it.\n-    set current_target [current_target_name]\n-    if { $current_target != $et_filesystem_ts_target_name } {\n-\tverbose \"check_v3_target_filesystem_ts: `$et_filesystem_ts_target_name'\" 2\n-\tset et_filesystem_ts_target_name $current_target\n-\tif [info exists et_filesystem_ts] {\n-\t    verbose \"check_v3_target_filesystem_ts: removing cached result\" 2\n-\t    unset et_filesystem_ts\n-\t}\n-    }\n-\n-    if [info exists et_filesystem_ts] {\n-\tverbose \"check_v3_target_filesystem_ts: using cached result\" 2\n-    } else {\n-\tset et_filesystem_ts 0\n-\n+    return [check_v3_target_prop_cached et_filesystem_ts {\n+\tglobal cxxflags\n+\tglobal DEFAULT_CXXFLAGS\n \t# Set up and preprocess a C++ test program that depends\n \t# on the Filesystem TS feature-test macro being defined.\n \tset src filesystem_ts[pid].cc\n@@ -2026,11 +1532,10 @@ proc check_v3_target_filesystem_ts { } {\n \n \tif [string match \"\" $lines] {\n \t    # No error message, preprocessing succeeded.\n-\t    set et_filesystem_ts 1\n+\t    return 1\n \t}\n-    }\n-    verbose \"check_v3_target_filesystem_ts: $et_filesystem_ts\" 2\n-    return $et_filesystem_ts\n+\treturn 0\n+    }]\n }\n \n # Return 1 if the \"cxx11\" ABI is in use using the current flags, 0 otherwise."}]}