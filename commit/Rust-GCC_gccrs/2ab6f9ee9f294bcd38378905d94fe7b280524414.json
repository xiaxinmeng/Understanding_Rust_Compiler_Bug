{"sha": "2ab6f9ee9f294bcd38378905d94fe7b280524414", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFiNmY5ZWU5ZjI5NGJjZDM4Mzc4OTA1ZDk0ZmU3YjI4MDUyNDQxNA==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-31T11:22:18Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-31T11:22:18Z"}, "message": "Add name resolution for QualifiedPathInType\n\nQualified path types allow for TypePaths qualified with a paticular\nassociated impl and type;", "tree": {"sha": "b0047c7b6d3a1717d3f592ab5ed13447dab04e57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0047c7b6d3a1717d3f592ab5ed13447dab04e57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ab6f9ee9f294bcd38378905d94fe7b280524414", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab6f9ee9f294bcd38378905d94fe7b280524414", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ab6f9ee9f294bcd38378905d94fe7b280524414", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab6f9ee9f294bcd38378905d94fe7b280524414/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e3030707bfcd196fd678a25bf28fbdb925914c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3030707bfcd196fd678a25bf28fbdb925914c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3030707bfcd196fd678a25bf28fbdb925914c4"}], "stats": {"total": 118, "additions": 116, "deletions": 2}, "files": [{"sha": "9ad465a274ba35086b1e746d81d7f7ce375f9cd3", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab6f9ee9f294bcd38378905d94fe7b280524414/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab6f9ee9f294bcd38378905d94fe7b280524414/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=2ab6f9ee9f294bcd38378905d94fe7b280524414", "patch": "@@ -97,6 +97,7 @@ class ResolveTraitItemTypeToCanonicalPath\n \n class ResolveTypeToCanonicalPath : public ResolverBase\n {\n+protected:\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n@@ -128,7 +129,7 @@ class ResolveTypeToCanonicalPath : public ResolverBase\n \n   static bool type_resolve_generic_args (AST::GenericArgs &args);\n \n-private:\n+protected:\n   ResolveTypeToCanonicalPath (bool include_generic_args,\n \t\t\t      bool type_resolve_generic_args)\n     : ResolverBase (UNKNOWN_NODEID), result (CanonicalPath::create_empty ()),\n@@ -182,8 +183,10 @@ class TraitImplProjection\n   }\n };\n \n-class ResolveRelativeTypePath\n+class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n {\n+  using ResolveTypeToCanonicalPath::visit;\n+\n public:\n   static NodeId go (AST::TypePath &path, NodeId parent,\n \t\t    const CanonicalPath &prefix,\n@@ -218,6 +221,64 @@ class ResolveRelativeTypePath\n \n     return resolved_node;\n   }\n+\n+  static NodeId go (AST::QualifiedPathInType &path, NodeId parent,\n+\t\t    const CanonicalPath &prefix,\n+\t\t    bool canonicalize_type_with_generics)\n+  {\n+    auto &qualified_path = path.get_qualified_path_type ();\n+    CanonicalPath result = prefix;\n+    if (!resolve_qual_seg (qualified_path, result))\n+      return UNKNOWN_NODEID;\n+\n+    // resolve the associated impl\n+    auto resolver = Resolver::get ();\n+    NodeId projection_resolved_id = UNKNOWN_NODEID;\n+    if (!resolver->get_name_scope ().lookup (result, &projection_resolved_id))\n+      {\n+\trust_error_at (path.get_locus (),\n+\t\t       \"failed to resolve associated path: %s\",\n+\t\t       result.get ().c_str ());\n+\n+\treturn UNKNOWN_NODEID;\n+      }\n+    // mark the resolution for this\n+    resolver->insert_resolved_name (qualified_path.get_node_id (),\n+\t\t\t\t    projection_resolved_id);\n+\n+    // qualified types are similar to other paths in that we cannot guarantee\n+    // that we can resolve the path at name resolution. We must look up\n+    // associated types and type information to figure this out properly\n+\n+    ResolveRelativeTypePath o (result);\n+    std::unique_ptr<AST::TypePathSegment> &associated\n+      = path.get_associated_segment ();\n+\n+    associated->accept_vis (o);\n+    if (o.failure_flag)\n+      return UNKNOWN_NODEID;\n+\n+    for (auto &seg : path.get_segments ())\n+      {\n+\tseg->accept_vis (o);\n+\tif (o.failure_flag)\n+\t  return UNKNOWN_NODEID;\n+      }\n+\n+    // we only return the projection id for now since we need the type system to\n+    // resolve the associated types in this path\n+    return projection_resolved_id;\n+  }\n+\n+private:\n+  ResolveRelativeTypePath (CanonicalPath qualified_path)\n+    : ResolveTypeToCanonicalPath (true, true)\n+  {\n+    result = qualified_path;\n+  }\n+\n+  static bool resolve_qual_seg (AST::QualifiedPathType &seg,\n+\t\t\t\tCanonicalPath &result);\n };\n \n class ResolveType : public ResolverBase\n@@ -275,6 +336,15 @@ class ResolveType : public ResolverBase\n       }\n   }\n \n+  void visit (AST::QualifiedPathInType &path) override\n+  {\n+    resolved_node\n+      = ResolveRelativeTypePath::go (path, parent,\n+\t\t\t\t     CanonicalPath::create_empty (),\n+\t\t\t\t     canonicalize_type_with_generics);\n+    ok = resolved_node != UNKNOWN_NODEID;\n+  }\n+\n   void visit (AST::ArrayType &type) override;\n \n   void visit (AST::ReferenceType &type) override"}, {"sha": "1f901813c1d371471449a694ec99498bffef72f5", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab6f9ee9f294bcd38378905d94fe7b280524414/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab6f9ee9f294bcd38378905d94fe7b280524414/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=2ab6f9ee9f294bcd38378905d94fe7b280524414", "patch": "@@ -744,5 +744,49 @@ ResolveItem::resolve_extern_item (AST::ExternalItem *item)\n   ResolveExternItem::go (item);\n }\n \n+// qualified path in type\n+\n+bool\n+ResolveRelativeTypePath::resolve_qual_seg (AST::QualifiedPathType &seg,\n+\t\t\t\t\t   CanonicalPath &result)\n+{\n+  if (seg.is_error ())\n+    {\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return false;\n+    }\n+\n+  bool canonicalize_type_with_generics = true;\n+  NodeId type_resolved_node\n+    = ResolveType::go (seg.get_type ().get (), seg.get_node_id (),\n+\t\t       canonicalize_type_with_generics);\n+  if (type_resolved_node == UNKNOWN_NODEID)\n+    return false;\n+\n+  CanonicalPath impl_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (*seg.get_type ().get ());\n+  if (!seg.has_as_clause ())\n+    {\n+      result = result.append (impl_type_seg);\n+      return true;\n+    }\n+\n+  NodeId trait_resolved_node\n+    = ResolveType::go (&seg.get_as_type_path (), seg.get_node_id (),\n+\t\t       canonicalize_type_with_generics);\n+\n+  if (trait_resolved_node == UNKNOWN_NODEID)\n+    return false;\n+\n+  CanonicalPath trait_type_seg\n+    = ResolveTypeToCanonicalPath::resolve (seg.get_as_type_path ());\n+  CanonicalPath projection\n+    = TraitImplProjection::resolve (seg.get_node_id (), trait_type_seg,\n+\t\t\t\t    impl_type_seg);\n+  result = result.append (projection);\n+  return true;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}]}