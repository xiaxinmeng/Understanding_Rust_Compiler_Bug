{"sha": "dad0ebe674d495a7e032a123d2d60c090729ef2c", "node_id": "C_kwDOANBUbNoAKGRhZDBlYmU2NzRkNDk1YTdlMDMyYTEyM2QyZDYwYzA5MDcyOWVmMmM", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2022-08-23T11:28:43Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-12T08:16:49Z"}, "message": "[Ada] Revert \"Enforce matching of extra formals\"\n\nThis reverts commit 51abc0cc8691daecd7cec8372e4988e9f3f1913c.", "tree": {"sha": "5c2d16eee13a4a38955ec4766fae816f0ef38944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c2d16eee13a4a38955ec4766fae816f0ef38944"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dad0ebe674d495a7e032a123d2d60c090729ef2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad0ebe674d495a7e032a123d2d60c090729ef2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad0ebe674d495a7e032a123d2d60c090729ef2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad0ebe674d495a7e032a123d2d60c090729ef2c/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fa66b95570a125fd35d5721c9eb08d975f73e82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fa66b95570a125fd35d5721c9eb08d975f73e82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fa66b95570a125fd35d5721c9eb08d975f73e82"}], "stats": {"total": 1588, "additions": 439, "deletions": 1149}, "files": [{"sha": "b67103a0ff34a545afe636a2256c0ae486e6b294", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -189,7 +189,7 @@ package body Debug is\n    --  d_U  Disable prepending messages with \"error:\".\n    --  d_V  Enable verifications on the expanded tree\n    --  d_W\n-   --  d_X  Disable assertions to check matching of extra formals\n+   --  d_X\n    --  d_Y\n    --  d_Z\n \n@@ -1044,10 +1044,6 @@ package body Debug is\n    --  d_V  Enable verification of the expanded code before calling the backend\n    --       and generate error messages on each inconsistency found.\n \n-   --  d_X  Disable assertions to check matching of extra formals; switch added\n-   --       temporarily to disable these checks until this work is complete if\n-   --       they cause unexpected assertion failures.\n-\n    --  d1   Error messages have node numbers where possible. Normally error\n    --       messages have only source locations. This option is useful when\n    --       debugging errors caused by expanded code, where the source location"}, {"sha": "4a266715b28f0bcc0cdced0736fa17153ecd0198", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -2311,40 +2311,19 @@ package body Exp_Attr is\n             if Is_Access_Protected_Subprogram_Type (Btyp) then\n                Expand_Access_To_Protected_Op (N, Pref, Typ);\n \n+            --  If prefix is a subprogram that has class-wide preconditions and\n+            --  an indirect-call wrapper (ICW) of such subprogram is available\n+            --  then replace the prefix by the ICW.\n+\n             elsif Is_Access_Subprogram_Type (Btyp)\n               and then Is_Entity_Name (Pref)\n+              and then Present (Class_Preconditions (Entity (Pref)))\n+              and then Present (Indirect_Call_Wrapper (Entity (Pref)))\n             then\n-               --  If prefix is a subprogram that has class-wide preconditions\n-               --  and an indirect-call wrapper (ICW) of the subprogram is\n-               --  available then replace the prefix by the ICW.\n-\n-               if Present (Class_Preconditions (Entity (Pref)))\n-                 and then Present (Indirect_Call_Wrapper (Entity (Pref)))\n-               then\n-                  Rewrite (Pref,\n-                    New_Occurrence_Of\n-                      (Indirect_Call_Wrapper (Entity (Pref)), Loc));\n-                  Analyze_And_Resolve (N, Typ);\n-               end if;\n-\n-               --  Ensure the availability of the extra formals to check that\n-               --  they match.\n-\n-               if not Is_Frozen (Entity (Pref))\n-                 or else From_Limited_With (Etype (Entity (Pref)))\n-               then\n-                  Create_Extra_Formals (Entity (Pref));\n-               end if;\n-\n-               if not Is_Frozen (Btyp_DDT)\n-                 or else From_Limited_With (Etype (Btyp_DDT))\n-               then\n-                  Create_Extra_Formals (Btyp_DDT);\n-               end if;\n-\n-               pragma Assert\n-                 (Extra_Formals_Match_OK\n-                   (E => Entity (Pref), Ref_E => Btyp_DDT));\n+               Rewrite (Pref,\n+                 New_Occurrence_Of\n+                   (Indirect_Call_Wrapper (Entity (Pref)), Loc));\n+               Analyze_And_Resolve (N, Typ);\n \n             --  If prefix is a type name, this is a reference to the current\n             --  instance of the type, within its initialization procedure."}, {"sha": "0d826913f756d26b451dc3fb2b15f17999f410c7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 20, "deletions": 109, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -44,6 +44,7 @@ with Exp_Dist;       use Exp_Dist;\n with Exp_Put_Image;\n with Exp_Smem;       use Exp_Smem;\n with Exp_Strm;       use Exp_Strm;\n+with Exp_Tss;        use Exp_Tss;\n with Exp_Util;       use Exp_Util;\n with Freeze;         use Freeze;\n with Ghost;          use Ghost;\n@@ -407,6 +408,15 @@ package body Exp_Ch3 is\n    --  Freeze entities of all predefined primitive operations. This is needed\n    --  because the bodies of these operations do not normally do any freezing.\n \n+   function Stream_Operation_OK\n+     (Typ       : Entity_Id;\n+      Operation : TSS_Name_Type) return Boolean;\n+   --  Check whether the named stream operation must be emitted for a given\n+   --  type. The rules for inheritance of stream attributes by type extensions\n+   --  are enforced by this function. Furthermore, various restrictions prevent\n+   --  the generation of these operations, as a useful optimization or for\n+   --  certification purposes and to save unnecessary generated code.\n+\n    --------------------------\n    -- Adjust_Discriminants --\n    --------------------------\n@@ -5369,10 +5379,6 @@ package body Exp_Ch3 is\n       procedure Register_Dispatch_Table_Wrappers (Typ : Entity_Id);\n       --  Register dispatch-table wrappers in the dispatch table of Typ\n \n-      procedure Validate_Tagged_Type_Extra_Formals (Typ : Entity_Id);\n-      --  Check extra formals of dispatching primitives of tagged type Typ.\n-      --  Used in pragma Debug.\n-\n       ---------------------------------------\n       -- Build_Class_Condition_Subprograms --\n       ---------------------------------------\n@@ -5502,71 +5508,6 @@ package body Exp_Ch3 is\n          end loop;\n       end Register_Dispatch_Table_Wrappers;\n \n-      ----------------------------------------\n-      -- Validate_Tagged_Type_Extra_Formals --\n-      ----------------------------------------\n-\n-      procedure Validate_Tagged_Type_Extra_Formals (Typ : Entity_Id) is\n-         Ovr_Subp : Entity_Id;\n-         Elmt     : Elmt_Id;\n-         Subp     : Entity_Id;\n-\n-      begin\n-         pragma Assert (not Is_Class_Wide_Type (Typ));\n-\n-         --  No check required if expansion is not active since we never\n-         --  generate extra formals in such case.\n-\n-         if not Expander_Active then\n-            return;\n-         end if;\n-\n-         Elmt := First_Elmt (Primitive_Operations (Typ));\n-         while Present (Elmt) loop\n-            Subp := Node (Elmt);\n-\n-            --  Extra formals of a primitive must match the extra formals of\n-            --  its covered interface primitive.\n-\n-            if Present (Interface_Alias (Subp)) then\n-               pragma Assert\n-                 (Extra_Formals_Match_OK\n-                   (E     => Interface_Alias (Subp),\n-                    Ref_E => Alias (Subp)));\n-\n-            elsif Present (Overridden_Operation (Subp)) then\n-               Ovr_Subp := Overridden_Operation (Subp);\n-\n-               --  Handle controlling function wrapper\n-\n-               if Is_Wrapper (Subp)\n-                 and then Ultimate_Alias (Ovr_Subp) = Subp\n-               then\n-                  if Present (Overridden_Operation (Ovr_Subp)) then\n-                     pragma Assert\n-                       (Extra_Formals_Match_OK\n-                         (E     => Subp,\n-                          Ref_E => Overridden_Operation (Ovr_Subp)));\n-                  end if;\n-\n-               else\n-                  pragma Assert\n-                    (Extra_Formals_Match_OK\n-                      (E     => Subp,\n-                       Ref_E => Overridden_Operation (Subp)));\n-               end if;\n-\n-            elsif Present (Alias (Subp)) then\n-               pragma Assert\n-                 (Extra_Formals_Match_OK\n-                   (E     => Subp,\n-                    Ref_E => Ultimate_Alias (Subp)));\n-            end if;\n-\n-            Next_Elmt (Elmt);\n-         end loop;\n-      end Validate_Tagged_Type_Extra_Formals;\n-\n       --  Local variables\n \n       Typ      : constant Node_Id := Entity (N);\n@@ -5955,58 +5896,28 @@ package body Exp_Ch3 is\n          --  inherited functions, then add their bodies to the freeze actions.\n \n          Append_Freeze_Actions (Typ, Wrapper_Body_List);\n-      end if;\n \n-      --  Create extra formals for the primitive operations of the type.\n-      --  This must be done before analyzing the body of the initialization\n-      --  procedure, because a self-referential type might call one of these\n-      --  primitives in the body of the init_proc itself.\n-      --\n-      --  This is not needed:\n-      --    1) If expansion is disabled, because extra formals are only added\n-      --       when we are generating code.\n-      --\n-      --    2) For types with foreign convention since primitives with foreign\n-      --       convention don't have extra formals and AI-117 requires that all\n-      --       primitives of a tagged type inherit the convention.\n+         --  Create extra formals for the primitive operations of the type.\n+         --  This must be done before analyzing the body of the initialization\n+         --  procedure, because a self-referential type might call one of these\n+         --  primitives in the body of the init_proc itself.\n \n-      if Expander_Active\n-        and then Is_Tagged_Type (Typ)\n-        and then not Has_Foreign_Convention (Typ)\n-      then\n          declare\n             Elmt : Elmt_Id;\n-            E    : Entity_Id;\n+            Subp : Entity_Id;\n \n          begin\n-            --  Add extra formals to primitive operations\n-\n             Elmt := First_Elmt (Primitive_Operations (Typ));\n             while Present (Elmt) loop\n-               Create_Extra_Formals (Node (Elmt));\n-               Next_Elmt (Elmt);\n-            end loop;\n-\n-            --  Add extra formals to renamings of primitive operations. The\n-            --  addition of extra formals is done in two steps to minimize\n-            --  the compile time required for this action; the evaluation of\n-            --  Find_Dispatching_Type() and Contains() is only done here for\n-            --  renamings that are not primitive operations.\n-\n-            E := First_Entity (Scope (Typ));\n-            while Present (E) loop\n-               if Is_Dispatching_Operation (E)\n-                 and then Present (Alias (E))\n-                 and then Find_Dispatching_Type (E) = Typ\n-                 and then not Contains (Primitive_Operations (Typ), E)\n+               Subp := Node (Elmt);\n+               if not Has_Foreign_Convention (Subp)\n+                 and then not Is_Predefined_Dispatching_Operation (Subp)\n                then\n-                  Create_Extra_Formals (E);\n+                  Create_Extra_Formals (Subp);\n                end if;\n \n-               Next_Entity (E);\n+               Next_Elmt (Elmt);\n             end loop;\n-\n-            pragma Debug (Validate_Tagged_Type_Extra_Formals (Typ));\n          end;\n       end if;\n "}, {"sha": "f7d43c4aa7ec34b2c6b43e8bbdab3b2cd75f04dd", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -25,10 +25,9 @@\n \n --  Expand routines for chapter 3 constructs\n \n-with Types;   use Types;\n-with Elists;  use Elists;\n-with Exp_Tss; use Exp_Tss;\n-with Uintp;   use Uintp;\n+with Types;  use Types;\n+with Elists; use Elists;\n+with Uintp;  use Uintp;\n \n package Exp_Ch3 is\n \n@@ -208,13 +207,4 @@ package Exp_Ch3 is\n    --  Make_Predefined_Primitive_Eq_Spec; see there for description of\n    --  the Renamed_Eq parameter.\n \n-   function Stream_Operation_OK\n-     (Typ       : Entity_Id;\n-      Operation : TSS_Name_Type) return Boolean;\n-   --  Check whether the named stream operation must be emitted for a given\n-   --  type. The rules for inheritance of stream attributes by type extensions\n-   --  are enforced by this function. Furthermore, various restrictions prevent\n-   --  the generation of these operations, as a useful optimization or for\n-   --  certification purposes and to save unnecessary generated code.\n-\n end Exp_Ch3;"}, {"sha": "fe3bb5be28d0461ae91f543a30ba5f846c21718a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -315,6 +315,15 @@ package body Exp_Ch6 is\n    --  Expand simple return from function. In the case where we are returning\n    --  from a function body this is called by Expand_N_Simple_Return_Statement.\n \n+   function Has_BIP_Extra_Formal\n+     (E    : Entity_Id;\n+      Kind : BIP_Formal_Kind) return Boolean;\n+   --  Given a frozen subprogram, subprogram type, entry or entry family,\n+   --  return True if E has the BIP extra formal associated with Kind. It must\n+   --  be invoked with a frozen entity or a subprogram type of a dispatching\n+   --  call since we can only rely on the availability of the extra formals\n+   --  on these entities.\n+\n    procedure Insert_Post_Call_Actions (N : Node_Id; Post_Call : List_Id);\n    --  Insert the Post_Call list previously produced by routine Expand_Actuals\n    --  or Expand_Call_Helper into the tree.\n@@ -3804,7 +3813,7 @@ package body Exp_Ch6 is\n         and then Thunk_Entity (Current_Scope) = Subp\n         and then Present (Extra_Formals (Subp))\n       then\n-         pragma Assert (Extra_Formals_Match_OK (Current_Scope, Subp));\n+         pragma Assert (Present (Extra_Formals (Current_Scope)));\n \n          declare\n             Target_Formal : Entity_Id;\n@@ -7185,9 +7194,8 @@ package body Exp_Ch6 is\n    --------------------------\n \n    function Has_BIP_Extra_Formal\n-     (E              : Entity_Id;\n-      Kind           : BIP_Formal_Kind;\n-      Must_Be_Frozen : Boolean := True) return Boolean\n+     (E    : Entity_Id;\n+      Kind : BIP_Formal_Kind) return Boolean\n    is\n       Extra_Formal : Entity_Id := Extra_Formals (E);\n \n@@ -7197,7 +7205,7 @@ package body Exp_Ch6 is\n       --  extra formals are added when the target subprogram is frozen; see\n       --  Expand_Dispatching_Call).\n \n-      pragma Assert ((Is_Frozen (E) or else not Must_Be_Frozen)\n+      pragma Assert (Is_Frozen (E)\n         or else (Ekind (E) = E_Subprogram_Type\n                    and then Is_Dispatch_Table_Entity (E))\n         or else (Is_Dispatching_Operation (E)\n@@ -7826,7 +7834,7 @@ package body Exp_Ch6 is\n                or else\n              (Kind = E_Subprogram_Type and then Typ /= Standard_Void_Type))\n         and then Is_Build_In_Place_Result_Type (Typ)\n-        and then not Has_Foreign_Convention (E);\n+        and then not (Is_Imported (E) and then Has_Foreign_Convention (E));\n    end Is_Build_In_Place_Function;\n \n    -------------------------------------\n@@ -8555,11 +8563,6 @@ package body Exp_Ch6 is\n       --  initialization expression of the object to Empty, which would be\n       --  illegal Ada, and would cause gigi to misallocate X.\n \n-      Is_OK_Return_Object : constant Boolean :=\n-        Is_Return_Object (Obj_Def_Id)\n-          and then\n-        not Has_Foreign_Convention (Return_Applies_To (Scope (Obj_Def_Id)));\n-\n    --  Start of processing for Make_Build_In_Place_Call_In_Object_Declaration\n \n    begin\n@@ -8612,7 +8615,7 @@ package body Exp_Ch6 is\n       --  the result object is in a different (transient) scope, so won't cause\n       --  freezing.\n \n-      if Definite and then not Is_OK_Return_Object then\n+      if Definite and then not Is_Return_Object (Obj_Def_Id) then\n \n          --  The presence of an address clause complicates the build-in-place\n          --  expansion because the indicated address must be processed before\n@@ -8695,7 +8698,7 @@ package body Exp_Ch6 is\n       --  really be directly built in place in the aggregate and not in a\n       --  temporary. ???)\n \n-      if Is_OK_Return_Object then\n+      if Is_Return_Object (Obj_Def_Id) then\n          Pass_Caller_Acc := True;\n \n          --  When the enclosing function has a BIP_Alloc_Form formal then we\n@@ -8880,7 +8883,7 @@ package body Exp_Ch6 is\n       --  itself the return expression of an enclosing BIP function, then mark\n       --  the object as having no initialization.\n \n-      if Definite and then not Is_OK_Return_Object then\n+      if Definite and then not Is_Return_Object (Obj_Def_Id) then\n \n          --  The related object declaration is encased in a transient block\n          --  because the build-in-place function call contains at least one\n@@ -9237,7 +9240,7 @@ package body Exp_Ch6 is\n         and then not No_Run_Time_Mode\n         and then (Has_Task (Typ)\n                     or else (Is_Class_Wide_Type (Typ)\n-                               and then Is_Limited_Record (Etype (Typ))\n+                               and then Is_Limited_Record (Typ)\n                                and then not Has_Aspect\n                                  (Etype (Typ), Aspect_No_Task_Parts)));\n    end Might_Have_Tasks;\n@@ -9247,6 +9250,7 @@ package body Exp_Ch6 is\n    ----------------------------\n \n    function Needs_BIP_Task_Actuals (Func_Id : Entity_Id) return Boolean is\n+      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n       Subp_Id  : Entity_Id;\n       Func_Typ : Entity_Id;\n \n@@ -9271,20 +9275,14 @@ package body Exp_Ch6 is\n \n       Func_Typ := Underlying_Type (Etype (Subp_Id));\n \n-      --  Functions returning types with foreign convention don't have extra\n-      --  formals.\n-\n-      if Has_Foreign_Convention (Func_Typ) then\n-         return False;\n-\n       --  At first sight, for all the following cases, we could add assertions\n       --  to ensure that if Func_Id is frozen then the computed result matches\n       --  with the availability of the task master extra formal; unfortunately\n       --  this is not feasible because we may be precisely freezing this entity\n       --  (that is, Is_Frozen has been set by Freeze_Entity but it has not\n       --  completed its work).\n \n-      elsif Has_Task (Func_Typ) then\n+      if Has_Task (Func_Typ) then\n          return True;\n \n       elsif Ekind (Func_Id) = E_Function then\n@@ -9316,6 +9314,8 @@ package body Exp_Ch6 is\n       Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n \n    begin\n+      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n+\n       --  A formal giving the finalization master is needed for build-in-place\n       --  functions whose result type needs finalization or is a tagged type.\n       --  Tagged primitive build-in-place functions need such a formal because\n@@ -9327,8 +9327,7 @@ package body Exp_Ch6 is\n       --  such build-in-place functions, primitive or not.\n \n       return not Restriction_Active (No_Finalization)\n-        and then (Needs_Finalization (Typ) or else Is_Tagged_Type (Typ))\n-        and then not Has_Foreign_Convention (Typ);\n+        and then (Needs_Finalization (Typ) or else Is_Tagged_Type (Typ));\n    end Needs_BIP_Finalization_Master;\n \n    --------------------------\n@@ -9339,6 +9338,8 @@ package body Exp_Ch6 is\n       Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n \n    begin\n+      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n+\n       --  A formal giving the allocation method is needed for build-in-place\n       --  functions whose result type is returned on the secondary stack or\n       --  is a tagged type. Tagged primitive build-in-place functions need\n@@ -9350,8 +9351,7 @@ package body Exp_Ch6 is\n       --  to be passed to all such build-in-place functions, primitive or not.\n \n       return not Restriction_Active (No_Secondary_Stack)\n-        and then (Needs_Secondary_Stack (Typ) or else Is_Tagged_Type (Typ))\n-        and then not Has_Foreign_Convention (Typ);\n+        and then (Needs_Secondary_Stack (Typ) or else Is_Tagged_Type (Typ));\n    end Needs_BIP_Alloc_Form;\n \n    -------------------------------------"}, {"sha": "19d0bc3ff694fb829c9773189d80561fa42abd8d", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -121,18 +121,6 @@ package Exp_Ch6 is\n    --  The returned node is the root of the procedure body which will replace\n    --  the original function body, which is not needed for the C program.\n \n-   function Has_BIP_Extra_Formal\n-     (E              : Entity_Id;\n-      Kind           : BIP_Formal_Kind;\n-      Must_Be_Frozen : Boolean := True) return Boolean;\n-   --  Given a subprogram, subprogram type, entry or entry family, return True\n-   --  if E has the BIP extra formal associated with Kind. In general this\n-   --  subprogram must be invoked with a frozen entity or a subprogram type of\n-   --  a dispatching call since we can only rely on the availability of extra\n-   --  formals on these entities; this requirement can be relaxed using the\n-   --  formal Must_Be_Frozen in scenarios where we know that the entity has\n-   --  the extra formals.\n-\n    procedure Install_Class_Preconditions_Check (Call_Node : Node_Id);\n    --  Install check of class-wide preconditions on the caller.\n "}, {"sha": "52858e23b333b5670aa4d0c21019c9a3c9a1e669", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 86, "deletions": 17, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -4979,7 +4979,6 @@ package body Freeze is\n               and then Convention (Desig) /= Convention_Protected\n             then\n                Set_Is_Frozen (Desig);\n-               Create_Extra_Formals (Desig);\n             end if;\n          end Check_Itype;\n \n@@ -8238,7 +8237,7 @@ package body Freeze is\n             if Present (Nam)\n               and then Ekind (Nam) = E_Function\n               and then Nkind (Parent (N)) = N_Function_Call\n-              and then not Has_Foreign_Convention (Nam)\n+              and then Convention (Nam) = Convention_Ada\n             then\n                Create_Extra_Formals (Nam);\n             end if;\n@@ -9845,11 +9844,77 @@ package body Freeze is\n    -----------------------\n \n    procedure Freeze_Subprogram (E : Entity_Id) is\n+      function Check_Extra_Formals (E : Entity_Id) return Boolean;\n+      --  Return True if the decoration of the attributes associated with extra\n+      --  formals are properly set.\n \n       procedure Set_Profile_Convention (Subp_Id : Entity_Id);\n       --  Set the conventions of all anonymous access-to-subprogram formals and\n       --  result subtype of subprogram Subp_Id to the convention of Subp_Id.\n \n+      -------------------------\n+      -- Check_Extra_Formals --\n+      -------------------------\n+\n+      function Check_Extra_Formals (E : Entity_Id) return Boolean is\n+         Last_Formal       : Entity_Id := Empty;\n+         Formal            : Entity_Id;\n+         Has_Extra_Formals : Boolean := False;\n+\n+      begin\n+         --  No check required if expansion is disabled because extra\n+         --  formals are only generated when we are generating code.\n+         --  See Create_Extra_Formals.\n+\n+         if not Expander_Active then\n+            return True;\n+         end if;\n+\n+         --  Check attribute Extra_Formal: If available, it must be set only\n+         --  on the last formal of E.\n+\n+         Formal := First_Formal (E);\n+         while Present (Formal) loop\n+            if Present (Extra_Formal (Formal)) then\n+               if Has_Extra_Formals then\n+                  return False;\n+               end if;\n+\n+               Has_Extra_Formals := True;\n+            end if;\n+\n+            Last_Formal := Formal;\n+            Next_Formal (Formal);\n+         end loop;\n+\n+         --  Check attribute Extra_Accessibility_Of_Result\n+\n+         if Ekind (E) in E_Function | E_Subprogram_Type\n+           and then Needs_Result_Accessibility_Level (E)\n+           and then No (Extra_Accessibility_Of_Result (E))\n+         then\n+            return False;\n+         end if;\n+\n+         --  Check attribute Extra_Formals: If E has extra formals, then this\n+         --  attribute must point to the first extra formal of E.\n+\n+         if Has_Extra_Formals then\n+            return Present (Extra_Formals (E))\n+              and then Present (Extra_Formal (Last_Formal))\n+              and then Extra_Formal (Last_Formal) = Extra_Formals (E);\n+\n+         --  When E has no formals, the first extra formal is available through\n+         --  the Extra_Formals attribute.\n+\n+         elsif Present (Extra_Formals (E)) then\n+            return No (First_Formal (E));\n+\n+         else\n+            return True;\n+         end if;\n+      end Check_Extra_Formals;\n+\n       ----------------------------\n       -- Set_Profile_Convention --\n       ----------------------------\n@@ -9988,26 +10053,30 @@ package body Freeze is\n       --  that we know the convention.\n \n       if not Has_Foreign_Convention (E) then\n+         if No (Extra_Formals (E)) then\n \n-         --  Extra formals of dispatching operations are added later by\n-         --  Expand_Freeze_Record_Type, which also adds extra formals to\n-         --  internal entities built to handle interface types.\n+            --  Extra formals are shared by derived subprograms; therefore, if\n+            --  the ultimate alias of E has been frozen before E then the extra\n+            --  formals have been added, but the attribute Extra_Formals is\n+            --  still unset (and must be set now).\n \n-         if not Is_Dispatching_Operation (E) then\n-            Create_Extra_Formals (E);\n+            if Present (Alias (E))\n+              and then Is_Frozen (Ultimate_Alias (E))\n+              and then Present (Extra_Formals (Ultimate_Alias (E)))\n+              and then Last_Formal (Ultimate_Alias (E)) = Last_Formal (E)\n+            then\n+               Set_Extra_Formals (E, Extra_Formals (Ultimate_Alias (E)));\n \n-            pragma Assert\n-              ((Ekind (E) = E_Subprogram_Type\n-                  and then Extra_Formals_OK (E))\n-               or else\n-                 (Is_Subprogram (E)\n-                   and then Extra_Formals_OK (E)\n-                   and then\n-                     (No (Overridden_Operation (E))\n-                       or else Extra_Formals_Match_OK (E,\n-                                 Ultimate_Alias (Overridden_Operation (E))))));\n+               if Ekind (E) = E_Function then\n+                  Set_Extra_Accessibility_Of_Result (E,\n+                    Extra_Accessibility_Of_Result (Ultimate_Alias (E)));\n+               end if;\n+            else\n+               Create_Extra_Formals (E);\n+            end if;\n          end if;\n \n+         pragma Assert (Check_Extra_Formals (E));\n          Set_Mechanisms (E);\n \n          --  If this is convention Ada and a Valued_Procedure, that's odd"}, {"sha": "00c2e67fa20dd5558df6dd8e511b76347be1d381", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -1318,8 +1318,7 @@ package body Sem_Ch3 is\n \n       Check_Restriction (No_Access_Subprograms, T_Def);\n \n-      --  Addition of extra formals must be delayed till the freeze point so\n-      --  that we know the convention.\n+      Create_Extra_Formals (Desig_Type);\n    end Access_Subprogram_Declaration;\n \n    ----------------------------\n@@ -11769,9 +11768,11 @@ package body Sem_Ch3 is\n          Insert_Before (Typ_Decl, Decl);\n          Analyze (Decl);\n \n-         --  At first sight we could add here the extra formals of an access to\n-         --  subprogram; however, it must delayed till the freeze point so that\n-         --  we know the convention.\n+         --  If an access to subprogram, create the extra formals\n+\n+         if Present (Acc_Def) then\n+            Create_Extra_Formals (Designated_Type (Anon_Access));\n+         end if;\n \n          if Nkind (Comp_Def) = N_Component_Definition then\n             Rewrite (Comp_Def,\n@@ -16032,12 +16033,12 @@ package body Sem_Ch3 is\n          Next_Formal (Formal);\n       end loop;\n \n-      --  Extra formals are shared between the parent subprogram and this\n-      --  internal entity built by Derive_Subprogram (implicit in the above\n-      --  copy of formals), unless the parent type is a limited interface type;\n-      --  hence we must inherit also the reference to the first extra formal.\n-      --  When the parent type is an interface, the extra formals will be added\n-      --  when the tagged type is frozen (see Expand_Freeze_Record_Type).\n+      --  Extra formals are shared between the parent subprogram and the\n+      --  derived subprogram (implicit in the above copy of formals), unless\n+      --  the parent type is a limited interface type; hence we must inherit\n+      --  also the reference to the first extra formal. When the parent type is\n+      --  an interface the extra formals will be added when the subprogram is\n+      --  frozen (see Freeze.Freeze_Subprogram).\n \n       if not Is_Limited_Interface (Parent_Type) then\n          Set_Extra_Formals (New_Subp, Extra_Formals (Parent_Subp));"}, {"sha": "c92e69139bebe38e94761abc8b1672f020bb536f", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 279, "deletions": 903, "changes": 1182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -34,7 +34,6 @@ with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n with Errout;         use Errout;\n with Expander;       use Expander;\n-with Exp_Ch3;        use Exp_Ch3;\n with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch9;        use Exp_Ch9;\n with Exp_Dbug;       use Exp_Dbug;\n@@ -201,13 +200,6 @@ package body Sem_Ch6 is\n    --  This procedure makes S, a new overloaded entity, into the first visible\n    --  entity with that name.\n \n-   function Has_Reliable_Extra_Formals (E : Entity_Id) return Boolean;\n-   --  E is the entity for a subprogram spec. Returns False for abstract\n-   --  predefined dispatching primitives of Root_Controlled since they\n-   --  cannot have extra formals (this is required to build the runtime);\n-   --  it also returns False for predefined stream dispatching operations\n-   --  not emitted by the frontend. Otherwise returns True.\n-\n    function Is_Non_Overriding_Operation\n      (Prev_E : Entity_Id;\n       New_E  : Entity_Id) return Boolean;\n@@ -3357,8 +3349,7 @@ package body Sem_Ch6 is\n                       or else\n                         (Is_Class_Wide_Type (Designated_Type (Etype (Scop)))\n                            and then\n-                         Is_Limited_Record\n-                           (Etype (Designated_Type (Etype (Scop))))))\n+                         Is_Limited_Record (Designated_Type (Etype (Scop)))))\n            and then Expander_Active\n          then\n             Decl := Build_Master_Declaration (Loc);\n@@ -8477,253 +8468,6 @@ package body Sem_Ch6 is\n         (New_Id, Old_Id, Type_Conformant, True, Result, Err_Loc);\n    end Check_Type_Conformant;\n \n-   -----------------------------\n-   -- Check_Untagged_Equality --\n-   -----------------------------\n-\n-   procedure Check_Untagged_Equality (Eq_Op : Entity_Id) is\n-      Eq_Decl : constant Node_Id   := Unit_Declaration_Node (Eq_Op);\n-      Typ     : constant Entity_Id := Etype (First_Formal (Eq_Op));\n-\n-      procedure Freezing_Point_Warning (N : Node_Id; S : String);\n-      --  Output a warning about the freezing point N of Typ\n-\n-      function Is_Actual_Of_Instantiation\n-        (E    : Entity_Id;\n-         Inst : Node_Id) return Boolean;\n-      --  Return True if E is an actual parameter of instantiation Inst\n-\n-      -----------------------------------\n-      -- Output_Freezing_Point_Warning --\n-      -----------------------------------\n-\n-      procedure Freezing_Point_Warning (N : Node_Id; S : String) is\n-      begin\n-         Error_Msg_String (1 .. S'Length) := S;\n-         Error_Msg_Strlen := S'Length;\n-\n-         if Ada_Version >= Ada_2012 then\n-            Error_Msg_NE (\"type& is frozen by ~??\", N, Typ);\n-            Error_Msg_N\n-              (\"\\an equality operator cannot be declared after this point??\",\n-               N);\n-\n-         else\n-            Error_Msg_NE (\"type& is frozen by ~ (Ada 2012)?y?\", N, Typ);\n-            Error_Msg_N\n-              (\"\\an equality operator cannot be declared after this point\"\n-               & \" (Ada 2012)?y?\", N);\n-         end if;\n-      end Freezing_Point_Warning;\n-\n-      --------------------------------\n-      -- Is_Actual_Of_Instantiation --\n-      --------------------------------\n-\n-      function Is_Actual_Of_Instantiation\n-        (E    : Entity_Id;\n-         Inst : Node_Id) return Boolean\n-      is\n-         Assoc : Node_Id;\n-\n-      begin\n-         if Present (Generic_Associations (Inst)) then\n-            Assoc := First (Generic_Associations (Inst));\n-\n-            while Present (Assoc) loop\n-               if Present (Explicit_Generic_Actual_Parameter (Assoc))\n-                 and then\n-                   Is_Entity_Name (Explicit_Generic_Actual_Parameter (Assoc))\n-                 and then\n-                   Entity (Explicit_Generic_Actual_Parameter (Assoc)) = E\n-               then\n-                  return True;\n-               end if;\n-\n-               Next (Assoc);\n-            end loop;\n-         end if;\n-\n-         return False;\n-      end Is_Actual_Of_Instantiation;\n-\n-      --  Local variable\n-\n-      Decl : Node_Id;\n-\n-   --  Start of processing for Check_Untagged_Equality\n-\n-   begin\n-      --  This check applies only if we have a subprogram declaration or a\n-      --  subprogram body that is not a completion, for an untagged record\n-      --  type, and that is conformant with the predefined operator.\n-\n-      if (Nkind (Eq_Decl) /= N_Subprogram_Declaration\n-           and then not (Nkind (Eq_Decl) = N_Subprogram_Body\n-                          and then Acts_As_Spec (Eq_Decl)))\n-        or else not Is_Record_Type (Typ)\n-        or else Is_Tagged_Type (Typ)\n-        or else not Is_User_Defined_Equality (Eq_Op)\n-      then\n-         return;\n-      end if;\n-\n-      --  In Ada 2012 case, we will output errors or warnings depending on\n-      --  the setting of debug flag -gnatd.E.\n-\n-      if Ada_Version >= Ada_2012 then\n-         Error_Msg_Warn := Debug_Flag_Dot_EE;\n-\n-      --  In earlier versions of Ada, nothing to do unless we are warning on\n-      --  Ada 2012 incompatibilities (Warn_On_Ada_2012_Incompatibility set).\n-\n-      else\n-         if not Warn_On_Ada_2012_Compatibility then\n-            return;\n-         end if;\n-      end if;\n-\n-      --  Cases where the type has already been frozen\n-\n-      if Is_Frozen (Typ) then\n-\n-         --  The check applies to a primitive operation, so check that type\n-         --  and equality operation are in the same scope.\n-\n-         if Scope (Typ) /= Current_Scope then\n-            return;\n-\n-         --  If the type is a generic actual (sub)type, the operation is not\n-         --  primitive either because the base type is declared elsewhere.\n-\n-         elsif Is_Generic_Actual_Type (Typ) then\n-            return;\n-\n-         --  Here we may have an error of declaration after freezing, but we\n-         --  must make sure not to flag the equality operator itself causing\n-         --  the freezing when it is a subprogram body.\n-\n-         else\n-            Decl := Next (Declaration_Node (Typ));\n-\n-            while Present (Decl) and then Decl /= Eq_Decl loop\n-\n-               --  The declaration of an object of the type\n-\n-               if Nkind (Decl) = N_Object_Declaration\n-                 and then Etype (Defining_Identifier (Decl)) = Typ\n-               then\n-                  Freezing_Point_Warning (Decl, \"declaration\");\n-                  exit;\n-\n-               --  The instantiation of a generic on the type\n-\n-               elsif Nkind (Decl) in N_Generic_Instantiation\n-                 and then Is_Actual_Of_Instantiation (Typ, Decl)\n-               then\n-                  Freezing_Point_Warning (Decl, \"instantiation\");\n-                  exit;\n-\n-               --  A noninstance proper body, body stub or entry body\n-\n-               elsif Nkind (Decl) in N_Proper_Body\n-                                   | N_Body_Stub\n-                                   | N_Entry_Body\n-                 and then not Is_Generic_Instance (Defining_Entity (Decl))\n-               then\n-                  Freezing_Point_Warning (Decl, \"body\");\n-                  exit;\n-\n-               --  If we have reached the freeze node and immediately after we\n-               --  have the body or generated code for the body, then it is the\n-               --  body that caused the freezing and this is legal.\n-\n-               elsif Nkind (Decl) = N_Freeze_Entity\n-                 and then Entity (Decl) = Typ\n-                 and then (Next (Decl) = Eq_Decl\n-                            or else\n-                           Sloc (Next (Decl)) = Sloc (Eq_Decl))\n-               then\n-                  return;\n-               end if;\n-\n-               Next (Decl);\n-            end loop;\n-\n-            --  Here we have a definite error of declaration after freezing\n-\n-            if Ada_Version >= Ada_2012 then\n-               Error_Msg_NE\n-                 (\"equality operator must be declared before type & is \"\n-                  & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)<<\", Eq_Op, Typ);\n-\n-               --  In Ada 2012 mode with error turned to warning, output one\n-               --  more warning to warn that the equality operation may not\n-               --  compose. This is the consequence of ignoring the error.\n-\n-               if Error_Msg_Warn then\n-                  Error_Msg_N (\"\\equality operation may not compose??\", Eq_Op);\n-               end if;\n-\n-            else\n-               Error_Msg_NE\n-                 (\"equality operator must be declared before type& is \"\n-                  & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)?y?\", Eq_Op, Typ);\n-            end if;\n-\n-            --  If we have found no freezing point and the declaration of the\n-            --  operator could not be reached from that of the type and we are\n-            --  in a package body, this must be because the type is declared\n-            --  in the spec of the package. Add a message tailored to this.\n-\n-            if No (Decl) and then In_Package_Body (Scope (Typ)) then\n-               if Ada_Version >= Ada_2012 then\n-                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n-                     Error_Msg_N\n-                       (\"\\put declaration in package spec<<\", Eq_Op);\n-                  else\n-                     Error_Msg_N\n-                       (\"\\move declaration to package spec<<\", Eq_Op);\n-                  end if;\n-\n-               else\n-                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n-                     Error_Msg_N\n-                       (\"\\put declaration in package spec (Ada 2012)?y?\",\n-                        Eq_Op);\n-                  else\n-                     Error_Msg_N\n-                       (\"\\move declaration to package spec (Ada 2012)?y?\",\n-                        Eq_Op);\n-                  end if;\n-               end if;\n-            end if;\n-         end if;\n-\n-      --  Now check for AI12-0352: the declaration of a user-defined primitive\n-      --  equality operation for a record type T is illegal if it occurs after\n-      --  a type has been derived from T.\n-\n-      else\n-         Decl := Next (Declaration_Node (Typ));\n-\n-         while Present (Decl) and then Decl /= Eq_Decl loop\n-            if Nkind (Decl) = N_Full_Type_Declaration\n-              and then Etype (Defining_Identifier (Decl)) = Typ\n-            then\n-               Error_Msg_N\n-                 (\"equality operator cannot appear after derivation\", Eq_Op);\n-               Error_Msg_NE\n-                 (\"an equality operator for& cannot be declared after \"\n-                  & \"this point??\",\n-                  Decl, Typ);\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n-      end if;\n-   end Check_Untagged_Equality;\n-\n    ---------------------------\n    -- Can_Override_Operator --\n    ---------------------------\n@@ -9203,29 +8947,6 @@ package body Sem_Ch6 is\n       --  BIP_xxx denotes an extra formal for a build-in-place function. See\n       --  the full list in exp_ch6.BIP_Formal_Kind.\n \n-      function Has_BIP_Formals (E : Entity_Id) return Boolean;\n-      --  Determines if a given entity has build-in-place formals\n-\n-      function Has_Extra_Formals (E : Entity_Id) return Boolean;\n-      --  Determines if E has its extra formals\n-\n-      function Needs_Accessibility_Check_Extra\n-        (E      : Entity_Id;\n-         Formal : Node_Id) return Boolean;\n-      --  Determines whether the given formal of E needs an extra formal for\n-      --  supporting accessibility checking. Returns True for both anonymous\n-      --  access formals and formals of named access types that are marked as\n-      --  controlling formals. The latter case can occur when the subprogram\n-      --  Expand_Dispatching_Call creates a subprogram-type and substitutes\n-      --  the types of access-to-class-wide actuals for the anonymous access-\n-      --  to-specific-type of controlling formals.\n-\n-      function Parent_Subprogram (Subp_Id : Entity_Id) return Entity_Id;\n-      --  Subp_Id is a subprogram of a derived type; return its parent\n-      --  subprogram if Subp_Id overrides a parent primitive or derives\n-      --  from a parent primitive, and such parent primitive can have extra\n-      --  formals. Otherwise return Empty.\n-\n       ----------------------\n       -- Add_Extra_Formal --\n       ----------------------\n@@ -9236,7 +8957,10 @@ package body Sem_Ch6 is\n          Scope        : Entity_Id;\n          Suffix       : String) return Entity_Id\n       is\n-         EF : Entity_Id;\n+         EF : constant Entity_Id :=\n+                Make_Defining_Identifier (Sloc (Assoc_Entity),\n+                  Chars  => New_External_Name (Chars (Assoc_Entity),\n+                                               Suffix => Suffix));\n \n       begin\n          --  A little optimization. Never generate an extra formal for the\n@@ -9247,10 +8971,6 @@ package body Sem_Ch6 is\n             return Empty;\n          end if;\n \n-         EF := Make_Defining_Identifier (Sloc (Assoc_Entity),\n-                 Chars => New_External_Name (Chars (Assoc_Entity),\n-                                             Suffix => Suffix));\n-\n          Mutate_Ekind        (EF, E_In_Parameter);\n          Set_Actual_Subtype  (EF, Typ);\n          Set_Etype           (EF, Typ);\n@@ -9272,280 +8992,49 @@ package body Sem_Ch6 is\n          return EF;\n       end Add_Extra_Formal;\n \n-      ---------------------\n-      -- Has_BIP_Formals --\n-      ---------------------\n+      --  Local variables\n \n-      function Has_BIP_Formals (E : Entity_Id) return Boolean is\n-         Formal : Entity_Id := First_Formal_With_Extras (E);\n-\n-      begin\n-         while Present (Formal) loop\n-            if Is_Build_In_Place_Entity (Formal) then\n-               return True;\n-            end if;\n-\n-            Next_Formal_With_Extras (Formal);\n-         end loop;\n-\n-         return False;\n-      end Has_BIP_Formals;\n-\n-      -----------------------\n-      -- Has_Extra_Formals --\n-      -----------------------\n-\n-      function Has_Extra_Formals (E : Entity_Id) return Boolean is\n-      begin\n-         return Present (Extra_Formals (E))\n-           or else\n-             (Ekind (E) = E_Function\n-                and then Present (Extra_Accessibility_Of_Result (E)));\n-      end Has_Extra_Formals;\n-\n-      -------------------------------------\n-      -- Needs_Accessibility_Check_Extra --\n-      -------------------------------------\n-\n-      function Needs_Accessibility_Check_Extra\n-        (E      : Entity_Id;\n-         Formal : Node_Id) return Boolean is\n-\n-      begin\n-         --  For dispatching operations this extra formal is not suppressed\n-         --  since all the derivations must have matching formals.\n-\n-         --  For non-dispatching operations it is suppressed if we specifically\n-         --  suppress accessibility checks at the package level for either the\n-         --  subprogram, or the package in which it resides. However, we do\n-         --  not suppress it simply if the scope has accessibility checks\n-         --  suppressed, since this could cause trouble when clients are\n-         --  compiled with a different suppression setting. The explicit checks\n-         --  at the package level are safe from this point of view.\n-\n-         if not Is_Dispatching_Operation (E)\n-           and then\n-             (Explicit_Suppress (E, Accessibility_Check)\n-                or else Explicit_Suppress (Scope (E), Accessibility_Check))\n-         then\n-            return False;\n-         end if;\n-\n-         --  Base_Type is applied to handle cases where there is a null\n-         --  exclusion the formal may have an access subtype.\n-\n-         return\n-           Ekind (Base_Type (Etype (Formal))) = E_Anonymous_Access_Type\n-             or else\n-               (Is_Controlling_Formal (Formal)\n-                  and then Is_Access_Type (Base_Type (Etype (Formal))));\n-      end Needs_Accessibility_Check_Extra;\n-\n-      -----------------------\n-      -- Parent_Subprogram --\n-      -----------------------\n-\n-      function Parent_Subprogram (Subp_Id : Entity_Id) return Entity_Id is\n-         pragma Assert (not Is_Thunk (Subp_Id));\n-         Ovr_E     : Entity_Id := Overridden_Operation (Subp_Id);\n-         Ovr_Alias : Entity_Id;\n-\n-      begin\n-         if Present (Ovr_E) then\n-            Ovr_Alias := Ultimate_Alias (Ovr_E);\n-\n-            --  There is no real overridden subprogram if there is a mutual\n-            --  reference between the E and its overridden operation. This\n-            --  weird scenery occurs in the following cases:\n-\n-            --  1) Controlling function wrappers internally built by\n-            --     Make_Controlling_Function_Wrappers.\n-\n-            --  2) Hidden overridden primitives of type extensions or private\n-            --     extensions (cf. Find_Hidden_Overridden_Primitive). These\n-            --     hidden primitives have suffix 'P'.\n-\n-            --  3) Overridding primitives of stub types (see the subprogram\n-            --     Add_RACW_Primitive_Declarations_And_Bodies).\n-\n-            if Ovr_Alias = Subp_Id then\n-               pragma Assert\n-                 ((Is_Wrapper (Subp_Id)\n-                     and then Has_Controlling_Result (Subp_Id))\n-                   or else Has_Suffix (Ovr_E, 'P')\n-                   or else Is_RACW_Stub_Type\n-                             (Find_Dispatching_Type (Subp_Id)));\n-\n-               if Present (Overridden_Operation (Ovr_E)) then\n-                  Ovr_E := Overridden_Operation (Ovr_E);\n-\n-               --  Ovr_E is an internal entity built by Derive_Subprogram and\n-               --  we have no direct way to climb to the corresponding parent\n-               --  subprogram but this internal entity has the extra formals\n-               --  (if any) required for the purpose of checking the extra\n-               --  formals of Subp_Id.\n-\n-               else\n-                  pragma Assert (not Comes_From_Source (Ovr_E));\n-               end if;\n-\n-            --  Use as our reference entity the ultimate renaming of the\n-            --  overriddden subprogram.\n-\n-            elsif Present (Alias (Ovr_E)) then\n-               pragma Assert (No (Overridden_Operation (Ovr_Alias))\n-                 or else Overridden_Operation (Ovr_Alias) /= Ovr_E);\n-\n-               Ovr_E := Ovr_Alias;\n-            end if;\n-         end if;\n-\n-         if Present (Ovr_E) and then Has_Reliable_Extra_Formals (Ovr_E) then\n-            return Ovr_E;\n-         else\n-            return Empty;\n-         end if;\n-      end Parent_Subprogram;\n-\n-      --  Local variables\n-\n-      Formal_Type      : Entity_Id;\n-      May_Have_Alias   : Boolean;\n-      Alias_Formal     : Entity_Id := Empty;\n-      Alias_Subp       : Entity_Id := Empty;\n-      Parent_Formal    : Entity_Id := Empty;\n-      Parent_Subp      : Entity_Id := Empty;\n-      Ref_E            : Entity_Id;\n+      Formal_Type : Entity_Id;\n+      P_Formal    : Entity_Id;\n \n    --  Start of processing for Create_Extra_Formals\n \n    begin\n-      pragma Assert (Is_Subprogram_Or_Entry (E)\n-        or else Ekind (E) in E_Subprogram_Type);\n-\n       --  We never generate extra formals if expansion is not active because we\n       --  don't need them unless we are generating code.\n \n       if not Expander_Active then\n          return;\n-\n-      --  Enumeration literals have no extra formal; this case occurs when\n-      --  a function renames it.\n-\n-      elsif Ekind (E) = E_Function\n-        and then Ekind (Ultimate_Alias (E)) = E_Enumeration_Literal\n-      then\n-         return;\n+      end if;\n \n       --  No need to generate extra formals in thunks whose target has no extra\n       --  formals, but we can have two of them chained (interface and stack).\n \n-      elsif Is_Thunk (E) and then No (Extra_Formals (Thunk_Target (E))) then\n-         return;\n-\n-      --  If Extra_Formals were already created, don't do it again. This\n-      --  situation may arise for subprogram types created as part of\n-      --  dispatching calls (see Expand_Dispatching_Call).\n-\n-      elsif Has_Extra_Formals (E) then\n+      if Is_Thunk (E) and then No (Extra_Formals (Thunk_Target (E))) then\n          return;\n+      end if;\n \n-      --  Extra formals of renamings of generic actual subprograms and\n-      --  renamings of instances of generic subprograms are shared. The\n-      --  check performed on the last formal is required to ensure that\n-      --  this is the renaming built by Analyze_Instance_And_Renamings\n-      --  (which shares all the formals); otherwise this would be wrong.\n-\n-      elsif Ekind (E) in E_Function | E_Procedure\n-        and then Is_Generic_Instance (E)\n-        and then Present (Alias (E))\n-        and then Last_Formal (Ultimate_Alias (E)) = Last_Formal (E)\n-      then\n-         pragma Assert (Is_Generic_Instance (E)\n-           = Is_Generic_Instance (Ultimate_Alias (E)));\n-\n-         Create_Extra_Formals (Ultimate_Alias (E));\n-\n-         --  Share the extra formals\n-\n-         Set_Extra_Formals (E, Extra_Formals (Ultimate_Alias (E)));\n-\n-         if Ekind (E) = E_Function then\n-            Set_Extra_Accessibility_Of_Result (E,\n-              Extra_Accessibility_Of_Result (Ultimate_Alias (E)));\n-         end if;\n+      --  If this is a derived subprogram then the subtypes of the parent\n+      --  subprogram's formal parameters will be used to determine the need\n+      --  for extra formals.\n \n-         pragma Assert (Extra_Formals_OK (E));\n-         return;\n+      if Is_Overloadable (E) and then Present (Alias (E)) then\n+         P_Formal := First_Formal (Alias (E));\n+      else\n+         P_Formal := Empty;\n       end if;\n \n-      --  Locate the last formal; required by Add_Extra_Formal.\n-\n       Formal := First_Formal (E);\n       while Present (Formal) loop\n          Last_Extra := Formal;\n          Next_Formal (Formal);\n       end loop;\n \n-      --  We rely on three entities to ensure consistency of extra formals of\n-      --  entity E:\n-      --\n-      --    1. A reference entity (Ref_E). For thunks it is their target\n-      --       primitive since this ensures that they have exactly the\n-      --       same extra formals; otherwise it is the identity.\n-      --\n-      --    2. The parent subprogram; only for derived types and references\n-      --       either the overridden subprogram or the internal entity built\n-      --       by Derive_Subprogram that has the extra formals of the parent\n-      --       subprogram; otherwise it is Empty. This entity ensures matching\n-      --       extra formals in derived types.\n-      --\n-      --    3. For renamings, their ultimate alias; this ensures taking the\n-      --       same decision in all the renamings (independently of the Ada\n-      --       mode on which they are compiled). For example:\n-      --\n-      --          pragma Ada_2012;\n-      --          function Id_A (I : access Integer) return access Integer;\n-      --\n-      --          pragma Ada_2005;\n-      --          function Id_B (I : access Integer) return access Integer\n-      --             renames Id_A;\n-\n-      if Is_Thunk (E) then\n-         Ref_E := Thunk_Target (E);\n-      else\n-         Ref_E := E;\n-      end if;\n-\n-      if Is_Subprogram (Ref_E) then\n-         Parent_Subp := Parent_Subprogram (Ref_E);\n-      end if;\n-\n-      May_Have_Alias :=\n-        (Is_Subprogram (Ref_E) or else Ekind (Ref_E) = E_Subprogram_Type);\n-\n-      --  If the parent subprogram is available then its ultimate alias of\n-      --  Ref_E is not needed since it will not be used to check its extra\n-      --  formals.\n-\n-      if No (Parent_Subp)\n-        and then May_Have_Alias\n-        and then Present (Alias (Ref_E))\n-        and then Has_Reliable_Extra_Formals (Ultimate_Alias (Ref_E))\n-      then\n-         Alias_Subp := Ultimate_Alias (Ref_E);\n-      end if;\n-\n-      --  Cannot add extra formals to subprograms and access types that have\n-      --  foreign convention nor to subprograms overriding primitives that\n-      --  have foreign convention since the foreign language does not know\n-      --  how to handle these extra formals; same for renamings of entities\n-      --  with foreign convention.\n+      --  If Extra_Formals were already created, don't do it again. This\n+      --  situation may arise for subprogram types created as part of\n+      --  dispatching calls (see Expand_Dispatching_Call).\n \n-      if Has_Foreign_Convention (Ref_E)\n-        or else (Present (Alias_Subp)\n-                   and then Has_Foreign_Convention (Alias_Subp))\n-      then\n+      if Present (Last_Extra) and then Present (Extra_Formal (Last_Extra)) then\n          return;\n       end if;\n \n@@ -9560,74 +9049,20 @@ package body Sem_Ch6 is\n          goto Test_For_Func_Result_Extras;\n       end if;\n \n-      --  Process the formals relying on the formals of our reference entities:\n-      --  Parent_Formal, Alias_Formal and Formal. Notice that we don't use the\n-      --  formal of Ref_E; we must use the formal of E which is the entity to\n-      --  which we are adding the extra formals.\n-\n-      --  If this is a derived subprogram then the subtypes of the parent\n-      --  subprogram's formal parameters will be used to determine the need\n-      --  for extra formals.\n-\n-      if Present (Parent_Subp) then\n-         Parent_Formal := First_Formal (Parent_Subp);\n-\n-         --  For concurrent types, the controlling argument of a dispatching\n-         --  primitive implementing an interface primitive is implicit. For\n-         --  example:\n-         --\n-         --     type Iface is protected interface;\n-         --     function Prim\n-         --       (Obj   : Iface;\n-         --        Value : Integer) return Natural is abstract;\n-         --\n-         --     protected type PO is new Iface with\n-         --        function Prim (Value : Integer) return Natural;\n-         --     end PO;\n-\n-         if Convention (Ref_E) = Convention_Protected\n-           and then Is_Abstract_Subprogram (Parent_Subp)\n-           and then Is_Interface (Find_Dispatching_Type (Parent_Subp))\n-         then\n-            Parent_Formal := Next_Formal (Parent_Formal);\n-\n-            --  This is the non-dispatching subprogram of a concurrent type\n-            --  that overrides the interface primitive; the expander will\n-            --  create the dispatching primitive (without Convention_Protected)\n-            --  with all the matching formals (see exp_ch9.Build_Wrapper_Specs)\n-\n-            pragma Assert (not Is_Dispatching_Operation (Ref_E));\n-         end if;\n-\n-      --  Ensure that the ultimate alias has all its extra formals\n-\n-      elsif Present (Alias_Subp) then\n-         Create_Extra_Formals (Alias_Subp);\n-         Alias_Formal := First_Formal (Alias_Subp);\n-      end if;\n-\n       Formal := First_Formal (E);\n       while Present (Formal) loop\n \n-         --  Here we establish our priority for deciding on the extra\n-         --  formals: 1) Parent primitive 2) Aliased primitive 3) Identity\n-\n-         if Present (Parent_Formal) then\n-            Formal_Type := Etype (Parent_Formal);\n-\n-         elsif Present (Alias_Formal) then\n-            Formal_Type := Etype (Alias_Formal);\n-\n-         else\n-            Formal_Type := Etype (Formal);\n-         end if;\n-\n          --  Create extra formal for supporting the attribute 'Constrained.\n          --  The case of a private type view without discriminants also\n          --  requires the extra formal if the underlying type has defaulted\n          --  discriminants.\n \n          if Ekind (Formal) /= E_In_Parameter then\n+            if Present (P_Formal) then\n+               Formal_Type := Etype (P_Formal);\n+            else\n+               Formal_Type := Etype (Formal);\n+            end if;\n \n             --  Do not produce extra formals for Unchecked_Union parameters.\n             --  Jump directly to the end of the loop.\n@@ -9672,83 +9107,66 @@ package body Sem_Ch6 is\n             end if;\n          end if;\n \n-         --  Extra formal for supporting accessibility checking\n-\n-         if Needs_Accessibility_Check_Extra (Ref_E, Formal) then\n-            pragma Assert (No (Parent_Formal)\n-              or else Present (Extra_Accessibility (Parent_Formal)));\n-            pragma Assert (No (Alias_Formal)\n-              or else Present (Extra_Accessibility (Alias_Formal)));\n+         --  Create extra formal for supporting accessibility checking. This\n+         --  is done for both anonymous access formals and formals of named\n+         --  access types that are marked as controlling formals. The latter\n+         --  case can occur when Expand_Dispatching_Call creates a subprogram\n+         --  type and substitutes the types of access-to-class-wide actuals\n+         --  for the anonymous access-to-specific-type of controlling formals.\n+         --  Base_Type is applied because in cases where there is a null\n+         --  exclusion the formal may have an access subtype.\n \n+         --  This is suppressed if we specifically suppress accessibility\n+         --  checks at the package level for either the subprogram, or the\n+         --  package in which it resides. However, we do not suppress it\n+         --  simply if the scope has accessibility checks suppressed, since\n+         --  this could cause trouble when clients are compiled with a\n+         --  different suppression setting. The explicit checks at the\n+         --  package level are safe from this point of view.\n+\n+         if (Ekind (Base_Type (Etype (Formal))) = E_Anonymous_Access_Type\n+              or else (Is_Controlling_Formal (Formal)\n+                        and then Is_Access_Type (Base_Type (Etype (Formal)))))\n+           and then not\n+             (Explicit_Suppress (E, Accessibility_Check)\n+               or else\n+              Explicit_Suppress (Scope (E), Accessibility_Check))\n+           and then\n+             (No (P_Formal)\n+               or else Present (Extra_Accessibility (P_Formal)))\n+         then\n             Set_Extra_Accessibility\n               (Formal, Add_Extra_Formal (Formal, Standard_Natural, E, \"L\"));\n-\n-         else\n-            pragma Assert (No (Parent_Formal)\n-              or else No (Extra_Accessibility (Parent_Formal)));\n-            pragma Assert (No (Alias_Formal)\n-              or else No (Extra_Accessibility (Alias_Formal)));\n          end if;\n \n          --  This label is required when skipping extra formal generation for\n          --  Unchecked_Union parameters.\n \n          <<Skip_Extra_Formal_Generation>>\n \n-         if Present (Parent_Formal) then\n-            Next_Formal (Parent_Formal);\n-         end if;\n-\n-         if Present (Alias_Formal) then\n-            Next_Formal (Alias_Formal);\n+         if Present (P_Formal) then\n+            Next_Formal (P_Formal);\n          end if;\n \n          Next_Formal (Formal);\n       end loop;\n \n       <<Test_For_Func_Result_Extras>>\n \n-      --  Assume the worse scenery (Ada 2022) to evaluate this extra formal;\n-      --  required to ensure matching of extra formals between subprograms\n-      --  and access to subprogram types in projects with mixed Ada dialects.\n-\n-      declare\n-         Save_Ada_Version : constant Ada_Version_Type := Ada_Version;\n-\n-      begin\n-         Ada_Version := Ada_2022;\n+      --  Ada 2012 (AI05-234): \"the accessibility level of the result of a\n+      --  function call is ... determined by the point of call ...\".\n \n-         if Needs_Result_Accessibility_Level (Ref_E) then\n-            pragma Assert (No (Parent_Subp)\n-              or else Needs_Result_Accessibility_Level (Parent_Subp));\n-            pragma Assert (No (Alias_Subp)\n-              or else Needs_Result_Accessibility_Level (Alias_Subp));\n-\n-            Set_Extra_Accessibility_Of_Result (E,\n-              Add_Extra_Formal (E, Standard_Natural, E, \"L\"));\n-\n-         else\n-            pragma Assert (No (Parent_Subp)\n-              or else not Needs_Result_Accessibility_Level (Parent_Subp));\n-            pragma Assert (No (Alias_Subp)\n-              or else not Needs_Result_Accessibility_Level (Alias_Subp));\n-         end if;\n-\n-         Ada_Version := Save_Ada_Version;\n-      end;\n+      if Needs_Result_Accessibility_Level (E) then\n+         Set_Extra_Accessibility_Of_Result\n+           (E, Add_Extra_Formal (E, Standard_Natural, E, \"L\"));\n+      end if;\n \n       --  Ada 2005 (AI-318-02): In the case of build-in-place functions, add\n       --  appropriate extra formals. See type Exp_Ch6.BIP_Formal_Kind.\n \n-      if (Present (Parent_Subp) and then Has_BIP_Formals (Parent_Subp))\n-            or else\n-         (Present (Alias_Subp) and then Has_BIP_Formals (Alias_Subp))\n-            or else\n-         (Is_Build_In_Place_Function (Ref_E)\n-            and then Has_Reliable_Extra_Formals (Ref_E))\n-      then\n+      if Is_Build_In_Place_Function (E) then\n          declare\n-            Result_Subt : constant Entity_Id := Etype (Ref_E);\n+            Result_Subt : constant Entity_Id := Etype (E);\n             Formal_Typ  : Entity_Id;\n             Subp_Decl   : Node_Id;\n             Discard     : Entity_Id;\n@@ -9766,14 +9184,7 @@ package body Sem_Ch6 is\n             --  dispatching context and such calls must be handled like calls\n             --  to a class-wide function.\n \n-            if Needs_BIP_Alloc_Form (Ref_E) then\n-               pragma Assert (No (Parent_Subp)\n-                 or else Has_BIP_Extra_Formal (Parent_Subp, BIP_Alloc_Form,\n-                           Must_Be_Frozen => False));\n-               pragma Assert (No (Alias_Subp)\n-                 or else Has_BIP_Extra_Formal (Alias_Subp, BIP_Alloc_Form,\n-                           Must_Be_Frozen => False));\n-\n+            if Needs_BIP_Alloc_Form (E) then\n                Discard :=\n                  Add_Extra_Formal\n                    (E, Standard_Natural,\n@@ -9789,66 +9200,23 @@ package body Sem_Ch6 is\n                       (E, RTE (RE_Root_Storage_Pool_Ptr),\n                        E, BIP_Formal_Suffix (BIP_Storage_Pool));\n                end if;\n-\n-            else\n-               pragma Assert (No (Parent_Subp)\n-                 or else not\n-                   Has_BIP_Extra_Formal (Parent_Subp, BIP_Alloc_Form,\n-                     Must_Be_Frozen => False));\n-               pragma Assert (No (Alias_Subp)\n-                 or else not\n-                   Has_BIP_Extra_Formal (Alias_Subp, BIP_Alloc_Form,\n-                     Must_Be_Frozen => False));\n             end if;\n \n             --  In the case of functions whose result type needs finalization,\n             --  add an extra formal which represents the finalization master.\n \n-            if Needs_BIP_Finalization_Master (Ref_E) then\n-               pragma Assert (No (Parent_Subp)\n-                 or else Has_BIP_Extra_Formal (Parent_Subp,\n-                           Kind           => BIP_Finalization_Master,\n-                           Must_Be_Frozen => False));\n-               pragma Assert (No (Alias_Subp)\n-                 or else Has_BIP_Extra_Formal (Alias_Subp,\n-                           Kind           => BIP_Finalization_Master,\n-                           Must_Be_Frozen => False));\n-\n+            if Needs_BIP_Finalization_Master (E) then\n                Discard :=\n                  Add_Extra_Formal\n                    (E, RTE (RE_Finalization_Master_Ptr),\n                     E, BIP_Formal_Suffix (BIP_Finalization_Master));\n-\n-            else\n-               pragma Assert (No (Parent_Subp)\n-                 or else not\n-                   Has_BIP_Extra_Formal (Parent_Subp,\n-                     Kind           => BIP_Finalization_Master,\n-                     Must_Be_Frozen => False));\n-               pragma Assert (No (Alias_Subp)\n-                 or else not\n-                   Has_BIP_Extra_Formal (Alias_Subp,\n-                     Kind           => BIP_Finalization_Master,\n-                     Must_Be_Frozen => False));\n             end if;\n \n             --  When the result type contains tasks, add two extra formals: the\n             --  master of the tasks to be created, and the caller's activation\n             --  chain.\n \n-            if Needs_BIP_Task_Actuals (Ref_E) then\n-               pragma Assert (No (Parent_Subp)\n-                 or else Has_BIP_Extra_Formal (Parent_Subp, BIP_Task_Master,\n-                           Must_Be_Frozen => False));\n-               pragma Assert (No (Alias_Subp)\n-                 or else Has_BIP_Extra_Formal (Alias_Subp, BIP_Task_Master,\n-                           Must_Be_Frozen => False)\n-                 or else\n-                   (Is_Abstract_Subprogram (Ref_E)\n-                      and then Is_Predefined_Dispatching_Operation (Ref_E)\n-                      and then Is_Interface\n-                                 (Find_Dispatching_Type (Alias_Subp))));\n-\n+            if Needs_BIP_Task_Actuals (E) then\n                Discard :=\n                  Add_Extra_Formal\n                    (E, Standard_Integer,\n@@ -9860,16 +9228,6 @@ package body Sem_Ch6 is\n                  Add_Extra_Formal\n                    (E, RTE (RE_Activation_Chain_Access),\n                     E, BIP_Formal_Suffix (BIP_Activation_Chain));\n-\n-            else\n-               pragma Assert (No (Parent_Subp)\n-                 or else not\n-                   Has_BIP_Extra_Formal (Parent_Subp, BIP_Task_Master,\n-                     Must_Be_Frozen => False));\n-               pragma Assert (No (Alias_Subp)\n-                 or else not\n-                   Has_BIP_Extra_Formal (Alias_Subp, BIP_Task_Master,\n-                     Must_Be_Frozen => False));\n             end if;\n \n             --  All build-in-place functions get an extra formal that will be\n@@ -9935,14 +9293,6 @@ package body Sem_Ch6 is\n       if Is_Generic_Instance (E) and then Present (Alias (E)) then\n          Set_Extra_Formals (Alias (E), Extra_Formals (E));\n       end if;\n-\n-      pragma Assert (No (Alias_Subp)\n-        or else Extra_Formals_Match_OK (E, Alias_Subp));\n-\n-      pragma Assert (No (Parent_Subp)\n-        or else Extra_Formals_Match_OK (E, Parent_Subp));\n-\n-      pragma Assert (Extra_Formals_OK (E));\n    end Create_Extra_Formals;\n \n    -----------------------------\n@@ -10173,162 +9523,252 @@ package body Sem_Ch6 is\n       end if;\n    end Enter_Overloaded_Entity;\n \n-   ----------------------------\n-   -- Extra_Formals_Match_OK --\n-   ----------------------------\n+   -----------------------------\n+   -- Check_Untagged_Equality --\n+   -----------------------------\n \n-   function Extra_Formals_Match_OK\n-     (E     : Entity_Id;\n-      Ref_E : Entity_Id) return Boolean is\n-   begin\n-      pragma Assert (Is_Subprogram (E));\n-\n-      --  Cases were no check can be performed:\n-      --    1) When expansion is not active (since we never generate extra\n-      --       formals if expansion is not active because we don't need them\n-      --       unless we are generating code).\n-      --    2) On abstract predefined dispatching operations of Root_Controlled\n-      --       and predefined stream operations not emitted by the frontend.\n-      --    3) On renamings of abstract predefined dispatching operations of\n-      --       interface types (since limitedness is not inherited in such\n-      --       case (AI-419)).\n-      --    4) The controlling formal of the non-dispatching subprogram of\n-      --       a concurrent type that overrides an interface primitive is\n-      --       implicit and hence we cannot check here if all its extra\n-      --       formals match; the expander will create the dispatching\n-      --       primitive (without Convention_Protected) with the matching\n-      --       formals (see exp_ch9.Build_Wrapper_Specs) which will be\n-      --       checked later.\n-\n-      if Debug_Flag_Underscore_XX\n-        or else not Expander_Active\n-        or else\n-          (Is_Predefined_Dispatching_Operation (E)\n-             and then (not Has_Reliable_Extra_Formals (E)\n-                         or else not Has_Reliable_Extra_Formals (Ref_E)))\n-        or else\n-          (Is_Predefined_Dispatching_Operation (E)\n-             and then Is_Abstract_Subprogram (E)\n-             and then Is_Interface (Find_Dispatching_Type (Ref_E)))\n-      then\n-         return True;\n+   procedure Check_Untagged_Equality (Eq_Op : Entity_Id) is\n+      Eq_Decl : constant Node_Id   := Unit_Declaration_Node (Eq_Op);\n+      Typ     : constant Entity_Id := Etype (First_Formal (Eq_Op));\n \n-      elsif Convention (E) = Convention_Protected\n-        and then not Is_Dispatching_Operation (E)\n-        and then Is_Abstract_Subprogram (Ref_E)\n-        and then Is_Interface (Find_Dispatching_Type (Ref_E))\n-      then\n-         return True;\n-      end if;\n+      procedure Freezing_Point_Warning (N : Node_Id; S : String);\n+      --  Output a warning about the freezing point N of Typ\n \n-      --  Perform the checks\n+      function Is_Actual_Of_Instantiation\n+        (E    : Entity_Id;\n+         Inst : Node_Id) return Boolean;\n+      --  Return True if E is an actual parameter of instantiation Inst\n \n-      if No (Extra_Formals (E)) then\n-         return No (Extra_Formals (Ref_E));\n-      end if;\n+      -----------------------------------\n+      -- Output_Freezing_Point_Warning --\n+      -----------------------------------\n \n-      if Ekind (E) in E_Function | E_Subprogram_Type\n-        and then Present (Extra_Accessibility_Of_Result (E))\n-                   /= Present (Extra_Accessibility_Of_Result (Ref_E))\n-      then\n-         return False;\n-      end if;\n+      procedure Freezing_Point_Warning (N : Node_Id; S : String) is\n+      begin\n+         Error_Msg_String (1 .. S'Length) := S;\n+         Error_Msg_Strlen := S'Length;\n \n-      declare\n-         Formal_1 : Entity_Id := Extra_Formals (E);\n-         Formal_2 : Entity_Id := Extra_Formals (Ref_E);\n+         if Ada_Version >= Ada_2012 then\n+            Error_Msg_NE (\"type& is frozen by ~??\", N, Typ);\n+            Error_Msg_N\n+              (\"\\an equality operator cannot be declared after this point??\",\n+               N);\n+\n+         else\n+            Error_Msg_NE (\"type& is frozen by ~ (Ada 2012)?y?\", N, Typ);\n+            Error_Msg_N\n+              (\"\\an equality operator cannot be declared after this point\"\n+               & \" (Ada 2012)?y?\", N);\n+         end if;\n+      end Freezing_Point_Warning;\n+\n+      --------------------------------\n+      -- Is_Actual_Of_Instantiation --\n+      --------------------------------\n+\n+      function Is_Actual_Of_Instantiation\n+        (E    : Entity_Id;\n+         Inst : Node_Id) return Boolean\n+      is\n+         Assoc : Node_Id;\n \n       begin\n-         while Present (Formal_1) and then Present (Formal_2) loop\n-            if Has_Suffix (Formal_1, 'L') then\n-               if not Has_Suffix (Formal_2, 'L') then\n-                  return False;\n-               end if;\n+         if Present (Generic_Associations (Inst)) then\n+            Assoc := First (Generic_Associations (Inst));\n \n-            elsif Has_Suffix (Formal_1, 'O') then\n-               if not Has_Suffix (Formal_2, 'O') then\n-                  return False;\n+            while Present (Assoc) loop\n+               if Present (Explicit_Generic_Actual_Parameter (Assoc))\n+                 and then\n+                   Is_Entity_Name (Explicit_Generic_Actual_Parameter (Assoc))\n+                 and then\n+                   Entity (Explicit_Generic_Actual_Parameter (Assoc)) = E\n+               then\n+                  return True;\n                end if;\n \n-            elsif BIP_Suffix_Kind (Formal_1) /= BIP_Suffix_Kind (Formal_2) then\n-               return False;\n-            end if;\n+               Next (Assoc);\n+            end loop;\n+         end if;\n \n-            Formal_1 := Next_Formal_With_Extras (Formal_1);\n-            Formal_2 := Next_Formal_With_Extras (Formal_2);\n-         end loop;\n+         return False;\n+      end Is_Actual_Of_Instantiation;\n \n-         return No (Formal_1) and then No (Formal_2);\n-      end;\n-   end Extra_Formals_Match_OK;\n+      --  Local variable\n \n-   ----------------------\n-   -- Extra_Formals_OK --\n-   ----------------------\n+      Decl : Node_Id;\n \n-   function Extra_Formals_OK (E : Entity_Id) return Boolean is\n-      Last_Formal       : Entity_Id := Empty;\n-      Formal            : Entity_Id;\n-      Has_Extra_Formals : Boolean := False;\n+   --  Start of processing for Check_Untagged_Equality\n \n    begin\n-      --  No check required if explicitly disabled\n+      --  This check applies only if we have a subprogram declaration or a\n+      --  subprogram body that is not a completion, for an untagged record\n+      --  type, and that is conformant with the predefined operator.\n \n-      if Debug_Flag_Underscore_XX then\n-         return True;\n+      if (Nkind (Eq_Decl) /= N_Subprogram_Declaration\n+           and then not (Nkind (Eq_Decl) = N_Subprogram_Body\n+                          and then Acts_As_Spec (Eq_Decl)))\n+        or else not Is_Record_Type (Typ)\n+        or else Is_Tagged_Type (Typ)\n+        or else not Is_User_Defined_Equality (Eq_Op)\n+      then\n+         return;\n+      end if;\n+\n+      --  In Ada 2012 case, we will output errors or warnings depending on\n+      --  the setting of debug flag -gnatd.E.\n \n-      --  No check required if expansion is disabled because extra\n-      --  formals are only generated when we are generating code.\n-      --  See Create_Extra_Formals.\n+      if Ada_Version >= Ada_2012 then\n+         Error_Msg_Warn := Debug_Flag_Dot_EE;\n \n-      elsif not Expander_Active then\n-         return True;\n+      --  In earlier versions of Ada, nothing to do unless we are warning on\n+      --  Ada 2012 incompatibilities (Warn_On_Ada_2012_Incompatibility set).\n+\n+      else\n+         if not Warn_On_Ada_2012_Compatibility then\n+            return;\n+         end if;\n       end if;\n \n-      --  Check attribute Extra_Formal: If available, it must be set only\n-      --  on the last formal of E.\n+      --  Cases where the type has already been frozen\n \n-      Formal := First_Formal (E);\n-      while Present (Formal) loop\n-         if Present (Extra_Formal (Formal)) then\n-            if Has_Extra_Formals then\n-               return False;\n-            end if;\n+      if Is_Frozen (Typ) then\n \n-            Has_Extra_Formals := True;\n-         end if;\n+         --  The check applies to a primitive operation, so check that type\n+         --  and equality operation are in the same scope.\n \n-         Last_Formal := Formal;\n-         Next_Formal (Formal);\n-      end loop;\n+         if Scope (Typ) /= Current_Scope then\n+            return;\n+\n+         --  If the type is a generic actual (sub)type, the operation is not\n+         --  primitive either because the base type is declared elsewhere.\n \n-      --  Check attribute Extra_Accessibility_Of_Result\n+         elsif Is_Generic_Actual_Type (Typ) then\n+            return;\n \n-      if Ekind (E) in E_Function | E_Subprogram_Type\n-        and then Needs_Result_Accessibility_Level (E)\n-        and then No (Extra_Accessibility_Of_Result (E))\n-      then\n-         return False;\n-      end if;\n+         --  Here we may have an error of declaration after freezing, but we\n+         --  must make sure not to flag the equality operator itself causing\n+         --  the freezing when it is a subprogram body.\n \n-      --  Check attribute Extra_Formals: If E has extra formals, then this\n-      --  attribute must point to the first extra formal of E.\n+         else\n+            Decl := Next (Declaration_Node (Typ));\n \n-      if Has_Extra_Formals then\n-         return Present (Extra_Formals (E))\n-           and then Present (Extra_Formal (Last_Formal))\n-           and then Extra_Formal (Last_Formal) = Extra_Formals (E);\n+            while Present (Decl) and then Decl /= Eq_Decl loop\n+\n+               --  The declaration of an object of the type\n \n-      --  When E has no formals, the first extra formal is available through\n-      --  the Extra_Formals attribute.\n+               if Nkind (Decl) = N_Object_Declaration\n+                 and then Etype (Defining_Identifier (Decl)) = Typ\n+               then\n+                  Freezing_Point_Warning (Decl, \"declaration\");\n+                  exit;\n \n-      elsif Present (Extra_Formals (E)) then\n-         return No (First_Formal (E));\n+               --  The instantiation of a generic on the type\n+\n+               elsif Nkind (Decl) in N_Generic_Instantiation\n+                 and then Is_Actual_Of_Instantiation (Typ, Decl)\n+               then\n+                  Freezing_Point_Warning (Decl, \"instantiation\");\n+                  exit;\n+\n+               --  A noninstance proper body, body stub or entry body\n+\n+               elsif Nkind (Decl) in N_Proper_Body\n+                                   | N_Body_Stub\n+                                   | N_Entry_Body\n+                 and then not Is_Generic_Instance (Defining_Entity (Decl))\n+               then\n+                  Freezing_Point_Warning (Decl, \"body\");\n+                  exit;\n+\n+               --  If we have reached the freeze node and immediately after we\n+               --  have the body or generated code for the body, then it is the\n+               --  body that caused the freezing and this is legal.\n+\n+               elsif Nkind (Decl) = N_Freeze_Entity\n+                 and then Entity (Decl) = Typ\n+                 and then (Next (Decl) = Eq_Decl\n+                            or else\n+                           Sloc (Next (Decl)) = Sloc (Eq_Decl))\n+               then\n+                  return;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+\n+            --  Here we have a definite error of declaration after freezing\n+\n+            if Ada_Version >= Ada_2012 then\n+               Error_Msg_NE\n+                 (\"equality operator must be declared before type & is \"\n+                  & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)<<\", Eq_Op, Typ);\n+\n+               --  In Ada 2012 mode with error turned to warning, output one\n+               --  more warning to warn that the equality operation may not\n+               --  compose. This is the consequence of ignoring the error.\n+\n+               if Error_Msg_Warn then\n+                  Error_Msg_N (\"\\equality operation may not compose??\", Eq_Op);\n+               end if;\n+\n+            else\n+               Error_Msg_NE\n+                 (\"equality operator must be declared before type& is \"\n+                  & \"frozen (RM 4.5.2 (9.8)) (Ada 2012)?y?\", Eq_Op, Typ);\n+            end if;\n+\n+            --  If we have found no freezing point and the declaration of the\n+            --  operator could not be reached from that of the type and we are\n+            --  in a package body, this must be because the type is declared\n+            --  in the spec of the package. Add a message tailored to this.\n+\n+            if No (Decl) and then In_Package_Body (Scope (Typ)) then\n+               if Ada_Version >= Ada_2012 then\n+                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n+                     Error_Msg_N\n+                       (\"\\put declaration in package spec<<\", Eq_Op);\n+                  else\n+                     Error_Msg_N\n+                       (\"\\move declaration to package spec<<\", Eq_Op);\n+                  end if;\n+\n+               else\n+                  if Nkind (Eq_Decl) = N_Subprogram_Body then\n+                     Error_Msg_N\n+                       (\"\\put declaration in package spec (Ada 2012)?y?\",\n+                        Eq_Op);\n+                  else\n+                     Error_Msg_N\n+                       (\"\\move declaration to package spec (Ada 2012)?y?\",\n+                        Eq_Op);\n+                  end if;\n+               end if;\n+            end if;\n+         end if;\n+\n+      --  Now check for AI12-0352: the declaration of a user-defined primitive\n+      --  equality operation for a record type T is illegal if it occurs after\n+      --  a type has been derived from T.\n \n       else\n-         return True;\n+         Decl := Next (Declaration_Node (Typ));\n+\n+         while Present (Decl) and then Decl /= Eq_Decl loop\n+            if Nkind (Decl) = N_Full_Type_Declaration\n+              and then Etype (Defining_Identifier (Decl)) = Typ\n+            then\n+               Error_Msg_N\n+                 (\"equality operator cannot appear after derivation\", Eq_Op);\n+               Error_Msg_NE\n+                 (\"an equality operator for& cannot be declared after \"\n+                  & \"this point??\",\n+                  Decl, Typ);\n+            end if;\n+\n+            Next (Decl);\n+         end loop;\n       end if;\n-   end Extra_Formals_OK;\n+   end Check_Untagged_Equality;\n \n    -----------------------------\n    -- Find_Corresponding_Spec --\n@@ -11213,70 +10653,6 @@ package body Sem_Ch6 is\n       end if;\n    end Fully_Conformant_Discrete_Subtypes;\n \n-   --------------------------------\n-   -- Has_Reliable_Extra_Formals --\n-   --------------------------------\n-\n-   function Has_Reliable_Extra_Formals (E : Entity_Id) return Boolean is\n-      Alias_E : Entity_Id;\n-\n-   begin\n-      --  Extra formals are not added if expansion is not active (and hence if\n-      --  available they are not reliable for extra formals check).\n-\n-      if not Expander_Active then\n-         return False;\n-\n-      --  Currently the unique cases where extra formals are not reliable\n-      --  are associated with predefined dispatching operations; otherwise\n-      --  they are properly added when required.\n-\n-      elsif not Is_Predefined_Dispatching_Operation (E) then\n-         return True;\n-      end if;\n-\n-      Alias_E := Ultimate_Alias (E);\n-\n-      --  Abstract predefined primitives of Root_Controlled don't have\n-      --  extra formals; this is required to build the runtime.\n-\n-      if Ekind (Alias_E) = E_Function\n-        and then Is_Abstract_Subprogram (Alias_E)\n-        and then Is_RTE (Underlying_Type (Etype (Alias_E)),\n-                           RE_Root_Controlled)\n-      then\n-         return False;\n-\n-      --  Predefined stream dispatching operations that are not emitted by\n-      --  the frontend; they have a renaming of the corresponding primive\n-      --  of their parent type and hence they don't have extra formals.\n-\n-      else\n-         declare\n-            Typ : constant Entity_Id :=\n-                    Underlying_Type (Find_Dispatching_Type (Alias_E));\n-\n-         begin\n-            if (Get_TSS_Name (E) = TSS_Stream_Input\n-                  and then not Stream_Operation_OK (Typ, TSS_Stream_Input))\n-              or else\n-                (Get_TSS_Name (E) = TSS_Stream_Output\n-                   and then not Stream_Operation_OK (Typ, TSS_Stream_Output))\n-              or else\n-                (Get_TSS_Name (E) = TSS_Stream_Read\n-                   and then not Stream_Operation_OK (Typ, TSS_Stream_Read))\n-              or else\n-                (Get_TSS_Name (E) = TSS_Stream_Write\n-                   and then not Stream_Operation_OK (Typ, TSS_Stream_Write))\n-            then\n-               return False;\n-            end if;\n-         end;\n-      end if;\n-\n-      return True;\n-   end Has_Reliable_Extra_Formals;\n-\n    --------------------\n    -- Install_Entity --\n    --------------------"}, {"sha": "da56ce6ab722c8ccccbfa864e40585f4f96c4243", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -174,22 +174,6 @@ package Sem_Ch6 is\n    --  the end of Subp's parameter list (with each subsequent extra formal\n    --  being attached to the preceding extra formal).\n \n-   function Extra_Formals_Match_OK\n-     (E     : Entity_Id;\n-      Ref_E : Entity_Id) return Boolean;\n-   --  Return True if the extra formals of the given entities match. E is a\n-   --  subprogram, and Ref_E is the reference entity that will be used to check\n-   --  the extra formals of E: a subprogram type or another subprogram. For\n-   --  example, if E is a dispatching primitive of a tagged type then Ref_E\n-   --  may be the overridden primitive of its parent type or its ultimate\n-   --  renamed entity; however, if E is a subprogram to which 'Access is\n-   --  applied then Ref_E is its corresponding subprogram type. Used in\n-   --  assertions.\n-\n-   function Extra_Formals_OK (E : Entity_Id) return Boolean;\n-   --  Return True if the decoration of the attributes associated with extra\n-   --  formals are properly set. Used in assertions.\n-\n    function Find_Corresponding_Spec\n      (N          : Node_Id;\n       Post_Error : Boolean := True) return Entity_Id;"}, {"sha": "2ba460889405d627a19310575c10ff875296704a", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -1823,7 +1823,6 @@ package body Sem_Eval is\n          return False;\n \n       elsif Op = Error\n-        or else Nkind (Op) not in N_Has_Etype\n         or else Etype (Op) = Any_Type\n         or else Raises_Constraint_Error (Op)\n       then"}, {"sha": "4a12f080bcaebbd8147ff26fe893292e9b49a7fb", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dad0ebe674d495a7e032a123d2d60c090729ef2c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=dad0ebe674d495a7e032a123d2d60c090729ef2c", "patch": "@@ -23226,12 +23226,9 @@ package body Sem_Util is\n \n          return Present (Extra_Accessibility_Of_Result (Alias (Func_Id)));\n \n-      --  Remaining cases require Ada 2012 mode, unless they are dispatching\n-      --  operations, since they may be overridden by Ada_2012 primitives.\n+      --  Remaining cases require Ada 2012 mode\n \n-      elsif Ada_Version < Ada_2012\n-        and then not Is_Dispatching_Operation (Func_Id)\n-      then\n+      elsif Ada_Version < Ada_2012 then\n          return False;\n \n       --  Handle the situation where a result is an anonymous access type"}]}