{"sha": "f3204ce1ae6b97f7e79d633844d61d021da8502e", "node_id": "C_kwDOANBUbNoAKGYzMjA0Y2UxYWU2Yjk3ZjdlNzlkNjMzODQ0ZDYxZDAyMWRhODUwMmU", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-09T17:32:31Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-05-13T14:54:45Z"}, "message": "Return a bool result for union, and add performance improvements.\n\nUnion_ returns a boolean indicating if the operation changes the range.\nAlso optimize the common single-pair UNION single-pair case.\n\n\t* gimple-range-edge.cc (calc_switch_ranges): Check union return value.\n\t* value-range.cc (irange::legacy_verbose_union_): Add return value.\n\t(irange::irange_single_pair_union): New.\n\t(irange::irange_union): Add return value.\n\t* value-range.h (class irange): Adjust prototypes.", "tree": {"sha": "7b5111a38a27decd2a93d9b7c113a4ca74b3f9f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b5111a38a27decd2a93d9b7c113a4ca74b3f9f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3204ce1ae6b97f7e79d633844d61d021da8502e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3204ce1ae6b97f7e79d633844d61d021da8502e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3204ce1ae6b97f7e79d633844d61d021da8502e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3204ce1ae6b97f7e79d633844d61d021da8502e/comments", "author": null, "committer": null, "parents": [{"sha": "1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d3d7e88aac0db20a4b59044f9b7cd35e847e8d3"}], "stats": {"total": 109, "additions": 94, "deletions": 15}, "files": [{"sha": "0bee38ba770ff9b90821c4aa5f6acc41b623b52a", "filename": "gcc/gimple-range-edge.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3204ce1ae6b97f7e79d633844d61d021da8502e/gcc%2Fgimple-range-edge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3204ce1ae6b97f7e79d633844d61d021da8502e/gcc%2Fgimple-range-edge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-edge.cc?ref=f3204ce1ae6b97f7e79d633844d61d021da8502e", "patch": "@@ -154,7 +154,9 @@ gimple_outgoing_range::calc_switch_ranges (gswitch *sw)\n       irange *&slot = m_edge_table->get_or_insert (e, &existed);\n       if (existed)\n \t{\n-\t  case_range.union_ (*slot);\n+\t  // If this doesn't change the value, move on.\n+\t  if (!case_range.union_ (*slot))\n+\t   continue;\n \t  if (slot->fits_p (case_range))\n \t    {\n \t      *slot = case_range;"}, {"sha": "2e7385aecc2e8b1815054250c4b66e7ce02cc6a5", "filename": "gcc/value-range.cc", "status": "modified", "additions": 84, "deletions": 9, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3204ce1ae6b97f7e79d633844d61d021da8502e/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3204ce1ae6b97f7e79d633844d61d021da8502e/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=f3204ce1ae6b97f7e79d633844d61d021da8502e", "patch": "@@ -1439,9 +1439,10 @@ irange::legacy_union (irange *vr0, const irange *vr1)\n \n /* Meet operation for value ranges.  Given two value ranges VR0 and\n    VR1, store in VR0 a range that contains both VR0 and VR1.  This\n-   may not be the smallest possible such range.  */\n+   may not be the smallest possible such range.\n+   Return TRUE if the original value changes.  */\n \n-void\n+bool\n irange::legacy_verbose_union_ (const irange *other)\n {\n   if (legacy_mode_p ())\n@@ -1450,7 +1451,7 @@ irange::legacy_verbose_union_ (const irange *other)\n \t{\n \t  int_range<1> tmp = *other;\n \t  legacy_union (this, &tmp);\n-\t  return;\n+\t  return true;\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n@@ -1469,16 +1470,16 @@ irange::legacy_verbose_union_ (const irange *other)\n \t  dump_value_range (dump_file, this);\n \t  fprintf (dump_file, \"\\n\");\n \t}\n-      return;\n+      return true;\n     }\n \n   if (other->legacy_mode_p ())\n     {\n       int_range<2> wider = *other;\n-      irange_union (wider);\n+      return irange_union (wider);\n     }\n   else\n-    irange_union (*other);\n+    return irange_union (*other);\n }\n \n bool\n@@ -1522,22 +1523,95 @@ irange::legacy_verbose_intersect (const irange *other)\n     return irange_intersect (*other);\n }\n \n+// Perform an efficient union with R when both ranges have only a single pair.\n+// Excluded are VARYING and UNDEFINED ranges.\n+\n+bool\n+irange::irange_single_pair_union (const irange &r)\n+{\n+  gcc_checking_assert (!undefined_p () && !varying_p ());\n+  gcc_checking_assert (!r.undefined_p () && !varying_p ());\n+\n+  signop sign = TYPE_SIGN (TREE_TYPE (m_base[0]));\n+  // Check if current lower bound is also the new lower bound.\n+  if (wi::le_p (wi::to_wide (m_base[0]), wi::to_wide (r.m_base[0]), sign))\n+    {\n+      // If current upper bound is new upper bound, we're done.\n+      if (wi::le_p (wi::to_wide (r.m_base[1]), wi::to_wide (m_base[1]), sign))\n+\treturn false;\n+      // Otherwise R has the new upper bound.\n+      // Check for overlap/touching ranges, or single target range.\n+      if (m_max_ranges == 1\n+\t  || wi::to_widest (m_base[1]) + 1 >= wi::to_widest (r.m_base[0]))\n+\t{\n+\t  m_base[1] = r.m_base[1];\n+\t  if (varying_compatible_p ())\n+\t    m_kind = VR_VARYING;\n+\t}\n+      else\n+\t{\n+\t  // This is a dual range result.\n+\t  m_base[2] = r.m_base[0];\n+\t  m_base[3] = r.m_base[1];\n+\t  m_num_ranges = 2;\n+\t}\n+      if (flag_checking)\n+\tverify_range ();\n+      return true;\n+    }\n+\n+  // Set the new lower bound to R's lower bound.\n+  tree lb = m_base[0];\n+  m_base[0] = r.m_base[0];\n+\n+  // If R fully contains THIS range, just set the upper bound.\n+  if (wi::ge_p (wi::to_wide (r.m_base[1]), wi::to_wide (m_base[1]), sign))\n+    m_base[1] = r.m_base[1];\n+  // Check for overlapping ranges, or target limited to a single range.\n+  else if (m_max_ranges == 1\n+\t   || wi::to_widest (r.m_base[1]) + 1 >= wi::to_widest (lb))\n+    {\n+      // This has the new upper bound, just check for varying.\n+      if (varying_compatible_p ())\n+\t  m_kind = VR_VARYING;\n+    }\n+  else\n+    {\n+      // Left with 2 pairs.\n+      m_num_ranges = 2;\n+      m_base[2] = lb;\n+      m_base[3] = m_base[1];\n+      m_base[1] = r.m_base[1];\n+    }\n+  if (flag_checking)\n+    verify_range ();\n+  return true;\n+}\n+\n // union_ for multi-ranges.\n \n-void\n+bool\n irange::irange_union (const irange &r)\n {\n   gcc_checking_assert (!legacy_mode_p () && !r.legacy_mode_p ());\n \n   if (r.undefined_p () || varying_p ())\n-    return;\n+    return false;\n \n   if (undefined_p () || r.varying_p ())\n     {\n       operator= (r);\n-      return;\n+      return true;\n     }\n \n+  // Special case one range union one range.\n+  if (m_num_ranges == 1 && r.m_num_ranges == 1)\n+    return irange_single_pair_union (r);\n+\n+  // If this ranges fully contains R, then we need do nothing.\n+  if (irange_contains_p (r))\n+    return false;\n+\n   // Do not worry about merging and such by reserving twice as many\n   // pairs as needed, and then simply sort the 2 ranges into this\n   // intermediate form.\n@@ -1628,6 +1702,7 @@ irange::irange_union (const irange &r)\n \n   if (flag_checking)\n     verify_range ();\n+  return true;\n }\n \n // Return TRUE if THIS fully contains R.  No undefined or varying cases."}, {"sha": "ec59d2e4f235e45a046c26eeafc4da9d97c19292", "filename": "gcc/value-range.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3204ce1ae6b97f7e79d633844d61d021da8502e/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3204ce1ae6b97f7e79d633844d61d021da8502e/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=f3204ce1ae6b97f7e79d633844d61d021da8502e", "patch": "@@ -71,7 +71,7 @@ class GTY((user)) irange\n   bool contains_p (tree) const;\n \n   // In-place operators.\n-  void union_ (const irange &);\n+  bool union_ (const irange &);\n   bool intersect (const irange &);\n   void invert ();\n \n@@ -96,7 +96,7 @@ class GTY((user)) irange\n   bool may_contain_p (tree) const;\t\t// DEPRECATED\n   void set (tree);\t\t\t\t// DEPRECATED\n   bool equal_p (const irange &) const;\t\t// DEPRECATED\n-  void legacy_verbose_union_ (const class irange *);\t// DEPRECATED\n+  bool legacy_verbose_union_ (const class irange *);\t// DEPRECATED\n   bool legacy_verbose_intersect (const irange *);\t// DEPRECATED\n \n protected:\n@@ -107,11 +107,12 @@ class GTY((user)) irange\n   tree tree_upper_bound () const;\n \n    // In-place operators.\n-  void irange_union (const irange &);\n+  bool irange_union (const irange &);\n   bool irange_intersect (const irange &);\n   void irange_set (tree, tree);\n   void irange_set_anti_range (tree, tree);\n   bool irange_contains_p (const irange &) const;\n+  bool irange_single_pair_union (const irange &r);\n \n   void normalize_kind ();\n \n@@ -545,13 +546,14 @@ irange::upper_bound () const\n   return upper_bound (pairs - 1);\n }\n \n-inline void\n+inline bool\n irange::union_ (const irange &r)\n {\n   dump_flags_t m_flags = dump_flags;\n   dump_flags &= ~TDF_DETAILS;\n-  irange::legacy_verbose_union_ (&r);\n+  bool ret = irange::legacy_verbose_union_ (&r);\n   dump_flags = m_flags;\n+  return ret;\n }\n \n inline bool"}]}