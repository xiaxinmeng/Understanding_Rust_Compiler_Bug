{"sha": "71affc54b59a7026571ee5d8dad000bd6e0c760c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFhZmZjNTRiNTlhNzAyNjU3MWVlNWQ4ZGFkMDAwYmQ2ZTBjNzYwYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T16:33:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-21T16:33:09Z"}, "message": "[multiple changes]\n\n2014-01-21  Robert Dewar  <dewar@adacore.com>\n\n\t* par-ch4.adb (P_If_Expression): Rewritten to improve error recovery.\n\t* par-ch5.adb (P_Condition): New version with expression prescanned.\n\t* par.adb (P_Condition): New version with expression prescanned.\n\n2014-01-21  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Document that Allow_Integer_Address is ignored\n\tif Address is not a private type.\n\t* sem_prag.adb (Analyze_Pragma, case Allow_Integer_Address):\n\tIgnore pragma if System.Address is not a private type.\n\n2014-01-21  Arnaud Charlet  <charlet@adacore.com>\n\n\t* namet.ads (Name_Len): Initialize to 0 to avoid accessing an\n\tuninitialized value.\n\nFrom-SVN: r206892", "tree": {"sha": "f6613c9cb7abf86dd60c46c21622ad75ef34fe4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6613c9cb7abf86dd60c46c21622ad75ef34fe4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71affc54b59a7026571ee5d8dad000bd6e0c760c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71affc54b59a7026571ee5d8dad000bd6e0c760c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71affc54b59a7026571ee5d8dad000bd6e0c760c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71affc54b59a7026571ee5d8dad000bd6e0c760c/comments", "author": null, "committer": null, "parents": [{"sha": "ef1c051102dd6c40fc8dbaf9ab8d87b06b47b8d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef1c051102dd6c40fc8dbaf9ab8d87b06b47b8d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef1c051102dd6c40fc8dbaf9ab8d87b06b47b8d0"}], "stats": {"total": 232, "additions": 160, "deletions": 72}, "files": [{"sha": "a630bc7eabbf5b20a83adcbd8e9151d0a55fec15", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=71affc54b59a7026571ee5d8dad000bd6e0c760c", "patch": "@@ -1,3 +1,21 @@\n+2014-01-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par-ch4.adb (P_If_Expression): Rewritten to improve error recovery.\n+\t* par-ch5.adb (P_Condition): New version with expression prescanned.\n+\t* par.adb (P_Condition): New version with expression prescanned.\n+\n+2014-01-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Document that Allow_Integer_Address is ignored\n+\tif Address is not a private type.\n+\t* sem_prag.adb (Analyze_Pragma, case Allow_Integer_Address):\n+\tIgnore pragma if System.Address is not a private type.\n+\n+2014-01-21  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* namet.ads (Name_Len): Initialize to 0 to avoid accessing an\n+\tuninitialized value.\n+\n 2014-01-21  Thomas Quinot  <quinot@adacore.com>\n \n \t* gnat_rm.texi (Scalar_Storage_Order): Update documentation."}, {"sha": "80aa33d6630307b7c119eaa2afe233a3f9516345", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=71affc54b59a7026571ee5d8dad000bd6e0c760c", "patch": "@@ -1284,6 +1284,15 @@ package AddrAsInt is\n end AddrAsInt;\n @end smallexample\n \n+@noindent\n+Note that pragma @code{Allow_Integer_Address} is ignored if\n+@code{System.Address}\n+is not a private type. In implementations of @code{GNAT} where\n+System.Address is a visible integer type (notably the implementations\n+for @code{OpenVMS}), this pragma serves no purpose but is ignored\n+rather than rejected to allow common sets of sources to be used\n+in the two situations.\n+\n @node Pragma Annotate\n @unnumberedsec Pragma Annotate\n @findex Annotate"}, {"sha": "4c9fc77bf788f13f4307e534e42d2c39c09dbed4", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=71affc54b59a7026571ee5d8dad000bd6e0c760c", "patch": "@@ -130,9 +130,15 @@ package Namet is\n    --  The limit here is intended to be an infinite value that ensures that we\n    --  never overflow the buffer (names this long are too absurd to worry!)\n \n-   Name_Len : Natural;\n+   Name_Len : Natural := 0;\n    --  Length of name stored in Name_Buffer. Used as an input parameter for\n    --  Name_Find, and as an output value by Get_Name_String, or Write_Name.\n+   --  Note: in normal usage, all users of Name_Buffer/Name_Len are expected\n+   --  to initialize Name_Len appropriately. The reason we preinitialize to\n+   --  zero here is that some circuitry (e.g. Osint.Write_Program_Name) does\n+   --  a save/restore on Name_Len and Name_Buffer (1 .. Name_Len), and we do\n+   --  not want some arbitrary junk value to result in saving an arbitrarily\n+   --  long slice which would waste time and blow the stack.\n \n    -----------------------------\n    -- Types for Namet Package --"}, {"sha": "4003d96812ad767f1a7951efd08301007127a949", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 104, "deletions": 65, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=71affc54b59a7026571ee5d8dad000bd6e0c760c", "patch": "@@ -3076,100 +3076,139 @@ package body Ch4 is\n    ---------------------\n \n    function P_If_Expression return Node_Id is\n-      Exprs : constant List_Id    := New_List;\n-      Loc   : constant Source_Ptr := Token_Ptr;\n-      Cond  : Node_Id;\n-      Expr  : Node_Id;\n-      State : Saved_Scan_State;\n \n-   begin\n-      Inside_If_Expression := Inside_If_Expression + 1;\n-      Error_Msg_Ada_2012_Feature (\"|if expression\", Token_Ptr);\n-      Scan; -- past IF or ELSIF\n-      Cond := P_Condition;\n+      function P_If_Expression_Internal\n+        (Loc  : Source_Ptr;\n+         Cond : Node_Id) return Node_Id;\n+      --  This is the internal recursive routine that does all the work, it is\n+      --  recursive since it is used to process ELSIF parts, which internally\n+      --  are N_If_Expression nodes with the Is_Elsif flag set. The calling\n+      --  sequence is like the outer function except that the caller passes\n+      --  the conditional expression (scanned using P_Expression), and the\n+      --  scan pointer points just past this expression. Loc points to the\n+      --  IF or ELSIF token.\n+\n+      ------------------------------\n+      -- P_If_Expression_Internal --\n+      ------------------------------\n+\n+      function P_If_Expression_Internal\n+        (Loc  : Source_Ptr;\n+         Cond : Node_Id) return Node_Id\n+      is\n+         Exprs : constant List_Id    := New_List;\n+         Expr  : Node_Id;\n+         State : Saved_Scan_State;\n+         Eptr  : Source_Ptr;\n \n-      if Token = Tok_Then then\n-         Scan;  --  past THEN\n-         Append_To (Exprs, Cond);\n-         Append_To (Exprs, P_Expression);\n+      begin\n+         --  All cases except where we are at right paren\n \n-      else\n-         Error_Msg (\"ELSIF should be ELSE\", Loc);\n-         return Cond;\n-      end if;\n+         if Token /= Tok_Right_Paren then\n+            TF_Then;\n+            Append_To (Exprs, P_Condition (Cond));\n+            Append_To (Exprs, P_Expression);\n \n-      --  We now have scanned out IF expr THEN expr\n+         --  Case of right paren (missing THEN phrase). Note that we know this\n+         --  is the IF case, since the caller dealt with this possibility in\n+         --  the ELSIF case.\n \n-      --  Check for common error of semicolon before the ELSE\n+         else\n+            Error_Msg_BC (\"missing THEN phrase\");\n+            Append_To (Exprs, P_Condition (Cond));\n+         end if;\n \n-      if Token = Tok_Semicolon then\n-         Save_Scan_State (State);\n-         Scan; -- past semicolon\n+         --  We now have scanned out IF expr THEN expr\n \n-         if Token = Tok_Else or else Token = Tok_Elsif then\n-            Error_Msg_SP -- CODEFIX\n-              (\"|extra \"\";\"\" ignored\");\n+         --  Check for common error of semicolon before the ELSE\n \n-         else\n-            Restore_Scan_State (State);\n+         if Token = Tok_Semicolon then\n+            Save_Scan_State (State);\n+            Scan; -- past semicolon\n+\n+            if Token = Tok_Else or else Token = Tok_Elsif then\n+               Error_Msg_SP -- CODEFIX\n+                 (\"|extra \"\";\"\" ignored\");\n+\n+            else\n+               Restore_Scan_State (State);\n+            end if;\n          end if;\n-      end if;\n \n-      --  Scan out ELSIF sequence if present\n+         --  Scan out ELSIF sequence if present\n \n-      if Token = Tok_Elsif then\n-         Expr := P_If_Expression;\n+         if Token = Tok_Elsif then\n+            Eptr := Token_Ptr;\n+            Scan; -- past ELSIF\n+            Expr := P_Expression;\n \n-         if Nkind (Expr) = N_If_Expression then\n-            Set_Is_Elsif (Expr);\n+            --  If we are at a right paren, we assume the ELSIF should be ELSE\n \n-            --  Otherwise, this is an incomplete ELSIF as reported earlier,\n-            --  so treat the expression as a final ELSE for better recovery.\n-         end if;\n+            if Token = Tok_Right_Paren then\n+               Error_Msg (\"ELSIF should be ELSE\", Eptr);\n+               Append_To (Exprs, Expr);\n \n-         Append_To (Exprs, Expr);\n+            --  Otherwise we have an OK ELSIF\n \n-      --  Scan out ELSE phrase if present\n+            else\n+               Expr := P_If_Expression_Internal (Eptr, Expr);\n+               Set_Is_Elsif (Expr);\n+               Append_To (Exprs, Expr);\n+            end if;\n \n-      elsif Token = Tok_Else then\n+         --  Scan out ELSE phrase if present\n \n-         --  Scan out ELSE expression\n+         elsif Token = Tok_Else then\n \n-         Scan; -- Past ELSE\n-         Append_To (Exprs, P_Expression);\n+            --  Scan out ELSE expression\n \n-         --  Skip redundant ELSE parts\n+            Scan; -- Past ELSE\n+            Append_To (Exprs, P_Expression);\n \n-         while Token = Tok_Else loop\n-            Error_Msg_SC (\"only one ELSE part is allowed\");\n-            Scan; -- past ELSE\n-            Discard_Junk_Node (P_Expression);\n-         end loop;\n+            --  Skip redundant ELSE parts\n \n-      --  Two expression case (implied True, filled in during semantics)\n+            while Token = Tok_Else loop\n+               Error_Msg_SC (\"only one ELSE part is allowed\");\n+               Scan; -- past ELSE\n+               Discard_Junk_Node (P_Expression);\n+            end loop;\n \n-      else\n-         null;\n-      end if;\n+         --  Two expression case (implied True, filled in during semantics)\n+\n+         else\n+            null;\n+         end if;\n \n-      --  If we have an END IF, diagnose as not needed\n+         --  If we have an END IF, diagnose as not needed\n \n-      if Token = Tok_End then\n-         Error_Msg_SC (\"`END IF` not allowed at end of if expression\");\n-         Scan; -- past END\n+         if Token = Tok_End then\n+            Error_Msg_SC (\"`END IF` not allowed at end of if expression\");\n+            Scan; -- past END\n \n-         if Token = Tok_If then\n-            Scan; -- past IF;\n+            if Token = Tok_If then\n+               Scan; -- past IF;\n+            end if;\n          end if;\n-      end if;\n \n-      Inside_If_Expression := Inside_If_Expression - 1;\n+         --  Return the If_Expression node\n+\n+         return Make_If_Expression (Loc, Expressions => Exprs);\n+      end P_If_Expression_Internal;\n+\n+   --  Local variables\n+\n+      Loc     : constant Source_Ptr := Token_Ptr;\n+      If_Expr : Node_Id;\n \n-      --  Return the If_Expression node\n+   --  Start of processing for P_If_Expression\n \n-      return\n-        Make_If_Expression (Loc,\n-          Expressions => Exprs);\n+   begin\n+      Error_Msg_Ada_2012_Feature (\"|if expression\", Token_Ptr);\n+      Scan; -- past IF\n+      Inside_If_Expression := Inside_If_Expression + 1;\n+      If_Expr := P_If_Expression_Internal (Loc, P_Expression);\n+      Inside_If_Expression := Inside_If_Expression - 1;\n+      return If_Expr;\n    end P_If_Expression;\n \n    -----------------------"}, {"sha": "e20cf11a685ef37652bc8bee5a44bf52664c7493", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=71affc54b59a7026571ee5d8dad000bd6e0c760c", "patch": "@@ -1256,11 +1256,12 @@ package body Ch5 is\n    --  CONDITION ::= boolean_EXPRESSION\n \n    function P_Condition return Node_Id is\n-      Cond : Node_Id;\n-\n    begin\n-      Cond := P_Expression_No_Right_Paren;\n+      return P_Condition (P_Expression_No_Right_Paren);\n+   end P_Condition;\n \n+   function P_Condition (Cond : Node_Id) return Node_Id is\n+   begin\n       --  It is never possible for := to follow a condition, so if we get\n       --  a := we assume it is a mistyped equality. Note that we do not try\n       --  to reconstruct the tree correctly in this case, but we do at least\n@@ -1278,7 +1279,7 @@ package body Ch5 is\n \n       --  Otherwise check for redundant parentheses\n \n-      --  If the  condition is a conditional or a quantified expression, it is\n+      --  If the condition is a conditional or a quantified expression, it is\n       --  parenthesized in the context of a condition, because of a separate\n       --  syntax rule.\n "}, {"sha": "6788692864e66c497a703e0f562af7a3099c059e", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=71affc54b59a7026571ee5d8dad000bd6e0c760c", "patch": "@@ -737,7 +737,13 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n    package Ch5 is\n       function P_Condition return Node_Id;\n-      --  Scan out and return a condition\n+      --  Scan out and return a condition. Note that an error is given if\n+      --  the condition is followed by a right parenthesis.\n+\n+      function P_Condition (Cond : Node_Id) return Node_Id;\n+      --  Similar to the above, but the caller has already scanned out the\n+      --  conditional expression and passes it as an argument. This form of\n+      --  the call does not check for a following right parenthesis.\n \n       function P_Loop_Parameter_Specification return Node_Id;\n       --  Used in loop constructs and quantified expressions."}, {"sha": "347feb2206f262f749907f16baae0c02b3cd78ae", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71affc54b59a7026571ee5d8dad000bd6e0c760c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=71affc54b59a7026571ee5d8dad000bd6e0c760c", "patch": "@@ -10206,8 +10206,17 @@ package body Sem_Prag is\n \n          when Pragma_Allow_Integer_Address =>\n             GNAT_Pragma;\n+            Check_Valid_Configuration_Pragma;\n             Check_Arg_Count (0);\n-            Opt.Allow_Integer_Address := True;\n+\n+            --  If Address is a private type, then set the flag to allow\n+            --  integer address values. If Address is not private (e.g. on\n+            --  VMS, where it is an integer type), then this pragma has no\n+            --  purpose, so it is simply ignored.\n+\n+            if Is_Private_Type (RTE (RE_Address)) then\n+               Opt.Allow_Integer_Address := True;\n+            end if;\n \n          --------------\n          -- Annotate --"}]}