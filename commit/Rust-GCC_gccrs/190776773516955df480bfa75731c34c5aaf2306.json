{"sha": "190776773516955df480bfa75731c34c5aaf2306", "node_id": "C_kwDOANBUbNoAKDE5MDc3Njc3MzUxNjk1NWRmNDgwYmZhNzU3MzFjMzRjNWFhZjIzMDY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-07T08:07:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-07T08:07:38Z"}, "message": "c++: Add support for __real__/__imag__ modifications in constant expressions [PR88174]\n\nWe claim we support P0415R1 (constexpr complex), but e.g.\n #include <complex>\n\nconstexpr bool\nfoo ()\n{\n  std::complex<double> a (1.0, 2.0);\n  a += 3.0;\n  a.real (6.0);\n  return a.real () == 6.0 && a.imag () == 2.0;\n}\n\nstatic_assert (foo ());\n\nfails with\ntest.C:12:20: error: non-constant condition for static assertion\n   12 | static_assert (foo ());\n      |                ~~~~^~\ntest.C:12:20:   in \u2018constexpr\u2019 expansion of \u2018foo()\u2019\ntest.C:8:10:   in \u2018constexpr\u2019 expansion of \u2018a.std::complex<double>::real(6.0e+0)\u2019\ntest.C:12:20: error: modification of \u2018__real__ a.std::complex<double>::_M_value\u2019 is not a constant expression\n\nThe problem is we don't handle REALPART_EXPR and IMAGPART_EXPR\nin cxx_eval_store_expression.\nThe following patch attempts to support it (with a requirement\nthat those are the outermost expressions, ARRAY_REF/COMPONENT_REF\netc. are just not possible on the result of these, BIT_FIELD_REF\nwould be theoretically possible if trying to extract some bits\nfrom one part of a complex int, but I don't see how it could appear\nin the FE trees.\n\nFor these references, the code handles value being COMPLEX_CST,\nCOMPLEX_EXPR or CONSTRUCTOR_NO_CLEARING empty CONSTRUCTOR (what we use\nto represent uninitialized values for C++20 and later) and the\ncode starts by rewriting it to COMPLEX_EXPR, so that we can freely\nadjust the individual parts and later on possibly optimize it back\nto COMPLEX_CST if both halves are constant.\n\n2022-08-07  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/88174\n\t* constexpr.cc (cxx_eval_store_expression): Handle REALPART_EXPR\n\tand IMAGPART_EXPR.  Change ctors from releasing_vec to\n\tauto_vec<tree *>, adjust all uses.  For !preeval, update ctors\n\tvector.\n\n\t* g++.dg/cpp1y/constexpr-complex1.C: New test.", "tree": {"sha": "b3140f5eccf67869abd92bdc051b0dc6c1487622", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3140f5eccf67869abd92bdc051b0dc6c1487622"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/190776773516955df480bfa75731c34c5aaf2306", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/190776773516955df480bfa75731c34c5aaf2306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/190776773516955df480bfa75731c34c5aaf2306", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/190776773516955df480bfa75731c34c5aaf2306/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a46bca36b7b3a8a7e15b04225fb2b4f9b1bed62c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a46bca36b7b3a8a7e15b04225fb2b4f9b1bed62c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a46bca36b7b3a8a7e15b04225fb2b4f9b1bed62c"}], "stats": {"total": 118, "additions": 104, "deletions": 14}, "files": [{"sha": "c047fe4a2a1e66ae6d59a29e4f79572c2619d35b", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 80, "deletions": 14, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190776773516955df480bfa75731c34c5aaf2306/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190776773516955df480bfa75731c34c5aaf2306/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=190776773516955df480bfa75731c34c5aaf2306", "patch": "@@ -5732,6 +5732,20 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t  }\n \t  break;\n \n+\tcase REALPART_EXPR:\n+\t  gcc_assert (probe == target);\n+\t  vec_safe_push (refs, probe);\n+\t  vec_safe_push (refs, TREE_TYPE (probe));\n+\t  probe = TREE_OPERAND (probe, 0);\n+\t  break;\n+\n+\tcase IMAGPART_EXPR:\n+\t  gcc_assert (probe == target);\n+\t  vec_safe_push (refs, probe);\n+\t  vec_safe_push (refs, TREE_TYPE (probe));\n+\t  probe = TREE_OPERAND (probe, 0);\n+\t  break;\n+\n \tdefault:\n \t  if (evaluated)\n \t    object = probe;\n@@ -5770,7 +5784,8 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n   type = TREE_TYPE (object);\n   bool no_zero_init = true;\n \n-  releasing_vec ctors, indexes;\n+  auto_vec<tree *> ctors;\n+  releasing_vec indexes;\n   auto_vec<int> index_pos_hints;\n   bool activated_union_member_p = false;\n   bool empty_base = false;\n@@ -5810,14 +5825,36 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t  *valp = ary_ctor;\n \t}\n \n-      /* If the value of object is already zero-initialized, any new ctors for\n-\t subobjects will also be zero-initialized.  */\n-      no_zero_init = CONSTRUCTOR_NO_CLEARING (*valp);\n-\n       enum tree_code code = TREE_CODE (type);\n       tree reftype = refs->pop();\n       tree index = refs->pop();\n \n+      if (code == COMPLEX_TYPE)\n+\t{\n+\t  if (TREE_CODE (*valp) == COMPLEX_CST)\n+\t    *valp = build2 (COMPLEX_EXPR, type, TREE_REALPART (*valp),\n+\t\t\t    TREE_IMAGPART (*valp));\n+\t  else if (TREE_CODE (*valp) == CONSTRUCTOR\n+\t\t   && CONSTRUCTOR_NELTS (*valp) == 0\n+\t\t   && CONSTRUCTOR_NO_CLEARING (*valp))\n+\t    {\n+\t      tree r = build_constructor (reftype, NULL);\n+\t      CONSTRUCTOR_NO_CLEARING (r) = 1;\n+\t      *valp = build2 (COMPLEX_EXPR, type, r, r);\n+\t    }\n+\t  gcc_assert (TREE_CODE (*valp) == COMPLEX_EXPR);\n+\t  ctors.safe_push (valp);\n+\t  vec_safe_push (indexes, index);\n+\t  valp = &TREE_OPERAND (*valp, TREE_CODE (index) == IMAGPART_EXPR);\n+\t  gcc_checking_assert (refs->is_empty ());\n+\t  type = reftype;\n+\t  break;\n+\t}\n+\n+      /* If the value of object is already zero-initialized, any new ctors for\n+\t subobjects will also be zero-initialized.  */\n+      no_zero_init = CONSTRUCTOR_NO_CLEARING (*valp);\n+\n       if (code == RECORD_TYPE && is_empty_field (index))\n \t/* Don't build a sub-CONSTRUCTOR for an empty base or field, as they\n \t   have no data and might have an offset lower than previously declared\n@@ -5860,7 +5897,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t  no_zero_init = true;\n \t}\n \n-      vec_safe_push (ctors, *valp);\n+      ctors.safe_push (valp);\n       vec_safe_push (indexes, index);\n \n       constructor_elt *cep\n@@ -5922,11 +5959,11 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t     semantics are not applied on an object under construction.\n \t     They come into effect when the constructor for the most\n \t     derived object ends.\"  */\n-\t  for (tree elt : *ctors)\n+\t  for (tree *elt : ctors)\n \t    if (same_type_ignoring_top_level_qualifiers_p\n-\t\t(TREE_TYPE (const_object_being_modified), TREE_TYPE (elt)))\n+\t\t(TREE_TYPE (const_object_being_modified), TREE_TYPE (*elt)))\n \t      {\n-\t\tfail = TREE_READONLY (elt);\n+\t\tfail = TREE_READONLY (*elt);\n \t\tbreak;\n \t      }\n \t}\n@@ -5967,6 +6004,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n       valp = ctx->global->values.get (object);\n       for (unsigned i = 0; i < vec_safe_length (indexes); i++)\n \t{\n+\t  ctors[i] = valp;\n \t  constructor_elt *cep\n \t    = get_or_insert_ctor_field (*valp, indexes[i], index_pos_hints[i]);\n \t  valp = &cep->value;\n@@ -6029,17 +6067,45 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n      CONSTRUCTORs, if any.  */\n   bool c = TREE_CONSTANT (init);\n   bool s = TREE_SIDE_EFFECTS (init);\n+  if (!indexes->is_empty ())\n+    {\n+      tree last = indexes->last ();\n+      if (TREE_CODE (last) == REALPART_EXPR\n+\t  || TREE_CODE (last) == IMAGPART_EXPR)\n+\t{\n+\t  /* And canonicalize COMPLEX_EXPR into COMPLEX_CST if\n+\t     possible.  */\n+\t  tree *cexpr = ctors.last ();\n+\t  if (tree c = const_binop (COMPLEX_EXPR, TREE_TYPE (*cexpr),\n+\t\t\t\t    TREE_OPERAND (*cexpr, 0),\n+\t\t\t\t    TREE_OPERAND (*cexpr, 1)))\n+\t    *cexpr = c;\n+\t  else\n+\t    {\n+\t      TREE_CONSTANT (*cexpr)\n+\t\t= (TREE_CONSTANT (TREE_OPERAND (*cexpr, 0))\n+\t\t   & TREE_CONSTANT (TREE_OPERAND (*cexpr, 1)));\n+\t      TREE_SIDE_EFFECTS (*cexpr)\n+\t\t= (TREE_SIDE_EFFECTS (TREE_OPERAND (*cexpr, 0))\n+\t\t   | TREE_SIDE_EFFECTS (TREE_OPERAND (*cexpr, 1)));\n+\t    }\n+\t  c = TREE_CONSTANT (*cexpr);\n+\t  s = TREE_SIDE_EFFECTS (*cexpr);\n+\t}\n+    }\n   if (!c || s || activated_union_member_p)\n-    for (tree elt : *ctors)\n+    for (tree *elt : ctors)\n       {\n+\tif (TREE_CODE (*elt) != CONSTRUCTOR)\n+\t  continue;\n \tif (!c)\n-\t  TREE_CONSTANT (elt) = false;\n+\t  TREE_CONSTANT (*elt) = false;\n \tif (s)\n-\t  TREE_SIDE_EFFECTS (elt) = true;\n+\t  TREE_SIDE_EFFECTS (*elt) = true;\n \t/* Clear CONSTRUCTOR_NO_CLEARING since we've activated a member of\n \t   this union.  */\n-\tif (TREE_CODE (TREE_TYPE (elt)) == UNION_TYPE)\n-\t  CONSTRUCTOR_NO_CLEARING (elt) = false;\n+\tif (TREE_CODE (TREE_TYPE (*elt)) == UNION_TYPE)\n+\t  CONSTRUCTOR_NO_CLEARING (*elt) = false;\n       }\n \n   if (lval)"}, {"sha": "8bb24cb277563d4f3aabd713366e7ddf87b46863", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-complex1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/190776773516955df480bfa75731c34c5aaf2306/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-complex1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/190776773516955df480bfa75731c34c5aaf2306/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-complex1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-complex1.C?ref=190776773516955df480bfa75731c34c5aaf2306", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/88174\n+// { dg-do compile { target c++14 } }\n+\n+constexpr bool\n+foo (double x, double y, double z, double w)\n+{\n+  __complex__ double a = 0;\n+  __real__ a = x;\n+  __imag__ a = y;\n+#if __cpp_constexpr >= 201907L\n+  __complex__ double b;\n+  __real__ b = z;\n+#else\n+  __complex__ double b = z;\n+#endif\n+  __imag__ b = w;\n+  a += b;\n+  a -= b;\n+  a *= b;\n+  a /= b;\n+  return __real__ a == x && __imag__ a == y;\n+}\n+\n+static_assert (foo (1.0, 2.0, 3.0, 4.0), \"\");"}]}