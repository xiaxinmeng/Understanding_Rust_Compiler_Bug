{"sha": "22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJiZTIzNDk1YTFmMGNkMWFlNmExYWNhMzJjMzllZGI5ZjdhOWM1MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2015-07-21T13:30:06Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-07-21T13:30:06Z"}, "message": "target.c (gomp_offload_image_to_device): Rename to ...\n\n\tlibgomp/\n\t* target.c (gomp_offload_image_to_device): Rename to ...\n\t(gomp_load_image_to_device): ... here.\n\t(GOMP_offload_register): Adjust call.\n\t(gomp_init_device): Likewise.\n\t(gomp_unload_image_from_device): New.  Broken out of ...\n\t(GOMP_offload_unregister): ... here.  Call it.\n\t(gomp_unload_device): New.\n\t* libgomp.h (gomp_unload_device): Declare.\n\t* oacc-init.c (acc_shutdown_1): Unload from device before deleting\n\tmem maps.\n\n\tgcc/\n\t* config/nvptx/mkoffload.c (process): Add static destructor call.\n\nFrom-SVN: r226039", "tree": {"sha": "5346a618826d07eaa35796ae94daf5f43300dc8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5346a618826d07eaa35796ae94daf5f43300dc8a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/comments", "author": null, "committer": null, "parents": [{"sha": "c5189d8e679126d652b23761fb95bc5042c19ea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5189d8e679126d652b23761fb95bc5042c19ea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5189d8e679126d652b23761fb95bc5042c19ea9"}], "stats": {"total": 198, "additions": 130, "deletions": 68}, "files": [{"sha": "69e5bbef35b5b57a8a6f812199bb1de8b11e3ac8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "patch": "@@ -1,3 +1,7 @@\n+2015-07-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/nvptx/mkoffload.c (process): Add static destructor call.\n+\n 2015-07-21  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR middle-end/66915"}, {"sha": "1e154c8412c6b7d416b17959ac69234244d7e028", "filename": "gcc/config/nvptx/mkoffload.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c?ref=22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "patch": "@@ -880,18 +880,29 @@ process (FILE *in, FILE *out)\n   fprintf (out, \"#ifdef __cplusplus\\n\"\n \t   \"extern \\\"C\\\" {\\n\"\n \t   \"#endif\\n\");\n+\n   fprintf (out, \"extern void GOMP_offload_register\"\n \t   \" (const void *, int, const void *);\\n\");\n+  fprintf (out, \"extern void GOMP_offload_unregister\"\n+\t   \" (const void *, int, const void *);\\n\");\n+\n   fprintf (out, \"#ifdef __cplusplus\\n\"\n \t   \"}\\n\"\n \t   \"#endif\\n\");\n \n   fprintf (out, \"extern const void *const __OFFLOAD_TABLE__[];\\n\\n\");\n-  fprintf (out, \"static __attribute__((constructor)) void init (void)\\n{\\n\");\n-  fprintf (out, \"  GOMP_offload_register (__OFFLOAD_TABLE__, %d,\\n\",\n-\t   GOMP_DEVICE_NVIDIA_PTX);\n-  fprintf (out, \"                         &target_data);\\n\");\n-  fprintf (out, \"};\\n\");\n+\n+  fprintf (out, \"static __attribute__((constructor)) void init (void)\\n\"\n+\t   \"{\\n\"\n+\t   \"  GOMP_offload_register (__OFFLOAD_TABLE__, %d/*NVIDIA_PTX*/,\\n\"\n+\t   \"                         &target_data);\\n\"\n+\t   \"};\\n\", GOMP_DEVICE_NVIDIA_PTX);\n+\n+  fprintf (out, \"static __attribute__((destructor)) void fini (void)\\n\"\n+\t   \"{\\n\"\n+\t   \"  GOMP_offload_unregister (__OFFLOAD_TABLE__, %d/*NVIDIA_PTX*/,\\n\"\n+\t   \"                           &target_data);\\n\"\n+\t   \"};\\n\", GOMP_DEVICE_NVIDIA_PTX);\n }\n \n static void"}, {"sha": "12c9e947e20469e210470466ef6fcfb239f009a0", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "patch": "@@ -1,3 +1,16 @@\n+2015-07-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* target.c (gomp_offload_image_to_device): Rename to ...\n+\t(gomp_load_image_to_device): ... here.\n+\t(GOMP_offload_register): Adjust call.\n+\t(gomp_init_device): Likewise.\n+\t(gomp_unload_image_from_device): New.  Broken out of ...\n+\t(GOMP_offload_unregister): ... here.  Call it.\n+\t(gomp_unload_device): New.\n+\t* libgomp.h (gomp_unload_device): Declare.\n+\t* oacc-init.c (acc_shutdown_1): Unload from device before deleting\n+\tmem maps.\n+\n 2015-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* oacc-parallel.c (GOACC_parallel): Move variadic handling into"}, {"sha": "ac40e2aa5100b89477ebe19bfd29221ab29c79d1", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "patch": "@@ -782,6 +782,7 @@ extern void gomp_unmap_vars (struct target_mem_desc *, bool);\n extern void gomp_init_device (struct gomp_device_descr *);\n extern void gomp_free_memmap (struct splay_tree_s *);\n extern void gomp_fini_device (struct gomp_device_descr *);\n+extern void gomp_unload_device (struct gomp_device_descr *);\n \n /* work.c */\n "}, {"sha": "105d9dc45de99b62213917c83885bc1c98656174", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "patch": "@@ -252,6 +252,18 @@ acc_shutdown_1 (acc_device_t d)\n   /* Get the base device for this device type.  */\n   base_dev = resolve_device (d, true);\n \n+  ndevs = base_dev->get_num_devices_func ();\n+\n+  /* Unload all the devices of this type that have been opened.  */\n+  for (i = 0; i < ndevs; i++)\n+    {\n+      struct gomp_device_descr *acc_dev = &base_dev[i];\n+\n+      gomp_mutex_lock (&acc_dev->lock);\n+      gomp_unload_device (acc_dev);\n+      gomp_mutex_unlock (&acc_dev->lock);\n+    }\n+  \n   gomp_mutex_lock (&goacc_thread_lock);\n \n   /* Free target-specific TLS data and close all devices.  */\n@@ -290,7 +302,6 @@ acc_shutdown_1 (acc_device_t d)\n \n   gomp_mutex_unlock (&goacc_thread_lock);\n \n-  ndevs = base_dev->get_num_devices_func ();\n \n   /* Close all the devices of this type that have been opened.  */\n   for (i = 0; i < ndevs; i++)"}, {"sha": "7b3d0f9572d555fc7722c9a651635689f20d6205", "filename": "libgomp/target.c", "status": "modified", "additions": 84, "deletions": 62, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=22be23495a1f0cd1ae6a1aca32c39edb9f7a9c51", "patch": "@@ -638,12 +638,13 @@ gomp_update (struct gomp_device_descr *devicep, size_t mapnum, void **hostaddrs,\n \n /* Load image pointed by TARGET_DATA to the device, specified by DEVICEP.\n    And insert to splay tree the mapping between addresses from HOST_TABLE and\n-   from loaded target image.  */\n+   from loaded target image.  We rely in the host and device compiler\n+   emitting variable and functions in the same order.  */\n \n static void\n-gomp_offload_image_to_device (struct gomp_device_descr *devicep,\n-\t\t\t      const void *host_table, const void *target_data,\n-\t\t\t      bool is_register_lock)\n+gomp_load_image_to_device (struct gomp_device_descr *devicep,\n+\t\t\t   const void *host_table, const void *target_data,\n+\t\t\t   bool is_register_lock)\n {\n   void **host_func_table = ((void ***) host_table)[0];\n   void **host_funcs_end  = ((void ***) host_table)[1];\n@@ -658,7 +659,8 @@ gomp_offload_image_to_device (struct gomp_device_descr *devicep,\n   /* Load image to device and get target addresses for the image.  */\n   struct addr_pair *target_table = NULL;\n   int i, num_target_entries\n-    = devicep->load_image_func (devicep->target_id, target_data, &target_table);\n+    = devicep->load_image_func (devicep->target_id, target_data,\n+\t\t\t\t&target_table);\n \n   if (num_target_entries != num_funcs + num_vars)\n     {\n@@ -725,6 +727,60 @@ gomp_offload_image_to_device (struct gomp_device_descr *devicep,\n   free (target_table);\n }\n \n+/* Unload the mappings described by target_data from device DEVICE_P.\n+   The device must be locked.   */\n+\n+static void\n+gomp_unload_image_from_device (struct gomp_device_descr *devicep,\n+\t\t\t       const void *host_table, const void *target_data)\n+{\n+  void **host_func_table = ((void ***) host_table)[0];\n+  void **host_funcs_end  = ((void ***) host_table)[1];\n+  void **host_var_table  = ((void ***) host_table)[2];\n+  void **host_vars_end   = ((void ***) host_table)[3];\n+\n+  /* The func table contains only addresses, the var table contains addresses\n+     and corresponding sizes.  */\n+  int num_funcs = host_funcs_end - host_func_table;\n+  int num_vars  = (host_vars_end - host_var_table) / 2;\n+\n+  unsigned j;\n+  struct splay_tree_key_s k;\n+  splay_tree_key node = NULL;\n+\n+  /* Find mapping at start of node array */\n+  if (num_funcs || num_vars)\n+    {\n+      k.host_start = (num_funcs ? (uintptr_t) host_func_table[0]\n+\t\t      : (uintptr_t) host_var_table[0]);\n+      k.host_end = k.host_start + 1;\n+      node = splay_tree_lookup (&devicep->mem_map, &k);\n+    }\n+  \n+  devicep->unload_image_func (devicep->target_id, target_data);\n+\n+  /* Remove mappings from splay tree.  */\n+  for (j = 0; j < num_funcs; j++)\n+    {\n+      k.host_start = (uintptr_t) host_func_table[j];\n+      k.host_end = k.host_start + 1;\n+      splay_tree_remove (&devicep->mem_map, &k);\n+    }\n+\n+  for (j = 0; j < num_vars; j++)\n+    {\n+      k.host_start = (uintptr_t) host_var_table[j * 2];\n+      k.host_end = k.host_start + (uintptr_t) host_var_table[j * 2 + 1];\n+      splay_tree_remove (&devicep->mem_map, &k);\n+    }\n+\n+  if (node)\n+    {\n+      free (node->tgt);\n+      free (node);\n+    }\n+}\n+\n /* This function should be called from every offload image while loading.\n    It gets the descriptor of the host func and var tables HOST_TABLE, TYPE of\n    the target, and TARGET_DATA needed by target plugin.  */\n@@ -742,7 +798,7 @@ GOMP_offload_register (const void *host_table, int target_type,\n       struct gomp_device_descr *devicep = &devices[i];\n       gomp_mutex_lock (&devicep->lock);\n       if (devicep->type == target_type && devicep->is_initialized)\n-\tgomp_offload_image_to_device (devicep, host_table, target_data, true);\n+\tgomp_load_image_to_device (devicep, host_table, target_data, true);\n       gomp_mutex_unlock (&devicep->lock);\n     }\n \n@@ -767,69 +823,17 @@ void\n GOMP_offload_unregister (const void *host_table, int target_type,\n \t\t\t const void *target_data)\n {\n-  void **host_func_table = ((void ***) host_table)[0];\n-  void **host_funcs_end  = ((void ***) host_table)[1];\n-  void **host_var_table  = ((void ***) host_table)[2];\n-  void **host_vars_end   = ((void ***) host_table)[3];\n   int i;\n \n-  /* The func table contains only addresses, the var table contains addresses\n-     and corresponding sizes.  */\n-  int num_funcs = host_funcs_end - host_func_table;\n-  int num_vars  = (host_vars_end - host_var_table) / 2;\n-\n   gomp_mutex_lock (&register_lock);\n \n   /* Unload image from all initialized devices.  */\n   for (i = 0; i < num_devices; i++)\n     {\n-      int j;\n       struct gomp_device_descr *devicep = &devices[i];\n       gomp_mutex_lock (&devicep->lock);\n-      if (devicep->type != target_type || !devicep->is_initialized)\n-\t{\n-\t  gomp_mutex_unlock (&devicep->lock);\n-\t  continue;\n-\t}\n-\n-      devicep->unload_image_func (devicep->target_id, target_data);\n-\n-      /* Remove mapping from splay tree.  */\n-      struct splay_tree_key_s k;\n-      splay_tree_key node = NULL;\n-      if (num_funcs > 0)\n-\t{\n-\t  k.host_start = (uintptr_t) host_func_table[0];\n-\t  k.host_end = k.host_start + 1;\n-\t  node = splay_tree_lookup (&devicep->mem_map, &k);\n-\t}\n-      else if (num_vars > 0)\n-\t{\n-\t  k.host_start = (uintptr_t) host_var_table[0];\n-\t  k.host_end = k.host_start + (uintptr_t) host_var_table[1];\n-\t  node = splay_tree_lookup (&devicep->mem_map, &k);\n-\t}\n-\n-      for (j = 0; j < num_funcs; j++)\n-\t{\n-\t  k.host_start = (uintptr_t) host_func_table[j];\n-\t  k.host_end = k.host_start + 1;\n-\t  splay_tree_remove (&devicep->mem_map, &k);\n-\t}\n-\n-      for (j = 0; j < num_vars; j++)\n-\t{\n-\t  k.host_start = (uintptr_t) host_var_table[j * 2];\n-\t  k.host_end = k.host_start + (uintptr_t) host_var_table[j * 2 + 1];\n-\t  splay_tree_remove (&devicep->mem_map, &k);\n-\t}\n-\n-      if (node)\n-\t{\n-\t  free (node->tgt);\n-\t  free (node);\n-\t}\n-\n+      if (devicep->type == target_type && devicep->is_initialized)\n+\tgomp_unload_image_from_device (devicep, host_table, target_data);\n       gomp_mutex_unlock (&devicep->lock);\n     }\n \n@@ -858,13 +862,31 @@ gomp_init_device (struct gomp_device_descr *devicep)\n     {\n       struct offload_image_descr *image = &offload_images[i];\n       if (image->type == devicep->type)\n-\tgomp_offload_image_to_device (devicep, image->host_table,\n-\t\t\t\t      image->target_data, false);\n+\tgomp_load_image_to_device (devicep, image->host_table,\n+\t\t\t\t   image->target_data, false);\n     }\n \n   devicep->is_initialized = true;\n }\n \n+attribute_hidden void\n+gomp_unload_device (struct gomp_device_descr *devicep)\n+{\n+  if (devicep->is_initialized)\n+    {\n+      unsigned i;\n+      \n+      /* Unload from device all images registered at the moment.  */\n+      for (i = 0; i < num_offload_images; i++)\n+\t{\n+\t  struct offload_image_descr *image = &offload_images[i];\n+\t  if (image->type == devicep->type)\n+\t    gomp_unload_image_from_device (devicep, image->host_table,\n+\t\t\t\t\t   image->target_data);\n+\t}\n+    }\n+}\n+\n /* Free address mapping tables.  MM must be locked on entry, and remains locked\n    on return.  */\n "}]}