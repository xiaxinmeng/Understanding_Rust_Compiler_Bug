{"sha": "3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q3ZGUxZmEwM2JkN2RkNmM1Yjk4MjZjYjE0ZWE0ZGIyZWEwM2M2Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-15T17:52:25Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-15T17:52:25Z"}, "message": "cp-tree.h (lang_type): Add documentation.\n\n\t* cp-tree.h (lang_type): Add documentation.\n\t* decl2.c (handle_class_head): Create template declarations here,\n\tas appropriate.\n\t* parse.y (class_head): Return whether or not we entered a new\n\tscope, as well as the type named.\n\t(named_class_head): Likewise.\n\t(named_complex_class_head_sans_basetype): Likewise.\n\t(structsp): Adjust accordingly.  Pop scope when required.\n\t* parse.c: Regenerated.\n\t* pt.c (check_default_tmpl_args): Robustify.\n\t(redeclare_class_template): Likewise.\n\t(instantiate_class_template): An instantiation of an\n\tanonymous union is itself an anonymous union.\n\t* semantics.c (begin_class_definition): Don't create template\n\tdeclarations here.\n\nFrom-SVN: r26475", "tree": {"sha": "353c00ef2b3c60285c7f29faa543d98b5a7a5eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/353c00ef2b3c60285c7f29faa543d98b5a7a5eca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/comments", "author": null, "committer": null, "parents": [{"sha": "08967681aff5889301500fe0d126c32c1a95a0ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08967681aff5889301500fe0d126c32c1a95a0ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08967681aff5889301500fe0d126c32c1a95a0ac"}], "stats": {"total": 8423, "additions": 4263, "deletions": 4160}, "files": [{"sha": "9429875e8524e9d15a936d7e65fa953ea5b4cd4c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "patch": "@@ -1,3 +1,21 @@\n+1999-04-15  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (lang_type): Add documentation.\n+\t* decl2.c (handle_class_head): Create template declarations here,\n+\tas appropriate.\n+\t* parse.y (class_head): Return whether or not we entered a new\n+\tscope, as well as the type named.\n+\t(named_class_head): Likewise.\n+\t(named_complex_class_head_sans_basetype): Likewise.\n+\t(structsp): Adjust accordingly.  Pop scope when required.\n+\t* parse.c: Regenerated.\n+\t* pt.c (check_default_tmpl_args): Robustify.\n+\t(redeclare_class_template): Likewise.\n+\t(instantiate_class_template): An instantiation of an\n+\tanonymous union is itself an anonymous union.\n+\t* semantics.c (begin_class_definition): Don't create template\n+\tdeclarations here.\n+\t\n 1999-04-15  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* parse.y (after_type_declarator_intern): New nonterminal.\n@@ -23,7 +41,7 @@\n \t(pop_nested_class): Likewise.\n \t* decl.c (poplevel_class): Declare it here, and make it static.\n \t(poplevel): Handle class scopes.\n-\t(pop_level_class): Don't take an rgument.  Simplify.\n+\t(poplevel_class): Don't take an rgument.  Simplify.\n \t(pop_everything): Pass no arguments to pop_nested_class.\n \t(cp_finish_decl): Pass no arguments to popclass.\n \t(grokdeclarator): Pass no arguments to pop_nested_class."}, {"sha": "a7d27ac9a692d7ec70356c915c3eb643d2e972c7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "patch": "@@ -737,6 +737,9 @@ struct lang_type\n       unsigned is_partial_instantiation : 1;\n       unsigned has_mutable : 1;\n       unsigned com_interface : 1;\n+      /* When adding a flag here, consider whether or not it ought to\n+\t apply to a template instance if it applies to the template.\n+\t If so, make sure to copy it in instantiate_class_template!  */\n \n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a"}, {"sha": "c68e25a76b2a8d2c18934394d6ba80df5d1a3438", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "patch": "@@ -5040,23 +5040,41 @@ mark_used (decl)\n     instantiate_decl (decl);\n }\n \n-/* Helper function for named_class_head_sans_basetype nonterminal.  */\n+/* Helper function for named_class_head_sans_basetype nonterminal.  We\n+   have just seen something of the form `AGGR SCOPE::ID'.  Return a\n+   TYPE_DECL for the type declared by ID in SCOPE.  */\n \n tree\n handle_class_head (aggr, scope, id)\n      tree aggr, scope, id;\n {\n+  tree decl;\n+\n   if (TREE_CODE (id) == TYPE_DECL)\n-    return id;\n-  if (DECL_CLASS_TEMPLATE_P (id))\n-    return DECL_TEMPLATE_RESULT (id);\n+    decl = id;\n+  else if (DECL_CLASS_TEMPLATE_P (id))\n+    decl = DECL_TEMPLATE_RESULT (id);\n+  else \n+    {\n+      if (scope)\n+\tcp_error (\"`%T' does not have a nested type named `%D'\", scope, id);\n+      else\n+\tcp_error (\"no file-scope type named `%D'\", id);\n+      \n+      decl = TYPE_MAIN_DECL (xref_tag (aggr, make_anon_name (), 1));\n+    }\n \n-  if (scope)\n-    cp_error (\"`%T' does not have a nested type named `%D'\", scope, id);\n-  else\n-    cp_error (\"no file-scope type named `%D'\", id);\n+  /* This syntax is only allowed when we're defining a type, so we\n+     enter the SCOPE.  */\n+  push_scope (CP_DECL_CONTEXT (decl));\n+\n+  /* If we see something like:\n \n-  id = xref_tag\n-    (aggr, make_anon_name (), 1);\n-  return TYPE_MAIN_DECL (id);\n+       template <typename T> struct S::I ....\n+       \n+     we must create a TEMPLATE_DECL for the nested type.  */\n+  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n+    decl = push_template_decl (decl);\n+\n+  return decl;\n }"}, {"sha": "ec99d60716ab924c6671616f73d408e56722cdf4", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 4107, "deletions": 4111, "changes": 8218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c"}, {"sha": "d9913e33a64ba2c9f867ef2556d897dabbb359bd", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "patch": "@@ -239,10 +239,11 @@ empty_parms ()\n %type <ttype> component_constructor_declarator\n %type <ttype> fn.def2 return_id fn.defpen constructor_declarator\n %type <itype> ctor_initializer_opt function_try_block\n-%type <ttype> named_class_head named_class_head_sans_basetype\n-%type <ttype> named_complex_class_head_sans_basetype\n+%type <ttype> named_class_head_sans_basetype\n+%type <ftype> class_head named_class_head \n+%type <ftype> named_complex_class_head_sans_basetype \n %type <ttype> unnamed_class_head\n-%type <ttype> class_head base_class_list\n+%type <ttype> base_class_list\n %type <ttype> base_class_access_list\n %type <ttype> base_class maybe_base_class_list base_class.1\n %type <ttype> exception_specification_opt ansi_raise_identifier ansi_raise_identifiers\n@@ -2140,7 +2141,7 @@ structsp:\n \t\t    cp_pedwarn (\"using `typename' outside of template\"); }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n \t| class_head '{'\n-                { $<ttype>1 = begin_class_definition ($<ttype>1); }\n+                { $1.t = begin_class_definition ($1.t); }\n           opt.component_decl_list '}' maybe_attribute\n \t\t{ \n \t\t  int semi;\n@@ -2149,7 +2150,7 @@ structsp:\n \t\t    yychar = YYLEX;\n \t\t  semi = yychar == ';';\n \n-\t\t  $<ttype>$ = finish_class_definition ($1, $6, semi); \n+\t\t  $<ttype>$ = finish_class_definition ($1.t, $6, semi); \n \t\t}\n \t  pending_defargs\n                 {\n@@ -2158,20 +2159,24 @@ structsp:\n \t  pending_inlines\n                 {\n \t\t  finish_inline_definitions ();\n+\t\t  if ($1.new_type_flag)\n+\t\t    pop_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL ($<ttype>7)));\n \t\t  $$.t = $<ttype>7;\n \t\t  $$.new_type_flag = 1; \n \t\t}\n \t| class_head  %prec EMPTY\n \t\t{\n+\t\t  if ($1.new_type_flag)\n+\t\t    pop_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL ($1.t)));\n \t\t  $$.new_type_flag = 0;\n-\t\t  if (TYPE_BINFO ($1) == NULL_TREE)\n+\t\t  if (TYPE_BINFO ($1.t) == NULL_TREE)\n \t\t    {\n-\t\t      cp_error (\"%T is not a class type\", $1);\n+\t\t      cp_error (\"%T is not a class type\", $1.t);\n \t\t      $$.t = error_mark_node;\n \t\t    } \n \t\t  else\n \t\t    {\n-\t\t      $$.t = $1;\n+\t\t      $$.t = $1.t;\n \t\t      /* struct B: public A; is not accepted by the WP grammar.  */\n \t\t      if (TYPE_BINFO_BASETYPES ($$.t) && !TYPE_SIZE ($$.t)\n \t\t\t  && ! TYPE_BEING_DEFINED ($$.t))\n@@ -2228,63 +2233,77 @@ named_complex_class_head_sans_basetype:\n \t  aggr nested_name_specifier identifier\n \t\t{\n \t\t  current_aggr = $1;\n-\t\t  $$ = handle_class_head ($1, $2, $3);\n+\t\t  $$.t = handle_class_head ($1, $2, $3);\n+\t\t  $$.new_type_flag = 1;\n \t\t}\n \t| aggr global_scope nested_name_specifier identifier\n \t\t{\n \t\t  current_aggr = $1;\n-\t\t  $$ = handle_class_head ($1, $3, $4);\n+\t\t  $$.t = handle_class_head ($1, $3, $4);\n+\t\t  $$.new_type_flag = 1;\n \t\t}\n \t| aggr global_scope identifier\n \t\t{\n \t\t  current_aggr = $1;\n-\t\t  $$ = handle_class_head ($1, NULL_TREE, $3);\n+\t\t  $$.t = handle_class_head ($1, NULL_TREE, $3);\n+\t\t  $$.new_type_flag = 1;\n \t\t}\n \t| aggr apparent_template_type\n-\t\t{ current_aggr = $$; $$ = $2; }\n+\t\t{ \n+\t\t  current_aggr = $1; \n+\t\t  $$.t = $2;\n+\t\t  $$.new_type_flag = 0;\n+\t\t}\n \t| aggr nested_name_specifier apparent_template_type\n-\t\t{ current_aggr = $$; $$ = $3; }\n+\t\t{ \n+\t\t  current_aggr = $1; \n+\t\t  $$.t = $3;\n+\t\t  if (CP_DECL_CONTEXT ($$.t))\n+\t\t    push_scope (CP_DECL_CONTEXT ($$.t));\n+\t\t  $$.new_type_flag = 1;\n+\t\t}\n \t;\n \n named_class_head:\n \t  named_class_head_sans_basetype  %prec EMPTY\n-\t\t{ $$ = xref_tag (current_aggr, $1, 1); }\n+\t\t{ \n+\t\t  $$.t = xref_tag (current_aggr, $1, 1); \n+\t\t  $$.new_type_flag = 0;\n+\t\t}\n \t| named_class_head_sans_basetype_defn \n                 { $<ttype>$ = xref_tag (current_aggr, $1, 0); }\n           /* Class name is unqualified, so we look for base classes\n              in the current scope.  */\n           maybe_base_class_list  %prec EMPTY\n \t\t{ \n-\t\t  $$ = $<ttype>2;\n+\t\t  $$.t = $<ttype>2;\n+\t\t  $$.new_type_flag = 0;\n \t\t  if ($3)\n                     xref_basetypes (current_aggr, $1, $<ttype>2, $3); \n \t\t}\n \t| named_complex_class_head_sans_basetype \n-                { \n-\t\t  if ($1 != error_mark_node)\n-\t\t    push_scope (CP_DECL_CONTEXT ($1)); \n-\t\t}\n \t  maybe_base_class_list\n \t\t{ \n-\t\t  if ($1 != error_mark_node)\n+\t\t  if ($1.t != error_mark_node)\n \t\t    {\n-\t\t      pop_scope (CP_DECL_CONTEXT ($1));\n-\t\t      $$ = TREE_TYPE ($1);\n+\t\t      $$.t = TREE_TYPE ($1.t);\n+\t\t      $$.new_type_flag = $1.new_type_flag;\n \t\t      if (current_aggr == union_type_node\n-\t\t\t  && TREE_CODE ($$) != UNION_TYPE)\n-\t\t\tcp_pedwarn (\"`union' tag used in declaring `%#T'\", $$);\n-\t\t      else if (TREE_CODE ($$) == UNION_TYPE\n+\t\t\t  && TREE_CODE ($$.t) != UNION_TYPE)\n+\t\t\tcp_pedwarn (\"`union' tag used in declaring `%#T'\", \n+\t\t\t\t    $$.t);\n+\t\t      else if (TREE_CODE ($$.t) == UNION_TYPE\n \t\t\t       && current_aggr != union_type_node)\n \t\t\tcp_pedwarn (\"non-`union' tag used in declaring `%#T'\", $$);\n-\t\t      else if (TREE_CODE ($$) == RECORD_TYPE)\n+\t\t      else if (TREE_CODE ($$.t) == RECORD_TYPE)\n \t\t\t/* We might be specializing a template with a different\n \t\t\t   class-key; deal.  */\n-\t\t\tCLASSTYPE_DECLARED_CLASS ($$) = (current_aggr\n-\t\t\t\t\t\t\t == class_type_node);\n-\t\t      if ($3)\n+\t\t\tCLASSTYPE_DECLARED_CLASS ($$.t) \n+\t\t\t  = (current_aggr == class_type_node);\n+\t\t      if ($2)\n \t\t\t{\n-\t\t\t  maybe_process_partial_specialization ($$);\n-\t\t\t  xref_basetypes (current_aggr, $1, $$, $3); \n+\t\t\t  maybe_process_partial_specialization ($$.t);\n+\t\t\t  xref_basetypes (current_aggr, $1.t, $$.t, $2); \n \t\t\t}\n \t\t    }\n \t\t}\n@@ -2296,8 +2315,16 @@ unnamed_class_head:\n \t\t  yyungetc ('{', 1); }\n \t;\n \n+/* The tree output of this nonterminal a declarationf or the type\n+   named.  If NEW_TYPE_FLAG is set, then the name used in this\n+   class-head was explicitly qualified, e.g.:  `struct X::Y'.  We have\n+   already called push_scope for X.  */\n class_head:\n \t  unnamed_class_head\n+                {\n+\t\t  $$.t = $1;\n+\t\t  $$.new_type_flag = 0;\n+\t\t}\n \t| named_class_head\n \t;\n "}, {"sha": "d73f18299f64737a106903f54785db7beab21a58", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "patch": "@@ -2170,6 +2170,7 @@ check_default_tmpl_args (decl, parms, is_primary, is_partial)\n   if (current_class_type\n       && !TYPE_BEING_DEFINED (current_class_type)\n       && DECL_REAL_CONTEXT (decl) == current_class_type\n+      && DECL_LANG_SPECIFIC (decl)\n       && DECL_DEFINED_IN_CLASS_P (decl)) \n     /* We already checked these parameters when the template was\n        declared, so there's no need to do it again now.  This is an\n@@ -2495,10 +2496,17 @@ redeclare_class_template (type, parms)\n      tree type;\n      tree parms;\n {\n-  tree tmpl = CLASSTYPE_TI_TEMPLATE (type);\n+  tree tmpl;\n   tree tmpl_parms;\n   int i;\n \n+  if (!TYPE_TEMPLATE_INFO (type))\n+    {\n+      cp_error (\"`%T' is not a template type\", type);\n+      return;\n+    }\n+\n+  tmpl = TYPE_TI_TEMPLATE (type);\n   if (!PRIMARY_TEMPLATE_P (tmpl))\n     /* The type is nested in some template class.  Nothing to worry\n        about here; there are no new template parameters for the nested\n@@ -4816,6 +4824,8 @@ instantiate_class_template (type)\n   TYPE_PACKED (type) = TYPE_PACKED (pattern);\n   TYPE_ALIGN (type) = TYPE_ALIGN (pattern);\n   TYPE_FOR_JAVA (type) = TYPE_FOR_JAVA (pattern); /* For libjava's JArray<T> */\n+  if (ANON_UNION_TYPE_P (pattern))\n+    SET_ANON_UNION_TYPE_P (type);\n \n   /* We must copy the arguments to the permanent obstack since\n      during the tsubst'ing below they may wind up in the"}, {"sha": "6ed5a1e137b6d6422e9fa22cf0b85062155bbe25", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "patch": "@@ -1290,11 +1290,6 @@ begin_class_definition (t)\n       pushtag (TYPE_IDENTIFIER (t), t, 0);\n     }\n   maybe_process_partial_specialization (t);\n-  if (processing_template_decl\n-      && ! CLASSTYPE_TEMPLATE_SPECIALIZATION (t)\n-      && TYPE_CONTEXT (t) && TYPE_P (TYPE_CONTEXT (t))\n-      && ! current_class_type)\n-    push_template_decl (TYPE_STUB_DECL (t));\n   pushclass (t, 1);\n   TYPE_BEING_DEFINED (t) = 1;\n   /* Reset the interface data, at the earliest possible"}, {"sha": "0c1e5460c4ff94895e2f28792c23e2a4bb4bdc34", "filename": "gcc/testsuite/g++.old-deja/g++.other/lookup13.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Flookup13.C?ref=3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "patch": "@@ -0,0 +1,18 @@\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+int main() \n+{\n+  typedef double I;\n+ \n+  struct S1 {\n+    typedef char I;\n+    \n+    struct S2;\n+  };\n+  \n+  struct S1::S2 {\n+    typedef I J;\n+  };\n+ \n+  return !(sizeof (S1::S2::J) == 1);\n+}"}, {"sha": "f064e4ecefd99f169fbbdf4b01229aecbc5c1520", "filename": "gcc/testsuite/g++.old-deja/g++.pt/union2.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funion2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funion2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Funion2.C?ref=3d7de1fa03bd7dd6c5b9826cb14ea4db2ea03c6c", "patch": "@@ -0,0 +1,18 @@\n+// Build don't link:\n+// Origin: David Mazieres <dm@amsterdam.lcs.mit.edu>\n+\n+template<class T> struct vector_base {\n+  typedef T elm_t;\n+protected:\n+  union {\n+    double alignment_hack;\n+    char defbuf_space[2 * sizeof (elm_t)];\n+  };\n+  elm_t *def_basep () { return reinterpret_cast<elm_t *> (defbuf_space); }\n+};\n+\n+template<class T> struct vector : public vector_base<T> {\n+  vector () { def_basep (); }\n+};\n+\n+vector<int> iv;"}]}