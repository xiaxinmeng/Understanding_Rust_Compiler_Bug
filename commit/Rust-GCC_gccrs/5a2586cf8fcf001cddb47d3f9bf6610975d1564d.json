{"sha": "5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEyNTg2Y2Y4ZmNmMDAxY2RkYjQ3ZDNmOWJmNjYxMDk3NWQxNTY0ZA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-08-18T01:04:43Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-08-18T01:04:43Z"}, "message": "Makefile.am, [...]: Imported GC 6.0 and merged local changes.\n\n\t* Makefile.am, acinclude.m4, configure.in: Imported GC 6.0 and\n\tmerged local changes.\n\nFrom-SVN: r44994", "tree": {"sha": "0a038d94cc4acd44c0926f011247f6b7969fa84b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a038d94cc4acd44c0926f011247f6b7969fa84b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/comments", "author": null, "committer": null, "parents": [{"sha": "eed566698034311c58eea585da1ddb5a6e0807fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eed566698034311c58eea585da1ddb5a6e0807fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eed566698034311c58eea585da1ddb5a6e0807fb"}], "stats": {"total": 1981, "additions": 1274, "deletions": 707}, "files": [{"sha": "e1efa19d1c2ef7ca757e8a16849441c41da2d919", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -1,3 +1,8 @@\n+2001-08-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Makefile.am, acinclude.m4, configure.in: Imported GC 6.0 and\n+\tmerged local changes.\n+\n 2001-08-02  David Billinghurst <David.Billinghurst>\n \n \t* configure: Rebuilt."}, {"sha": "0949ed8a37362fbc6b539a95f9764b37f856694a", "filename": "boehm-gc/Makefile.am", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -37,13 +37,13 @@ libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)\n libgcjgc_la_DEPENDENCIES = @addobjs@\n libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)\n \n-EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s hpux_test_and_clear.s \\\n+EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s \\\n mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s \\\n rs6000_mach_dep.s sparc_mach_dep.s sparc_netbsd_mach_dep.s \\\n sparc_sunos4_mach_dep.s\n \n-AM_CXXFLAGS = @BOEHM_GC_CFLAGS@\n-AM_CFLAGS = @BOEHM_GC_CFLAGS@\n+AM_CXXFLAGS = @GC_CFLAGS@\n+AM_CFLAGS = @GC_CFLAGS@\n \n check_PROGRAMS = gctest\n # The following hack produces a warning from automake, but we need it in order \n@@ -71,10 +71,10 @@ include/private/gc_hdrs.h include/gc.h include/gc_gcj.h include/gc_mark.h\n ## CFLAGS, not those passed in from the top level make.\n LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) \\\n-\t$(AM_CFLAGS) $(MY_CFLAGS) $(BOEHM_GC_CFLAGS) \n+\t$(AM_CFLAGS) $(MY_CFLAGS) $(GC_CFLAGS) \n LINK = $(LIBTOOL) --mode=link $(CC) $(AM_CFLAGS) $(MY_CFLAGS) $(LDFLAGS) -o $@\n \n-AM_CFLAGS = @BOEHM_GC_CFLAGS@\n+AM_CFLAGS = @GC_CFLAGS@\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "09fae4e613fbf5e8f5232925e751768ae8cc84ad", "filename": "boehm-gc/Makefile.dj", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2FMakefile.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2FMakefile.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dj?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -62,10 +62,11 @@ CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIO\n #   code from the heap.  Currently this only affects the incremental\n #   collector on UNIX machines.  It may greatly improve its performance,\n #   since this may avoid some expensive cache synchronization.\n-# -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n-#   new syntax \"operator new[]\" for allocating and deleting arrays.\n+# -DGC_NO_OPERATOR_NEW_ARRAY declares that the C++ compiler does not support\n+#   the  new syntax \"operator new[]\" for allocating and deleting arrays.\n #   See gc_cpp.h for details.  No effect on the C part of the collector.\n-#   This is defined implicitly in a few environments.\n+#   This is defined implicitly in a few environments.  Must also be defined\n+#   by clients that use gc_cpp.h.\n # -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n #   as aliases for X, GC_realloc, and GC_free, respectively.\n #   Calloc is redefined in terms of the new malloc.  X should"}, {"sha": "e0900025f90427dfc482305a75dca9050ac9ed66", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -65,7 +65,6 @@ target_alias = @target_alias@\n target_triplet = @target@\n AR = @AR@\n AS = @AS@\n-BOEHM_GC_CFLAGS = @BOEHM_GC_CFLAGS@\n CC = @CC@\n CPP = @CPP@\n CXX = @CXX@\n@@ -76,6 +75,7 @@ EXEEXT = @EXEEXT@\n EXTRA_TEST_LIBS = @EXTRA_TEST_LIBS@\n GCJ = @GCJ@\n GCJFLAGS = @GCJFLAGS@\n+GC_CFLAGS = @GC_CFLAGS@\n INCLUDES = @INCLUDES@\n LIBTOOL = @LIBTOOL@\n LN_S = @LN_S@\n@@ -90,7 +90,7 @@ STRIP = @STRIP@\n THREADLIBS = @THREADLIBS@\n VERSION = @VERSION@\n addobjs = @addobjs@\n-boehm_gc_basedir = @boehm_gc_basedir@\n+gc_basedir = @gc_basedir@\n mkinstalldirs = @mkinstalldirs@\n target_all = @target_all@\n \n@@ -125,15 +125,15 @@ libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)\n libgcjgc_la_DEPENDENCIES = @addobjs@\n libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)\n \n-EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s hpux_test_and_clear.s \\\n+EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s \\\n mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s \\\n rs6000_mach_dep.s sparc_mach_dep.s sparc_netbsd_mach_dep.s \\\n sparc_sunos4_mach_dep.s\n \n \n-AM_CXXFLAGS = @BOEHM_GC_CFLAGS@\n+AM_CXXFLAGS = @GC_CFLAGS@\n \n-AM_CFLAGS = @BOEHM_GC_CFLAGS@\n+AM_CFLAGS = @GC_CFLAGS@\n \n check_PROGRAMS = gctest\n gctest_OBJECTS = test.o\n@@ -146,7 +146,7 @@ all_objs = @addobjs@ $(libgcjgc_la_OBJECTS)\n \n LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) \\\n-\t$(AM_CFLAGS) $(MY_CFLAGS) $(BOEHM_GC_CFLAGS) \n+\t$(AM_CFLAGS) $(MY_CFLAGS) $(GC_CFLAGS) \n \n LINK = $(LIBTOOL) --mode=link $(CC) $(AM_CFLAGS) $(MY_CFLAGS) $(LDFLAGS) -o $@\n \n@@ -216,7 +216,8 @@ CFLAGS = @CFLAGS@\n COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n CCLD = $(CC)\n DIST_COMMON =  ChangeLog Makefile.am Makefile.in acinclude.m4 aclocal.m4 \\\n-configure configure.in\n+config.guess config.sub configure configure.in install-sh ltconfig \\\n+ltmain.sh mkinstalldirs\n \n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)"}, {"sha": "1957026a946e6b3b66966d0a75db916876f609eb", "filename": "boehm-gc/acinclude.m4", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Facinclude.m4?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -1,10 +1,23 @@\n+# Copyright (c) 1999-2001 by Red Hat, Inc. All rights reserved.\n+# \n+# THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+# OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+# \n+# Permission is hereby granted to use or copy this program\n+# for any purpose,  provided the above notices are retained on all copies.\n+# Permission to modify the code and to distribute modified code is granted,\n+# provided the above notices are retained, and a notice that the code was\n+# modified is included with the above copyright notice.\n+#\n+# Original author: Tom Tromey\n+\n # FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n # copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n # are probably using a cross compiler, which will not be able to fully\n # link an executable.  This should really be fixed in autoconf\n # itself.\n \n-AC_DEFUN(BOEHM_CONFIGURE,\n+AC_DEFUN(GC_CONFIGURE,\n [\n dnl Default to --enable-multilib\n AC_ARG_ENABLE(multilib,\n@@ -18,17 +31,18 @@ AC_ARG_ENABLE(multilib,\n dnl We may get other options which we don't document:\n dnl --with-target-subdir, --with-multisrctop, --with-multisubdir\n \n+dnl I needed to add the -n test to allow configuration in src directory - HB\n if test \"[$]{srcdir}\" = \".\"; then\n-  if test \"[$]{with_target_subdir}\" != \".\"; then\n-    boehm_gc_basedir=\"[$]{srcdir}/[$]{with_multisrctop}../$1\"\n+  if test \"[$]{with_target_subdir}\" != \".\" -a -n \"[$]{with_target_subdir}\"; then\n+    gc_basedir=\"[$]{srcdir}/[$]{with_multisrctop}../$1\"\n   else\n-    boehm_gc_basedir=\"[$]{srcdir}/[$]{with_multisrctop}$1\"\n+    gc_basedir=\"[$]{srcdir}/[$]{with_multisrctop}$1\"\n   fi\n else\n-  boehm_gc_basedir=\"[$]{srcdir}/$1\"\n+  gc_basedir=\"[$]{srcdir}/$1\"\n fi\n-AC_SUBST(boehm_gc_basedir)\n-AC_CONFIG_AUX_DIR($boehm_gc_basedir/..)\n+AC_SUBST(gc_basedir)\n+AC_CONFIG_AUX_DIR($gc_basedir/..)\n if :; then :; else\n   # This overrides the previous occurrence for automake, but not for\n   # autoconf, which is exactly what we want.\n@@ -41,7 +55,7 @@ AC_CANONICAL_SYSTEM\n mkinstalldirs=\"`cd $ac_aux_dir && pwd`/mkinstalldirs\"\n AC_SUBST(mkinstalldirs)\n \n-AM_INIT_AUTOMAKE(boehm-gc, 5.1, no-define)\n+AM_INIT_AUTOMAKE(gc, 6.0, no-define)\n \n # FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n # copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n@@ -150,22 +164,22 @@ fi\n \n . [$]{srcdir}/configure.host\n \n-case [$]{boehm_gc_basedir} in\n-/* | [A-Za-z]:[/\\\\]*) boehm_gc_flagbasedir=[$]{boehm_gc_basedir} ;;\n-*) boehm_gc_flagbasedir='[$](top_builddir)/'[$]{boehm_gc_basedir} ;;\n+case [$]{gc_basedir} in\n+/* | [A-Za-z]:[/\\\\]*) gc_flagbasedir=[$]{gc_basedir} ;;\n+*) gc_flagbasedir='[$](top_builddir)/'[$]{gc_basedir} ;;\n esac\n \n-boehm_gc_cflags=\"[$]{boehm_gc_cflags} -I\"'[$](top_builddir)'\"/$1/targ-include -I[$]{boehm_gc_flagbasedir}/libc/include\"\n+gc_cflags=\"[$]{gc_cflags} -I\"'[$](top_builddir)'\"/$1/targ-include -I[$]{gc_flagbasedir}/libc/include\"\n case \"${host}\" in\n   *-*-cygwin32*)\n-    boehm_gc_cflags=\"[$]{boehm_gc_cflags} -I[$]{boehm_gc_flagbasedir}/../winsup/include\"\n+    gc_cflags=\"[$]{gc_cflags} -I[$]{gc_flagbasedir}/../winsup/include\"\n     ;;\n esac\n \n-boehm_gc_cflags=\"[$]{boehm_gc_cflags} -fno-builtin\"\n+dnl gc_cflags=\"[$]{gc_cflags} -fno-builtin\"\n \n-BOEHM_GC_CFLAGS=${boehm_gc_cflags}\n-AC_SUBST(BOEHM_GC_CFLAGS)\n+GC_CFLAGS=${gc_cflags}\n+AC_SUBST(GC_CFLAGS)\n ]))\n \n ))))"}, {"sha": "f35b954b0fc74d1eb5c5f8b34d4a53cdc9473650", "filename": "boehm-gc/aclocal.m4", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Faclocal.m4?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -10,13 +10,26 @@ dnl but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n dnl even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n dnl PARTICULAR PURPOSE.\n \n+# Copyright (c) 1999-2001 by Red Hat, Inc. All rights reserved.\n+# \n+# THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+# OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+# \n+# Permission is hereby granted to use or copy this program\n+# for any purpose,  provided the above notices are retained on all copies.\n+# Permission to modify the code and to distribute modified code is granted,\n+# provided the above notices are retained, and a notice that the code was\n+# modified is included with the above copyright notice.\n+#\n+# Original author: Tom Tromey\n+\n # FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n # copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n # are probably using a cross compiler, which will not be able to fully\n # link an executable.  This should really be fixed in autoconf\n # itself.\n \n-AC_DEFUN(BOEHM_CONFIGURE,\n+AC_DEFUN(GC_CONFIGURE,\n [\n dnl Default to --enable-multilib\n AC_ARG_ENABLE(multilib,\n@@ -30,17 +43,18 @@ AC_ARG_ENABLE(multilib,\n dnl We may get other options which we don't document:\n dnl --with-target-subdir, --with-multisrctop, --with-multisubdir\n \n+dnl I needed to add the -n test to allow configuration in src directory - HB\n if test \"[$]{srcdir}\" = \".\"; then\n-  if test \"[$]{with_target_subdir}\" != \".\"; then\n-    boehm_gc_basedir=\"[$]{srcdir}/[$]{with_multisrctop}../$1\"\n+  if test \"[$]{with_target_subdir}\" != \".\" -a -n \"[$]{with_target_subdir}\"; then\n+    gc_basedir=\"[$]{srcdir}/[$]{with_multisrctop}../$1\"\n   else\n-    boehm_gc_basedir=\"[$]{srcdir}/[$]{with_multisrctop}$1\"\n+    gc_basedir=\"[$]{srcdir}/[$]{with_multisrctop}$1\"\n   fi\n else\n-  boehm_gc_basedir=\"[$]{srcdir}/$1\"\n+  gc_basedir=\"[$]{srcdir}/$1\"\n fi\n-AC_SUBST(boehm_gc_basedir)\n-AC_CONFIG_AUX_DIR($boehm_gc_basedir/..)\n+AC_SUBST(gc_basedir)\n+AC_CONFIG_AUX_DIR($gc_basedir/..)\n if :; then :; else\n   # This overrides the previous occurrence for automake, but not for\n   # autoconf, which is exactly what we want.\n@@ -53,7 +67,7 @@ AC_CANONICAL_SYSTEM\n mkinstalldirs=\"`cd $ac_aux_dir && pwd`/mkinstalldirs\"\n AC_SUBST(mkinstalldirs)\n \n-AM_INIT_AUTOMAKE(boehm-gc, 5.1, no-define)\n+AM_INIT_AUTOMAKE(gc, 6.0, no-define)\n \n # FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n # copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We\n@@ -162,22 +176,22 @@ fi\n \n . [$]{srcdir}/configure.host\n \n-case [$]{boehm_gc_basedir} in\n-/* | [A-Za-z]:[/\\\\]*) boehm_gc_flagbasedir=[$]{boehm_gc_basedir} ;;\n-*) boehm_gc_flagbasedir='[$](top_builddir)/'[$]{boehm_gc_basedir} ;;\n+case [$]{gc_basedir} in\n+/* | [A-Za-z]:[/\\\\]*) gc_flagbasedir=[$]{gc_basedir} ;;\n+*) gc_flagbasedir='[$](top_builddir)/'[$]{gc_basedir} ;;\n esac\n \n-boehm_gc_cflags=\"[$]{boehm_gc_cflags} -I\"'[$](top_builddir)'\"/$1/targ-include -I[$]{boehm_gc_flagbasedir}/libc/include\"\n+gc_cflags=\"[$]{gc_cflags} -I\"'[$](top_builddir)'\"/$1/targ-include -I[$]{gc_flagbasedir}/libc/include\"\n case \"${host}\" in\n   *-*-cygwin32*)\n-    boehm_gc_cflags=\"[$]{boehm_gc_cflags} -I[$]{boehm_gc_flagbasedir}/../winsup/include\"\n+    gc_cflags=\"[$]{gc_cflags} -I[$]{gc_flagbasedir}/../winsup/include\"\n     ;;\n esac\n \n-boehm_gc_cflags=\"[$]{boehm_gc_cflags} -fno-builtin\"\n+dnl gc_cflags=\"[$]{gc_cflags} -fno-builtin\"\n \n-BOEHM_GC_CFLAGS=${boehm_gc_cflags}\n-AC_SUBST(BOEHM_GC_CFLAGS)\n+GC_CFLAGS=${gc_cflags}\n+AC_SUBST(GC_CFLAGS)\n ]))\n \n ))))"}, {"sha": "59515c7866e2506c80d829ae57968f063bb5e578", "filename": "boehm-gc/add_gc_prefix.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fadd_gc_prefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fadd_gc_prefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fadd_gc_prefix.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -1,4 +1,5 @@\n # include <stdio.h>\n+# include \"version.h\"\n  \n int main(argc, argv, envp)\n int argc;\n@@ -8,7 +9,12 @@ char ** envp;\n     int i;\n     \n     for (i = 1; i < argc; i++) {\n-    \tprintf(\"gc/%s \", argv[i]);\n+      if (GC_ALPHA_VERSION == GC_NOT_ALPHA) {\n+\tprintf(\"gc%d.%d/%s \", GC_VERSION_MAJOR, GC_VERSION_MINOR, argv[i]);\n+      } else {\n+\tprintf(\"gc%d.%dalpha%d/%s \", GC_VERSION_MAJOR,\n+\t       GC_VERSION_MINOR, GC_ALPHA_VERSION, argv[i]);\n+      }\n     }\n     return(0);\n }"}, {"sha": "76296721416b81deaabe362266ba48dedf200b10", "filename": "boehm-gc/allchblk.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -627,7 +627,8 @@ int n;\n \t      \n \t      while ((ptr_t)lasthbp <= search_end\n \t             && (thishbp = GC_is_black_listed(lasthbp,\n-\t             \t\t\t\t      (word)eff_size_needed))) {\n+\t             \t\t\t\t      (word)eff_size_needed))\n+\t\t        != 0) {\n \t        lasthbp = thishbp;\n \t      }\n \t      size_avail -= (ptr_t)lasthbp - (ptr_t)hbp;\n@@ -654,7 +655,7 @@ int n;\n \t                 && orig_avail - size_needed\n \t\t\t    > (signed_word)BL_LIMIT) {\n \t        /* Punt, since anything else risks unreasonable heap growth. */\n-\t\tif (0 != GETENV(\"GC_NO_BLACKLIST_WARNING\")) {\n+\t\tif (0 == GETENV(\"GC_NO_BLACKLIST_WARNING\")) {\n \t          WARN(\"Needed to allocate blacklisted block at 0x%lx\\n\",\n \t\t       (word)hbp);\n \t\t}"}, {"sha": "1664e4a4df54dfbd0b3e60751b8420b82abe9b1b", "filename": "boehm-gc/alloc.c", "status": "modified", "additions": 74, "deletions": 38, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -105,7 +105,7 @@ CLOCK_TYPE GC_start_time;  \t/* Time at which we stopped world.\t*/\n int GC_n_attempts = 0;\t\t/* Number of attempts at finishing\t*/\n \t\t\t\t/* collection within TIME_LIMIT\t\t*/\n \n-#ifdef SMALL_CONFIG\n+#if defined(SMALL_CONFIG) || defined(NO_CLOCK)\n #   define GC_timeout_stop_func GC_never_stop_func\n #else\n   int GC_timeout_stop_func GC_PROTO((void))\n@@ -250,7 +250,11 @@ void GC_maybe_gc()\n             GC_gcollect_inner();\n             n_partial_gcs = 0;\n             return;\n-        } else if (GC_need_full_gc || n_partial_gcs >= GC_full_freq) {\n+        } else {\n+#   \t  ifdef PARALLEL_MARK\n+\t    GC_wait_for_reclaim();\n+#   \t  endif\n+\t  if (GC_need_full_gc || n_partial_gcs >= GC_full_freq) {\n #   \t    ifdef CONDPRINT\n \t      if (GC_print_stats) {\n \t        GC_printf2(\n@@ -260,23 +264,21 @@ void GC_maybe_gc()\n \t      }\n #           endif\n \t    GC_promote_black_lists();\n-#   \t    ifdef PARALLEL_MARK\n-\t\tGC_wait_for_reclaim();\n-#   \t    endif\n \t    (void)GC_reclaim_all((GC_stop_func)0, TRUE);\n \t    GC_clear_marks();\n             n_partial_gcs = 0;\n \t    GC_notify_full_gc();\n  \t    GC_is_full_gc = TRUE;\n-        } else {\n+          } else {\n             n_partial_gcs++;\n-        }\n+          }\n+\t}\n         /* We try to mark with the world stopped.\t*/\n         /* If we run out of time, this turns into\t*/\n         /* incremental marking.\t\t\t*/\n-#ifndef NO_CLOCK\n-        GET_TIME(GC_start_time);\n-#endif\n+#\tifndef NO_CLOCK\n+          GET_TIME(GC_start_time);\n+#\tendif\n         if (GC_stopped_mark(GC_timeout_stop_func)) {\n #           ifdef SAVE_CALL_CHAIN\n                 GC_save_callers(GC_last_stack);\n@@ -367,7 +369,7 @@ GC_stop_func stop_func;\n # define GC_RATE 10 \n # define MAX_PRIOR_ATTEMPTS 1\n  \t/* Maximum number of prior attempts at world stop marking\t*/\n- \t/* A value of 1 means that we finish the seconf time, no matter */\n+ \t/* A value of 1 means that we finish the second time, no matter */\n  \t/* how long it takes.  Doesn't count the initial root scan\t*/\n  \t/* for a full GC.\t\t\t\t\t\t*/\n \n@@ -386,6 +388,9 @@ int n;\n #     \t\tifdef SAVE_CALL_CHAIN\n         \t    GC_save_callers(GC_last_stack);\n #     \t\tendif\n+#\t\tifdef PARALLEL_MARK\n+\t\t    GC_wait_for_reclaim();\n+#\t\tendif\n \t\tif (GC_n_attempts < MAX_PRIOR_ATTEMPTS) {\n \t\t  GET_TIME(GC_start_time);\n \t\t  if (!GC_stopped_mark(GC_timeout_stop_func)) {\n@@ -506,6 +511,57 @@ GC_stop_func stop_func;\n     return(TRUE);\n }\n \n+/* Set all mark bits for the free list whose first entry is q\t*/\n+#ifdef __STDC__\n+  void GC_set_fl_marks(ptr_t q)\n+#else\n+  void GC_set_fl_marks(q)\n+  ptr_t q;\n+#endif\n+{\n+   ptr_t p;\n+   struct hblk * h, * last_h = 0;\n+   hdr *hhdr;\n+   int word_no;\n+\n+   for (p = q; p != 0; p = obj_link(p)){\n+\th = HBLKPTR(p);\n+\tif (h != last_h) {\n+\t  last_h = h; \n+\t  hhdr = HDR(h);\n+\t}\n+\tword_no = (((word *)p) - ((word *)h));\n+\tset_mark_bit_from_hdr(hhdr, word_no);\n+   }\n+}\n+\n+/* Clear all mark bits for the free list whose first entry is q\t*/\n+/* Decrement GC_mem_found by number of words on free list.\t*/\n+#ifdef __STDC__\n+  void GC_clear_fl_marks(ptr_t q)\n+#else\n+  void GC_clear_fl_marks(q)\n+  ptr_t q;\n+#endif\n+{\n+   ptr_t p;\n+   struct hblk * h, * last_h = 0;\n+   hdr *hhdr;\n+   int word_no;\n+\n+   for (p = q; p != 0; p = obj_link(p)){\n+\th = HBLKPTR(p);\n+\tif (h != last_h) {\n+\t  last_h = h; \n+\t  hhdr = HDR(h);\n+\t}\n+\tword_no = (((word *)p) - ((word *)h));\n+\tclear_mark_bit_from_hdr(hhdr, word_no);\n+#\tifdef GATHERSTATS\n+\t    GC_mem_found -= hhdr -> hb_sz;\n+#\tendif\n+   }\n+}\n \n /* Finish up a collection.  Assumes lock is held, signals are disabled,\t*/\n /* but the world is otherwise running.\t\t\t\t\t*/\n@@ -533,21 +589,13 @@ void GC_finish_collection()\n       /* marked when we're done.\t\t\t\t   */\n \t{\n \t  register word size;\t\t/* current object size\t\t*/\n-\t  register ptr_t p;\t/* pointer to current object\t*/\n-\t  register struct hblk * h;\t/* pointer to block containing *p */\n-\t  register hdr * hhdr;\n-\t  register int word_no;           /* \"index\" of *p in *q          */\n \t  int kind;\n+\t  ptr_t q;\n \n \t  for (kind = 0; kind < GC_n_kinds; kind++) {\n \t    for (size = 1; size <= MAXOBJSZ; size++) {\n-\t      for (p= GC_obj_kinds[kind].ok_freelist[size];\n-\t           p != 0; p=obj_link(p)){\n-\t\th = HBLKPTR(p);\n-\t\thhdr = HDR(h);\n-\t\tword_no = (((word *)p) - ((word *)h));\n-\t\tset_mark_bit_from_hdr(hhdr, word_no);\n-\t      }\n+\t      q = GC_obj_kinds[kind].ok_freelist[size];\n+\t      if (q != 0) GC_set_fl_marks(q);\n \t    }\n \t  }\n \t}\n@@ -565,32 +613,20 @@ void GC_finish_collection()\n #   endif\n \n     /* Clear free list mark bits, in case they got accidentally marked   */\n-    /* Note: HBLKPTR(p) == pointer to head of block containing *p        */\n-    /* (or GC_find_leak is set and they were intentionally marked.)\t */\n+    /* (or GC_find_leak is set and they were intentionally marked).\t */\n     /* Also subtract memory remaining from GC_mem_found count.           */\n     /* Note that composite objects on free list are cleared.             */\n     /* Thus accidentally marking a free list is not a problem;  only     */\n     /* objects on the list itself will be marked, and that's fixed here. */\n       {\n \tregister word size;\t\t/* current object size\t\t*/\n-\tregister ptr_t p;\t/* pointer to current object\t*/\n-\tregister struct hblk * h;\t/* pointer to block containing *p */\n-\tregister hdr * hhdr;\n-\tregister int word_no;           /* \"index\" of *p in *q          */\n+\tregister ptr_t q;\t/* pointer to current object\t*/\n \tint kind;\n \n \tfor (kind = 0; kind < GC_n_kinds; kind++) {\n \t  for (size = 1; size <= MAXOBJSZ; size++) {\n-\t    for (p= GC_obj_kinds[kind].ok_freelist[size];\n-\t         p != 0; p=obj_link(p)){\n-\t\th = HBLKPTR(p);\n-\t\thhdr = HDR(h);\n-\t\tword_no = (((word *)p) - ((word *)h));\n-\t\tclear_mark_bit_from_hdr(hhdr, word_no);\n-#\t\tifdef GATHERSTATS\n-\t\t    GC_mem_found -= size;\n-#\t\tendif\n-\t    }\n+\t    q = GC_obj_kinds[kind].ok_freelist[size];\n+\t    if (q != 0) GC_clear_fl_marks(q);\n \t  }\n \t}\n       }"}, {"sha": "271ce5c2f5f57fc79b5a88ac5a24f616738e81cc", "filename": "boehm-gc/configure", "status": "modified", "additions": 222, "deletions": 106, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -37,9 +37,13 @@ ac_help=\"$ac_help\n   --enable-maintainer-mode enable make rules and dependencies not useful\n                           (and sometimes confusing) to the casual installer\"\n ac_help=\"$ac_help\n-  --enable-java-gc=TYPE   choose garbage collector [boehm]\"\n+  --enable-threads=TYPE   choose threading package\"\n+ac_help=\"$ac_help\n+  --enable-parallel-mark\tparallelize marking and free list construction\"\n ac_help=\"$ac_help\n   --with-ecos             enable runtime eCos target support\"\n+ac_help=\"$ac_help\n+  --enable-full-debug\tinclude full support for pointer backtracing etc.\"\n \n # Initialize some variables set by options.\n # The variables have the same names as the options, with\n@@ -562,6 +566,26 @@ fi\n \n \n \n+ac_aux_dir=\n+for ac_dir in . $srcdir/.; do\n+  if test -f $ac_dir/install-sh; then\n+    ac_aux_dir=$ac_dir\n+    ac_install_sh=\"$ac_aux_dir/install-sh -c\"\n+    break\n+  elif test -f $ac_dir/install.sh; then\n+    ac_aux_dir=$ac_dir\n+    ac_install_sh=\"$ac_aux_dir/install.sh -c\"\n+    break\n+  fi\n+done\n+if test -z \"$ac_aux_dir\"; then\n+  { echo \"configure: error: can not find install-sh or install.sh in . $srcdir/.\" 1>&2; exit 1; }\n+fi\n+ac_config_guess=$ac_aux_dir/config.guess\n+ac_config_sub=$ac_aux_dir/config.sub\n+ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.\n+\n+\n # Find a good install program.  We prefer a C program (faster),\n # so one script is as good as another.  But avoid the broken or\n # incompatible versions:\n@@ -574,7 +598,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:578: checking for a BSD compatible install\" >&5\n+echo \"configure:602: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -627,7 +651,7 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether build environment is sane\"\"... $ac_c\" 1>&6\n-echo \"configure:631: checking whether build environment is sane\" >&5\n+echo \"configure:655: checking whether build environment is sane\" >&5\n # Just in case\n sleep 1\n echo timestamp > conftestfile\n@@ -684,7 +708,7 @@ test \"$program_suffix\" != NONE &&\n test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:688: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:712: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -717,12 +741,12 @@ else\n fi\n \n echo $ac_n \"checking for Cygwin environment\"\"... $ac_c\" 1>&6\n-echo \"configure:721: checking for Cygwin environment\" >&5\n+echo \"configure:745: checking for Cygwin environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_cygwin'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 726 \"configure\"\n+#line 750 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -733,7 +757,7 @@ int main() {\n return __CYGWIN__;\n ; return 0; }\n EOF\n-if { (eval echo configure:737: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:761: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_cygwin=yes\n else\n@@ -750,19 +774,19 @@ echo \"$ac_t\"\"$ac_cv_cygwin\" 1>&6\n CYGWIN=\n test \"$ac_cv_cygwin\" = yes && CYGWIN=yes\n echo $ac_n \"checking for mingw32 environment\"\"... $ac_c\" 1>&6\n-echo \"configure:754: checking for mingw32 environment\" >&5\n+echo \"configure:778: checking for mingw32 environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_mingw32'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 759 \"configure\"\n+#line 783 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n return __MINGW32__;\n ; return 0; }\n EOF\n-if { (eval echo configure:766: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:790: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_mingw32=yes\n else\n@@ -793,17 +817,17 @@ fi\n \n \n if test \"${srcdir}\" = \".\"; then\n-  if test \"${with_target_subdir}\" != \".\"; then\n-    boehm_gc_basedir=\"${srcdir}/${with_multisrctop}../.\"\n+  if test \"${with_target_subdir}\" != \".\" -a -n \"${with_target_subdir}\"; then\n+    gc_basedir=\"${srcdir}/${with_multisrctop}../.\"\n   else\n-    boehm_gc_basedir=\"${srcdir}/${with_multisrctop}.\"\n+    gc_basedir=\"${srcdir}/${with_multisrctop}.\"\n   fi\n else\n-  boehm_gc_basedir=\"${srcdir}/.\"\n+  gc_basedir=\"${srcdir}/.\"\n fi\n \n ac_aux_dir=\n-for ac_dir in $boehm_gc_basedir/.. $srcdir/$boehm_gc_basedir/..; do\n+for ac_dir in $gc_basedir/.. $srcdir/$gc_basedir/..; do\n   if test -f $ac_dir/install-sh; then\n     ac_aux_dir=$ac_dir\n     ac_install_sh=\"$ac_aux_dir/install-sh -c\"\n@@ -815,7 +839,7 @@ for ac_dir in $boehm_gc_basedir/.. $srcdir/$boehm_gc_basedir/..; do\n   fi\n done\n if test -z \"$ac_aux_dir\"; then\n-  { echo \"configure: error: can not find install-sh or install.sh in $boehm_gc_basedir/.. $srcdir/$boehm_gc_basedir/..\" 1>&2; exit 1; }\n+  { echo \"configure: error: can not find install-sh or install.sh in $gc_basedir/.. $srcdir/$gc_basedir/..\" 1>&2; exit 1; }\n fi\n ac_config_guess=$ac_aux_dir/config.guess\n ac_config_sub=$ac_aux_dir/config.sub\n@@ -873,7 +897,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:877: checking host system type\" >&5\n+echo \"configure:901: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -894,7 +918,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:898: checking target system type\" >&5\n+echo \"configure:922: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -912,7 +936,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:916: checking build system type\" >&5\n+echo \"configure:940: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -940,9 +964,9 @@ mkinstalldirs=\"`cd $ac_aux_dir && pwd`/mkinstalldirs\"\n \n \n \n-PACKAGE=boehm-gc\n+PACKAGE=gc\n \n-VERSION=5.1\n+VERSION=6.0\n \n if test \"`cd $srcdir && pwd`\" != \"`pwd`\" && test -f $srcdir/config.status; then\n   { echo \"configure: error: source directory already configured; run \"make distclean\" there first\" 1>&2; exit 1; }\n@@ -952,7 +976,7 @@ fi\n \n missing_dir=`cd $ac_aux_dir && pwd`\n echo $ac_n \"checking for working aclocal\"\"... $ac_c\" 1>&6\n-echo \"configure:956: checking for working aclocal\" >&5\n+echo \"configure:980: checking for working aclocal\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -965,7 +989,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoconf\"\"... $ac_c\" 1>&6\n-echo \"configure:969: checking for working autoconf\" >&5\n+echo \"configure:993: checking for working autoconf\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -978,7 +1002,7 @@ else\n fi\n \n echo $ac_n \"checking for working automake\"\"... $ac_c\" 1>&6\n-echo \"configure:982: checking for working automake\" >&5\n+echo \"configure:1006: checking for working automake\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -991,7 +1015,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoheader\"\"... $ac_c\" 1>&6\n-echo \"configure:995: checking for working autoheader\" >&5\n+echo \"configure:1019: checking for working autoheader\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1004,7 +1028,7 @@ else\n fi\n \n echo $ac_n \"checking for working makeinfo\"\"... $ac_c\" 1>&6\n-echo \"configure:1008: checking for working makeinfo\" >&5\n+echo \"configure:1032: checking for working makeinfo\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1030,7 +1054,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1034: checking for $ac_word\" >&5\n+echo \"configure:1058: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1060,7 +1084,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1064: checking for $ac_word\" >&5\n+echo \"configure:1088: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1109,7 +1133,7 @@ fi\n fi\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1113: checking whether we are using GNU C\" >&5\n+echo \"configure:1137: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1118,7 +1142,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1122: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1146: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1133,7 +1157,7 @@ if test $ac_cv_prog_gcc = yes; then\n   ac_save_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\n   echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1137: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1161: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1170,7 +1194,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1174: checking for $ac_word\" >&5\n+echo \"configure:1198: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1203,7 +1227,7 @@ test -n \"$CXX\" || CXX=\"gcc\"\n test -z \"$CXX\" && { echo \"configure: error: no acceptable c++ found in \\$PATH\" 1>&2; exit 1; }\n \n echo $ac_n \"checking whether we are using GNU C++\"\"... $ac_c\" 1>&6\n-echo \"configure:1207: checking whether we are using GNU C++\" >&5\n+echo \"configure:1231: checking whether we are using GNU C++\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gxx'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1212,7 +1236,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1216: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1240: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gxx=yes\n else\n   ac_cv_prog_gxx=no\n@@ -1227,7 +1251,7 @@ if test $ac_cv_prog_gxx = yes; then\n   ac_save_CXXFLAGS=\"$CXXFLAGS\"\n   CXXFLAGS=\n   echo $ac_n \"checking whether ${CXX-g++} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1231: checking whether ${CXX-g++} accepts -g\" >&5\n+echo \"configure:1255: checking whether ${CXX-g++} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1260,7 +1284,7 @@ fi\n # NEWLIB_CONFIGURE, which doesn't work because that means that it will\n # be run before AC_CANONICAL_HOST.\n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:1264: checking build system type\" >&5\n+echo \"configure:1288: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -1281,7 +1305,7 @@ echo \"$ac_t\"\"$build\" 1>&6\n # Extract the first word of \"${ac_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1285: checking for $ac_word\" >&5\n+echo \"configure:1309: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1313,7 +1337,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1317: checking for $ac_word\" >&5\n+echo \"configure:1341: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1345,7 +1369,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1349: checking for $ac_word\" >&5\n+echo \"configure:1373: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1377,7 +1401,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1381: checking for $ac_word\" >&5\n+echo \"configure:1405: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1422,7 +1446,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:1426: checking for a BSD compatible install\" >&5\n+echo \"configure:1450: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1476,7 +1500,7 @@ test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:1480: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:1504: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -1514,7 +1538,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1518: checking for executable suffix\" >&5\n+echo \"configure:1542: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1524,7 +1548,7 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:1528: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:1552: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n       *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n@@ -1548,21 +1572,20 @@ fi\n \n . ${srcdir}/configure.host\n \n-case ${boehm_gc_basedir} in\n-/* | A-Za-z:/\\\\*) boehm_gc_flagbasedir=${boehm_gc_basedir} ;;\n-*) boehm_gc_flagbasedir='$(top_builddir)/'${boehm_gc_basedir} ;;\n+case ${gc_basedir} in\n+/* | A-Za-z:/\\\\*) gc_flagbasedir=${gc_basedir} ;;\n+*) gc_flagbasedir='$(top_builddir)/'${gc_basedir} ;;\n esac\n \n-boehm_gc_cflags=\"${boehm_gc_cflags} -I\"'$(top_builddir)'\"/./targ-include -I${boehm_gc_flagbasedir}/libc/include\"\n+gc_cflags=\"${gc_cflags} -I\"'$(top_builddir)'\"/./targ-include -I${gc_flagbasedir}/libc/include\"\n case \"${host}\" in\n   *-*-cygwin32*)\n-    boehm_gc_cflags=\"${boehm_gc_cflags} -I${boehm_gc_flagbasedir}/../winsup/include\"\n+    gc_cflags=\"${gc_cflags} -I${gc_flagbasedir}/../winsup/include\"\n     ;;\n esac\n \n-boehm_gc_cflags=\"${boehm_gc_cflags} -fno-builtin\"\n \n-BOEHM_GC_CFLAGS=${boehm_gc_cflags}\n+GC_CFLAGS=${gc_cflags}\n \n \n \n@@ -1647,7 +1670,7 @@ ac_prog=ld\n if test \"$GCC\" = yes; then\n   # Check if gcc -print-prog-name=ld gives a path.\n   echo $ac_n \"checking for ld used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:1651: checking for ld used by GCC\" >&5\n+echo \"configure:1674: checking for ld used by GCC\" >&5\n   case $host in\n   *-*-mingw*)\n     # gcc leaves a trailing carriage return which upsets mingw\n@@ -1677,10 +1700,10 @@ echo \"configure:1651: checking for ld used by GCC\" >&5\n   esac\n elif test \"$with_gnu_ld\" = yes; then\n   echo $ac_n \"checking for GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1681: checking for GNU ld\" >&5\n+echo \"configure:1704: checking for GNU ld\" >&5\n else\n   echo $ac_n \"checking for non-GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1684: checking for non-GNU ld\" >&5\n+echo \"configure:1707: checking for non-GNU ld\" >&5\n fi\n if eval \"test \\\"`echo '$''{'lt_cv_path_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1715,7 +1738,7 @@ else\n fi\n test -z \"$LD\" && { echo \"configure: error: no acceptable ld found in \\$PATH\" 1>&2; exit 1; }\n echo $ac_n \"checking if the linker ($LD) is GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1719: checking if the linker ($LD) is GNU ld\" >&5\n+echo \"configure:1742: checking if the linker ($LD) is GNU ld\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_prog_gnu_ld'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1732,7 +1755,7 @@ with_gnu_ld=$lt_cv_prog_gnu_ld\n \n \n echo $ac_n \"checking for $LD option to reload object files\"\"... $ac_c\" 1>&6\n-echo \"configure:1736: checking for $LD option to reload object files\" >&5\n+echo \"configure:1759: checking for $LD option to reload object files\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_ld_reload_flag'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1744,7 +1767,7 @@ reload_flag=$lt_cv_ld_reload_flag\n test -n \"$reload_flag\" && reload_flag=\" $reload_flag\"\n \n echo $ac_n \"checking for BSD-compatible nm\"\"... $ac_c\" 1>&6\n-echo \"configure:1748: checking for BSD-compatible nm\" >&5\n+echo \"configure:1771: checking for BSD-compatible nm\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1782,7 +1805,7 @@ NM=\"$lt_cv_path_NM\"\n echo \"$ac_t\"\"$NM\" 1>&6\n \n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:1786: checking whether ln -s works\" >&5\n+echo \"configure:1809: checking whether ln -s works\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1803,7 +1826,7 @@ else\n fi\n \n echo $ac_n \"checking how to recognise dependant libraries\"\"... $ac_c\" 1>&6\n-echo \"configure:1807: checking how to recognise dependant libraries\" >&5\n+echo \"configure:1830: checking how to recognise dependant libraries\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_deplibs_check_method'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1967,13 +1990,13 @@ file_magic_cmd=$lt_cv_file_magic_cmd\n deplibs_check_method=$lt_cv_deplibs_check_method\n \n echo $ac_n \"checking for object suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1971: checking for object suffix\" >&5\n+echo \"configure:1994: checking for object suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_objext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   rm -f conftest*\n echo 'int i = 1;' > conftest.$ac_ext\n-if { (eval echo configure:1977: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2000: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   for ac_file in conftest.*; do\n     case $ac_file in\n     *.c) ;;\n@@ -1997,7 +2020,7 @@ case $deplibs_check_method in\n file_magic*)\n   if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n     echo $ac_n \"checking for ${ac_tool_prefix}file\"\"... $ac_c\" 1>&6\n-echo \"configure:2001: checking for ${ac_tool_prefix}file\" >&5\n+echo \"configure:2024: checking for ${ac_tool_prefix}file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2059,7 +2082,7 @@ fi\n if test -z \"$lt_cv_path_MAGIC_CMD\"; then\n   if test -n \"$ac_tool_prefix\"; then\n     echo $ac_n \"checking for file\"\"... $ac_c\" 1>&6\n-echo \"configure:2063: checking for file\" >&5\n+echo \"configure:2086: checking for file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2130,7 +2153,7 @@ esac\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2134: checking for $ac_word\" >&5\n+echo \"configure:2157: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2162,7 +2185,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2166: checking for $ac_word\" >&5\n+echo \"configure:2189: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2197,7 +2220,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}strip\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2201: checking for $ac_word\" >&5\n+echo \"configure:2224: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2229,7 +2252,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"strip\", so it can be a program name with args.\n set dummy strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2233: checking for $ac_word\" >&5\n+echo \"configure:2256: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2296,8 +2319,8 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 2300 \"configure\"' > conftest.$ac_ext\n-  if { (eval echo configure:2301: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  echo '#line 2323 \"configure\"' > conftest.$ac_ext\n+  if { (eval echo configure:2324: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case `/usr/bin/file conftest.$ac_objext` in\n     *32-bit*)\n       LD=\"${LD-ld} -32\"\n@@ -2318,7 +2341,7 @@ case $host in\n   SAVE_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"$CFLAGS -belf\"\n   echo $ac_n \"checking whether the C compiler needs -belf\"\"... $ac_c\" 1>&6\n-echo \"configure:2322: checking whether the C compiler needs -belf\" >&5\n+echo \"configure:2345: checking whether the C compiler needs -belf\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2331,14 +2354,14 @@ ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$a\n cross_compiling=$ac_cv_prog_cc_cross\n \n      cat > conftest.$ac_ext <<EOF\n-#line 2335 \"configure\"\n+#line 2358 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2342: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2365: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   lt_cv_cc_needs_belf=yes\n else\n@@ -2368,7 +2391,7 @@ echo \"$ac_t\"\"$lt_cv_cc_needs_belf\" 1>&6\n esac\n \n echo $ac_n \"checking how to run the C++ preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2372: checking how to run the C++ preprocessor\" >&5\n+echo \"configure:2395: checking how to run the C++ preprocessor\" >&5\n if test -z \"$CXXCPP\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXXCPP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -2381,12 +2404,12 @@ ac_link='${CXX-g++} -o conftest${ac_exeext} $CXXFLAGS $CPPFLAGS $LDFLAGS conftes\n cross_compiling=$ac_cv_prog_cxx_cross\n   CXXCPP=\"${CXX-g++} -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2385 \"configure\"\n+#line 2408 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2390: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2413: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2533,7 +2556,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:2537: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:2560: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -2566,7 +2589,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:2570: checking for executable suffix\" >&5\n+echo \"configure:2593: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2576,7 +2599,7 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:2580: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:2603: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n       *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n@@ -2598,10 +2621,34 @@ ac_exeext=$EXEEXT\n \n fi\n \n-echo $ac_n \"checking for thread model used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:2603: checking for thread model used by GCC\" >&5\n-THREADS=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n-echo \"$ac_t\"\"$THREADS\" 1>&6\n+echo $ac_n \"checking for threads package to use\"\"... $ac_c\" 1>&6\n+echo \"configure:2626: checking for threads package to use\" >&5\n+# Check whether --enable-threads or --disable-threads was given.\n+if test \"${enable_threads+set}\" = set; then\n+  enableval=\"$enable_threads\"\n+  THREADS=$enableval\n+else\n+   echo $ac_n \"checking for thread model used by GCC\"\"... $ac_c\" 1>&6\n+echo \"configure:2633: checking for thread model used by GCC\" >&5\n+    THREADS=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n+    if test -z \"$THREADS\"; then\n+      THREADS=no\n+    fi\n+    echo \"$ac_t\"\"$THREADS\" 1>&6\n+fi\n+\n+\n+# Check whether --enable-parallel-mark or --disable-parallel-mark was given.\n+if test \"${enable_parallel_mark+set}\" = set; then\n+  enableval=\"$enable_parallel_mark\"\n+  case \"$THREADS\" in\n+      no | none | single)\n+\t{ echo \"configure: error: Parallel mark requires --enable-threads=x spec\" 1>&2; exit 1; }\n+\t;;\n+    esac\n+\n+fi\n+\n \n INCLUDES=-I${srcdir}/include\n THREADLIBS=\n@@ -2613,15 +2660,57 @@ case \"$THREADS\" in\n     THREADS=posix\n     THREADLIBS=-lpthread\n     case \"$host\" in\n+     x86-*-linux* | ia64-*-linux* | i586-*-linux* | i686-*-linux*)\n+\tcat >> confdefs.h <<\\EOF\n+#define GC_LINUX_THREADS 1\n+EOF\n+\n+\tcat >> confdefs.h <<\\EOF\n+#define _REENTRANT 1\n+EOF\n+\n+        if test \"${enable_parallel_mark}\"; then\n+\t  cat >> confdefs.h <<\\EOF\n+#define PARALLEL_MARK 1\n+EOF\n+\n+\tfi\n+\tcat >> confdefs.h <<\\EOF\n+#define THREAD_LOCAL_ALLOC 1\n+EOF\n+\n+\t;;\n      *-*-linux*)\n \tcat >> confdefs.h <<\\EOF\n-#define LINUX_THREADS 1\n+#define GC_LINUX_THREADS 1\n EOF\n \n \tcat >> confdefs.h <<\\EOF\n #define _REENTRANT 1\n EOF\n \n+\t;;\n+     *-*-hpux*)\n+\techo \"configure: warning: \"Only HP/UX 11 threads are supported.\"\" 1>&2\n+\tcat >> confdefs.h <<\\EOF\n+#define GC_HPUX_THREADS 1\n+EOF\n+\n+\tcat >> confdefs.h <<\\EOF\n+#define _POSIX_C_SOURCE 199506L\n+EOF\n+\n+\tif test \"${enable_parallel_mark}\" = yes; then\n+\t  cat >> confdefs.h <<\\EOF\n+#define PARALLEL_MARK 1\n+EOF\n+\n+\tfi\n+\tcat >> confdefs.h <<\\EOF\n+#define THREAD_LOCAL_ALLOC 1\n+EOF\n+\n+\tTHREADLIBS=\"-lpthread -lrt\"\n \t;;\n      *-*-freebsd*)\n \techo \"configure: warning: \"FreeBSD does not yet fully support threads with Boehm GC.\"\" 1>&2\n@@ -2634,17 +2723,17 @@ EOF\n       \t;;\n      *-*-solaris*)\n \tcat >> confdefs.h <<\\EOF\n-#define SOLARIS_THREADS 1\n+#define GC_SOLARIS_THREADS 1\n EOF\n \n \tcat >> confdefs.h <<\\EOF\n-#define _SOLARIS_PTHREADS 1\n+#define GC_SOLARIS_PTHREADS 1\n EOF\n \n \t;;\n      *-*-irix*)\n \tcat >> confdefs.h <<\\EOF\n-#define IRIX_THREADS 1\n+#define GC_IRIX_THREADS 1\n EOF\n \n \t;;\n@@ -2663,15 +2752,15 @@ esac\n \n \n echo $ac_n \"checking for dlopen in -ldl\"\"... $ac_c\" 1>&6\n-echo \"configure:2667: checking for dlopen in -ldl\" >&5\n+echo \"configure:2756: checking for dlopen in -ldl\" >&5\n ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-ldl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 2675 \"configure\"\n+#line 2764 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -2682,7 +2771,7 @@ int main() {\n dlopen()\n ; return 0; }\n EOF\n-if { (eval echo configure:2686: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2775: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -2704,19 +2793,7 @@ fi\n \n \n \n-# Check whether --enable-java-gc or --disable-java-gc was given.\n-if test \"${enable_java_gc+set}\" = set; then\n-  enableval=\"$enable_java_gc\"\n-  \n-  GC=$enableval\n-else\n-  GC=boehm\n-fi\n-\n-target_all=\n-if test \"$GC\" = \"boehm\"; then\n-   target_all=libgcjgc.la\n-fi\n+target_all=libgcjgc.la\n \n \n TARGET_ECOS=\"no\"\n@@ -2815,6 +2892,15 @@ cat >> confdefs.h <<\\EOF\n #define NO_SIGNALS 1\n EOF\n \n+cat >> confdefs.h <<\\EOF\n+#define NO_EXECUTE_PERMISSION 1\n+EOF\n+\n+cat >> confdefs.h <<\\EOF\n+#define ALL_INTERIOR_POINTERS 1\n+EOF\n+\n+\n cat >> confdefs.h <<\\EOF\n #define JAVA_FINALIZATION 1\n EOF\n@@ -2823,6 +2909,10 @@ cat >> confdefs.h <<\\EOF\n #define GC_GCJ_SUPPORT 1\n EOF\n \n+cat >> confdefs.h <<\\EOF\n+#define ATOMIC_UNCOLLECTABLE 1\n+EOF\n+\n \n if test -n \"${with_cross_host}\"; then\n    cat >> confdefs.h <<\\EOF\n@@ -2843,6 +2933,32 @@ EOF\n \n fi\n \n+# Check whether --enable-full-debug or --disable-full-debug was given.\n+if test \"${enable_full_debug+set}\" = set; then\n+  enableval=\"$enable_full_debug\"\n+   if test \"$enable_full_debug\" = \"yes\"; then\n+    echo \"configure: warning: \"Must define GC_DEBUG and use debug alloc. in clients.\"\" 1>&2\n+    cat >> confdefs.h <<\\EOF\n+#define KEEP_BACK_PTRS 1\n+EOF\n+\n+    cat >> confdefs.h <<\\EOF\n+#define DBG_HDRS_ALL 1\n+EOF\n+\n+    case $host in\n+      x86-*-linux* | i586-*-linux* | i686-*-linux* )\n+\techo \"configure: warning: \"Client must not use -fomit-frame-pointer.\"\" 1>&2\n+\tcat >> confdefs.h <<\\EOF\n+#define SAVE_CALL_COUNT 8\n+EOF\n+\n+      ;;\n+    esac \n+  fi\n+fi\n+\n+\n \n \n if test -z \"$with_cross_host\"; then\n@@ -3004,7 +3120,7 @@ s%@includedir@%$includedir%g\n s%@oldincludedir@%$oldincludedir%g\n s%@infodir@%$infodir%g\n s%@mandir@%$mandir%g\n-s%@boehm_gc_basedir@%$boehm_gc_basedir%g\n+s%@gc_basedir@%$gc_basedir%g\n s%@host@%$host%g\n s%@host_alias@%$host_alias%g\n s%@host_cpu@%$host_cpu%g\n@@ -3041,7 +3157,7 @@ s%@MAINTAINER_MODE_TRUE@%$MAINTAINER_MODE_TRUE%g\n s%@MAINTAINER_MODE_FALSE@%$MAINTAINER_MODE_FALSE%g\n s%@MAINT@%$MAINT%g\n s%@EXEEXT@%$EXEEXT%g\n-s%@BOEHM_GC_CFLAGS@%$BOEHM_GC_CFLAGS%g\n+s%@GC_CFLAGS@%$GC_CFLAGS%g\n s%@LN_S@%$LN_S%g\n s%@OBJEXT@%$OBJEXT%g\n s%@STRIP@%$STRIP%g\n@@ -3164,7 +3280,7 @@ target=${target}\n with_multisubdir=${with_multisubdir}\n ac_configure_args=\"${multilib_arg} ${ac_configure_args}\"\n CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n-boehm_gc_basedir=${boehm_gc_basedir}\n+gc_basedir=${gc_basedir}\n CC=\"${CC}\"\n DEFS=\"$DEFS\"\n \n@@ -3174,7 +3290,7 @@ cat >> $CONFIG_STATUS <<\\EOF\n echo \"$DEFS\" > boehm-cflags\n \n if test -n \"$CONFIG_FILES\"; then\n-  ac_file=Makefile . ${boehm_gc_basedir}/../config-ml.in\n+  ac_file=Makefile . ${gc_basedir}/../config-ml.in\n fi\n exit 0\n EOF"}, {"sha": "da2b5b31a0e9c1a91d60f94003da3e839dbac233", "filename": "boehm-gc/configure.host", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.host?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -1,6 +1,7 @@\n # configure.host\n \n-# This shell script handles all host based configuration for boehm_gc.\n+# This shell script handles all host based configuration for the garbage\n+# collector.\n # It sets various shell variables based on the the host and the\n # configuration options.  You can modify this shell script without\n # needing to rerun autoconf.\n@@ -15,16 +16,25 @@\n #   target_optspace\t--enable-target-optspace (\"yes\", \"no\", \"\")\n \n # It sets the following shell variables:\n-#   boehm_gc_cflags\tSpecial CFLAGS to use when building\n+#   gc_cflags\tSpecial CFLAGS to use when building\n \n-boehm_gc_cflags=-fexceptions\n+# We should set -fexceptions if we are using gcc and might be used\n+# inside something like gcj.  This is the zeroth approximation:\n+case \"$host\" in \n+    *-*-linux* )\n+    gc_cflags=-fexceptions\n+    ;;\n+    *-*-hpux* )\n+    gc_cflags=+ESdbgasm\n+    ;;\n+esac\n \n case \"${target_optspace}:${host}\" in\n   yes:*)\n-    boehm_gc_cflags=\"${boehm_gc_cflags} -Os\"\n+    gc_cflags=\"${gc_cflags} -Os\"\n     ;;\n   :m32r-* | :d10v-* | :d30v-*)\n-    boehm_gc_cflags=\"${boehm_gc_cflags} -Os\"\n+    gc_cflags=\"${gc_cflags} -Os\"\n     ;;\n   no:* | :*)\n     # Nothing."}, {"sha": "5a0092ecadc0b9cc3083c5601956ed5499a6c70c", "filename": "boehm-gc/configure.in", "status": "modified", "additions": 83, "deletions": 27, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.in?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -1,8 +1,24 @@\n+# Copyright (c) 1999-2001 by Red Hat, Inc. All rights reserved.\n+# \n+# THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n+# OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n+# \n+# Permission is hereby granted to use or copy this program\n+# for any purpose,  provided the above notices are retained on all copies.\n+# Permission to modify the code and to distribute modified code is granted,\n+# provided the above notices are retained, and a notice that the code was\n+# modified is included with the above copyright notice.\n+#\n+# Original author: Tom Tromey\n+\n dnl Process this file with autoconf to produce configure.\n \n AC_INIT(gcj_mlc.c)\n \n-BOEHM_CONFIGURE(.)\n+dnl Can't be done in GC_CONFIGURE because that confuses automake. \n+AC_CONFIG_AUX_DIR(.)\n+\n+GC_CONFIGURE(.)\n \n AM_PROG_LIBTOOL\n \n@@ -25,9 +41,24 @@ if false; then\n   AC_EXEEXT\n fi\n \n-AC_MSG_CHECKING([for thread model used by GCC])\n-THREADS=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n-AC_MSG_RESULT([$THREADS])\n+AC_MSG_CHECKING([for threads package to use])\n+AC_ARG_ENABLE(threads, [  --enable-threads=TYPE   choose threading package],\n+  THREADS=$enableval,\n+  [ AC_MSG_CHECKING([for thread model used by GCC])\n+    THREADS=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n+    if test -z \"$THREADS\"; then\n+      THREADS=no\n+    fi\n+    AC_MSG_RESULT([$THREADS])])\n+\n+AC_ARG_ENABLE(parallel-mark,\n+[  --enable-parallel-mark\tparallelize marking and free list construction],\n+   [case \"$THREADS\" in\n+      no | none | single)\n+\tAC_MSG_ERROR([Parallel mark requires --enable-threads=x spec])\n+\t;;\n+    esac]\n+)\n \n INCLUDES=-I${srcdir}/include\n THREADLIBS=\n@@ -39,22 +70,40 @@ case \"$THREADS\" in\n     THREADS=posix\n     THREADLIBS=-lpthread\n     case \"$host\" in\n+     x86-*-linux* | ia64-*-linux* | i586-*-linux* | i686-*-linux*)\n+\tAC_DEFINE(GC_LINUX_THREADS)\n+\tAC_DEFINE(_REENTRANT)\n+        if test \"${enable_parallel_mark}\"; then\n+\t  AC_DEFINE(PARALLEL_MARK)\n+\tfi\n+\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n+\t;;\n      *-*-linux*)\n-\tAC_DEFINE(LINUX_THREADS)\n+\tAC_DEFINE(GC_LINUX_THREADS)\n \tAC_DEFINE(_REENTRANT)\n \t;;\n+     *-*-hpux*)\n+\tAC_MSG_WARN(\"Only HP/UX 11 threads are supported.\")\n+\tAC_DEFINE(GC_HPUX_THREADS)\n+\tAC_DEFINE(_POSIX_C_SOURCE,199506L)\n+\tif test \"${enable_parallel_mark}\" = yes; then\n+\t  AC_DEFINE(PARALLEL_MARK)\n+\tfi\n+\tAC_DEFINE(THREAD_LOCAL_ALLOC)\n+\tTHREADLIBS=\"-lpthread -lrt\"\n+\t;;\n      *-*-freebsd*)\n \tAC_MSG_WARN(\"FreeBSD does not yet fully support threads with Boehm GC.\")\n \tAC_DEFINE(FREEBSD_THREADS)\n \tINCLUDES=\"$INCLUDES -pthread\"\n \tTHREADLIBS=-pthread\n       \t;;\n      *-*-solaris*)\n-\tAC_DEFINE(SOLARIS_THREADS)\n-\tAC_DEFINE(_SOLARIS_PTHREADS)\n+\tAC_DEFINE(GC_SOLARIS_THREADS)\n+\tAC_DEFINE(GC_SOLARIS_PTHREADS)\n \t;;\n      *-*-irix*)\n-\tAC_DEFINE(IRIX_THREADS)\n+\tAC_DEFINE(GC_IRIX_THREADS)\n \t;;\n      *-*-cygwin*)\n \tTHREADLIBS=\n@@ -73,16 +122,7 @@ AC_SUBST(THREADLIBS)\n AC_CHECK_LIB(dl, dlopen, EXTRA_TEST_LIBS=\"$EXTRA_TEST_LIBS -ldl\")\n AC_SUBST(EXTRA_TEST_LIBS)\n \n-AC_ARG_ENABLE(java-gc,\n-changequote(<<,>>)dnl\n-<<  --enable-java-gc=TYPE   choose garbage collector [boehm]>>,\n-changequote([,])\n-  GC=$enableval,\n-  GC=boehm)\n-target_all=\n-if test \"$GC\" = \"boehm\"; then\n-   target_all=libgcjgc.la\n-fi\n+target_all=libgcjgc.la\n AC_SUBST(target_all)\n \n dnl If the target is an eCos system, use the appropriate eCos\n@@ -162,12 +202,17 @@ dnl We need to override the top-level CFLAGS.  This is how we do it.\n MY_CFLAGS=\"$CFLAGS\"\n AC_SUBST(MY_CFLAGS)\n \n-dnl Define a few things to retarget the library towards\n-dnl embedded Java.\n+dnl Include defines that have become de facto standard.\n+dnl ALL_INTERIOR_POINTERS can be overridden in startup code.\n AC_DEFINE(SILENT)\n AC_DEFINE(NO_SIGNALS)\n+AC_DEFINE(NO_EXECUTE_PERMISSION)\n+AC_DEFINE(ALL_INTERIOR_POINTERS)\n+\n+dnl By default, make the library as general as possible.\n AC_DEFINE(JAVA_FINALIZATION)\n AC_DEFINE(GC_GCJ_SUPPORT)\n+AC_DEFINE(ATOMIC_UNCOLLECTABLE)\n \n dnl This is something of a hack.  When cross-compiling we turn off\n dnl some functionality.  We also enable the \"small\" configuration.\n@@ -179,6 +224,20 @@ if test -n \"${with_cross_host}\"; then\n    AC_DEFINE(NO_DEBUGGING)\n fi\n \n+AC_ARG_ENABLE(full-debug,\n+[  --enable-full-debug\tinclude full support for pointer backtracing etc.],\n+[ if test \"$enable_full_debug\" = \"yes\"; then\n+    AC_MSG_WARN(\"Must define GC_DEBUG and use debug alloc. in clients.\")\n+    AC_DEFINE(KEEP_BACK_PTRS)\n+    AC_DEFINE(DBG_HDRS_ALL)\n+    case $host in\n+      x86-*-linux* | i586-*-linux* | i686-*-linux* )\n+\tAC_MSG_WARN(\"Client must not use -fomit-frame-pointer.\")\n+\tAC_DEFINE(SAVE_CALL_COUNT, 8)\n+      ;;\n+    esac ]\n+  fi)\n+\n AM_CONDITIONAL(USE_LIBDIR, test -z \"$with_cross_host\")\n \n if test \"${multilib}\" = \"yes\"; then\n@@ -187,23 +246,20 @@ else\n   multilib_arg=\n fi\n \n-AC_OUTPUT(Makefile,\n-[\n-dnl Put all the -D options in a file.  These are required before\n-dnl boehm-config.h can be included.  This is a huge hack brought\n-dnl about by overall poor structuring of this entire library.\n+AC_OUTPUT(Makefile, [\n+dnl Put all the -D options in a file.\n echo \"$DEFS\" > boehm-cflags\n \n if test -n \"$CONFIG_FILES\"; then\n-  ac_file=Makefile . ${boehm_gc_basedir}/../config-ml.in\n+  ac_file=Makefile . ${gc_basedir}/../config-ml.in\n fi],\n srcdir=${srcdir}\n host=${host}\n target=${target}\n with_multisubdir=${with_multisubdir}\n ac_configure_args=\"${multilib_arg} ${ac_configure_args}\"\n CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n-boehm_gc_basedir=${boehm_gc_basedir}\n+gc_basedir=${gc_basedir}\n CC=\"${CC}\"\n DEFS=\"$DEFS\"\n )"}, {"sha": "a56a93c63d7e840b2c19695d81513e40301b50e8", "filename": "boehm-gc/dbg_mlc.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -26,7 +26,7 @@ GC_API void GC_register_finalizer_no_order\n /* Check whether object with base pointer p has debugging info\t*/ \n /* p is assumed to point to a legitimate object in our part\t*/\n /* of the heap.\t\t\t\t\t\t\t*/\n-/* This excludes the check as to whether tha back pointer is \t*/\n+/* This excludes the check as to whether the back pointer is \t*/\n /* odd, which is added by the GC_HAS_DEBUG_INFO macro.\t\t*/\n /* Note that if DBG_HDRS_ALL is set, uncollectable objects\t*/\n /* on free lists may not have debug information set.  Thus it's\t*/\n@@ -233,7 +233,7 @@ ptr_t p;\n ptr_t GC_store_debug_info(p, sz, string, integer)\n register ptr_t p;\t/* base pointer */\n word sz; \t/* bytes */\n-char * string;\n+GC_CONST char * string;\n word integer;\n {\n     register word * result = (word *)((oh *)p + 1);\n@@ -252,7 +252,7 @@ word integer;\n       ((oh *)p) -> oh_sz = sz;\n       ((oh *)p) -> oh_sf = START_FLAG ^ (word)result;\n       ((word *)p)[BYTES_TO_WORDS(GC_size(p))-1] =\n-         result[ROUNDED_UP_WORDS(sz)] = END_FLAG ^ (word)result;\n+         result[SIMPLE_ROUNDED_UP_WORDS(sz)] = END_FLAG ^ (word)result;\n #   endif\n     UNLOCK();\n     return((ptr_t)result);\n@@ -273,15 +273,15 @@ word integer;\n     /* But that's expensive.  And this way things should only appear\t*/\n     /* inconsistent while we're in the handler.\t\t\t\t*/\n #   ifdef KEEP_BACK_PTRS\n-      ((oh *)p) -> oh_back_ptr = 0;\n+      ((oh *)p) -> oh_back_ptr = HIDE_BACK_PTR(NOT_MARKED);\n #   endif\n     ((oh *)p) -> oh_string = string;\n     ((oh *)p) -> oh_int = integer;\n #   ifndef SHORT_DBG_HDRS\n       ((oh *)p) -> oh_sz = sz;\n       ((oh *)p) -> oh_sf = START_FLAG ^ (word)result;\n       ((word *)p)[BYTES_TO_WORDS(GC_size(p))-1] =\n-         result[ROUNDED_UP_WORDS(sz)] = END_FLAG ^ (word)result;\n+         result[SIMPLE_ROUNDED_UP_WORDS(sz)] = END_FLAG ^ (word)result;\n #   endif\n     return((ptr_t)result);\n }\n@@ -305,9 +305,9 @@ register oh * ohdr;\n     if (((word *)ohdr)[BYTES_TO_WORDS(gc_sz)-1] != (END_FLAG ^ (word)body)) {\n         return((ptr_t)((word *)ohdr + BYTES_TO_WORDS(gc_sz)-1));\n     }\n-    if (((word *)body)[ROUNDED_UP_WORDS(ohdr -> oh_sz)]\n+    if (((word *)body)[SIMPLE_ROUNDED_UP_WORDS(ohdr -> oh_sz)]\n         != (END_FLAG ^ (word)body)) {\n-        return((ptr_t)((word *)body + ROUNDED_UP_WORDS(ohdr -> oh_sz)));\n+        return((ptr_t)((word *)body + SIMPLE_ROUNDED_UP_WORDS(ohdr -> oh_sz)));\n     }\n     return(0);\n }\n@@ -964,15 +964,21 @@ struct closure {\n     \t\t\t  \t      GC_make_closure(fn,cd), ofn, ocd);\n }\n \n+#ifdef GC_ADD_CALLER\n+# define RA GC_RETURN_ADDR,\n+#else\n+# define RA\n+#endif\n+\n GC_PTR GC_debug_malloc_replacement(lb)\n size_t lb;\n {\n-    return GC_debug_malloc(lb, \"unknown\", 0);\n+    return GC_debug_malloc(lb, RA \"unknown\", 0);\n }\n \n GC_PTR GC_debug_realloc_replacement(p, lb)\n GC_PTR p;\n size_t lb;\n {\n-    return GC_debug_realloc(p, lb, \"unknown\", 0);\n+    return GC_debug_realloc(p, lb, RA \"unknown\", 0);\n }"}, {"sha": "c6b48c3bb411ad6237ad24bb6cf290918739a49a", "filename": "boehm-gc/doc/README", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -9,6 +9,9 @@ Copyright (c) 1998 by Fergus Henderson.  All rights reserved.\n The files Makefile.am, and configure.in are\n Copyright (c) 2001 by Red Hat Inc. All rights reserved.\n \n+The files config.guess and a few others are copyrighted by the Free\n+Software Foundation.\n+\n THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n \n@@ -18,7 +21,13 @@ Permission to modify the code and to distribute modified code is granted,\n provided the above notices are retained, and a notice that the code was\n modified is included with the above copyright notice.\n \n-This is version 6.0alpha7 of a conservative garbage collector for C and C++.\n+A few of the files needed to use the GNU-style build procedure come with\n+slightly different licenses, though they are all similar in spirit.  A few\n+are GPL'ed, but with an exception that should cover all uses in the\n+collector.  (If you are concerned about such things, I recommend you look\n+at the notice in config.guess or ltmain.sh.)\n+\n+This is version 6.0 of a conservative garbage collector for C and C++.\n \n You might find a more recent version of this at\n "}, {"sha": "2abf0b400f7f6455297ac9e6f31255c9b45b0309", "filename": "boehm-gc/doc/README.MacOSX", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME.MacOSX", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME.MacOSX", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.MacOSX?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -17,3 +17,11 @@ June, 1 2000\n \n Dietmar Planitzer\n dave.pl@ping.at\n+\n+Note from Andrew Begel:\n+\n+One more fix to enable gc.a to link successfully into a shared library for\n+MacOS X. You have to add -fno-common to the CFLAGS in the Makefile. MacOSX\n+disallows common symbols in anything that eventually finds its way into a\n+shared library. (I don't completely understand why, but -fno-common seems to\n+work and doesn't mess up the garbage collector's functionality)."}, {"sha": "c018c8b64d0915b88cc584fcd87f5c90c3b27d9c", "filename": "boehm-gc/doc/README.changes", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME.changes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME.changes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.changes?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -1291,7 +1291,103 @@ Since 6.0alpha6:\n    There seemed to be some problems with the encoding of root and finalizer\n    references.\n   \n+Since 6.0alpha7:\n+ - Changed GC_debug_malloc_replacement and GC_debug_realloc_replacement\n+   so that they compile under Irix.  (Thanks to Dave Love.)\n+ - Updated powerpc_macosx_mach_dep.s so that it works if the collector\n+   is in a dynamic library.  (Thanks to Andrew Begel.)\n+ - Transformed README.debugging into debugging.html, updating and\n+   expanding it in the process.  Added gcdescr.html and tree.html\n+   from the web site to the GC distribution.\n+ - Fixed several problems related to PRINT_BLACK_LIST. This involved\n+   restructuring some of the marker macros.\n+ - Fixed some problems with the sizing of objects with debug information.\n+   Finalization was broken KEEP_BACK_PTRS or PRINT_BLACK_LIST.  Reduced the\n+   object size with SHORT_DEBUG_HDRS by another word.\n+ - The \"Needed to allocate blacklisted ...\" warning had inadvertently\n+   been turned off by default, due to a buggy test in allchblk.c.  Turned\n+   it back on.\n+ - Removed the marker macros to deal with 2 pointers in interleaved fashion.\n+   They were messy and the performance improvement seemed minimal.  We'll\n+   leave such scheduling issues to the compiler.\n+ - Changed Linux/PowerPC test to also check for __powerpc__ in response\n+   to a discussion on the gcc mailing list.\n+ - On Matthew Flatt's suggestion removed the \"static\" from the jmp_buf\n+   declaration in GC_generic_push_regs.  This was causing problems in\n+   systems that register all of their own roots.  It looks far more correct\n+   to me without the \"static\" anyway. \n+ - Fixed several problems with thread local allocation of pointerfree or\n+   typed objects.  The collector was reclaiming thread-local free lists, since\n+   it wasn't following the link fields.\n+ - There was apparently a long-standing race condition related to multithreaded\n+   incremental collection.  A collection could be started and a thread stopped\n+   between the memory unprotect system call and the setting of the\n+   corresponding dirt bit.  I believe this did not affect Solaris or PCR, which\n+   use a different dirty-bit implementation.  Fixed this by installing\n+   signal handlers with sigaction instead of signal, and disabling the thread\n+   suspend signal while in the write-protect handler.  (It is unclear\n+   whether this scenario ever actually occurred.  I found it while tracking\n+   down the following:)\n+ - Incremental collection did not cooperate correctly with the PARALLEL_MARK\n+   implementation of GC_malloc_many or the local_malloc primitves.  It still\n+   doesn't work well, but it shouldn't lose memory anymore.\n+ - Integrated some changes from the gcc source tree that I had previously\n+   missed.  (Thanks to Bryce McKinley for the reminder/diff.)\n+ - Added Makefile.direct as a copy of the default Makefile, which would\n+   normally be overwritten if configure is run.\n+ - Changed the gc.tar target in Makefile.direct to embed the version number\n+   in the gc directory name.  This will affect future tar file distributions.\n+ - Changed the Irix dynamic library finding code to no longer try to\n+   eliminate writable text segments under Irix6.x, since that is probably no\n+   longer necessary, and can apparently be unsafe on occasion.  (Thanks to\n+   Shiro Kawai for pointing this out.)\n+ - GC_cleanup with GC_DEBUG enabled passed a real object base address to\n+   GC_debug_register_finalizer_ignore_self, which expected a pointer past the\n+   debug header.  Call GC_register_finalizer_ignore_self instead, even with\n+   debugging enabled.  (Thanks to Jean-Daniel Fekete for catching this.)\n+ - The collector didn't build with call chain saving enabled but NARGS=0.\n+   (Thanks to Maarten Thibaut.)\n+ - Fixed up the GNU-style build files enough so that they work in some\n+   obvious cases.\n+ - Added initial port to Digital Mars compiler for win32. (Thanks to Walter\n+   Bright.)\n+\n+Since 6.0alpha8:\n+ - added README.macros.\n+ - Made gc.mak a symbolic link to work around winzip's tendency to ignore\n+   hard links.\n+ - Simplified the setting of NEED_FIND_LIMIT in os_dep.c, possibly breaking\n+   it on untested platforms.\n+ - Integrated initial GNU HURD port. (Thanks to Chris Lingard and Igor\n+   Khavkine.)\n+ - A few more fixes for Digital Mars compiler.\n+ - Fixed gcc version recognition.  Renamed OPERATOR_NEW_ARRAY to\n+   GC_OPERATOR_NEW_ARRAY.  Changed GC_OPERATOR_NEW_ARRAY to be the default.\n+   It can be overridden with -DGC_NO_OPERATOR_NEW_ARRAY.  (Thanks to\n+   Cesar Eduardo Barros.) \n+ - Changed the byte size to free-list mapping in thread local allocation\n+   so that size 0 allocations are handled correctly.\n+ - Fixed Linux/MIPS stackbottom for new toolchain. (Thanks to Ryan Murray.)\n+ - Changed finalization registration to invoke GC_oom_fn when it runs out\n+   of memory.\n+ - Removed lvalue cast in finalize.c.  This caused some debug configurations\n+   not to build with some non-gcc compilers.\n+\n+Since 6.0alpha9:\n+ - Two more bug fixes for KEEP_BACK_PTRS and DBG_HDRS_ALL.\n+ - Fixed a stack clearing problem that resulted in SIGILL with a\n+   misaligned stack pointer for multithreaded SPARC builds.\n+ - Integrated another HURD patch (thanks to Igor Khavkine).\n+ \n+\n To do:\n+ - There seem to be outstanding issues on Solaris/X86, possibly with\n+   finding the data segment starting address.  Information/patches would\n+   ne appreciated.\n+ - New_gc_alloc.h is apparently no longer compatible with the latest C++\n+   standard library in gcc3.0.  (This isn't technically a bug, since it only\n+   claimed compatibility with the SGI STL.  But we may need a new C++ STL\n+   allocator interface.)\n  - Very large root set sizes (> 16 MB or so) could cause the collector\n    to abort with an unexpected mark stack overflow.  (Thanks again to\n    Peter Chubb.)  NOT YET FIXED.  Workaround is to increase the initial"}, {"sha": "3485e0145af2cf9db44a3849593befae70046396", "filename": "boehm-gc/doc/README.cords", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME.cords", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME.cords", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.cords?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -18,6 +18,20 @@ See cord.h for a description of the functions provided.  Ec.h describes\n to a cord.  These allow for efficient construction of cords without\n requiring a bound on the size of a cord.\n \n+More details on the data structure can be found in\n+\n+Boehm, Atkinson, and Plass, \"Ropes: An Alternative to Strings\",\n+Software Practice and Experience 25, 12, December 1995, pp. 1315-1330.\n+\n+A fundamentally similar \"rope\" data structure is also part of SGI's standard\n+template library implementation, and its descendents, which include the\n+GNU C++ library.  That uses reference counting by default.\n+There is a short description of that data structure at\n+http://reality.sgi.com/boehm/ropeimpl.html .  (The more official location\n+http://www.sgi.com/tech/stl/ropeimpl.html is missing a figure.)\n+\n+All of these are descendents of the \"ropes\" in Xerox Cedar.\n+\n de.c is a very dumb text editor that illustrates the use of cords.\n It maintains a list of file versions.  Each version is simply a\n cord representing the file contents.  Nonetheless, standard"}, {"sha": "f4dd65676aae5472806217081aae77aa1dd52ec7", "filename": "boehm-gc/doc/README.debugging", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eed566698034311c58eea585da1ddb5a6e0807fb/boehm-gc%2Fdoc%2FREADME.debugging", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eed566698034311c58eea585da1ddb5a6e0807fb/boehm-gc%2Fdoc%2FREADME.debugging", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.debugging?ref=eed566698034311c58eea585da1ddb5a6e0807fb", "patch": "@@ -1,68 +0,0 @@\n-Debugging suggestions:\n-\n-****If you get a segmentation fault or bus error while debugging with a debugger:\n-If the fault occurred in GC_find_limit, or with incremental collection enabled, this is probably normal.  The collector installs handlers to take care of these.  You will not see these unless you are using a debugger.  Your debugger should allow you to continue.  It's preferable to tell the debugger to ignore SIGBUS and SIGSEGV (\"handle\" in gdb, \"ignore\" in most versions of dbx) and set a breakpoint in abort.  The collector will call abort if the signal had another cause, and there was not other handler previously installed.  I recommend debugging without incremental collection if possible.  (This applies directly to UNIX systems.  Debugging with incremental collection under win32 is worse.  See README.win32.)  \n-\n-****If you get warning messages informing you that the collector needed to allocate blacklisted blocks:\n-\n-0) Ignore these warnings while you are using GC_DEBUG.  Some of the routines mentioned below don't have debugging equivalents.  (Alternatively, write the missing routines and send them to me.)\n-\n-1) Replace allocator calls that request large blocks with calls to GC_malloc_ignore_off_page or GC_malloc_atomic_ignore_off_page.  You may want to set a breakpoint in GC_default_warn_proc to help you identify such calls.  Make sure that a pointer to somewhere near the beginning of the resulting block is maintained in a (preferably volatile) variable as long as the block is needed.\n-\n-2) If the large blocks are allocated with realloc, I suggest instead allocating them with something like the following.  Note that the realloc size increment should be fairly large (e.g. a factor of 3/2) for this to exhibit reasonable performance.  But we all know we should do that anyway.\n-\n-void * big_realloc(void *p, size_t new_size)\n-{\n-    size_t old_size = GC_size(p);\n-    void * result;\n- \n-    if (new_size <= 10000) return(GC_realloc(p, new_size));\n-    if (new_size <= old_size) return(p);\n-    result = GC_malloc_ignore_off_page(new_size);\n-    if (result == 0) return(0);\n-    memcpy(result,p,old_size);\n-    GC_free(p);\n-    return(result);\n-}\n-\n-3) In the unlikely case that even relatively small object (<20KB) allocations are triggering these warnings, then your address space contains lots of \"bogus pointers\", i.e. values that appear to be pointers but aren't.  Usually this can be solved by using GC_malloc_atomic or the routines in gc_typed.h to allocate large pointerfree regions of bitmaps, etc.  Sometimes the problem can be solved with trivial changes of encoding in certain values.  It is possible, though not pleasant, to identify the source of the bogus pointers by setting a breakpoint in GC_add_to_black_list_stack, and looking at the value of current_p in the GC_mark_from_mark_stack frame.  Current_p contains the address of the bogus pointer.\n-\n-4) If you get only a fixed number of these warnings, you are probably only introducing a bounded leak by ignoring them.  If the data structures being allocated are intended to be permanent, then it is also safe to ignore them.  The warnings can be turned off by calling GC_set_warn_proc with a procedure that ignores these warnings (e.g. by doing absolutely nothing).\n-\n-\n-****If the collector dies in GC_malloc while trying to remove a free list element:\n-\n-1) With > 99% probability, you wrote past the end of an allocated object.  Try setting GC_DEBUG and using the debugging facilities in gc.h.\n-\n-\n-****If the heap grows too much:\n-\n-1) Consider using GC_malloc_atomic for objects containing nonpointers.  This is especially important for large arrays containg compressed data, pseudo-random numbers, and the like.  (This isn't all that likely to solve your problem, but it's a useful and easy optimization anyway, and this is a good time to try it.)   If you allocate large objects containg only one or two pointers at the beginning, either try the typed allocation primitives is gc.h, or separate out the pointerfree component.\n-2) If you are using the collector in its default mode, with interior pointer recognition enabled, consider using GC_malloc_ignore_off_page to allocate large objects.  (See gc.h and above for details.  Large means > 100K in most environments.)\n-3) GC_print_block_list() will print a list of all currently allocated heap blocks and what size objects they contain.  GC_print_hblkfreelist() will print a list of free heap blocks, and whether they are blacklisted.  GC_dump calls both of these, and also prints information about heap sections, and root segments.\n-4) Build the collector with -DKEEP_BACK_PTRS, and use the backptr.h\n-interface to determine why objects are being retained.\n-\n-\n-****If the collector appears to be losing objects:\n-\n-1) Replace all calls to GC_malloc_atomic and typed allocation by GC_malloc calls.  If this fixes the problem, gradually reinsert your optimizations.\n-2) You may also want to try the safe(r) pointer manipulation primitives in gc.h.  But those are hard to use until the preprocessor becomes available.\n-3) Try using the GC_DEBUG facilities.  This is less likely to be successful here than if the collector crashes.\n-[The rest of these are primarily for wizards.  You shouldn't need them unless you're doing something really strange, or debugging a collector port.]\n-4) Don't turn on incremental collection.  If that fixes the problem, suspect a bug in the dirty bit implementation.  Try compiling with -DCHECKSUMS to check for modified, but supposedly clean, pages.\n-5) On a SPARC, in a single-threaded environment, GC_print_callers(GC_arrays._last_stack) prints a cryptic stack trace as of the time of the last collection.  (You will need a debugger to decipher the result.)  The question to ask then is \"why should this object have been accessible at the time of the last collection?  Where was a pointer to it stored?\".  This facility should be easy to add for some other collector ports (namely if it's easy to traverse stack frames), but will be hard for others.\n-6) \"print *GC_find_header(p)\" in dbx or gdb will print the garbage collector block header information associated with the object p (e.g. object size, etc.)\n-7) GC_is_marked(p) determines whether p is the base address of a marked object.  Note that objects allocated since the last collection should not be marked, and that unmarked objects are reclaimed incrementally.  It's usually most interesting to set a breakpoint in GC_finish_collection and then to determine how much of the damaged data structure is marked at that point.\n-8) Look at the tracing facility in mark.c.  (Ignore this suggestion unless you are very familiar with collector internals.)\n-9) [From Melissa O'Neill:]\n-If you're using multiple threads, double check that all thread\n-creation goes through the GC_ wrapper functions rather than\n-calling the thread-creation functions themselves (e.g.,\n-GC_pthread_create rather than pthread_create).  The gc.h header\n-file includes suitable preprocessor definitions to accomplish\n-this mapping transparently -- the question is: are you including\n-it in all the modules that create threads?\n-\n-\n-"}, {"sha": "5760342a86a6187fa4d7b1967a79d80579b28617", "filename": "boehm-gc/doc/README.environment", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME.environment", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdoc%2FREADME.environment", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.environment?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -29,6 +29,9 @@ GC_NPROCS=<n> - Linux w/threads only.  Explicitly sets the number of processors\n \t\twhen multiple processors are available will preserve\n \t\tcorrectness, but may lead to really horrible performance.\n \n+GC_NO_BLACKLIST_WARNING - Prevents the collector from issuing\n+\t\t\"Needed to allocate blacklisted block at ...\" warnings.\n+\n The following turn on runtime flags that are also program settable.  Checked\n only during initialization.  We expect that they will usually be set through\n other means, but this may help with debugging and testing:"}, {"sha": "508fd24179ac1d442b2047515ee02e4a8f8a1ec4", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -53,7 +53,7 @@\n     !(defined(ALPHA) && defined(OSF1)) && \\\n     !defined(HPUX) && !(defined(LINUX) && defined(__ELF__)) && \\\n     !defined(RS6000) && !defined(SCO_ELF) && \\\n-    !(defined(NETBSD) && defined(__ELF__))\n+    !(defined(NETBSD) && defined(__ELF__)) && !defined(HURD)\n  --> We only know how to find data segments of dynamic libraries for the\n  --> above.  Additional SVR4 variants might not be too\n  --> hard to add.\n@@ -243,7 +243,7 @@ void GC_register_dynamic_libraries()\n # endif /* SUNOS */\n \n #if defined(LINUX) && defined(__ELF__) || defined(SCO_ELF) || \\\n-    (defined(NETBSD) && defined(__ELF__))\n+    (defined(NETBSD) && defined(__ELF__)) || defined(HURD)\n \n \n #ifdef USE_PROC_FOR_LIBRARIES\n@@ -514,6 +514,10 @@ void GC_register_dynamic_libraries()\n #include <fcntl.h>\n #include <elf.h>\n #include <errno.h>\n+#include <signal.h>  /* Only for the following test. */\n+#ifndef _sigargs\n+# define IRIX6\n+#endif\n \n extern void * GC_roots_present();\n \t/* The type is a lie, since the real type doesn't make sense here, */\n@@ -574,7 +578,8 @@ void GC_register_dynamic_libraries()\n         if ((flags & (MA_BREAK | MA_STACK | MA_PHYS)) != 0) goto irrelevant;\n         if ((flags & (MA_READ | MA_WRITE)) != (MA_READ | MA_WRITE))\n             goto irrelevant;\n-          /* The latter test is empirically useless.  Other than the\t*/\n+          /* The latter test is empirically useless in very old Irix\t*/\n+\t  /* versions.  Other than the\t\t\t\t\t*/\n           /* main data and stack segments, everything appears to be\t*/\n           /* mapped readable, writable, executable, and shared(!!).\t*/\n           /* This makes no sense to me.\t- HB\t\t\t\t*/\n@@ -587,7 +592,11 @@ void GC_register_dynamic_libraries()\n #\tendif /* MMAP_STACKS */\n \n         limit = start + addr_map[i].pr_size;\n-\tif (addr_map[i].pr_off == 0 && strncmp(start, ELFMAG, 4) == 0) {\n+\t/* The following seemed to be necessary for very old versions \t*/\n+\t/* of Irix, but it has been reported to discard relevant\t*/\n+\t/* segments under Irix 6.5.  \t\t\t\t\t*/\n+#\tifndef IRIX6\n+\t  if (addr_map[i].pr_off == 0 && strncmp(start, ELFMAG, 4) == 0) {\n \t    /* Discard text segments, i.e. 0-offset mappings against\t*/\n \t    /* executable files which appear to have ELF headers.\t*/\n \t    caddr_t arg;\n@@ -614,7 +623,8 @@ void GC_register_dynamic_libraries()\n \t            goto irrelevant;\n \t        }\n \t    }\n-\t}\n+\t  }\n+#\tendif /* !IRIX6 */\n         GC_add_roots_inner(start, limit, TRUE);\n       irrelevant: ;\n     }"}, {"sha": "229d828632c39868ccddd5cfe87b00eb1a2ad5f1", "filename": "boehm-gc/finalize.c", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -202,15 +202,27 @@ signed_word * log_size_ptr;\n     }\n     new_dl = (struct disappearing_link *)\n     \tGC_INTERNAL_MALLOC(sizeof(struct disappearing_link),NORMAL);\n-    if (new_dl != 0) {\n-        new_dl -> dl_hidden_obj = HIDE_POINTER(obj);\n-        new_dl -> dl_hidden_link = HIDE_POINTER(link);\n-        dl_set_next(new_dl, dl_head[index]);\n-        dl_head[index] = new_dl;\n-        GC_dl_entries++;\n-    } else {\n-        GC_finalization_failures++;\n+    if (0 == new_dl) {\n+#     ifdef THREADS\n+\tUNLOCK();\n+    \tENABLE_SIGNALS();\n+#     endif\n+      new_dl == GC_oom_fn(sizeof(struct disappearing_link));\n+      if (0 == new_dl) {\n+\tGC_finalization_failures++;\n+\treturn(0);\n+      }\n+      /* It's not likely we'll make it here, but ... */\n+#     ifdef THREADS\n+        DISABLE_SIGNALS();\n+\tLOCK();\n+#     endif\n     }\n+    new_dl -> dl_hidden_obj = HIDE_POINTER(obj);\n+    new_dl -> dl_hidden_link = HIDE_POINTER(link);\n+    dl_set_next(new_dl, dl_head[index]);\n+    dl_head[index] = new_dl;\n+    GC_dl_entries++;\n #   ifdef THREADS\n         UNLOCK();\n         ENABLE_SIGNALS();\n@@ -245,7 +257,7 @@ signed_word * log_size_ptr;\n             UNLOCK();\n     \t    ENABLE_SIGNALS();\n #\t    ifdef DBG_HDRS_ALL\n-\t      dl_next(curr_dl) = 0;\n+\t      dl_set_next(curr_dl, 0);\n #\t    else\n               GC_free((GC_PTR)curr_dl);\n #\t    endif\n@@ -416,18 +428,30 @@ finalization_mark_proc * mp;\n     }\n     new_fo = (struct finalizable_object *)\n     \tGC_INTERNAL_MALLOC(sizeof(struct finalizable_object),NORMAL);\n-    if (new_fo != 0) {\n-        new_fo -> fo_hidden_base = (word)HIDE_POINTER(base);\n-\tnew_fo -> fo_fn = fn;\n-\tnew_fo -> fo_client_data = (ptr_t)cd;\n-\tnew_fo -> fo_object_size = hhdr -> hb_sz;\n-\tnew_fo -> fo_mark_proc = mp;\n-\tfo_set_next(new_fo, fo_head[index]);\n-\tGC_fo_entries++;\n-\tfo_head[index] = new_fo;\n-    } else {\n-     \tGC_finalization_failures++;\n+    if (0 == new_fo) {\n+#     ifdef THREADS\n+\tUNLOCK();\n+    \tENABLE_SIGNALS();\n+#     endif\n+      new_fo == GC_oom_fn(sizeof(struct finalizable_object));\n+      if (0 == new_fo) {\n+\tGC_finalization_failures++;\n+\treturn;\n+      }\n+      /* It's not likely we'll make it here, but ... */\n+#     ifdef THREADS\n+        DISABLE_SIGNALS();\n+\tLOCK();\n+#     endif\n     }\n+    new_fo -> fo_hidden_base = (word)HIDE_POINTER(base);\n+    new_fo -> fo_fn = fn;\n+    new_fo -> fo_client_data = (ptr_t)cd;\n+    new_fo -> fo_object_size = hhdr -> hb_sz;\n+    new_fo -> fo_mark_proc = mp;\n+    fo_set_next(new_fo, fo_head[index]);\n+    GC_fo_entries++;\n+    fo_head[index] = new_fo;\n #   ifdef THREADS\n         UNLOCK();\n     \tENABLE_SIGNALS();\n@@ -593,7 +617,7 @@ void GC_finalize()\n               GC_words_finalized +=\n                  \tALIGNED_WORDS(curr_fo -> fo_object_size)\n               \t\t+ ALIGNED_WORDS(sizeof(struct finalizable_object));\n-\t    GC_ASSERT(GC_is_marked((ptr_t)curr_fo));\n+\t    GC_ASSERT(GC_is_marked(GC_base((ptr_t)curr_fo)));\n             curr_fo = next_fo;\n         } else {\n             prev_fo = curr_fo;"}, {"sha": "7e79521eb1f5db073ef0ce1453948d1ebd6d442f", "filename": "boehm-gc/gcj_mlc.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fgcj_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fgcj_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcj_mlc.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -36,7 +36,6 @@\n  *  3) FASTLOCK is not a significant win.\n  */\n \n-#include \"private/gc_priv.h\"\n #include \"private/gc_pmark.h\"\n #include \"gc_gcj.h\"\n #include \"private/dbg_mlc.h\""}, {"sha": "aaf29ee35ba5b124fffa29db70606d61b00481a9", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -80,10 +80,6 @@\n     typedef long ptrdiff_t;\t/* ptrdiff_t is not defined */\n # endif\n \n-#if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n-#include \"libgc_globals.h\"\n-#endif\n-\n #if defined(__MINGW32__) && defined(WIN32_THREADS)\n # ifdef GC_BUILD\n #   define GC_API __declspec(dllexport)\n@@ -92,8 +88,9 @@\n # endif\n #endif\n \n-#if defined(_MSC_VER) && (defined(_DLL) && !defined(NOT_GC_DLL) \\\n-\t                  || defined(GC_DLL))\n+#if (defined(__DMC__) || defined(_MSC_VER)) \\\n+\t\t&& (defined(_DLL) && !defined(GC_NOT_DLL) \\\n+\t            || defined(GC_DLL))\n # ifdef GC_BUILD\n #   define GC_API extern __declspec(dllexport)\n # else\n@@ -347,6 +344,10 @@ GC_API void GC_end_stubborn_change GC_PROTO((GC_PTR));\n \n /* Return a pointer to the base (lowest address) of an object given\t*/\n /* a pointer to a location within the object.\t\t\t\t*/\n+/* I.e. map an interior pointer to the corresponding bas pointer.\t*/\n+/* Note that with debugging allocation, this returns a pointer to the\t*/\n+/* actual base of the object, i.e. the debug information, not to\t*/\n+/* the base of the user object.\t\t\t\t\t\t*/\n /* Return 0 if displaced_pointer doesn't point to within a valid\t*/\n /* object.\t\t\t\t\t\t\t\t*/\n GC_API GC_PTR GC_base GC_PROTO((GC_PTR displaced_pointer));\n@@ -701,7 +702,7 @@ GC_API GC_warn_proc GC_set_warn_proc GC_PROTO((GC_warn_proc p));\n     /* Returns old warning procedure.\t*/\n \t\n /* The following is intended to be used by a higher level\t*/\n-/* (e.g. cedar-like) finalization facility.  It is expected\t*/\n+/* (e.g. Java-like) finalization facility.  It is expected\t*/\n /* that finalization code will arrange for hidden pointers to\t*/\n /* disappear.  Otherwise objects can be accessed after they\t*/\n /* have been collected.\t\t\t\t\t\t*/"}, {"sha": "ceb73f50a65f18d2e59923811645d409241d29f5", "filename": "boehm-gc/include/gc_cpp.h", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_cpp.h?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -83,7 +83,7 @@ objects.  In practice, it finds almost all of them.\n 1. Be sure the collector has been augmented with \"make c++\".\n \n 2.  If your compiler supports the new \"operator new[]\" syntax, then\n-add -DOPERATOR_NEW_ARRAY to the Makefile.\n+add -DGC_OPERATOR_NEW_ARRAY to the Makefile.\n \n If your compiler doesn't support \"operator new[]\", beware that an\n array of type T, where T is derived from \"gc\", may or may not be\n@@ -137,10 +137,17 @@ by UseGC.  GC is an alias for UseGC, unless GC_NAME_CONFLICT is defined.\n #define _cdecl\n #endif\n \n-#if ! defined( OPERATOR_NEW_ARRAY ) \\\n-    && (__BORLANDC__ >= 0x450 || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6) \\\n-\t|| __WATCOMC__ >= 1050 || _MSC_VER >= 1100)\n-#   define OPERATOR_NEW_ARRAY\n+#if ! defined( GC_NO_OPERATOR_NEW_ARRAY ) \\\n+    && !defined(_ENABLE_ARRAYNEW) /* Digimars */ \\\n+    && (defined(__BORLANDC__) && (__BORLANDC__ < 0x450) \\\n+\t|| (defined(__GNUC__) && \\\n+\t    (__GNUC__ < 2 || __GNUC__ == 2 && __GNUC_MINOR__ < 6)) \\\n+\t|| (defined(__WATCOMC__) && __WATCOMC__ < 1050))\n+#   define GC_NO_OPERATOR_NEW_ARRAY\n+#endif\n+\n+#if !defined(GC_NO_OPERATOR_NEW_ARRAY) && !defined(GC_OPERATOR_NEW_ARRAY)\n+#   define GC_OPERATOR_NEW_ARRAY\n #endif\n \n enum GCPlacement {UseGC,\n@@ -154,11 +161,11 @@ class gc {public:\n     inline void* operator new( size_t size, GCPlacement gcp );\n     inline void operator delete( void* obj );\n \n-#ifdef OPERATOR_NEW_ARRAY\n+#ifdef GC_OPERATOR_NEW_ARRAY\n     inline void* operator new[]( size_t size );\n     inline void* operator new[]( size_t size, GCPlacement gcp );\n     inline void operator delete[]( void* obj );\n-#endif /* OPERATOR_NEW_ARRAY */\n+#endif /* GC_OPERATOR_NEW_ARRAY */\n     };    \n     /*\n     Instances of classes derived from \"gc\" will be allocated in the \n@@ -204,7 +211,7 @@ inline void* operator new(\n     classes derived from \"gc_cleanup\" or containing members derived\n     from \"gc_cleanup\". */\n \n-#ifdef OPERATOR_NEW_ARRAY\n+#ifdef GC_OPERATOR_NEW_ARRAY\n \n #ifdef _MSC_VER\n  /** This ensures that the system default operator new[] doesn't get\n@@ -257,7 +264,7 @@ inline void* operator new[](\n     /*\n     The operator new for arrays, identical to the above. */\n \n-#endif /* OPERATOR_NEW_ARRAY */\n+#endif /* GC_OPERATOR_NEW_ARRAY */\n \n /****************************************************************************\n \n@@ -280,7 +287,7 @@ inline void gc::operator delete( void* obj ) {\n     GC_FREE( obj );}\n     \n \n-#ifdef OPERATOR_NEW_ARRAY\n+#ifdef GC_OPERATOR_NEW_ARRAY\n \n inline void* gc::operator new[]( size_t size ) {\n     return gc::operator new( size );}\n@@ -291,7 +298,7 @@ inline void* gc::operator new[]( size_t size, GCPlacement gcp ) {\n inline void gc::operator delete[]( void* obj ) {\n     gc::operator delete( obj );}\n     \n-#endif /* OPERATOR_NEW_ARRAY */\n+#endif /* GC_OPERATOR_NEW_ARRAY */\n \n \n inline gc_cleanup::~gc_cleanup() {\n@@ -305,11 +312,12 @@ inline gc_cleanup::gc_cleanup() {\n     void* oldData;\n     void* base = GC_base( (void *) this );\n     if (0 != base)  {\n-      GC_REGISTER_FINALIZER_IGNORE_SELF( \n+      // Don't call the debug version, since this is a real base address.\n+      GC_register_finalizer_ignore_self( \n         base, (GC_finalization_proc)cleanup, (void*) ((char*) this - (char*) base), \n         &oldProc, &oldData );\n       if (0 != oldProc) {\n-        GC_REGISTER_FINALIZER_IGNORE_SELF( base, oldProc, oldData, 0, 0 );}}}\n+        GC_register_finalizer_ignore_self( base, oldProc, oldData, 0, 0 );}}}\n \n inline void* operator new( \n     size_t size, \n@@ -331,7 +339,7 @@ inline void* operator new(\n     return obj;}\n         \n \n-#ifdef OPERATOR_NEW_ARRAY\n+#ifdef GC_OPERATOR_NEW_ARRAY\n \n inline void* operator new[]( \n     size_t size, \n@@ -341,7 +349,7 @@ inline void* operator new[](\n {\n     return ::operator new( size, gcp, cleanup, clientData );}\n \n-#endif /* OPERATOR_NEW_ARRAY */\n+#endif /* GC_OPERATOR_NEW_ARRAY */\n \n \n #endif /* GC_CPP_H */"}, {"sha": "6f5b3c8677d86dc4009127a4f14e9870627cbd50", "filename": "boehm-gc/include/private/dbg_mlc.h", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -19,7 +19,7 @@\n  * not use it.  Clients that define their own object kinds with\n  * debugging allocators will probably want to include this, however.\n  * No attempt is made to keep the namespace clean.  This should not be\n- * included from header filrd that are frequently included by clients.\n+ * included from header files that are frequently included by clients.\n  */\n \n #ifndef _DBG_MLC_H\n@@ -32,11 +32,31 @@\n #   include \"gc_backptr.h\"\n # endif\n \n+#ifndef HIDE_POINTER\n+  /* Gc.h was previously included, and hence the I_HIDE_POINTERS\t*/\n+  /* definition had no effect.  Repeat the gc.h definitions here to\t*/\n+  /* get them anyway.\t\t\t\t\t\t\t*/\n+    typedef GC_word GC_hidden_pointer;\n+#   define HIDE_POINTER(p) (~(GC_hidden_pointer)(p))\n+#   define REVEAL_POINTER(p) ((GC_PTR)(HIDE_POINTER(p)))\n+#endif /* HIDE_POINTER */\n+\n # define START_FLAG ((word)0xfedcedcb)\n # define END_FLAG ((word)0xbcdecdef)\n \t/* Stored both one past the end of user object, and one before\t*/\n \t/* the end of the object as seen by the allocator.\t\t*/\n \n+# if defined(KEEP_BACK_PTRS) || defined(PRINT_BLACK_LIST)\n+    /* Pointer \"source\"s that aren't real locations.\t*/\n+    /* Used in oh_back_ptr fields and as \"source\"\t*/\n+    /* argument to some marking functions.\t\t*/\n+#\tdefine NOT_MARKED (ptr_t)(0)\n+#\tdefine MARKED_FOR_FINALIZATION (ptr_t)(2)\n+\t    /* Object was marked because it is finalizable.\t*/\n+#\tdefine MARKED_FROM_REGISTER (ptr_t)(4)\n+\t    /* Object was marked from a rgister.  Hence the\t*/\n+\t    /* source of the reference doesn't have an address.\t*/\n+# endif /* KEEP_BACK_PTRS || PRINT_BLACK_LIST */\n \n /* Object header */\n typedef struct {\n@@ -48,16 +68,13 @@ typedef struct {\n \t    /* overwrite a value with the least significant\t*/\n \t    /* bit clear, thus ensuring that we never overwrite\t*/\n \t    /* a free list link field.\t\t\t\t*/\n+ \t    /* Note that blocks dropped by black-listing will\t*/\n+ \t    /* also have the lsb clear once debugging has\t*/\n+ \t    /* started.\t\t\t\t\t\t*/\n \t    /* The following are special back pointer values.\t*/\n \t    /* Note that the \"hidden\" (i.e. bitwise \t\t*/\n \t    /* complemented version) of these is actually \t*/\n \t    /* stored.\t\t\t\t\t\t*/\n-#\tdefine NOT_MARKED (ptr_t)(0)\n-#\tdefine MARKED_FOR_FINALIZATION (ptr_t)(2)\n-\t    /* Object was marked because it is finalizable.\t*/\n-#\tdefine MARKED_FROM_REGISTER (ptr_t)(4)\n-\t    /* Object was marked from a rgister.  Hence the\t*/\n-\t    /* source of the reference doesn't have an address.\t*/\n #       if ALIGNMENT == 1\n \t  /* Fudge back pointer to be even.  */\n #\t  define HIDE_BACK_PTR(p) HIDE_POINTER(~1 & (GC_word)(p))\n@@ -68,7 +85,7 @@ typedef struct {\n \t  word oh_dummy;\n #\tendif\n #   endif\n-    char * oh_string;\t\t/* object descriptor string\t*/\n+    GC_CONST char * oh_string;\t/* object descriptor string\t*/\n     word oh_int;\t\t/* object descriptor integers\t*/\n #   ifdef NEED_CALLINFO\n       struct callinfo oh_ci[NFRAMES];\n@@ -81,13 +98,17 @@ typedef struct {\n /* The size of the above structure is assumed not to dealign things,\t*/\n /* and to be a multiple of the word length.\t\t\t\t*/\n \n-#define DEBUG_BYTES (sizeof (oh) + sizeof (word))\n+#ifdef SHORT_DBG_HDRS\n+#   define DEBUG_BYTES (sizeof (oh))\n+#else\n+    /* Add space for END_FLAG, but use any extra space that was already\t*/\n+    /* added to catch off-the-end pointers.\t\t\t\t*/\n+#   define DEBUG_BYTES (sizeof (oh) + sizeof (word) - EXTRA_BYTES)\n+#endif\n #define USR_PTR_FROM_BASE(p) ((ptr_t)(p) + sizeof(oh))\n \n-/* There is no reason to ever add a byte at the end explicitly, since we */\n-/* already add a guard word.\t\t\t\t\t\t */\n-#undef ROUNDED_UP_WORDS\n-#define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1) - 1)\n+/* Round bytes to words without adding extra byte at end.\t*/\n+#define SIMPLE_ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1) - 1)\n \n #ifdef SAVE_CALL_CHAIN\n #   define ADD_CALL_CHAIN(base, ra) GC_save_callers(((oh *)(base)) -> oh_ci)"}, {"sha": "dd615455f3b485b94957786b55a69a6103dd3abb", "filename": "boehm-gc/include/private/gc_hdrs.h", "status": "modified", "additions": 16, "deletions": 86, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_hdrs.h?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -26,13 +26,11 @@ typedef struct hblkhdr hdr;\n  * table.\n  *\n  * This defines HDR, GET_HDR, and SET_HDR, the main macros used to\n- * retrieve and set object headers.  We also define some variants to\n- * retrieve 2 unrelated headers in interleaved fashion.  This\n- * slightly improves scheduling.\n+ * retrieve and set object headers.\n  *\n  * Since 5.0 alpha 5, we can also take advantage of a header lookup\n  * cache.  This is a locally declared direct mapped cache, used inside\n- * the marker.  The HC_GET_HDR and HC_GET_HDR2 macros use and maintain this\n+ * the marker.  The HC_GET_HDR macro uses and maintains this\n  * cache.  Assuming we get reasonable hit rates, this shaves a few\n  * memory references from each pointer validation.\n  */\n@@ -67,16 +65,13 @@ extern hdr * GC_invalid_header; /* header for an imaginary block \t*/\n \n \n /* Check whether p and corresponding hhdr point to long or invalid\t*/\n-/* object.  If so, advance them\tto\t\t\t\t\t*/\n+/* object.  If so, advance hhdr\tto\t\t\t\t\t*/\n /* beginning of\tblock, or set hhdr to GC_invalid_header.\t\t*/\n #define ADVANCE(p, hhdr, source) \\\n-            if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) { \\\n-              p = GC_FIND_START(p, hhdr, (word)source); \\\n-              if (p == 0) { \\\n-\t\thhdr = GC_invalid_header; \\\n-\t      } else { \\\n-                hhdr = GC_find_header(p); \\\n-\t      } \\\n+\t    { \\\n+\t      hdr * new_hdr = GC_invalid_header; \\\n+              p = GC_FIND_START(p, hhdr, &new_hdr, (word)source); \\\n+\t      hhdr = new_hdr; \\\n     \t    }\n \n #ifdef USE_HDR_CACHE\n@@ -124,35 +119,12 @@ extern hdr * GC_invalid_header; /* header for an imaginary block \t*/\n \t  } else { \\\n \t    HC_MISS(); \\\n \t    GET_HDR(p, hhdr); \\\n-\t    ADVANCE(p, hhdr, source); \\\n-\t    hce -> block_addr = (word)(p) >> LOG_HBLKSIZE; \\\n-\t    hce -> hce_hdr = hhdr; \\\n-\t  } \\\n-\t}\n-\n-# define HC_GET_HDR2(p1, hhdr1, source1, p2, hhdr2, source2) \\\n-\t{ \\\n-\t  hdr_cache_entry * hce1 = HCE(p1); \\\n-\t  hdr_cache_entry * hce2 = HCE(p2); \\\n-\t  if (HCE_VALID_FOR(hce1, p1)) { \\\n-\t    HC_HIT(); \\\n-\t    hhdr1 = hce1 -> hce_hdr; \\\n-\t  } else { \\\n-\t    HC_MISS(); \\\n-\t    GET_HDR(p1, hhdr1); \\\n-\t    ADVANCE(p1, hhdr1, source1); \\\n-\t    hce1 -> block_addr = (word)(p1) >> LOG_HBLKSIZE; \\\n-\t    hce1 -> hce_hdr = hhdr1; \\\n-\t  } \\\n-\t  if (HCE_VALID_FOR(hce2, p2)) { \\\n-\t    HC_HIT(); \\\n-\t    hhdr2 = hce2 -> hce_hdr; \\\n-\t  } else { \\\n-\t    HC_MISS(); \\\n-\t    GET_HDR(p2, hhdr2); \\\n-\t    ADVANCE(p2, hhdr2, source2); \\\n-\t    hce2 -> block_addr = (word)(p2) >> LOG_HBLKSIZE; \\\n-\t    hce2 -> hce_hdr = hhdr2; \\\n+            if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) { \\\n+\t      ADVANCE(p, hhdr, source); \\\n+\t    } else { \\\n+\t      hce -> block_addr = (word)(p) >> LOG_HBLKSIZE; \\\n+\t      hce -> hce_hdr = hhdr; \\\n+\t    } \\\n \t  } \\\n \t}\n \n@@ -165,16 +137,10 @@ extern hdr * GC_invalid_header; /* header for an imaginary block \t*/\n # define HC_GET_HDR(p, hhdr, source) \\\n \t{ \\\n \t  GET_HDR(p, hhdr); \\\n-\t  ADVANCE(p, hhdr, source); \\\n-\t}\n-\n-# define HC_GET_HDR2(p1, hhdr1, source1, p2, hhdr2, source2) \\\n-\t{ \\\n-\t  GET_HDR2(p1, hhdr1, p2, hhdr2); \\\n-\t  ADVANCE(p1, hhdr1, source1); \\\n-\t  ADVANCE(p2, hhdr2, source2); \\\n+          if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) { \\\n+\t    ADVANCE(p, hhdr, source); \\\n+\t  } \\\n \t}\n-\n #endif\n \n typedef struct bi {\n@@ -229,8 +195,6 @@ typedef struct bi {\n #   define GET_HDR(p, hhdr) (hhdr) = HDR(p)\n #   define SET_HDR(p, hhdr) HDR_INNER(p) = (hhdr)\n #   define GET_HDR_ADDR(p, ha) (ha) = &(HDR_INNER(p))\n-#   define GET_HDR2(p1, hhdr1, p2, hhdr2) \\\n-\t{ GET_HDR(p1, hhdr1); GET_HDR(p2, hhdr2); }\n # else /* hash */\n /*  Hash function for tree top level */\n #   define TL_HASH(hi) ((hi) & (TOP_SZ - 1))\n@@ -257,40 +221,6 @@ typedef struct bi {\n #   define SET_HDR(p, hhdr) { register hdr ** _ha; GET_HDR_ADDR(p, _ha); \\\n \t\t\t      *_ha = (hhdr); }\n #   define HDR(p) GC_find_header((ptr_t)(p))\n-    /* And some interleaved versions for two pointers at once.  \t*/\n-    /* This hopefully helps scheduling on processors like IA64.\t\t*/\n-#   define GET_BI2(p1, bottom_indx1, p2, bottom_indx2) \\\n-\t{ \\\n-\t    register word hi1 = \\\n-\t        (word)(p1) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE); \\\n-\t    register word hi2 = \\\n-\t        (word)(p2) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE); \\\n-\t    register bottom_index * _bi1 = GC_top_index[TL_HASH(hi1)]; \\\n-\t    register bottom_index * _bi2 = GC_top_index[TL_HASH(hi2)]; \\\n-\t    \\\n-\t    while (_bi1 -> key != hi1 && _bi1 != GC_all_nils) \\\n-\t    \t_bi1 = _bi1 -> hash_link; \\\n-\t    while (_bi2 -> key != hi2 && _bi2 != GC_all_nils) \\\n-\t    \t_bi2 = _bi2 -> hash_link; \\\n-\t    (bottom_indx1) = _bi1; \\\n-\t    (bottom_indx2) = _bi2; \\\n-\t}\n-#   define GET_HDR_ADDR2(p1, ha1, p2, ha2) \\\n-\t{ \\\n-\t    register bottom_index * bi1; \\\n-\t    register bottom_index * bi2; \\\n-\t    \\\n-\t    GET_BI2(p1, bi1, p2, bi2);\t\\\n-\t    (ha1) = &(HDR_FROM_BI(bi1, p1)); \\\n-\t    (ha2) = &(HDR_FROM_BI(bi2, p2)); \\\n-\t}\n-#   define GET_HDR2(p1, hhdr1, p2, hhdr2) \\\n-\t{ register hdr ** _ha1;  \\\n-\t  register hdr ** _ha2;  \\\n-\t  GET_HDR_ADDR2(p1, _ha1, p2, _ha2); \\\n-\t  (hhdr1) = *_ha1;  \\\n-\t  (hhdr2) = *_ha2;  \\\n-\t}\n # endif\n \t\t\t    \n /* Is the result a forwarding address to someplace closer to the\t*/"}, {"sha": "eed9f1050f88dcfb54fa732a14c8914d2e240338", "filename": "boehm-gc/include/private/gc_locks.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_locks.h?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -43,6 +43,7 @@\n  *   \n  */  \n # ifdef THREADS\n+   void GC_noop1 GC_PROTO((word));\n #  ifdef PCR_OBSOLETE\t/* Faster, but broken with multiple lwp's\t*/\n #    include  \"th/PCR_Th.h\"\n #    include  \"th/PCR_ThCrSec.h\"\n@@ -236,7 +237,7 @@\n      /* \"set\" means 0 and \"clear\" means 1 here.\t\t*/\n #    define GC_test_and_set(addr) !GC_test_and_clear(addr);\n #    define GC_TEST_AND_SET_DEFINED\n-#    define GC_clear(addr) GC_noop1(addr); *(volatile unsigned int *)addr = 1;\n+#    define GC_clear(addr) GC_noop1((word)(addr)); *(volatile unsigned int *)addr = 1;\n \t/* The above needs a memory barrier! */\n #    define GC_CLEAR_DEFINED\n #  endif"}, {"sha": "43077e9f616f2be97ac8156c41e4c68122fa5ac4", "filename": "boehm-gc/include/private/gc_pmark.h", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -25,7 +25,7 @@\n #ifndef GC_PMARK_H\n # define GC_PMARK_H\n \n-# ifdef KEEP_BACK_PTRS\n+# if defined(KEEP_BACK_PTRS) || defined(PRINT_BLACK_LIST)\n #   include \"dbg_mlc.h\"\n # endif\n # ifndef GC_MARK_H\n@@ -132,12 +132,17 @@ extern mse * GC_mark_stack;\n      */\n #endif /* PARALLEL_MARK */\n \n+/* Return a pointer to within 1st page of object.  \t*/\n+/* Set *new_hdr_p to corr. hdr.\t\t\t\t*/\n+#ifdef __STDC__\n # ifdef PRINT_BLACK_LIST\n-  ptr_t GC_find_start(ptr_t current, hdr *hhdr, word source);\n+    ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p, word source);\n # else\n-  ptr_t GC_find_start(ptr_t current, hdr *hhdr);\n-# define source 0\n+    ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p);\n # endif\n+#else\n+  ptr_t GC_find_start();\n+#endif\n \n mse *GC_signal_mark_stack_overflow(mse *msp);\n \n@@ -169,11 +174,11 @@ mse *GC_signal_mark_stack_overflow(mse *msp);\n }\n \n #ifdef PRINT_BLACK_LIST\n-#   define GC_FIND_START(current, hhdr, source) \\\n-\tGC_find_start(current, hhdr, source)\n+#   define GC_FIND_START(current, hhdr, new_hdr_p, source) \\\n+\tGC_find_start(current, hhdr, new_hdr_p, source)\n #else\n-#   define GC_FIND_START(current, hhdr, source) \\\n-\tGC_find_start(current, hhdr)\n+#   define GC_FIND_START(current, hhdr, new_hdr_p, source) \\\n+\tGC_find_start(current, hhdr, new_hdr_p)\n #endif\n \n /* Push the contents of current onto the mark stack if it is a valid\t*/\n@@ -188,9 +193,10 @@ mse *GC_signal_mark_stack_overflow(mse *msp);\n  \\\n     GET_HDR(my_current, my_hhdr); \\\n     if (IS_FORWARDING_ADDR_OR_NIL(my_hhdr)) { \\\n-         my_current = GC_FIND_START(my_current, my_hhdr, (word)source); \\\n-         if (my_current == 0) goto exit_label; \\\n-         my_hhdr = GC_find_header(my_current); \\\n+\t hdr * new_hdr = GC_invalid_header; \\\n+         my_current = GC_FIND_START(my_current, my_hhdr, \\\n+\t\t\t \t    &new_hdr, (word)source); \\\n+         my_hhdr = new_hdr; \\\n     } \\\n     PUSH_CONTENTS_HDR(my_current, mark_stack_top, mark_stack_limit, \\\n \t\t  source, exit_label, my_hhdr);\t\\\n@@ -210,27 +216,6 @@ exit_label: ; \\\n exit_label: ; \\\n }\n \n-/* As above, but deal with two pointers in interleaved fashion.\t*/\n-# define HC_PUSH_CONTENTS2(current1, current2, mark_stack_top, \\\n-\t\t\t   mark_stack_limit, \\\n-\t\t           source1, source2, exit_label1, exit_label2) \\\n-{ \\\n-    hdr * hhdr1; \\\n-    ptr_t my_current1 = current1; \\\n-    hdr * hhdr2; \\\n-    ptr_t my_current2 = current2; \\\n- \\\n-    HC_GET_HDR2(my_current1, hhdr1, source1, my_current2, hhdr2, source2); \\\n-    PUSH_CONTENTS_HDR(my_current1, mark_stack_top, mark_stack_limit, \\\n-\t\t  source1, exit_label1, hhdr1);\t\\\n-exit_label1: ; \\\n-    if (0 != hhdr2) { \\\n-      PUSH_CONTENTS_HDR(my_current2, mark_stack_top, mark_stack_limit, \\\n-\t\t  source2, exit_label2, hhdr2);\t\\\n-    } \\\n-exit_label2: ; \\\n-}\n-\n /* Set mark bit, exit if it was already set.\t*/\n \n # ifdef USE_MARK_BYTES\n@@ -257,10 +242,12 @@ exit_label2: ; \\\n # endif /* USE_MARK_BYTES */\n \n /* If the mark bit corresponding to current is not set, set it, and \t*/\n-/* push the contents of the object on the mark stack.  Since we\t\t*/\n-/* already have the header, we only look at the low order bits of \t*/\n-/* current.  (The value of current doesn't matter if hhdr = \t\t*/\n-/* GC_invalid_header.)\t\t\t\t\t\t\t*/\n+/* push the contents of the object on the mark stack.  For a small \t*/\n+/* object we assume that current is the (possibly interior) pointer\t*/\n+/* to the object.  For large objects we assume that current points\t*/\n+/* to somewhere inside the first page of the object.  If\t\t*/\n+/* GC_all_interior_pointers is set, it may have been previously \t*/\n+/* adjusted to make that true.\t\t\t\t\t\t*/\n # define PUSH_CONTENTS_HDR(current, mark_stack_top, mark_stack_limit, \\\n \t\t           source, exit_label, hhdr) \\\n { \\\n@@ -346,7 +333,7 @@ mse * GC_mark_from GC_PROTO((mse * top, mse * bottom, mse *limit));\n     while (!GC_mark_stack_empty()) MARK_FROM_MARK_STACK(); \\\n     if (GC_mark_state != MS_NONE) { \\\n         GC_set_mark_bit(real_ptr); \\\n-        while (!GC_mark_some((ptr_t)0)); \\\n+        while (!GC_mark_some((ptr_t)0)) {} \\\n     } \\\n }\n "}, {"sha": "5135e3e9b0a73344677de25133e781a81a2f0636", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -634,7 +634,7 @@ extern GC_warn_proc GC_current_warn_proc;\n # else\n #       define ALIGNED_WORDS(n) ROUNDED_UP_WORDS(n)\n # endif\n-# define SMALL_OBJ(bytes) ((bytes) < (MAXOBJBYTES -EXTRA_BYTES))\n+# define SMALL_OBJ(bytes) ((bytes) < (MAXOBJBYTES - EXTRA_BYTES))\n # define ADD_SLOP(bytes) ((bytes) + EXTRA_BYTES)\n # ifndef MIN_WORDS\n     /* MIN_WORDS is the size of the smallest allocated object.\t*/\n@@ -1456,6 +1456,9 @@ void GC_clear_hdr_marks GC_PROTO((hdr * hhdr));\n \t\t\t\t    /* Clear the mark bits in a header */\n void GC_set_hdr_marks GC_PROTO((hdr * hhdr));\n  \t\t\t\t    /* Set the mark bits in a header */\n+void GC_set_fl_marks GC_PROTO((ptr_t p));\n+\t\t\t\t    /* Set all mark bits associated with */\n+\t\t\t\t    /* a free list.\t\t\t */\n void GC_add_roots_inner GC_PROTO((char * b, char * e, GC_bool tmp));\n GC_bool GC_is_static_root GC_PROTO((ptr_t p));\n   \t\t/* Is the address p in one of the registered static\t*/\n@@ -1484,9 +1487,9 @@ void GC_bl_init GC_PROTO((void));\n \t\t\t/* reference from the heap or static data\t*/\n #     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n       \t\tif (GC_all_interior_pointers) { \\\n-\t\t  GC_add_to_black_list_stack(bits, source); \\\n+\t\t  GC_add_to_black_list_stack(bits, (ptr_t)(source)); \\\n \t\t} else { \\\n-  \t\t  GC_add_to_black_list_normal(bits, source); \\\n+  \t\t  GC_add_to_black_list_normal(bits, (ptr_t)(source)); \\\n \t\t}\n # else\n       void GC_add_to_black_list_normal GC_PROTO((word p));\n@@ -1796,12 +1799,16 @@ void GC_dump GC_PROTO((void));\n \n /* Make arguments appear live to compiler */\n # ifdef __WATCOMC__\n-  void GC_noop(void*, ...);\n+    void GC_noop(void*, ...);\n # else\n-  GC_API void GC_noop();\n+#   ifdef __DMC__\n+      GC_API void GC_noop(...);\n+#   else\n+      GC_API void GC_noop();\n+#   endif\n # endif\n \n-void GC_noop1 GC_PROTO((word arg));\n+void GC_noop1 GC_PROTO((word));\n \n /* Logging and diagnostic output: \t*/\n GC_API void GC_printf GC_PROTO((GC_CONST char * format, long, long, long, long, long, long));\n@@ -1859,7 +1866,7 @@ void GC_err_puts GC_PROTO((GC_CONST char *s));\n #\tdefine GC_ASSERT(expr)\n # endif\n \n-# ifdef PARALLEL_MARK\n+# if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n     /* We need additional synchronization facilities from the thread\t*/\n     /* support.  We believe these are less performance critical\t\t*/\n     /* than the main garbage collector lock; standard pthreads-based\t*/\n@@ -1878,13 +1885,15 @@ void GC_err_puts GC_PROTO((GC_CONST char *s));\n \n      extern void GC_acquire_mark_lock();\n      extern void GC_release_mark_lock();\n-     extern void GC_notify_all_marker();\n      extern void GC_notify_all_builder();\n-     extern void GC_wait_marker();\n      /* extern void GC_wait_builder(); */\n      extern void GC_wait_for_reclaim();\n \n      extern word GC_fl_builder_count;\t/* Protected by mark lock.\t*/\n+# endif /* PARALLEL_MARK || THREAD_LOCAL_ALLOC */\n+# ifdef PARALLEL_MARK\n+     extern void GC_notify_all_marker();\n+     extern void GC_wait_marker();\n      extern word GC_mark_no;\t\t/* Protected by mark lock.\t*/\n \n      extern void GC_help_marker(word my_mark_no);\n@@ -1894,4 +1903,29 @@ void GC_err_puts GC_PROTO((GC_CONST char *s));\n \t\t/* some other reason.\t\t\t\t\t*/\n # endif /* PARALLEL_MARK */\n \n+# if defined(LINUX_THREADS) || defined(IRIX_THREADS) \\\n+     || defined(HPUX_THREADS) || defined(OSF1_THREADS)\n+  /* We define the thread suspension signal here, so that we can refer\t*/\n+  /* to it in the dirty bit implementation, if necessary.  Ideally we\t*/\n+  /* would allocate a (real-time ?) signal using the standard mechanism.*/\n+  /* unfortunately, there is no standard mechanism.  (There is one \t*/\n+  /* in Linux glibc, but it's not exported.)  Thus we continue to use\t*/\n+  /* the same hard-coded signals we've always used.\t\t\t*/\n+#  if !defined(SIG_SUSPEND)\n+#   if defined(LINUX_THREADS)\n+#    if defined(SPARC) && !defined(SIGPWR)\n+       /* SPARC/Linux doesn't properly define SIGPWR in <signal.h>.\n+        * It is aliased to SIGLOST in asm/signal.h, though.\t\t*/\n+#      define SIG_SUSPEND SIGLOST\n+#    else\n+       /* Linuxthreads uses SIGUSR1 and SIGUSR2.\t\t\t*/\n+#      define SIG_SUSPEND SIGPWR\n+#    endif\n+#   else  /* !LINUX_THREADS */\n+#    define SIG_SUSPEND _SIGRTMIN + 6\n+#   endif\n+#  endif /* !SIG_SUSPEND */\n+  \n+# endif\n+\n # endif /* GC_PRIVATE_H */"}, {"sha": "e8bac1bcdc29e648e191d79ae4ece6f97abab1c6", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -174,7 +174,7 @@\n #    define IA64\n #    define mach_type_known\n # endif\n-# if defined(LINUX) && defined(powerpc)\n+# if defined(LINUX) && (defined(powerpc) || defined(__powerpc__))\n #    define POWERPC\n #    define mach_type_known\n # endif\n@@ -350,6 +350,14 @@\n #    define S370\n #    define mach_type_known\n # endif\n+# if defined(__GNU__)\n+#   if defined(__i386__)\n+/* The Debian Hurd running on generic PC */  \n+#     define  HURD\n+#     define  I386\n+#     define  mach_type_known\n+#    endif \n+# endif\n \n /* Feel free to add more clauses here */\n \n@@ -497,6 +505,14 @@\n  * word stores of 0 are used instead.\n  */\n \n+/* If we are using a recent version of gcc, we can use __builtin_unwind_init()\n+ * to push the relevant registers onto the stack.  This generally makes\n+ * USE_GENERIC_PUSH_REGS the preferred approach for marking from registers.\n+ */\n+# if defined(__GNUC__) && ((__GNUC__ >= 3) || \\\n+\t\t\t   (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))\n+#   define HAVE_BUILTIN_UNWIND_INIT\n+# endif\n \n # define STACK_GRAN 0x1000000\n # ifdef M68K\n@@ -804,6 +820,9 @@\n #     define ALIGN_DOUBLE /* Not strictly necessary, but may give speed   */\n \t\t\t  /* improvement on Pentiums.\t\t\t  */\n #   endif\n+#   ifdef HAVE_BUILTIN_UNWIND_INIT\n+#\tdefine USE_GENERIC_PUSH_REGS\n+#   endif\n #   ifdef SEQUENT\n #\tdefine OS_TYPE \"SEQUENT\"\n \textern int etext;\n@@ -1023,6 +1042,17 @@\n #     define DATASTART ((ptr_t) &__nullarea)\n #     define DATAEND ((ptr_t) &_end)\n #   endif\n+#   ifdef HURD\n+#     define OS_TYPE \"HURD\"\n+#     define STACK_GROWS_DOWN\n+#     define HEURISTIC2\n+      extern int  __data_start;\n+#     define DATASTART ( (ptr_t) (&__data_start))\n+      extern int   _end;\n+#     define DATAEND ( (ptr_t) (&_end))\n+/* #     define MPROTECT_VDB  Not quite working yet? */\n+#     define DYNAMIC_LOADING\n+#   endif\n # endif\n \n # ifdef NS32K\n@@ -1039,16 +1069,16 @@\n \n # ifdef MIPS\n #   define MACH_TYPE \"MIPS\"\n-/* #   define STACKBOTTOM ((ptr_t)0x7fff8000)  sometimes also works.  */\n #   ifdef LINUX\n       /* This was developed for a linuxce style platform.  Probably\t*/\n       /* needs to be tweaked for workstation class machines.\t\t*/\n #     define OS_TYPE \"LINUX\"\n       extern int __data_start;\n #     define DATASTART ((ptr_t)(&__data_start))\n #     define ALIGNMENT 4\n-#     define USE_GENERIC_PUSH_REGS 1\n-#     define STACKBOTTOM 0x80000000\n+#     define USE_GENERIC_PUSH_REGS\n+#     define STACKBOTTOM ((ptr_t)0x7fff8000)\n+        /* Older toolchains may need 0x80000000.\t*/\n \t/* In many cases, this should probably use LINUX_STACKBOTTOM \t*/\n \t/* instead. But some kernel versions seem to give the wrong\t*/\n \t/* value from /proc.\t\t\t\t\t\t*/\n@@ -1106,7 +1136,7 @@\n #     define ALIGNMENT 4\n #     define OS_TYPE \"NETBSD\"\n #     define HEURISTIC2\n-#     define USE_GENERIC_PUSH_REGS 1\n+#     define USE_GENERIC_PUSH_REGS\n #     ifdef __ELF__\n         extern int etext;\n #       define DATASTART GC_data_start\n@@ -1587,6 +1617,12 @@\n # if defined(HPUX_THREADS) && !defined(HPUX)\n --> inconsistent configuration\n # endif\n+# if defined(WIN32_THREADS) && !defined(MSWIN32)\n+    /* Ideally CYGWIN32 should work, in addition to MSWIN32.  I suspect the necessary code\t*/\n+    /* is mostly there, but nobody has actually made sure the right combination of pieces is\t*/\n+    /* compiled in, etc.\t\t\t\t\t\t\t\t\t*/\n+--> inconsistent configuration\n+# endif\n # if defined(PCR) || defined(SRC_M3) || \\\n \tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n \tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\"}, {"sha": "12aba546ab98c38e273ed75d19c1a5fe0b34ba13", "filename": "boehm-gc/irix_threads.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Firix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Firix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Firix_threads.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -100,8 +100,8 @@ GC_thread GC_lookup_thread(pthread_t id);\n  * The only way to suspend threads given the pthread interface is to send\n  * signals.  Unfortunately, this means we have to reserve\n  * a signal, and intercept client calls to change the signal mask.\n+ * We use SIG_SUSPEND, defined in gc_priv.h.\n  */\n-# define SIG_SUSPEND (SIGRTMIN + 6)\n \n pthread_mutex_t GC_suspend_lock = PTHREAD_MUTEX_INITIALIZER;\n \t\t\t\t/* Number of threads stopped so far\t*/"}, {"sha": "8ab140b6b38234912ba7a13dfef086bf7d4d900b", "filename": "boehm-gc/linux_threads.c", "status": "modified", "additions": 127, "deletions": 77, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Flinux_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Flinux_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flinux_threads.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -55,6 +55,12 @@\n      || defined(GC_OSF1_THREADS) || defined(OSF1_THREADS) \\\n \n # include \"private/gc_priv.h\"\n+\n+# if defined(HPUX_THREADS) && !defined(USE_PTHREAD_SPECIFIC) \\\n+     && !defined(USE_HPUX_TLS)\n+#   define USE_HPUX_TLS\n+# endif\n+\n # ifdef THREAD_LOCAL_ALLOC\n #   if !defined(USE_PTHREAD_SPECIFIC) && !defined(USE_HPUX_TLS)\n #     include \"private/specific.h\"\n@@ -161,15 +167,16 @@ typedef struct GC_Thread_Rep {\n #   ifdef THREAD_LOCAL_ALLOC\n #\tif CPP_WORDSZ == 64 && defined(ALIGN_DOUBLE)\n #\t    define GRANULARITY 16\n-#\t    define NFREELISTS 48\n+#\t    define NFREELISTS 49\n #\telse\n #\t    define GRANULARITY 8\n-#\t    define NFREELISTS 64\n+#\t    define NFREELISTS 65\n #\tendif\n-\t/* The ith free list corresponds to size (i+1)*GRANULARITY */\n-#\tdefine INDEX_FROM_BYTES(n) (ADD_SLOP(n) - 1)/GRANULARITY\n-#\tdefine BYTES_FROM_INDEX(i) (((i) + 1) * GRANULARITY - EXTRA_BYTES)\n-#\tdefine SMALL_ENOUGH(bytes) (ADD_SLOP(bytes) <= NFREELISTS*GRANULARITY)\n+\t/* The ith free list corresponds to size i*GRANULARITY */\n+#\tdefine INDEX_FROM_BYTES(n) ((ADD_SLOP(n) + GRANULARITY - 1)/GRANULARITY)\n+#\tdefine BYTES_FROM_INDEX(i) ((i) * GRANULARITY - EXTRA_BYTES)\n+#\tdefine SMALL_ENOUGH(bytes) (ADD_SLOP(bytes) <= \\\n+\t\t\t\t    (NFREELISTS-1)*GRANULARITY)\n \tptr_t ptrfree_freelists[NFREELISTS];\n \tptr_t normal_freelists[NFREELISTS];\n #\tifdef GC_GCJ_SUPPORT\n@@ -194,12 +201,12 @@ typedef struct GC_Thread_Rep {\n \n GC_thread GC_lookup_thread(pthread_t id);\n \n-static GC_bool fully_initialized = FALSE;\n+static GC_bool parallel_initialized = FALSE;\n \n # if defined(__GNUC__)\n-    void GC_full_init() __attribute__ ((constructor));\n+    void GC_init_parallel() __attribute__ ((constructor));\n # else\n-    void GC_full_init();\n+    void GC_init_parallel();\n # endif\n \n # if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n@@ -223,8 +230,8 @@ static void return_freelists(ptr_t *fl, ptr_t *gfl)\n     ptr_t q, *qptr;\n     size_t nwords;\n \n-    for (i = 0; i < NFREELISTS; ++i) {\n-\tnwords = (i + 1) * (GRANULARITY/sizeof(word));\n+    for (i = 1; i < NFREELISTS; ++i) {\n+\tnwords = i * (GRANULARITY/sizeof(word));\n         qptr = fl + i;\t\n \tq = *qptr;\n \tif ((word)q < HBLKSIZE) continue;\n@@ -243,6 +250,12 @@ static void return_freelists(ptr_t *fl, ptr_t *gfl)\n     }\n }\n \n+/* We statically allocate a single \"size 0\" object. It is linked to\t*/\n+/* itself, and is thus repeatedly reused for all size 0 allocation\t*/\n+/* requests.  (Size 0 gcj allocation requests are incorrect, and\t*/\n+/* we arrange for those to fault asap.)\t\t\t\t\t*/\n+static ptr_t size_zero_object = (ptr_t)(&size_zero_object);\n+\n /* Each thread structure must be initialized.\t*/\n /* This call must be made from the new thread.\t*/\n /* Caller holds allocation lock.\t\t*/\n@@ -259,13 +272,19 @@ void GC_init_thread_local(GC_thread p)\n     if (0 != GC_setspecific(GC_thread_key, p)) {\n \tABORT(\"Failed to set thread specific allocation pointers\");\n     }\n-    for (i = 0; i < NFREELISTS; ++i) {\n+    for (i = 1; i < NFREELISTS; ++i) {\n \tp -> ptrfree_freelists[i] = (ptr_t)1;\n \tp -> normal_freelists[i] = (ptr_t)1;\n #\tifdef GC_GCJ_SUPPORT\n \t  p -> gcj_freelists[i] = (ptr_t)1;\n #\tendif\n     }   \n+    /* Set up the size 0 free lists.\t*/\n+    p -> ptrfree_freelists[0] = (ptr_t)(&size_zero_object);\n+    p -> normal_freelists[0] = (ptr_t)(&size_zero_object);\n+#   ifdef GC_GCJ_SUPPORT\n+        p -> gcj_freelists[0] = (ptr_t)(-1);\n+#   endif\n }\n \n #ifdef GC_GCJ_SUPPORT\n@@ -303,7 +322,7 @@ GC_PTR GC_local_malloc(size_t bytes)\n \t\t/* This can happen if we get called when the world is\t*/\n \t\t/* being initialized.  Whether we can actually complete\t*/\n \t\t/* the initialization then is unclear.\t\t\t*/\n-\t\tGC_full_init();\n+\t\tGC_init_parallel();\n \t\tk = GC_thread_key;\n \t    }\n #\tendif\n@@ -326,10 +345,8 @@ GC_PTR GC_local_malloc(size_t bytes)\n \t    *my_fl = my_entry + index + 1;\n             return GC_malloc(bytes);\n \t} else {\n-\t    my_entry = GC_generic_malloc_many(BYTES_FROM_INDEX(index),\n-\t\t\t\t\t      NORMAL);\n-\t    *my_fl = my_entry;\n-\t    if (my_entry == 0) return GC_oom_fn(bytes);\n+\t    GC_generic_malloc_many(BYTES_FROM_INDEX(index), NORMAL, my_fl);\n+\t    if (*my_fl == 0) return GC_oom_fn(bytes);\n \t    return GC_local_malloc(bytes);\n \t}\n     }\n@@ -352,10 +369,11 @@ GC_PTR GC_local_malloc_atomic(size_t bytes)\n \t    *my_fl = my_entry + index + 1;\n             return GC_malloc_atomic(bytes);\n \t} else {\n-\t    my_entry = GC_generic_malloc_many(BYTES_FROM_INDEX(index),\n-\t\t\t\t\t      PTRFREE);\n-\t    *my_fl = my_entry;\n-\t    if (my_entry == 0) return GC_oom_fn(bytes);\n+\t    GC_generic_malloc_many(BYTES_FROM_INDEX(index), PTRFREE, my_fl);\n+\t    /* *my_fl is updated while the collector is excluded;\t*/\n+\t    /* the free list is always visible to the collector as \t*/\n+\t    /* such.\t\t\t\t\t\t\t*/\n+\t    if (*my_fl == 0) return GC_oom_fn(bytes);\n \t    return GC_local_malloc_atomic(bytes);\n \t}\n     }\n@@ -390,18 +408,22 @@ GC_PTR GC_local_gcj_malloc(size_t bytes,\n \t    /* allocation of the next object, but to see this object \t*/\n \t    /* still containing a free list pointer.  Otherwise the \t*/\n \t    /* marker might find a random \"mark descriptor\".\t\t*/\n-\t    *my_fl = obj_link(my_entry);\n-\t    *(void **)result = ptr_to_struct_containing_descr; \n+\t    *(volatile ptr_t *)my_fl = obj_link(my_entry);\n+\t    /* We must update the freelist before we store the pointer.\t*/\n+\t    /* Otherwise a GC at this point would see a corrupted\t*/\n+\t    /* free list.\t\t\t\t\t\t*/\n+\t    /* A memory barrier is probably never needed, since the \t*/\n+\t    /* action of stopping this thread will cause prior writes\t*/\n+\t    /* to complete.\t\t\t\t\t\t*/\n+\t    *(void * volatile *)result = ptr_to_struct_containing_descr; \n \t    return result;\n \t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n \t    *my_fl = my_entry + index + 1;\n             return GC_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n \t} else {\n-\t    my_entry = GC_generic_malloc_many(BYTES_FROM_INDEX(index),\n-\t\t\t\t\t      GC_gcj_kind);\n-\t    *my_fl = my_entry;\n-\t    if (my_entry == 0) return GC_oom_fn(bytes);\n-\t    return GC_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n+\t    GC_generic_malloc_many(BYTES_FROM_INDEX(index), GC_gcj_kind, my_fl);\n+\t    if (*my_fl == 0) return GC_oom_fn(bytes);\n+\t    return GC_local_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n \t}\n     }\n }\n@@ -415,22 +437,16 @@ GC_PTR GC_local_gcj_malloc(size_t bytes,\n # endif /* !THREAD_LOCAL_ALLOC */\n \n /*\n- * The only way to suspend threads given the pthread interface is to send\n- * signals.  We can't use SIGSTOP directly, because we need to get the\n- * thread to save its stack pointer in the GC thread table before\n- * suspending.  So we have to reserve a signal of our own for this.\n- * This means we have to intercept client calls to change the signal mask.\n- * The linuxthreads package already uses SIGUSR1 and SIGUSR2,\n- * so we need to reuse something else.  I chose SIGPWR.\n- * (Perhaps SIGUNUSED would be a better choice.)\n+ * We use signals to stop threads during GC.\n+ * \n+ * Suspended threads wait in signal handler for SIG_THR_RESTART.\n+ * That's more portable than semaphores or condition variables.\n+ * (We do use sem_post from a signal handler, but that should be portable.)\n+ *\n+ * The thread suspension signal SIG_SUSPEND is now defined in gc_priv.h.\n+ * Note that we can't just stop a thread; we need it to save its stack\n+ * pointer(s) and acknowledge.\n  */\n-#ifndef SIG_SUSPEND\n-#  if defined(HPUX_THREADS) || defined(GC_OSF1_THREADS)\n-#   define SIG_SUSPEND _SIGRTMIN + 6\n-#  else\n-#   define SIG_SUSPEND SIGPWR\n-#  endif\n-#endif\n \n #ifndef SIG_THR_RESTART\n #  if defined(HPUX_THREADS) || defined(GC_OSF1_THREADS)\n@@ -440,12 +456,6 @@ GC_PTR GC_local_gcj_malloc(size_t bytes,\n #  endif\n #endif\n \n-/* SPARC/Linux doesn't properly define SIGPWR in <signal.h>.\n- * It is aliased to SIGLOST in asm/signal.h, though.\t\t*/\n-#if defined(SPARC) && !defined(SIGPWR)\n-#   define SIGPWR SIGLOST\n-#endif\n-\n sem_t GC_suspend_ack_sem;\n \n #if !defined(HPUX_THREADS) && !defined(GC_OSF1_THREADS)\n@@ -654,6 +664,34 @@ void GC_push_thread_structures GC_PROTO((void))\n     GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));\n }\n \n+#ifdef THREAD_LOCAL_ALLOC\n+/* We must explicitly mark ptrfree and gcj free lists, since the free \t*/\n+/* list links wouldn't otherwise be found.  We also set them in the \t*/\n+/* normal free lists, since that involves touching less memory than if\t*/\n+/* we scanned them normally.\t\t\t\t\t\t*/\n+void GC_mark_thread_local_free_lists(void)\n+{\n+    int i, j;\n+    GC_thread p;\n+    ptr_t q;\n+    \n+    for (i = 0; i < THREAD_TABLE_SZ; ++i) {\n+      for (p = GC_threads[i]; 0 != p; p = p -> next) {\n+\tfor (j = 1; j < NFREELISTS; ++j) {\n+\t  q = p -> ptrfree_freelists[j];\n+\t  if ((word)q > HBLKSIZE) GC_set_fl_marks(q);\n+\t  q = p -> normal_freelists[j];\n+\t  if ((word)q > HBLKSIZE) GC_set_fl_marks(q);\n+#\t  ifdef GC_GCJ_SUPPORT\n+\t    q = p -> gcj_freelists[j];\n+\t    if ((word)q > HBLKSIZE) GC_set_fl_marks(q);\n+#\t  endif /* GC_GCJ_SUPPORT */\n+\t}\n+      }\n+    }\n+}\n+#endif /* THREAD_LOCAL_ALLOC */\n+\n /* Add a thread to GC_threads.  We assume it wasn't already there.\t*/\n /* Caller holds allocation lock.\t\t\t\t\t*/\n GC_thread GC_new_thread(pthread_t id)\n@@ -752,7 +790,6 @@ void GC_stop_world()\n \n     GC_stopping_thread = my_thread;    /* debugging only.      */\n     GC_stopping_pid = getpid();                /* debugging only.      */\n-\n     /* Make sure all free list construction has stopped before we start. */\n     /* No new construction can start, since free list construction is\t*/\n     /* required to acquire and release the GC lock before it starts,\t*/\n@@ -795,6 +832,7 @@ void GC_stop_world()\n     #if DEBUG_THREADS\n       GC_printf1(\"World stopped 0x%x\\n\", pthread_self());\n     #endif\n+    GC_stopping_thread = 0;  /* debugging only */\n }\n \n /* Caller holds allocation lock, and has held it continuously since\t*/\n@@ -1072,9 +1110,12 @@ void GC_thr_init()\n /* may require allocation.\t\t\t\t*/\n /* Called as constructor without allocation lock.\t*/\n /* Must be called before a second thread is created.\t*/\n-void GC_full_init()\n+/* Called without allocation lock.\t\t\t*/\n+void GC_init_parallel()\n {\n-    if (fully_initialized) return;\n+    if (parallel_initialized) return;\n+    parallel_initialized = TRUE;\n+    \t/* GC_init() calls us back, so set flag first.\t*/\n     if (!GC_is_initialized) GC_init();\n     /* If we are using a parallel marker, start the helper threads.  */\n #     ifdef PARALLEL_MARK\n@@ -1086,7 +1127,6 @@ void GC_full_init()\n       GC_init_thread_local(GC_lookup_thread(pthread_self()));\n       UNLOCK();\n #   endif\n-    fully_initialized = TRUE;\n }\n \n \n@@ -1327,7 +1367,7 @@ WRAP_FUNC(pthread_create)(pthread_t *new_thread,\n     LOCK();\n     si = (struct start_info *)GC_INTERNAL_MALLOC(sizeof(struct start_info), NORMAL);\n     UNLOCK();\n-    if (!fully_initialized) GC_full_init();\n+    if (!parallel_initialized) GC_init_parallel();\n     if (0 == si) return(ENOMEM);\n     sem_init(&(si -> registered), 0, 0);\n     si -> start_routine = start_routine;\n@@ -1539,7 +1579,7 @@ void GC_lock()\n \n #endif /* !USE_SPINLOCK */\n \n-#ifdef PARALLEL_MARK\n+#if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n \n #ifdef GC_ASSERTIONS\n   pthread_t GC_mark_lock_holder = NO_THREAD;\n@@ -1559,8 +1599,6 @@ void GC_lock()\n   static pthread_mutex_t mark_mutex = PTHREAD_MUTEX_INITIALIZER;\n #endif\n \n-static pthread_cond_t mark_cv = PTHREAD_COND_INITIALIZER;\n-\n static pthread_cond_t builder_cv = PTHREAD_COND_INITIALIZER;\n \n void GC_acquire_mark_lock()\n@@ -1587,13 +1625,18 @@ void GC_release_mark_lock()\n     }\n }\n \n-void GC_wait_marker()\n+/* Collector must wait for a freelist builders for 2 reasons:\t\t*/\n+/* 1) Mark bits may still be getting examined without lock.\t\t*/\n+/* 2) Partial free lists referenced only by locals may not be scanned \t*/\n+/*    correctly, e.g. if they contain \"pointer-free\" objects, since the\t*/\n+/*    free-list link may be ignored.\t\t\t\t\t*/\n+void GC_wait_builder()\n {\n     GC_ASSERT(GC_mark_lock_holder == pthread_self());\n #   ifdef GC_ASSERTIONS\n \tGC_mark_lock_holder = NO_THREAD;\n #   endif\n-    if (pthread_cond_wait(&mark_cv, &mark_mutex) != 0) {\n+    if (pthread_cond_wait(&builder_cv, &mark_mutex) != 0) {\n \tABORT(\"pthread_cond_wait failed\");\n     }\n     GC_ASSERT(GC_mark_lock_holder == NO_THREAD);\n@@ -1602,13 +1645,36 @@ void GC_wait_marker()\n #   endif\n }\n \n-void GC_wait_builder()\n+void GC_wait_for_reclaim()\n+{\n+    GC_acquire_mark_lock();\n+    while (GC_fl_builder_count > 0) {\n+\tGC_wait_builder();\n+    }\n+    GC_release_mark_lock();\n+}\n+\n+void GC_notify_all_builder()\n+{\n+    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n+    if (pthread_cond_broadcast(&builder_cv) != 0) {\n+\tABORT(\"pthread_cond_broadcast failed\");\n+    }\n+}\n+\n+#endif /* PARALLEL_MARK || THREAD_LOCAL_ALLOC */\n+\n+#ifdef PARALLEL_MARK\n+\n+static pthread_cond_t mark_cv = PTHREAD_COND_INITIALIZER;\n+\n+void GC_wait_marker()\n {\n     GC_ASSERT(GC_mark_lock_holder == pthread_self());\n #   ifdef GC_ASSERTIONS\n \tGC_mark_lock_holder = NO_THREAD;\n #   endif\n-    if (pthread_cond_wait(&builder_cv, &mark_mutex) != 0) {\n+    if (pthread_cond_wait(&mark_cv, &mark_mutex) != 0) {\n \tABORT(\"pthread_cond_wait failed\");\n     }\n     GC_ASSERT(GC_mark_lock_holder == NO_THREAD);\n@@ -1624,22 +1690,6 @@ void GC_notify_all_marker()\n     }\n }\n \n-void GC_notify_all_builder()\n-{\n-    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n-    if (pthread_cond_broadcast(&builder_cv) != 0) {\n-\tABORT(\"pthread_cond_broadcast failed\");\n-    }\n-}\n-\n-void GC_wait_for_reclaim()\n-{\n-    GC_acquire_mark_lock();\n-    while (GC_fl_builder_count > 0) {\n-\tGC_wait_builder();\n-    }\n-    GC_release_mark_lock();\n-}\n #endif /* PARALLEL_MARK */\n \n # endif /* LINUX_THREADS */"}, {"sha": "776bf6909bc187c5af4716d30792210c56f2c2f5", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -228,7 +228,7 @@ void GC_push_regs()\n \t&& !(defined(NETBSD) && defined(__ELF__)) \\\n \t&& !(defined(OPENBSD) && defined(__ELF__)) \\\n \t&& !(defined(BEOS) && defined(__ELF__)) \\\n-\t&& !defined(DOS4GW)\n+\t&& !defined(DOS4GW) && !defined(HURD)\n \t/* I386 code, generic code does not appear to work */\n \t/* It does appear to work under OS2, and asms dont */\n \t/* This is used for some 38g UNIX variants and for CYGWIN32 */\n@@ -244,7 +244,8 @@ void GC_push_regs()\n #\tif ( defined(I386) && defined(LINUX) && defined(__ELF__) ) \\\n \t|| ( defined(I386) && defined(FREEBSD) && defined(__ELF__) ) \\\n \t|| ( defined(I386) && defined(NETBSD) && defined(__ELF__) ) \\\n-\t|| ( defined(I386) && defined(OPENBSD) && defined(__ELF__) )\n+\t|| ( defined(I386) && defined(OPENBSD) && defined(__ELF__) ) \\\n+\t|| ( defined(I386) && defined(HURD) && defined(__ELF__) )\n \n \t/* This is modified for Linux with ELF (Note: _ELF_ only) */\n \t/* This section handles FreeBSD with ELF. */\n@@ -391,8 +392,8 @@ void GC_push_regs()\n #     endif\n \n       /* other machines... */\n-#       if !(defined M68K) && !(defined VAX) && !(defined RT) \n-#\tif !(defined SPARC) && !(defined I386) && !(defined NS32K)\n+#       if !defined(M68K) && !defined(VAX) && !defined(RT) \n+#\tif !defined(SPARC) && !defined(I386) && !defined(NS32K)\n #\tif !defined(POWERPC) && !defined(UTS4) \n #       if !defined(PJ) && !(defined(MIPS) && defined(LINUX))\n \t    --> bad news <--\n@@ -407,27 +408,35 @@ void GC_push_regs()\n void GC_generic_push_regs(cold_gc_frame)\n ptr_t cold_gc_frame;\n {\n-\t/* Generic code                          */\n-\t/* The idea is due to Parag Patel at HP. */\n-\t/* We're not sure whether he would like  */\n-\t/* to be he acknowledged for it or not.  */\n \t{\n-\t    static jmp_buf regs;\n-\t    register word * i = (word *) regs;\n-\t    register ptr_t lim = (ptr_t)(regs) + (sizeof regs);\n-\n-\t    /* Setjmp on Sun 3s doesn't clear all of the buffer.  */\n-\t    /* That tends to preserve garbage.  Clear it.         */\n+#\t    ifdef HAVE_BUILTIN_UNWIND_INIT\n+\t      /* This was suggested by Richard Henderson as the way to\t*/\n+\t      /* force callee-save registers and register windows onto\t*/\n+\t      /* the stack.\t\t\t\t\t\t*/\n+\t      __builtin_unwind_init();\n+#\t    else /* !HAVE_BUILTIN_UNWIND_INIT */\n+\t      /* Generic code                          */\n+\t      /* The idea is due to Parag Patel at HP. */\n+\t      /* We're not sure whether he would like  */\n+\t      /* to be he acknowledged for it or not.  */\n+\t      jmp_buf regs;\n+\t      register word * i = (word *) regs;\n+\t      register ptr_t lim = (ptr_t)(regs) + (sizeof regs);\n+\n+\t      /* Setjmp doesn't always clear all of the buffer.\t\t*/\n+\t      /* That tends to preserve garbage.  Clear it.   \t\t*/\n \t\tfor (; (char *)i < lim; i++) {\n \t\t    *i = 0;\n \t\t}\n-#\t    if defined(POWERPC) || defined(MSWIN32) || defined(MSWINCE) \\\n-\t       || defined(UTS4) || defined(LINUX)\n-\t\t(void) setjmp(regs);\n-#\t    else\n-\t        (void) _setjmp(regs);\n-#\t    endif\n-#           if defined(SPARC) || defined(IA64)\n+#\t      if defined(POWERPC) || defined(MSWIN32) || defined(MSWINCE) \\\n+\t         || defined(UTS4) || defined(LINUX)\n+\t\t  (void) setjmp(regs);\n+#\t      else\n+\t          (void) _setjmp(regs);\n+#\t      endif\n+#\t    endif /* !HAVE_BUILTIN_UNWIND_INIT */\n+#           if (defined(SPARC) && !defined(HAVE_BUILTIN_UNWIND_INIT)) \\\n+\t\t|| defined(IA64)\n \t      /* On a register window machine, we need to save register\t*/\n \t      /* contents on the stack for this to work.  The setjmp\t*/\n \t      /* is probably not needed on SPARC, since pointers are\t*/\n@@ -438,6 +447,10 @@ ptr_t cold_gc_frame;\n \t        word GC_save_regs_in_stack();\n \t      \n \t        GC_save_regs_ret_val = GC_save_regs_in_stack();\n+\t\t/* On IA64 gcc, could use __builtin_ia64_flushrs() and\t*/\n+\t\t/* __builtin_ia64_flushrs().  The latter will be done\t*/\n+\t\t/* implicitly by __builtin_unwind_init() for gcc3.0.1\t*/\n+\t\t/* and later.\t\t\t\t\t\t*/\n \t      }\n #           endif\n \t    GC_push_current_stack(cold_gc_frame);\n@@ -511,7 +524,7 @@ ptr_t cold_gc_frame;\n /* returns arg.  Stack clearing is crucial on SPARC, so we supply\t*/\n /* an assembly version that's more careful.  Assumes limit is hotter\t*/\n /* than sp, and limit is 8 byte aligned.\t\t\t\t*/\n-#if defined(ASM_CLEAR_CODE) && !defined(THREADS)\n+#if defined(ASM_CLEAR_CODE)\n #ifndef SPARC\n \t--> fix it\n #endif"}, {"sha": "031fcaf91a8347890fedb2618cd26b2121920e28", "filename": "boehm-gc/mallocx.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmallocx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmallocx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmallocx.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -323,10 +323,15 @@ extern ptr_t GC_reclaim_generic();\n /* GC_malloc_many or friends to replenish it.  (We do not round up\t*/\n /* object sizes, since a call indicates the intention to consume many\t*/\n /* objects of exactly this size.)\t\t\t\t\t*/\n+/* We return the free-list by assigning it to *result, since it is\t*/\n+/* not safe to return, e.g. a linked list of pointer-free objects,\t*/\n+/* since the collector would not retain the entire list if it were \t*/\n+/* invoked just as we were returning.\t\t\t\t\t*/\n /* Note that the client should usually clear the link field.\t\t*/\n-ptr_t GC_generic_malloc_many(lb, k)\n+void GC_generic_malloc_many(lb, k, result)\n register word lb;\n register int k;\n+ptr_t *result;\n {\n ptr_t op;\n ptr_t p;\n@@ -345,13 +350,20 @@ DCL_LOCK_STATE;\n     if (!SMALL_OBJ(lb)) {\n         op = GC_generic_malloc(lb, k);\n         if(0 != op) obj_link(op) = 0;\n-        return(op);\n+\t*result = op;\n+        return;\n     }\n     lw = ALIGNED_WORDS(lb);\n     GC_INVOKE_FINALIZERS();\n     DISABLE_SIGNALS();\n     LOCK();\n     if (!GC_is_initialized) GC_init_inner();\n+    /* Do our share of marking work */\n+      if (GC_incremental && !GC_dont_gc) {\n+        ENTER_GC();\n+\tGC_collect_a_little_inner(1);\n+        EXIT_GC();\n+      }\n     /* First see if we can reclaim a page of objects waiting to be */\n     /* reclaimed.\t\t\t\t\t\t   */\n     {\n@@ -403,14 +415,16 @@ DCL_LOCK_STATE;\n \t\tGC_mem_found += my_words_allocd;\n #\t      endif\n #\t      ifdef PARALLEL_MARK\n+\t\t*result = op;\n \t\t(void)GC_atomic_add(\n \t\t\t\t(volatile GC_word *)(&GC_words_allocd_tmp),\n \t\t\t\t(GC_word)(my_words_allocd));\n \t\tGC_acquire_mark_lock();\n \t\t-- GC_fl_builder_count;\n \t\tif (GC_fl_builder_count == 0) GC_notify_all_builder();\n \t\tGC_release_mark_lock();\n-\t\treturn GC_clear_stack(op);\n+\t\t(void) GC_clear_stack(0);\n+\t\treturn;\n #\t      else\n \t        GC_words_allocd += my_words_allocd;\n \t        goto out;\n@@ -464,11 +478,13 @@ DCL_LOCK_STATE;\n \n \t  op = GC_build_fl(h, lw, ok -> ok_init, 0);\n #\t  ifdef PARALLEL_MARK\n+\t    *result = op;\n \t    GC_acquire_mark_lock();\n \t    -- GC_fl_builder_count;\n \t    if (GC_fl_builder_count == 0) GC_notify_all_builder();\n \t    GC_release_mark_lock();\n-\t    return GC_clear_stack(op);\n+\t    (void) GC_clear_stack(0);\n+\t    return;\n #\t  else\n \t    goto out;\n #\t  endif\n@@ -481,14 +497,17 @@ DCL_LOCK_STATE;\n       if (0 != op) obj_link(op) = 0;\n     \n   out:\n+    *result = op;\n     UNLOCK();\n     ENABLE_SIGNALS();\n-    return(GC_clear_stack(op));\n+    (void) GC_clear_stack(0);\n }\n \n GC_PTR GC_malloc_many(size_t lb)\n {\n-    return(GC_generic_malloc_many(lb, NORMAL));\n+    ptr_t result;\n+    GC_generic_malloc_many(lb, NORMAL, &result);\n+    return result;\n }\n \n /* Note that the \"atomic\" version of this would be unsafe, since the\t*/"}, {"sha": "4d7504799d4471cf5f63f9ef37b709f09ba3bbf7", "filename": "boehm-gc/mark.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -427,21 +427,22 @@ GC_bool GC_mark_stack_empty()\n #endif\n \n /* Given a pointer to someplace other than a small object page or the\t*/\n-/* first page of a large object, return a pointer either to the\t\t*/\n-/* start of the large object or NIL.\t\t\t\t\t*/\n-/* In the latter case black list the address current.\t\t\t*/\n-/* Returns NIL without black listing if current points to a block\t*/\n-/* with IGNORE_OFF_PAGE set.\t\t\t\t\t\t*/\n+/* first page of a large object, either:\t\t\t\t*/\n+/*\t- return a pointer to somewhere in the first page of the large\t*/\n+/*\t  object, if current points to a large object.\t\t\t*/\n+/*\t  In this case *hhdr is replaced with a pointer to the header\t*/\n+/*\t  for the large object.\t\t\t\t\t\t*/\n+/*\t- just return current if it does not point to a large object.\t*/\n /*ARGSUSED*/\n # ifdef PRINT_BLACK_LIST\n-  ptr_t GC_find_start(current, hhdr, source)\n-  word source;\n+  ptr_t GC_find_start(current, hhdr, new_hdr_p, source)\n+  ptr_t source;\n # else\n-  ptr_t GC_find_start(current, hhdr)\n+  ptr_t GC_find_start(current, hhdr, new_hdr_p)\n # define source 0\n # endif\n register ptr_t current;\n-register hdr * hhdr;\n+register hdr *hhdr, **new_hdr_p;\n {\n     if (GC_all_interior_pointers) {\n \tif (hhdr != 0) {\n@@ -457,17 +458,15 @@ register hdr * hhdr;\n \t    if ((word *)orig - (word *)current\n \t         >= (ptrdiff_t)(hhdr->hb_sz)) {\n \t        /* Pointer past the end of the block */\n-\t        GC_ADD_TO_BLACK_LIST_NORMAL((word)orig, source);\n-\t        return(0);\n+\t        return(orig);\n \t    }\n+\t    *new_hdr_p = hhdr;\n \t    return(current);\n \t} else {\n-\t    GC_ADD_TO_BLACK_LIST_NORMAL((word)current, source);\n-\t    return(0);\n+\t    return(current);\n         }\n     } else {\n-        GC_ADD_TO_BLACK_LIST_NORMAL((word)current, source);\n-        return(0);\n+        return(current);\n     }\n #   undef source\n }"}, {"sha": "251a0d1458f613539ffe6a1fe5a3c5cddbfa8ade", "filename": "boehm-gc/mark_rts.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -471,8 +471,9 @@ ptr_t cold_gc_frame;\n \t          cold_gc_bs_pointer = bsp - 2048;\n \t\t  if (cold_gc_bs_pointer < BACKING_STORE_BASE) {\n \t\t    cold_gc_bs_pointer = BACKING_STORE_BASE;\n+\t\t  } else {\n+\t\t    GC_push_all_stack(BACKING_STORE_BASE, cold_gc_bs_pointer);\n \t\t  }\n-\t\t  GC_push_all_stack(BACKING_STORE_BASE, cold_gc_bs_pointer);\n \t\t} else {\n \t\t  cold_gc_bs_pointer = BACKING_STORE_BASE;\n \t\t}\n@@ -501,6 +502,10 @@ void GC_push_gc_structures GC_PROTO((void))\n #   endif\n }\n \n+#ifdef THREAD_LOCAL_ALLOC\n+  void GC_mark_thread_local_free_lists();\n+#endif\n+\n /*\n  * Call the mark routines (GC_tl_push for a single pointer, GC_push_conditional\n  * on groups of pointers) on every top level accessible pointer.\n@@ -552,6 +557,12 @@ ptr_t cold_gc_frame;\n \t   GC_push_gc_structures();\n        }\n \n+     /* Mark thread local free lists, even if their mark \t*/\n+     /* descriptor excludes the link field.\t\t\t*/\n+#      ifdef THREAD_LOCAL_ALLOC\n+         GC_mark_thread_local_free_lists();\n+#      endif\n+\n     /*\n      * Now traverse stacks.\n      */"}, {"sha": "94ef15d3c3f276babc5af626221a1c8f58d2a9b2", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -45,7 +45,7 @@\n \t  mutex_t GC_allocate_ml;\t/* Implicitly initialized.\t*/\n #\telse\n #          ifdef WIN32_THREADS\n-#\t      if defined(_DLL) || defined(GC_DLL)\n+#\t      if !defined(GC_NOT_DLL) && (defined(_DLL) || defined(GC_DLL))\n \t\t __declspec(dllexport) CRITICAL_SECTION GC_allocate_ml;\n #\t      else\n \t\t CRITICAL_SECTION GC_allocate_ml;\n@@ -301,6 +301,8 @@ ptr_t arg;\n     if (++random_no % 13 == 0) {\n \tlimit = sp;\n \tMAKE_HOTTER(limit, BIG_CLEAR_SIZE*sizeof(word));\n+        limit &= ~0xf;\t/* Make it sufficiently aligned for assembly\t*/\n+        \t\t/* implementations of GC_clear_stack_inner.\t*/\n \treturn GC_clear_stack_inner(arg, limit);\n     } else {\n \tBZERO(dummy, SMALL_CLEAR_SIZE*sizeof(word));\n@@ -441,6 +443,15 @@ void GC_init()\n     UNLOCK();\n     ENABLE_SIGNALS();\n \n+#   if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n+\t/* Make sure marker threads and started and thread local */\n+\t/* allocation is initialized, in case we didn't get \t */\n+\t/* called from GC_init_parallel();\t\t\t */\n+        {\n+\t  extern void GC_init_parallel(void);\n+\t  GC_init_parallel();\n+\t}\n+#   endif /* PARALLEL_MARK || THREAD_LOCAL_ALLOC */\n }\n \n #if defined(MSWIN32) || defined(MSWINCE)\n@@ -682,7 +693,7 @@ void GC_enable_incremental GC_PROTO(())\n   }\n \n   int GC_write(buf, len)\n-  char * buf;\n+  GC_CONST char * buf;\n   size_t len;\n   {\n       BOOL tmp;\n@@ -735,7 +746,7 @@ int GC_tmp;  /* Should really be local ... */\n #if !defined(MSWIN32) && !defined(MSWINCE) && !defined(OS2) && !defined(MACOS)\n int GC_write(fd, buf, len)\n int fd;\n-char *buf;\n+GC_CONST char *buf;\n size_t len;\n {\n      register int bytes_written = 0;\n@@ -867,7 +878,7 @@ GC_CONST char * msg;\n \t    /* It's arguably nicer to sleep, but that makes it harder\t*/\n \t    /* to look at the thread if the debugger doesn't know much\t*/\n \t    /* about threads.\t\t\t\t\t\t*/\n-\t    for(;;);\n+\t    for(;;) {}\n     }\n #   ifdef MSWIN32\n \tDebugBreak();"}, {"sha": "71fc3b68e209712ed16e6402d0503bdf743db58f", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 83, "deletions": 39, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -63,25 +63,24 @@\n /* Blatantly OS dependent routines, except for those that are related \t*/\n /* to dynamic loading.\t\t\t\t\t\t\t*/\n \n-# if !defined(THREADS) && !defined(STACKBOTTOM) && defined(HEURISTIC2)\n+# if defined(HEURISTIC2) || defined(SEARCH_FOR_DATA_START)\n #   define NEED_FIND_LIMIT\n # endif\n \n-# if defined(IRIX_THREADS) || defined(HPUX_THREADS)\n+# if !defined(STACKBOTTOM) && defined(HEURISTIC2)\n #   define NEED_FIND_LIMIT\n # endif\n \n-# if (defined(SUNOS4) && defined(DYNAMIC_LOADING)) && !defined(PCR)\n+# if defined(IRIX_THREADS) || defined(HPUX_THREADS)\n #   define NEED_FIND_LIMIT\n # endif\n \n-# if (defined(SVR4) || defined(AUX) || defined(DGUX)) && !defined(PCR)\n+# if (defined(SUNOS4) && defined(DYNAMIC_LOADING)) && !defined(PCR)\n #   define NEED_FIND_LIMIT\n # endif\n \n-# if defined(LINUX) && \\\n-     (defined(POWERPC) || defined(SPARC) || defined(ALPHA) || defined(IA64) \\\n-      || defined(MIPS))\n+# if (defined(SVR4) || defined(AUX) || defined(DGUX) \\\n+      || (defined(LINUX) && defined(SPARC))) && !defined(PCR)\n #   define NEED_FIND_LIMIT\n # endif\n \n@@ -123,8 +122,10 @@\n # include <fcntl.h>\n #endif\n \n-#ifdef SUNOS5SIGS\n-# include <sys/siginfo.h>\n+#if defined(SUNOS5SIGS) || defined (HURD) || defined(LINUX)\n+# ifdef SUNOS5SIGS\n+#  include <sys/siginfo.h>\n+# endif\n # undef setjmp\n # undef longjmp\n # define setjmp(env) sigsetjmp(env, 1)\n@@ -338,7 +339,7 @@ void GC_enable_signals(void)\n       && !defined(MSWINCE) \\\n       && !defined(MACOS) && !defined(DJGPP) && !defined(DOS4GW)\n \n-#   if defined(sigmask) && !defined(UTS4)\n+#   if defined(sigmask) && !defined(UTS4) && !defined(HURD)\n \t/* Use the traditional BSD interface */\n #\tdefine SIGSET_T int\n #\tdefine SIG_DEL(set, signal) (set) &= ~(sigmask(signal))\n@@ -519,17 +520,17 @@ ptr_t GC_get_stack_base()\n #   undef GC_AMIGA_SB\n # endif /* AMIGA */\n \n-# if defined(NEED_FIND_LIMIT) || defined(UNIX_LIKE)\n+# if defined(NEED_FIND_LIMIT) || (defined(UNIX_LIKE) && !defined(ECOS))\n \n #   ifdef __STDC__\n \ttypedef void (*handler)(int);\n #   else\n \ttypedef void (*handler)();\n #   endif\n \n-#   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1)\n+#   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1) || defined(HURD)\n \tstatic struct sigaction old_segv_act;\n-#\tif defined(_sigargs) || defined(HPUX) /* !Irix6.x */\n+#\tif defined(_sigargs) /* !Irix6.x */ || defined(HPUX) || defined(HURD)\n \t    static struct sigaction old_bus_act;\n #\tendif\n #   else\n@@ -544,11 +545,16 @@ ptr_t GC_get_stack_base()\n #   endif\n     {\n # ifndef ECOS\n-#\tif defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1)\n+#\tif defined(SUNOS5SIGS) || defined(IRIX5)  \\\n+        || defined(OSF1) || defined(HURD)\n \t  struct sigaction\tact;\n \n \t  act.sa_handler\t= h;\n-          act.sa_flags          = SA_RESTART | SA_NODEFER;\n+#\t  ifdef SUNOS5SIGS\n+            act.sa_flags          = SA_RESTART | SA_NODEFER;\n+#         else\n+            act.sa_flags          = SA_RESTART;\n+#\t  endif\n           /* The presence of SA_NODEFER represents yet another gross    */\n           /* hack.  Under Solaris 2.3, siglongjmp doesn't appear to     */\n           /* interact correctly with -lthread.  We hide the confusion   */\n@@ -564,7 +570,7 @@ ptr_t GC_get_stack_base()\n #\t  else\n \t        (void) sigaction(SIGSEGV, &act, &old_segv_act);\n #\t\tif defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n-\t\t   || defined(HPUX)\n+\t\t   || defined(HPUX) || defined(HURD)\n \t\t    /* Under Irix 5.x or HP/UX, we may get SIGBUS.\t*/\n \t\t    /* Pthreads doesn't exist under Irix 5.x, so we\t*/\n \t\t    /* don't have to worry in the threads case.\t\t*/\n@@ -601,10 +607,11 @@ ptr_t GC_get_stack_base()\n     void GC_reset_fault_handler()\n     {\n # ifndef ECOS\n-#       if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1)\n+#       if defined(SUNOS5SIGS) || defined(IRIX5) \\\n+\t   || defined(OSF1) || defined(HURD)\n \t  (void) sigaction(SIGSEGV, &old_segv_act, 0);\n #\t  if defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n-\t     || defined(HPUX)\n+\t     || defined(HPUX) || defined(HURD)\n \t      (void) sigaction(SIGBUS, &old_bus_act, 0);\n #\t  endif\n #       else\n@@ -753,7 +760,7 @@ ptr_t GC_get_stack_base()\n #endif /* FREEBSD_STACKBOTTOM */\n \n #if !defined(BEOS) && !defined(AMIGA) && !defined(MSWIN32) \\\n-    && !defined(MSWINCE) && !defined(OS2)\n+    && !defined(MSWINCE) && !defined(OS2) && !defined(ECOS)\n \n ptr_t GC_get_stack_base()\n {\n@@ -1808,7 +1815,8 @@ struct hblk *h;\n #if defined(SUNOS4) || defined(FREEBSD)\n     typedef void (* SIG_PF)();\n #endif\n-#if defined(SUNOS5SIGS) || defined(OSF1) || defined(LINUX) || defined(MACOSX)\n+#if defined(SUNOS5SIGS) || defined(OSF1) || defined(LINUX) \\\n+    || defined(MACOSX) || defined(HURD)\n # ifdef __STDC__\n     typedef void (* SIG_PF)(int);\n # else\n@@ -1826,7 +1834,7 @@ struct hblk *h;\n #   define SIG_DFL (SIG_PF) (-1)\n #endif\n \n-#if defined(IRIX5) || defined(OSF1)\n+#if defined(IRIX5) || defined(OSF1) || defined(HURD)\n     typedef void (* REAL_SIG_PF)(int, int, struct sigcontext *);\n #endif\n #if defined(SUNOS5SIGS)\n@@ -2013,7 +2021,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #ifdef GC_TEST_AND_SET_DEFINED\n   static VOLATILE unsigned int fault_handler_lock = 0;\n   void async_set_pht_entry_from_index(VOLATILE page_hash_table db, int index) {\n-    while (GC_test_and_set(&fault_handler_lock));\n+    while (GC_test_and_set(&fault_handler_lock)) {}\n     /* Could also revert to set_pht_entry_from_index_safe if initial\t*/\n     /* GC_test_and_set fails.\t\t\t\t\t\t*/\n     set_pht_entry_from_index(db, index);\n@@ -2067,16 +2075,21 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #     define CODE_OK (code == BUS_PAGE_FAULT)\n #   endif\n # endif\n-# if defined(IRIX5) || defined(OSF1)\n+# if defined(IRIX5) || defined(OSF1) || defined(HURD)\n #   include <errno.h>\n     void GC_write_fault_handler(int sig, int code, struct sigcontext *scp)\n-#   define SIG_OK (sig == SIGSEGV)\n #   ifdef OSF1\n+#     define SIG_OK (sig == SIGSEGV)\n #     define CODE_OK (code == 2 /* experimentally determined */)\n #   endif\n #   ifdef IRIX5\n+#     define SIG_OK (sig == SIGSEGV)\n #     define CODE_OK (code == EACCES)\n #   endif\n+#   ifdef HURD\n+#     define SIG_OK (sig == SIGBUS || sig == SIGSEGV) \t\n+#     define CODE_OK  TRUE\n+#   endif\n # endif\n # if defined(LINUX)\n #   if defined(ALPHA) || defined(M68K)\n@@ -2131,6 +2144,9 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n # endif\n {\n     register unsigned i;\n+#   if defined(HURD) \n+\tchar *addr = (char *) code;\n+#   endif\n #   ifdef IRIX5\n \tchar * addr = (char *) (size_t) (scp -> sc_badvaddr);\n #   endif\n@@ -2254,7 +2270,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #\t\t    endif\n \t\t    return;\n #\t\tendif\n-#\t\tif defined (IRIX5) || defined(OSF1)\n+#\t\tif defined (IRIX5) || defined(OSF1) || defined(HURD)\n \t\t    (*(REAL_SIG_PF)old_handler) (sig, code, scp);\n \t\t    return;\n #\t\tendif\n@@ -2266,13 +2282,24 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #\t\tendif\n             }\n         }\n+        UNPROTECT(h, GC_page_size);\n+\t/* We need to make sure that no collection occurs between\t*/\n+\t/* the UNPROTECT and the setting of the dirty bit.  Otherwise\t*/\n+\t/* a write by a third thread might go unnoticed.  Reversing\t*/\n+\t/* the order is just as bad, since we would end up unprotecting\t*/\n+\t/* a page in a GC cycle during which it's not marked.\t\t*/\n+\t/* Currently we do this by disabling the thread stopping\t*/\n+\t/* signals while this handler is running.  An alternative might\t*/\n+\t/* be to record the fact that we're about to unprotect, or\t*/\n+\t/* have just unprotected a page in the GC's thread structure,\t*/\n+\t/* and then to have the thread stopping code set the dirty\t*/\n+\t/* flag, if necessary.\t\t\t\t\t\t*/\n         for (i = 0; i < divHBLKSZ(GC_page_size); i++) {\n             register int index = PHT_HASH(h+i);\n             \n             async_set_pht_entry_from_index(GC_dirty_pages, index);\n         }\n-        UNPROTECT(h, GC_page_size);\n-#\tif defined(OSF1) || defined(LINUX)\n+#\tif defined(OSF1)\n \t    /* These reset the signal handler each time by default. */\n \t    signal(SIGSEGV, (SIG_PF) GC_write_fault_handler);\n #\tendif\n@@ -2321,16 +2348,25 @@ struct hblk *h;\n \n void GC_dirty_init()\n {\n-#   if defined(SUNOS5SIGS) || defined(IRIX5) /* || defined(OSF1) */\n+#   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(LINUX) || \\\n+       defined(OSF1) || defined(HURD)\n       struct sigaction\tact, oldact;\n-#     ifdef IRIX5\n+      /* We should probably specify SA_SIGINFO for Linux, and handle \t*/\n+      /* the different architectures more uniformly.\t\t\t*/\n+#     if defined(IRIX5) || defined(LINUX) || defined(OSF1) || defined(HURD)\n     \tact.sa_flags\t= SA_RESTART;\n-        act.sa_handler  = GC_write_fault_handler;\n+        act.sa_handler  = (SIG_PF)GC_write_fault_handler;\n #     else\n     \tact.sa_flags\t= SA_RESTART | SA_SIGINFO;\n         act.sa_sigaction = GC_write_fault_handler;\n #     endif\n       (void)sigemptyset(&act.sa_mask);\n+#     ifdef SIG_SUSPEND\n+        /* Arrange to postpone SIG_SUSPEND while we're in a write fault\t*/\n+        /* handler.  This effectively makes the handler atomic w.r.t.\t*/\n+        /* stopping the world for GC.\t\t\t\t\t*/\n+        (void)sigaddset(&act.sa_mask, SIG_SUSPEND);\n+#     endif /* SIG_SUSPEND */\n #    endif\n #   if defined(MACOSX)\n       struct sigaction act, oldact;\n@@ -2359,7 +2395,7 @@ void GC_dirty_init()\n #\tendif\n       }\n #   endif\n-#   if defined(OSF1) || defined(SUNOS4) || defined(LINUX)\n+#   if defined(SUNOS4)\n       GC_old_segv_handler = signal(SIGSEGV, (SIG_PF)GC_write_fault_handler);\n       if (GC_old_segv_handler == SIG_IGN) {\n         GC_err_printf0(\"Previously ignored segmentation violation!?\");\n@@ -2371,18 +2407,20 @@ void GC_dirty_init()\n #\tendif\n       }\n #   endif\n-#   if defined(SUNOS5SIGS) || defined(IRIX5)\n+#   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(LINUX) \\\n+       || defined(OSF1) || defined(HURD)\n+      /* SUNOS5SIGS includes HPUX */\n #     if defined(IRIX_THREADS)\n       \tsigaction(SIGSEGV, 0, &oldact);\n       \tsigaction(SIGSEGV, &act, 0);\n #     else\n       \tsigaction(SIGSEGV, &act, &oldact);\n #     endif\n-#     if defined(_sigargs)\n+#     if defined(_sigargs) || defined(HURD)\n \t/* This is Irix 5.x, not 6.x.  Irix 5.x does not have\t*/\n \t/* sa_sigaction.\t\t\t\t\t*/\n \tGC_old_segv_handler = oldact.sa_handler;\n-#     else /* Irix 6.x or SUNOS5SIGS */\n+#     else /* Irix 6.x or SUNOS5SIGS or LINUX */\n         if (oldact.sa_flags & SA_SIGINFO) {\n           GC_old_segv_handler = (SIG_PF)(oldact.sa_sigaction);\n         } else {\n@@ -2399,7 +2437,7 @@ void GC_dirty_init()\n #       endif\n       }\n #   endif\n-#   if defined(MACOSX) || defined(HPUX)\n+#   if defined(MACOSX) || defined(HPUX) || defined(LINUX) || defined(HURD)\n       sigaction(SIGBUS, &act, &oldact);\n       GC_old_bus_handler = oldact.sa_handler;\n       if (GC_old_bus_handler == SIG_IGN) {\n@@ -2411,7 +2449,7 @@ void GC_dirty_init()\n \t  GC_err_printf0(\"Replaced other SIGBUS handler\\n\");\n #       endif\n       }\n-#   endif /* MACOS || HPUX */\n+#   endif /* MACOS || HPUX || LINUX */\n #   if defined(MSWIN32)\n       GC_old_segv_handler = SetUnhandledExceptionFilter(GC_write_fault_handler);\n       if (GC_old_segv_handler != NULL) {\n@@ -2548,10 +2586,14 @@ word len;\n \t    result = readv(fd, &iov, 1);\n \t}\n #   else\n+#     if defined(HURD)\t\n+\tresult = __read(fd, buf, nbyte);\n+#     else\n  \t/* The two zero args at the end of this list are because one\n  \t   IA-64 syscall() implementation actually requires six args\n  \t   to be passed, even though they aren't always used. */\n      \tresult = syscall(SYS_read, fd, buf, nbyte, 0, 0);\n+#     endif /* !HURD */\n #   endif\n     GC_end_syscall();\n     return(result);\n@@ -3005,9 +3047,11 @@ struct callinfo info[NFRAMES];\n       register int i;\n       \n       info[nframes].ci_pc = fp->FR_SAVPC;\n-      for (i = 0; i < NARGS; i++) {\n-\tinfo[nframes].ci_arg[i] = ~(fp->fr_arg[i]);\n-      }\n+#     if NARGS > 0\n+        for (i = 0; i < NARGS; i++) {\n+\t  info[nframes].ci_arg[i] = ~(fp->fr_arg[i]);\n+        }\n+#     endif /* NARGS > 0 */\n   }\n   if (nframes < NFRAMES) info[nframes].ci_pc = 0;\n }"}, {"sha": "92f06286e73edab1a276862110d5b90766754033", "filename": "boehm-gc/powerpc_macosx_mach_dep.s", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fpowerpc_macosx_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fpowerpc_macosx_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpowerpc_macosx_mach_dep.s?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -1,4 +1,5 @@\n-    .text\n+\t\n+.text\n     \n     .set   linkageArea,24\n     .set   params,4\n@@ -15,52 +16,80 @@ _GC_push_regs:\n     stw     r0,8(r1)    ; save return address\n     stwu    r1,-spaceToSave(r1)   ; skip over caller save area\n     ;\n-    mr      r3,r2         ; mark from r2. Well I'm not really sure\n+    mr      r3,r2         ; mark from r2. Well Im not really sure\n                           ; that this is necessary or even the right\n-                          ; thing to do - at least it doesn't harm...\n-                          ; According to Apple's docs it points to\n+                          ; thing to do - at least it doesnt harm...\n+                          ; According to Apples docs it points to\n                           ; the direct data area, whatever that is...\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r13        ; mark from r13-r31\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r14\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r15\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r16\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r17\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r18\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r19\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r20\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r21\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r22\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r23\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r24\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r25\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r26\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r27\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r28\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r29\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r30\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     mr      r3,r31\n-    bl \t    _GC_push_one\n+    bl \t    L_GC_push_one$stub\n     ; EPILOG\n     lwz     r0,spaceToSave8(r1)   ; get return address back\n     mtlr    r0    ; reset link register\n     addic   r1,r1,spaceToSave   ; restore stack pointer\n     blr\n+\n+.data\n+.picsymbol_stub\n+L_GC_push_one$stub:\n+\t.indirect_symbol _GC_push_one\n+\tmflr r0\n+\tbcl 20,31,L0$_GC_push_one\n+L0$_GC_push_one:\n+\tmflr r11\n+\taddis r11,r11,ha16(L_GC_push_one$lazy_ptr-L0$_GC_push_one)\n+\tmtlr r0\n+\tlwz r12,lo16(L_GC_push_one$lazy_ptr-L0$_GC_push_one)(r11)\n+\tmtctr r12\n+\taddi r11,r11,lo16(L_GC_push_one$lazy_ptr-L0$_GC_push_one)\n+\tbctr\n+.data\n+.lazy_symbol_pointer\n+L_GC_push_one$lazy_ptr:\n+\t.indirect_symbol _GC_push_one\n+\t.long dyld_stub_binding_helper\n+.non_lazy_symbol_pointer\n+L_GC_push_one$non_lazy_ptr:\n+\t.indirect_symbol _GC_push_one\n+\t.long 0\n+\t\n+\n+\n+"}, {"sha": "78995f3985f2ec0a0b915b837898874e6a743a6e", "filename": "boehm-gc/reclaim.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -20,7 +20,7 @@\n signed_word GC_mem_found = 0;\n \t\t\t/* Number of words of memory reclaimed     */\n \n-#ifdef PARALLEL_MARK\n+#if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n   word GC_fl_builder_count = 0;\n \t/* Number of threads currently building free lists without \t*/\n \t/* holding GC lock.  It is not safe to collect if this is \t*/\n@@ -866,6 +866,9 @@ int report_if_found;\t\t/* Abort if a GC_reclaimable object is found */\n {\n     int kind;\n     \n+#   if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n+      GC_ASSERT(0 == GC_fl_builder_count);\n+#   endif\n     /* Clear reclaim- and free-lists */\n       for (kind = 0; kind < GC_n_kinds; kind++) {\n         register ptr_t *fop;\n@@ -902,6 +905,9 @@ int report_if_found;\t\t/* Abort if a GC_reclaimable object is found */\n     /* so that you can convince yourself that it really is very stupid.\t*/\n     GC_reclaim_all((GC_stop_func)0, FALSE);\n # endif\n+# if defined(PARALLEL_MARK) || defined(THREAD_LOCAL_ALLOC)\n+    GC_ASSERT(0 == GC_fl_builder_count);\n+# endif\n     \n }\n "}, {"sha": "1bd98d64e0f5abb76b501fc7bf1353252ac7353c", "filename": "boehm-gc/tests/test.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Ftests%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Ftests%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest.c?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -14,6 +14,9 @@\n  */\n /* An incomplete test for the garbage collector.  \t\t*/\n /* Some more obscure entry points are not tested at all.\t*/\n+/* This must be compiled with the same flags used to build the \t*/\n+/* GC.  It uses GC internals to allow more precise results\t*/\n+/* checking for some of the tests.\t\t\t\t*/\n \n # undef GC_BUILD\n \n@@ -238,8 +241,8 @@ sexpr y;\n \n #ifdef GC_GCJ_SUPPORT\n \n-#include \"private/dbg_mlc.h\"\n-#include \"private/gc_pmark.h\"\n+#include \"gc_mark.h\"\n+#include \"private/dbg_mlc.h\"  /* For USR_PTR_FROM_BASE */\n #include \"gc_gcj.h\"\n \n /* The following struct emulates the vtable in gcj.\t*/\n@@ -267,16 +270,12 @@ struct GC_ms_entry * fake_gcj_mark_proc(word * addr,\n \taddr = (word *)USR_PTR_FROM_BASE(addr);\n     }\n     x = (sexpr)(addr + 1); /* Skip the vtable pointer. */\n-    /* We could just call PUSH_CONTENTS directly here.  But any real\t*/\n-    /* real client would try to filter out the obvious misses.\t\t*/\n-    if (0 != x -> sexpr_cdr) {\n-\tPUSH_CONTENTS((ptr_t)(x -> sexpr_cdr), mark_stack_ptr,\n-\t\t\t      mark_stack_limit, &(x -> sexpr_cdr), exit1);\n-    }\n-    if ((ptr_t)(x -> sexpr_car) > (ptr_t) GC_least_plausible_heap_addr) {\n-\tPUSH_CONTENTS((ptr_t)(x -> sexpr_car), mark_stack_ptr,\n-\t\t\t      mark_stack_limit, &(x -> sexpr_car), exit2);\n-    }\n+    mark_stack_ptr = GC_MARK_AND_PUSH(\n+\t\t\t      (GC_PTR)(x -> sexpr_cdr), mark_stack_ptr,\n+\t\t\t      mark_stack_limit, (GC_PTR *)&(x -> sexpr_cdr));\n+    mark_stack_ptr = GC_MARK_AND_PUSH(\n+\t\t\t      (GC_PTR)(x -> sexpr_car), mark_stack_ptr,\n+\t\t\t      mark_stack_limit, (GC_PTR *)&(x -> sexpr_car));\n     return(mark_stack_ptr);\n }\n \n@@ -703,6 +702,13 @@ int n;\n #   endif\n     \n     collectable_count++;\n+#   ifdef THREAD_LOCAL_ALLOC\n+       /* Minimally exercise thread local allocation */\n+       {\n+         char * result = (char *)GC_LOCAL_MALLOC_ATOMIC(17);\n+\t memset(result, 'a', 17);\n+       }\n+#   endif /* THREAD_LOCAL_ALLOC */\n #   if defined(MACOS)\n \t/* get around static data limitations. */\n \tif (!live_indicators)"}, {"sha": "7efee18fd67276bc1c4628021372e580bb0d74fc", "filename": "boehm-gc/version.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a2586cf8fcf001cddb47d3f9bf6610975d1564d/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=5a2586cf8fcf001cddb47d3f9bf6610975d1564d", "patch": "@@ -1,6 +1,6 @@\n #define GC_VERSION_MAJOR 6\n #define GC_VERSION_MINOR 0\n-#define GC_ALPHA_VERSION 7\n+#define GC_ALPHA_VERSION GC_NOT_ALPHA\n \n #   define GC_NOT_ALPHA 0xff\n "}]}