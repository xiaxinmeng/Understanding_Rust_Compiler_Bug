{"sha": "d9d09ca2d67c64d7746c70f61fb595994ae941f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDlkMDljYTJkNjdjNjRkNzc0NmM3MGY2MWZiNTk1OTk0YWU5NDFmNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-10-26T13:54:13Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-10-26T13:54:13Z"}, "message": "reload.c (reload_inner_reg_of_subreg): Change type of return value and type of OUTPUT parameter to bool and adjust.\n\n\t* reload.c (reload_inner_reg_of_subreg): Change type of return value\n\tand type of OUTPUT parameter to bool and adjust.  Document MODE and\n\tOUTPUT parameters.  Use HARD_REGISTER_P.  Reorder final condition\n\tand improve associated comment.\n\t(push_reload): Clarify and update comments about reloading of subregs.\n\tAdjust calls to reload_inner_reg_of_subreg.  Compute the class upfront\n\tfor the reloading of subregs in the out case as well.\n\nFrom-SVN: r180526", "tree": {"sha": "d066abe1a45fa2c2f22ff463c528153ff122a592", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d066abe1a45fa2c2f22ff463c528153ff122a592"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9d09ca2d67c64d7746c70f61fb595994ae941f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9d09ca2d67c64d7746c70f61fb595994ae941f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9d09ca2d67c64d7746c70f61fb595994ae941f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9d09ca2d67c64d7746c70f61fb595994ae941f5/comments", "author": null, "committer": null, "parents": [{"sha": "bfd5f9f59dc139568b3c205b7452a68cd8392d05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfd5f9f59dc139568b3c205b7452a68cd8392d05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfd5f9f59dc139568b3c205b7452a68cd8392d05"}], "stats": {"total": 103, "additions": 56, "deletions": 47}, "files": [{"sha": "cd1a2365d561e8a5d4c990ac242c6aeb1af28358", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d09ca2d67c64d7746c70f61fb595994ae941f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d09ca2d67c64d7746c70f61fb595994ae941f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9d09ca2d67c64d7746c70f61fb595994ae941f5", "patch": "@@ -1,3 +1,13 @@\n+2011-10-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* reload.c (reload_inner_reg_of_subreg): Change type of return value\n+\tand type of OUTPUT parameter to bool and adjust.  Document MODE and\n+\tOUTPUT parameters.  Use HARD_REGISTER_P.  Reorder final condition\n+\tand improve associated comment.\n+\t(push_reload): Clarify and update comments about reloading of subregs.\n+\tAdjust calls to reload_inner_reg_of_subreg.  Compute the class upfront\n+\tfor the reloading of subregs in the out case as well.\n+\n 2011-10-26  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR debug/50826\n@@ -12,7 +22,7 @@\n \t(statement_sink_location): Use it.\n \t* params.def (SINK_FREQUENCY_THRESHOLD): New PARAM.\n \n-2011-10-14  Iain Sandoe  <iains@gcc.gnu.org>\n+2011-10-26  Iain Sandoe  <iains@gcc.gnu.org>\n \n \tPR target/48108\n \t* config/darwin.c (top level): Amend comments concerning LTO output."}, {"sha": "307bc3a91efbf4ce2b6c45065567ff61e5a38a7c", "filename": "gcc/reload.c", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9d09ca2d67c64d7746c70f61fb595994ae941f5/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9d09ca2d67c64d7746c70f61fb595994ae941f5/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=d9d09ca2d67c64d7746c70f61fb595994ae941f5", "patch": "@@ -256,7 +256,6 @@ static int push_secondary_reload (int, rtx, int, int, enum reg_class,\n \t\t\t\t  enum insn_code *, secondary_reload_info *);\n static enum reg_class find_valid_class (enum machine_mode, enum machine_mode,\n \t\t\t\t\tint, unsigned int);\n-static int reload_inner_reg_of_subreg (rtx, enum machine_mode, int);\n static void push_replacement (rtx *, int, enum machine_mode);\n static void dup_replacements (rtx *, rtx *);\n static void combine_reloads (void);\n@@ -791,39 +790,39 @@ find_reusable_reload (rtx *p_in, rtx out, enum reg_class rclass,\n   return n_reloads;\n }\n \n-/* Return nonzero if X is a SUBREG which will require reloading of its\n-   SUBREG_REG expression.  */\n+/* Return true if X is a SUBREG that will need reloading of its SUBREG_REG\n+   expression.  MODE is the mode that X will be used in.  OUTPUT is true if\n+   the function is invoked for the output part of an enclosing reload.  */\n \n-static int\n-reload_inner_reg_of_subreg (rtx x, enum machine_mode mode, int output)\n+static bool\n+reload_inner_reg_of_subreg (rtx x, enum machine_mode mode, bool output)\n {\n   rtx inner;\n \n   /* Only SUBREGs are problematical.  */\n   if (GET_CODE (x) != SUBREG)\n-    return 0;\n+    return false;\n \n   inner = SUBREG_REG (x);\n \n-  /* If INNER is a constant or PLUS, then INNER must be reloaded.  */\n+  /* If INNER is a constant or PLUS, then INNER will need reloading.  */\n   if (CONSTANT_P (inner) || GET_CODE (inner) == PLUS)\n-    return 1;\n+    return true;\n \n-  /* If INNER is not a hard register, then INNER will not need to\n-     be reloaded.  */\n-  if (!REG_P (inner)\n-      || REGNO (inner) >= FIRST_PSEUDO_REGISTER)\n-    return 0;\n+  /* If INNER is not a hard register, then INNER will not need reloading.  */\n+  if (!(REG_P (inner) && HARD_REGISTER_P (inner)))\n+    return false;\n \n   /* If INNER is not ok for MODE, then INNER will need reloading.  */\n-  if (! HARD_REGNO_MODE_OK (subreg_regno (x), mode))\n-    return 1;\n-\n-  /* If the outer part is a word or smaller, INNER larger than a\n-     word and the number of regs for INNER is not the same as the\n-     number of words in INNER, then INNER will need reloading.  */\n-  return (GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n-\t  && output\n+  if (!HARD_REGNO_MODE_OK (subreg_regno (x), mode))\n+    return true;\n+\n+  /* If this is for an output, and the outer part is a word or smaller,\n+     INNER is larger than a word and the number of registers in INNER is\n+     not the same as the number of words in INNER, then INNER will need\n+     reloading (with an in-out reload).  */\n+  return (output\n+\t  && GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t  && GET_MODE_SIZE (GET_MODE (inner)) > UNITS_PER_WORD\n \t  && ((GET_MODE_SIZE (GET_MODE (inner)) / UNITS_PER_WORD)\n \t      != (int) hard_regno_nregs[REGNO (inner)][GET_MODE (inner)]));\n@@ -990,9 +989,9 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n      For machines that extend byte loads, do this for any SUBREG of a pseudo\n      where both M1 and M2 are a word or smaller, M1 is wider than M2, and\n      M2 is an integral mode that gets extended when loaded.\n-     Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where\n-     either M1 is not valid for R or M2 is wider than a word but we only\n-     need one word to store an M2-sized quantity in R.\n+     Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R\n+     where either M1 is not valid for R or M2 is wider than a word but we\n+     only need one register to store an M2-sized quantity in R.\n      (However, if OUT is nonzero, we need to reload the reg *and*\n      the subreg, so do nothing here, and let following statement handle it.)\n \n@@ -1082,17 +1081,16 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       inmode = GET_MODE (in);\n     }\n \n-  /* Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where\n-     either M1 is not valid for R or M2 is wider than a word but we only\n-     need one word to store an M2-sized quantity in R.\n+  /* Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R\n+     where M1 is not valid for R if it was not handled by the code above.\n+\n+     Similar issue for (SUBREG constant ...) if it was not handled by the\n+     code above.  This can happen if SUBREG_BYTE != 0.\n \n      However, we must reload the inner reg *as well as* the subreg in\n      that case.  */\n \n-  /* Similar issue for (SUBREG constant ...) if it was not handled by the\n-     code above.  This can happen if SUBREG_BYTE != 0.  */\n-\n-  if (in != 0 && reload_inner_reg_of_subreg (in, inmode, 0))\n+  if (in != 0 && reload_inner_reg_of_subreg (in, inmode, false))\n     {\n       enum reg_class in_class = rclass;\n \n@@ -1168,31 +1166,32 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       outmode = GET_MODE (out);\n     }\n \n-  /* Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where\n-     either M1 is not valid for R or M2 is wider than a word but we only\n-     need one word to store an M2-sized quantity in R.\n+  /* Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R\n+     where either M1 is not valid for R or M2 is wider than a word but we\n+     only need one register to store an M2-sized quantity in R.\n \n      However, we must reload the inner reg *as well as* the subreg in\n-     that case.  In this case, the inner reg is an in-out reload.  */\n+     that case and the inner reg is an in-out reload.  */\n \n-  if (out != 0 && reload_inner_reg_of_subreg (out, outmode, 1))\n+  if (out != 0 && reload_inner_reg_of_subreg (out, outmode, true))\n     {\n+      enum reg_class in_out_class\n+\t= find_valid_class (outmode, GET_MODE (SUBREG_REG (out)),\n+\t\t\t    subreg_regno_offset (REGNO (SUBREG_REG (out)),\n+\t\t\t\t\t\t GET_MODE (SUBREG_REG (out)),\n+\t\t\t\t\t\t SUBREG_BYTE (out),\n+\t\t\t\t\t\t GET_MODE (out)),\n+\t\t\t    REGNO (SUBREG_REG (out)));\n+\n       /* This relies on the fact that emit_reload_insns outputs the\n \t instructions for output reloads of type RELOAD_OTHER in reverse\n \t order of the reloads.  Thus if the outer reload is also of type\n \t RELOAD_OTHER, we are guaranteed that this inner reload will be\n \t output after the outer reload.  */\n-      dont_remove_subreg = 1;\n       push_reload (SUBREG_REG (out), SUBREG_REG (out), &SUBREG_REG (out),\n-\t\t   &SUBREG_REG (out),\n-\t\t   find_valid_class (outmode, GET_MODE (SUBREG_REG (out)),\n-\t\t\t\t     subreg_regno_offset (REGNO (SUBREG_REG (out)),\n-\t\t\t\t\t\t\t  GET_MODE (SUBREG_REG (out)),\n-\t\t\t\t\t\t\t  SUBREG_BYTE (out),\n-\t\t\t\t\t\t\t  GET_MODE (out)),\n-\t\t\t\t     REGNO (SUBREG_REG (out))),\n-\t\t   VOIDmode, VOIDmode, 0, 0,\n-\t\t   opnum, RELOAD_OTHER);\n+\t\t   &SUBREG_REG (out), in_out_class, VOIDmode, VOIDmode,\n+\t\t   0, 0, opnum, RELOAD_OTHER);\n+      dont_remove_subreg = 1;\n     }\n \n   /* If IN appears in OUT, we can't share any input-only reload for IN.  */"}]}