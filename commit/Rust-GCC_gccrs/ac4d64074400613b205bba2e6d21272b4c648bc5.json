{"sha": "ac4d64074400613b205bba2e6d21272b4c648bc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM0ZDY0MDc0NDAwNjEzYjIwNWJiYTJlNmQyMTI3MmI0YzY0OGJjNQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-12-13T10:22:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:22:06Z"}, "message": "atree.adb (Flag231..Flag247): New functions\n\n2007-12-06  Robert Dewar  <dewar@adacore.com>\n\n\t* atree.adb (Flag231..Flag247): New functions\n\t(Set_Flag231..Set_Flag247): New procedures\n\t(Basic_Set_Convention): Rename Set_Convention to be\n\tBasic_Set_Convention\n\t(Nkind_In): New functions\n\tRemove Atree.Delete_Tree/Delete_Node and Nlist.Delete_List\n\n\t* exp_ch6.adb (Expand_Call): Use new flag Has_Pragma_Inline_Always\n\tinstead\n\t of obsolete function Is_Always_Inlined\n\t(Register_Predefined_DT_Entry): Initialize slots of the second\n\tsecondary dispatch table.\n\tRemove Atree.Delete_Tree/Delete_Node and Nlist.Delete_List\n\t(Expand_N_Function_Call): Remove special provision for stack checking.\n\n\t* exp_util.ads, exp_util.adb (Is_Predefined_Dispatching_Operation):\n\tInclude _Disp_Requeue in the list of predefined operations.\n\t(Find_Interface_ADT): Modified to fulfill the new specification.\n\tRemove Atree.Delete_Tree/Delete_Node and Nlist.Delete_List\n\n\t* par-ch4.adb, nlists.ads, nlists.adb: \n\tRemove Atree.Delete_Tree/Delete_Node and Nlist.Delete_List\n\n\t* sinfo.ads, sinfo.adb: (Nkind_In): New functions\n\tFix location of flag for unrecognized pragma message\n\n\t* sem_ch7.adb: Use Nkind_In\n\nFrom-SVN: r130820", "tree": {"sha": "c68ed79f7c2a4dc0ccf8b7d714f6a24bc37734fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c68ed79f7c2a4dc0ccf8b7d714f6a24bc37734fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac4d64074400613b205bba2e6d21272b4c648bc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac4d64074400613b205bba2e6d21272b4c648bc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac4d64074400613b205bba2e6d21272b4c648bc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac4d64074400613b205bba2e6d21272b4c648bc5/comments", "author": null, "committer": null, "parents": [{"sha": "f8755021cc57dcd4514ef53a8d8cb5fe4059d1c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8755021cc57dcd4514ef53a8d8cb5fe4059d1c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8755021cc57dcd4514ef53a8d8cb5fe4059d1c8"}], "stats": {"total": 1138, "additions": 708, "deletions": 430}, "files": [{"sha": "322528c4b9c03eb4a879cf173f320b210ab47e17", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 338, "deletions": 105, "changes": 443, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -364,9 +364,6 @@ package body Atree is\n       Flag228 : Boolean;\n       Flag229 : Boolean;\n       Flag230 : Boolean;\n-\n-      --  Note: flags 231-247 not in use yet\n-\n       Flag231 : Boolean;\n \n       Flag232 : Boolean;\n@@ -647,6 +644,18 @@ package body Atree is\n       return Nodes.Table (N).Analyzed;\n    end Analyzed;\n \n+   --------------------------\n+   -- Basic_Set_Convention --\n+   --------------------------\n+\n+   procedure Basic_Set_Convention  (E : Entity_Id; Val : Convention_Id) is\n+   begin\n+      pragma Assert (Nkind (E) in N_Entity);\n+      To_Flag_Word_Ptr\n+        (Union_Id_Ptr'\n+          (Nodes.Table (E + 2).Field12'Unrestricted_Access)).Convention := Val;\n+   end Basic_Set_Convention;\n+\n    -----------------\n    -- Change_Node --\n    -----------------\n@@ -868,91 +877,6 @@ package body Atree is\n       end if;\n    end Copy_Separate_Tree;\n \n-   -----------------\n-   -- Delete_Node --\n-   -----------------\n-\n-   procedure Delete_Node (Node : Node_Id) is\n-   begin\n-      pragma Assert (not Nodes.Table (Node).In_List);\n-\n-      if Debug_Flag_N then\n-         Write_Str (\"Delete node \");\n-         Write_Int (Int (Node));\n-         Write_Eol;\n-      end if;\n-\n-      Nodes.Table (Node)       := Default_Node;\n-      Nodes.Table (Node).Nkind := N_Unused_At_Start;\n-      Node_Count := Node_Count - 1;\n-\n-      --  Note: for now, we are not bothering to reuse deleted nodes\n-\n-   end Delete_Node;\n-\n-   -----------------\n-   -- Delete_Tree --\n-   -----------------\n-\n-   procedure Delete_Tree (Node : Node_Id) is\n-\n-      procedure Delete_Field (F : Union_Id);\n-      --  Delete item pointed to by field F if it is a syntactic element\n-\n-      procedure Delete_List (L : List_Id);\n-      --  Delete all elements on the given list\n-\n-      ------------------\n-      -- Delete_Field --\n-      ------------------\n-\n-      procedure Delete_Field (F : Union_Id) is\n-      begin\n-         if F = Union_Id (Empty) then\n-            return;\n-\n-         elsif F in Node_Range\n-           and then Parent (Node_Id (F)) = Node\n-         then\n-            Delete_Tree (Node_Id (F));\n-\n-         elsif F in List_Range\n-           and then Parent (List_Id (F)) = Node\n-         then\n-            Delete_List (List_Id (F));\n-\n-         --  No need to test Elist case, there are no syntactic Elists\n-\n-         else\n-            return;\n-         end if;\n-      end Delete_Field;\n-\n-      -----------------\n-      -- Delete_List --\n-      -----------------\n-\n-      procedure Delete_List (L : List_Id) is\n-      begin\n-         while Is_Non_Empty_List (L) loop\n-            Delete_Tree (Remove_Head (L));\n-         end loop;\n-      end Delete_List;\n-\n-   --  Start of processing for Delete_Tree\n-\n-   begin\n-      --  Delete descendents\n-\n-      Delete_Field (Field1 (Node));\n-      Delete_Field (Field2 (Node));\n-      Delete_Field (Field3 (Node));\n-      Delete_Field (Field4 (Node));\n-      Delete_Field (Field5 (Node));\n-\n-      --  ??? According to spec, Node itself should be deleted as well\n-   end Delete_Tree;\n-\n    -----------\n    -- Ekind --\n    -----------\n@@ -2275,6 +2199,94 @@ package body Atree is\n       return Nodes.Table (N).Nkind;\n    end Nkind;\n \n+   --------------\n+   -- Nkind_In --\n+   --------------\n+\n+   function Nkind_In\n+     (N  : Node_Id;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Nkind (N), V1, V2);\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (N  : Node_Id;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Nkind (N), V1, V2, V3);\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (N  : Node_Id;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Nkind (N), V1, V2, V3, V4);\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (N  : Node_Id;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Nkind (N), V1, V2, V3, V4, V5);\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (N  : Node_Id;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind;\n+      V6 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Nkind (N), V1, V2, V3, V4, V5, V6);\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (N  : Node_Id;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind;\n+      V6 : Node_Kind;\n+      V7 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Nkind (N), V1, V2, V3, V4, V5, V6, V7);\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (N  : Node_Id;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind;\n+      V6 : Node_Kind;\n+      V7 : Node_Kind;\n+      V8 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return Nkind_In (Nkind (N), V1, V2, V3, V4, V5, V6, V7, V8);\n+   end Nkind_In;\n+\n    --------\n    -- No --\n    --------\n@@ -2443,10 +2455,6 @@ package body Atree is\n       --  to Rewrite if there were an intention to save the original node.\n \n       Orig_Nodes.Table (Old_Node) := Old_Node;\n-\n-      --  Finally delete the source, since it is now copied\n-\n-      Delete_Node (New_Node);\n    end Replace;\n \n    -------------\n@@ -2534,19 +2542,6 @@ package body Atree is\n       Default_Node.Comes_From_Source := Default;\n    end Set_Comes_From_Source_Default;\n \n-   --------------------\n-   -- Set_Convention --\n-   --------------------\n-\n-   procedure Set_Convention  (E : Entity_Id; Val : Convention_Id) is\n-   begin\n-      pragma Assert (Nkind (E) in N_Entity);\n-      To_Flag_Word_Ptr\n-        (Union_Id_Ptr'\n-          (Nodes.Table (E + 2).Field12'Unrestricted_Access)).Convention :=\n-                                                                        Val;\n-   end Set_Convention;\n-\n    ---------------\n    -- Set_Ekind --\n    ---------------\n@@ -4865,6 +4860,108 @@ package body Atree is\n          return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag230;\n       end Flag230;\n \n+      function Flag231 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag231;\n+      end Flag231;\n+\n+      function Flag232 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag232;\n+      end Flag232;\n+\n+      function Flag233 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag233;\n+      end Flag233;\n+\n+      function Flag234 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag234;\n+      end Flag234;\n+\n+      function Flag235 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag235;\n+      end Flag235;\n+\n+      function Flag236 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag236;\n+      end Flag236;\n+\n+      function Flag237 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag237;\n+      end Flag237;\n+\n+      function Flag238 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag238;\n+      end Flag238;\n+\n+      function Flag239 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag239;\n+      end Flag239;\n+\n+      function Flag240 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag240;\n+      end Flag240;\n+\n+      function Flag241 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag241;\n+      end Flag241;\n+\n+      function Flag242 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag242;\n+      end Flag242;\n+\n+      function Flag243 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag243;\n+      end Flag243;\n+\n+      function Flag244 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag244;\n+      end Flag244;\n+\n+      function Flag245 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag245;\n+      end Flag245;\n+\n+      function Flag246 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag246;\n+      end Flag246;\n+\n+      function Flag247 (N : Node_Id) return Boolean is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         return To_Flag_Word5 (Nodes.Table (N + 4).Field12).Flag247;\n+      end Flag247;\n+\n       procedure Set_Nkind (N : Node_Id; Val : Node_Kind) is\n       begin\n          pragma Assert (N <= Nodes.Last);\n@@ -7091,6 +7188,142 @@ package body Atree is\n              (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag230 := Val;\n       end Set_Flag230;\n \n+      procedure Set_Flag231 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag231 := Val;\n+      end Set_Flag231;\n+\n+      procedure Set_Flag232 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag232 := Val;\n+      end Set_Flag232;\n+\n+      procedure Set_Flag233 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag233 := Val;\n+      end Set_Flag233;\n+\n+      procedure Set_Flag234 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag234 := Val;\n+      end Set_Flag234;\n+\n+      procedure Set_Flag235 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag235 := Val;\n+      end Set_Flag235;\n+\n+      procedure Set_Flag236 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag236 := Val;\n+      end Set_Flag236;\n+\n+      procedure Set_Flag237 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag237 := Val;\n+      end Set_Flag237;\n+\n+      procedure Set_Flag238 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag238 := Val;\n+      end Set_Flag238;\n+\n+      procedure Set_Flag239 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag239 := Val;\n+      end Set_Flag239;\n+\n+      procedure Set_Flag240 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag240 := Val;\n+      end Set_Flag240;\n+\n+      procedure Set_Flag241 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag241 := Val;\n+      end Set_Flag241;\n+\n+      procedure Set_Flag242 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag242 := Val;\n+      end Set_Flag242;\n+\n+      procedure Set_Flag243 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag243 := Val;\n+      end Set_Flag243;\n+\n+      procedure Set_Flag244 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag244 := Val;\n+      end Set_Flag244;\n+\n+      procedure Set_Flag245 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag245 := Val;\n+      end Set_Flag245;\n+\n+      procedure Set_Flag246 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag246 := Val;\n+      end Set_Flag246;\n+\n+      procedure Set_Flag247 (N : Node_Id; Val : Boolean) is\n+      begin\n+         pragma Assert (Nkind (N) in N_Entity);\n+         To_Flag_Word5_Ptr\n+           (Union_Id_Ptr'\n+             (Nodes.Table (N + 4).Field12'Unrestricted_Access)).Flag247 := Val;\n+      end Set_Flag247;\n+\n       procedure Set_Node1_With_Parent (N : Node_Id; Val : Node_Id) is\n       begin\n          pragma Assert (N <= Nodes.Last);"}, {"sha": "e8f5c114ace618cfb771468a336fde14976c0ef6", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 57, "deletions": 235, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -1391,8 +1391,8 @@ package body Exp_Ch6 is\n       begin\n          loop\n             Set_Analyzed (Pfx, False);\n-            exit when Nkind (Pfx) /= N_Selected_Component\n-              and then Nkind (Pfx) /= N_Indexed_Component;\n+            exit when\n+              not Nkind_In (Pfx, N_Selected_Component, N_Indexed_Component);\n             Pfx := Prefix (Pfx);\n          end loop;\n       end Reset_Packed_Prefix;\n@@ -1633,8 +1633,8 @@ package body Exp_Ch6 is\n                P : constant Node_Id := Parent (N);\n \n             begin\n-               pragma Assert (Nkind (P) = N_Triggering_Alternative\n-                 or else Nkind (P) = N_Entry_Call_Alternative);\n+               pragma Assert (Nkind_In (P, N_Triggering_Alternative,\n+                                           N_Entry_Call_Alternative));\n \n                if Is_Non_Empty_List (Statements (P)) then\n                   Insert_List_Before_And_Analyze\n@@ -2023,10 +2023,7 @@ package body Exp_Ch6 is\n          --  form, and rewritten before analysis.\n \n          if not Analyzed (Prev_Orig)\n-           and then\n-             (Nkind (Actual) = N_Function_Call\n-                or else\n-              Nkind (Actual) = N_Identifier)\n+           and then Nkind_In (Actual, N_Function_Call, N_Identifier)\n          then\n             Prev_Orig := Prev;\n          end if;\n@@ -2087,8 +2084,8 @@ package body Exp_Ch6 is\n                   --  as out parameter actuals on calls to stream procedures.\n \n                   Act_Prev := Prev;\n-                  while Nkind (Act_Prev) = N_Type_Conversion\n-                    or else Nkind (Act_Prev) = N_Unchecked_Type_Conversion\n+                  while Nkind_In (Act_Prev, N_Type_Conversion,\n+                                            N_Unchecked_Type_Conversion)\n                   loop\n                      Act_Prev := Expression (Act_Prev);\n                   end loop;\n@@ -2318,9 +2315,7 @@ package body Exp_Ch6 is\n             then\n                null;\n \n-            elsif Nkind (Prev) = N_Allocator\n-              or else Nkind (Prev) = N_Attribute_Reference\n-            then\n+            elsif Nkind_In (Prev, N_Allocator, N_Attribute_Reference) then\n                null;\n \n             --  Suppress null checks when passing to access parameters of Java\n@@ -2361,9 +2356,8 @@ package body Exp_Ch6 is\n \n                begin\n                   Nod := Actual;\n-                  while Nkind (Nod) = N_Indexed_Component\n-                          or else\n-                        Nkind (Nod) = N_Selected_Component\n+                  while Nkind_In (Nod, N_Indexed_Component,\n+                                       N_Selected_Component)\n                   loop\n                      Set_Analyzed (Nod, False);\n                      Nod := Prefix (Nod);\n@@ -2419,11 +2413,14 @@ package body Exp_Ch6 is\n                Sav : Node_Id;\n \n             begin\n-               --  For an OUT parameter that is an assignable entity, we do not\n-               --  want to clobber the Last_Assignment field, since if it is\n-               --  set, it was precisely because it is indeed an OUT parameter!\n-\n-               if Ekind (Formal) = E_Out_Parameter\n+               --  For an OUT or IN OUT parameter that is an assignable entity,\n+               --  we do not want to clobber the Last_Assignment field, since\n+               --  if it is set, it was precisely because it is indeed an OUT\n+               --  or IN OUT parameter!\n+\n+               if (Ekind (Formal) = E_Out_Parameter\n+                     or else\n+                   Ekind (Formal) = E_In_Out_Parameter)\n                  and then Is_Assignable (Ent)\n                then\n                   Sav := Last_Assignment (Ent);\n@@ -2534,8 +2531,7 @@ package body Exp_Ch6 is\n       --  Ada 2005 (AI-251): If some formal is a class-wide interface, expand\n       --  it to point to the correct secondary virtual table\n \n-      if (Nkind (N) = N_Function_Call\n-           or else Nkind (N) = N_Procedure_Call_Statement)\n+      if Nkind_In (N, N_Function_Call, N_Procedure_Call_Statement)\n         and then CW_Interface_Formals_Present\n       then\n          Expand_Interface_Actuals (N);\n@@ -2549,8 +2545,7 @@ package body Exp_Ch6 is\n       --  the VM back-ends directly handle the generation of dispatching\n       --  calls and would have to undo any expansion to an indirect call.\n \n-      if (Nkind (N) = N_Function_Call\n-           or else Nkind (N) =  N_Procedure_Call_Statement)\n+      if Nkind_In (N, N_Function_Call, N_Procedure_Call_Statement)\n         and then Present (Controlling_Argument (N))\n         and then VM_Target = No_VM\n       then\n@@ -2899,7 +2894,7 @@ package body Exp_Ch6 is\n \n                   if (In_Extended_Main_Code_Unit (N)\n                         or else In_Extended_Main_Code_Unit (Parent (N))\n-                        or else Is_Always_Inlined (Subp))\n+                        or else Has_Pragma_Inline_Always (Subp))\n                     and then (not In_Same_Extended_Unit (Sloc (Bod), Loc)\n                                or else\n                                  Earlier_In_Extended_Unit (Sloc (Bod), Loc))\n@@ -3036,10 +3031,6 @@ package body Exp_Ch6 is\n             --  If no arguments, delete entire list, this is the easy case\n \n             if No (Last_Keep_Arg) then\n-               while Is_Non_Empty_List (Parameter_Associations (N)) loop\n-                  Delete_Tree (Remove_Head (Parameter_Associations (N)));\n-               end loop;\n-\n                Set_Parameter_Associations (N, No_List);\n                Set_First_Named_Actual (N, Empty);\n \n@@ -3050,7 +3041,7 @@ package body Exp_Ch6 is\n \n             elsif Is_List_Member (Last_Keep_Arg) then\n                while Present (Next (Last_Keep_Arg)) loop\n-                  Delete_Tree (Remove_Next (Last_Keep_Arg));\n+                  Discard_Node (Remove_Next (Last_Keep_Arg));\n                end loop;\n \n                Set_First_Named_Actual (N, Empty);\n@@ -3114,7 +3105,6 @@ package body Exp_Ch6 is\n                      exit when No (Temp);\n                      Set_Next_Named_Actual\n                        (Passoc, Next_Named_Actual (Parent (Temp)));\n-                     Delete_Tree (Temp);\n                   end loop;\n                end;\n             end if;\n@@ -3359,9 +3349,7 @@ package body Exp_Ch6 is\n                --  use a qualified expression, because an aggregate is not a\n                --  legal argument of a conversion.\n \n-               if Nkind (Expression (N)) = N_Aggregate\n-                 or else Nkind (Expression (N)) = N_Null\n-               then\n+               if Nkind_In (Expression (N), N_Aggregate, N_Null) then\n                   Ret :=\n                     Make_Qualified_Expression (Sloc (N),\n                        Subtype_Mark => New_Occurrence_Of (Ret_Type, Sloc (N)),\n@@ -3724,10 +3712,10 @@ package body Exp_Ch6 is\n              and then Formal_Is_Used_Once (F))\n \n            or else\n-             ((Nkind (A) = N_Real_Literal    or else\n-               Nkind (A) = N_Integer_Literal or else\n-               Nkind (A) = N_Character_Literal)\n-              and then not Address_Taken (F))\n+             (Nkind_In (A, N_Real_Literal,\n+                            N_Integer_Literal,\n+                            N_Character_Literal)\n+                and then not Address_Taken (F))\n          then\n             if Etype (F) /= Etype (A) then\n                Set_Renamed_Object\n@@ -3944,190 +3932,8 @@ package body Exp_Ch6 is\n    ----------------------------\n \n    procedure Expand_N_Function_Call (N : Node_Id) is\n-      Typ   : constant Entity_Id := Etype (N);\n-\n-      function Returned_By_Reference return Boolean;\n-      --  If the return type is returned through the secondary stack; that is\n-      --  by reference, we don't want to create a temp to force stack checking.\n-      --  ???\"sec stack\" is not right -- Ada 95 return-by-reference object are\n-      --  returned wherever they are.\n-      --  Shouldn't this function be moved to exp_util???\n-\n-      function Rhs_Of_Assign_Or_Decl (N : Node_Id) return Boolean;\n-      --  If the call is the right side of an assignment or the expression in\n-      --  an object declaration, we don't need to create a temp as the left\n-      --  side will already trigger stack checking if necessary.\n-      --\n-      --  If the call is a component in an extension aggregate, it will be\n-      --  expanded into assignments as well, so no temporary is needed. This\n-      --  also solves the problem of functions returning types with unknown\n-      --  discriminants, where it is not possible to declare an object of the\n-      --  type altogether.\n-\n-      ---------------------------\n-      -- Returned_By_Reference --\n-      ---------------------------\n-\n-      function Returned_By_Reference return Boolean is\n-         S : Entity_Id;\n-\n-      begin\n-         if Is_Inherently_Limited_Type (Typ) then\n-            return True;\n-\n-         elsif Nkind (Parent (N)) /= N_Simple_Return_Statement then\n-            return False;\n-\n-         elsif Requires_Transient_Scope (Typ) then\n-\n-            --  Verify that the return type of the enclosing function has the\n-            --  same constrained status as that of the expression.\n-\n-            S := Current_Scope;\n-            while Ekind (S) /= E_Function loop\n-               S := Scope (S);\n-            end loop;\n-\n-            return Is_Constrained (Typ) = Is_Constrained (Etype (S));\n-         else\n-            return False;\n-         end if;\n-      end Returned_By_Reference;\n-\n-      ---------------------------\n-      -- Rhs_Of_Assign_Or_Decl --\n-      ---------------------------\n-\n-      function Rhs_Of_Assign_Or_Decl (N : Node_Id) return Boolean is\n-      begin\n-         if (Nkind (Parent (N)) = N_Assignment_Statement\n-               and then Expression (Parent (N)) = N)\n-           or else\n-             (Nkind (Parent (N)) = N_Qualified_Expression\n-                and then Nkind (Parent (Parent (N))) = N_Assignment_Statement\n-                  and then Expression (Parent (Parent (N))) = Parent (N))\n-           or else\n-             (Nkind (Parent (N)) = N_Object_Declaration\n-                and then Expression (Parent (N)) = N)\n-           or else\n-             (Nkind (Parent (N)) = N_Component_Association\n-                and then Expression (Parent (N)) = N\n-                  and then Nkind (Parent (Parent (N))) = N_Aggregate\n-                    and then Rhs_Of_Assign_Or_Decl (Parent (Parent (N))))\n-           or else\n-             (Nkind (Parent (N)) = N_Extension_Aggregate\n-               and then Is_Private_Type (Etype (Typ)))\n-         then\n-            return True;\n-         else\n-            return False;\n-         end if;\n-      end Rhs_Of_Assign_Or_Decl;\n-\n-   --  Start of processing for Expand_N_Function_Call\n-\n    begin\n-      --  A special check. If stack checking is enabled, and the return type\n-      --  might generate a large temporary, and the call is not the right side\n-      --  of an assignment, then generate an explicit temporary. We do this\n-      --  because otherwise gigi may generate a large temporary on the fly and\n-      --  this can cause trouble with stack checking.\n-\n-      --  This is unnecessary if the call is the expression in an object\n-      --  declaration, or if it appears outside of any library unit. This can\n-      --  only happen if it appears as an actual in a library-level instance,\n-      --  in which case a temporary will be generated for it once the instance\n-      --  itself is installed.\n-\n-      if May_Generate_Large_Temp (Typ)\n-        and then not Rhs_Of_Assign_Or_Decl (N)\n-        and then not Returned_By_Reference\n-        and then Current_Scope /= Standard_Standard\n-      then\n-         if Stack_Checking_Enabled then\n-\n-            --  Note: it might be thought that it would be OK to use a call to\n-            --  Force_Evaluation here, but that's not good enough, because\n-            --  that can results in a 'Reference construct that may still need\n-            --  a temporary.\n-\n-            declare\n-               Loc      : constant Source_Ptr := Sloc (N);\n-               Temp_Obj : constant Entity_Id :=\n-                            Make_Defining_Identifier (Loc,\n-                              Chars => New_Internal_Name ('F'));\n-               Temp_Typ : Entity_Id := Typ;\n-               Decl     : Node_Id;\n-               A        : Node_Id;\n-               F        : Entity_Id;\n-               Proc     : Entity_Id;\n-\n-            begin\n-               if Is_Tagged_Type (Typ)\n-                 and then Present (Controlling_Argument (N))\n-               then\n-                  if Nkind (Parent (N)) /= N_Procedure_Call_Statement\n-                    and then Nkind (Parent (N)) /= N_Function_Call\n-                  then\n-                     --  If this is a tag-indeterminate call, the object must\n-                     --  be classwide.\n-\n-                     if Is_Tag_Indeterminate (N) then\n-                        Temp_Typ := Class_Wide_Type (Typ);\n-                     end if;\n-\n-                  else\n-                     --  If this is a dispatching call that is itself the\n-                     --  controlling argument of an enclosing call, the\n-                     --  nominal subtype of the object that replaces it must\n-                     --  be classwide, so that dispatching will take place\n-                     --  properly. If it is not a controlling argument, the\n-                     --  object is not classwide.\n-\n-                     Proc := Entity (Name (Parent (N)));\n-\n-                     F := First_Formal (Proc);\n-                     A := First_Actual (Parent (N));\n-                     while A /= N loop\n-                        Next_Formal (F);\n-                        Next_Actual (A);\n-                     end loop;\n-\n-                     if Is_Controlling_Formal (F) then\n-                        Temp_Typ := Class_Wide_Type (Typ);\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp_Obj,\n-                   Object_Definition   => New_Occurrence_Of (Temp_Typ, Loc),\n-                   Constant_Present    => True,\n-                   Expression          => Relocate_Node (N));\n-               Set_Assignment_OK (Decl);\n-\n-               Insert_Actions (N, New_List (Decl));\n-               Rewrite (N, New_Occurrence_Of (Temp_Obj, Loc));\n-            end;\n-\n-         else\n-            --  If stack-checking is not enabled, increment serial number\n-            --  for internal names, so that subsequent symbols are consistent\n-            --  with and without stack-checking.\n-\n-            Synchronize_Serial_Number;\n-\n-            --  Now we can expand the call with consistent symbol names\n-\n-            Expand_Call (N);\n-         end if;\n-\n-      --  Normal case, expand the call\n-\n-      else\n-         Expand_Call (N);\n-      end if;\n+      Expand_Call (N);\n    end Expand_N_Function_Call;\n \n    ---------------------------------------\n@@ -4881,8 +4687,8 @@ package body Exp_Ch6 is\n       --  Step past qualification or unchecked conversion (the latter can occur\n       --  in cases of calls to 'Input).\n \n-      if Nkind (Exp_Node) = N_Qualified_Expression\n-        or else Nkind (Exp_Node) = N_Unchecked_Type_Conversion\n+      if Nkind_In\n+           (Exp_Node, N_Qualified_Expression, N_Unchecked_Type_Conversion)\n       then\n          Exp_Node := Expression (N);\n       end if;\n@@ -4908,8 +4714,8 @@ package body Exp_Ch6 is\n \n    function Is_Build_In_Place_Function_Return (N : Node_Id) return Boolean is\n    begin\n-      if Nkind (N) = N_Simple_Return_Statement\n-        or else Nkind (N) = N_Extended_Return_Statement\n+      if Nkind_In (N, N_Simple_Return_Statement,\n+                      N_Extended_Return_Statement)\n       then\n          return Is_Build_In_Place_Function\n                   (Return_Applies_To (Return_Statement_Entity (N)));\n@@ -4962,10 +4768,11 @@ package body Exp_Ch6 is\n          while Present (Iface_DT_Ptr)\n             and then Ekind (Node (Iface_DT_Ptr)) = E_Constant\n          loop\n+            pragma Assert (Has_Thunks (Node (Iface_DT_Ptr)));\n             Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n             if Present (Thunk_Code) then\n-               Insert_Actions (N, New_List (\n+               Insert_Actions_After (N, New_List (\n                  Thunk_Code,\n \n                  Build_Set_Predefined_Prim_Op_Address (Loc,\n@@ -4974,9 +4781,21 @@ package body Exp_Ch6 is\n                    Address_Node =>\n                      Make_Attribute_Reference (Loc,\n                        Prefix         => New_Reference_To (Thunk_Id, Loc),\n+                       Attribute_Name => Name_Address)),\n+\n+                 Build_Set_Predefined_Prim_Op_Address (Loc,\n+                   Tag_Node => New_Reference_To\n+                                 (Node (Next_Elmt (Iface_DT_Ptr)), Loc),\n+                   Position => DT_Position (Prim),\n+                   Address_Node =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         => New_Reference_To (Prim, Loc),\n                        Attribute_Name => Name_Address))));\n             end if;\n \n+            Next_Elmt (Iface_DT_Ptr);\n+            pragma Assert (not Has_Thunks (Node (Iface_DT_Ptr)));\n+\n             Next_Elmt (Iface_DT_Ptr);\n          end loop;\n       end Register_Predefined_DT_Entry;\n@@ -4985,6 +4804,8 @@ package body Exp_Ch6 is\n \n       Subp : constant Entity_Id := Entity (N);\n \n+   --  Start of processing for Freeze_Subprogram\n+\n    begin\n       --  We suppress the initialization of the dispatch table entry when\n       --  VM_Target because the dispatching mechanism is handled internally\n@@ -5088,8 +4909,9 @@ package body Exp_Ch6 is\n       --  Step past qualification or unchecked conversion (the latter can occur\n       --  in cases of calls to 'Input).\n \n-      if Nkind (Func_Call) = N_Qualified_Expression\n-        or else Nkind (Func_Call) = N_Unchecked_Type_Conversion\n+      if Nkind_In (Func_Call,\n+                   N_Qualified_Expression,\n+                   N_Unchecked_Type_Conversion)\n       then\n          Func_Call := Expression (Func_Call);\n       end if;\n@@ -5241,8 +5063,8 @@ package body Exp_Ch6 is\n       --  Step past qualification or unchecked conversion (the latter can occur\n       --  in cases of calls to 'Input).\n \n-      if Nkind (Func_Call) = N_Qualified_Expression\n-        or else Nkind (Func_Call) = N_Unchecked_Type_Conversion\n+      if Nkind_In (Func_Call, N_Qualified_Expression,\n+                              N_Unchecked_Type_Conversion)\n       then\n          Func_Call := Expression (Func_Call);\n       end if;\n@@ -5369,8 +5191,8 @@ package body Exp_Ch6 is\n       --  Step past qualification or unchecked conversion (the latter can occur\n       --  in cases of calls to 'Input).\n \n-      if Nkind (Func_Call) = N_Qualified_Expression\n-        or else Nkind (Func_Call) = N_Unchecked_Type_Conversion\n+      if Nkind_In (Func_Call, N_Qualified_Expression,\n+                              N_Unchecked_Type_Conversion)\n       then\n          Func_Call := Expression (Func_Call);\n       end if;\n@@ -5491,8 +5313,8 @@ package body Exp_Ch6 is\n       --  Step past qualification or unchecked conversion (the latter can occur\n       --  in cases of calls to 'Input).\n \n-      if Nkind (Func_Call) = N_Qualified_Expression\n-        or else Nkind (Func_Call) = N_Unchecked_Type_Conversion\n+      if Nkind_In (Func_Call, N_Qualified_Expression,\n+                              N_Unchecked_Type_Conversion)\n       then\n          Func_Call := Expression (Func_Call);\n       end if;"}, {"sha": "f3b9ee2f199b30530de17fd69c0d522869f2012b", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -1327,7 +1327,7 @@ package body Exp_Util is\n \n    function Find_Interface_ADT\n      (T     : Entity_Id;\n-      Iface : Entity_Id) return Entity_Id\n+      Iface : Entity_Id) return Elmt_Id\n    is\n       ADT   : Elmt_Id;\n       Found : Boolean   := False;\n@@ -1384,6 +1384,7 @@ package body Exp_Util is\n                   return;\n                end if;\n \n+               Next_Elmt (ADT);\n                Next_Elmt (ADT);\n                Next_Elmt (AI_Elmt);\n             end loop;\n@@ -1423,7 +1424,7 @@ package body Exp_Util is\n       pragma Assert (Present (Node (ADT)));\n       Find_Secondary_Table (Typ);\n       pragma Assert (Found);\n-      return Node (ADT);\n+      return ADT;\n    end Find_Interface_ADT;\n \n    ------------------------\n@@ -2336,14 +2337,31 @@ package body Exp_Util is\n \n             when N_And_Then | N_Or_Else =>\n                if N = Right_Opnd (P) then\n+\n+                  --  We are now going to either append the actions to the\n+                  --  actions field of the short-circuit operation. We will\n+                  --  also analyze the actions now.\n+\n+                  --  This analysis is really too early, the proper thing would\n+                  --  be to just park them there now, and only analyze them if\n+                  --  we find we really need them, and to it at the proper\n+                  --  final insertion point. However attempting to this proved\n+                  --  tricky, so for now we just kill current values before and\n+                  --  after the analyze call to make sure we avoid peculiar\n+                  --  optimizations from this out of order insertion.\n+\n+                  Kill_Current_Values;\n+\n                   if Present (Actions (P)) then\n                      Insert_List_After_And_Analyze\n-                      (Last (Actions (P)), Ins_Actions);\n+                       (Last (Actions (P)), Ins_Actions);\n                   else\n                      Set_Actions (P, Ins_Actions);\n                      Analyze_List (Actions (P));\n                   end if;\n \n+                  Kill_Current_Values;\n+\n                   return;\n                end if;\n \n@@ -2985,11 +3003,12 @@ package body Exp_Util is\n            or else TSS_Name  = TSS_Deep_Adjust\n            or else TSS_Name  = TSS_Deep_Finalize\n            or else (Ada_Version >= Ada_05\n-             and then (Chars (E) = Name_uDisp_Asynchronous_Select\n-               or else Chars (E) = Name_uDisp_Conditional_Select\n-               or else Chars (E) = Name_uDisp_Get_Prim_Op_Kind\n-               or else Chars (E) = Name_uDisp_Get_Task_Id\n-               or else Chars (E) = Name_uDisp_Timed_Select))\n+                      and then (Chars (E) = Name_uDisp_Asynchronous_Select\n+                        or else Chars (E) = Name_uDisp_Conditional_Select\n+                        or else Chars (E) = Name_uDisp_Get_Prim_Op_Kind\n+                        or else Chars (E) = Name_uDisp_Get_Task_Id\n+                        or else Chars (E) = Name_uDisp_Requeue\n+                        or else Chars (E) = Name_uDisp_Timed_Select))\n          then\n             return True;\n          end if;\n@@ -3459,8 +3478,6 @@ package body Exp_Util is\n          elsif Nkind (N) in N_Generic_Instantiation then\n             Remove_Dead_Instance (N);\n          end if;\n-\n-         Delete_Tree (N);\n       end if;\n    end Kill_Dead_Code;\n \n@@ -3472,11 +3489,11 @@ package body Exp_Util is\n    begin\n       W := Warn;\n       if Is_Non_Empty_List (L) then\n-         loop\n-            N := Remove_Head (L);\n-            exit when No (N);\n+         N := First (L);\n+         while Present (N) loop\n             Kill_Dead_Code (N, W);\n             W := False;\n+            Next (N);\n          end loop;\n       end if;\n    end Kill_Dead_Code;"}, {"sha": "42c8d2ab8f35683cb23161cdb95b5d136b692965", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -338,9 +338,10 @@ package Exp_Util is\n \n    function Find_Interface_ADT\n      (T     : Entity_Id;\n-      Iface : Entity_Id) return Entity_Id;\n+      Iface : Entity_Id) return Elmt_Id;\n    --  Ada 2005 (AI-251): Given a type T implementing the interface Iface,\n-   --  return the Access_Disp_Table value of the interface.\n+   --  return the element of Access_Disp_Table containing the tag of the\n+   --  interface.\n \n    function Find_Interface_Tag\n      (T     : Entity_Id;\n@@ -483,16 +484,16 @@ package Exp_Util is\n    --  or is a private type whose completion is such a type.\n \n    procedure Kill_Dead_Code (N : Node_Id; Warn : Boolean := False);\n-   --  N represents a node for a section of code that is known to be dead. The\n-   --  node is deleted, and any exception handler references and warning\n-   --  messages relating to this code are removed. If Warn is True, a warning\n-   --  will be output at the start of N indicating the deletion of the code.\n+   --  N represents a node for a section of code that is known to be dead. Any\n+   --  exception handler references and warning messages relating to this code\n+   --  are removed. If Warn is True, a warning will be output at the start of N\n+   --  indicating the deletion of the code. Note that the tree for the deleted\n+   --  code is left intact so that e.g. cross-reference data is still valid.\n \n    procedure Kill_Dead_Code (L : List_Id; Warn : Boolean := False);\n    --  Like the above procedure, but applies to every element in the given\n-   --  list. Each of the entries is removed from the list before killing it.\n-   --  If Warn is True, a warning will be output at the start of N indicating\n-   --  the deletion of the code.\n+   --  list. If Warn is True, a warning will be output at the start of N\n+   --  indicating the deletion of the code.\n \n    function Known_Non_Negative (Opnd : Node_Id) return Boolean;\n    --  Given a node for a subexpression, determines if it represents a value"}, {"sha": "b75226e6ee52ef4ef28eceebadfcc6e7675a82dd", "filename": "gcc/ada/nlists.adb", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fnlists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fnlists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.adb?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -279,22 +279,6 @@ package body Nlists is\n       Append (Node, To);\n    end Append_To;\n \n-   -----------------\n-   -- Delete_List --\n-   -----------------\n-\n-   procedure Delete_List (L : List_Id) is\n-      N : Node_Id;\n-\n-   begin\n-      while Is_Non_Empty_List (L) loop\n-         N := Remove_Head (L);\n-         Delete_Tree (N);\n-      end loop;\n-\n-      --  Should recycle list header???\n-   end Delete_List;\n-\n    -----------\n    -- First --\n    -----------\n@@ -315,7 +299,6 @@ package body Nlists is\n \n    function First_Non_Pragma (List : List_Id) return Node_Id is\n       N : constant Node_Id := First (List);\n-\n    begin\n       if Nkind (N) /= N_Pragma\n            and then\n@@ -649,7 +632,6 @@ package body Nlists is\n \n    function Last_Non_Pragma (List : List_Id) return Node_Id is\n       N : constant Node_Id := Last (List);\n-\n    begin\n       if Nkind (N) /= N_Pragma then\n          return N;"}, {"sha": "77ae55a567941c1dd49c9c03292fa72f5158cf5e", "filename": "gcc/ada/nlists.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fnlists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fnlists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.ads?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -333,9 +333,6 @@ package Nlists is\n    --  These functions return the addresses of the Next_Node and Prev_Node\n    --  tables (used in Back_End for Gigi).\n \n-   procedure Delete_List (L : List_Id);\n-   --  Removes all elements of the given list, and calls Delete_Tree on each\n-\n    function p (U : Union_Id) return Node_Id;\n    --  This function is intended for use from the debugger, it determines\n    --  whether U is a Node_Id or List_Id, and calls the appropriate Parent"}, {"sha": "0db6d20a2ba1b407796e558593b3450156eef352", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -463,8 +463,6 @@ package body Ch4 is\n                   Style.Check_Attribute_Name (False);\n                end if;\n \n-               Delete_Node (Token_Node);\n-\n             --  Here for case of attribute designator is not an identifier\n \n             else"}, {"sha": "11f24ce3c6c6909c11c25d5ea0f15286e0e7e70b", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -592,9 +592,9 @@ package body Sem_Ch7 is\n                   --  the flag for outer level entities that are not\n                   --  imported/exported, and which have no interface name.\n \n-                  elsif K = N_Object_Declaration\n-                    or else K = N_Exception_Declaration\n-                    or else K = N_Subprogram_Declaration\n+                  elsif Nkind_In (K, N_Object_Declaration,\n+                                     N_Exception_Declaration,\n+                                     N_Subprogram_Declaration)\n                   then\n                      E := Defining_Entity (D);\n \n@@ -844,8 +844,8 @@ package body Sem_Ch7 is\n          then\n             Generate_Reference (Id, Scope (Id), 'k', False);\n \n-         elsif Nkind (Unit (Cunit (Main_Unit))) /= N_Subprogram_Body\n-           and then Nkind (Unit (Cunit (Main_Unit))) /= N_Subunit\n+         elsif not Nkind_In (Unit (Cunit (Main_Unit)), N_Subprogram_Body,\n+                                                       N_Subunit)\n          then\n             --  If current unit is an ancestor of main unit, generate\n             --  a reference to its own parent.\n@@ -909,16 +909,16 @@ package body Sem_Ch7 is\n             --  with a known_discriminant_part whose full view is an\n             --  Unchecked_Union.\n \n-            if (Nkind (Decl) = N_Incomplete_Type_Declaration\n-                  or else\n-                Nkind (Decl) = N_Private_Type_Declaration)\n+            if Nkind_In (Decl, N_Incomplete_Type_Declaration,\n+                               N_Private_Type_Declaration)\n               and then Has_Discriminants (Defining_Identifier (Decl))\n               and then Present (Full_View (Defining_Identifier (Decl)))\n-              and then Is_Unchecked_Union\n-                (Full_View (Defining_Identifier (Decl)))\n+              and then\n+                Is_Unchecked_Union (Full_View (Defining_Identifier (Decl)))\n             then\n-               Error_Msg_N (\"completion of discriminated partial view\" &\n-                 \" cannot be an Unchecked_Union\",\n+               Error_Msg_N\n+                 (\"completion of discriminated partial view \"\n+                  & \"cannot be an Unchecked_Union\",\n                  Full_View (Defining_Identifier (Decl)));\n             end if;\n \n@@ -942,8 +942,8 @@ package body Sem_Ch7 is\n          while Present (Gen_Par) and then Is_Child_Unit (Gen_Par) loop\n             Inst_Node := Get_Package_Instantiation_Node (Inst_Par);\n \n-            if (Nkind (Inst_Node) = N_Package_Instantiation\n-                  or else Nkind (Inst_Node) = N_Formal_Package_Declaration)\n+            if Nkind_In (Inst_Node, N_Package_Instantiation,\n+                                    N_Formal_Package_Declaration)\n               and then Nkind (Name (Inst_Node)) = N_Expanded_Name\n             then\n                Inst_Par := Entity (Prefix (Name (Inst_Node)));"}, {"sha": "2baa94b7d3a825b2623b0ebb952523439ef39e33", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -2192,6 +2192,14 @@ package body Sinfo is\n       return List2 (N);\n    end Pragma_Argument_Associations;\n \n+   function Pragma_Identifier\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      return Node4 (N);\n+   end Pragma_Identifier;\n+\n    function Pragmas_After\n       (N : Node_Id) return List_Id is\n    begin\n@@ -4915,6 +4923,14 @@ package body Sinfo is\n       Set_List2_With_Parent (N, Val);\n    end Set_Pragma_Argument_Associations;\n \n+   procedure Set_Pragma_Identifier\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Node4_With_Parent (N, Val);\n+   end Set_Pragma_Identifier;\n+\n    procedure Set_Pragmas_After\n       (N : Node_Id; Val : List_Id) is\n    begin\n@@ -5558,4 +5574,120 @@ package body Sinfo is\n         UI_From_Int (Int (S) - Int (Sloc (N))));\n    end Set_End_Location;\n \n+   --------------------------------\n+   -- Node_Kind Membership Tests --\n+   --------------------------------\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2;\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3;\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4;\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4 or else\n+             T = V5;\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind;\n+      V6 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4 or else\n+             T = V5 or else\n+             T = V6;\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind;\n+      V6 : Node_Kind;\n+      V7 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4 or else\n+             T = V5 or else\n+             T = V6 or else\n+             T = V7;\n+   end Nkind_In;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind;\n+      V6 : Node_Kind;\n+      V7 : Node_Kind;\n+      V8 : Node_Kind) return Boolean\n+   is\n+   begin\n+      return T = V1 or else\n+             T = V2 or else\n+             T = V3 or else\n+             T = V4 or else\n+             T = V5 or else\n+             T = V6 or else\n+             T = V7 or else\n+             T = V8;\n+   end Nkind_In;\n+\n end Sinfo;"}, {"sha": "d1f201767688b66e57cb5d35929c12660f608a31", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 127, "deletions": 31, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac4d64074400613b205bba2e6d21272b4c648bc5/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=ac4d64074400613b205bba2e6d21272b4c648bc5", "patch": "@@ -549,9 +549,11 @@ package Sinfo is\n \n    --  Acts_As_Spec (Flag4-Sem)\n    --    A flag set in the N_Subprogram_Body node for a subprogram body which\n-   --    is acting as its own spec. This flag also appears in the compilation\n-   --    unit node at the library level for such a subprogram (see further\n-   --    description in spec of Lib package).\n+   --    is acting as its own spec, except in the case of a library level\n+   --    subprogram, in which case the flag is set on the parent compilation\n+   --    unit node instead (see further description in spec of Lib package).\n+   --    ??? Above note about Lib is dubious since lib.ads does not mention\n+   --    Acts_As_Spec at all.\n \n    --  Actual_Designated_Subtype (Node4-Sem)\n    --    Present in N_Free_Statement and N_Explicit_Dereference nodes. If gigi\n@@ -907,27 +909,36 @@ package Sinfo is\n    --    processing of the variant part of a record type.\n \n    --  Entity (Node4-Sem)\n-   --    Appears in all direct names (identifier, character literal, operator\n-   --    symbol), as well as expanded names, and attributes that denote\n-   --    entities, such as 'Class. Points to the entity for the corresponding\n-   --    defining occurrence. Set after name resolution. In the case of\n-   --    identifiers in a WITH list, the corresponding defining occurrence is\n-   --    in a separately compiled file, and this pointer must be set using the\n-   --    library Load procedure. Note that during name resolution, the value in\n-   --    Entity may be temporarily incorrect (e.g. during overload resolution,\n-   --    Entity is initially set to the first possible correct interpretation,\n-   --    and then later modified if necessary to contain the correct value\n-   --    after resolution). Note that this field overlaps Associated_Node,\n-   --    which is used during generic processing (see Sem_Ch12 for details).\n-   --    Note also that in generic templates, this means that the Entity field\n-   --    does not always point to an Entity. Since the back end is expected to\n-   --    ignore generic templates, this is harmless. Note that this field also\n-   --    appears in N_Attribute_Definition_Clause nodes. It is used only for\n-   --    stream attributes definition clauses. In this case, it denotes a\n-   --    (possibly dummy) subprogram entity that is conceptually declared at\n-   --    the point of the clause. Thus the visibility of the attribute\n-   --    definition clause (in the sense of 8.3(23) as amended by AI-195) can\n-   --    be checked by testing the visibility of that subprogram.\n+   --    Appears in all direct names (identifiers, character literals, and\n+   --    operator symbols), as well as expanded names, and attributes that\n+   --    denote entities, such as 'Class. Points to entity for corresponding\n+   --    defining occurrence. Set after name resolution. For identifiers in a\n+   --    WITH list, the corresponding defining occurrence is in a separately\n+   --    compiled file, and Entity must be set by the library Load procedure.\n+   --\n+   --    Note: During name resolution, the value in Entity may be temporarily\n+   --    incorrect (e.g. during overload resolution, Entity is initially set to\n+   --    the first possible correct interpretation, and then later modified if\n+   --    necessary to contain the correct value after resolution).\n+   --\n+   --    Note: This field overlaps Associated_Node, which is used during\n+   --    generic processing (see Sem_Ch12 for details). Note also that in\n+   --    generic templates, this means that the Entity field does not always\n+   --    point to an Entity. Since the back end is expected to ignore generic\n+   --    templates, this is harmless.\n+   --\n+   --    Note: This field also appears in N_Attribute_Definition_Clause nodes.\n+   --    It is used only for stream attributes definition clauses. In this\n+   --    case, it denotes a (possibly dummy) subprogram entity that is declared\n+   --    conceptually at the point of the clause. Thus the visibility of the\n+   --    attribute definition clause (in the sense of 8.3(23) as amended by\n+   --    AI-195) can be checked by testing the visibility of that subprogram.\n+   --\n+   --    Note: Normally the Entity field of an identifier points to the entity\n+   --    for the corresponding defining identifier, and hence the Chars field\n+   --    of an identifier will match the Chars field of the entity. However,\n+   --    there is no requirement that these match, and there are obscure cases\n+   --    of generated code where they do not match.\n \n    --  Entity_Or_Associated_Node (Node4-Sem)\n    --    A synonym for both Entity and Associated_Node. Used by convention in\n@@ -1070,7 +1081,7 @@ package Sinfo is\n    --    in the non-generic package case if it determines that no elaboration\n    --    code is generated. Note that this flag is not related to the\n    --    Is_Preelaborated status, there can be preelaborated packages that\n-   --    generate elaboration code, and non- preelaborated packages which do\n+   --    generate elaboration code, and non-preelaborated packages which do\n    --    not generate elaboration code.\n \n    --  Has_Priority_Pragma (Flag6-Sem)\n@@ -1864,17 +1875,25 @@ package Sinfo is\n       --  which are explicitly documented.\n \n       --  N_Pragma\n-      --  Sloc points to PRAGMA\n+      --  Sloc points to pragma identifier\n       --  Chars (Name1) identifier name from pragma identifier\n       --  Pragma_Argument_Associations (List2) (set to No_List if none)\n       --  Debug_Statement (Node3) (set to Empty if not Debug, Assert)\n+      --  Pragma_Identifier (Node4)\n       --  Next_Rep_Item (Node5-Sem)\n \n       --  Note: we should have a section on what pragmas are passed on to\n       --  the back end to be processed. This section should note that pragma\n       --  Psect_Object is always converted to Common_Object, but there are\n       --  undoubtedly many other similar notes required ???\n \n+      --  Note: we don't really need the Chars field, since it can trivially\n+      --  be obtained as Chars (Pragma_Identifier (Node)). However, it is\n+      --  convenient to have this directly available, and historically the\n+      --  Chars field has been around for ever, whereas the Pragma_Identifier\n+      --  field was added much later (when we found the need to be able to get\n+      --  the Sloc of the pragma identifier).\n+\n       --------------------------------------\n       -- 2.8  Pragma Argument Association --\n       --------------------------------------\n@@ -3232,9 +3251,9 @@ package Sinfo is\n       --    component_SELECTOR_NAME {| component_SELECTOR_NAME}\n       --  | others\n \n-      --  The entries of a component choice list appear in the Choices list\n-      --  of the associated N_Component_Association, as either selector\n-      --  names, or as an N_Others_Choice node.\n+      --  The entries of a component choice list appear in the Choices list of\n+      --  the associated N_Component_Association, as either selector names, or\n+      --  as an N_Others_Choice node.\n \n       --------------------------------\n       -- 4.3.2  Extension Aggregate --\n@@ -7385,7 +7404,7 @@ package Sinfo is\n \n    subtype N_Unit_Body is Node_Kind range\n      N_Package_Body ..\n-     N_Subprogram_Body;\n+       N_Subprogram_Body;\n \n    ---------------------------\n    -- Node Access Functions --\n@@ -8071,6 +8090,9 @@ package Sinfo is\n    function Pragma_Argument_Associations\n      (N : Node_Id) return List_Id;    -- List2\n \n+   function Pragma_Identifier\n+     (N : Node_Id) return Node_Id;    -- Node4\n+\n    function Pragmas_After\n      (N : Node_Id) return List_Id;    -- List5\n \n@@ -8935,6 +8957,9 @@ package Sinfo is\n    procedure Set_Pragma_Argument_Associations\n      (N : Node_Id; Val : List_Id);            -- List2\n \n+   procedure Set_Pragma_Identifier\n+     (N : Node_Id; Val : Node_Id);            -- Node4\n+\n    procedure Set_Pragmas_After\n      (N : Node_Id; Val : List_Id);            -- List5\n \n@@ -9144,6 +9169,75 @@ package Sinfo is\n    --  other words, End_Span is set to the difference between S and\n    --  Sloc (N), the starting location.\n \n+   --------------------------------\n+   -- Node_Kind Membership Tests --\n+   --------------------------------\n+\n+   --  The following functions allow a convenient notation for testing wheter\n+   --  a Node_Kind value matches any one of a list of possible values. In each\n+   --  case True is returned if the given T argument is equal to any of the V\n+   --  arguments. Note that there is a similar set of functions defined in\n+   --  Atree where the first argument is a Node_Id whose Nkind field is tested.\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind) return Boolean;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind) return Boolean;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind) return Boolean;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind) return Boolean;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind;\n+      V6 : Node_Kind) return Boolean;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind;\n+      V6 : Node_Kind;\n+      V7 : Node_Kind) return Boolean;\n+\n+   function Nkind_In\n+     (T  : Node_Kind;\n+      V1 : Node_Kind;\n+      V2 : Node_Kind;\n+      V3 : Node_Kind;\n+      V4 : Node_Kind;\n+      V5 : Node_Kind;\n+      V6 : Node_Kind;\n+      V7 : Node_Kind;\n+      V8 : Node_Kind) return Boolean;\n+\n+   pragma Inline (Nkind_In);\n+   --  Inline all above functions\n+\n    -----------------------------\n    -- Syntactic Parent Tables --\n    -----------------------------\n@@ -9198,7 +9292,7 @@ package Sinfo is\n        (1 => True,    --  Chars (Name1)\n         2 => True,    --  Pragma_Argument_Associations (List2)\n         3 => True,    --  Debug_Statement (Node3)\n-        4 => False,   --  Entity (Node4-Sem)\n+        4 => True,    --  Pragma_Identifier (Node4)\n         5 => False),  --  Next_Rep_Item (Node5-Sem)\n \n      N_Pragma_Argument_Association =>\n@@ -10912,6 +11006,7 @@ package Sinfo is\n    pragma Inline (Parent_Spec);\n    pragma Inline (Position);\n    pragma Inline (Pragma_Argument_Associations);\n+   pragma Inline (Pragma_Identifier);\n    pragma Inline (Pragmas_After);\n    pragma Inline (Pragmas_Before);\n    pragma Inline (Prefix);\n@@ -11196,6 +11291,7 @@ package Sinfo is\n    pragma Inline (Set_Parent_Spec);\n    pragma Inline (Set_Position);\n    pragma Inline (Set_Pragma_Argument_Associations);\n+   pragma Inline (Set_Pragma_Identifier);\n    pragma Inline (Set_Pragmas_After);\n    pragma Inline (Set_Pragmas_Before);\n    pragma Inline (Set_Prefix);"}]}