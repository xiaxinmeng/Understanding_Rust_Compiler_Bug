{"sha": "a38e0142a8424e5d53b673ecaaa2976982a84834", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM4ZTAxNDJhODQyNGU1ZDUzYjY3M2VjYWFhMjk3Njk4MmE4NDgzNA==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-05-23T20:03:00Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-05-23T20:03:00Z"}, "message": "Fix up MIPS16 hard float and add support for complex.\n\n2007-05-23  Sandra Loosemore  <sandra@codesourcery.com>\n\t    Nigel Stephens  <nigel@mips.com>\n\t    Richard Sandiford  <richard@codesourcery.com>\n\n\tgcc/\n\tFix up MIPS16 hard float and add support for complex.\n\n\t* config/mips/mips.h (TARGET_HARD_FLOAT_ABI): New.\n\t(TARGET_SOFT_FLOAT_ABI): New.\n\t(TARGET_CPU_CPP_BUILTINS): Define __mips_hard_float and\n\t__mips_soft_float to reflect the ABI in use, not whether the\n\tFPU is directly accessible (e.g., in MIPS16 mode).\n\t(UNITS_PER_HWFPVALUE): Use TARGET_SOFT_FLOAT_ABI.\n\t(UNITS_PER_FPVALUE): Likewise.\n\n\t* config/mips/mips.c (mips_expand_call): Remove redundant\n\tTARGET_MIPS16 check.\n\t(mips_arg_regno): New.\n\t(function_arg_advance): When setting bits in cum->fp_code for\n\tMIPS16, don't subtract 1 from cum->arg_number, since it is now\n\tzero-based.\n\t(function_arg): Use mips_arg_regno.\n\t(mips_return_mode_in_fpr_p): New.\n\t(mips16_call_stub_mode_suffix): New.\n\t(mips16_cfun_returns_in_fpr_p): New.\n\t(mips_save_reg_p): Use mips16_cfun_returns_in_fpr_p.\n\t(mips_output_function_prologue): Test mips16_hard_float, not\n\t!TARGET_SOFT_FLOAT, to decide when a function stub is required.\n\t(mips_expand_epilogue): Call MIPS16 helper routines to copy\n\treturn value into a floating-point register.\n\t(mips_can_use_return_insn): Use mips16_cfun_returns_in_fpr_p.\n\t(mips_function_value): Rewrite to use mips_return_mode_in_fpr_p.\n\t(mips16_fp_args): Handle MIPS32r2 ISA which supports\n\tTARGET_FLOAT64, and use mfhc1/mthc1 to copy the most significant\n\tword of double arguments from or to the high bits of 64-bit\n\tfloating point registers.\n\t(build_mips16_function_stub): Fill in DECL_RESULT for stubdecl.\n\t(mips16_fpret_double): New helper function.\n\t(build_mips16_call_stub): Use mips16_return_mode_in_fpr_p.  Add\n\tsupport for complex modes.  Fill in DECL_RESULT for stubdecl.\n\t(mips_init_libfuncs): Remove redundant TARGET_MIPS16 check.\n\n\t* config/mips/mips16.S \n\t(RET, ARG1, ARG2): New.\n\t(MERGE_GPRf, MERGE_GPRt): New.\n\t(DELAYt, DELAYf): New.\n\t(MOVE_SF_BYTE0, MOVE_SI_BYTE0): New.\n\t(MOVE_SF_BYTE4, MOVE_SF_BYTE8): New.\n\t(MOVE_DF_BYTE0, MOVE_DF_BYTE8): New.\n\t(MOVE_SF_RET, MOVE_SC_RET, MOVE_DF_RET, MOVE_DC_RET, MOVE_SI_RET): New.\n\t(SFOP): Renamed to...\n\t(OPSF3): This, and macro-ified.  Updated all uses.\n\t(SFOP2): Renamed to...\n\t(OPSF2): This, and macro-ified.  Updated all uses.\n\t(SFCMP): Renamed to...\n\t(CMPSF): This, and macro-ified.  Updated all uses.\n\t(SFREVCMP): Renamed to...\n\t(REVCMPSF): This, and macro-ified.  Updated all uses.\n\t(__mips16_floatsisf, __mips16_fix_truncsfsi): Macro-ified.\n\t(LDDBL1, LDDBL2, RETDBL): Deleted.\n\t(DFOP): Renamed to...\n\t(OPDF3): This, and macro-ified.  Updated all uses.\n\t(DFOP2): Renamed to...\n\t(OPDF2): This, and macro-ified.  Updated all uses.\n\t(__mips16_extendsfdf2, __mips16_truncdfsf2): Macro-ified.\n\t(DFCMP): Renamed to...\n\t(CMPDF): This, and macro-ified.  Updated all uses.\n\t(DFREVCMP): Renamed to...\n\t(REVCMPDF): This, and macro-ified.  Updated all uses.\n\t(__mips16_floatsidf, __mips16_fix_truncdfsi): Macro-ified.\n\t(RET_FUNCTION): New.\n\t(__mips16_ret_sf, __mips16_ret_df): Macro-ified.\n\t(__mips16_ret_sc, __mips16_ret_dc): New.\n\t(STUB_ARGS_0, STUB_ARGS_1, STUB_ARGS_5, STUB_ARGS_9, STUB_ARGS_2,\n\tSTUB_ARGS_6, STUB_ARGS_10): New.\n\t(CALL_STUB_NO_RET): New.\n\t(__mips16_call_stub_1): Macro-ified.\n\t(__mips16_call_stub_5): Macro-ified.\n\t(__mips16_call_stub_2): Macro-ified.\n\t(__mips16_call_stub_6): Macro-ified.\n\t(__mips16_call_stub_9): Macro-ified.\n\t(__mips16_call_stub_10): Macro-ified.\n\t(CALL_STUB_RET): New.\n\t(__mips16_call_stub_sf_0): Macro-ified.\n\t(__mips16_call_stub_sf_1): Macro-ified.\n\t(__mips16_call_stub_sf_5): Macro-ified.\n\t(__mips16_call_stub_sf_2): Macro-ified.\n\t(__mips16_call_stub_sf_6): Macro-ified.\n\t(__mips16_call_stub_sf_9): Macro-ified.\n\t(__mips16_call_stub_sf_10): Macro-ified.\n\t(__mips16_call_stub_df_0): Macro-ified.\n\t(__mips16_call_stub_df_1): Macro-ified.\n\t(__mips16_call_stub_df_5): Macro-ified.\n\t(__mips16_call_stub_df_2): Macro-ified.\n\t(__mips16_call_stub_df_6): Macro-ified.\n\t(__mips16_call_stub_df_9): Macro-ified.\n\t(__mips16_call_stub_df_10): Macro-ified.\n\t(__mips16_call_stub_sc_0): New.\n\t(__mips16_call_stub_sc_1): New.\n\t(__mips16_call_stub_sc_5): New.\n\t(__mips16_call_stub_sc_2): New.\n\t(__mips16_call_stub_sc_6): New.\n\t(__mips16_call_stub_sc_9): New.\n\t(__mips16_call_stub_sc_10): New.\n\t(__mips16_call_stub_dc_0): New.\n\t(__mips16_call_stub_dc_1): New.\n\t(__mips16_call_stub_dc_5): New.\n\t(__mips16_call_stub_dc_2): New.\n\t(__mips16_call_stub_dc_6): New.\n\t(__mips16_call_stub_dc_9): New.\n\t(__mips16_call_stub_dc_10): New.\n\t\n\t* config/mips/t-elf (LIB1ASMFUNCS): Add MIPS16 floating-point stubs.\n\t* config/mips/t-isa3264 (LIB1ASMFUNCS): Likewise.\n\t* config/mips/t-r2900 (LIB1ASMFUNCS): Likewise.\n\n\tgcc/testsuite/\n\t* gcc.target/mips/inter/mips16_stubs_1_main.c: New.\n\t* gcc.target/mips/inter/mips16_stubs_1_x.c: New.\n\t* gcc.target/mips/inter/mips16_stubs_1_y.c: New.\n\t* gcc.target/mips/inter/mips16-inter.exp: New.\n\n\nCo-Authored-By: Nigel Stephens <nigel@mips.com>\nCo-Authored-By: Richard Sandiford <richard@codesourcery.com>\n\nFrom-SVN: r124999", "tree": {"sha": "cd02dcb528cfcda488ff2971a284e216d7dbe59b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd02dcb528cfcda488ff2971a284e216d7dbe59b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a38e0142a8424e5d53b673ecaaa2976982a84834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38e0142a8424e5d53b673ecaaa2976982a84834", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a38e0142a8424e5d53b673ecaaa2976982a84834", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a38e0142a8424e5d53b673ecaaa2976982a84834/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70c1e0331bd30847a68d7eb2a8a4fd1e5463ea57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70c1e0331bd30847a68d7eb2a8a4fd1e5463ea57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70c1e0331bd30847a68d7eb2a8a4fd1e5463ea57"}], "stats": {"total": 1695, "additions": 1140, "deletions": 555}, "files": [{"sha": "414b1eb377196c1df282d395d25c9e97e0e06640", "filename": "gcc/ChangeLog", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -1,3 +1,118 @@\n+2007-05-23  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Nigel Stephens  <nigel@mips.com>\n+\t    Richard Sandiford  <richard@codesourcery.com>\n+\n+\tFix up MIPS16 hard float and add support for complex.\n+\n+\t* config/mips/mips.h (TARGET_HARD_FLOAT_ABI): New.\n+\t(TARGET_SOFT_FLOAT_ABI): New.\n+\t(TARGET_CPU_CPP_BUILTINS): Define __mips_hard_float and\n+\t__mips_soft_float to reflect the ABI in use, not whether the\n+\tFPU is directly accessible (e.g., in MIPS16 mode).\n+\t(UNITS_PER_HWFPVALUE): Use TARGET_SOFT_FLOAT_ABI.\n+\t(UNITS_PER_FPVALUE): Likewise.\n+\n+\t* config/mips/mips.c (mips_expand_call): Remove redundant\n+\tTARGET_MIPS16 check.\n+\t(mips_arg_regno): New.\n+\t(function_arg_advance): When setting bits in cum->fp_code for\n+\tMIPS16, don't subtract 1 from cum->arg_number, since it is now\n+\tzero-based.\n+\t(function_arg): Use mips_arg_regno.\n+\t(mips_return_mode_in_fpr_p): New.\n+\t(mips16_call_stub_mode_suffix): New.\n+\t(mips16_cfun_returns_in_fpr_p): New.\n+\t(mips_save_reg_p): Use mips16_cfun_returns_in_fpr_p.\n+\t(mips_output_function_prologue): Test mips16_hard_float, not\n+\t!TARGET_SOFT_FLOAT, to decide when a function stub is required.\n+\t(mips_expand_epilogue): Call MIPS16 helper routines to copy\n+\treturn value into a floating-point register.\n+\t(mips_can_use_return_insn): Use mips16_cfun_returns_in_fpr_p.\n+\t(mips_function_value): Rewrite to use mips_return_mode_in_fpr_p.\n+\t(mips16_fp_args): Handle MIPS32r2 ISA which supports\n+\tTARGET_FLOAT64, and use mfhc1/mthc1 to copy the most significant\n+\tword of double arguments from or to the high bits of 64-bit\n+\tfloating point registers.\n+\t(build_mips16_function_stub): Fill in DECL_RESULT for stubdecl.\n+\t(mips16_fpret_double): New helper function.\n+\t(build_mips16_call_stub): Use mips16_return_mode_in_fpr_p.  Add\n+\tsupport for complex modes.  Fill in DECL_RESULT for stubdecl.\n+\t(mips_init_libfuncs): Remove redundant TARGET_MIPS16 check.\n+\n+\t* config/mips/mips16.S \n+\t(RET, ARG1, ARG2): New.\n+\t(MERGE_GPRf, MERGE_GPRt): New.\n+\t(DELAYt, DELAYf): New.\n+\t(MOVE_SF_BYTE0, MOVE_SI_BYTE0): New.\n+\t(MOVE_SF_BYTE4, MOVE_SF_BYTE8): New.\n+\t(MOVE_DF_BYTE0, MOVE_DF_BYTE8): New.\n+\t(MOVE_SF_RET, MOVE_SC_RET, MOVE_DF_RET, MOVE_DC_RET, MOVE_SI_RET): New.\n+\t(SFOP): Renamed to...\n+\t(OPSF3): This, and macro-ified.  Updated all uses.\n+\t(SFOP2): Renamed to...\n+\t(OPSF2): This, and macro-ified.  Updated all uses.\n+\t(SFCMP): Renamed to...\n+\t(CMPSF): This, and macro-ified.  Updated all uses.\n+\t(SFREVCMP): Renamed to...\n+\t(REVCMPSF): This, and macro-ified.  Updated all uses.\n+\t(__mips16_floatsisf, __mips16_fix_truncsfsi): Macro-ified.\n+\t(LDDBL1, LDDBL2, RETDBL): Deleted.\n+\t(DFOP): Renamed to...\n+\t(OPDF3): This, and macro-ified.  Updated all uses.\n+\t(DFOP2): Renamed to...\n+\t(OPDF2): This, and macro-ified.  Updated all uses.\n+\t(__mips16_extendsfdf2, __mips16_truncdfsf2): Macro-ified.\n+\t(DFCMP): Renamed to...\n+\t(CMPDF): This, and macro-ified.  Updated all uses.\n+\t(DFREVCMP): Renamed to...\n+\t(REVCMPDF): This, and macro-ified.  Updated all uses.\n+\t(__mips16_floatsidf, __mips16_fix_truncdfsi): Macro-ified.\n+\t(RET_FUNCTION): New.\n+\t(__mips16_ret_sf, __mips16_ret_df): Macro-ified.\n+\t(__mips16_ret_sc, __mips16_ret_dc): New.\n+\t(STUB_ARGS_0, STUB_ARGS_1, STUB_ARGS_5, STUB_ARGS_9, STUB_ARGS_2,\n+\tSTUB_ARGS_6, STUB_ARGS_10): New.\n+\t(CALL_STUB_NO_RET): New.\n+\t(__mips16_call_stub_1): Macro-ified.\n+\t(__mips16_call_stub_5): Macro-ified.\n+\t(__mips16_call_stub_2): Macro-ified.\n+\t(__mips16_call_stub_6): Macro-ified.\n+\t(__mips16_call_stub_9): Macro-ified.\n+\t(__mips16_call_stub_10): Macro-ified.\n+\t(CALL_STUB_RET): New.\n+\t(__mips16_call_stub_sf_0): Macro-ified.\n+\t(__mips16_call_stub_sf_1): Macro-ified.\n+\t(__mips16_call_stub_sf_5): Macro-ified.\n+\t(__mips16_call_stub_sf_2): Macro-ified.\n+\t(__mips16_call_stub_sf_6): Macro-ified.\n+\t(__mips16_call_stub_sf_9): Macro-ified.\n+\t(__mips16_call_stub_sf_10): Macro-ified.\n+\t(__mips16_call_stub_df_0): Macro-ified.\n+\t(__mips16_call_stub_df_1): Macro-ified.\n+\t(__mips16_call_stub_df_5): Macro-ified.\n+\t(__mips16_call_stub_df_2): Macro-ified.\n+\t(__mips16_call_stub_df_6): Macro-ified.\n+\t(__mips16_call_stub_df_9): Macro-ified.\n+\t(__mips16_call_stub_df_10): Macro-ified.\n+\t(__mips16_call_stub_sc_0): New.\n+\t(__mips16_call_stub_sc_1): New.\n+\t(__mips16_call_stub_sc_5): New.\n+\t(__mips16_call_stub_sc_2): New.\n+\t(__mips16_call_stub_sc_6): New.\n+\t(__mips16_call_stub_sc_9): New.\n+\t(__mips16_call_stub_sc_10): New.\n+\t(__mips16_call_stub_dc_0): New.\n+\t(__mips16_call_stub_dc_1): New.\n+\t(__mips16_call_stub_dc_5): New.\n+\t(__mips16_call_stub_dc_2): New.\n+\t(__mips16_call_stub_dc_6): New.\n+\t(__mips16_call_stub_dc_9): New.\n+\t(__mips16_call_stub_dc_10): New.\n+\t\n+\t* config/mips/t-elf (LIB1ASMFUNCS): Add MIPS16 floating-point stubs.\n+\t* config/mips/t-isa3264 (LIB1ASMFUNCS): Likewise.\n+\t* config/mips/t-r2900 (LIB1ASMFUNCS): Likewise.\n+\n 2007-05-23  Ian Lance Taylor  <iant@google.com>\n \n \t* doc/invoke.texi (Invoking GCC): Document that the order of the"}, {"sha": "07b5b78a6b598aed1cd3dbaa1604b6c851d967ce", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 230, "deletions": 93, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -3490,8 +3490,7 @@ mips_expand_call (rtx result, rtx addr, rtx args_size, rtx aux, int sibcall_p)\n       mips_load_call_address (addr, orig_addr, sibcall_p);\n     }\n \n-  if (TARGET_MIPS16\n-      && mips16_hard_float\n+  if (mips16_hard_float\n       && build_mips16_call_stub (result, addr, args_size,\n \t\t\t\t aux == 0 ? 0 : (int) GET_MODE (aux)))\n     return;\n@@ -3878,6 +3877,24 @@ mips_arg_info (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n }\n \n \n+/* INFO describes an argument that is passed in a single-register value.\n+   Return the register it uses, assuming that FPRs are available if\n+   HARD_FLOAT_P.  */\n+\n+static unsigned int\n+mips_arg_regno (const struct mips_arg_info *info, bool hard_float_p)\n+{\n+  if (!info->fpr_p || !hard_float_p)\n+    return GP_ARG_FIRST + info->reg_offset;\n+  else if (mips_abi == ABI_32 && TARGET_DOUBLE_FLOAT && info->reg_offset > 0)\n+    /* In o32, the second argument is always passed in $f14\n+       for TARGET_DOUBLE_FLOAT, regardless of whether the\n+       first argument was a word or doubleword.  */\n+    return FP_ARG_FIRST + 2;\n+  else\n+    return FP_ARG_FIRST + info->reg_offset;\n+}\n+\n /* Implement FUNCTION_ARG_ADVANCE.  */\n \n void\n@@ -3895,7 +3912,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n      for an explanation of what this code does.  It assumes the O32\n      ABI, which passes at most 2 arguments in float registers.  */\n   if (cum->arg_number < 2 && info.fpr_p)\n-    cum->fp_code += (mode == SFmode ? 1 : 2) << ((cum->arg_number - 1) * 2);\n+    cum->fp_code += (mode == SFmode ? 1 : 2) << (cum->arg_number * 2);\n \n   if (mips_abi != ABI_EABI || !info.fpr_p)\n     cum->num_gprs = info.reg_offset + info.reg_words;\n@@ -4032,15 +4049,7 @@ function_arg (const CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t}\n     }\n \n-  if (!info.fpr_p)\n-    return gen_rtx_REG (mode, GP_ARG_FIRST + info.reg_offset);\n-  else if (mips_abi == ABI_32 && TARGET_DOUBLE_FLOAT && info.reg_offset > 0)\n-    /* In o32, the second argument is always passed in $f14\n-       for TARGET_DOUBLE_FLOAT, regardless of whether the\n-       first argument was a word or doubleword.  */\n-    return gen_rtx_REG (mode, FP_ARG_FIRST + 2);\n-  else\n-    return gen_rtx_REG (mode, FP_ARG_FIRST + info.reg_offset);\n+  return gen_rtx_REG (mode, mips_arg_regno (&info, TARGET_HARD_FLOAT));\n }\n \n \n@@ -6303,6 +6312,51 @@ mips_global_pointer (void)\n }\n \n \n+/* Return true if the function return value MODE will get returned in a\n+   floating-point register.  */\n+\n+static bool\n+mips_return_mode_in_fpr_p (enum machine_mode mode)\n+{\n+  return ((GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t   || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT\n+\t   || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+\t  && GET_MODE_UNIT_SIZE (mode) <= UNITS_PER_HWFPVALUE);\n+}\n+\n+/* Return a two-character string representing a function floating-point\n+   return mode, used to name MIPS16 function stubs.  */\n+\n+static const char *\n+mips16_call_stub_mode_suffix (enum machine_mode mode)\n+{\n+  if (mode == SFmode)\n+    return \"sf\";\n+  else if (mode == DFmode)\n+    return \"df\";\n+  else if (mode == SCmode)\n+    return \"sc\";\n+  else if (mode == DCmode)\n+    return \"dc\";\n+  else if (mode == V2SFmode)\n+    return \"df\";\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Return true if the current function returns its value in a floating-point\n+   register in MIPS16 mode.  */\n+\n+static bool\n+mips16_cfun_returns_in_fpr_p (void)\n+{\n+  tree return_type = DECL_RESULT (current_function_decl);\n+  return (mips16_hard_float\n+\t  && !aggregate_value_p (return_type, current_function_decl)\n+ \t  && mips_return_mode_in_fpr_p (DECL_MODE (return_type)));\n+}\n+\n+\n /* Return true if the current function must save REGNO.  */\n \n static bool\n@@ -6337,10 +6391,6 @@ mips_save_reg_p (unsigned int regno)\n \n   if (TARGET_MIPS16)\n     {\n-      tree return_type;\n-\n-      return_type = DECL_RESULT (current_function_decl);\n-\n       /* $18 is a special case in mips16 code.  It may be used to call\n \t a function which returns a floating point value, but it is\n \t marked in call_used_regs.  */\n@@ -6351,10 +6401,7 @@ mips_save_reg_p (unsigned int regno)\n \t value into the floating point registers if the return value is\n \t floating point.  */\n       if (regno == GP_REG_FIRST + 31\n-\t  && mips16_hard_float\n-\t  && !aggregate_value_p (return_type, current_function_decl)\n-\t  && GET_MODE_CLASS (DECL_MODE (return_type)) == MODE_FLOAT\n-\t  && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE)\n+\t  && mips16_cfun_returns_in_fpr_p ())\n \treturn true;\n     }\n \n@@ -6739,7 +6786,7 @@ mips_output_function_prologue (FILE *file, HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n      floating point arguments.  The linker will arrange for any 32-bit\n      functions to call this stub, which will then jump to the 16-bit\n      function proper.  */\n-  if (TARGET_MIPS16 && !TARGET_SOFT_FLOAT\n+  if (mips16_hard_float\n       && current_function_args_info.fp_code != 0)\n     build_mips16_function_stub (file);\n \n@@ -7069,6 +7116,33 @@ mips_expand_epilogue (int sibcall_p)\n       emit_jump_insn (gen_return ());\n       return;\n     }\n+  \n+  /* In mips16 mode, if the return value should go into a floating-point\n+     register, we need to call a helper routine to copy it over.  */\n+  if (mips16_cfun_returns_in_fpr_p ())\n+    {\n+      char *name;\n+      rtx func;\n+      rtx insn;\n+      rtx retval;\n+      rtx call;\n+      tree id;\n+      tree return_type;\n+      enum machine_mode return_mode;\n+\n+      return_type = DECL_RESULT (current_function_decl);\n+      return_mode = DECL_MODE (return_type);\n+\n+      name = ACONCAT ((\"__mips16_ret_\",\n+\t\t       mips16_call_stub_mode_suffix (return_mode),\n+\t\t       NULL));\n+      id = get_identifier (name);\n+      func = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));\n+      retval = gen_rtx_REG (return_mode, GP_RETURN);\n+      call = gen_call_value_internal (retval, func, const0_rtx);\n+      insn = emit_call_insn (call);\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), retval);\n+    }\n \n   /* Split the frame into two.  STEP1 is the amount of stack we should\n      deallocate before restoring the registers.  STEP2 is the amount we\n@@ -7175,24 +7249,16 @@ mips_expand_epilogue (int sibcall_p)\n int\n mips_can_use_return_insn (void)\n {\n-  tree return_type;\n-\n   if (! reload_completed)\n     return 0;\n \n   if (regs_ever_live[31] || current_function_profile)\n     return 0;\n \n-  return_type = DECL_RESULT (current_function_decl);\n-\n-  /* In mips16 mode, a function which returns a floating point value\n+  /* In mips16 mode, a function that returns a floating point value\n      needs to arrange to copy the return value into the floating point\n      registers.  */\n-  if (TARGET_MIPS16\n-      && mips16_hard_float\n-      && ! aggregate_value_p (return_type, current_function_decl)\n-      && GET_MODE_CLASS (DECL_MODE (return_type)) == MODE_FLOAT\n-      && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE)\n+  if (mips16_cfun_returns_in_fpr_p ())\n     return 0;\n \n   if (cfun->machine->frame.initialized)\n@@ -7617,23 +7683,25 @@ mips_function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n \treturn gen_rtx_REG (mode, GP_RETURN);\n     }\n \n-  if ((GET_MODE_CLASS (mode) == MODE_FLOAT\n-       || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n-      && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE)\n-    return gen_rtx_REG (mode, FP_RETURN);\n-\n-  /* Handle long doubles for n32 & n64.  */\n-  if (mode == TFmode)\n-    return mips_return_fpr_pair (mode,\n-\t\t\t\t DImode, 0,\n-\t\t\t\t DImode, GET_MODE_SIZE (mode) / 2);\n+  if (!TARGET_MIPS16)\n+    {\n+      /* Handle long doubles for n32 & n64.  */\n+      if (mode == TFmode)\n+\treturn mips_return_fpr_pair (mode,\n+\t\t\t\t     DImode, 0,\n+\t\t\t\t     DImode, GET_MODE_SIZE (mode) / 2);\n \n-  if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-      && GET_MODE_SIZE (mode) <= UNITS_PER_HWFPVALUE * 2)\n-    return mips_return_fpr_pair (mode,\n-\t\t\t\t GET_MODE_INNER (mode), 0,\n-\t\t\t\t GET_MODE_INNER (mode),\n-\t\t\t\t GET_MODE_SIZE (mode) / 2);\n+      if (mips_return_mode_in_fpr_p (mode))\n+\t{\n+\t  if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n+\t    return mips_return_fpr_pair (mode,\n+\t\t\t\t\t GET_MODE_INNER (mode), 0,\n+\t\t\t\t\t GET_MODE_INNER (mode),\n+\t\t\t\t\t GET_MODE_SIZE (mode) / 2);\n+\t  else\n+\t    return gen_rtx_REG (mode, FP_RETURN);\n+\t}\n+    }\n \n   return gen_rtx_REG (mode, GP_RETURN);\n }\n@@ -7978,6 +8046,7 @@ mips16_fp_args (FILE *file, int fp_code, int from_fp_p)\n   const char *s;\n   int gparg, fparg;\n   unsigned int f;\n+  CUMULATIVE_ARGS cum;\n \n   /* This code only works for the original 32-bit ABI and the O64 ABI.  */\n   gcc_assert (TARGET_OLDABI);\n@@ -7986,43 +8055,50 @@ mips16_fp_args (FILE *file, int fp_code, int from_fp_p)\n     s = \"mfc1\";\n   else\n     s = \"mtc1\";\n-  gparg = GP_ARG_FIRST;\n-  fparg = FP_ARG_FIRST;\n+\n+  init_cumulative_args (&cum, NULL, NULL);\n+\n   for (f = (unsigned int) fp_code; f != 0; f >>= 2)\n     {\n+      enum machine_mode mode;\n+      struct mips_arg_info info;\n+\n       if ((f & 3) == 1)\n-\t{\n-\t  if ((fparg & 1) != 0)\n-\t    ++fparg;\n-\t  fprintf (file, \"\\t%s\\t%s,%s\\n\", s,\n-\t\t   reg_names[gparg], reg_names[fparg]);\n-\t}\n+\tmode = SFmode;\n       else if ((f & 3) == 2)\n-\t{\n-\t  if (TARGET_64BIT)\n-\t    fprintf (file, \"\\td%s\\t%s,%s\\n\", s,\n-\t\t     reg_names[gparg], reg_names[fparg]);\n-\t  else\n-\t    {\n-\t      if ((fparg & 1) != 0)\n-\t\t++fparg;\n-\t      if (TARGET_BIG_ENDIAN)\n-\t\tfprintf (file, \"\\t%s\\t%s,%s\\n\\t%s\\t%s,%s\\n\", s,\n-\t\t\t reg_names[gparg], reg_names[fparg + 1], s,\n-\t\t\t reg_names[gparg + 1], reg_names[fparg]);\n-\t      else\n-\t\tfprintf (file, \"\\t%s\\t%s,%s\\n\\t%s\\t%s,%s\\n\", s,\n-\t\t\t reg_names[gparg], reg_names[fparg], s,\n-\t\t\t reg_names[gparg + 1], reg_names[fparg + 1]);\n-\t      ++gparg;\n-\t      ++fparg;\n-\t    }\n-\t}\n+\tmode = DFmode;\n       else\n \tgcc_unreachable ();\n \n-      ++gparg;\n-      ++fparg;\n+      mips_arg_info (&cum, mode, NULL, true, &info);\n+      gparg = mips_arg_regno (&info, false);\n+      fparg = mips_arg_regno (&info, true);\n+\n+      if (mode == SFmode)\n+\tfprintf (file, \"\\t%s\\t%s,%s\\n\", s,\n+\t\t reg_names[gparg], reg_names[fparg]);\n+      else if (TARGET_64BIT)\n+\tfprintf (file, \"\\td%s\\t%s,%s\\n\", s,\n+\t\t reg_names[gparg], reg_names[fparg]);\n+      else if (ISA_HAS_MXHC1)\n+\t/* -mips32r2 -mfp64 */\n+\tfprintf (file, \"\\t%s\\t%s,%s\\n\\t%s\\t%s,%s\\n\", \n+\t\t s,\n+\t\t reg_names[gparg + (WORDS_BIG_ENDIAN ? 1 : 0)],\n+\t\t reg_names[fparg],\n+\t\t from_fp_p ? \"mfhc1\" : \"mthc1\",\n+\t\t reg_names[gparg + (WORDS_BIG_ENDIAN ? 0 : 1)],\n+\t\t reg_names[fparg]);\n+      else if (TARGET_BIG_ENDIAN)\n+\tfprintf (file, \"\\t%s\\t%s,%s\\n\\t%s\\t%s,%s\\n\", s,\n+\t\t reg_names[gparg], reg_names[fparg + 1], s,\n+\t\t reg_names[gparg + 1], reg_names[fparg]);\n+      else\n+\tfprintf (file, \"\\t%s\\t%s,%s\\n\\t%s\\t%s,%s\\n\", s,\n+\t\t reg_names[gparg], reg_names[fparg], s,\n+\t\t reg_names[gparg + 1], reg_names[fparg + 1]);\n+\n+      function_arg_advance (&cum, mode, NULL, true);\n     }\n }\n \n@@ -8049,6 +8125,7 @@ build_mips16_function_stub (FILE *file)\n   stubdecl = build_decl (FUNCTION_DECL, stubid,\n \t\t\t build_function_type (void_type_node, NULL_TREE));\n   DECL_SECTION_NAME (stubdecl) = build_string (strlen (secname), secname);\n+  DECL_RESULT (stubdecl) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n \n   fprintf (file, \"\\t# Stub function for %s (\", current_function_name ());\n   need_comma = 0;\n@@ -8122,6 +8199,47 @@ struct mips16_stub\n \n static struct mips16_stub *mips16_stubs;\n \n+/* Emit code to return a double value from a mips16 stub.  GPREG is the\n+   first GP reg to use, FPREG is the first FP reg to use.  */\n+\n+static void\n+mips16_fpret_double (int gpreg, int fpreg)\n+{\n+  if (TARGET_64BIT)\n+    fprintf (asm_out_file, \"\\tdmfc1\\t%s,%s\\n\",\n+ \t     reg_names[gpreg], reg_names[fpreg]);\n+  else if (TARGET_FLOAT64)\n+    {\n+      fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n+ \t       reg_names[gpreg + WORDS_BIG_ENDIAN],\n+ \t       reg_names[fpreg]);\n+      fprintf (asm_out_file, \"\\tmfhc1\\t%s,%s\\n\",\n+ \t       reg_names[gpreg + !WORDS_BIG_ENDIAN],\n+ \t       reg_names[fpreg]);\n+    }\n+  else\n+    {\n+      if (TARGET_BIG_ENDIAN)\n+ \t{\n+ \t  fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n+ \t\t   reg_names[gpreg + 0],\n+ \t\t   reg_names[fpreg + 1]);\n+ \t  fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n+ \t\t   reg_names[gpreg + 1],\n+ \t\t   reg_names[fpreg + 0]);\n+ \t}\n+      else\n+ \t{\n+\t  fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n+\t\t   reg_names[gpreg + 0],\n+ \t\t   reg_names[fpreg + 0]);\n+ \t  fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n+ \t\t   reg_names[gpreg + 1],\n+ \t\t   reg_names[fpreg + 1]);\n+ \t}\n+    }\n+}\n+\n /* Build a call stub for a mips16 call.  A stub is needed if we are\n    passing any floating point values which should go into the floating\n    point registers.  If we are, and the call turns out to be to a\n@@ -8143,7 +8261,7 @@ static struct mips16_stub *mips16_stubs;\n int\n build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n {\n-  int fpret;\n+  int fpret = 0;\n   const char *fnname;\n   char *secname, *stubname;\n   struct mips16_stub *l;\n@@ -8153,14 +8271,13 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \n   /* We don't need to do anything if we aren't in mips16 mode, or if\n      we were invoked with the -msoft-float option.  */\n-  if (! TARGET_MIPS16 || ! mips16_hard_float)\n+  if (!mips16_hard_float)\n     return 0;\n \n   /* Figure out whether the value might come back in a floating point\n      register.  */\n-  fpret = (retval != 0\n-\t   && GET_MODE_CLASS (GET_MODE (retval)) == MODE_FLOAT\n-\t   && GET_MODE_SIZE (GET_MODE (retval)) <= UNITS_PER_FPVALUE);\n+  if (retval)\n+    fpret = mips_return_mode_in_fpr_p (GET_MODE (retval));\n \n   /* We don't need to do anything if there were no floating point\n      arguments and the value will not be returned in a floating point\n@@ -8178,11 +8295,6 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n      require more sophisticated support.  */\n   gcc_assert (TARGET_OLDABI);\n \n-  /* We can only handle SFmode and DFmode floating point return\n-     values.  */\n-  if (fpret)\n-    gcc_assert (GET_MODE (retval) == SFmode || GET_MODE (retval) == DFmode);\n-\n   /* If we're calling via a function pointer, then we must always call\n      via a stub.  There are magic stubs provided in libgcc.a for each\n      of the required cases.  Each of them expects the function address\n@@ -8197,11 +8309,14 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n       /* ??? If this code is modified to support other ABI's, we need\n          to handle PARALLEL return values here.  */\n \n-      sprintf (buf, \"__mips16_call_stub_%s%d\",\n-\t       (fpret\n-\t\t? (GET_MODE (retval) == SFmode ? \"sf_\" : \"df_\")\n-\t\t: \"\"),\n-\t       fp_code);\n+      if (fpret)\n+\tsprintf (buf, \"__mips16_call_stub_%s_%d\",\n+\t\t mips16_call_stub_mode_suffix (GET_MODE (retval)),\n+\t\t fp_code);\n+      else\n+\tsprintf (buf, \"__mips16_call_stub_%d\",\n+\t\t fp_code);\n+\n       id = get_identifier (buf);\n       stub_fn = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (id));\n \n@@ -8277,6 +8392,7 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n       stubdecl = build_decl (FUNCTION_DECL, stubid,\n \t\t\t     build_function_type (void_type_node, NULL_TREE));\n       DECL_SECTION_NAME (stubdecl) = build_string (strlen (secname), secname);\n+      DECL_RESULT (stubdecl) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n \n       fprintf (asm_out_file, \"\\t# Stub function to call %s%s (\",\n \t       (fpret\n@@ -8339,6 +8455,27 @@ build_mips16_call_stub (rtx retval, rtx fn, rtx arg_size, int fp_code)\n \t  if (GET_MODE (retval) == SFmode)\n \t    fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n \t\t     reg_names[GP_REG_FIRST + 2], reg_names[FP_REG_FIRST + 0]);\n+ \t  else if (GET_MODE (retval) == SCmode)\n+ \t    {\n+ \t      fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n+ \t\t       reg_names[GP_REG_FIRST + 2],\n+\t\t       reg_names[FP_REG_FIRST + 0]);\n+ \t      fprintf (asm_out_file, \"\\tmfc1\\t%s,%s\\n\",\n+ \t\t       reg_names[GP_REG_FIRST + 3],\n+\t\t       reg_names[FP_REG_FIRST + MAX_FPRS_PER_FMT]);\n+ \t    }\n+ \t  else if (GET_MODE (retval) == DFmode\n+\t\t   || GET_MODE (retval) == V2SFmode)\n+ \t    {\n+ \t      mips16_fpret_double (GP_REG_FIRST + 2, FP_REG_FIRST + 0);\n+ \t    }\n+ \t  else if (GET_MODE (retval) == DCmode)\n+\t    {\n+ \t      mips16_fpret_double (GP_REG_FIRST + 2,\n+\t\t\t\t   FP_REG_FIRST + 0);\n+ \t      mips16_fpret_double (GP_REG_FIRST + 4,\n+\t\t\t\t   FP_REG_FIRST + MAX_FPRS_PER_FMT);\n+ \t    }\n \t  else\n \t    {\n \t      if (TARGET_BIG_ENDIAN)\n@@ -9190,7 +9327,7 @@ mips_init_libfuncs (void)\n       set_optab_libfunc (smod_optab, SImode, \"__vr4120_modsi3\");\n     }\n \n-  if (TARGET_MIPS16 && mips16_hard_float)\n+  if (mips16_hard_float)\n     {\n       set_optab_libfunc (add_optab, SFmode, \"__mips16_addsf3\");\n       set_optab_libfunc (sub_optab, SFmode, \"__mips16_subsf3\");"}, {"sha": "0e90d030d3478d9c0538ab8d95b87cded38082fc", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -288,6 +288,11 @@ extern const struct mips_rtx_cost_data *mips_cost;\n #define TARGET_OLDABI\t\t    (mips_abi == ABI_32 || mips_abi == ABI_O64)\n #define TARGET_NEWABI\t\t    (mips_abi == ABI_N32 || mips_abi == ABI_64)\n \n+/* Similar to TARGET_HARD_FLOAT and TARGET_SOFT_FLOAT, but reflect the ABI\n+   in use rather than whether the FPU is directly accessible.  */\n+#define TARGET_HARD_FLOAT_ABI (TARGET_HARD_FLOAT || mips16_hard_float)\n+#define TARGET_SOFT_FLOAT_ABI (!TARGET_HARD_FLOAT_ABI)\n+\n /* IRIX specific stuff.  */\n #define TARGET_IRIX\t   0\n #define TARGET_IRIX6\t   0\n@@ -406,9 +411,11 @@ extern const struct mips_rtx_cost_data *mips_cost;\n \t  builtin_define (\"_MIPS_ISA=_MIPS_ISA_MIPS64\");\t\\\n \t}\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n-      if (TARGET_HARD_FLOAT)\t\t\t\t\t\\\n+      /* These defines reflect the ABI in use, not whether the  \\\n+\t FPU is directly accessible.  */\t\t\t\\\n+      if (TARGET_HARD_FLOAT_ABI)\t\t\t\t\\\n \tbuiltin_define (\"__mips_hard_float\");\t\t\t\\\n-      else if (TARGET_SOFT_FLOAT)\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n \tbuiltin_define (\"__mips_soft_float\");\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n       if (TARGET_SINGLE_FLOAT)\t\t\t\t\t\\\n@@ -1033,12 +1040,12 @@ extern const struct mips_rtx_cost_data *mips_cost;\n /* The largest size of value that can be held in floating-point\n    registers and moved with a single instruction.  */\n #define UNITS_PER_HWFPVALUE \\\n-  (TARGET_SOFT_FLOAT ? 0 : MAX_FPRS_PER_FMT * UNITS_PER_FPREG)\n+  (TARGET_SOFT_FLOAT_ABI ? 0 : MAX_FPRS_PER_FMT * UNITS_PER_FPREG)\n \n /* The largest size of value that can be held in floating-point\n    registers.  */\n #define UNITS_PER_FPVALUE\t\t\t\\\n-  (TARGET_SOFT_FLOAT ? 0\t\t\t\\\n+  (TARGET_SOFT_FLOAT_ABI ? 0\t\t\t\\\n    : TARGET_SINGLE_FLOAT ? UNITS_PER_FPREG\t\\\n    : LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT)\n "}, {"sha": "17e7d0e92b55313c6456b0af3e1cf333843baf4a", "filename": "gcc/config/mips/mips16.S", "status": "modified", "additions": 390, "deletions": 455, "changes": 845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Fmips16.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Fmips16.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips16.S?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -49,83 +49,218 @@ Boston, MA 02110-1301, USA.  */\n \n #define ENDFN(NAME) .end NAME\n \n-/* Single precision math.  */\n+/* ARG1\n+\tThe FPR that holds the first floating-point argument.\n \n-/* This macro defines a function which loads two single precision\n-   values, performs an operation, and returns the single precision\n-   result.  */\n+   ARG2\n+\tThe FPR that holds the second floating-point argument.\n \n-#define SFOP(NAME, OPCODE)\t\\\n+   RET\n+\tThe FPR that holds a floating-point return value.  */\n+\n+#define RET $f0\n+#define ARG1 $f12\n+#ifdef __mips64\n+#define ARG2 $f13\n+#else\n+#define ARG2 $f14\n+#endif\n+\n+/* Set 64-bit register GPR so that its high 32 bits contain HIGH_FPR\n+   and so that its low 32 bits contain LOW_FPR.  */\n+#define MERGE_GPRf(GPR, HIGH_FPR, LOW_FPR)\t\\\n+\t.set\tnoat;\t\t\t\t\\\n+\tmfc1\tGPR, HIGH_FPR;\t\t\t\\\n+\tmfc1\t$1, LOW_FPR;\t\t\t\\\n+\tdsll\tGPR, GPR, 32;\t\t\t\\\n+\tor\tGPR, GPR, $1;\t\t\t\\\n+\t.set\tat\n+\n+/* Move the high 32 bits of GPR to HIGH_FPR and the low 32 bits of\n+   GPR to LOW_FPR.  */\n+#define MERGE_GPRt(GPR, HIGH_FPR, LOW_FPR)\t\\\n+\t.set\tnoat;\t\t\t\t\\\n+\tdsrl\t$1, GPR, 32;\t\t\t\\\n+\tmtc1\tGPR, LOW_FPR;\t\t\t\\\n+\tmtc1\t$1, HIGH_FPR;\t\t\t\\\n+\t.set\tat\n+\n+/* Jump to T, and use \"OPCODE, OP2\" to implement a delayed move.  */\n+#define DELAYt(T, OPCODE, OP2)\t\t\t\\\n+\t.set\tnoreorder;\t\t\t\\\n+\tjr\tT;\t\t\t\t\\\n+\tOPCODE, OP2;\t\t\t\t\\\n+\t.set\treorder\n+\n+/* Use \"OPCODE. OP2\" and jump to T.  */\n+#define DELAYf(T, OPCODE, OP2) OPCODE, OP2; jr T\n+\n+/* MOVE_SF_BYTE0(D)\n+\tMove the first single-precision floating-point argument between\n+\tGPRs and FPRs.\n+\n+   MOVE_SI_BYTE0(D)\n+\tLikewise the first single-precision integer argument.\n+\n+   MOVE_SF_BYTE4(D)\n+\tMove the second single-precision floating-point argument between\n+\tGPRs and FPRs, given that the first argument occupies 4 bytes.\n+\n+   MOVE_SF_BYTE8(D)\n+\tMove the second single-precision floating-point argument between\n+\tGPRs and FPRs, given that the first argument occupies 8 bytes.\n+\n+   MOVE_DF_BYTE0(D)\n+\tMove the first double-precision floating-point argument between\n+\tGPRs and FPRs.\n+\n+   MOVE_DF_BYTE8(D)\n+\tLikewise the second double-precision floating-point argument.\n+\n+   MOVE_SF_RET(D, T)\n+\tLikewise a single-precision floating-point return value,\n+\tthen jump to T.\n+\n+   MOVE_SC_RET(D, T)\n+\tLikewise a complex single-precision floating-point return value.\n+\n+   MOVE_DF_RET(D, T)\n+\tLikewise a double-precision floating-point return value.\n+\n+   MOVE_DC_RET(D, T)\n+\tLikewise a complex double-precision floating-point return value.\n+\n+   MOVE_SI_RET(D, T)\n+\tLikewise a single-precision integer return value.\n+\n+   The D argument is \"t\" to move to FPRs and \"f\" to move from FPRs.\n+   The return macros may assume that the target of the jump does not\n+   use a floating-point register.  */\n+\n+#define MOVE_SF_RET(D, T) DELAY##D (T, m##D##c1 $2,$f0)\n+#define MOVE_SI_RET(D, T) DELAY##D (T, m##D##c1 $2,$f0)\n+\n+#if defined(__mips64) && defined(__MIPSEB__)\n+#define MOVE_SC_RET(D, T) MERGE_GPR##D ($2, $f0, $f1); jr T\n+#elif defined(__mips64)\n+/* The high 32 bits of $2 correspond to the second word in memory;\n+   i.e. the imaginary part.  */\n+#define MOVE_SC_RET(D, T) MERGE_GPR##D ($2, $f1, $f0); jr T\n+#elif __mips_fpr == 64\n+#define MOVE_SC_RET(D, T) m##D##c1 $2,$f0; DELAY##D (T, m##D##c1 $3,$f1)\n+#else\n+#define MOVE_SC_RET(D, T) m##D##c1 $2,$f0; DELAY##D (T, m##D##c1 $3,$f2)\n+#endif\n+\n+#if defined(__mips64)\n+#define MOVE_SF_BYTE0(D) m##D##c1 $4,$f12\n+#define MOVE_SF_BYTE4(D) m##D##c1 $5,$f13\n+#define MOVE_SF_BYTE8(D) m##D##c1 $5,$f13\n+#else\n+#define MOVE_SF_BYTE0(D) m##D##c1 $4,$f12\n+#define MOVE_SF_BYTE4(D) m##D##c1 $5,$f14\n+#define MOVE_SF_BYTE8(D) m##D##c1 $6,$f14\n+#endif\n+#define MOVE_SI_BYTE0(D) MOVE_SF_BYTE0(D)\n+\n+#if defined(__mips64)\n+#define MOVE_DF_BYTE0(D) dm##D##c1 $4,$f12\n+#define MOVE_DF_BYTE8(D) dm##D##c1 $5,$f13\n+#define MOVE_DF_RET(D, T) DELAY##D (T, dm##D##c1 $2,$f0)\n+#define MOVE_DC_RET(D, T) dm##D##c1 $3,$f1; MOVE_DF_RET (D, T)\n+#elif __mips_fpr == 64 && defined(__MIPSEB__)\n+#define MOVE_DF_BYTE0(D) m##D##c1 $5,$f12; m##D##hc1 $4,$f12\n+#define MOVE_DF_BYTE8(D) m##D##c1 $7,$f14; m##D##hc1 $6,$f14\n+#define MOVE_DF_RET(D, T) m##D##c1 $3,$f0; DELAY##D (T, m##D##hc1 $2,$f0)\n+#define MOVE_DC_RET(D, T) m##D##c1 $5,$f1; m##D##hc1 $4,$f1; MOVE_DF_RET (D, T)\n+#elif __mips_fpr == 64\n+#define MOVE_DF_BYTE0(D) m##D##c1 $4,$f12; m##D##hc1 $5,$f12\n+#define MOVE_DF_BYTE8(D) m##D##c1 $6,$f14; m##D##hc1 $7,$f14\n+#define MOVE_DF_RET(D, T) m##D##c1 $2,$f0; DELAY##D (T, m##D##hc1 $3,$f0)\n+#define MOVE_DC_RET(D, T) m##D##c1 $4,$f1; m##D##hc1 $5,$f1; MOVE_DF_RET (D, T)\n+#elif defined(__MIPSEB__)\n+/* FPRs are little-endian.  */\n+#define MOVE_DF_BYTE0(D) m##D##c1 $4,$f13; m##D##c1 $5,$f12\n+#define MOVE_DF_BYTE8(D) m##D##c1 $6,$f15; m##D##c1 $7,$f14\n+#define MOVE_DF_RET(D, T) m##D##c1 $2,$f1; DELAY##D (T, m##D##c1 $3,$f0)\n+#define MOVE_DC_RET(D, T) m##D##c1 $4,$f3; m##D##c1 $5,$f2; MOVE_DF_RET (D, T)\n+#else\n+#define MOVE_DF_BYTE0(D) m##D##c1 $4,$f12; m##D##c1 $5,$f13\n+#define MOVE_DF_BYTE8(D) m##D##c1 $6,$f14; m##D##c1 $7,$f15\n+#define MOVE_DF_RET(D, T) m##D##c1 $2,$f0; DELAY##D (T, m##D##c1 $3,$f1)\n+#define MOVE_DC_RET(D, T) m##D##c1 $4,$f2; m##D##c1 $5,$f3; MOVE_DF_RET (D, T)\n+#endif\n+\n+/* Single-precision math.  */\n+\n+/* Define a function NAME that loads two single-precision values,\n+   performs FPU operation OPCODE on them, and returns the single-\n+   precision result.  */\n+\n+#define OPSF3(NAME, OPCODE)\t\\\n STARTFN (NAME);\t\t\t\\\n-\t.set\tnoreorder;\t\\\n-\tmtc1\t$4,$f0;\t\t\\\n-\tmtc1\t$5,$f2;\t\t\\\n-\tnop;\t\t\t\\\n-\tOPCODE\t$f0,$f0,$f2;\t\\\n-\tmfc1\t$2,$f0;\t\t\\\n-\tj\t$31;\t\t\\\n-\tnop;\t\t\t\\\n-\t.set\treorder;\t\\\n+\tMOVE_SF_BYTE0 (t);\t\\\n+\tMOVE_SF_BYTE4 (t);\t\\\n+\tOPCODE\tRET,ARG1,ARG2;\t\\\n+\tMOVE_SF_RET (f, $31);\t\\\n \tENDFN (NAME)\n \n #ifdef L_m16addsf3\n-SFOP(__mips16_addsf3, add.s)\n+OPSF3 (__mips16_addsf3, add.s)\n #endif\n #ifdef L_m16subsf3\n-SFOP(__mips16_subsf3, sub.s)\n+OPSF3 (__mips16_subsf3, sub.s)\n #endif\n #ifdef L_m16mulsf3\n-SFOP(__mips16_mulsf3, mul.s)\n+OPSF3 (__mips16_mulsf3, mul.s)\n #endif\n #ifdef L_m16divsf3\n-SFOP(__mips16_divsf3, div.s)\n+OPSF3 (__mips16_divsf3, div.s)\n #endif\n \n-#define SFOP2(NAME, OPCODE)\t\\\n+/* Define a function NAME that loads a single-precision value,\n+   performs FPU operation OPCODE on it, and returns the single-\n+   precision result.  */\n+\n+#define OPSF2(NAME, OPCODE)\t\\\n STARTFN (NAME);\t\t\t\\\n-\t.set\tnoreorder;\t\\\n-\tmtc1\t$4,$f0;\t\t\\\n-\tnop;\t\t\t\\\n-\tOPCODE\t$f0,$f0;\t\\\n-\tmfc1\t$2,$f0;\t\t\\\n-\tj\t$31;\t\t\\\n-\tnop;\t\t\t\\\n-\t.set\treorder;\t\\\n+\tMOVE_SF_BYTE0 (t);\t\\\n+\tOPCODE\tRET,ARG1;\t\\\n+\tMOVE_SF_RET (f, $31);\t\\\n \tENDFN (NAME)\n \n #ifdef L_m16negsf2\n-SFOP2(__mips16_negsf2, neg.s)\n+OPSF2 (__mips16_negsf2, neg.s)\n #endif\n #ifdef L_m16abssf2\n-SFOP2(__mips16_abssf2, abs.s)\n+OPSF2 (__mips16_abssf2, abs.s)\n #endif\n \n-/* Single precision comparisons.  */\n+/* Single-precision comparisons.  */\n \n-/* This macro defines a function which loads two single precision\n-   values, performs a floating point comparison, and returns the\n-   specified values according to whether the comparison is true or\n-   false.  */\n+/* Define a function NAME that loads two single-precision values,\n+   performs floating point comparison OPCODE, and returns TRUE or\n+   FALSE depending on the result.  */\n \n-#define SFCMP(NAME, OPCODE, TRUE, FALSE)\t\\\n+#define CMPSF(NAME, OPCODE, TRUE, FALSE)\t\\\n STARTFN (NAME);\t\t\t\t\t\\\n-\tmtc1\t$4,$f0;\t\t\t\t\\\n-\tmtc1\t$5,$f2;\t\t\t\t\\\n-\tOPCODE\t$f0,$f2;\t\t\t\\\n+\tMOVE_SF_BYTE0 (t);\t\t\t\\\n+\tMOVE_SF_BYTE4 (t);\t\t\t\\\n+\tOPCODE\tARG1,ARG2;\t\t\t\\\n \tli\t$2,TRUE;\t\t\t\\\n \tbc1t\t1f;\t\t\t\t\\\n \tli\t$2,FALSE;\t\t\t\\\n 1:;\t\t\t\t\t\t\\\n \tj\t$31;\t\t\t\t\\\n \tENDFN (NAME)\n \n-/* This macro is like SFCMP, but it reverses the comparison.  */\n+/* Like CMPSF, but reverse the comparison operands.  */\n \n-#define SFREVCMP(NAME, OPCODE, TRUE, FALSE)\t\\\n+#define REVCMPSF(NAME, OPCODE, TRUE, FALSE)\t\\\n STARTFN (NAME);\t\t\t\t\t\\\n-\tmtc1\t$4,$f0;\t\t\t\t\\\n-\tmtc1\t$5,$f2;\t\t\t\t\\\n-\tOPCODE\t$f2,$f0;\t\t\t\\\n+\tMOVE_SF_BYTE0 (t);\t\t\t\\\n+\tMOVE_SF_BYTE4 (t);\t\t\t\\\n+\tOPCODE\tARG2,ARG1;\t\t\t\\\n \tli\t$2,TRUE;\t\t\t\\\n \tbc1t\t1f;\t\t\t\t\\\n \tli\t$2,FALSE;\t\t\t\\\n@@ -134,203 +269,132 @@ STARTFN (NAME);\t\t\t\t\t\\\n \tENDFN (NAME)\n \n #ifdef L_m16eqsf2\n-SFCMP(__mips16_eqsf2, c.eq.s, 0, 1)\n+CMPSF (__mips16_eqsf2, c.eq.s, 0, 1)\n #endif\n #ifdef L_m16nesf2\n-SFCMP(__mips16_nesf2, c.eq.s, 0, 1)\n+CMPSF (__mips16_nesf2, c.eq.s, 0, 1)\n #endif\n #ifdef L_m16gtsf2\n-SFREVCMP(__mips16_gtsf2, c.lt.s, 1, 0)\n+REVCMPSF (__mips16_gtsf2, c.lt.s, 1, 0)\n #endif\n #ifdef L_m16gesf2\n-SFREVCMP(__mips16_gesf2, c.le.s, 0, -1)\n+REVCMPSF (__mips16_gesf2, c.le.s, 0, -1)\n #endif\n #ifdef L_m16lesf2\n-SFCMP(__mips16_lesf2, c.le.s, 0, 1)\n+CMPSF (__mips16_lesf2, c.le.s, 0, 1)\n #endif\n #ifdef L_m16ltsf2\n-SFCMP(__mips16_ltsf2, c.lt.s, -1, 0)\n+CMPSF (__mips16_ltsf2, c.lt.s, -1, 0)\n #endif\n \n-/* Single precision conversions.  */\n+/* Single-precision conversions.  */\n \n #ifdef L_m16fltsisf\n STARTFN (__mips16_floatsisf)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f0\n-\tnop\n-\tcvt.s.w\t$f0,$f0\n-\tmfc1\t$2,$f0\n-\tj\t$31\n-\tnop\n-\t.set\treorder\n+\tMOVE_SF_BYTE0 (t)\n+\tcvt.s.w\tRET,ARG1\n+\tMOVE_SF_RET (f, $31)\n \tENDFN (__mips16_floatsisf)\n #endif\n \n #ifdef L_m16fix_truncsfsi\n STARTFN (__mips16_fix_truncsfsi)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f0\n-\tnop\n-\ttrunc.w.s $f0,$f0,$4\n-\tmfc1\t$2,$f0\n-\tj\t$31\n-\tnop\n-\t.set\treorder\n+\tMOVE_SF_BYTE0 (t)\n+\ttrunc.w.s RET,ARG1,$4\n+\tMOVE_SI_RET (f, $31)\n \tENDFN (__mips16_fix_truncsfsi)\n #endif\n \n #if !defined(__mips_single_float) && !defined(__SINGLE_FLOAT)\n \n-/* The double precision operations.  We need to use different code\n-   based on the preprocessor symbol __mips64, because the way in which\n-   double precision values will change.  Without __mips64, the value\n-   is passed in two 32-bit registers.  With __mips64, the value is\n-   passed in a single 64-bit register.  */\n+/* Double-precision math.  */\n \n-/* Load the first double precision operand.  */\n+/* Define a function NAME that loads two double-precision values,\n+   performs FPU operation OPCODE on them, and returns the double-\n+   precision result.  */\n \n-#if defined(__mips64)\n-#define LDDBL1 dmtc1 $4,$f12\n-#elif defined(__mipsfp64)\n-#define LDDBL1 sw $4,0($29); sw $5,4($29); l.d $f12,0($29)\n-#elif defined(__MIPSEB__)\n-#define LDDBL1 mtc1 $4,$f13; mtc1 $5,$f12\n-#else\n-#define LDDBL1 mtc1 $4,$f12; mtc1 $5,$f13\n-#endif\n-\n-/* Load the second double precision operand.  */\n-\n-#if defined(__mips64)\n-/* XXX this should be $6 for Algo arg passing model */\n-#define LDDBL2 dmtc1 $5,$f14\n-#elif defined(__mipsfp64)\n-#define LDDBL2 sw $6,8($29); sw $7,12($29); l.d $f14,8($29)\n-#elif defined(__MIPSEB__)\n-#define LDDBL2 mtc1 $6,$f15; mtc1 $7,$f14\n-#else\n-#define LDDBL2 mtc1 $6,$f14; mtc1 $7,$f15\n-#endif\n-\n-/* Move the double precision return value to the right place.  */\n-\n-#if defined(__mips64)\n-#define RETDBL dmfc1 $2,$f0\n-#elif defined(__mipsfp64)\n-#define RETDBL s.d $f0,0($29); lw $2,0($29); lw $3,4($29)\n-#elif defined(__MIPSEB__)\n-#define RETDBL mfc1 $2,$f1; mfc1 $3,$f0\n-#else\n-#define RETDBL mfc1 $2,$f0; mfc1 $3,$f1\n-#endif\n-\n-/* Double precision math.  */\n-\n-/* This macro defines a function which loads two double precision\n-   values, performs an operation, and returns the double precision\n-   result.  */\n-\n-#define DFOP(NAME, OPCODE)\t\\\n+#define OPDF3(NAME, OPCODE)\t\\\n STARTFN (NAME);\t\t\t\\\n-\t.set\tnoreorder;\t\\\n-\tLDDBL1;\t\t\t\\\n-\tLDDBL2;\t\t\t\\\n-\tnop;\t\t\t\\\n-\tOPCODE\t$f0,$f12,$f14;\t\\\n-\tRETDBL;\t\t\t\\\n-\tj\t$31;\t\t\\\n-\tnop;\t\t\t\\\n-\t.set\treorder;\t\\\n+\tMOVE_DF_BYTE0 (t);\t\\\n+\tMOVE_DF_BYTE8 (t);\t\\\n+\tOPCODE RET,ARG1,ARG2;\t\\\n+\tMOVE_DF_RET (f, $31);\t\\\n \tENDFN (NAME)\n \n #ifdef L_m16adddf3\n-DFOP(__mips16_adddf3, add.d)\n+OPDF3 (__mips16_adddf3, add.d)\n #endif\n #ifdef L_m16subdf3\n-DFOP(__mips16_subdf3, sub.d)\n+OPDF3 (__mips16_subdf3, sub.d)\n #endif\n #ifdef L_m16muldf3\n-DFOP(__mips16_muldf3, mul.d)\n+OPDF3 (__mips16_muldf3, mul.d)\n #endif\n #ifdef L_m16divdf3\n-DFOP(__mips16_divdf3, div.d)\n+OPDF3 (__mips16_divdf3, div.d)\n #endif\n \n-#define DFOP2(NAME, OPCODE)\t\\\n+/* Define a function NAME that loads a double-precision value,\n+   performs FPU operation OPCODE on it, and returns the double-\n+   precision result.  */\n+\n+#define OPDF2(NAME, OPCODE)\t\\\n STARTFN (NAME);\t\t\t\\\n-\t.set\tnoreorder;\t\\\n-\tLDDBL1;\t\t\t\\\n-\tnop;\t\t\t\\\n-\tOPCODE\t$f0,$f12;\t\\\n-\tRETDBL;\t\t\t\\\n-\tj\t$31;\t\t\\\n-\tnop;\t\t\t\\\n-\t.set\treorder;\t\\\n+\tMOVE_DF_BYTE0 (t);\t\\\n+\tOPCODE RET,ARG1;\t\\\n+\tMOVE_DF_RET (f, $31);\t\\\n \tENDFN (NAME)\n \n #ifdef L_m16negdf2\n-DFOP2(__mips16_negdf2, neg.d)\n+OPDF2 (__mips16_negdf2, neg.d)\n #endif\n #ifdef L_m16absdf2\n-DFOP2(__mips16_absdf2, abs.d)\n+OPDF2 (__mips16_absdf2, abs.d)\n #endif\n \n-\n /* Conversions between single and double precision.  */\n \n #ifdef L_m16extsfdf2\n STARTFN (__mips16_extendsfdf2)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tnop\n-\tcvt.d.s\t$f0,$f12\n-\tRETDBL\n-\tj\t$31\n-\tnop\n-\t.set\treorder\n+\tMOVE_SF_BYTE0 (t)\n+\tcvt.d.s\tRET,ARG1\n+\tMOVE_DF_RET (f, $31)\n \tENDFN (__mips16_extendsfdf2)\n #endif\n \n #ifdef L_m16trdfsf2\n STARTFN (__mips16_truncdfsf2)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tnop\n-\tcvt.s.d\t$f0,$f12\n-\tmfc1\t$2,$f0\n-\tj\t$31\n-\tnop\n-\t.set\treorder\n+\tMOVE_DF_BYTE0 (t)\n+\tcvt.s.d\tRET,ARG1\n+\tMOVE_SF_RET (f, $31)\n \tENDFN (__mips16_truncdfsf2)\n #endif\n \n-/* Double precision comparisons.  */\n+/* Double-precision comparisons.  */\n \n-/* This macro defines a function which loads two double precision\n-   values, performs a floating point comparison, and returns the\n-   specified values according to whether the comparison is true or\n-   false.  */\n+/* Define a function NAME that loads two double-precision values,\n+   performs floating point comparison OPCODE, and returns TRUE or\n+   FALSE depending on the result.  */\n \n-#define DFCMP(NAME, OPCODE, TRUE, FALSE)\t\\\n+#define CMPDF(NAME, OPCODE, TRUE, FALSE)\t\\\n STARTFN (NAME);\t\t\t\t\t\\\n-\tLDDBL1;\t\t\t\t\t\\\n-\tLDDBL2;\t\t\t\t\t\\\n-\tOPCODE\t$f12,$f14;\t\t\t\\\n+\tMOVE_DF_BYTE0 (t);\t\t\t\\\n+\tMOVE_DF_BYTE8 (t);\t\t\t\\\n+\tOPCODE\tARG1,ARG2;\t\t\t\\\n \tli\t$2,TRUE;\t\t\t\\\n \tbc1t\t1f;\t\t\t\t\\\n \tli\t$2,FALSE;\t\t\t\\\n 1:;\t\t\t\t\t\t\\\n \tj\t$31;\t\t\t\t\\\n \tENDFN (NAME)\n \n-/* This macro is like DFCMP, but it reverses the comparison.  */\n+/* Like CMPDF, but reverse the comparison operands.  */\n \n-#define DFREVCMP(NAME, OPCODE, TRUE, FALSE)\t\\\n+#define REVCMPDF(NAME, OPCODE, TRUE, FALSE)\t\\\n STARTFN (NAME);\t\t\t\t\t\\\n-\tLDDBL1;\t\t\t\t\t\\\n-\tLDDBL2;\t\t\t\t\t\\\n-\tOPCODE\t$f14,$f12;\t\t\t\\\n+\tMOVE_DF_BYTE0 (t);\t\t\t\\\n+\tMOVE_DF_BYTE8 (t);\t\t\t\\\n+\tOPCODE\tARG2,ARG1;\t\t\t\\\n \tli\t$2,TRUE;\t\t\t\\\n \tbc1t\t1f;\t\t\t\t\\\n \tli\t$2,FALSE;\t\t\t\\\n@@ -339,174 +403,125 @@ STARTFN (NAME);\t\t\t\t\t\\\n \tENDFN (NAME)\n \n #ifdef L_m16eqdf2\n-DFCMP(__mips16_eqdf2, c.eq.d, 0, 1)\n+CMPDF (__mips16_eqdf2, c.eq.d, 0, 1)\n #endif\n #ifdef L_m16nedf2\n-DFCMP(__mips16_nedf2, c.eq.d, 0, 1)\n+CMPDF (__mips16_nedf2, c.eq.d, 0, 1)\n #endif\n #ifdef L_m16gtdf2\n-DFREVCMP(__mips16_gtdf2, c.lt.d, 1, 0)\n+REVCMPDF (__mips16_gtdf2, c.lt.d, 1, 0)\n #endif\n #ifdef L_m16gedf2\n-DFREVCMP(__mips16_gedf2, c.le.d, 0, -1)\n+REVCMPDF (__mips16_gedf2, c.le.d, 0, -1)\n #endif\n #ifdef L_m16ledf2\n-DFCMP(__mips16_ledf2, c.le.d, 0, 1)\n+CMPDF (__mips16_ledf2, c.le.d, 0, 1)\n #endif\n #ifdef L_m16ltdf2\n-DFCMP(__mips16_ltdf2, c.lt.d, -1, 0)\n+CMPDF (__mips16_ltdf2, c.lt.d, -1, 0)\n #endif\n \n-/* Double precision conversions.  */\n+/* Double-precision conversions.  */\n \n #ifdef L_m16fltsidf\n STARTFN (__mips16_floatsidf)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tnop\n-\tcvt.d.w\t$f0,$f12\n-\tRETDBL\n-\tj\t$31\n-\tnop\n-\t.set\treorder\n+\tMOVE_SI_BYTE0 (t)\n+\tcvt.d.w\tRET,ARG1\n+\tMOVE_DF_RET (f, $31)\n \tENDFN (__mips16_floatsidf)\n #endif\n \n #ifdef L_m16fix_truncdfsi\n STARTFN (__mips16_fix_truncdfsi)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tnop\n-\ttrunc.w.d $f0,$f12,$4\n-\tmfc1\t$2,$f0\n-\tj\t$31\n-\tnop\n-\t.set\treorder\n+\tMOVE_DF_BYTE0 (t)\n+\ttrunc.w.d RET,ARG1,$4\n+\tMOVE_SI_RET (f, $31)\n \tENDFN (__mips16_fix_truncdfsi)\n #endif\n #endif /* !__mips_single_float */\n \n-/* These functions are used to return floating point values from\n-   mips16 functions.  In this case we can put mtc1 in a jump delay slot,\n-   because we know that the next instruction will not refer to a floating\n-   point register.  */\n+/* Define a function NAME that moves a return value of mode MODE from\n+   FPRs to GPRs.  */\n+\n+#define RET_FUNCTION(NAME, MODE)\t\\\n+STARTFN (NAME);\t\t\t\t\\\n+\tMOVE_##MODE##_RET (t, $31);\t\\\n+\tENDFN (NAME)\n \n #ifdef L_m16retsf\n-STARTFN (__mips16_ret_sf)\n-\t.set\tnoreorder\n-\tj\t$31\n-\tmtc1\t$2,$f0\n-\t.set\treorder\n-\tENDFN (__mips16_ret_sf)\n+RET_FUNCTION (__mips16_ret_sf, SF)\n+#endif\n+\n+#ifdef L_m16retsc\n+RET_FUNCTION (__mips16_ret_sc, SC)\n #endif\n \n #if !defined(__mips_single_float) && !defined(__SINGLE_FLOAT)\n #ifdef L_m16retdf\n-STARTFN (__mips16_ret_df)\n-\t.set\tnoreorder\n-#if defined(__mips64)\n-\tj\t$31\n-\tdmtc1\t$2,$f0\n-#elif defined(__mipsfp64)\n-\tsw\t$2,0($29)\n-\tsw\t$3,4($29)\n-\tl.d\t$f0,0($29)\n-#elif defined(__MIPSEB__)\n-\tmtc1\t$2,$f1\n-\tj\t$31\n-\tmtc1\t$3,$f0\n-#else\n-\tmtc1\t$2,$f0\n-\tj\t$31\n-\tmtc1\t$3,$f1\n+RET_FUNCTION (__mips16_ret_df, DF)\n #endif\n-\t.set\treorder\n-\tENDFN (__mips16_ret_df)\n+\n+#ifdef L_m16retdc\n+RET_FUNCTION (__mips16_ret_dc, DC)\n #endif\n #endif /* !__mips_single_float */\n \n+/* STUB_ARGS_X copies the arguments from GPRs to FPRs for argument\n+   code X.  X is calculated as ARG1 + ARG2 * 4, where ARG1 and ARG2\n+   classify the first and second arguments as follows:\n+\n+\t1: a single-precision argument\n+\t2: a double-precision argument\n+\t0: no argument, or not one of the above.  */\n+\n+#define STUB_ARGS_0\t\t\t\t\t\t/* () */\n+#define STUB_ARGS_1 MOVE_SF_BYTE0 (t)\t\t\t\t/* (sf) */\n+#define STUB_ARGS_5 MOVE_SF_BYTE0 (t); MOVE_SF_BYTE4 (t)\t/* (sf, sf) */\n+#define STUB_ARGS_9 MOVE_SF_BYTE0 (t); MOVE_DF_BYTE8 (t)\t/* (sf, df) */\n+#define STUB_ARGS_2 MOVE_DF_BYTE0 (t)\t\t\t\t/* (df) */\n+#define STUB_ARGS_6 MOVE_DF_BYTE0 (t); MOVE_SF_BYTE8 (t)\t/* (df, sf) */\n+#define STUB_ARGS_10 MOVE_DF_BYTE0 (t); MOVE_DF_BYTE8 (t)\t/* (df, df) */\n+\n /* These functions are used by 16-bit code when calling via a function\n-   pointer.  They must copy the floating point arguments from the gp\n-   regs into the fp regs.  The function to call will be in $2.  The\n-   exact set of floating point arguments to copy is encoded in the\n-   function name; the final number is an fp_code, as described in\n-   mips.h in the comment about CUMULATIVE_ARGS.  */\n+   pointer.  They must copy the floating point arguments from the GPRs\n+   to FPRs and then call function $2.  */\n+\n+#define CALL_STUB_NO_RET(NAME, CODE)\t\\\n+STARTFN (NAME);\t\t\t\t\\\n+\tSTUB_ARGS_##CODE;\t\t\\\n+\tjr\t$2;\t\t\t\\\n+\tENDFN (NAME)\n \n #ifdef L_m16stub1\n-/* (float) */\n-STARTFN (__mips16_call_stub_1)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tj\t$2\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_1)\n+CALL_STUB_NO_RET (__mips16_call_stub_1, 1)\n #endif\n \n #ifdef L_m16stub5\n-/* (float, float) */\n-STARTFN (__mips16_call_stub_5)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tmtc1\t$5,$f14\n-\tj\t$2\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_5)\n+CALL_STUB_NO_RET (__mips16_call_stub_5, 5)\n #endif\n \n #if !defined(__mips_single_float) && !defined(__SINGLE_FLOAT)\n \n #ifdef L_m16stub2\n-/* (double) */\n-STARTFN (__mips16_call_stub_2)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tj\t$2\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_2)\n+CALL_STUB_NO_RET (__mips16_call_stub_2, 2)\n #endif\n \n #ifdef L_m16stub6\n-/* (double, float) */\n-STARTFN (__mips16_call_stub_6)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tmtc1\t$6,$f14\n-\tj\t$2\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_6)\n+CALL_STUB_NO_RET (__mips16_call_stub_6, 6)\n #endif\n \n #ifdef L_m16stub9\n-/* (float, double) */\n-STARTFN (__mips16_call_stub_9)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tLDDBL2\n-\tj\t$2\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_9)\n+CALL_STUB_NO_RET (__mips16_call_stub_9, 9)\n #endif\n \n #ifdef L_m16stub10\n-/* (double, double) */\n-STARTFN (__mips16_call_stub_10)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tLDDBL2\n-\tj\t$2\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_10)\n+CALL_STUB_NO_RET (__mips16_call_stub_10, 10)\n #endif\n #endif /* !__mips_single_float */\n \n /* Now we have the same set of functions, except that this time the\n-   function being called returns an SFmode value.  The calling\n+   function being called returns an SFmode, SCmode, DFmode or DCmode\n+   value; we need to instantiate a set for each case.  The calling\n    function will arrange to preserve $18, so these functions are free\n    to use it to hold the return address.\n \n@@ -517,223 +532,143 @@ STARTFN (__mips16_call_stub_10)\n    being called is 16 bits, in which case the copy is unnecessary;\n    however, it's faster to always do the copy.  */\n \n+#define CALL_STUB_RET(NAME, CODE, MODE)\t\\\n+STARTFN (NAME);\t\t\t\t\\\n+\tmove\t$18,$31;\t\t\\\n+\tSTUB_ARGS_##CODE;\t\t\\\n+\tjalr\t$2;\t\t\t\\\n+\tMOVE_##MODE##_RET (f, $18);\t\\\n+\tENDFN (NAME)\n+\n+/* First, instantiate the single-float set.  */\n+\n #ifdef L_m16stubsf0\n-/* () */\n-STARTFN (__mips16_call_stub_sf_0)\n-\t.set\tnoreorder\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tmfc1\t$2,$f0\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_sf_0)\n+CALL_STUB_RET (__mips16_call_stub_sf_0, 0, SF)\n #endif\n \n #ifdef L_m16stubsf1\n-/* (float) */\n-STARTFN (__mips16_call_stub_sf_1)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tmfc1\t$2,$f0\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_sf_1)\n+CALL_STUB_RET (__mips16_call_stub_sf_1, 1, SF)\n #endif\n \n #ifdef L_m16stubsf5\n-/* (float, float) */\n-STARTFN (__mips16_call_stub_sf_5)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tmtc1\t$5,$f14\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tmfc1\t$2,$f0\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_sf_5)\n+CALL_STUB_RET (__mips16_call_stub_sf_5, 5, SF)\n #endif\n \n #if !defined(__mips_single_float) && !defined(__SINGLE_FLOAT)\n #ifdef L_m16stubsf2\n-/* (double) */\n-STARTFN (__mips16_call_stub_sf_2)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tmfc1\t$2,$f0\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_sf_2)\n+CALL_STUB_RET (__mips16_call_stub_sf_2, 2, SF)\n #endif\n \n #ifdef L_m16stubsf6\n-/* (double, float) */\n-STARTFN (__mips16_call_stub_sf_6)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tmtc1\t$6,$f14\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tmfc1\t$2,$f0\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_sf_6)\n+CALL_STUB_RET (__mips16_call_stub_sf_6, 6, SF)\n #endif\n \n #ifdef L_m16stubsf9\n-/* (float, double) */\n-STARTFN (__mips16_call_stub_sf_9)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tLDDBL2\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tmfc1\t$2,$f0\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_sf_9)\n+CALL_STUB_RET (__mips16_call_stub_sf_9, 9, SF)\n #endif\n \n #ifdef L_m16stubsf10\n-/* (double, double) */\n-STARTFN (__mips16_call_stub_sf_10)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tLDDBL2\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tmfc1\t$2,$f0\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_sf_10)\n+CALL_STUB_RET (__mips16_call_stub_sf_10, 10, SF)\n #endif\n+#endif /* !__mips_single_float */\n+\n \n /* Now we have the same set of functions again, except that this time\n    the function being called returns an DFmode value.  */\n \n+#if !defined(__mips_single_float) && !defined(__SINGLE_FLOAT)\n #ifdef L_m16stubdf0\n-/* () */\n-STARTFN (__mips16_call_stub_df_0)\n-\t.set\tnoreorder\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tRETDBL\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_df_0)\n+CALL_STUB_RET (__mips16_call_stub_df_0, 0, DF)\n #endif\n \n #ifdef L_m16stubdf1\n-/* (float) */\n-STARTFN (__mips16_call_stub_df_1)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tRETDBL\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_df_1)\n+CALL_STUB_RET (__mips16_call_stub_df_1, 1, DF)\n #endif\n \n-#ifdef L_m16stubdf2\n-/* (double) */\n-STARTFN (__mips16_call_stub_df_2)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tRETDBL\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_df_2)\n+#ifdef L_m16stubdf5\n+CALL_STUB_RET (__mips16_call_stub_df_5, 5, DF)\n #endif\n \n-#ifdef L_m16stubdf5\n-/* (float, float) */\n-STARTFN (__mips16_call_stub_df_5)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tmtc1\t$5,$f14\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tRETDBL\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_df_5)\n+#ifdef L_m16stubdf2\n+CALL_STUB_RET (__mips16_call_stub_df_2, 2, DF)\n #endif\n \n #ifdef L_m16stubdf6\n-/* (double, float) */\n-STARTFN (__mips16_call_stub_df_6)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tmtc1\t$6,$f14\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tRETDBL\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_df_6)\n+CALL_STUB_RET (__mips16_call_stub_df_6, 6, DF)\n #endif\n \n #ifdef L_m16stubdf9\n-/* (float, double) */\n-STARTFN (__mips16_call_stub_df_9)\n-\t.set\tnoreorder\n-\tmtc1\t$4,$f12\n-\tLDDBL2\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tRETDBL\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_df_9)\n+CALL_STUB_RET (__mips16_call_stub_df_9, 9, DF)\n #endif\n \n #ifdef L_m16stubdf10\n-/* (double, double) */\n-STARTFN (__mips16_call_stub_df_10)\n-\t.set\tnoreorder\n-\tLDDBL1\n-\tLDDBL2\n-\tmove\t$18,$31\n-\tjal\t$2\n-\tnop\n-\tRETDBL\n-\tj\t$18\n-\tnop\n-\t.set\treorder\n-\tENDFN (__mips16_call_stub_df_10)\n+CALL_STUB_RET (__mips16_call_stub_df_10, 10, DF)\n+#endif\n+#endif /* !__mips_single_float */\n+\n+\n+/* Ho hum.  Here we have the same set of functions again, this time\n+   for when the function being called returns an SCmode value.  */\n+\n+#ifdef L_m16stubsc0\n+CALL_STUB_RET (__mips16_call_stub_sc_0, 0, SC)\n+#endif\n+\n+#ifdef L_m16stubsc1\n+CALL_STUB_RET (__mips16_call_stub_sc_1, 1, SC)\n+#endif\n+\n+#ifdef L_m16stubsc5\n+CALL_STUB_RET (__mips16_call_stub_sc_5, 5, SC)\n+#endif\n+\n+#if !defined(__mips_single_float) && !defined(__SINGLE_FLOAT)\n+#ifdef L_m16stubsc2\n+CALL_STUB_RET (__mips16_call_stub_sc_2, 2, SC)\n+#endif\n+\n+#ifdef L_m16stubsc6\n+CALL_STUB_RET (__mips16_call_stub_sc_6, 6, SC)\n+#endif\n+\n+#ifdef L_m16stubsc9\n+CALL_STUB_RET (__mips16_call_stub_sc_9, 9, SC)\n+#endif\n+\n+#ifdef L_m16stubsc10\n+CALL_STUB_RET (__mips16_call_stub_sc_10, 10, SC)\n+#endif\n+#endif /* !__mips_single_float */\n+\n+\n+/* Finally, another set of functions for DCmode.  */\n+\n+#if !defined(__mips_single_float) && !defined(__SINGLE_FLOAT)\n+#ifdef L_m16stubdc0\n+CALL_STUB_RET (__mips16_call_stub_dc_0, 0, DC)\n+#endif\n+\n+#ifdef L_m16stubdc1\n+CALL_STUB_RET (__mips16_call_stub_dc_1, 1, DC)\n+#endif\n+\n+#ifdef L_m16stubdc5\n+CALL_STUB_RET (__mips16_call_stub_dc_5, 5, DC)\n+#endif\n+\n+#ifdef L_m16stubdc2\n+CALL_STUB_RET (__mips16_call_stub_dc_2, 2, DC)\n+#endif\n+\n+#ifdef L_m16stubdc6\n+CALL_STUB_RET (__mips16_call_stub_dc_6, 6, DC)\n+#endif\n+\n+#ifdef L_m16stubdc9\n+CALL_STUB_RET (__mips16_call_stub_dc_9, 9, DC)\n+#endif\n+\n+#ifdef L_m16stubdc10\n+CALL_STUB_RET (__mips16_call_stub_dc_10, 10, DC)\n #endif\n #endif /* !__mips_single_float */"}, {"sha": "e66520b77d4bbaeff90424ef4b353e0769420f84", "filename": "gcc/config/mips/t-elf", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Ft-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Ft-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-elf?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -19,11 +19,16 @@ LIB1ASMFUNCS = _m16addsf3 _m16subsf3 _m16mulsf3 _m16divsf3 \\\n \t_m16eqdf2 _m16nedf2 _m16gtdf2 _m16gedf2 _m16ledf2 _m16ltdf2 \\\n \t_m16fltsidf _m16fix_truncdfsi \\\n \t_m16retsf _m16retdf \\\n+\t_m16retsc _m16retdc \\\n \t_m16stub1 _m16stub2 _m16stub5 _m16stub6 _m16stub9 _m16stub10 \\\n \t_m16stubsf0 _m16stubsf1 _m16stubsf2 _m16stubsf5 _m16stubsf6 \\\n \t_m16stubsf9 _m16stubsf10 \\\n \t_m16stubdf0 _m16stubdf1 _m16stubdf2 _m16stubdf5 _m16stubdf6 \\\n-\t_m16stubdf9 _m16stubdf10\n+\t_m16stubdf9 _m16stubdf10 \\\n+\t_m16stubsc0 _m16stubsc1 _m16stubsc2 _m16stubsc5 _m16stubsc6 \\\n+\t_m16stubsc9 _m16stubsc10 \\\n+\t_m16stubdc0 _m16stubdc1 _m16stubdc2 _m16stubdc5 _m16stubdc6 \\\n+\t_m16stubdc9 _m16stubdc10\n \n # We must build libgcc2.a with -G 0, in case the user wants to link\n # without the $gp register."}, {"sha": "be1fc867540f09a02036dde49015834110e0a15b", "filename": "gcc/config/mips/t-isa3264", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Ft-isa3264", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Ft-isa3264", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-isa3264?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -19,11 +19,16 @@ LIB1ASMFUNCS = _m16addsf3 _m16subsf3 _m16mulsf3 _m16divsf3 \\\n \t_m16eqdf2 _m16nedf2 _m16gtdf2 _m16gedf2 _m16ledf2 _m16ltdf2 \\\n \t_m16fltsidf _m16fix_truncdfsi \\\n \t_m16retsf _m16retdf \\\n+\t_m16retsc _m16retdc \\\n \t_m16stub1 _m16stub2 _m16stub5 _m16stub6 _m16stub9 _m16stub10 \\\n \t_m16stubsf0 _m16stubsf1 _m16stubsf2 _m16stubsf5 _m16stubsf6 \\\n \t_m16stubsf9 _m16stubsf10 \\\n \t_m16stubdf0 _m16stubdf1 _m16stubdf2 _m16stubdf5 _m16stubdf6 \\\n-\t_m16stubdf9 _m16stubdf10\n+\t_m16stubdf9 _m16stubdf10 \\\n+\t_m16stubsc0 _m16stubsc1 _m16stubsc2 _m16stubsc5 _m16stubsc6 \\\n+\t_m16stubsc9 _m16stubsc10 \\\n+\t_m16stubdc0 _m16stubdc1 _m16stubdc2 _m16stubdc5 _m16stubdc6 \\\n+\t_m16stubdc9 _m16stubdc10\n \n # We must build libgcc2.a with -G 0, in case the user wants to link\n # without the $gp register."}, {"sha": "12455985074bd42784e2bec2a368637d454ad3da", "filename": "gcc/config/mips/t-r3900", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Ft-r3900", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Fconfig%2Fmips%2Ft-r3900", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-r3900?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -7,11 +7,16 @@ LIB1ASMFUNCS = _m16addsf3 _m16subsf3 _m16mulsf3 _m16divsf3 \\\n \t_m16eqdf2 _m16nedf2 _m16gtdf2 _m16gedf2 _m16ledf2 _m16ltdf2 \\\n \t_m16fltsidf _m16fix_truncdfsi \\\n \t_m16retsf _m16retdf \\\n+\t_m16retsc _m16retdc \\\n \t_m16stub1 _m16stub2 _m16stub5 _m16stub6 _m16stub9 _m16stub10 \\\n \t_m16stubsf0 _m16stubsf1 _m16stubsf2 _m16stubsf5 _m16stubsf6 \\\n \t_m16stubsf9 _m16stubsf10 \\\n \t_m16stubdf0 _m16stubdf1 _m16stubdf2 _m16stubdf5 _m16stubdf6 \\\n-\t_m16stubdf9 _m16stubdf10\n+\t_m16stubdf9 _m16stubdf10 \\\n+\t_m16stubsc0 _m16stubsc1 _m16stubsc2 _m16stubsc5 _m16stubsc6 \\\n+\t_m16stubsc9 _m16stubsc10 \\\n+\t_m16stubdc0 _m16stubdc1 _m16stubdc2 _m16stubdc5 _m16stubdc6 \\\n+\t_m16stubdc9 _m16stubdc10\n \n # We must build libgcc2.a with -G 0, in case the user wants to link\n # without the $gp register."}, {"sha": "988a41ba5610e6f9d580ad050c83c67906b51f85", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -1,3 +1,12 @@\n+2007-05-23  Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Nigel Stephens  <nigel@mips.com>\n+\t    Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* gcc.target/mips/inter/mips16_stubs_1_main.c: New.\n+\t* gcc.target/mips/inter/mips16_stubs_1_x.c: New.\n+\t* gcc.target/mips/inter/mips16_stubs_1_y.c: New.\n+\t* gcc.target/mips/inter/mips16-inter.exp: New.\n+\n 2007-05-23  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* gcc.dg/bf-spl1.c, gcc.dg/m68k-pic-1.c: Enable on fido-*-*."}, {"sha": "dc28dad4f6f98d4a016299d59dbdbc5a7fa2b610", "filename": "gcc/testsuite/gcc.target/mips/inter/mips16-inter.exp", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16-inter.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16-inter.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16-inter.exp?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -0,0 +1,48 @@\n+# Run compatibility tests in which the \"alt\" compiler tries to force\n+# MIPS16 mode.\n+\n+# We can only guarantee MIPS16 runtime support for certain targets.\n+if { ![istarget mipsisa*-*-elf*] && ![istarget mips64vr*-*-elf*] } {\n+    return\n+}\n+\n+# Save the old value of CFLAGS_FOR_TARGET, if any.\n+global saved_CFLAGS_FOR_TARGET\n+if { [info exists CFLAGS_FOR_TARGET] } {\n+    set saved_CFLAGS_FOR_TARGET $CFLAGS_FOR_TARGET\n+} else {\n+    unset -nocomplain saved_CFLAGS_FOR_TARGET\n+}\n+\n+# The \"alt\" compiler is the normal compiler with an extra \"-mips16\" argument.\n+proc compat-use-alt-compiler { } {\n+    global saved_CFLAGS_FOR_TARGET CFLAGS_FOR_TARGET\n+\n+    if { [info exists saved_CFLAGS_FOR_TARGET] } {\n+\tset CFLAGS_FOR_TARGET [concat $saved_CFLAGS_FOR_TARGET \"-mips16\"]\n+    } else {\n+\tset CFLAGS_FOR_TARGET \"-mips16\"\n+    }\n+}\n+\n+# Make the compiler under test the default.\n+proc compat-use-tst-compiler { } {\n+    global saved_CFLAGS_FOR_TARGET CFLAGS_FOR_TARGET\n+\n+    if { [info exists saved_CFLAGS_FOR_TARGET] } {\n+\tset CFLAGS_FOR_TARGET $saved_CFLAGS_FOR_TARGET\n+    } else {\n+\tunset -nocomplain CFLAGS_FOR_TARGET\n+    }\n+}\n+\n+load_lib gcc.exp\n+load_lib compat.exp\n+\n+gcc_init\n+foreach src [lsort [find $srcdir/$subdir mips16_*_main.c]] {\n+    if { [runtest_file_p $runtests $src] } {\n+\tcompat-execute $src \"mips16_inter\" 1\n+    }\n+}\n+compat-use-tst-compiler"}, {"sha": "df18c7670ca4b89220bf70bbed6583857833e032", "filename": "gcc/testsuite/gcc.target/mips/inter/mips16_stubs_1_main.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16_stubs_1_main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16_stubs_1_main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16_stubs_1_main.c?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -0,0 +1,10 @@\n+extern void init (void);\n+extern void test (void);\n+\n+int\n+main (void)\n+{\n+  init ();\n+  test ();\n+  return 0;\n+}"}, {"sha": "076b399a3845c8f5de2e80354cdd12ee39f54911", "filename": "gcc/testsuite/gcc.target/mips/inter/mips16_stubs_1_x.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16_stubs_1_x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16_stubs_1_x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16_stubs_1_x.c?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -0,0 +1,176 @@\n+#include <stdlib.h>\n+\n+/* All the function pointers are declared and initialized in\n+   mips16-stubs-2.c.  */\n+\n+extern double the_result;\n+\n+extern void v0 (void);\n+extern void v1 (float);\n+extern void v5 (float, float);\n+extern void v9 (float, double);\n+extern void v2 (double);\n+extern void v6 (double, float);\n+extern void v10 (double, double);\n+\n+extern float f0 (void);\n+extern float f1 (float);\n+extern float f5 (float, float);\n+extern float f9 (float, double);\n+extern float f2 (double);\n+extern float f6 (double, float);\n+extern float f10 (double, double);\n+\n+extern double d0 (void);\n+extern double d1 (float);\n+extern double d5 (float, float);\n+extern double d9 (float, double);\n+extern double d2 (double);\n+extern double d6 (double, float);\n+extern double d10 (double, double);\n+\n+extern _Complex float cf0 (void);\n+extern _Complex float cf1 (float);\n+extern _Complex float cf5 (float, float);\n+extern _Complex float cf9 (float, double);\n+extern _Complex float cf2 (double);\n+extern _Complex float cf6 (double, float);\n+extern _Complex float cf10 (double, double);\n+\n+extern _Complex double cd0 (void);\n+extern _Complex double cd1 (float);\n+extern _Complex double cd5 (float, float);\n+extern _Complex double cd9 (float, double);\n+extern _Complex double cd2 (double);\n+extern _Complex double cd6 (double, float);\n+extern _Complex double cd10 (double, double);\n+\n+extern void (*pv0) (void);\n+extern void (*pv1) (float);\n+extern void (*pv5) (float, float);\n+extern void (*pv9) (float, double);\n+extern void (*pv2) (double);\n+extern void (*pv6) (double, float);\n+extern void (*pv10) (double, double);\n+\n+extern float (*pf0) (void);\n+extern float (*pf1) (float);\n+extern float (*pf5) (float, float);\n+extern float (*pf9) (float, double);\n+extern float (*pf2) (double);\n+extern float (*pf6) (double, float);\n+extern float (*pf10) (double, double);\n+\n+extern double (*pd0) (void);\n+extern double (*pd1) (float);\n+extern double (*pd5) (float, float);\n+extern double (*pd9) (float, double);\n+extern double (*pd2) (double);\n+extern double (*pd6) (double, float);\n+extern double (*pd10) (double, double);\n+\n+extern _Complex float (*pcf0) (void);\n+extern _Complex float (*pcf1) (float);\n+extern _Complex float (*pcf5) (float, float);\n+extern _Complex float (*pcf9) (float, double);\n+extern _Complex float (*pcf2) (double);\n+extern _Complex float (*pcf6) (double, float);\n+extern _Complex float (*pcf10) (double, double);\n+\n+extern _Complex double (*pcd0) (void);\n+extern _Complex double (*pcd1) (float);\n+extern _Complex double (*pcd5) (float, float);\n+extern _Complex double (*pcd9) (float, double);\n+extern _Complex double (*pcd2) (double);\n+extern _Complex double (*pcd6) (double, float);\n+extern _Complex double (*pcd10) (double, double);\n+\n+/* Macros for results checking.  */\n+#define CHECK_RESULT(x, y) if ((x) != (y)) abort ()\n+#define CHECK_VOID_RESULT(x, y)  CHECK_RESULT (((x), the_result), y)\n+\n+/* Call functions through pointers and and check against expected results.  */\n+void\n+test (void)\n+{\n+\n+  CHECK_VOID_RESULT (v0 (), 1.0);\n+  CHECK_VOID_RESULT (v1 (1.0), 2.0);\n+  CHECK_VOID_RESULT (v5 (5.0, 6.0), 12.0);\n+  CHECK_VOID_RESULT (v9 (9.0, 10.0), 20.0);\n+  CHECK_VOID_RESULT (v2 (2.0), 3.0);\n+  CHECK_VOID_RESULT (v6 (6.0, 7.0), 14.0);\n+  CHECK_VOID_RESULT (v10 (10.0, 11.0), 22.0);\n+\n+  CHECK_RESULT (f0 (), 1.0);\n+  CHECK_RESULT (f1 (1.0), 2.0);\n+  CHECK_RESULT (f5 (5.0, 6.0), 12.0);\n+  CHECK_RESULT (f9 (9.0, 10.0), 20.0);\n+  CHECK_RESULT (f2 (2.0), 3.0);\n+  CHECK_RESULT (f6 (6.0, 7.0), 14.0);\n+  CHECK_RESULT (f10 (10.0, 11.0), 22.0);\n+\n+  CHECK_RESULT (d0 (), 1.0);\n+  CHECK_RESULT (d1 (1.0), 2.0);\n+  CHECK_RESULT (d5 (5.0, 6.0), 12.0);\n+  CHECK_RESULT (d9 (9.0, 10.0), 20.0);\n+  CHECK_RESULT (d2 (2.0), 3.0);\n+  CHECK_RESULT (d6 (6.0, 7.0), 14.0);\n+  CHECK_RESULT (d10 (10.0, 11.0), 22.0);\n+\n+  CHECK_RESULT (cf0 (), 1.0 + 0.0i);\n+  CHECK_RESULT (cf1 (1.0), 2.0 + 1.0i);\n+  CHECK_RESULT (cf5 (5.0, 6.0), 12.0 + 5.0i);\n+  CHECK_RESULT (cf9 (9.0, 10.0), 20.0 + 9.0i);\n+  CHECK_RESULT (cf2 (2.0), 3.0 + 2.0i);\n+  CHECK_RESULT (cf6 (6.0, 7.0), 14.0 + 6.0i);\n+  CHECK_RESULT (cf10 (10.0, 11.0), 22.0 + 10.0i);\n+\n+  CHECK_RESULT (cd0 (), 1.0 + 0.0i);\n+  CHECK_RESULT (cd1 (1.0), 2.0 + 1.0i);\n+  CHECK_RESULT (cd5 (5.0, 6.0), 12.0 + 5.0i);\n+  CHECK_RESULT (cd9 (9.0, 10.0), 20.0 + 9.0i);\n+  CHECK_RESULT (cd2 (2.0), 3.0 + 2.0i);\n+  CHECK_RESULT (cd6 (6.0, 7.0), 14.0 + 6.0i);\n+  CHECK_RESULT (cd10 (10.0, 11.0), 22.0 + 10.0i);\n+\n+  CHECK_VOID_RESULT ((*pv0) (), 1.0);\n+  CHECK_VOID_RESULT ((*pv1) (1.0), 2.0);\n+  CHECK_VOID_RESULT ((*pv5) (5.0, 6.0), 12.0);\n+  CHECK_VOID_RESULT ((*pv9) (9.0, 10.0), 20.0);\n+  CHECK_VOID_RESULT ((*pv2) (2.0), 3.0);\n+  CHECK_VOID_RESULT ((*pv6) (6.0, 7.0), 14.0);\n+  CHECK_VOID_RESULT ((*pv10) (10.0, 11.0), 22.0);\n+\n+  CHECK_RESULT ((*pf0) (), 1.0);\n+  CHECK_RESULT ((*pf1) (1.0), 2.0);\n+  CHECK_RESULT ((*pf5) (5.0, 6.0), 12.0);\n+  CHECK_RESULT ((*pf9) (9.0, 10.0), 20.0);\n+  CHECK_RESULT ((*pf2) (2.0), 3.0);\n+  CHECK_RESULT ((*pf6) (6.0, 7.0), 14.0);\n+  CHECK_RESULT ((*pf10) (10.0, 11.0), 22.0);\n+\n+  CHECK_RESULT ((*pd0) (), 1.0);\n+  CHECK_RESULT ((*pd1) (1.0), 2.0);\n+  CHECK_RESULT ((*pd5) (5.0, 6.0), 12.0);\n+  CHECK_RESULT ((*pd9) (9.0, 10.0), 20.0);\n+  CHECK_RESULT ((*pd2) (2.0), 3.0);\n+  CHECK_RESULT ((*pd6) (6.0, 7.0), 14.0);\n+  CHECK_RESULT ((*pd10) (10.0, 11.0), 22.0);\n+\n+  CHECK_RESULT ((*pcf0) (), 1.0 + 0.0i);\n+  CHECK_RESULT ((*pcf1) (1.0), 2.0 + 1.0i);\n+  CHECK_RESULT ((*pcf5) (5.0, 6.0), 12.0 + 5.0i);\n+  CHECK_RESULT ((*pcf9) (9.0, 10.0), 20.0 + 9.0i);\n+  CHECK_RESULT ((*pcf2) (2.0), 3.0 + 2.0i);\n+  CHECK_RESULT ((*pcf6) (6.0, 7.0), 14.0 + 6.0i);\n+  CHECK_RESULT ((*pcf10) (10.0, 11.0), 22.0 + 10.0i);\n+\n+  CHECK_RESULT ((*pcd0) (), 1.0 + 0.0i);\n+  CHECK_RESULT ((*pcd1) (1.0), 2.0 + 1.0i);\n+  CHECK_RESULT ((*pcd5) (5.0, 6.0), 12.0 + 5.0i);\n+  CHECK_RESULT ((*pcd9) (9.0, 10.0), 20.0 + 9.0i);\n+  CHECK_RESULT ((*pcd2) (2.0), 3.0 + 2.0i);\n+  CHECK_RESULT ((*pcd6) (6.0, 7.0), 14.0 + 6.0i);\n+  CHECK_RESULT ((*pcd10) (10.0, 11.0), 22.0 + 10.0i);\n+}"}, {"sha": "b7a4d7f32e9bc43491863667f7f86a5a182eeab6", "filename": "gcc/testsuite/gcc.target/mips/inter/mips16_stubs_1_y.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16_stubs_1_y.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a38e0142a8424e5d53b673ecaaa2976982a84834/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16_stubs_1_y.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Finter%2Fmips16_stubs_1_y.c?ref=a38e0142a8424e5d53b673ecaaa2976982a84834", "patch": "@@ -0,0 +1,133 @@\n+/* All test functions return the sum of arguments, plus 1.\n+   Void-returning functions put the result in the_result.\n+   Complex-returning functions return their signature number as the\n+   (constant) imaginary part of the result.  */\n+\n+double the_result;\n+\n+void v0 (void) \t\t\t{ the_result = 1.0; }\n+void v1 (float x)\t\t{ the_result = 1.0 + x; }\n+void v5 (float x, float y) \t{ the_result = 1.0 + x + y; }\n+void v9 (float x, double y) \t{ the_result = 1.0 + x + y; }\n+void v2 (double x)\t\t{ the_result = 1.0 + x; }\n+void v6 (double x, float y)\t{ the_result = 1.0 + x + y; }\n+void v10 (double x, double y)  \t{ the_result = 1.0 + x + y; }\n+\n+float f0 (void) \t\t{ return 1.0; }\n+float f1 (float x)\t\t{ return 1.0 + x; }\n+float f5 (float x, float y) \t{ return 1.0 + x + y; }\n+float f9 (float x, double y) \t{ return 1.0 + x + y; }\n+float f2 (double x)\t\t{ return 1.0 + x; }\n+float f6 (double x, float y)\t{ return 1.0 + x + y; }\n+float f10 (double x, double y)\t{ return 1.0 + x + y; }\n+\n+double d0 (void) \t\t{ return 1.0; }\n+double d1 (float x)\t\t{ return 1.0 + x; }\n+double d5 (float x, float y) \t{ return 1.0 + x + y; }\n+double d9 (float x, double y) \t{ return 1.0 + x + y; }\n+double d2 (double x)\t\t{ return 1.0 + x; }\n+double d6 (double x, float y)\t{ return 1.0 + x + y; }\n+double d10 (double x, double y) { return 1.0 + x + y; }\n+\n+_Complex float cf0 (void) \t\t\t{ return 1.0 + 0.0i; }\n+_Complex float cf1 (float x)\t\t\t{ return 1.0 + x + 1.0i; }\n+_Complex float cf5 (float x, float y) \t\t{ return 1.0 + x + y + 5.0i; }\n+_Complex float cf9 (float x, double y) \t\t{ return 1.0 + x + y + 9.0i; }\n+_Complex float cf2 (double x)\t\t\t{ return 1.0 + x + 2.0i; }\n+_Complex float cf6 (double x, float y)\t\t{ return 1.0 + x + y + 6.0i; }\n+_Complex float cf10 (double x, double y)\t{ return 1.0 + x + y + 10.0i; }\n+\n+_Complex double cd0 (void) \t\t\t{ return 1.0 + 0.0i; }\n+_Complex double cd1 (float x)\t\t\t{ return 1.0 + x + 1.0i; }\n+_Complex double cd5 (float x, float y) \t\t{ return 1.0 + x + y + 5.0i; }\n+_Complex double cd9 (float x, double y) \t{ return 1.0 + x + y + 9.0i; }\n+_Complex double cd2 (double x)\t\t\t{ return 1.0 + x + 2.0i; }\n+_Complex double cd6 (double x, float y)\t\t{ return 1.0 + x + y + 6.0i; }\n+_Complex double cd10 (double x, double y)\t{ return 1.0 + x + y + 10.0i; }\n+\n+\n+/* Declare and initialize all the pointer-to-function variables.  */\n+\n+void (*pv0) (void);\n+void (*pv1) (float);\n+void (*pv5) (float, float);\n+void (*pv9) (float, double);\n+void (*pv2) (double);\n+void (*pv6) (double, float);\n+void (*pv10) (double, double);\n+\n+float (*pf0) (void);\n+float (*pf1) (float);\n+float (*pf5) (float, float);\n+float (*pf9) (float, double);\n+float (*pf2) (double);\n+float (*pf6) (double, float);\n+float (*pf10) (double, double);\n+\n+double (*pd0) (void);\n+double (*pd1) (float);\n+double (*pd5) (float, float);\n+double (*pd9) (float, double);\n+double (*pd2) (double);\n+double (*pd6) (double, float);\n+double (*pd10) (double, double);\n+\n+_Complex float (*pcf0) (void);\n+_Complex float (*pcf1) (float);\n+_Complex float (*pcf5) (float, float);\n+_Complex float (*pcf9) (float, double);\n+_Complex float (*pcf2) (double);\n+_Complex float (*pcf6) (double, float);\n+_Complex float (*pcf10) (double, double);\n+\n+_Complex double (*pcd0) (void);\n+_Complex double (*pcd1) (float);\n+_Complex double (*pcd5) (float, float);\n+_Complex double (*pcd9) (float, double);\n+_Complex double (*pcd2) (double);\n+_Complex double (*pcd6) (double, float);\n+_Complex double (*pcd10) (double, double);\n+\n+void\n+init (void)\n+{\n+  pv0 = v0;\n+  pv1 = v1;\n+  pv5 = v5;\n+  pv9 = v9;\n+  pv2 = v2;\n+  pv6 = v6;\n+  pv10 = v10;\n+\n+  pf0 = f0;\n+  pf1 = f1;\n+  pf5 = f5;\n+  pf9 = f9;\n+  pf2 = f2;\n+  pf6 = f6;\n+  pf10 = f10;\n+\n+  pd0 = d0;\n+  pd1 = d1;\n+  pd5 = d5;\n+  pd9 = d9;\n+  pd2 = d2;\n+  pd6 = d6;\n+  pd10 = d10;\n+\n+  pcf0 = cf0;\n+  pcf1 = cf1;\n+  pcf5 = cf5;\n+  pcf9 = cf9;\n+  pcf2 = cf2;\n+  pcf6 = cf6;\n+  pcf10 = cf10;\n+\n+  pcd0 = cd0;\n+  pcd1 = cd1;\n+  pcd5 = cd5;\n+  pcd9 = cd9;\n+  pcd2 = cd2;\n+  pcd6 = cd6;\n+  pcd10 = cd10;\n+}"}]}