{"sha": "4e9a497f07457d63c74962ee0d90c96bdd98f918", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU5YTQ5N2YwNzQ1N2Q2M2M3NDk2MmVlMGQ5MGM5NmJkZDk4ZjkxOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-06-19T09:47:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-06-19T09:47:31Z"}, "message": "profile-count.c (profile_count::dump): Dump quality.\n\n\t* profile-count.c (profile_count::dump): Dump quality.\n\t(profile_count::differs_from_p): Update for unsigned val.\n\t* profile-count.h (profile_count_quality): New enum.\n\t(profile_count): Turn m_val to 62bit unsigned, add quality tracking.\n\nFrom-SVN: r249360", "tree": {"sha": "a246eb44570f5679b805cce58626b999212867f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a246eb44570f5679b805cce58626b999212867f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e9a497f07457d63c74962ee0d90c96bdd98f918", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9a497f07457d63c74962ee0d90c96bdd98f918", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e9a497f07457d63c74962ee0d90c96bdd98f918", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e9a497f07457d63c74962ee0d90c96bdd98f918/comments", "author": null, "committer": null, "parents": [{"sha": "fe1ae165924f6c4bc55e40c2d3843d39b9bfc297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1ae165924f6c4bc55e40c2d3843d39b9bfc297", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1ae165924f6c4bc55e40c2d3843d39b9bfc297"}], "stats": {"total": 96, "additions": 77, "deletions": 19}, "files": [{"sha": "78ded852f32755e06a3045390a500d43c39f10c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9a497f07457d63c74962ee0d90c96bdd98f918/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9a497f07457d63c74962ee0d90c96bdd98f918/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e9a497f07457d63c74962ee0d90c96bdd98f918", "patch": "@@ -1,3 +1,10 @@\n+2017-06-19  Jan Hubicka <hubicka@ucw.cz>\n+\n+\t* profile-count.c (profile_count::dump): Dump quality.\n+\t(profile_count::differs_from_p): Update for unsigned val.\n+\t* profile-count.h (profile_count_quality): New enum.\n+\t(profile_count): Turn m_val to 62bit unsigned, add quality tracking.\n+\n 2017-06-19  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-loop-niter.h (estimate_numbers_of_iterations): Take"}, {"sha": "e64d1b564214c0ebf99ce753b7aee5c071447fe8", "filename": "gcc/profile-count.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9a497f07457d63c74962ee0d90c96bdd98f918/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9a497f07457d63c74962ee0d90c96bdd98f918/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=4e9a497f07457d63c74962ee0d90c96bdd98f918", "patch": "@@ -37,7 +37,15 @@ profile_count::dump (FILE *f) const\n   if (!initialized_p ())\n     fprintf (f, \"uninitialized\");\n   else\n-    fprintf (f, \"%\" PRId64, m_val);\n+    {\n+      fprintf (f, \"%\" PRId64, m_val);\n+      if (m_quality == count_adjusted)\n+\tfprintf (f, \"(adjusted)\");\n+      else if (m_quality == count_afdo)\n+\tfprintf (f, \"(auto FDO)\");\n+      else if (m_quality == count_guessed)\n+\tfprintf (f, \"(guessed)\");\n+    }\n }\n \n void\n@@ -51,7 +59,7 @@ profile_count::differs_from_p (profile_count other) const\n {\n   if (!initialized_p () || !other.initialized_p ())\n     return false;\n-  if (m_val - other.m_val < 100 && other.m_val - m_val < 100)\n+  if (m_val - other.m_val < 100 || other.m_val - m_val < 100)\n     return false;\n   if (!other.m_val)\n     return true;\n@@ -64,17 +72,20 @@ profile_count::stream_in (struct lto_input_block *ib)\n {\n   profile_count ret;\n   ret.m_val = streamer_read_gcov_count (ib);\n+  ret.m_quality = (profile_count_quality) streamer_read_uhwi (ib);\n   return ret;\n }\n \n void\n profile_count::stream_out (struct output_block *ob)\n {\n   streamer_write_gcov_count (ob, m_val);\n+  streamer_write_uhwi (ob, m_quality);\n }\n \n void\n profile_count::stream_out (struct lto_output_stream *ob)\n {\n   streamer_write_gcov_count_stream (ob, m_val);\n+  streamer_write_uhwi_stream (ob, m_quality);\n }"}, {"sha": "cdd79060ee290535dcab25b6925e9143ba6bb574", "filename": "gcc/profile-count.h", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e9a497f07457d63c74962ee0d90c96bdd98f918/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e9a497f07457d63c74962ee0d90c96bdd98f918/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=4e9a497f07457d63c74962ee0d90c96bdd98f918", "patch": "@@ -21,6 +21,22 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_PROFILE_COUNT_H\n #define GCC_PROFILE_COUNT_H\n \n+/* Quality of the proflie count.  Because gengtype does not support enums\n+   inside of clases, this is in global namespace.  */\n+enum profile_count_quality {\n+  /* Profile is based on static branch prediction heuristics.  It may or may\n+     not reflect the reality.  */\n+  count_guessed = 0,\n+  /* Profile was determined by autofdo.  */\n+  count_afdo = 2,\n+  /* Profile was originally based on feedback but it was adjusted \n+     by code duplicating optimization.  It may not precisely reflect the\n+     particular code path.  */\n+  count_adjusted = 1,\n+  /* Profile was read from profile feedback or determined by accurate static\n+     method.  */\n+  count_read = 3\n+};\n \n /* The base value for branch probability notes and edge probabilities.  */\n #define REG_BR_PROB_BASE  10000\n@@ -58,17 +74,21 @@ along with GCC; see the file COPYING3.  If not see\n \n  */\n \n-\n class GTY(()) profile_count\n {\n-  /* Use int64_t to hold basic block counters.  Should be at least\n+  /* Use 62bit to hold basic block counters.  Should be at least\n      64bit.  Although a counter cannot be negative, we use a signed\n      type to hold various extra stages.  */\n \n-  int64_t m_val;\n+  static const int n_bits = 62;\n+  static const uint64_t max_count = ((uint64_t) 1 << n_bits) - 2;\n+  static const uint64_t uninitialized_count = ((uint64_t) 1 << n_bits) - 1;\n+\n+  uint64_t m_val : n_bits;\n+  enum profile_count_quality m_quality : 2;\n \n   /* Assume numbers smaller than this to multiply.  This is set to make\n-     testsuite pass, in future we may implement precise multiples in higer\n+     testsuite pass, in future we may implement precise multiplication in higer\n      rangers.  */\n   static const int64_t max_safe_multiplier = 131072;\n public:\n@@ -87,7 +107,8 @@ class GTY(()) profile_count\n   static profile_count uninitialized ()\n     {\n       profile_count c;\n-      c.m_val = -1;\n+      c.m_val = uninitialized_count;\n+      c.m_quality = count_guessed;\n       return c;\n     }\n \n@@ -97,8 +118,9 @@ class GTY(()) profile_count\n   static profile_count from_gcov_type (gcov_type v)\n     {\n       profile_count ret;\n-      gcc_checking_assert (v>=0);\n+      gcc_checking_assert (v >= 0 && (uint64_t) v <= max_count);\n       ret.m_val = v;\n+      ret.m_quality = count_read;\n       return ret;\n     }\n \n@@ -112,7 +134,7 @@ class GTY(()) profile_count\n   /* Return true if value has been initialized.  */\n   bool initialized_p () const\n     {\n-      return m_val != -1;\n+      return m_val != uninitialized_count;\n     }\n   /* Return true if value can be trusted.  */\n   bool reliable_p () const\n@@ -123,7 +145,7 @@ class GTY(()) profile_count\n   /* Basic operations.  */\n   bool operator== (const profile_count &other) const\n     {\n-      return m_val == other.m_val;\n+      return m_val == other.m_val && m_quality == other.m_quality;\n     }\n   profile_count operator+ (const profile_count &other) const\n     {\n@@ -136,6 +158,7 @@ class GTY(()) profile_count\n \n       profile_count ret;\n       ret.m_val = m_val + other.m_val;\n+      ret.m_quality = MIN (m_quality, other.m_quality);\n       return ret;\n     }\n   profile_count &operator+= (const profile_count &other)\n@@ -150,7 +173,10 @@ class GTY(()) profile_count\n       if (!initialized_p () || !other.initialized_p ())\n \treturn *this = profile_count::uninitialized ();\n       else\n-\tm_val += other.m_val;\n+\t{\n+\t  m_val += other.m_val;\n+          m_quality = MIN (m_quality, other.m_quality);\n+\t}\n       return *this;\n     }\n   profile_count operator- (const profile_count &other) const\n@@ -160,7 +186,8 @@ class GTY(()) profile_count\n       if (!initialized_p () || !other.initialized_p ())\n \treturn profile_count::uninitialized ();\n       profile_count ret;\n-      ret.m_val = MAX (m_val - other.m_val, 0);\n+      ret.m_val = m_val >= other.m_val ? m_val - other.m_val : 0;\n+      ret.m_quality = MIN (m_quality, other.m_quality);\n       return ret;\n     }\n   profile_count &operator-= (const profile_count &other)\n@@ -170,14 +197,17 @@ class GTY(()) profile_count\n       if (!initialized_p () || !other.initialized_p ())\n \treturn *this = profile_count::uninitialized ();\n       else\n-\tm_val = MAX (m_val - other.m_val, 0);\n+\t{\n+\t  m_val = m_val >= other.m_val ? m_val - other.m_val: 0;\n+          m_quality = MIN (m_quality, other.m_quality);\n+\t}\n       return *this;\n     }\n \n   /* Return false if profile_count is bogus.  */\n   bool verify () const\n     {\n-      return m_val >= -1;\n+      return m_val != uninitialized_count || m_quality == count_guessed;\n     }\n \n   /* Comparsions are three-state and conservative.  False is returned if\n@@ -192,11 +222,13 @@ class GTY(()) profile_count\n     }\n   bool operator< (const gcov_type other) const\n     {\n-      return initialized_p () && m_val < other;\n+      gcc_checking_assert (other >= 0);\n+      return initialized_p () && m_val < (uint64_t) other;\n     }\n   bool operator> (const gcov_type other) const\n     {\n-      return initialized_p () && m_val > other;\n+      gcc_checking_assert (other >= 0);\n+      return initialized_p () && m_val > (uint64_t) other;\n     }\n \n   bool operator<= (const profile_count &other) const\n@@ -209,11 +241,13 @@ class GTY(()) profile_count\n     }\n   bool operator<= (const gcov_type other) const\n     {\n-      return initialized_p () && m_val <= other;\n+      gcc_checking_assert (other >= 0);\n+      return initialized_p () && m_val <= (uint64_t) other;\n     }\n   bool operator>= (const gcov_type other) const\n     {\n-      return initialized_p () && m_val >= other;\n+      gcc_checking_assert (other >= 0);\n+      return initialized_p () && m_val >= (uint64_t) other;\n     }\n \n   /* PROB is a probability in scale 0...REG_BR_PROB_BASE.  Scale counter\n@@ -227,6 +261,7 @@ class GTY(()) profile_count\n \treturn profile_count::uninitialized ();\n       profile_count ret;\n       ret.m_val = RDIV (m_val * prob, REG_BR_PROB_BASE);\n+      ret.m_quality = MIN (m_quality, count_adjusted);\n       return ret;\n     }\n   /* Return *THIS * NUM / DEN.  */\n@@ -243,6 +278,7 @@ class GTY(()) profile_count\n \t\t\t        || den <= REG_BR_PROB_BASE)\n \t\t\t    && den > 0) || 1);\n       ret.m_val = RDIV (m_val * num, den);\n+      ret.m_quality = MIN (m_quality, count_adjusted);\n       return ret;\n     }\n   profile_count apply_scale (profile_count num, profile_count den) const\n@@ -251,14 +287,18 @@ class GTY(()) profile_count\n \treturn profile_count::zero ();\n       if (!initialized_p () || !num.initialized_p () || !den.initialized_p ())\n \treturn profile_count::uninitialized ();\n-      profile_count ret;\n       gcc_checking_assert (den > 0);\n+      if (num == den)\n+\treturn *this;\n+\n+      profile_count ret;\n       /* Take care for overflows!  */\n       if (num.m_val < max_safe_multiplier || m_val < max_safe_multiplier)\n         ret.m_val = RDIV (m_val * num.m_val, den.m_val);\n       else\n         ret.m_val = RDIV (m_val * RDIV (num.m_val * max_safe_multiplier,\n \t\t\t\t\tden.m_val), max_safe_multiplier);\n+      ret.m_quality = MIN (m_quality, count_adjusted);\n       return ret;\n     }\n "}]}