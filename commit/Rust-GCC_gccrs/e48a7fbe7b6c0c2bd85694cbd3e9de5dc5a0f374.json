{"sha": "e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ4YTdmYmU3YjZjMGMyYmQ4NTY5NGNiZDNlOWRlNWRjNWEwZjM3NA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-09-25T19:13:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-25T19:13:18Z"}, "message": "cse.c: Update comments.\n\n        * cse.c: Update comments.\n        (cse_insn): When converting a conditional/computed jump into\n        an unconditional jump, always make sure a BARRIER immediately\n        follows the converted jump.  Do not delete unreachable code.\n        (cse_basic_block): Do not delete unreachable code.\n        * toplev.c (rest_of_compilation): Move call to\n        delete_trivially_dead_insns after the conditional call to\n        jump_optimize.\n\nFrom-SVN: r29665", "tree": {"sha": "6cba319247dacc4698f137bc5577241ff4fbb0f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cba319247dacc4698f137bc5577241ff4fbb0f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374/comments", "author": null, "committer": null, "parents": [{"sha": "57151693bcd51686403400d7e924c00389883ce4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57151693bcd51686403400d7e924c00389883ce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57151693bcd51686403400d7e924c00389883ce4"}], "stats": {"total": 76, "additions": 28, "deletions": 48}, "files": [{"sha": "13ee0e9f53eeb301595870c92923435bcbda2139", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374", "patch": "@@ -1,3 +1,14 @@\n+Sat Sep 25 13:11:07 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* cse.c: Update comments.\n+\t(cse_insn): When converting a conditional/computed jump into\n+\tan unconditional jump, always make sure a BARRIER immediately\n+\tfollows the converted jump.  Do not delete unreachable code.\n+\t(cse_basic_block): Do not delete unreachable code.\n+\t* toplev.c (rest_of_compilation): Move call to \n+\tdelete_trivially_dead_insns after the conditional call to\n+\tjump_optimize.\n+\n Sat Sep 25 09:03:17 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* collect2.c (make_temp_file): Don't prototype."}, {"sha": "d9ed6253fbdcb5f006c2a726590a6d0adf68c5a3", "filename": "gcc/cse.c", "status": "modified", "additions": 13, "deletions": 46, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374", "patch": "@@ -45,12 +45,14 @@ Boston, MA 02111-1307, USA.  */\n    expressions encountered with the cheapest equivalent expression.\n \n    It is too complicated to keep track of the different possibilities\n-   when control paths merge; so, at each label, we forget all that is\n-   known and start fresh.  This can be described as processing each\n-   basic block separately.  Note, however, that these are not quite\n-   the same as the basic blocks found by a later pass and used for\n-   data flow analysis and register packing.  We do not need to start fresh\n-   after a conditional jump instruction if there is no label there.\n+   when control paths merge in this code; so, at each label, we forget all\n+   that is known and start fresh.  This can be described as processing each\n+   extended basic block separately.  We have a separate pass to perform\n+   global CSE.\n+\n+   Note CSE can turn a conditional or computed jump into a nop or\n+   an unconditional jump.  When this occurs we arrange to run the jump\n+   optimizer after CSE to delete the unreachable code.\n \n    We use two data structures to record the equivalent expressions:\n    a hash table for most expressions, and several vectors together\n@@ -7417,7 +7419,6 @@ cse_insn (insn, libcall_insn)\n \t      rtx new = emit_jump_insn_before (gen_jump (XEXP (src, 0)), insn);\n \t      JUMP_LABEL (new) = XEXP (src, 0);\n \t      LABEL_NUSES (XEXP (src, 0))++;\n-\t      delete_insn (insn);\n \t      insn = new;\n \t    }\n \t  else\n@@ -7428,44 +7429,13 @@ cse_insn (insn, libcall_insn)\n \t       Until the right place is found, might as well do this here.  */\n \t    INSN_CODE (insn) = -1;\n \n-\t  /* Now that we've converted this jump to an unconditional jump,\n-\t     there is dead code after it.  Delete the dead code until we\n-\t     reach a BARRIER, the end of the function, or a label.  Do\n-\t     not delete NOTEs except for NOTE_INSN_DELETED since later\n-\t     phases assume these notes are retained.  */\n-\n \t  never_reached_warning (insn);\n \n-\t  p = insn;\n-\n-\t  while (NEXT_INSN (p) != 0\n-\t\t && GET_CODE (NEXT_INSN (p)) != BARRIER\n-\t\t && GET_CODE (NEXT_INSN (p)) != CODE_LABEL)\n-\t    {\n-\t      /* Note, we must update P with the return value from\n-\t\t delete_insn, otherwise we could get an infinite loop\n-\t\t if NEXT_INSN (p) had INSN_DELETED_P set.  */\n-\t      if (GET_CODE (NEXT_INSN (p)) != NOTE\n-\t\t  || NOTE_LINE_NUMBER (NEXT_INSN (p)) == NOTE_INSN_DELETED)\n-\t\tp = PREV_INSN (delete_insn (NEXT_INSN (p)));\n-\t      else\n-\t\tp = NEXT_INSN (p);\n-\t    }\n-\n-\t  /* If we don't have a BARRIER immediately after INSN, put one there.\n-\t     Much code assumes that there are no NOTEs between a JUMP_INSN and\n-\t     BARRIER.  */\n-\n-\t  if (NEXT_INSN (insn) == 0\n-\t      || GET_CODE (NEXT_INSN (insn)) != BARRIER)\n-\t    emit_barrier_before (NEXT_INSN (insn));\n-\n-\t  /* We might have two BARRIERs separated by notes.  Delete the second\n-\t     one if so.  */\n-\n-\t  if (p != insn && NEXT_INSN (p) != 0\n-\t      && GET_CODE (NEXT_INSN (p)) == BARRIER)\n-\t    delete_insn (NEXT_INSN (p));\n+\t  /* Now emit a BARRIER after the unconditional jump.  Do not bother\n+\t     deleting any unreachable code, let jump/flow do that.  */\n+\t  if (NEXT_INSN (insn) != 0\n+\t      && GET_CODE (NEXT_INSN (insn)) != BARRIER)\n+\t    emit_barrier_after (insn);\n \n \t  cse_jumps_altered = 1;\n \t  sets[i].rtl = 0;\n@@ -8968,9 +8938,6 @@ cse_basic_block (from, to, next_branch, around_loop)\n \n \t  insn = NEXT_INSN (to);\n \n-\t  if (LABEL_NUSES (to) == 0)\n-\t    insn = delete_insn (to);\n-\n \t  /* If TO was the last insn in the function, we are done.  */\n \t  if (insn == 0)\n \t    return 0;"}, {"sha": "b4e65c7ff7cbc0edc8c7a5915d9450ad35d82f06", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=e48a7fbe7b6c0c2bd85694cbd3e9de5dc5a0f374", "patch": "@@ -3745,8 +3745,6 @@ rest_of_compilation (decl)\n \n       TIMEVAR (cse_time, tem = cse_main (insns, max_reg_num (),\n \t\t\t\t\t 0, rtl_dump_file));\n-      TIMEVAR (cse_time, delete_trivially_dead_insns (insns, max_reg_num ()));\n-\n       /* If we are not running the second CSE pass, then we are no longer\n \t expecting CSE to be run.  */\n       cse_not_expected = !flag_rerun_cse_after_loop;\n@@ -3756,6 +3754,10 @@ rest_of_compilation (decl)\n \t\t\t\t\t   !JUMP_NOOP_MOVES,\n \t\t\t\t\t   !JUMP_AFTER_REGSCAN));\n  \n+      /* Run this after jump optmizations remove all the unreachable code\n+\t so that unreachable code will not keep values live.  */\n+      TIMEVAR (cse_time, delete_trivially_dead_insns (insns, max_reg_num ()));\n+\n       /* Try to identify useless null pointer tests and delete them.  */\n       if (flag_delete_null_pointer_checks)\n \tTIMEVAR (jump_time, delete_null_pointer_checks (get_insns ()));"}]}