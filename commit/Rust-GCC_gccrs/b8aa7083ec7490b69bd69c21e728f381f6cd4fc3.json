{"sha": "b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhhYTcwODNlYzc0OTBiNjliZDY5YzIxZTcyOGYzODFmNmNkNGZjMw==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2015-01-29T13:52:28Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-01-29T13:52:28Z"}, "message": "re PR tree-optimization/64746 (Loop with nested load/stores is not vectorized using aggressive if-conversion.)\n\ngcc/\n\n\tPR tree-optimization/64746\n\t* tree-if-conv.c (mask_exists): New function.\n\t(predicate_mem_writes): Save created mask with given size for further\n\tuse.\n\t(stmt_is_root_of_bool_pattern): Remove argument VAR and store to it.\n\t(ifcvt_repair_bool_pattern): Collect all statements that are root\n\tof bool pattern and use iterative algorithm to remove multiple uses\n\tof predicates, display number of required iterations.\n\ngcc/testsuite/\n\n\tPR tree-optimization/64746\n\t* gcc.target/i386/avx2-vect-aggressive-1.c: New test.\n\nFrom-SVN: r220248", "tree": {"sha": "580d0bf030254594d77906cd1a8f4404e385f004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/580d0bf030254594d77906cd1a8f4404e385f004"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d94e3e750d1e5c2fc9ecc8e8a32adec33fc85f8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d94e3e750d1e5c2fc9ecc8e8a32adec33fc85f8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d94e3e750d1e5c2fc9ecc8e8a32adec33fc85f8e"}], "stats": {"total": 145, "additions": 124, "deletions": 21}, "files": [{"sha": "7424d9faa42cb7e2da21b11d419e3813ad05f0cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "patch": "@@ -1,3 +1,14 @@\n+2015-01-29  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\tPR tree-optimization/64746\n+\t* tree-if-conv.c (mask_exists): New function.\n+\t(predicate_mem_writes): Save created mask with given size for further\n+\tuse.\n+\t(stmt_is_root_of_bool_pattern): Remove argument VAR and store to it.\n+\t(ifcvt_repair_bool_pattern): Collect all statements that are root\n+\tof bool pattern and use iterative algorithm to remove multiple uses\n+\tof predicates, display number of required iterations.\n+\n 2015-01-29  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/64853"}, {"sha": "69488ec0106a01c2aa7fb5c02cf7957aaa9affec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "patch": "@@ -1,3 +1,8 @@\n+2015-01-29  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\tPR tree-optimization/64746\n+\t* gcc.target/i386/avx2-vect-aggressive-1.c: New test.\n+\n 2015-01-29  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/64853"}, {"sha": "a9a88e12a3b06e898653fbe4cf9e64a908bcc041", "filename": "gcc/testsuite/gcc.target/i386/avx2-vect-aggressive-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-aggressive-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-aggressive-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx2-vect-aggressive-1.c?ref=b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target avx2 } */\n+/* { dg-options \"-mavx2 -O3 -fopenmp-simd -fdump-tree-vect-details\" } */\n+\n+#define N 256\n+int a1[N], a2[N], a3[N], a4[N], a5[N], a6[N], a7[N];\n+\n+void foo()\n+{\n+  int x1, x2, x3;\n+  int i;\n+#pragma omp simd safelen(8)\n+  for (i=0; i<N; i++)\n+    {\n+      x1 = a1[i] + a2 [i];\n+\tif (x1 >= 0 && x1 != 3)\n+\t  {\n+\t    x2 = a3[i] - a1[i];\n+\t    if (x2 >= 0 && x2 != 4)\n+\t      {\n+\t\tx3 = a4[i] + a5[i];\n+\t\tif (x3 >= 0 && x3 != 5)\n+\t\t  {\n+\t\t    a6[i] = x1 - x2;\n+\t\t    a7[i] = x3 + x2;\n+\t\t  }\n+\t      }\n+\t  }\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "400ee01a5122c0c74b21a9b100f36b2951e45a46", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 75, "deletions": 21, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8aa7083ec7490b69bd69c21e728f381f6cd4fc3/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=b8aa7083ec7490b69bd69c21e728f381f6cd4fc3", "patch": "@@ -1974,6 +1974,20 @@ insert_gimplified_predicates (loop_p loop, bool any_mask_load_store)\n     }\n }\n \n+/* Helper function for predicate_mem_writes. Returns index of existent\n+   mask if it was created for given SIZE and -1 otherwise.  */\n+\n+static int\n+mask_exists (int size, vec<int> vec)\n+{\n+  unsigned int ix;\n+  int v;\n+  FOR_EACH_VEC_ELT (vec, ix, v)\n+    if (v == size)\n+      return (int) ix;\n+  return -1;\n+}\n+\n /* Predicate each write to memory in LOOP.\n \n    This function transforms control flow constructs containing memory\n@@ -2085,6 +2099,8 @@ static void\n predicate_mem_writes (loop_p loop)\n {\n   unsigned int i, orig_loop_num_nodes = loop->num_nodes;\n+  auto_vec<int, 1> vect_sizes;\n+  auto_vec<tree, 1> vect_masks;\n \n   for (i = 1; i < orig_loop_num_nodes; i++)\n     {\n@@ -2093,6 +2109,7 @@ predicate_mem_writes (loop_p loop)\n       tree cond = bb_predicate (bb);\n       bool swap;\n       gimple stmt;\n+      int index;\n \n       if (is_true_predicate (cond))\n \tcontinue;\n@@ -2104,6 +2121,9 @@ predicate_mem_writes (loop_p loop)\n \t  cond = TREE_OPERAND (cond, 0);\n \t}\n \n+      vect_sizes.truncate (0);\n+      vect_masks.truncate (0);\n+\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \tif (!gimple_assign_single_p (stmt = gsi_stmt (gsi)))\n \t  continue;\n@@ -2114,21 +2134,31 @@ predicate_mem_writes (loop_p loop)\n \t    tree ref, addr, ptr, masktype, mask_op0, mask_op1, mask;\n \t    gimple new_stmt;\n \t    int bitsize = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (lhs)));\n-\n-\t    masktype = build_nonstandard_integer_type (bitsize, 1);\n-\t    mask_op0 = build_int_cst (masktype, swap ? 0 : -1);\n-\t    mask_op1 = build_int_cst (masktype, swap ? -1 : 0);\n \t    ref = TREE_CODE (lhs) == SSA_NAME ? rhs : lhs;\n \t    mark_addressable (ref);\n \t    addr = force_gimple_operand_gsi (&gsi, build_fold_addr_expr (ref),\n \t\t\t\t\t     true, NULL_TREE, true,\n \t\t\t\t\t     GSI_SAME_STMT);\n-\t    cond = force_gimple_operand_gsi_1 (&gsi, unshare_expr (cond),\n-\t\t\t\t\t       is_gimple_condexpr, NULL_TREE,\n-\t\t\t\t\t       true, GSI_SAME_STMT);\n-\t    mask = fold_build_cond_expr (masktype, unshare_expr (cond),\n-\t\t\t\t\t mask_op0, mask_op1);\n-\t    mask = ifc_temp_var (masktype, mask, &gsi);\n+\t    if (!vect_sizes.is_empty ()\n+\t\t&& (index = mask_exists (bitsize, vect_sizes)) != -1)\n+\t      /* Use created mask.  */\n+\t      mask = vect_masks[index];\n+\t    else\n+\t      {\n+\t\tmasktype = build_nonstandard_integer_type (bitsize, 1);\n+\t\tmask_op0 = build_int_cst (masktype, swap ? 0 : -1);\n+\t\tmask_op1 = build_int_cst (masktype, swap ? -1 : 0);\n+\t\tcond = force_gimple_operand_gsi_1 (&gsi, unshare_expr (cond),\n+\t\t\t\t\t\t   is_gimple_condexpr,\n+\t\t\t\t\t\t   NULL_TREE,\n+\t\t\t\t\t\t   true, GSI_SAME_STMT);\n+\t\tmask = fold_build_cond_expr (masktype, unshare_expr (cond),\n+\t\t\t\t\t     mask_op0, mask_op1);\n+\t\tmask = ifc_temp_var (masktype, mask, &gsi);\n+\t\t/* Save mask and its size for further use.  */\n+\t        vect_sizes.safe_push (bitsize);\n+\t\tvect_masks.safe_push (mask);\n+\t      }\n \t    ptr = build_int_cst (reference_alias_ptr_type (ref), 0);\n \t    /* Copy points-to info if possible.  */\n \t    if (TREE_CODE (addr) == SSA_NAME && !SSA_NAME_PTR_INFO (addr))\n@@ -2494,10 +2524,10 @@ ifcvt_walk_pattern_tree (tree var, vec<gimple> *defuse_list,\n }\n \n /* Returns true if STMT can be a root of bool pattern apllied\n-   by vectorizer.  VAR contains SSA_NAME which starts pattern.  */\n+   by vectorizer.  */\n \n static bool\n-stmt_is_root_of_bool_pattern (gimple stmt, tree *var)\n+stmt_is_root_of_bool_pattern (gimple stmt)\n {\n   enum tree_code code;\n   tree lhs, rhs;\n@@ -2511,15 +2541,13 @@ stmt_is_root_of_bool_pattern (gimple stmt, tree *var)\n \treturn false;\n       if (TREE_CODE (TREE_TYPE (lhs)) == BOOLEAN_TYPE)\n \treturn false;\n-      *var = rhs;\n       return true;\n     }\n   else if (code == COND_EXPR)\n     {\n       rhs = gimple_assign_rhs1 (stmt);\n       if (TREE_CODE (rhs) != SSA_NAME)\n \treturn false;\n-      *var = rhs;\n       return true;\n     }\n   return false;\n@@ -2538,23 +2566,49 @@ ifcvt_repair_bool_pattern (basic_block bb)\n   gimple stmt;\n   gimple_stmt_iterator gsi;\n   vec<gimple> defuse_list = vNULL;\n+  vec<gimple> pattern_roots = vNULL;\n+  bool repeat = true;\n+  int niter = 0;\n+  unsigned int ix;\n \n+  /* Collect all root pattern statements.  */\n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       stmt = gsi_stmt (gsi);\n       if (gimple_code (stmt) != GIMPLE_ASSIGN)\n \tcontinue;\n-      if (!stmt_is_root_of_bool_pattern (stmt, &rhs))\n+      if (!stmt_is_root_of_bool_pattern (stmt))\n \tcontinue;\n-      ifcvt_walk_pattern_tree (rhs, &defuse_list, stmt);\n-      while (defuse_list.length () > 0)\n+      pattern_roots.safe_push (stmt);\n+    }\n+\n+  if (pattern_roots.is_empty ())\n+    return;\n+\n+  /* Split all statements with multiple uses iteratively since splitting\n+     may create new multiple uses.  */\n+  while (repeat)\n+    {\n+      repeat = false;\n+      niter++;\n+      FOR_EACH_VEC_ELT (pattern_roots, ix, stmt)\n \t{\n-\t  gimple def_stmt, use_stmt;\n-\t  use_stmt = defuse_list.pop ();\n-\t  def_stmt = defuse_list.pop ();\n-\t  ifcvt_split_def_stmt (def_stmt, use_stmt);\n+\t  rhs = gimple_assign_rhs1 (stmt);\n+\t  ifcvt_walk_pattern_tree (rhs, &defuse_list, stmt);\n+\t  while (defuse_list.length () > 0)\n+\t    {\n+\t      repeat = true;\n+\t      gimple def_stmt, use_stmt;\n+\t      use_stmt = defuse_list.pop ();\n+\t      def_stmt = defuse_list.pop ();\n+\t      ifcvt_split_def_stmt (def_stmt, use_stmt);\n+\t    }\n+\n \t}\n     }\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Repair bool pattern takes %d iterations. \\n\",\n+\t     niter);\n }\n \n /* Delete redundant statements produced by predication which prevents"}]}