{"sha": "12be130c3f1d09b4b9923de6b4c1c66d61c9497c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJiZTEzMGMzZjFkMDliNGI5OTIzZGU2YjRjMWM2NmQ2MWM5NDk3Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-04-21T20:28:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-18T09:08:25Z"}, "message": "[Ada] Improve compile-time evaluation of value ranges\n\n2020-06-18  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* checks.adb (Compute_Range_For_Arithmetic_Op): New procedure to\n\tcompute a range for an arithmetical operation extracted from...\n\t(Minimize_Eliminate_Overflows): ...here.  Call it.\n\t(Determine_Range_Cache_O): New cache for Original_Node nodes.\n\t(Determine_Range): Call Compute_Range_For_Arithmetic_Op for all\n\tarithmetic expressions. Use Attribute_Id in lieu of Attribute_Name\n\tfor attributes. Add handling for Range_Length alongside Length.\n\tAdd specific handling for Alignment, Bit, First_Bit, Last_Bit,\n\tMax_Size_In_Storage_Elements, Position, Bit_Position,\n\tComponent_Size, Object_Size, Size, Value_Size, Descriptor_Size.\n\t(Enable_Overflow_Check): Omit the check for Abs and Minus if the\n\toperand cannot be the largest negative number.\n\t(Selected_Length_Checks): Use Pos for Number_Dimensions.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Move compile-time\n\thandling of Bit_Position, Descriptor_Size, First_Bit, Last_Bit\n\tand Position to...\n\t* sem_attr.adb (Eval_Attribute): ...here.  Move up Alignment for\n\tobjects and use Compile_Time_Known_Attribute in this case too.", "tree": {"sha": "49357cc48430c837a2ef5777430c73ee9a2b8830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49357cc48430c837a2ef5777430c73ee9a2b8830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12be130c3f1d09b4b9923de6b4c1c66d61c9497c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12be130c3f1d09b4b9923de6b4c1c66d61c9497c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12be130c3f1d09b4b9923de6b4c1c66d61c9497c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12be130c3f1d09b4b9923de6b4c1c66d61c9497c/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78689aa295f9b0e54807462d13d3125a5a83c64b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78689aa295f9b0e54807462d13d3125a5a83c64b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78689aa295f9b0e54807462d13d3125a5a83c64b"}], "stats": {"total": 1282, "additions": 667, "deletions": 615}, "files": [{"sha": "746688f963eca9bf8c6618d83d45c70393196371", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 506, "deletions": 432, "changes": 938, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12be130c3f1d09b4b9923de6b4c1c66d61c9497c/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12be130c3f1d09b4b9923de6b4c1c66d61c9497c/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=12be130c3f1d09b4b9923de6b4c1c66d61c9497c", "patch": "@@ -250,6 +250,21 @@ package body Checks is\n    --  routine. The Do_Static flag indicates that only a static check is\n    --  to be done.\n \n+   procedure Compute_Range_For_Arithmetic_Op\n+     (Op       : Node_Kind;\n+      Lo_Left  : Uint;\n+      Hi_Left  : Uint;\n+      Lo_Right : Uint;\n+      Hi_Right : Uint;\n+      OK       : out Boolean;\n+      Lo       : out Uint;\n+      Hi       : out Uint);\n+   --  Given an integer arithmetical operation Op and the range of values of\n+   --  its operand(s), try to compute a conservative estimate of the possible\n+   --  range of values for the result of the operation. Thus if OK is True on\n+   --  return, the result is known to lie in the range Lo .. Hi (inclusive).\n+   --  If OK is false, both Lo and Hi are set to No_Uint.\n+\n    type Check_Type is new Check_Id range Access_Check .. Division_Check;\n    function Check_Needed (Nod : Node_Id; Check : Check_Type) return Boolean;\n    --  This function is used to see if an access or division by zero check is\n@@ -4417,6 +4432,307 @@ package body Checks is\n       end if;\n    end Null_Exclusion_Static_Checks;\n \n+   -------------------------------------\n+   -- Compute_Range_For_Arithmetic_Op --\n+   -------------------------------------\n+\n+   procedure Compute_Range_For_Arithmetic_Op\n+     (Op       : Node_Kind;\n+      Lo_Left  : Uint;\n+      Hi_Left  : Uint;\n+      Lo_Right : Uint;\n+      Hi_Right : Uint;\n+      OK       : out Boolean;\n+      Lo       : out Uint;\n+      Hi       : out Uint)\n+   is\n+      --  Use local variables for possible adjustments\n+\n+      Llo : Uint renames Lo_Left;\n+      Lhi : Uint renames Hi_Left;\n+      Rlo : Uint := Lo_Right;\n+      Rhi : Uint := Hi_Right;\n+\n+   begin\n+      --  We will compute a range for the result in almost all cases\n+\n+      OK := True;\n+\n+      case Op is\n+\n+         --  Absolute value\n+\n+         when N_Op_Abs =>\n+            Lo := Uint_0;\n+            Hi := UI_Max (abs Rlo, abs Rhi);\n+\n+         --  Addition\n+\n+         when N_Op_Add =>\n+            Lo := Llo + Rlo;\n+            Hi := Lhi + Rhi;\n+\n+         --  Division\n+\n+         when N_Op_Divide =>\n+\n+            --  If the right operand can only be zero, set 0..0\n+\n+            if Rlo = 0 and then Rhi = 0 then\n+               Lo := Uint_0;\n+               Hi := Uint_0;\n+\n+            --  Possible bounds of division must come from dividing end\n+            --  values of the input ranges (four possibilities), provided\n+            --  zero is not included in the possible values of the right\n+            --  operand.\n+\n+            --  Otherwise, we just consider two intervals of values for\n+            --  the right operand: the interval of negative values (up to\n+            --  -1) and the interval of positive values (starting at 1).\n+            --  Since division by 1 is the identity, and division by -1\n+            --  is negation, we get all possible bounds of division in that\n+            --  case by considering:\n+            --    - all values from the division of end values of input\n+            --      ranges;\n+            --    - the end values of the left operand;\n+            --    - the negation of the end values of the left operand.\n+\n+            else\n+               declare\n+                  Mrk : constant Uintp.Save_Mark := Mark;\n+                  --  Mark so we can release the RR and Ev values\n+\n+                  Ev1 : Uint;\n+                  Ev2 : Uint;\n+                  Ev3 : Uint;\n+                  Ev4 : Uint;\n+\n+               begin\n+                  --  Discard extreme values of zero for the divisor, since\n+                  --  they will simply result in an exception in any case.\n+\n+                  if Rlo = 0 then\n+                     Rlo := Uint_1;\n+                  elsif Rhi = 0 then\n+                     Rhi := -Uint_1;\n+                  end if;\n+\n+                  --  Compute possible bounds coming from dividing end\n+                  --  values of the input ranges.\n+\n+                  Ev1 := Llo / Rlo;\n+                  Ev2 := Llo / Rhi;\n+                  Ev3 := Lhi / Rlo;\n+                  Ev4 := Lhi / Rhi;\n+\n+                  Lo := UI_Min (UI_Min (Ev1, Ev2), UI_Min (Ev3, Ev4));\n+                  Hi := UI_Max (UI_Max (Ev1, Ev2), UI_Max (Ev3, Ev4));\n+\n+                  --  If the right operand can be both negative or positive,\n+                  --  include the end values of the left operand in the\n+                  --  extreme values, as well as their negation.\n+\n+                  if Rlo < 0 and then Rhi > 0 then\n+                     Ev1 := Llo;\n+                     Ev2 := -Llo;\n+                     Ev3 := Lhi;\n+                     Ev4 := -Lhi;\n+\n+                     Lo := UI_Min (Lo,\n+                             UI_Min (UI_Min (Ev1, Ev2), UI_Min (Ev3, Ev4)));\n+                     Hi := UI_Max (Hi,\n+                             UI_Max (UI_Max (Ev1, Ev2), UI_Max (Ev3, Ev4)));\n+                  end if;\n+\n+                  --  Release the RR and Ev values\n+\n+                  Release_And_Save (Mrk, Lo, Hi);\n+               end;\n+            end if;\n+\n+         --  Exponentiation\n+\n+         when N_Op_Expon =>\n+\n+            --  Discard negative values for the exponent, since they will\n+            --  simply result in an exception in any case.\n+\n+            if Rhi < 0 then\n+               Rhi := Uint_0;\n+            elsif Rlo < 0 then\n+               Rlo := Uint_0;\n+            end if;\n+\n+            --  Estimate number of bits in result before we go computing\n+            --  giant useless bounds. Basically the number of bits in the\n+            --  result is the number of bits in the base multiplied by the\n+            --  value of the exponent. If this is big enough that the result\n+            --  definitely won't fit in Long_Long_Integer, return immediately\n+            --  and avoid computing giant bounds.\n+\n+            --  The comparison here is approximate, but conservative, it\n+            --  only clicks on cases that are sure to exceed the bounds.\n+\n+            if Num_Bits (UI_Max (abs Llo, abs Lhi)) * Rhi + 1 > 100 then\n+               Lo := No_Uint;\n+               Hi := No_Uint;\n+               OK := False;\n+               return;\n+\n+            --  If right operand is zero then result is 1\n+\n+            elsif Rhi = 0 then\n+               Lo := Uint_1;\n+               Hi := Uint_1;\n+\n+            else\n+               --  High bound comes either from exponentiation of largest\n+               --  positive value to largest exponent value, or from\n+               --  the exponentiation of most negative value to an\n+               --  even exponent.\n+\n+               declare\n+                  Hi1, Hi2 : Uint;\n+\n+               begin\n+                  if Lhi > 0 then\n+                     Hi1 := Lhi ** Rhi;\n+                  else\n+                     Hi1 := Uint_0;\n+                  end if;\n+\n+                  if Llo < 0 then\n+                     if Rhi mod 2 = 0 then\n+                        Hi2 := Llo ** Rhi;\n+                     else\n+                        Hi2 := Llo ** (Rhi - 1);\n+                     end if;\n+                  else\n+                     Hi2 := Uint_0;\n+                  end if;\n+\n+                  Hi := UI_Max (Hi1, Hi2);\n+               end;\n+\n+               --  Result can only be negative if base can be negative\n+\n+               if Llo < 0 then\n+                  if Rhi mod 2 = 0 then\n+                     Lo := Llo ** (Rhi - 1);\n+                  else\n+                     Lo := Llo ** Rhi;\n+                  end if;\n+\n+               --  Otherwise low bound is minimum ** minimum\n+\n+               else\n+                  Lo := Llo ** Rlo;\n+               end if;\n+            end if;\n+\n+         --  Negation\n+\n+         when N_Op_Minus =>\n+            Lo := -Rhi;\n+            Hi := -Rlo;\n+\n+         --  Mod\n+\n+         when N_Op_Mod =>\n+            declare\n+               Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi) - 1;\n+               --  This is the maximum absolute value of the result\n+\n+            begin\n+               Lo := Uint_0;\n+               Hi := Uint_0;\n+\n+               --  The result depends only on the sign and magnitude of\n+               --  the right operand, it does not depend on the sign or\n+               --  magnitude of the left operand.\n+\n+               if Rlo < 0 then\n+                  Lo := -Maxabs;\n+               end if;\n+\n+               if Rhi > 0 then\n+                  Hi := Maxabs;\n+               end if;\n+            end;\n+\n+         --  Multiplication\n+\n+         when N_Op_Multiply =>\n+\n+            --  Possible bounds of multiplication must come from multiplying\n+            --  end values of the input ranges (four possibilities).\n+\n+            declare\n+               Mrk : constant Uintp.Save_Mark := Mark;\n+               --  Mark so we can release the Ev values\n+\n+               Ev1 : constant Uint := Llo * Rlo;\n+               Ev2 : constant Uint := Llo * Rhi;\n+               Ev3 : constant Uint := Lhi * Rlo;\n+               Ev4 : constant Uint := Lhi * Rhi;\n+\n+            begin\n+               Lo := UI_Min (UI_Min (Ev1, Ev2), UI_Min (Ev3, Ev4));\n+               Hi := UI_Max (UI_Max (Ev1, Ev2), UI_Max (Ev3, Ev4));\n+\n+               --  Release the Ev values\n+\n+               Release_And_Save (Mrk, Lo, Hi);\n+            end;\n+\n+         --  Plus operator (affirmation)\n+\n+         when N_Op_Plus =>\n+            Lo := Rlo;\n+            Hi := Rhi;\n+\n+         --  Remainder\n+\n+         when N_Op_Rem =>\n+            declare\n+               Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi) - 1;\n+               --  This is the maximum absolute value of the result. Note\n+               --  that the result range does not depend on the sign of the\n+               --  right operand.\n+\n+            begin\n+               Lo := Uint_0;\n+               Hi := Uint_0;\n+\n+               --  Case of left operand negative, which results in a range\n+               --  of -Maxabs .. 0 for those negative values. If there are\n+               --  no negative values then Lo value of result is always 0.\n+\n+               if Llo < 0 then\n+                  Lo := -Maxabs;\n+               end if;\n+\n+               --  Case of left operand positive\n+\n+               if Lhi > 0 then\n+                  Hi := Maxabs;\n+               end if;\n+            end;\n+\n+         --  Subtract\n+\n+         when N_Op_Subtract =>\n+            Lo := Llo - Rhi;\n+            Hi := Lhi - Rlo;\n+\n+         --  Nothing else should be possible\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+   end Compute_Range_For_Arithmetic_Op;\n+\n    ----------------------------------\n    -- Conditional_Statements_Begin --\n    ----------------------------------\n@@ -4530,6 +4846,7 @@ package body Checks is\n    --  Determine size of below cache (power of 2 is more efficient)\n \n    Determine_Range_Cache_N    : array (Cache_Index) of Node_Id;\n+   Determine_Range_Cache_O    : array (Cache_Index) of Node_Id;\n    Determine_Range_Cache_V    : array (Cache_Index) of Boolean;\n    Determine_Range_Cache_Lo   : array (Cache_Index) of Uint;\n    Determine_Range_Cache_Hi   : array (Cache_Index) of Uint;\n@@ -4541,7 +4858,9 @@ package body Checks is\n    --  checking calls the routine on the way up the tree, a quadratic behavior\n    --  can otherwise be encountered in large expressions. The cache entry for\n    --  node N is stored in the (N mod Cache_Size) entry, and can be validated\n-   --  by checking the actual node value stored there. The Range_Cache_V array\n+   --  by checking the actual node value stored there. The Range_Cache_O array\n+   --  records the setting of Original_Node (N) so that the cache entry does\n+   --  not become stale when the node N is rewritten. The Range_Cache_V array\n    --  records the setting of Assume_Valid for the cache entry.\n \n    procedure Determine_Range\n@@ -4551,11 +4870,30 @@ package body Checks is\n       Hi           : out Uint;\n       Assume_Valid : Boolean := False)\n    is\n+      Kind : constant Node_Kind := Nkind (N);\n+      --  Kind of node\n+\n+      function Half_Address_Space return Uint;\n+      --  The size of half the total addressable memory space in storage units\n+      --  (minus one, so that the size fits in a signed integer whose size is\n+      --  System_Address_Size, which helps in various cases).\n+\n+      ------------------------\n+      -- Half_Address_Space --\n+      ------------------------\n+\n+      function Half_Address_Space return Uint is\n+      begin\n+         return Uint_2 ** (System_Address_Size - 1) - 1;\n+      end Half_Address_Space;\n+\n+      --  Local variables\n+\n       Typ : Entity_Id := Etype (N);\n       --  Type to use, may get reset to base type for possibly invalid entity\n \n-      Lo_Left : Uint;\n-      Hi_Left : Uint;\n+      Lo_Left : Uint := No_Uint;\n+      Hi_Left : Uint := No_Uint;\n       --  Lo and Hi bounds of left operand\n \n       Lo_Right : Uint := No_Uint;\n@@ -4581,29 +4919,6 @@ package body Checks is\n       Btyp : Entity_Id;\n       --  Base type\n \n-      function OK_Operands return Boolean;\n-      --  Used for binary operators. Determines the ranges of the left and\n-      --  right operands, and if they are both OK, returns True, and puts\n-      --  the results in Lo_Right, Hi_Right, Lo_Left, Hi_Left.\n-\n-      -----------------\n-      -- OK_Operands --\n-      -----------------\n-\n-      function OK_Operands return Boolean is\n-      begin\n-         Determine_Range\n-           (Left_Opnd  (N), OK1, Lo_Left,  Hi_Left, Assume_Valid);\n-\n-         if not OK1 then\n-            return False;\n-         end if;\n-\n-         Determine_Range\n-           (Right_Opnd (N), OK1, Lo_Right, Hi_Right, Assume_Valid);\n-         return OK1;\n-      end OK_Operands;\n-\n    --  Start of processing for Determine_Range\n \n    begin\n@@ -4681,6 +4996,8 @@ package body Checks is\n \n       if Determine_Range_Cache_N (Cindex) = N\n            and then\n+         Determine_Range_Cache_O (Cindex) = Original_Node (N)\n+           and then\n          Determine_Range_Cache_V (Cindex) = Assume_Valid\n       then\n          Lo := Determine_Range_Cache_Lo (Cindex);\n@@ -4736,7 +5053,7 @@ package body Checks is\n       --  corresponding base type bound if possible. If we can't get a bound\n       --  then we figure we can't determine the range (a peculiar case, that\n       --  perhaps cannot happen, but there is no point in bombing in this\n-      --  optimization circuit.\n+      --  optimization circuit).\n \n       --  First the low bound\n \n@@ -4781,198 +5098,121 @@ package body Checks is\n       --  refinement is possible, then Lor and Hir are set to possibly tighter\n       --  bounds, and OK1 is set to True.\n \n-      case Nkind (N) is\n-\n-         --  For unary plus, result is limited by range of operand\n-\n-         when N_Op_Plus =>\n-            Determine_Range\n-              (Right_Opnd (N), OK1, Lor, Hir, Assume_Valid);\n+      case Kind is\n \n-         --  For unary minus, determine range of operand, and negate it\n+         --  Unary operation case\n \n-         when N_Op_Minus =>\n+         when N_Op_Abs\n+            | N_Op_Minus\n+            | N_Op_Plus\n+         =>\n             Determine_Range\n               (Right_Opnd (N), OK1, Lo_Right, Hi_Right, Assume_Valid);\n \n             if OK1 then\n-               Lor := -Hi_Right;\n-               Hir := -Lo_Right;\n-            end if;\n-\n-         --  For binary addition, get range of each operand and do the\n-         --  addition to get the result range.\n-\n-         when N_Op_Add =>\n-            if OK_Operands then\n-               Lor := Lo_Left + Lo_Right;\n-               Hir := Hi_Left + Hi_Right;\n-            end if;\n-\n-         --  Division is tricky. The only case we consider is where the right\n-         --  operand is a positive constant, and in this case we simply divide\n-         --  the bounds of the left operand\n-\n-         when N_Op_Divide =>\n-            if OK_Operands then\n-               if Lo_Right = Hi_Right\n-                 and then Lo_Right > 0\n-               then\n-                  Lor := Lo_Left / Lo_Right;\n-                  Hir := Hi_Left / Lo_Right;\n-               else\n-                  OK1 := False;\n-               end if;\n+               Compute_Range_For_Arithmetic_Op\n+                 (Kind, Lo_Left, Hi_Left, Lo_Right, Hi_Right, OK1, Lor, Hir);\n             end if;\n \n-         --  For binary subtraction, get range of each operand and do the worst\n-         --  case subtraction to get the result range.\n-\n-         when N_Op_Subtract =>\n-            if OK_Operands then\n-               Lor := Lo_Left - Hi_Right;\n-               Hir := Hi_Left - Lo_Right;\n-            end if;\n-\n-         --  For MOD, if right operand is a positive constant, then result must\n-         --  be in the allowable range of mod results.\n-\n-         when N_Op_Mod =>\n-            if OK_Operands then\n-               if Lo_Right = Hi_Right\n-                 and then Lo_Right /= 0\n-               then\n-                  if Lo_Right > 0 then\n-                     Lor := Uint_0;\n-                     Hir := Lo_Right - 1;\n+         --  Binary operation case\n \n-                  else -- Lo_Right < 0\n-                     Lor := Lo_Right + 1;\n-                     Hir := Uint_0;\n-                  end if;\n+         when N_Op_Add\n+            | N_Op_Divide\n+            | N_Op_Expon\n+            | N_Op_Mod\n+            | N_Op_Multiply\n+            | N_Op_Rem\n+            | N_Op_Subtract\n+         =>\n+            Determine_Range\n+              (Left_Opnd (N), OK1, Lo_Left, Hi_Left, Assume_Valid);\n \n-               else\n-                  OK1 := False;\n-               end if;\n+            if OK1 then\n+               Determine_Range\n+                 (Right_Opnd (N), OK1, Lo_Right, Hi_Right, Assume_Valid);\n             end if;\n \n-         --  For REM, if right operand is a positive constant, then result must\n-         --  be in the allowable range of mod results.\n-\n-         when N_Op_Rem =>\n-            if OK_Operands then\n-               if Lo_Right = Hi_Right and then Lo_Right /= 0 then\n-                  declare\n-                     Dval : constant Uint := (abs Lo_Right) - 1;\n-\n-                  begin\n-                     --  The sign of the result depends on the sign of the\n-                     --  dividend (but not on the sign of the divisor, hence\n-                     --  the abs operation above).\n-\n-                     if Lo_Left < 0 then\n-                        Lor := -Dval;\n-                     else\n-                        Lor := Uint_0;\n-                     end if;\n-\n-                     if Hi_Left < 0 then\n-                        Hir := Uint_0;\n-                     else\n-                        Hir := Dval;\n-                     end if;\n-                  end;\n-\n-               else\n-                  OK1 := False;\n-               end if;\n+            if OK1 then\n+               Compute_Range_For_Arithmetic_Op\n+                 (Kind, Lo_Left, Hi_Left, Lo_Right, Hi_Right, OK1, Lor, Hir);\n             end if;\n \n          --  Attribute reference cases\n \n          when N_Attribute_Reference =>\n-            case Attribute_Name (N) is\n+            case Get_Attribute_Id (Attribute_Name (N)) is\n \n                --  For Pos/Val attributes, we can refine the range using the\n                --  possible range of values of the attribute expression.\n \n-               when Name_Pos\n-                  | Name_Val\n+               when Attribute_Pos\n+                  | Attribute_Val\n                =>\n                   Determine_Range\n                     (First (Expressions (N)), OK1, Lor, Hir, Assume_Valid);\n \n-               --  For Length attribute, use the bounds of the corresponding\n-               --  index type to refine the range.\n+               --  For Length and Range_Length attributes, use the bounds of\n+               --  the (corresponding index) type to refine the range.\n \n-               when Name_Length =>\n+               when Attribute_Length\n+                  | Attribute_Range_Length\n+               =>\n                   declare\n-                     Atyp : Entity_Id := Etype (Prefix (N));\n-                     Inum : Nat;\n-                     Indx : Node_Id;\n+                     Ptyp : Entity_Id;\n+                     Ityp : Entity_Id;\n \n                      LL, LU : Uint;\n                      UL, UU : Uint;\n \n                   begin\n-                     if Is_Access_Type (Atyp) then\n-                        Atyp := Designated_Type (Atyp);\n+                     Ptyp := Etype (Prefix (N));\n+                     if Is_Access_Type (Ptyp) then\n+                        Ptyp := Designated_Type (Ptyp);\n                      end if;\n \n                      --  For string literal, we know exact value\n \n-                     if Ekind (Atyp) = E_String_Literal_Subtype then\n+                     if Ekind (Ptyp) = E_String_Literal_Subtype then\n                         OK := True;\n-                        Lo := String_Literal_Length (Atyp);\n-                        Hi := String_Literal_Length (Atyp);\n+                        Lo := String_Literal_Length (Ptyp);\n+                        Hi := String_Literal_Length (Ptyp);\n                         return;\n                      end if;\n \n-                     --  Otherwise check for expression given\n-\n-                     if No (Expressions (N)) then\n-                        Inum := 1;\n+                     if Is_Array_Type (Ptyp) then\n+                        Ityp := Get_Index_Subtype (N);\n                      else\n-                        Inum :=\n-                          UI_To_Int (Expr_Value (First (Expressions (N))));\n+                        Ityp := Ptyp;\n                      end if;\n \n-                     Indx := First_Index (Atyp);\n-                     for J in 2 .. Inum loop\n-                        Next_Index (Indx);\n-                     end loop;\n-\n-                     --  If the index type is a formal type or derived from\n+                     --  If the (index) type is a formal type or derived from\n                      --  one, the bounds are not static.\n \n-                     if Is_Generic_Type (Root_Type (Etype (Indx))) then\n+                     if Is_Generic_Type (Root_Type (Ityp)) then\n                         OK := False;\n                         return;\n                      end if;\n \n                      Determine_Range\n-                       (Type_Low_Bound (Etype (Indx)), OK1, LL, LU,\n-                        Assume_Valid);\n+                       (Type_Low_Bound (Ityp), OK1, LL, LU, Assume_Valid);\n \n                      if OK1 then\n                         Determine_Range\n-                          (Type_High_Bound (Etype (Indx)), OK1, UL, UU,\n-                           Assume_Valid);\n+                          (Type_High_Bound (Ityp), OK1, UL, UU, Assume_Valid);\n \n                         if OK1 then\n-\n                            --  The maximum value for Length is the biggest\n                            --  possible gap between the values of the bounds.\n                            --  But of course, this value cannot be negative.\n \n                            Hir := UI_Max (Uint_0, UU - LL + 1);\n \n-                           --  For constrained arrays, the minimum value for\n+                           --  For a constrained array, the minimum value for\n                            --  Length is taken from the actual value of the\n                            --  bounds, since the index will be exactly of this\n                            --  subtype.\n \n-                           if Is_Constrained (Atyp) then\n+                           if Is_Constrained (Ptyp) then\n                               Lor := UI_Max (Uint_0, UL - LU + 1);\n \n                            --  For an unconstrained array, the minimum value\n@@ -4983,6 +5223,95 @@ package body Checks is\n                            end if;\n                         end if;\n                      end if;\n+\n+                     --  Small optimization: the maximum size in storage units\n+                     --  an object can have with GNAT is half of the address\n+                     --  space, so we can bound the length of an array declared\n+                     --  in Interfaces (or its children) because its component\n+                     --  size is at least the storage unit and it is meant to\n+                     --  be used to interface actual array objects.\n+\n+                     if Is_Array_Type (Ptyp) then\n+                        declare\n+                           S : constant Entity_Id := Scope (Base_Type (Ptyp));\n+                        begin\n+                           if Is_RTU (S, Interfaces)\n+                             or else (S /= Standard_Standard\n+                                       and then Is_RTU (Scope (S), Interfaces))\n+                           then\n+                              Hir := UI_Min (Hir, Half_Address_Space);\n+                           end if;\n+                        end;\n+                     end if;\n+                  end;\n+\n+               --  The maximum default alignment is quite low, but GNAT accepts\n+               --  alignment clauses that are fairly large, but not as large as\n+               --  the maximum size of objects, see below.\n+\n+               when Attribute_Alignment =>\n+                  Lor := Uint_0;\n+                  Hir := Half_Address_Space;\n+                  OK1 := True;\n+\n+               --  The attribute should have been folded if a component clause\n+               --  was specified, so we assume there is none.\n+\n+               when Attribute_Bit\n+                  | Attribute_First_Bit\n+               =>\n+                  Lor := Uint_0;\n+                  Hir := UI_From_Int (System_Storage_Unit - 1);\n+                  OK1 := True;\n+\n+               --  Likewise about the component clause. Note that Last_Bit\n+               --  yields -1 for a field of size 0 if First_Bit is 0.\n+\n+               when Attribute_Last_Bit =>\n+                  Lor := Uint_Minus_1;\n+                  Hir := Hi;\n+                  OK1 := True;\n+\n+               --  Likewise about the component clause for Position. The\n+               --  maximum size in storage units that an object can have\n+               --  with GNAT is half of the address space.\n+\n+               when Attribute_Max_Size_In_Storage_Elements\n+                  | Attribute_Position\n+               =>\n+                  Lor := Uint_0;\n+                  Hir := Half_Address_Space;\n+                  OK1 := True;\n+\n+               --  These attributes yield a nonnegative value (we do not set\n+               --  the maximum value because it is too large to be useful).\n+\n+               when Attribute_Bit_Position\n+                  | Attribute_Component_Size\n+                  | Attribute_Object_Size\n+                  | Attribute_Size\n+                  | Attribute_Value_Size\n+               =>\n+                  Lor := Uint_0;\n+                  Hir := Hi;\n+                  OK1 := True;\n+\n+               --  The maximum size is the sum of twice the size of the largest\n+               --  integer for every dimension, rounded up to the next multiple\n+               --  of the maximum alignment, but we add instead of rounding.\n+\n+               when Attribute_Descriptor_Size =>\n+                  declare\n+                     Max_Align : constant Pos :=\n+                                   Maximum_Alignment * System_Storage_Unit;\n+                     Max_Size  : constant Uint :=\n+                                   2 * Esize (Universal_Integer);\n+                     Ndims     : constant Pos :=\n+                                   Number_Dimensions (Etype (Prefix (N)));\n+                  begin\n+                     Lor := Uint_0;\n+                     Hir := Max_Size * Ndims + Max_Align;\n+                     OK1 := True;\n                   end;\n \n                --  No special handling for other attributes\n@@ -5068,6 +5397,7 @@ package body Checks is\n       --  Set cache entry for future call and we are all done\n \n       Determine_Range_Cache_N  (Cindex) := N;\n+      Determine_Range_Cache_O  (Cindex) := Original_Node (N);\n       Determine_Range_Cache_V  (Cindex) := Assume_Valid;\n       Determine_Range_Cache_Lo (Cindex) := Lo;\n       Determine_Range_Cache_Hi (Cindex) := Hi;\n@@ -5244,6 +5574,8 @@ package body Checks is\n \n       if Determine_Range_Cache_N (Cindex) = N\n            and then\n+         Determine_Range_Cache_O (Cindex) = Original_Node (N)\n+           and then\n          Determine_Range_Cache_V (Cindex) = Assume_Valid\n       then\n          Lo := Determine_Range_Cache_Lo_R (Cindex);\n@@ -5515,6 +5847,7 @@ package body Checks is\n       --  Set cache entry for future call and we are all done\n \n       Determine_Range_Cache_N    (Cindex) := N;\n+      Determine_Range_Cache_O    (Cindex) := Original_Node (N);\n       Determine_Range_Cache_V    (Cindex) := Assume_Valid;\n       Determine_Range_Cache_Lo_R (Cindex) := Lo;\n       Determine_Range_Cache_Hi_R (Cindex) := Hi;\n@@ -5728,9 +6061,9 @@ package body Checks is\n                Do_Ovflow_Check := False;\n \n             --  Despite the comments above, it is worth dealing specially with\n-            --  division specially. The only case where integer division can\n-            --  overflow is (largest negative number) / (-1). So we will do\n-            --  an extra range analysis to see if this is possible.\n+            --  division. The only case where integer division can overflow is\n+            --  (largest negative number) / (-1). So we will do an extra range\n+            --  analysis to see if this is possible.\n \n             elsif Nkind (N) = N_Op_Divide then\n                Determine_Range\n@@ -5750,6 +6083,17 @@ package body Checks is\n                      Do_Ovflow_Check := False;\n                   end if;\n                end if;\n+\n+            --  Likewise for Abs/Minus, the only case where the operation can\n+            --  overflow is when the operand is the largest negative number.\n+\n+            elsif Nkind_In (N, N_Op_Abs, N_Op_Minus) then\n+               Determine_Range\n+                 (Right_Opnd (N), OK, Lo, Hi, Assume_Valid => True);\n+\n+               if OK and then Lo > Expr_Value (Type_Low_Bound (Typ)) then\n+                  Do_Ovflow_Check := False;\n+               end if;\n             end if;\n \n             --  If no overflow check required, we are done\n@@ -8868,279 +9212,9 @@ package body Checks is\n       --  Otherwise compute result range\n \n       else\n+         Compute_Range_For_Arithmetic_Op\n+           (Nkind (N), Llo, Lhi, Rlo, Rhi, OK, Lo, Hi);\n          Bignum_Operands := False;\n-\n-         case Nkind (N) is\n-\n-            --  Absolute value\n-\n-            when N_Op_Abs =>\n-               Lo := Uint_0;\n-               Hi := UI_Max (abs Rlo, abs Rhi);\n-\n-            --  Addition\n-\n-            when N_Op_Add =>\n-               Lo := Llo + Rlo;\n-               Hi := Lhi + Rhi;\n-\n-            --  Division\n-\n-            when N_Op_Divide =>\n-\n-               --  If the right operand can only be zero, set 0..0\n-\n-               if Rlo = 0 and then Rhi = 0 then\n-                  Lo := Uint_0;\n-                  Hi := Uint_0;\n-\n-               --  Possible bounds of division must come from dividing end\n-               --  values of the input ranges (four possibilities), provided\n-               --  zero is not included in the possible values of the right\n-               --  operand.\n-\n-               --  Otherwise, we just consider two intervals of values for\n-               --  the right operand: the interval of negative values (up to\n-               --  -1) and the interval of positive values (starting at 1).\n-               --  Since division by 1 is the identity, and division by -1\n-               --  is negation, we get all possible bounds of division in that\n-               --  case by considering:\n-               --    - all values from the division of end values of input\n-               --      ranges;\n-               --    - the end values of the left operand;\n-               --    - the negation of the end values of the left operand.\n-\n-               else\n-                  declare\n-                     Mrk : constant Uintp.Save_Mark := Mark;\n-                     --  Mark so we can release the RR and Ev values\n-\n-                     Ev1 : Uint;\n-                     Ev2 : Uint;\n-                     Ev3 : Uint;\n-                     Ev4 : Uint;\n-\n-                  begin\n-                     --  Discard extreme values of zero for the divisor, since\n-                     --  they will simply result in an exception in any case.\n-\n-                     if Rlo = 0 then\n-                        Rlo := Uint_1;\n-                     elsif Rhi = 0 then\n-                        Rhi := -Uint_1;\n-                     end if;\n-\n-                     --  Compute possible bounds coming from dividing end\n-                     --  values of the input ranges.\n-\n-                     Ev1 := Llo / Rlo;\n-                     Ev2 := Llo / Rhi;\n-                     Ev3 := Lhi / Rlo;\n-                     Ev4 := Lhi / Rhi;\n-\n-                     Lo := UI_Min (UI_Min (Ev1, Ev2), UI_Min (Ev3, Ev4));\n-                     Hi := UI_Max (UI_Max (Ev1, Ev2), UI_Max (Ev3, Ev4));\n-\n-                     --  If the right operand can be both negative or positive,\n-                     --  include the end values of the left operand in the\n-                     --  extreme values, as well as their negation.\n-\n-                     if Rlo < 0 and then Rhi > 0 then\n-                        Ev1 := Llo;\n-                        Ev2 := -Llo;\n-                        Ev3 := Lhi;\n-                        Ev4 := -Lhi;\n-\n-                        Min (Lo,\n-                             UI_Min (UI_Min (Ev1, Ev2), UI_Min (Ev3, Ev4)));\n-                        Max (Hi,\n-                             UI_Max (UI_Max (Ev1, Ev2), UI_Max (Ev3, Ev4)));\n-                     end if;\n-\n-                     --  Release the RR and Ev values\n-\n-                     Release_And_Save (Mrk, Lo, Hi);\n-                  end;\n-               end if;\n-\n-            --  Exponentiation\n-\n-            when N_Op_Expon =>\n-\n-               --  Discard negative values for the exponent, since they will\n-               --  simply result in an exception in any case.\n-\n-               if Rhi < 0 then\n-                  Rhi := Uint_0;\n-               elsif Rlo < 0 then\n-                  Rlo := Uint_0;\n-               end if;\n-\n-               --  Estimate number of bits in result before we go computing\n-               --  giant useless bounds. Basically the number of bits in the\n-               --  result is the number of bits in the base multiplied by the\n-               --  value of the exponent. If this is big enough that the result\n-               --  definitely won't fit in Long_Long_Integer, switch to bignum\n-               --  mode immediately, and avoid computing giant bounds.\n-\n-               --  The comparison here is approximate, but conservative, it\n-               --  only clicks on cases that are sure to exceed the bounds.\n-\n-               if Num_Bits (UI_Max (abs Llo, abs Lhi)) * Rhi + 1 > 100 then\n-                  Lo := No_Uint;\n-                  Hi := No_Uint;\n-\n-               --  If right operand is zero then result is 1\n-\n-               elsif Rhi = 0 then\n-                  Lo := Uint_1;\n-                  Hi := Uint_1;\n-\n-               else\n-                  --  High bound comes either from exponentiation of largest\n-                  --  positive value to largest exponent value, or from\n-                  --  the exponentiation of most negative value to an\n-                  --  even exponent.\n-\n-                  declare\n-                     Hi1, Hi2 : Uint;\n-\n-                  begin\n-                     if Lhi > 0 then\n-                        Hi1 := Lhi ** Rhi;\n-                     else\n-                        Hi1 := Uint_0;\n-                     end if;\n-\n-                     if Llo < 0 then\n-                        if Rhi mod 2 = 0 then\n-                           Hi2 := Llo ** Rhi;\n-                        else\n-                           Hi2 := Llo ** (Rhi - 1);\n-                        end if;\n-                     else\n-                        Hi2 := Uint_0;\n-                     end if;\n-\n-                     Hi := UI_Max (Hi1, Hi2);\n-                  end;\n-\n-                  --  Result can only be negative if base can be negative\n-\n-                  if Llo < 0 then\n-                     if Rhi mod 2 = 0 then\n-                        Lo := Llo ** (Rhi - 1);\n-                     else\n-                        Lo := Llo ** Rhi;\n-                     end if;\n-\n-                  --  Otherwise low bound is minimum ** minimum\n-\n-                  else\n-                     Lo := Llo ** Rlo;\n-                  end if;\n-               end if;\n-\n-            --  Negation\n-\n-            when N_Op_Minus =>\n-               Lo := -Rhi;\n-               Hi := -Rlo;\n-\n-            --  Mod\n-\n-            when N_Op_Mod =>\n-               declare\n-                  Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi) - 1;\n-                  --  This is the maximum absolute value of the result\n-\n-               begin\n-                  Lo := Uint_0;\n-                  Hi := Uint_0;\n-\n-                  --  The result depends only on the sign and magnitude of\n-                  --  the right operand, it does not depend on the sign or\n-                  --  magnitude of the left operand.\n-\n-                  if Rlo < 0 then\n-                     Lo := -Maxabs;\n-                  end if;\n-\n-                  if Rhi > 0 then\n-                     Hi := Maxabs;\n-                  end if;\n-               end;\n-\n-            --  Multiplication\n-\n-            when N_Op_Multiply =>\n-\n-               --  Possible bounds of multiplication must come from multiplying\n-               --  end values of the input ranges (four possibilities).\n-\n-               declare\n-                  Mrk : constant Uintp.Save_Mark := Mark;\n-                  --  Mark so we can release the Ev values\n-\n-                  Ev1 : constant Uint := Llo * Rlo;\n-                  Ev2 : constant Uint := Llo * Rhi;\n-                  Ev3 : constant Uint := Lhi * Rlo;\n-                  Ev4 : constant Uint := Lhi * Rhi;\n-\n-               begin\n-                  Lo := UI_Min (UI_Min (Ev1, Ev2), UI_Min (Ev3, Ev4));\n-                  Hi := UI_Max (UI_Max (Ev1, Ev2), UI_Max (Ev3, Ev4));\n-\n-                  --  Release the Ev values\n-\n-                  Release_And_Save (Mrk, Lo, Hi);\n-               end;\n-\n-            --  Plus operator (affirmation)\n-\n-            when N_Op_Plus =>\n-               Lo := Rlo;\n-               Hi := Rhi;\n-\n-            --  Remainder\n-\n-            when N_Op_Rem =>\n-               declare\n-                  Maxabs : constant Uint := UI_Max (abs Rlo, abs Rhi) - 1;\n-                  --  This is the maximum absolute value of the result. Note\n-                  --  that the result range does not depend on the sign of the\n-                  --  right operand.\n-\n-               begin\n-                  Lo := Uint_0;\n-                  Hi := Uint_0;\n-\n-                  --  Case of left operand negative, which results in a range\n-                  --  of -Maxabs .. 0 for those negative values. If there are\n-                  --  no negative values then Lo value of result is always 0.\n-\n-                  if Llo < 0 then\n-                     Lo := -Maxabs;\n-                  end if;\n-\n-                  --  Case of left operand positive\n-\n-                  if Lhi > 0 then\n-                     Hi := Maxabs;\n-                  end if;\n-               end;\n-\n-            --  Subtract\n-\n-            when N_Op_Subtract =>\n-               Lo := Llo - Rhi;\n-               Hi := Lhi - Rlo;\n-\n-            --  Nothing else should be possible\n-\n-            when others =>\n-               raise Program_Error;\n-         end case;\n       end if;\n \n       --  Here for the case where we have not rewritten anything (no bignum\n@@ -10094,7 +10168,7 @@ package body Checks is\n \n             else\n                declare\n-                  Ndims : constant Nat := Number_Dimensions (T_Typ);\n+                  Ndims : constant Pos := Number_Dimensions (T_Typ);\n \n                begin\n                   --  Build the condition for the explicit dereference case\n@@ -10799,7 +10873,7 @@ package body Checks is\n \n             elsif Is_Constrained (Exptyp) then\n                declare\n-                  Ndims : constant Nat := Number_Dimensions (T_Typ);\n+                  Ndims : constant Pos := Number_Dimensions (T_Typ);\n \n                   L_Index : Node_Id;\n                   R_Index : Node_Id;\n@@ -10853,7 +10927,7 @@ package body Checks is\n \n             else\n                declare\n-                  Ndims : constant Nat := Number_Dimensions (T_Typ);\n+                  Ndims : constant Pos := Number_Dimensions (T_Typ);\n \n                begin\n                   --  Build the condition for the explicit dereference case"}, {"sha": "0482ec68f3f46a25ce12d2711d829a4af0b0997a", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 19, "deletions": 154, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12be130c3f1d09b4b9923de6b4c1c66d61c9497c/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12be130c3f1d09b4b9923de6b4c1c66d61c9497c/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=12be130c3f1d09b4b9923de6b4c1c66d61c9497c", "patch": "@@ -2549,34 +2549,11 @@ package body Exp_Attr is\n       -- Bit_Position --\n       ------------------\n \n-      --  We compute this if a component clause was present, otherwise we leave\n-      --  the computation up to the back end, since we don't know what layout\n-      --  will be chosen.\n+      --  We leave the computation up to the back end, since we don't know what\n+      --  layout will be chosen if no component clause was specified.\n \n-      --  Note that the attribute can apply to a naked record component\n-      --  in generated code (i.e. the prefix is an identifier that\n-      --  references the component or discriminant entity).\n-\n-      when Attribute_Bit_Position => Bit_Position : declare\n-         CE : Entity_Id;\n-\n-      begin\n-         if Nkind (Pref) = N_Identifier then\n-            CE := Entity (Pref);\n-         else\n-            CE := Entity (Selector_Name (Pref));\n-         end if;\n-\n-         if Known_Static_Component_Bit_Offset (CE) then\n-            Rewrite (N,\n-              Make_Integer_Literal (Loc,\n-                Intval => Component_Bit_Offset (CE)));\n-            Analyze_And_Resolve (N, Typ);\n-\n-         else\n-            Apply_Universal_Integer_Attribute_Checks (N);\n-         end if;\n-      end Bit_Position;\n+      when Attribute_Bit_Position =>\n+         Apply_Universal_Integer_Attribute_Checks (N);\n \n       ------------------\n       -- Body_Version --\n@@ -3022,24 +2999,10 @@ package body Exp_Attr is\n       -- Descriptor_Size --\n       ---------------------\n \n-      when Attribute_Descriptor_Size =>\n-\n-         --  Attribute Descriptor_Size is handled by the back end when applied\n-         --  to an unconstrained array type.\n-\n-         if Is_Array_Type (Ptyp)\n-           and then not Is_Constrained (Ptyp)\n-         then\n-            Apply_Universal_Integer_Attribute_Checks (N);\n-\n-         --  For any other type, the descriptor size is 0 because there is no\n-         --  actual descriptor, but the result is not formally static.\n+      --  Attribute Descriptor_Size is handled by the back end\n \n-         else\n-            Rewrite (N, Make_Integer_Literal (Loc, 0));\n-            Analyze (N);\n-            Set_Is_Static_Expression (N, False);\n-         end if;\n+      when Attribute_Descriptor_Size =>\n+         Apply_Universal_Integer_Attribute_Checks (N);\n \n       ---------------\n       -- Elab_Body --\n@@ -3482,42 +3445,11 @@ package body Exp_Attr is\n       -- First_Bit --\n       ---------------\n \n-      --  Compute this if component clause was present, otherwise we leave the\n-      --  computation to be completed in the back-end, since we don't know what\n-      --  layout will be chosen.\n-\n-      when Attribute_First_Bit => First_Bit_Attr : declare\n-         CE : constant Entity_Id := Entity (Selector_Name (Pref));\n-\n-      begin\n-         --  In Ada 2005 (or later) if we have the non-default bit order, then\n-         --  we return the original value as given in the component clause\n-         --  (RM 2005 13.5.2(3/2)).\n-\n-         if Present (Component_Clause (CE))\n-           and then Ada_Version >= Ada_2005\n-           and then Reverse_Bit_Order (Scope (CE))\n-         then\n-            Rewrite (N,\n-              Make_Integer_Literal (Loc,\n-                Intval => Expr_Value (First_Bit (Component_Clause (CE)))));\n-            Analyze_And_Resolve (N, Typ);\n-\n-         --  Otherwise (Ada 83/95 or Ada 2005 or later with default bit order),\n-         --  rewrite with normalized value if we know it statically.\n+      --  We leave the computation up to the back end, since we don't know what\n+      --  layout will be chosen if no component clause was specified.\n \n-         elsif Known_Static_Component_Bit_Offset (CE) then\n-            Rewrite (N,\n-              Make_Integer_Literal (Loc,\n-                Component_Bit_Offset (CE) mod System_Storage_Unit));\n-            Analyze_And_Resolve (N, Typ);\n-\n-         --  Otherwise left to back end, just do universal integer checks\n-\n-         else\n-            Apply_Universal_Integer_Attribute_Checks (N);\n-         end if;\n-      end First_Bit_Attr;\n+      when Attribute_First_Bit =>\n+         Apply_Universal_Integer_Attribute_Checks (N);\n \n       --------------------------------\n       -- Fixed_Value, Integer_Value --\n@@ -4147,45 +4079,11 @@ package body Exp_Attr is\n       -- Last_Bit --\n       --------------\n \n-      --  We compute this if a component clause was present, otherwise we leave\n-      --  the computation up to the back end, since we don't know what layout\n-      --  will be chosen.\n-\n-      when Attribute_Last_Bit => Last_Bit_Attr : declare\n-         CE : constant Entity_Id := Entity (Selector_Name (Pref));\n-\n-      begin\n-         --  In Ada 2005 (or later) if we have the non-default bit order, then\n-         --  we return the original value as given in the component clause\n-         --  (RM 2005 13.5.2(3/2)).\n-\n-         if Present (Component_Clause (CE))\n-           and then Ada_Version >= Ada_2005\n-           and then Reverse_Bit_Order (Scope (CE))\n-         then\n-            Rewrite (N,\n-              Make_Integer_Literal (Loc,\n-                Intval => Expr_Value (Last_Bit (Component_Clause (CE)))));\n-            Analyze_And_Resolve (N, Typ);\n-\n-         --  Otherwise (Ada 83/95 or Ada 2005 or later with default bit order),\n-         --  rewrite with normalized value if we know it statically.\n-\n-         elsif Known_Static_Component_Bit_Offset (CE)\n-           and then Known_Static_Esize (CE)\n-         then\n-            Rewrite (N,\n-              Make_Integer_Literal (Loc,\n-               Intval => (Component_Bit_Offset (CE) mod System_Storage_Unit)\n-                                + Esize (CE) - 1));\n-            Analyze_And_Resolve (N, Typ);\n-\n-         --  Otherwise leave to back end, just apply universal integer checks\n+      --  We leave the computation up to the back end, since we don't know what\n+      --  layout will be chosen if no component clause was specified.\n \n-         else\n-            Apply_Universal_Integer_Attribute_Checks (N);\n-         end if;\n-      end Last_Bit_Attr;\n+      when Attribute_Last_Bit =>\n+         Apply_Universal_Integer_Attribute_Checks (N);\n \n       ------------------\n       -- Leading_Part --\n@@ -5249,44 +5147,11 @@ package body Exp_Attr is\n       -- Position --\n       --------------\n \n-      --  We compute this if a component clause was present, otherwise we leave\n-      --  the computation up to the back end, since we don't know what layout\n-      --  will be chosen.\n+      --  We leave the computation up to the back end, since we don't know what\n+      --  layout will be chosen if no component clause was specified.\n \n-      when Attribute_Position => Position_Attr : declare\n-         CE : constant Entity_Id := Entity (Selector_Name (Pref));\n-\n-      begin\n-         if Present (Component_Clause (CE)) then\n-\n-            --  In Ada 2005 (or later) if we have the non-default bit order,\n-            --  then we return the original value as given in the component\n-            --  clause (RM 2005 13.5.2(2/2)).\n-\n-            if Ada_Version >= Ada_2005\n-              and then Reverse_Bit_Order (Scope (CE))\n-            then\n-               Rewrite (N,\n-                  Make_Integer_Literal (Loc,\n-                    Intval => Expr_Value (Position (Component_Clause (CE)))));\n-\n-            --  Otherwise (Ada 83 or 95, or default bit order specified in\n-            --  later Ada version), return the normalized value.\n-\n-            else\n-               Rewrite (N,\n-                 Make_Integer_Literal (Loc,\n-                   Intval => Component_Bit_Offset (CE) / System_Storage_Unit));\n-            end if;\n-\n-            Analyze_And_Resolve (N, Typ);\n-\n-         --  If back end is doing things, just apply universal integer checks\n-\n-         else\n-            Apply_Universal_Integer_Attribute_Checks (N);\n-         end if;\n-      end Position_Attr;\n+      when Attribute_Position =>\n+         Apply_Universal_Integer_Attribute_Checks (N);\n \n       ----------\n       -- Pred --"}, {"sha": "d444b9f1c9db0afbcd820e317eddd7ff2eb4924a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 142, "deletions": 29, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12be130c3f1d09b4b9923de6b4c1c66d61c9497c/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12be130c3f1d09b4b9923de6b4c1c66d61c9497c/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=12be130c3f1d09b4b9923de6b4c1c66d61c9497c", "patch": "@@ -7750,13 +7750,24 @@ package body Sem_Attr is\n         or else (Is_Entity_Name (P)\n                  and then Ekind (Entity (P)) = E_Enumeration_Literal)\n       then\n+         --  For Alignment, give alignment of object if available, otherwise we\n+         --  cannot fold Alignment.\n+\n+         if Id = Attribute_Alignment then\n+            if Is_Entity_Name (P) and then Known_Alignment (Entity (P)) then\n+               Compile_Time_Known_Attribute (N, Alignment (Entity (P)));\n+            else\n+               Check_Expressions;\n+            end if;\n+\n+            return;\n \n          --  For Component_Size, the prefix is an array object, and we apply\n          --  the attribute to the type of the object. This is allowed for both\n          --  unconstrained and constrained arrays, since the bounds have no\n          --  influence on the value of this attribute.\n \n-         if Id = Attribute_Component_Size then\n+         elsif Id = Attribute_Component_Size then\n             P_Entity := Etype (P);\n \n          --  For Enum_Rep, evaluation depends on the nature of the prefix and\n@@ -7818,13 +7829,126 @@ package body Sem_Attr is\n                return;\n             end if;\n \n-         --  For First and Last, the prefix is an array object, and we apply\n-         --  the attribute to the type of the array, but we need a constrained\n-         --  type for this, so we use the actual subtype if available.\n+         --  For Bit_Position, give Component_Bit_Offset of object if available\n+         --  otherwise we cannot fold Bit_Position. Note that the attribute can\n+         --  be applied to a naked record component in generated code, in which\n+         --  case the prefix is an identifier that references the component or\n+         --  discriminant entity.\n+\n+         elsif Id = Attribute_Bit_Position then\n+            declare\n+               CE : Entity_Id;\n+\n+            begin\n+               if Is_Entity_Name (P) then\n+                  CE := Entity (P);\n+               else\n+                  CE := Entity (Selector_Name (P));\n+               end if;\n+\n+               if Known_Static_Component_Bit_Offset (CE) then\n+                  Compile_Time_Known_Attribute\n+                    (N, Component_Bit_Offset (Entity (P)));\n+               else\n+                  Check_Expressions;\n+               end if;\n+\n+               return;\n+            end;\n+\n+         --  For Position, in Ada 2005 (or later) if we have the non-default\n+         --  bit order, we return the original value as given in the component\n+         --  clause (RM 2005 13.5.2(3/2)). Otherwise (Ada 83/95, or later with\n+         --  default bit order) return the value if it is known statically.\n+\n+         elsif Id = Attribute_Position then\n+            declare\n+               CE : constant Entity_Id := Entity (Selector_Name (P));\n+\n+            begin\n+               if Present (Component_Clause (CE))\n+                 and then Ada_Version >= Ada_2005\n+                 and then Reverse_Bit_Order (Scope (CE))\n+               then\n+                  Compile_Time_Known_Attribute\n+                    (N, Expr_Value (Position (Component_Clause (CE))));\n+\n+               elsif Known_Static_Component_Bit_Offset (CE) then\n+                  Compile_Time_Known_Attribute\n+                    (N, Component_Bit_Offset (CE) / System_Storage_Unit);\n+\n+               else\n+                  Check_Expressions;\n+               end if;\n+\n+               return;\n+            end;\n+\n+         --  For First_Bit, in Ada 2005 (or later) if we have the non-default\n+         --  bit order, we return the original value as given in the component\n+         --  clause (RM 2005 13.5.2(3/2)). Otherwise (Ada 83/95, or later with\n+         --  default bit order) return the value if it is known statically.\n+\n+         elsif Id = Attribute_First_Bit then\n+            declare\n+               CE : constant Entity_Id := Entity (Selector_Name (P));\n+\n+            begin\n+               if Present (Component_Clause (CE))\n+                 and then Ada_Version >= Ada_2005\n+                 and then Reverse_Bit_Order (Scope (CE))\n+               then\n+                  Compile_Time_Known_Attribute\n+                    (N, Expr_Value (First_Bit (Component_Clause (CE))));\n+\n+               elsif Known_Static_Component_Bit_Offset (CE) then\n+                  Compile_Time_Known_Attribute\n+                    (N, Component_Bit_Offset (CE) mod System_Storage_Unit);\n+\n+               else\n+                  Check_Expressions;\n+               end if;\n+\n+               return;\n+            end;\n+\n+         --  For Last_Bit, in Ada 2005 (or later) if we have the non-default\n+         --  bit order, we return the original value as given in the component\n+         --  clause (RM 2005 13.5.2(3/2)). Otherwise (Ada 83/95, or later with\n+         --  default bit order) return the value if it is known statically.\n+\n+         elsif Id = Attribute_Last_Bit then\n+            declare\n+               CE : constant Entity_Id := Entity (Selector_Name (P));\n+\n+            begin\n+               if Present (Component_Clause (CE))\n+                 and then Ada_Version >= Ada_2005\n+                 and then Reverse_Bit_Order (Scope (CE))\n+               then\n+                  Compile_Time_Known_Attribute\n+                    (N, Expr_Value (Last_Bit (Component_Clause (CE))));\n+\n+               elsif Known_Static_Component_Bit_Offset (CE)\n+                 and then Known_Static_Esize (CE)\n+               then\n+                  Compile_Time_Known_Attribute\n+                    (N, (Component_Bit_Offset (CE) mod System_Storage_Unit)\n+                                                             + Esize (CE) - 1);\n+               else\n+                  Check_Expressions;\n+               end if;\n+\n+               return;\n+            end;\n+\n+         --  For First, Last and Length, the prefix is an array object, and we\n+         --  apply the attribute to its type, but we need a constrained type\n+         --  for this, so we use the actual subtype if available.\n \n-         elsif Id = Attribute_First or else\n-               Id = Attribute_Last  or else\n-               Id = Attribute_Length\n+         elsif Id = Attribute_First\n+           or else Id = Attribute_Last\n+           or else Id = Attribute_Length\n          then\n             declare\n                AS : constant Entity_Id := Get_Actual_Subtype_If_Available (P);\n@@ -7846,30 +7970,14 @@ package body Sem_Attr is\n \n          elsif Id = Attribute_Size then\n             if Is_Entity_Name (P)\n-              and then Known_Esize (Entity (P))\n+              and then Known_Static_Esize (Entity (P))\n             then\n                Compile_Time_Known_Attribute (N, Esize (Entity (P)));\n-               return;\n-\n             else\n                Check_Expressions;\n-               return;\n             end if;\n \n-         --  For Alignment, give size of object if available, otherwise we\n-         --  cannot fold Alignment.\n-\n-         elsif Id = Attribute_Alignment then\n-            if Is_Entity_Name (P)\n-              and then Known_Alignment (Entity (P))\n-            then\n-               Fold_Uint (N, Alignment (Entity (P)), Static);\n-               return;\n-\n-            else\n-               Check_Expressions;\n-               return;\n-            end if;\n+            return;\n \n          --  For Lock_Free, we apply the attribute to the type of the object.\n          --  This is allowed since we have already verified that the type is a\n@@ -7995,11 +8103,11 @@ package body Sem_Attr is\n \n       --  Definite must be folded if the prefix is not a generic type, that\n       --  is to say if we are within an instantiation. Same processing applies\n-      --  to the GNAT attributes Atomic_Always_Lock_Free, Has_Discriminants,\n-      --  Lock_Free, Type_Class, Has_Tagged_Value, and Unconstrained_Array.\n+      --  to selected GNAT attributes.\n \n       elsif (Id = Attribute_Atomic_Always_Lock_Free or else\n              Id = Attribute_Definite                or else\n+             Id = Attribute_Descriptor_Size         or else\n              Id = Attribute_Has_Access_Values       or else\n              Id = Attribute_Has_Discriminants       or else\n              Id = Attribute_Has_Tagged_Values       or else\n@@ -8110,7 +8218,7 @@ package body Sem_Attr is\n       --  since we can't do anything with unconstrained arrays. In addition,\n       --  only the First, Last and Length attributes are possibly static.\n \n-      --  Atomic_Always_Lock_Free, Definite, Has_Access_Values,\n+      --  Atomic_Always_Lock_Free, Definite, Descriptor_Size, Has_Access_Values\n       --  Has_Discriminants, Has_Tagged_Values, Lock_Free, Type_Class, and\n       --  Unconstrained_Array are again exceptions, because they apply as well\n       --  to unconstrained types.\n@@ -8122,6 +8230,7 @@ package body Sem_Attr is\n \n       elsif Id = Attribute_Atomic_Always_Lock_Free or else\n             Id = Attribute_Definite                or else\n+            Id = Attribute_Descriptor_Size         or else\n             Id = Attribute_Has_Access_Values       or else\n             Id = Attribute_Has_Discriminants       or else\n             Id = Attribute_Has_Tagged_Values       or else\n@@ -8490,8 +8599,12 @@ package body Sem_Attr is\n       -- Descriptor_Size --\n       ---------------------\n \n+      --  Descriptor_Size is nonnull only for unconstrained array types\n+\n       when Attribute_Descriptor_Size =>\n-         null;\n+         if not Is_Array_Type (P_Type) or else Is_Constrained (P_Type) then\n+            Fold_Uint (N, Uint_0, Static);\n+         end if;\n \n       ------------\n       -- Digits --"}]}