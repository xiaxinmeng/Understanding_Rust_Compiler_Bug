{"sha": "af1ab44914e9d544f7b24c21634e02f62ef086ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYxYWI0NDkxNGU5ZDU0NGY3YjI0YzIxNjM0ZTAyZjYyZWYwODZmZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-03-11T12:42:18Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-03-11T12:42:18Z"}, "message": "re PR middle-end/60429 (Miscompilation (aliasing) with -finline-functions)\n\n2014-03-11  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/60429\n\tPR tree-optimization/60485\n\t* tree-ssa-structalias.c (set_union_with_increment): Properly\n\ttake into account all fields that overlap the shifted vars.\n\t(do_sd_constraint): Likewise.\n\t(do_ds_constraint): Likewise.\n\t(get_constraint_for_ptr_offset): Likewise.\n\n\t* gcc.dg/pr60485-1.c: New testcase.\n\t* gcc.dg/pr60485-2.c: Likewise.\n\nFrom-SVN: r208479", "tree": {"sha": "af561b689b875e166348ce17ab0dfa579443ef87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af561b689b875e166348ce17ab0dfa579443ef87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af1ab44914e9d544f7b24c21634e02f62ef086ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af1ab44914e9d544f7b24c21634e02f62ef086ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af1ab44914e9d544f7b24c21634e02f62ef086ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af1ab44914e9d544f7b24c21634e02f62ef086ff/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "75b107f5942b75e085958c04b09dbcbf12ff68ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75b107f5942b75e085958c04b09dbcbf12ff68ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75b107f5942b75e085958c04b09dbcbf12ff68ac"}], "stats": {"total": 194, "additions": 141, "deletions": 53}, "files": [{"sha": "a38241587b63cdf5840dec8cfd7413e47be07883", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af1ab44914e9d544f7b24c21634e02f62ef086ff", "patch": "@@ -1,3 +1,13 @@\n+2014-03-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/60429\n+\tPR tree-optimization/60485\n+\t* tree-ssa-structalias.c (set_union_with_increment): Properly\n+\ttake into account all fields that overlap the shifted vars.\n+\t(do_sd_constraint): Likewise.\n+\t(do_ds_constraint): Likewise.\n+\t(get_constraint_for_ptr_offset): Likewise.\n+\n 2014-03-11  Chung-Lin Tang  <cltang@codesourcery.com>\n \n \t* config/nios2/nios2.c (machine_function): Add fp_save_offset field."}, {"sha": "241f619613369bb7b3533f63e64fa022529e3a5f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=af1ab44914e9d544f7b24c21634e02f62ef086ff", "patch": "@@ -1,3 +1,10 @@\n+2014-03-11  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/60429\n+\tPR tree-optimization/60485\n+\t* gcc.dg/pr60485-1.c: New testcase.\n+\t* gcc.dg/pr60485-2.c: Likewise.\n+\n 2014-03-10  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR ipa/60457"}, {"sha": "2e5c2e5bf3891d054881d74f2e1eb84bd99d6a7a", "filename": "gcc/testsuite/gcc.dg/pr60485-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2Ftestsuite%2Fgcc.dg%2Fpr60485-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2Ftestsuite%2Fgcc.dg%2Fpr60485-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr60485-1.c?ref=af1ab44914e9d544f7b24c21634e02f62ef086ff", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void);\n+struct S {\n+    int *i[4];\n+    int *p1;\n+    int *p2;\n+    int *p3;\n+    int *p4;\n+};\n+int **b;\n+int main()\n+{\n+  int i = 1;\n+  struct S s;\n+  s.p3 = &i;\n+  int **p;\n+  if (b)\n+    p = b;\n+  else\n+    p = &s.i[2];\n+  p += 4;\n+  if (!b)\n+    **p = 0;\n+  if (i != 0)\n+    abort ();\n+  return i;\n+}"}, {"sha": "767e61d1c1431a88465d7a92200c2bb92bd5485f", "filename": "gcc/testsuite/gcc.dg/pr60485-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2Ftestsuite%2Fgcc.dg%2Fpr60485-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2Ftestsuite%2Fgcc.dg%2Fpr60485-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr60485-2.c?ref=af1ab44914e9d544f7b24c21634e02f62ef086ff", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+extern void abort (void);\n+struct S {\n+    int *i[4];\n+    int *p1;\n+    int *p2;\n+    int *p3;\n+    int *p4;\n+    int **x;\n+};\n+int **b;\n+int main()\n+{\n+  int i = 1;\n+  struct S s;\n+  s.p3 = &i;\n+  int **p;\n+  if (b)\n+    p = b;\n+  else\n+    p = &s.i[2];\n+  p += 4;\n+  /* prevert fowrprop from creating an offsetted sd constraint and\n+     preserve the pointer offsetting constraint.  */\n+  s.x = p;\n+  p = s.x;\n+  if (!b)\n+    {\n+      int *z = *p;\n+      /* z should point to i (and non-local/escaped).  */\n+      *z = 0;\n+    }\n+  if (i != 0)\n+    abort ();\n+  return i;\n+}"}, {"sha": "e1e1147e99355b111aa93e7a436efb6ec9a72906", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af1ab44914e9d544f7b24c21634e02f62ef086ff/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=af1ab44914e9d544f7b24c21634e02f62ef086ff", "patch": "@@ -993,23 +993,28 @@ set_union_with_increment  (bitmap to, bitmap delta, HOST_WIDE_INT inc,\n \tchanged |= bitmap_set_bit (to, i);\n       else\n \t{\n-\t  unsigned HOST_WIDE_INT fieldoffset = vi->offset + inc;\n+\t  HOST_WIDE_INT fieldoffset = vi->offset + inc;\n+\t  unsigned HOST_WIDE_INT size = vi->size;\n \n \t  /* If the offset makes the pointer point to before the\n \t     variable use offset zero for the field lookup.  */\n-\t  if (inc < 0\n-\t      && fieldoffset > vi->offset)\n-\t    fieldoffset = 0;\n-\n-\t  vi = first_or_preceding_vi_for_offset (vi, fieldoffset);\n-\n-\t  changed |= bitmap_set_bit (to, vi->id);\n-\t  /* If the result is not exactly at fieldoffset include the next\n-\t     field as well.  See get_constraint_for_ptr_offset for more\n-\t     rationale.  */\n-\t  if (vi->offset != fieldoffset\n-\t      && vi->next != 0)\n-\t    changed |= bitmap_set_bit (to, vi->next);\n+\t  if (fieldoffset < 0)\n+\t    vi = get_varinfo (vi->head);\n+\t  else\n+\t    vi = first_or_preceding_vi_for_offset (vi, fieldoffset);\n+\n+\t  do\n+\t    {\n+\t      changed |= bitmap_set_bit (to, vi->id);\n+\t      if (vi->is_full_var\n+\t\t  || vi->next == 0)\n+\t\tbreak;\n+\n+\t      /* We have to include all fields that overlap the current field\n+\t         shifted by inc.  */\n+\t      vi = vi_next (vi);\n+\t    }\n+\t  while (vi->offset < fieldoffset + size);\n \t}\n     }\n \n@@ -1618,16 +1623,21 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n     {\n       varinfo_t v = get_varinfo (j);\n       HOST_WIDE_INT fieldoffset = v->offset + roffset;\n+      unsigned HOST_WIDE_INT size = v->size;\n       unsigned int t;\n \n       if (v->is_full_var)\n-\tfieldoffset = v->offset;\n+\t;\n       else if (roffset != 0)\n-\tv = first_vi_for_offset (v, fieldoffset);\n-      /* If the access is outside of the variable we can ignore it.  */\n-      if (!v)\n-\tcontinue;\n+\t{\n+\t  if (fieldoffset < 0)\n+\t    v = get_varinfo (v->head);\n+\t  else\n+\t    v = first_or_preceding_vi_for_offset (v, fieldoffset);\n+\t}\n \n+      /* We have to include all fields that overlap the current field\n+\t shifted by roffset.  */\n       do\n \t{\n \t  t = find (v->id);\n@@ -1644,16 +1654,13 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t\t   && add_graph_edge (graph, lhs, t))\n \t    flag |= bitmap_ior_into (sol, get_varinfo (t)->solution);\n \n-\t  /* If the variable is not exactly at the requested offset\n-\t     we have to include the next one.  */\n-\t  if (v->offset == (unsigned HOST_WIDE_INT)fieldoffset\n+\t  if (v->is_full_var\n \t      || v->next == 0)\n \t    break;\n \n \t  v = vi_next (v);\n-\t  fieldoffset = v->offset;\n \t}\n-      while (1);\n+      while (v->offset < fieldoffset + size);\n     }\n \n done:\n@@ -1716,15 +1723,20 @@ do_ds_constraint (constraint_t c, bitmap delta, bitmap *expanded_delta)\n       varinfo_t v = get_varinfo (j);\n       unsigned int t;\n       HOST_WIDE_INT fieldoffset = v->offset + loff;\n+      unsigned HOST_WIDE_INT size = v->size;\n \n       if (v->is_full_var)\n-\tfieldoffset = v->offset;\n+\t;\n       else if (loff != 0)\n-\tv = first_vi_for_offset (v, fieldoffset);\n-      /* If the access is outside of the variable we can ignore it.  */\n-      if (!v)\n-\tcontinue;\n+\t{\n+\t  if (fieldoffset < 0)\n+\t    v = get_varinfo (v->head);\n+\t  else\n+\t    v = first_or_preceding_vi_for_offset (v, fieldoffset);\n+\t}\n \n+      /* We have to include all fields that overlap the current field\n+\t shifted by loff.  */\n       do\n \t{\n \t  if (v->may_have_pointers)\n@@ -1750,16 +1762,13 @@ do_ds_constraint (constraint_t c, bitmap delta, bitmap *expanded_delta)\n \t\tbitmap_set_bit (changed, t);\n \t    }\n \n-\t  /* If the variable is not exactly at the requested offset\n-\t     we have to include the next one.  */\n-\t  if (v->offset == (unsigned HOST_WIDE_INT)fieldoffset\n+\t  if (v->is_full_var\n \t      || v->next == 0)\n \t    break;\n \n \t  v = vi_next (v);\n-\t  fieldoffset = v->offset;\n \t}\n-      while (1);\n+      while (v->offset < fieldoffset + size);\n     }\n }\n \n@@ -3109,35 +3118,30 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n \t  varinfo_t temp;\n \t  unsigned HOST_WIDE_INT offset = curr->offset + rhsoffset;\n \n-\t  /* Search the sub-field which overlaps with the\n-\t     pointed-to offset.  If the result is outside of the variable\n-\t     we have to provide a conservative result, as the variable is\n-\t     still reachable from the resulting pointer (even though it\n-\t     technically cannot point to anything).  The last and first\n-\t     sub-fields are such conservative results.\n-\t     ???  If we always had a sub-field for &object + 1 then\n-\t     we could represent this in a more precise way.  */\n+\t  /* If curr->offset + rhsoffset is less than zero adjust it.  */\n \t  if (rhsoffset < 0\n \t      && curr->offset < offset)\n \t    offset = 0;\n-\t  temp = first_or_preceding_vi_for_offset (curr, offset);\n \n-\t  /* If the found variable is not exactly at the pointed to\n-\t     result, we have to include the next variable in the\n-\t     solution as well.  Otherwise two increments by offset / 2\n-\t     do not result in the same or a conservative superset\n-\t     solution.  */\n-\t  if (temp->offset != offset\n-\t      && temp->next != 0)\n+\t  /* We have to include all fields that overlap the current\n+\t     field shifted by rhsoffset.  And we include at least\n+\t     the last or the first field of the variable to represent\n+\t     reachability of off-bound addresses, in particular &object + 1,\n+\t     conservatively correct.  */\n+\t  temp = first_or_preceding_vi_for_offset (curr, offset);\n+\t  c.var = temp->id;\n+\t  c.offset = 0;\n+\t  temp = vi_next (temp);\n+\t  while (temp\n+\t\t && temp->offset < offset + curr->size)\n \t    {\n \t      struct constraint_expr c2;\n-\t      c2.var = temp->next;\n+\t      c2.var = temp->id;\n \t      c2.type = ADDRESSOF;\n \t      c2.offset = 0;\n \t      results->safe_push (c2);\n+\t      temp = vi_next (temp);\n \t    }\n-\t  c.var = temp->id;\n-\t  c.offset = 0;\n \t}\n       else\n \tc.offset = rhsoffset;"}]}