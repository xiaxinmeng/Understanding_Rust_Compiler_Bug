{"sha": "68523ddb284e83f64b2fd0249298589bf04389c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg1MjNkZGIyODRlODNmNjRiMmZkMDI0OTI5ODU4OWJmMDQzODljMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-28T14:22:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-10-28T14:22:09Z"}, "message": "[multiple changes]\n\n2009-10-28  Bob Duff  <duff@adacore.com>\n\n\t* s-fileio.adb: Give more information in exception messages.\n\n2009-10-28  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_ugn.texi: Document new -gnatyt requirement for space after right\n\tparen if next token starts with digit or letter.\n\t* styleg.adb (Check_Right_Paren): New rule for space after if next\n\tcharacter is a letter or digit.\n\nFrom-SVN: r153663", "tree": {"sha": "42db45f77c47ebe5caa380893c706854f115f1ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42db45f77c47ebe5caa380893c706854f115f1ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68523ddb284e83f64b2fd0249298589bf04389c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68523ddb284e83f64b2fd0249298589bf04389c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68523ddb284e83f64b2fd0249298589bf04389c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68523ddb284e83f64b2fd0249298589bf04389c2/comments", "author": null, "committer": null, "parents": [{"sha": "66a63e0d327753984f05353b4cf68e0f734311fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66a63e0d327753984f05353b4cf68e0f734311fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66a63e0d327753984f05353b4cf68e0f734311fc"}], "stats": {"total": 207, "additions": 148, "deletions": 59}, "files": [{"sha": "218dc32a9152c885dd4c764c8eb90a1db8807b26", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68523ddb284e83f64b2fd0249298589bf04389c2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68523ddb284e83f64b2fd0249298589bf04389c2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=68523ddb284e83f64b2fd0249298589bf04389c2", "patch": "@@ -1,3 +1,14 @@\n+2009-10-28  Bob Duff  <duff@adacore.com>\n+\n+\t* s-fileio.adb: Give more information in exception messages.\n+\n+2009-10-28  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_ugn.texi: Document new -gnatyt requirement for space after right\n+\tparen if next token starts with digit or letter.\n+\t* styleg.adb (Check_Right_Paren): New rule for space after if next\n+\tcharacter is a letter or digit.\n+\n 2009-10-28  Thomas Quinot  <quinot@adacore.com>\n \n \t* s-crtl.ads (System.CRTL.strerror): New function."}, {"sha": "77d52eb032102a13422bdd766a0d578285fbf43c", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68523ddb284e83f64b2fd0249298589bf04389c2/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68523ddb284e83f64b2fd0249298589bf04389c2/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=68523ddb284e83f64b2fd0249298589bf04389c2", "patch": "@@ -6433,6 +6433,10 @@ by a space.\n If the token preceding a left parenthesis ends with a letter or digit, then\n a space must separate the two tokens.\n \n+@item\n+if the token following a right parenthesis starts with a letter or digit, then\n+a space must separate the two tokens.\n+\n @item\n A right parenthesis must either be the first non-blank character on\n a line, or it must be preceded by a non-blank character.\n@@ -6524,8 +6528,6 @@ the exception of ORDERED_SUBPROGRAMS, UNNECESSARY_BLANK_LINES,\n XTRA_PARENS, and DOS_LINE_ENDINGS. In addition\n @end ifset\n \n-\n-\n The switch\n @ifclear vms\n @option{-gnatyN}"}, {"sha": "d6cd2ad0386d4129e849dd9340793209ef7f4d64", "filename": "gcc/ada/s-fileio.adb", "status": "modified", "additions": 127, "deletions": 56, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68523ddb284e83f64b2fd0249298589bf04389c2/gcc%2Fada%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68523ddb284e83f64b2fd0249298589bf04389c2/gcc%2Fada%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.adb?ref=68523ddb284e83f64b2fd0249298589bf04389c2", "patch": "@@ -31,7 +31,10 @@\n \n with Ada.Finalization;            use Ada.Finalization;\n with Ada.IO_Exceptions;           use Ada.IO_Exceptions;\n+with Ada.Unchecked_Conversion;\n+\n with Interfaces.C;\n+with Interfaces.C.Strings;        use Interfaces.C.Strings;\n with Interfaces.C_Streams;        use Interfaces.C_Streams;\n \n with System.CRTL;\n@@ -48,7 +51,7 @@ package body System.File_IO is\n    package SSL renames System.Soft_Links;\n \n    use type Interfaces.C.int;\n-   use type System.CRTL.size_t;\n+   use type CRTL.size_t;\n \n    ----------------------\n    -- Global Variables --\n@@ -126,6 +129,23 @@ package body System.File_IO is\n    --  call to fopen or freopen. Amethod is the character designating\n    --  the access method from the Access_Method field of the FCB.\n \n+   function Errno_Message\n+     (Errno : Integer := OS_Lib.Errno) return String;\n+   function Errno_Message\n+     (Name : String;\n+      Errno : Integer := OS_Lib.Errno) return String;\n+   --  Return a message suitable for \"raise ... with Errno_Message (...)\".\n+   --  Errno defaults to the current errno, but should be passed explicitly if\n+   --  there is significant code in between the call that sets errno and the\n+   --  call to Errno_Message, in case that code also sets errno. The version\n+   --  with Name includes that file name in the message.\n+\n+   procedure Raise_Device_Error\n+     (File : AFCB_Ptr; Errno : Integer := OS_Lib.Errno);\n+   pragma No_Return (Raise_Device_Error);\n+   --  Clear error indication on File and raise Device_Error with an exception\n+   --  message providing errno information.\n+\n    ----------------\n    -- Append_Set --\n    ----------------\n@@ -134,7 +154,7 @@ package body System.File_IO is\n    begin\n       if File.Mode = Append_File then\n          if fseek (File.Stream, 0, SEEK_END) /= 0 then\n-            raise Device_Error;\n+            Raise_Device_Error (File);\n          end if;\n       end if;\n    end Append_Set;\n@@ -174,7 +194,7 @@ package body System.File_IO is\n    procedure Check_File_Open (File : AFCB_Ptr) is\n    begin\n       if File = null then\n-         raise Status_Error;\n+         raise Status_Error with \"file not open\";\n       end if;\n    end Check_File_Open;\n \n@@ -185,9 +205,9 @@ package body System.File_IO is\n    procedure Check_Read_Status (File : AFCB_Ptr) is\n    begin\n       if File = null then\n-         raise Status_Error;\n+         raise Status_Error with \"file not open\";\n       elsif File.Mode > Inout_File then\n-         raise Mode_Error;\n+         raise Mode_Error with \"file not readable\";\n       end if;\n    end Check_Read_Status;\n \n@@ -198,9 +218,9 @@ package body System.File_IO is\n    procedure Check_Write_Status (File : AFCB_Ptr) is\n    begin\n       if File = null then\n-         raise Status_Error;\n+         raise Status_Error with \"file not open\";\n       elsif File.Mode = In_File then\n-         raise Mode_Error;\n+         raise Mode_Error with \"file not writable\";\n       end if;\n    end Check_Write_Status;\n \n@@ -212,6 +232,7 @@ package body System.File_IO is\n       Close_Status : int := 0;\n       Dup_Strm     : Boolean := False;\n       File         : AFCB_Ptr renames File_Ptr.all;\n+      Errno        : Integer;\n \n    begin\n       --  Take a task lock, to protect the global data value Open_Files\n@@ -228,6 +249,7 @@ package body System.File_IO is\n       --  stream value -- happens in some error situations).\n \n       if not File.Is_System_File and then File.Stream /= NULL_Stream then\n+\n          --  Do not do an fclose if this is a shared file and there is at least\n          --  one other instance of the stream that is open.\n \n@@ -252,6 +274,10 @@ package body System.File_IO is\n \n          if not Dup_Strm then\n             Close_Status := fclose (File.Stream);\n+\n+            if Close_Status /= 0 then\n+               Errno := OS_Lib.Errno;\n+            end if;\n          end if;\n       end if;\n \n@@ -280,7 +306,7 @@ package body System.File_IO is\n       File := null;\n \n       if Close_Status /= 0 then\n-         raise Device_Error;\n+         Raise_Device_Error (null, Errno);\n       end if;\n \n       SSL.Unlock_Task.all;\n@@ -297,11 +323,12 @@ package body System.File_IO is\n \n    procedure Delete (File_Ptr : access AFCB_Ptr) is\n       File : AFCB_Ptr renames File_Ptr.all;\n+\n    begin\n       Check_File_Open (File);\n \n       if not File.Is_Regular_File then\n-         raise Use_Error;\n+         raise Use_Error with \"cannot delete non-regular file\";\n       end if;\n \n       declare\n@@ -315,7 +342,7 @@ package body System.File_IO is\n          --  we did the open, and we want to unlink the right file!\n \n          if unlink (Filename'Address) = -1 then\n-            raise Use_Error;\n+            raise Use_Error with Errno_Message;\n          end if;\n       end;\n    end Delete;\n@@ -343,13 +370,40 @@ package body System.File_IO is\n       end if;\n    end End_Of_File;\n \n+   -------------------\n+   -- Errno_Message --\n+   -------------------\n+\n+   function Errno_Message (Errno : Integer := OS_Lib.Errno) return String is\n+      function To_Chars_Ptr is\n+        new Ada.Unchecked_Conversion (System.Address, chars_ptr);\n+\n+      Message : constant chars_ptr :=\n+                  To_Chars_Ptr (CRTL.strerror (Errno));\n+\n+   begin\n+      if Message = Null_Ptr then\n+         return \"errno =\" & Errno'Img;\n+      else\n+         return Value (Message);\n+      end if;\n+   end Errno_Message;\n+\n+   function Errno_Message\n+     (Name : String;\n+      Errno : Integer := OS_Lib.Errno) return String\n+   is\n+   begin\n+      return Name & \": \" & String'(Errno_Message (Errno));\n+   end Errno_Message;\n+\n    --------------\n    -- Finalize --\n    --------------\n \n-   --  Note: we do not need to worry about locking against multiple task\n-   --  access in this routine, since it is called only from the environment\n-   --  task just before terminating execution.\n+   --  Note: we do not need to worry about locking against multiple task access\n+   --  in this routine, since it is called only from the environment task just\n+   --  before terminating execution.\n \n    procedure Finalize (V : in out File_IO_Clean_Up_Type) is\n       pragma Warnings (Off, V);\n@@ -400,10 +454,8 @@ package body System.File_IO is\n    begin\n       Check_Write_Status (File);\n \n-      if fflush (File.Stream) = 0 then\n-         return;\n-      else\n-         raise Device_Error;\n+      if fflush (File.Stream) /= 0 then\n+         Raise_Device_Error (File);\n       end if;\n    end Flush;\n \n@@ -506,7 +558,7 @@ package body System.File_IO is\n    function Form (File : AFCB_Ptr) return String is\n    begin\n       if File = null then\n-         raise Status_Error;\n+         raise Status_Error with \"Form: file not open\";\n       else\n          return File.Form.all (1 .. File.Form'Length - 1);\n       end if;\n@@ -537,7 +589,7 @@ package body System.File_IO is\n          return False;\n \n       else\n-         raise Use_Error;\n+         raise Use_Error with \"invalid Form\";\n       end if;\n    end Form_Boolean;\n \n@@ -564,13 +616,13 @@ package body System.File_IO is\n \n          for J in V1 .. V2 loop\n             if Form (J) not in '0' .. '9' then\n-               raise Use_Error;\n+               raise Use_Error with \"invalid Form\";\n             else\n                V := V * 10 + Character'Pos (Form (J)) - Character'Pos ('0');\n             end if;\n \n             if V > 999_999 then\n-               raise Use_Error;\n+               raise Use_Error with \"invalid Form\";\n             end if;\n          end loop;\n \n@@ -678,7 +730,7 @@ package body System.File_IO is\n    function Mode (File : AFCB_Ptr) return File_Mode is\n    begin\n       if File = null then\n-         raise Status_Error;\n+         raise Status_Error with \"Mode: file not open\";\n       else\n          return File.Mode;\n       end if;\n@@ -691,7 +743,7 @@ package body System.File_IO is\n    function Name (File : AFCB_Ptr) return String is\n    begin\n       if File = null then\n-         raise Status_Error;\n+         raise Status_Error with \"Name: file not open\";\n       else\n          return File.Name.all (1 .. File.Name'Length - 1);\n       end if;\n@@ -752,12 +804,12 @@ package body System.File_IO is\n       Full_Name_Len : Integer;\n       --  Length of name actually stored in Fullname\n \n-      Encoding : System.CRTL.Filename_Encoding;\n+      Encoding : CRTL.Filename_Encoding;\n       --  Filename encoding specified into the form parameter\n \n    begin\n       if File_Ptr /= null then\n-         raise Status_Error;\n+         raise Status_Error with \"file already open\";\n       end if;\n \n       --  Acquire form string, setting required NUL terminator\n@@ -791,7 +843,7 @@ package body System.File_IO is\n             Shared := No;\n \n          else\n-            raise Use_Error;\n+            raise Use_Error with \"invalid Form\";\n          end if;\n       end;\n \n@@ -804,16 +856,16 @@ package body System.File_IO is\n          Form_Parameter (Formstr, \"encoding\", V1, V2);\n \n          if V1 = 0 then\n-            Encoding := System.CRTL.Unspecified;\n+            Encoding := CRTL.Unspecified;\n \n          elsif Formstr (V1 .. V2) = \"utf8\" then\n-            Encoding := System.CRTL.UTF8;\n+            Encoding := CRTL.UTF8;\n \n          elsif Formstr (V1 .. V2) = \"8bits\" then\n-            Encoding := System.CRTL.ASCII_8bits;\n+            Encoding := CRTL.ASCII_8bits;\n \n          else\n-            raise Use_Error;\n+            raise Use_Error with \"invalid Form\";\n          end if;\n       end;\n \n@@ -845,13 +897,13 @@ package body System.File_IO is\n \n          if Tempfile then\n             if not Creat then\n-               raise Name_Error;\n+               raise Name_Error with \"opening temp file without creating it\";\n             end if;\n \n             Tmp_Name (Namestr'Address);\n \n             if Namestr (1) = ASCII.NUL then\n-               raise Use_Error;\n+               raise Use_Error with \"invalid temp file name\";\n             end if;\n \n             --  Chain to temp file list, ensuring thread safety with a lock\n@@ -872,7 +924,7 @@ package body System.File_IO is\n \n          else\n             if Name'Length > Namelen then\n-               raise Name_Error;\n+               raise Name_Error with \"file name too long\";\n             end if;\n \n             Namestr (1 .. Name'Length) := Name;\n@@ -884,7 +936,7 @@ package body System.File_IO is\n          full_name (Namestr'Address, Fullname'Address);\n \n          if Fullname (1) = ASCII.NUL then\n-            raise Use_Error;\n+            raise Use_Error with Errno_Message (Name);\n          end if;\n \n          Full_Name_Len := 1;\n@@ -931,7 +983,7 @@ package body System.File_IO is\n                      if Shared = None\n                        or else P.Shared_Status = None\n                      then\n-                        raise Use_Error;\n+                        raise Use_Error with \"reopening shared file\";\n \n                      --  If both files have Shared=Yes, then we acquire the\n                      --  stream from the located file to use as our stream.\n@@ -977,7 +1029,7 @@ package body System.File_IO is\n \n             if not Creat and then Fopstr (1) /= 'r' then\n                if file_exists (Namestr'Address) = 0 then\n-                  raise Name_Error;\n+                  raise Name_Error with Errno_Message (Name);\n                end if;\n             end if;\n \n@@ -1001,24 +1053,22 @@ package body System.File_IO is\n                --  Should we raise Device_Error for ENOSPC???\n \n                declare\n-                  subtype Cint is Interfaces.C.int;\n-\n                   function Is_File_Not_Found_Error\n-                    (Errno_Value : Cint) return Cint;\n+                    (Errno_Value : Integer) return Integer;\n                   --  Non-zero when the given errno value indicates a non-\n                   --  existing file.\n \n                   pragma Import\n                     (C, Is_File_Not_Found_Error,\n                      \"__gnat_is_file_not_found_error\");\n \n+                  Errno : constant Integer := OS_Lib.Errno;\n+                  Message : constant String := Errno_Message (Name, Errno);\n                begin\n-                  if\n-                    Is_File_Not_Found_Error (Cint (System.OS_Lib.Errno)) /= 0\n-                  then\n-                     raise Name_Error;\n+                  if Is_File_Not_Found_Error (Errno) /= 0 then\n+                     raise Name_Error with Message;\n                   else\n-                     raise Use_Error;\n+                     raise Use_Error with Message;\n                   end if;\n                end;\n             end if;\n@@ -1047,6 +1097,23 @@ package body System.File_IO is\n       Append_Set (File_Ptr);\n    end Open;\n \n+   ------------------------\n+   -- Raise_Device_Error --\n+   ------------------------\n+\n+   procedure Raise_Device_Error\n+     (File : AFCB_Ptr; Errno : Integer := OS_Lib.Errno)\n+   is\n+   begin\n+      --  Clear error status so that the same error is not reported twice\n+\n+      if File /= null then\n+         clearerr (File.Stream);\n+      end if;\n+\n+      raise Device_Error with Errno_Message (Errno);\n+   end Raise_Device_Error;\n+\n    --------------\n    -- Read_Buf --\n    --------------\n@@ -1061,13 +1128,13 @@ package body System.File_IO is\n          return;\n \n       elsif ferror (File.Stream) /= 0 then\n-         raise Device_Error;\n+         Raise_Device_Error (File);\n \n       elsif Nread = 0 then\n          raise End_Error;\n \n       else -- 0 < Nread < Siz\n-         raise Data_Error;\n+         raise Data_Error with \"not enough data read\";\n       end if;\n \n    end Read_Buf;\n@@ -1082,7 +1149,7 @@ package body System.File_IO is\n       Count := fread (Buf, 1, Siz, File.Stream);\n \n       if Count = 0 and then ferror (File.Stream) /= 0 then\n-         raise Device_Error;\n+         Raise_Device_Error (File);\n       end if;\n    end Read_Buf;\n \n@@ -1114,19 +1181,23 @@ package body System.File_IO is\n       --  file that is not a regular file, or for a system file. Note that we\n       --  allow the \"change\" of mode if it is not in fact doing a change.\n \n-      if Mode /= File.Mode\n-        and then (File.Shared_Status = Yes\n-                   or else File.Name'Length <= 1\n-                   or else File.Is_System_File\n-                   or else not File.Is_Regular_File)\n-      then\n-         raise Use_Error;\n+      if Mode /= File.Mode then\n+         if File.Shared_Status = Yes then\n+            raise Use_Error with \"cannot change mode of shared file\";\n+         elsif File.Name'Length <= 1 then\n+            raise Use_Error with \"cannot change mode of temp file\";\n+         elsif File.Is_System_File then\n+            raise Use_Error with \"cannot change mode of system file\";\n+         elsif not File.Is_Regular_File then\n+            raise Use_Error with \"cannot change mode of non-regular file\";\n+         end if;\n+      end if;\n \n       --  For In_File or Inout_File for a regular file, we can just do a rewind\n       --  if the mode is unchanged, which is more efficient than doing a full\n       --  reopen.\n \n-      elsif Mode = File.Mode\n+      if Mode = File.Mode\n         and then Mode <= Inout_File\n       then\n          rewind (File.Stream);\n@@ -1168,7 +1239,7 @@ package body System.File_IO is\n       if fwrite (Buf, Siz, 1, File.Stream) /= 1 then\n          if Siz /= 0 then\n             SSL.Abort_Undefer.all;\n-            raise Device_Error;\n+            Raise_Device_Error (File);\n          end if;\n       end if;\n "}, {"sha": "bf72722cc883c2796f88165a768c1d25c1ee46ec", "filename": "gcc/ada/styleg.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68523ddb284e83f64b2fd0249298589bf04389c2/gcc%2Fada%2Fstyleg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68523ddb284e83f64b2fd0249298589bf04389c2/gcc%2Fada%2Fstyleg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstyleg.adb?ref=68523ddb284e83f64b2fd0249298589bf04389c2", "patch": "@@ -813,12 +813,17 @@ package body Styleg is\n    -- Check_Right_Paren --\n    -----------------------\n \n-   --  In check tokens mode (-gnatyt), right paren must never be preceded by\n+   --  In check tokens mode (-gnatyt), right paren must not be immediately\n+   --  followed by an identifier character, and must never be preceded by\n    --  a space unless it is the initial non-blank character on the line.\n \n    procedure Check_Right_Paren is\n    begin\n       if Style_Check_Tokens then\n+         if Identifier_Char (Source (Token_Ptr + 1)) then\n+            Error_Space_Required (Token_Ptr + 1);\n+         end if;\n+\n          Check_No_Space_Before;\n       end if;\n    end Check_Right_Paren;"}]}