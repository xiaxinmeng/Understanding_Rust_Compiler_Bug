{"sha": "c506ca222b67f823e968193b4b1c7f4f5d814062", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUwNmNhMjIyYjY3ZjgyM2U5NjgxOTNiNGIxYzdmNGY1ZDgxNDA2Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-11-14T05:04:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-11-14T05:04:19Z"}, "message": "call.c (build_conditional_expr): Use build_target_expr_with_type.\n\n\t* call.c (build_conditional_expr): Use build_target_expr_with_type.\n\t(convert_like): Likewise.\n\t(build_over_call): Likewise.\n\t* cp-tree.h (build_target_expr): Remove.\n\t(build_target_expr_with_type): New function.\n\t* cvt.c (build_up_reference): Use get_target_expr.\n\t* decl.c (build_target_expr): Move to ...\n\t* tree.c (build_target_expr): Here.  Make it static.\n\t(build_target_expr_with_type): New function.  Set DECL_CONTEXT on\n\tthe temporary VAR_DECLs.\n\t(get_target_expr): Use it.\n\nFrom-SVN: r30524", "tree": {"sha": "31adff7c914e81c695f58a7804b07e16ea46c1e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31adff7c914e81c695f58a7804b07e16ea46c1e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c506ca222b67f823e968193b4b1c7f4f5d814062", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c506ca222b67f823e968193b4b1c7f4f5d814062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c506ca222b67f823e968193b4b1c7f4f5d814062", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c506ca222b67f823e968193b4b1c7f4f5d814062/comments", "author": null, "committer": null, "parents": [{"sha": "794d4a61f8208daf82205681b6081fa560b68ddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794d4a61f8208daf82205681b6081fa560b68ddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/794d4a61f8208daf82205681b6081fa560b68ddd"}], "stats": {"total": 98, "additions": 55, "deletions": 43}, "files": [{"sha": "da62559c9aa772a64e532e685fb57dd87ff53ee5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c506ca222b67f823e968193b4b1c7f4f5d814062", "patch": "@@ -1,3 +1,17 @@\n+1999-11-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (build_conditional_expr): Use build_target_expr_with_type.\n+\t(convert_like): Likewise.\n+\t(build_over_call): Likewise.\n+\t* cp-tree.h (build_target_expr): Remove.\n+\t(build_target_expr_with_type): New function.\n+\t* cvt.c (build_up_reference): Use get_target_expr.\n+\t* decl.c (build_target_expr): Move to ...\n+\t* tree.c (build_target_expr): Here.  Make it static.\n+\t(build_target_expr_with_type): New function.  Set DECL_CONTEXT on\n+\tthe temporary VAR_DECLs.\n+\t(get_target_expr): Use it.\n+\n 1999-11-13  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (duplicate_decls): Propagate DECL_DEFER_OUTPUT."}, {"sha": "ee127435dc94edf01f29f7ee202d3ac06d27ea0d", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c506ca222b67f823e968193b4b1c7f4f5d814062", "patch": "@@ -3074,11 +3074,7 @@ build_conditional_expr (arg1, arg2, arg3)\n      ?: expression.  We used to check for TARGET_EXPRs here, but now we\n      sometimes wrap them in NOP_EXPRs so the test would fail.  */\n   if (!lvalue_p && IS_AGGR_TYPE (result_type))\n-    {\n-      tree slot = build (VAR_DECL, result_type);\n-      layout_decl (slot, 0);\n-      result = build_target_expr (slot, result);\n-    }\n+    result = build_target_expr_with_type (result, result_type);\n   \n   /* If this expression is an rvalue, but might be mistaken for an\n      lvalue, we must add a NON_LVALUE_EXPR.  */\n@@ -3743,10 +3739,7 @@ convert_like (convs, expr)\n \tif (NEED_TEMPORARY_P (convs))\n \t  {\n \t    tree type = TREE_TYPE (TREE_OPERAND (convs, 0));\n-\t    tree slot = build_decl (VAR_DECL, NULL_TREE, type);\n-\t    DECL_ARTIFICIAL (slot) = 1;\n-\t    expr = build_target_expr (slot, expr);\n-\t    TREE_SIDE_EFFECTS (expr) = 1;\n+\t    expr = build_target_expr_with_type (expr, type);\n \t  }\n \n \t/* Take the address of the thing to which we will bind the\n@@ -4074,11 +4067,7 @@ build_over_call (cand, args, flags)\n \t  if (! real_lvalue_p (arg))\n \t    return arg;\n \t  else if (TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n-\t    {\n-\t      val = build_decl (VAR_DECL, NULL_TREE, DECL_CONTEXT (fn));\n-\t      val = build_target_expr (val, arg);\n-\t      return val;\n-\t    }\n+\t    return build_target_expr_with_type (arg, DECL_CONTEXT (fn));\n \t}\n       else if (! real_lvalue_p (arg)\n \t       || TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))"}, {"sha": "3c25cad3572e4cab08418bbecb4d6013c6c0d659", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c506ca222b67f823e968193b4b1c7f4f5d814062", "patch": "@@ -3507,7 +3507,7 @@ extern tree cp_namespace_decls                  PROTO((tree));\n extern tree create_implicit_typedef             PROTO((tree, tree));\n extern tree maybe_push_decl                     PROTO((tree));\n extern void emit_local_var                      PROTO((tree));\n-extern tree build_target_expr                   PROTO((tree, tree));\n+extern tree build_target_expr_with_type         PROTO((tree, tree));\n extern void make_rtl_for_local_static           PROTO((tree));\n \n /* in decl2.c */"}, {"sha": "19e4d3c253f32570f0499a942050152b6b56c72a", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=c506ca222b67f823e968193b4b1c7f4f5d814062", "patch": "@@ -361,11 +361,7 @@ build_up_reference (type, arg, flags)\n \t\t      LOOKUP_ONLYCONVERTING|DIRECT_BIND);\n     }\n   else if (!(flags & DIRECT_BIND) && ! lvalue_p (arg))\n-    {\n-      tree slot = build_decl (VAR_DECL, NULL_TREE, argtype);\n-      DECL_ARTIFICIAL (slot) = 1;\n-      arg = build_target_expr (slot, arg);\n-    }\n+    return get_target_expr (arg);\n \n   /* If we had a way to wrap this up, and say, if we ever needed it's\n      address, transform all occurrences of the register, into a memory"}, {"sha": "5c231294c2a7b89927d6ff75a8c01a7a99398616", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c506ca222b67f823e968193b4b1c7f4f5d814062", "patch": "@@ -14091,26 +14091,6 @@ maybe_build_cleanup_1 (decl, auto_delete)\n   return 0;\n }\n \n-/* Build a TARGET_EXPR, initializing the DECL with the VALUE.  */\n-\n-tree\n-build_target_expr (decl, value)\n-     tree decl;\n-     tree value;\n-{\n-  tree t;\n-\n-  t = build (TARGET_EXPR, TREE_TYPE (decl), decl, value, \n-\t     maybe_build_cleanup (decl), NULL_TREE);\n-  /* We always set TREE_SIDE_EFFECTS so that expand_expr does not\n-     ignore the TARGET_EXPR.  If there really turn out to be no\n-     side-effects, then the optimizer should be able to get rid of\n-     whatever code is generated anyhow.  */\n-  TREE_SIDE_EFFECTS (t) = 1;\n-\n-  return t;\n-}\n-\n /* If DECL is of a type which needs a cleanup, build that cleanup\n    here.  The cleanup does free the storage with a call to delete.  */\n "}, {"sha": "93412738c30abcaccc50f8f7f18d762de1b68b49", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c506ca222b67f823e968193b4b1c7f4f5d814062/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=c506ca222b67f823e968193b4b1c7f4f5d814062", "patch": "@@ -43,6 +43,7 @@ static tree no_linkage_helper PROTO((tree *, int *, void *));\n static tree build_srcloc PROTO((char *, int));\n static void mark_list_hash PROTO ((void *));\n static tree copy_tree_r PROTO ((tree *, int *, void *));\n+static tree build_target_expr PROTO((tree, tree));\n \n #define CEIL(x,y) (((x) + (y) - 1) / (y))\n \n@@ -213,6 +214,26 @@ lvalue_or_else (ref, string)\n   return win;\n }\n \n+/* Build a TARGET_EXPR, initializing the DECL with the VALUE.  */\n+\n+static tree\n+build_target_expr (decl, value)\n+     tree decl;\n+     tree value;\n+{\n+  tree t;\n+\n+  t = build (TARGET_EXPR, TREE_TYPE (decl), decl, value, \n+\t     maybe_build_cleanup (decl), NULL_TREE);\n+  /* We always set TREE_SIDE_EFFECTS so that expand_expr does not\n+     ignore the TARGET_EXPR.  If there really turn out to be no\n+     side-effects, then the optimizer should be able to get rid of\n+     whatever code is generated anyhow.  */\n+  TREE_SIDE_EFFECTS (t) = 1;\n+\n+  return t;\n+}\n+\n /* INIT is a CALL_EXPR which needs info about its target.\n    TYPE is the type that this initialization should appear to have.\n \n@@ -260,23 +281,35 @@ build_cplus_new (type, init)\n   return rval;\n }\n \n-/* Encapsulate the expression INIT in a TARGET_EXPR.  */\n+/* Buidl a TARGET_EXPR using INIT to initialize a new temporary of the\n+   indicated TYPE.  */\n \n tree\n-get_target_expr (init)\n+build_target_expr_with_type (init, type)\n      tree init;\n+     tree type;\n {\n   tree slot;\n   tree rval;\n \n-  slot = build (VAR_DECL, TREE_TYPE (init));\n+  slot = build (VAR_DECL, type);\n   DECL_ARTIFICIAL (slot) = 1;\n+  DECL_CONTEXT (slot) = current_function_decl;\n   layout_decl (slot, 0);\n   rval = build_target_expr (slot, init);\n \n   return rval;\n }\n \n+/* Like build_target_expr_with_type, but use the type of INIT.  */\n+\n+tree\n+get_target_expr (init)\n+     tree init;\n+{\n+  return build_target_expr_with_type (init, TREE_TYPE (init));\n+}\n+\n /* Recursively search EXP for CALL_EXPRs that need cleanups and replace\n    these CALL_EXPRs with tree nodes that will perform the cleanups.  */\n "}]}