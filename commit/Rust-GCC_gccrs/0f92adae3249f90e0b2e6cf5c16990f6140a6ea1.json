{"sha": "0f92adae3249f90e0b2e6cf5c16990f6140a6ea1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY5MmFkYWUzMjQ5ZjkwZTBiMmU2Y2Y1YzE2OTkwZjYxNDBhNmVhMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-04-26T21:18:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-04-26T21:18:08Z"}, "message": "c-pragma.c (push_alignment): Don't ignore alignments greater than 4 bytes.\n\n\t* c-pragma.c (push_alignment): Don't ignore alignments greater than\n\t4 bytes.\n\t(handle_pragma_token): Likewise.\n\t* c-pragma.c: Support for #pragma pack (push, <id>, <n>).\n\t(struct align_stack): Add id field.\n\t(push_alignment, pop_alignment): Take id parameter.\n\t(handle_pragma_token): Add necessary states.\n\t* c-pragma.h (enum pragma_state): Add necessary states.\n\nFrom-SVN: r26662", "tree": {"sha": "79e74ebb6fd99785e533cb54e51556ce92f82ae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79e74ebb6fd99785e533cb54e51556ce92f82ae5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1/comments", "author": null, "committer": null, "parents": [{"sha": "7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f1d48663e8aa1d749c88ffd17365bf2aa80f21a"}], "stats": {"total": 159, "additions": 114, "deletions": 45}, "files": [{"sha": "ae7d4d0650b08902faa88e741819ad395056f250", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f92adae3249f90e0b2e6cf5c16990f6140a6ea1", "patch": "@@ -1,3 +1,15 @@\n+Mon Apr 26 21:17:41 1999  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* c-pragma.c (push_alignment): Don't ignore alignments greater than\n+\t4 bytes.\n+\t(handle_pragma_token): Likewise.\n+\n+\t* c-pragma.c: Support for #pragma pack (push, <id>, <n>).\n+\t(struct align_stack): Add id field.\n+\t(push_alignment, pop_alignment): Take id parameter.\n+\t(handle_pragma_token): Add necessary states.\n+\t* c-pragma.h (enum pragma_state): Add necessary states.\n+\n Tue Apr 27 13:58:23 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.md (*cmpqf, *cmpqf_noov, *cmpqi_test, "}, {"sha": "eedd0a13f0d6c28e4aef1a8d692f12ba75b15d85", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 99, "deletions": 41, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=0f92adae3249f90e0b2e6cf5c16990f6140a6ea1", "patch": "@@ -1,5 +1,5 @@\n /* Handle #pragma, system V.4 style.  Supports #pragma weak and #pragma pack.\n-   Copyright (C) 1992, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1997, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -45,18 +45,20 @@ typedef struct align_stack\n {\n   int                  alignment;\n   unsigned int         num_pushes;\n+  tree                 id;\n   struct align_stack * prev;\n } align_stack;\n \n static struct align_stack * alignment_stack = NULL;\n \n-static int  push_alignment PROTO((int));\n-static int  pop_alignment  PROTO((void));\n+static int  push_alignment PROTO((int, tree));\n+static int  pop_alignment  PROTO((tree));\n \n /* Push an alignment value onto the stack.  */\n static int\n-push_alignment (alignment)\n+push_alignment (alignment, id)\n      int alignment;\n+     tree id;\n {\n   switch (alignment)\n     {\n@@ -75,7 +77,8 @@ Alignment must be a small power of two, not %d, in #pragma pack\",\n     }\n   \n   if (alignment_stack == NULL\n-      || alignment_stack->alignment != alignment)\n+      || alignment_stack->alignment != alignment\n+      || id != NULL_TREE)\n     {\n       align_stack * entry;\n \n@@ -89,15 +92,12 @@ Alignment must be a small power of two, not %d, in #pragma pack\",\n \n       entry->alignment  = alignment;\n       entry->num_pushes = 1;\n+      entry->id         = id;\n       entry->prev       = alignment_stack;\n       \n       alignment_stack = entry;\n \n-      if (alignment < 8)\n-\tmaximum_field_alignment = alignment * 8;\n-      else\n-\t/* MSVC ignores alignments > 4.  */\n-\tmaximum_field_alignment = 0;\n+      maximum_field_alignment = alignment * 8;\n     }\n   else\n     alignment_stack->num_pushes ++;\n@@ -107,19 +107,38 @@ Alignment must be a small power of two, not %d, in #pragma pack\",\n \n /* Undo a push of an alignment onto the stack.  */\n static int\n-pop_alignment ()\n+pop_alignment (id)\n+     tree id;\n {\n+  align_stack * entry;\n+      \n   if (alignment_stack == NULL)\n     {\n       warning (\"\\\n-#pragma pack(pop) encountered without corresponding #pragma pack(push,<n>)\");\n+#pragma pack (pop) encountered without matching #pragma pack (push, <n>)\"\n+\t       );\n       return 0;\n     }\n \n+  /* If we got an identifier, strip away everything above the target\n+     entry so that the next step will restore the state just below it.  */\n+  if (id)\n+    {\n+      for (entry = alignment_stack; entry; entry = entry->prev)\n+\tif (entry->id == id)\n+\t  {\n+\t    entry->num_pushes = 1;\n+\t    alignment_stack = entry;\n+\t    break;\n+\t  }\n+      if (entry == NULL)\n+\twarning (\"\\\n+#pragma pack(pop, %s) encountered without matching #pragma pack(push, %s, <n>)\"\n+\t\t , IDENTIFIER_POINTER (id), IDENTIFIER_POINTER (id));\n+    }\n+\n   if (-- alignment_stack->num_pushes == 0)\n     {\n-      align_stack * entry;\n-      \n       entry = alignment_stack->prev;\n \n       if (entry == NULL || entry->alignment > 4)\n@@ -215,6 +234,7 @@ handle_pragma_token (string, token)\n   static char * name;\n   static char * value;\n   static int align;\n+  static tree id;\n \n   /* If we have reached the end of the #pragma directive then\n      determine what value we should return.  */\n@@ -248,16 +268,16 @@ handle_pragma_token (string, token)\n #ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n \tcase ps_push:\n \t  if (state == ps_right)\n-\t    ret_val = push_alignment (align);\n+\t    ret_val = push_alignment (align, id);\n \t  else\n-\t    warning (\"incomplete '#pragma pack(push,<n>)'\");\n+\t    warning (\"malformed '#pragma pack(push[,id],<n>)'\");\n \t  break;\n \t  \n \tcase ps_pop:\n \t  if (state == ps_right)\n-\t    ret_val = pop_alignment ();\n+\t    ret_val = pop_alignment (id);\n \t  else\n-\t    warning (\"missing closing parenthesis in '#pragma pack(pop)'\");\n+\t    warning (\"malformed '#pragma pack(pop[,id])'\");\n \t  break;\n #endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n \t  \n@@ -279,6 +299,7 @@ handle_pragma_token (string, token)\n \t}\n \n       type = state = ps_start;\n+      id = NULL_TREE;\n       \n       return ret_val;\n     }\n@@ -361,40 +382,45 @@ handle_pragma_token (string, token)\n \n     case ps_left:\n \n-      if (token && TREE_CODE(token) == INTEGER_CST) \n-\talign = TREE_INT_CST_LOW(token);\n+      if (token == NULL_TREE)\n+\tstate = (strcmp (string, \")\") ? ps_bad : ps_right);\n+\n+      else if (TREE_CODE (token) == INTEGER_CST)\n+\tgoto handle_align;\n+\n+#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n+      else if (TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  if (strcmp (string, \"push\") == 0)\n+\t    type = state = ps_push;\n+\t  else if (strcmp (string, \"pop\") == 0)\n+\t    type = state = ps_pop;\n+\t  else\n+\t    state = ps_bad;\n+\t}\n+#endif\n       else\n-\talign = atoi (string);\n+\tstate = ps_bad;\n+      break;\n+\n+    handle_align:\n+      align = TREE_INT_CST_LOW (token);\n       switch (align)\n \t{\n \tcase 1:\n \tcase 2:\n \tcase 4:\n+\tcase 8:\n+\tcase 16:\n \t  state = ps_align;\n \t  break;\n \n-\tcase 0:\n-\t  state = (strcmp (string, \")\") ? ps_bad : ps_right);\n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-\t  if (state == ps_bad)\n-\t    {\n-\t      if (strcmp (string, \"push\") == 0)\n-\t\ttype = state = ps_push;\n-\t      else if (strcmp (string, \"pop\") == 0)\n-\t\ttype = state = ps_pop;\n-\t    }\n-#endif\n-\t  break;\n-\n \tdefault:\n \t  state = ps_bad;\n \t  break;\n \t}\n       break;\n \n-#ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-    case ps_pop:\n-#endif\n     case ps_align:\n       state = (strcmp (string, \")\") ? ps_bad : ps_right);\n       break;\n@@ -406,12 +432,44 @@ handle_pragma_token (string, token)\n \n #ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n     case ps_push:\n-      state = (strcmp (string, \",\") ? ps_bad : ps_comma);\n+      state = (strcmp (string, \",\") ? ps_bad : ps_pushcomma);\n       break;\n \n-    case ps_comma:\n-      align = atoi (string);\n-      state = ps_align;\n+    case ps_pushid:\n+      state = (strcmp (string, \",\") ? ps_bad : ps_pushcomma2);\n+      break;\n+\n+    case ps_pushcomma:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  id = token;\n+\t  state = ps_pushid;\n+\t  break;\n+\t}\n+\n+      /* else fall through */\n+    case ps_pushcomma2:\n+      if (token && TREE_CODE (token) == INTEGER_CST)\n+\tgoto handle_align;\n+      else\n+\tstate = ps_bad;\n+      break;\n+\n+    case ps_pop:\n+      if (strcmp (string, \",\") == 0)\n+\tstate = ps_popcomma;\n+      else\n+\tstate = (strcmp (string, \")\") ? ps_bad : ps_right);\n+      break;\n+\n+    case ps_popcomma:\n+      if (token && TREE_CODE (token) == IDENTIFIER_NODE)\n+\t{\n+\t  id = token;\n+\t  state = ps_align;\n+\t}\n+      else\n+\tstate = ps_bad;\n       break;\n #endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n       "}, {"sha": "f94ee9fe6c500555aa165306357de6c64b11b1c1", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f92adae3249f90e0b2e6cf5c16990f6140a6ea1/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=0f92adae3249f90e0b2e6cf5c16990f6140a6ea1", "patch": "@@ -1,5 +1,5 @@\n /* Pragma related interfaces.\n-   Copyright (C) 1995, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1998, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -88,9 +88,8 @@ enum pragma_state\n   ps_right,\n #endif\n #ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n-  ps_push,\n-  ps_pop,\n-  ps_comma,\n+  ps_push, ps_pushcomma, ps_pushid, ps_pushcomma2,\n+  ps_pop, ps_popcomma,\n #endif\n   ps_bad\n };"}]}