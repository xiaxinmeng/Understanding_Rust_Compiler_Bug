{"sha": "69d8df443906f77be079de8c9bb2c52da69351a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlkOGRmNDQzOTA2Zjc3YmUwNzlkZThjOWJiMmM1MmRhNjkzNTFhMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-06-25T16:34:28Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-06-25T16:34:28Z"}, "message": "compiler: Fix type determination issues.\n\nFrom-SVN: r200398", "tree": {"sha": "edc9cac0bb05376c0ed0a909eb2eb4608140892a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edc9cac0bb05376c0ed0a909eb2eb4608140892a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69d8df443906f77be079de8c9bb2c52da69351a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d8df443906f77be079de8c9bb2c52da69351a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69d8df443906f77be079de8c9bb2c52da69351a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d8df443906f77be079de8c9bb2c52da69351a2/comments", "author": null, "committer": null, "parents": [{"sha": "7292300cda0d1457baa43ef5e65fb6a7cabd25c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7292300cda0d1457baa43ef5e65fb6a7cabd25c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7292300cda0d1457baa43ef5e65fb6a7cabd25c9"}], "stats": {"total": 25, "additions": 22, "deletions": 3}, "files": [{"sha": "9085a46b73d482336fbbe6e654add0b17d6fad61", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d8df443906f77be079de8c9bb2c52da69351a2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d8df443906f77be079de8c9bb2c52da69351a2/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=69d8df443906f77be079de8c9bb2c52da69351a2", "patch": "@@ -5668,6 +5668,7 @@ Binary_expression::do_determine_type(const Type_context* context)\n       if (tleft->is_abstract()\n \t  && subcontext.type != NULL\n \t  && !subcontext.may_be_abstract\n+\t  && subcontext.type->interface_type() == NULL\n \t  && subcontext.type->integer_type() == NULL)\n \tthis->report_error((\"invalid context-determined non-integer type \"\n \t\t\t    \"for left operand of shift\"));\n@@ -7383,6 +7384,8 @@ Builtin_call_expression::lower_make()\n   Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n   int uintptr_bits = uintptr_type->integer_type()->bits();\n \n+  Type_context int_context(Type::lookup_integer_type(\"int\"), false);\n+\n   ++parg;\n   Expression* len_arg;\n   if (parg == args->end())\n@@ -7401,6 +7404,7 @@ Builtin_call_expression::lower_make()\n   else\n     {\n       len_arg = *parg;\n+      len_arg->determine_type(&int_context);\n       if (!this->check_int_value(len_arg, true))\n \treturn Expression::make_error(this->location());\n       if (len_arg->type()->integer_type() != NULL\n@@ -7413,6 +7417,7 @@ Builtin_call_expression::lower_make()\n   if (is_slice && parg != args->end())\n     {\n       cap_arg = *parg;\n+      cap_arg->determine_type(&int_context);\n       if (!this->check_int_value(cap_arg, false))\n \treturn Expression::make_error(this->location());\n \n@@ -8030,6 +8035,8 @@ Builtin_call_expression::do_determine_type(const Type_context* context)\n     case BUILTIN_REAL:\n     case BUILTIN_IMAG:\n       arg_type = Builtin_call_expression::complex_type(context->type);\n+      if (arg_type == NULL)\n+\targ_type = Type::lookup_complex_type(\"complex128\");\n       is_print = false;\n       break;\n \n@@ -8038,6 +8045,8 @@ Builtin_call_expression::do_determine_type(const Type_context* context)\n \t// For the complex function the type of one operand can\n \t// determine the type of the other, as in a binary expression.\n \targ_type = Builtin_call_expression::real_imag_type(context->type);\n+\tif (arg_type == NULL)\n+\t  arg_type = Type::lookup_float_type(\"float64\");\n \tif (args != NULL && args->size() == 2)\n \t  {\n \t    Type* t1 = args->front()->type();\n@@ -10379,13 +10388,20 @@ Array_index_expression::do_determine_type(const Type_context*)\n void\n Array_index_expression::do_check_types(Gogo*)\n {\n-  if (this->start_->type()->integer_type() == NULL)\n+  Numeric_constant nc;\n+  unsigned long v;\n+  if (this->start_->type()->integer_type() == NULL\n+      && !this->start_->type()->is_error()\n+      && (!this->start_->numeric_constant_value(&nc)\n+\t  || nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_NOTINT))\n     this->report_error(_(\"index must be integer\"));\n   if (this->end_ != NULL\n       && this->end_->type()->integer_type() == NULL\n       && !this->end_->type()->is_error()\n       && !this->end_->is_nil_expression()\n-      && !this->end_->is_error_expression())\n+      && !this->end_->is_error_expression()\n+      && (!this->end_->numeric_constant_value(&nc)\n+\t  || nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_NOTINT))\n     this->report_error(_(\"slice end must be integer\"));\n \n   Array_type* array_type = this->array_->type()->array_type();"}, {"sha": "ca1ad07af6cb8f9059522daf9efe730ee3748c1a", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d8df443906f77be079de8c9bb2c52da69351a2/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d8df443906f77be079de8c9bb2c52da69351a2/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=69d8df443906f77be079de8c9bb2c52da69351a2", "patch": "@@ -569,7 +569,10 @@ void\n Assignment_statement::do_determine_types()\n {\n   this->lhs_->determine_type_no_context();\n-  Type_context context(this->lhs_->type(), false);\n+  Type* rhs_context_type = this->lhs_->type();\n+  if (rhs_context_type->is_sink_type())\n+    rhs_context_type = NULL;\n+  Type_context context(rhs_context_type, false);\n   this->rhs_->determine_type(&context);\n }\n "}]}