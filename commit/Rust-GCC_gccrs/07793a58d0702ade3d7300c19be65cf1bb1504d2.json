{"sha": "07793a58d0702ade3d7300c19be65cf1bb1504d2", "node_id": "C_kwDOANBUbNoAKDA3NzkzYTU4ZDA3MDJhZGUzZDczMDBjMTliZTY1Y2YxYmIxNTA0ZDI", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-12-02T14:42:32Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-06T17:11:30Z"}, "message": "[Ada] Proof of runtime unit for non-binary modular exponentiation\n\ngcc/ada/\n\n\t* libgnat/s-expmod.adb: Mark in SPARK. Add ghost code for proof.\n\t* libgnat/s-expmod.ads: Mark in SPARK. Add ghost specifications.", "tree": {"sha": "74f2de43404d924f07eaeb9d355c7c9ea14cb980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74f2de43404d924f07eaeb9d355c7c9ea14cb980"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07793a58d0702ade3d7300c19be65cf1bb1504d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07793a58d0702ade3d7300c19be65cf1bb1504d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07793a58d0702ade3d7300c19be65cf1bb1504d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07793a58d0702ade3d7300c19be65cf1bb1504d2/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed722edd2f4accad60744b95426dba3fc9ca084c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed722edd2f4accad60744b95426dba3fc9ca084c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed722edd2f4accad60744b95426dba3fc9ca084c"}], "stats": {"total": 284, "additions": 274, "deletions": 10}, "files": [{"sha": "6b69d8b05aa8bf3892fea9d5d3040ee8f7925a6c", "filename": "gcc/ada/libgnat/s-expmod.adb", "status": "modified", "additions": 238, "deletions": 2, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07793a58d0702ade3d7300c19be65cf1bb1504d2/gcc%2Fada%2Flibgnat%2Fs-expmod.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07793a58d0702ade3d7300c19be65cf1bb1504d2/gcc%2Fada%2Flibgnat%2Fs-expmod.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expmod.adb?ref=07793a58d0702ade3d7300c19be65cf1bb1504d2", "patch": "@@ -29,9 +29,168 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Exp_Mod is\n+--  Preconditions, postconditions, ghost code, loop invariants and assertions\n+--  in this unit are meant for analysis only, not for run-time checking, as it\n+--  would be too costly otherwise. This is enforced by setting the assertion\n+--  policy to Ignore.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Ghost          => Ignore,\n+                         Loop_Invariant => Ignore,\n+                         Assert         => Ignore);\n+\n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+use Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+\n+package body System.Exp_Mod\n+  with SPARK_Mode\n+is\n    use System.Unsigned_Types;\n \n+   --  Local lemmas\n+\n+   procedure Lemma_Add_Mod (X, Y : Big_Natural; B : Big_Positive)\n+   with\n+     Ghost,\n+     Post => (X + Y) mod B = ((X mod B) + (Y mod B)) mod B;\n+\n+   procedure Lemma_Exp_Expand (A : Big_Integer; Exp : Natural)\n+   with\n+     Ghost,\n+     Post =>\n+       (if Exp rem 2 = 0 then\n+          A ** Exp = A ** (Exp / 2) * A ** (Exp / 2)\n+        else\n+          A ** Exp = A ** (Exp / 2) * A ** (Exp / 2) * A);\n+\n+   procedure Lemma_Exp_Mod (A : Big_Natural; Exp : Natural; B : Big_Positive)\n+   with\n+     Ghost,\n+     Subprogram_Variant => (Decreases => Exp),\n+     Post => ((A mod B) ** Exp) mod B = (A ** Exp) mod B;\n+\n+   procedure Lemma_Mod_Ident (A : Big_Natural; B : Big_Positive)\n+   with\n+     Ghost,\n+     Pre => A < B,\n+     Post => A mod B = A;\n+\n+   procedure Lemma_Mod_Mod (A : Big_Integer; B : Big_Positive)\n+   with\n+     Ghost,\n+     Post => A mod B mod B = A mod B;\n+\n+   procedure Lemma_Mult_Div (X : Big_Natural; Y : Big_Positive)\n+   with\n+     Ghost,\n+     Post => X * Y / Y = X;\n+\n+   procedure Lemma_Mult_Mod (X, Y : Big_Natural; B : Big_Positive)\n+   with\n+     Ghost,\n+     --  The following subprogram variant can be added as soon as supported\n+     --  Subprogram_Variant => (Decreases => Y),\n+     Post => (X * Y) mod B = ((X mod B) * (Y mod B)) mod B;\n+\n+   -----------------------------\n+   -- Local lemma null bodies --\n+   -----------------------------\n+\n+   procedure Lemma_Mod_Ident (A : Big_Natural; B : Big_Positive) is null;\n+   procedure Lemma_Mod_Mod (A : Big_Integer; B : Big_Positive) is null;\n+   procedure Lemma_Mult_Div (X : Big_Natural; Y : Big_Positive) is null;\n+\n+   -------------------\n+   -- Lemma_Add_Mod --\n+   -------------------\n+\n+   procedure Lemma_Add_Mod (X, Y : Big_Natural; B : Big_Positive) is\n+      Left  : constant Big_Natural := (X + Y) mod B;\n+      Right : constant Big_Natural := ((X mod B) + (Y mod B)) mod B;\n+      XQuot : constant Big_Natural := X / B;\n+      YQuot : constant Big_Natural := Y / B;\n+      AQuot : constant Big_Natural := (X mod B + Y mod B) / B;\n+   begin\n+      if Y /= 0 and B > 1 then\n+         pragma Assert (X = XQuot * B + X mod B);\n+         pragma Assert (Y = YQuot * B + Y mod B);\n+         pragma Assert\n+           (Left = ((XQuot + YQuot) * B + X mod B + Y mod B) mod B);\n+         pragma Assert (X mod B + Y mod B = AQuot * B + Right);\n+         pragma Assert (Left = ((XQuot + YQuot + AQuot) * B + Right) mod B);\n+         pragma Assert (Left = Right);\n+      end if;\n+   end Lemma_Add_Mod;\n+\n+   ----------------------\n+   -- Lemma_Exp_Expand --\n+   ----------------------\n+\n+   procedure Lemma_Exp_Expand (A : Big_Integer; Exp : Natural) is\n+   begin\n+      if Exp rem 2 = 0 then\n+         pragma Assert (Exp = Exp / 2 + Exp / 2);\n+      else\n+         pragma Assert (Exp = Exp / 2 + Exp / 2 + 1);\n+         pragma Assert (A ** Exp = A ** (Exp / 2) * A ** (Exp / 2 + 1));\n+         pragma Assert (A ** (Exp / 2 + 1) = A ** (Exp / 2) * A);\n+         pragma Assert (A ** Exp = A ** (Exp / 2) * A ** (Exp / 2) * A);\n+      end if;\n+   end Lemma_Exp_Expand;\n+\n+   -------------------\n+   -- Lemma_Exp_Mod --\n+   -------------------\n+\n+   procedure Lemma_Exp_Mod (A : Big_Natural; Exp : Natural; B : Big_Positive)\n+   is\n+   begin\n+      if Exp /= 0 then\n+         declare\n+            Left  : constant Big_Integer := ((A mod B) ** Exp) mod B;\n+            Right : constant Big_Integer := (A ** Exp) mod B;\n+         begin\n+            Lemma_Mult_Mod (A mod B, (A mod B) ** (Exp - 1), B);\n+            Lemma_Mod_Mod (A, B);\n+            Lemma_Exp_Mod (A, Exp - 1, B);\n+            Lemma_Mult_Mod (A, A ** (Exp - 1), B);\n+            pragma Assert (Left = Right);\n+         end;\n+      end if;\n+   end Lemma_Exp_Mod;\n+\n+   --------------------\n+   -- Lemma_Mult_Mod --\n+   --------------------\n+\n+   procedure Lemma_Mult_Mod (X, Y : Big_Natural; B : Big_Positive) is\n+      Left : constant Big_Natural := (X * Y) mod B;\n+      Right : constant Big_Natural := ((X mod B) * (Y mod B)) mod B;\n+   begin\n+      if Y /= 0 and B > 1 then\n+         Lemma_Add_Mod (X * (Y - 1), X, B);\n+         Lemma_Mult_Mod (X, Y - 1, B);\n+         Lemma_Mod_Mod (X, B);\n+         Lemma_Add_Mod ((X mod B) * ((Y - 1) mod B), X mod B, B);\n+         Lemma_Add_Mod (Y - 1, 1, B);\n+         pragma Assert (((Y - 1) mod B + 1) mod B = Y mod B);\n+         if (Y - 1) mod B + 1 < B then\n+            Lemma_Mod_Ident ((Y - 1) mod B + 1, B);\n+            Lemma_Mod_Mod ((X mod B) * (Y mod B), B);\n+            pragma Assert (Left = Right);\n+         else\n+            pragma Assert (Y mod B = 0);\n+            pragma Assert ((X * Y) mod B = (X * Y) - (X * Y) / B * B);\n+            pragma Assert\n+              ((X * Y) mod B = (X * Y) - (X * (Y / B) * B) / B * B);\n+            Lemma_Mult_Div (X * (Y / B), B);\n+            pragma Assert (Left = 0);\n+            pragma Assert (Left = Right);\n+         end if;\n+      end if;\n+   end Lemma_Mult_Mod;\n+\n    -----------------\n    -- Exp_Modular --\n    -----------------\n@@ -47,11 +206,36 @@ package body System.Exp_Mod is\n \n       function Mult (X, Y : Unsigned) return Unsigned is\n         (Unsigned (Long_Long_Unsigned (X) * Long_Long_Unsigned (Y)\n-                    mod Long_Long_Unsigned (Modulus)));\n+                    mod Long_Long_Unsigned (Modulus)))\n+      with\n+        Pre => Modulus /= 0;\n       --  Modular multiplication. Note that we can't take advantage of the\n       --  compiler's circuit, because the modulus is not known statically.\n \n+      --  Local ghost variables, functions and lemmas\n+\n+      M : constant Big_Positive := Big (Modulus) with Ghost;\n+\n+      function Equal_Modulo (X, Y : Big_Integer) return Boolean is\n+         (X mod M = Y mod M)\n+      with\n+        Ghost,\n+        Pre => Modulus /= 0;\n+\n+      procedure Lemma_Mult (X, Y : Unsigned)\n+      with\n+        Ghost,\n+        Post => Big (Mult (X, Y)) = (Big (X) * Big (Y)) mod M\n+          and then Big (Mult (X, Y)) < M;\n+\n+      procedure Lemma_Mult (X, Y : Unsigned) is null;\n+\n+      Rest : Big_Integer with Ghost;\n+      --  Ghost variable to hold Factor**Exp between Exp and Factor updates\n+\n    begin\n+      pragma Assert (Modulus /= 1);\n+\n       --  We use the standard logarithmic approach, Exp gets shifted right\n       --  testing successive low order bits and Factor is the value of the\n       --  base raised to the next power of 2.\n@@ -62,14 +246,66 @@ package body System.Exp_Mod is\n \n       if Exp /= 0 then\n          loop\n+            pragma Loop_Invariant (Exp > 0);\n+            pragma Loop_Invariant (Result < Modulus);\n+            pragma Loop_Invariant (Equal_Modulo\n+              (Big (Result) * Big (Factor) ** Exp, Big (Left) ** Right));\n+            pragma Loop_Variant (Decreases => Exp);\n+            pragma Annotate\n+              (CodePeer, False_Positive,\n+               \"validity check\", \"confusion on generated code\");\n+\n             if Exp rem 2 /= 0 then\n+               pragma Assert\n+                 (Big (Factor) ** Exp\n+                  = Big (Factor) * Big (Factor) ** (Exp - 1));\n+               pragma Assert (Equal_Modulo\n+                 ((Big (Result) * Big (Factor)) * Big (Factor) ** (Exp - 1),\n+                  Big (Left) ** Right));\n+               Lemma_Mult_Mod (Big (Result) * Big (Factor),\n+                                  Big (Factor) ** (Exp - 1),\n+                                  Big (Modulus));\n+               Lemma_Mult (Result, Factor);\n+\n                Result := Mult (Result, Factor);\n+\n+               Lemma_Mod_Ident (Big (Result), Big (Modulus));\n+               Lemma_Mod_Mod (Big (Factor) ** (Exp - 1), Big (Modulus));\n+               Lemma_Mult_Mod (Big (Result),\n+                                  Big (Factor) ** (Exp - 1),\n+                                  Big (Modulus));\n+               pragma Assert (Equal_Modulo\n+                 (Big (Result) * Big (Factor) ** (Exp - 1),\n+                  Big (Left) ** Right));\n+               Lemma_Exp_Expand (Big (Factor), Exp - 1);\n             end if;\n \n+            Lemma_Exp_Expand (Big (Factor), Exp);\n+\n             Exp := Exp / 2;\n             exit when Exp = 0;\n+\n+            Rest := Big (Factor) ** Exp;\n+            Lemma_Exp_Mod (Big (Factor) * Big (Factor), Exp, Big (Modulus));\n+            pragma Assert\n+              ((Big (Factor) * Big (Factor)) ** Exp = Rest * Rest);\n+            pragma Assert (Equal_Modulo\n+              ((Big (Factor) * Big (Factor)) ** Exp,\n+               Rest * Rest));\n+            Lemma_Mult (Factor, Factor);\n+\n             Factor := Mult (Factor, Factor);\n+\n+            Lemma_Mod_Mod (Rest * Rest, Big (Modulus));\n+            Lemma_Mod_Ident (Big (Result), Big (Modulus));\n+            Lemma_Mult_Mod (Big (Result), Rest * Rest, Big (Modulus));\n+            Lemma_Mult_Mod (Big (Result), Big (Factor) ** Exp,\n+                               Big (Modulus));\n+            pragma Assert (Equal_Modulo\n+              (Big (Result) * Big (Factor) ** Exp, Big (Left) ** Right));\n          end loop;\n+\n+         pragma Assert (Big (Result) = Big (Left) ** Right mod Big (Modulus));\n       end if;\n \n       return Result;"}, {"sha": "405ecfaf80f22cd507d2782f64ce4d0ada8c557a", "filename": "gcc/ada/libgnat/s-expmod.ads", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07793a58d0702ade3d7300c19be65cf1bb1504d2/gcc%2Fada%2Flibgnat%2Fs-expmod.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07793a58d0702ade3d7300c19be65cf1bb1504d2/gcc%2Fada%2Flibgnat%2Fs-expmod.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-expmod.ads?ref=07793a58d0702ade3d7300c19be65cf1bb1504d2", "patch": "@@ -35,22 +35,50 @@\n --  Note that 1 is a binary modulus (2**0), so the compiler should not (and\n --  will not) call this function with Modulus equal to 1.\n \n+--  Preconditions in this unit are meant for analysis only, not for run-time\n+--  checking, so that the expected exceptions are raised. This is enforced by\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  contract cases should not be executed at runtime as well, in order not to\n+--  slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Pre            => Ignore,\n+                         Post           => Ignore,\n+                         Contract_Cases => Ignore,\n+                         Ghost          => Ignore);\n+\n+with Ada.Numerics.Big_Numbers.Big_Integers_Ghost;\n+\n with System.Unsigned_Types;\n \n-package System.Exp_Mod is\n-   pragma Pure;\n+package System.Exp_Mod\n+  with Pure, SPARK_Mode\n+is\n    use type System.Unsigned_Types.Unsigned;\n+   subtype Unsigned is System.Unsigned_Types.Unsigned;\n+\n+   use type Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Big_Integer;\n+   subtype Big_Integer is\n+     Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Big_Integer\n+   with Ghost;\n+\n+   package Unsigned_Conversion is\n+     new Ada.Numerics.Big_Numbers.Big_Integers_Ghost.Unsigned_Conversions\n+       (Int => Unsigned);\n+\n+   function Big (Arg : Unsigned) return Big_Integer is\n+     (Unsigned_Conversion.To_Big_Integer (Arg))\n+   with Ghost;\n \n-   subtype Power_Of_2 is System.Unsigned_Types.Unsigned with\n+   subtype Power_Of_2 is Unsigned with\n      Dynamic_Predicate =>\n         Power_Of_2 /= 0 and then (Power_Of_2 and (Power_Of_2 - 1)) = 0;\n \n    function Exp_Modular\n-     (Left    : System.Unsigned_Types.Unsigned;\n-      Modulus : System.Unsigned_Types.Unsigned;\n-      Right   : Natural) return System.Unsigned_Types.Unsigned\n+     (Left    : Unsigned;\n+      Modulus : Unsigned;\n+      Right   : Natural) return Unsigned\n    with\n-       Pre  => Modulus /= 0 and then Modulus not in Power_Of_2,\n-       Post => Exp_Modular'Result = Left ** Right mod Modulus;\n+     Pre  => Modulus /= 0 and then Modulus not in Power_Of_2,\n+     Post => Big (Exp_Modular'Result) = Big (Left) ** Right mod Big (Modulus);\n \n end System.Exp_Mod;"}]}