{"sha": "c778a237c1c605c2c5606c212c1ace756739442b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc3OGEyMzdjMWM2MDVjMmM1NjA2YzIxMmMxYWNlNzU2NzM5NDQyYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-03T18:09:41Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2021-03-04T12:46:57Z"}, "message": "c++: Redesign pending entity handling [PR 99170]\n\nThis patch addresses 99170.  with modules (and in particular header\nunits), one module can provide a (maybe nested) class or template and\nanother module can provide a definition or (maybe partial)\nspecialization of said entity, or member thereof.  when both are\nimported into a 3rd TU, and that TU instantiates or uses the class, it\nneeds to stream in those entities (in general).  But how does it key\nthose entities to the original?  It can't /just/ use the entity index,\nbecause, when header-units and/or partitions are in play, the entity\nindex /is not unique/.  I had two complicated schemes that tried to\nunify that, but it failed.  Here's a simpler scheme.  Such pending\nentities are keyed to the namespace and identifier of the\nnamespace-scope entity that contains them.  Thus the final TU needs to\nfind that entity and look in a hash table for lists of sections that\nneed loading just before instantiating a template or looking inside a\nclass.\n\nI would like to make this more efficient, but given the complex scheme\nfailed, I'm shooting for correctness right now.  There will be a\nfollow up patch to complete the cleanup this enables.\n\n\tPR c++/99170\n\tgcc/cp/\n\t* cp-tree.h\n\t* lex.c (cxx_dup_lang_specific_decl): Adjust for module_attached_p\n\trename.\n\t* module.cc (class pending_key): New.\n\t(default_hash_traits<pending_key>): New specialization.\n\t(pending_map_t): New typedef.\n\t(pending_table): Replace old table.\n\t(trees_out::lang_decl_bools): Adjust.\n\t(trees_in::lang_decl_bools): Adjust.\n\t(trees_in::install_entity): Drop pending member and specialization\n\thandling.\n\t(find_pending_key): New.\n\t(depset::hash::fiund_dependencies): Use it.\n\t(pendset_lazy_load): Delete.\n\t(module_state::write_cluster): Don't count pendings here.  Bye\n\tDuff's device-like thing.\n\t(module_state::write_pendings): Reimplement.\n\t(module_state::read_pendings): Reimplement.\n\t(lazy_specializations_p): Delete.\n\t(module_state::write): Adjust write_pendings call.\n\t(lazy_load_pendings): New.\n\t(lazy_load_specializations): Delete.\n\t(lazy_load_members): Delete.\n\t(init_modules):\tAdjust.\n\t* name-lookup.c (maybe_lazily_declare):\tCall lazy_load_pendings\n\tnot lazy_load_members.\n\t(note_pending_specializations): Delete.\n\t(load_pending_specializations): Delete.\n\t* name-lookup.h\t(BINDING_VECTR_PENDING_SPECIALIZATIONS_P): Delete.\n\t(BINDING_VECTOR_PENDING_MEMBERS_P): Delete.\n\t(BINDING_VECTR_PENDING_MEMBERS_P): Delete.\n\t(note_pending_specializations): Delete.\n\t(load_pending_specializations): Delete.\n\t* pt.c (lookup_template_class_1): Call lazy_load_pendings not\n\tlazy_load_specializations.\n\t(instantiate_template_class_1): Likewise.\n\t(instantiate_decl): Call lazy_load_pendings.\n\t* typeck.c (complete_type): Likewise.\n\tgcc/testsuite/\n\t* g++.dg/modules/pr99170-1_a.H: New.\n\t* g++.dg/modules/pr99170-1_b.C: New.\n\t* g++.dg/modules/pr99170-2.h: New.\n\t* g++.dg/modules/pr99170-2_a.C: New.\n\t* g++.dg/modules/pr99170-2_b.C: New.\n\t* g++.dg/modules/pr99170-3_a.H: New.\n\t* g++.dg/modules/pr99170-3_b.C: New.\n\t* g++.dg/modules/inst-2_b.C: Adjust scan.\n\t* g++.dg/modules/inst-4_a.C: Adjust scan.\n\t* g++.dg/modules/inst-4_b.C: Adjust scan.\n\t* g++.dg/modules/member-def-1_b.C: Adjust scan.\n\t* g++.dg/modules/member-def-1_c.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-1_a.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-1_b.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-2_b.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-2_c.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-2_d.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-3_a.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-3_b.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-4_a.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-4_b.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-5_a.C: Adjust scan.\n\t* g++.dg/modules/tpl-spec-5_b.C: Adjust scan.", "tree": {"sha": "4c90f1be0fe5d3e256efb289c060e23ce1438fbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c90f1be0fe5d3e256efb289c060e23ce1438fbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c778a237c1c605c2c5606c212c1ace756739442b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c778a237c1c605c2c5606c212c1ace756739442b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c778a237c1c605c2c5606c212c1ace756739442b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c778a237c1c605c2c5606c212c1ace756739442b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c955b4ad37cf31c1d7cfa146c2b3ead2042869b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c955b4ad37cf31c1d7cfa146c2b3ead2042869b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c955b4ad37cf31c1d7cfa146c2b3ead2042869b"}], "stats": {"total": 922, "additions": 480, "deletions": 442}, "files": [{"sha": "39e2ad83abdb002dbd092025f10eb5fc3e60256c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -1678,21 +1678,10 @@ check_constraint_info (tree t)\n #define DECL_MODULE_ENTITY_P(NODE) \\\n   (DECL_LANG_SPECIFIC (DECL_MODULE_CHECK (NODE))->u.base.module_entity_p)\n \n-/* True if there are unloaded specializations keyed to this template.  */\n-#define DECL_MODULE_PENDING_SPECIALIZATIONS_P(NODE)\t\\\n-  (DECL_LANG_SPECIFIC (TEMPLATE_DECL_CHECK (NODE))\t\\\n-   ->u.base.module_pending_p)\n-\n-/* True if this class has unloaded members.  These should be loaded\n-   before we do member lookups.   */\n-#define DECL_MODULE_PENDING_MEMBERS_P(NODE)\t\t\\\n-  (DECL_LANG_SPECIFIC (TYPE_DECL_CHECK (NODE))\t\t\\\n-   ->u.base.module_pending_p)\n-\n /* DECL that has attached decls for ODR-relatedness.  */\n #define DECL_MODULE_ATTACHMENTS_P(NODE)\t\t\t\\\n   (DECL_LANG_SPECIFIC (TREE_CHECK2(NODE,FUNCTION_DECL,VAR_DECL))\\\n-   ->u.base.module_pending_p)\n+   ->u.base.module_attached_p)\n \n /* Whether this is an exported DECL.  Held on any decl that can appear\n    at namespace scope (function, var, type, template, const or\n@@ -2771,10 +2760,8 @@ struct GTY(()) lang_decl_base {\n   unsigned module_import_p : 1;     \t   /* from an import */\n   unsigned module_entity_p : 1;\t\t   /* is in the entitity ary &\n \t\t\t\t\t      hash.  */\n-  /* TEMPLATE_DECL has specializations or,\n-     TYPE_DECL has class members yet to load, or\n-     VAR_DECL or FUNCTION_DECL has attached decls.     */\n-  unsigned module_pending_p : 1;\n+  /* VAR_DECL or FUNCTION_DECL has attached decls.     */\n+  unsigned module_attached_p : 1;\n \n   /* 12 spare bits.  */\n };\n@@ -7025,9 +7012,7 @@ extern void mangle_module (int m, bool include_partition);\n extern void mangle_module_fini ();\n extern void lazy_load_binding (unsigned mod, tree ns, tree id,\n \t\t\t       binding_slot *bslot);\n-extern void lazy_load_specializations (tree tmpl);\n-extern void lazy_load_members (tree decl);\n-extern bool lazy_specializations_p (unsigned, bool, bool);\n+extern void lazy_load_pendings (tree decl);\n extern module_state *preprocess_module (module_state *, location_t,\n \t\t\t\t\tbool in_purview, \n \t\t\t\t\tbool is_import, bool export_p,"}, {"sha": "c83346b617ddeb26c00c1b7636cd0708e9676a82", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -1010,7 +1010,7 @@ cxx_dup_lang_specific_decl (tree node)\n      (module_purview_p still does).  */\n   ld->u.base.module_entity_p = false;\n   ld->u.base.module_import_p = false;\n-  ld->u.base.module_pending_p = false;\n+  ld->u.base.module_attached_p = false;\n   \n   if (GATHER_STATISTICS)\n     {"}, {"sha": "3ee71e5211f7490f93d2c74615943f02cd7fa933", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 343, "deletions": 315, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -53,16 +53,13 @@ along with GCC; see the file COPYING3.  If not see\n    the third indicates whether it was an import into this TU or not.\n \n    The more detailed flags are DECL_MODULE_PARTITION_P,\n-   DECL_MODULE_ENTITY_P & DECL_MODULE_PENDING_SPECIALIZATIONS_P.  The\n-   first is set in a primary interface unit on decls that were read\n-   from module partitions (these will have DECL_MODULE_IMPORT_P set\n-   too).  Such decls will be streamed out to the primary's CMI.\n-   DECL_MODULE_ENTITY_P is set when an entity is imported, even if it\n-   matched a non-imported entity.  Such a decl will not have\n-   DECL_MODULE_IMPORT_P set, even though it has an entry in the entity\n-   map and array.  DECL_MODULE_PENDING_SPECIALIZATIONS_P is set on a\n-   primary template, and indicates there are specializations that\n-   should be streamed in before trying to specialize this template.\n+   DECL_MODULE_ENTITY_P.  The first is set in a primary interface unit\n+   on decls that were read from module partitions (these will have\n+   DECL_MODULE_IMPORT_P set too).  Such decls will be streamed out to\n+   the primary's CMI.  DECL_MODULE_ENTITY_P is set when an entity is\n+   imported, even if it matched a non-imported entity.  Such a decl\n+   will not have DECL_MODULE_IMPORT_P set, even though it has an entry\n+   in the entity map and array.\n \n    Header units are module-like.\n \n@@ -2644,6 +2641,58 @@ depset *depset::make_entity (tree entity, entity_kind ek, bool is_defn)\n   return r;\n }\n \n+class pending_key\n+{\n+public:\n+  tree ns;\n+  tree id;\n+};\n+\n+template<>\n+struct default_hash_traits<pending_key>\n+{\n+  using value_type = pending_key;\n+\n+  static const bool empty_zero_p = false;\n+  static hashval_t hash (const value_type &k)\n+  {\n+    hashval_t h = IDENTIFIER_HASH_VALUE (k.id);\n+    h = iterative_hash_hashval_t (DECL_UID (k.ns), h);\n+\n+    return h;\n+  }\n+  static bool equal (const value_type &k, const value_type &l)\n+  {\n+    return k.ns == l.ns && k.id == l.id;\n+  }\n+  static void mark_empty (value_type &k)\n+  {\n+    k.ns = k.id = NULL_TREE;\n+  }\n+  static void mark_deleted (value_type &k)\n+  {\n+    k.ns = NULL_TREE;\n+    gcc_checking_assert (k.id);\n+  }\n+  static bool is_empty (const value_type &k)\n+  {\n+    return k.ns == NULL_TREE && k.id == NULL_TREE;\n+  }\n+  static bool is_deleted (const value_type &k)\n+  {\n+    return k.ns == NULL_TREE && k.id != NULL_TREE;\n+  }\n+  static void remove (value_type &)\n+  {\n+  }\n+};\n+\n+typedef hash_map<pending_key, auto_vec<unsigned>> pending_map_t;\n+\n+/* Not-loaded entities that are keyed to a namespace-scope\n+   identifier.  See module_state::write_pendings for details.  */\n+pending_map_t *pending_table;\n+\n /* Decls that need some post processing once a batch of lazy loads has\n    completed.  */\n vec<tree, va_heap, vl_embed> *post_load_decls;\n@@ -2804,20 +2853,6 @@ uintset<T>::hash::get (typename uintset<T>::hash::key_t key, bool extract)\n   return res;\n }\n \n-/* Entities keyed to some other entity.  When we load the other\n-   entity, we mark it in some way to indicate there are further\n-   entities to load when you start looking inside it.  For instance\n-   template specializations are keyed to their most general template.\n-   When we instantiate that, we need to know all the partial\n-   specializations (to pick the right template), and all the known\n-   specializations (to avoid reinstantiating it, and/or whether it's\n-   extern).  The values split into two ranges.  If !MSB set, indices\n-   into the entity array.  If MSB set, an indirection to another\n-   pendset.  */\n-\n-typedef uintset<unsigned> pendset;\n-static pendset::hash *pending_table;\n-\n /* Some entities are attached to another entitity for ODR purposes.\n    For example, at namespace scope, 'inline auto var = []{};', that\n    lambda is attached to 'var', and follows its ODRness.  */\n@@ -3709,8 +3744,8 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n   bool read_inits (unsigned count);\n \n  private:\n-  void write_pendings (elf_out *to, vec<depset *> depsets,\n-\t\t      depset::hash &, unsigned count, unsigned *crc_ptr);\n+  unsigned write_pendings (elf_out *to, vec<depset *> depsets,\n+\t\t\t   depset::hash &, unsigned *crc_ptr);\n   bool read_pendings (unsigned count);\n \n  private:\n@@ -5644,7 +5679,7 @@ trees_out::lang_decl_bools (tree t)\n   WB (lang->u.base.dependent_init_p);\n   WB (lang->u.base.module_purview_p);\n   if (VAR_OR_FUNCTION_DECL_P (t))\n-    WB (lang->u.base.module_pending_p);\n+    WB (lang->u.base.module_attached_p);\n   switch (lang->u.base.selector)\n     {\n     default:\n@@ -5714,7 +5749,7 @@ trees_in::lang_decl_bools (tree t)\n   RB (lang->u.base.dependent_init_p);\n   RB (lang->u.base.module_purview_p);\n   if (VAR_OR_FUNCTION_DECL_P (t))\n-    RB (lang->u.base.module_pending_p);\n+    RB (lang->u.base.module_attached_p);\n   switch (lang->u.base.selector)\n     {\n     default:\n@@ -7572,12 +7607,7 @@ trees_in::install_entity (tree decl)\n \n   /* Insert the real decl into the entity ary.  */\n   unsigned ident = state->entity_lwm + entity_index - 1;\n-  binding_slot &elt = (*entity_ary)[ident];\n-\n-  /* See module_state::read_pendings for how this got set.  */\n-  int pending = elt.get_lazy () & 3;\n-\n-  elt = decl;\n+  (*entity_ary)[ident] = decl;\n \n   /* And into the entity map, if it's not already there.  */\n   if (!DECL_LANG_SPECIFIC (decl)\n@@ -7592,26 +7622,6 @@ trees_in::install_entity (tree decl)\n       gcc_checking_assert (!existed);\n       slot = ident;\n     }\n-  else if (pending != 0)\n-    {\n-      unsigned key_ident = import_entity_index (decl);\n-      if (pending & 1)\n-\tif (!pending_table->add (key_ident, ~ident))\n-\t  pending &= ~1;\n-\n-      if (pending & 2)\n-\tif (!pending_table->add (~key_ident, ~ident))\n-\t  pending &= ~2;\n-    }\n-\n-  if (pending & 1)\n-    DECL_MODULE_PENDING_SPECIALIZATIONS_P (decl) = true;\n-\n-  if (pending & 2)\n-    {\n-      DECL_MODULE_PENDING_MEMBERS_P (decl) = true;\n-      gcc_checking_assert (TREE_CODE (decl) != TEMPLATE_DECL);\n-    }\n \n   return true;\n }\n@@ -10558,7 +10568,6 @@ trees_out::key_mergeable (int tag, merge_kind mk, tree decl, tree inner,\n \t\t// FIXME: What if the return type is a voldemort?\n \t\tkey.ret = fndecl_declared_return_type (inner);\n \t    }\n-\n \t  break;\n \n \tcase MK_field:\n@@ -13225,6 +13234,28 @@ depset::hash::add_mergeable (depset *mergeable)\n   dep->deps.safe_push (mergeable);\n }\n \n+/* Find the innermost-namespace scope of DECL, and that\n+   namespace-scope decl.  */\n+\n+tree\n+find_pending_key (tree decl, tree *decl_p = nullptr)\n+{\n+  tree ns = decl;\n+  do\n+    {\n+      decl = ns;\n+      ns = CP_DECL_CONTEXT (ns);\n+      if (TYPE_P (ns))\n+\tns = TYPE_NAME (ns);\n+    }\n+  while (TREE_CODE (ns) != NAMESPACE_DECL);\n+\n+  if (decl_p)\n+    *decl_p = decl;\n+\n+  return ns;\n+}\n+\n /* Iteratively find dependencies.  During the walk we may find more\n    entries on the same binding that need walking.  */\n \n@@ -13259,13 +13290,22 @@ depset::hash::find_dependencies (module_state *module)\n \t\twalker.tree_node (OVL_FUNCTION (decl));\n \t      else if (TREE_VISITED (decl))\n \t\t/* A global tree.  */;\n-\t      else if (TREE_CODE (decl) == NAMESPACE_DECL\n-\t\t       && !DECL_NAMESPACE_ALIAS (decl))\n+\t      else if (item->get_entity_kind () == EK_NAMESPACE)\n \t\tadd_namespace_context (current, CP_DECL_CONTEXT (decl));\n \t      else\n \t\t{\n \t\t  walker.mark_declaration (decl, current->has_defn ());\n \n+\t\t  if (!walker.is_key_order ()\n+\t\t      && (item->get_entity_kind () == EK_SPECIALIZATION\n+\t\t\t  || item->get_entity_kind () == EK_PARTIAL\n+\t\t\t  || (item->get_entity_kind () == EK_DECL\n+\t\t\t      && item->is_member ())))\n+\t\t    {\n+\t\t      tree ns = find_pending_key (decl, nullptr);\n+\t\t      add_namespace_context (item, ns);\n+\t\t    }\n+\n \t\t  // FIXME: Perhaps p1815 makes this redundant? Or at\n \t\t  // least simplifies it.  Voldemort types are only\n \t\t  // ever emissable when containing (inline) function\n@@ -13709,43 +13749,6 @@ depset::hash::connect ()\n   return connector.result;\n }\n \n-/* Load the entities referred to by this pendset.  */\n-\n-static bool\n-pendset_lazy_load (pendset *pendings, bool specializations_p)\n-{\n-  bool ok = true;\n-\n-  for (unsigned ix = 0; ok && ix != pendings->num; ix++)\n-    {\n-      unsigned index = pendings->values[ix];\n-      if (index & ~(~0u >> 1))\n-\t{\n-\t  /* An indirection.  */\n-\t  if (specializations_p)\n-\t    index = ~index;\n-\t  pendset *other = pending_table->get (index, true);\n-\t  if (!pendset_lazy_load (other, specializations_p))\n-\t    ok = false;\n-\t}\n-      else\n-\t{\n-\t  module_state *module = import_entity_module (index);\n-\t  binding_slot *slot = &(*entity_ary)[index];\n-\t  if (!slot->is_lazy ())\n-\t    dump () && dump (\"Specialiation %M[%u] already loaded\",\n-\t\t\t     module, index - module->entity_lwm);\n-\t  else if (!module->lazy_load (index - module->entity_lwm, slot))\n-\t    ok = false;\n-\t}\n-    }\n-\n-  /* We own set, so delete it now.  */\n-  delete pendings;\n-\n-  return ok;\n-}\n-\n /* Initialize location spans.  */\n \n void\n@@ -14665,12 +14668,8 @@ module_state::write_cluster (elf_out *to, depset *scc[], unsigned size,\n \t  break;\n \n \tcase depset::EK_DECL:\n-\t  if (b->is_member ())\n-\t    {\n-\t    case depset::EK_SPECIALIZATION:  /* Yowzer! */\n-\t    case depset::EK_PARTIAL:  /* Hey, let's do it again! */\n-\t      counts[MSC_pendings]++;\n-\t    }\n+\tcase depset::EK_SPECIALIZATION:\n+\tcase depset::EK_PARTIAL:\n \t  b->cluster = counts[MSC_entities]++;\n \t  sec.mark_declaration (b->get_entity (), b->has_defn ());\n \t  /* FALLTHROUGH  */\n@@ -14688,10 +14687,9 @@ module_state::write_cluster (elf_out *to, depset *scc[], unsigned size,\n   dump (dumper::CLUSTER) && (dump.outdent (), true);\n \n   /* Ensure every imported decl is referenced before we start\n-     streaming.  This ensures that we never encounter the\n-     situation where this cluster instantiates some implicit\n-     member that importing some other decl causes to be\n-     instantiated.  */\n+     streaming.  This ensures that we never encounter the situation\n+     where this cluster instantiates some implicit member that\n+     importing some other decl causes to be instantiated.  */\n   sec.set_importing (+1);\n   for (unsigned ix = 0; ix != size; ix++)\n     {\n@@ -14704,14 +14702,14 @@ module_state::write_cluster (elf_out *to, depset *scc[], unsigned size,\n \n \t  if (dep->is_binding ())\n \t    {\n-\t      /* A cross-module using decl could be here.  */\n \t      for (unsigned ix = dep->deps.length (); --ix;)\n \t\t{\n \t\t  depset *bind = dep->deps[ix];\n-\t\t  if (bind->get_entity_kind () == depset::EK_USING\n-\t\t      && bind->deps[1]->is_import ())\n+\t\t  if (bind->get_entity_kind () == depset::EK_USING)\n+\t\t    bind = bind->deps[1];\n+\t\t  if (bind->is_import ())\n \t\t    {\n-\t\t      tree import = bind->deps[1]->get_entity ();\n+\t\t      tree import = bind->get_entity ();\n \t\t      if (!TREE_VISITED (import))\n \t\t\t{\n \t\t\t  sec.tree_node (import);\n@@ -15397,98 +15395,208 @@ module_state::read_entities (unsigned count, unsigned lwm, unsigned hwm)\n \n /* Write the pending table to MOD_SNAME_PFX.pnd\n \n-   Specializations & partials are keyed to their primary template.\n-   Members are keyed to their context.\n-\n-   For specializations & partials, primary templates are keyed to the\n-   (namespace name) of their originating decl (because that's the only\n-   handle we have).  */\n+   The pending table holds information about clusters that need to be\n+   loaded because they contain information about something that is not\n+   found by namespace-scope lookup.\n+\n+   The three cases are:\n+\n+   (a) Template (maybe-partial) specializations that we have\n+   instantiated or defined.  When an importer needs to instantiate\n+   that template, they /must have/ the partial, explicit & extern\n+   specializations available.  If they have the other specializations\n+   available, they'll have less work to do.  Thus, when we're about to\n+   instantiate FOO, we have to be able to ask 'are there any\n+   specialization of FOO in our imports?'.\n+\n+   (b) (Maybe-implicit) member functions definitions.  A class could\n+   be defined in one header, and an inline member defined in a\n+   different header (this occurs in the STL).  Similarly, like the\n+   specialization case, an implicit member function could have been\n+   'instantiated' in one module, and it'd be nice to not have to\n+   reinstantiate it in another.\n+\n+   (c) A member classes completed elsewhere.  A member class could be\n+   declared in one header and defined in another.  We need to know to\n+   load the class definition before looking in it.  This turns out to\n+   be a specific case of #b, so we can treat these the same.  But it\n+   does highlight an issue -- there could be an intermediate import\n+   between the outermost containing namespace-scope class and the\n+   innermost being-defined member class.  This is actually possible\n+   with all of these cases, so be aware -- we're not just talking of\n+   one level of import to get to the innermost namespace.\n+\n+   This gets complicated fast, it took me multiple attempts to even\n+   get something remotely working.  Partially because I focussed on\n+   optimizing what I think turns out to be a smaller problem, given\n+   the known need to do the more general case *anyway*.  I document\n+   the smaller problem, because it does appear to be the natural way\n+   to do it.  It's trap!\n+\n+   **** THE TRAP\n+\n+   Let's refer to the primary template or the containing class as the\n+   KEY.  And the specialization or member as the PENDING-ENTITY.  (To\n+   avoid having to say those mouthfuls all the time.)\n+\n+   In either case, we have an entity and we need some way of mapping\n+   that to a set of entities that need to be loaded before we can\n+   proceed with whatever processing of the entity we were going to do.\n+\n+   We need to link the key to the pending-entity in some way.  Given a\n+   key, tell me the pending-entities I need to have loaded.  However\n+   we tie the key to the pending-entity must not rely on the key being\n+   loaded -- that'd defeat the lazy loading scheme.\n+\n+   As the key will be an import in we know its entity number (either\n+   because we imported it, or we're writing it out too).  Thus we can\n+   generate a map of key-indices to pending-entities.  The\n+   pending-entity indices will be into our span of the entity table,\n+   and thus allow them to be lazily loaded.  The key index will be\n+   into another slot of the entity table.  Notice that this checking\n+   could be expensive, we don't want to iterate over a bunch of\n+   pending-entity indices (across multiple imports), every time we're\n+   about do to the thing with the key.  We need to quickly determine\n+   'definitely nothing needed'.\n+\n+   That's almost good enough, except that key indices are not unique\n+   in a couple of cases :( Specifically the Global Module or a module\n+   partition can result in multiple modules assigning an entity index\n+   for the key.  The decl-merging on loading will detect that so we\n+   only have one Key loaded, and in the entity hash it'll indicate the\n+   entity index of first load.  Which might be different to how we\n+   know it.  Notice this is restricted to GM entities or this-module\n+   entities.  Foreign imports cannot have this.\n+\n+   We can simply resolve this in the direction of how this module\n+   referred to the key to how the importer knows it.  Look in the\n+   entity table slot that we nominate, maybe lazy load it, and then\n+   lookup the resultant entity in the entity hash to learn how the\n+   importer knows it.\n+\n+   But we need to go in the other direction :( Given the key, find all\n+   the index-aliases of that key.  We can partially solve that by\n+   adding an alias hash table.  Whenever we load a merged decl, add or\n+   augment a mapping from the entity (or its entity-index) to the\n+   newly-discovered index.  Then when we look for pending entities of\n+   a key, we also iterate over this aliases this mapping provides.\n+\n+   But that requires the alias to be loaded.  And that's not\n+   necessarily true.\n+\n+   *** THE SIMPLER WAY\n+\n+   The remaining fixed thing we have is the innermost namespace\n+   containing the ultimate namespace-scope container of the key and\n+   the name of that container (which might be the key itself).  I.e. a\n+   namespace-decl/identifier/module tuple.  Let's call this the\n+   top-key.  We'll discover that the module is not important here,\n+   because of cross-module possibilities mentioned in case #c above.\n+   We can't markup namespace-binding slots.  The best we can do is\n+   mark the binding vector with 'there's something here', and have\n+   another map from namespace/identifier pairs to a vector of pending\n+   entity indices.\n+\n+   Maintain a pending-entity map.  This is keyed by top-key, and\n+   maps to a vector of pending-entity indices.  On the binding vector\n+   have flags saying whether the pending-name-entity map has contents.\n+   (We might want to further extend the key to be GM-vs-Partition and\n+   specialization-vs-member, but let's not get ahead of ourselves.)\n+\n+   For every key-like entity, find the outermost namespace-scope\n+   name.  Use that to lookup in the pending-entity map and then make\n+   sure the specified entities are loaded.\n+\n+   An optimization might be to have a flag in each key-entity saying\n+   that it's top key might be in the entity table.  It's not clear to\n+   me how to set that flag cheaply -- cheaper than just looking.\n+\n+   FIXME: It'd be nice to have a bit in decls to tell us whether to\n+   even try this.  We can have a 'already done' flag, that we set when\n+   we've done KLASS's lazy pendings.  When we import a module that\n+   registers pendings on the same top-key as KLASS we need to clear\n+   the flag.  A recursive walk of the top-key clearing the bit will\n+   suffice.  Plus we only need to recurse on classes that have the bit\n+   set.  (That means we need to set the bit on parents of KLASS here,\n+   don't forget.)  However, first: correctness, second: efficiency.  */\n \n-void\n+unsigned\n module_state::write_pendings (elf_out *to, vec<depset *> depsets,\n-\t\t\t      depset::hash &table,\n-\t\t\t      unsigned count, unsigned *crc_p)\n+\t\t\t      depset::hash &table, unsigned *crc_p)\n {\n-  dump () && dump (\"Writing %u pendings\", count);\n+  dump () && dump (\"Writing pending-entities\");\n   dump.indent ();\n \n   trees_out sec (to, this, table);\n   sec.begin ();\n \n+  unsigned count = 0;\n+  tree cache_ns = NULL_TREE;\n+  tree cache_id = NULL_TREE;\n+  unsigned cache_section = ~0;\n   for (unsigned ix = 0; ix < depsets.length (); ix++)\n     {\n       depset *d = depsets[ix];\n-      depset::entity_kind kind = d->get_entity_kind ();\n-      tree key = NULL_TREE;\n-      bool is_spec = false;\n-      \n \n-      if (kind == depset::EK_SPECIALIZATION)\n-\t{\n-\t  is_spec = true;\n-\t  key = reinterpret_cast <spec_entry *> (d->deps[0])->tmpl;\n-\t}\n-      else if (kind == depset::EK_PARTIAL)\n-\t{\n-\t  is_spec = true;\n-\t  key = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (d->get_entity ()));\n-\t}\n-      else if (kind == depset::EK_DECL && d->is_member ())\n-\t{\n-\t  tree ctx = DECL_CONTEXT (d->get_entity ());\n-\t  key = TYPE_NAME (ctx);\n-\t  if (tree ti = CLASSTYPE_TEMPLATE_INFO (ctx))\n-\t    if (DECL_TEMPLATE_RESULT (TI_TEMPLATE (ti)) == key)\n-\t      key = TI_TEMPLATE (ti);\n-\t}\n+      if (d->is_binding ())\n+\tcontinue;\n \n-      // FIXME:OPTIMIZATION More than likely when there is one pending\n-      // member, there will be others.  All written in the same\n-      // section and keyed to the same class.  We only need to record\n-      // one of them.  The same is not true for specializations\n+      if (d->is_import ())\n+\tcontinue;\n \n-      if (key)\n-\t{\n-\t  gcc_checking_assert (!d->is_import ());\n+      if (!(d->get_entity_kind () == depset::EK_SPECIALIZATION\n+\t    || d->get_entity_kind () == depset::EK_PARTIAL\n+\t    || (d->get_entity_kind () == depset::EK_DECL && d->is_member ())))\n+\tcontinue;\n \n-\t  {\n-\t    /* Key the entity to its key.  */\n-\t    depset *key_dep = table.find_dependency (key);\n-\t    if (key_dep->get_entity_kind () == depset::EK_REDIRECT)\n-\t      key_dep = key_dep->deps[0];\n-\t    unsigned key_origin\n-\t      = key_dep->is_import () ? key_dep->section : 0;\n-\t    sec.u (key_origin);\n-\t    sec.u (key_dep->cluster);\n-\t    sec.u (d->cluster);\n-\t    dump () && dump (\"%s %N entity:%u keyed to %M[%u] %N\",\n-\t\t\t     is_spec ? \"Specialization\" : \"Member\",\n-\t\t\t     d->get_entity (),\n-\t\t\t     d->cluster, (*modules)[key_origin],\n-\t\t\t     key_dep->cluster, key);\n-\t  }\n+      tree key_decl = nullptr;\n+      tree key_ns = find_pending_key (d->get_entity (), &key_decl);\n+      tree key_name = DECL_NAME (key_decl);\n \n-\t  if (is_spec)\n+      if (IDENTIFIER_ANON_P (key_name))\n+\t{\n+\t  gcc_checking_assert (IDENTIFIER_LAMBDA_P (key_name));\n+\t  if (tree attached = LAMBDA_TYPE_EXTRA_SCOPE (TREE_TYPE (key_decl)))\n+\t    key_name = DECL_NAME (attached);\n+\t  else\n \t    {\n-\t      /* Key the general template to the originating decl.  */\n-\t      tree origin = get_originating_module_decl (key);\n-\t      sec.tree_node (CP_DECL_CONTEXT (origin));\n-\t      sec.tree_node (DECL_NAME (origin));\n-\n-\t      unsigned origin_ident = import_entity_index (origin);\n-\t      module_state *origin_from = this;\n-\t      if (!(origin_ident & ~(~0u>>1)))\n-\t\torigin_from = import_entity_module (origin_ident);\n-\t      sec.u (origin_from->remap);\n+\t      /* There's nothing to attach it to.  Must\n+\t\t always reinstantiate.  */\n+\t      dump ()\n+\t\t&& dump (\"Unattached lambda %N[%u] section:%u\",\n+\t\t\t d->get_entity_kind () == depset::EK_DECL\n+\t\t\t ? \"Member\" : \"Specialization\", d->get_entity (),\n+\t\t\t d->cluster, d->section);\n+\t      continue;\n \t    }\n-\t  else\n-\t    sec.tree_node (NULL);\n-\t  count--;\n \t}\n+\n+      char const *also = \"\";\n+      if (d->section == cache_section\n+\t  && key_ns == cache_ns\n+\t  && key_name == cache_id)\n+\t/* Same section & key as previous, no need to repeat ourselves.  */\n+\talso = \"also \";\n+      else\n+\t{\n+\t  cache_ns = key_ns;\n+\t  cache_id = key_name;\n+\t  cache_section = d->section;\n+\t  gcc_checking_assert (table.find_dependency (cache_ns));\n+\t  sec.tree_node (cache_ns);\n+\t  sec.tree_node (cache_id);\n+\t  sec.u (d->cluster);\n+\t  count++;\n+\t}\n+      dump () && dump (\"Pending %s %N entity:%u section:%u %skeyed to %P\",\n+\t\t       d->get_entity_kind () == depset::EK_DECL\n+\t\t       ? \"member\" : \"specialization\", d->get_entity (),\n+\t\t       d->cluster, cache_section, also, cache_ns, cache_id);\n       }\n-  gcc_assert (!count);\n   sec.end (to, to->name (MOD_SNAME_PFX \".pnd\"), crc_p);\n   dump.outdent ();\n+\n+  return count;\n }\n \n bool\n@@ -15504,72 +15612,28 @@ module_state::read_pendings (unsigned count)\n \n   for (unsigned ix = 0; ix != count; ix++)\n     {\n-      unsigned key_origin = slurp->remap_module (sec.u ());\n-      unsigned key_index = sec.u ();\n-      unsigned ent_index = sec.u ();\n-      module_state *from = (*modules)[key_origin];\n-      tree ns = sec.tree_node ();\n+      pending_key key;\n+      unsigned index;\n \n-      if (!key_origin\n-\t  || key_index >= from->entity_num || ent_index >= entity_num\n-\t  || (ns && TREE_CODE (ns) != NAMESPACE_DECL))\n+      key.ns = sec.tree_node ();\n+      key.id = sec.tree_node ();\n+      index = sec.u ();\n+\n+      if (!key.ns || !key.id\n+\t  || !(TREE_CODE (key.ns) == NAMESPACE_DECL\n+\t       && !DECL_NAMESPACE_ALIAS (key.ns))\n+\t  || !identifier_p (key.id)\n+\t  || index >= entity_num)\n \tsec.set_overrun ();\n \n       if (sec.get_overrun ())\n \tbreak;\n \n-      bool loaded = false;\n-      dump () && dump (\"%s keyed to %M[%u] entity:%u\",\n-\t\t       ns ? \"Specialization\" : \"Member\",\n-\t\t       from, key_index, ent_index);\n-      unsigned key_ident = from->entity_lwm + key_index;\n-      if (pending_table->add (ns ? key_ident : ~key_ident,\n-\t\t\t      ent_index + entity_lwm))\n-\t{\n-\t  binding_slot &slot = (*entity_ary)[key_ident];\n-\t  if (slot.is_lazy ())\n-\t    slot.or_lazy (ns ? 1 : 2);\n-\t  else\n-\t    {\n-\t      tree key = slot;\n-\n-\t      loaded = true;\n-\t      if (ns)\n-\t\t{\n-\t\t  if (key && TREE_CODE (key) == TEMPLATE_DECL)\n-\t\t    DECL_MODULE_PENDING_SPECIALIZATIONS_P (key) = true;\n-\t\t  else\n-\t\t    sec.set_overrun ();\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (key && TREE_CODE (key) == TYPE_DECL)\n-\t\t    DECL_MODULE_PENDING_MEMBERS_P (key) = true;\n-\t\t  else\n-\t\t    sec.set_overrun ();\n-\t\t}\n-\t    }\n-\t}\n+      dump () && dump (\"Pending:%u keyed to %P\", index, key.ns, key.id);\n \n-      if (ns)\n-\t{\n-\t  /* We also need to mark the namespace binding of the\n-\t     originating template, so we know to set its pending\n-\t     specializations flag, when we load it.  */\n-\t  tree name = sec.tree_node ();\n-\t  unsigned origin = slurp->remap_module (sec.u ());\n-\t  if (!origin || !name || TREE_CODE (name) != IDENTIFIER_NODE)\n-\t    sec.set_overrun ();\n-\t  if (sec.get_overrun ())\n-\t    break;\n-\n-\t  module_state *origin_from = (*modules)[origin];\n-\t  if (!loaded\n-\t      && (origin_from->is_header ()\n-\t\t  || (origin_from->is_partition ()\n-\t\t      || origin_from->is_module ())))\n-\t    note_pending_specializations (ns, name, origin_from->is_header ());\n-\t}\n+      index += entity_lwm;\n+      auto &vec = pending_table->get_or_insert (key);\n+      vec.safe_push (index);\n     }\n \n   dump.outdent ();\n@@ -15578,23 +15642,6 @@ module_state::read_pendings (unsigned count)\n   return true;\n }\n \n-/* Return true if module MOD cares about lazy specializations keyed to\n-   possibly duplicated entity bindings.  */\n-\n-bool\n-lazy_specializations_p (unsigned mod, bool header_p, bool partition_p)\n-{\n-  module_state *module = (*modules)[mod];\n-\n-  if (module->is_header ())\n-    return header_p;\n-\n-  if (module->is_module () || module->is_partition ())\n-    return partition_p;\n-\n-  return false;\n-}\n-\n /* Read & write locations.  */\n enum loc_kind {\n   LK_ORDINARY,\n@@ -17873,6 +17920,8 @@ module_state::write (elf_out *to, cpp_reader *reader)\n \t}\n     }\n \n+  /* depset::cluster - entity number (on entities)\n+     depset::section - cluster number  */\n   /* We'd better have written as many sections and found as many\n      namespaces as we predicted.  */\n   gcc_assert (counts[MSC_sec_hwm] == to->get_section_limit ()\n@@ -17892,8 +17941,7 @@ module_state::write (elf_out *to, cpp_reader *reader)\n   counts[MSC_bindings] = write_bindings (to, sccs, &crc);\n \n   /* Write the unnamed.  */\n-  if (counts[MSC_pendings])\n-    write_pendings (to, sccs, table, counts[MSC_pendings], &crc);\n+  counts[MSC_pendings] = write_pendings (to, sccs, table, &crc);\n \n   /* Write the import table.  */\n   if (config.num_imports > 1)\n@@ -18928,84 +18976,65 @@ lazy_load_binding (unsigned mod, tree ns, tree id, binding_slot *mslot)\n \t    module->get_flatname ());\n }\n \n-/* Load any pending specializations of TMPL.  Called just before\n-   instantiating TMPL.  */\n+/* Load any pending entities keyed to the top-key of DECL.  */\n \n void\n-lazy_load_specializations (tree tmpl)\n+lazy_load_pendings (tree decl)\n {\n-  gcc_checking_assert (DECL_MODULE_PENDING_SPECIALIZATIONS_P (tmpl)\n-\t\t       && DECL_MODULE_ENTITY_P (tmpl));\n+  tree key_decl;\n+  pending_key key;\n+  key.ns = find_pending_key (decl, &key_decl);\n+  key.id = DECL_NAME (key_decl);\n+\n+  auto *pending_vec = pending_table ? pending_table->get (key) : nullptr;\n+  if (!pending_vec)\n+    return;\n \n   int count = errorcount + warningcount;\n \n   timevar_start (TV_MODULE_IMPORT);\n   bool ok = !recursive_lazy ();\n   if (ok)\n     {\n-      unsigned ident = import_entity_index (tmpl);\n-      if (pendset *set = pending_table->get (ident, true))\n+      function_depth++; /* Prevent GC */\n+      unsigned n = dump.push (NULL);\n+      dump () && dump (\"Reading %u pending entities keyed to %P\",\n+\t\t       pending_vec->length (), key.ns, key.id);\n+      for (unsigned ix = pending_vec->length (); ix--;)\n \t{\n-\t  function_depth++; /* Prevent GC */\n-\t  unsigned n = dump.push (NULL);\n-\t  dump ()\n-\t    && dump (\"Reading %u pending specializations keyed to %M[%u] %N\",\n-\t\t     set->num, import_entity_module (ident),\n-\t\t     ident - import_entity_module (ident)->entity_lwm, tmpl);\n-\t  if (!pendset_lazy_load (set, true))\n-\t    ok = false;\n-\t  dump.pop (n);\n+\t  unsigned index = (*pending_vec)[ix];\n+\t  binding_slot *slot = &(*entity_ary)[index];\n \n-\t  function_depth--;\n+\t  if (slot->is_lazy ())\n+\t    {\n+\t      module_state *import = import_entity_module (index);\n+\t      if (!import->lazy_load (index - import->entity_lwm, slot))\n+\t\tok = false;\n+\t    }\n+\t  else if (dump ())\n+\t    {\n+\t      module_state *import = import_entity_module (index);\n+\t      dump () && dump (\"Entity %M[%u] already loaded\",\n+\t\t\t       import, index - import->entity_lwm);\n+\t    }\n \t}\n+\n+      pending_table->remove (key);\n+      dump.pop (n);\n+      function_depth--;\n       lazy_snum = 0;\n       post_load_processing ();\n     }\n \n   timevar_stop (TV_MODULE_IMPORT);\n \n   if (!ok)\n-    fatal_error (input_location, \"failed to load specializations keyed to %qD\",\n-\t\t tmpl);\n+    fatal_error (input_location, \"failed to load pendings for %<%E%s%E%>\",\n+\t\t key.ns, &\"::\"[key.ns == global_namespace ? 2 : 0], key.id);\n \n   if (count != errorcount + warningcount)\n-    inform (input_location,\n-\t    \"during load of specializations keyed to %qD\", tmpl);\n-}\n-\n-void\n-lazy_load_members (tree decl)\n-{\n-  gcc_checking_assert (DECL_MODULE_PENDING_MEMBERS_P (decl));\n-  if (!DECL_MODULE_ENTITY_P (decl))\n-    {\n-      // FIXME: I can't help feeling that DECL_TEMPLATE_RESULT should\n-      // be inserted into the entity map, or perhaps have the same\n-      // DECL_UID as the template, so I don't have to do this dance\n-      // here and elsewhere.  It also simplifies when DECL is a\n-      // partial specialization.  (also noted elsewhere as an issue)\n-      tree ti = CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (decl));\n-      tree tmpl = TI_TEMPLATE (ti);\n-      gcc_checking_assert (DECL_TEMPLATE_RESULT (tmpl) == decl);\n-      decl = tmpl;\n-    }\n-\n-  timevar_start (TV_MODULE_IMPORT);\n-  unsigned ident = import_entity_index (decl);\n-  if (pendset *set = pending_table->get (~ident, true))\n-    {\n-      function_depth++; /* Prevent GC */\n-      unsigned n = dump.push (NULL);\n-      dump () && dump (\"Reading %u pending members keyed to %M[%u] %N\",\n-\t\t       set->num, import_entity_module (ident),\n-\t\t       ident - import_entity_module (ident)->entity_lwm, decl);\n-      pendset_lazy_load (set, false);\n-      post_load_processing ();\n-      dump.pop (n);\n-\n-      function_depth--;\n-    }\n-  timevar_stop (TV_MODULE_IMPORT);\n+    inform (input_location, \"during load of pendings for %<%E%s%E%>\",\n+\t    key.ns, &\"::\"[key.ns == global_namespace ? 2 : 0], key.id);\n }\n \n static void\n@@ -19532,7 +19561,7 @@ preprocess_module (module_state *module, location_t from_loc,\n \t{\n \t  unsigned n = dump.push (NULL);\n \n-\t  dump () && dump (\"Reading %s preprocessor state\", module);\n+\t  dump () && dump (\"Reading %M preprocessor state\", module);\n \t  name_pending_imports (reader, false);\n \n \t  /* Preserve the state of the line-map.  */\n@@ -19873,8 +19902,7 @@ init_modules (cpp_reader *reader)\n \n   if (!flag_preprocess_only)\n     {\n-      pending_table = new pendset::hash (EXPERIMENT (1, 400));\n-\n+      pending_table = new pending_map_t (EXPERIMENT (1, 400));\n       entity_map = new entity_map_t (EXPERIMENT (1, 400));\n       vec_safe_reserve (entity_ary, EXPERIMENT (1, 400));\n     }"}, {"sha": "f57708700c2c0c296b9069f439e8c6fd6ad307b5", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 55, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -1916,10 +1916,10 @@ get_class_binding_direct (tree klass, tree name, bool want_type)\n static void\n maybe_lazily_declare (tree klass, tree name)\n {\n-  tree main_decl = TYPE_NAME (TYPE_MAIN_VARIANT (klass));\n-  if (DECL_LANG_SPECIFIC (main_decl)\n-      && DECL_MODULE_PENDING_MEMBERS_P (main_decl))\n-    lazy_load_members (main_decl);\n+  /* See big comment anout module_state::write_pendings regarding adding a check\n+     bit.  */\n+  if (modules_p ())\n+    lazy_load_pendings (TYPE_NAME (klass));\n \n   /* Lazily declare functions, if we're going to search these.  */\n   if (IDENTIFIER_CTOR_P (name))\n@@ -4100,57 +4100,6 @@ set_module_binding (tree ns, tree name, unsigned mod, int mod_glob,\n   return true;\n }\n \n-void\n-note_pending_specializations (tree ns, tree name, bool is_header)\n-{\n-  if (tree *slot = find_namespace_slot (ns, name, false))\n-    if (TREE_CODE (*slot) == BINDING_VECTOR)\n-      {\n-\ttree vec = *slot;\n-\tBINDING_VECTOR_PENDING_SPECIALIZATIONS_P (vec) = true;\n-\tif (is_header)\n-\t  BINDING_VECTOR_PENDING_IS_HEADER_P (vec) = true;\n-\telse\n-\t  BINDING_VECTOR_PENDING_IS_PARTITION_P (vec) = true;\n-      }\n-}\n-\n-void\n-load_pending_specializations (tree ns, tree name)\n-{\n-  tree *slot = find_namespace_slot (ns, name, false);\n-\n-  if (!slot || TREE_CODE (*slot) != BINDING_VECTOR\n-      || !BINDING_VECTOR_PENDING_SPECIALIZATIONS_P (*slot))\n-    return;\n-\n-  tree vec = *slot;\n-  BINDING_VECTOR_PENDING_SPECIALIZATIONS_P (vec) = false;\n-\n-  bool do_header = BINDING_VECTOR_PENDING_IS_HEADER_P (vec);\n-  bool do_partition = BINDING_VECTOR_PENDING_IS_PARTITION_P (vec);\n-  BINDING_VECTOR_PENDING_IS_HEADER_P (vec) = false;\n-  BINDING_VECTOR_PENDING_IS_PARTITION_P (vec) = false;\n-\n-  gcc_checking_assert (do_header | do_partition);\n-  binding_cluster *cluster = BINDING_VECTOR_CLUSTER_BASE (vec);\n-  unsigned ix = BINDING_VECTOR_NUM_CLUSTERS (vec);\n-  if (BINDING_VECTOR_SLOTS_PER_CLUSTER == BINDING_SLOTS_FIXED)\n-    {\n-      ix--;\n-      cluster++;\n-    }\n-\n-  for (; ix--; cluster++)\n-    for (unsigned jx = 0; jx != BINDING_VECTOR_SLOTS_PER_CLUSTER; jx++)\n-      if (cluster->indices[jx].span\n-\t  && cluster->slots[jx].is_lazy ()\n-\t  && lazy_specializations_p (cluster->indices[jx].base,\n-\t\t\t\t     do_header, do_partition))\n-\tlazy_load_binding (cluster->indices[jx].base, ns, name,\n-\t\t\t   &cluster->slots[jx]);\n-}\n-\n void\n add_module_namespace_decl (tree ns, tree decl)\n {"}, {"sha": "67e923fc611bd64ce3024fda973e7a3807709782", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -177,17 +177,6 @@ struct GTY(()) tree_binding_vec {\n #define MODULE_BINDING_PARTITION_P(NODE)\t\t\\\n   (OVERLOAD_CHECK (NODE)->base.volatile_flag)\n \n-/* There are specializations of a template keyed to this binding.  */\n-#define BINDING_VECTOR_PENDING_SPECIALIZATIONS_P(NODE) \\\n-  (BINDING_VECTOR_CHECK (NODE)->base.public_flag)\n-/* The key is in a header unit (not a named module partition or\n-   primary).  */\n-#define BINDING_VECTOR_PENDING_IS_HEADER_P(NODE) \\\n-  (BINDING_VECTOR_CHECK (NODE)->base.protected_flag)\n-/* The key is in a named module (primary or partition).  */\n-#define BINDING_VECTOR_PENDING_IS_PARTITION_P(NODE) \\\n-  (BINDING_VECTOR_CHECK (NODE)->base.private_flag)\n-\n extern void set_identifier_type_value (tree, tree);\n extern void push_binding (tree, tree, cp_binding_level*);\n extern void pop_local_binding (tree, tree);\n@@ -507,8 +496,6 @@ extern unsigned walk_module_binding (tree binding, bitmap partitions,\n extern tree add_imported_namespace (tree ctx, tree name, location_t,\n \t\t\t\t    unsigned module,\n \t\t\t\t    bool inline_p, bool visible_p);\n-extern void note_pending_specializations (tree ns, tree name, bool is_header);\n-extern void load_pending_specializations (tree ns, tree name);\n extern const char *get_cxx_dialect_name (enum cxx_dialect dialect);\n \n #endif /* GCC_CP_NAME_LOOKUP_H */"}, {"sha": "83589101c0d76c58f143a2fee43244651acb873c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -9796,13 +9796,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,\n \n       gen_tmpl = most_general_template (templ);\n       if (modules_p ())\n-\t{\n-\t  tree origin = get_originating_module_decl (gen_tmpl);\n-\t  load_pending_specializations (CP_DECL_CONTEXT (origin),\n-\t\t\t\t\tDECL_NAME (origin));\n-\t  if (DECL_MODULE_PENDING_SPECIALIZATIONS_P (gen_tmpl))\n-\t    lazy_load_specializations (gen_tmpl);\n-\t}\n+\tlazy_load_pendings (gen_tmpl);\n \n       parmlist = DECL_TEMPLATE_PARMS (gen_tmpl);\n       parm_depth = TMPL_PARMS_DEPTH (parmlist);\n@@ -21001,6 +20995,9 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n \n   gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);\n \n+  if (modules_p ())\n+    lazy_load_pendings (tmpl);\n+\n   /* If this function is a clone, handle it specially.  */\n   if (DECL_CLONED_FUNCTION_P (tmpl))\n     {\n@@ -21037,15 +21034,6 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n \t\t(DECL_TI_ARGS (DECL_TEMPLATE_RESULT (tmpl)),\n \t\t targ_ptr));\n \n-  if (modules_p ())\n-    {\n-      tree origin = get_originating_module_decl (gen_tmpl);\n-      load_pending_specializations (CP_DECL_CONTEXT (origin),\n-\t\t\t\t    DECL_NAME (origin));\n-      if (DECL_MODULE_PENDING_SPECIALIZATIONS_P (gen_tmpl))\n-\tlazy_load_specializations (gen_tmpl);\n-    }\n-\n   /* It would be nice to avoid hashing here and then again in tsubst_decl,\n      but it doesn't seem to be on the hot path.  */\n   spec = retrieve_specialization (gen_tmpl, targ_ptr, 0);\n@@ -25946,6 +25934,10 @@ instantiate_decl (tree d, bool defer_ok, bool expl_inst_class_mem_p)\n \n   gcc_checking_assert (!DECL_FUNCTION_SCOPE_P (d));\n \n+  if (modules_p ())\n+    /* We may have a pending instantiation of D itself.  */\n+    lazy_load_pendings (d);\n+\n   /* Variables are never deferred; if instantiation is required, they\n      are instantiated right away.  That allows for better code in the\n      case that an expression refers to the value of the variable --"}, {"sha": "dff4e9b63cab507366ff81ead82efa9fbc3d64a3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -133,8 +133,15 @@ complete_type (tree type)\n \t  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = has_nontrivial_dtor;\n \t}\n     }\n-  else if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n-    instantiate_class_template (TYPE_MAIN_VARIANT (type));\n+  else if (CLASS_TYPE_P (type))\n+    {\n+      if (modules_p ())\n+\t/* TYPE could be a class member we've not loaded the definition of.  */ \n+\tlazy_load_pendings (TYPE_NAME (TYPE_MAIN_VARIANT (type)));\n+\n+      if (CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n+\tinstantiate_class_template (TYPE_MAIN_VARIANT (type));\n+    }\n \n   return type;\n }"}, {"sha": "59e48b31a4c15e1d5af70801476665a8fcde6eac", "filename": "gcc/testsuite/g++.dg/modules/inst-2_b.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finst-2_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finst-2_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finst-2_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -1,4 +1,4 @@\n-// { dg-additional-options {-fmodules-ts -fdump-lang-module-uid-alias} }\n+// { dg-additional-options {-fmodules-ts -fdump-lang-module-alias} }\n import foo;\n \n int main ()\n@@ -9,6 +9,6 @@ int main ()\n   return 0;\n }\n \n-// { dg-final { scan-lang-dump {Reading 1 pending specializations} module } }\n+// { dg-final { scan-lang-dump {Reading 1 pending entities keyed to '::foo'} module } }\n \n // { dg-final { scan-lang-dump {Read:-[0-9]*'s decl spec merge key \\(new\\) function_decl:'::foo'} module } }"}, {"sha": "fa94ab636cdac029146604f1fe595542872bd387", "filename": "gcc/testsuite/g++.dg/modules/inst-4_a.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finst-4_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finst-4_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finst-4_a.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -1,5 +1,5 @@\n // { dg-module-do run }\n-// { dg-additional-options {-fmodules-ts -fdump-lang-module-graph-blocks-alias} }\n+// { dg-additional-options {-fmodules-ts -fdump-lang-module-graph} }\n \n export module foo;\n // { dg-module-cmi foo }\n@@ -16,5 +16,5 @@ export inline int user (int i)\n   return x.m;\n }\n \n-// { dg-final { scan-lang-dump {Specialization '::TPL<int>' entity:. keyed to foo\\[.\\] '::template TPL'} module } }\n-// { dg-final { scan-lang-dump {Specialization '::TPL<int>::TPL<int>' entity:. keyed to foo\\[.\\] '::template TPL<T>::template TPL'} module } }\n+// { dg-final { scan-lang-dump {Pending specialization '::TPL<int>' entity:. section:. keyed to '::TPL'} module } }\n+// { dg-final { scan-lang-dump {Pending specialization '::TPL<int>::TPL<int>' entity:. section:. also keyed to '::TPL'} module } }"}, {"sha": "c7b02b470bd6a4161916e56b63497f2b6816dd52", "filename": "gcc/testsuite/g++.dg/modules/inst-4_b.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finst-4_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finst-4_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Finst-4_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -1,4 +1,4 @@\n-// { dg-additional-options {-fmodules-ts -fdump-lang-module-alias-uid} }\n+// { dg-additional-options {-fmodules-ts -fdump-lang-module-alias} }\n import foo;\n \n int main ()\n@@ -9,5 +9,5 @@ int main ()\n   return 0;\n }\n \n-// { dg-final { scan-lang-dump {Reading 1 pending specializations keyed to foo\\[.\\] '::template TPL@foo:.'} module } }\n+// { dg-final { scan-lang-dump {Reading 1 pending entities keyed to '::TPL'} module } }\n // { dg-final { scan-lang-dump {Read:-[0-9]*'s type spec merge key \\(new\\) type_decl:'::TPL'} module } }"}, {"sha": "ad4826ccacd578e6bf55ea75d96c6f5cf7465e94", "filename": "gcc/testsuite/g++.dg/modules/member-def-1_b.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmember-def-1_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmember-def-1_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmember-def-1_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -11,4 +11,4 @@ struct frob::inner\n };\n \n // { dg-final { scan-lang-dump { Cluster members:\\n  \\[0\\]=decl definition '::frob@foo:part1:1::inner'\\n  \\[1\\]=decl declaration '::frob@foo:part1:1::inner::inner'\\n} module } }\n-// { dg-final { scan-lang-dump {Member '::frob@foo:part1:1::inner' entity:0 keyed to foo:part1\\[0\\] '::frob@foo:part1:1'} module } }\n+// { dg-final { scan-lang-dump {Pending member '::frob@foo:part1:1::inner' entity:0 section:. keyed to '::frob'} module } }"}, {"sha": "d4190a84d581878d1d1dc305c82f9349d5663f46", "filename": "gcc/testsuite/g++.dg/modules/member-def-1_c.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmember-def-1_c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmember-def-1_c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fmember-def-1_c.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -11,6 +11,6 @@ export auto foo ()\n   return frob::inner ();\n }\n \n-// { dg-final { scan-lang-dump {Reading 1 pending members keyed to foo:part1\\[0\\] '::frob@foo:part1:1'} module } }\n+// { dg-final { scan-lang-dump {Reading 1 pending entities keyed to '::frob'} module } }\n // { dg-final { scan-lang-dump { Cluster members:\\n  \\[0\\]=decl definition '::frob@foo:part1:1'\\n  \\[1\\]=decl definition '::frob@foo:part1:1::inner@foo:part1:1'\\n  \\[2\\]=decl declaration '::frob@foo:part1:1::inner@foo:part1:1::__dt '\\n(  \\[.\\]=decl declaration '::frob@foo:part1:1::inner@foo:part1:1::__ct '\\n)*  \\[6\\]=decl declaration '::frob@foo:part1:1::inner@foo:part1:1::inner@foo:part2:2'\\n  \\[7\\]=decl declaration '::frob@foo:part1:1::frob@foo:part1:1'\\n  \\[8\\]=decl declaration '::frob@foo:part1:1::__as_base @foo:part1:1'\\n  \\[9\\]=binding '::frob'\\n} module } }\n // { dg-final { scan-lang-dump {Pendings 0} module } }"}, {"sha": "d9a0b8b650a9586aebe386d3aae8b7b0196b16ad", "filename": "gcc/testsuite/g++.dg/modules/pr99170-1_a.H", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-1_a.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-1_a.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-1_a.H?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -0,0 +1,10 @@\n+// PR 99170, pending instantiation snafu\n+// { dg-additional-options {-fmodule-header} }\n+// { dg-module-cmi {} }\n+namespace STD {\n+class string {\n+public:\n+  template <typename T>\n+  string (const T *);\n+};\n+}"}, {"sha": "d3d8ac96a79972ecc72878ca6d225e6df8e292fe", "filename": "gcc/testsuite/g++.dg/modules/pr99170-1_b.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-1_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-1_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-1_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -0,0 +1,7 @@\n+// { dg-additional-options {-fmodules-ts} }\n+export module test;\n+// { dg-module-cmi test }\n+import \"pr99170-1_a.H\";\n+export class A {\n+  STD::string str{\"ayyy\"};\n+};"}, {"sha": "10259d408997df4b9fa7dafe9a3690d479b81699", "filename": "gcc/testsuite/g++.dg/modules/pr99170-2.h", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-2.h?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -0,0 +1,44 @@\n+\n+namespace std\n+{\n+typedef long unsigned int size_t;\n+}\n+\n+namespace __gnu_cxx\n+{\n+template<typename _CharT>\n+struct char_traits\n+{\n+  typedef _CharT char_type;\n+\n+  static constexpr std::size_t\n+    length(const char_type* __s);\n+};\n+\n+template<typename _CharT>\n+constexpr std::size_t\n+  char_traits<_CharT>::\n+  length(const char_type* __p)\n+{\n+  std::size_t __i = 0;\n+  return __i;\n+}\n+}\n+\n+namespace std\n+{\n+template<class _CharT>\n+struct char_traits;\n+\n+template<>\n+struct char_traits<char>\n+{\n+  typedef char char_type;\n+\n+  static constexpr size_t\n+    length(const char_type* __s)\n+  {\n+    return __gnu_cxx::char_traits<char_type>::length(__s);\n+  }\n+};\n+}"}, {"sha": "8b0b5e80345e80feb9fcaf250d5bf412cf81e844", "filename": "gcc/testsuite/g++.dg/modules/pr99170-2_a.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-2_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-2_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-2_a.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -0,0 +1,9 @@\n+// pr99170 pending instantiations\n+// { dg-additional-options -fmodules-ts }\n+module;\n+#include \"pr99170-2.h\"\n+\n+export  module  hello;\n+// { dg-module-cmi hello }\n+\n+export void greeter (__gnu_cxx::char_traits<char> const &name);"}, {"sha": "335eb1ffa13164853d0600ea38502d2ffcce36cc", "filename": "gcc/testsuite/g++.dg/modules/pr99170-2_b.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-2_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-2_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-2_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -0,0 +1,4 @@\n+// { dg-additional-options -fmodules-ts }\n+\n+#include \"pr99170-2.h\"\n+import hello;"}, {"sha": "6b570b5b431d4a92703af00d50144f05204a6f2b", "filename": "gcc/testsuite/g++.dg/modules/pr99170-3_a.H", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-3_a.H", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-3_a.H", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-3_a.H?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -0,0 +1,11 @@\n+// PR 99170\n+// { dg-module-do link }\n+// { dg-additional-options -fmodule-header }\n+// { dg-module-cmi {} }\n+struct Foo \n+{\n+  Foo () {};\n+  \n+};\n+\n+static Foo __ioinit;"}, {"sha": "76fa71d842789693de148a1b90b37e11c4440364", "filename": "gcc/testsuite/g++.dg/modules/pr99170-3_b.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-3_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-3_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr99170-3_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -0,0 +1,6 @@\n+// { dg-additional-options -fmodules-ts }\n+import \"pr99170-3_a.H\";\n+\n+int main ()\n+{\n+}"}, {"sha": "3bfb6394d565d7d448e73ca41298866a92f251a3", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-1_a.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-1_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-1_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-1_a.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -17,6 +17,6 @@ template <> int foo<int> (int y)\n // { dg-final { scan-lang-dump {Dependencies of specialization function_decl:'::foo<int>'} module } }\n // { dg-final { scan-lang-dump-not {Depending definition function_decl:'::foo<int>'} module } }\n // { dg-final { scan-lang-dump {Cluster members:\\n  \\[0\\]=specialization declaration '::foo<int>'} module } }\n-// { dg-final { scan-lang-dump {Specialization '::foo<int>' entity:[0-9]* keyed to TPL\\[0\\] '::template foo'} module } }\n+// { dg-final { scan-lang-dump {Pending specialization '::foo<int>' entity:[0-9]* section:. keyed to '::foo'} module } }\n \n // { dg-final { scan-assembler {_Z3fooIiEiT_:} } }"}, {"sha": "a1dd6566412b1aa7577c93d5f30234f292b74b6a", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-1_b.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-1_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-1_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-1_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -14,7 +14,6 @@ int main ()\n }\n \n // { dg-final { scan-lang-dump-not {Reading definition function_decl '::foo@TPL:.<int>'} module } }\n-// { dg-final { scan-lang-dump {Specialization keyed to TPL\\[0\\] entity:1} module } }\n-// { dg-final { scan-lang-dump {Reading 1 pending specializations keyed to TPL\\[0\\] '::template foo@TPL:1'} module } }\n+// { dg-final { scan-lang-dump {Reading 1 pending entities keyed to '::foo'} module } }\n \n // { dg-final { scan-assembler-not {_Z3fooIiEiT_:} } }"}, {"sha": "a8b40caf91219aead26f544c440aae492c47a5bc", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-2_b.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-2_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-2_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-2_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -13,6 +13,6 @@ template <> int foo<int> (int y)\n // { dg-final { scan-lang-dump {Dependencies of specialization function_decl:'::foo<int>'} module } }\n // { dg-final { scan-lang-dump-not {Depending definition function_decl:'::foo<int>'} module } }\n // { dg-final { scan-lang-dump {Cluster members:\\n  \\[0\\]=specialization declaration '::foo<int>'} module } }\n-// { dg-final { scan-lang-dump {Specialization '::foo<int>' entity:[0-9]* keyed to TPL\\[.\\] '::template foo@TPL:.'} module } }\n+// { dg-final { scan-lang-dump {Pending specialization '::foo<int>' entity:[0-9]* section:. keyed to '::foo'} module } }\n \n // { dg-final { scan-assembler {_Z3fooIiEiT_:} } }"}, {"sha": "51b5eadfc96de300dcfb56b1c6690d984aeac5ba", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-2_c.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-2_c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-2_c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-2_c.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -13,7 +13,7 @@ int main ()\n   return 0;\n }\n \n-// { dg-final { scan-lang-dump {Reading 1 pending specializations keyed to TPL\\[0\\] '::template foo@TPL:.'} module } }\n+// { dg-final { scan-lang-dump {Reading 1 pending entities keyed to '::foo'} module } }\n // { dg-final { scan-lang-dump-not {Reading definition function_decl '::foo@TPL:.<int>'} module } }\n \n // { dg-final { scan-assembler-not {_Z3fooIiEiT_:} } }"}, {"sha": "f8aae310b31e1cc2156b025e2acd3a079c2ce01f", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-2_d.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-2_d.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-2_d.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-2_d.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -20,7 +20,7 @@ int two ()\n   return 0;\n }\n \n-// { dg-final { scan-lang-dump {Reading 1 pending specializations keyed to TPL\\[0\\] '::template foo@TPL:.'} module } }\n+// { dg-final { scan-lang-dump {Reading 1 pending entities keyed to '::foo'} module } }\n // { dg-final { scan-lang-dump-not {Reading definition function_decl '::foo@TPL:.<int>'} module } }\n \n // { dg-final { scan-assembler-not {_Z3fooIiEiT_:} } }"}, {"sha": "1e677fc42dff9570daa71939a5ad26a1fb126d58", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-3_a.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-3_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-3_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-3_a.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -22,6 +22,6 @@ template <> void frob::store (int i_)\n // { dg-final { scan-lang-dump {Dependencies of specialization function_decl:'::frob::store<int>'} module } }\n // { dg-final { scan-lang-dump-not {Depending definition function_decl:'::frob::store<int>'} module } }\n // { dg-final { scan-lang-dump {Cluster members:\\n  \\[0\\]=specialization declaration '::frob::store<int>'} module } }\n-// { dg-final { scan-lang-dump {Specialization '::frob::store<int>' entity:[0-9]* keyed to TPL\\[1\\] '::frob::template store'} module } }\n+// { dg-final { scan-lang-dump {Pending specialization '::frob::store<int>' entity:[0-9]* section:. keyed to '::frob'} module } }\n \n // { dg-final { scan-assembler {_ZN4frob5storeIiEEvT_:} } }"}, {"sha": "a7105ae6759baaf1b5853759dd4887892a951063", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-3_b.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-3_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-3_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-3_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -17,7 +17,7 @@ int main ()\n   return 0;\n }\n \n-// { dg-final { scan-lang-dump {Reading 1 pending specializations keyed to TPL\\[1\\] '::frob@TPL:.::template store@TPL:.'} module } }\n+// { dg-final { scan-lang-dump {Reading 1 pending entities keyed to '::frob'} module } }\n // { dg-final { scan-lang-dump-not {Reading definition function_decl '::frob@TPL:.::store@TPL:.<int>'} module } }\n \n // { dg-final { scan-assembler-not {_ZN4frob5storeIiEEvT_:} } }"}, {"sha": "85068215d63af28d01218342e2ec5f474a11e5d5", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-4_a.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-4_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-4_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-4_a.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -16,4 +16,4 @@ template<> struct X<int>\n \n // { dg-final { scan-lang-dump {Dependencies of specialization type_decl:'::X<int>'} module } }\n // { dg-final { scan-lang-dump {Cluster members:\\n(  \\[.\\]=[^\\n]*'\\n)*  \\[.\\]=specialization definition '::X<int>'} module } }\n-// { dg-final { scan-lang-dump {Specialization '::X<int>' entity:[0-9]* keyed to TPL\\[0\\] '::template X'} module } }\n+// { dg-final { scan-lang-dump {Pending specialization '::X<int>' entity:[0-9]* section:. keyed to '::X'} module } }"}, {"sha": "97aa251d3e058b41bbcaaad790692c2ce29b6e35", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-4_b.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-4_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-4_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-4_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -14,4 +14,4 @@ int main ()\n   return 0;\n }\n \n-// { dg-final { scan-lang-dump {Reading 1 pending specializations keyed to TPL\\[0\\] '::template X@TPL:.'} module } }\n+// { dg-final { scan-lang-dump {Reading 1 pending entities keyed to '::X'} module } }"}, {"sha": "f475b824ebd4250d0aac9c292b321f07e06a966b", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-5_a.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-5_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-5_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-5_a.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -16,4 +16,4 @@ template<typename T> struct X<T,1>\n \n // { dg-final { scan-lang-dump {Dependency on partial template_decl:'::template X<T,0x1>' found} module } }\n // { dg-final { scan-lang-dump {Cluster members:\\n(  \\[.\\][^\\n]*'\\n)*  \\[.\\]=partial definition '::template X<T,0x1>'} module } }\n-// { dg-final { scan-lang-dump {Specialization '::template X<T,0x1>' entity:[0-9]* keyed to TPL\\[0\\] '::template X'} module } }\n+// { dg-final { scan-lang-dump {Pending specialization '::template X<T,0x1>' entity:[0-9]* section:. keyed to '::X'} module } }"}, {"sha": "ff3d84c1384e5d44a42b65729b23229e2476c948", "filename": "gcc/testsuite/g++.dg/modules/tpl-spec-5_b.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-5_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c778a237c1c605c2c5606c212c1ace756739442b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-5_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Ftpl-spec-5_b.C?ref=c778a237c1c605c2c5606c212c1ace756739442b", "patch": "@@ -14,4 +14,4 @@ int main ()\n   return 0;\n }\n \n-// { dg-final { scan-lang-dump {Reading 1 pending specializations keyed to TPL\\[0\\] '::template X@TPL:.'} module } }\n+// { dg-final { scan-lang-dump {Reading 1 pending entities keyed to '::X'} module } }"}]}