{"sha": "7628dc541e7092f0d58de9a3622ce242807cb47d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzYyOGRjNTQxZTcwOTJmMGQ1OGRlOWEzNjIyY2UyNDI4MDdjYjQ3ZA==", "commit": {"author": {"name": "Fabien Ch\u00eane", "email": "fabien@gcc.gnu.org", "date": "2012-11-14T20:12:47Z"}, "committer": {"name": "Fabien Ch\u00eane", "email": "fabien@gcc.gnu.org", "date": "2012-11-14T20:12:47Z"}, "message": "re PR c++/11750 (class scope using-declaration lookup not implemented)\n\ngcc/testsuite/ChangeLog\n\n2012-11-14  Fabien Ch\u00eane  <fabien@gcc.gnu.org>\n\n\tPR c++/11750\n\t* g++.dg/inherit/vitual9.C: New.\n\ngcc/cp/ChangeLog\n\n2012-11-14  Fabien Ch\u00eane  <fabien@gcc.gnu.org>\n\n\tPR c++/11750\n\t* call.c (build_new_method_call_1): Check that the instance type\n\tand the function context are the same before setting the flag\n\tLOOKUP_NONVIRTUAL.\n\nFrom-SVN: r193504", "tree": {"sha": "a138a764fd88db8b06626eb9bfea1e90755b2ede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a138a764fd88db8b06626eb9bfea1e90755b2ede"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7628dc541e7092f0d58de9a3622ce242807cb47d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7628dc541e7092f0d58de9a3622ce242807cb47d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7628dc541e7092f0d58de9a3622ce242807cb47d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7628dc541e7092f0d58de9a3622ce242807cb47d/comments", "author": null, "committer": null, "parents": [{"sha": "ccd025e14c48690c37d0321be833a426df31dc16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd025e14c48690c37d0321be833a426df31dc16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccd025e14c48690c37d0321be833a426df31dc16"}], "stats": {"total": 68, "additions": 66, "deletions": 2}, "files": [{"sha": "fc5351815bbe9d2c3943e81b9a0d520c7639bfba", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7628dc541e7092f0d58de9a3622ce242807cb47d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7628dc541e7092f0d58de9a3622ce242807cb47d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7628dc541e7092f0d58de9a3622ce242807cb47d", "patch": "@@ -1,3 +1,10 @@\n+2012-11-14  Fabien Ch\u00eane  <fabien@gcc.gnu.org>\n+\n+\tPR c++/11750\n+\t* call.c (build_new_method_call_1): Check that the instance type\n+\tand the function context are the same before setting the flag\n+\tLOOKUP_NONVIRTUAL.\n+\n 2012-11-13  Sriraman Tallam  <tmsriram@google.com>\n \n \t* class.c (mark_versions_used): Remove."}, {"sha": "77bd28882d6ff3e46861ac90f53cd8efa0c5825b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7628dc541e7092f0d58de9a3622ce242807cb47d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7628dc541e7092f0d58de9a3622ce242807cb47d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=7628dc541e7092f0d58de9a3622ce242807cb47d", "patch": "@@ -7652,9 +7652,15 @@ build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,\n \t    }\n \t  else\n \t    {\n-\t      /* Optimize away vtable lookup if we know that this function\n-\t\t can't be overridden.  */\n+\t      /* Optimize away vtable lookup if we know that this\n+\t\t function can't be overridden.  We need to check if\n+\t\t the context and the instance type are the same,\n+\t\t actually FN might be defined in a different class\n+\t\t type because of a using-declaration. In this case, we\n+\t\t do not want to perform a non-virtual call.  */\n \t      if (DECL_VINDEX (fn) && ! (flags & LOOKUP_NONVIRTUAL)\n+\t\t  && same_type_ignoring_top_level_qualifiers_p\n+\t\t  (DECL_CONTEXT (fn), TREE_TYPE (instance))\n \t\t  && resolves_to_fixed_type_p (instance, 0))\n \t\tflags |= LOOKUP_NONVIRTUAL;\n               if (explicit_targs)"}, {"sha": "23424c50154eb304909ab78bc9e39a7075b50eda", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7628dc541e7092f0d58de9a3622ce242807cb47d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7628dc541e7092f0d58de9a3622ce242807cb47d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7628dc541e7092f0d58de9a3622ce242807cb47d", "patch": "@@ -1,3 +1,10 @@\n+2012-11-14  Fabien Ch\u00eane  <fabien@gcc.gnu.org>\n+\n+\tPR c++/11750\n+\t* call.c (build_new_method_call_1): Check that the instance type\n+\tand the function context are the same before setting the flag\n+\tLOOKUP_NONVIRTUAL.\n+\n 2012-11-13  Sriraman Tallam  <tmsriram@google.com>\n \n \t* testsuite/g++.dg/mv4.C: Add require ifunc. Change error message."}, {"sha": "03342646ff5ae0f82d2ff780dfad04bc3eb04472", "filename": "gcc/testsuite/g++.dg/inherit/virtual9.C", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7628dc541e7092f0d58de9a3622ce242807cb47d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fvirtual9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7628dc541e7092f0d58de9a3622ce242807cb47d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fvirtual9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fvirtual9.C?ref=7628dc541e7092f0d58de9a3622ce242807cb47d", "patch": "@@ -0,0 +1,44 @@\n+// { dg-do run }\n+// PR c++/11750\n+\n+struct A\n+{\n+  virtual void f() const { __builtin_abort(); }\n+  virtual void g() {}\n+};\n+\n+struct B : virtual A\n+{\n+  virtual void f() const {}\n+  virtual void g() { __builtin_abort(); }\n+};\n+\n+struct C : B, virtual A\n+{\n+  using A::f;\n+  using A::g;\n+};\n+\n+int main()\n+{\n+  C c;\n+  c.f(); // call B::f\n+\n+  C c2;\n+  c2.C::g(); // call A::g\n+\n+  C* c3 = &c;\n+  c3->f(); // call B::f\n+\n+  C& c4 = c;\n+  c4.f(); // call B::f\n+\n+  C const* c5 = &c;\n+  c5->f(); // call B::f\n+\n+  C** c6 = &c3;\n+  (*c6)->f(); // call B::f\n+\n+  C const& c7 = c;\n+  c7.f(); // call B::f\n+}"}]}