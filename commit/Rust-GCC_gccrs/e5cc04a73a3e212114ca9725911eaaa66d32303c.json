{"sha": "e5cc04a73a3e212114ca9725911eaaa66d32303c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVjYzA0YTczYTNlMjEyMTE0Y2E5NzI1OTExZWFhYTY2ZDMyMzAzYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-02-12T17:35:12Z"}, "committer": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2020-02-12T17:35:12Z"}, "message": "Clean up dead patterns, splitters, expanders and peepholes on the H8 port.\n\n\t* config/h8300/h8300.md (cpymemsi, movmd): Remove dead patterns,\n\texpanders, splits, etc.\n\t(movmd_internal_<mode>, movmd splitter, movstr, movsd): Likewise.\n\t(stpcpy_internal_<mode>, stpcpy splitter): Likewise.\n\t(peepholes to convert QI/HI mode pushes to SI mode pushes): Likewise.\n\t* config/h8300/h8300.c (h8300_swap_into_er6): Remove unused function.\n\t(h8300_swap_out_of_er6, h8sx_emit_movmd): Likewise\n\t* config/h8300/h8300-protos.h (h8300_swap_into_er6): Remove unused\n\tfunction prototype.\n\t(h8300_swap_out_of_er6, h8sx_emit_movmd): Likewise.", "tree": {"sha": "30c7d89cfa28d83321a4b95c9a7b76b3ee43c2e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30c7d89cfa28d83321a4b95c9a7b76b3ee43c2e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5cc04a73a3e212114ca9725911eaaa66d32303c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5cc04a73a3e212114ca9725911eaaa66d32303c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5cc04a73a3e212114ca9725911eaaa66d32303c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5cc04a73a3e212114ca9725911eaaa66d32303c/comments", "author": null, "committer": null, "parents": [{"sha": "54947e4db0a98a9190bab263e6ae539065ac52c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54947e4db0a98a9190bab263e6ae539065ac52c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54947e4db0a98a9190bab263e6ae539065ac52c5"}], "stats": {"total": 440, "additions": 13, "deletions": 427}, "files": [{"sha": "9ff0a943e4f87c4c2794cb2ba495df7463898146", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cc04a73a3e212114ca9725911eaaa66d32303c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cc04a73a3e212114ca9725911eaaa66d32303c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5cc04a73a3e212114ca9725911eaaa66d32303c", "patch": "@@ -1,3 +1,16 @@\n+2020-02-12  Jeff Law  <law@redhat.com>\n+\n+\t* config/h8300/h8300.md (cpymemsi, movmd): Remove dead patterns,\n+\texpanders, splits, etc.\n+\t(movmd_internal_<mode>, movmd splitter, movstr, movsd): Likewise.\n+\t(stpcpy_internal_<mode>, stpcpy splitter): Likewise.\n+\t(peepholes to convert QI/HI mode pushes to SI mode pushes): Likewise.\n+\t* config/h8300/h8300.c (h8300_swap_into_er6): Remove unused function.\n+\t(h8300_swap_out_of_er6, h8sx_emit_movmd): Likewise\n+\t* config/h8300/h8300-protos.h (h8300_swap_into_er6): Remove unused\n+\tfunction prototype.\n+\t(h8300_swap_out_of_er6, h8sx_emit_movmd): Likewise.\n+\n 2020-02-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/93670"}, {"sha": "2416741e76a4c4c4b77575f793b84b6f6243534c", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cc04a73a3e212114ca9725911eaaa66d32303c/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cc04a73a3e212114ca9725911eaaa66d32303c/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=e5cc04a73a3e212114ca9725911eaaa66d32303c", "patch": "@@ -109,9 +109,6 @@ extern unsigned int    h8300_insn_length_from_table (rtx_insn *, rtx *);\n extern const char *    output_h8sx_shift (rtx *, int, int);\n extern bool            h8300_operands_match_p (rtx *);\n extern bool            h8sx_mergeable_memrefs_p (rtx, rtx);\n-extern bool            h8sx_emit_movmd (rtx, rtx, rtx, HOST_WIDE_INT);\n-extern void            h8300_swap_into_er6 (rtx);\n-extern void            h8300_swap_out_of_er6 (rtx);\n extern poly_int64      h8300_push_rounding (poly_int64);\n \n #endif /* ! GCC_H8300_PROTOS_H */"}, {"sha": "d2fea04d8e49ade79e122b696ade2fe360401e11", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cc04a73a3e212114ca9725911eaaa66d32303c/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cc04a73a3e212114ca9725911eaaa66d32303c/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=e5cc04a73a3e212114ca9725911eaaa66d32303c", "patch": "@@ -2647,145 +2647,6 @@ h8300_operands_match_p (rtx *operands)\n   return false;\n }\n \f\n-/* Try using movmd to move LENGTH bytes from memory region SRC to memory\n-   region DEST.  The two regions do not overlap and have the common\n-   alignment given by ALIGNMENT.  Return true on success.\n-\n-   Using movmd for variable-length moves seems to involve some\n-   complex trade-offs.  For instance:\n-\n-      - Preparing for a movmd instruction is similar to preparing\n-\tfor a memcpy.  The main difference is that the arguments\n-\tare moved into er4, er5 and er6 rather than er0, er1 and er2.\n-\n-      - Since movmd clobbers the frame pointer, we need to save\n-\tand restore it somehow when frame_pointer_needed.  This can\n-\tsometimes make movmd sequences longer than calls to memcpy().\n-\n-      - The counter register is 16 bits, so the instruction is only\n-\tsuitable for variable-length moves when sizeof (size_t) == 2.\n-\tThat's only true in normal mode.\n-\n-      - We will often lack static alignment information.  Falling back\n-\ton movmd.b would likely be slower than calling memcpy(), at least\n-\tfor big moves.\n-\n-   This function therefore only uses movmd when the length is a\n-   known constant, and only then if -fomit-frame-pointer is in\n-   effect or if we're not optimizing for size.\n-\n-   At the moment the function uses movmd for all in-range constants,\n-   but it might be better to fall back on memcpy() for large moves\n-   if ALIGNMENT == 1.  */\n-\n-bool\n-h8sx_emit_movmd (rtx dest, rtx src, rtx length,\n-\t\t HOST_WIDE_INT alignment)\n-{\n-  if (!flag_omit_frame_pointer && optimize_size)\n-    return false;\n-\n-  if (GET_CODE (length) == CONST_INT)\n-    {\n-      rtx dest_reg, src_reg, first_dest, first_src;\n-      HOST_WIDE_INT n;\n-      int factor;\n-\n-      /* Use movmd.l if the alignment allows it, otherwise fall back\n-\t on movmd.b.  */\n-      factor = (alignment >= 2 ? 4 : 1);\n-\n-      /* Make sure the length is within range.  We can handle counter\n-\t values up to 65536, although HImode truncation will make\n-\t the count appear negative in rtl dumps.  */\n-      n = INTVAL (length);\n-      if (n <= 0 || n / factor > 65536)\n-\treturn false;\n-\n-      /* Create temporary registers for the source and destination\n-\t pointers.  Initialize them to the start of each region.  */\n-      dest_reg = copy_addr_to_reg (XEXP (dest, 0));\n-      src_reg = copy_addr_to_reg (XEXP (src, 0));\n-\n-      /* Create references to the movmd source and destination blocks.  */\n-      first_dest = replace_equiv_address (dest, dest_reg);\n-      first_src = replace_equiv_address (src, src_reg);\n-\n-      set_mem_size (first_dest, n & -factor);\n-      set_mem_size (first_src, n & -factor);\n-\n-      length = copy_to_mode_reg (HImode, gen_int_mode (n / factor, HImode));\n-      emit_insn (gen_movmd (first_dest, first_src, length, GEN_INT (factor)));\n-\n-      if ((n & -factor) != n)\n-\t{\n-\t  /* Move SRC and DEST past the region we just copied.\n-\t     This is done to update the memory attributes.  */\n-\t  dest = adjust_address (dest, BLKmode, n & -factor);\n-\t  src = adjust_address (src, BLKmode, n & -factor);\n-\n-\t  /* Replace the addresses with the source and destination\n-\t     registers, which movmd has left with the right values.  */\n-\t  dest = replace_equiv_address (dest, dest_reg);\n-\t  src = replace_equiv_address (src, src_reg);\n-\n-\t  /* Mop up the left-over bytes.  */\n-\t  if (n & 2)\n-\t    emit_move_insn (adjust_address (dest, HImode, 0),\n-\t\t\t    adjust_address (src, HImode, 0));\n-\t  if (n & 1)\n-\t    emit_move_insn (adjust_address (dest, QImode, n & 2),\n-\t\t\t    adjust_address (src, QImode, n & 2));\n-\t}\n-      return true;\n-    }\n-  return false;\n-}\n-\n-/* Move ADDR into er6 after pushing its old value onto the stack.  */\n-\n-void\n-h8300_swap_into_er6 (rtx addr)\n-{\n-  rtx insn = push (HARD_FRAME_POINTER_REGNUM, false);\n-  if (frame_pointer_needed)\n-    add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t  plus_constant (Pmode, gen_rtx_MEM (Pmode, stack_pointer_rtx),\n-\t\t\t\t 2 * UNITS_PER_WORD));\n-  else\n-    add_reg_note (insn, REG_CFA_ADJUST_CFA,\n-\t\t  gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t       plus_constant (Pmode, stack_pointer_rtx, 4)));\n-\n-  emit_move_insn (hard_frame_pointer_rtx, addr);\n-  if (REGNO (addr) == SP_REG)\n-    emit_move_insn (hard_frame_pointer_rtx,\n-\t\t    plus_constant (Pmode, hard_frame_pointer_rtx,\n-\t\t\t\t   GET_MODE_SIZE (word_mode)));\n-}\n-\n-/* Move the current value of er6 into ADDR and pop its old value\n-   from the stack.  */\n-\n-void\n-h8300_swap_out_of_er6 (rtx addr)\n-{\n-  rtx insn;\n-\n-  if (REGNO (addr) != SP_REG)\n-    emit_move_insn (addr, hard_frame_pointer_rtx);\n-\n-  insn = pop (HARD_FRAME_POINTER_REGNUM);\n-  if (frame_pointer_needed)\n-    add_reg_note (insn, REG_CFA_DEF_CFA,\n-\t\t  plus_constant (Pmode, hard_frame_pointer_rtx,\n-\t\t\t\t 2 * UNITS_PER_WORD));\n-  else\n-    add_reg_note (insn, REG_CFA_ADJUST_CFA,\n-\t\t  gen_rtx_SET (stack_pointer_rtx,\n-\t\t\t       plus_constant (Pmode, stack_pointer_rtx, -4)));\n-}\n-\f\n /* Return the length of mov instruction.  */\n \n unsigned int"}, {"sha": "0548368215b0f7843c6f8bc652f87065760421f3", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 0, "deletions": 285, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5cc04a73a3e212114ca9725911eaaa66d32303c/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5cc04a73a3e212114ca9725911eaaa66d32303c/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=e5cc04a73a3e212114ca9725911eaaa66d32303c", "patch": "@@ -474,174 +474,6 @@\n    (set_attr \"length_table\" \"*,movl\")\n    (set_attr \"cc\" \"set_zn,set_znv\")])\n \n-;; Implement block copies using movmd.  Defining cpymemsi allows the full\n-;; range of constant lengths (up to 0x40000 bytes when using movmd.l).\n-;; See h8sx_emit_movmd for details.\n-\n-(define_expand \"cpymemsi\"\n-  [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n-   (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n-   (use (match_operand:SI 2 \"\" \"\"))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"TARGET_H8300SX && 0\"\n-  {\n-    if (h8sx_emit_movmd (operands[0], operands[1], operands[2], INTVAL (operands[3])))\n-      DONE;\n-    else\n-      FAIL;\n-  })\n-\n-;; Expander for generating movmd insns.  Operand 0 is the destination\n-;; memory region, operand 1 is the source, operand 2 is the counter\n-;; register and operand 3 is the chunk size (1, 2 or 4).\n-\n-(define_expand \"movmd\"\n-  [(parallel\n-    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-\t  (match_operand:BLK 1 \"memory_operand\" \"\"))\n-     (unspec [(match_operand:HI 2 \"register_operand\" \"\")\n-\t      (match_operand:HI 3 \"const_int_operand\" \"\")] UNSPEC_MOVMD)\n-     (clobber (match_dup 4))\n-     (clobber (match_dup 5))\n-     (set (match_dup 2)\n-\t  (const_int 0))])]\n-  \"TARGET_H8300SX && 0\"\n-  {\n-    operands[4] = copy_rtx (XEXP (operands[0], 0));\n-    operands[5] = copy_rtx (XEXP (operands[1], 0));\n-  })\n-\n-;; This is a difficult instruction to reload since operand 0 must be the\n-;; frame pointer.  See h8300_reg_class_from_letter for an explanation.\n-\n-(define_insn \"movmd_internal_<mode>\"\n-  [(set (mem:BLK (match_operand:P 3 \"register_operand\" \"0,r\"))\n-\t(mem:BLK (match_operand:P 4 \"register_operand\" \"1,1\")))\n-   (unspec [(match_operand:HI 5 \"register_operand\" \"2,2\")\n-\t    (match_operand:HI 6 \"const_int_operand\" \"n,n\")] UNSPEC_MOVMD)\n-   (clobber (match_operand:P 0 \"register_operand\" \"=d,??D\"))\n-   (clobber (match_operand:P 1 \"register_operand\" \"=f,f\"))\n-   (set (match_operand:HI 2 \"register_operand\" \"=c,c\")\n-\t(const_int 0))]\n-  \"TARGET_H8300SX && 0\"\n-  \"@\n-    movmd%m6\n-    #\"\n-  [(set_attr \"length\" \"2,14\")\n-   (set_attr \"can_delay\" \"no\")\n-   (set_attr \"cc\" \"none,clobber\")])\n-\n-;; Split the above instruction if the destination register isn't er6.\n-;; We need a sequence like:\n-;;\n-;;\tmov.l\ter6,@-er7\n-;;\tmov.l\t<dest>,er6\n-;;\tmovmd.sz\n-;;\tmov.l\ter6,<dest>\n-;;\tmov.l\t@er7+,er6\n-;;\n-;; where <dest> is the current destination register (operand 4).\n-;; The fourth instruction will be deleted if <dest> dies here.\n-\n-(define_split\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-\t(match_operand:BLK 1 \"memory_operand\" \"\"))\n-   (unspec [(match_operand:HI 2 \"register_operand\" \"\")\n-\t    (match_operand:HI 3 \"const_int_operand\" \"\")] UNSPEC_MOVMD)\n-   (clobber (match_operand:P 4 \"register_operand\" \"\"))\n-   (clobber (match_operand:P 5 \"register_operand\" \"\"))\n-   (set (match_dup 2)\n-\t(const_int 0))]\n-  \"TARGET_H8300SX && reload_completed\n-   && 0\n-   && REGNO (operands[4]) != DESTINATION_REG\"\n-  [(const_int 0)]\n-  {\n-    rtx dest;\n-\n-    h8300_swap_into_er6 (XEXP (operands[0], 0));\n-    dest = replace_equiv_address (operands[0], hard_frame_pointer_rtx);\n-    emit_insn (gen_movmd (dest, operands[1], operands[2], operands[3]));\n-    h8300_swap_out_of_er6 (operands[4]);\n-    DONE;\n-  })\n-\n-;; Expand a call to stpcpy() using movsd.  Operand 0 should point to\n-;; the final character, but movsd leaves it pointing to the character\n-;; after that.\n-\n-(define_expand \"movstr\"\n-  [(use (match_operand 0 \"register_operand\" \"\"))\n-   (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n-   (use (match_operand:BLK 2 \"memory_operand\" \"\"))]\n-  \"TARGET_H8300SX && 0\"\n-  {\n-    operands[1] = replace_equiv_address\n-      (operands[1], copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n-    operands[2] = replace_equiv_address\n-      (operands[2], copy_to_mode_reg (Pmode, XEXP (operands[2], 0)));\n-    emit_insn (gen_movsd (operands[1], operands[2], gen_reg_rtx (Pmode)));\n-    emit_insn (gen_add3_insn (operands[0], XEXP (operands[1], 0), constm1_rtx));\n-    DONE;\n-  })\n-\n-;; Expander for generating a movsd instruction.  Operand 0 is the\n-;; destination string, operand 1 is the source string and operand 2\n-;; is a scratch register.\n-\n-(define_expand \"movsd\"\n-  [(parallel\n-    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-\t  (unspec:BLK [(match_operand:BLK 1 \"memory_operand\" \"\")]\n-\t  UNSPEC_STPCPY))\n-     (clobber (match_dup 3))\n-     (clobber (match_dup 4))\n-     (clobber (match_operand 2 \"register_operand\" \"\"))])]\n-  \"TARGET_H8300SX && 0\"\n-  {\n-    operands[3] = copy_rtx (XEXP (operands[0], 0));\n-    operands[4] = copy_rtx (XEXP (operands[1], 0));\n-  })\n-\n-;; See comments above memcpy_internal().\n-\n-(define_insn \"stpcpy_internal_<mode>\"\n-  [(set (mem:BLK (match_operand:P 3 \"register_operand\" \"0,r\"))\n-\t(unspec:BLK [(mem:BLK (match_operand:P 4 \"register_operand\" \"1,1\"))]\n-\tUNSPEC_STPCPY))\n-   (clobber (match_operand:P 0 \"register_operand\" \"=d,??D\"))\n-   (clobber (match_operand:P 1 \"register_operand\" \"=f,f\"))\n-   (clobber (match_operand:P 2 \"register_operand\" \"=c,c\"))]\n-  \"TARGET_H8300SX && 0\"\n-  \"@\n-    \\n1:\\tmovsd\\t2f\\;bra\\t1b\\n2:\n-    #\"\n-  [(set_attr \"length\" \"6,18\")\n-   (set_attr \"cc\" \"none,clobber\")])\n-\n-;; Split the above instruction if the destination isn't er6.  This works\n-;; in the same way as the movmd splitter.\n-\n-(define_split\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n-\t(unspec:BLK [(match_operand:BLK 1 \"memory_operand\" \"\")] UNSPEC_STPCPY))\n-   (clobber (match_operand:P 2 \"register_operand\" \"\"))\n-   (clobber (match_operand:P 3 \"register_operand\" \"\"))\n-   (clobber (match_operand:P 4 \"register_operand\" \"\"))]\n-  \"TARGET_H8300SX &&  reload_completed\n-   && 0\n-   && REGNO (operands[2]) != DESTINATION_REG\"\n-  [(const_int 0)]\n-  {\n-    rtx dest;\n-\n-    h8300_swap_into_er6 (XEXP (operands[0], 0));\n-    dest = replace_equiv_address (operands[0], hard_frame_pointer_rtx);\n-    emit_insn (gen_movsd (dest, operands[1], operands[4]));\n-    h8300_swap_out_of_er6 (operands[2]);\n-    DONE;\n-  })\n-\n (include \"mova.md\")\n \n (define_insn \"*movsf_h8300\"\n@@ -4248,60 +4080,6 @@\n \t      (clobber (match_dup 2))])]\n   \"\")\n \n-;; Convert a QImode push into an SImode push so that the\n-;; define_peephole2 below can cram multiple pushes into one stm.l.\n-\n-(define_peephole2\n-  [(parallel [(set (reg:SI SP_REG)\n-                   (plus:SI (reg:SI SP_REG) (const_int -4)))\n-              (set (mem:QI (plus:SI (reg:SI SP_REG) (const_int -3)))\n-                   (match_operand:QI 0 \"register_operand\" \"\"))])]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_dup 0))]\n-  {\n-    operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n-  })\n-\n-(define_peephole2\n-  [(parallel [(set (reg:HI SP_REG)\n-                   (plus:HI (reg:HI SP_REG) (const_int -4)))\n-              (set (mem:QI (plus:HI (reg:HI SP_REG) (const_int -3)))\n-                   (match_operand:QI 0 \"register_operand\" \"\"))])]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_dup 0))]\n-  {\n-    operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n-  })\n-\n-;; Convert a HImode push into an SImode push so that the\n-;; define_peephole2 below can cram multiple pushes into one stm.l.\n-\n-(define_peephole2\n-  [(parallel [(set (reg:SI SP_REG)\n-                   (plus:SI (reg:SI SP_REG) (const_int -4)))\n-              (set (mem:HI (plus:SI (reg:SI SP_REG) (const_int -2)))\n-                   (match_operand:HI 0 \"register_operand\" \"\"))])]\n-  \"TARGET_H8300S && !TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))\n-\t(match_dup 0))]\n-  {\n-    operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n-  })\n-\n-(define_peephole2\n-  [(parallel [(set (reg:HI SP_REG)\n-                   (plus:HI (reg:HI SP_REG) (const_int -4)))\n-              (set (mem:HI (plus:HI (reg:HI SP_REG) (const_int -2)))\n-                   (match_operand:HI 0 \"register_operand\" \"\"))])]\n-  \"TARGET_H8300S && TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG\"\n-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))\n-\t(match_dup 0))]\n-  {\n-    operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]));\n-  })\n-\n ;; Cram four pushes into stm.l.\n \n (define_peephole2\n@@ -5745,69 +5523,6 @@\n \t(match_dup 0))]\n   \"\")\n \n-;; Transform\n-;;\n-;;\tmov\tdst,reg\n-;;\top\tsrc,reg\n-;;\tmov\treg,dst\n-;;\n-;; into\n-;;\n-;;\top\tsrc,dst\n-;;\n-;; if \"reg\" dies at the end of the sequence.\n-\n-(define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(match_operand 1 \"memory_operand\" \"\"))\n-   (set (match_dup 0)\n-\t(match_operator 2 \"h8sx_binary_memory_operator\"\n-\t [(match_dup 0)\n-\t  (match_operand 3 \"h8300_src_operand\" \"\")]))\n-   (set (match_operand 4 \"memory_operand\" \"\")\n-\t(match_dup 0))]\n-  \"0 /* Disable because it breaks compiling fp-bit.c.  */\n-   && TARGET_H8300SX\n-   && peep2_reg_dead_p (3, operands[0])\n-   && !reg_overlap_mentioned_p (operands[0], operands[3])\n-   && !reg_overlap_mentioned_p (operands[0], operands[4])\n-   && h8sx_mergeable_memrefs_p (operands[4], operands[1])\"\n-  [(set (match_dup 4)\n-\t(match_dup 5))]\n-  {\n-    operands[5] = shallow_copy_rtx (operands[2]);\n-    XEXP (operands[5], 0) = operands[1];\n-  })\n-\n-;; Transform\n-;;\n-;;\tmov\tsrc,reg\n-;;\top\treg,dst\n-;;\n-;; into\n-;;\n-;;\top\tsrc,dst\n-;;\n-;; if \"reg\" dies in the second insn.\n-\n-(define_peephole2\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(match_operand 1 \"h8300_src_operand\" \"\"))\n-   (set (match_operand 2 \"h8300_dst_operand\" \"\")\n-\t(match_operator 3 \"h8sx_binary_memory_operator\"\n-\t [(match_operand 4 \"h8300_dst_operand\" \"\")\n-\t  (match_dup 0)]))]\n-  \"0 /* Disable because it breaks compiling fp-bit.c.  */\n-   && TARGET_H8300SX\n-   && peep2_reg_dead_p (2, operands[0])\n-   && !reg_overlap_mentioned_p (operands[0], operands[4])\"\n-  [(set (match_dup 2)\n-\t(match_dup 5))]\n-  {\n-    operands[5] = shallow_copy_rtx (operands[3]);\n-    XEXP (operands[5], 1) = operands[1];\n-  })\n-\n ;; Transform\n ;;\n ;;\tmov\tdst,reg"}]}