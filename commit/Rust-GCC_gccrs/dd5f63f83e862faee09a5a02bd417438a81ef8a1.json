{"sha": "dd5f63f83e862faee09a5a02bd417438a81ef8a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ1ZjYzZjgzZTg2MmZhZWUwOWE1YTAyYmQ0MTc0MzhhODFlZjhhMQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2006-11-15T14:29:10Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2006-11-15T14:29:10Z"}, "message": "tree-flow.h (multiplier_allowed_in_address_p): Adjust prototype.\n\n\t* tree-flow.h (multiplier_allowed_in_address_p): Adjust prototype.\n\t* tree-ssa-loop-ivopts.c (multiplier_allowed_in_address_p): New\n\targ MODE; all callers changed.  Use it to determine validity per\n\tmachine mode instead of using Pmode for all memory references.\n\t(get_address_cost): Likewise add and use new arg MEM_MODE.\n\nFrom-SVN: r118856", "tree": {"sha": "016447456ff77c72488cc81bf2d117b7bcf6d8af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/016447456ff77c72488cc81bf2d117b7bcf6d8af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd5f63f83e862faee09a5a02bd417438a81ef8a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5f63f83e862faee09a5a02bd417438a81ef8a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd5f63f83e862faee09a5a02bd417438a81ef8a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5f63f83e862faee09a5a02bd417438a81ef8a1/comments", "author": null, "committer": null, "parents": [{"sha": "c78ba53a65fdd2586b93937e6a757e652149e37f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c78ba53a65fdd2586b93937e6a757e652149e37f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c78ba53a65fdd2586b93937e6a757e652149e37f"}], "stats": {"total": 102, "additions": 60, "deletions": 42}, "files": [{"sha": "67a5d8008940c94ec1483a1072dfddeb17acd6da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5f63f83e862faee09a5a02bd417438a81ef8a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5f63f83e862faee09a5a02bd417438a81ef8a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd5f63f83e862faee09a5a02bd417438a81ef8a1", "patch": "@@ -1,3 +1,11 @@\n+2006-11-15  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* tree-flow.h (multiplier_allowed_in_address_p): Adjust prototype.\n+\t* tree-ssa-loop-ivopts.c (multiplier_allowed_in_address_p): New\n+\targ MODE; all callers changed.  Use it to determine validity per\n+\tmachine mode instead of using Pmode for all memory references.\n+\t(get_address_cost): Likewise add and use new arg MEM_MODE.\n+\n 2006-11-15  Rask Ingemann Lambertsen <rask@sygehus.dk>\n \t    J\"orn Rennecke <joern.rennecke@st.com>\n "}, {"sha": "64926306ba9a0f59a9ff5d81eb87797e26c4749d", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5f63f83e862faee09a5a02bd417438a81ef8a1/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5f63f83e862faee09a5a02bd417438a81ef8a1/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=dd5f63f83e862faee09a5a02bd417438a81ef8a1", "patch": "@@ -949,7 +949,7 @@ extern void linear_transform_loops (struct loops *);\n \n /* In tree-ssa-loop-ivopts.c  */\n bool expr_invariant_in_loop_p (struct loop *, tree);\n-bool multiplier_allowed_in_address_p (HOST_WIDE_INT);\n+bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode);\n unsigned multiply_by_cost (HOST_WIDE_INT, enum machine_mode);\n \n /* In tree-ssa-threadupdate.c.  */"}, {"sha": "c3394498964984725b6b1cf97a84d2dadeec4d01", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5f63f83e862faee09a5a02bd417438a81ef8a1/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5f63f83e862faee09a5a02bd417438a81ef8a1/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=dd5f63f83e862faee09a5a02bd417438a81ef8a1", "patch": "@@ -397,8 +397,9 @@ most_expensive_mult_to_index (struct mem_address *parts, tree type,\n \n   for (i = 0; i < addr->n; i++)\n     {\n+      /* FIXME: Should use the correct memory mode rather than Pmode.  */\n       if (addr->coefs[i] == 1\n-\t  || !multiplier_allowed_in_address_p (addr->coefs[i]))\n+\t  || !multiplier_allowed_in_address_p (addr->coefs[i], Pmode))\n \tcontinue;\n       \n       acost = multiply_by_cost (addr->coefs[i], Pmode);"}, {"sha": "b20c309a707d50d19c1344c9d48b1f3d08af7560", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5f63f83e862faee09a5a02bd417438a81ef8a1/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5f63f83e862faee09a5a02bd417438a81ef8a1/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=dd5f63f83e862faee09a5a02bd417438a81ef8a1", "patch": "@@ -3321,32 +3321,32 @@ multiply_by_cost (HOST_WIDE_INT cst, enum machine_mode mode)\n /* Returns true if multiplying by RATIO is allowed in address.  */\n \n bool\n-multiplier_allowed_in_address_p (HOST_WIDE_INT ratio)\n+multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode)\n {\n #define MAX_RATIO 128\n-  static sbitmap valid_mult;\n+  static sbitmap valid_mult[MAX_MACHINE_MODE];\n   \n-  if (!valid_mult)\n+  if (!valid_mult[mode])\n     {\n       rtx reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n       rtx addr;\n       HOST_WIDE_INT i;\n \n-      valid_mult = sbitmap_alloc (2 * MAX_RATIO + 1);\n-      sbitmap_zero (valid_mult);\n+      valid_mult[mode] = sbitmap_alloc (2 * MAX_RATIO + 1);\n+      sbitmap_zero (valid_mult[mode]);\n       addr = gen_rtx_fmt_ee (MULT, Pmode, reg1, NULL_RTX);\n       for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (i, Pmode);\n-\t  if (memory_address_p (Pmode, addr))\n-\t    SET_BIT (valid_mult, i + MAX_RATIO);\n+\t  if (memory_address_p (mode, addr))\n+\t    SET_BIT (valid_mult[mode], i + MAX_RATIO);\n \t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"  allowed multipliers:\");\n \t  for (i = -MAX_RATIO; i <= MAX_RATIO; i++)\n-\t    if (TEST_BIT (valid_mult, i + MAX_RATIO))\n+\t    if (TEST_BIT (valid_mult[mode], i + MAX_RATIO))\n \t      fprintf (dump_file, \" %d\", (int) i);\n \t  fprintf (dump_file, \"\\n\");\n \t  fprintf (dump_file, \"\\n\");\n@@ -3356,7 +3356,7 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio)\n   if (ratio > MAX_RATIO || ratio < -MAX_RATIO)\n     return false;\n \n-  return TEST_BIT (valid_mult, ratio + MAX_RATIO);\n+  return TEST_BIT (valid_mult[mode], ratio + MAX_RATIO);\n }\n \n /* Returns cost of address in shape symbol + var + OFFSET + RATIO * index.\n@@ -3367,60 +3367,65 @@ multiplier_allowed_in_address_p (HOST_WIDE_INT ratio)\n \n static unsigned\n get_address_cost (bool symbol_present, bool var_present,\n-\t\t  unsigned HOST_WIDE_INT offset, HOST_WIDE_INT ratio)\n+\t\t  unsigned HOST_WIDE_INT offset, HOST_WIDE_INT ratio,\n+\t\t  enum machine_mode mem_mode)\n {\n-  static bool initialized = false;\n-  static HOST_WIDE_INT rat, off;\n-  static HOST_WIDE_INT min_offset, max_offset;\n-  static unsigned costs[2][2][2][2];\n+  static bool initialized[MAX_MACHINE_MODE];\n+  static HOST_WIDE_INT rat[MAX_MACHINE_MODE], off[MAX_MACHINE_MODE];\n+  static HOST_WIDE_INT min_offset[MAX_MACHINE_MODE], max_offset[MAX_MACHINE_MODE];\n+  static unsigned costs[MAX_MACHINE_MODE][2][2][2][2];\n   unsigned cost, acost;\n   bool offset_p, ratio_p;\n   HOST_WIDE_INT s_offset;\n   unsigned HOST_WIDE_INT mask;\n   unsigned bits;\n \n-  if (!initialized)\n+  if (!initialized[mem_mode])\n     {\n       HOST_WIDE_INT i;\n       int old_cse_not_expected;\n       unsigned sym_p, var_p, off_p, rat_p, add_c;\n       rtx seq, addr, base;\n       rtx reg0, reg1;\n \n-      initialized = true;\n+      initialized[mem_mode] = true;\n \n       reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n \n       addr = gen_rtx_fmt_ee (PLUS, Pmode, reg1, NULL_RTX);\n       for (i = 1; i <= 1 << 20; i <<= 1)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (i, Pmode);\n-\t  if (!memory_address_p (Pmode, addr))\n+\t  if (!memory_address_p (mem_mode, addr))\n \t    break;\n \t}\n-      max_offset = i >> 1;\n-      off = max_offset;\n+      max_offset[mem_mode] = i >> 1;\n+      off[mem_mode] = max_offset[mem_mode];\n \n       for (i = 1; i <= 1 << 20; i <<= 1)\n \t{\n \t  XEXP (addr, 1) = gen_int_mode (-i, Pmode);\n-\t  if (!memory_address_p (Pmode, addr))\n+\t  if (!memory_address_p (mem_mode, addr))\n \t    break;\n \t}\n-      min_offset = -(i >> 1);\n+      min_offset[mem_mode] = -(i >> 1);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"get_address_cost:\\n\");\n-\t  fprintf (dump_file, \"  min offset %d\\n\", (int) min_offset);\n-\t  fprintf (dump_file, \"  max offset %d\\n\", (int) max_offset);\n+\t  fprintf (dump_file, \"  min offset %s %d\\n\",\n+\t\t   GET_MODE_NAME (mem_mode),\n+\t\t   (int) min_offset[mem_mode]);\n+\t  fprintf (dump_file, \"  max offset %s %d\\n\",\n+\t\t   GET_MODE_NAME (mem_mode),\n+\t\t   (int) max_offset[mem_mode]);\n \t}\n \n-      rat = 1;\n+      rat[mem_mode] = 1;\n       for (i = 2; i <= MAX_RATIO; i++)\n-\tif (multiplier_allowed_in_address_p (i))\n+\tif (multiplier_allowed_in_address_p (i, mem_mode))\n \t  {\n-\t    rat = i;\n+\t    rat[mem_mode] = i;\n \t    break;\n \t  }\n \n@@ -3438,7 +3443,8 @@ get_address_cost (bool symbol_present, bool var_present,\n \n \t  addr = reg0;\n \t  if (rat_p)\n-\t    addr = gen_rtx_fmt_ee (MULT, Pmode, addr, gen_int_mode (rat, Pmode));\n+\t    addr = gen_rtx_fmt_ee (MULT, Pmode, addr,\n+\t\t\t\t   gen_int_mode (rat[mem_mode], Pmode));\n \n \t  if (var_p)\n \t    addr = gen_rtx_fmt_ee (PLUS, Pmode, addr, reg1);\n@@ -3450,10 +3456,11 @@ get_address_cost (bool symbol_present, bool var_present,\n \t\tbase = gen_rtx_fmt_e (CONST, Pmode,\n \t\t\t\t      gen_rtx_fmt_ee (PLUS, Pmode,\n \t\t\t\t\t\t      base,\n-\t\t\t\t\t\t      gen_int_mode (off, Pmode)));\n+\t\t\t\t\t\t      gen_int_mode (off[mem_mode],\n+\t\t\t\t\t\t\t\t    Pmode)));\n \t    }\n \t  else if (off_p)\n-\t    base = gen_int_mode (off, Pmode);\n+\t    base = gen_int_mode (off[mem_mode], Pmode);\n \t  else\n \t    base = NULL_RTX;\n     \n@@ -3465,17 +3472,17 @@ get_address_cost (bool symbol_present, bool var_present,\n \t     follow.  */\n \t  old_cse_not_expected = cse_not_expected;\n \t  cse_not_expected = true;\n-\t  addr = memory_address (Pmode, addr);\n+\t  addr = memory_address (mem_mode, addr);\n \t  cse_not_expected = old_cse_not_expected;\n \t  seq = get_insns ();\n \t  end_sequence ();\n \n \t  acost = seq_cost (seq);\n-\t  acost += address_cost (addr, Pmode);\n+\t  acost += address_cost (addr, mem_mode);\n \n \t  if (!acost)\n \t    acost = 1;\n-\t  costs[sym_p][var_p][off_p][rat_p] = acost;\n+\t  costs[mem_mode][sym_p][var_p][off_p][rat_p] = acost;\n \t}\n \n       /* On some targets, it is quite expensive to load symbol to a register,\n@@ -3497,12 +3504,12 @@ get_address_cost (bool symbol_present, bool var_present,\n \t  off_p = (i >> 1) & 1;\n \t  rat_p = (i >> 2) & 1;\n \n-\t  acost = costs[0][1][off_p][rat_p] + 1;\n+\t  acost = costs[mem_mode][0][1][off_p][rat_p] + 1;\n \t  if (var_p)\n \t    acost += add_c;\n \n-\t  if (acost < costs[1][var_p][off_p][rat_p])\n-\t    costs[1][var_p][off_p][rat_p] = acost;\n+\t  if (acost < costs[mem_mode][1][var_p][off_p][rat_p])\n+\t    costs[mem_mode][1][var_p][off_p][rat_p] = acost;\n \t}\n   \n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3526,7 +3533,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t      if (rat_p)\n \t\tfprintf (dump_file, \"rat * \");\n \n-\t      acost = costs[sym_p][var_p][off_p][rat_p];\n+\t      acost = costs[mem_mode][sym_p][var_p][off_p][rat_p];\n \t      fprintf (dump_file, \"index costs %d\\n\", acost);\n \t    }\n \t  fprintf (dump_file, \"\\n\");\n@@ -3542,9 +3549,10 @@ get_address_cost (bool symbol_present, bool var_present,\n \n   cost = 0;\n   offset_p = (s_offset != 0\n-\t      && min_offset <= s_offset && s_offset <= max_offset);\n+\t      && min_offset[mem_mode] <= s_offset\n+\t      && s_offset <= max_offset[mem_mode]);\n   ratio_p = (ratio != 1\n-\t     && multiplier_allowed_in_address_p (ratio));\n+\t     && multiplier_allowed_in_address_p (ratio, mem_mode));\n \n   if (ratio != 1 && !ratio_p)\n     cost += multiply_by_cost (ratio, Pmode);\n@@ -3555,7 +3563,7 @@ get_address_cost (bool symbol_present, bool var_present,\n       var_present = true;\n     }\n \n-  acost = costs[symbol_present][var_present][offset_p][ratio_p];\n+  acost = costs[mem_mode][symbol_present][var_present][offset_p][ratio_p];\n   return cost + acost;\n }\n \n@@ -3963,7 +3971,8 @@ get_computation_cost_at (struct ivopts_data *data,\n      (symbol/var/const parts may be omitted).  If we are looking for an address,\n      find the cost of addressing this.  */\n   if (address_p)\n-    return cost + get_address_cost (symbol_present, var_present, offset, ratio);\n+    return cost + get_address_cost (symbol_present, var_present, offset, ratio,\n+\t\t\t\t    TYPE_MODE (TREE_TYPE (*use->op_p)));\n \n   /* Otherwise estimate the costs for computing the expression.  */\n   aratio = ratio > 0 ? ratio : -ratio;"}]}