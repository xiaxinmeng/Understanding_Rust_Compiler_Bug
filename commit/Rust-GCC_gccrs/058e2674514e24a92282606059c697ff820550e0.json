{"sha": "058e2674514e24a92282606059c697ff820550e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU4ZTI2NzQ1MTRlMjRhOTIyODI2MDYwNTljNjk3ZmY4MjA1NTBlMA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "ulrich.weigand@linaro.org", "date": "2012-09-17T17:08:14Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2012-09-17T17:08:14Z"}, "message": "arm.c (arm_rtx_costs_1): Handle vec_extract and vec_set patterns.\n\n2012-09-17  Ulrich Weigand  <ulrich.weigand@linaro.org>\n\n\t* config/arm/arm.c (arm_rtx_costs_1): Handle vec_extract and vec_set\n\tpatterns.\n\t* config/arm/arm.md (\"vec_set<mode>_internal\"): Support memory source\n\toperands, implemented via vld1 instruction.\n\t(\"vec_extract<mode>\"): Support memory destination operands, implemented\n\tvia vst1 instruction.\n\t(\"neon_vst1_lane<mode>\"): Use UNSPEC_VST1_LANE instead of vec_select.\n\t* config/arm/predicates.md (\"neon_lane_number\"): Remove.\n\nFrom-SVN: r191400", "tree": {"sha": "67e730e37a26483acdca94f188106d2957246c6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67e730e37a26483acdca94f188106d2957246c6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/058e2674514e24a92282606059c697ff820550e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058e2674514e24a92282606059c697ff820550e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058e2674514e24a92282606059c697ff820550e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058e2674514e24a92282606059c697ff820550e0/comments", "author": null, "committer": null, "parents": [{"sha": "a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e7bf8fc3b4bcfe57bd0bb5b2260dd678e9b063"}], "stats": {"total": 138, "additions": 94, "deletions": 44}, "files": [{"sha": "bc8257c052b66fe4baba8dea987d8cee288630d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058e2674514e24a92282606059c697ff820550e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058e2674514e24a92282606059c697ff820550e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=058e2674514e24a92282606059c697ff820550e0", "patch": "@@ -1,3 +1,14 @@\n+2012-09-17  Ulrich Weigand  <ulrich.weigand@linaro.org>\n+\n+\t* config/arm/arm.c (arm_rtx_costs_1): Handle vec_extract and vec_set\n+\tpatterns.\n+\t* config/arm/arm.md (\"vec_set<mode>_internal\"): Support memory source\n+\toperands, implemented via vld1 instruction.\n+\t(\"vec_extract<mode>\"): Support memory destination operands, implemented\n+\tvia vst1 instruction.\n+\t(\"neon_vst1_lane<mode>\"): Use UNSPEC_VST1_LANE instead of vec_select.\n+\t* config/arm/predicates.md (\"neon_lane_number\"): Remove.\n+\n 2012-09-17  Ramana Radhakrishnan  <ramana.radhakrishnan@linaro.org>\n \t    Ulrich Weigand  <ulrich.weigand@linaro.org>\n "}, {"sha": "1031b68586378db9f2774f1a6e726ffff4223578", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058e2674514e24a92282606059c697ff820550e0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058e2674514e24a92282606059c697ff820550e0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=058e2674514e24a92282606059c697ff820550e0", "patch": "@@ -7666,6 +7666,28 @@ arm_rtx_costs_1 (rtx x, enum rtx_code outer, int* total, bool speed)\n       return true;\n \n     case SET:\n+      /* The vec_extract patterns accept memory operands that require an\n+\t address reload.  Account for the cost of that reload to give the\n+\t auto-inc-dec pass an incentive to try to replace them.  */\n+      if (TARGET_NEON && MEM_P (SET_DEST (x))\n+\t  && GET_CODE (SET_SRC (x)) == VEC_SELECT)\n+\t{\n+\t  *total = rtx_cost (SET_DEST (x), code, 0, speed);\n+\t  if (!neon_vector_mem_operand (SET_DEST (x), 2))\n+\t    *total += COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n+      /* Likewise for the vec_set patterns.  */\n+      if (TARGET_NEON && GET_CODE (SET_SRC (x)) == VEC_MERGE\n+\t  && GET_CODE (XEXP (SET_SRC (x), 0)) == VEC_DUPLICATE\n+\t  && MEM_P (XEXP (XEXP (SET_SRC (x), 0), 0)))\n+\t{\n+\t  rtx mem = XEXP (XEXP (SET_SRC (x), 0), 0);\n+\t  *total = rtx_cost (mem, code, 0, speed);\n+\t  if (!neon_vector_mem_operand (mem, 2))\n+\t    *total += COSTS_N_INSNS (1);\n+\t  return true;\n+\t}\n       return false;\n \n     case UNSPEC:"}, {"sha": "b89d5383a9305c3aba7914532e23b204ed390ffb", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058e2674514e24a92282606059c697ff820550e0/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058e2674514e24a92282606059c697ff820550e0/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=058e2674514e24a92282606059c697ff820550e0", "patch": "@@ -416,30 +416,33 @@\n   [(set_attr \"neon_type\" \"neon_vld1_1_2_regs\")])\n \n (define_insn \"vec_set<mode>_internal\"\n-  [(set (match_operand:VD 0 \"s_register_operand\" \"=w\")\n+  [(set (match_operand:VD 0 \"s_register_operand\" \"=w,w\")\n         (vec_merge:VD\n           (vec_duplicate:VD\n-            (match_operand:<V_elem> 1 \"s_register_operand\" \"r\"))\n-          (match_operand:VD 3 \"s_register_operand\" \"0\")\n-          (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+            (match_operand:<V_elem> 1 \"nonimmediate_operand\" \"Um,r\"))\n+          (match_operand:VD 3 \"s_register_operand\" \"0,0\")\n+          (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n   \"TARGET_NEON\"\n {\n   int elt = ffs ((int) INTVAL (operands[2])) - 1;\n   if (BYTES_BIG_ENDIAN)\n     elt = GET_MODE_NUNITS (<MODE>mode) - 1 - elt;\n   operands[2] = GEN_INT (elt);\n-  \n-  return \"vmov.<V_sz_elem>\\t%P0[%c2], %1\";\n+\n+  if (which_alternative == 0)\n+    return \"vld1.<V_sz_elem>\\t{%P0[%c2]}, %A1\";\n+  else\n+    return \"vmov.<V_sz_elem>\\t%P0[%c2], %1\";\n }\n-  [(set_attr \"neon_type\" \"neon_mcr\")])\n+  [(set_attr \"neon_type\" \"neon_vld1_vld2_lane,neon_mcr\")])\n \n (define_insn \"vec_set<mode>_internal\"\n-  [(set (match_operand:VQ 0 \"s_register_operand\" \"=w\")\n+  [(set (match_operand:VQ 0 \"s_register_operand\" \"=w,w\")\n         (vec_merge:VQ\n           (vec_duplicate:VQ\n-            (match_operand:<V_elem> 1 \"s_register_operand\" \"r\"))\n-          (match_operand:VQ 3 \"s_register_operand\" \"0\")\n-          (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+            (match_operand:<V_elem> 1 \"nonimmediate_operand\" \"Um,r\"))\n+          (match_operand:VQ 3 \"s_register_operand\" \"0,0\")\n+          (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n   \"TARGET_NEON\"\n {\n   HOST_WIDE_INT elem = ffs ((int) INTVAL (operands[2])) - 1;\n@@ -454,28 +457,34 @@\n   operands[0] = gen_rtx_REG (<V_HALF>mode, regno + hi);\n   operands[2] = GEN_INT (elt);\n \n-  return \"vmov.<V_sz_elem>\\t%P0[%c2], %1\";\n+  if (which_alternative == 0)\n+    return \"vld1.<V_sz_elem>\\t{%P0[%c2]}, %A1\";\n+  else\n+    return \"vmov.<V_sz_elem>\\t%P0[%c2], %1\";\n }\n-  [(set_attr \"neon_type\" \"neon_mcr\")]\n+  [(set_attr \"neon_type\" \"neon_vld1_vld2_lane,neon_mcr\")]\n )\n \n (define_insn \"vec_setv2di_internal\"\n-  [(set (match_operand:V2DI 0 \"s_register_operand\" \"=w\")\n+  [(set (match_operand:V2DI 0 \"s_register_operand\" \"=w,w\")\n         (vec_merge:V2DI\n           (vec_duplicate:V2DI\n-            (match_operand:DI 1 \"s_register_operand\" \"r\"))\n-          (match_operand:V2DI 3 \"s_register_operand\" \"0\")\n-          (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+            (match_operand:DI 1 \"nonimmediate_operand\" \"Um,r\"))\n+          (match_operand:V2DI 3 \"s_register_operand\" \"0,0\")\n+          (match_operand:SI 2 \"immediate_operand\" \"i,i\")))]\n   \"TARGET_NEON\"\n {\n   HOST_WIDE_INT elem = ffs ((int) INTVAL (operands[2])) - 1;\n   int regno = REGNO (operands[0]) + 2 * elem;\n \n   operands[0] = gen_rtx_REG (DImode, regno);\n \n-  return \"vmov\\t%P0, %Q1, %R1\";\n+  if (which_alternative == 0)\n+    return \"vld1.64\\t%P0, %A1\";\n+  else\n+    return \"vmov\\t%P0, %Q1, %R1\";\n }\n-  [(set_attr \"neon_type\" \"neon_mcr_2_mcrr\")]\n+  [(set_attr \"neon_type\" \"neon_vld1_1_2_regs,neon_mcr_2_mcrr\")]\n )\n \n (define_expand \"vec_set<mode>\"\n@@ -491,10 +500,10 @@\n })\n \n (define_insn \"vec_extract<mode>\"\n-  [(set (match_operand:<V_elem> 0 \"s_register_operand\" \"=r\")\n+  [(set (match_operand:<V_elem> 0 \"nonimmediate_operand\" \"=Um,r\")\n         (vec_select:<V_elem>\n-          (match_operand:VD 1 \"s_register_operand\" \"w\")\n-          (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")])))]\n+          (match_operand:VD 1 \"s_register_operand\" \"w,w\")\n+          (parallel [(match_operand:SI 2 \"immediate_operand\" \"i,i\")])))]\n   \"TARGET_NEON\"\n {\n   if (BYTES_BIG_ENDIAN)\n@@ -503,16 +512,20 @@\n       elt = GET_MODE_NUNITS (<MODE>mode) - 1 - elt;\n       operands[2] = GEN_INT (elt);\n     }\n-  return \"vmov.<V_uf_sclr>\\t%0, %P1[%c2]\";\n+\n+  if (which_alternative == 0)\n+    return \"vst1.<V_sz_elem>\\t{%P1[%c2]}, %A0\";\n+  else\n+    return \"vmov.<V_uf_sclr>\\t%0, %P1[%c2]\";\n }\n-  [(set_attr \"neon_type\" \"neon_bp_simple\")]\n+  [(set_attr \"neon_type\" \"neon_vst1_vst2_lane,neon_bp_simple\")]\n )\n \n (define_insn \"vec_extract<mode>\"\n-  [(set (match_operand:<V_elem> 0 \"s_register_operand\" \"=r\")\n+  [(set (match_operand:<V_elem> 0 \"nonimmediate_operand\" \"=Um,r\")\n \t(vec_select:<V_elem>\n-          (match_operand:VQ 1 \"s_register_operand\" \"w\")\n-          (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")])))]\n+          (match_operand:VQ 1 \"s_register_operand\" \"w,w\")\n+          (parallel [(match_operand:SI 2 \"immediate_operand\" \"i,i\")])))]\n   \"TARGET_NEON\"\n {\n   int half_elts = GET_MODE_NUNITS (<MODE>mode) / 2;\n@@ -526,25 +539,31 @@\n   operands[1] = gen_rtx_REG (<V_HALF>mode, regno + hi);\n   operands[2] = GEN_INT (elt);\n \n-  return \"vmov.<V_uf_sclr>\\t%0, %P1[%c2]\";\n+  if (which_alternative == 0)\n+    return \"vst1.<V_sz_elem>\\t{%P1[%c2]}, %A0\";\n+  else\n+    return \"vmov.<V_uf_sclr>\\t%0, %P1[%c2]\";\n }\n-  [(set_attr \"neon_type\" \"neon_bp_simple\")]\n+  [(set_attr \"neon_type\" \"neon_vst1_vst2_lane,neon_bp_simple\")]\n )\n \n (define_insn \"vec_extractv2di\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=Um,r\")\n \t(vec_select:DI\n-          (match_operand:V2DI 1 \"s_register_operand\" \"w\")\n-          (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")])))]\n+          (match_operand:V2DI 1 \"s_register_operand\" \"w,w\")\n+          (parallel [(match_operand:SI 2 \"immediate_operand\" \"i,i\")])))]\n   \"TARGET_NEON\"\n {\n   int regno = REGNO (operands[1]) + 2 * INTVAL (operands[2]);\n \n   operands[1] = gen_rtx_REG (DImode, regno);\n \n-  return \"vmov\\t%Q0, %R0, %P1  @ v2di\";\n+  if (which_alternative == 0)\n+    return \"vst1.64\\t{%P1}, %A0  @ v2di\";\n+  else\n+    return \"vmov\\t%Q0, %R0, %P1  @ v2di\";\n }\n-  [(set_attr \"neon_type\" \"neon_int_1\")]\n+  [(set_attr \"neon_type\" \"neon_vst1_vst2_lane,neon_int_1\")]\n )\n \n (define_expand \"vec_init<mode>\"\n@@ -4449,9 +4468,10 @@\n \n (define_insn \"neon_vst1_lane<mode>\"\n   [(set (match_operand:<V_elem> 0 \"neon_struct_operand\" \"=Um\")\n-\t(vec_select:<V_elem>\n-\t  (match_operand:VDX 1 \"s_register_operand\" \"w\")\n-\t  (parallel [(match_operand:SI 2 \"neon_lane_number\" \"i\")])))]\n+\t(unspec:<V_elem>\n+\t  [(match_operand:VDX 1 \"s_register_operand\" \"w\")\n+\t   (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+\t  UNSPEC_VST1_LANE))]\n   \"TARGET_NEON\"\n {\n   HOST_WIDE_INT lane = INTVAL (operands[2]);\n@@ -4470,9 +4490,10 @@\n \n (define_insn \"neon_vst1_lane<mode>\"\n   [(set (match_operand:<V_elem> 0 \"neon_struct_operand\" \"=Um\")\n-        (vec_select:<V_elem>\n-           (match_operand:VQX 1 \"s_register_operand\" \"w\")\n-           (parallel [(match_operand:SI 2 \"neon_lane_number\" \"i\")])))]\n+\t(unspec:<V_elem>\n+\t  [(match_operand:VQX 1 \"s_register_operand\" \"w\")\n+\t   (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+\t  UNSPEC_VST1_LANE))]\n   \"TARGET_NEON\"\n {\n   HOST_WIDE_INT lane = INTVAL (operands[2]);"}, {"sha": "f55acbf22103a170f85d86f03ea8998146b9678e", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/058e2674514e24a92282606059c697ff820550e0/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/058e2674514e24a92282606059c697ff820550e0/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=058e2674514e24a92282606059c697ff820550e0", "patch": "@@ -524,10 +524,6 @@\n   (ior (match_operand 0 \"imm_for_neon_inv_logic_operand\")\n        (match_operand 0 \"s_register_operand\")))\n \n-;; TODO: We could check lane numbers more precisely based on the mode.\n-(define_predicate \"neon_lane_number\"\n-  (and (match_code \"const_int\")\n-       (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 15\")))\n ;; Predicates for named expanders that overlap multiple ISAs.\n \n (define_predicate \"cmpdi_operand\""}]}