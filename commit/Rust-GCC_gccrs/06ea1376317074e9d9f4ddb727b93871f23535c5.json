{"sha": "06ea1376317074e9d9f4ddb727b93871f23535c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZlYTEzNzYzMTcwNzRlOWQ5ZjRkZGI3MjdiOTM4NzFmMjM1MzVjNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-10-16T21:58:19Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-10-16T21:58:19Z"}, "message": "Core 1591\n\n\tCore 1591\n\t* pt.c (unify_array_domain): Split out from unify.\n\t(unify): Use it for list deduction, too.\n\nFrom-SVN: r203725", "tree": {"sha": "7ebdf49640d63cbdbfcc797e6c6186699f67f2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ebdf49640d63cbdbfcc797e6c6186699f67f2d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06ea1376317074e9d9f4ddb727b93871f23535c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ea1376317074e9d9f4ddb727b93871f23535c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06ea1376317074e9d9f4ddb727b93871f23535c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06ea1376317074e9d9f4ddb727b93871f23535c5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fac91973cceae62ffa4a3cd285cb4c9557f83416", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac91973cceae62ffa4a3cd285cb4c9557f83416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fac91973cceae62ffa4a3cd285cb4c9557f83416"}], "stats": {"total": 157, "additions": 96, "deletions": 61}, "files": [{"sha": "2852f1f1c75794fff93865ebe073765d77e56f22", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ea1376317074e9d9f4ddb727b93871f23535c5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ea1376317074e9d9f4ddb727b93871f23535c5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=06ea1376317074e9d9f4ddb727b93871f23535c5", "patch": "@@ -1,5 +1,9 @@\n 2013-10-16  Jason Merrill  <jason@redhat.com>\n \n+\tCore 1591\n+\t* pt.c (unify_array_domain): Split out from unify.\n+\t(unify): Use it for list deduction, too.\n+\n \tPR c++/57850\n \t* decl2.c (dump_tu): Split out from...\n \t(cp_write_global_declarations): ...here.  Call it in PCH mode."}, {"sha": "a1eb7a2d35d3a2d381177e3cffabd433c5bd4d51", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 85, "deletions": 61, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ea1376317074e9d9f4ddb727b93871f23535c5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ea1376317074e9d9f4ddb727b93871f23535c5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=06ea1376317074e9d9f4ddb727b93871f23535c5", "patch": "@@ -17007,6 +17007,72 @@ unify_pack_expansion (tree tparms, tree targs, tree packed_parms,\n   return unify_success (explain_p);\n }\n \n+/* Handle unification of the domain of an array.  PARM_DOM and ARG_DOM are\n+   INTEGER_TYPEs representing the TYPE_DOMAIN of ARRAY_TYPEs.  The other\n+   parameters and return value are as for unify.  */\n+\n+static int\n+unify_array_domain (tree tparms, tree targs,\n+\t\t    tree parm_dom, tree arg_dom,\n+\t\t    bool explain_p)\n+{\n+  tree parm_max;\n+  tree arg_max;\n+  bool parm_cst;\n+  bool arg_cst;\n+\n+  /* Our representation of array types uses \"N - 1\" as the\n+     TYPE_MAX_VALUE for an array with \"N\" elements, if \"N\" is\n+     not an integer constant.  We cannot unify arbitrarily\n+     complex expressions, so we eliminate the MINUS_EXPRs\n+     here.  */\n+  parm_max = TYPE_MAX_VALUE (parm_dom);\n+  parm_cst = TREE_CODE (parm_max) == INTEGER_CST;\n+  if (!parm_cst)\n+    {\n+      gcc_assert (TREE_CODE (parm_max) == MINUS_EXPR);\n+      parm_max = TREE_OPERAND (parm_max, 0);\n+    }\n+  arg_max = TYPE_MAX_VALUE (arg_dom);\n+  arg_cst = TREE_CODE (arg_max) == INTEGER_CST;\n+  if (!arg_cst)\n+    {\n+      /* The ARG_MAX may not be a simple MINUS_EXPR, if we are\n+\t trying to unify the type of a variable with the type\n+\t of a template parameter.  For example:\n+\n+\t   template <unsigned int N>\n+\t   void f (char (&) [N]);\n+\t   int g();\n+\t   void h(int i) {\n+\t     char a[g(i)];\n+\t     f(a);\n+\t   }\n+\n+\t Here, the type of the ARG will be \"int [g(i)]\", and\n+\t may be a SAVE_EXPR, etc.  */\n+      if (TREE_CODE (arg_max) != MINUS_EXPR)\n+\treturn unify_vla_arg (explain_p, arg_dom);\n+      arg_max = TREE_OPERAND (arg_max, 0);\n+    }\n+\n+  /* If only one of the bounds used a MINUS_EXPR, compensate\n+     by adding one to the other bound.  */\n+  if (parm_cst && !arg_cst)\n+    parm_max = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tparm_max,\n+\t\t\t\tinteger_one_node);\n+  else if (arg_cst && !parm_cst)\n+    arg_max = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t       integer_type_node,\n+\t\t\t       arg_max,\n+\t\t\t       integer_one_node);\n+\n+  return unify (tparms, targs, parm_max, arg_max,\n+\t\tUNIFY_ALLOW_INTEGER, explain_p);\n+}\n+\n /* Deduce the value of template parameters.  TPARMS is the (innermost)\n    set of template parameters to a template.  TARGS is the bindings\n    for those template parameters, as determined thus far; TARGS may\n@@ -17092,13 +17158,17 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t  && flag_deduce_init_list)\n \tparm = listify (parm);\n \n-      if (!is_std_init_list (parm))\n+      if (!is_std_init_list (parm)\n+\t  && TREE_CODE (parm) != ARRAY_TYPE)\n \t/* We can only deduce from an initializer list argument if the\n-\t   parameter is std::initializer_list; otherwise this is a\n-\t   non-deduced context. */\n+\t   parameter is std::initializer_list or an array; otherwise this\n+\t   is a non-deduced context. */\n \treturn unify_success (explain_p);\n \n-      elttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (parm), 0);\n+      if (TREE_CODE (parm) == ARRAY_TYPE)\n+\telttype = TREE_TYPE (parm);\n+      else\n+\telttype = TREE_VEC_ELT (CLASSTYPE_TI_ARGS (parm), 0);\n \n       FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (arg), i, elt)\n \t{\n@@ -17121,6 +17191,15 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t\t\t\t   explain_p);\n \t}\n \n+      if (TREE_CODE (parm) == ARRAY_TYPE)\n+\t{\n+\t  /* Also deduce from the length of the initializer list.  */\n+\t  tree max = size_int (CONSTRUCTOR_NELTS (arg));\n+\t  tree idx = compute_array_index_type (NULL_TREE, max, tf_none);\n+\t  return unify_array_domain (tparms, targs, TYPE_DOMAIN (parm),\n+\t\t\t\t     idx, explain_p);\n+\t}\n+\n       /* If the std::initializer_list<T> deduction worked, replace the\n \t deduced A with std::initializer_list<A>.  */\n       if (orig_parm != parm)\n@@ -17494,63 +17573,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n       RECUR_AND_CHECK_FAILURE (tparms, targs, TREE_TYPE (parm), TREE_TYPE (arg),\n \t\t\t       strict & UNIFY_ALLOW_MORE_CV_QUAL, explain_p);\n       if (TYPE_DOMAIN (parm) != NULL_TREE)\n-\t{\n-\t  tree parm_max;\n-\t  tree arg_max;\n-\t  bool parm_cst;\n-\t  bool arg_cst;\n-\n-\t  /* Our representation of array types uses \"N - 1\" as the\n-\t     TYPE_MAX_VALUE for an array with \"N\" elements, if \"N\" is\n-\t     not an integer constant.  We cannot unify arbitrarily\n-\t     complex expressions, so we eliminate the MINUS_EXPRs\n-\t     here.  */\n-\t  parm_max = TYPE_MAX_VALUE (TYPE_DOMAIN (parm));\n-\t  parm_cst = TREE_CODE (parm_max) == INTEGER_CST;\n-\t  if (!parm_cst)\n-\t    {\n-\t      gcc_assert (TREE_CODE (parm_max) == MINUS_EXPR);\n-\t      parm_max = TREE_OPERAND (parm_max, 0);\n-\t    }\n-\t  arg_max = TYPE_MAX_VALUE (TYPE_DOMAIN (arg));\n-\t  arg_cst = TREE_CODE (arg_max) == INTEGER_CST;\n-\t  if (!arg_cst)\n-\t    {\n-\t      /* The ARG_MAX may not be a simple MINUS_EXPR, if we are\n-\t\t trying to unify the type of a variable with the type\n-\t\t of a template parameter.  For example:\n-\n-                   template <unsigned int N>\n-\t\t   void f (char (&) [N]);\n-\t\t   int g(); \n-\t\t   void h(int i) {\n-                     char a[g(i)];\n-\t\t     f(a); \n-                   }\n-\n-                Here, the type of the ARG will be \"int [g(i)]\", and\n-                may be a SAVE_EXPR, etc.  */\n-\t      if (TREE_CODE (arg_max) != MINUS_EXPR)\n-\t\treturn unify_vla_arg (explain_p, arg);\n-\t      arg_max = TREE_OPERAND (arg_max, 0);\n-\t    }\n-\n-\t  /* If only one of the bounds used a MINUS_EXPR, compensate\n-\t     by adding one to the other bound.  */\n-\t  if (parm_cst && !arg_cst)\n-\t    parm_max = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t    integer_type_node,\n-\t\t\t\t    parm_max,\n-\t\t\t\t    integer_one_node);\n-\t  else if (arg_cst && !parm_cst)\n-\t    arg_max = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t   integer_type_node,\n-\t\t\t\t   arg_max,\n-\t\t\t\t   integer_one_node);\n-\n-\t  RECUR_AND_CHECK_FAILURE (tparms, targs, parm_max, arg_max,\n-\t\t\t\t   UNIFY_ALLOW_INTEGER, explain_p);\n-\t}\n+\treturn unify_array_domain (tparms, targs, TYPE_DOMAIN (parm),\n+\t\t\t\t   TYPE_DOMAIN (arg), explain_p);\n       return unify_success (explain_p);\n \n     case REAL_TYPE:"}, {"sha": "4305b59a0ec118bfc7928a81a436d078648d0faf", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist74.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06ea1376317074e9d9f4ddb727b93871f23535c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist74.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06ea1376317074e9d9f4ddb727b93871f23535c5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist74.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist74.C?ref=06ea1376317074e9d9f4ddb727b93871f23535c5", "patch": "@@ -0,0 +1,7 @@\n+// Core 1591\n+// { dg-require-effective-target c++11 }\n+\n+template<class T, int N> void g(T const (&)[N]);\n+void f() {\n+  g( { 1, 2, 3, 4 } );\n+}"}]}