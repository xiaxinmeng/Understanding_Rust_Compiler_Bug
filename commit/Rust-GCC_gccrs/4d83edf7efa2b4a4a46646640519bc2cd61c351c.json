{"sha": "4d83edf7efa2b4a4a46646640519bc2cd61c351c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ4M2VkZjdlZmEyYjRhNGE0NjY0NjY0MDUxOWJjMmNkNjFjMzUxYw==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2019-12-20T01:20:23Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2019-12-20T01:20:23Z"}, "message": "Factor out duplicate code in gimplify_scan_omp_clauses\n\n\tgcc/\n\t* gimplify.c (insert_struct_comp_map, extract_base_bit_offset): New.\n\t(gimplify_scan_omp_clauses): Outline duplicated code into calls to\n\tabove two functions.\n\nFrom-SVN: r279623", "tree": {"sha": "7d09554ce1e23f83a1734251773f79d9046871a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d09554ce1e23f83a1734251773f79d9046871a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d83edf7efa2b4a4a46646640519bc2cd61c351c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d83edf7efa2b4a4a46646640519bc2cd61c351c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d83edf7efa2b4a4a46646640519bc2cd61c351c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d83edf7efa2b4a4a46646640519bc2cd61c351c/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5bcd470bf0749e1f56d05dd43aa9584ff2e3a090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bcd470bf0749e1f56d05dd43aa9584ff2e3a090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bcd470bf0749e1f56d05dd43aa9584ff2e3a090"}], "stats": {"total": 296, "additions": 163, "deletions": 133}, "files": [{"sha": "bd1e0047f08a62ba69147e6a7612a9309944d24d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d83edf7efa2b4a4a46646640519bc2cd61c351c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d83edf7efa2b4a4a46646640519bc2cd61c351c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d83edf7efa2b4a4a46646640519bc2cd61c351c", "patch": "@@ -1,3 +1,9 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\n+\t* gimplify.c (insert_struct_comp_map, extract_base_bit_offset): New.\n+\t(gimplify_scan_omp_clauses): Outline duplicated code into calls to\n+\tabove two functions.\n+\n 2019-12-19  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/92905"}, {"sha": "bb75dc6fcf7f7f4c89aa6b1aecd318dec1676ba9", "filename": "gcc/gimplify.c", "status": "modified", "additions": 157, "deletions": 133, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d83edf7efa2b4a4a46646640519bc2cd61c351c/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d83edf7efa2b4a4a46646640519bc2cd61c351c/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=4d83edf7efa2b4a4a46646640519bc2cd61c351c", "patch": "@@ -8186,6 +8186,138 @@ gimplify_omp_depend (tree *list_p, gimple_seq *pre_p)\n   return 1;\n }\n \n+/* Insert a GOMP_MAP_ALLOC or GOMP_MAP_RELEASE node following a\n+   GOMP_MAP_STRUCT mapping.  C is an always_pointer mapping.  STRUCT_NODE is\n+   the struct node to insert the new mapping after (when the struct node is\n+   initially created).  PREV_NODE is the first of two or three mappings for a\n+   pointer, and is either:\n+     - the node before C, when a pair of mappings is used, e.g. for a C/C++\n+       array section.\n+     - not the node before C.  This is true when we have a reference-to-pointer\n+       type (with a mapping for the reference and for the pointer), or for\n+       Fortran derived-type mappings with a GOMP_MAP_TO_PSET.\n+   If SCP is non-null, the new node is inserted before *SCP.\n+   if SCP is null, the new node is inserted before PREV_NODE.\n+   The return type is:\n+     - PREV_NODE, if SCP is non-null.\n+     - The newly-created ALLOC or RELEASE node, if SCP is null.\n+     - The second newly-created ALLOC or RELEASE node, if we are mapping a\n+       reference to a pointer.  */\n+\n+static tree\n+insert_struct_comp_map (enum tree_code code, tree c, tree struct_node,\n+\t\t\ttree prev_node, tree *scp)\n+{\n+  enum gomp_map_kind mkind\n+    = code == OMP_TARGET_EXIT_DATA ? GOMP_MAP_RELEASE : GOMP_MAP_ALLOC;\n+\n+  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n+  tree cl = scp ? prev_node : c2;\n+  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n+  OMP_CLAUSE_DECL (c2) = unshare_expr (OMP_CLAUSE_DECL (c));\n+  OMP_CLAUSE_CHAIN (c2) = scp ? *scp : prev_node;\n+  OMP_CLAUSE_SIZE (c2) = TYPE_SIZE_UNIT (ptr_type_node);\n+  if (struct_node)\n+    OMP_CLAUSE_CHAIN (struct_node) = c2;\n+\n+  /* We might need to create an additional mapping if we have a reference to a\n+     pointer (in C++).  */\n+  if (OMP_CLAUSE_CHAIN (prev_node) != c)\n+    {\n+      tree c4 = OMP_CLAUSE_CHAIN (prev_node);\n+      tree c3 = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (c3, mkind);\n+      OMP_CLAUSE_DECL (c3) = unshare_expr (OMP_CLAUSE_DECL (c4));\n+      OMP_CLAUSE_SIZE (c3) = TYPE_SIZE_UNIT (ptr_type_node);\n+      OMP_CLAUSE_CHAIN (c3) = prev_node;\n+      if (!scp)\n+\tOMP_CLAUSE_CHAIN (c2) = c3;\n+      else\n+\tcl = c3;\n+    }\n+\n+  if (scp)\n+    *scp = c2;\n+\n+  return cl;\n+}\n+\n+/* Strip ARRAY_REFS or an indirect ref off BASE, find the containing object,\n+   and set *BITPOSP and *POFFSETP to the bit offset of the access.\n+   If BASE_REF is non-NULL and the containing object is a reference, set\n+   *BASE_REF to that reference before dereferencing the object.\n+   If BASE_REF is NULL, check that the containing object is a COMPONENT_REF or\n+   has array type, else return NULL.  */\n+\n+static tree\n+extract_base_bit_offset (tree base, tree *base_ref, poly_int64 *bitposp,\n+\t\t\t poly_offset_int *poffsetp)\n+{\n+  tree offset;\n+  poly_int64 bitsize, bitpos;\n+  machine_mode mode;\n+  int unsignedp, reversep, volatilep = 0;\n+  poly_offset_int poffset;\n+\n+  if (base_ref)\n+    {\n+      *base_ref = NULL_TREE;\n+\n+      while (TREE_CODE (base) == ARRAY_REF)\n+\tbase = TREE_OPERAND (base, 0);\n+\n+      if (TREE_CODE (base) == INDIRECT_REF)\n+\tbase = TREE_OPERAND (base, 0);\n+    }\n+  else\n+    {\n+      if (TREE_CODE (base) == ARRAY_REF)\n+\t{\n+\t  while (TREE_CODE (base) == ARRAY_REF)\n+\t    base = TREE_OPERAND (base, 0);\n+\t  if (TREE_CODE (base) != COMPONENT_REF\n+\t      || TREE_CODE (TREE_TYPE (base)) != ARRAY_TYPE)\n+\t    return NULL_TREE;\n+\t}\n+      else if (TREE_CODE (base) == INDIRECT_REF\n+\t       && TREE_CODE (TREE_OPERAND (base, 0)) == COMPONENT_REF\n+\t       && (TREE_CODE (TREE_TYPE (TREE_OPERAND (base, 0)))\n+\t\t   == REFERENCE_TYPE))\n+\tbase = TREE_OPERAND (base, 0);\n+    }\n+\n+  base = get_inner_reference (base, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t      &unsignedp, &reversep, &volatilep);\n+\n+  tree orig_base = base;\n+\n+  if ((TREE_CODE (base) == INDIRECT_REF\n+       || (TREE_CODE (base) == MEM_REF\n+\t   && integer_zerop (TREE_OPERAND (base, 1))))\n+      && DECL_P (TREE_OPERAND (base, 0))\n+      && TREE_CODE (TREE_TYPE (TREE_OPERAND (base, 0))) == REFERENCE_TYPE)\n+    base = TREE_OPERAND (base, 0);\n+\n+  gcc_assert (offset == NULL_TREE || poly_int_tree_p (offset));\n+\n+  if (offset)\n+    poffset = wi::to_poly_offset (offset);\n+  else\n+    poffset = 0;\n+\n+  if (maybe_ne (bitpos, 0))\n+    poffset += bits_to_bytes_round_down (bitpos);\n+\n+  *bitposp = bitpos;\n+  *poffsetp = poffset;\n+\n+  /* Set *BASE_REF if BASE was a dereferenced reference variable.  */\n+  if (base_ref && orig_base != base)\n+    *base_ref = orig_base;\n+\n+  return base;\n+}\n+\n /* Scan the OMP clauses in *LIST_P, installing mappings into a new\n    and previous omp contexts.  */\n \n@@ -8738,29 +8870,15 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t}\n \t\t    }\n \n-\t\t  tree offset;\n-\t\t  poly_int64 bitsize, bitpos;\n-\t\t  machine_mode mode;\n-\t\t  int unsignedp, reversep, volatilep = 0;\n-\t\t  tree base = OMP_CLAUSE_DECL (c);\n-\t\t  while (TREE_CODE (base) == ARRAY_REF)\n-\t\t    base = TREE_OPERAND (base, 0);\n-\t\t  if (TREE_CODE (base) == INDIRECT_REF)\n-\t\t    base = TREE_OPERAND (base, 0);\n-\t\t  base = get_inner_reference (base, &bitsize, &bitpos, &offset,\n-\t\t\t\t\t      &mode, &unsignedp, &reversep,\n-\t\t\t\t\t      &volatilep);\n-\t\t  tree orig_base = base;\n-\t\t  if ((TREE_CODE (base) == INDIRECT_REF\n-\t\t       || (TREE_CODE (base) == MEM_REF\n-\t\t\t   && integer_zerop (TREE_OPERAND (base, 1))))\n-\t\t      && DECL_P (TREE_OPERAND (base, 0))\n-\t\t      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (base, 0)))\n-\t\t\t  == REFERENCE_TYPE))\n-\t\t    base = TREE_OPERAND (base, 0);\n-\t\t  gcc_assert (base == decl\n-\t\t\t      && (offset == NULL_TREE\n-\t\t\t\t  || poly_int_tree_p (offset)));\n+\t\t  poly_offset_int offset1;\n+\t\t  poly_int64 bitpos1;\n+\t\t  tree base_ref;\n+\n+\t\t  tree base\n+\t\t    = extract_base_bit_offset (OMP_CLAUSE_DECL (c), &base_ref,\n+\t\t\t\t\t       &bitpos1, &offset1);\n+\n+\t\t  gcc_assert (base == decl);\n \n \t\t  splay_tree_node n\n \t\t    = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n@@ -8771,8 +8889,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      tree l = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t\t OMP_CLAUSE_MAP);\n \t\t      OMP_CLAUSE_SET_MAP_KIND (l, GOMP_MAP_STRUCT);\n-\t\t      if (orig_base != base)\n-\t\t\tOMP_CLAUSE_DECL (l) = unshare_expr (orig_base);\n+\t\t      if (base_ref)\n+\t\t\tOMP_CLAUSE_DECL (l) = unshare_expr (base_ref);\n \t\t      else\n \t\t\tOMP_CLAUSE_DECL (l) = decl;\n \t\t      OMP_CLAUSE_SIZE (l) = size_int (1);\n@@ -8781,32 +8899,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      struct_map_to_clause->put (decl, l);\n \t\t      if (ptr)\n \t\t\t{\n-\t\t\t  enum gomp_map_kind mkind\n-\t\t\t    = code == OMP_TARGET_EXIT_DATA\n-\t\t\t      ? GOMP_MAP_RELEASE : GOMP_MAP_ALLOC;\n-\t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t      OMP_CLAUSE_MAP);\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n-\t\t\t  OMP_CLAUSE_DECL (c2)\n-\t\t\t    = unshare_expr (OMP_CLAUSE_DECL (c));\n-\t\t\t  OMP_CLAUSE_CHAIN (c2) = *prev_list_p;\n-\t\t\t  OMP_CLAUSE_SIZE (c2)\n-\t\t\t    = TYPE_SIZE_UNIT (ptr_type_node);\n-\t\t\t  OMP_CLAUSE_CHAIN (l) = c2;\n-\t\t\t  if (OMP_CLAUSE_CHAIN (*prev_list_p) != c)\n-\t\t\t    {\n-\t\t\t      tree c4 = OMP_CLAUSE_CHAIN (*prev_list_p);\n-\t\t\t      tree c3\n-\t\t\t\t= build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n-\t\t\t      OMP_CLAUSE_SET_MAP_KIND (c3, mkind);\n-\t\t\t      OMP_CLAUSE_DECL (c3)\n-\t\t\t\t= unshare_expr (OMP_CLAUSE_DECL (c4));\n-\t\t\t      OMP_CLAUSE_SIZE (c3)\n-\t\t\t\t= TYPE_SIZE_UNIT (ptr_type_node);\n-\t\t\t      OMP_CLAUSE_CHAIN (c3) = *prev_list_p;\n-\t\t\t      OMP_CLAUSE_CHAIN (c2) = c3;\n-\t\t\t    }\n+\t\t\t  insert_struct_comp_map (code, c, l, *prev_list_p,\n+\t\t\t\t\t\t  NULL);\n \t\t\t  *prev_list_p = l;\n \t\t\t  prev_list_p = NULL;\n \t\t\t}\n@@ -8816,7 +8910,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t  *list_p = l;\n \t\t\t  list_p = &OMP_CLAUSE_CHAIN (l);\n \t\t\t}\n-\t\t      if (orig_base != base && code == OMP_TARGET)\n+\t\t      if (base_ref && code == OMP_TARGET)\n \t\t\t{\n \t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t\t      OMP_CLAUSE_MAP);\n@@ -8839,13 +8933,6 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      tree *sc = NULL, *scp = NULL;\n \t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) || ptr)\n \t\t\tn->value |= GOVD_SEEN;\n-\t\t      poly_offset_int o1, o2;\n-\t\t      if (offset)\n-\t\t\to1 = wi::to_poly_offset (offset);\n-\t\t      else\n-\t\t\to1 = 0;\n-\t\t      if (maybe_ne (bitpos, 0))\n-\t\t\to1 += bits_to_bytes_round_down (bitpos);\n \t\t      sc = &OMP_CLAUSE_CHAIN (*osc);\n \t\t      if (*sc != c\n \t\t\t  && (OMP_CLAUSE_MAP_KIND (*sc)\n@@ -8863,44 +8950,16 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t  break;\n \t\t\telse\n \t\t\t  {\n-\t\t\t    tree offset2;\n-\t\t\t    poly_int64 bitsize2, bitpos2;\n-\t\t\t    base = OMP_CLAUSE_DECL (*sc);\n-\t\t\t    if (TREE_CODE (base) == ARRAY_REF)\n-\t\t\t      {\n-\t\t\t\twhile (TREE_CODE (base) == ARRAY_REF)\n-\t\t\t\t  base = TREE_OPERAND (base, 0);\n-\t\t\t\tif (TREE_CODE (base) != COMPONENT_REF\n-\t\t\t\t    || (TREE_CODE (TREE_TYPE (base))\n-\t\t\t\t\t!= ARRAY_TYPE))\n-\t\t\t\t  break;\n-\t\t\t      }\n-\t\t\t    else if (TREE_CODE (base) == INDIRECT_REF\n-\t\t\t\t     && (TREE_CODE (TREE_OPERAND (base, 0))\n-\t\t\t\t\t == COMPONENT_REF)\n-\t\t\t\t     && (TREE_CODE (TREE_TYPE\n-\t\t\t\t\t\t     (TREE_OPERAND (base, 0)))\n-\t\t\t\t\t == REFERENCE_TYPE))\n-\t\t\t      base = TREE_OPERAND (base, 0);\n-\t\t\t    base = get_inner_reference (base, &bitsize2,\n-\t\t\t\t\t\t\t&bitpos2, &offset2,\n-\t\t\t\t\t\t\t&mode, &unsignedp,\n-\t\t\t\t\t\t\t&reversep, &volatilep);\n-\t\t\t    if ((TREE_CODE (base) == INDIRECT_REF\n-\t\t\t\t || (TREE_CODE (base) == MEM_REF\n-\t\t\t\t     && integer_zerop (TREE_OPERAND (base,\n-\t\t\t\t\t\t\t\t     1))))\n-\t\t\t\t&& DECL_P (TREE_OPERAND (base, 0))\n-\t\t\t\t&& (TREE_CODE (TREE_TYPE (TREE_OPERAND (base,\n-\t\t\t\t\t\t\t\t\t0)))\n-\t\t\t\t    == REFERENCE_TYPE))\n-\t\t\t      base = TREE_OPERAND (base, 0);\n+\t\t\t    tree sc_decl = OMP_CLAUSE_DECL (*sc);\n+\t\t\t    poly_offset_int offsetn;\n+\t\t\t    poly_int64 bitposn;\n+\t\t\t    tree base\n+\t\t\t      = extract_base_bit_offset (sc_decl, NULL,\n+\t\t\t\t\t\t\t &bitposn, &offsetn);\n \t\t\t    if (base != decl)\n \t\t\t      break;\n \t\t\t    if (scp)\n \t\t\t      continue;\n-\t\t\t    gcc_assert (offset2 == NULL_TREE\n-\t\t\t\t\t|| poly_int_tree_p (offset2));\n \t\t\t    tree d1 = OMP_CLAUSE_DECL (*sc);\n \t\t\t    tree d2 = OMP_CLAUSE_DECL (c);\n \t\t\t    while (TREE_CODE (d1) == ARRAY_REF)\n@@ -8929,14 +8988,9 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t\tremove = true;\n \t\t\t\tbreak;\n \t\t\t      }\n-\t\t\t    if (offset2)\n-\t\t\t      o2 = wi::to_poly_offset (offset2);\n-\t\t\t    else\n-\t\t\t      o2 = 0;\n-\t\t\t    o2 += bits_to_bytes_round_down (bitpos2);\n-\t\t\t    if (maybe_lt (o1, o2)\n-\t\t\t\t|| (known_eq (o1, o2)\n-\t\t\t\t    && maybe_lt (bitpos, bitpos2)))\n+\t\t\t    if (maybe_lt (offset1, offsetn)\n+\t\t\t\t|| (known_eq (offset1, offsetn)\n+\t\t\t\t    && maybe_lt (bitpos1, bitposn)))\n \t\t\t      {\n \t\t\t\tif (ptr)\n \t\t\t\t  scp = sc;\n@@ -8951,38 +9005,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t\t      size_one_node);\n \t\t      if (ptr)\n \t\t\t{\n-\t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t      OMP_CLAUSE_MAP);\n-\t\t\t  tree cl = NULL_TREE;\n-\t\t\t  enum gomp_map_kind mkind\n-\t\t\t    = code == OMP_TARGET_EXIT_DATA\n-\t\t\t      ? GOMP_MAP_RELEASE : GOMP_MAP_ALLOC;\n-\t\t\t  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n-\t\t\t  OMP_CLAUSE_DECL (c2)\n-\t\t\t    = unshare_expr (OMP_CLAUSE_DECL (c));\n-\t\t\t  OMP_CLAUSE_CHAIN (c2) = scp ? *scp : *prev_list_p;\n-\t\t\t  OMP_CLAUSE_SIZE (c2)\n-\t\t\t    = TYPE_SIZE_UNIT (ptr_type_node);\n-\t\t\t  cl = scp ? *prev_list_p : c2;\n-\t\t\t  if (OMP_CLAUSE_CHAIN (*prev_list_p) != c)\n-\t\t\t    {\n-\t\t\t      tree c4 = OMP_CLAUSE_CHAIN (*prev_list_p);\n-\t\t\t      tree c3\n-\t\t\t\t= build_omp_clause (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\t\t\t    OMP_CLAUSE_MAP);\n-\t\t\t      OMP_CLAUSE_SET_MAP_KIND (c3, mkind);\n-\t\t\t      OMP_CLAUSE_DECL (c3)\n-\t\t\t\t= unshare_expr (OMP_CLAUSE_DECL (c4));\n-\t\t\t      OMP_CLAUSE_SIZE (c3)\n-\t\t\t\t= TYPE_SIZE_UNIT (ptr_type_node);\n-\t\t\t      OMP_CLAUSE_CHAIN (c3) = *prev_list_p;\n-\t\t\t      if (!scp)\n-\t\t\t\tOMP_CLAUSE_CHAIN (c2) = c3;\n-\t\t\t      else\n-\t\t\t\tcl = c3;\n-\t\t\t    }\n-\t\t\t  if (scp)\n-\t\t\t    *scp = c2;\n+\t\t\t  tree cl = insert_struct_comp_map (code, c, NULL,\n+\t\t\t\t\t\t\t    *prev_list_p, scp);\n \t\t\t  if (sc == prev_list_p)\n \t\t\t    {\n \t\t\t      *sc = cl;"}]}