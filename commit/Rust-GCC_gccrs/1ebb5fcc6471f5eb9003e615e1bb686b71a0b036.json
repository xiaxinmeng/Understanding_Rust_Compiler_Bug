{"sha": "1ebb5fcc6471f5eb9003e615e1bb686b71a0b036", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWViYjVmY2M2NDcxZjVlYjkwMDNlNjE1ZTFiYjY4NmI3MWEwYjAzNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-05T14:10:50Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-05T14:10:50Z"}, "message": "(sarray_{remove,free}_garbage): New functions.\n\n(sarray_at_put, sarray_new, sarray_lazy_copy):\nModify/copy sarray structure/data in a thread-safe manner\n(sarray_{realloc,free}): Reallocate/free sarray structure/data in a\nthread-safe manner.\n\nFrom-SVN: r11445", "tree": {"sha": "478fa069b641a16db6a237348fe7551182f6eca3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/478fa069b641a16db6a237348fe7551182f6eca3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ebb5fcc6471f5eb9003e615e1bb686b71a0b036", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ebb5fcc6471f5eb9003e615e1bb686b71a0b036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ebb5fcc6471f5eb9003e615e1bb686b71a0b036", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ebb5fcc6471f5eb9003e615e1bb686b71a0b036/comments", "author": null, "committer": null, "parents": [{"sha": "54d643f6f26b192c82c2aac16122417e3e9281c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54d643f6f26b192c82c2aac16122417e3e9281c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54d643f6f26b192c82c2aac16122417e3e9281c3"}], "stats": {"total": 323, "additions": 202, "deletions": 121}, "files": [{"sha": "fc7323a2442447e75539747074153be923c23b0b", "filename": "gcc/objc/sarray.c", "status": "modified", "additions": 202, "deletions": 121, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ebb5fcc6471f5eb9003e615e1bb686b71a0b036/gcc%2Fobjc%2Fsarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ebb5fcc6471f5eb9003e615e1bb686b71a0b036/gcc%2Fobjc%2Fsarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsarray.c?ref=1ebb5fcc6471f5eb9003e615e1bb686b71a0b036", "patch": "@@ -1,5 +1,5 @@\n /* Sparse Arrays for Objective C dispatch tables\n-   Copyright (C) 1993, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -25,13 +25,16 @@ Boston, MA 02111-1307, USA.  */\n    the executable file might be covered by the GNU General Public License.  */\n \n #include \"objc/sarray.h\"\n+#include \"objc/runtime.h\"\n #include <stdio.h>\n #include \"assert.h\"\n \n-int nbuckets = 0;\n-int nindices = 0;\n-int narrays = 0;\n-int idxsize = 0;\n+int nbuckets = 0;\t\t\t\t\t/* !T:MUTEX */\n+int nindices = 0;\t\t\t\t\t/* !T:MUTEX */\n+int narrays = 0;\t\t\t\t\t/* !T:MUTEX */\n+int idxsize = 0;\t\t\t\t\t/* !T:MUTEX */\n+\n+static void *\tfirst_free_data = NULL;\t\t\t/* !T:MUTEX */\n \n #ifdef OBJC_SPARSE2\n const char* __objc_sparse2_id = \"2 level sparse indices\";\n@@ -46,13 +49,60 @@ const void *memcpy (void*, const void*, size_t);\n void free (const void*);\n #endif\n \n+/* This function removes any structures left over from free operations\n+   that were not safe in a multi-threaded environment. */\n+void\n+sarray_remove_garbage(void)\n+{\n+  void **vp;\n+  void *np;\n+  \n+  objc_mutex_lock(__objc_runtime_mutex);\n+\n+  vp = first_free_data;\n+  first_free_data = NULL;\n+\n+  while (vp) {\n+    np = *vp;\n+    free(vp);\n+    vp = np;\n+  }\n+  \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+/* Free a block of dynamically allocated memory.  If we are in multi-threaded\n+   mode, it is ok to free it.  If not, we add it to the garbage heap to be\n+   freed later. */\n+\n+static void\n+sarray_free_garbage(void *vp)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  \n+  if (__objc_runtime_threads_alive == 1) {\n+    free(vp);\n+    if (first_free_data)\n+      sarray_remove_garbage();\n+  }\n+  else {\n+    *(void **)vp = first_free_data;\n+    first_free_data = vp;\n+  }\n+      \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+}\n+\n+/* sarray_at_put : copies data in such a way as to be thread reader safe. */\n void\n sarray_at_put(struct sarray* array, sidx index, void* element)\n {\n #ifdef OBJC_SPARSE3\n   struct sindex** the_index;\n+  struct sindex*  new_index;\n #endif\n   struct sbucket** the_bucket;\n+  struct sbucket*  new_bucket;\n #ifdef OBJC_SPARSE3\n   size_t ioffset;\n #endif\n@@ -96,22 +146,24 @@ sarray_at_put(struct sarray* array, sidx index, void* element)\n   if ((*the_index) == array->empty_index) {\n \n     /* The index was previously empty, allocate a new */\n-    *the_index = (struct sindex*)__objc_xmalloc(sizeof(struct sindex));\n-    memcpy(*the_index, array->empty_index, sizeof(struct sindex));\n-    (*the_index)->version = array->version;\n+    new_index = (struct sindex*)__objc_xmalloc(sizeof(struct sindex));\n+    memcpy(new_index, array->empty_index, sizeof(struct sindex));\n+    new_index->version.version = array->version.version;\n+    *the_index = new_index;                     /* Prepared for install. */\n     the_bucket = &((*the_index)->buckets[boffset]);\n-    nindices += 1;\n     \n-  } else if ((*the_index)->version != array->version) {\n+    nindices += 1;\n+  } else if ((*the_index)->version.version != array->version.version) {\n \n     /* This index must be lazy copied */\n     struct sindex* old_index = *the_index;\n-    *the_index = (struct sindex*)__objc_xmalloc(sizeof(struct sindex));\n-    memcpy( *the_index,old_index, sizeof(struct sindex));\n-    (*the_index)->version = array->version;\n+    new_index = (struct sindex*)__objc_xmalloc(sizeof(struct sindex));\n+    memcpy( new_index, old_index, sizeof(struct sindex));\n+    new_index->version.version = array->version.version;\n+    *the_index = new_index;                     /* Prepared for install. */\n     the_bucket = &((*the_index)->buckets[boffset]);\n-    nindices += 1;\n     \n+    nindices += 1;\n   }\n \n #endif /* OBJC_SPARSE3 */\n@@ -122,18 +174,22 @@ sarray_at_put(struct sarray* array, sidx index, void* element)\n \n     /* The bucket was previously empty (or something like that), */\n     /* allocate a new.  This is the effect of `lazy' allocation */  \n-    *the_bucket = (struct sbucket*)__objc_xmalloc(sizeof(struct sbucket));\n-    memcpy((void *) *the_bucket, (const void*)array->empty_bucket, sizeof(struct sbucket));\n-    (*the_bucket)->version = array->version;\n+    new_bucket = (struct sbucket*)__objc_xmalloc(sizeof(struct sbucket));\n+    memcpy((void *) new_bucket, (const void*)array->empty_bucket, sizeof(struct sbucket));\n+    new_bucket->version.version = array->version.version;\n+    *the_bucket = new_bucket;                   /* Prepared for install. */\n+    \n     nbuckets += 1;\n \n-  } else if ((*the_bucket)->version != array->version) {\n+  } else if ((*the_bucket)->version.version != array->version.version) {\n \n     /* Perform lazy copy. */\n     struct sbucket* old_bucket = *the_bucket;\n-    *the_bucket = (struct sbucket*)__objc_xmalloc(sizeof(struct sbucket));\n-    memcpy( *the_bucket,old_bucket, sizeof(struct sbucket));\n-    (*the_bucket)->version = array->version;\n+    new_bucket = (struct sbucket*)__objc_xmalloc(sizeof(struct sbucket));\n+    memcpy( new_bucket, old_bucket, sizeof(struct sbucket));\n+    new_bucket->version.version = array->version.version;\n+    *the_bucket = new_bucket;                   /* Prepared for install. */\n+    \n     nbuckets += 1;\n \n   }\n@@ -151,42 +207,48 @@ sarray_at_put_safe(struct sarray* array, sidx index, void* element)\n struct sarray* \n sarray_new (int size, void* default_element)\n {\n+  struct sarray* arr;\n #ifdef OBJC_SPARSE3\n   size_t num_indices = ((size-1)/(INDEX_CAPACITY))+1;\n+  struct sindex ** new_indices;\n #else /* OBJC_SPARSE2 */\n   size_t num_indices = ((size-1)/BUCKET_SIZE)+1;\n+  struct sbucket ** new_buckets;\n #endif\n   int counter;\n-  struct sarray* arr;\n \n   assert(size > 0);\n \n   /* Allocate core array */\n   arr = (struct sarray*) __objc_xmalloc(sizeof(struct sarray));\n-  arr->version = 0;\n-  narrays  += 1;\n+  arr->version.version = 0;\n   \n   /* Initialize members */\n #ifdef OBJC_SPARSE3\n   arr->capacity = num_indices*INDEX_CAPACITY;\n-  arr->indices = (struct sindex**) \n+  new_indices = (struct sindex**) \n     __objc_xmalloc(sizeof(struct sindex*)*num_indices);\n-  idxsize  += num_indices;\n \n   arr->empty_index = (struct sindex*) __objc_xmalloc(sizeof(struct sindex));\n-  arr->empty_index->version = 0;\n+  arr->empty_index->version.version = 0;\n+  \n+  narrays  += 1;\n+  idxsize  += num_indices;\n   nindices += 1;\n \n #else /* OBJC_SPARSE2 */\n   arr->capacity = num_indices*BUCKET_SIZE;\n-  arr->buckets = (struct sbucket**) \n+  new_buckets = (struct sbucket**) \n     __objc_xmalloc(sizeof(struct sbucket*)*num_indices);\n+  \n+  narrays  += 1;\n   idxsize  += num_indices;\n \n #endif\n \n   arr->empty_bucket = (struct sbucket*) __objc_xmalloc(sizeof(struct sbucket));\n-  arr->empty_bucket->version = 0;\n+  arr->empty_bucket->version.version = 0;\n+  \n   nbuckets += 1;\n \n   arr->ref_count = 1;\n@@ -200,20 +262,28 @@ sarray_new (int size, void* default_element)\n     arr->empty_index->buckets[counter] = arr->empty_bucket;\n \n   for (counter=0; counter<num_indices; counter++)\n-    arr->indices[counter] = arr->empty_index;\n+    new_indices[counter] = arr->empty_index;\n \n #else /* OBJC_SPARSE2 */\n \n   for (counter=0; counter<num_indices; counter++)\n-    arr->buckets[counter] = arr->empty_bucket;\n+    new_buckets[counter] = arr->empty_bucket;\n \n #endif\n-\n+  \n+#ifdef OBJC_SPARSE3\n+  arr->indices = new_indices;\n+#else /* OBJC_SPARSE2 */\n+  arr->buckets = new_buckets;\n+#endif\n+  \n   return arr;\n }\n \f\n \n-/* Reallocate the sparse array to hold `newsize' entries */\n+/* Reallocate the sparse array to hold `newsize' entries\n+   Note: We really allocate and then free.  We have to do this to ensure that\n+   any concurrent readers notice the update. */\n \n void \n sarray_realloc(struct sarray* array, int newsize)\n@@ -223,99 +293,90 @@ sarray_realloc(struct sarray* array, int newsize)\n   size_t new_max_index = ((newsize-1)/INDEX_CAPACITY);\n   size_t rounded_size = (new_max_index+1)*INDEX_CAPACITY;\n \n+  struct sindex ** new_indices;\n+  struct sindex ** old_indices;\n+  \n #else /* OBJC_SPARSE2 */\n   size_t old_max_index = (array->capacity-1)/BUCKET_SIZE;\n   size_t new_max_index = ((newsize-1)/BUCKET_SIZE);\n   size_t rounded_size = (new_max_index+1)*BUCKET_SIZE;\n \n+  struct sbucket ** new_buckets;\n+  struct sbucket ** old_buckets;\n+  \n #endif\n \n   int counter;\n \n   assert(newsize > 0);\n \n   /* The size is the same, just ignore the request */\n-  if(rounded_size == array->capacity)\n+  if(rounded_size <= array->capacity)\n     return;\n \n   assert(array->ref_count == 1);\t/* stop if lazy copied... */\n \n-  if(rounded_size < array->capacity) \n+  /* We are asked to extend the array -- allocate new bucket table, */\n+  /* and insert empty_bucket in newly allocated places. */\n+  if(rounded_size > array->capacity) \n     {\n+\n+#ifdef OBJC_SPARSE3\n+      new_max_index += 4;\n+      rounded_size = (new_max_index+1)*INDEX_CAPACITY;\n+      \n+#else /* OBJC_SPARSE2 */\n+      new_max_index += 4;\n+      rounded_size = (new_max_index+1)*BUCKET_SIZE;\n+#endif\n+      \n       /* update capacity */\n       array->capacity = rounded_size;\n \n-      /* free buckets above new_max_index */\n-      for(counter = old_max_index; counter > new_max_index; counter-- ) {\n #ifdef OBJC_SPARSE3\n-\tstruct sindex* idx = array->indices[counter];\n-\tif((idx != array->empty_index) && (idx->version == array->version)) {\n-\t  int c2; \n-\t  for(c2=0; c2<INDEX_SIZE; c2++) {\n-\t    struct sbucket* bkt = idx->buckets[c2];\n-\t    if((bkt != array->empty_bucket) && (bkt->version == array->version))\n-\t      {\n-\t\tfree(bkt);\n-\t\tnbuckets -= 1;\n-\t      }\n-\t  }\n-\t  free(idx);\n-\t  nindices -= 1;\n-\t}\n+      /* alloc to force re-read by any concurrent readers. */\n+      old_indices = array->indices;\n+      new_indices = (struct sindex**)\n+\t__objc_xmalloc((new_max_index+1)*sizeof(struct sindex*));\n #else /* OBJC_SPARSE2 */\n-\tstruct sbucket* bkt = array->buckets[counter];\n-\tif ((bkt != array->empty_bucket) && (bkt->version == array->version))\n-\t  {\n-\t    free(bkt);\n-\t    nbuckets -= 1;\n-\t  }\n+      old_buckets = array->buckets;\n+      new_buckets = (struct sbucket**)\n+\t__objc_xmalloc((new_max_index+1)*sizeof(struct sbucket*));\n #endif\n-      }\n-\t  \n+\n+      /* copy buckets below old_max_index (they are still valid) */\n+      for(counter = 0; counter <= old_max_index; counter++ ) {\n #ifdef OBJC_SPARSE3\n-      /* realloc to free the space above new_max_index */\n-      array->indices = (struct sindex**)\n-\t__objc_xrealloc(array->indices, \n-\t\t\t(new_max_index+1)*sizeof(struct sindex*));\n+\tnew_indices[counter] = old_indices[counter];\n #else /* OBJC_SPARSE2 */\n-      array->buckets = (struct sbucket**)\n-\t__objc_xrealloc(array->buckets, \n-\t\t\t(new_max_index+1)*sizeof(struct sbucket*));\n-#endif      \n-      idxsize -= (old_max_index-new_max_index);\n-\n-      return;\n-    }\n-\n-  /* We are asked to extend the array -- reallocate the bucket table, */\n-  /* and insert empty_bucket in newly allocated places. */\n-  if(rounded_size > array->capacity) \n-    {\n-      /* update capacity */\n-      array->capacity = rounded_size;\n+\tnew_buckets[counter] = old_buckets[counter];\n+#endif\n+      }\n \n #ifdef OBJC_SPARSE3\n-      /* realloc to make room in table above old_max_index */\n-      array->indices = (struct sindex**)\n-\t__objc_xrealloc(array->indices, \n-\t\t\t(new_max_index+1)*sizeof(struct sindex*));\n-\n       /* reset entries above old_max_index to empty_bucket */\n       for(counter = old_max_index+1; counter <= new_max_index; counter++)\n-\tarray->indices[counter] = array->empty_index;\n-\n+\tnew_indices[counter] = array->empty_index;\n #else /* OBJC_SPARSE2 */\n-\n-      /* realloc to make room in table above old_max_index */\n-      array->buckets = (struct sbucket**)\n-\t__objc_xrealloc(array->buckets, \n-\t\t\t(new_max_index+1)*sizeof(struct sbucket*));\n-\n       /* reset entries above old_max_index to empty_bucket */\n       for(counter = old_max_index+1; counter <= new_max_index; counter++)\n-\tarray->buckets[counter] = array->empty_bucket;\n+\tnew_buckets[counter] = array->empty_bucket;\n+#endif\n+      \n+#ifdef OBJC_SPARSE3\n+      /* install the new indices */\n+      array->indices = new_indices;\n+#else /* OBJC_SPARSE2 */\n+      array->buckets = new_buckets;\n+#endif\n \n+#ifdef OBJC_SPARSE3\n+      /* free the old indices */\n+      sarray_free_garbage(old_indices);\n+#else /* OBJC_SPARSE2 */\n+      sarray_free_garbage(old_buckets);\n #endif\n+      \n       idxsize += (new_max_index-old_max_index);\n       return;\n     }\n@@ -326,10 +387,13 @@ sarray_realloc(struct sarray* array, int newsize)\n \n void \n sarray_free(struct sarray* array) {\n+\n #ifdef OBJC_SPARSE3\n   size_t old_max_index = (array->capacity-1)/INDEX_CAPACITY;\n+  struct sindex ** old_indices;\n #else\n   size_t old_max_index = (array->capacity-1)/BUCKET_SIZE;\n+  struct sbucket ** old_buckets;\n #endif\n   int counter = 0;\n \n@@ -338,65 +402,73 @@ sarray_free(struct sarray* array) {\n   if(--(array->ref_count) != 0)\t/* There exists copies of me */\n     return;\n \n+#ifdef OBJC_SPARSE3\n+  old_indices = array->indices;\n+#else\n+  old_buckets = array->buckets;\n+#endif\n+  \n   if((array->is_copy_of) && ((array->is_copy_of->ref_count - 1) == 0))\n     sarray_free(array->is_copy_of);\n \n   /* Free all entries that do not point to empty_bucket */\n   for(counter = 0; counter <= old_max_index; counter++ ) {\n #ifdef OBJC_SPARSE3\n-    struct sindex* idx = array->indices[counter];\n-    if((idx != array->empty_index) && (idx->version == array->version)) {\n+    struct sindex* idx = old_indices[counter];\n+    if((idx != array->empty_index) &&\n+       (idx->version.version == array->version.version)) {\n       int c2; \n       for(c2=0; c2<INDEX_SIZE; c2++) {\n \tstruct sbucket* bkt = idx->buckets[c2];\n-\tif((bkt != array->empty_bucket) && (bkt->version == array->version))\n+\tif((bkt != array->empty_bucket) &&\n+\t   (bkt->version.version == array->version.version))\n \t  {\n-\t    free(bkt);\n+\t    sarray_free_garbage(bkt);\n \t    nbuckets -= 1;\n \t  }\n       }\n-      free(idx);\n+      sarray_free_garbage(idx);\n       nindices -= 1;\n     }\n #else /* OBJC_SPARSE2 */\n     struct sbucket* bkt = array->buckets[counter];\n-    if ((bkt != array->empty_bucket) && (bkt->version == array->version))\n+    if ((bkt != array->empty_bucket) &&\n+\t(bkt->version.version == array->version.version))\n       {\n-\tfree(bkt);\n+\tsarray_free_garbage(bkt);\n \tnbuckets -= 1;\n       }\n #endif\n   }\n \t\n #ifdef OBJC_SPARSE3  \n   /* free empty_index */\n-  if(array->empty_index->version == array->version) {\n-    free(array->empty_index);\n+  if(array->empty_index->version.version == array->version.version) {\n+    sarray_free_garbage(array->empty_index);\n     nindices -= 1;\n   }\n #endif\n \n   /* free empty_bucket */\n-  if(array->empty_bucket->version == array->version) {\n-    free(array->empty_bucket);\n+  if(array->empty_bucket->version.version == array->version.version) {\n+    sarray_free_garbage(array->empty_bucket);\n     nbuckets -= 1;\n   }\n+  idxsize -= (old_max_index+1);\n+  narrays -= 1;\n \n #ifdef OBJC_SPARSE3\n   /* free bucket table */\n-  free(array->indices);\n-  idxsize -= (old_max_index+1);\n+  sarray_free_garbage(array->indices);\n \n #else\n   /* free bucket table */\n-  free(array->buckets);\n-  idxsize -= (old_max_index+1);\n+  sarray_free_garbage(array->buckets);\n \n #endif\n-\n+  \n   /* free array */\n-  free(array);\n-  narrays -= 1;\n+  sarray_free_garbage(array);\n }\n \n /* This is a lazy copy.  Only the core of the structure is actually */\n@@ -405,37 +477,46 @@ sarray_free(struct sarray* array) {\n struct sarray* \n sarray_lazy_copy(struct sarray* oarr)\n {\n+  struct sarray* arr;\n+\n #ifdef OBJC_SPARSE3\n   size_t num_indices = ((oarr->capacity-1)/INDEX_CAPACITY)+1;\n+  struct sindex ** new_indices;\n #else /* OBJC_SPARSE2 */\n   size_t num_indices = ((oarr->capacity-1)/BUCKET_SIZE)+1;\n+  struct sbucket ** new_buckets;\n #endif\n-  struct sarray* arr;\n \n   /* Allocate core array */\n-  arr = (struct sarray*) __objc_xmalloc(sizeof(struct sarray));\n-  memcpy( arr,oarr, sizeof(struct sarray));\n-  arr->version = oarr->version + 1;\n-  arr->is_copy_of = oarr;\n-  oarr->ref_count += 1;\n+  arr = (struct sarray*) __objc_xmalloc(sizeof(struct sarray)); /* !!! */\n+  arr->version.version = oarr->version.version + 1;\n+#ifdef OBJC_SPARSE3\n+  arr->empty_index = oarr->empty_index;\n+#endif\n+  arr->empty_bucket = oarr->empty_bucket;\n   arr->ref_count = 1;\n+  oarr->ref_count += 1;\n+  arr->is_copy_of = oarr;\n+  arr->capacity = oarr->capacity;\n   \n #ifdef OBJC_SPARSE3\n   /* Copy bucket table */\n-  arr->indices = (struct sindex**) \n+  new_indices = (struct sindex**) \n     __objc_xmalloc(sizeof(struct sindex*)*num_indices);\n-  memcpy( arr->indices,oarr->indices, \n+  memcpy( new_indices,oarr->indices, \n \tsizeof(struct sindex*)*num_indices);\n+  arr->indices = new_indices;\n #else \n   /* Copy bucket table */\n-  arr->buckets = (struct sbucket**) \n+  new_buckets = (struct sbucket**) \n     __objc_xmalloc(sizeof(struct sbucket*)*num_indices);\n-  memcpy( arr->buckets,oarr->buckets, \n+  memcpy( new_buckets,oarr->buckets, \n \tsizeof(struct sbucket*)*num_indices);\n+  arr->buckets = new_buckets;\n #endif\n \n   idxsize += num_indices;\n   narrays += 1;\n-\n+  \n   return arr;\n }"}]}