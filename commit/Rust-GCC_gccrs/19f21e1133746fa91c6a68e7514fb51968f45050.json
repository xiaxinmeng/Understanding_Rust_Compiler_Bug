{"sha": "19f21e1133746fa91c6a68e7514fb51968f45050", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlmMjFlMTEzMzc0NmZhOTFjNmE2OGU3NTE0ZmI1MTk2OGY0NTA1MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-23T12:27:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-07-23T12:27:37Z"}, "message": "[multiple changes]\n\n2009-07-23  Yannick Moy  <moy@adacore.com>\n\n\t* s-regexp.adb (Check_Well_Formed_Pattern): Called before compiling the\n\tpattern.\n\t(Raise_Exception_If_No_More_Chars): Remove extra blank in exception\n\tstring.\n\t(Raise_Exception): Ditto.\n\n2009-07-23  Olivier Hainque  <hainque@adacore.com>\n\n\t* g-sse.ads: Simplify comment.\n\nFrom-SVN: r150000", "tree": {"sha": "d72eed2b844820d6ec143ac42455485d1db1d8a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d72eed2b844820d6ec143ac42455485d1db1d8a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19f21e1133746fa91c6a68e7514fb51968f45050", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19f21e1133746fa91c6a68e7514fb51968f45050", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19f21e1133746fa91c6a68e7514fb51968f45050", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19f21e1133746fa91c6a68e7514fb51968f45050/comments", "author": null, "committer": null, "parents": [{"sha": "84d60eea81f358bb5e81cda00631786d05653ff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84d60eea81f358bb5e81cda00631786d05653ff0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84d60eea81f358bb5e81cda00631786d05653ff0"}], "stats": {"total": 298, "additions": 291, "deletions": 7}, "files": [{"sha": "4cd15a948277f84a0f342968f2421a4805771073", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19f21e1133746fa91c6a68e7514fb51968f45050/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19f21e1133746fa91c6a68e7514fb51968f45050/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=19f21e1133746fa91c6a68e7514fb51968f45050", "patch": "@@ -1,3 +1,15 @@\n+2009-07-23  Yannick Moy  <moy@adacore.com>\n+\n+\t* s-regexp.adb (Check_Well_Formed_Pattern): Called before compiling the\n+\tpattern.\n+\t(Raise_Exception_If_No_More_Chars): Remove extra blank in exception\n+\tstring.\n+\t(Raise_Exception): Ditto.\n+\n+2009-07-23  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* g-sse.ads: Simplify comment.\n+\n 2009-07-23  Olivier Hainque  <hainque@adacore.com>\n \n \t* g-ssinty.ads: New unit. GNAT.SSE.Internal_Types. Factorize"}, {"sha": "f669f2e5e0ff93208a7eb07ab8780824bff83b94", "filename": "gcc/ada/g-sse.ads", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19f21e1133746fa91c6a68e7514fb51968f45050/gcc%2Fada%2Fg-sse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19f21e1133746fa91c6a68e7514fb51968f45050/gcc%2Fada%2Fg-sse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-sse.ads?ref=19f21e1133746fa91c6a68e7514fb51968f45050", "patch": "@@ -82,11 +82,7 @@\n --     end if;\n --  end;\n \n---  Use of Unchecked_Union is very tempting, however hits difficulties with\n---  e.g. implicit front-end expanded equality operators, which typically\n---  feature a subcase comparing the m128 components, not supported by the\n---  middle-end. This needs more explanation, should it be fixed ??? It\n---  reads like a bug in this paragraph.\n+--  Use of Unchecked_Union to perform the overlays is not supported.\n \n package GNAT.SSE is\n    type Float32 is new Float;"}, {"sha": "02d0a99f492201b1f4a0a418467adb8b1b5e8170", "filename": "gcc/ada/s-regexp.adb", "status": "modified", "additions": 278, "deletions": 2, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19f21e1133746fa91c6a68e7514fb51968f45050/gcc%2Fada%2Fs-regexp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19f21e1133746fa91c6a68e7514fb51968f45050/gcc%2Fada%2Fs-regexp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regexp.adb?ref=19f21e1133746fa91c6a68e7514fb51968f45050", "patch": "@@ -129,6 +129,14 @@ package body System.Regexp is\n       --  Number of significant characters in the regular expression.\n       --  This total does not include special operators, such as *, (, ...\n \n+      procedure Check_Well_Formed_Pattern;\n+      --  Check that the pattern to compile is well-formed, so that\n+      --  subsequent code can rely on this without performing each time\n+      --  the checks to avoid accessing the pattern outside its bounds.\n+      --  Except that, not all well-formedness rules are checked.\n+      --  In particular, the rules about special characters not being\n+      --  treated as regular characters are not checked.\n+\n       procedure Create_Mapping;\n       --  Creates a mapping between characters in the regexp and columns\n       --  in the tables representing the regexp. Test that the regexp is\n@@ -180,6 +188,270 @@ package body System.Regexp is\n       pragma No_Return (Raise_Exception);\n       --  Raise an exception, indicating an error at character Index in S\n \n+      -------------------------------\n+      -- Check_Well_Formed_Pattern --\n+      -------------------------------\n+\n+      procedure Check_Well_Formed_Pattern is\n+\n+         J                 : Integer := S'First;\n+         Past_Elmt         : Boolean := False;\n+         --  Set to True everywhere an elmt has been parsed, if Glob=False,\n+         --  meaning there can be now an occurence of '*', '+' and '?'.\n+         Past_Term         : Boolean := False;\n+         --  Set to True everywhere a term has been parsed, if Glob=False,\n+         --  meaning there can be now an occurence of '|'.\n+         Parenthesis_Level : Integer := 0;\n+         Curly_Level       : Integer := 0;\n+         Last_Open         : Integer := S'First - 1;\n+         --  The last occurence of an opening parenthesis, if Glob=False,\n+         --  or the last occurence of an opening curly brace, if Glob=True.\n+\n+         procedure Raise_Exception_If_No_More_Chars (K : Integer := 0);\n+\n+         --------------------------------------\n+         -- Raise_Exception_If_No_More_Chars --\n+         --------------------------------------\n+\n+         procedure Raise_Exception_If_No_More_Chars (K : Integer := 0) is\n+         begin\n+            if J + K > S'Last then\n+               Raise_Exception\n+                 (\"Ill-formed pattern while parsing\", J);\n+            end if;\n+         end Raise_Exception_If_No_More_Chars;\n+\n+      --  Start of processing for Check_Well_Formed_Pattern\n+\n+      begin\n+         while J <= S'Last loop\n+            case S (J) is\n+               when Open_Bracket =>\n+                  J := J + 1;\n+                  Raise_Exception_If_No_More_Chars;\n+\n+                  if not Glob then\n+                     if S (J) = '^' then\n+                        J := J + 1;\n+                        Raise_Exception_If_No_More_Chars;\n+                     end if;\n+                  end if;\n+\n+                  --  The first character never has a special meaning\n+\n+                  if S (J) = ']' or else S (J) = '-' then\n+                     J := J + 1;\n+                     Raise_Exception_If_No_More_Chars;\n+                  end if;\n+\n+                  --  The set of characters cannot be empty\n+\n+                  if S (J) = ']' then\n+                     Raise_Exception\n+                       (\"Set of characters cannot be empty in regular \"\n+                          & \"expression\", J);\n+                  end if;\n+\n+                  declare\n+                     Possible_Range_Start : Boolean := True;\n+                     --  Set to True everywhere a range character '-'\n+                     --  can occur.\n+                  begin\n+                     loop\n+                        exit when S (J) = Close_Bracket;\n+\n+                        --  The current character should be followed by\n+                        --  a closing bracket.\n+\n+                        Raise_Exception_If_No_More_Chars (1);\n+\n+                        if S (J) = '-'\n+                          and then S (J + 1) /= Close_Bracket\n+                        then\n+                           if not Possible_Range_Start then\n+                              Raise_Exception\n+                                (\"No mix of ranges is allowed in \"\n+                                   & \"regular expression\", J);\n+                           end if;\n+\n+                           J := J + 1;\n+                           Raise_Exception_If_No_More_Chars;\n+\n+                           --  Range cannot be followed by '-' character,\n+                           --  except as last character in the set.\n+\n+                           Possible_Range_Start := False;\n+                        else\n+                           Possible_Range_Start := True;\n+                        end if;\n+\n+                        if S (J) = '\\' then\n+                           J := J + 1;\n+                           Raise_Exception_If_No_More_Chars;\n+                        end if;\n+\n+                        J := J + 1;\n+                     end loop;\n+                  end;\n+\n+                  --  A closing bracket can end an elmt or term\n+\n+                  Past_Elmt := True;\n+                  Past_Term := True;\n+\n+               when Close_Bracket =>\n+                  --  A close bracket must follow a open_bracket,\n+                  --  and cannot be found alone on the line.\n+\n+                  Raise_Exception\n+                    (\"Incorrect character ']' in regular expression\", J);\n+\n+               when '\\' =>\n+                  if J < S'Last then\n+                     J := J + 1;\n+\n+                     --  Any character can be an elmt or a term\n+\n+                     Past_Elmt := True;\n+                     Past_Term := True;\n+                  else\n+                     --  \\ not allowed at the end of the regexp\n+\n+                     Raise_Exception\n+                       (\"Incorrect character '\\' in regular expression\", J);\n+                  end if;\n+\n+               when Open_Paren =>\n+                  if not Glob then\n+                     Parenthesis_Level := Parenthesis_Level + 1;\n+                     Last_Open := J;\n+\n+                     --  An open parenthesis does not end an elmt or term\n+\n+                     Past_Elmt := False;\n+                     Past_Term := False;\n+                  end if;\n+\n+               when Close_Paren =>\n+                  if not Glob then\n+                     Parenthesis_Level := Parenthesis_Level - 1;\n+\n+                     if Parenthesis_Level < 0 then\n+                        Raise_Exception\n+                          (\"')' is not associated with '(' in regular \"\n+                           & \"expression\", J);\n+                     end if;\n+\n+                     if J = Last_Open + 1 then\n+                        Raise_Exception\n+                          (\"Empty parentheses not allowed in regular \"\n+                           & \"expression\", J);\n+                     end if;\n+\n+                     if not Past_Term then\n+                        Raise_Exception\n+                          (\"Closing parenthesis not allowed here in regular \"\n+                             & \"expression\", J);\n+                     end if;\n+\n+                     --  A closing parenthesis can end an elmt or term\n+\n+                     Past_Elmt := True;\n+                     Past_Term := True;\n+                  end if;\n+\n+               when '{' =>\n+                  if Glob then\n+                     Curly_Level := Curly_Level + 1;\n+                     Last_Open := J;\n+                  else\n+                     --  Any character can be an elmt or a term\n+\n+                     Past_Elmt := True;\n+                     Past_Term := True;\n+                  end if;\n+\n+                  --  No need to check for ',' as the code always accepts them\n+\n+               when '}' =>\n+                  if Glob then\n+                     Curly_Level := Curly_Level - 1;\n+\n+                     if Curly_Level < 0 then\n+                        Raise_Exception\n+                          (\"'}' is not associated with '{' in regular \"\n+                           & \"expression\", J);\n+                     end if;\n+\n+                     if J = Last_Open + 1 then\n+                        Raise_Exception\n+                          (\"Empty curly braces not allowed in regular \"\n+                           & \"expression\", J);\n+                     end if;\n+                  else\n+                     --  Any character can be an elmt or a term\n+\n+                     Past_Elmt := True;\n+                     Past_Term := True;\n+                  end if;\n+\n+               when '*' | '?' | '+' =>\n+                  if not Glob then\n+                     --  These operators must apply to an elmt sub-expression,\n+                     --  and cannot be found if one has not just been parsed.\n+\n+                     if not Past_Elmt then\n+                        Raise_Exception\n+                          (\"'*', '+' and '?' operators must be \"\n+                           & \"applied to an element in regular expression\", J);\n+                     end if;\n+\n+                     Past_Elmt := False;\n+                     Past_Term := True;\n+                  end if;\n+\n+               when '|' =>\n+                  if not Glob then\n+                     --  This operator must apply to a term sub-expression,\n+                     --  and cannot be found if one has not just been parsed.\n+\n+                     if not Past_Term then\n+                        Raise_Exception\n+                          (\"'|' operator must be \"\n+                           & \"applied to a term in regular expression\", J);\n+                     end if;\n+\n+                     Past_Elmt := False;\n+                     Past_Term := False;\n+                  end if;\n+\n+               when others =>\n+                  if not Glob then\n+                     --  Any character can be an elmt or a term\n+\n+                     Past_Elmt := True;\n+                     Past_Term := True;\n+                  end if;\n+            end case;\n+\n+            J := J + 1;\n+         end loop;\n+\n+         --  A closing parenthesis must follow an open parenthesis\n+\n+         if Parenthesis_Level /= 0 then\n+            Raise_Exception\n+              (\"'(' must always be associated with a ')'\", J);\n+         end if;\n+\n+         --  A closing curly brace must follow an open curly brace\n+\n+         if Curly_Level /= 0 then\n+            Raise_Exception\n+              (\"'{' must always be associated with a '}'\", J);\n+         end if;\n+      end Check_Well_Formed_Pattern;\n+\n       --------------------\n       -- Create_Mapping --\n       --------------------\n@@ -1224,7 +1496,7 @@ package body System.Regexp is\n \n       procedure Raise_Exception (M : String; Index : Integer) is\n       begin\n-         raise Error_In_Regexp with M & \" at offset \" & Index'Img;\n+         raise Error_In_Regexp with M & \" at offset\" & Index'Img;\n       end Raise_Exception;\n \n    --  Start of processing for Compile\n@@ -1247,12 +1519,16 @@ package body System.Regexp is\n          System.Case_Util.To_Lower (S);\n       end if;\n \n+      --  Check the pattern is well-formed before any treatment\n+\n+      Check_Well_Formed_Pattern;\n+\n       Create_Mapping;\n \n       --  Creates the primary table\n \n       declare\n-         Table : Regexp_Array_Access;\n+         Table       : Regexp_Array_Access;\n          Num_States  : State_Index;\n          Start_State : State_Index;\n          End_State   : State_Index;"}]}