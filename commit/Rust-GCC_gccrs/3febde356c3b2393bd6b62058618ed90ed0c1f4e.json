{"sha": "3febde356c3b2393bd6b62058618ed90ed0c1f4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZlYmRlMzU2YzNiMjM5M2JkNmI2MjA1ODYxOGVkOTBlZDBjMWY0ZQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2004-10-07T22:06:23Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-10-07T22:06:23Z"}, "message": "tr1: New.\n\n\n2004-10-07  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/tr1: New.\n\t* include/tr1/array: New.\n\t* include/Makefile.am (tr1_headers): New.\n\t(stamp-tr1): New.\n\t(install-headers): New.\n\t(allstamped): Add stamp-tr1.\n\n\t* include/ext/array_allocator.h: New.\n\t* include/Makefile.am: Add.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/ext/array_allocator/1.cc: New.\n\t* testsuite/ext/array_allocator/2.cc: New.\n\nFrom-SVN: r88711", "tree": {"sha": "72831aac65ca4881122762d9733f6ba6048187f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72831aac65ca4881122762d9733f6ba6048187f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3febde356c3b2393bd6b62058618ed90ed0c1f4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3febde356c3b2393bd6b62058618ed90ed0c1f4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3febde356c3b2393bd6b62058618ed90ed0c1f4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3febde356c3b2393bd6b62058618ed90ed0c1f4e/comments", "author": null, "committer": null, "parents": [{"sha": "446e8778259f7495567358b8d3d98ca7c910ab80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/446e8778259f7495567358b8d3d98ca7c910ab80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/446e8778259f7495567358b8d3d98ca7c910ab80"}], "stats": {"total": 534, "additions": 532, "deletions": 2}, "files": [{"sha": "daae169960ef98551327ca0ab223ecbcc3443d60", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3febde356c3b2393bd6b62058618ed90ed0c1f4e", "patch": "@@ -1,3 +1,18 @@\n+2004-10-07  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/tr1: New.\n+\t* include/tr1/array: New.\n+\t* include/Makefile.am (tr1_headers): New.\n+\t(stamp-tr1): New.\n+\t(install-headers): New.\n+\t(allstamped): Add stamp-tr1.\n+\n+\t* include/ext/array_allocator.h: New.\n+\t* include/Makefile.am: Add.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/ext/array_allocator/1.cc: New.\n+\t* testsuite/ext/array_allocator/2.cc: New.\n+\n 2004-10-07  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* testsuite/lib/libstdc++.exp (libstdc++_exit): New proc."}, {"sha": "ffa16d5aaf88043f4a78518db85414b4b0e2114a", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=3febde356c3b2393bd6b62058618ed90ed0c1f4e", "patch": "@@ -201,6 +201,7 @@ ext_srcdir = ${glibcxx_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/array_allocator.h \\\n \t${ext_srcdir}/bitmap_allocator.h \\\n \t${ext_srcdir}/debug_allocator.h \\\n \t${ext_srcdir}/enc_filebuf.h \\\n@@ -224,6 +225,11 @@ ext_headers = \\\n \t${ext_srcdir}/hash_fun.h \\\n \t${ext_srcdir}/hashtable.h\n \n+tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n+tr1_builddir = ./tr1\n+tr1_headers = \\\n+\t${tr1_srcdir}/array\n+\n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)\n c_base_builddir = .\n@@ -380,7 +386,7 @@ endif\n # CLEANFILES and all-local are kept up-to-date.\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_compatibility \\\n-\tstamp-backward stamp-ext stamp-debug stamp-host\n+\tstamp-backward stamp-ext stamp-tr1 stamp-debug stamp-host\n \n # List of all files that are created by explicit building, editing, or\n # catenation.\n@@ -459,6 +465,16 @@ stamp-ext: ${ext_headers}\n \tfi ;\\\n \t$(STAMP) stamp-ext\n \n+\n+stamp-tr1: ${tr1_headers}\n+\t@if [ ! -d \"${tr1_builddir}\" ]; then \\\n+\t    mkdir -p ${tr1_builddir} ;\\\n+\tfi ;\\\n+\tif [ ! -f stamp-tr1 ]; then \\\n+\t  (cd ${tr1_builddir} && $(LN_S) $? . || true) ;\\\n+\tfi ;\\\n+\t$(STAMP) stamp-tr1\n+\n stamp-debug: ${debug_headers}\n \t@if [ ! -d \"${debug_builddir}\" ]; then \\\n \t  mkdir -p ${debug_builddir} ;\\\n@@ -596,6 +612,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${ext_builddir}\n \tfor file in ${ext_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${ext_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_builddir}\n+\tfor file in ${tr1_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${c_base_builddir}\n \tfor file in ${c_base_headers_rename}; do \\\n \t  $(INSTALL_DATA) ${c_base_builddir}/$${file} $(DESTDIR)${gxx_include_dir}/${c_base_builddir}; done"}, {"sha": "4a2ec864dd8729a5e2ed9960b43fe072311baf15", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=3febde356c3b2393bd6b62058618ed90ed0c1f4e", "patch": "@@ -418,6 +418,7 @@ ext_srcdir = ${glibcxx_srcdir}/include/ext\n ext_builddir = ./ext\n ext_headers = \\\n \t${ext_srcdir}/algorithm \\\n+\t${ext_srcdir}/array_allocator.h \\\n \t${ext_srcdir}/bitmap_allocator.h \\\n \t${ext_srcdir}/debug_allocator.h \\\n \t${ext_srcdir}/enc_filebuf.h \\\n@@ -441,6 +442,11 @@ ext_headers = \\\n \t${ext_srcdir}/hash_fun.h \\\n \t${ext_srcdir}/hashtable.h\n \n+tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n+tr1_builddir = ./tr1\n+tr1_headers = \\\n+\t${tr1_srcdir}/array\n+\n \n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)\n@@ -593,7 +599,7 @@ PCHFLAGS = -Winvalid-pch -Wno-deprecated -x c++-header $(CXXFLAGS)\n # CLEANFILES and all-local are kept up-to-date.\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_compatibility \\\n-\tstamp-backward stamp-ext stamp-debug stamp-host\n+\tstamp-backward stamp-ext stamp-tr1 stamp-debug stamp-host\n \n \n # List of all files that are created by explicit building, editing, or\n@@ -841,6 +847,15 @@ stamp-ext: ${ext_headers}\n \tfi ;\\\n \t$(STAMP) stamp-ext\n \n+stamp-tr1: ${tr1_headers}\n+\t@if [ ! -d \"${tr1_builddir}\" ]; then \\\n+\t    mkdir -p ${tr1_builddir} ;\\\n+\tfi ;\\\n+\tif [ ! -f stamp-tr1 ]; then \\\n+\t  (cd ${tr1_builddir} && $(LN_S) $? . || true) ;\\\n+\tfi ;\\\n+\t$(STAMP) stamp-tr1\n+\n stamp-debug: ${debug_headers}\n \t@if [ ! -d \"${debug_builddir}\" ]; then \\\n \t  mkdir -p ${debug_builddir} ;\\\n@@ -972,6 +987,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${ext_builddir}\n \tfor file in ${ext_headers}; do \\\n \t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${ext_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${tr1_builddir}\n+\tfor file in ${tr1_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${tr1_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${c_base_builddir}\n \tfor file in ${c_base_headers_rename}; do \\\n \t  $(INSTALL_DATA) ${c_base_builddir}/$${file} $(DESTDIR)${gxx_include_dir}/${c_base_builddir}; done"}, {"sha": "22564c821d92a02a5f4bf1f5a2fa1a417e99d013", "filename": "libstdc++-v3/include/ext/array_allocator.h", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Finclude%2Fext%2Farray_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Finclude%2Fext%2Farray_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Farray_allocator.h?ref=3febde356c3b2393bd6b62058618ed90ed0c1f4e", "patch": "@@ -0,0 +1,141 @@\n+// array allocator -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _ARRAY_ALLOCATOR_H\n+#define _ARRAY_ALLOCATOR_H 1\n+\n+#include <cstddef>\n+#include <new>\n+#include <tr1/array>\n+\n+namespace __gnu_cxx\n+{\n+ template<typename _Tp>\n+    class array_allocator_base\n+    {\n+    public:\n+      typedef size_t     size_type;\n+      typedef ptrdiff_t  difference_type;\n+      typedef _Tp*       pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp        value_type;\n+\n+      pointer\n+      address(reference __x) const { return &__x; }\n+\n+      const_pointer\n+      address(const_reference __x) const { return &__x; }\n+\n+      void\n+      deallocate(pointer __p, size_type)\n+      { \n+\t// Does nothing.\n+      }\n+\n+      size_type\n+      max_size() const throw() \n+      { return size_t(-1) / sizeof(_Tp); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 402. wrong new expression in [some_] allocator::construct\n+      void \n+      construct(pointer __p, const _Tp& __val) \n+      { ::new(__p) value_type(__val); }\n+\n+      void \n+      destroy(pointer __p) { __p->~_Tp(); }\n+    };  \n+\n+  /**\n+   *  @brief  An allocator that uses previously allocated memory.\n+   *  This memory can be externally, globally, or otherwise allocated.\n+   *\n+   *  (See @link Allocators allocators info @endlink for more.)\n+   */\n+  template<typename _Tp, typename _Array = std::tr1::array<_Tp> >\n+    class array_allocator : public array_allocator_base<_Tp>\n+    {\n+    public:\n+      typedef size_t     size_type;\n+      typedef ptrdiff_t  difference_type;\n+      typedef _Tp*       pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp&       reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp        value_type;\n+\n+      typedef _Array\tarray_type;\n+\n+      array_type* _M_array;\n+      \n+     template<typename _Tp1, typename _Array1 = _Array>\n+        struct rebind\n+        { typedef array_allocator<_Tp1, _Array1> other; };\n+\n+      array_allocator(array_type* __array = NULL) throw() \n+      : _M_array(__array) \n+      { }\n+\n+      array_allocator(const array_allocator& __o)  throw() \n+      : _M_array(__o._M_array) { }\n+\n+      template<typename _Tp1, typename _Array1>\n+        array_allocator(const array_allocator<_Tp1, _Array1>&) throw()\n+\t: _M_array(NULL) { }\n+\n+      ~array_allocator() throw() { }\n+\n+      pointer\n+      allocate(size_type __n, const void* = 0)\n+      {\n+\tstatic size_type used;\n+\tif (__builtin_expect(used > array_type::_S_index, false))\n+\t  throw std::bad_alloc();\n+\tpointer __ret = _M_array->begin() + used;\n+\tused += __n;\n+\treturn __ret;\n+      }\n+    };\n+\n+  template<typename _Tp, typename _Array>\n+    inline bool\n+    operator==(const array_allocator<_Tp, _Array>&,\n+\t       const array_allocator<_Tp, _Array>&)\n+    { return true; }\n+  \n+  template<typename _Tp, typename _Array>\n+    inline bool\n+    operator!=(const array_allocator<_Tp, _Array>&, \n+\t       const array_allocator<_Tp, _Array>&)\n+    { return false; }\n+} // namespace __gnu_cxx\n+\n+#endif"}, {"sha": "e41fced7f3b7f1fae12ae4905dd62af431c7b8d0", "filename": "libstdc++-v3/include/tr1/array", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Farray?ref=3febde356c3b2393bd6b62058618ed90ed0c1f4e", "patch": "@@ -0,0 +1,200 @@\n+// class template array -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _ARRAY\n+#define _ARRAY 1\n+\n+#include <new>\n+#include <iterator>\n+\n+//namespace std::tr1\n+namespace std\n+{\n+namespace tr1\n+{\n+  // [6.2.2] Class template array template\n+  // Requires complete type _Tp.\n+  // Use of char array allows _Tp to skirt default constructable requirement.\n+  template<typename _Tp, size_t _Nm = 1>\n+    struct array\n+    {\n+      enum { _S_index = _Nm };\n+\n+      typedef _Tp \t    \t\t\tvalue_type;\n+      typedef value_type&                   \treference;\n+      typedef const value_type&             \tconst_reference;\n+      typedef value_type*          \t\titerator;\n+      typedef const value_type*\t\t\tconst_iterator;\n+      typedef size_t                    \tsize_type;\n+      typedef ptrdiff_t                     \tdifference_type;\n+      typedef std::reverse_iterator<iterator>\treverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>\tconst_reverse_iterator;\n+      typedef char layout_type[sizeof(_Tp)] __attribute__ ((aligned(__alignof__(_Tp))));\n+\n+      layout_type _M_instance[_Nm];\n+\n+      // No explicit construct/copy/destroy for aggregate type.\n+\n+      void \n+      assign(const value_type& u); \n+\n+      void \n+      swap(array&);\n+\n+      // Iterators.\n+      iterator \n+      begin()\n+      { return reinterpret_cast<iterator>(&_M_instance[0]); }\n+\n+      const_iterator \n+      begin() const \n+      { return reinterpret_cast<const_iterator>(&_M_instance[0]); }\n+\n+      iterator \n+      end() \n+      { return reinterpret_cast<iterator>(&_M_instance[_S_index - 1]); }\n+\n+      const_iterator \n+      end() const\n+      { return reinterpret_cast<iterator>(&_M_instance[_S_index - 1]); }\n+\n+      reverse_iterator \n+      rbegin()\n+      { return reverse_iterator(this->end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(this->end()); }\n+\n+      reverse_iterator \n+      rend()\n+      { return reverse_iterator(this->begin()); }\n+\n+      const_reverse_iterator \n+      rend() const\n+      { return const_reverse_iterator(this->begin()); }\n+\n+      // Capacity.\n+      size_type \n+      size() const { return _S_index; }\n+\n+      size_type \n+      max_size() const\n+      { \n+\t// XXX Not specified. Unnecessary, this is fixed-size.\n+\treturn _S_index; \n+      }\n+\n+      bool \n+      empty() const;\n+\n+      // Element access.\n+      reference \n+      operator[](size_type __n)\n+      { return reinterpret_cast<reference>(_M_instance[__n]); }\n+\n+      const_reference \n+      operator[](size_type __n) const\n+      { return reinterpret_cast<const_reference>(_M_instance[__n]); }\n+\n+      const_reference \n+      at(size_type __n) const\n+      { \n+\tif (__builtin_expect(__n > _S_index, false))\n+\t  throw std::bad_alloc();\n+\treturn reinterpret_cast<const_reference>(_M_instance[__n]); \n+      }\n+\n+      reference \n+      at(size_type __n)\n+      { \n+\tif (__builtin_expect(__n > _S_index, false))\n+\t  throw std::bad_alloc();\n+\treturn reinterpret_cast<reference>(_M_instance[__n]); \n+      }\n+\n+      reference \n+      front(); \n+\n+      const_reference \n+      front() const; \n+\n+      reference \n+      back(); \n+\n+      const_reference \n+      back() const; \n+\n+      _Tp* \n+      data(); \n+\n+      const _Tp* \n+      data() const;\n+    };\n+\n+  // Array comparisons.\n+ template<typename _Tp, size_t _Nm>\n+   bool \n+   operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+   { return false; }\n+\n+ template<typename _Tp, size_t _Nm>\n+   bool \n+   operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+   { return !(__one == __two); }\n+\n+ template<typename _Tp, size_t _Nm>\n+   bool \n+   operator<(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+   { return false; }\n+\n+ template<typename _Tp, size_t _Nm>\n+   bool \n+   operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+   { return false; }\n+\n+ template<typename _Tp, size_t _Nm>\n+   bool \n+   operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+   { return false; }\n+\n+ template<typename _Tp, size_t _Nm>\n+   bool \n+   operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n+   { return false; }\n+\n+  // [6.2.2.2] Specialized algorithms.\n+ template<typename _Tp, size_t _Nm>\n+   void\n+   swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)\n+   { swap_ranges(__one.begin(), __one.end(), __two.begin()); }\n+} // namespace std::tr1\n+}\n+\n+#endif"}, {"sha": "68cbc73f3f7a4bf0194607857e8fcc296ca72dbf", "filename": "libstdc++-v3/testsuite/ext/array_allocator/1.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Farray_allocator%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Farray_allocator%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Farray_allocator%2F1.cc?ref=3febde356c3b2393bd6b62058618ed90ed0c1f4e", "patch": "@@ -0,0 +1,65 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cassert>\n+#include <string>\n+#include <ext/array_allocator.h>\n+\n+typedef char char_type;\n+typedef std::char_traits<char_type> traits_type;\n+typedef std::tr1::array<char_type, 4> array_type;\n+\n+array_type extern_array;\n+\n+void test01() \n+{\n+  using std::basic_string;\n+  typedef __gnu_cxx::array_allocator<char_type, array_type> allocator_type;\n+  typedef basic_string<char_type, traits_type, allocator_type> string_type;\n+\n+  allocator_type a(&extern_array);\n+  string_type s(a);\n+    \n+  try\n+    {\n+      s.reserve(4); // Actually need 4 + 1 + sizeof(std::string::_Rep).\n+    }\n+  catch(std::bad_alloc& obj)\n+    {\n+      assert(true);\n+    }\n+  catch(...)\n+    {\n+      assert(false);\n+    }\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2d757b533aa352ed01f318ecbf3488f303d73c1e", "filename": "libstdc++-v3/testsuite/ext/array_allocator/2.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Farray_allocator%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3febde356c3b2393bd6b62058618ed90ed0c1f4e/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Farray_allocator%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Farray_allocator%2F2.cc?ref=3febde356c3b2393bd6b62058618ed90ed0c1f4e", "patch": "@@ -0,0 +1,72 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cassert>\n+#include <string>\n+#include <iostream>\n+#include <ext/array_allocator.h>\n+\n+typedef char char_type;\n+typedef std::char_traits<char_type> traits_type;\n+typedef std::tr1::array<char_type, 17> array_type;\n+\n+array_type extern_array;\n+\n+void test01() \n+{\n+  using std::basic_string;\n+  typedef __gnu_cxx::array_allocator<char_type, array_type> allocator_type;\n+  typedef basic_string<char_type, traits_type, allocator_type> string_type;\n+\n+  size_t index = array_type::_S_index;\n+  allocator_type a(&extern_array);\n+  string_type s(a);\n+    \n+  try\n+    {\n+      s.reserve(4); // Actually need 4 + 1 + sizeof(std::string::_Rep).\n+    }\n+  catch(std::bad_alloc& obj)\n+    {\n+      assert(false);\n+    }\n+  catch(...)\n+    {\n+      assert(false);\n+    }\n+\n+  s.append(1, 'c');\n+  s.append(2, 'b');\n+\n+  std::cout << s.c_str() << std::endl;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}