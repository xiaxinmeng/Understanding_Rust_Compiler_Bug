{"sha": "d8ee014f291458a3518ea516619e75faf24aca17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhlZTAxNGYyOTE0NThhMzUxOGVhNTE2NjE5ZTc1ZmFmMjRhY2ExNw==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2017-04-25T10:09:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T10:09:31Z"}, "message": "checks.adb (Apply_Scalar_Range_Check): Analyze precisely conversions from float to integer in GNATprove mode.\n\n2017-04-25  Yannick Moy  <moy@adacore.com>\n\n\t* checks.adb (Apply_Scalar_Range_Check): Analyze precisely\n\tconversions from float to integer in GNATprove mode.\n\t(Apply_Type_Conversion_Checks): Make sure in GNATprove mode\n\tto call Apply_Type_Conversion_Checks, so that range checks\n\tare properly positioned when needed on conversions, including\n\twhen converting from float to integer.\t(Determine_Range): In\n\tGNATprove mode, take into account the possibility of conversion\n\tfrom float to integer.\n\t* sem_res.adb (Resolve_Type_Conversion): Only enforce range\n\tcheck on conversions from fixed-point to integer, not anymore\n\ton conversions from floating-point to integer, when in GNATprove\n\tmode.\n\nFrom-SVN: r247173", "tree": {"sha": "c073b26e5d471ac891115b0d2173abf751c6f1b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c073b26e5d471ac891115b0d2173abf751c6f1b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8ee014f291458a3518ea516619e75faf24aca17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8ee014f291458a3518ea516619e75faf24aca17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8ee014f291458a3518ea516619e75faf24aca17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8ee014f291458a3518ea516619e75faf24aca17/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c77943ebf24f7751cff692cf83fccc4866453e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c77943ebf24f7751cff692cf83fccc4866453e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c77943ebf24f7751cff692cf83fccc4866453e5"}], "stats": {"total": 112, "additions": 97, "deletions": 15}, "files": [{"sha": "0a7a78246ee974b13751c17a819fee52ebb88ec0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ee014f291458a3518ea516619e75faf24aca17/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ee014f291458a3518ea516619e75faf24aca17/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d8ee014f291458a3518ea516619e75faf24aca17", "patch": "@@ -1,3 +1,18 @@\n+2017-04-25  Yannick Moy  <moy@adacore.com>\n+\n+\t* checks.adb (Apply_Scalar_Range_Check): Analyze precisely\n+\tconversions from float to integer in GNATprove mode.\n+\t(Apply_Type_Conversion_Checks): Make sure in GNATprove mode\n+\tto call Apply_Type_Conversion_Checks, so that range checks\n+\tare properly positioned when needed on conversions, including\n+\twhen converting from float to integer.\t(Determine_Range): In\n+\tGNATprove mode, take into account the possibility of conversion\n+\tfrom float to integer.\n+\t* sem_res.adb (Resolve_Type_Conversion): Only enforce range\n+\tcheck on conversions from fixed-point to integer, not anymore\n+\ton conversions from floating-point to integer, when in GNATprove\n+\tmode.\n+\n 2017-04-25  Yannick Moy  <moy@adacore.com>\n \n \t* checks.adb (Determine_Range_R): Special case type conversions"}, {"sha": "a057cf3d16570ea031c117500689c807cbc2b71f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 72, "deletions": 9, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ee014f291458a3518ea516619e75faf24aca17/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ee014f291458a3518ea516619e75faf24aca17/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=d8ee014f291458a3518ea516619e75faf24aca17", "patch": "@@ -2943,20 +2943,24 @@ package body Checks is\n \n       --  The additional less-precise tests below catch these cases\n \n+      --  In GNATprove_Mode, also deal with the case of a conversion from\n+      --  floating-point to integer. It is only possible because analysis\n+      --  in GNATprove rules out the possibility of a NaN or infinite value.\n+\n       --  Note: skip this if we are given a source_typ, since the point of\n       --  supplying a Source_Typ is to stop us looking at the expression.\n       --  We could sharpen this test to be out parameters only ???\n \n       if Is_Discrete_Type (Target_Typ)\n-        and then Is_Discrete_Type (Etype (Expr))\n+        and then (Is_Discrete_Type (Etype (Expr))\n+                   or else (GNATprove_Mode\n+                             and then Is_Floating_Point_Type (Etype (Expr))))\n         and then not Is_Unconstrained_Subscr_Ref\n         and then No (Source_Typ)\n       then\n          declare\n             Tlo : constant Node_Id := Type_Low_Bound  (Target_Typ);\n             Thi : constant Node_Id := Type_High_Bound (Target_Typ);\n-            Lo  : Uint;\n-            Hi  : Uint;\n \n          begin\n             if Compile_Time_Known_Value (Tlo)\n@@ -2965,6 +2969,8 @@ package body Checks is\n                declare\n                   Lov : constant Uint := Expr_Value (Tlo);\n                   Hiv : constant Uint := Expr_Value (Thi);\n+                  Lo  : Uint;\n+                  Hi  : Uint;\n \n                begin\n                   --  If range is null, we for sure have a constraint error\n@@ -2991,7 +2997,34 @@ package body Checks is\n \n                   --  Otherwise determine range of value\n \n-                  Determine_Range (Expr, OK, Lo, Hi, Assume_Valid => True);\n+                  if Is_Discrete_Type (Etype (Expr)) then\n+                     Determine_Range (Expr, OK, Lo, Hi,\n+                                      Assume_Valid => True);\n+\n+                  --  When converting a float to an integer type, determine the\n+                  --  range in real first, and then convert the bounds using\n+                  --  UR_To_Uint which correctly rounds away from zero when\n+                  --  half way between two integers, as required by normal\n+                  --  Ada 95 rounding semantics. It is only possible because\n+                  --  analysis in GNATprove rules out the possibility of a NaN\n+                  --  or infinite value.\n+\n+                  elsif GNATprove_Mode\n+                    and then Is_Floating_Point_Type (Etype (Expr))\n+                  then\n+                     declare\n+                        Lor : Ureal;\n+                        Hir : Ureal;\n+                     begin\n+                        Determine_Range_R (Expr, OK, Lor, Hir,\n+                                           Assume_Valid => True);\n+\n+                        if OK then\n+                           Lo := UR_To_Uint (Lor);\n+                           Hi := UR_To_Uint (Hir);\n+                        end if;\n+                     end;\n+                  end if;\n \n                   if OK then\n \n@@ -3449,7 +3482,9 @@ package body Checks is\n             if not Range_Checks_Suppressed (Target_Type)\n               and then not Range_Checks_Suppressed (Expr_Type)\n             then\n-               if Float_To_Int then\n+               if Float_To_Int\n+                 and then not GNATprove_Mode\n+               then\n                   Apply_Float_Conversion_Check (Expr, Target_Type);\n                else\n                   Apply_Scalar_Range_Check\n@@ -4688,11 +4723,39 @@ package body Checks is\n \n             end case;\n \n-         --  For type conversion from one discrete type to another, we can\n-         --  refine the range using the converted value.\n-\n          when N_Type_Conversion =>\n-            Determine_Range (Expression (N), OK1, Lor, Hir, Assume_Valid);\n+\n+            --  For type conversion from one discrete type to another, we can\n+            --  refine the range using the converted value.\n+\n+            if Is_Discrete_Type (Etype (Expression (N))) then\n+               Determine_Range (Expression (N), OK1, Lor, Hir, Assume_Valid);\n+\n+            --  When converting a float to an integer type, determine the range\n+            --  in real first, and then convert the bounds using UR_To_Uint\n+            --  which correctly rounds away from zero when half way between two\n+            --  integers, as required by normal Ada 95 rounding semantics. It\n+            --  is only possible because analysis in GNATprove rules out the\n+            --  possibility of a NaN or infinite value.\n+\n+            elsif GNATprove_Mode\n+              and then Is_Floating_Point_Type (Etype (Expression (N)))\n+            then\n+               declare\n+                  Lor_Real, Hir_Real : Ureal;\n+               begin\n+                  Determine_Range_R (Expression (N), OK1, Lor_Real, Hir_Real,\n+                                     Assume_Valid);\n+\n+                  if OK1 then\n+                     Lor := UR_To_Uint (Lor_Real);\n+                     Hir := UR_To_Uint (Hir_Real);\n+                  end if;\n+               end;\n+\n+            else\n+               OK1 := False;\n+            end if;\n \n          --  Nothing special to do for all other expression kinds\n "}, {"sha": "70e0c28141372d5ef894cdb6a585805e9eb3b6b2", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8ee014f291458a3518ea516619e75faf24aca17/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8ee014f291458a3518ea516619e75faf24aca17/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d8ee014f291458a3518ea516619e75faf24aca17", "patch": "@@ -11053,15 +11053,19 @@ package body Sem_Res is\n          end if;\n       end if;\n \n-      --  If at this stage we have a real to integer conversion, make sure\n-      --  that the Do_Range_Check flag is set, because such conversions in\n-      --  general need a range check. We only need this if expansion is off\n-      --  or we are in GNATProve mode.\n+      --  If at this stage we have a real to integer conversion, make sure that\n+      --  the Do_Range_Check flag is set, because such conversions in general\n+      --  need a range check. We only need this if expansion is off, or we are\n+      --  in GNATprove mode and the conversion if from fixed-point to integer\n+      --  (as floating-point to integer conversions are now handled in\n+      --  GNATprove mode).\n \n       if Nkind (N) = N_Type_Conversion\n-        and then (GNATprove_Mode or not Expander_Active)\n+        and then not Expander_Active\n         and then Is_Integer_Type (Target_Typ)\n-        and then Is_Real_Type (Operand_Typ)\n+        and then (Is_Real_Type (Operand_Typ)\n+                   or else (GNATprove_Mode\n+                             and then Is_Fixed_Point_Type (Operand_Typ)))\n       then\n          Set_Do_Range_Check (Operand);\n       end if;"}]}