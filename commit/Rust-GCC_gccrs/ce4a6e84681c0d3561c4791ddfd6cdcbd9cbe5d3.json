{"sha": "ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U0YTZlODQ2ODFjMGQzNTYxYzQ3OTFkZGZkNmNkY2JkOWNiZTVkMw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-04-08T06:45:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:45:42Z"}, "message": "fe.h: Remove global Optimize_Alignment flag, no longer used\n\n2008-04-08  Robert Dewar  <dewar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* fe.h: Remove global Optimize_Alignment flag, no longer used\n\n\t* layout.adb: Test Optimize_Alignment flags rather than global switch\n\n\t* lib.ads, lib.adb: New OA_Setting field in library record\n\n\t* lib-load.adb: New OA_Setting field in library record\n\n\t* lib-writ.ads, lib-writ.adb (Collect_Withs, Write_With_Lines): Place\n\tunits mentioned in limited_with_ clauses in the ali file, with an\n\t'Y' marker.\n\tNew Ox fields in U line\n\n\t* opt.adb: New flag Optimize_Alignment_Local\n\t(Check_Policy_List[_Config]): New flags\n\n\t* opt.ads (Invalid_Value_Used): New flag\n\tNew switch Optimize_Alignment_Local\n\t(Warn_On_Parameter_Order): New flag\n\t(Check_Policy_List[_Config]): New flags\n\n\t* ali.ads, ali.adb: Add indicator 'Y' to mark mark the presence of\n\tlimited_with clauses.\n\tNew data structures for Optimize_Alignment\n\n\t* bcheck.adb (Check_Consistent_Restriction_No_Default_Initialization):\n\tNew procedure\n\t(Check_Consistent_Optimize_Alignment): Rework for new structure\n\t(Check_Consistent_Restrictions): Fix incorrect error message\n\n\tsem_ch10.adb (Decorate_Tagged_Type): Set the Parent field of a newly\n\tcreated class-wide type (to the Parent field of the specific type).\n\t(Install_Siblings): Handle properly private_with_clauses on subprogram\n\tbodies and on generic units.\n\t(Analyze_With_Clause, Install_Limited_Withed_Unit): Guard against an\n\tillegal limited_with_clause that names a non-existent package.\n\t(Check_Body_Required): Determine whether a unit named a limited_with\n\tclause needs a body.\n\t(Analyze_Context): A limited_with_clause is illegal on a unit_renaming.\n\tCapture Optimize_Alignment settings to set new OA_Setting field in\n\tlibrary record.\n\t(Build_Limited_Views): Include task and protected type declarations.\n\n\t* sem_ch3.ads, sem_ch3.adb (Analyze_Object_Declaration): Handle the\n\tcase of a possible constant redeclaration where the current object is\n\tan entry index constant.\n\t(Analyze_Object_Declaration): Generate an error in case of CPP\n\tclass-wide object initialization.\n\t(Analyze_Object_Declaration): Add extra information on warnings for\n\tdeclaration of unconstrained objects.\n\t(Access_Type_Declaration): Set Associated_Final_Chain to Empty, to avoid\n\tconflicts with the setting of Stored_Constraint in the case where the\n\taccess type entity has already been created as an E_Incomplete_Type due\n\tto a limited with clause.\n\tUse new Is_Standard_Character_Type predicate\n\t(Analyze_Object_Declaration): Apply access_constant check only after\n\texpression has been resolved, given that it may be overloaded with\n\tseveral access types.\n\t(Constant_Redeclaration): Additional legality checks for deferred\n\tconstant declarations tha involve anonymous access types and/or null\n\texclusion indicators.\n\t(Analyze_Type_Declaration): Set Optimize_Alignment flags\n\t(Analyze_Subtype_Declaration): Ditto\n\t(Analyze_Object_Declaration): Ditto\n\t(Analyze_Object_Declaration): Don't count tasks in generics\n\tChange name In_Default_Expression      => In_Spec_Expression\n\tChange name Analyze_Per_Use_Expression => Preanalyze_Spec_Expression\n\tChange name Pre_Analyze_And_Resolve    => Preanalyze_And_Resolve\n\t(Process_Discriminants): Additional check for illegal use of default\n\texpressions in access discriminant specifications in a type that is not\n\texplicitly limited.\n\t(Check_Abstract_Overriding): If an inherited function dispaches on an\n\taccess result, it must be overridden, even if the type is a null\n\textension.\n\t(Derive_Subprogram): The formals of the derived subprogram have the\n\tnames and defaults of the parent subprogram, even if the type is\n\tobtained from the actual subprogram.\n\t(Derive_Subprogram): In the presence of interfaces, a formal of an\n\tinherited operation has the derived type not only if it descends from\n\tthe type of the formal of the parent operation, but also if it\n\timplements it. This is relevant for the renamings created for the\n\tprimitive operations of the actual for a formal derived type.\n\t(Is_Progenitor): New predicate, to determine whether the type of a\n\tformal in the parent operation must be replaced by the derived type.\n\n\t* sem_util.ads, sem_util.adb (Has_Overriding_Initialize): Make\n\tpredicate recursive to handle components that have a user-defined\n\tInitialize procedure. Handle controlled derived types whose ancestor\n\thas a user-defined Initialize procedured.\n\t(Note_Possible_Modification): Add Sure parameter, generate warning if\n\tsure modification of constant\n\tUse new Is_Standard_Character_Type predicate\n\t(Find_Parameter_Type): when determining whether a protected operation\n\timplements an interface operation, retrieve the type of the formal from\n\tthe entity when the formal is an access parameter or an\n\tanonymous-access-to-subprogram.\n\tMove Copy_Parameter_List to sem_util, for use when building stubbed\n\tsubprogram bodies.\n\t(Has_Access_Values): Tagged types now return False\n\t(Within_HSS_Or_If): New procedure\n\t(Set_Optimize_Alignment_Flags): New procedure\n\tChange name In_Default_Expression      => In_Spec_Expression\n\tChange name Analyze_Per_Use_Expression => Preanalyze_Spec_Expression\n\tChange name Pre_Analyze_And_Resolve    => Preanalyze_And_Resolve\n\nFrom-SVN: r134011", "tree": {"sha": "364bb5359429fa617f70c71d9d19558946d8121d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/364bb5359429fa617f70c71d9d19558946d8121d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/comments", "author": null, "committer": null, "parents": [{"sha": "21d279972261484650109d662caf32b73a91bf1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21d279972261484650109d662caf32b73a91bf1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21d279972261484650109d662caf32b73a91bf1d"}], "stats": {"total": 1824, "additions": 1371, "deletions": 453}, "files": [{"sha": "31695a386ac7b1adafc30f7fb4dff6888ce308bb", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -53,6 +53,7 @@ package body ALI is\n       'D'    => True,   -- dependency\n       'X'    => True,   -- xref\n       'S'    => True,   -- specific dispatching\n+      'Y'    => True,   -- limited_with\n       others => False);\n \n    --------------------\n@@ -772,7 +773,7 @@ package body ALI is\n       --  Acquire lines to be ignored\n \n       if Read_Xref then\n-         Ignore := ('U' | 'W' | 'D' | 'X' => False, others => True);\n+         Ignore := ('U' | 'W' | 'Y' | 'D' | 'X' => False, others => True);\n \n       --  Read_Lines parameter given\n \n@@ -818,7 +819,6 @@ package body ALI is\n         No_Object                  => False,\n         Normalize_Scalars          => False,\n         Ofile_Full_Name            => Full_Object_File_Name,\n-        Optimize_Alignment_Setting => 'O',\n         Queuing_Policy             => ' ',\n         Restrictions               => No_Restrictions,\n         SAL_Interface              => False,\n@@ -1041,11 +1041,6 @@ package body ALI is\n                   Fatal_Error_Ignore;\n                end if;\n \n-            --  Processing for Ox\n-\n-            elsif C = 'O' then\n-               ALIs.Table (Id).Optimize_Alignment_Setting := Getc;\n-\n             --  Processing for Qx\n \n             elsif C = 'Q' then\n@@ -1424,6 +1419,7 @@ package body ALI is\n             UL.SAL_Interface            := ALIs.Table (Id).SAL_Interface;\n             UL.Body_Needed_For_SAL      := False;\n             UL.Elaborate_Body_Desirable := False;\n+            UL.Optimize_Alignment       := 'O';\n \n             if Debug_Flag_U then\n                Write_Str (\" ----> reading unit \");\n@@ -1626,6 +1622,19 @@ package body ALI is\n \n                Check_At_End_Of_Field;\n \n+            --  OL/OO/OS/OT parameters\n+\n+            elsif C = 'O' then\n+               C := Getc;\n+\n+               if C = 'L' or else C = 'O' or else C = 'S' or else C = 'T' then\n+                  Units.Table (Units.Last).Optimize_Alignment := C;\n+               else\n+                  Fatal_Error_Ignore;\n+               end if;\n+\n+               Check_At_End_Of_Field;\n+\n             --  RC/RT parameters\n \n             elsif C = 'R' then\n@@ -1678,7 +1687,7 @@ package body ALI is\n \n          With_Loop : loop\n             Check_Unknown_Line;\n-            exit With_Loop when C /= 'W';\n+            exit With_Loop when C /= 'W' and then C /= 'Y';\n \n             if Ignore ('W') then\n                Skip_Line;\n@@ -1693,6 +1702,7 @@ package body ALI is\n                Withs.Table (Withs.Last).Elab_Desirable     := False;\n                Withs.Table (Withs.Last).Elab_All_Desirable := False;\n                Withs.Table (Withs.Last).SAL_Interface      := False;\n+               Withs.Table (Withs.Last).Limited_With       := (C = 'Y');\n \n                --  Generic case with no object file available\n "}, {"sha": "dd3b6cd6577d867efd0aa40ca5647891334d9780", "filename": "gcc/ada/ali.ads", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fali.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fali.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.ads?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -176,11 +176,6 @@ package ALI is\n       --  Set to True if file was compiled with Normalize_Scalars. Not set if\n       --  'P' appears in Ignore_Lines.\n \n-      Optimize_Alignment_Setting : Character;\n-      --  Optimize_Alignment setting. Set to S/T if OS/OT parameters present,\n-      --  otherwise set to 'O' (S/T/O = Space/Time/Off). Not set if 'P' appears\n-      --  in Ignore_Lines.\n-\n       Unit_Exception_Table : Boolean;\n       --  Set to True if unit exception table pointer generated. Not set if 'P'\n       --  appears in Ignore_Lines.\n@@ -358,6 +353,9 @@ package ALI is\n       --  for the body right after the call for the spec, or at least as close\n       --  together as possible.\n \n+      Optimize_Alignment : Character;\n+      --  Optimize_Alignment setting. Set to L/S/T/O for OL/OS/OT/OO present\n+\n    end record;\n \n    package Units is new Table.Table (\n@@ -539,6 +537,8 @@ package ALI is\n       SAL_Interface : Boolean := False;\n       --  True if the Unit is an Interface of a Stand-Alone Library\n \n+      Limited_With : Boolean := False;\n+      --  True if unit is named in a limited_with_clause\n    end record;\n \n    package Withs is new Table.Table (\n@@ -669,43 +669,42 @@ package ALI is\n    -- Sdep (Source Dependency) Table --\n    ------------------------------------\n \n-   --  Each source dependency (D line) in an ALI file generates an\n-   --  entry in the Sdep table.\n+   --  Each source dependency (D line) in an ALI file generates an entry in the\n+   --  Sdep table.\n \n    --  Note: there will be no entries in this table if 'D' lines are ignored\n \n    No_Sdep_Id : constant Sdep_Id := Sdep_Id'First;\n    --  Special value indicating no Sdep table entry\n \n    First_Sdep_Entry : Sdep_Id := No_Sdep_Id + 1;\n-   --  Id of first Sdep entry for current ali file. This is initialized to\n-   --  the first Sdep entry in the table, and then incremented appropriately\n-   --  as successive ALI files are scanned.\n+   --  Id of first Sdep entry for current ali file. This is initialized to the\n+   --  first Sdep entry in the table, and then incremented appropriately as\n+   --  successive ALI files are scanned.\n \n    type Sdep_Record is record\n \n       Sfile : File_Name_Type;\n       --  Name of source file\n \n       Stamp : Time_Stamp_Type;\n-      --  Time stamp value. Note that this will be all zero characters\n-      --  for the dummy entries for missing or non-dependent files.\n+      --  Time stamp value. Note that this will be all zero characters for the\n+      --  dummy entries for missing or non-dependent files.\n \n       Checksum : Word;\n-      --  Checksum value. Note that this will be all zero characters\n-      --  for the dummy entries for missing or non-dependent files\n+      --  Checksum value. Note that this will be all zero characters for the\n+      --  dummy entries for missing or non-dependent files\n \n       Dummy_Entry : Boolean;\n-      --  Set True for dummy entries that correspond to missing files\n-      --  or files where no dependency relationship exists.\n+      --  Set True for dummy entries that correspond to missing files or files\n+      --  where no dependency relationship exists.\n \n       Subunit_Name : Name_Id;\n       --  Name_Id for subunit name if present, else No_Name\n \n       Rfile : File_Name_Type;\n-      --  Reference file name. Same as Sfile unless a Source_Reference\n-      --  pragma was used, in which case it reflects the name used in\n-      --  the pragma.\n+      --  Reference file name. Same as Sfile unless a Source_Reference pragma\n+      --  was used, in which case it reflects the name used in the pragma.\n \n       Start_Line : Nat;\n       --  Starting line number in file. Always 1, unless a Source_Reference\n@@ -726,8 +725,8 @@ package ALI is\n    -- Use of Name Table Info --\n    ----------------------------\n \n-   --  All unit names and file names are entered into the Names table. The\n-   --  Info fields of these entries are used as follows:\n+   --  All unit names and file names are entered into the Names table. The Info\n+   --  fields of these entries are used as follows:\n \n    --    Unit name           Info field has Unit_Id of unit table entry\n    --    ALI file name       Info field has ALI_Id of ALI table entry\n@@ -737,8 +736,8 @@ package ALI is\n    -- Cross-Reference Data --\n    --------------------------\n \n-   --  The following table records cross-reference sections, there is one\n-   --  entry for each X header line in the ALI file for an xref section.\n+   --  The following table records cross-reference sections, there is one entry\n+   --  for each X header line in the ALI file for an xref section.\n \n    --  Note: there will be no entries in this table if 'X' lines are ignored\n "}, {"sha": "3332d2083f8019d5dd674a177db4dbe44f905c76", "filename": "gcc/ada/bcheck.adb", "status": "modified", "additions": 99, "deletions": 31, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fbcheck.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fbcheck.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbcheck.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,7 +43,7 @@ package body Bcheck is\n    -----------------------\n \n    --  The following checking subprograms make up the parts of the\n-   --  configuration consistency check.\n+   --  configuration consistency check. See bodies for details of checks.\n \n    procedure Check_Consistent_Dispatching_Policy;\n    procedure Check_Consistent_Dynamic_Elaboration_Checking;\n@@ -54,6 +54,7 @@ package body Bcheck is\n    procedure Check_Consistent_Optimize_Alignment;\n    procedure Check_Consistent_Queuing_Policy;\n    procedure Check_Consistent_Restrictions;\n+   procedure Check_Consistent_Restriction_No_Default_Initialization;\n    procedure Check_Consistent_Zero_Cost_Exception_Handling;\n \n    procedure Consistency_Error_Msg (Msg : String);\n@@ -90,6 +91,7 @@ package body Bcheck is\n       Check_Consistent_Optimize_Alignment;\n       Check_Consistent_Dynamic_Elaboration_Checking;\n       Check_Consistent_Restrictions;\n+      Check_Consistent_Restriction_No_Default_Initialization;\n       Check_Consistent_Interrupt_States;\n       Check_Consistent_Dispatching_Policy;\n    end Check_Configuration_Consistency;\n@@ -700,34 +702,40 @@ package body Bcheck is\n    -- Check_Consistent_Optimize_Alignment --\n    -----------------------------------------\n \n-   --  The rule is that all units other than internal units must be compiled\n-   --  with the same setting for Optimize_Alignment. We can exclude internal\n-   --  units since they are forced to compile with Optimize_Alignment (Off).\n+   --  The rule is that all units which depend on the global default setting\n+   --  of Optimize_Alignment must be compiled with the same settinng for this\n+   --  default. Units which specify an explicit local value for this setting\n+   --  are exempt from the consistency rule (this includes all internal units).\n \n    procedure Check_Consistent_Optimize_Alignment is\n       OA_Setting : Character := ' ';\n-      --  Reset when we find a non-internal unit\n+      --  Reset when we find a unit that depends on the default and does\n+      --  not have a local specification of the Optimize_Alignment setting.\n \n-      OA_Unit : ALI_Id;\n+      OA_Unit : Unit_Id;\n       --  Id of unit from which OA_Setting was set\n \n+      C : Character;\n+\n    begin\n-      for A in ALIs.First .. ALIs.Last loop\n-         if not Is_Internal_File_Name (ALIs.Table (A).Afile) then\n+      for U in First_Unit_Entry .. Units.Last loop\n+         C := Units.Table (U).Optimize_Alignment;\n+\n+         if C /= 'L' then\n             if OA_Setting = ' ' then\n-               OA_Setting := ALIs.Table (A).Optimize_Alignment_Setting;\n-               OA_Unit := A;\n+               OA_Setting := C;\n+               OA_Unit := U;\n \n-            elsif OA_Setting = ALIs.Table (A).Optimize_Alignment_Setting then\n+            elsif OA_Setting = C then\n                null;\n \n             else\n-               Error_Msg_File_1 := ALIs.Table (OA_Unit).Sfile;\n-               Error_Msg_File_2 := ALIs.Table (A).Sfile;\n+               Error_Msg_Unit_1 := Units.Table (OA_Unit).Uname;\n+               Error_Msg_Unit_2 := Units.Table (U).Uname;\n \n                Consistency_Error_Msg\n-                 (\"{ and { compiled with different \"\n-                  & \"Optimize_Alignment settings\");\n+                 (\"$ and $ compiled with different \"\n+                  & \"default Optimize_Alignment settings\");\n                return;\n             end if;\n          end if;\n@@ -775,10 +783,9 @@ package body Bcheck is\n    -- Check_Consistent_Restrictions --\n    -----------------------------------\n \n-   --  The rule is that if a restriction is specified in any unit,\n-   --  then all units must obey the restriction. The check applies\n-   --  only to restrictions which require partition wide consistency,\n-   --  and not to internal units.\n+   --  The rule is that if a restriction is specified in any unit, then all\n+   --  units must obey the restriction. The check applies only to restrictions\n+   --  which require partition wide consistency, and not to internal units.\n \n    procedure Check_Consistent_Restrictions is\n       Restriction_File_Output : Boolean;\n@@ -811,7 +818,7 @@ package body Bcheck is\n                   declare\n                      M1 : constant String := \"{ has restriction \";\n                      S  : constant String := Restriction_Id'Image (R);\n-                     M2 : String (1 .. 200); -- big enough!\n+                     M2 : String (1 .. 2000); -- big enough!\n                      P  : Integer;\n \n                   begin\n@@ -902,7 +909,7 @@ package body Bcheck is\n                                 (\"  { (count = at least #)\");\n                            else\n                               Consistency_Error_Msg\n-                                (\"  % (count = #)\");\n+                                (\"  { (count = #)\");\n                            end if;\n                         end if;\n                      end if;\n@@ -950,6 +957,75 @@ package body Bcheck is\n       end loop;\n    end Check_Consistent_Restrictions;\n \n+   ------------------------------------------------------------\n+   -- Check_Consistent_Restriction_No_Default_Initialization --\n+   ------------------------------------------------------------\n+\n+   --  The Restriction (No_Default_Initialization) has special consistency\n+   --  rules. The rule is that no unit compiled without this restriction\n+   --  that violates the restriction can WITH a unit that is compiled with\n+   --  the restriction.\n+\n+   procedure Check_Consistent_Restriction_No_Default_Initialization is\n+   begin\n+      --  Nothing to do if no one set this restriction\n+\n+      if not Cumulative_Restrictions.Set (No_Default_Initialization) then\n+         return;\n+      end if;\n+\n+      --  Nothing to do if no one violates the restriction\n+\n+      if not Cumulative_Restrictions.Violated (No_Default_Initialization) then\n+         return;\n+      end if;\n+\n+      --  Otherwise we go into a full scan to find possible problems\n+\n+      for U in Units.First .. Units.Last loop\n+         declare\n+            UTE : Unit_Record renames Units.Table (U);\n+            ATE : ALIs_Record renames ALIs.Table (UTE.My_ALI);\n+\n+         begin\n+            if ATE.Restrictions.Violated (No_Default_Initialization) then\n+               for W in UTE.First_With .. UTE.Last_With loop\n+                  declare\n+                     AFN : constant File_Name_Type := Withs.Table (W).Afile;\n+\n+                  begin\n+                     --  The file name may not be present for withs of certain\n+                     --  generic run-time files. The test can be safely left\n+                     --  out in such cases anyway.\n+\n+                     if AFN /= No_File then\n+                        declare\n+                           WAI : constant ALI_Id :=\n+                                   ALI_Id (Get_Name_Table_Info (AFN));\n+                           WTE : ALIs_Record renames ALIs.Table (WAI);\n+\n+                        begin\n+                           if WTE.Restrictions.Set\n+                               (No_Default_Initialization)\n+                           then\n+                              Error_Msg_Unit_1 := UTE.Uname;\n+                              Consistency_Error_Msg\n+                                (\"unit $ compiled without restriction \"\n+                                 & \"No_Default_Initialization\");\n+                              Error_Msg_Unit_1 := Withs.Table (W).Uname;\n+                              Consistency_Error_Msg\n+                                (\"withs unit $, compiled with restriction \"\n+                                 & \"No_Default_Initialization\");\n+                           end if;\n+                        end;\n+                     end if;\n+                  end;\n+               end loop;\n+            end if;\n+         end;\n+      end loop;\n+   end Check_Consistent_Restriction_No_Default_Initialization;\n+\n    ---------------------------------------------------\n    -- Check_Consistent_Zero_Cost_Exception_Handling --\n    ---------------------------------------------------\n@@ -1056,15 +1132,7 @@ package body Bcheck is\n          --  If consistency errors are tolerated,\n          --  output the message as a warning.\n \n-         declare\n-            Warning_Msg : String (1 .. Msg'Length + 1);\n-\n-         begin\n-            Warning_Msg (1) := '?';\n-            Warning_Msg (2 .. Warning_Msg'Last) := Msg;\n-\n-            Error_Msg (Warning_Msg);\n-         end;\n+         Error_Msg ('?' & Msg);\n \n       --  Otherwise the consistency error is a true error\n "}, {"sha": "2a038d58ffefd075a28d9b7a3ef8c31716708b74", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -46,11 +46,11 @@ extern char Fold_Lower[], Fold_Upper[];\n \n /* debug: */\n \n-#define Debug_Flag_XX debug__debug_flag_xx\n #define Debug_Flag_NN debug__debug_flag_nn\n+#define Debug_Flag_Dot_A debug__debug_flag_dot_a\n \n-extern Boolean Debug_Flag_XX;\n extern Boolean Debug_Flag_NN;\n+extern Boolean Debug_Flag_Dot_A;\n \n /* einfo: We will be setting Esize for types, Component_Bit_Offset for fields,\n    Alignment for types and objects, Component_Size for array types, and"}, {"sha": "c6dec0aa379fd275e8cdc514b84f5290213e846b", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2807,7 +2807,7 @@ package body Layout is\n       --  have an alignment of 1. But don't do anything for atomic records\n       --  since we may need higher alignment for indivisible access.\n \n-      if Optimize_Alignment = 'S'\n+      if Optimize_Alignment_Space (E)\n         and then Is_Record_Type (E)\n         and then Is_Packed (E)\n         and then not Is_Atomic (E)\n@@ -2848,7 +2848,7 @@ package body Layout is\n             --  alignment matches the size, for example, if the size is 17\n             --  bytes then we want an alignment of 1 for the type.\n \n-         elsif Optimize_Alignment = 'S' then\n+         elsif Optimize_Alignment_Space (E) then\n             if Siz mod (8 * System_Storage_Unit) = 0 then\n                Align := 8;\n             elsif Siz mod (4 * System_Storage_Unit) = 0 then\n@@ -2864,7 +2864,7 @@ package body Layout is\n             --  alignment of 4. Note that this matches the old VMS behavior\n             --  in versions of GNAT prior to 6.1.1.\n \n-         elsif Optimize_Alignment = 'T'\n+         elsif Optimize_Alignment_Time (E)\n            and then Siz > System_Storage_Unit\n            and then Siz <= 8 * System_Storage_Unit\n          then\n@@ -2902,7 +2902,7 @@ package body Layout is\n          --  since conceivably we may be able to do better.\n \n          if Align > System_Word_Size / System_Storage_Unit\n-           and then Optimize_Alignment /= 'T'\n+           and then not Optimize_Alignment_Time (E)\n          then\n             Align := System_Word_Size / System_Storage_Unit;\n          end if;\n@@ -2912,7 +2912,7 @@ package body Layout is\n          --  we have Optimize_Alignment set to Space. Note that that covers\n          --  the case of packed records, where we already set alignment to 1.\n \n-         if Optimize_Alignment  /= 'S' then\n+         if not Optimize_Alignment_Space (E) then\n             declare\n                Comp : Entity_Id;\n "}, {"sha": "d928b79a3a98459bdc65730b93c3743b5f3899c6", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -224,7 +224,8 @@ package body Lib.Load is\n         Source_Index     => No_Source_File,\n         Unit_File_Name   => Get_File_Name (Spec_Name, Subunit => False),\n         Unit_Name        => Spec_Name,\n-        Version          => 0);\n+        Version          => 0,\n+        OA_Setting       => 'O');\n \n       Set_Comes_From_Source_Default (Save_CS);\n       Set_Error_Posted (Cunit_Entity);\n@@ -327,7 +328,8 @@ package body Lib.Load is\n            Source_Index     => Main_Source_File,\n            Unit_File_Name   => Fname,\n            Unit_Name        => No_Unit_Name,\n-           Version          => Version);\n+           Version          => Version,\n+           OA_Setting       => 'O');\n       end if;\n    end Load_Main_Source;\n \n@@ -647,7 +649,8 @@ package body Lib.Load is\n               Source_Index     => Src_Ind,\n               Unit_File_Name   => Fname,\n               Unit_Name        => Uname_Actual,\n-              Version          => Source_Checksum (Src_Ind));\n+              Version          => Source_Checksum (Src_Ind),\n+              OA_Setting       => 'O');\n \n             --  Parse the new unit\n "}, {"sha": "7ebfc7d3d5148b016ac484014b759db9b1ac33f0", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 54, "deletions": 36, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -87,7 +87,8 @@ package body Lib.Writ is\n          Munit_Index      => 0,\n          Serial_Number    => 0,\n          Version          => 0,\n-         Error_Location   => No_Location);\n+         Error_Location   => No_Location,\n+         OA_Setting       => 'O');\n    end Add_Preprocessing_Dependency;\n \n    ------------------------------\n@@ -141,7 +142,8 @@ package body Lib.Writ is\n         Munit_Index      => 0,\n         Serial_Number    => 0,\n         Version          => 0,\n-        Error_Location   => No_Location);\n+        Error_Location   => No_Location,\n+        OA_Setting       => 'O');\n \n       --  Parse system.ads so that the checksum is set right\n       --  Style checks are not applied.\n@@ -236,28 +238,33 @@ package body Lib.Writ is\n             --  Process with clause\n \n             --  Ada 2005 (AI-50217): limited with_clauses do not create\n-            --  dependencies\n+            --  dependencies, but must be recorded as components of the\n+            --  partition, in case there is no regular with_clause for\n+            --  the unit anywhere else.\n \n-            if Nkind (Item) = N_With_Clause\n-              and then not (Limited_Present (Item))\n-            then\n+            if Nkind (Item) = N_With_Clause then\n                Unum := Get_Cunit_Unit_Number (Library_Unit (Item));\n                With_Flags (Unum) := True;\n \n-               if Elaborate_Present (Item) then\n-                  Elab_Flags (Unum) := True;\n-               end if;\n+               if not Limited_Present (Item) then\n+                  if Elaborate_Present (Item) then\n+                     Elab_Flags (Unum) := True;\n+                  end if;\n \n-               if Elaborate_All_Present (Item) then\n-                  Elab_All_Flags (Unum) := True;\n-               end if;\n+                  if Elaborate_All_Present (Item) then\n+                     Elab_All_Flags (Unum) := True;\n+                  end if;\n \n-               if Elaborate_All_Desirable (Item) then\n-                  Elab_All_Des_Flags (Unum) := True;\n-               end if;\n+                  if Elaborate_All_Desirable (Item) then\n+                     Elab_All_Des_Flags (Unum) := True;\n+                  end if;\n \n-               if Elaborate_Desirable (Item) then\n-                  Elab_Des_Flags (Unum) := True;\n+                  if Elaborate_Desirable (Item) then\n+                     Elab_Des_Flags (Unum) := True;\n+                  end if;\n+\n+               else\n+                  Set_From_With_Type (Cunit_Entity (Unum));\n                end if;\n             end if;\n \n@@ -441,6 +448,9 @@ package body Lib.Writ is\n             Write_Info_Str (\" NE\");\n          end if;\n \n+         Write_Info_Str (\" O\");\n+         Write_Info_Char (OA_Setting (Unit_Num));\n+\n          if Is_Preelaborated (Uent) then\n             Write_Info_Str (\" PR\");\n          end if;\n@@ -512,7 +522,7 @@ package body Lib.Writ is\n             end case;\n          end if;\n \n-         if Initialize_Scalars then\n+         if Initialize_Scalars or else Invalid_Value_Used then\n             Write_Info_Str (\" IS\");\n          end if;\n \n@@ -696,7 +706,14 @@ package body Lib.Writ is\n             Uname  := Units.Table (Unum).Unit_Name;\n             Fname  := Units.Table (Unum).Unit_File_Name;\n \n-            Write_Info_Initiate ('W');\n+            if Ekind (Cunit_Entity (Unum)) = E_Package\n+              and then From_With_Type (Cunit_Entity (Unum))\n+            then\n+               Write_Info_Initiate ('Y');\n+            else\n+               Write_Info_Initiate ('W');\n+            end if;\n+\n             Write_Info_Char (' ');\n             Write_Info_Name (Uname);\n \n@@ -750,20 +767,26 @@ package body Lib.Writ is\n                   Write_With_File_Names (Fname, Munit_Index (Unum));\n                end if;\n \n-               if Elab_Flags (Unum) then\n-                  Write_Info_Str (\"  E\");\n-               end if;\n+               if Ekind (Cunit_Entity (Unum)) = E_Package\n+                  and then From_With_Type (Cunit_Entity (Unum))\n+               then\n+                  null;\n+               else\n+                  if Elab_Flags (Unum) then\n+                     Write_Info_Str (\"  E\");\n+                  end if;\n \n-               if Elab_All_Flags (Unum) then\n-                  Write_Info_Str (\"  EA\");\n-               end if;\n+                  if Elab_All_Flags (Unum) then\n+                     Write_Info_Str (\"  EA\");\n+                  end if;\n \n-               if Elab_Des_Flags (Unum) then\n-                  Write_Info_Str (\"  ED\");\n-               end if;\n+                  if Elab_Des_Flags (Unum) then\n+                     Write_Info_Str (\"  ED\");\n+                  end if;\n \n-               if Elab_All_Des_Flags (Unum) then\n-                  Write_Info_Str (\"  AD\");\n+                  if Elab_All_Des_Flags (Unum) then\n+                     Write_Info_Str (\"  AD\");\n+                  end if;\n                end if;\n             end if;\n \n@@ -971,11 +994,6 @@ package body Lib.Writ is\n          Write_Info_Str (\" NS\");\n       end if;\n \n-      if Optimize_Alignment /= 'O' then\n-         Write_Info_Str (\" O\");\n-         Write_Info_Char (Optimize_Alignment);\n-      end if;\n-\n       if Sec_Stack_Used then\n          Write_Info_Str (\" SS\");\n       end if;"}, {"sha": "f152742bfa7a4d87ea37e5a1feef0c337183e634", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -167,7 +167,7 @@ package Lib.Writ is\n    --    P <<parameters>>\n \n    --      Indicates various information that applies to the compilation\n-   --      of the corresponding source unit. Parameters is a sequence of\n+   --      of the corresponding source file. Parameters is a sequence of\n    --      zero or more two letter codes that indicate configuration\n    --      pragmas and other parameters that apply:\n    --\n@@ -211,10 +211,6 @@ package Lib.Writ is\n    --         NS   Normalize_Scalars pragma in effect for all units in\n    --              this file.\n    --\n-   --         OS   Optimize_Alignment (Space) active for all units in this file\n-   --\n-   --         OT   Optimize_Alignment (Time) active for all units in this file\n-   --\n    --         Qx   A valid Queueing_Policy pragma applies to all the units\n    --              in this file, where x is the first character (upper case)\n    --              of the policy name (e.g. 'P' for Priority_Queueing).\n@@ -462,7 +458,8 @@ package Lib.Writ is\n    --             case usage is detected, or the compiler cannot determine\n    --             the style, then no I parameter will appear.\n    --\n-   --         IS  Initialize_Scalars pragma applies to this unit\n+   --         IS  Initialize_Scalars pragma applies to this unit, or else there\n+   --             is at least one use of the Invalid_Value attribute.\n    --\n    --         KM  Unit source uses a style with keywords in mixed case\n    --         KU  (KM) or all upper case (KU). If the standard lower-case\n@@ -475,6 +472,23 @@ package Lib.Writ is\n    --             elaboration code is required. Set if N_Compilation_Unit\n    --             node has flag Has_No_Elaboration_Code set.\n    --\n+   --         OL   The units in this file are commpiled with a local pragma\n+   --              Optimize_Alignment, so no consistency requirement applies\n+   --              to these units. All internal units have this status since\n+   --              they have an automatic default of Optimize_Alignment (Off).\n+   --\n+   --         OO   Optimize_Alignment (Off) is the default setting for all\n+   --              units in this file. All files in the partition that specify\n+   --              a default must specify the same default.\n+   --\n+   --         OS   Optimize_Alignment (Space) is the default settinng for all\n+   --              units in this file. All files in the partition that specify\n+   --              a default must specify the same default.\n+   --\n+   --         OT   Optimize_Alignment (Time) is the default settinng for all\n+   --              units in this file. All files in the partition that specify\n+   --              a default must specify the same default.\n+   --\n    --         PK  Unit is package, rather than a subprogram\n    --\n    --         PU  Unit has pragma Pure"}, {"sha": "dd0e24552bf332f6832f1410cfcde1edd24c529b", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -145,6 +145,11 @@ package body Lib is\n       return Units.Table (U).Munit_Index;\n    end Munit_Index;\n \n+   function OA_Setting (U : Unit_Number_Type) return Character is\n+   begin\n+      return Units.Table (U).OA_Setting;\n+   end OA_Setting;\n+\n    function Source_Index (U : Unit_Number_Type) return Source_File_Index is\n    begin\n       return Units.Table (U).Source_Index;\n@@ -223,6 +228,11 @@ package body Lib is\n       Units.Table (U).Main_Priority := P;\n    end Set_Main_Priority;\n \n+   procedure Set_OA_Setting (U : Unit_Number_Type; C : Character) is\n+   begin\n+      Units.Table (U).OA_Setting := C;\n+   end Set_OA_Setting;\n+\n    procedure Set_Unit_Name (U : Unit_Number_Type; N : Unit_Name_Type) is\n    begin\n       Units.Table (U).Unit_Name := N;"}, {"sha": "672396e52b09f71271eca9960fdfe40813029aff", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -344,6 +344,10 @@ package Lib is\n    --      that the default priority is to be used (and is also used for\n    --      entries that do not correspond to possible main programs).\n \n+   --    OA_Setting\n+   --      This is a character field containing L if Optimize_Alignment mode\n+   --      was set locally, and O/T/S for Off/Time/Space default if not.\n+\n    --    Serial_Number\n    --      This field holds a serial number used by New_Internal_Name to\n    --      generate unique temporary numbers on a unit by unit basis. The\n@@ -385,6 +389,7 @@ package Lib is\n    function Loading          (U : Unit_Number_Type) return Boolean;\n    function Main_Priority    (U : Unit_Number_Type) return Int;\n    function Munit_Index      (U : Unit_Number_Type) return Nat;\n+   function OA_Setting       (U : Unit_Number_Type) return Character;\n    function Source_Index     (U : Unit_Number_Type) return Source_File_Index;\n    function Unit_File_Name   (U : Unit_Number_Type) return File_Name_Type;\n    function Unit_Name        (U : Unit_Number_Type) return Unit_Name_Type;\n@@ -401,6 +406,7 @@ package Lib is\n    procedure Set_Ident_String     (U : Unit_Number_Type; N : Node_Id);\n    procedure Set_Loading          (U : Unit_Number_Type; B : Boolean := True);\n    procedure Set_Main_Priority    (U : Unit_Number_Type; P : Int);\n+   procedure Set_OA_Setting       (U : Unit_Number_Type; C : Character);\n    procedure Set_Unit_Name        (U : Unit_Number_Type; N : Unit_Name_Type);\n    --  Set value of named field for given units table entry. Note that we\n    --  do not have an entry for each possible field, since some of the fields\n@@ -630,13 +636,15 @@ private\n    pragma Inline (Loading);\n    pragma Inline (Main_Priority);\n    pragma Inline (Munit_Index);\n+   pragma Inline (OA_Setting);\n    pragma Inline (Set_Cunit);\n    pragma Inline (Set_Cunit_Entity);\n    pragma Inline (Set_Fatal_Error);\n    pragma Inline (Set_Generate_Code);\n    pragma Inline (Set_Has_RACW);\n    pragma Inline (Set_Loading);\n    pragma Inline (Set_Main_Priority);\n+   pragma Inline (Set_OA_Setting);\n    pragma Inline (Set_Unit_Name);\n    pragma Inline (Source_Index);\n    pragma Inline (Unit_File_Name);\n@@ -662,6 +670,7 @@ private\n       Is_Compiler_Unit : Boolean;\n       Dynamic_Elab     : Boolean;\n       Loading          : Boolean;\n+      OA_Setting       : Character;\n    end record;\n \n    --  The following representation clause ensures that the above record\n@@ -686,11 +695,12 @@ private\n       Generate_Code    at 53 range 0 ..  7;\n       Has_RACW         at 54 range 0 ..  7;\n       Dynamic_Elab     at 55 range 0 ..  7;\n-      Is_Compiler_Unit at 56 range 0 .. 31;\n-      Loading          at 60 range 0 .. 31;\n+      Is_Compiler_Unit at 56 range 0 ..  7;\n+      OA_Setting       at 57 range 0 ..  7;\n+      Loading          at 58 range 0 .. 15;\n    end record;\n \n-   for Unit_Record'Size use 64 * 8;\n+   for Unit_Record'Size use 60 * 8;\n    --  This ensures that we did not leave out any fields\n \n    package Units is new Table.Table ("}, {"sha": "859a4170eadcdc657fcd4be4649f50edcf19ab62", "filename": "gcc/ada/opt.adb", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -49,6 +49,7 @@ package body Opt is\n       Ada_Version_Config                    := Ada_Version;\n       Ada_Version_Explicit_Config           := Ada_Version_Explicit;\n       Assertions_Enabled_Config             := Assertions_Enabled;\n+      Check_Policy_List_Config              := Check_Policy_List;\n       Debug_Pragmas_Enabled_Config          := Debug_Pragmas_Enabled;\n       Dynamic_Elaboration_Checks_Config     := Dynamic_Elaboration_Checks;\n       Exception_Locations_Suppressed_Config := Exception_Locations_Suppressed;\n@@ -60,6 +61,12 @@ package body Opt is\n       Persistent_BSS_Mode_Config            := Persistent_BSS_Mode;\n       Polling_Required_Config               := Polling_Required;\n       Use_VADS_Size_Config                  := Use_VADS_Size;\n+\n+      --  Reset the indication that Optimize_Alignment was set locally, since\n+      --  if we had a pragma in the config file, it would set this flag True,\n+      --  but that's not a local setting.\n+\n+      Optimize_Alignment_Local := False;\n    end Register_Opt_Config_Switches;\n \n    ---------------------------------\n@@ -71,6 +78,7 @@ package body Opt is\n       Ada_Version                    := Save.Ada_Version;\n       Ada_Version_Explicit           := Save.Ada_Version_Explicit;\n       Assertions_Enabled             := Save.Assertions_Enabled;\n+      Check_Policy_List              := Save.Check_Policy_List;\n       Debug_Pragmas_Enabled          := Save.Debug_Pragmas_Enabled;\n       Dynamic_Elaboration_Checks     := Save.Dynamic_Elaboration_Checks;\n       Exception_Locations_Suppressed := Save.Exception_Locations_Suppressed;\n@@ -79,6 +87,7 @@ package body Opt is\n       External_Name_Imp_Casing       := Save.External_Name_Imp_Casing;\n       Fast_Math                      := Save.Fast_Math;\n       Optimize_Alignment             := Save.Optimize_Alignment;\n+      Optimize_Alignment_Local       := Save.Optimize_Alignment_Local;\n       Persistent_BSS_Mode            := Save.Persistent_BSS_Mode;\n       Polling_Required               := Save.Polling_Required;\n       Use_VADS_Size                  := Save.Use_VADS_Size;\n@@ -93,6 +102,7 @@ package body Opt is\n       Save.Ada_Version                    := Ada_Version;\n       Save.Ada_Version_Explicit           := Ada_Version_Explicit;\n       Save.Assertions_Enabled             := Assertions_Enabled;\n+      Save.Check_Policy_List              := Check_Policy_List;\n       Save.Debug_Pragmas_Enabled          := Debug_Pragmas_Enabled;\n       Save.Dynamic_Elaboration_Checks     := Dynamic_Elaboration_Checks;\n       Save.Exception_Locations_Suppressed := Exception_Locations_Suppressed;\n@@ -101,6 +111,7 @@ package body Opt is\n       Save.External_Name_Imp_Casing       := External_Name_Imp_Casing;\n       Save.Fast_Math                      := Fast_Math;\n       Save.Optimize_Alignment             := Optimize_Alignment;\n+      Save.Optimize_Alignment_Local       := Optimize_Alignment_Local;\n       Save.Persistent_BSS_Mode            := Persistent_BSS_Mode;\n       Save.Polling_Required               := Polling_Required;\n       Save.Use_VADS_Size                  := Use_VADS_Size;\n@@ -131,33 +142,38 @@ package body Opt is\n          Optimize_Alignment         := 'O';\n          Persistent_BSS_Mode        := False;\n          Use_VADS_Size              := False;\n+         Optimize_Alignment_Local   := True;\n \n          --  For an internal unit, assertions/debug pragmas are off unless this\n          --  is the main unit and they were explicitly enabled.\n \n          if Main_Unit then\n             Assertions_Enabled    := Assertions_Enabled_Config;\n             Debug_Pragmas_Enabled := Debug_Pragmas_Enabled_Config;\n+            Check_Policy_List     := Check_Policy_List_Config;\n          else\n             Assertions_Enabled    := False;\n             Debug_Pragmas_Enabled := False;\n+            Check_Policy_List     := Empty;\n          end if;\n \n       --  Case of non-internal unit\n \n       else\n-         Ada_Version                := Ada_Version_Config;\n-         Ada_Version_Explicit       := Ada_Version_Explicit_Config;\n-         Assertions_Enabled         := Assertions_Enabled_Config;\n-         Debug_Pragmas_Enabled      := Debug_Pragmas_Enabled_Config;\n-         Dynamic_Elaboration_Checks := Dynamic_Elaboration_Checks_Config;\n-         Extensions_Allowed         := Extensions_Allowed_Config;\n-         External_Name_Exp_Casing   := External_Name_Exp_Casing_Config;\n-         External_Name_Imp_Casing   := External_Name_Imp_Casing_Config;\n-         Fast_Math                  := Fast_Math_Config;\n-         Optimize_Alignment         := Optimize_Alignment_Config;\n-         Persistent_BSS_Mode        := Persistent_BSS_Mode_Config;\n-         Use_VADS_Size              := Use_VADS_Size_Config;\n+         Ada_Version                 := Ada_Version_Config;\n+         Ada_Version_Explicit        := Ada_Version_Explicit_Config;\n+         Assertions_Enabled          := Assertions_Enabled_Config;\n+         Check_Policy_List           := Check_Policy_List_Config;\n+         Debug_Pragmas_Enabled       := Debug_Pragmas_Enabled_Config;\n+         Dynamic_Elaboration_Checks  := Dynamic_Elaboration_Checks_Config;\n+         Extensions_Allowed          := Extensions_Allowed_Config;\n+         External_Name_Exp_Casing    := External_Name_Exp_Casing_Config;\n+         External_Name_Imp_Casing    := External_Name_Imp_Casing_Config;\n+         Fast_Math                   := Fast_Math_Config;\n+         Optimize_Alignment          := Optimize_Alignment_Config;\n+         Optimize_Alignment_Local    := False;\n+         Persistent_BSS_Mode         := Persistent_BSS_Mode_Config;\n+         Use_VADS_Size               := Use_VADS_Size_Config;\n       end if;\n \n       Exception_Locations_Suppressed := Exception_Locations_Suppressed_Config;\n@@ -192,6 +208,7 @@ package body Opt is\n       Tree_Read_Int  (Assertions_Enabled_Config_Val);\n       Tree_Read_Bool (All_Errors_Mode);\n       Tree_Read_Bool (Assertions_Enabled);\n+      Tree_Read_Int  (Int (Check_Policy_List));\n       Tree_Read_Bool (Debug_Pragmas_Enabled);\n       Tree_Read_Bool (Enable_Overflow_Checks);\n       Tree_Read_Bool (Full_List);\n@@ -256,6 +273,7 @@ package body Opt is\n       Tree_Write_Int  (Boolean'Pos (Assertions_Enabled_Config));\n       Tree_Write_Bool (All_Errors_Mode);\n       Tree_Write_Bool (Assertions_Enabled);\n+      Tree_Write_Int  (Int (Check_Policy_List));\n       Tree_Write_Bool (Debug_Pragmas_Enabled);\n       Tree_Write_Bool (Enable_Overflow_Checks);\n       Tree_Write_Bool (Full_List);"}, {"sha": "65a9bb4bd8dbab9690b29fa5079928271292eff1", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -214,6 +214,12 @@ package Opt is\n    --  GNATBIND\n    --  Set to True to do checks only, no output of binder file\n \n+   Check_Policy_List : Node_Id := Empty;\n+   --  GNAT\n+   --  This points to the list of N_Pragma nodes for Check_Policy pragmas\n+   --  that are linked through the Next_Pragma fields, with the list being\n+   --  terminated by Empty. The order is most recently processed first.\n+\n    Check_Readonly_Files : Boolean := False;\n    --  GNATMAKE\n    --  Set to True to check readonly files during the make process\n@@ -400,7 +406,7 @@ package Opt is\n    --  message routines generates one line of output as a separate message.\n    --  If it is set to a non-zero value, then continuation lines are folded\n    --  to make a single long message, and then this message is split up into\n-   --  multiple lines not exceeding the specified length. Set by -gnatLnnn.\n+   --  multiple lines not exceeding the specified length. Set by -gnatj=nn.\n \n    Exception_Locations_Suppressed : Boolean := False;\n    --  GNAT\n@@ -620,6 +626,10 @@ package Opt is\n    --  generate code even in case of unsupported construct, so that the byte\n    --  code can be used by static analysis tools.\n \n+   Invalid_Value_Used : Boolean := False;\n+   --  GNAT\n+   --  Set True if a valid Invalid_Value attribute is encountered\n+\n    Follow_Links_For_Files : Boolean := False;\n    --  PROJECT MANAGER\n    --  Set to True (-eL) to process the project files in trusted mode\n@@ -862,6 +872,14 @@ package Opt is\n    --  Setting of Optimize_Alignment, set to T/S/O for time/space/off. Can\n    --  be modified by use of pragma Optimize_Alignment.\n \n+   Optimize_Alignment_Local : Boolean := False;\n+   --  Set True if Optimize_Alignment mode is set by a local configuration\n+   --  pragma that overrides the gnat.adc (or other configuration file) default\n+   --  so that the unit is not dependent on the default setting. Also always\n+   --  set True for internal units, since these always have a default setting\n+   --  of Optimize_Alignment (Off) that is enforced (essentially equivalent to\n+   --  them all having such an explicit pragma in each unit).\n+\n    Original_Operating_Mode : Operating_Mode_Type := Generate_Code;\n    --  GNAT\n    --  Indicates the original operating mode of the compiler as set by\n@@ -870,7 +888,7 @@ package Opt is\n \n    Optimization_Level : Int;\n    pragma Import (C, Optimization_Level, \"optimize\");\n-   --  This constant reflects the optimization level (0,1,2 for -O0,-O1,-O2)\n+   --  Constant reflecting the optimization level (0,1,2,3 for -O0,-O1,-O2,-O3)\n \n    Output_File_Name_Present : Boolean := False;\n    --  GNATBIND, GNAT, GNATMAKE, GPRMAKE\n@@ -1133,7 +1151,7 @@ package Opt is\n \n    Upper_Half_Encoding : Boolean := False;\n    --  GNAT, GNATBIND\n-   --  Normally set False, indicating that upper half ASCII characters are\n+   --  Normally set False, indicating that upper half ISO 8859-1 characters are\n    --  used in the normal way to represent themselves. If the wide character\n    --  encoding method uses the upper bit for this encoding, then this flag is\n    --  set True, and upper half characters in the source indicate the start of\n@@ -1190,6 +1208,12 @@ package Opt is\n    --  including warnings on Ada 2005 obsolescent features used in Ada 2005\n    --  mode. Set False by -gnatwY.\n \n+   Warn_On_Parameter_Order : Boolean := False;\n+   --  GNAT\n+   --  Set to True to generate warnings for cases where the argument list for\n+   --  a call is a sequence of identifiers that match the formal identifiers,\n+   --  but are in the wrong order.\n+\n    Warn_On_Assertion_Failure : Boolean := True;\n    --  GNAT\n    --  Set to True to activate warnings on assertions that can be determined\n@@ -1374,6 +1398,13 @@ package Opt is\n    --  mode, as possibly set by the command line switch -gnata, and possibly\n    --  modified by the use of the configuration pragma Assertion_Policy.\n \n+   Check_Policy_List_Config : Node_Id;\n+   --  GNAT\n+   --  This points to the list of N_Pragma nodes for Check_Policy pragmas\n+   --  that are linked through the Next_Pragma fields, with the list being\n+   --  terminated by Empty. The order is most recently processed first. This\n+   --  list includes only those pragmas in configuration pragma files.\n+\n    Debug_Pragmas_Enabled_Config : Boolean;\n    --  GNAT\n    --  This is the value of the configuration switch for debug pragmas enabled\n@@ -1485,9 +1516,10 @@ package Opt is\n    --  call to Save_Opt_Switches.\n \n    procedure Register_Opt_Config_Switches;\n-   --  This procedure is called after processing the gnat.adc file to record\n-   --  the values of the Config switches, as possibly modified by the use of\n-   --  command line switches and configuration pragmas.\n+   --  This procedure is called after processing the gnat.adc file and other\n+   --  configuration pragma files to record the values of the Config switches,\n+   --  as possibly modified by the use of command line switches and pragmas\n+   --  appearing in these files.\n \n    ------------------------\n    -- Other Global Flags --\n@@ -1564,6 +1596,7 @@ private\n       Ada_Version                    : Ada_Version_Type;\n       Ada_Version_Explicit           : Ada_Version_Type;\n       Assertions_Enabled             : Boolean;\n+      Check_Policy_List              : Node_Id;\n       Debug_Pragmas_Enabled          : Boolean;\n       Dynamic_Elaboration_Checks     : Boolean;\n       Exception_Locations_Suppressed : Boolean;\n@@ -1572,6 +1605,7 @@ private\n       External_Name_Imp_Casing       : External_Casing_Type;\n       Fast_Math                      : Boolean;\n       Optimize_Alignment             : Character;\n+      Optimize_Alignment_Local       : Boolean;\n       Persistent_BSS_Mode            : Boolean;\n       Polling_Required               : Boolean;\n       Use_VADS_Size                  : Boolean;"}, {"sha": "bd9b5746f3cd54af44e8522c46af36afecb7894a", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 276, "deletions": 73, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -28,6 +28,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Util; use Exp_Util;\n+with Elists;   use Elists;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Freeze;   use Freeze;\n@@ -1247,6 +1248,16 @@ package body Sem_Ch10 is\n          Next (Item);\n       end loop;\n \n+      --  This is the point at which we capture the configuration settings\n+      --  for the unit. At the moment only the Optimize_Alignment setting\n+      --  needs to be captured. Probably more later ???\n+\n+      if Optimize_Alignment_Local then\n+         Set_OA_Setting (Current_Sem_Unit, 'L');\n+      else\n+         Set_OA_Setting (Current_Sem_Unit, Optimize_Alignment);\n+      end if;\n+\n       --  Loop through actual context items. This is done in two passes:\n \n       --  a) The first pass analyzes non-limited with-clauses and also any\n@@ -1305,14 +1316,12 @@ package body Sem_Ch10 is\n \n             if not Implicit_With (Item) then\n \n-               --  Check compilation unit containing the limited-with clause\n+               --  Verify that the illegal contexts given in 10.1.2 (18/2)\n+               --  are properly rejected, including renaming declarations.\n \n                if not Nkind_In (Ukind, N_Package_Declaration,\n-                                       N_Subprogram_Declaration,\n-                                       N_Package_Renaming_Declaration,\n-                                       N_Subprogram_Renaming_Declaration)\n+                                       N_Subprogram_Declaration)\n                  and then Ukind not in N_Generic_Declaration\n-                 and then Ukind not in N_Generic_Renaming_Declaration\n                  and then Ukind not in N_Generic_Instantiation\n                then\n                   Error_Msg_N (\"limited with_clause not allowed here\", Item);\n@@ -2221,12 +2230,21 @@ package body Sem_Ch10 is\n                            Cunit_Boolean_Restrictions_Save;\n \n    begin\n+      U := Unit (Library_Unit (N));\n+\n+      --  Several actions are skipped for dummy packages (those supplied for\n+      --  with's where no matching file could be found). Such packages are\n+      --  identified by the Sloc value being set to No_Location.\n+\n       if Limited_Present (N) then\n \n          --  Ada 2005 (AI-50217): Build visibility structures but do not\n          --  analyze the unit.\n \n-         Build_Limited_Views (N);\n+         if Sloc (U) /= No_Location then\n+            Build_Limited_Views (N);\n+         end if;\n+\n          return;\n       end if;\n \n@@ -2256,13 +2274,8 @@ package body Sem_Ch10 is\n          Semantics (Library_Unit (N));\n       end if;\n \n-      U := Unit (Library_Unit (N));\n       Intunit := Is_Internal_File_Name (Unit_File_Name (Current_Sem_Unit));\n \n-      --  Following checks are skipped for dummy packages (those supplied for\n-      --  with's where no matching file could be found). Such packages are\n-      --  identified by the Sloc value being set to No_Location\n-\n       if Sloc (U) /= No_Location then\n \n          --  Check restrictions, except that we skip the check if this is an\n@@ -2529,6 +2542,7 @@ package body Sem_Ch10 is\n \n          if Nkind (Item) = N_With_Clause\n             and then not Implicit_With (Item)\n+            and then not Limited_Present (Item)\n             and then Is_Private_Descendant (Entity (Name (Item)))\n          then\n             Priv_Child := Entity (Name (Item));\n@@ -3166,7 +3180,11 @@ package body Sem_Ch10 is\n       --  Check that if a limited_with clause of a given compilation_unit\n       --  mentions a descendant of a private child of some library unit,\n       --  then the given compilation_unit shall be the declaration of a\n-      --  private descendant of that library unit.\n+      --  private descendant of that library unit, or a public descendant\n+      --  of such. The code is analogous to that of Check_Private_Child_Unit\n+      --  but we cannot use entities on the limited with_clauses because\n+      --  their units have not been analyzed, so we have to climb the tree\n+      --  of ancestors looking for private keywords.\n \n       procedure Expand_Limited_With_Clause\n         (Comp_Unit : Node_Id;\n@@ -3277,11 +3295,12 @@ package body Sem_Ch10 is\n       procedure Check_Private_Limited_Withed_Unit (Item : Node_Id) is\n          Curr_Parent  : Node_Id;\n          Child_Parent : Node_Id;\n+         Curr_Private : Boolean;\n \n       begin\n          --  Compilation unit of the parent of the withed library unit\n \n-         Child_Parent := Parent_Spec (Unit (Library_Unit (Item)));\n+         Child_Parent := Library_Unit (Item);\n \n          --  If the child unit is a public child, then locate its nearest\n          --  private ancestor, if any; Child_Parent will then be set to\n@@ -3297,18 +3316,21 @@ package body Sem_Ch10 is\n             if No (Child_Parent) then\n                return;\n             end if;\n-\n-            Child_Parent := Parent_Spec (Unit (Child_Parent));\n          end if;\n \n+         Child_Parent := Parent_Spec (Unit (Child_Parent));\n+\n          --  Traverse all the ancestors of the current compilation\n          --  unit to check if it is a descendant of named library unit.\n \n          Curr_Parent := Parent (Item);\n+         Curr_Private := Private_Present (Curr_Parent);\n+\n          while Present (Parent_Spec (Unit (Curr_Parent)))\n            and then Curr_Parent /= Child_Parent\n          loop\n             Curr_Parent := Parent_Spec (Unit (Curr_Parent));\n+            Curr_Private := Curr_Private or else Private_Present (Curr_Parent);\n          end loop;\n \n          if Curr_Parent /= Child_Parent then\n@@ -3318,12 +3340,18 @@ package body Sem_Ch10 is\n               (\"\\current unit must also have parent&!\",\n                Item, Defining_Unit_Name (Specification (Unit (Child_Parent))));\n \n-         elsif not Private_Present (Parent (Item))\n-           and then not Private_Present (Item)\n-           and then not Nkind_In (Unit (Parent (Item)), N_Package_Body,\n+         elsif Private_Present (Parent (Item))\n+            or else Curr_Private\n+            or else Private_Present (Item)\n+            or else Nkind_In (Unit (Parent (Item)), N_Package_Body,\n                                                         N_Subprogram_Body,\n                                                         N_Subunit)\n          then\n+            --  Current unit is private, of descendant of a private unit.\n+\n+            null;\n+\n+         else\n             Error_Msg_NE\n               (\"current unit must also be private descendant of&\",\n                Item, Defining_Unit_Name (Specification (Unit (Child_Parent))));\n@@ -3722,16 +3750,20 @@ package body Sem_Ch10 is\n       Item := First (Context_Items (N));\n       while Present (Item) loop\n \n-         --  Do not install private_with_clauses if the unit is a package\n-         --  declaration, unless it is itself a private child unit.\n+         --  Do not install private_with_clauses declaration, unless\n+         --  unit is itself a private child unit, or is a body.\n+         --  Note that for a subprogram body the private_with_clause does\n+         --  not take effect until after the specification.\n \n-         if Nkind (Item) = N_With_Clause\n-           and then not Implicit_With (Item)\n-           and then not Limited_Present (Item)\n-           and then\n-              (not Private_Present (Item)\n-                 or else Nkind (Unit (N)) /= N_Package_Declaration\n-                 or else Private_Present (N))\n+         if Nkind (Item) /= N_With_Clause\n+           or else Implicit_With (Item)\n+           or else Limited_Present (Item)\n+         then\n+            null;\n+\n+         elsif not Private_Present (Item)\n+           or else Private_Present (N)\n+           or else Nkind (Unit (N)) = N_Package_Body\n          then\n             Id := Entity (Name (Item));\n \n@@ -3792,15 +3824,26 @@ package body Sem_Ch10 is\n                   end loop;\n                end;\n             end if;\n+\n+         --  If the item is a private with-clause on a child unit, the parent\n+         --  may have been installed already, but the child unit must remain\n+         --  invisible until installed in a private part or body.\n+\n+         elsif Private_Present (Item) then\n+            Id := Entity (Name (Item));\n+\n+            if Is_Child_Unit (Id) then\n+               Set_Is_Visible_Child_Unit (Id, False);\n+            end if;\n          end if;\n \n          Next (Item);\n       end loop;\n    end Install_Siblings;\n \n-   -------------------------------\n-   -- Install_Limited_With_Unit --\n-   -------------------------------\n+   ---------------------------------\n+   -- Install_Limited_Withed_Unit --\n+   ---------------------------------\n \n    procedure Install_Limited_Withed_Unit (N : Node_Id) is\n       P_Unit           : constant Entity_Id := Unit (Library_Unit (N));\n@@ -3810,6 +3853,14 @@ package body Sem_Ch10 is\n       Lim_Header       : Entity_Id;\n       Lim_Typ          : Entity_Id;\n \n+      procedure Check_Body_Required;\n+      --  A unit mentioned in a limited with_clause may not be mentioned in\n+      --  a regular with_clause, but must still be included in the current\n+      --  partition. We need to determine whether the unit needs a body, so\n+      --  that the binder can determine the name of the file to be compiled.\n+      --  Checking whether a unit needs a body can be done without semantic\n+      --  analysis, by examining the nature of the declarations in the package.\n+\n       function Has_Limited_With_Clause\n         (C_Unit : Entity_Id;\n          Pack   : Entity_Id) return Boolean;\n@@ -3828,6 +3879,157 @@ package body Sem_Ch10 is\n       --  Check if some package installed though normal with-clauses has a\n       --  renaming declaration of package P. AARM 10.1.2(21/2).\n \n+      -------------------------\n+      -- Check_Body_Required --\n+      -------------------------\n+\n+      --  ??? misses pragma Import on subprograms\n+      --  ??? misses pragma Import on renamed subprograms\n+\n+      procedure Check_Body_Required is\n+         PA : constant List_Id :=\n+                Pragmas_After (Aux_Decls_Node (Parent (P_Unit)));\n+\n+         procedure Check_Declarations (Spec : Node_Id);\n+         --  Recursive procedure that does the work and checks nested packages\n+\n+         ------------------------\n+         -- Check_Declarations --\n+         ------------------------\n+\n+         procedure Check_Declarations (Spec : Node_Id) is\n+            Decl             : Node_Id;\n+            Incomplete_Decls : constant Elist_Id := New_Elmt_List;\n+\n+         begin\n+            --  Search for Elaborate Body pragma\n+\n+            Decl := First (Visible_Declarations (Spec));\n+            while Present (Decl)\n+              and then Nkind (Decl) = N_Pragma\n+            loop\n+               if Get_Pragma_Id (Decl) = Pragma_Elaborate_Body then\n+                  Set_Body_Required (Library_Unit (N));\n+                  return;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+\n+            --  Look for declarations that require the presence of a body\n+\n+            while Present (Decl) loop\n+\n+               --  Subprogram that comes from source means body required\n+               --  This is where a test for Import is missing ???\n+\n+               if Comes_From_Source (Decl)\n+                 and then (Nkind_In (Decl, N_Subprogram_Declaration,\n+                                           N_Generic_Subprogram_Declaration))\n+               then\n+                  Set_Body_Required (Library_Unit (N));\n+                  return;\n+\n+               --  Package declaration of generic package declaration. We need\n+               --  to recursively examine nested declarations.\n+\n+               elsif Nkind_In (Decl, N_Package_Declaration,\n+                                     N_Generic_Package_Declaration)\n+               then\n+                  Check_Declarations (Specification (Decl));\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+\n+            --  Same set of tests for private part. In addition to subprograms\n+            --  detect the presence of Taft Amendment types (incomplete types\n+            --  completed in the body).\n+\n+            Decl := First (Private_Declarations (Spec));\n+            while Present (Decl) loop\n+               if Comes_From_Source (Decl)\n+                 and then (Nkind_In (Decl, N_Subprogram_Declaration,\n+                                           N_Generic_Subprogram_Declaration))\n+               then\n+                  Set_Body_Required (Library_Unit (N));\n+\n+               elsif Nkind_In (Decl, N_Package_Declaration,\n+                                     N_Generic_Package_Declaration)\n+               then\n+                  Check_Declarations (Specification (Decl));\n+\n+               --  Collect incomplete type declarations for separate pass\n+\n+               elsif Nkind (Decl) = N_Incomplete_Type_Declaration then\n+                  Append_Elmt (Decl, Incomplete_Decls);\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+\n+            --  Now check incomplete declarations to locate Taft amendment\n+            --  types. This can be done by examing the defining identifiers\n+            --  of  type declarations without real semantic analysis.\n+\n+            declare\n+               Inc : Elmt_Id;\n+\n+            begin\n+               Inc := First_Elmt (Incomplete_Decls);\n+               while Present (Inc) loop\n+                  Decl := Next (Node (Inc));\n+                  while Present (Decl) loop\n+                     if Nkind (Decl) = N_Full_Type_Declaration\n+                       and then Chars (Defining_Identifier (Decl)) =\n+                                Chars (Defining_Identifier (Node (Inc)))\n+                     then\n+                        exit;\n+                     end if;\n+\n+                     Next (Decl);\n+                  end loop;\n+\n+                  --  If no completion, this is a TAT, and a body is needed\n+\n+                  if No (Decl) then\n+                     Set_Body_Required (Library_Unit (N));\n+                     return;\n+                  end if;\n+\n+                  Next_Elmt (Inc);\n+               end loop;\n+            end;\n+         end Check_Declarations;\n+\n+      --  Start of processing for Check_Body_Required\n+\n+      begin\n+         --  If this is an imported package (Java and CIL usage) no body is\n+         --  needed. Scan list of pragmas that may follow a compilation unit\n+         --  to look for a relevant pragma Import.\n+\n+         if Present (PA) then\n+            declare\n+               Prag : Node_Id;\n+\n+            begin\n+               Prag := First (PA);\n+               while Present (Prag) loop\n+                  if Nkind (Prag) = N_Pragma\n+                    and then Get_Pragma_Id (Prag) = Pragma_Import\n+                  then\n+                     return;\n+                  end if;\n+\n+                  Next (Prag);\n+               end loop;\n+            end;\n+         end if;\n+\n+         Check_Declarations (Specification (P_Unit));\n+      end Check_Body_Required;\n+\n       -----------------------------\n       -- Has_Limited_With_Clause --\n       -----------------------------\n@@ -4017,9 +4219,12 @@ package body Sem_Ch10 is\n \n       --  In case of limited with_clause on subprograms, generics, instances,\n       --  or renamings, the corresponding error was previously posted and we\n-      --  have nothing to do here.\n+      --  have nothing to do here. If the file is missing altogether, it has\n+      --  no source location.\n \n-      if Nkind (P_Unit) /= N_Package_Declaration then\n+      if Nkind (P_Unit) /= N_Package_Declaration\n+        or else Sloc (P_Unit) = No_Location\n+      then\n          return;\n       end if;\n \n@@ -4105,39 +4310,11 @@ package body Sem_Ch10 is\n       --  view of X supersedes its limited view.\n \n       if Analyzed (P_Unit)\n-        and then (Is_Immediately_Visible (P)\n-                    or else (Is_Child_Package\n-                               and then Is_Visible_Child_Unit (P)))\n+        and then\n+          (Is_Immediately_Visible (P)\n+            or else\n+              (Is_Child_Package and then Is_Visible_Child_Unit (P)))\n       then\n-         --  Ada 2005 (AI-262): Install the private declarations of P\n-\n-         if Private_Present (N)\n-           and then not In_Private_Part (P)\n-         then\n-            declare\n-               Id : Entity_Id;\n-\n-            begin\n-               Id := First_Private_Entity (P);\n-               while Present (Id) loop\n-                  if not Is_Internal (Id)\n-                    and then not Is_Child_Unit (Id)\n-                  then\n-                     if not In_Chain (Id) then\n-                        Set_Homonym (Id, Current_Entity (Id));\n-                        Set_Current_Entity (Id);\n-                     end if;\n-\n-                     Set_Is_Immediately_Visible (Id);\n-                  end if;\n-\n-                  Next_Entity (Id);\n-               end loop;\n-\n-               Set_In_Private_Part (P);\n-            end;\n-         end if;\n-\n          return;\n       end if;\n \n@@ -4296,6 +4473,13 @@ package body Sem_Ch10 is\n       Set_Is_Immediately_Visible (P);\n       Set_Limited_View_Installed (N);\n \n+      --  If unit has not been analyzed in some previous context, check\n+      --  (imperfectly ???) whether it might need a body.\n+\n+      if not Analyzed (P_Unit) then\n+         Check_Body_Required;\n+      end if;\n+\n       --  If the package in the limited_with clause is a child unit, the\n       --  clause is unanalyzed and appears as a selected component. Recast\n       --  it as an expanded name so that the entity can be properly set. Use\n@@ -4674,12 +4858,24 @@ package body Sem_Ch10 is\n \n          --  Build corresponding class_wide type, if not previously done\n \n-         --  Warning: The class-wide entity is shared by the limited-view\n+         --  Note: The class-wide entity is shared by the limited-view\n          --  and the full-view.\n \n          if No (Class_Wide_Type (T)) then\n             CW := Make_Defining_Identifier (Loc,  New_Internal_Name ('S'));\n \n+            --  Set parent to be the same as the parent of the tagged type.\n+            --  We need a parent field set, and it is supposed to point to\n+            --  the declaration of the type. The tagged type declaration\n+            --  essentially declares two separate types, the tagged type\n+            --  itself and the corresponding class-wide type, so it is\n+            --  reasonable for the parent fields to point to the declaration\n+            --  in both cases.\n+\n+            Set_Parent (CW, Parent (T));\n+\n+            --  Set remaining fields of classwide type\n+\n             Set_Ekind                     (CW, E_Class_Wide_Type);\n             Set_Etype                     (CW, T);\n             Set_Scope                     (CW, Scop);\n@@ -4691,6 +4887,8 @@ package body Sem_Ch10 is\n             Set_Equivalent_Type           (CW, Empty);\n             Set_From_With_Type            (CW, From_With_Type (T));\n \n+            --  Link type to its class-wide type\n+\n             Set_Class_Wide_Type           (T, CW);\n          end if;\n       end Decorate_Tagged_Type;\n@@ -4807,12 +5005,19 @@ package body Sem_Ch10 is\n                Set_Non_Limited_View (Lim_Typ, Comp_Typ);\n \n             elsif Nkind_In (Decl, N_Private_Type_Declaration,\n-                                  N_Incomplete_Type_Declaration)\n+                                  N_Incomplete_Type_Declaration,\n+                                  N_Task_Type_Declaration,\n+                                  N_Protected_Type_Declaration)\n             then\n                Comp_Typ := Defining_Identifier (Decl);\n \n+               Is_Tagged :=\n+                 Nkind_In (Decl, N_Private_Type_Declaration,\n+                                 N_Incomplete_Type_Declaration)\n+                 and then Tagged_Present (Decl);\n+\n                if not Analyzed_Unit then\n-                  if Tagged_Present (Decl) then\n+                  if Is_Tagged then\n                      Decorate_Tagged_Type (Sloc (Decl), Comp_Typ, Scope);\n                   else\n                      Decorate_Incomplete_Type (Comp_Typ, Scope);\n@@ -4828,7 +5033,7 @@ package body Sem_Ch10 is\n                Set_Parent (Lim_Typ, Parent (Comp_Typ));\n                Set_From_With_Type (Lim_Typ);\n \n-               if Tagged_Present (Decl) then\n+               if Is_Tagged then\n                   Decorate_Tagged_Type (Sloc (Decl), Lim_Typ, Scope);\n                else\n                   Decorate_Incomplete_Type (Lim_Typ, Scope);\n@@ -4902,13 +5107,11 @@ package body Sem_Ch10 is\n    begin\n       pragma Assert (Limited_Present (N));\n \n-      --  A library_item mentioned in a limited_with_clause shall\n-      --  be a package_declaration, not a subprogram_declaration,\n-      --  generic_declaration, generic_instantiation, or\n-      --  package_renaming_declaration\n+      --  A library_item mentioned in a limited_with_clause is a package\n+      --  declaration, not a subprogram declaration, generic declaration,\n+      --  generic instantiation, or package renaming declaration.\n \n       case Nkind (Unit (Library_Unit (N))) is\n-\n          when N_Package_Declaration =>\n             null;\n "}, {"sha": "00e471abf66896cf0bc87722a6da88b6672ae6ef", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 347, "deletions": 129, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -236,6 +236,7 @@ package body Sem_Ch3 is\n    --  itype. The Itype_Reference node forces the elaboration of the itype\n    --  in the proper scope. The node is inserted after Nod, which is the\n    --  enclosing declaration that generated Ityp.\n+   --\n    --  A related mechanism is used during expansion, for itypes created in\n    --  branches of conditionals. See Ensure_Defined in exp_util.\n    --  Could both mechanisms be merged ???\n@@ -341,11 +342,11 @@ package body Sem_Ch3 is\n       Constraints : Elist_Id);\n    --  Build the list of entities for a constrained discriminated record\n    --  subtype. If a component depends on a discriminant, replace its subtype\n-   --  using the discriminant values in the discriminant constraint. Subt is\n-   --  the defining identifier for the subtype whose list of constrained\n-   --  entities we will create. Decl_Node is the type declaration node where we\n-   --  will attach all the itypes created. Typ is the base discriminated type\n-   --  for the subtype Subt. Constraints is the list of discriminant\n+   --  using the discriminant values in the discriminant constraint. Subt\n+   --  is the defining identifier for the subtype whose list of constrained\n+   --  entities we will create. Decl_Node is the type declaration node where\n+   --  we will attach all the itypes created. Typ is the base discriminated\n+   --  type for the subtype Subt. Constraints is the list of discriminant\n    --  constraints for Typ.\n \n    function Constrain_Component_Type\n@@ -362,6 +363,7 @@ package body Sem_Ch3 is\n    --  Constrained_Typ is the final constrained subtype to which the\n    --  constrained Compon_Type belongs. Related_Node is the node where we will\n    --  attach all the itypes created.\n+   --\n    --  Above description is confused, what is Compon_Type???\n \n    procedure Constrain_Access\n@@ -504,12 +506,11 @@ package body Sem_Ch3 is\n      (T             : Entity_Id;\n       N             : Node_Id;\n       Is_Completion : Boolean);\n-   --  Process a derived type declaration. This routine will invoke\n-   --  Build_Derived_Type to process the actual derived type definition.\n-   --  Parameters N and Is_Completion have the same meaning as in\n-   --  Build_Derived_Type. T is the N_Defining_Identifier for the entity\n-   --  defined in the N_Full_Type_Declaration node N, that is T is the derived\n-   --  type.\n+   --  Process a derived type declaration. Build_Derived_Type is invoked\n+   --  to process the actual derived type definition. Parameters N and\n+   --  Is_Completion have the same meaning as in Build_Derived_Type.\n+   --  T is the N_Defining_Identifier for the entity defined in the\n+   --  N_Full_Type_Declaration node N, that is T is the derived type.\n \n    procedure Enumeration_Type_Declaration (T : Entity_Id; Def : Node_Id);\n    --  Insert each literal in symbol table, as an overloadable identifier. Each\n@@ -521,7 +522,7 @@ package body Sem_Ch3 is\n    function Expand_To_Stored_Constraint\n      (Typ        : Entity_Id;\n       Constraint : Elist_Id) return Elist_Id;\n-   --  Given a Constraint (i.e. a list of expressions) on the discriminants of\n+   --  Given a constraint (i.e. a list of expressions) on the discriminants of\n    --  Typ, expand it into a constraint on the stored discriminants and return\n    --  the new list of expressions constraining the stored discriminants.\n \n@@ -532,7 +533,7 @@ package body Sem_Ch3 is\n    --  implicit types generated to Related_Nod\n \n    procedure Floating_Point_Type_Declaration (T : Entity_Id; Def : Node_Id);\n-   --  Create a new float, and apply the constraint to obtain subtype of it\n+   --  Create a new float and apply the constraint to obtain subtype of it\n \n    function Has_Range_Constraint (N : Node_Id) return Boolean;\n    --  Given an N_Subtype_Indication node N, return True if a range constraint\n@@ -582,6 +583,14 @@ package body Sem_Ch3 is\n    --  copying the record declaration for the derived base. In the tagged case\n    --  the value returned is irrelevant.\n \n+   function Is_Progenitor\n+     (Iface : Entity_Id;\n+      Typ   :  Entity_Id) return Boolean;\n+   --  Determine whether type Typ implements interface Iface. This requires\n+   --  traversing the list of abstract interfaces of the type, as well as that\n+   --  of the ancestor types. The predicate is used to determine when a formal\n+   --  in the signature of an inherited operation must carry the derived type.\n+\n    function Is_Valid_Constraint_Kind\n      (T_Kind          : Type_Kind;\n       Constraint_Kind : Node_Kind) return Boolean;\n@@ -632,16 +641,16 @@ package body Sem_Ch3 is\n    --  Similarly, access_to_subprogram types may have a parameter or a return\n    --  type that is an incomplete type, and that must be replaced with the\n    --  full type.\n-\n+   --\n    --  If the full type is tagged, subprogram with access parameters that\n    --  designated the incomplete may be primitive operations of the full type,\n    --  and have to be processed accordingly.\n \n    procedure Process_Real_Range_Specification (Def : Node_Id);\n-   --  Given the type definition for a real type, this procedure processes\n-   --  and checks the real range specification of this type definition if\n-   --  one is present. If errors are found, error messages are posted, and\n-   --  the Real_Range_Specification of Def is reset to Empty.\n+   --  Given the type definition for a real type, this procedure processes and\n+   --  checks the real range specification of this type definition if one is\n+   --  present. If errors are found, error messages are posted, and the\n+   --  Real_Range_Specification of Def is reset to Empty.\n \n    procedure Record_Type_Declaration\n      (T    : Entity_Id;\n@@ -655,14 +664,14 @@ package body Sem_Ch3 is\n    --  cross-referencing. Otherwise Prev = T.\n \n    procedure Record_Type_Definition (Def : Node_Id; Prev_T : Entity_Id);\n-   --  This routine is used to process the actual record type definition\n-   --  (both for untagged and tagged records). Def is a record type\n-   --  definition node. This procedure analyzes the components in this\n-   --  record type definition. Prev_T is the entity for the enclosing record\n-   --  type. It is provided so that its Has_Task flag can be set if any of\n-   --  the component have Has_Task set. If the declaration is the completion\n-   --  of an incomplete type declaration, Prev_T is the original incomplete\n-   --  type, whose full view is the record type.\n+   --  This routine is used to process the actual record type definition (both\n+   --  for untagged and tagged records). Def is a record type definition node.\n+   --  This procedure analyzes the components in this record type definition.\n+   --  Prev_T is the entity for the enclosing record type. It is provided so\n+   --  that its Has_Task flag can be set if any of the component have Has_Task\n+   --  set. If the declaration is the completion of an incomplete type\n+   --  declaration, Prev_T is the original incomplete type, whose full view is\n+   --  the record type.\n \n    procedure Replace_Components (Typ : Entity_Id; Decl : Node_Id);\n    --  Subsidiary to Build_Derived_Record_Type. For untagged records, we\n@@ -809,8 +818,20 @@ package body Sem_Ch3 is\n       Set_Directly_Designated_Type\n                              (Anon_Type, Desig_Type);\n       Set_Etype              (Anon_Type, Anon_Type);\n-      Init_Size_Align        (Anon_Type);\n+\n+      --  Make sure the anonymous access type has size and alignment fields\n+      --  set, as required by gigi. This is necessary in the case of the\n+      --  Task_Body_Procedure.\n+\n+      if not Has_Private_Component (Desig_Type) then\n+         Layout_Type (Anon_Type);\n+      end if;\n+\n+      --  ???The following makes no sense, because Anon_Type is an access type\n+      --  and therefore cannot have components, private or otherwise. Hence\n+      --  the assertion. Not sure what was meant, here.\n       Set_Depends_On_Private (Anon_Type, Has_Private_Component (Anon_Type));\n+      pragma Assert (not Depends_On_Private (Anon_Type));\n \n       --  Ada 2005 (AI-231): Ada 2005 semantics for anonymous access differs\n       --  from Ada 95 semantics. In Ada 2005, anonymous access must specify if\n@@ -1232,6 +1253,13 @@ package body Sem_Ch3 is\n       Set_Has_Task (T, False);\n       Set_Has_Controlled_Component (T, False);\n \n+      --  Initialize Associated_Final_Chain explicitly to Empty, to avoid\n+      --  problems where an incomplete view of this entity has been previously\n+      --  established by a limited with and an overlaid version of this field\n+      --  (Stored_Constraint) was initialized for the incomplete view.\n+\n+      Set_Associated_Final_Chain (T, Empty);\n+\n       --  Ada 2005 (AI-231): Propagate the null-excluding and access-constant\n       --  attributes\n \n@@ -1619,7 +1647,7 @@ package body Sem_Ch3 is\n       --  package Sem).\n \n       if Present (E) then\n-         Analyze_Per_Use_Expression (E, T);\n+         Preanalyze_Spec_Expression (E, T);\n          Check_Initialization (T, E);\n \n          if Ada_Version >= Ada_05\n@@ -2011,6 +2039,17 @@ package body Sem_Ch3 is\n          Set_Is_Synchronized_Interface (CW, Is_Synchronized_Interface (T));\n          Set_Is_Task_Interface         (CW, Is_Task_Interface (T));\n       end if;\n+\n+      --  Check runtime support for synchronized interfaces\n+\n+      if VM_Target = No_VM\n+        and then (Is_Task_Interface (T)\n+                    or else Is_Protected_Interface (T)\n+                    or else Is_Synchronized_Interface (T))\n+        and then not RTE_Available (RE_Select_Specific_Data)\n+      then\n+         Error_Msg_CRT (\"synchronized interfaces\", T);\n+      end if;\n    end Analyze_Interface_Declaration;\n \n    -----------------------------\n@@ -2178,11 +2217,11 @@ package body Sem_Ch3 is\n       Prev_Entity : Entity_Id := Empty;\n \n       function Count_Tasks (T : Entity_Id) return Uint;\n-      --  This function is called when a library level object of type is\n-      --  declared. It's function is to count the static number of tasks\n-      --  declared within the type (it is only called if Has_Tasks is set for\n-      --  T). As a side effect, if an array of tasks with non-static bounds or\n-      --  a variant record type is encountered, Check_Restrictions is called\n+      --  This function is called when a non-generic library level object of a\n+      --  task type is declared. Its function is to count the static number of\n+      --  tasks declared within the type (it is only called if Has_Tasks is set\n+      --  for T). As a side effect, if an array of tasks with non-static bounds\n+      --  or a variant record type is encountered, Check_Restrictions is called\n       --  indicating the count is unknown.\n \n       -----------------\n@@ -2259,12 +2298,23 @@ package body Sem_Ch3 is\n       if Constant_Present (N) then\n          Prev_Entity := Current_Entity_In_Scope (Id);\n \n-         --  If homograph is an implicit subprogram, it is overridden by the\n-         --  current declaration.\n+         --  If the homograph is an implicit subprogram, it is overridden by\n+         --  the current declaration.\n \n          if Present (Prev_Entity)\n-           and then Is_Overloadable (Prev_Entity)\n-           and then Is_Inherited_Operation (Prev_Entity)\n+           and then\n+             ((Is_Overloadable (Prev_Entity)\n+                 and then Is_Inherited_Operation (Prev_Entity))\n+\n+               --  The current object is a discriminal generated for an entry\n+               --  family index. Even though the index is a constant, in this\n+               --  particular context there is no true contant redeclaration.\n+               --  Enter_Name will handle the visibility.\n+\n+               or else\n+                (Is_Discriminal (Id)\n+                   and then Ekind (Discriminal_Link (Id)) =\n+                              E_Entry_Index_Parameter))\n          then\n             Prev_Entity := Empty;\n          end if;\n@@ -2425,6 +2475,19 @@ package body Sem_Ch3 is\n       --  Process initialization expression if present and not in error\n \n       if Present (E) and then E /= Error then\n+\n+         --  Generate an error in case of CPP class-wide object initialization.\n+         --  Required because otherwise the expansion of the class-wide\n+         --  assignment would try to use 'size to initialize the object\n+         --  (primitive that is not available in CPP tagged types).\n+\n+         if Is_Class_Wide_Type (Act_T)\n+           and then Convention (Act_T) = Convention_CPP\n+         then\n+            Error_Msg_N\n+              (\"predefined assignment not available in CPP tagged types\", E);\n+         end if;\n+\n          Mark_Coextensions (N, E);\n          Analyze (E);\n \n@@ -2441,6 +2504,18 @@ package body Sem_Ch3 is\n \n          Set_Is_True_Constant (Id, True);\n \n+         --  If we are analyzing a constant declaration, set its completion\n+         --  flag after analyzing and resolving the expression.\n+\n+         if Constant_Present (N) then\n+            Set_Has_Completion (Id);\n+         end if;\n+\n+         --  Set type and resolve (type may be overridden later on)\n+\n+         Set_Etype (Id, T);\n+         Resolve (E, T);\n+\n          --  If the object is an access to variable, the initialization\n          --  expression cannot be an access to constant.\n \n@@ -2454,16 +2529,6 @@ package body Sem_Ch3 is\n                 \"with an access-to-constant expression\", E);\n          end if;\n \n-         --  If we are analyzing a constant declaration, set its completion\n-         --  flag after analyzing the expression.\n-\n-         if Constant_Present (N) then\n-            Set_Has_Completion (Id);\n-         end if;\n-\n-         Set_Etype (Id, T);             --  may be overridden later on\n-         Resolve (E, T);\n-\n          if not Assignment_OK (N) then\n             Check_Initialization (T, E);\n          end if;\n@@ -2556,6 +2621,21 @@ package body Sem_Ch3 is\n                Error_Msg_N\n                  (\"unconstrained subtype not allowed (need initialization)\",\n                   Object_Definition (N));\n+\n+               if Is_Record_Type (T) and then Has_Discriminants (T) then\n+                  Error_Msg_N\n+                    (\"\\provide initial value or explicit discriminant values\",\n+                     Object_Definition (N));\n+\n+                  Error_Msg_NE\n+                    (\"\\or give default discriminant values for type&\",\n+                     Object_Definition (N), T);\n+\n+               elsif Is_Array_Type (T) then\n+                  Error_Msg_N\n+                    (\"\\provide initial value or explicit array bounds\",\n+                     Object_Definition (N));\n+               end if;\n             end if;\n \n          --  Case of initialization present but in error. Set initial\n@@ -2685,7 +2765,10 @@ package body Sem_Ch3 is\n          Remove_Side_Effects (E);\n       end if;\n \n-      if T = Standard_Wide_Character or else T = Standard_Wide_Wide_Character\n+      --  Check No_Wide_Characters restriction\n+\n+      if T = Standard_Wide_Character\n+        or else T = Standard_Wide_Wide_Character\n         or else Root_Type (T) = Standard_Wide_String\n         or else Root_Type (T) = Standard_Wide_Wide_String\n       then\n@@ -2730,10 +2813,11 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  Initialize alignment and size\n+      --  Initialize alignment and size and capture alignment setting\n \n-      Init_Alignment (Id);\n-      Init_Esize     (Id);\n+      Init_Alignment               (Id);\n+      Init_Esize                   (Id);\n+      Set_Optimize_Alignment_Flags (Id);\n \n       --  Deal with aliased case\n \n@@ -2853,8 +2937,22 @@ package body Sem_Ch3 is\n       if Has_Task (Etype (Id)) then\n          Check_Restriction (No_Tasking, N);\n \n-         if Is_Library_Level_Entity (Id) then\n+         --  Deal with counting max tasks\n+\n+         --  Nothing to do if inside a generic\n+\n+         if Inside_A_Generic then\n+            null;\n+\n+         --  If library level entity, then count tasks\n+\n+         elsif Is_Library_Level_Entity (Id) then\n             Check_Restriction (Max_Tasks, N, Count_Tasks (Etype (Id)));\n+\n+         --  If not library level entity, then indicate we don't know max\n+         --  tasks and also check task hierarchy restriction and blocking\n+         --  operation (since starting a task is definitely blocking!)\n+\n          else\n             Check_Restriction (Max_Tasks, N);\n             Check_Restriction (No_Task_Hierarchy, N);\n@@ -2980,18 +3078,6 @@ package body Sem_Ch3 is\n       null;\n    end Analyze_Others_Choice;\n \n-   --------------------------------\n-   -- Analyze_Per_Use_Expression --\n-   --------------------------------\n-\n-   procedure Analyze_Per_Use_Expression (N : Node_Id; T : Entity_Id) is\n-      Save_In_Default_Expression : constant Boolean := In_Default_Expression;\n-   begin\n-      In_Default_Expression := True;\n-      Pre_Analyze_And_Resolve (N, T);\n-      In_Default_Expression := Save_In_Default_Expression;\n-   end Analyze_Per_Use_Expression;\n-\n    -------------------------------------------\n    -- Analyze_Private_Extension_Declaration --\n    -------------------------------------------\n@@ -3383,7 +3469,8 @@ package body Sem_Ch3 is\n                   Set_Stored_Constraint_From_Discriminant_Constraint (Id);\n \n                   --  This would seem semantically correct, but apparently\n-                  --  confuses the back-end (4412-009). To be explained ???\n+                  --  confuses the back-end. To be explained and checked with\n+                  --  current version ???\n \n                   --  Set_Has_Discriminants (Id);\n                end if;\n@@ -3575,6 +3662,7 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      Set_Optimize_Alignment_Flags (Id);\n       Check_Eliminated (Id);\n    end Analyze_Subtype_Declaration;\n \n@@ -3886,6 +3974,7 @@ package body Sem_Ch3 is\n          Set_Is_Descendent_Of_Address (Prev);\n       end if;\n \n+      Set_Optimize_Alignment_Flags (Def_Id);\n       Check_Eliminated (Def_Id);\n    end Analyze_Type_Declaration;\n \n@@ -3938,7 +4027,7 @@ package body Sem_Ch3 is\n          end if;\n       end Process_Declarations;\n \n-      --  Variables local to Analyze_Case_Statement\n+      --  Local Variables\n \n       Discr_Name : Node_Id;\n       Discr_Type : Entity_Id;\n@@ -3960,13 +4049,15 @@ package body Sem_Ch3 is\n       Discr_Name := Name (N);\n       Analyze (Discr_Name);\n \n-      if Etype (Discr_Name) = Any_Type then\n-\n-         --  Prevent cascaded errors\n+      --  If Discr_Name bad, get out (prevent cascaded errors)\n \n+      if Etype (Discr_Name) = Any_Type then\n          return;\n+      end if;\n \n-      elsif Ekind (Entity (Discr_Name)) /= E_Discriminant then\n+      --  Check invalid discriminant in variant part\n+\n+      if Ekind (Entity (Discr_Name)) /= E_Discriminant then\n          Error_Msg_N (\"invalid discriminant name in variant part\", Discr_Name);\n       end if;\n \n@@ -4136,7 +4227,6 @@ package body Sem_Ch3 is\n \n          Implicit_Base := Create_Itype (E_Array_Type, P, Related_Id, 'B');\n \n-         Init_Size_Align        (Implicit_Base);\n          Set_Etype              (Implicit_Base, Implicit_Base);\n          Set_Scope              (Implicit_Base, Current_Scope);\n          Set_Has_Delayed_Freeze (Implicit_Base);\n@@ -4281,7 +4371,6 @@ package body Sem_Ch3 is\n            (\"the type of a component cannot be abstract\",\n             Subtype_Indication (Component_Def));\n       end if;\n-\n    end Array_Type_Declaration;\n \n    ------------------------------------------------------\n@@ -4624,9 +4713,13 @@ package body Sem_Ch3 is\n    begin\n       Set_Stored_Constraint (Derived_Type, No_Elist);\n \n+      --  Copy Storage_Size and Relative_Deadline variables if task case\n+\n       if Is_Task_Type (Parent_Type) then\n          Set_Storage_Size_Variable (Derived_Type,\n            Storage_Size_Variable (Parent_Type));\n+         Set_Relative_Deadline_Variable (Derived_Type,\n+           Relative_Deadline_Variable (Parent_Type));\n       end if;\n \n       if Present (Discriminant_Specifications (N)) then\n@@ -4795,10 +4888,7 @@ package body Sem_Ch3 is\n       --  and we construct the same skeletal representation as for the generic\n       --  parent type.\n \n-      if Root_Type (Parent_Type) = Standard_Character\n-        or else Root_Type (Parent_Type) = Standard_Wide_Character\n-        or else Root_Type (Parent_Type) = Standard_Wide_Wide_Character\n-      then\n+      if Is_Standard_Character_Type (Parent_Type) then\n          Derived_Standard_Character (N, Parent_Type, Derived_Type);\n \n       elsif Is_Generic_Type (Root_Type (Parent_Type)) then\n@@ -5232,9 +5322,7 @@ package body Sem_Ch3 is\n          if Ekind (Parent_Type) in Record_Kind\n            or else\n              (Ekind (Parent_Type) in Enumeration_Kind\n-               and then Root_Type (Parent_Type) /= Standard_Character\n-               and then Root_Type (Parent_Type) /= Standard_Wide_Character\n-               and then Root_Type (Parent_Type) /= Standard_Wide_Wide_Character\n+               and then not Is_Standard_Character_Type (Parent_Type)\n                and then not Is_Generic_Type (Root_Type (Parent_Type)))\n          then\n             Full_N := New_Copy_Tree (N);\n@@ -6463,7 +6551,10 @@ package body Sem_Ch3 is\n       if Limited_Present (Type_Def) then\n          Set_Is_Limited_Record (Derived_Type);\n \n-      elsif Is_Limited_Record (Parent_Type) then\n+      elsif Is_Limited_Record (Parent_Type)\n+        or else (Present (Full_View (Parent_Type))\n+                   and then Is_Limited_Record (Full_View (Parent_Type)))\n+      then\n          if not Is_Interface (Parent_Type)\n            or else Is_Synchronized_Interface (Parent_Type)\n            or else Is_Protected_Interface (Parent_Type)\n@@ -8031,16 +8122,17 @@ package body Sem_Ch3 is\n            and then Present (Alias (Subp))\n            and then not Comes_From_Source (Subp)\n            and then not Is_Abstract_Subprogram (Alias (Subp))\n+           and then not Is_Access_Type (Etype (Subp))\n          then\n             null;\n \n          elsif (Is_Abstract_Subprogram (Subp)\n-              or else Requires_Overriding (Subp)\n-              or else\n-                (Has_Controlling_Result (Subp)\n-                   and then Present (Alias_Subp)\n-                   and then not Comes_From_Source (Subp)\n-                   and then Sloc (Subp) = Sloc (First_Subtype (T))))\n+                 or else Requires_Overriding (Subp)\n+                 or else\n+                   (Has_Controlling_Result (Subp)\n+                     and then Present (Alias_Subp)\n+                     and then not Comes_From_Source (Subp)\n+                     and then Sloc (Subp) = Sloc (First_Subtype (T))))\n            and then not Is_TSS (Subp, TSS_Stream_Input)\n            and then not Is_TSS (Subp, TSS_Stream_Output)\n            and then not Is_Abstract_Type (T)\n@@ -8061,10 +8153,10 @@ package body Sem_Ch3 is\n             if Present (Alias_Subp) then\n \n                --  Only perform the check for a derived subprogram when the\n-               --  type has an explicit record extension. This avoids\n-               --  incorrectly flagging abstract subprograms for the case of a\n-               --  type without an extension derived from a formal type with a\n-               --  tagged actual (can occur within a private part).\n+               --  type has an explicit record extension. This avoids incorect\n+               --  flagging of abstract subprograms for the case of a type\n+               --  without an extension that is derived from a formal type\n+               --  with a tagged actual (can occur within a private part).\n \n                --  Ada 2005 (AI-391): In the case of an inherited function with\n                --  a controlling result of the type, the rule does not apply if\n@@ -9049,6 +9141,12 @@ package body Sem_Ch3 is\n         and then\n           (Ekind (Etype (Prev)) /= E_Anonymous_Access_Type\n              or else Ekind (Etype (New_T)) /= E_Anonymous_Access_Type\n+             or else Is_Access_Constant (Etype (New_T)) /=\n+                     Is_Access_Constant (Etype (Prev))\n+             or else Can_Never_Be_Null (Etype (New_T)) /=\n+                     Can_Never_Be_Null (Etype (Prev))\n+             or else Null_Exclusion_Present (Parent (Prev)) /=\n+                     Null_Exclusion_Present (Parent (Id))\n              or else not Subtypes_Statically_Match\n                            (Designated_Type (Etype (Prev)),\n                             Designated_Type (Etype (New_T))))\n@@ -9058,6 +9156,15 @@ package body Sem_Ch3 is\n          Set_Full_View (Prev, Id);\n          Set_Etype (Id, Any_Type);\n \n+      elsif\n+        Null_Exclusion_Present (Parent (Prev))\n+          and then not Null_Exclusion_Present (N)\n+      then\n+         Error_Msg_Sloc := Sloc (Prev);\n+         Error_Msg_N (\"null-exclusion does not match declaration#\", N);\n+         Set_Full_View (Prev, Id);\n+         Set_Etype (Id, Any_Type);\n+\n       --  If so, process the full constant declaration\n \n       else\n@@ -9922,7 +10029,6 @@ package body Sem_Ch3 is\n \n    begin\n       Set_Etype             (T_Sub, Corr_Rec);\n-      Init_Size_Align       (T_Sub);\n       Set_Has_Discriminants (T_Sub, Has_Discriminants (Prot_Subt));\n       Set_Is_Constrained    (T_Sub, True);\n       Set_First_Entity      (T_Sub, First_Entity (Corr_Rec));\n@@ -11120,12 +11226,12 @@ package body Sem_Ch3 is\n \n       Set_Fixed_Range (Implicit_Base, Loc, -Bound_Val, Bound_Val);\n \n-      --  Set size to zero for now, size will be set at freeze time. We have\n-      --  to do this for ordinary fixed-point, because the size depends on\n-      --  the specified small, and we might as well do the same for decimal\n-      --  fixed-point.\n+      --  Note: We leave size as zero for now, size will be set at freeze\n+      --  time. We have to do this for ordinary fixed-point, because the size\n+      --  depends on the specified small, and we might as well do the same for\n+      --  decimal fixed-point.\n \n-      Init_Size_Align (Implicit_Base);\n+      pragma Assert (Esize (Implicit_Base) = Uint_0);\n \n       --  If there are bounds given in the declaration use them as the\n       --  bounds of the first named subtype.\n@@ -11224,7 +11330,6 @@ package body Sem_Ch3 is\n          Iface_Elmt := First_Elmt (Ifaces_List);\n          while Present (Iface_Elmt) loop\n             Elmt := First_Elmt (Primitive_Operations (Node (Iface_Elmt)));\n-\n             while Present (Elmt) loop\n                Prim := Node (Elmt);\n \n@@ -11247,6 +11352,7 @@ package body Sem_Ch3 is\n \n       function In_List (L : Elist_Id; Subp : Entity_Id) return Boolean is\n          Elmt : Elmt_Id;\n+\n       begin\n          Elmt := First_Elmt (L);\n          while Present (Elmt) loop\n@@ -11410,19 +11516,28 @@ package body Sem_Ch3 is\n       Parent_Type  : Entity_Id;\n       Actual_Subp  : Entity_Id := Empty)\n    is\n-      Formal       : Entity_Id;\n-      New_Formal   : Entity_Id;\n+      Formal : Entity_Id;\n+      --  Formal parameter of parent primitive operation\n+\n+      Formal_Of_Actual : Entity_Id;\n+      --  Formal parameter of actual operation, when the derivation is to\n+      --  create a renaming for a primitive operation of an actual in an\n+      --  instantiation.\n+\n+      New_Formal : Entity_Id;\n+      --  Formal of inherited operation\n+\n       Visible_Subp : Entity_Id := Parent_Subp;\n \n       function Is_Private_Overriding return Boolean;\n-      --  If Subp is a private overriding of a visible operation, the in-\n-      --  herited operation derives from the overridden op (even though\n-      --  its body is the overriding one) and the inherited operation is\n-      --  visible now. See sem_disp to see the details of the handling of\n-      --  the overridden subprogram, which is removed from the list of\n-      --  primitive operations of the type. The overridden subprogram is\n-      --  saved locally in Visible_Subp, and used to diagnose abstract\n-      --  operations that need overriding in the derived type.\n+      --  If Subp is a private overriding of a visible operation, the inherited\n+      --  operation derives from the overridden op (even though its body is the\n+      --  overriding one) and the inherited operation is visible now. See\n+      --  sem_disp to see the full details of the handling of the overridden\n+      --  subprogram, which is removed from the list of primitive operations of\n+      --  the type. The overridden subprogram is saved locally in Visible_Subp,\n+      --  and used to diagnose abstract operations that need overriding in the\n+      --  derived type.\n \n       procedure Replace_Type (Id, New_Id : Entity_Id);\n       --  When the type is an anonymous access type, create a new access type\n@@ -11583,6 +11698,7 @@ package body Sem_Ch3 is\n \n          elsif Is_Interface (Etype (Id))\n            and then not Is_Class_Wide_Type (Etype (Id))\n+           and then Is_Progenitor (Etype (Id), Derived_Type)\n          then\n             Set_Etype (New_Id, Derived_Type);\n \n@@ -11671,10 +11787,29 @@ package body Sem_Ch3 is\n       end if;\n \n       Set_Parent (New_Subp, Parent (Derived_Type));\n-      Replace_Type (Parent_Subp, New_Subp);\n+\n+      if Present (Actual_Subp) then\n+         Replace_Type (Actual_Subp, New_Subp);\n+      else\n+         Replace_Type (Parent_Subp, New_Subp);\n+      end if;\n+\n       Conditional_Delay (New_Subp, Parent_Subp);\n \n+      --  If we are creating a renaming for a primitive operation of an\n+      --  actual of a generic derived type, we must examine the signature\n+      --  of the actual primive, not that of the generic formal, which for\n+      --  example may be an interface. However the name and initial value\n+      --  of the inherited operation are those of the formal primitive.\n+\n       Formal := First_Formal (Parent_Subp);\n+\n+      if Present (Actual_Subp) then\n+         Formal_Of_Actual := First_Formal (Actual_Subp);\n+      else\n+         Formal_Of_Actual := Empty;\n+      end if;\n+\n       while Present (Formal) loop\n          New_Formal := New_Copy (Formal);\n \n@@ -11684,19 +11819,24 @@ package body Sem_Ch3 is\n          --  original formal's parameter specification in this case.\n \n          Set_Parent (New_Formal, Parent (Formal));\n-\n          Append_Entity (New_Formal, New_Subp);\n \n-         Replace_Type (Formal, New_Formal);\n+         if Present (Formal_Of_Actual) then\n+            Replace_Type (Formal_Of_Actual, New_Formal);\n+            Next_Formal (Formal_Of_Actual);\n+         else\n+            Replace_Type (Formal, New_Formal);\n+         end if;\n+\n          Next_Formal (Formal);\n       end loop;\n \n       --  If this derivation corresponds to a tagged generic actual, then\n       --  primitive operations rename those of the actual. Otherwise the\n-      --  primitive operations rename those of the parent type, If the\n-      --  parent renames an intrinsic operator, so does the new subprogram.\n-      --  We except concatenation, which is always properly typed, and does\n-      --  not get expanded as other intrinsic operations.\n+      --  primitive operations rename those of the parent type, If the parent\n+      --  renames an intrinsic operator, so does the new subprogram. We except\n+      --  concatenation, which is always properly typed, and does not get\n+      --  expanded as other intrinsic operations.\n \n       if No (Actual_Subp) then\n          if Is_Intrinsic_Subprogram (Parent_Subp) then\n@@ -11786,10 +11926,10 @@ package body Sem_Ch3 is\n          Set_Is_Abstract_Subprogram (New_Subp);\n \n       --  Finally, if the parent type is abstract we must verify that all\n-      --  inherited operations are either non-abstract or overridden, or\n-      --  that the derived type itself is abstract (this check is performed\n-      --  at the end of a package declaration, in Check_Abstract_Overriding).\n-      --  A private overriding in the parent type will not be visible in the\n+      --  inherited operations are either non-abstract or overridden, or that\n+      --  the derived type itself is abstract (this check is performed at the\n+      --  end of a package declaration, in Check_Abstract_Overriding). A\n+      --  private overriding in the parent type will not be visible in the\n       --  derivation if we are not in an inner package or in a child unit of\n       --  the parent type, in which case the abstractness of the inherited\n       --  operation is carried to the new subprogram.\n@@ -13066,6 +13206,8 @@ package body Sem_Ch3 is\n          Typ := Entity (S);\n       end if;\n \n+      --  Check No_Wide_Characters restriction\n+\n       if Typ = Standard_Wide_Character\n         or else Typ = Standard_Wide_Wide_Character\n         or else Typ = Standard_Wide_String\n@@ -13407,6 +13549,8 @@ package body Sem_Ch3 is\n          return Result;\n       end Search_Derivation_Levels;\n \n+      --  Local Variables\n+\n       Result : Node_Or_Entity_Id;\n \n    --  Start of processing for Get_Discriminant_Value\n@@ -13816,6 +13960,58 @@ package body Sem_Ch3 is\n       end if;\n    end Is_Null_Extension;\n \n+   --------------------\n+   --  Is_Progenitor --\n+   --------------------\n+\n+   function Is_Progenitor\n+     (Iface : Entity_Id;\n+      Typ   : Entity_Id) return Boolean\n+   is\n+      Iface_Elmt  : Elmt_Id;\n+      I_Name      : Entity_Id;\n+\n+   begin\n+      if No (Abstract_Interfaces (Typ)) then\n+         return False;\n+\n+      else\n+         Iface_Elmt := First_Elmt (Abstract_Interfaces (Typ));\n+         while Present (Iface_Elmt) loop\n+            I_Name := Node (Iface_Elmt);\n+            if Base_Type (I_Name) = Base_Type (Iface) then\n+               return True;\n+\n+            elsif Is_Derived_Type (I_Name)\n+              and then Is_Ancestor (Iface, I_Name)\n+            then\n+               return True;\n+\n+            else\n+               Next_Elmt (Iface_Elmt);\n+            end if;\n+         end loop;\n+\n+         --  For concurrent record types, they have the interfaces of the\n+         --  parent synchronized type. However these have no ancestors that\n+         --  implement anything, so assume it is a progenitor.\n+         --  Should be cleaned up in Collect_Abstract_Interfaces???\n+\n+         if Is_Concurrent_Record_Type (Typ) then\n+            return Present (Abstract_Interfaces (Typ));\n+         end if;\n+\n+         --  If type is a derived type, check recursively its ancestors\n+\n+         if Is_Derived_Type (Typ) then\n+            return Etype (Typ) = Iface\n+              or else  Is_Progenitor (Iface, Etype (Typ));\n+         else\n+            return False;\n+         end if;\n+      end if;\n+   end Is_Progenitor;\n+\n    ------------------------------\n    -- Is_Valid_Constraint_Kind --\n    ------------------------------\n@@ -14006,8 +14202,6 @@ package body Sem_Ch3 is\n \n                Ancestor := Etype (Ancestor);\n             end loop;\n-\n-            return True;\n          end;\n       end if;\n    end Is_Visible_Component;\n@@ -14059,7 +14253,6 @@ package body Sem_Ch3 is\n       Set_Is_Abstract_Type     (CW_Type, False);\n       Set_Is_Constrained       (CW_Type, False);\n       Set_Is_First_Subtype     (CW_Type, Is_First_Subtype (T));\n-      Init_Size_Align          (CW_Type);\n \n       if Ekind (T) = E_Class_Wide_Subtype then\n          Set_Etype             (CW_Type, Etype (Base_Type (T)));\n@@ -14548,7 +14741,6 @@ package body Sem_Ch3 is\n \n    function OK_For_Limited_Init_In_05 (Exp : Node_Id) return Boolean is\n    begin\n-\n       --  Ada 2005 (AI-287, AI-318): Relax the strictness of the front end in\n       --  case of limited aggregates (including extension aggregates), and\n       --  function calls. The function call may have been give in prefixed\n@@ -14697,8 +14889,6 @@ package body Sem_Ch3 is\n       Set_Fixed_Range (Implicit_Base, Loc, Low_Val, High_Val);\n       Set_Fixed_Range (T, Loc, Low_Val, High_Val);\n \n-      Init_Size_Align (Implicit_Base);\n-\n       --  Complete definition of first subtype\n \n       Set_Ekind          (T, E_Ordinary_Fixed_Point_Subtype);\n@@ -14850,7 +15040,7 @@ package body Sem_Ch3 is\n          --  Object Expressions\" in spec of package Sem).\n \n          if Present (Expression (Discr)) then\n-            Analyze_Per_Use_Expression (Expression (Discr), Discr_Type);\n+            Preanalyze_Spec_Expression (Expression (Discr), Discr_Type);\n \n             if Nkind (N) = N_Formal_Type_Declaration then\n                Error_Msg_N\n@@ -14915,7 +15105,11 @@ package body Sem_Ch3 is\n             end if;\n \n             --  Ada 2005 (AI-402): access discriminants of nonlimited types\n-            --  can't have defaults\n+            --  can't have defaults. Synchronized types, or types that are\n+            --  explicitly limited are fine, but special tests apply to derived\n+            --  types in generics: in a generic body we have to assume the\n+            --  worst, and therefore defaults are not allowed if the parent is\n+            --  a generic formal private type (see ACATS B370001).\n \n             if Is_Access_Type (Discr_Type) then\n                if Ekind (Discr_Type) /= E_Anonymous_Access_Type\n@@ -14925,7 +15119,19 @@ package body Sem_Ch3 is\n                  or else Is_Concurrent_Record_Type (Current_Scope)\n                  or else Ekind (Current_Scope) = E_Limited_Private_Type\n                then\n-                  null;\n+                  if not Is_Derived_Type (Current_Scope)\n+                    or else not Is_Generic_Type (Etype (Current_Scope))\n+                    or else not In_Package_Body (Scope (Etype (Current_Scope)))\n+                    or else Limited_Present\n+                              (Type_Definition (Parent (Current_Scope)))\n+                  then\n+                     null;\n+\n+                  else\n+                     Error_Msg_N (\"access discriminants of nonlimited types\",\n+                         Expression (Discr));\n+                     Error_Msg_N (\"\\cannot have defaults\", Expression (Discr));\n+                  end if;\n \n                elsif Present (Expression (Discr)) then\n                   Error_Msg_N\n@@ -16290,8 +16496,8 @@ package body Sem_Ch3 is\n             return;\n \n          else\n-            Inc_T  := Make_Defining_Identifier (Loc, Chars (Typ));\n-            Decl   := Make_Incomplete_Type_Declaration (Loc, Inc_T);\n+            Inc_T := Make_Defining_Identifier (Loc, Chars (Typ));\n+            Decl  := Make_Incomplete_Type_Declaration (Loc, Inc_T);\n \n             --  Type has already been inserted into the current scope.\n             --  Remove it, and add incomplete declaration for type, so\n@@ -16589,6 +16795,18 @@ package body Sem_Ch3 is\n       end if;\n    end Check_Anonymous_Access_Components;\n \n+   --------------------------------\n+   -- Preanalyze_Spec_Expression --\n+   --------------------------------\n+\n+   procedure Preanalyze_Spec_Expression (N : Node_Id; T : Entity_Id) is\n+      Save_In_Spec_Expression : constant Boolean := In_Spec_Expression;\n+   begin\n+      In_Spec_Expression := True;\n+      Preanalyze_And_Resolve (N, T);\n+      In_Spec_Expression := Save_In_Spec_Expression;\n+   end Preanalyze_Spec_Expression;\n+\n    -----------------------------\n    -- Record_Type_Declaration --\n    -----------------------------"}, {"sha": "0dff777a654e140e9d52b67aaa8838e646ad2b79", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -71,14 +71,6 @@ package Sem_Ch3  is\n    procedure Analyze_Interface_Declaration (T : Entity_Id; Def : Node_Id);\n    --  Analyze an interface declaration or a formal interface declaration\n \n-   procedure Analyze_Per_Use_Expression (N : Node_Id; T : Entity_Id);\n-   --  Default and per object expressions do not freeze their components,\n-   --  and must be analyzed and resolved accordingly. The analysis is\n-   --  done by calling the Pre_Analyze_And_Resolve routine and setting\n-   --  the global In_Default_Expression flag. See the documentation section\n-   --  entitled \"Handling of Default and Per-Object Expressions\" in sem.ads\n-   --  for details. N is the expression to be analyzed, T is the expected type.\n-\n    procedure Array_Type_Declaration (T : in out Entity_Id; Def : Node_Id);\n    --  Process an array type declaration. If the array is constrained, we\n    --  create an implicit parent array type, with the same index types and\n@@ -204,6 +196,14 @@ package Sem_Ch3  is\n    --  Always False in Ada 95 mode. Equivalent to OK_For_Limited_Init_In_05 in\n    --  Ada 2005 mode.\n \n+   procedure Preanalyze_Spec_Expression (N : Node_Id; T : Entity_Id);\n+   --  Default and per object expressions do not freeze their components, and\n+   --  must be analyzed and resolved accordingly. The analysis is done by\n+   --  calling the Preanalyze_And_Resolve routine and setting the global\n+   --  In_Default_Expression flag. See the documentation section entitled\n+   --  \"Handling of Default and Per-Object Expressions\" in sem.ads for full\n+   --  details. N is the expression to be analyzed, T is the expected type.\n+\n    procedure Process_Full_View (N : Node_Id; Full_T, Priv_T : Entity_Id);\n    --  Process some semantic actions when the full view of a private type is\n    --  encountered and analyzed. The first action is to create the full views"}, {"sha": "54925d7b600512e43a74ae6bc5274d2604bd9f02", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 369, "deletions": 86, "changes": 455, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -205,8 +205,10 @@ package body Sem_Util is\n       Rep    : Boolean    := True;\n       Warn   : Boolean    := False)\n    is\n-      Stat : constant Boolean := Is_Static_Expression (N);\n-      Rtyp : Entity_Id;\n+      Stat   : constant Boolean := Is_Static_Expression (N);\n+      R_Stat : constant Node_Id :=\n+                 Make_Raise_Constraint_Error (Sloc (N), Reason => Reason);\n+      Rtyp   : Entity_Id;\n \n    begin\n       if No (Typ) then\n@@ -225,10 +227,9 @@ package body Sem_Util is\n       --  Now we replace the node by an N_Raise_Constraint_Error node\n       --  This does not need reanalyzing, so set it as analyzed now.\n \n-      Rewrite (N,\n-        Make_Raise_Constraint_Error (Sloc (N),\n-          Reason => Reason));\n+      Rewrite (N, R_Stat);\n       Set_Analyzed (N, True);\n+\n       Set_Etype (N, Rtyp);\n       Set_Raises_Constraint_Error (N);\n \n@@ -486,9 +487,13 @@ package body Sem_Util is\n    --  Start of processing for Build_Actual_Subtype_Of_Component\n \n    begin\n-      if In_Default_Expression then\n+      --  Why the test for Spec_Expression mode here???\n+\n+      if In_Spec_Expression then\n          return Empty;\n \n+      --  More commments for the rest of this body would be good ???\n+\n       elsif Nkind (N) = N_Explicit_Dereference then\n          if Is_Composite_Type (T)\n            and then not Is_Constrained (T)\n@@ -1010,11 +1015,12 @@ package body Sem_Util is\n               (\"premature usage of incomplete}\", N, First_Subtype (T));\n          end if;\n \n+      --  Need comments for these tests ???\n+\n       elsif Has_Private_Component (T)\n         and then not Is_Generic_Type (Root_Type (T))\n-        and then not In_Default_Expression\n+        and then not In_Spec_Expression\n       then\n-\n          --  Special case: if T is the anonymous type created for a single\n          --  task or protected object, use the name of the source object.\n \n@@ -1045,6 +1051,8 @@ package body Sem_Util is\n       --  Currently only enabled for VM back-ends for efficiency, should we\n       --  enable it more systematically ???\n \n+      --  Check for Is_Imported needs commenting below ???\n+\n       if VM_Target /= No_VM\n         and then (Ekind (Ent) = E_Variable\n                     or else\n@@ -1053,6 +1061,7 @@ package body Sem_Util is\n                   Ekind (Ent) = E_Loop_Parameter)\n         and then Scope (Ent) /= Empty\n         and then not Is_Library_Level_Entity (Ent)\n+        and then not Is_Imported (Ent)\n       then\n          if Is_Subprogram (Scop)\n            or else Is_Generic_Subprogram (Scop)\n@@ -1103,6 +1112,117 @@ package body Sem_Util is\n       end loop;\n    end Check_Potentially_Blocking_Operation;\n \n+   ------------------------------\n+   -- Check_Unprotected_Access --\n+   ------------------------------\n+\n+   procedure Check_Unprotected_Access\n+     (Context : Node_Id;\n+      Expr    : Node_Id)\n+   is\n+      Cont_Encl_Typ : Entity_Id;\n+      Pref_Encl_Typ : Entity_Id;\n+\n+      function Enclosing_Protected_Type (Obj : Node_Id) return Entity_Id;\n+      --  Check whether Obj is a private component of a protected object.\n+      --  Return the protected type where the component resides, Empty\n+      --  otherwise.\n+\n+      function Is_Public_Operation return Boolean;\n+      --  Verify that the enclosing operation is callable from outside the\n+      --  protected object, to minimize false positives.\n+\n+      ------------------------------\n+      -- Enclosing_Protected_Type --\n+      ------------------------------\n+\n+      function Enclosing_Protected_Type (Obj : Node_Id) return Entity_Id is\n+      begin\n+         if Is_Entity_Name (Obj) then\n+            declare\n+               Ent : Entity_Id := Entity (Obj);\n+\n+            begin\n+               --  The object can be a renaming of a private component, use\n+               --  the original record component.\n+\n+               if Is_Prival (Ent) then\n+                  Ent := Prival_Link (Ent);\n+               end if;\n+\n+               if Is_Protected_Type (Scope (Ent)) then\n+                  return Scope (Ent);\n+               end if;\n+            end;\n+         end if;\n+\n+         --  For indexed and selected components, recursively check the prefix\n+\n+         if Nkind_In (Obj, N_Indexed_Component, N_Selected_Component) then\n+            return Enclosing_Protected_Type (Prefix (Obj));\n+\n+         --  The object does not denote a protected component\n+\n+         else\n+            return Empty;\n+         end if;\n+      end Enclosing_Protected_Type;\n+\n+      -------------------------\n+      -- Is_Public_Operation --\n+      -------------------------\n+\n+      function Is_Public_Operation return Boolean is\n+         S : Entity_Id;\n+         E : Entity_Id;\n+\n+      begin\n+         S := Current_Scope;\n+         while Present (S)\n+           and then S /= Pref_Encl_Typ\n+         loop\n+            if Scope (S) = Pref_Encl_Typ then\n+               E := First_Entity (Pref_Encl_Typ);\n+               while Present (E)\n+                 and then E /= First_Private_Entity (Pref_Encl_Typ)\n+               loop\n+                  if E = S then\n+                     return True;\n+                  end if;\n+                  Next_Entity (E);\n+               end loop;\n+            end if;\n+\n+            S := Scope (S);\n+         end loop;\n+\n+         return False;\n+      end Is_Public_Operation;\n+\n+   --  Start of processing for Check_Unprotected_Access\n+\n+   begin\n+      if Nkind (Expr) = N_Attribute_Reference\n+        and then Attribute_Name (Expr) = Name_Unchecked_Access\n+      then\n+         Cont_Encl_Typ := Enclosing_Protected_Type (Context);\n+         Pref_Encl_Typ := Enclosing_Protected_Type (Prefix (Expr));\n+\n+         --  Check whether we are trying to export a protected component to a\n+         --  context with an equal or lower access level.\n+\n+         if Present (Pref_Encl_Typ)\n+           and then No (Cont_Encl_Typ)\n+           and then Is_Public_Operation\n+           and then Scope_Depth (Pref_Encl_Typ) >=\n+                      Object_Access_Level (Context)\n+         then\n+            Error_Msg_N\n+              (\"?possible unprotected access to protected data\", Expr);\n+         end if;\n+      end if;\n+   end Check_Unprotected_Access;\n+\n    ---------------\n    -- Check_VMS --\n    ---------------\n@@ -1772,6 +1892,42 @@ package body Sem_Util is\n       end if;\n    end Conditional_Delay;\n \n+   -------------------------\n+   -- Copy_Parameter_List --\n+   -------------------------\n+\n+   function Copy_Parameter_List (Subp_Id : Entity_Id) return List_Id is\n+      Loc    : constant Source_Ptr := Sloc (Subp_Id);\n+      Plist  : List_Id;\n+      Formal : Entity_Id;\n+\n+   begin\n+      if No (First_Formal (Subp_Id)) then\n+         return No_List;\n+      else\n+         Plist := New_List;\n+         Formal := First_Formal (Subp_Id);\n+         while Present (Formal) loop\n+            Append\n+              (Make_Parameter_Specification (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Sloc (Formal),\n+                    Chars => Chars (Formal)),\n+                In_Present  => In_Present (Parent (Formal)),\n+                Out_Present => Out_Present (Parent (Formal)),\n+             Parameter_Type =>\n+                  New_Reference_To (Etype (Formal), Loc),\n+                Expression =>\n+                  New_Copy_Tree (Expression (Parent (Formal)))),\n+              Plist);\n+\n+            Next_Formal (Formal);\n+         end loop;\n+      end if;\n+\n+      return Plist;\n+   end Copy_Parameter_List;\n+\n    --------------------\n    -- Current_Entity --\n    --------------------\n@@ -2259,26 +2415,6 @@ package body Sem_Util is\n       E : constant Entity_Id := Current_Entity_In_Scope (Def_Id);\n       S : constant Entity_Id := Current_Scope;\n \n-      function Is_Private_Component_Renaming (N : Node_Id) return Boolean;\n-      --  Recognize a renaming declaration that is introduced for private\n-      --  components of a protected type. We treat these as weak declarations\n-      --  so that they are overridden by entities with the same name that\n-      --  come from source, such as formals or local variables of a given\n-      --  protected declaration.\n-\n-      -----------------------------------\n-      -- Is_Private_Component_Renaming --\n-      -----------------------------------\n-\n-      function Is_Private_Component_Renaming (N : Node_Id) return Boolean is\n-      begin\n-         return not Comes_From_Source (N)\n-           and then not Comes_From_Source (Current_Scope)\n-           and then Nkind (N) = N_Object_Renaming_Declaration;\n-      end Is_Private_Component_Renaming;\n-\n-   --  Start of processing for Enter_Name\n-\n    begin\n       Generate_Definition (Def_Id);\n \n@@ -2402,7 +2538,29 @@ package body Sem_Util is\n          then\n             return;\n \n-         elsif Is_Private_Component_Renaming (Parent (Def_Id)) then\n+         --  If the homograph is a protected component renaming, it should not\n+         --  be hiding the current entity. Such renamings are treated as weak\n+         --  declarations.\n+\n+         elsif Is_Prival (E) then\n+            Set_Is_Immediately_Visible (E, False);\n+\n+         --  In this case the current entity is a protected component renaming.\n+         --  Perform minimal decoration by setting the scope and return since\n+         --  the prival should not be hiding other visible entities.\n+\n+         elsif Is_Prival (Def_Id) then\n+            Set_Scope (Def_Id, Current_Scope);\n+            return;\n+\n+         --  Analogous to privals, the discriminal generated for an entry\n+         --  index parameter acts as a weak declaration. Perform minimal\n+         --  decoration to avoid bogus errors.\n+\n+         elsif Is_Discriminal (Def_Id)\n+           and then Ekind (Discriminal_Link (Def_Id)) = E_Entry_Index_Parameter\n+         then\n+            Set_Scope (Def_Id, Current_Scope);\n             return;\n \n          --  In the body or private part of an instance, a type extension\n@@ -2411,7 +2569,7 @@ package body Sem_Util is\n          --  of the full type with two components of the same name are not\n          --  clear at this point ???\n \n-         elsif In_Instance_Not_Visible  then\n+         elsif In_Instance_Not_Visible then\n             null;\n \n          --  When compiling a package body, some child units may have become\n@@ -2446,21 +2604,19 @@ package body Sem_Util is\n               and then Nkind (Parent (Def_Id)) = N_Private_Type_Declaration\n             then\n                Error_Msg_N\n-                 (\"incomplete type cannot be completed\" &\n-                        \" with a private declaration\",\n-                    Parent (Def_Id));\n+                 (\"incomplete type cannot be completed with a private \" &\n+                  \"declaration\", Parent (Def_Id));\n                Set_Is_Immediately_Visible (E, False);\n                Set_Full_View (E, Def_Id);\n \n+            --  An inherited component of a record conflicts with a new\n+            --  discriminant. The discriminant is inserted first in the scope,\n+            --  but the error should be posted on it, not on the component.\n+\n             elsif Ekind (E) = E_Discriminant\n               and then Present (Scope (Def_Id))\n               and then Scope (Def_Id) /= Current_Scope\n             then\n-               --  An inherited component of a record conflicts with\n-               --  a new discriminant. The discriminant is inserted first\n-               --  in the scope, but the error should be posted on it, not\n-               --  on the component.\n-\n                Error_Msg_Sloc := Sloc (Def_Id);\n                Error_Msg_N (\"& conflicts with declaration#\", E);\n                return;\n@@ -2490,8 +2646,8 @@ package body Sem_Util is\n                end if;\n             end if;\n \n-            if Nkind (Parent (Parent (Def_Id)))\n-                 = N_Generic_Subprogram_Declaration\n+            if Nkind (Parent (Parent (Def_Id))) =\n+                N_Generic_Subprogram_Declaration\n               and then Def_Id =\n                 Defining_Entity (Specification (Parent (Parent (Def_Id))))\n             then\n@@ -2922,7 +3078,14 @@ package body Sem_Util is\n \n       begin\n          Iface_Param := First (Iface_Params);\n-         Iface_Typ   := Find_Parameter_Type (Iface_Param);\n+\n+         if Nkind (Parameter_Type (Iface_Param)) = N_Access_Definition then\n+            Iface_Typ :=\n+               Designated_Type (Etype (Defining_Identifier (Iface_Param)));\n+         else\n+            Iface_Typ := Etype (Defining_Identifier (Iface_Param));\n+         end if;\n+\n          Prim_Param  := First (Prim_Params);\n \n          --  The first parameter of the potentially overriden subprogram\n@@ -3126,8 +3289,12 @@ package body Sem_Util is\n       if Nkind (Param) /= N_Parameter_Specification then\n          return Empty;\n \n+      --  For an access parameter, obtain the type from the formal entity\n+      --  itself, because access to subprogram nodes do not carry a type.\n+      --  Shouldn't we always use the formal entity ???\n+\n       elsif Nkind (Parameter_Type (Param)) = N_Access_Definition then\n-         return Etype (Subtype_Mark (Parameter_Type (Param)));\n+         return Etype (Defining_Identifier (Param));\n \n       else\n          return Etype (Parameter_Type (Param));\n@@ -3293,7 +3460,7 @@ package body Sem_Util is\n \n    begin\n       Res := Internal_Full_Qualified_Name (E);\n-      Store_String_Char (Get_Char_Code (ASCII.nul));\n+      Store_String_Char (Get_Char_Code (ASCII.NUL));\n       return End_String;\n    end Full_Qualified_Name;\n \n@@ -3541,9 +3708,9 @@ package body Sem_Util is\n            and then not Has_Unknown_Discriminants (Utyp)\n            and then not (Ekind (Utyp) = E_String_Literal_Subtype)\n       then\n-         --  Nothing to do if in default expression\n+         --  Nothing to do if in spec expression (why not???)\n \n-         if In_Default_Expression then\n+         if In_Spec_Expression then\n             return Typ;\n \n          elsif Is_Private_Type (Typ)\n@@ -3661,10 +3828,7 @@ package body Sem_Util is\n       --  literals to search. Instead, an N_Character_Literal node is created\n       --  with the appropriate Char_Code and Chars fields.\n \n-      if Root_Type (T) = Standard_Character\n-        or else Root_Type (T) = Standard_Wide_Character\n-        or else Root_Type (T) = Standard_Wide_Wide_Character\n-      then\n+      if Is_Standard_Character_Type (T) then\n          Set_Character_Literal_Name (UI_To_CC (Pos));\n          return\n            Make_Character_Literal (Loc,\n@@ -3902,7 +4066,7 @@ package body Sem_Util is\n    function Get_Task_Body_Procedure (E : Entity_Id) return Node_Id is\n    begin\n       --  Note: A task type may be the completion of a private type with\n-      --  discriminants. when performing elaboration checks on a task\n+      --  discriminants. When performing elaboration checks on a task\n       --  declaration, the current view of the type may be the private one,\n       --  and the procedure that holds the body of the task is held in its\n       --  underlying type.\n@@ -4018,9 +4182,17 @@ package body Sem_Util is\n             Comp : Entity_Id;\n \n          begin\n+            --  Loop to Check components\n+\n             Comp := First_Component_Or_Discriminant (Typ);\n             while Present (Comp) loop\n-               if Has_Access_Values (Etype (Comp)) then\n+\n+               --  Check for access component, tag field does not count, even\n+               --  though it is implemented internally using an access type.\n+\n+               if Has_Access_Values (Etype (Comp))\n+                 and then Chars (Comp) /= Name_uTag\n+               then\n                   return True;\n                end if;\n \n@@ -4526,6 +4698,59 @@ package body Sem_Util is\n       end if;\n    end Has_Null_Extension;\n \n+   -------------------------------\n+   -- Has_Overriding_Initialize --\n+   -------------------------------\n+\n+   function Has_Overriding_Initialize (T : Entity_Id) return Boolean is\n+      BT   : constant Entity_Id := Base_Type (T);\n+      Comp : Entity_Id;\n+      P    : Elmt_Id;\n+\n+   begin\n+      if Is_Controlled (BT) then\n+\n+         --  For derived types, check immediate ancestor, excluding\n+         --  Controlled itself.\n+\n+         if Is_Derived_Type (BT)\n+           and then not In_Predefined_Unit (Etype (BT))\n+           and then Has_Overriding_Initialize (Etype (BT))\n+         then\n+            return True;\n+\n+         elsif Present (Primitive_Operations (BT)) then\n+            P := First_Elmt (Primitive_Operations (BT));\n+            while Present (P) loop\n+               if Chars (Node (P)) = Name_Initialize\n+                 and then Comes_From_Source (Node (P))\n+               then\n+                  return True;\n+               end if;\n+\n+               Next_Elmt (P);\n+            end loop;\n+         end if;\n+\n+         return False;\n+\n+      elsif Has_Controlled_Component (BT) then\n+         Comp := First_Component (BT);\n+         while Present (Comp) loop\n+            if Has_Overriding_Initialize (Etype (Comp)) then\n+               return True;\n+            end if;\n+\n+            Next_Component (Comp);\n+         end loop;\n+\n+         return False;\n+\n+      else\n+         return False;\n+      end if;\n+   end Has_Overriding_Initialize;\n+\n    --------------------------------------\n    -- Has_Preelaborable_Initialization --\n    --------------------------------------\n@@ -4810,24 +5035,9 @@ package body Sem_Util is\n \n          if Has_PE\n            and then Is_Controlled (E)\n-           and then Present (Primitive_Operations (E))\n+           and then Has_Overriding_Initialize (E)\n          then\n-            declare\n-               P : Elmt_Id;\n-\n-            begin\n-               P := First_Elmt (Primitive_Operations (E));\n-               while Present (P) loop\n-                  if Chars (Node (P)) = Name_Initialize\n-                    and then Comes_From_Source (Node (P))\n-                  then\n-                     Has_PE := False;\n-                     exit;\n-                  end if;\n-\n-                  Next_Elmt (P);\n-               end loop;\n-            end;\n+            Has_PE := False;\n          end if;\n \n       --  Record type has PI if it is non private and all components have PI\n@@ -5757,8 +5967,6 @@ package body Sem_Util is\n             T := Base_Type (Etyp);\n          end loop;\n       end if;\n-\n-      raise Program_Error;\n    end Is_Descendent_Of;\n \n    --------------\n@@ -5920,13 +6128,13 @@ package body Sem_Util is\n                              or else No (Expression (Parent (Ent))))\n                  and then not Is_Fully_Initialized_Type (Etype (Ent))\n \n-                  --  Special VM case for uTag component, which needs to be\n-                  --  defined in this case, but is never initialized as VMs\n+                  --  Special VM case for tag components, which need to be\n+                  --  defined in this case, but are never initialized as VMs\n                   --  are using other dispatching mechanisms. Ignore this\n-                  --  uninitialized case.\n+                  --  uninitialized case. Note that this applies both to the\n+                  --  uTag entry and the main vtable pointer (CPP_Class case).\n \n-                 and then (VM_Target = No_VM\n-                            or else Chars (Ent) /= Name_uTag)\n+                 and then (VM_Target = No_VM or else not Is_Tag (Ent))\n                then\n                   return False;\n                end if;\n@@ -6176,7 +6384,7 @@ package body Sem_Util is\n \n    function Is_OK_Variable_For_Out_Formal (AV : Node_Id) return Boolean is\n    begin\n-      Note_Possible_Modification (AV);\n+      Note_Possible_Modification (AV, Sure => True);\n \n       --  We must reject parenthesized variable names. The check for\n       --  Comes_From_Source is present because there are currently\n@@ -6220,7 +6428,7 @@ package body Sem_Util is\n          if Is_Variable (Expression (AV))\n            and then Paren_Count (Expression (AV)) = 0\n          then\n-            Note_Possible_Modification (Expression (AV));\n+            Note_Possible_Modification (Expression (AV), Sure => True);\n             return True;\n \n          --  We also allow a non-parenthesized expression that raises\n@@ -7877,7 +8085,7 @@ package body Sem_Util is\n    -- Note_Possible_Modification --\n    --------------------------------\n \n-   procedure Note_Possible_Modification (N : Node_Id) is\n+   procedure Note_Possible_Modification (N : Node_Id; Sure : Boolean) is\n       Modification_Comes_From_Source : constant Boolean :=\n                                          Comes_From_Source (Parent (N));\n \n@@ -7993,6 +8201,35 @@ package body Sem_Util is\n             end if;\n \n             Kill_Checks (Ent);\n+\n+            --  If we are sure this is a modification from source, and we know\n+            --  this modifies a constant, then give an appropriate warning.\n+\n+            if Overlays_Constant (Ent)\n+              and then Modification_Comes_From_Source\n+              and then Sure\n+            then\n+               declare\n+                  A : constant Node_Id := Address_Clause (Ent);\n+               begin\n+                  if Present (A) then\n+                     declare\n+                        Exp : constant Node_Id := Expression (A);\n+                     begin\n+                        if Nkind (Exp) = N_Attribute_Reference\n+                          and then Attribute_Name (Exp) = Name_Address\n+                          and then Is_Entity_Name (Prefix (Exp))\n+                        then\n+                           Error_Msg_Sloc := Sloc (A);\n+                           Error_Msg_NE\n+                             (\"constant& may be modified via address clause#?\",\n+                              N, Entity (Prefix (Exp)));\n+                        end if;\n+                     end;\n+                  end if;\n+               end;\n+            end if;\n+\n             return;\n          end if;\n       end loop;\n@@ -8045,6 +8282,10 @@ package body Sem_Util is\n       if Is_Entity_Name (Obj) then\n          E := Entity (Obj);\n \n+         if Is_Prival (E) then\n+            E := Prival_Link (E);\n+         end if;\n+\n          --  If E is a type then it denotes a current instance. For this case\n          --  we add one to the normal accessibility level of the type to ensure\n          --  that current instances are treated as always being deeper than\n@@ -8881,7 +9122,7 @@ package body Sem_Util is\n    -- Scope_Is_Transient --\n    ------------------------\n \n-   function Scope_Is_Transient  return Boolean is\n+   function Scope_Is_Transient return Boolean is\n    begin\n       return Scope_Stack.Table (Scope_Stack.Last).Is_Transient;\n    end Scope_Is_Transient;\n@@ -9113,13 +9354,54 @@ package body Sem_Util is\n       end if;\n    end Set_Next_Actual;\n \n+   ----------------------------------\n+   -- Set_Optimize_Alignment_Flags --\n+   ----------------------------------\n+\n+   procedure Set_Optimize_Alignment_Flags (E : Entity_Id) is\n+   begin\n+      if Optimize_Alignment = 'S' then\n+         Set_Optimize_Alignment_Space (E);\n+      elsif Optimize_Alignment = 'T' then\n+         Set_Optimize_Alignment_Time (E);\n+      end if;\n+   end Set_Optimize_Alignment_Flags;\n+\n    -----------------------\n    -- Set_Public_Status --\n    -----------------------\n \n    procedure Set_Public_Status (Id : Entity_Id) is\n       S : constant Entity_Id := Current_Scope;\n \n+      function Within_HSS_Or_If (E : Entity_Id) return Boolean;\n+      --  Determines if E is defined within handled statement sequence or\n+      --  an if statement, returns True if so, False otherwise.\n+\n+      ----------------------\n+      -- Within_HSS_Or_If --\n+      ----------------------\n+\n+      function Within_HSS_Or_If (E : Entity_Id) return Boolean is\n+         N : Node_Id;\n+      begin\n+         N := Declaration_Node (E);\n+         loop\n+            N := Parent (N);\n+\n+            if No (N) then\n+               return False;\n+\n+            elsif Nkind_In (N, N_Handled_Sequence_Of_Statements,\n+                               N_If_Statement)\n+            then\n+               return True;\n+            end if;\n+         end loop;\n+      end Within_HSS_Or_If;\n+\n+   --  Start of processing for Set_Public_Status\n+\n    begin\n       --  Everything in the scope of Standard is public\n \n@@ -9131,14 +9413,15 @@ package body Sem_Util is\n       elsif not Is_Public (S) then\n          return;\n \n-      --  An object declaration that occurs in a handled sequence of statements\n-      --  is the declaration for a temporary object generated by the expander.\n-      --  It never needs to be made public and furthermore, making it public\n-      --  can cause back end problems if it is of variable size.\n+      --  An object or function declaration that occurs in a handled sequence\n+      --  of statements or within an if statement is the declaration for a\n+      --  temporary object or local subprogram generated by the expander. It\n+      --  never needs to be made public and furthermore, making it public can\n+      --  cause back end problems.\n \n-      elsif Nkind (Parent (Id)) = N_Object_Declaration\n-        and then\n-          Nkind (Parent (Parent (Id))) = N_Handled_Sequence_Of_Statements\n+      elsif Nkind_In (Parent (Id), N_Object_Declaration,\n+                                   N_Function_Specification)\n+        and then Within_HSS_Or_If (Id)\n       then\n          return;\n "}, {"sha": "c47af51cb127e5ecb60a19621854aa550733a0d6", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=ce4a6e84681c0d3561c4791ddfd6cdcbd9cbe5d3", "patch": "@@ -139,6 +139,13 @@ package Sem_Util is\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning.\n \n+   procedure Check_Unprotected_Access\n+     (Context : Node_Id;\n+      Expr    : Node_Id);\n+   --  Check whether the expression is a pointer to a protected component,\n+   --  and the context is external to the protected operation, to warn against\n+   --  a possible unlocked access to data.\n+\n    procedure Check_VMS (Construct : Node_Id);\n    --  Check that this the target is OpenVMS, and if so, return with\n    --  no effect, otherwise post an error noting this can only be used\n@@ -196,6 +203,12 @@ package Sem_Util is\n    --  Sets the Has_Delayed_Freeze flag of New if the Delayed_Freeze flag\n    --  of Old is set and Old has no yet been Frozen (i.e. Is_Frozen is false);\n \n+   function Copy_Parameter_List (Subp_Id : Entity_Id) return List_Id;\n+   --  Utility to create a parameter profile for a new subprogram spec,\n+   --  when the subprogram has a body that acts as spec. This is done for\n+   --  some cases of inlining, and for private protected ops. Also used\n+   --  to create bodies for stubbed subprograms.\n+\n    function Current_Entity (N : Node_Id) return Entity_Id;\n    --  Find the currently visible definition for a given identifier, that is to\n    --  say the first entry in the visibility chain for the Chars of N.\n@@ -474,11 +487,13 @@ package Sem_Util is\n    --  declaration.\n \n    function Has_Access_Values (T : Entity_Id) return Boolean;\n-   --  Returns true if type or subtype T is an access type, or has a\n-   --  component (at any recursive level) that is an access type. This\n-   --  is a conservative predicate, if it is not known whether or not\n-   --  T contains access values (happens for generic formals in some\n-   --  cases), then False is returned.\n+   --  Returns true if type or subtype T is an access type, or has a component\n+   --  (at any recursive level) that is an access type. This is a conservative\n+   --  predicate, if it is not known whether or not T contains access values\n+   --  (happens for generic formals in some cases), then False is returned.\n+   --  Note that tagged types return False. Even though the tag is implemented\n+   --  as an access type internally, this function tests only for access types\n+   --  known to the programmer. See also Has_Tagged_Component.\n \n    function Has_Abstract_Interfaces\n      (T             : Entity_Id;\n@@ -527,6 +542,10 @@ package Sem_Util is\n    function Has_Null_Exclusion (N : Node_Id) return Boolean;\n    --  Determine whether node N has a null exclusion\n \n+   function Has_Overriding_Initialize (T : Entity_Id) return Boolean;\n+   --  Predicate to determine whether a controlled type has a user-defined\n+   --  initialize procedure, which makes the type not preelaborable.\n+\n    function Has_Preelaborable_Initialization (E : Entity_Id) return Boolean;\n    --  Return True iff type E has preelaborable initialiation as defined in\n    --  Ada 2005 (see AI-161 for details of the definition of this attribute).\n@@ -544,8 +563,11 @@ package Sem_Util is\n    --  if there is no underlying type).\n \n    function Has_Tagged_Component (Typ : Entity_Id) return Boolean;\n-   --  Typ must be a composite type (array or record). This function is used\n-   --  to check if '=' has to be expanded into a bunch component comparaisons.\n+   --  Returns True if Typ is a composite type (array or record) which is\n+   --  either itself a tagged type, or has a component (recursively) which is\n+   --  a tagged type. Returns False for non-composite type, or if no tagged\n+   --  component is present. to check if '=' has to be expanded into a bunch\n+   --  component comparisons.\n \n    function In_Instance return Boolean;\n    --  Returns True if the current scope is within a generic instance\n@@ -801,10 +823,10 @@ package Sem_Util is\n    --  set if you want to clear only the Last_Assignment field (see above).\n \n    procedure Kill_Size_Check_Code (E : Entity_Id);\n-   --  Called when an address clause or pragma Import is applied to an\n-   --  entity. If the entity is a variable or a constant, and size check\n-   --  code is present, this size check code is killed, since the object\n-   --  will not be allocated by the program.\n+   --  Called when an address clause or pragma Import is applied to an entity.\n+   --  If the entity is a variable or a constant, and size check code is\n+   --  present, this size check code is killed, since the object will not\n+   --  be allocated by the program.\n \n    function Known_To_Be_Assigned (N : Node_Id) return Boolean;\n    --  The node N is an entity reference. This function determines whether the\n@@ -900,13 +922,17 @@ package Sem_Util is\n    --  in Success indicates sucess of reordering. For more details, see body.\n    --  Errors are reported only if Report is set to True.\n \n-   procedure Note_Possible_Modification (N : Node_Id);\n+   procedure Note_Possible_Modification (N : Node_Id; Sure : Boolean);\n    --  This routine is called if the sub-expression N maybe the target of\n    --  an assignment (e.g. it is the left side of an assignment, used as\n    --  an out parameters, or used as prefixes of access attributes). It\n    --  sets May_Be_Modified in the associated entity if there is one,\n    --  taking into account the rule that in the case of renamed objects,\n    --  it is the flag in the renamed object that must be set.\n+   --\n+   --  The parameter Sure is set True if the modification is sure to occur\n+   --  (e.g. target of assignment, or out parameter), and to False if the\n+   --  modification is only potential (e.g. address of entity taken).\n \n    function Object_Access_Level (Obj : Node_Id) return Uint;\n    --  Return the accessibility level of the view of the object Obj.\n@@ -1057,6 +1083,10 @@ package Sem_Util is\n    --  parameters are already members of a list, and do not need to be\n    --  chained separately. See also First_Actual and Next_Actual.\n \n+   procedure Set_Optimize_Alignment_Flags (E : Entity_Id);\n+   pragma Inline (Set_Optimize_Alignment_Flags);\n+   --  Sets Optimize_Aliignment_Space/Time flags in E from current settings\n+\n    procedure Set_Public_Status (Id : Entity_Id);\n    --  If an entity (visible or otherwise) is defined in a library\n    --  package, or a package that is itself public, then this subprogram"}]}