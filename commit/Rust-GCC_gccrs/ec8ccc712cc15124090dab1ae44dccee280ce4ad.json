{"sha": "ec8ccc712cc15124090dab1ae44dccee280ce4ad", "node_id": "C_kwDOANBUbNoAKGVjOGNjYzcxMmNjMTUxMjQwOTBkYWIxYWU0NGRjY2VlMjgwY2U0YWQ", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2021-08-31T08:21:42Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-05T08:20:00Z"}, "message": "[Ada] Proof of Ada.Characters.Handling\n\ngcc/ada/\n\n\t* libgnat/a-chahan.adb: Add loop invariants as needed to prove\n\tsubprograms.  Also use extended return statements where\n\tappropriate and not done already.  Mark data with\n\tRelaxed_Initialization where needed for initialization by parts.\n\tConvert regular functions to expression functions where needed\n\tfor proof.\n\t* libgnat/a-chahan.ads: Add postconditions.\n\t* libgnat/a-strmap.ads (Model): New ghost function to create a\n\tpublicly visible model of the private data Character_Mapping,\n\tneeded in order to prove subprograms in Ada.Characters.Handling.", "tree": {"sha": "1ba8112705882a6116b77fe17cf057bc8f6f0d5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ba8112705882a6116b77fe17cf057bc8f6f0d5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec8ccc712cc15124090dab1ae44dccee280ce4ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8ccc712cc15124090dab1ae44dccee280ce4ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8ccc712cc15124090dab1ae44dccee280ce4ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8ccc712cc15124090dab1ae44dccee280ce4ad/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1581aa38eba0ab47eaebe45e8dc6bef6832381c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1581aa38eba0ab47eaebe45e8dc6bef6832381c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1581aa38eba0ab47eaebe45e8dc6bef6832381c8"}], "stats": {"total": 512, "additions": 428, "deletions": 84}, "files": [{"sha": "411d485db60d49eabd4878abd31c46afab2382ea", "filename": "gcc/ada/libgnat/a-chahan.adb", "status": "modified", "additions": 74, "deletions": 48, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8ccc712cc15124090dab1ae44dccee280ce4ad/gcc%2Fada%2Flibgnat%2Fa-chahan.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8ccc712cc15124090dab1ae44dccee280ce4ad/gcc%2Fada%2Flibgnat%2Fa-chahan.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chahan.adb?ref=ec8ccc712cc15124090dab1ae44dccee280ce4ad", "patch": "@@ -29,11 +29,19 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+--  Loop invariants in this unit are meant for analysis only, not for run-time\n+--  checking, as it would be too costly otherwise. This is enforced by setting\n+--  the assertion policy to Ignore.\n+\n+pragma Assertion_Policy (Loop_Invariant => Ignore);\n+\n with Ada.Characters.Latin_1;     use Ada.Characters.Latin_1;\n with Ada.Strings.Maps;           use Ada.Strings.Maps;\n with Ada.Strings.Maps.Constants; use Ada.Strings.Maps.Constants;\n \n-package body Ada.Characters.Handling is\n+package body Ada.Characters.Handling\n+  with SPARK_Mode\n+is\n \n    ------------------------------------\n    -- Character Classification Table --\n@@ -299,9 +307,7 @@ package body Ada.Characters.Handling is\n    ------------------\n \n    function Is_Character (Item : Wide_Character) return Boolean is\n-   begin\n-      return Wide_Character'Pos (Item) < 256;\n-   end Is_Character;\n+     (Wide_Character'Pos (Item) < 256);\n \n    ----------------\n    -- Is_Control --\n@@ -344,9 +350,7 @@ package body Ada.Characters.Handling is\n    ----------------\n \n    function Is_ISO_646 (Item : Character) return Boolean is\n-   begin\n-      return Item in ISO_646;\n-   end Is_ISO_646;\n+     (Item in ISO_646);\n \n    --  Note: much more efficient coding of the following function is possible\n    --  by testing several 16#80# bits in a complete word in a single operation\n@@ -357,6 +361,8 @@ package body Ada.Characters.Handling is\n          if Item (J) not in ISO_646 then\n             return False;\n          end if;\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Is_ISO_646 (Item (K)));\n       end loop;\n \n       return True;\n@@ -456,6 +462,8 @@ package body Ada.Characters.Handling is\n          if Wide_Character'Pos (Item (J)) >= 256 then\n             return False;\n          end if;\n+         pragma Loop_Invariant\n+           (for all K in Item'First .. J => Is_Character (Item (K)));\n       end loop;\n \n       return True;\n@@ -475,15 +483,18 @@ package body Ada.Characters.Handling is\n    --------------\n \n    function To_Basic (Item : Character) return Character is\n-   begin\n-      return Value (Basic_Map, Item);\n-   end To_Basic;\n+      (Value (Basic_Map, Item));\n \n    function To_Basic (Item : String) return String is\n    begin\n-      return Result : String (1 .. Item'Length) do\n+      return Result : String (1 .. Item'Length) with Relaxed_Initialization do\n          for J in Item'Range loop\n             Result (J - (Item'First - 1)) := Value (Basic_Map, Item (J));\n+            pragma Loop_Invariant\n+              (Result (1 .. J - Item'First + 1)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Item'First .. J =>\n+                 Result (K - (Item'First - 1)) = To_Basic (Item (K)));\n          end loop;\n       end return;\n    end To_Basic;\n@@ -511,40 +522,44 @@ package body Ada.Characters.Handling is\n    function To_ISO_646\n      (Item       : Character;\n       Substitute : ISO_646 := ' ') return ISO_646\n-   is\n-   begin\n-      return (if Item in ISO_646 then Item else Substitute);\n-   end To_ISO_646;\n+   is (if Item in ISO_646 then Item else Substitute);\n \n    function To_ISO_646\n      (Item       : String;\n       Substitute : ISO_646 := ' ') return String\n    is\n-      Result : String (1 .. Item'Length);\n-\n    begin\n-      for J in Item'Range loop\n-         Result (J - (Item'First - 1)) :=\n-           (if Item (J) in ISO_646 then Item (J) else Substitute);\n-      end loop;\n-\n-      return Result;\n+      return Result : String (1 .. Item'Length) with Relaxed_Initialization do\n+         for J in Item'Range loop\n+            Result (J - (Item'First - 1)) :=\n+              (if Item (J) in ISO_646 then Item (J) else Substitute);\n+            pragma Loop_Invariant\n+              (Result (1 .. J - Item'First + 1)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Item'First .. J =>\n+                 Result (K - (Item'First - 1)) =\n+                   To_ISO_646 (Item (K), Substitute));\n+         end loop;\n+      end return;\n    end To_ISO_646;\n \n    --------------\n    -- To_Lower --\n    --------------\n \n    function To_Lower (Item : Character) return Character is\n-   begin\n-      return Value (Lower_Case_Map, Item);\n-   end To_Lower;\n+     (Value (Lower_Case_Map, Item));\n \n    function To_Lower (Item : String) return String is\n    begin\n-      return Result : String (1 .. Item'Length) do\n+      return Result : String (1 .. Item'Length) with Relaxed_Initialization do\n          for J in Item'Range loop\n             Result (J - (Item'First - 1)) := Value (Lower_Case_Map, Item (J));\n+            pragma Loop_Invariant\n+              (Result (1 .. J - Item'First + 1)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Item'First .. J =>\n+                 Result (K - (Item'First - 1)) = To_Lower (Item (K)));\n          end loop;\n       end return;\n    end To_Lower;\n@@ -557,34 +572,40 @@ package body Ada.Characters.Handling is\n      (Item       : Wide_String;\n       Substitute : Character := ' ') return String\n    is\n-      Result : String (1 .. Item'Length);\n-\n    begin\n-      for J in Item'Range loop\n-         Result (J - (Item'First - 1)) := To_Character (Item (J), Substitute);\n-      end loop;\n-\n-      return Result;\n+      return Result : String (1 .. Item'Length) with Relaxed_Initialization do\n+         for J in Item'Range loop\n+            Result (J - (Item'First - 1)) :=\n+              To_Character (Item (J), Substitute);\n+            pragma Loop_Invariant\n+              (Result (1 .. J - (Item'First - 1))'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Item'First .. J =>\n+                 Result (K - (Item'First - 1)) =\n+                   To_Character (Item (K), Substitute));\n+         end loop;\n+      end return;\n    end To_String;\n \n    --------------\n    -- To_Upper --\n    --------------\n \n-   function To_Upper\n-     (Item : Character) return Character\n-   is\n-   begin\n-      return Value (Upper_Case_Map, Item);\n-   end To_Upper;\n+   function To_Upper (Item : Character) return Character is\n+     (Value (Upper_Case_Map, Item));\n \n    function To_Upper\n      (Item : String) return String\n    is\n    begin\n-      return Result : String (1 .. Item'Length) do\n+      return Result : String (1 .. Item'Length) with Relaxed_Initialization do\n          for J in Item'Range loop\n             Result (J - (Item'First - 1)) := Value (Upper_Case_Map, Item (J));\n+            pragma Loop_Invariant\n+              (Result (1 .. J - Item'First + 1)'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Item'First .. J =>\n+                 Result (K - (Item'First - 1)) = To_Upper (Item (K)));\n          end loop;\n       end return;\n    end To_Upper;\n@@ -607,14 +628,19 @@ package body Ada.Characters.Handling is\n    function To_Wide_String\n      (Item : String) return Wide_String\n    is\n-      Result : Wide_String (1 .. Item'Length);\n-\n    begin\n-      for J in Item'Range loop\n-         Result (J - (Item'First - 1)) := To_Wide_Character (Item (J));\n-      end loop;\n-\n-      return Result;\n+      return Result : Wide_String (1 .. Item'Length)\n+        with Relaxed_Initialization\n+      do\n+         for J in Item'Range loop\n+            Result (J - (Item'First - 1)) := To_Wide_Character (Item (J));\n+            pragma Loop_Invariant\n+              (Result (1 .. J - (Item'First - 1))'Initialized);\n+            pragma Loop_Invariant\n+              (for all K in Item'First .. J =>\n+                 Result (K - (Item'First - 1)) = To_Wide_Character (Item (K)));\n+         end loop;\n+      end return;\n    end To_Wide_String;\n \n end Ada.Characters.Handling;"}, {"sha": "093237dea79fbf1e90a1a17b52d4febc5b2a23c9", "filename": "gcc/ada/libgnat/a-chahan.ads", "status": "modified", "additions": 326, "deletions": 33, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8ccc712cc15124090dab1ae44dccee280ce4ad/gcc%2Fada%2Flibgnat%2Fa-chahan.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8ccc712cc15124090dab1ae44dccee280ce4ad/gcc%2Fada%2Flibgnat%2Fa-chahan.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-chahan.ads?ref=ec8ccc712cc15124090dab1ae44dccee280ce4ad", "patch": "@@ -33,62 +33,313 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package Ada.Characters.Handling is\n+--  Postconditions in this unit are meant for analysis only, not for run-time\n+--  checking, in order not to slow down the execution of these functions.\n+\n+pragma Assertion_Policy (Post => Ignore);\n+\n+with Ada.Characters.Latin_1;\n+\n+package Ada.Characters.Handling\n+  with SPARK_Mode\n+is\n    pragma Pure;\n    --  In accordance with Ada 2005 AI-362\n \n    ----------------------------------------\n    -- Character Classification Functions --\n    ----------------------------------------\n \n-   function Is_Control               (Item : Character) return Boolean;\n-   function Is_Graphic               (Item : Character) return Boolean;\n-   function Is_Letter                (Item : Character) return Boolean;\n-   function Is_Lower                 (Item : Character) return Boolean;\n-   function Is_Upper                 (Item : Character) return Boolean;\n-   function Is_Basic                 (Item : Character) return Boolean;\n-   function Is_Digit                 (Item : Character) return Boolean;\n+   --  In the description below for each function that returns a Boolean\n+   --  result, the effect is described in terms of the conditions under which\n+   --  the value True is returned. If these conditions are not met, then the\n+   --  function returns False.\n+   --\n+   --  Each of the following classification functions has a formal Character\n+   --  parameter, Item, and returns a Boolean result.\n+\n+   function Is_Control               (Item : Character) return Boolean\n+   with\n+     Post => Is_Control'Result =\n+       (Character'Pos (Item) in 0 .. 31 | 127 .. 159);\n+   --  True if Item is a control character. A control character is a character\n+   --  whose position is in one of the ranges 0..31 or 127..159.\n+\n+   function Is_Graphic               (Item : Character) return Boolean\n+   with\n+     Post => Is_Graphic'Result =\n+       (Character'Pos (Item) in 32 .. 126 | 160 .. 255);\n+   --  True if Item is a graphic character. A graphic character is a character\n+   --  whose position is in one of the ranges 32..126 or 160..255.\n+\n+   function Is_Letter                (Item : Character) return Boolean\n+   with\n+     Post => Is_Letter'Result =\n+       (Item in 'A' .. 'Z' | 'a' .. 'z'\n+         or else Character'Pos (Item) in 192 .. 214 | 216 .. 246 | 248 .. 255);\n+   --  True if Item is a letter. A letter is a character that is in one of the\n+   --  ranges 'A'..'Z' or 'a'..'z', or whose position is in one of the ranges\n+   --  192..214, 216..246, or 248..255.\n+\n+   function Is_Lower                 (Item : Character) return Boolean\n+   with\n+     Post => Is_Lower'Result =\n+       (Item in 'a' .. 'z'\n+         or else Character'Pos (Item) in 223 .. 246 | 248 .. 255);\n+   --  True if Item is a lower-case letter. A lower-case letter is a character\n+   --  that is in the range 'a'..'z', or whose position is in one of the ranges\n+   --  223..246 or 248..255.\n+\n+   function Is_Upper                 (Item : Character) return Boolean\n+   with\n+     Post => Is_Upper'Result =\n+       (Item in 'A' .. 'Z'\n+         or else Character'Pos (Item) in 192 .. 214 | 216 .. 222);\n+   --  True if Item is an upper-case letter. An upper-case letter is a\n+   --  character that is in the range 'A'..'Z' or whose position is in one\n+   --  of the ranges 192..214 or 216..222.\n+\n+   function Is_Basic                 (Item : Character) return Boolean\n+   with\n+     Post => Is_Basic'Result =\n+       (Item in 'A' .. 'Z'\n+          | 'a' .. 'z'\n+          | Latin_1.UC_AE_Diphthong\n+          | Latin_1.LC_AE_Diphthong\n+          | Latin_1.UC_Icelandic_Eth\n+          | Latin_1.LC_Icelandic_Eth\n+          | Latin_1.UC_Icelandic_Thorn\n+          | Latin_1.LC_Icelandic_Thorn\n+          | Latin_1.LC_German_Sharp_S);\n+   --  True if Item is a basic letter. A basic letter is a character that\n+   --  is in one of the ranges 'A'..'Z' and 'a'..'z', or that is one of\n+   --  the following: UC_AE_Diphthong, LC_AE_Diphthong, UC_Icelandic_Eth,\n+   --  LC_Icelandic_Eth, UC_Icelandic_Thorn, LC_Icelandic_Thorn, or\n+   --  LC_German_Sharp_S.\n+\n+   function Is_Digit                 (Item : Character) return Boolean\n+   with\n+     Post => Is_Digit'Result = (Item in '0' .. '9');\n+   --  True if Item is a decimal digit. A decimal digit is a character in the\n+   --  range '0'..'9'.\n+\n    function Is_Decimal_Digit         (Item : Character) return Boolean\n      renames Is_Digit;\n-   function Is_Hexadecimal_Digit     (Item : Character) return Boolean;\n-   function Is_Alphanumeric          (Item : Character) return Boolean;\n-   function Is_Special               (Item : Character) return Boolean;\n-   function Is_Line_Terminator       (Item : Character) return Boolean;\n-   function Is_Mark                  (Item : Character) return Boolean;\n-   function Is_Other_Format          (Item : Character) return Boolean;\n-   function Is_Punctuation_Connector (Item : Character) return Boolean;\n-   function Is_Space                 (Item : Character) return Boolean;\n-   function Is_NFKC                  (Item : Character) return Boolean;\n+\n+   function Is_Hexadecimal_Digit     (Item : Character) return Boolean\n+   with\n+     Post => Is_Hexadecimal_Digit'Result =\n+       (Is_Decimal_Digit (Item) or Item in 'A' .. 'F' | 'a' .. 'f');\n+   --  True if Item is a hexadecimal digit. A hexadecimal digit is a character\n+   --  that is either a decimal digit or that is in one of the ranges 'A'..'F'\n+   --  or 'a'..'f'.\n+\n+   function Is_Alphanumeric          (Item : Character) return Boolean\n+   with\n+     Post => Is_Alphanumeric'Result =\n+       (Is_Letter (Item) or Is_Decimal_Digit (Item));\n+   --  True if Item is an alphanumeric character. An alphanumeric character is\n+   --  a character that is either a letter or a decimal digit.\n+\n+   function Is_Special               (Item : Character) return Boolean\n+   with\n+     Post => Is_Special'Result =\n+       (Is_Graphic (Item) and not Is_Alphanumeric (Item));\n+   --  True if Item is a special graphic character. A special graphic character\n+   --  is a graphic character that is not alphanumeric.\n+\n+   function Is_Line_Terminator       (Item : Character) return Boolean\n+   with\n+     Post => Is_Line_Terminator'Result =\n+       (Character'Pos (Item) in 10 .. 13 | 133);\n+   --  True if Item is a character with position 10..13 (Line_Feed,\n+   --  Line_Tabulation, Form_Feed, Carriage_Return) or 133 (Next_Line).\n+\n+   function Is_Mark                  (Item : Character) return Boolean\n+   with\n+     Post => Is_Mark'Result = False;\n+   --  Never True (no value of type Character has categories Mark, Non-Spacing\n+   --  or Mark, Spacing Combining).\n+\n+   function Is_Other_Format          (Item : Character) return Boolean\n+   with\n+     Post => Is_Other_Format'Result = (Character'Pos (Item) = 173);\n+   --  True if Item is a character with position 173 (Soft_Hyphen).\n+\n+   function Is_Punctuation_Connector (Item : Character) return Boolean\n+   with\n+     Post => Is_Punctuation_Connector'Result =\n+       (Character'Pos (Item) = 95);\n+   --  True if Item is a character with position 95 ('_', known as Low_Line or\n+   --  Underscore).\n+\n+   function Is_Space                 (Item : Character) return Boolean\n+   with\n+     Post => Is_Space'Result = (Character'Pos (Item) in 32 | 160);\n+   --  True if Item is a character with position 32 (' ') or 160\n+   --  (No_Break_Space).\n+\n+   function Is_NFKC                  (Item : Character) return Boolean\n+   with\n+     Post => Is_NFKC'Result =\n+       (Character'Pos (Item) not in\n+            160 | 168 | 170 | 175 | 178 | 179 | 180\n+          | 181 | 184 | 185 | 186 | 188 | 189 | 190);\n+   --  True if Item could be present in a string normalized to Normalization\n+   --  Form KC (as defined by Clause 21 of ISO/IEC 10646:2017); this includes\n+   --  all characters except those with positions 160, 168, 170, 175, 178, 179,\n+   --  180, 181, 184, 185, 186, 188, 189, and 190.\n \n    ---------------------------------------------------\n    -- Conversion Functions for Character and String --\n    ---------------------------------------------------\n \n-   function To_Lower (Item : Character) return Character;\n-   function To_Upper (Item : Character) return Character;\n-   function To_Basic (Item : Character) return Character;\n+   --  Each of the names To_Lower, To_Upper, and To_Basic refers to two\n+   --  functions: one that converts from Character to Character, and\n+   --  the other that converts from String to String. The result of each\n+   --  Character-to-Character function is described below, in terms of\n+   --  the conversion applied to Item, its formal Character parameter. The\n+   --  result of each String-to-String conversion is obtained by applying\n+   --  to each element of the function's String parameter the corresponding\n+   --  Character-to-Character conversion; the result is the null String if the\n+   --  value of the formal parameter is the null String. The lower bound of the\n+   --  result String is 1.\n+\n+   function To_Lower (Item : Character) return Character\n+   with\n+     Post => To_Lower'Result =\n+       (if Is_Upper (Item) then\n+          Character'Val (Character'Pos (Item) +\n+            (if Item in 'A' .. 'Z' then\n+               Character'Pos ('a') - Character'Pos ('A')\n+             else\n+               Character'Pos (Latin_1.LC_A_Grave)\n+                 - Character'Pos (Latin_1.UC_A_Grave)))\n+        else\n+          Item);\n+   --  Returns the corresponding lower-case value for Item if Is_Upper(Item),\n+   --  and returns Item otherwise.\n \n-   function To_Lower (Item : String) return String;\n-   function To_Upper (Item : String) return String;\n-   function To_Basic (Item : String) return String;\n+   function To_Upper (Item : Character) return Character\n+   with\n+     Post => To_Upper'Result =\n+       (if Is_Lower (Item)\n+          and then Item not in Latin_1.LC_German_Sharp_S\n+                             | Latin_1.LC_Y_Diaeresis\n+        then\n+          Character'Val (Character'Pos (Item) +\n+            (if Item in 'A' .. 'Z' then\n+               Character'Pos ('A') - Character'Pos ('a')\n+             else\n+               Character'Pos (Latin_1.UC_A_Grave)\n+                 - Character'Pos (Latin_1.LC_A_Grave)))\n+        else\n+          Item);\n+   --  Returns the corresponding upper-case value for Item if Is_Lower(Item)\n+   --  and Item has an upper-case form, and returns Item otherwise. The lower\n+   --  case letters LC_German_Sharp_S and LC_Y_Diaeresis do not have upper case\n+   --  forms.\n+\n+   function To_Basic (Item : Character) return Character\n+   with\n+     Post => To_Basic'Result =\n+       (if not Is_Letter (Item) or else Is_Basic (Item) then\n+          Item\n+        else\n+          (case Item is\n+             when Latin_1.UC_A_Grave .. Latin_1.UC_A_Ring      => 'A',\n+             when Latin_1.UC_C_Cedilla                         => 'C',\n+             when Latin_1.UC_E_Grave .. Latin_1.UC_E_Diaeresis => 'E',\n+             when Latin_1.UC_I_Grave .. Latin_1.UC_I_Diaeresis => 'I',\n+             when Latin_1.UC_N_Tilde                           => 'N',\n+             when Latin_1.UC_O_Grave .. Latin_1.UC_O_Diaeresis => 'O',\n+             when Latin_1.UC_O_Oblique_Stroke                  => 'O',\n+             when Latin_1.UC_U_Grave .. Latin_1.UC_U_Diaeresis => 'U',\n+             when Latin_1.UC_Y_Acute                           => 'Y',\n+             when Latin_1.LC_A_Grave .. Latin_1.LC_A_Ring      => 'a',\n+             when Latin_1.LC_C_Cedilla                         => 'c',\n+             when Latin_1.LC_E_Grave .. Latin_1.LC_E_Diaeresis => 'e',\n+             when Latin_1.LC_I_Grave .. Latin_1.LC_I_Diaeresis => 'i',\n+             when Latin_1.LC_N_Tilde                           => 'n',\n+             when Latin_1.LC_O_Grave .. Latin_1.LC_O_Diaeresis => 'o',\n+             when Latin_1.LC_O_Oblique_Stroke                  => 'o',\n+             when Latin_1.LC_U_Grave .. Latin_1.LC_U_Diaeresis => 'u',\n+             when Latin_1.LC_Y_Acute                           => 'y',\n+             when Latin_1.LC_Y_Diaeresis                       => 'y',\n+             when others => raise Program_Error));\n+   --  Returns the letter corresponding to Item but with no diacritical mark,\n+   --  if Item is a letter but not a basic letter; returns Item otherwise.\n+\n+   function To_Lower (Item : String) return String\n+   with\n+     Post => To_Lower'Result'First = 1\n+       and then To_Lower'Result'Length = Item'Length\n+       and then\n+         (for all J in To_Lower'Result'Range =>\n+            To_Lower'Result (J) = To_Lower (Item (Item'First + (J - 1))));\n+\n+   function To_Upper (Item : String) return String\n+   with\n+     Post => To_Upper'Result'First = 1\n+       and then To_Upper'Result'Length = Item'Length\n+       and then\n+         (for all J in To_Upper'Result'Range =>\n+            To_Upper'Result (J) = To_Upper (Item (Item'First + (J - 1))));\n+\n+   function To_Basic (Item : String) return String\n+   with\n+     Post => To_Basic'Result'First = 1\n+       and then To_Basic'Result'Length = Item'Length\n+       and then\n+         (for all J in To_Basic'Result'Range =>\n+            To_Basic'Result (J) = To_Basic (Item (Item'First + (J - 1))));\n \n    ----------------------------------------------------------------------\n    -- Classifications of and Conversions Between Character and ISO 646 --\n    ----------------------------------------------------------------------\n \n+   --  The following set of functions test for membership in the ISO 646\n+   --  character range, or convert between ISO 646 and Character.\n+\n    subtype ISO_646 is\n      Character range Character'Val (0) .. Character'Val (127);\n \n-   function Is_ISO_646 (Item : Character) return Boolean;\n-   function Is_ISO_646 (Item : String)    return Boolean;\n+   function Is_ISO_646 (Item : Character) return Boolean\n+   with\n+     Post => Is_ISO_646'Result = (Item in ISO_646);\n+   --  The function whose formal parameter, Item, is of type Character returns\n+   --  True if Item is in the subtype ISO_646.\n+\n+   function Is_ISO_646 (Item : String)    return Boolean\n+   with\n+     Post => Is_ISO_646'Result =\n+       (for all J in Item'Range => Is_ISO_646 (Item (J)));\n+   --  The function whose formal parameter, Item, is of type String returns\n+   --  True if Is_ISO_646(Item(I)) is True for each I in Item'Range.\n \n    function To_ISO_646\n      (Item       : Character;\n-      Substitute : ISO_646 := ' ') return ISO_646;\n+      Substitute : ISO_646 := ' ') return ISO_646\n+   with\n+     Post => To_ISO_646'Result =\n+       (if Is_ISO_646 (Item) then Item else Substitute);\n+   --  The function whose first formal parameter, Item, is of type Character\n+   --  returns Item if Is_ISO_646(Item), and returns the Substitute ISO_646\n+   --  character otherwise.\n \n    function To_ISO_646\n      (Item       : String;\n-      Substitute : ISO_646 := ' ') return String;\n+      Substitute : ISO_646 := ' ') return String\n+   with\n+     Post => To_ISO_646'Result'First = 1\n+       and then To_ISO_646'Result'Length = Item'Length\n+       and then\n+         (for all J in To_ISO_646'Result'Range =>\n+            To_ISO_646'Result (J) =\n+              To_ISO_646 (Item (Item'First + (J - 1)), Substitute));\n+   --  The function whose first formal parameter, Item, is of type String\n+   --  returns the String whose Range is 1..Item'Length and each of whose\n+   --  elements is given by To_ISO_646 of the corresponding element in Item.\n \n    ------------------------------------------------------\n    -- Classifications of Wide_Character and Characters --\n@@ -103,8 +354,18 @@ package Ada.Characters.Handling is\n    --  We do however have to flag these if the pragma No_Obsolescent_Features\n    --  restriction is active (see Restrict.Check_Obsolescent_2005_Entity).\n \n-   function Is_Character (Item : Wide_Character) return Boolean;\n-   function Is_String    (Item : Wide_String)    return Boolean;\n+   function Is_Character (Item : Wide_Character) return Boolean\n+   with\n+     Post => Is_Character'Result =\n+       (Wide_Character'Pos (Item) <= Character'Pos (Character'Last));\n+   --  Returns True if Wide_Character'Pos(Item) <=\n+   --  Character'Pos(Character'Last).\n+\n+   function Is_String    (Item : Wide_String)    return Boolean\n+   with\n+     Post => Is_String'Result =\n+       (for all I in Item'Range => Is_Character (Item (I)));\n+   --  Returns True if Is_Character(Item(I)) is True for each I in Item'Range.\n \n    ------------------------------------------------------\n    -- Conversions between Wide_Character and Character --\n@@ -121,17 +382,49 @@ package Ada.Characters.Handling is\n \n    function To_Character\n      (Item       : Wide_Character;\n-      Substitute : Character := ' ') return Character;\n+      Substitute : Character := ' ') return Character\n+   with\n+     Post => To_Character'Result =\n+       (if Is_Character (Item) then\n+          Character'Val (Wide_Character'Pos (Item))\n+        else\n+          Substitute);\n+   --  Returns the Character corresponding to Item if Is_Character(Item), and\n+   --  returns the Substitute Character otherwise.\n \n    function To_String\n      (Item       : Wide_String;\n-      Substitute : Character := ' ') return String;\n+      Substitute : Character := ' ') return String\n+   with\n+     Post => To_String'Result'First = 1\n+       and then To_String'Result'Length = Item'Length\n+       and then\n+         (for all J in To_String'Result'Range =>\n+            To_String'Result (J) =\n+              To_Character (Item (Item'First + (J - 1)), Substitute));\n+   --  Returns the String whose range is 1..Item'Length and each of whose\n+   --  elements is given by To_Character of the corresponding element in Item.\n \n    function To_Wide_Character\n-     (Item : Character) return Wide_Character;\n+     (Item : Character) return Wide_Character\n+   with\n+     Post => To_Wide_Character'Result =\n+       Wide_Character'Val (Character'Pos (Item));\n+   --  Returns the Wide_Character X such that Character'Pos(Item) =\n+   --  Wide_Character'Pos (X).\n \n    function To_Wide_String\n-     (Item : String) return Wide_String;\n+     (Item : String) return Wide_String\n+   with\n+     Post => To_Wide_String'Result'First = 1\n+       and then To_Wide_String'Result'Length = Item'Length\n+       and then\n+         (for all J in To_Wide_String'Result'Range =>\n+            To_Wide_String'Result (J) =\n+              To_Wide_Character (Item (Item'First + (J - 1))));\n+   --  Returns the Wide_String whose range is 1..Item'Length and each of whose\n+   --  elements is given by To_Wide_Character of the corresponding element in\n+   --  Item.\n \n private\n    pragma Inline (Is_Alphanumeric);"}, {"sha": "ffc69a92136b05425f037fd9f1161949994b8ea0", "filename": "gcc/ada/libgnat/a-strmap.ads", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec8ccc712cc15124090dab1ae44dccee280ce4ad/gcc%2Fada%2Flibgnat%2Fa-strmap.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec8ccc712cc15124090dab1ae44dccee280ce4ad/gcc%2Fada%2Flibgnat%2Fa-strmap.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strmap.ads?ref=ec8ccc712cc15124090dab1ae44dccee280ce4ad", "patch": "@@ -35,9 +35,13 @@\n \n --  Preconditions in this unit are meant for analysis only, not for run-time\n --  checking, so that the expected exceptions are raised. This is enforced by\n---  setting the corresponding assertion policy to Ignore.\n+--  setting the corresponding assertion policy to Ignore. Postconditions and\n+--  ghost code should not be executed at runtime as well, in order not to slow\n+--  down the execution of these functions.\n \n-pragma Assertion_Policy (Pre => Ignore);\n+pragma Assertion_Policy (Pre   => Ignore,\n+                         Post  => Ignore,\n+                         Ghost => Ignore);\n \n with Ada.Characters.Latin_1;\n \n@@ -210,9 +214,24 @@ package Ada.Strings.Maps is\n    pragma Preelaborable_Initialization (Character_Mapping);\n    --  Representation for a character to character mapping:\n \n+   type SPARK_Proof_Character_Mapping_Model is\n+     array (Character) of Character\n+   with Ghost;\n+   --  Publicly visible model of a Character_Mapping\n+\n+   function SPARK_Proof_Model\n+     (Map : Character_Mapping)\n+      return SPARK_Proof_Character_Mapping_Model\n+   with Ghost;\n+   --  Creation of a publicly visible model of a Character_Mapping\n+\n    function Value\n      (Map     : Character_Mapping;\n-      Element : Character) return Character;\n+      Element : Character) return Character\n+   with\n+     Post => Value'Result = SPARK_Proof_Model (Map) (Element);\n+   --  The function Value returns the Character value to which Element maps\n+   --  with respect to the mapping represented by Map.\n \n    Identity : constant Character_Mapping;\n \n@@ -285,6 +304,12 @@ private\n \n    type Character_Mapping is array (Character) of Character;\n \n+   function SPARK_Proof_Model\n+     (Map : Character_Mapping)\n+      return SPARK_Proof_Character_Mapping_Model\n+   is\n+     (SPARK_Proof_Character_Mapping_Model (Map));\n+\n    package L renames Ada.Characters.Latin_1;\n \n    Identity : constant Character_Mapping :="}]}