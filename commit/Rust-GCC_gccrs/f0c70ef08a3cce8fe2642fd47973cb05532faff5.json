{"sha": "f0c70ef08a3cce8fe2642fd47973cb05532faff5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBjNzBlZjA4YTNjY2U4ZmUyNjQyZmQ0Nzk3M2NiMDU1MzJmYWZmNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-19T04:47:57Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-09-19T04:47:57Z"}, "message": "(initializer_constant_valid_p): Warn about address arithmetic destined for a type that's too narrow.\n\n(initializer_constant_valid_p): Warn about address\narithmetic destined for a type that's too narrow.\nNew argument ENDTYPE.\n\nFrom-SVN: r2159", "tree": {"sha": "2f0b17282b52d90f3bdf0302534570e5fa5f4d71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f0b17282b52d90f3bdf0302534570e5fa5f4d71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0c70ef08a3cce8fe2642fd47973cb05532faff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0c70ef08a3cce8fe2642fd47973cb05532faff5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0c70ef08a3cce8fe2642fd47973cb05532faff5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0c70ef08a3cce8fe2642fd47973cb05532faff5/comments", "author": null, "committer": null, "parents": [{"sha": "ad38743d79042c5c7a40350f44327ad5d054a532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad38743d79042c5c7a40350f44327ad5d054a532", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad38743d79042c5c7a40350f44327ad5d054a532"}], "stats": {"total": 55, "additions": 36, "deletions": 19}, "files": [{"sha": "c9215c8c3f8981ac9888e42ee6407f05044783db", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0c70ef08a3cce8fe2642fd47973cb05532faff5/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0c70ef08a3cce8fe2642fd47973cb05532faff5/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=f0c70ef08a3cce8fe2642fd47973cb05532faff5", "patch": "@@ -4125,8 +4125,9 @@ warn_for_assignment (msg, opname, function, argnum)\n    arithmetic-combinations of integers.  */\n \n static tree\n-initializer_constant_valid_p (value)\n+initializer_constant_valid_p (value, endtype)\n      tree value;\n+     tree endtype;\n {\n   switch (TREE_CODE (value))\n     {\n@@ -4142,29 +4143,30 @@ initializer_constant_valid_p (value)\n       return TREE_OPERAND (value, 0);\n \n     case NON_LVALUE_EXPR:\n-      return initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+      return initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n \n     case CONVERT_EXPR:\n     case NOP_EXPR:\n       /* Allow conversions between pointer types.  */\n       if (TREE_CODE (TREE_TYPE (value)) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n       /* Allow conversions between real types.  */\n       if (TREE_CODE (TREE_TYPE (value)) == REAL_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == REAL_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n       /* Allow length-preserving conversions between integer types.  */\n       if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE\n \t  && tree_int_cst_equal (TYPE_SIZE (TREE_TYPE (value)),\n \t\t\t\t TYPE_SIZE (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0), endtype);\n       /* Allow conversions between integer types only if explicit value.  */\n       if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == INTEGER_TYPE)\n \t{\n-\t  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+\t  tree inner = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t     endtype);\n \t  if (inner == null_pointer_node)\n \t    return null_pointer_node;\n \t  return 0;\n@@ -4174,16 +4176,23 @@ initializer_constant_valid_p (value)\n \t  && TREE_CODE (TREE_TYPE (TREE_OPERAND (value, 0))) == POINTER_TYPE\n \t  && tree_int_cst_equal (TYPE_SIZE (TREE_TYPE (value)),\n \t\t\t\t TYPE_SIZE (TREE_TYPE (TREE_OPERAND (value, 0)))))\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n       /* Allow conversions to union types if the value inside is okay.  */\n       if (TREE_CODE (TREE_TYPE (value)) == UNION_TYPE)\n-\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0));\n+\treturn initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t     endtype);\n       return 0;\n \n     case PLUS_EXPR:\n+      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n+\t  && TYPE_PRECISION (TREE_TYPE (value)) < POINTER_SIZE)\n+\treturn 0;\n       {\n-\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0));\n-\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1));\n+\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t    endtype);\n+\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n+\t\t\t\t\t\t    endtype);\n \t/* If either term is absolute, use the other terms relocation.  */\n \tif (valid0 == null_pointer_node)\n \t  return valid1;\n@@ -4193,9 +4202,14 @@ initializer_constant_valid_p (value)\n       }\n \n     case MINUS_EXPR:\n+      if (TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n+\t  && TYPE_PRECISION (TREE_TYPE (value)) < POINTER_SIZE)\n+\treturn 0;\n       {\n-\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0));\n-\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1));\n+\ttree valid0 = initializer_constant_valid_p (TREE_OPERAND (value, 0),\n+\t\t\t\t\t\t    endtype);\n+\ttree valid1 = initializer_constant_valid_p (TREE_OPERAND (value, 1),\n+\t\t\t\t\t\t    endtype);\n \t/* Win if second argument is absolute.  */\n \tif (valid1 == null_pointer_node)\n \t  return valid0;\n@@ -4247,7 +4261,7 @@ store_init_value (decl, init)\n       value = error_mark_node;\n     }\n   else if (TREE_STATIC (decl)\n-\t   && initializer_constant_valid_p (value) == 0)\n+\t   && initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)\n     {\n       error (\"initializer for static variable uses complicated arithmetic\");\n       value = error_mark_node;\n@@ -4637,7 +4651,8 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t\t      \" for `%s'\", ofwhat);\n \t  inside_init = error_mark_node;\n \t}\n-      else if (require_constant && initializer_constant_valid_p (inside_init) == 0)\n+      else if (require_constant\n+\t       && initializer_constant_valid_p (inside_init, TREE_TYPE (inside_init)) == 0)\n \t{\n \t  error_init (\"initializer element%s is not computable at load time\",\n \t\t      \" for `%s'\", ofwhat);\n@@ -4668,7 +4683,8 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t\t      \" for `%s'\", ofwhat);\n \t  element = error_mark_node;\n \t}\n-      else if (require_constant && initializer_constant_valid_p (element) == 0)\n+      else if (require_constant\n+\t       && initializer_constant_valid_p (element, TREE_TYPE (element)) == 0)\n \t{\n \t  error_init (\"initializer element%s is not computable at load time\",\n \t\t      \" for `%s'\", ofwhat);\n@@ -4772,7 +4788,8 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t\t      \" for `%s'\", ofwhat);\n \t  inside_init = error_mark_node;\n \t}\n-      else if (require_constant && initializer_constant_valid_p (inside_init) == 0)\n+      else if (require_constant\n+\t       && initializer_constant_valid_p (inside_init, TREE_TYPE (inside_init)) == 0)\n \t{\n \t  error_init (\"initializer element%s is not computable at load time\",\n \t\t      \" for `%s'\", ofwhat);\n@@ -5045,7 +5062,7 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t    erroneous = 1;\n \t  else if (!TREE_CONSTANT (next1))\n \t    allconstant = 0;\n-\t  else if (initializer_constant_valid_p (next1) == 0)\n+\t  else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n \t    allsimple = 0;\n \n \t  /* Now store NEXT1 in the list, I elements from the *end*.\n@@ -5146,7 +5163,7 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \t    erroneous = 1;\n \t  else if (!TREE_CONSTANT (next1))\n \t    allconstant = 0;\n-\t  else if (initializer_constant_valid_p (next1) == 0)\n+\t  else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n \t    allsimple = 0;\n \n \t  /* Now store NEXT1 in the list, I elements from the *end*.\n@@ -5234,7 +5251,7 @@ process_init_constructor (type, init, elts, constant_value, constant_element,\n \terroneous = 1;\n       else if (!TREE_CONSTANT (next1))\n \tallconstant = 0;\n-      else if (initializer_constant_valid_p (next1) == 0)\n+      else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n \tallsimple = 0;\n       members = tree_cons (field, next1, members);\n     }"}]}