{"sha": "c8a9218a5bab48fffe1f5fa02244954d55f8945c", "node_id": "C_kwDOANBUbNoAKGM4YTkyMThhNWJhYjQ4ZmZmZTFmNWZhMDIyNDQ5NTRkNTVmODk0NWM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-07-07T09:34:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-07T09:34:02Z"}, "message": "Merge #1355\n\n1355: Ambiguous generic arg r=CohenArthur a=CohenArthur\n\nNeeds #1354. Only review the last commit :)\r\n\r\nast: Rename ConstGenericArg -> GenericArg\r\n\r\nThis makes the class clearer and exposes the fact that it may contain a\r\ntype OR a const value clearer.\r\n\r\nBecause we now run in ambiguous cases later in the compiler pipeline,\r\nthis commit also adds horrible hacks to simply ignore ambiguous generic\r\narguments and treat them as type arguments.\r\n\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "46593ffd2c9b242b801f7cf021a4b9d380baf55a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46593ffd2c9b242b801f7cf021a4b9d380baf55a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c8a9218a5bab48fffe1f5fa02244954d55f8945c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixqiKCRBK7hj4Ov3rIwAAU6AIAJCdXKSgsUC/VE7Bmpc7FIQt\n85m5pF08LuPWzeYhnDMSS1dC9AdJhxIHnPBRp6R2gCzeZOn3OoVFcAu6YGC6FBAL\nYbhII/n2rP5w8Kxy3/7KSRrKLsiqUbXht6/MNclUCGG7H6WUdJ/fnR/lxP9NVvxm\nfwVHkGxeCc/wsDLrzcfzqGRdV119t+x+IbDijBB4VMaXpG+ARy9xBsRAendfA/I9\nAQl9TpIt5qx1GXgkVRTFw/bN4AxZOAIscbZqCw5UtC3RytwEo8905bHtqmC706lR\nVOpSipBswr2poOrK8ltnoEP5k2FsUV57nazE1ZPEpsUkRomTM/s/vE7JywlwMj8=\n=cOvr\n-----END PGP SIGNATURE-----\n", "payload": "tree 46593ffd2c9b242b801f7cf021a4b9d380baf55a\nparent ad0e01dfbba94c0a10019db7c11b13fa0758c1fb\nparent 1f32e5b4558126d872f455c65a94d9640a93c285\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1657186442 +0000\ncommitter GitHub <noreply@github.com> 1657186442 +0000\n\nMerge #1355\n\n1355: Ambiguous generic arg r=CohenArthur a=CohenArthur\n\nNeeds #1354. Only review the last commit :)\r\n\r\nast: Rename ConstGenericArg -> GenericArg\r\n\r\nThis makes the class clearer and exposes the fact that it may contain a\r\ntype OR a const value clearer.\r\n\r\nBecause we now run in ambiguous cases later in the compiler pipeline,\r\nthis commit also adds horrible hacks to simply ignore ambiguous generic\r\narguments and treat them as type arguments.\r\n\r\n\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a9218a5bab48fffe1f5fa02244954d55f8945c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8a9218a5bab48fffe1f5fa02244954d55f8945c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8a9218a5bab48fffe1f5fa02244954d55f8945c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad0e01dfbba94c0a10019db7c11b13fa0758c1fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad0e01dfbba94c0a10019db7c11b13fa0758c1fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad0e01dfbba94c0a10019db7c11b13fa0758c1fb"}, {"sha": "1f32e5b4558126d872f455c65a94d9640a93c285", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f32e5b4558126d872f455c65a94d9640a93c285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f32e5b4558126d872f455c65a94d9640a93c285"}], "stats": {"total": 416, "additions": 253, "deletions": 163}, "files": [{"sha": "6c41d138bb835243bed0915dfb09c3995737efef", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=c8a9218a5bab48fffe1f5fa02244954d55f8945c", "patch": "@@ -2598,28 +2598,14 @@ GenericArgs::as_string () const\n     }\n \n   // type args\n-  if (!type_args.empty ())\n+  if (!generic_args.empty ())\n     {\n-      auto i = type_args.begin ();\n-      auto e = type_args.end ();\n+      auto i = generic_args.begin ();\n+      auto e = generic_args.end ();\n \n       for (; i != e; i++)\n \t{\n-\t  args += (*i)->as_string ();\n-\t  if (e != i + 1)\n-\t    args += \", \";\n-\t}\n-    }\n-\n-  // const args\n-  if (!const_args.empty ())\n-    {\n-      auto i = const_args.begin ();\n-      auto e = const_args.end ();\n-\n-      for (; i != e; i++)\n-\t{\n-\t  args += i->as_string ();\n+\t  args += (*i).as_string ();\n \t  if (e != i + 1)\n \t    args += \", \";\n \t}\n@@ -5800,15 +5786,28 @@ MetaWord::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-ConstGenericArg\n-ConstGenericArg::disambiguate_to_const () const\n+GenericArg\n+GenericArg::disambiguate_to_const () const\n {\n-  rust_assert (get_kind () == Kind::Ambiguous);\n+  rust_assert (get_kind () == Kind::Either);\n \n   // FIXME: is it fine to have no outer attributes?\n-  return ConstGenericArg (std::unique_ptr<Expr> (\n-\t\t\t    new IdentifierExpr (path, {}, locus)),\n-\t\t\t  locus);\n+  return GenericArg::create_const (\n+    std::unique_ptr<Expr> (new IdentifierExpr (path, {}, locus)));\n+}\n+\n+GenericArg\n+GenericArg::disambiguate_to_type () const\n+{\n+  rust_assert (get_kind () == Kind::Either);\n+\n+  auto segment = std::unique_ptr<TypePathSegment> (\n+    new TypePathSegment (path, false, locus));\n+  auto segments = std::vector<std::unique_ptr<TypePathSegment>> ();\n+  segments.emplace_back (std::move (segment));\n+\n+  return GenericArg::create_type (\n+    std::unique_ptr<Type> (new TypePath (std::move (segments), locus)));\n }\n \n } // namespace AST"}, {"sha": "722ed93ec57cec99630d35bfaf1d9a26a96b9e65", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 100, "deletions": 72, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=c8a9218a5bab48fffe1f5fa02244954d55f8945c", "patch": "@@ -132,7 +132,7 @@ struct GenericArgsBinding\n };\n \n /* Class representing a const generic application */\n-class ConstGenericArg\n+class GenericArg\n {\n public:\n   /**\n@@ -152,80 +152,116 @@ class ConstGenericArg\n   enum class Kind\n   {\n     Error,\n-    Clear,\n-    Ambiguous,\n+    Const,  // A const value\n+    Type,   // A type argument (not discernable during parsing)\n+    Either, // Either a type or a const value, cleared up during resolving\n   };\n \n-  static ConstGenericArg create_error ()\n+  static GenericArg create_error ()\n   {\n-    return ConstGenericArg (nullptr, \"\", Kind::Error, Location ());\n+    return GenericArg (nullptr, nullptr, \"\", Kind::Error, Location ());\n   }\n \n-  ConstGenericArg (std::unique_ptr<Expr> expression, Location locus)\n-    : expression (std::move (expression)), path (\"\"), kind (Kind::Clear),\n-      locus (locus)\n-  {}\n+  static GenericArg create_const (std::unique_ptr<Expr> expression)\n+  {\n+    return GenericArg (std::move (expression), nullptr, \"\", Kind::Const,\n+\t\t       expression->get_locus ());\n+  }\n \n-  ConstGenericArg (Identifier path, Location locus)\n-    : expression (nullptr), path (path), kind (Kind::Ambiguous), locus (locus)\n-  {}\n+  static GenericArg create_type (std::unique_ptr<Type> type)\n+  {\n+    return GenericArg (nullptr, std::move (type), \"\", Kind::Type,\n+\t\t       type->get_locus ());\n+  }\n \n-  ConstGenericArg (const ConstGenericArg &other)\n+  static GenericArg create_ambiguous (Identifier path, Location locus)\n+  {\n+    return GenericArg (nullptr, nullptr, std::move (path), Kind::Either, locus);\n+  }\n+\n+  GenericArg (const GenericArg &other)\n     : path (other.path), kind (other.kind), locus (other.locus)\n   {\n     if (other.expression)\n       expression = other.expression->clone_expr ();\n+    if (other.type)\n+      type = other.type->clone_type ();\n   }\n \n-  ConstGenericArg operator= (const ConstGenericArg &other)\n+  GenericArg operator= (const GenericArg &other)\n   {\n     kind = other.kind;\n     path = other.path;\n     locus = other.locus;\n \n     if (other.expression)\n       expression = other.expression->clone_expr ();\n+    if (other.type)\n+      type = other.type->clone_type ();\n \n     return *this;\n   }\n \n   bool is_error () const { return kind == Kind::Error; }\n \n   Kind get_kind () const { return kind; }\n+  const Location &get_locus () const { return locus; }\n \n-  const std::unique_ptr<AST::Expr> &get_expression () const\n+  std::unique_ptr<Expr> &get_expression ()\n   {\n-    rust_assert (kind == Kind::Clear);\n+    rust_assert (kind == Kind::Const);\n \n     return expression;\n   }\n \n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (kind == Kind::Type);\n+\n+    return type;\n+  }\n+\n+  const std::string &get_path () const\n+  {\n+    rust_assert (kind == Kind::Either);\n+\n+    return path;\n+  }\n+\n   std::string as_string () const\n   {\n     switch (get_kind ())\n       {\n       case Kind::Error:\n \tgcc_unreachable ();\n-      case Kind::Ambiguous:\n+      case Kind::Either:\n \treturn \"Ambiguous: \" + path;\n-      case Kind::Clear:\n-\treturn \"Clear: { \" + expression->as_string () + \" }\";\n+      case Kind::Const:\n+\treturn \"Const: { \" + expression->as_string () + \" }\";\n+      case Kind::Type:\n+\treturn \"Type: \" + type->as_string ();\n       }\n \n     return \"\";\n   }\n \n   /**\n-   * Disambiguate an amibguous const generic argument or generic type argument\n-   * to a const generic argument, unequivocally\n+   * Disambiguate an ambiguous generic argument to a const generic argument,\n+   * unequivocally\n    */\n-  ConstGenericArg disambiguate_to_const () const;\n+  GenericArg disambiguate_to_const () const;\n+\n+  /**\n+   * Disambiguate an ambiguous generic argument to a type argument,\n+   * unequivocally\n+   */\n+  GenericArg disambiguate_to_type () const;\n \n private:\n-  ConstGenericArg (std::unique_ptr<AST::Expr> expression, Identifier path,\n-\t\t   Kind kind, Location locus)\n-    : expression (std::move (expression)), path (std::move (path)), kind (kind),\n-      locus (locus)\n+  GenericArg (std::unique_ptr<Expr> expression, std::unique_ptr<Type> type,\n+\t      Identifier path, Kind kind, Location locus)\n+    : expression (std::move (expression)), type (std::move (type)),\n+      path (std::move (path)), kind (kind), locus (locus)\n   {}\n \n   /**\n@@ -235,9 +271,15 @@ class ConstGenericArg\n    */\n   std::unique_ptr<Expr> expression;\n \n+  /**\n+   * If the argument ends up being a type argument instead. A null pointer will\n+   * be present here until the resolving phase.\n+   */\n+  std::unique_ptr<Type> type;\n+\n   /**\n    * Optional path which cannot be differentiated between a constant item and\n-   * a type. Only used for `Ambiguous` const generic arguments, otherwise\n+   * a type. Only used for ambiguous const generic arguments, otherwise\n    * empty.\n    */\n   Identifier path;\n@@ -262,14 +304,14 @@ class ConstGenericParam : public GenericParam\n   /**\n    * Default value for the const generic parameter\n    */\n-  ConstGenericArg default_value;\n+  GenericArg default_value;\n \n   Attribute outer_attr;\n   Location locus;\n \n public:\n   ConstGenericParam (Identifier name, std::unique_ptr<AST::Type> type,\n-\t\t     ConstGenericArg default_value, Attribute outer_attr,\n+\t\t     GenericArg default_value, Attribute outer_attr,\n \t\t     Location locus)\n     : name (name), type (std::move (type)),\n       default_value (std::move (default_value)), outer_attr (outer_attr),\n@@ -294,7 +336,14 @@ class ConstGenericParam : public GenericParam\n     return type;\n   }\n \n-  const ConstGenericArg &get_default_value () const\n+  GenericArg &get_default_value ()\n+  {\n+    rust_assert (has_default_value ());\n+\n+    return default_value;\n+  }\n+\n+  const GenericArg &get_default_value () const\n   {\n     rust_assert (has_default_value ());\n \n@@ -322,54 +371,43 @@ class ConstGenericParam : public GenericParam\n struct GenericArgs\n {\n   std::vector<Lifetime> lifetime_args;\n-  std::vector<std::unique_ptr<Type> > type_args;\n+  std::vector<GenericArg> generic_args;\n   std::vector<GenericArgsBinding> binding_args;\n-  std::vector<ConstGenericArg> const_args;\n   Location locus;\n \n public:\n   // Returns true if there are any generic arguments\n   bool has_generic_args () const\n   {\n-    return !(lifetime_args.empty () && type_args.empty ()\n-\t     && binding_args.empty () && const_args.empty ());\n+    return !(lifetime_args.empty () && generic_args.empty ()\n+\t     && binding_args.empty ());\n   }\n \n   GenericArgs (std::vector<Lifetime> lifetime_args,\n-\t       std::vector<std::unique_ptr<Type> > type_args,\n+\t       std::vector<GenericArg> generic_args,\n \t       std::vector<GenericArgsBinding> binding_args,\n-\t       std::vector<ConstGenericArg> const_args,\n \t       Location locus = Location ())\n     : lifetime_args (std::move (lifetime_args)),\n-      type_args (std::move (type_args)),\n-      binding_args (std::move (binding_args)),\n-      const_args (std::move (const_args)), locus (locus)\n+      generic_args (std::move (generic_args)),\n+      binding_args (std::move (binding_args)), locus (locus)\n   {}\n \n   // copy constructor with vector clone\n   GenericArgs (GenericArgs const &other)\n-    : lifetime_args (other.lifetime_args), binding_args (other.binding_args),\n-      const_args (other.const_args), locus (other.locus)\n-  {\n-    type_args.reserve (other.type_args.size ());\n-    for (const auto &e : other.type_args)\n-      type_args.push_back (e->clone_type ());\n-  }\n+    : lifetime_args (other.lifetime_args), generic_args (other.generic_args),\n+      binding_args (other.binding_args), locus (other.locus)\n+  {}\n \n   ~GenericArgs () = default;\n \n   // overloaded assignment operator to vector clone\n   GenericArgs &operator= (GenericArgs const &other)\n   {\n     lifetime_args = other.lifetime_args;\n+    generic_args = other.generic_args;\n     binding_args = other.binding_args;\n-    const_args = other.const_args;\n     locus = other.locus;\n \n-    type_args.reserve (other.type_args.size ());\n-    for (const auto &e : other.type_args)\n-      type_args.push_back (e->clone_type ());\n-\n     return *this;\n   }\n \n@@ -378,26 +416,18 @@ struct GenericArgs\n   GenericArgs &operator= (GenericArgs &&other) = default;\n \n   // Creates an empty GenericArgs (no arguments)\n-  static GenericArgs create_empty ()\n-  {\n-    return GenericArgs (std::vector<Lifetime> (),\n-\t\t\tstd::vector<std::unique_ptr<Type> > (),\n-\t\t\tstd::vector<GenericArgsBinding> (),\n-\t\t\tstd::vector<ConstGenericArg> ());\n-  }\n+  static GenericArgs create_empty () { return GenericArgs ({}, {}, {}); }\n \n   std::string as_string () const;\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n-  std::vector<std::unique_ptr<Type> > &get_type_args () { return type_args; }\n+  std::vector<GenericArg> &get_generic_args () { return generic_args; }\n \n   // TODO: is this better? Or is a \"vis_pattern\" better?\n   std::vector<GenericArgsBinding> &get_binding_args () { return binding_args; }\n \n   std::vector<Lifetime> &get_lifetime_args () { return lifetime_args; };\n \n-  std::vector<ConstGenericArg> &get_const_args () { return const_args; };\n-\n   Location get_locus () { return locus; }\n };\n \n@@ -427,13 +457,12 @@ class PathExprSegment\n    * args) */\n   PathExprSegment (std::string segment_name, Location locus,\n \t\t   std::vector<Lifetime> lifetime_args = {},\n-\t\t   std::vector<std::unique_ptr<Type> > type_args = {},\n-\t\t   std::vector<GenericArgsBinding> binding_args = {},\n-\t\t   std::vector<ConstGenericArg> const_args = {})\n+\t\t   std::vector<GenericArg> generic_args = {},\n+\t\t   std::vector<GenericArgsBinding> binding_args = {})\n     : segment_name (PathIdentSegment (std::move (segment_name), locus)),\n-      generic_args (\n-\tGenericArgs (std::move (lifetime_args), std::move (type_args),\n-\t\t     std::move (binding_args), std::move (const_args))),\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (generic_args),\n+\t\t\t\t std::move (binding_args))),\n       locus (locus), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n@@ -724,15 +753,14 @@ class TypePathSegmentGeneric : public TypePathSegment\n   TypePathSegmentGeneric (std::string segment_name,\n \t\t\t  bool has_separating_scope_resolution,\n \t\t\t  std::vector<Lifetime> lifetime_args,\n-\t\t\t  std::vector<std::unique_ptr<Type> > type_args,\n+\t\t\t  std::vector<GenericArg> generic_args,\n \t\t\t  std::vector<GenericArgsBinding> binding_args,\n-\t\t\t  std::vector<ConstGenericArg> const_args,\n \t\t\t  Location locus)\n     : TypePathSegment (std::move (segment_name),\n \t\t       has_separating_scope_resolution, locus),\n-      generic_args (\n-\tGenericArgs (std::move (lifetime_args), std::move (type_args),\n-\t\t     std::move (binding_args), std::move (const_args)))\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (generic_args),\n+\t\t\t\t std::move (binding_args)))\n   {}\n \n   std::string as_string () const override;"}, {"sha": "bec6a9d138bec0842111f8a3a308fbb7368aebcf", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=c8a9218a5bab48fffe1f5fa02244954d55f8945c", "patch": "@@ -130,14 +130,23 @@ AttrVisitor::expand_generic_args (AST::GenericArgs &args)\n   expander.push_context (MacroExpander::ContextType::TYPE);\n \n   // expand type args - strip sub-types only\n-  for (auto &type : args.get_type_args ())\n+  for (auto &arg : args.get_generic_args ())\n     {\n-      type->accept_vis (*this);\n-      maybe_expand_type (type);\n+      // FIXME: Arthur: Another ugly hack while waiting for disambiguation\n+      if (arg.get_kind () == AST::GenericArg::Kind::Either)\n+\targ = arg.disambiguate_to_type ();\n \n-      if (type->is_marked_for_strip ())\n-\trust_error_at (type->get_locus (),\n-\t\t       \"cannot strip type in this position\");\n+      if (arg.get_kind () == AST::GenericArg::Kind::Type)\n+\t{\n+\t  auto &type = arg.get_type ();\n+\n+\t  type->accept_vis (*this);\n+\t  maybe_expand_type (type);\n+\n+\t  if (type->is_marked_for_strip ())\n+\t    rust_error_at (type->get_locus (),\n+\t\t\t   \"cannot strip type in this position\");\n+\t}\n     }\n \n   expander.pop_context ();"}, {"sha": "6afbbe2b828a91b8c796847cc7c79562ca342af1", "filename": "gcc/rust/hir/rust-ast-lower-base.cc", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc?ref=c8a9218a5bab48fffe1f5fa02244954d55f8945c", "patch": "@@ -606,22 +606,37 @@ ASTLoweringBase::lower_generic_args (AST::GenericArgs &args)\n     }\n \n   std::vector<std::unique_ptr<HIR::Type>> type_args;\n-  for (auto &type : args.get_type_args ())\n+  std::vector<HIR::ConstGenericArg> const_args;\n+\n+  for (auto &arg : args.get_generic_args ())\n     {\n-      HIR::Type *t = ASTLoweringType::translate (type.get ());\n-      type_args.push_back (std::unique_ptr<HIR::Type> (t));\n+      switch (arg.get_kind ())\n+\t{\n+\t  case AST::GenericArg::Kind::Type: {\n+\t    auto type = ASTLoweringType::translate (arg.get_type ().get ());\n+\t    type_args.emplace_back (std::unique_ptr<HIR::Type> (type));\n+\t    break;\n+\t  }\n+\t  case AST::GenericArg::Kind::Const: {\n+\t    auto expr\n+\t      = ASTLoweringExpr::translate (arg.get_expression ().get ());\n+\t    const_args.emplace_back (\n+\t      HIR::ConstGenericArg (std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t    expr->get_locus ()));\n+\t    break;\n+\t  }\n+\t  // FIXME: Arthur: Other horrible hack waiting for disambiguation\n+\t  case AST::GenericArg::Kind::Either: {\n+\t    arg = arg.disambiguate_to_type ();\n+\t    auto type = ASTLoweringType::translate (arg.get_type ().get ());\n+\t    type_args.emplace_back (std::unique_ptr<HIR::Type> (type));\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n \n-  std::vector<HIR::ConstGenericArg> const_args;\n-  for (auto &const_arg : args.get_const_args ())\n-    const_args.emplace_back (HIR::ConstGenericArg (\n-      std::unique_ptr<HIR::Expr> (\n-\tASTLoweringExpr::translate (const_arg.get_expression ().get ())),\n-      Location ()));\n-\n-  // FIXME:\n-  // const_arg.get_locus ());\n-\n   return HIR::GenericArgs (std::move (lifetime_args), std::move (type_args),\n \t\t\t   std::move (binding_args), std::move (const_args),\n \t\t\t   args.get_locus ());"}, {"sha": "a897c031444455e553c5d8f95a7d60d47796d657", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=c8a9218a5bab48fffe1f5fa02244954d55f8945c", "patch": "@@ -381,7 +381,7 @@ class ASTLowerGenericParam : public ASTLoweringBase\n     HIR::Expr *default_expr = nullptr;\n     if (param.has_default_value ()\n \t&& param.get_default_value ().get_kind ()\n-\t     == AST::ConstGenericArg::Kind::Clear)\n+\t     == AST::GenericArg::Kind::Const)\n       default_expr = ASTLoweringExpr::translate (\n \tparam.get_default_value ().get_expression ().get ());\n "}, {"sha": "446df13ab9272dbeee263a06a4c70511db81465f", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=c8a9218a5bab48fffe1f5fa02244954d55f8945c", "patch": "@@ -2878,12 +2878,12 @@ Parser<ManagedTokenSource>::parse_generic_param (EndTokenPred is_end_token)\n \t  return nullptr;\n \n \t// optional default value\n-\tauto default_expr = AST::ConstGenericArg::create_error ();\n+\tauto default_expr = AST::GenericArg::create_error ();\n \tif (lexer.peek_token ()->get_id () == EQUAL)\n \t  {\n \t    lexer.skip_token ();\n \t    auto tok = lexer.peek_token ();\n-\t    default_expr = parse_const_generic_expression ();\n+\t    default_expr = parse_generic_arg ();\n \n \t    if (default_expr.is_error ())\n \t      rust_error_at (tok->get_locus (),\n@@ -2894,8 +2894,7 @@ Parser<ManagedTokenSource>::parse_generic_param (EndTokenPred is_end_token)\n \n \t    // At this point, we *know* that we are parsing a const\n \t    // expression\n-\t    if (default_expr.get_kind ()\n-\t\t== AST::ConstGenericArg::Kind::Ambiguous)\n+\t    if (default_expr.get_kind () == AST::GenericArg::Kind::Either)\n \t      default_expr = default_expr.disambiguate_to_const ();\n \t  }\n \n@@ -6167,23 +6166,31 @@ Parser<ManagedTokenSource>::parse_type_path ()\n }\n \n template <typename ManagedTokenSource>\n-AST::ConstGenericArg\n-Parser<ManagedTokenSource>::parse_const_generic_expression ()\n+AST::GenericArg\n+Parser<ManagedTokenSource>::parse_generic_arg ()\n {\n   auto tok = lexer.peek_token ();\n   std::unique_ptr<AST::Expr> expr = nullptr;\n \n   switch (tok->get_id ())\n     {\n-    case IDENTIFIER:\n-      lexer.skip_token ();\n-\n-      // TODO: This is ambiguous with regular generic types. We probably need\n-      // to differentiate later on during type checking, and thus keep a\n-      // special variant here\n-\n-      // FIXME: We need locus here as well\n-      return AST::ConstGenericArg (tok->get_str (), tok->get_locus ());\n+      case IDENTIFIER: {\n+\t// This is a bit of a weird situation: With an identifier token, we\n+\t// could either have a valid type or a macro (FIXME: anything else?). So\n+\t// we need one bit of lookahead to differentiate if this is really\n+\tauto next_tok = lexer.peek_token (1);\n+\tif (next_tok->get_id () == EXCLAM)\n+\t  {\n+\t    auto type = parse_type ();\n+\t    if (type)\n+\t      return AST::GenericArg::create_type (std::move (type));\n+\t    else\n+\t      return AST::GenericArg::create_error ();\n+\t  }\n+\tlexer.skip_token ();\n+\treturn AST::GenericArg::create_ambiguous (tok->get_str (),\n+\t\t\t\t\t\t  tok->get_locus ());\n+      }\n     case LEFT_CURLY:\n       expr = parse_block_expr ();\n       break;\n@@ -6196,14 +6203,22 @@ Parser<ManagedTokenSource>::parse_const_generic_expression ()\n     case FALSE_LITERAL:\n       expr = parse_literal_expr ();\n       break;\n-    default:\n-      expr = nullptr;\n+      // FIXME: Because of this, error reporting is garbage for const generic\n+      // parameter's default values\n+      default: {\n+\tauto type = parse_type ();\n+\t// FIXME: Find a better way to do this?\n+\tif (type)\n+\t  return AST::GenericArg::create_type (std::move (type));\n+\telse\n+\t  return AST::GenericArg::create_error ();\n+      }\n     }\n \n   if (!expr)\n-    return AST::ConstGenericArg::create_error ();\n+    return AST::GenericArg::create_error ();\n \n-  return AST::ConstGenericArg (std::move (expr), tok->get_locus ());\n+  return AST::GenericArg::create_const (std::move (expr));\n }\n \n // Parses the generic arguments in each path segment.\n@@ -6247,11 +6262,8 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n       t = lexer.peek_token ();\n     }\n \n-  // try to parse types second\n-  std::vector<std::unique_ptr<AST::Type>> type_args;\n-  std::vector<AST::ConstGenericArg> const_args;\n-\n-  // TODO: Keep list of const expressions as well\n+  // try to parse types and const generics second\n+  std::vector<AST::GenericArg> generic_args;\n \n   // TODO: think of better control structure\n   t = lexer.peek_token ();\n@@ -6265,20 +6277,14 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n \t  && lexer.peek_token (1)->get_id () == EQUAL)\n \tbreak;\n \n-      auto type = parse_type (false);\n-      if (type)\n+      auto arg = parse_generic_arg ();\n+      if (!arg.is_error ())\n \t{\n-\t  type_args.emplace_back (std::move (type));\n-\t}\n-      else\n-\t{\n-\t  auto const_generic_expr = parse_const_generic_expression ();\n-\t  if (const_generic_expr.is_error ())\n-\t    break;\n-\t  else\n-\t    const_args.emplace_back (std::move (const_generic_expr));\n+\t  generic_args.emplace_back (std::move (arg));\n \t}\n \n+      // FIXME: Do we need to break if we encounter an error?\n+\n       // if next token isn't comma, then it must be end of list\n       if (lexer.peek_token ()->get_id () != COMMA)\n \tbreak;\n@@ -6323,12 +6329,11 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n     return AST::GenericArgs::create_empty ();\n \n   lifetime_args.shrink_to_fit ();\n-  type_args.shrink_to_fit ();\n+  generic_args.shrink_to_fit ();\n   binding_args.shrink_to_fit ();\n \n-  return AST::GenericArgs (std::move (lifetime_args), std::move (type_args),\n-\t\t\t   std::move (binding_args), std::move (const_args),\n-\t\t\t   locus);\n+  return AST::GenericArgs (std::move (lifetime_args), std::move (generic_args),\n+\t\t\t   std::move (binding_args), locus);\n }\n \n // Parses a binding in a generic args path segment."}, {"sha": "23a1e7c6e939f026938a85ec83fdcfbfdde2e43c", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=c8a9218a5bab48fffe1f5fa02244954d55f8945c", "patch": "@@ -177,7 +177,7 @@ template <typename ManagedTokenSource> class Parser\n   AST::TypePath parse_type_path ();\n   std::unique_ptr<AST::TypePathSegment> parse_type_path_segment ();\n   AST::PathIdentSegment parse_path_ident_segment ();\n-  AST::ConstGenericArg parse_const_generic_expression ();\n+  AST::GenericArg parse_generic_arg ();\n   AST::GenericArgs parse_path_generic_args ();\n   AST::GenericArgsBinding parse_generic_args_binding ();\n   AST::TypePathFunction parse_type_path_function (Location locus);"}, {"sha": "e875688dc28f9c53f1764fd23733e22c1dcb6818", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=c8a9218a5bab48fffe1f5fa02244954d55f8945c", "patch": "@@ -384,12 +384,35 @@ ResolveTypeToCanonicalPath::visit (AST::TypePath &path)\n \t    std::vector<CanonicalPath> args;\n \t    if (s->has_generic_args ())\n \t      {\n-\t\tfor (auto &gt : s->get_generic_args ().get_type_args ())\n+\t\tfor (auto &generic : s->get_generic_args ().get_generic_args ())\n \t\t  {\n-\t\t    CanonicalPath arg = CanonicalPath::create_empty ();\n-\t\t    bool ok = ResolveTypeToCanonicalPath::go (gt.get (), arg);\n-\t\t    if (ok)\n-\t\t      args.push_back (std::move (arg));\n+\t\t    // FIXME: What do we want to do here in case there is a\n+\t\t    // constant or an ambiguous const generic?\n+\t\t    // TODO: At that point, will all generics have been\n+\t\t    // disambiguated? Can we thus canonical resolve types and\n+\t\t    // const and `gcc_unreachable` on ambiguous types?\n+\t\t    //\n+\t\t    // FIXME: Arthur: This is an ugly hack to resolve just as\n+\t\t    // much as before despite not handling ambiguity yet. The\n+\t\t    // calls to `clone_type` will be removed.\n+\t\t    std::unique_ptr<AST::Type> gt = nullptr;\n+\n+\t\t    if (generic.get_kind () == AST::GenericArg::Kind::Type)\n+\t\t      gt = generic.get_type ()->clone_type ();\n+\t\t    else if (generic.get_kind ()\n+\t\t\t     == AST::GenericArg::Kind::Either)\n+\t\t      gt = generic.disambiguate_to_type ()\n+\t\t\t     .get_type ()\n+\t\t\t     ->clone_type ();\n+\n+\t\t    if (gt)\n+\t\t      {\n+\t\t\tCanonicalPath arg = CanonicalPath::create_empty ();\n+\t\t\tbool ok\n+\t\t\t  = ResolveTypeToCanonicalPath::go (gt.get (), arg);\n+\t\t\tif (ok)\n+\t\t\t  args.push_back (std::move (arg));\n+\t\t      }\n \t\t  }\n \t      }\n \n@@ -472,8 +495,18 @@ ResolveTypeToCanonicalPath::ResolveTypeToCanonicalPath ()\n void\n ResolveGenericArgs::go (AST::GenericArgs &args)\n {\n-  for (auto &gt : args.get_type_args ())\n-    ResolveType::go (gt.get ());\n+  for (auto &arg : args.get_generic_args ())\n+    {\n+      // FIXME: Arthur: Ugly hack while waiting for disambiguation\n+      if (arg.get_kind () == AST::GenericArg::Kind::Either)\n+\targ = arg.disambiguate_to_type ();\n+\n+      if (arg.get_kind () == AST::GenericArg::Kind::Type)\n+\tResolveType::go (arg.get_type ().get ());\n+\n+      // else...\n+      // We need to use a switch instead\n+    }\n }\n \n } // namespace Resolver"}, {"sha": "98495cf404d4e118d5c71b7d357ceb297da1c220", "filename": "gcc/testsuite/rust/compile/const_generics_2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c8a9218a5bab48fffe1f5fa02244954d55f8945c/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fconst_generics_2.rs?ref=c8a9218a5bab48fffe1f5fa02244954d55f8945c", "patch": "@@ -1,3 +1,4 @@\n struct Foo<const N>; // { dg-error \"expecting .:. but .>. found\" }\n struct Bar<const N: >; // { dg-error \"unrecognised token .>. in type\" }\n struct Baz<const N: usize = >; // { dg-error \"invalid token for start of default value for const generic parameter\" }\n+// { dg-error \"unrecognised token .>. in type\" \"\" { target *-*-* } .-1 }"}]}