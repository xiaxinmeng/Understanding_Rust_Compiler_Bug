{"sha": "38ad6f8a440f7594b9cea5fb999078035ee36a57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhhZDZmOGE0NDBmNzU5NGI5Y2VhNWZiOTk5MDc4MDM1ZWUzNmE1Nw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-23T04:44:12Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-23T04:44:12Z"}, "message": "cmd/go: buildid support for AIX archives.\n\n    \n    Reviewed-on: https://go-review.googlesource.com/88935\n\nFrom-SVN: r256971", "tree": {"sha": "2499e11d4df673826314f3f14158f8467d4a42db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2499e11d4df673826314f3f14158f8467d4a42db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38ad6f8a440f7594b9cea5fb999078035ee36a57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38ad6f8a440f7594b9cea5fb999078035ee36a57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38ad6f8a440f7594b9cea5fb999078035ee36a57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38ad6f8a440f7594b9cea5fb999078035ee36a57/comments", "author": null, "committer": null, "parents": [{"sha": "f991f1022c6254678cc61304ecd1e0fba0ac79db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f991f1022c6254678cc61304ecd1e0fba0ac79db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f991f1022c6254678cc61304ecd1e0fba0ac79db"}], "stats": {"total": 132, "additions": 131, "deletions": 1}, "files": [{"sha": "a100cab84fe5e3f8d4029a2e235a1cbf5e5e3f3c", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ad6f8a440f7594b9cea5fb999078035ee36a57/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ad6f8a440f7594b9cea5fb999078035ee36a57/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=38ad6f8a440f7594b9cea5fb999078035ee36a57", "patch": "@@ -1,4 +1,4 @@\n-87525458bcd5ab4beb5b95e7d58e3dfdbc1bd478\n+3488a401e50835de5de5c4f153772ac2798d0e71\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e2ae85083d8bc628e1ae64b3a03e72517cba9674", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ad6f8a440f7594b9cea5fb999078035ee36a57/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ad6f8a440f7594b9cea5fb999078035ee36a57/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=38ad6f8a440f7594b9cea5fb999078035ee36a57", "patch": "@@ -330,6 +330,43 @@ func (b *Builder) gccgoBuildIDELFFile(a *Action) (string, error) {\n \treturn sfile, nil\n }\n \n+// gccgoBuildIDXCOFFFile creates an assembler file that records the\n+// action's build ID in a CSECT (AIX linker deletes CSECTs that are\n+// not referenced in the output file).\n+func (b *Builder) gccgoBuildIDXCOFFFile(a *Action) (string, error) {\n+\tsfile := a.Objdir + \"_buildid.s\"\n+\n+\tvar buf bytes.Buffer\n+\tfmt.Fprintf(&buf, \"\\t.csect .go.buildid[XO]\\n\")\n+\tfmt.Fprintf(&buf, \"\\t.byte \")\n+\tfor i := 0; i < len(a.buildID); i++ {\n+\t\tif i > 0 {\n+\t\t\tif i%8 == 0 {\n+\t\t\t\tfmt.Fprintf(&buf, \"\\n\\t.byte \")\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(&buf, \",\")\n+\t\t\t}\n+\t\t}\n+\t\tfmt.Fprintf(&buf, \"%#02x\", a.buildID[i])\n+\t}\n+\tfmt.Fprintf(&buf, \"\\n\")\n+\n+\tif cfg.BuildN || cfg.BuildX {\n+\t\tfor _, line := range bytes.Split(buf.Bytes(), []byte(\"\\n\")) {\n+\t\t\tb.Showcmd(\"\", \"echo '%s' >> %s\", line, sfile)\n+\t\t}\n+\t\tif cfg.BuildN {\n+\t\t\treturn sfile, nil\n+\t\t}\n+\t}\n+\n+\tif err := ioutil.WriteFile(sfile, buf.Bytes(), 0666); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\treturn sfile, nil\n+}\n+\n // buildID returns the build ID found in the given file.\n // If no build ID is found, buildID returns the content hash of the file.\n func (b *Builder) buildID(file string) string {"}, {"sha": "edd2694b086dfc6914a737900450e4d702a42115", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ad6f8a440f7594b9cea5fb999078035ee36a57/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ad6f8a440f7594b9cea5fb999078035ee36a57/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=38ad6f8a440f7594b9cea5fb999078035ee36a57", "patch": "@@ -637,6 +637,16 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t\t\treturn err\n \t\t\t}\n \t\t\tobjects = append(objects, ofiles...)\n+\t\tcase \"aix\":\n+\t\t\tasmfile, err := b.gccgoBuildIDXCOFFFile(a)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tofiles, err := BuildToolchain.asm(b, a, []string{asmfile})\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tobjects = append(objects, ofiles...)\n \t\t}\n \t}\n "}, {"sha": "41e6c773e1b6eec049d9b12270dd68d94ab39a9f", "filename": "libgo/go/cmd/internal/buildid/buildid.go", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38ad6f8a440f7594b9cea5fb999078035ee36a57/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38ad6f8a440f7594b9cea5fb999078035ee36a57/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid.go?ref=38ad6f8a440f7594b9cea5fb999078035ee36a57", "patch": "@@ -7,6 +7,7 @@ package buildid\n import (\n \t\"bytes\"\n \t\"debug/elf\"\n+\t\"debug/xcoff\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n@@ -40,6 +41,9 @@ func ReadFile(name string) (id string, err error) {\n \t\treturn \"\", err\n \t}\n \tif string(buf) != \"!<arch>\\n\" {\n+\t\tif string(buf) == \"<bigaf>\\n\" {\n+\t\t\treturn readGccgoBigArchive(name, f)\n+\t\t}\n \t\treturn readBinary(name, f)\n \t}\n \n@@ -157,6 +161,85 @@ func readGccgoArchive(name string, f *os.File) (string, error) {\n \t}\n }\n \n+// readGccgoBigArchive tries to parse the archive as an AIX big\n+// archive file, and fetch the build ID from the _buildid.o entry.\n+// The _buildid.o entry is written by (*Builder).gccgoBuildIDXCOFFFile\n+// in cmd/go/internal/work/exec.go.\n+func readGccgoBigArchive(name string, f *os.File) (string, error) {\n+\tbad := func() (string, error) {\n+\t\treturn \"\", &os.PathError{Op: \"parse\", Path: name, Err: errBuildIDMalformed}\n+\t}\n+\n+\t// Read fixed-length header.\n+\tif _, err := f.Seek(0, io.SeekStart); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tvar flhdr [128]byte\n+\tif _, err := io.ReadFull(f, flhdr[:]); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\t// Read first member offset.\n+\toffStr := strings.TrimSpace(string(flhdr[68:88]))\n+\toff, err := strconv.ParseInt(offStr, 10, 64)\n+\tif err != nil {\n+\t\treturn bad()\n+\t}\n+\tfor {\n+\t\tif off == 0 {\n+\t\t\t// No more entries, no build ID.\n+\t\t\treturn \"\", nil\n+\t\t}\n+\t\tif _, err := f.Seek(off, io.SeekStart); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\t// Read member header.\n+\t\tvar hdr [112]byte\n+\t\tif _, err := io.ReadFull(f, hdr[:]); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\t// Read member name length.\n+\t\tnamLenStr := strings.TrimSpace(string(hdr[108:112]))\n+\t\tnamLen, err := strconv.ParseInt(namLenStr, 10, 32)\n+\t\tif err != nil {\n+\t\t\treturn bad()\n+\t\t}\n+\t\tif namLen == 10 {\n+\t\t\tvar nam [10]byte\n+\t\t\tif _, err := io.ReadFull(f, nam[:]); err != nil {\n+\t\t\t\treturn \"\", err\n+\t\t\t}\n+\t\t\tif string(nam[:]) == \"_buildid.o\" {\n+\t\t\t\tsizeStr := strings.TrimSpace(string(hdr[0:20]))\n+\t\t\t\tsize, err := strconv.ParseInt(sizeStr, 10, 64)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn bad()\n+\t\t\t\t}\n+\t\t\t\toff += int64(len(hdr)) + namLen + 2\n+\t\t\t\tif off&1 != 0 {\n+\t\t\t\t\toff++\n+\t\t\t\t}\n+\t\t\t\tsr := io.NewSectionReader(f, off, size)\n+\t\t\t\tx, err := xcoff.NewFile(sr)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn bad()\n+\t\t\t\t}\n+\t\t\t\tdata := x.CSect(\".go.buildid\")\n+\t\t\t\tif data == nil {\n+\t\t\t\t\treturn bad()\n+\t\t\t\t}\n+\t\t\t\treturn string(data), nil\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Read next member offset.\n+\t\toffStr = strings.TrimSpace(string(hdr[20:40]))\n+\t\toff, err = strconv.ParseInt(offStr, 10, 64)\n+\t\tif err != nil {\n+\t\t\treturn bad()\n+\t\t}\n+\t}\n+}\n+\n var (\n \tgoBuildPrefix = []byte(\"\\xff Go build ID: \\\"\")\n \tgoBuildEnd    = []byte(\"\\\"\\n \\xff\")"}]}