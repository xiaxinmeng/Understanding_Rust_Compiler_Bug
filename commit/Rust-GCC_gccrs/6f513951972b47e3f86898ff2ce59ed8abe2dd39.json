{"sha": "6f513951972b47e3f86898ff2ce59ed8abe2dd39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY1MTM5NTE5NzJiNDdlM2Y4Njg5OGZmMmNlNTllZDhhYmUyZGQzOQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-09-17T11:53:39Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2020-09-29T10:48:04Z"}, "message": "libgomp: disable barriers in nested teams\n\nBoth GCN and NVPTX allow nested parallel regions, but the barrier\nimplementation did not allow the nested teams to run independently of each\nother (due to hardware limitations).  This patch fixes that, under the\nassumption that each thread will create a new subteam of one thread, by\nsimply not using barriers when there's no other thread to synchronise.\n\nlibgomp/ChangeLog:\n\n\t* config/gcn/bar.c (gomp_barrier_wait_end): Skip the barrier if the\n\ttotal number of threads is one.\n\t(gomp_team_barrier_wake): Likewise.\n\t(gomp_team_barrier_wait_end): Likewise.\n\t(gomp_team_barrier_wait_cancel_end): Likewise.\n\t* config/nvptx/bar.c (gomp_barrier_wait_end): Likewise.\n\t(gomp_team_barrier_wake): Likewise.\n\t(gomp_team_barrier_wait_end): Likewise.\n\t(gomp_team_barrier_wait_cancel_end): Likewise.\n\t* testsuite/libgomp.c-c++-common/nested-parallel-unbalanced.c: New test.", "tree": {"sha": "7d429d1099482b891546e466971af6061965605c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d429d1099482b891546e466971af6061965605c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f513951972b47e3f86898ff2ce59ed8abe2dd39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f513951972b47e3f86898ff2ce59ed8abe2dd39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f513951972b47e3f86898ff2ce59ed8abe2dd39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f513951972b47e3f86898ff2ce59ed8abe2dd39/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95e10b8aa1066dbd5c433e613652674b0636fcd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e10b8aa1066dbd5c433e613652674b0636fcd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95e10b8aa1066dbd5c433e613652674b0636fcd1"}], "stats": {"total": 64, "additions": 53, "deletions": 11}, "files": [{"sha": "a21529a624b616158858f999e1d664f0a22863df", "filename": "libgomp/config/gcn/bar.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f513951972b47e3f86898ff2ce59ed8abe2dd39/libgomp%2Fconfig%2Fgcn%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f513951972b47e3f86898ff2ce59ed8abe2dd39/libgomp%2Fconfig%2Fgcn%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fgcn%2Fbar.c?ref=6f513951972b47e3f86898ff2ce59ed8abe2dd39", "patch": "@@ -43,7 +43,8 @@ gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n       __atomic_store_n (&bar->generation, bar->generation + BAR_INCR,\n \t\t\tMEMMODEL_RELAXED);\n     }\n-  asm (\"s_barrier\" ::: \"memory\");\n+  if (bar->total > 1)\n+    asm (\"s_barrier\" ::: \"memory\");\n }\n \n void\n@@ -71,7 +72,8 @@ gomp_barrier_wait_last (gomp_barrier_t *bar)\n void\n gomp_team_barrier_wake (gomp_barrier_t *bar, int count)\n {\n-  asm (\"s_barrier\" ::: \"memory\");\n+  if (bar->total > 1)\n+    asm (\"s_barrier\" ::: \"memory\");\n }\n \n void\n@@ -97,7 +99,8 @@ gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n \t  state &= ~BAR_CANCELLED;\n \t  state += BAR_INCR - BAR_WAS_LAST;\n \t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELAXED);\n-\t  asm (\"s_barrier\" ::: \"memory\");\n+\t  if (bar->total > 1)\n+\t    asm (\"s_barrier\" ::: \"memory\");\n \t  return;\n \t}\n     }\n@@ -172,7 +175,8 @@ gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n \t{\n \t  state += BAR_INCR - BAR_WAS_LAST;\n \t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELAXED);\n-\t  asm (\"s_barrier\" ::: \"memory\");\n+\t  if (bar->total > 1)\n+\t    asm (\"s_barrier\" ::: \"memory\");\n \t  return false;\n \t}\n     }\n@@ -195,7 +199,8 @@ gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n \t  abort();\n \t}\n \n-      asm (\"s_barrier\" ::: \"memory\");\n+      if (bar->total > 1)\n+\tasm (\"s_barrier\" ::: \"memory\");\n       gen = __atomic_load_n (&bar->generation, MEMMODEL_RELAXED);\n       if (__builtin_expect (gen & BAR_CANCELLED, 0))\n \treturn true;"}, {"sha": "1116561d93154a6584bac82ccd223f427611c649", "filename": "libgomp/config/nvptx/bar.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f513951972b47e3f86898ff2ce59ed8abe2dd39/libgomp%2Fconfig%2Fnvptx%2Fbar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f513951972b47e3f86898ff2ce59ed8abe2dd39/libgomp%2Fconfig%2Fnvptx%2Fbar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Fnvptx%2Fbar.c?ref=6f513951972b47e3f86898ff2ce59ed8abe2dd39", "patch": "@@ -41,7 +41,8 @@ gomp_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n       __atomic_store_n (&bar->generation, bar->generation + BAR_INCR,\n \t\t\tMEMMODEL_RELEASE);\n     }\n-  asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+  if (bar->total > 1)\n+    asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n }\n \n void\n@@ -69,7 +70,8 @@ gomp_barrier_wait_last (gomp_barrier_t *bar)\n void\n gomp_team_barrier_wake (gomp_barrier_t *bar, int count)\n {\n-  asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+  if (bar->total > 1)\n+    asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n }\n \n void\n@@ -95,7 +97,8 @@ gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n \t  state &= ~BAR_CANCELLED;\n \t  state += BAR_INCR - BAR_WAS_LAST;\n \t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n-\t  asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+\t  if (bar->total > 1)\n+\t    asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n \t  return;\n \t}\n     }\n@@ -104,7 +107,8 @@ gomp_team_barrier_wait_end (gomp_barrier_t *bar, gomp_barrier_state_t state)\n   state &= ~BAR_CANCELLED;\n   do\n     {\n-      asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+      if (bar->total > 1)\n+\tasm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n       gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n       if (__builtin_expect (gen & BAR_TASK_PENDING, 0))\n \t{\n@@ -158,7 +162,8 @@ gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n \t{\n \t  state += BAR_INCR - BAR_WAS_LAST;\n \t  __atomic_store_n (&bar->generation, state, MEMMODEL_RELEASE);\n-\t  asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+\t  if (bar->total > 1)\n+\t    asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n \t  return false;\n \t}\n     }\n@@ -169,7 +174,8 @@ gomp_team_barrier_wait_cancel_end (gomp_barrier_t *bar,\n   generation = state;\n   do\n     {\n-      asm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n+      if (bar->total > 1)\n+\tasm (\"bar.sync 1, %0;\" : : \"r\" (32 * bar->total));\n       gen = __atomic_load_n (&bar->generation, MEMMODEL_ACQUIRE);\n       if (__builtin_expect (gen & BAR_CANCELLED, 0))\n \treturn true;"}, {"sha": "e777271dde1d49c66ae118f4daa87111ef87c1f2", "filename": "libgomp/testsuite/libgomp.c-c++-common/nested-parallel-unbalanced.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f513951972b47e3f86898ff2ce59ed8abe2dd39/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fnested-parallel-unbalanced.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f513951972b47e3f86898ff2ce59ed8abe2dd39/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fnested-parallel-unbalanced.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Fnested-parallel-unbalanced.c?ref=6f513951972b47e3f86898ff2ce59ed8abe2dd39", "patch": "@@ -0,0 +1,31 @@\n+/* Ensure that nested parallel regions work even when the number of loop\n+   iterations is not divisible by the number of threads.  */\n+\n+#include <stdlib.h>\n+\n+int main() {\n+  int A[30][40], B[30][40];\n+  size_t n = 30;\n+\n+  for (size_t i = 0; i < 30; ++i)\n+    for (size_t j = 0; j < 40; ++j)\n+    A[i][j] = 42;\n+\n+#pragma omp target map(A[0:30][0:40], B[0:30][0:40])\n+  {\n+#pragma omp parallel for num_threads(8)\n+    for (size_t i = 0; i < n; ++i)\n+      {\n+#pragma omp parallel for\n+\tfor (size_t j = 0; j < n; ++j)\n+\t  {\n+\t    B[i][j] = A[i][j];\n+\t  }\n+      }\n+  }\n+\n+for (size_t i = 0; i < n; ++i)\n+  for (size_t j = 0; j < n; ++j)\n+    if (B[i][j] != 42)\n+      abort ();\n+}"}]}