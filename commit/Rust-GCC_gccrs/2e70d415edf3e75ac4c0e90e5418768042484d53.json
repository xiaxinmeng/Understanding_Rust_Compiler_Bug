{"sha": "2e70d415edf3e75ac4c0e90e5418768042484d53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU3MGQ0MTVlZGYzZTc1YWM0YzBlOTBlNTQxODc2ODA0MjQ4NGQ1Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-22T14:02:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-22T14:02:27Z"}, "message": "[multiple changes]\n\n2014-01-22  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb (Analyze_Initializes_In_Decl_Part): Handle null\n\tinitializes case.\n\n2014-01-22  Robert Dewar  <dewar@adacore.com>\n\n\t* snames.ads-tmpl: Update header.\n\n2014-01-22  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_util.adb (Insert_Actions): When inserting actions on a\n\tshort circuit operator that has already been analyzed, do not park\n\tactions in node; instead introduce an N_Expression_With_Actions\n\tand insert actions immediately.\n\tAdd guard for unexpected case of climbing up through statement\n\tin Actions list of an N_Expression_With_Actions.\n\t* sem_elab.adb (Insert_Elab_Check): Remove complex\n\tspecialized circuitry for the case where the context is already\n\tanalyzed, as it is not needed and introduces irregularities in\n\tfinalization. Instead rely on the above change to Insert_Actions\n\tto ensure that late insertion on short circuit operators works\n\tas expected.\n\n2014-01-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Operator_Check): Improve error message when an\n\toperand of concatenation is an access type.\n\n2014-01-22  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_dim.adb (Analyze_Dimension_Identifier): Add guard against\n\tcascaded error.\n\n2014-01-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Find_Selected_Component): Handle properly the case\n\tof an expanded name in a proper body, whose prefix is a package\n\tin the context of the proper body, when there is a homonym of\n\tthe package declared in the parent unit.\n\nFrom-SVN: r206921", "tree": {"sha": "4cb3212b80066b3186c25f0f196ffcca1e526ffc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4cb3212b80066b3186c25f0f196ffcca1e526ffc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e70d415edf3e75ac4c0e90e5418768042484d53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e70d415edf3e75ac4c0e90e5418768042484d53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e70d415edf3e75ac4c0e90e5418768042484d53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e70d415edf3e75ac4c0e90e5418768042484d53/comments", "author": null, "committer": null, "parents": [{"sha": "1250f802690505f7b38517a0f0e9cb9957532010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1250f802690505f7b38517a0f0e9cb9957532010", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1250f802690505f7b38517a0f0e9cb9957532010"}], "stats": {"total": 260, "additions": 162, "deletions": 98}, "files": [{"sha": "1cff347bf6b24901b3ae6d3d906f53d151aed0df", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2e70d415edf3e75ac4c0e90e5418768042484d53", "patch": "@@ -1,3 +1,44 @@\n+2014-01-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Initializes_In_Decl_Part): Handle null\n+\tinitializes case.\n+\n+2014-01-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* snames.ads-tmpl: Update header.\n+\n+2014-01-22  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_util.adb (Insert_Actions): When inserting actions on a\n+\tshort circuit operator that has already been analyzed, do not park\n+\tactions in node; instead introduce an N_Expression_With_Actions\n+\tand insert actions immediately.\n+\tAdd guard for unexpected case of climbing up through statement\n+\tin Actions list of an N_Expression_With_Actions.\n+\t* sem_elab.adb (Insert_Elab_Check): Remove complex\n+\tspecialized circuitry for the case where the context is already\n+\tanalyzed, as it is not needed and introduces irregularities in\n+\tfinalization. Instead rely on the above change to Insert_Actions\n+\tto ensure that late insertion on short circuit operators works\n+\tas expected.\n+\n+2014-01-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Operator_Check): Improve error message when an\n+\toperand of concatenation is an access type.\n+\n+2014-01-22  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_dim.adb (Analyze_Dimension_Identifier): Add guard against\n+\tcascaded error.\n+\n+2014-01-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Find_Selected_Component): Handle properly the case\n+\tof an expanded name in a proper body, whose prefix is a package\n+\tin the context of the proper body, when there is a homonym of\n+\tthe package declared in the parent unit.\n+\n 2014-01-22  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_warn.adb (Check_Use_Clause): Don't give no entities used"}, {"sha": "d97146c0df8d3f47106890e4c937f4663275c158", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=2e70d415edf3e75ac4c0e90e5418768042484d53", "patch": "@@ -3317,7 +3317,21 @@ package body Exp_Util is\n \n                   Kill_Current_Values;\n \n-                  if Present (Actions (P)) then\n+                  --  If P has already been expanded, we can't park new actions\n+                  --  on it, so we need to expand them immediately, introducing\n+                  --  an Expression_With_Actions. N can't be an expression\n+                  --  with actions, or else then the actions would have been\n+                  --  inserted at an inner level.\n+\n+                  if Analyzed (P) then\n+                     pragma Assert (Nkind (N) /= N_Expression_With_Actions);\n+                     Rewrite (N,\n+                       Make_Expression_With_Actions (Sloc (N),\n+                         Actions    => Ins_Actions,\n+                         Expression => Relocate_Node (N)));\n+                     Analyze_And_Resolve (N);\n+\n+                  elsif Present (Actions (P)) then\n                      Insert_List_After_And_Analyze\n                        (Last (Actions (P)), Ins_Actions);\n                   else\n@@ -3407,8 +3421,12 @@ package body Exp_Util is\n             --  the new actions come from the expression of the expression with\n             --  actions, they must be added to the existing actions. The other\n             --  alternative is when the new actions are related to one of the\n-            --  existing actions of the expression with actions. In that case\n-            --  they must be inserted further up the tree.\n+            --  existing actions of the expression with actions, and should\n+            --  never reach here: if actions are inserted on a statement within\n+            --  the Actions of an expression with actions, or on some\n+            --  sub-expression of such a statement, then the outermost proper\n+            --  insertion point is right before the statement, and we should\n+            --  never climb up as far as the N_Expression_With_Actions itself.\n \n             when N_Expression_With_Actions =>\n                if N = Expression (P) then\n@@ -3420,6 +3438,9 @@ package body Exp_Util is\n                        (Last (Actions (P)), Ins_Actions);\n                   end if;\n                   return;\n+\n+               else\n+                  raise Program_Error;\n                end if;\n \n             --  Case of appearing in the condition of a while expression or"}, {"sha": "c21293638458873f49ea8f3f359b4c6a70bd896c", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=2e70d415edf3e75ac4c0e90e5418768042484d53", "patch": "@@ -6151,7 +6151,8 @@ package body Sem_Ch4 is\n             --  In an instance a generic actual may be a numeric type even if\n             --  the formal in the generic unit was not. In that case, the\n             --  predefined operator was not a possible interpretation in the\n-            --  generic, and cannot be one in the instance.\n+            --  generic, and cannot be one in the instance, unless the operator\n+            --  is an actual of an instance.\n \n             if In_Instance\n               and then\n@@ -6576,6 +6577,17 @@ package body Sem_Ch4 is\n                         if Nkind (N) /= N_Op_Concat then\n                            Error_Msg_NE (\"\\left operand has}!\",  N, Etype (L));\n                            Error_Msg_NE (\"\\right operand has}!\", N, Etype (R));\n+\n+                        --  For concatenation operators it is more difficult to\n+                        --  determine which is the wrong operand. It is worth\n+                        --  flagging explicitly an access type, for those who\n+                        --  might think that a dereference happens here.\n+\n+                        elsif Is_Access_Type (Etype (L)) then\n+                           Error_Msg_N (\"\\left operand is access type\", N);\n+\n+                        elsif Is_Access_Type (Etype (R)) then\n+                           Error_Msg_N (\"\\right operand is access type\", N);\n                         end if;\n                      end if;\n                   end if;"}, {"sha": "bcf06a7d9e2de6efbda02c75e8eea3f1ec0d3a16", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=2e70d415edf3e75ac4c0e90e5418768042484d53", "patch": "@@ -5963,6 +5963,52 @@ package body Sem_Ch8 is\n \n       Nam : Node_Id;\n \n+      function Is_Reference_In_Subunit return Boolean;\n+      --  In a subunit, the scope depth is not a proper measure of hiding,\n+      --  because the context of the proper body may itself hide entities in\n+      --  parent units. This rare case requires inspecting the tree directly\n+      --  because the proper body is inserted in the main unit and its context\n+      --  is simply added to that of the parent.\n+\n+      -----------------------------\n+      -- Is_Reference_In_Subunit --\n+      -----------------------------\n+\n+      function Is_Reference_In_Subunit return Boolean is\n+         Clause    : Node_Id;\n+         Comp_Unit : Node_Id;\n+\n+      begin\n+         Comp_Unit := N;\n+         while Present (Comp_Unit)\n+            and then Nkind (Comp_Unit) /= N_Compilation_Unit\n+         loop\n+            Comp_Unit := Parent (Comp_Unit);\n+         end loop;\n+\n+         if No (Comp_Unit)\n+           or else Nkind (Unit (Comp_Unit)) /= N_Subunit\n+         then\n+            return False;\n+         end if;\n+\n+         --  Now check whether the package is in the context of the subunit\n+\n+         Clause := First (Context_Items (Comp_Unit));\n+\n+         while Present (Clause) loop\n+            if Nkind (Clause) = N_With_Clause\n+              and then Entity (Name (Clause)) = P_Name\n+            then\n+               return True;\n+            end if;\n+\n+            Clause := Next (Clause);\n+         end loop;\n+\n+         return False;\n+      end Is_Reference_In_Subunit;\n+\n    begin\n       Analyze (P);\n \n@@ -6244,11 +6290,13 @@ package body Sem_Ch8 is\n                      end loop;\n \n                      if Present (P_Name) then\n-                        Error_Msg_Sloc := Sloc (Entity (Prefix (N)));\n+                        if not Is_Reference_In_Subunit then\n+                           Error_Msg_Sloc := Sloc (Entity (Prefix (N)));\n \n-                        Error_Msg_NE\n-                          (\"package& is hidden by declaration#\",\n-                            N, P_Name);\n+                           Error_Msg_NE\n+                             (\"package& is hidden by declaration#\",\n+                               N, P_Name);\n+                        end if;\n \n                         Set_Entity (Prefix (N), P_Name);\n                         Find_Expanded_Name (N);"}, {"sha": "3d010f7837fdcea40e032da1472768f05117bb79", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=2e70d415edf3e75ac4c0e90e5418768042484d53", "patch": "@@ -1909,7 +1909,13 @@ package body Sem_Dim is\n          Analyze_Dimension_Identifier : declare\n             Id : constant Entity_Id := Entity (N);\n          begin\n-            if Ekind (Id) = E_Constant\n+            if No (Id) then\n+               --  Abnormal tree, assume previous error\n+\n+               Check_Error_Detected;\n+               return;\n+\n+            elsif Ekind (Id) = E_Constant\n               and then Exists (Dimensions_Of (Id))\n             then\n                Set_Dimensions (N, Dimensions_Of (Id));"}, {"sha": "d3f9b91fa2027f30eeaf3bfc9d4ceb23d1aad811", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 17, "deletions": 87, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=2e70d415edf3e75ac4c0e90e5418768042484d53", "patch": "@@ -47,8 +47,6 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Res;  use Sem_Res;\n-with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n@@ -2891,6 +2889,9 @@ package body Sem_Elab is\n       Nod : Node_Id;\n       Loc : constant Source_Ptr := Sloc (N);\n \n+      Chk : Node_Id;\n+      --  The check (N_Raise_Program_Error) node to be inserted\n+\n    begin\n       --  If expansion is disabled, do not generate any checks. Also\n       --  skip checks if any subunits are missing because in either\n@@ -2914,106 +2915,35 @@ package body Sem_Elab is\n          Nod := N;\n       end if;\n \n+      --  Build check node, possibly with condition\n+\n+      Chk := Make_Raise_Program_Error (Loc,\n+               Reason => PE_Access_Before_Elaboration);\n+      if Present (C) then\n+         Set_Condition (Chk,\n+           Make_Op_Not (Loc, Right_Opnd => C));\n+      end if;\n+\n       --  If we are inserting at the top level, insert in Aux_Decls\n \n       if Nkind (Parent (Nod)) = N_Compilation_Unit then\n          declare\n             ADN : constant Node_Id := Aux_Decls_Node (Parent (Nod));\n-            R   : Node_Id;\n \n          begin\n-            if No (C) then\n-               R :=\n-                 Make_Raise_Program_Error (Loc,\n-                   Reason => PE_Access_Before_Elaboration);\n-            else\n-               R :=\n-                 Make_Raise_Program_Error (Loc,\n-                   Condition => Make_Op_Not (Loc, C),\n-                   Reason    => PE_Access_Before_Elaboration);\n-            end if;\n-\n             if No (Declarations (ADN)) then\n-               Set_Declarations (ADN, New_List (R));\n+               Set_Declarations (ADN, New_List (Chk));\n             else\n-               Append_To (Declarations (ADN), R);\n+               Append_To (Declarations (ADN), Chk);\n             end if;\n \n-            Analyze (R);\n+            Analyze (Chk);\n          end;\n \n-      --  Otherwise just insert before the node in question. However, if\n-      --  the context of the call has already been analyzed, an insertion\n-      --  will not work if it depends on subsequent expansion (e.g. a call in\n-      --  a branch of a short-circuit). In that case we replace the call with\n-      --  an if expression, or with a Raise if it is unconditional.\n-\n-      --  Unfortunately this does not work if the call has a dynamic size,\n-      --  because gigi regards it as a dynamic-sized temporary. If such a call\n-      --  appears in a short-circuit expression, the elaboration check will be\n-      --  missed (rare enough ???). Otherwise, the code below inserts the check\n-      --  at the appropriate place before the call. Same applies in the even\n-      --  rarer case the return type has a known size but is unconstrained.\n+      --  Otherwise just insert as an action on the node in question\n \n       else\n-         if Nkind (N) = N_Function_Call\n-           and then Analyzed (Parent (N))\n-           and then Size_Known_At_Compile_Time (Etype (N))\n-           and then\n-            (not Has_Discriminants (Etype (N))\n-              or else Is_Constrained (Etype (N)))\n-\n-         then\n-            declare\n-               Typ : constant Entity_Id := Etype (N);\n-               Chk : constant Boolean   := Do_Range_Check (N);\n-\n-               R  : constant Node_Id :=\n-                      Make_Raise_Program_Error (Loc,\n-                         Reason => PE_Access_Before_Elaboration);\n-\n-               Reloc_N : Node_Id;\n-\n-            begin\n-               Set_Etype (R, Typ);\n-\n-               if No (C) then\n-                  Rewrite (N, R);\n-\n-               else\n-                  Reloc_N := Relocate_Node (N);\n-                  Save_Interps (N, Reloc_N);\n-                  Rewrite (N,\n-                    Make_If_Expression (Loc,\n-                      Expressions => New_List (C, Reloc_N, R)));\n-               end if;\n-\n-               Analyze_And_Resolve (N, Typ);\n-\n-               --  If the original call requires a range check, so does the\n-               --  if expression.\n-\n-               if Chk then\n-                  Enable_Range_Check (N);\n-               else\n-                  Set_Do_Range_Check (N, False);\n-               end if;\n-            end;\n-\n-         else\n-            if No (C) then\n-               Insert_Action (Nod,\n-                  Make_Raise_Program_Error (Loc,\n-                    Reason => PE_Access_Before_Elaboration));\n-            else\n-               Insert_Action (Nod,\n-                  Make_Raise_Program_Error (Loc,\n-                    Condition =>\n-                      Make_Op_Not (Loc,\n-                        Right_Opnd => C),\n-                    Reason => PE_Access_Before_Elaboration));\n-            end if;\n-         end if;\n+         Insert_Action (Nod, Chk);\n       end if;\n    end Insert_Elab_Check;\n "}, {"sha": "07ad998b42cdf2e47390b5703c7c4499396e283f", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2e70d415edf3e75ac4c0e90e5418768042484d53", "patch": "@@ -2635,8 +2635,14 @@ package body Sem_Prag is\n \n       Collect_States_And_Variables;\n \n+      --  All done if result is null\n+\n+      if Nkind (Inits) = N_Null then\n+         return;\n+      end if;\n+\n       --  Single and multiple initialization clauses must appear as an\n-      --  aggregate. If this is not the case, then either the parser of\n+      --  aggregate. If this is not the case, then either the parser or\n       --  the analysis of the pragma failed to produce an aggregate.\n \n       pragma Assert (Nkind (Inits) = N_Aggregate);"}, {"sha": "8259976fb19d4b7997041cbf534f43d3a1375afb", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e70d415edf3e75ac4c0e90e5418768042484d53/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=2e70d415edf3e75ac4c0e90e5418768042484d53", "patch": "@@ -4,7 +4,7 @@\n --                                                                          --\n --                               S N A M E S                                --\n --                                                                          --\n---                             T e m p l a t e                              --\n+--                                 S p e c                                  --\n --                                                                          --\n --          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --"}]}