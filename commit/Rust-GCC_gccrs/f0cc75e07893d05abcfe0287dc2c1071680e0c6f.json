{"sha": "f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBjYzc1ZTA3ODkzZDA1YWJjZmUwMjg3ZGMyYzEwNzE2ODBlMGM2Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-28T15:12:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-28T15:12:11Z"}, "message": "re PR tree-optimization/44357 (internal compiler error: in cgraph_decide_inlining_of_small_functions)\n\n\tPR tree-optimization/44357\n\t* ipa-inline.c (add_new_edges_to_heap): Do not add edges to uninlinable\n\tfunctions.\n\n\tPR tree-optimization/44357\n\t* g++.dg/torture/pr44357.C: New testcase.\n\nFrom-SVN: r161495", "tree": {"sha": "7b8a52cdd4f55b6dc7d70a1d71f3b2b05e29d5da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b8a52cdd4f55b6dc7d70a1d71f3b2b05e29d5da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0cc75e07893d05abcfe0287dc2c1071680e0c6f/comments", "author": null, "committer": null, "parents": [{"sha": "1b9503a1f5769e6b09d7a054ad2260d0fa8474d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b9503a1f5769e6b09d7a054ad2260d0fa8474d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b9503a1f5769e6b09d7a054ad2260d0fa8474d2"}], "stats": {"total": 243, "additions": 242, "deletions": 1}, "files": [{"sha": "aa933337f9b9c96bd236441c3f2d9a198e847bbf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0cc75e07893d05abcfe0287dc2c1071680e0c6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0cc75e07893d05abcfe0287dc2c1071680e0c6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "patch": "@@ -1,3 +1,9 @@\n+2010-06-28  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/44357\n+\t* ipa-inline.c (add_new_edges_to_heap): Do not add edges to uninlinable\n+\tfunctions.\n+\n 2010-06-28  Philipp Tomsich <philipp.tomsich@theobroma-systems.com>\n \n \t* config.gcc (powerpc*-*-*): Handle titan."}, {"sha": "f9e4cf3cfa736c73b5591f314d99aaeecc7c39a5", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0cc75e07893d05abcfe0287dc2c1071680e0c6f/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0cc75e07893d05abcfe0287dc2c1071680e0c6f/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "patch": "@@ -968,7 +968,9 @@ add_new_edges_to_heap (fibheap_t heap, VEC (cgraph_edge_p, heap) *new_edges)\n       struct cgraph_edge *edge = VEC_pop (cgraph_edge_p, new_edges);\n \n       gcc_assert (!edge->aux);\n-      edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge, false), edge);\n+      if (edge->callee->local.inlinable\n+\t  && cgraph_default_inline_p (edge->callee, &edge->inline_failed))\n+        edge->aux = fibheap_insert (heap, cgraph_edge_badness (edge, false), edge);\n     }\n }\n "}, {"sha": "59b0bf9a64c57040513fccff0c67eb48898a3943", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0cc75e07893d05abcfe0287dc2c1071680e0c6f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0cc75e07893d05abcfe0287dc2c1071680e0c6f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "patch": "@@ -1,3 +1,8 @@\n+2010-06-28  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/44357\n+\t* g++.dg/torture/pr44357.C: New testcase.\n+\n 2010-06-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.dg/tree-ssa/ltrans-1.c: Add -march=i486 for i?86-*-* && ilp32."}, {"sha": "3380350e81b8d836bd6cd2bf644830c9fa799704", "filename": "gcc/testsuite/g++.dg/torture/pr44357.C", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0cc75e07893d05abcfe0287dc2c1071680e0c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr44357.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0cc75e07893d05abcfe0287dc2c1071680e0c6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr44357.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr44357.C?ref=f0cc75e07893d05abcfe0287dc2c1071680e0c6f", "patch": "@@ -0,0 +1,228 @@\n+/* { dg-do compile } */\n+extern \"C\"\n+{\n+  typedef long unsigned int size_t;\n+}\n+namespace llvm\n+{\n+  namespace dont_use\n+  {\n+    template < typename T > double is_class_helper (...);\n+  }\n+  template < typename T > struct is_class\n+  {\n+  public:enum\n+    { value = sizeof (char) == sizeof (dont_use::is_class_helper < T > (0)) };\n+  };\n+    template < typename T > struct isPodLike\n+  {\n+    static const bool value = !is_class < T >::value;\n+  };\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _Iterator > struct iterator_traits\n+  {\n+  };\n+  template < typename _Tp > struct iterator_traits <_Tp * >\n+  {\n+    typedef _Tp value_type;\n+  };\n+}\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _Tp > class new_allocator\n+  {\n+  public:typedef size_t size_type;\n+    typedef const _Tp & const_reference;\n+  };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+template < typename _Tp > class allocator:public __gnu_cxx::new_allocator <\n+    _Tp >\n+  {\n+  public:typedef size_t size_type;\n+    template < typename _Tp1 > struct rebind\n+    {\n+      typedef allocator < _Tp1 > other;\n+    };\n+  };\n+  template < typename _Tp, typename _Alloc > struct _Vector_base\n+  {\n+    typedef typename _Alloc::template rebind < _Tp >::other _Tp_alloc_type;\n+  };\n+template < typename _Tp, typename _Alloc = std::allocator < _Tp > >class vector:protected _Vector_base < _Tp,\n+    _Alloc\n+    >\n+  {\n+    typedef _Vector_base < _Tp, _Alloc > _Base;\n+    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;\n+  public:typedef _Tp value_type;\n+    typedef typename _Tp_alloc_type::const_reference const_reference;\n+    typedef size_t size_type;\n+    size_type size () const\n+    {\n+    } const_reference operator[] (size_type __n) const\n+    {\n+  }};\n+}\n+\n+namespace llvm\n+{\n+  struct LandingPadInfo;\n+  class DwarfException\n+  {\n+    static bool PadLT (const LandingPadInfo * L, const LandingPadInfo * R);\n+    struct CallSiteEntry\n+    {\n+    };\n+    void EmitExceptionTable ();\n+  };\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _RandomAccessIterator,\n+    typename _Compare >\n+    void __unguarded_linear_insert (_RandomAccessIterator __last,\n+\t\t\t\t    _Compare __comp)\n+  {\n+    typename iterator_traits < _RandomAccessIterator >::value_type __val =\n+      (*__last);\n+    _RandomAccessIterator __next = __last;\n+    while (__comp (__val, *__next))\n+      {\n+      }\n+  }\n+  template < typename _RandomAccessIterator,\n+    typename _Compare > void __insertion_sort (_RandomAccessIterator __first,\n+\t\t\t\t\t       _RandomAccessIterator __last,\n+\t\t\t\t\t       _Compare __comp)\n+  {\n+    for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)\n+      {\n+\tif (__comp (*__i, *__first))\n+\t  {\n+\t  }\n+\telse\n+\t  std::__unguarded_linear_insert (__i, __comp);\n+      }\n+  }\n+  enum\n+  { _S_threshold = 16 };\n+  template < typename _RandomAccessIterator,\n+    typename _Compare >\n+    void __final_insertion_sort (_RandomAccessIterator __first,\n+\t\t\t\t _RandomAccessIterator __last,\n+\t\t\t\t _Compare __comp)\n+  {\n+    if (__last - __first > int (_S_threshold))\n+      {\n+\tstd::__insertion_sort (__first, __first + int (_S_threshold), __comp);\n+      }\n+  }\n+  template < typename _RandomAccessIterator,\n+    typename _Compare > inline void sort (_RandomAccessIterator __first,\n+\t\t\t\t\t  _RandomAccessIterator __last,\n+\t\t\t\t\t  _Compare __comp)\n+  {\n+    if (__first != __last)\n+      {\n+\tstd::__final_insertion_sort (__first, __last, __comp);\n+      }\n+  }\n+}\n+\n+namespace llvm\n+{\n+  class SmallVectorBase\n+  {\n+  protected:void *BeginX, *EndX, *CapacityX;\n+    struct U\n+    {\n+    } FirstEl;\n+  protected:  SmallVectorBase (size_t Size):BeginX (&FirstEl), EndX (&FirstEl),\n+      CapacityX ((char *) &FirstEl + Size)\n+    {\n+  }};\n+template < typename T > class SmallVectorTemplateCommon:public\n+    SmallVectorBase\n+  {\n+  public: SmallVectorTemplateCommon (size_t Size):SmallVectorBase (Size)\n+    {\n+    } typedef size_t size_type;\n+    typedef T *iterator;\n+    iterator begin ()\n+    {\n+    } iterator end ()\n+    {\n+    } size_type size () const\n+    {\n+  }};\n+template < typename T, bool isPodLike > class SmallVectorTemplateBase:public SmallVectorTemplateCommon <\n+    T >\n+  {\n+  public: SmallVectorTemplateBase (size_t Size):SmallVectorTemplateCommon < T >\n+      (Size)\n+    {\n+  }};\n+template < typename T > class SmallVectorImpl:public SmallVectorTemplateBase < T,\n+    isPodLike < T >::value >\n+  {\n+    typedef SmallVectorTemplateBase < T, isPodLike < T >::value > SuperClass;\n+  public:typedef typename SuperClass::iterator iterator;\n+    explicit SmallVectorImpl (unsigned N):SmallVectorTemplateBase < T,\n+      isPodLike < T >::value > (N * sizeof (T))\n+    {\n+    }\n+  };\n+  template < typename T,\n+    unsigned N > class SmallVector:public SmallVectorImpl < T >\n+  {\n+    typedef typename SmallVectorImpl < T >::U U;\n+    enum\n+    { MinUs =\n+\t(static_cast < unsigned int >(sizeof (T)) * N + static_cast <\n+\t unsigned int >(sizeof (U)) - 1) /static_cast <\n+\tunsigned int >(sizeof (U)), NumInlineEltsElts =\n+\tMinUs > 1 ? (MinUs - 1) : 1, NumTsAvailable =\n+\t(NumInlineEltsElts + 1) * static_cast <\n+\tunsigned int >(sizeof (U)) / static_cast <\n+\tunsigned int >(sizeof (T)) };\n+  public:  SmallVector ():SmallVectorImpl < T > (NumTsAvailable)\n+    {\n+    }\n+  };\n+  struct LandingPadInfo\n+  {\n+    std::vector < int >TypeIds;\n+    union\n+    {\n+    } Contents;\n+  };\n+}\n+\n+using namespace llvm;\n+bool\n+DwarfException::PadLT (const LandingPadInfo * L, const LandingPadInfo * R)\n+{\n+  const std::vector < int >&LIds = L->TypeIds, &RIds = R->TypeIds;\n+  unsigned LSize = LIds.size (), RSize = RIds.size ();\n+  unsigned MinSize = LSize < RSize ? LSize : RSize;\n+  for (unsigned i = 0; i != MinSize; ++i)\n+    if (LIds[i] != RIds[i])\n+      return LIds[i] < RIds[i];\n+}\n+\n+void\n+DwarfException::EmitExceptionTable ()\n+{\n+  SmallVector < const LandingPadInfo *, 64 > LandingPads;\n+  std::sort (LandingPads.begin (), LandingPads.end (), PadLT);\n+  SmallVector < CallSiteEntry, 64 > CallSites;\n+  for (unsigned i = 0, e = CallSites.size (); i < e; ++i)\n+    {\n+    }\n+}"}]}