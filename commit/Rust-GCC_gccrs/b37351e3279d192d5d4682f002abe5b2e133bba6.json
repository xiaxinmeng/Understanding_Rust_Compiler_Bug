{"sha": "b37351e3279d192d5d4682f002abe5b2e133bba6", "node_id": "C_kwDOANBUbNoAKGIzNzM1MWUzMjc5ZDE5MmQ1ZDQ2ODJmMDAyYWJlNWIyZTEzM2JiYTY", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-10-12T16:20:38Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-10-12T16:21:33Z"}, "message": "i386: Improve workaround for PR82524 LRA limitation [PR85730]\n\nAs explained in PR82524, LRA is not able to reload strict_low_part inout\noperand with matched input operand. The patch introduces a workaround,\nwhere we allow LRA to generate an instruction with non-matched input operand\nwhich is split post reload to an instruction that inserts non-matched input\noperand to an inout operand and the instruction that uses matched operand.\n\nThe generated code improves from:\n\n        movsbl  %dil, %edx\n        movl    %edi, %eax\n        sall    $3, %edx\n        movb    %dl, %al\n\nto:\n\n        movl    %edi, %eax\n        movb    %dil, %al\n        salb    $3, %al\n\nwhich is still not optimal, but the code is one instruction shorter and\ndoes not use a temporary register.\n\n2021-10-12  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\ngcc/\n\tPR target/85730\n\tPR target/82524\n\t* config/i386/i386.md (*add<mode>_1_slp): Rewrite as\n\tdefine_insn_and_split pattern.  Add alternative 1 and split it\n\tpost reload to insert operand 1 into the low part of operand 0.\n\t(*sub<mode>_1_slp): Ditto.\n\t(*and<mode>_1_slp): Ditto.\n\t(*<any_or:code><mode>_1_slp): Ditto.\n\t(*ashl<mode>3_1_slp): Ditto.\n\t(*<any_shiftrt:insn><mode>3_1_slp): Ditto.\n\t(*<any_rotate:insn><mode>3_1_slp): Ditto.\n\t(*neg<mode>_1_slp): New insn_and_split pattern.\n\t(*one_cmpl<mode>_1_slp): Ditto.\n\ngcc/testsuite/\n\tPR target/85730\n\tPR target/82524\n\t* gcc.target/i386/pr85730.c: New test.", "tree": {"sha": "f7ab094b13ae40882054aa022eba3ffd726e3b02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7ab094b13ae40882054aa022eba3ffd726e3b02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b37351e3279d192d5d4682f002abe5b2e133bba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b37351e3279d192d5d4682f002abe5b2e133bba6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b37351e3279d192d5d4682f002abe5b2e133bba6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b37351e3279d192d5d4682f002abe5b2e133bba6/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "640ae312f1273a92ce55842f745bc0db6e7bad30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/640ae312f1273a92ce55842f745bc0db6e7bad30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/640ae312f1273a92ce55842f745bc0db6e7bad30"}], "stats": {"total": 297, "additions": 242, "deletions": 55}, "files": [{"sha": "e733a40fc90ef3d02623a60065bb87c2a517da1c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 147, "deletions": 55, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b37351e3279d192d5d4682f002abe5b2e133bba6/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b37351e3279d192d5d4682f002abe5b2e133bba6/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b37351e3279d192d5d4682f002abe5b2e133bba6", "patch": "@@ -5730,16 +5730,17 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n-(define_insn \"*add<mode>_1_slp\"\n-  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n-\t(plus:SWI12 (match_operand:SWI12 1 \"nonimmediate_operand\" \"%0\")\n-\t\t    (match_operand:SWI12 2 \"general_operand\" \"<r>mn\")))\n+;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n+(define_insn_and_split \"*add<mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,<r>\"))\n+\t(plus:SWI12 (match_operand:SWI12 1 \"nonimmediate_operand\" \"%0,!<r>\")\n+\t\t    (match_operand:SWI12 2 \"general_operand\" \"<r>mn,<r>mn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n-   && (rtx_equal_p (operands[0], operands[1])\n-       || rtx_equal_p (operands[0], operands[2]))\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n {\n+  if (which_alternative)\n+    return \"#\";\n+\n   switch (get_attr_type (insn))\n     {\n     case TYPE_INCDEC:\n@@ -5758,6 +5759,13 @@\n       return \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n+  \"&& reload_completed\"\n+  [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+   (parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (plus:SWI12 (match_dup 0) (match_dup 2)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n   [(set (attr \"type\")\n      (if_then_else (match_operand:QI 2 \"incdec_operand\")\n \t(const_string \"incdec\")\n@@ -6676,15 +6684,23 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*sub<mode>_1_slp\"\n-  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n-\t(minus:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:SWI12 2 \"general_operand\" \"<r>mn\")))\n+;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n+(define_insn_and_split \"*sub<mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,<r>\"))\n+\t(minus:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0,!<r>\")\n+\t\t     (match_operand:SWI12 2 \"general_operand\" \"<r>mn,<r>mn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n-   && rtx_equal_p (operands[0], operands[1])\"\n-  \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n+  \"@\n+   sub{<imodesuffix>}\\t{%2, %0|%0, %2}\n+   #\"\n+  \"&& reload_completed\"\n+  [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+   (parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (minus:SWI12 (match_dup 0) (match_dup 2)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -9606,16 +9622,23 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n-(define_insn \"*and<mode>_1_slp\"\n-  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n-\t(and:SWI12 (match_operand:SWI12 1 \"nonimmediate_operand\" \"%0\")\n-\t\t   (match_operand:SWI12 2 \"general_operand\" \"<r>mn\")))\n+;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n+(define_insn_and_split \"*and<mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,<r>\"))\n+\t(and:SWI12 (match_operand:SWI12 1 \"nonimmediate_operand\" \"%0,!<r>\")\n+\t\t   (match_operand:SWI12 2 \"general_operand\" \"<r>mn,<r>mn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n-   && (rtx_equal_p (operands[0], operands[1])\n-       || rtx_equal_p (operands[0], operands[2]))\"\n-  \"and{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n+  \"@\n+   and{<imodesuffix>}\\t{%2, %0|%0, %2}\n+   #\"\n+  \"&& reload_completed\"\n+  [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+   (parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (and:SWI12 (match_dup 0) (match_dup 2)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -10199,16 +10222,23 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n-(define_insn \"*<code><mode>_1_slp\"\n-  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n-\t(any_or:SWI12 (match_operand:SWI12 1 \"nonimmediate_operand\" \"%0\")\n-\t\t      (match_operand:SWI12 2 \"general_operand\" \"<r>mn\")))\n+;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n+(define_insn_and_split \"*<code><mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,<r>\"))\n+\t(any_or:SWI12 (match_operand:SWI12 1 \"nonimmediate_operand\" \"%0,!<r>\")\n+\t\t      (match_operand:SWI12 2 \"general_operand\" \"<r>mn,<r>mn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n-   && (rtx_equal_p (operands[0], operands[1])\n-       || rtx_equal_p (operands[0], operands[2]))\"\n-  \"<logic>{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n+  \"@\n+   <logic>{<imodesuffix>}\\t{%2, %0|%0, %2}\n+   #\"\n+  \"&& reload_completed\"\n+  [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+   (parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (any_or:SWI12 (match_dup 0) (match_dup 2)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -10505,6 +10535,25 @@\n   [(set_attr \"type\" \"negnot\")\n    (set_attr \"mode\" \"SI\")])\n \n+;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n+(define_insn_and_split \"*neg<mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,<r>\"))\n+\t(neg:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0,!<r>\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n+  \"@\n+   neg{<imodesuffix>}\\t%0\n+   #\"\n+  \"&& reload_completed\"\n+  [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+   (parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (neg:SWI12 (match_dup 0)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_insn \"*neg<mode>_2\"\n   [(set (reg FLAGS_REG)\n \t(compare\n@@ -11060,6 +11109,22 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n+;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n+(define_insn_and_split \"*one_cmpl<mode>_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,<r>\"))\n+\t(not:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0,!<r>\")))]\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n+  \"@\n+   not{<imodesuffix>}\\t%0\n+   #\"\n+  \"&& reload_completed\"\n+  [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+   (set (strict_low_part (match_dup 0))\n+\t(not:SWI12 (match_dup 0)))]\n+  \"\"\n+  [(set_attr \"type\" \"negnot\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n (define_insn \"*one_cmpl<mode>2_2\"\n   [(set (reg FLAGS_REG)\n \t(compare (not:SWI (match_operand:SWI 1 \"nonimmediate_operand\" \"0\"))\n@@ -11638,15 +11703,17 @@\n \t      (symbol_ref \"!TARGET_PARTIAL_REG_STALL\")]\n \t   (symbol_ref \"true\")))])\n \n-(define_insn \"*ashl<mode>3_1_slp\"\n-  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n-\t(ashift:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0\")\n-\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))\n+;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n+(define_insn_and_split \"*ashl<mode>3_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,<r>\"))\n+\t(ashift:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0,!<r>\")\n+\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"cI,cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n-   && rtx_equal_p (operands[0], operands[1])\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n {\n+  if (which_alternative)\n+    return \"#\";\n+\n   switch (get_attr_type (insn))\n     {\n     case TYPE_ALU:\n@@ -11661,6 +11728,13 @@\n \treturn \"sal{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n     }\n }\n+  \"&& reload_completed\"\n+  [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+   (parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (ashift:SWI12 (match_dup 0) (match_dup 2)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n   [(set (attr \"type\")\n      (cond [(and (match_test \"TARGET_DOUBLE_WITH_ADD\")\n \t\t (match_operand 2 \"const1_operand\"))\n@@ -12356,21 +12430,30 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"HI\")])\n \n-(define_insn \"*<insn><mode>3_1_slp\"\n-  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n-\t(any_shiftrt:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0\")\n-\t\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))\n+;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n+(define_insn_and_split \"*<insn><mode>3_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,<r>\"))\n+\t(any_shiftrt:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0,!<r>\")\n+\t\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"cI,cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n-   && rtx_equal_p (operands[0], operands[1])\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n {\n+  if (which_alternative)\n+    return \"#\";\n+\n   if (operands[2] == const1_rtx\n       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n     return \"<shift>{<imodesuffix>}\\t%0\";\n   else\n     return \"<shift>{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n }\n+  \"&& reload_completed\"\n+  [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+   (parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (any_shiftrt:SWI12 (match_dup 0) (match_dup 2)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n   [(set_attr \"type\" \"ishift\")\n    (set (attr \"length_immediate\")\n      (if_then_else\n@@ -12814,21 +12897,30 @@\n        (const_string \"*\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*<insn><mode>3_1_slp\"\n-  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>\"))\n-\t(any_rotate:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0\")\n-\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"cI\")))\n+;; Alternative 1 is needed to work around LRA limitation, see PR82524.\n+(define_insn_and_split \"*<insn><mode>3_1_slp\"\n+  [(set (strict_low_part (match_operand:SWI12 0 \"register_operand\" \"+<r>,<r>\"))\n+\t(any_rotate:SWI12 (match_operand:SWI12 1 \"register_operand\" \"0,!<r>\")\n+\t\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"cI,cI\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   /* FIXME: without this LRA can't reload this pattern, see PR82524.  */\n-   && rtx_equal_p (operands[0], operands[1])\"\n+  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n {\n+  if (which_alternative)\n+    return \"#\";\n+\n   if (operands[2] == const1_rtx\n       && (TARGET_SHIFT1 || optimize_function_for_size_p (cfun)))\n     return \"<rotate>{<imodesuffix>}\\t%0\";\n   else\n     return \"<rotate>{<imodesuffix>}\\t{%2, %0|%0, %2}\";\n }\n+  \"&& reload_completed\"\n+  [(set (strict_low_part (match_dup 0)) (match_dup 1))\n+   (parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (any_rotate:SWI12 (match_dup 0) (match_dup 2)))\n+      (clobber (reg:CC FLAGS_REG))])]\n+  \"\"\n   [(set_attr \"type\" \"rotate\")\n    (set (attr \"length_immediate\")\n      (if_then_else"}, {"sha": "b2790166689b7f9d36a1dbd952444adef6551514", "filename": "gcc/testsuite/gcc.target/i386/pr85730.c", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b37351e3279d192d5d4682f002abe5b2e133bba6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr85730.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b37351e3279d192d5d4682f002abe5b2e133bba6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr85730.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr85730.c?ref=b37351e3279d192d5d4682f002abe5b2e133bba6", "patch": "@@ -0,0 +1,95 @@\n+/* PR target/85730 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mno-sse4\" } */\n+\n+typedef char V __attribute__((vector_size(4)));\n+\n+V\n+test_and (V v, char c)\n+{\n+  v[0] &= c;\n+\n+  return v;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]andb\" } } */\n+\n+V\n+test_or (V v, char c)\n+{\n+  v[0] |= c;\n+\n+  return v;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]orb\" } } */\n+\n+V\n+test_xor (V v, char c)\n+{\n+  v[0] ^= c;\n+\n+  return v;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]xorb\" } } */\n+\n+V\n+test_not (V v)\n+{\n+  v[0] = ~v[0];\n+\n+  return v;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]notb\" } } */\n+\n+V\n+test_sal (V v)\n+{\n+  v[0] <<= 3;\n+\n+  return v;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]salb\" } } */\n+\n+V\n+test_sar (V v)\n+{\n+  v[0] >>= 3;\n+\n+  return v;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]sarb\" } } */\n+\n+V\n+test_add (V v, char c)\n+{\n+  v[0] += c;\n+\n+  return v;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]addb\" } } */\n+\n+V\n+test_sub (V v, char c)\n+{\n+  v[0] -= c;\n+\n+  return v;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]subb\" } } */\n+\n+V\n+test_neg (V v)\n+{\n+  v[0] = -v[0];\n+\n+  return v;\n+}\n+\n+/* { dg-final { scan-assembler \"\\[ \\t\\]negb\" } } */"}]}