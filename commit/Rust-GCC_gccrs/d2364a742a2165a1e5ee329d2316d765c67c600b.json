{"sha": "d2364a742a2165a1e5ee329d2316d765c67c600b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIzNjRhNzQyYTIxNjVhMWU1ZWUzMjlkMjMxNmQ3NjVjNjdjNjAwYg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-31T08:48:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-31T08:48:22Z"}, "message": "pa.c (output_cbranch): New function.\n\n\t* pa.c (output_cbranch): New function.  Given the operands of the\n\tbranch, possible nullification, length of the branch, possible branch\n\tnegation, and the branch insn itself, return the output template for\n\tthe desired conditional branch.\n\t(output_bb): Likewise, but for branch on bit.\n\nFrom-SVN: r3949", "tree": {"sha": "c1192a9b735d7f2555c2f2db1851f50718259657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1192a9b735d7f2555c2f2db1851f50718259657"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2364a742a2165a1e5ee329d2316d765c67c600b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2364a742a2165a1e5ee329d2316d765c67c600b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2364a742a2165a1e5ee329d2316d765c67c600b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2364a742a2165a1e5ee329d2316d765c67c600b/comments", "author": null, "committer": null, "parents": [{"sha": "0cf4720c583685a57ce812caf0d92b8dd487e3e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cf4720c583685a57ce812caf0d92b8dd487e3e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cf4720c583685a57ce812caf0d92b8dd487e3e4"}], "stats": {"total": 169, "additions": 169, "deletions": 0}, "files": [{"sha": "14142ec717cce4f11bfb63f3766a039e6df314e8", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2364a742a2165a1e5ee329d2316d765c67c600b/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2364a742a2165a1e5ee329d2316d765c67c600b/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=d2364a742a2165a1e5ee329d2316d765c67c600b", "patch": "@@ -2913,6 +2913,175 @@ hppa_builtin_saveregs (arglist)\n \t\t\t\t    offset, 0, 0, OPTAB_LIB_WIDEN));\n }\n \n+/* This routine handles all the normal conditional branch sequences we \n+   might need to generate.  It handles compare immediate vs compare \n+   register, nullification of delay slots, varying length branches, \n+   negated branches, and all combinations of the above.  It returns the\n+   output appropriate to emit the branch corresponding to all given \n+   parameters.  */\n+\n+char *\n+output_cbranch (operands, nullify, length, negated, insn)\n+  rtx *operands;\n+  int nullify, length, negated;\n+  rtx insn;\n+{ \n+  static char buf[100];\n+  int useskip = 0;\n+\n+  /* A forward branch over a single nullified insn can be done with a \n+     comclr instruction.  This avoids a single cycle penalty due to\n+     mis-predicted branch if we fall through (branch not taken).  */\n+\n+  if (length == 1\n+      && JUMP_LABEL (insn) == next_nonnote_insn (NEXT_INSN (insn))\n+      && nullify)\n+    useskip = 1;\n+\n+  switch (length)\n+    {\n+\n+      /* Short conditional branch.  May nullify either direction.  */\n+      case 1:\n+\tif (useskip)\n+\t  strcpy (buf, \"com%I2clr,\");\n+\telse\n+\t  strcpy (buf, \"com%I2b,\");\n+\tif (negated)\n+\t  strcat (buf, \"%B3\");\n+\telse\n+\t  strcat (buf, \"%S3\");\n+\tif (useskip)\n+\t  strcat (buf, \" %2,%1,0\");\n+\telse if (nullify)\n+\t  strcat (buf, \",n %2,%1,%0\");\n+\telse \n+\t  strcat (buf, \" %2,%1,%0%#\");\n+\tbreak;\n+\n+     /* Long conditional branch, possible forward nullification.  Also\n+\tnote all conditional branches have a length of 4 when not\n+\toptimizing!  */ \n+      case 2:\n+      case 4:\n+\tstrcpy (buf, \"com%I2clr,\");\n+\tif (negated)\n+\t  strcat (buf, \"%S3\");\n+\telse\n+\t  strcat (buf, \"%B3\");\n+\tif (nullify)\n+\t  strcat (buf, \" %2,%1,0\\n\\tbl,n %0,0\");\n+\telse\n+\t  strcat (buf, \" %2,%1,0\\n\\tbl %0,0%#\");\n+\tbreak;\n+\n+      /* Long backward conditional branch with nullification.  */\n+      case 3:\n+\tstrcpy (buf, \"com%I2b,\");\n+\tif (negated)\n+\t  strcat (buf, \"%S3\");\n+\telse\n+\t  strcat (buf, \"%B3\");\n+\tstrcat (buf, \" %2,%1,.+16\\n\\tnop\\n\\t bl %0,0\");\n+\tbreak;\n+\n+      default:\n+\tabort();\n+        }\n+  return buf;\n+}\n+\n+/* This routine handles all the branch-on-bit conditional branch sequences we \n+   might need to generate.  It handles nullification of delay slots,\n+   varying length branches, negated branches and all combinations of the\n+   above.  it returns the appropriate output template to emit the branch.  */\n+\n+char *\n+output_bb (operands, nullify, length, negated, insn, which)\n+  rtx *operands;\n+  int nullify, length, negated;\n+  rtx insn;\n+  int which;\n+{ \n+  static char buf[100];\n+  int useskip = 0;\n+\n+  /* A forward branch over a single nullified insn can be done with a \n+     extrs instruction.  This avoids a single cycle penalty due to\n+     mis-predicted branch if we fall through (branch not taken).  */\n+\n+  if (length == 1\n+      && JUMP_LABEL (insn) == next_nonnote_insn (NEXT_INSN (insn))\n+      && nullify)\n+    useskip = 1;\n+\n+  switch (length)\n+    {\n+\n+      /* Short conditional branch.  May nullify either direction.  */\n+      case 1:\n+\tif (useskip)\n+\t  strcpy (buf, \"extrs,\");\n+\telse \n+\t  strcpy (buf, \"bb,\");\n+\tif ((which == 0 && negated)\n+\t     || (which == 1 && ! negated))\n+\t  strcat (buf, \">=\");\n+\telse\n+\t  strcat (buf, \"<\");\n+\tif (useskip)\n+\t  strcat (buf, \" %0,%1,1,0\");\n+\telse if (nullify && negated)\n+\t  strcat (buf, \",n %0,%1,%3\");\n+\telse if (nullify && ! negated)\n+\t  strcat (buf, \",n %0,%1,%2\");\n+\telse if (! nullify && negated)\n+\t  strcat (buf, \"%0,%1,%3%#\");\n+\telse if (! nullify && ! negated)\n+\t  strcat (buf, \" %0,%1,%2%#\");\n+\tbreak;\n+\n+     /* Long conditional branch, possible forward nullification.  Also\n+\tnote all conditional branches have a length of 4 when not\n+\toptimizing!  */ \n+      case 2:\n+      case 4:\n+\tstrcpy (buf, \"extrs,\");\n+\tif ((which == 0 && negated)\n+\t     || (which == 1 && ! negated))\n+\t  strcat (buf, \"<\");\n+\telse\n+\t  strcat (buf, \">=\");\n+\tif (nullify && negated)\n+\t  strcat (buf, \" %0,%1,1,0\\n\\tbl,n %3,0\");\n+\telse if (nullify && ! negated)\n+\t  strcat (buf, \" %0,%1,1,0\\n\\tbl,n %2,0\");\n+\telse if (! nullify && negated)\n+\t  strcat (buf, \" %0,%1,1,0\\n\\tbl %3,0%#\");\n+\telse if (! nullify && ! negated)\n+\t  strcat (buf, \" %0,%1,1,0\\n\\tbl %2,0%#\");\n+\tbreak;\n+\n+      /* Long backward conditional branch with nullification.  */\n+      case 3:\n+\tstrcpy (buf, \"bb,\");\n+\tif ((which == 0 && negated)\n+\t     || (which == 1 && ! negated))\n+\t  strcat (buf, \"<\");\n+\telse\n+\t  strcat (buf, \">=\");\n+\tif (negated)\n+\t  strcat (buf, \" %0,%1,.+16\\n\\tnop\\n\\t bl %3,0\");\n+\telse\n+\t  strcat (buf, \" %0,%1,.+16\\n\\tnop\\n\\t bl %2,0\");\n+\tbreak;\n+\n+      default:\n+\tabort();\n+        }\n+  return buf;\n+}\n+\n extern struct obstack *saveable_obstack;\n \n /* In HPUX 8.0's shared library scheme, special relocations are needed"}]}