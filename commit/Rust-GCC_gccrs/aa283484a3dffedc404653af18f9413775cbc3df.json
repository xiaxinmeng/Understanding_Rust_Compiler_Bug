{"sha": "aa283484a3dffedc404653af18f9413775cbc3df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyODM0ODRhM2RmZmVkYzQwNDY1M2FmMThmOTQxMzc3NWNiYzNkZg==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-18T13:33:09Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-18T13:33:09Z"}, "message": "Merge branch 'master' of https://github.com/redbrain/gccrs", "tree": {"sha": "118a5b918c48fba3261731bba0a6b4149209f7d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/118a5b918c48fba3261731bba0a6b4149209f7d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa283484a3dffedc404653af18f9413775cbc3df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa283484a3dffedc404653af18f9413775cbc3df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa283484a3dffedc404653af18f9413775cbc3df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa283484a3dffedc404653af18f9413775cbc3df/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c"}, {"sha": "bc14d9a0cd3c67093a9c11ad368c0d28325b21c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc14d9a0cd3c67093a9c11ad368c0d28325b21c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc14d9a0cd3c67093a9c11ad368c0d28325b21c6"}], "stats": {"total": 33437, "additions": 26745, "deletions": 6692}, "files": [{"sha": "019c476371be837922526717f02ed15fc746de48", "filename": ".github/workflows/ccpp.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/.github%2Fworkflows%2Fccpp.yml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/.github%2Fworkflows%2Fccpp.yml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fworkflows%2Fccpp.yml?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -29,7 +29,8 @@ jobs:\n                   libmpc-dev \\\n                   build-essential \\\n                   gcc-multilib \\\n-                  g++-multilib\n+                  g++-multilib \\\n+                  dejagnu\n \n     - name: Configure\n       run: |"}, {"sha": "ea7accd23c9e35272735d4312f0bdcdccbbc727c", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/README.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/README.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/README.md?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -1,6 +1,7 @@\n ![C/C++ CI](https://github.com/philberty/gccrs/workflows/C/C++%20CI/badge.svg)\n ![Docker Build](https://img.shields.io/docker/cloud/build/philberty/gccrs)\n ![Docker Pulls](https://img.shields.io/docker/pulls/philberty/gccrs)\n+[![project chat](https://img.shields.io/badge/zulip-join_chat-brightgreen.svg)](https://gcc-rust.zulipchat.com/)\n # GCC Rust\n \n This is a full alternative implementaion of the Rust language ontop of GCC.\n@@ -12,7 +13,7 @@ status reports from Philip Herron and tast tracking overviews.\n Fetch dependancies for ubuntu:\n \n ```bash\n-$ apt install build-essential libgmp3-dev libmpfr-dev libmpc-dev flex bison autogen gcc-multilib\n+$ apt install build-essential libgmp3-dev libmpfr-dev libmpc-dev flex bison autogen gcc-multilib dejagnu\n ```\n \n Clone the repository\n@@ -58,7 +59,7 @@ The test suite can be invoked via:\n $ make check-rust\n ```\n \n-Test cases can be found within gcc/testsuite/rust.test please feel free to contriobute your specific\n+Test cases can be found within gcc/testsuite/rust.test please feel free to contribute your specific\n test cases referencing any issues on github.\n \n ## Docker image"}, {"sha": "5ac60ea7df1384a32a0551345e61e8818e4d59a1", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -69,11 +69,16 @@ GRS_OBJS = \\\n     rust/rust-parse.o \\\n     rust/rust-ast-full-test.o \\\n     rust/rust-session-manager.o \\\n-    rust/rust-name-resolution.o \\\n-    rust/rust-type-resolution.o \\\n-    rust/rust-scan.o \\\n     rust/rust-compile.o \\\n+    rust/rust-compile-resolve-path.o \\\n     rust/rust-macro-expand.o \\\n+    rust/rust-hir-full-test.o \\\n+    rust/rust-hir-map.o \\\n+    rust/rust-ast-lower.o \\\n+    rust/rust-ast-resolve.o \\\n+    rust/rust-hir-type-check.o \\\n+    rust/rust-tyty.o \\\n+    rust/rust-tyctx.o \\\n     $(END)\n # removed object files from here\n \n@@ -217,7 +222,18 @@ CFLAGS-rust/rust-lang.o += -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n \t-DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\"\n \n # cross-folder includes - add new folders later\n-RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast -I $(srcdir)/rust/analysis -I $(srcdir)/rust/backend -I $(srcdir)/rust/expand\n+RUST_INCLUDES = -I $(srcdir)/rust \\\n+\t-I $(srcdir)/rust/lex \\\n+\t-I $(srcdir)/rust/parse \\\n+\t-I $(srcdir)/rust/ast \\\n+\t-I $(srcdir)/rust/analysis \\\n+\t-I $(srcdir)/rust/backend \\\n+\t-I $(srcdir)/rust/expand \\\n+\t-I $(srcdir)/rust/hir/tree \\\n+\t-I $(srcdir)/rust/hir \\\n+\t-I $(srcdir)/rust/resolve \\\n+\t-I $(srcdir)/rust/util \\\n+\t-I $(srcdir)/rust/typecheck\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)\n@@ -226,33 +242,55 @@ CFLAGS-rust/rust-parse.o += $(RUST_INCLUDES)\n CFLAGS-rust/rust-session-manager.o += $(RUST_INCLUDES)\n \n # TODO: possibly find a way to ensure C++11 compilation level here?\n+RUST_CXXFLAGS = -std=c++11 -Wno-unused-parameter -Wno-overloaded-virtual\n \n # build all rust/lex files in rust folder, add cross-folder includes\n rust/%.o: rust/lex/%.cc\n-\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n # build all rust/parse files in rust folder, add cross-folder includes\n rust/%.o: rust/parse/%.cc\n-\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n # build rust/ast files in rust folder\n rust/%.o: rust/ast/%.cc\n-\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n-\t$(POSTCOMPILE)\n-\n-# build rust/analysis files in rust folder\n-rust/%.o: rust/analysis/%.cc\n-\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n # build rust/backend files in rust folder\n rust/%.o: rust/backend/%.cc\n-\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n-# build rust/backend files in rust folder\n+# build rust/expand files in rust folder\n rust/%.o: rust/expand/%.cc\n-\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n+\n+# build rust/util files in rust folder\n+rust/%.o: rust/util/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n+\n+# build rust/hir files in rust folder\n+rust/%.o: rust/hir/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n+\n+# build rust/hir/tree files in rust folder\n+rust/%.o: rust/hir/tree/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n+\n+# build rust/resolve files in rust folder\n+rust/%.o: rust/resolve/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n+\n+# build rust/typecheck files in rust folder\n+rust/%.o: rust/typecheck/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)\n+"}, {"sha": "28a4af81bd2f0f826af6b5f7c9b9cdff7abdda3a", "filename": "gcc/rust/analysis/rust-name-resolution.cc", "status": "removed", "additions": 0, "deletions": 657, "changes": 657, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-name-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-name-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-name-resolution.cc?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,657 +0,0 @@\n-#include \"rust-name-resolution.h\"\n-#include \"rust-diagnostics.h\"\n-\n-/*\n- * The principles of name resolution:\n- * 1. If a name resolves to a binding then it should always resolve to that\n- * binding, and if resolving a name produces an error, it should always produce\n- * an error.\n- * 2. Avoid errors due to the resolver being stuck.\n- * 3. Names should be able to be used before they are declared, but the order of\n- * declarations should be irrelevant.\n- * 4. Macros should be hygiene and manually expandable.\n- * 5. Glob imports should be manually expandable.\n- */\n-\n-/* The algorithm of name resolution\n- * 1. When encouter items which bind a name, add the name to the binding table.\n- * 2. When we find an import which can't be resolved, we add it to a work list.\n- * 3. When we find a glob import, we have to record a 'back link', so that when\n- *    a public name is added for the supplying module, we can add it for the\n- *    importing module.\n- * 4. Loop over the work list and try to lookup names.\n- *    a. If a name has exactly one best binding then we use it (and record the\n- *       binding on a list of resolved names).\n- *    b. If there are zero then we put it back on the work list.\n- *    c. If there is more than one binding, then we record an ambiguity error.\n- *    d. When the work list no longer changes, then we are done.\n- *    e. If the work list is empty, then expansion/import resolution succeeded.\n- *       Otherwise there are names not found, or ambiguous names, then failed.\n- * 5. When looking up names, we record the resolutions in the binding table.\n- *    a. If the name a glob import, we add bindings for every accessible name\n- *       currently known.\n- * 6. To expand a macro, we try to resolve the macro's name.\n- *    a. If that fails, we put it on the work list.\n- *       Otherwise, we expand that macro by parsing the arguments,\n- *       pattern matching, and doing hygienic expansion.\n- *    b. We then parse the generated code in the same way as we parsed the\n- *       original program. We add new names to the binding table, and expand any\n- *       new macro uses.\n- * 7. If we add names for a module which has back links, we must follow them and\n- *    add these names to the importing module (if they are accessible).\n- */\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-NameResolution::NameResolution (AST::Crate &crate, TopLevelScan &toplevel)\n-  : Resolution (crate, toplevel), is_work_list_changed_ (false)\n-\n-{}\n-\n-NameResolution::~NameResolution () {}\n-\n-bool\n-NameResolution::Resolve (AST::Crate &crate, TopLevelScan &toplevel)\n-{\n-  NameResolution resolver (crate, toplevel);\n-  return resolver.go ();\n-}\n-\n-void\n-NameResolution::process_work_list ()\n-{}\n-\n-void\n-NameResolution::expand_macros ()\n-{}\n-\n-bool\n-NameResolution::go ()\n-{\n-  bool ret = true;\n-\n-  do\n-    {\n-      for (auto &item : crate.items)\n-\t{\n-\t  item->accept_vis (*this);\n-\t}\n-    }\n-  while (is_work_list_changed ());\n-\n-  ret = work_list_.empty ();\n-  for (auto &item : work_list_)\n-    {\n-      std::cout << \"Resolution error: \" << item.as_string () << std::endl;\n-    }\n-\n-  return ret;\n-}\n-\n-void\n-NameResolution::visit (AST::Token &tok)\n-{}\n-\n-void\n-NameResolution::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-NameResolution::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-NameResolution::visit (AST::IdentifierExpr &ident_expr)\n-{\n-  do\n-    {\n-      process_work_list ();\n-    }\n-  while (is_work_list_changed ());\n-  expand_macros ();\n-}\n-\n-void\n-NameResolution::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-NameResolution::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-NameResolution::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-NameResolution::visit (AST::PathInExpression &path)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-NameResolution::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypePath &path)\n-{}\n-\n-void\n-NameResolution::visit (AST::QualifiedPathInExpression &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-NameResolution::visit (AST::QualifiedPathInType &path)\n-{}\n-\n-// rust-expr.h\n-void\n-NameResolution::visit (AST::LiteralExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-\n-void\n-NameResolution::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-\n-void\n-NameResolution::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-\n-void\n-NameResolution::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::NegationExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::ComparisonExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::LazyBooleanExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::AssignmentExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::GroupedExpr &expr)\n-{}\n-// void NameResolution::visit(ArrayElems& elems) {}\n-void\n-NameResolution::visit (AST::ArrayElemsValues &elems)\n-{}\n-void\n-NameResolution::visit (AST::ArrayElemsCopied &elems)\n-{}\n-void\n-NameResolution::visit (AST::ArrayExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ArrayIndexExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::TupleExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::TupleIndexExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::StructExprStruct &expr)\n-{}\n-// void NameResolution::visit(StructExprField& field) {}\n-void\n-NameResolution::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-void\n-NameResolution::visit (AST::StructExprFieldIdentifierValue &field)\n-{}\n-void\n-NameResolution::visit (AST::StructExprFieldIndexValue &field)\n-{}\n-void\n-NameResolution::visit (AST::StructExprStructFields &expr)\n-{}\n-void\n-NameResolution::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-NameResolution::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-NameResolution::visit (AST::StructExprUnit &expr)\n-{}\n-// void NameResolution::visit(EnumExprField& field) {}\n-void\n-NameResolution::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-NameResolution::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::CallExpr &expr)\n-{}\n-\n-void\n-NameResolution::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ClosureExprInner &expr)\n-{}\n-void\n-NameResolution::visit (AST::BlockExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-NameResolution::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::BreakExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::RangeToInclExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ReturnExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::LoopExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::WhileLoopExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::ForLoopExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfExprConseqElse &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfExprConseqIf &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfExprConseqIfLet &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfLetExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfLetExprConseqElse &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfLetExprConseqIf &expr)\n-{}\n-void\n-NameResolution::visit (AST::IfLetExprConseqIfLet &expr)\n-{}\n-// void NameResolution::visit(MatchCase& match_case) {}\n-/*void\n-NameResolution::visit (AST::MatchCaseBlockExpr &match_case)\n-{}*/\n-/*void\n-NameResolution::visit (AST::MatchCaseExpr &match_case)\n-{}*/\n-void\n-NameResolution::visit (AST::MatchExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-NameResolution::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-NameResolution::visit (AST::TypeParam &param)\n-{}\n-// void NameResolution::visit(WhereClauseItem& item) {}\n-void\n-NameResolution::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-NameResolution::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-NameResolution::visit (AST::Method &method)\n-{}\n-void\n-NameResolution::visit (AST::ModuleBodied &module)\n-{}\n-void\n-NameResolution::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-NameResolution::visit (AST::ExternCrate &crate)\n-{}\n-// void NameResolution::visit(UseTree& use_tree) {}\n-void\n-NameResolution::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-NameResolution::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-NameResolution::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-NameResolution::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-NameResolution::visit (AST::Function &function)\n-{}\n-\n-void\n-NameResolution::visit (AST::TypeAlias &type_alias)\n-{}\n-void\n-NameResolution::visit (AST::StructStruct &struct_item)\n-{}\n-void\n-NameResolution::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-NameResolution::visit (AST::EnumItem &item)\n-{}\n-void\n-NameResolution::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-NameResolution::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-NameResolution::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-NameResolution::visit (AST::Enum &enum_item)\n-{}\n-void\n-NameResolution::visit (AST::Union &union_item)\n-{}\n-\n-void\n-NameResolution::visit (AST::ConstantItem &const_item)\n-{}\n-\n-void\n-NameResolution::visit (AST::StaticItem &static_item)\n-{}\n-void\n-NameResolution::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-NameResolution::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-NameResolution::visit (AST::TraitItemConst &item)\n-{}\n-void\n-NameResolution::visit (AST::TraitItemType &item)\n-{}\n-void\n-NameResolution::visit (AST::Trait &trait)\n-{}\n-void\n-NameResolution::visit (AST::InherentImpl &impl)\n-{}\n-void\n-NameResolution::visit (AST::TraitImpl &impl)\n-{}\n-// void NameResolution::visit(ExternalItem& item) {}\n-void\n-NameResolution::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-NameResolution::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-NameResolution::visit (AST::ExternBlock &block)\n-{}\n-\n-// rust-macro.h\n-void\n-NameResolution::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-NameResolution::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-NameResolution::visit (AST::MacroMatcher &matcher)\n-{}\n-\n-void\n-NameResolution::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-\n-void\n-NameResolution::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-NameResolution::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-NameResolution::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n-\n-// rust-pattern.h\n-void\n-NameResolution::visit (AST::LiteralPattern &pattern)\n-{}\n-\n-void\n-NameResolution::visit (AST::IdentifierPattern &pattern)\n-{}\n-\n-void\n-NameResolution::visit (AST::WildcardPattern &pattern)\n-{}\n-// void NameResolution::visit(RangePatternBound& bound) {}\n-void\n-NameResolution::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-NameResolution::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-NameResolution::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-NameResolution::visit (AST::RangePattern &pattern)\n-{}\n-void\n-NameResolution::visit (AST::ReferencePattern &pattern)\n-{}\n-// void NameResolution::visit(StructPatternField& field) {}\n-void\n-NameResolution::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-NameResolution::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-NameResolution::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-NameResolution::visit (AST::StructPattern &pattern)\n-{}\n-// void NameResolution::visit(TupleStructItems& tuple_items) {}\n-void\n-NameResolution::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-NameResolution::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-NameResolution::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void NameResolution::visit(TuplePatternItems& tuple_items) {}\n-void\n-NameResolution::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-NameResolution::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-NameResolution::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-NameResolution::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-NameResolution::visit (AST::SlicePattern &pattern)\n-{}\n-\n-// rust-stmt.h\n-void\n-NameResolution::visit (AST::EmptyStmt &stmt)\n-{}\n-\n-void\n-NameResolution::visit (AST::LetStmt &stmt)\n-{}\n-\n-void\n-NameResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n-{}\n-\n-void\n-NameResolution::visit (AST::ExprStmtWithBlock &stmt)\n-{}\n-\n-// rust-type.h\n-void\n-NameResolution::visit (AST::TraitBound &bound)\n-{}\n-\n-void\n-NameResolution::visit (AST::ImplTraitType &type)\n-{}\n-\n-void\n-NameResolution::visit (AST::TraitObjectType &type)\n-{}\n-void\n-NameResolution::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-NameResolution::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-NameResolution::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-NameResolution::visit (AST::TupleType &type)\n-{}\n-void\n-NameResolution::visit (AST::NeverType &type)\n-{}\n-void\n-NameResolution::visit (AST::RawPointerType &type)\n-{}\n-void\n-NameResolution::visit (AST::ReferenceType &type)\n-{}\n-void\n-NameResolution::visit (AST::ArrayType &type)\n-{}\n-void\n-NameResolution::visit (AST::SliceType &type)\n-{}\n-void\n-NameResolution::visit (AST::InferredType &type)\n-{}\n-void\n-NameResolution::visit (AST::BareFunctionType &type)\n-{}\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "b3bc78002c054522474d1ba80f87df3ffd80dc7a", "filename": "gcc/rust/analysis/rust-name-resolution.h", "status": "removed", "additions": 0, "deletions": 232, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-name-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-name-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-name-resolution.h?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,232 +0,0 @@\n-#pragma once\n-\n-#include \"rust-resolution.h\"\n-#include <list>\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class NameResolution : public Resolution\n-{\n-public:\n-  ~NameResolution ();\n-  static bool Resolve (AST::Crate &crate, TopLevelScan &toplevel);\n-\n-  // visitor impl\n-  // rust-ast.h\n-  //  void visit(AttrInput& attr_input);\n-  //  void visit(TokenTree& token_tree);\n-  //  void visit(MacroMatch& macro_match);\n-  void visit (AST::Token &tok) override;\n-  void visit (AST::DelimTokenTree &delim_tok_tree) override;\n-  void visit (AST::AttrInputMetaItemContainer &input) override;\n-  //  void visit(MetaItem& meta_item) override;\n-  //  void vsit(Stmt& stmt) override;\n-  //  void visit(Expr& expr) override;\n-  void visit (AST::IdentifierExpr &ident_expr) override;\n-  //  void visit(Pattern& pattern) override;\n-  //  void visit(Type& type) override;\n-  //  void visit(TypeParamBound& type_param_bound) override;\n-  void visit (AST::Lifetime &lifetime) override;\n-  //  void visit(GenericParam& generic_param) override;\n-  void visit (AST::LifetimeParam &lifetime_param) override;\n-  //  void visit(TraitItem& trait_item) override;\n-  //  void visit(InherentImplItem& inherent_impl_item) override;\n-  //  void visit(TraitImplItem& trait_impl_item) override;\n-  void visit (AST::MacroInvocationSemi &macro) override;\n-\n-  // rust-path.h\n-  void visit (AST::PathInExpression &path) override;\n-  void visit (AST::TypePathSegment &segment) override;\n-  void visit (AST::TypePathSegmentGeneric &segment) override;\n-  void visit (AST::TypePathSegmentFunction &segment) override;\n-  void visit (AST::TypePath &path) override;\n-  void visit (AST::QualifiedPathInExpression &path) override;\n-  void visit (AST::QualifiedPathInType &path) override;\n-\n-  // rust-expr.h\n-  void visit (AST::LiteralExpr &expr) override;\n-  void visit (AST::AttrInputLiteral &attr_input) override;\n-  void visit (AST::MetaItemLitExpr &meta_item) override;\n-  void visit (AST::MetaItemPathLit &meta_item) override;\n-  void visit (AST::BorrowExpr &expr) override;\n-  void visit (AST::DereferenceExpr &expr) override;\n-  void visit (AST::ErrorPropagationExpr &expr) override;\n-  void visit (AST::NegationExpr &expr) override;\n-  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n-  void visit (AST::ComparisonExpr &expr) override;\n-  void visit (AST::LazyBooleanExpr &expr) override;\n-  void visit (AST::TypeCastExpr &expr) override;\n-  void visit (AST::AssignmentExpr &expr) override;\n-  void visit (AST::CompoundAssignmentExpr &expr) override;\n-  void visit (AST::GroupedExpr &expr) override;\n-  //  void visit(ArrayElems& elems) override;\n-  void visit (AST::ArrayElemsValues &elems) override;\n-  void visit (AST::ArrayElemsCopied &elems) override;\n-  void visit (AST::ArrayExpr &expr) override;\n-  void visit (AST::ArrayIndexExpr &expr) override;\n-  void visit (AST::TupleExpr &expr) override;\n-  void visit (AST::TupleIndexExpr &expr) override;\n-  void visit (AST::StructExprStruct &expr) override;\n-  //  void visit(StructExprField& field) override;\n-  void visit (AST::StructExprFieldIdentifier &field) override;\n-  void visit (AST::StructExprFieldIdentifierValue &field) override;\n-  void visit (AST::StructExprFieldIndexValue &field) override;\n-  void visit (AST::StructExprStructFields &expr) override;\n-  void visit (AST::StructExprStructBase &expr) override;\n-  void visit (AST::StructExprTuple &expr) override;\n-  void visit (AST::StructExprUnit &expr) override;\n-  //  void visit(EnumExprField& field) override;\n-  void visit (AST::EnumExprFieldIdentifier &field) override;\n-  void visit (AST::EnumExprFieldIdentifierValue &field) override;\n-  void visit (AST::EnumExprFieldIndexValue &field) override;\n-  void visit (AST::EnumExprStruct &expr) override;\n-  void visit (AST::EnumExprTuple &expr) override;\n-  void visit (AST::EnumExprFieldless &expr) override;\n-  void visit (AST::CallExpr &expr) override;\n-  void visit (AST::MethodCallExpr &expr) override;\n-  void visit (AST::FieldAccessExpr &expr) override;\n-  void visit (AST::ClosureExprInner &expr) override;\n-  void visit (AST::BlockExpr &expr) override;\n-  void visit (AST::ClosureExprInnerTyped &expr) override;\n-  void visit (AST::ContinueExpr &expr) override;\n-  void visit (AST::BreakExpr &expr) override;\n-  void visit (AST::RangeFromToExpr &expr) override;\n-  void visit (AST::RangeFromExpr &expr) override;\n-  void visit (AST::RangeToExpr &expr) override;\n-  void visit (AST::RangeFullExpr &expr) override;\n-  void visit (AST::RangeFromToInclExpr &expr) override;\n-  void visit (AST::RangeToInclExpr &expr) override;\n-  void visit (AST::ReturnExpr &expr) override;\n-  void visit (AST::UnsafeBlockExpr &expr) override;\n-  void visit (AST::LoopExpr &expr) override;\n-  void visit (AST::WhileLoopExpr &expr) override;\n-  void visit (AST::WhileLetLoopExpr &expr) override;\n-  void visit (AST::ForLoopExpr &expr) override;\n-  void visit (AST::IfExpr &expr) override;\n-  void visit (AST::IfExprConseqElse &expr) override;\n-  void visit (AST::IfExprConseqIf &expr) override;\n-  void visit (AST::IfExprConseqIfLet &expr) override;\n-  void visit (AST::IfLetExpr &expr) override;\n-  void visit (AST::IfLetExprConseqElse &expr) override;\n-  void visit (AST::IfLetExprConseqIf &expr) override;\n-  void visit (AST::IfLetExprConseqIfLet &expr) override;\n-  //  void visit(MatchCase& match_case) override;\n-  // void visit (AST::MatchCaseBlockExpr &match_case) override;\n-  // void visit (AST::MatchCaseExpr &match_case) override;\n-  void visit (AST::MatchExpr &expr) override;\n-  void visit (AST::AwaitExpr &expr) override;\n-  void visit (AST::AsyncBlockExpr &expr) override;\n-\n-  // rust-item.h\n-  void visit (AST::TypeParam &param) override;\n-  //  void visit(WhereClauseItem& item) override;\n-  void visit (AST::LifetimeWhereClauseItem &item) override;\n-  void visit (AST::TypeBoundWhereClauseItem &item) override;\n-  void visit (AST::Method &method) override;\n-  void visit (AST::ModuleBodied &module) override;\n-  void visit (AST::ModuleNoBody &module) override;\n-  void visit (AST::ExternCrate &crate) override;\n-  //  void visit(UseTree& use_tree) override;\n-  void visit (AST::UseTreeGlob &use_tree) override;\n-  void visit (AST::UseTreeList &use_tree) override;\n-  void visit (AST::UseTreeRebind &use_tree) override;\n-  void visit (AST::UseDeclaration &use_decl) override;\n-  void visit (AST::Function &function) override;\n-  void visit (AST::TypeAlias &type_alias) override;\n-  void visit (AST::StructStruct &struct_item) override;\n-  void visit (AST::TupleStruct &tuple_struct) override;\n-  void visit (AST::EnumItem &item) override;\n-  void visit (AST::EnumItemTuple &item) override;\n-  void visit (AST::EnumItemStruct &item) override;\n-  void visit (AST::EnumItemDiscriminant &item) override;\n-  void visit (AST::Enum &enum_item) override;\n-  void visit (AST::Union &union_item) override;\n-  void visit (AST::ConstantItem &const_item) override;\n-  void visit (AST::StaticItem &static_item) override;\n-  void visit (AST::TraitItemFunc &item) override;\n-  void visit (AST::TraitItemMethod &item) override;\n-  void visit (AST::TraitItemConst &item) override;\n-  void visit (AST::TraitItemType &item) override;\n-  void visit (AST::Trait &trait) override;\n-  void visit (AST::InherentImpl &impl) override;\n-  void visit (AST::TraitImpl &impl) override;\n-  //  void visit(ExternalItem& item) override;\n-  void visit (AST::ExternalStaticItem &item) override;\n-  void visit (AST::ExternalFunctionItem &item) override;\n-  void visit (AST::ExternBlock &block) override;\n-\n-  // rust-macro.h\n-  void visit (AST::MacroMatchFragment &match) override;\n-  void visit (AST::MacroMatchRepetition &match) override;\n-  void visit (AST::MacroMatcher &matcher) override;\n-  void visit (AST::MacroRulesDefinition &rules_def) override;\n-  void visit (AST::MacroInvocation &macro_invoc) override;\n-  void visit (AST::MetaItemPath &meta_item) override;\n-  void visit (AST::MetaItemSeq &meta_item) override;\n-  void visit (AST::MetaWord &meta_item) override;\n-  void visit (AST::MetaNameValueStr &meta_item) override;\n-  void visit (AST::MetaListPaths &meta_item) override;\n-  void visit (AST::MetaListNameValueStr &meta_item) override;\n-\n-  // rust-pattern.h\n-  void visit (AST::LiteralPattern &pattern) override;\n-  void visit (AST::IdentifierPattern &pattern) override;\n-  void visit (AST::WildcardPattern &pattern) override;\n-  //  void visit(RangePatternBound& bound) override;\n-  void visit (AST::RangePatternBoundLiteral &bound) override;\n-  void visit (AST::RangePatternBoundPath &bound) override;\n-  void visit (AST::RangePatternBoundQualPath &bound) override;\n-  void visit (AST::RangePattern &pattern) override;\n-  void visit (AST::ReferencePattern &pattern) override;\n-  //  void visit(StructPatternField& field) override;\n-  void visit (AST::StructPatternFieldTuplePat &field) override;\n-  void visit (AST::StructPatternFieldIdentPat &field) override;\n-  void visit (AST::StructPatternFieldIdent &field) override;\n-  void visit (AST::StructPattern &pattern) override;\n-  //  void visit(TupleStructItems& tuple_items) override;\n-  void visit (AST::TupleStructItemsNoRange &tuple_items) override;\n-  void visit (AST::TupleStructItemsRange &tuple_items) override;\n-  void visit (AST::TupleStructPattern &pattern) override;\n-  //  void visit(TuplePatternItems& tuple_items) override;\n-  void visit (AST::TuplePatternItemsMultiple &tuple_items) override;\n-  void visit (AST::TuplePatternItemsRanged &tuple_items) override;\n-  void visit (AST::TuplePattern &pattern) override;\n-  void visit (AST::GroupedPattern &pattern) override;\n-  void visit (AST::SlicePattern &pattern) override;\n-\n-  // rust-stmt.h\n-  void visit (AST::EmptyStmt &stmt) override;\n-  void visit (AST::LetStmt &stmt) override;\n-  void visit (AST::ExprStmtWithoutBlock &stmt) override;\n-  void visit (AST::ExprStmtWithBlock &stmt) override;\n-\n-  // rust-type.h\n-  void visit (AST::TraitBound &bound) override;\n-  void visit (AST::ImplTraitType &type) override;\n-  void visit (AST::TraitObjectType &type) override;\n-  void visit (AST::ParenthesisedType &type) override;\n-  void visit (AST::ImplTraitTypeOneBound &type) override;\n-  void visit (AST::TraitObjectTypeOneBound &type) override;\n-  void visit (AST::TupleType &type) override;\n-  void visit (AST::NeverType &type) override;\n-  void visit (AST::RawPointerType &type) override;\n-  void visit (AST::ReferenceType &type) override;\n-  void visit (AST::ArrayType &type) override;\n-  void visit (AST::SliceType &type) override;\n-  void visit (AST::InferredType &type) override;\n-  void visit (AST::BareFunctionType &type) override;\n-\n-private:\n-  NameResolution (AST::Crate &crate, TopLevelScan &toplevel);\n-  bool go () override;\n-  void process_names ();\n-  void process_work_list ();\n-  void expand_macros ();\n-  bool is_work_list_changed () { return is_work_list_changed_; }\n-  std::list<AST::UseDeclaration> work_list_;\n-  bool is_work_list_changed_;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "731801a03c3786a8fcfd5a7959d4f410bf2ca83d", "filename": "gcc/rust/analysis/rust-resolution.cc", "status": "removed", "additions": 0, "deletions": 867, "changes": 867, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-resolution.cc?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,867 +0,0 @@\n-#include \"rust-resolution.h\"\n-#include \"rust-diagnostics.h\"\n-\n-#define ADD_BUILTIN_TYPE(_X, _S)                                               \\\n-  do                                                                           \\\n-    {                                                                          \\\n-      AST::PathIdentSegment seg (_X);                                          \\\n-      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n-\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n-\t\t\t\t  Linemap::unknown_location ()));              \\\n-      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n-      segs.push_back (::std::move (typePath));                                 \\\n-      auto bType = new AST::TypePath (::std::move (segs),                      \\\n-\t\t\t\t      Linemap::unknown_location (), false);    \\\n-      _S.Insert (_X, bType);                                                   \\\n-    }                                                                          \\\n-  while (0)\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-TypeResolution::TypeResolution (AST::Crate &crate, TopLevelScan &toplevel)\n-  : crate (crate), toplevel (toplevel)\n-{\n-  typeScope.Push ();\n-  scope.Push ();\n-\n-  // push all builtin types - this is probably too basic for future needs\n-  ADD_BUILTIN_TYPE (\"u8\", typeScope);\n-  ADD_BUILTIN_TYPE (\"u16\", typeScope);\n-  ADD_BUILTIN_TYPE (\"u32\", typeScope);\n-  ADD_BUILTIN_TYPE (\"u64\", typeScope);\n-\n-  ADD_BUILTIN_TYPE (\"i8\", typeScope);\n-  ADD_BUILTIN_TYPE (\"i16\", typeScope);\n-  ADD_BUILTIN_TYPE (\"i32\", typeScope);\n-  ADD_BUILTIN_TYPE (\"i64\", typeScope);\n-\n-  ADD_BUILTIN_TYPE (\"f32\", typeScope);\n-  ADD_BUILTIN_TYPE (\"f64\", typeScope);\n-\n-  ADD_BUILTIN_TYPE (\"char\", typeScope);\n-  ADD_BUILTIN_TYPE (\"str\", typeScope);\n-  ADD_BUILTIN_TYPE (\"bool\", typeScope);\n-}\n-\n-TypeResolution::~TypeResolution ()\n-{\n-  typeScope.Pop ();\n-  scope.Pop ();\n-}\n-\n-bool\n-TypeResolution::ResolveNamesAndTypes (AST::Crate &crate, TopLevelScan &toplevel)\n-{\n-  TypeResolution resolver (crate, toplevel);\n-  return resolver.go ();\n-}\n-\n-bool\n-TypeResolution::go ()\n-{\n-  for (auto &item : crate.items)\n-    item->accept_vis (*this);\n-\n-  return true;\n-}\n-\n-bool\n-TypeResolution::typesAreCompatible (AST::Type *lhs, AST::Type *rhs,\n-\t\t\t\t    Location locus)\n-{\n-  lhs->accept_vis (*this);\n-  rhs->accept_vis (*this);\n-\n-  auto rhsTypeStr = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-  auto lhsTypeStr = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-\n-  // FIXME this needs to handle the cases of an i8 going into an i32 which is\n-  // compatible\n-  if (lhsTypeStr.compare (rhsTypeStr))\n-    {\n-      rust_error_at (locus, \"E0308: expected: %s, found %s\",\n-\t\t     lhsTypeStr.c_str (), rhsTypeStr.c_str ());\n-      return false;\n-    }\n-\n-  return true;\n-}\n-\n-void\n-TypeResolution::visit (AST::Token &tok)\n-{}\n-\n-void\n-TypeResolution::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-TypeResolution::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-TypeResolution::visit (AST::IdentifierExpr &ident_expr)\n-{\n-  AST::Type *type = NULL;\n-  bool ok = scope.Lookup (ident_expr.ident, &type);\n-  if (!ok)\n-    {\n-      rust_error_at (ident_expr.locus, \"unknown identifier\");\n-      return;\n-    }\n-\n-  typeBuffer.push_back (type);\n-}\n-\n-void\n-TypeResolution::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-TypeResolution::visit (AST::PathInExpression &path)\n-{\n-  printf (\"PathInExpression: %s\\n\", path.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-TypeResolution::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypePath &path)\n-{\n-  // this may not be robust enough for type comparisons but lets try it for now\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::QualifiedPathInExpression &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::QualifiedPathInType &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-// rust-expr.h\n-void\n-TypeResolution::visit (AST::LiteralExpr &expr)\n-{\n-  std::string type;\n-  switch (expr.literal.get_lit_type ())\n-    {\n-    case AST::Literal::CHAR:\n-      type = \"char\";\n-      break;\n-\n-    case AST::Literal::STRING:\n-    case AST::Literal::RAW_STRING:\n-      type = \"str\";\n-      break;\n-\n-    case AST::Literal::BOOL:\n-      type = \"bool\";\n-      break;\n-\n-    case AST::Literal::BYTE:\n-      type = \"u8\";\n-      break;\n-\n-      // FIXME these are not always going to be the case\n-      // eg: suffix on the value can change the type\n-    case AST::Literal::FLOAT:\n-      type = \"f32\";\n-      break;\n-\n-    case AST::Literal::INT:\n-      type = \"i32\";\n-      break;\n-\n-    case AST::Literal::BYTE_STRING:\n-    case AST::Literal::RAW_BYTE_STRING:\n-      // FIXME\n-      break;\n-    }\n-\n-  if (type.empty ())\n-    {\n-      rust_error_at (expr.locus, \"unknown literal: %s\",\n-\t\t     expr.literal.as_string ().c_str ());\n-      return;\n-    }\n-\n-  AST::Type *val = NULL;\n-  bool ok = typeScope.Lookup (type, &val);\n-  if (ok)\n-    typeBuffer.push_back (val);\n-  else\n-    rust_error_at (expr.locus, \"unknown literal type: %s\", type.c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::NegationExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{\n-  size_t before;\n-  before = typeBuffer.size ();\n-  expr.visit_lhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.locus, \"unable to determine lhs type\");\n-      return;\n-    }\n-\n-  auto lhsType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.visit_rhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.locus, \"unable to determine rhs type\");\n-      return;\n-    }\n-\n-  auto rhsType = typeBuffer.back ();\n-  // not poping because we will be checking they match and the\n-  // scope will require knowledge of the type\n-\n-  // do the lhsType and the rhsType match\n-  typesAreCompatible (lhsType, rhsType, expr.right_expr->get_locus_slow ());\n-}\n-\n-void\n-TypeResolution::visit (AST::ComparisonExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LazyBooleanExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::AssignmentExpr &expr)\n-{\n-  size_t before;\n-  before = typeBuffer.size ();\n-  expr.visit_lhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.locus, \"unable to determine lhs type\");\n-      return;\n-    }\n-\n-  auto lhsType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.visit_rhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.locus, \"unable to determine rhs type\");\n-      return;\n-    }\n-\n-  auto rhsType = typeBuffer.back ();\n-  // not poping because we will be checking they match and the\n-  // scope will require knowledge of the type\n-\n-  // do the lhsType and the rhsType match\n-  if (!typesAreCompatible (lhsType, rhsType,\n-\t\t\t   expr.right_expr->get_locus_slow ()))\n-    return;\n-\n-  // is the lhs mutable?\n-}\n-\n-void\n-TypeResolution::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::GroupedExpr &expr)\n-{}\n-// void TypeResolution::visit(ArrayElems& elems) {}\n-void\n-TypeResolution::visit (AST::ArrayElemsValues &elems)\n-{}\n-void\n-TypeResolution::visit (AST::ArrayElemsCopied &elems)\n-{}\n-void\n-TypeResolution::visit (AST::ArrayExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ArrayIndexExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::TupleExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::TupleIndexExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprStruct &expr)\n-{}\n-// void TypeResolution::visit(StructExprField& field) {}\n-void\n-TypeResolution::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprFieldIdentifierValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprFieldIndexValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprStructFields &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprUnit &expr)\n-{}\n-// void TypeResolution::visit(EnumExprField& field) {}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::CallExpr &expr)\n-{\n-  printf (\"CallExpr: %s\\n\", expr.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ClosureExprInner &expr)\n-{}\n-void\n-TypeResolution::visit (AST::BlockExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::BreakExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeToInclExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ReturnExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::LoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::WhileLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ForLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfExprConseqElse &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfExprConseqIf &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfExprConseqIfLet &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqElse &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqIf &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqIfLet &expr)\n-{}\n-// void TypeResolution::visit(MatchCase& match_case) {}\n-void\n-TypeResolution::visit (AST::MatchCaseBlockExpr &match_case)\n-{}\n-void\n-TypeResolution::visit (AST::MatchCaseExpr &match_case)\n-{}\n-void\n-TypeResolution::visit (AST::MatchExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-TypeResolution::visit (AST::TypeParam &param)\n-{}\n-// void TypeResolution::visit(WhereClauseItem& item) {}\n-void\n-TypeResolution::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::Method &method)\n-{}\n-void\n-TypeResolution::visit (AST::ModuleBodied &module)\n-{}\n-void\n-TypeResolution::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-TypeResolution::visit (AST::ExternCrate &crate)\n-{}\n-// void TypeResolution::visit(UseTree& use_tree) {}\n-void\n-TypeResolution::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-TypeResolution::visit (AST::Function &function)\n-{\n-  // always emit the function with return type in the event of nil return type\n-  // its  a marker for a void function\n-  scope.Insert (function.function_name, function.return_type.get ());\n-\n-  scope.Push ();\n-  for (auto &param : function.function_params)\n-    {\n-      auto before = letPatternBuffer.size ();\n-      param.param_name->accept_vis (*this);\n-      if (letPatternBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (param.locus, \"failed to analyse parameter name\");\n-\t  return;\n-\t}\n-\n-      auto paramName = letPatternBuffer.back ();\n-      letPatternBuffer.pop_back ();\n-      scope.Insert (paramName.variable_ident, param.type.get ());\n-    }\n-\n-  // walk the expression body\n-  for (auto &stmt : function.function_body->statements)\n-    {\n-      stmt->accept_vis (*this);\n-    }\n-\n-  scope.Pop ();\n-}\n-\n-void\n-TypeResolution::visit (AST::TypeAlias &type_alias)\n-{}\n-void\n-TypeResolution::visit (AST::StructStruct &struct_item)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-TypeResolution::visit (AST::Enum &enum_item)\n-{}\n-void\n-TypeResolution::visit (AST::Union &union_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ConstantItem &const_item)\n-{\n-  printf (\"ConstantItem: %s\\n\", const_item.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::StaticItem &static_item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemConst &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemType &item)\n-{}\n-void\n-TypeResolution::visit (AST::Trait &trait)\n-{}\n-void\n-TypeResolution::visit (AST::InherentImpl &impl)\n-{}\n-void\n-TypeResolution::visit (AST::TraitImpl &impl)\n-{}\n-// void TypeResolution::visit(ExternalItem& item) {}\n-void\n-TypeResolution::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::ExternBlock &block)\n-{}\n-\n-// rust-macro.h\n-void\n-TypeResolution::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-TypeResolution::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-TypeResolution::visit (AST::MacroMatcher &matcher)\n-{}\n-void\n-TypeResolution::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-void\n-TypeResolution::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-TypeResolution::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n-\n-// rust-pattern.h\n-void\n-TypeResolution::visit (AST::LiteralPattern &pattern)\n-{\n-  printf (\"LiteralPattern: %s\\n\", pattern.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::IdentifierPattern &pattern)\n-{\n-  letPatternBuffer.push_back (pattern);\n-}\n-\n-void\n-TypeResolution::visit (AST::WildcardPattern &pattern)\n-{}\n-// void TypeResolution::visit(RangePatternBound& bound) {}\n-void\n-TypeResolution::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::ReferencePattern &pattern)\n-{}\n-// void TypeResolution::visit(StructPatternField& field) {}\n-void\n-TypeResolution::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPattern &pattern)\n-{}\n-// void TypeResolution::visit(TupleStructItems& tuple_items) {}\n-void\n-TypeResolution::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void TypeResolution::visit(TuplePatternItems& tuple_items) {}\n-void\n-TypeResolution::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::SlicePattern &pattern)\n-{}\n-\n-// rust-stmt.h\n-void\n-TypeResolution::visit (AST::EmptyStmt &stmt)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LetStmt &stmt)\n-{\n-  if (!stmt.has_init_expr () && !stmt.has_type ())\n-    {\n-      rust_error_at (stmt.locus,\n-\t\t     \"E0282: type annotations or init expression needed\");\n-      return;\n-    }\n-\n-  AST::Type *inferedType = NULL;\n-  if (stmt.has_init_expr ())\n-    {\n-      stmt.init_expr->accept_vis (*this);\n-\n-      if (typeBuffer.empty ())\n-\t{\n-\t  rust_error_at (\n-\t    stmt.init_expr->get_locus_slow (),\n-\t    \"unable to determine type for declaration from init expr\");\n-\t  return;\n-\t}\n-\n-      inferedType = typeBuffer.back ();\n-      typeBuffer.pop_back ();\n-    }\n-\n-  if (stmt.has_type () && stmt.has_init_expr ())\n-    {\n-      if (!typesAreCompatible (stmt.type.get (), inferedType,\n-\t\t\t       stmt.init_expr->get_locus_slow ()))\n-\t{\n-\t  return;\n-\t}\n-    }\n-  else if (stmt.has_type () && !stmt.has_init_expr ())\n-    {\n-      inferedType = stmt.type.get ();\n-    }\n-\n-  // TODO check we know what the type is in the scope requires the builtins to\n-  // be defined at the constructor\n-\n-  // ensure the decl has the type set for compilation later on\n-  if (!stmt.has_type ())\n-    {\n-      // FIXME\n-      // stmt.type = inferedType;\n-    }\n-\n-  // get all the names part of this declaration and add the types to the scope\n-  stmt.variables_pattern->accept_vis (*this);\n-  for (auto it = letPatternBuffer.begin (); it != letPatternBuffer.end (); it++)\n-    {\n-      scope.Insert (it->variable_ident, inferedType);\n-    }\n-  letPatternBuffer.clear ();\n-}\n-\n-void\n-TypeResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n-{\n-  stmt.expr->accept_vis (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::ExprStmtWithBlock &stmt)\n-{}\n-\n-// rust-type.h\n-void\n-TypeResolution::visit (AST::TraitBound &bound)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ImplTraitType &type)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TraitObjectType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-TypeResolution::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-TypeResolution::visit (AST::TupleType &type)\n-{}\n-void\n-TypeResolution::visit (AST::NeverType &type)\n-{}\n-void\n-TypeResolution::visit (AST::RawPointerType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ReferenceType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ArrayType &type)\n-{}\n-void\n-TypeResolution::visit (AST::SliceType &type)\n-{}\n-void\n-TypeResolution::visit (AST::InferredType &type)\n-{}\n-void\n-TypeResolution::visit (AST::BareFunctionType &type)\n-{}\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "9eb4b95a6fcf31c5cb3ffd487639308938740831", "filename": "gcc/rust/analysis/rust-resolution.h", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-resolution.h?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,51 +0,0 @@\n-#pragma once\n-\n-#include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-#include \"rust-ast-visitor.h\"\n-#include \"rust-scan.h\"\n-#include \"scope.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class Resolution : public AST::ASTVisitor\n-{\n-public:\n-  virtual ~Resolution ()\n-  {\n-    scope.Pop ();\n-    valueScope.Pop ();\n-    macroScope.Pop ();\n-    typeScope.Pop ();\n-  };\n-\n-private:\n-  virtual bool go () = 0;\n-\n-protected:\n-  Resolution (AST::Crate &crate, TopLevelScan &toplevel)\n-    : crate (crate), toplevel (toplevel)\n-  {\n-    scope.Push ();\n-    valueScope.Push ();\n-    macroScope.Push ();\n-    typeScope.Push ();\n-  };\n-\n-  Scope<AST::Type *> scope;\n-  Scope<AST::Type *> valueScope;\n-  Scope<AST::Type *> macroScope;\n-  Scope<AST::Type *> typeScope;\n-\n-  AST::Crate &crate;\n-  TopLevelScan &toplevel;\n-\n-  std::vector<AST::IdentifierPattern> letPatternBuffer;\n-  std::vector<AST::Type *> typeBuffer;\n-  std::vector<std::string> typeComparisonBuffer;\n-  std::vector<AST::Function *> functionLookup;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "31c89e499f791da1cafdf41c4e447c21097561ba", "filename": "gcc/rust/analysis/rust-scan.cc", "status": "removed", "additions": 0, "deletions": 593, "changes": 593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-scan.cc?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,593 +0,0 @@\n-#include \"rust-scan.h\"\n-#include \"rust-diagnostics.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-TopLevelScan::TopLevelScan (AST::Crate &crate) : crate (crate)\n-{\n-  for (auto &item : crate.items)\n-    item->accept_vis (*this);\n-}\n-\n-TopLevelScan::~TopLevelScan () {}\n-\n-AST::Function *\n-TopLevelScan::lookupFunction (AST::Expr *expr)\n-{\n-  auto before = fnLookup.size ();\n-  expr->accept_vis (*this);\n-  if (fnLookup.size () > before)\n-    {\n-      AST::Function *fndecl = fnLookup.back ();\n-      fnLookup.pop_back ();\n-      return fndecl;\n-    }\n-  return NULL;\n-}\n-\n-void\n-TopLevelScan::visit (AST::Token &tok)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::IdentifierExpr &ident_expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-TopLevelScan::visit (AST::PathInExpression &path)\n-{\n-  auto it = functions.find (path.as_string ());\n-  bool foundFndecl = it != functions.end ();\n-  if (foundFndecl)\n-    {\n-      fnLookup.push_back (it->second);\n-      return;\n-    }\n-}\n-\n-void\n-TopLevelScan::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-TopLevelScan::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::TypePath &path)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::QualifiedPathInExpression &path)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::QualifiedPathInType &path)\n-{}\n-\n-// rust-expr.h\n-void\n-TopLevelScan::visit (AST::LiteralExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::NegationExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ComparisonExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::LazyBooleanExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::AssignmentExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::GroupedExpr &expr)\n-{}\n-// void TopLevelScan::visit(ArrayElems& elems) {}\n-void\n-TopLevelScan::visit (AST::ArrayElemsValues &elems)\n-{}\n-void\n-TopLevelScan::visit (AST::ArrayElemsCopied &elems)\n-{}\n-void\n-TopLevelScan::visit (AST::ArrayExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ArrayIndexExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleIndexExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprStruct &expr)\n-{}\n-// void TopLevelScan::visit(StructExprField& field) {}\n-void\n-TopLevelScan::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprFieldIdentifierValue &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprFieldIndexValue &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprStructFields &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::StructExprUnit &expr)\n-{}\n-// void TopLevelScan::visit(EnumExprField& field) {}\n-void\n-TopLevelScan::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::CallExpr &expr)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ClosureExprInner &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::BlockExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::BreakExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::RangeToInclExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ReturnExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::LoopExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::WhileLoopExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::ForLoopExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfExprConseqElse &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfExprConseqIf &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfExprConseqIfLet &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfLetExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfLetExprConseqElse &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfLetExprConseqIf &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::IfLetExprConseqIfLet &expr)\n-{}\n-// void TopLevelScan::visit(MatchCase& match_case) {}\n-/*void\n-TopLevelScan::visit (AST::MatchCaseBlockExpr &match_case)\n-{}*/\n-/*void\n-TopLevelScan::visit (AST::MatchCaseExpr &match_case)\n-{}*/\n-void\n-TopLevelScan::visit (AST::MatchExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-TopLevelScan::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-TopLevelScan::visit (AST::TypeParam &param)\n-{}\n-// void TopLevelScan::visit(WhereClauseItem& item) {}\n-void\n-TopLevelScan::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::Method &method)\n-{}\n-void\n-TopLevelScan::visit (AST::ModuleBodied &module)\n-{}\n-void\n-TopLevelScan::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-TopLevelScan::visit (AST::ExternCrate &crate)\n-{}\n-// void TopLevelScan::visit(UseTree& use_tree) {}\n-void\n-TopLevelScan::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-TopLevelScan::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-TopLevelScan::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-TopLevelScan::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::Function &function)\n-{\n-  functions[function.get_function_name ()] = &function;\n-}\n-\n-void\n-TopLevelScan::visit (AST::TypeAlias &type_alias)\n-{}\n-void\n-TopLevelScan::visit (AST::StructStruct &struct_item)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-TopLevelScan::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-TopLevelScan::visit (AST::Enum &enum_item)\n-{}\n-void\n-TopLevelScan::visit (AST::Union &union_item)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ConstantItem &const_item)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::StaticItem &static_item)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitItemConst &item)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitItemType &item)\n-{}\n-void\n-TopLevelScan::visit (AST::Trait &trait)\n-{}\n-void\n-TopLevelScan::visit (AST::InherentImpl &impl)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitImpl &impl)\n-{}\n-// void TopLevelScan::visit(ExternalItem& item) {}\n-void\n-TopLevelScan::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-TopLevelScan::visit (AST::ExternBlock &block)\n-{}\n-\n-// rust-macro.h\n-void\n-TopLevelScan::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-TopLevelScan::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-TopLevelScan::visit (AST::MacroMatcher &matcher)\n-{}\n-void\n-TopLevelScan::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-void\n-TopLevelScan::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-TopLevelScan::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n-\n-// rust-pattern.h\n-void\n-TopLevelScan::visit (AST::LiteralPattern &pattern)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::IdentifierPattern &pattern)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::WildcardPattern &pattern)\n-{}\n-// void TopLevelScan::visit(RangePatternBound& bound) {}\n-void\n-TopLevelScan::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-TopLevelScan::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-TopLevelScan::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-TopLevelScan::visit (AST::RangePattern &pattern)\n-{}\n-void\n-TopLevelScan::visit (AST::ReferencePattern &pattern)\n-{}\n-// void TopLevelScan::visit(StructPatternField& field) {}\n-void\n-TopLevelScan::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-TopLevelScan::visit (AST::StructPattern &pattern)\n-{}\n-// void TopLevelScan::visit(TupleStructItems& tuple_items) {}\n-void\n-TopLevelScan::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void TopLevelScan::visit(TuplePatternItems& tuple_items) {}\n-void\n-TopLevelScan::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-TopLevelScan::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-TopLevelScan::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-TopLevelScan::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-TopLevelScan::visit (AST::SlicePattern &pattern)\n-{}\n-\n-// rust-stmt.h\n-void\n-TopLevelScan::visit (AST::EmptyStmt &stmt)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::LetStmt &stmt)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ExprStmtWithoutBlock &stmt)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ExprStmtWithBlock &stmt)\n-{}\n-\n-// rust-type.h\n-void\n-TopLevelScan::visit (AST::TraitBound &bound)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::ImplTraitType &type)\n-{}\n-\n-void\n-TopLevelScan::visit (AST::TraitObjectType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-TopLevelScan::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-TopLevelScan::visit (AST::TupleType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::NeverType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::RawPointerType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::ReferenceType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::ArrayType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::SliceType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::InferredType &type)\n-{}\n-void\n-TopLevelScan::visit (AST::BareFunctionType &type)\n-{}\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "77beeca86a03e838094af284798475834c7254ce", "filename": "gcc/rust/analysis/rust-scan.h", "status": "removed", "additions": 0, "deletions": 233, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-scan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-scan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-scan.h?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,233 +0,0 @@\n-#pragma once\n-\n-#include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-#include \"rust-ast-visitor.h\"\n-#include \"scope.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class TopLevelScan : public AST::ASTVisitor\n-{\n-public:\n-  TopLevelScan (AST::Crate &crate);\n-\n-  ~TopLevelScan ();\n-\n-  AST::Function *lookupFunction (AST::Expr *expr);\n-\n-  // visitor impl\n-  // rust-ast.h\n-  // virtual void visit(AttrInput& attr_input);\n-  // virtual void visit(TokenTree& token_tree);\n-  // virtual void visit(MacroMatch& macro_match);\n-  virtual void visit (AST::Token &tok);\n-  virtual void visit (AST::DelimTokenTree &delim_tok_tree);\n-  virtual void visit (AST::AttrInputMetaItemContainer &input);\n-  // virtual void visit(MetaItem& meta_item);\n-  // virtual void vsit(Stmt& stmt);\n-  // virtual void visit(Expr& expr);\n-  virtual void visit (AST::IdentifierExpr &ident_expr);\n-  // virtual void visit(Pattern& pattern);\n-  // virtual void visit(Type& type);\n-  // virtual void visit(TypeParamBound& type_param_bound);\n-  virtual void visit (AST::Lifetime &lifetime);\n-  // virtual void visit(GenericParam& generic_param);\n-  virtual void visit (AST::LifetimeParam &lifetime_param);\n-  // virtual void visit(TraitItem& trait_item);\n-  // virtual void visit(InherentImplItem& inherent_impl_item);\n-  // virtual void visit(TraitImplItem& trait_impl_item);\n-  virtual void visit (AST::MacroInvocationSemi &macro);\n-\n-  // rust-path.h\n-  virtual void visit (AST::PathInExpression &path);\n-  virtual void visit (AST::TypePathSegment &segment);\n-  virtual void visit (AST::TypePathSegmentGeneric &segment);\n-  virtual void visit (AST::TypePathSegmentFunction &segment);\n-  virtual void visit (AST::TypePath &path);\n-  virtual void visit (AST::QualifiedPathInExpression &path);\n-  virtual void visit (AST::QualifiedPathInType &path);\n-\n-  // rust-expr.h\n-  virtual void visit (AST::LiteralExpr &expr);\n-  virtual void visit (AST::AttrInputLiteral &attr_input);\n-  virtual void visit (AST::MetaItemLitExpr &meta_item);\n-  virtual void visit (AST::MetaItemPathLit &meta_item);\n-  virtual void visit (AST::BorrowExpr &expr);\n-  virtual void visit (AST::DereferenceExpr &expr);\n-  virtual void visit (AST::ErrorPropagationExpr &expr);\n-  virtual void visit (AST::NegationExpr &expr);\n-  virtual void visit (AST::ArithmeticOrLogicalExpr &expr);\n-  virtual void visit (AST::ComparisonExpr &expr);\n-  virtual void visit (AST::LazyBooleanExpr &expr);\n-  virtual void visit (AST::TypeCastExpr &expr);\n-  virtual void visit (AST::AssignmentExpr &expr);\n-  virtual void visit (AST::CompoundAssignmentExpr &expr);\n-  virtual void visit (AST::GroupedExpr &expr);\n-  // virtual void visit(ArrayElems& elems);\n-  virtual void visit (AST::ArrayElemsValues &elems);\n-  virtual void visit (AST::ArrayElemsCopied &elems);\n-  virtual void visit (AST::ArrayExpr &expr);\n-  virtual void visit (AST::ArrayIndexExpr &expr);\n-  virtual void visit (AST::TupleExpr &expr);\n-  virtual void visit (AST::TupleIndexExpr &expr);\n-  virtual void visit (AST::StructExprStruct &expr);\n-  // virtual void visit(StructExprField& field);\n-  virtual void visit (AST::StructExprFieldIdentifier &field);\n-  virtual void visit (AST::StructExprFieldIdentifierValue &field);\n-  virtual void visit (AST::StructExprFieldIndexValue &field);\n-  virtual void visit (AST::StructExprStructFields &expr);\n-  virtual void visit (AST::StructExprStructBase &expr);\n-  virtual void visit (AST::StructExprTuple &expr);\n-  virtual void visit (AST::StructExprUnit &expr);\n-  // virtual void visit(EnumExprField& field);\n-  virtual void visit (AST::EnumExprFieldIdentifier &field);\n-  virtual void visit (AST::EnumExprFieldIdentifierValue &field);\n-  virtual void visit (AST::EnumExprFieldIndexValue &field);\n-  virtual void visit (AST::EnumExprStruct &expr);\n-  virtual void visit (AST::EnumExprTuple &expr);\n-  virtual void visit (AST::EnumExprFieldless &expr);\n-  virtual void visit (AST::CallExpr &expr);\n-  virtual void visit (AST::MethodCallExpr &expr);\n-  virtual void visit (AST::FieldAccessExpr &expr);\n-  virtual void visit (AST::ClosureExprInner &expr);\n-  virtual void visit (AST::BlockExpr &expr);\n-  virtual void visit (AST::ClosureExprInnerTyped &expr);\n-  virtual void visit (AST::ContinueExpr &expr);\n-  virtual void visit (AST::BreakExpr &expr);\n-  virtual void visit (AST::RangeFromToExpr &expr);\n-  virtual void visit (AST::RangeFromExpr &expr);\n-  virtual void visit (AST::RangeToExpr &expr);\n-  virtual void visit (AST::RangeFullExpr &expr);\n-  virtual void visit (AST::RangeFromToInclExpr &expr);\n-  virtual void visit (AST::RangeToInclExpr &expr);\n-  virtual void visit (AST::ReturnExpr &expr);\n-  virtual void visit (AST::UnsafeBlockExpr &expr);\n-  virtual void visit (AST::LoopExpr &expr);\n-  virtual void visit (AST::WhileLoopExpr &expr);\n-  virtual void visit (AST::WhileLetLoopExpr &expr);\n-  virtual void visit (AST::ForLoopExpr &expr);\n-  virtual void visit (AST::IfExpr &expr);\n-  virtual void visit (AST::IfExprConseqElse &expr);\n-  virtual void visit (AST::IfExprConseqIf &expr);\n-  virtual void visit (AST::IfExprConseqIfLet &expr);\n-  virtual void visit (AST::IfLetExpr &expr);\n-  virtual void visit (AST::IfLetExprConseqElse &expr);\n-  virtual void visit (AST::IfLetExprConseqIf &expr);\n-  virtual void visit (AST::IfLetExprConseqIfLet &expr);\n-  // virtual void visit(MatchCase& match_case);\n-  // virtual void visit (AST::MatchCaseBlockExpr &match_case);\n-  // virtual void visit (AST::MatchCaseExpr &match_case);\n-  virtual void visit (AST::MatchExpr &expr);\n-  virtual void visit (AST::AwaitExpr &expr);\n-  virtual void visit (AST::AsyncBlockExpr &expr);\n-\n-  // rust-item.h\n-  virtual void visit (AST::TypeParam &param);\n-  // virtual void visit(WhereClauseItem& item);\n-  virtual void visit (AST::LifetimeWhereClauseItem &item);\n-  virtual void visit (AST::TypeBoundWhereClauseItem &item);\n-  virtual void visit (AST::Method &method);\n-  virtual void visit (AST::ModuleBodied &module);\n-  virtual void visit (AST::ModuleNoBody &module);\n-  virtual void visit (AST::ExternCrate &crate);\n-  // virtual void visit(UseTree& use_tree);\n-  virtual void visit (AST::UseTreeGlob &use_tree);\n-  virtual void visit (AST::UseTreeList &use_tree);\n-  virtual void visit (AST::UseTreeRebind &use_tree);\n-  virtual void visit (AST::UseDeclaration &use_decl);\n-  virtual void visit (AST::Function &function);\n-  virtual void visit (AST::TypeAlias &type_alias);\n-  virtual void visit (AST::StructStruct &struct_item);\n-  virtual void visit (AST::TupleStruct &tuple_struct);\n-  virtual void visit (AST::EnumItem &item);\n-  virtual void visit (AST::EnumItemTuple &item);\n-  virtual void visit (AST::EnumItemStruct &item);\n-  virtual void visit (AST::EnumItemDiscriminant &item);\n-  virtual void visit (AST::Enum &enum_item);\n-  virtual void visit (AST::Union &union_item);\n-  virtual void visit (AST::ConstantItem &const_item);\n-  virtual void visit (AST::StaticItem &static_item);\n-  virtual void visit (AST::TraitItemFunc &item);\n-  virtual void visit (AST::TraitItemMethod &item);\n-  virtual void visit (AST::TraitItemConst &item);\n-  virtual void visit (AST::TraitItemType &item);\n-  virtual void visit (AST::Trait &trait);\n-  virtual void visit (AST::InherentImpl &impl);\n-  virtual void visit (AST::TraitImpl &impl);\n-  // virtual void visit(ExternalItem& item);\n-  virtual void visit (AST::ExternalStaticItem &item);\n-  virtual void visit (AST::ExternalFunctionItem &item);\n-  virtual void visit (AST::ExternBlock &block);\n-\n-  // rust-macro.h\n-  virtual void visit (AST::MacroMatchFragment &match);\n-  virtual void visit (AST::MacroMatchRepetition &match);\n-  virtual void visit (AST::MacroMatcher &matcher);\n-  virtual void visit (AST::MacroRulesDefinition &rules_def);\n-  virtual void visit (AST::MacroInvocation &macro_invoc);\n-  virtual void visit (AST::MetaItemPath &meta_item);\n-  virtual void visit (AST::MetaItemSeq &meta_item);\n-  virtual void visit (AST::MetaWord &meta_item);\n-  virtual void visit (AST::MetaNameValueStr &meta_item);\n-  virtual void visit (AST::MetaListPaths &meta_item);\n-  virtual void visit (AST::MetaListNameValueStr &meta_item);\n-\n-  // rust-pattern.h\n-  virtual void visit (AST::LiteralPattern &pattern);\n-  virtual void visit (AST::IdentifierPattern &pattern);\n-  virtual void visit (AST::WildcardPattern &pattern);\n-  // virtual void visit(RangePatternBound& bound);\n-  virtual void visit (AST::RangePatternBoundLiteral &bound);\n-  virtual void visit (AST::RangePatternBoundPath &bound);\n-  virtual void visit (AST::RangePatternBoundQualPath &bound);\n-  virtual void visit (AST::RangePattern &pattern);\n-  virtual void visit (AST::ReferencePattern &pattern);\n-  // virtual void visit(StructPatternField& field);\n-  virtual void visit (AST::StructPatternFieldTuplePat &field);\n-  virtual void visit (AST::StructPatternFieldIdentPat &field);\n-  virtual void visit (AST::StructPatternFieldIdent &field);\n-  virtual void visit (AST::StructPattern &pattern);\n-  // virtual void visit(TupleStructItems& tuple_items);\n-  virtual void visit (AST::TupleStructItemsNoRange &tuple_items);\n-  virtual void visit (AST::TupleStructItemsRange &tuple_items);\n-  virtual void visit (AST::TupleStructPattern &pattern);\n-  // virtual void visit(TuplePatternItems& tuple_items);\n-  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items);\n-  virtual void visit (AST::TuplePatternItemsRanged &tuple_items);\n-  virtual void visit (AST::TuplePattern &pattern);\n-  virtual void visit (AST::GroupedPattern &pattern);\n-  virtual void visit (AST::SlicePattern &pattern);\n-\n-  // rust-stmt.h\n-  virtual void visit (AST::EmptyStmt &stmt);\n-  virtual void visit (AST::LetStmt &stmt);\n-  virtual void visit (AST::ExprStmtWithoutBlock &stmt);\n-  virtual void visit (AST::ExprStmtWithBlock &stmt);\n-\n-  // rust-type.h\n-  virtual void visit (AST::TraitBound &bound);\n-  virtual void visit (AST::ImplTraitType &type);\n-  virtual void visit (AST::TraitObjectType &type);\n-  virtual void visit (AST::ParenthesisedType &type);\n-  virtual void visit (AST::ImplTraitTypeOneBound &type);\n-  virtual void visit (AST::TraitObjectTypeOneBound &type);\n-  virtual void visit (AST::TupleType &type);\n-  virtual void visit (AST::NeverType &type);\n-  virtual void visit (AST::RawPointerType &type);\n-  virtual void visit (AST::ReferenceType &type);\n-  virtual void visit (AST::ArrayType &type);\n-  virtual void visit (AST::SliceType &type);\n-  virtual void visit (AST::InferredType &type);\n-  virtual void visit (AST::BareFunctionType &type);\n-\n-private:\n-  std::map<std::string, AST::Function *> functions;\n-  AST::Crate &crate;\n-\n-  std::vector<AST::Function *> fnLookup;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "f1edec822b7258dafee2a34a2a7203e5b44ca783", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "removed", "additions": 0, "deletions": 1348, "changes": 1348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,1348 +0,0 @@\n-#include \"rust-type-resolution.h\"\n-#include \"rust-diagnostics.h\"\n-#include \"rust-type-visitor.h\"\n-\n-#define ADD_BUILTIN_TYPE(_X, _S)                                               \\\n-  do                                                                           \\\n-    {                                                                          \\\n-      AST::PathIdentSegment seg (_X);                                          \\\n-      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n-\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n-\t\t\t\t  Linemap::predeclared_location ()));          \\\n-      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n-      segs.push_back (::std::move (typePath));                                 \\\n-      auto bType                                                               \\\n-\t= new AST::TypePath (::std::move (segs),                               \\\n-\t\t\t     Linemap::predeclared_location (), false);         \\\n-      _S.InsertType (_X, bType);                                               \\\n-    }                                                                          \\\n-  while (0)\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-TypeResolution::TypeResolution (AST::Crate &crate, TopLevelScan &toplevel)\n-  : Resolution (crate, toplevel)\n-{\n-  scope.Push ();\n-\n-  // push all builtin types - this is probably too basic for future needs\n-  ADD_BUILTIN_TYPE (\"u8\", scope);\n-  ADD_BUILTIN_TYPE (\"u16\", scope);\n-  ADD_BUILTIN_TYPE (\"u32\", scope);\n-  ADD_BUILTIN_TYPE (\"u64\", scope);\n-\n-  ADD_BUILTIN_TYPE (\"i8\", scope);\n-  ADD_BUILTIN_TYPE (\"i16\", scope);\n-  ADD_BUILTIN_TYPE (\"i32\", scope);\n-  ADD_BUILTIN_TYPE (\"i64\", scope);\n-\n-  ADD_BUILTIN_TYPE (\"f32\", scope);\n-  ADD_BUILTIN_TYPE (\"f64\", scope);\n-\n-  ADD_BUILTIN_TYPE (\"char\", scope);\n-  ADD_BUILTIN_TYPE (\"str\", scope);\n-  ADD_BUILTIN_TYPE (\"bool\", scope);\n-\n-  // now its the crate scope\n-  scope.Push ();\n-}\n-\n-TypeResolution::~TypeResolution ()\n-{\n-  scope.Pop (); // crate\n-  scope.Pop (); // builtins\n-}\n-\n-bool\n-TypeResolution::Resolve (AST::Crate &crate, TopLevelScan &toplevel)\n-{\n-  TypeResolution resolver (crate, toplevel);\n-  return resolver.go ();\n-}\n-\n-bool\n-TypeResolution::go ()\n-{\n-  for (auto &item : crate.items)\n-    item->accept_vis (*this);\n-\n-  return true;\n-}\n-\n-bool\n-TypeResolution::typesAreCompatible (AST::Type *lhs, AST::Type *rhs,\n-\t\t\t\t    Location locus)\n-{\n-  auto before = typeComparisonBuffer.size ();\n-  lhs->accept_vis (*this);\n-  if (typeComparisonBuffer.size () <= before)\n-    {\n-      rust_error_at (locus, \"failed to understand type for lhs\");\n-      return false;\n-    }\n-\n-  auto lhsTypeStr = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-\n-  rhs->accept_vis (*this);\n-  if (typeComparisonBuffer.size () <= before)\n-    {\n-      rust_error_at (locus, \"failed to understand type for rhs\");\n-      return false;\n-    }\n-\n-  auto rhsTypeStr = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-\n-  // FIXME this needs to handle the cases of an i8 going into an i32 which is\n-  // compatible\n-  if (lhsTypeStr.compare (rhsTypeStr))\n-    {\n-      rust_error_at (locus, \"E0308: expected: %s, found %s\",\n-\t\t     lhsTypeStr.c_str (), rhsTypeStr.c_str ());\n-      return false;\n-    }\n-\n-  AST::Type *val = NULL;\n-  if (!scope.LookupType (lhsTypeStr, &val))\n-    {\n-      rust_error_at (locus, \"Unknown type: %s\", lhsTypeStr.c_str ());\n-      return false;\n-    }\n-\n-  return true;\n-}\n-\n-bool\n-TypeResolution::isTypeInScope (AST::Type *type, Location locus)\n-{\n-  auto before = typeComparisonBuffer.size ();\n-  type->accept_vis (*this);\n-  if (typeComparisonBuffer.size () <= before)\n-    {\n-      rust_error_at (locus, \"unable to decipher type: %s\",\n-\t\t     type->as_string ().c_str ());\n-      return false;\n-    }\n-\n-  auto t = typeComparisonBuffer.back ();\n-  typeComparisonBuffer.pop_back ();\n-\n-  AST::Type *val = NULL;\n-  return scope.LookupType (t, &val);\n-}\n-\n-AST::Function *\n-TypeResolution::lookupFndecl (AST::Expr *expr)\n-{\n-  size_t before = functionLookup.size ();\n-  expr->accept_vis (*this);\n-  if (functionLookup.size () > before)\n-    {\n-      auto fndecl = functionLookup.back ();\n-      functionLookup.pop_back ();\n-      return fndecl;\n-    }\n-\n-  rust_error_at (expr->get_locus_slow (), \"failed to lookup function\");\n-  return NULL;\n-}\n-\n-void\n-TypeResolution::visit (AST::Token &tok)\n-{}\n-\n-void\n-TypeResolution::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-TypeResolution::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-TypeResolution::visit (AST::IdentifierExpr &ident_expr)\n-{\n-  AST::Type *type = NULL;\n-  bool ok = scope.LookupType (ident_expr.get_ident (), &type);\n-  if (!ok)\n-    {\n-      rust_error_at (ident_expr.get_locus (), \"unknown identifier\");\n-      return;\n-    }\n-\n-  typeBuffer.push_back (type);\n-}\n-\n-void\n-TypeResolution::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-TypeResolution::visit (AST::PathInExpression &path)\n-{\n-  // look up in the functionScope else lookup in the toplevel scan\n-  AST::Function *fndecl = NULL;\n-  if (scope.LookupFunction (path.as_string (), &fndecl))\n-    {\n-      functionLookup.push_back (fndecl);\n-      return;\n-    }\n-\n-  fndecl = toplevel.lookupFunction (&path);\n-  if (fndecl != NULL)\n-    {\n-      functionLookup.push_back (fndecl);\n-      return;\n-    }\n-}\n-\n-void\n-TypeResolution::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-TypeResolution::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypePath &path)\n-{\n-  // this may not be robust enough for type comparisons but lets try it for now\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::QualifiedPathInExpression &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::QualifiedPathInType &path)\n-{\n-  typeComparisonBuffer.push_back (path.as_string ());\n-}\n-\n-// rust-expr.h\n-void\n-TypeResolution::visit (AST::LiteralExpr &expr)\n-{\n-  std::string type;\n-  switch (expr.get_lit_type ())\n-    {\n-    case AST::Literal::CHAR:\n-      type = \"char\";\n-      break;\n-\n-    case AST::Literal::STRING:\n-    case AST::Literal::RAW_STRING:\n-      type = \"str\";\n-      break;\n-\n-    case AST::Literal::BOOL:\n-      type = \"bool\";\n-      break;\n-\n-    case AST::Literal::BYTE:\n-      type = \"u8\";\n-      break;\n-\n-      // FIXME these are not always going to be the case\n-      // eg: suffix on the value can change the type\n-    case AST::Literal::FLOAT:\n-      type = \"f32\";\n-      break;\n-\n-    case AST::Literal::INT:\n-      type = \"i32\";\n-      break;\n-\n-    case AST::Literal::BYTE_STRING:\n-    case AST::Literal::RAW_BYTE_STRING:\n-      // FIXME\n-      break;\n-    }\n-\n-  if (type.empty ())\n-    {\n-      rust_error_at (expr.get_locus (), \"unknown literal: %s\",\n-\t\t     expr.get_literal ().as_string ().c_str ());\n-      return;\n-    }\n-\n-  AST::Type *val = NULL;\n-  bool ok = scope.LookupType (type, &val);\n-  if (ok)\n-    typeBuffer.push_back (val);\n-  else\n-    rust_error_at (expr.get_locus (), \"unknown literal type: %s\", type.c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::NegationExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{\n-  size_t before;\n-  before = typeBuffer.size ();\n-  expr.visit_lhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus (), \"unable to determine lhs type\");\n-      return;\n-    }\n-\n-  auto lhsType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.visit_rhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus (), \"unable to determine rhs type\");\n-      return;\n-    }\n-\n-  auto rhsType = typeBuffer.back ();\n-  // not poping because we will be checking they match and the\n-  // scope will require knowledge of the type\n-\n-  // do the lhsType and the rhsType match\n-  typesAreCompatible (lhsType, rhsType, expr.get_right_expr ()->get_locus_slow ());\n-}\n-\n-void\n-TypeResolution::visit (AST::ComparisonExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LazyBooleanExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::AssignmentExpr &expr)\n-{\n-  size_t before;\n-  before = typeBuffer.size ();\n-  expr.visit_lhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus (), \"unable to determine lhs type\");\n-      return;\n-    }\n-\n-  auto lhsType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.visit_rhs (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus (), \"unable to determine rhs type\");\n-      return;\n-    }\n-\n-  auto rhsType = typeBuffer.back ();\n-  // not poping because we will be checking they match and the\n-  // scope will require knowledge of the type\n-\n-  // do the lhsType and the rhsType match\n-  if (!typesAreCompatible (lhsType, rhsType,\n-\t\t\t   expr.get_right_expr ()->get_locus_slow ()))\n-    return;\n-\n-  // is the lhs mutable?\n-}\n-\n-void\n-TypeResolution::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::GroupedExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ArrayElemsValues &elems)\n-{\n-  // we need to generate the AST::ArrayType for this array init_expression\n-  // we can get the size via get_num_values() but we need to ensure each element\n-  // are type compatible\n-\n-  bool failed = false;\n-  AST::Type *last_inferred_type = nullptr;\n-  elems.iterate ([&] (AST::Expr *expr) mutable -> bool {\n-    size_t before;\n-    before = typeBuffer.size ();\n-    expr->accept_vis (*this);\n-    if (typeBuffer.size () <= before)\n-      {\n-\trust_error_at (expr->get_locus_slow (),\n-\t\t       \"unable to determine element type\");\n-\treturn false;\n-      }\n-\n-    AST::Type *inferedType = typeBuffer.back ();\n-    typeBuffer.pop_back ();\n-\n-    if (last_inferred_type == nullptr)\n-      last_inferred_type = inferedType;\n-    else\n-      {\n-\tif (!typesAreCompatible (last_inferred_type, inferedType,\n-\t\t\t\t expr->get_locus_slow ()))\n-\t  {\n-\t    failed = true;\n-\t    return false;\n-\t  }\n-      }\n-\n-    return true;\n-  });\n-\n-  // nothing to do when its failed\n-  if (failed)\n-    return;\n-\n-  // FIXME This will leak\n-  auto capacity\n-    = new AST::LiteralExpr (std::to_string (elems.get_num_values ()),\n-\t\t\t    AST::Literal::INT,\n-\t\t\t    Linemap::predeclared_location ());\n-  auto arrayType = new AST::ArrayType (last_inferred_type->clone_type (),\n-\t\t\t\t       std::unique_ptr<AST::Expr> (capacity),\n-\t\t\t\t       Linemap::predeclared_location ());\n-  typeBuffer.push_back (arrayType);\n-}\n-\n-void\n-TypeResolution::visit (AST::ArrayElemsCopied &elems)\n-{\n-  printf (\"ArrayElemsCopied: %s\\n\", elems.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::ArrayExpr &expr)\n-{\n-  auto& elements = expr.get_array_elems ();\n-\n-  auto before = typeBuffer.size ();\n-  elements->accept_vis (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"unable to determine type for ArrayExpr\");\n-      return;\n-    }\n-\n-  expr.set_inferred_type (typeBuffer.back ());\n-}\n-\n-void\n-TypeResolution::visit (AST::ArrayIndexExpr &expr)\n-{\n-  auto before = typeBuffer.size ();\n-  expr.get_array_expr ()->accept_vis (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"unable to determine type for array index expression\");\n-      return;\n-    }\n-  AST::Type *array_expr_type = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  before = typeBuffer.size ();\n-  expr.get_index_expr ()->accept_vis (*this);\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_index_expr ()->get_locus_slow (),\n-\t\t     \"unable to determine type for index expression\");\n-      return;\n-    }\n-\n-  AST::Type *array_index_type = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  // check the index_type should be an i32 which should really be\n-  // more permissive\n-  AST::Type *i32 = nullptr;\n-  scope.LookupType (\"i32\", &i32);\n-  rust_assert (i32 != nullptr);\n-\n-  if (!typesAreCompatible (array_index_type, i32,\n-\t\t\t   expr.get_index_expr ()->get_locus_slow ()))\n-    {\n-      return;\n-    }\n-\n-  // the the element type from the array_expr_type and it _must_ be an array\n-  AST::ArrayType *resolved = ArrayTypeVisitor::Resolve (array_expr_type);\n-  if (resolved == nullptr)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"unable to resolve type for array expression\");\n-      return;\n-    }\n-\n-  typeBuffer.push_back (resolved->get_elem_type ().get ());\n-}\n-\n-void\n-TypeResolution::visit (AST::TupleExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::TupleIndexExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::StructExprStruct &expr)\n-{}\n-\n-// void TypeResolution::visit(StructExprField& field) {}\n-void\n-TypeResolution::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-\n-void\n-TypeResolution::visit (AST::StructExprFieldIdentifierValue &field)\n-{\n-  identifierBuffer = std::unique_ptr<std::string> (new std::string (field.get_field_name ()));\n-  field.get_value ()->accept_vis (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::StructExprFieldIndexValue &field)\n-{\n-  tupleIndexBuffer = std::unique_ptr<int> (new int (field.get_index ()));\n-  field.get_value ()->accept_vis (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::StructExprStructFields &expr)\n-{\n-  AST::StructStruct *decl = NULL;\n-  if (!scope.LookupStruct (expr.get_struct_name ().as_string (), &decl))\n-    {\n-      rust_error_at (expr.get_locus_slow (), \"unknown type\");\n-      return;\n-    }\n-\n-  for (auto &field : expr.get_fields ())\n-    {\n-      identifierBuffer = NULL;\n-      tupleIndexBuffer = NULL;\n-\n-      auto before = typeBuffer.size ();\n-      field->accept_vis (*this);\n-      if (typeBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (expr.get_locus_slow (),\n-\t\t\t \"unable to determine type for field\");\n-\t  return;\n-\t}\n-\n-      auto inferedType = typeBuffer.back ();\n-      typeBuffer.pop_back ();\n-\n-      // do we have a name for this\n-      if (identifierBuffer != NULL)\n-\t{\n-\t  AST::StructField *declField = NULL;\n-\t  for (auto &df : decl->get_fields ())\n-\t    {\n-\t      if (identifierBuffer->compare (df.get_field_name ()) == 0)\n-\t\t{\n-\t\t  declField = &df;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  identifierBuffer = NULL;\n-\n-\t  if (declField == NULL)\n-\t    {\n-\t      rust_error_at (expr.get_locus_slow (), \"unknown field\");\n-\t      return;\n-\t    }\n-\n-\t  if (!typesAreCompatible (declField->get_field_type ().get (), inferedType,\n-\t\t\t\t   expr.get_locus_slow ()))\n-\t    return;\n-\t}\n-      // do we have an index for this\n-      else if (tupleIndexBuffer != NULL)\n-\t{\n-\t  AST::StructField *declField = NULL;\n-\t  if (*tupleIndexBuffer < decl->get_fields ().size ())\n-\t    {\n-\t      declField = &decl->get_fields ()[*tupleIndexBuffer];\n-\t    }\n-\t  tupleIndexBuffer = NULL;\n-\n-\t  if (declField == NULL)\n-\t    {\n-\t      rust_error_at (expr.get_locus_slow (), \"unknown field at index\");\n-\t      return;\n-\t    }\n-\n-\t  if (!typesAreCompatible (declField->get_field_type ().get (), inferedType,\n-\t\t\t\t   expr.get_locus_slow ()))\n-\t    return;\n-\t}\n-      else\n-\t{\n-\t  rust_fatal_error (expr.get_locus_slow (), \"unknown field initialise\");\n-\t  return;\n-\t}\n-    }\n-\n-  // need to correct the ordering with the respect to the struct definition and\n-  // ensure we handle missing values and give them defaults\n-  // FIXME\n-\n-  // setup a path in type\n-  AST::PathIdentSegment seg (expr.get_struct_name ().as_string ());\n-  auto typePath = ::std::unique_ptr<AST::TypePathSegment> (\n-    new AST::TypePathSegment (::std::move (seg), false,\n-\t\t\t      expr.get_locus_slow ()));\n-  ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;\n-  segs.push_back (::std::move (typePath));\n-  auto bType\n-    = new AST::TypePath (::std::move (segs), expr.get_locus_slow (), false);\n-  typeBuffer.push_back (bType);\n-}\n-\n-void\n-TypeResolution::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-TypeResolution::visit (AST::StructExprUnit &expr)\n-{}\n-// void TypeResolution::visit(EnumExprField& field) {}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-TypeResolution::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::CallExpr &expr)\n-{\n-  // this look up should probably be moved to name resolution\n-  auto fndecl = lookupFndecl (expr.get_function_expr ().get ());\n-  if (fndecl == NULL)\n-    return;\n-\n-  // check num args match\n-  if (fndecl->get_function_params ().size () != expr.get_params ().size ())\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"differing number of arguments vs parameters to function\");\n-      return;\n-    }\n-\n-  typeBuffer.push_back (fndecl->get_return_type ().get ());\n-  expr.fndeclRef = fndecl;\n-\n-  auto before = typeBuffer.size ();\n-  for (auto &item : expr.get_params ())\n-    item->accept_vis (*this);\n-\n-  auto numInferedParams = typeBuffer.size () - before;\n-  if (numInferedParams != expr.get_params ().size ())\n-    {\n-      rust_error_at (expr.get_locus (), \"Failed to infer all parameters\");\n-      return;\n-    }\n-\n-  auto offs = numInferedParams - 1;\n-  for (auto it = fndecl->get_function_params ().rbegin ();\n-       it != fndecl->get_function_params ().rend (); ++it)\n-    {\n-      AST::Type *argument = typeBuffer.back ();\n-      typeBuffer.pop_back ();\n-\n-      if (!typesAreCompatible (it->get_type ().get (), argument,\n-\t\t\t       expr.get_params ()[offs]->get_locus_slow ()))\n-\treturn;\n-      offs--;\n-    }\n-}\n-\n-void\n-TypeResolution::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ClosureExprInner &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::BlockExpr &expr)\n-{\n-  scope.Push ();\n-  for (auto &stmt : expr.get_statements ())\n-    {\n-      stmt->accept_vis (*this);\n-    }\n-  scope.Pop ();\n-}\n-\n-void\n-TypeResolution::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::BreakExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::RangeToInclExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ReturnExpr &expr)\n-{\n-  // Ensure the type of this matches the function\n-  auto before = typeBuffer.size ();\n-  expr.get_returned_expr ()->accept_vis (*this);\n-\n-  if (typeBuffer.size () <= before)\n-    {\n-      rust_error_at (expr.get_returned_expr ()->get_locus_slow (),\n-\t\t     \"unable to determine type for return expr\");\n-      return;\n-    }\n-\n-  auto inferedType = typeBuffer.back ();\n-  typeBuffer.pop_back ();\n-\n-  // check this is compatible with the return type\n-  // this will again have issues with structs before we move to HIR\n-\n-  auto function = scope.CurrentFunction ();\n-  if (!function->has_return_type ())\n-    {\n-      rust_error_at (expr.get_locus (), \"return for void function %s\",\n-\t\t     function->as_string ().c_str ());\n-      return;\n-    }\n-\n-  if (!typesAreCompatible (function->get_return_type ().get (), inferedType,\n-\t\t\t   expr.get_locus_slow ()))\n-    {\n-      return;\n-    }\n-}\n-\n-void\n-TypeResolution::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::LoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::WhileLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::ForLoopExpr &expr)\n-{}\n-\n-void\n-TypeResolution::visit (AST::IfExpr &expr)\n-{\n-  expr.vis_if_block (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::IfExprConseqElse &expr)\n-{\n-  expr.vis_if_block (*this);\n-  expr.vis_else_block (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::IfExprConseqIf &expr)\n-{\n-  expr.vis_if_block (*this);\n-  expr.vis_conseq_if_expr (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::IfExprConseqIfLet &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqElse &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqIf &expr)\n-{}\n-void\n-TypeResolution::visit (AST::IfLetExprConseqIfLet &expr)\n-{}\n-// void TypeResolution::visit(MatchCase& match_case) {}\n-/*void\n-TypeResolution::visit (AST::MatchCaseBlockExpr &match_case)\n-{}*/\n-/*void\n-TypeResolution::visit (AST::MatchCaseExpr &match_case)\n-{}*/\n-void\n-TypeResolution::visit (AST::MatchExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-TypeResolution::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-TypeResolution::visit (AST::TypeParam &param)\n-{}\n-// void TypeResolution::visit(WhereClauseItem& item) {}\n-void\n-TypeResolution::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::Method &method)\n-{}\n-void\n-TypeResolution::visit (AST::ModuleBodied &module)\n-{}\n-void\n-TypeResolution::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-TypeResolution::visit (AST::ExternCrate &crate)\n-{}\n-// void TypeResolution::visit(UseTree& use_tree) {}\n-void\n-TypeResolution::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-TypeResolution::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-TypeResolution::visit (AST::Function &function)\n-{\n-  // always emit the function with return type in the event of nil return type\n-  // its  a marker for a void function\n-  scope.InsertType (function.get_function_name (), function.get_return_type ().get ());\n-  scope.InsertFunction (function.get_function_name (), &function);\n-  scope.PushFunction (&function);\n-  scope.Push ();\n-\n-  for (auto &param : function.get_function_params ())\n-    {\n-      if (!isTypeInScope (param.get_type ().get (), param.get_locus ()))\n-\t{\n-\t  scope.Pop ();\n-\t  scope.PopFunction ();\n-\t  return;\n-\t}\n-\n-      auto before = letPatternBuffer.size ();\n-      param.get_pattern ()->accept_vis (*this);\n-      if (letPatternBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n-\n-\t  scope.Pop ();\n-\t  scope.PopFunction ();\n-\t  return;\n-\t}\n-\n-      auto paramName = letPatternBuffer.back ();\n-      letPatternBuffer.pop_back ();\n-      scope.InsertType (paramName.get_ident (), param.get_type ().get ());\n-    }\n-\n-  // ensure the return type is resolved\n-  if (function.has_return_type ())\n-    {\n-      if (!isTypeInScope (function.get_return_type ().get (), function.get_locus ()))\n-\t{\n-\t  scope.Pop ();\n-\t  scope.PopFunction ();\n-\t  return;\n-\t}\n-    }\n-\n-  // walk the expression body\n-  for (auto &stmt : function.get_definition ()->get_statements ())\n-    {\n-      stmt->accept_vis (*this);\n-    }\n-\n-  auto localMap = scope.PeekLocals ();\n-  for (auto &[_, value] : localMap)\n-    function.locals.push_back (value);\n-\n-  scope.Pop ();\n-  scope.PopFunction ();\n-}\n-\n-void\n-TypeResolution::visit (AST::TypeAlias &type_alias)\n-{}\n-\n-void\n-TypeResolution::visit (AST::StructStruct &struct_item)\n-{\n-  for (auto &field : struct_item.get_fields ())\n-    {\n-      if (!isTypeInScope (field.get_field_type ().get (),\n-\t\t\t  Linemap::unknown_location ()))\n-\t{\n-\t  rust_fatal_error (Linemap::unknown_location (),\n-\t\t\t    \"unknown type in struct field\");\n-\t  return;\n-\t}\n-    }\n-\n-  scope.InsertStruct (struct_item.get_struct_name (), &struct_item);\n-}\n-\n-void\n-TypeResolution::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-TypeResolution::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-TypeResolution::visit (AST::Enum &enum_item)\n-{}\n-void\n-TypeResolution::visit (AST::Union &union_item)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ConstantItem &const_item)\n-{\n-  printf (\"ConstantItem: %s\\n\", const_item.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::StaticItem &static_item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemConst &item)\n-{}\n-void\n-TypeResolution::visit (AST::TraitItemType &item)\n-{}\n-void\n-TypeResolution::visit (AST::Trait &trait)\n-{}\n-void\n-TypeResolution::visit (AST::InherentImpl &impl)\n-{}\n-void\n-TypeResolution::visit (AST::TraitImpl &impl)\n-{}\n-// void TypeResolution::visit(ExternalItem& item) {}\n-void\n-TypeResolution::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-TypeResolution::visit (AST::ExternBlock &block)\n-{}\n-\n-// rust-macro.h\n-void\n-TypeResolution::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-TypeResolution::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-TypeResolution::visit (AST::MacroMatcher &matcher)\n-{}\n-void\n-TypeResolution::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-void\n-TypeResolution::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-TypeResolution::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-TypeResolution::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n-\n-// rust-pattern.h\n-void\n-TypeResolution::visit (AST::LiteralPattern &pattern)\n-{\n-  printf (\"LiteralPattern: %s\\n\", pattern.as_string ().c_str ());\n-}\n-\n-void\n-TypeResolution::visit (AST::IdentifierPattern &pattern)\n-{\n-  letPatternBuffer.push_back (pattern);\n-}\n-\n-void\n-TypeResolution::visit (AST::WildcardPattern &pattern)\n-{}\n-// void TypeResolution::visit(RangePatternBound& bound) {}\n-void\n-TypeResolution::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-TypeResolution::visit (AST::RangePattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::ReferencePattern &pattern)\n-{}\n-// void TypeResolution::visit(StructPatternField& field) {}\n-void\n-TypeResolution::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-TypeResolution::visit (AST::StructPattern &pattern)\n-{}\n-// void TypeResolution::visit(TupleStructItems& tuple_items) {}\n-void\n-TypeResolution::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void TypeResolution::visit(TuplePatternItems& tuple_items) {}\n-void\n-TypeResolution::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-TypeResolution::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-TypeResolution::visit (AST::SlicePattern &pattern)\n-{}\n-\n-// rust-stmt.h\n-void\n-TypeResolution::visit (AST::EmptyStmt &stmt)\n-{}\n-\n-void\n-TypeResolution::visit (AST::LetStmt &stmt)\n-{\n-  scope.InsertLocal (stmt.as_string (), &stmt);\n-  if (!stmt.has_init_expr () && !stmt.has_type ())\n-    {\n-      rust_error_at (stmt.get_locus (),\n-\t\t     \"E0282: type annotations or init expression needed\");\n-      return;\n-    }\n-\n-  AST::Type *inferedType = nullptr;\n-  if (stmt.has_init_expr ())\n-    {\n-      auto before = typeBuffer.size ();\n-      stmt.get_init_expr ()->accept_vis (*this);\n-\n-      if (typeBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (\n-\t    stmt.get_init_expr ()->get_locus_slow (),\n-\t    \"unable to determine type for declaration from init expr\");\n-\t  return;\n-\t}\n-\n-      inferedType = typeBuffer.back ();\n-      typeBuffer.pop_back ();\n-\n-      if (inferedType == NULL)\n-\t{\n-\t  rust_error_at (stmt.get_init_expr ()->get_locus_slow (),\n-\t\t\t \"void type found for statement initialisation\");\n-\t  return;\n-\t}\n-    }\n-\n-  if (stmt.has_type () && stmt.has_init_expr ())\n-    {\n-      if (!typesAreCompatible (stmt.get_type ().get (), inferedType,\n-\t\t\t       stmt.get_init_expr ()->get_locus_slow ()))\n-\t{\n-\t  return;\n-\t}\n-    }\n-  else if (stmt.has_type ())\n-    {\n-      auto before = typeComparisonBuffer.size ();\n-      stmt.get_type ()->accept_vis (*this);\n-      if (typeComparisonBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (stmt.get_locus (), \"failed to understand type for lhs\");\n-\t  return;\n-\t}\n-      auto typeString = typeComparisonBuffer.back ();\n-      typeComparisonBuffer.pop_back ();\n-\n-      // AST::Type *val = NULL;\n-      // if (!scope.LookupType (typeString, &val))\n-      //   {\n-      //     rust_error_at (stmt.locus, \"LetStmt has unknown type: %s\",\n-      //   \t\t stmt.type->as_string ().c_str ());\n-      //     return;\n-      //   }\n-    }\n-  else if (inferedType != nullptr)\n-    {\n-      auto before = typeComparisonBuffer.size ();\n-      inferedType->accept_vis (*this);\n-      if (typeComparisonBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (stmt.get_locus (), \"failed to understand type for lhs\");\n-\t  return;\n-\t}\n-      auto typeString = typeComparisonBuffer.back ();\n-      typeComparisonBuffer.pop_back ();\n-\n-      // AST::Type *val = NULL;\n-      // if (!scope.LookupType (typeString, &val))\n-      //   {\n-      //     rust_error_at (stmt.get_locus (), \"Inferred unknown type: %s\",\n-      //   \t\t inferedType->as_string ().c_str ());\n-      //     return;\n-      //   }\n-    }\n-  else\n-    {\n-      rust_fatal_error (stmt.get_locus (), \"Failed to determine any type for LetStmt\");\n-      return;\n-    }\n-\n-  // ensure the decl has the type set for compilation later on\n-  if (!stmt.has_type ())\n-    {\n-      stmt.inferedType = inferedType;\n-    }\n-\n-  // get all the names part of this declaration and add the types to the scope\n-  stmt.get_pattern ()->accept_vis (*this);\n-  for (auto &pattern : letPatternBuffer)\n-    scope.InsertType (pattern.get_ident (), inferedType);\n-\n-  letPatternBuffer.clear ();\n-}\n-\n-void\n-TypeResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n-{\n-  stmt.get_expr ()->accept_vis (*this);\n-}\n-\n-void\n-TypeResolution::visit (AST::ExprStmtWithBlock &stmt)\n-{\n-  scope.Push ();\n-  stmt.get_expr ()->accept_vis (*this);\n-  auto localMap = scope.PeekLocals ();\n-  for (auto &[_, value] : localMap)\n-    {\n-      stmt.locals.push_back (value);\n-    }\n-  scope.Pop ();\n-}\n-\n-// rust-type.h\n-void\n-TypeResolution::visit (AST::TraitBound &bound)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ImplTraitType &type)\n-{}\n-\n-void\n-TypeResolution::visit (AST::TraitObjectType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-TypeResolution::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-TypeResolution::visit (AST::TupleType &type)\n-{}\n-void\n-TypeResolution::visit (AST::NeverType &type)\n-{}\n-void\n-TypeResolution::visit (AST::RawPointerType &type)\n-{}\n-void\n-TypeResolution::visit (AST::ReferenceType &type)\n-{}\n-\n-void\n-TypeResolution::visit (AST::ArrayType &type)\n-{\n-  typeComparisonBuffer.push_back (type.get_elem_type ()->as_string ());\n-}\n-\n-void\n-TypeResolution::visit (AST::SliceType &type)\n-{}\n-void\n-TypeResolution::visit (AST::InferredType &type)\n-{}\n-void\n-TypeResolution::visit (AST::BareFunctionType &type)\n-{}\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "2f61a39418110b7136431c7cb153c0cdd9db3cbf", "filename": "gcc/rust/analysis/rust-type-resolution.h", "status": "removed", "additions": 0, "deletions": 334, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,334 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-#pragma once\n-\n-#include \"rust-resolution.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class TypeScoping\n-{\n-public:\n-  TypeScoping () {}\n-\n-  ~TypeScoping () {}\n-\n-  void Push ()\n-  {\n-    functionScope.Push ();\n-    localsPerBlock.Push ();\n-    structsPerBlock.Push ();\n-    typeScope.Push ();\n-  }\n-\n-  void Pop ()\n-  {\n-    functionScope.Pop ();\n-    localsPerBlock.Pop ();\n-    structsPerBlock.Pop ();\n-    typeScope.Pop ();\n-  }\n-\n-  void InsertFunction (std::string ident, AST::Function *fn)\n-  {\n-    functionScope.Insert (ident, fn);\n-  }\n-\n-  bool LookupFunction (std::string ident, AST::Function **fn)\n-  {\n-    return functionScope.Lookup (ident, fn);\n-  }\n-\n-  void PushFunction (AST::Function *fn) { functionStack.push_back (fn); }\n-\n-  void PopFunction () { functionStack.pop_back (); }\n-\n-  AST::Function *CurrentFunction () { return functionStack.back (); }\n-\n-  void InsertLocal (std::string ident, AST::LetStmt *let)\n-  {\n-    localsPerBlock.Insert (ident, let);\n-  }\n-\n-  bool LookupLocal (std::string ident, AST::LetStmt **let)\n-  {\n-    return localsPerBlock.Lookup (ident, let);\n-  }\n-\n-  std ::map<std::string, AST::LetStmt *> PeekLocals ()\n-  {\n-    return localsPerBlock.Peek ();\n-  }\n-\n-  void InsertStruct (std::string ident, AST::StructStruct *s)\n-  {\n-    structsPerBlock.Insert (ident, s);\n-  }\n-\n-  bool LookupStruct (std::string ident, AST::StructStruct **s)\n-  {\n-    return structsPerBlock.Lookup (ident, s);\n-  }\n-\n-  void InsertType (std::string ident, AST::Type *s)\n-  {\n-    typeScope.Insert (ident, s);\n-  }\n-\n-  bool LookupType (std::string ident, AST::Type **s)\n-  {\n-    return typeScope.Lookup (ident, s);\n-  }\n-\n-private:\n-  std::vector<AST::Function *> functionStack;\n-\n-  Scope<AST::Function *> functionScope;\n-  Scope<AST::LetStmt *> localsPerBlock;\n-  Scope<AST::StructStruct *> structsPerBlock;\n-  Scope<AST::Type *> typeScope;\n-};\n-\n-class TypeResolution : public Resolution\n-{\n-  friend class TypeScoping;\n-\n-public:\n-  ~TypeResolution ();\n-  static bool Resolve (AST::Crate &crate, TopLevelScan &toplevel);\n-\n-  // visitor impl\n-  // rust-ast.h\n-  //  void visit(AttrInput& attr_input);\n-  //  void visit(TokenTree& token_tree);\n-  //  void visit(MacroMatch& macro_match);\n-  void visit (AST::Token &tok) override;\n-  void visit (AST::DelimTokenTree &delim_tok_tree) override;\n-  void visit (AST::AttrInputMetaItemContainer &input) override;\n-  //  void visit(MetaItem& meta_item) override;\n-  //  void vsit(Stmt& stmt) override;\n-  //  void visit(Expr& expr) override;\n-  void visit (AST::IdentifierExpr &ident_expr) override;\n-  //  void visit(Pattern& pattern) override;\n-  //  void visit(Type& type) override;\n-  //  void visit(TypeParamBound& type_param_bound) override;\n-  void visit (AST::Lifetime &lifetime) override;\n-  //  void visit(GenericParam& generic_param) override;\n-  void visit (AST::LifetimeParam &lifetime_param) override;\n-  //  void visit(TraitItem& trait_item) override;\n-  //  void visit(InherentImplItem& inherent_impl_item) override;\n-  //  void visit(TraitImplItem& trait_impl_item) override;\n-  void visit (AST::MacroInvocationSemi &macro) override;\n-\n-  // rust-path.h\n-  void visit (AST::PathInExpression &path) override;\n-  void visit (AST::TypePathSegment &segment) override;\n-  void visit (AST::TypePathSegmentGeneric &segment) override;\n-  void visit (AST::TypePathSegmentFunction &segment) override;\n-  void visit (AST::TypePath &path) override;\n-  void visit (AST::QualifiedPathInExpression &path) override;\n-  void visit (AST::QualifiedPathInType &path) override;\n-\n-  // rust-expr.h\n-  void visit (AST::LiteralExpr &expr) override;\n-  void visit (AST::AttrInputLiteral &attr_input) override;\n-  void visit (AST::MetaItemLitExpr &meta_item) override;\n-  void visit (AST::MetaItemPathLit &meta_item) override;\n-  void visit (AST::BorrowExpr &expr) override;\n-  void visit (AST::DereferenceExpr &expr) override;\n-  void visit (AST::ErrorPropagationExpr &expr) override;\n-  void visit (AST::NegationExpr &expr) override;\n-  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n-  void visit (AST::ComparisonExpr &expr) override;\n-  void visit (AST::LazyBooleanExpr &expr) override;\n-  void visit (AST::TypeCastExpr &expr) override;\n-  void visit (AST::AssignmentExpr &expr) override;\n-  void visit (AST::CompoundAssignmentExpr &expr) override;\n-  void visit (AST::GroupedExpr &expr) override;\n-  //  void visit(ArrayElems& elems) override;\n-  void visit (AST::ArrayElemsValues &elems) override;\n-  void visit (AST::ArrayElemsCopied &elems) override;\n-  void visit (AST::ArrayExpr &expr) override;\n-  void visit (AST::ArrayIndexExpr &expr) override;\n-  void visit (AST::TupleExpr &expr) override;\n-  void visit (AST::TupleIndexExpr &expr) override;\n-  void visit (AST::StructExprStruct &expr) override;\n-  //  void visit(StructExprField& field) override;\n-  void visit (AST::StructExprFieldIdentifier &field) override;\n-  void visit (AST::StructExprFieldIdentifierValue &field) override;\n-  void visit (AST::StructExprFieldIndexValue &field) override;\n-  void visit (AST::StructExprStructFields &expr) override;\n-  void visit (AST::StructExprStructBase &expr) override;\n-  void visit (AST::StructExprTuple &expr) override;\n-  void visit (AST::StructExprUnit &expr) override;\n-  //  void visit(EnumExprField& field) override;\n-  void visit (AST::EnumExprFieldIdentifier &field) override;\n-  void visit (AST::EnumExprFieldIdentifierValue &field) override;\n-  void visit (AST::EnumExprFieldIndexValue &field) override;\n-  void visit (AST::EnumExprStruct &expr) override;\n-  void visit (AST::EnumExprTuple &expr) override;\n-  void visit (AST::EnumExprFieldless &expr) override;\n-  void visit (AST::CallExpr &expr) override;\n-  void visit (AST::MethodCallExpr &expr) override;\n-  void visit (AST::FieldAccessExpr &expr) override;\n-  void visit (AST::ClosureExprInner &expr) override;\n-  void visit (AST::BlockExpr &expr) override;\n-  void visit (AST::ClosureExprInnerTyped &expr) override;\n-  void visit (AST::ContinueExpr &expr) override;\n-  void visit (AST::BreakExpr &expr) override;\n-  void visit (AST::RangeFromToExpr &expr) override;\n-  void visit (AST::RangeFromExpr &expr) override;\n-  void visit (AST::RangeToExpr &expr) override;\n-  void visit (AST::RangeFullExpr &expr) override;\n-  void visit (AST::RangeFromToInclExpr &expr) override;\n-  void visit (AST::RangeToInclExpr &expr) override;\n-  void visit (AST::ReturnExpr &expr) override;\n-  void visit (AST::UnsafeBlockExpr &expr) override;\n-  void visit (AST::LoopExpr &expr) override;\n-  void visit (AST::WhileLoopExpr &expr) override;\n-  void visit (AST::WhileLetLoopExpr &expr) override;\n-  void visit (AST::ForLoopExpr &expr) override;\n-  void visit (AST::IfExpr &expr) override;\n-  void visit (AST::IfExprConseqElse &expr) override;\n-  void visit (AST::IfExprConseqIf &expr) override;\n-  void visit (AST::IfExprConseqIfLet &expr) override;\n-  void visit (AST::IfLetExpr &expr) override;\n-  void visit (AST::IfLetExprConseqElse &expr) override;\n-  void visit (AST::IfLetExprConseqIf &expr) override;\n-  void visit (AST::IfLetExprConseqIfLet &expr) override;\n-  //  void visit(MatchCase& match_case) override;\n-  // void visit (AST::MatchCaseBlockExpr &match_case) override;\n-  // void visit (AST::MatchCaseExpr &match_case) override;\n-  void visit (AST::MatchExpr &expr) override;\n-  void visit (AST::AwaitExpr &expr) override;\n-  void visit (AST::AsyncBlockExpr &expr) override;\n-\n-  // rust-item.h\n-  void visit (AST::TypeParam &param) override;\n-  //  void visit(WhereClauseItem& item) override;\n-  void visit (AST::LifetimeWhereClauseItem &item) override;\n-  void visit (AST::TypeBoundWhereClauseItem &item) override;\n-  void visit (AST::Method &method) override;\n-  void visit (AST::ModuleBodied &module) override;\n-  void visit (AST::ModuleNoBody &module) override;\n-  void visit (AST::ExternCrate &crate) override;\n-  //  void visit(UseTree& use_tree) override;\n-  void visit (AST::UseTreeGlob &use_tree) override;\n-  void visit (AST::UseTreeList &use_tree) override;\n-  void visit (AST::UseTreeRebind &use_tree) override;\n-  void visit (AST::UseDeclaration &use_decl) override;\n-  void visit (AST::Function &function) override;\n-  void visit (AST::TypeAlias &type_alias) override;\n-  void visit (AST::StructStruct &struct_item) override;\n-  void visit (AST::TupleStruct &tuple_struct) override;\n-  void visit (AST::EnumItem &item) override;\n-  void visit (AST::EnumItemTuple &item) override;\n-  void visit (AST::EnumItemStruct &item) override;\n-  void visit (AST::EnumItemDiscriminant &item) override;\n-  void visit (AST::Enum &enum_item) override;\n-  void visit (AST::Union &union_item) override;\n-  void visit (AST::ConstantItem &const_item) override;\n-  void visit (AST::StaticItem &static_item) override;\n-  void visit (AST::TraitItemFunc &item) override;\n-  void visit (AST::TraitItemMethod &item) override;\n-  void visit (AST::TraitItemConst &item) override;\n-  void visit (AST::TraitItemType &item) override;\n-  void visit (AST::Trait &trait) override;\n-  void visit (AST::InherentImpl &impl) override;\n-  void visit (AST::TraitImpl &impl) override;\n-  //  void visit(ExternalItem& item) override;\n-  void visit (AST::ExternalStaticItem &item) override;\n-  void visit (AST::ExternalFunctionItem &item) override;\n-  void visit (AST::ExternBlock &block) override;\n-\n-  // rust-macro.h\n-  void visit (AST::MacroMatchFragment &match) override;\n-  void visit (AST::MacroMatchRepetition &match) override;\n-  void visit (AST::MacroMatcher &matcher) override;\n-  void visit (AST::MacroRulesDefinition &rules_def) override;\n-  void visit (AST::MacroInvocation &macro_invoc) override;\n-  void visit (AST::MetaItemPath &meta_item) override;\n-  void visit (AST::MetaItemSeq &meta_item) override;\n-  void visit (AST::MetaWord &meta_item) override;\n-  void visit (AST::MetaNameValueStr &meta_item) override;\n-  void visit (AST::MetaListPaths &meta_item) override;\n-  void visit (AST::MetaListNameValueStr &meta_item) override;\n-\n-  // rust-pattern.h\n-  void visit (AST::LiteralPattern &pattern) override;\n-  void visit (AST::IdentifierPattern &pattern) override;\n-  void visit (AST::WildcardPattern &pattern) override;\n-  //  void visit(RangePatternBound& bound) override;\n-  void visit (AST::RangePatternBoundLiteral &bound) override;\n-  void visit (AST::RangePatternBoundPath &bound) override;\n-  void visit (AST::RangePatternBoundQualPath &bound) override;\n-  void visit (AST::RangePattern &pattern) override;\n-  void visit (AST::ReferencePattern &pattern) override;\n-  //  void visit(StructPatternField& field) override;\n-  void visit (AST::StructPatternFieldTuplePat &field) override;\n-  void visit (AST::StructPatternFieldIdentPat &field) override;\n-  void visit (AST::StructPatternFieldIdent &field) override;\n-  void visit (AST::StructPattern &pattern) override;\n-  //  void visit(TupleStructItems& tuple_items) override;\n-  void visit (AST::TupleStructItemsNoRange &tuple_items) override;\n-  void visit (AST::TupleStructItemsRange &tuple_items) override;\n-  void visit (AST::TupleStructPattern &pattern) override;\n-  //  void visit(TuplePatternItems& tuple_items) override;\n-  void visit (AST::TuplePatternItemsMultiple &tuple_items) override;\n-  void visit (AST::TuplePatternItemsRanged &tuple_items) override;\n-  void visit (AST::TuplePattern &pattern) override;\n-  void visit (AST::GroupedPattern &pattern) override;\n-  void visit (AST::SlicePattern &pattern) override;\n-\n-  // rust-stmt.h\n-  void visit (AST::EmptyStmt &stmt) override;\n-  void visit (AST::LetStmt &stmt) override;\n-  void visit (AST::ExprStmtWithoutBlock &stmt) override;\n-  void visit (AST::ExprStmtWithBlock &stmt) override;\n-\n-  // rust-type.h\n-  void visit (AST::TraitBound &bound) override;\n-  void visit (AST::ImplTraitType &type) override;\n-  void visit (AST::TraitObjectType &type) override;\n-  void visit (AST::ParenthesisedType &type) override;\n-  void visit (AST::ImplTraitTypeOneBound &type) override;\n-  void visit (AST::TraitObjectTypeOneBound &type) override;\n-  void visit (AST::TupleType &type) override;\n-  void visit (AST::NeverType &type) override;\n-  void visit (AST::RawPointerType &type) override;\n-  void visit (AST::ReferenceType &type) override;\n-  void visit (AST::ArrayType &type) override;\n-  void visit (AST::SliceType &type) override;\n-  void visit (AST::InferredType &type) override;\n-  void visit (AST::BareFunctionType &type) override;\n-\n-private:\n-  TypeResolution (AST::Crate &crate, TopLevelScan &toplevel);\n-  bool go () override;\n-  bool typesAreCompatible (AST::Type *lhs, AST::Type *rhs, Location locus);\n-  AST::Function *lookupFndecl (AST::Expr *expr);\n-  bool isTypeInScope (AST::Type *type, Location locus);\n-\n-  TypeScoping scope;\n-  std::unique_ptr<std::string> identifierBuffer;\n-  std::unique_ptr<int> tupleIndexBuffer;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "8cfe156782e648d50c30d2d02cbb37eb2d29c6d6", "filename": "gcc/rust/analysis/rust-type-visitor.h", "status": "removed", "additions": 0, "deletions": 261, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-type-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Frust-type-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-visitor.h?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,261 +0,0 @@\n-// rust-type-visitor.h -- Rust AST Visitor to AST::Type specific\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_TYPE_VISITOR_H\n-#define RUST_TYPE_VISITOR_H\n-\n-#include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-#include \"rust-ast-visitor.h\"\n-#include \"rust-scan.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-class BaseTypeVisitor : public AST::ASTVisitor\n-{\n-public:\n-  // visitor impl\n-  // rust-ast.h\n-  //  virtual void visit(AttrInput& attr_input);\n-  //  virtual void visit(TokenTree& token_tree);\n-  //  virtual void visit(MacroMatch& macro_match);\n-  virtual void visit (AST::Token &tok) override {}\n-  virtual void visit (AST::DelimTokenTree &delim_tok_tree) override {}\n-  virtual void visit (AST::AttrInputMetaItemContainer &input) override {}\n-  //  virtual void visit(MetaItem& meta_item) override {}\n-  //  void vsit(Stmt& stmt) override {}\n-  //  virtual void visit(Expr& expr) override {}\n-  virtual void visit (AST::IdentifierExpr &ident_expr) override {}\n-  //  virtual void visit(Pattern& pattern) override {}\n-  //  virtual void visit(Type& type) override {}\n-  //  virtual void visit(TypeParamBound& type_param_bound) override {}\n-  virtual void visit (AST::Lifetime &lifetime) override {}\n-  //  virtual void visit(GenericParam& generic_param) override {}\n-  virtual void visit (AST::LifetimeParam &lifetime_param) override {}\n-  //  virtual void visit(TraitItem& trait_item) override {}\n-  //  virtual void visit(InherentImplItem& inherent_impl_item) override {}\n-  //  virtual void visit(TraitImplItem& trait_impl_item) override {}\n-  virtual void visit (AST::MacroInvocationSemi &macro) override {}\n-\n-  // rust-path.h\n-  virtual void visit (AST::PathInExpression &path) override {}\n-  virtual void visit (AST::TypePathSegment &segment) override {}\n-  virtual void visit (AST::TypePathSegmentGeneric &segment) override {}\n-  virtual void visit (AST::TypePathSegmentFunction &segment) override {}\n-  virtual void visit (AST::TypePath &path) override {}\n-  virtual void visit (AST::QualifiedPathInExpression &path) override {}\n-  virtual void visit (AST::QualifiedPathInType &path) override {}\n-\n-  // rust-expr.h\n-  virtual void visit (AST::LiteralExpr &expr) override {}\n-  virtual void visit (AST::AttrInputLiteral &attr_input) override {}\n-  virtual void visit (AST::MetaItemLitExpr &meta_item) override {}\n-  virtual void visit (AST::MetaItemPathLit &meta_item) override {}\n-  virtual void visit (AST::BorrowExpr &expr) override {}\n-  virtual void visit (AST::DereferenceExpr &expr) override {}\n-  virtual void visit (AST::ErrorPropagationExpr &expr) override {}\n-  virtual void visit (AST::NegationExpr &expr) override {}\n-  virtual void visit (AST::ArithmeticOrLogicalExpr &expr) override {}\n-  virtual void visit (AST::ComparisonExpr &expr) override {}\n-  virtual void visit (AST::LazyBooleanExpr &expr) override {}\n-  virtual void visit (AST::TypeCastExpr &expr) override {}\n-  virtual void visit (AST::AssignmentExpr &expr) override {}\n-  virtual void visit (AST::CompoundAssignmentExpr &expr) override {}\n-  virtual void visit (AST::GroupedExpr &expr) override {}\n-  //  virtual void visit(ArrayElems& elems) override {}\n-  virtual void visit (AST::ArrayElemsValues &elems) override {}\n-  virtual void visit (AST::ArrayElemsCopied &elems) override {}\n-  virtual void visit (AST::ArrayExpr &expr) override {}\n-  virtual void visit (AST::ArrayIndexExpr &expr) override {}\n-  virtual void visit (AST::TupleExpr &expr) override {}\n-  virtual void visit (AST::TupleIndexExpr &expr) override {}\n-  virtual void visit (AST::StructExprStruct &expr) override {}\n-  //  virtual void visit(StructExprField& field) override {}\n-  virtual void visit (AST::StructExprFieldIdentifier &field) override {}\n-  virtual void visit (AST::StructExprFieldIdentifierValue &field) override {}\n-  virtual void visit (AST::StructExprFieldIndexValue &field) override {}\n-  virtual void visit (AST::StructExprStructFields &expr) override {}\n-  virtual void visit (AST::StructExprStructBase &expr) override {}\n-  virtual void visit (AST::StructExprTuple &expr) override {}\n-  virtual void visit (AST::StructExprUnit &expr) override {}\n-  //  virtual void visit(EnumExprField& field) override {}\n-  virtual void visit (AST::EnumExprFieldIdentifier &field) override {}\n-  virtual void visit (AST::EnumExprFieldIdentifierValue &field) override {}\n-  virtual void visit (AST::EnumExprFieldIndexValue &field) override {}\n-  virtual void visit (AST::EnumExprStruct &expr) override {}\n-  virtual void visit (AST::EnumExprTuple &expr) override {}\n-  virtual void visit (AST::EnumExprFieldless &expr) override {}\n-  virtual void visit (AST::CallExpr &expr) override {}\n-  virtual void visit (AST::MethodCallExpr &expr) override {}\n-  virtual void visit (AST::FieldAccessExpr &expr) override {}\n-  virtual void visit (AST::ClosureExprInner &expr) override {}\n-  virtual void visit (AST::BlockExpr &expr) override {}\n-  virtual void visit (AST::ClosureExprInnerTyped &expr) override {}\n-  virtual void visit (AST::ContinueExpr &expr) override {}\n-  virtual void visit (AST::BreakExpr &expr) override {}\n-  virtual void visit (AST::RangeFromToExpr &expr) override {}\n-  virtual void visit (AST::RangeFromExpr &expr) override {}\n-  virtual void visit (AST::RangeToExpr &expr) override {}\n-  virtual void visit (AST::RangeFullExpr &expr) override {}\n-  virtual void visit (AST::RangeFromToInclExpr &expr) override {}\n-  virtual void visit (AST::RangeToInclExpr &expr) override {}\n-  virtual void visit (AST::ReturnExpr &expr) override {}\n-  virtual void visit (AST::UnsafeBlockExpr &expr) override {}\n-  virtual void visit (AST::LoopExpr &expr) override {}\n-  virtual void visit (AST::WhileLoopExpr &expr) override {}\n-  virtual void visit (AST::WhileLetLoopExpr &expr) override {}\n-  virtual void visit (AST::ForLoopExpr &expr) override {}\n-  virtual void visit (AST::IfExpr &expr) override {}\n-  virtual void visit (AST::IfExprConseqElse &expr) override {}\n-  virtual void visit (AST::IfExprConseqIf &expr) override {}\n-  virtual void visit (AST::IfExprConseqIfLet &expr) override {}\n-  virtual void visit (AST::IfLetExpr &expr) override {}\n-  virtual void visit (AST::IfLetExprConseqElse &expr) override {}\n-  virtual void visit (AST::IfLetExprConseqIf &expr) override {}\n-  virtual void visit (AST::IfLetExprConseqIfLet &expr) override {}\n-  //  virtual void visit(MatchCase& match_case) override {}\n-  // virtual void visit (AST::MatchCaseBlockExpr &match_case) override {}\n-  // virtual void visit (AST::MatchCaseExpr &match_case) override {}\n-  virtual void visit (AST::MatchExpr &expr) override {}\n-  virtual void visit (AST::AwaitExpr &expr) override {}\n-  virtual void visit (AST::AsyncBlockExpr &expr) override {}\n-\n-  // rust-item.h\n-  virtual void visit (AST::TypeParam &param) override {}\n-  //  virtual void visit(WhereClauseItem& item) override {}\n-  virtual void visit (AST::LifetimeWhereClauseItem &item) override {}\n-  virtual void visit (AST::TypeBoundWhereClauseItem &item) override {}\n-  virtual void visit (AST::Method &method) override {}\n-  virtual void visit (AST::ModuleBodied &module) override {}\n-  virtual void visit (AST::ModuleNoBody &module) override {}\n-  virtual void visit (AST::ExternCrate &crate) override {}\n-  //  virtual void visit(UseTree& use_tree) override {}\n-  virtual void visit (AST::UseTreeGlob &use_tree) override {}\n-  virtual void visit (AST::UseTreeList &use_tree) override {}\n-  virtual void visit (AST::UseTreeRebind &use_tree) override {}\n-  virtual void visit (AST::UseDeclaration &use_decl) override {}\n-  virtual void visit (AST::Function &function) override {}\n-  virtual void visit (AST::TypeAlias &type_alias) override {}\n-  virtual void visit (AST::StructStruct &struct_item) override {}\n-  virtual void visit (AST::TupleStruct &tuple_struct) override {}\n-  virtual void visit (AST::EnumItem &item) override {}\n-  virtual void visit (AST::EnumItemTuple &item) override {}\n-  virtual void visit (AST::EnumItemStruct &item) override {}\n-  virtual void visit (AST::EnumItemDiscriminant &item) override {}\n-  virtual void visit (AST::Enum &enum_item) override {}\n-  virtual void visit (AST::Union &union_item) override {}\n-  virtual void visit (AST::ConstantItem &const_item) override {}\n-  virtual void visit (AST::StaticItem &static_item) override {}\n-  virtual void visit (AST::TraitItemFunc &item) override {}\n-  virtual void visit (AST::TraitItemMethod &item) override {}\n-  virtual void visit (AST::TraitItemConst &item) override {}\n-  virtual void visit (AST::TraitItemType &item) override {}\n-  virtual void visit (AST::Trait &trait) override {}\n-  virtual void visit (AST::InherentImpl &impl) override {}\n-  virtual void visit (AST::TraitImpl &impl) override {}\n-  //  virtual void visit(ExternalItem& item) override {}\n-  virtual void visit (AST::ExternalStaticItem &item) override {}\n-  virtual void visit (AST::ExternalFunctionItem &item) override {}\n-  virtual void visit (AST::ExternBlock &block) override {}\n-\n-  // rust-macro.h\n-  virtual void visit (AST::MacroMatchFragment &match) override {}\n-  virtual void visit (AST::MacroMatchRepetition &match) override {}\n-  virtual void visit (AST::MacroMatcher &matcher) override {}\n-  virtual void visit (AST::MacroRulesDefinition &rules_def) override {}\n-  virtual void visit (AST::MacroInvocation &macro_invoc) override {}\n-  virtual void visit (AST::MetaItemPath &meta_item) override {}\n-  virtual void visit (AST::MetaItemSeq &meta_item) override {}\n-  virtual void visit (AST::MetaWord &meta_item) override {}\n-  virtual void visit (AST::MetaNameValueStr &meta_item) override {}\n-  virtual void visit (AST::MetaListPaths &meta_item) override {}\n-  virtual void visit (AST::MetaListNameValueStr &meta_item) override {}\n-\n-  // rust-pattern.h\n-  virtual void visit (AST::LiteralPattern &pattern) override {}\n-  virtual void visit (AST::IdentifierPattern &pattern) override {}\n-  virtual void visit (AST::WildcardPattern &pattern) override {}\n-  //  virtual void visit(RangePatternBound& bound) override {}\n-  virtual void visit (AST::RangePatternBoundLiteral &bound) override {}\n-  virtual void visit (AST::RangePatternBoundPath &bound) override {}\n-  virtual void visit (AST::RangePatternBoundQualPath &bound) override {}\n-  virtual void visit (AST::RangePattern &pattern) override {}\n-  virtual void visit (AST::ReferencePattern &pattern) override {}\n-  //  virtual void visit(StructPatternField& field) override {}\n-  virtual void visit (AST::StructPatternFieldTuplePat &field) override {}\n-  virtual void visit (AST::StructPatternFieldIdentPat &field) override {}\n-  virtual void visit (AST::StructPatternFieldIdent &field) override {}\n-  virtual void visit (AST::StructPattern &pattern) override {}\n-  //  virtual void visit(TupleStructItems& tuple_items) override {}\n-  virtual void visit (AST::TupleStructItemsNoRange &tuple_items) override {}\n-  virtual void visit (AST::TupleStructItemsRange &tuple_items) override {}\n-  virtual void visit (AST::TupleStructPattern &pattern) override {}\n-  //  virtual void visit(TuplePatternItems& tuple_items) override {}\n-  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items) override {}\n-  virtual void visit (AST::TuplePatternItemsRanged &tuple_items) override {}\n-  virtual void visit (AST::TuplePattern &pattern) override {}\n-  virtual void visit (AST::GroupedPattern &pattern) override {}\n-  virtual void visit (AST::SlicePattern &pattern) override {}\n-\n-  // rust-stmt.h\n-  virtual void visit (AST::EmptyStmt &stmt) override {}\n-  virtual void visit (AST::LetStmt &stmt) override {}\n-  virtual void visit (AST::ExprStmtWithoutBlock &stmt) override {}\n-  virtual void visit (AST::ExprStmtWithBlock &stmt) override {}\n-\n-  // rust-type.h\n-  virtual void visit (AST::TraitBound &bound) override {}\n-  virtual void visit (AST::ImplTraitType &type) override {}\n-  virtual void visit (AST::TraitObjectType &type) override {}\n-  virtual void visit (AST::ParenthesisedType &type) override {}\n-  virtual void visit (AST::ImplTraitTypeOneBound &type) override {}\n-  virtual void visit (AST::TraitObjectTypeOneBound &type) override {}\n-  virtual void visit (AST::TupleType &type) override {}\n-  virtual void visit (AST::NeverType &type) override {}\n-  virtual void visit (AST::RawPointerType &type) override {}\n-  virtual void visit (AST::ReferenceType &type) override {}\n-  virtual void visit (AST::ArrayType &type) override {}\n-  virtual void visit (AST::SliceType &type) override {}\n-  virtual void visit (AST::InferredType &type) override {}\n-  virtual void visit (AST::BareFunctionType &type) override {}\n-};\n-\n-class ArrayTypeVisitor : public BaseTypeVisitor\n-{\n-public:\n-  static AST::ArrayType *Resolve (AST::Type *type)\n-  {\n-    ArrayTypeVisitor vis;\n-    type->accept_vis (vis);\n-    return vis.resolved;\n-  }\n-\n-  virtual void visit (AST::ArrayType &type) override { resolved = &type; };\n-\n-private:\n-  ArrayTypeVisitor () : resolved (nullptr) {}\n-\n-  AST::ArrayType *resolved;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust\n-\n-#endif // RUST_TYPE_VISITOR_H"}, {"sha": "41bcee61737b5ea5b56eec982c4d8106a61c82a1", "filename": "gcc/rust/analysis/scope.h", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f764eeb8abf1ec50794ddb1f31bc57d025e29a3c/gcc%2Frust%2Fanalysis%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Fscope.h?ref=f764eeb8abf1ec50794ddb1f31bc57d025e29a3c", "patch": "@@ -1,57 +0,0 @@\n-#pragma once\n-\n-#include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-\n-namespace Rust {\n-namespace Analysis {\n-\n-template <class T> class Scope\n-{\n-public:\n-  Scope () : scopeStack () {}\n-\n-  ~Scope () {}\n-\n-  bool Insert (std::string key, T val)\n-  {\n-    if (scopeStack.back ().find (key) != scopeStack.back ().end ())\n-      {\n-\treturn false;\n-      }\n-\n-    scopeStack.back ().insert (std::make_pair (key, std::move (val)));\n-    return true;\n-  }\n-\n-  bool Lookup (std::string key, T *result)\n-  {\n-    for (auto it = scopeStack.rbegin (); it != scopeStack.rend (); ++it)\n-      {\n-\tauto lookup = it->find (key);\n-\tif (lookup != it->end ())\n-\t  {\n-\t    *result = lookup->second;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n-\n-  void Push () { scopeStack.push_back ({}); }\n-\n-  std ::map<std::string, T> Pop ()\n-  {\n-    auto toplevel = scopeStack.back ();\n-    scopeStack.pop_back ();\n-    return toplevel;\n-  }\n-\n-  std ::map<std::string, T> Peek () { return scopeStack.back (); }\n-\n-private:\n-  std::vector<std::map<std::string, T> > scopeStack;\n-};\n-\n-} // namespace Analysis\n-} // namespace Rust"}, {"sha": "ebd2b2a337d5dd923671ab42d65f608c241c3753", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "modified", "additions": 274, "deletions": 254, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -1,266 +1,286 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_FULL_DECLS_H\n #define RUST_AST_FULL_DECLS_H\n-// Forward declarations for all AST classes. Useful for not having to include all definitions.\n+\n+// Forward declarations for all AST classes. Useful for not having to include\n+// all definitions.\n \n namespace Rust {\n-    namespace AST {\n-        // rust-ast.h\n-        class AttrInput;\n-        class TokenTree;\n-        class MacroMatch;\n-        class Token;\n-        struct Literal;\n-        class DelimTokenTree;\n-        class PathSegment;\n-        class SimplePathSegment;\n-        class SimplePath;\n-        struct Attribute;\n-        class MetaItemInner;\n-        class AttrInputMetaItemContainer;\n-        class MetaItem;\n-        class Stmt;\n-        class Item;\n-        class Expr;\n-        class ExprWithoutBlock;\n-        class IdentifierExpr;\n-        class Pattern;\n-        class Type;\n-        class TypeNoBounds;\n-        class TypeParamBound;\n-        class Lifetime;\n-        class GenericParam;\n-        class LifetimeParam;\n-        class MacroItem;\n-        class TraitItem;\n-        class InherentImplItem;\n-        class TraitImplItem;\n-        class MacroInvocationSemi;\n-        struct Crate;\n-        class PathExpr;\n+namespace AST {\n+// rust-ast.h\n+class AttrInput;\n+class TokenTree;\n+class MacroMatch;\n+class Token;\n+struct Literal;\n+class DelimTokenTree;\n+class PathSegment;\n+class SimplePathSegment;\n+class SimplePath;\n+struct Attribute;\n+class MetaItemInner;\n+class AttrInputMetaItemContainer;\n+class MetaItem;\n+class Stmt;\n+class Item;\n+class Expr;\n+class ExprWithoutBlock;\n+class IdentifierExpr;\n+class Pattern;\n+class Type;\n+class TypeNoBounds;\n+class TypeParamBound;\n+class Lifetime;\n+class GenericParam;\n+class LifetimeParam;\n+class MacroItem;\n+class TraitItem;\n+class InherentImplItem;\n+class TraitImplItem;\n+class MacroInvocationSemi;\n+struct Crate;\n+class PathExpr;\n \n-        // rust-path.h\n-        class PathIdentSegment;\n-        struct GenericArgsBinding;\n-        struct GenericArgs;\n-        class PathExprSegment;\n-        class PathPattern;\n-        class PathInExpression;\n-        class TypePathSegment;\n-        class TypePathSegmentGeneric;\n-        struct TypePathFunction;\n-        class TypePathSegmentFunction;\n-        class TypePath;\n-        struct QualifiedPathType;\n-        class QualifiedPathInExpression;\n-        class QualifiedPathInType;\n+// rust-path.h\n+class PathIdentSegment;\n+struct GenericArgsBinding;\n+struct GenericArgs;\n+class PathExprSegment;\n+class PathPattern;\n+class PathInExpression;\n+class TypePathSegment;\n+class TypePathSegmentGeneric;\n+struct TypePathFunction;\n+class TypePathSegmentFunction;\n+class TypePath;\n+struct QualifiedPathType;\n+class QualifiedPathInExpression;\n+class QualifiedPathInType;\n \n-        // rust-expr.h\n-        class ExprWithBlock;\n-        class LiteralExpr;\n-        class AttrInputLiteral;\n-        class MetaItemLitExpr;\n-        class MetaItemPathLit;\n-        class OperatorExpr;\n-        class BorrowExpr;\n-        class DereferenceExpr;\n-        class ErrorPropagationExpr;\n-        class NegationExpr;\n-        class ArithmeticOrLogicalExpr;\n-        class ComparisonExpr;\n-        class LazyBooleanExpr;\n-        class TypeCastExpr;\n-        class AssignmentExpr;\n-        class CompoundAssignmentExpr;\n-        class GroupedExpr;\n-        class ArrayElems;\n-        class ArrayElemsValues;\n-        class ArrayElemsCopied;\n-        class ArrayExpr;\n-        class ArrayIndexExpr;\n-        class TupleExpr;\n-        class TupleIndexExpr;\n-        class StructExpr;\n-        class StructExprStruct;\n-        struct StructBase;\n-        class StructExprField;\n-        class StructExprFieldIdentifier;\n-        class StructExprFieldWithVal;\n-        class StructExprFieldIdentifierValue;\n-        class StructExprFieldIndexValue;\n-        class StructExprStructFields;\n-        class StructExprStructBase;\n-        class StructExprTuple;\n-        class StructExprUnit;\n-        class EnumVariantExpr;\n-        class EnumExprField;\n-        class EnumExprFieldIdentifier;\n-        class EnumExprFieldWithVal;\n-        class EnumExprFieldIdentifierValue;\n-        class EnumExprFieldIndexValue;\n-        class EnumExprStruct;\n-        class EnumExprTuple;\n-        class EnumExprFieldless;\n-        class CallExpr;\n-        class MethodCallExpr;\n-        class FieldAccessExpr;\n-        struct ClosureParam;\n-        class ClosureExpr;\n-        class ClosureExprInner;\n-        class BlockExpr;\n-        class ClosureExprInnerTyped;\n-        class ContinueExpr;\n-        class BreakExpr;\n-        class RangeExpr;\n-        class RangeFromToExpr;\n-        class RangeFromExpr;\n-        class RangeToExpr;\n-        class RangeFullExpr;\n-        class RangeFromToInclExpr;\n-        class RangeToInclExpr;\n-        class ReturnExpr;\n-        class UnsafeBlockExpr;\n-        class LoopLabel;\n-        class BaseLoopExpr;\n-        class LoopExpr;\n-        class WhileLoopExpr;\n-        class WhileLetLoopExpr;\n-        class ForLoopExpr;\n-        class IfExpr;\n-        class IfExprConseqElse;\n-        class IfExprConseqIf;\n-        class IfLetExpr;\n-        class IfExprConseqIfLet;\n-        class IfLetExprConseqElse;\n-        class IfLetExprConseqIf;\n-        class IfLetExprConseqIfLet;\n-        struct MatchArm;\n-        // class MatchCase;\n-        // class MatchCaseBlockExpr;\n-        // class MatchCaseExpr;\n-        struct MatchCase;\n-        class MatchExpr;\n-        class AwaitExpr;\n-        class AsyncBlockExpr;\n+// rust-expr.h\n+class ExprWithBlock;\n+class LiteralExpr;\n+class AttrInputLiteral;\n+class MetaItemLitExpr;\n+class MetaItemPathLit;\n+class OperatorExpr;\n+class BorrowExpr;\n+class DereferenceExpr;\n+class ErrorPropagationExpr;\n+class NegationExpr;\n+class ArithmeticOrLogicalExpr;\n+class ComparisonExpr;\n+class LazyBooleanExpr;\n+class TypeCastExpr;\n+class AssignmentExpr;\n+class CompoundAssignmentExpr;\n+class GroupedExpr;\n+class ArrayElems;\n+class ArrayElemsValues;\n+class ArrayElemsCopied;\n+class ArrayExpr;\n+class ArrayIndexExpr;\n+class TupleExpr;\n+class TupleIndexExpr;\n+class StructExpr;\n+class StructExprStruct;\n+struct StructBase;\n+class StructExprField;\n+class StructExprFieldIdentifier;\n+class StructExprFieldWithVal;\n+class StructExprFieldIdentifierValue;\n+class StructExprFieldIndexValue;\n+class StructExprStructFields;\n+class StructExprStructBase;\n+class StructExprTuple;\n+class StructExprUnit;\n+class EnumVariantExpr;\n+class EnumExprField;\n+class EnumExprFieldIdentifier;\n+class EnumExprFieldWithVal;\n+class EnumExprFieldIdentifierValue;\n+class EnumExprFieldIndexValue;\n+class EnumExprStruct;\n+class EnumExprTuple;\n+class EnumExprFieldless;\n+class CallExpr;\n+class MethodCallExpr;\n+class FieldAccessExpr;\n+struct ClosureParam;\n+class ClosureExpr;\n+class ClosureExprInner;\n+class BlockExpr;\n+class ClosureExprInnerTyped;\n+class ContinueExpr;\n+class BreakExpr;\n+class RangeExpr;\n+class RangeFromToExpr;\n+class RangeFromExpr;\n+class RangeToExpr;\n+class RangeFullExpr;\n+class RangeFromToInclExpr;\n+class RangeToInclExpr;\n+class ReturnExpr;\n+class UnsafeBlockExpr;\n+class LoopLabel;\n+class BaseLoopExpr;\n+class LoopExpr;\n+class WhileLoopExpr;\n+class WhileLetLoopExpr;\n+class ForLoopExpr;\n+class IfExpr;\n+class IfExprConseqElse;\n+class IfExprConseqIf;\n+class IfLetExpr;\n+class IfExprConseqIfLet;\n+class IfLetExprConseqElse;\n+class IfLetExprConseqIf;\n+class IfLetExprConseqIfLet;\n+struct MatchArm;\n+// class MatchCase;\n+// class MatchCaseBlockExpr;\n+// class MatchCaseExpr;\n+struct MatchCase;\n+class MatchExpr;\n+class AwaitExpr;\n+class AsyncBlockExpr;\n \n-        // rust-stmt.h\n-        class EmptyStmt;\n-        class LetStmt;\n-        class ExprStmt;\n-        class ExprStmtWithoutBlock;\n-        class ExprStmtWithBlock;\n+// rust-stmt.h\n+class EmptyStmt;\n+class LetStmt;\n+class ExprStmt;\n+class ExprStmtWithoutBlock;\n+class ExprStmtWithBlock;\n \n-        // rust-item.h\n-        class TypeParam;\n-        class WhereClauseItem;\n-        class LifetimeWhereClauseItem;\n-        class TypeBoundWhereClauseItem;\n-        struct WhereClause;\n-        struct SelfParam;\n-        struct FunctionQualifiers;\n-        struct FunctionParam;\n-        struct Visibility;\n-        class Method;\n-        class VisItem;\n-        class Module;\n-        class ModuleBodied;\n-        class ModuleNoBody;\n-        class ExternCrate;\n-        class UseTree;\n-        class UseTreeGlob;\n-        class UseTreeList;\n-        class UseTreeRebind;\n-        class UseDeclaration;\n-        class Function;\n-        class TypeAlias;\n-        class Struct;\n-        struct StructField;\n-        class StructStruct;\n-        struct TupleField;\n-        class TupleStruct;\n-        class EnumItem;\n-        class EnumItemTuple;\n-        class EnumItemStruct;\n-        class EnumItemDiscriminant;\n-        class Enum;\n-        class Union;\n-        class ConstantItem;\n-        class StaticItem;\n-        struct TraitFunctionDecl;\n-        class TraitItemFunc;\n-        struct TraitMethodDecl;\n-        class TraitItemMethod;\n-        class TraitItemConst;\n-        class TraitItemType;\n-        class Trait;\n-        class Impl;\n-        class InherentImpl;\n-        class TraitImpl;\n-        class ExternalItem;\n-        class ExternalStaticItem;\n-        struct NamedFunctionParam;\n-        class ExternalFunctionItem;\n-        class ExternBlock;\n+// rust-item.h\n+class TypeParam;\n+class WhereClauseItem;\n+class LifetimeWhereClauseItem;\n+class TypeBoundWhereClauseItem;\n+struct WhereClause;\n+struct SelfParam;\n+struct FunctionQualifiers;\n+struct FunctionParam;\n+struct Visibility;\n+class Method;\n+class VisItem;\n+class Module;\n+class ModuleBodied;\n+class ModuleNoBody;\n+class ExternCrate;\n+class UseTree;\n+class UseTreeGlob;\n+class UseTreeList;\n+class UseTreeRebind;\n+class UseDeclaration;\n+class Function;\n+class TypeAlias;\n+class Struct;\n+struct StructField;\n+class StructStruct;\n+struct TupleField;\n+class TupleStruct;\n+class EnumItem;\n+class EnumItemTuple;\n+class EnumItemStruct;\n+class EnumItemDiscriminant;\n+class Enum;\n+class Union;\n+class ConstantItem;\n+class StaticItem;\n+struct TraitFunctionDecl;\n+class TraitItemFunc;\n+struct TraitMethodDecl;\n+class TraitItemMethod;\n+class TraitItemConst;\n+class TraitItemType;\n+class Trait;\n+class Impl;\n+class InherentImpl;\n+class TraitImpl;\n+class ExternalItem;\n+class ExternalStaticItem;\n+struct NamedFunctionParam;\n+class ExternalFunctionItem;\n+class ExternBlock;\n \n-        // rust-macro.h\n-        class MacroMatchFragment;\n-        class MacroMatchRepetition;\n-        class MacroMatcher;\n-        struct MacroTranscriber;\n-        struct MacroRule;\n-        class MacroRulesDefinition;\n-        class MacroInvocation;\n-        class MetaItemPath;\n-        class MetaItemSeq;\n-        class MetaWord;\n-        class MetaNameValueStr;\n-        class MetaListPaths;\n-        class MetaListNameValueStr;\n+// rust-macro.h\n+class MacroMatchFragment;\n+class MacroMatchRepetition;\n+class MacroMatcher;\n+struct MacroTranscriber;\n+struct MacroRule;\n+class MacroRulesDefinition;\n+class MacroInvocation;\n+class MetaItemPath;\n+class MetaItemSeq;\n+class MetaWord;\n+class MetaNameValueStr;\n+class MetaListPaths;\n+class MetaListNameValueStr;\n \n-        // rust-pattern.h\n-        class LiteralPattern;\n-        class IdentifierPattern;\n-        class WildcardPattern;\n-        class RangePatternBound;\n-        class RangePatternBoundLiteral;\n-        class RangePatternBoundPath;\n-        class RangePatternBoundQualPath;\n-        class RangePattern;\n-        class ReferencePattern;\n-        struct StructPatternEtc;\n-        class StructPatternField;\n-        class StructPatternFieldTuplePat;\n-        class StructPatternFieldIdentPat;\n-        class StructPatternFieldIdent;\n-        struct StructPatternElements;\n-        class StructPattern;\n-        class TupleStructItems;\n-        class TupleStructItemsNoRange;\n-        class TupleStructItemsRange;\n-        class TupleStructPattern;\n-        class TuplePatternItems;\n-        class TuplePatternItemsMultiple;\n-        class TuplePatternItemsRanged;\n-        class TuplePattern;\n-        class GroupedPattern;\n-        class SlicePattern;\n+// rust-pattern.h\n+class LiteralPattern;\n+class IdentifierPattern;\n+class WildcardPattern;\n+class RangePatternBound;\n+class RangePatternBoundLiteral;\n+class RangePatternBoundPath;\n+class RangePatternBoundQualPath;\n+class RangePattern;\n+class ReferencePattern;\n+struct StructPatternEtc;\n+class StructPatternField;\n+class StructPatternFieldTuplePat;\n+class StructPatternFieldIdentPat;\n+class StructPatternFieldIdent;\n+struct StructPatternElements;\n+class StructPattern;\n+class TupleStructItems;\n+class TupleStructItemsNoRange;\n+class TupleStructItemsRange;\n+class TupleStructPattern;\n+class TuplePatternItems;\n+class TuplePatternItemsMultiple;\n+class TuplePatternItemsRanged;\n+class TuplePattern;\n+class GroupedPattern;\n+class SlicePattern;\n \n-        // rust-type.h\n-        class TraitBound;\n-        class ImplTraitType;\n-        class TraitObjectType;\n-        class ParenthesisedType;\n-        class ImplTraitTypeOneBound;\n-        class TraitObjectTypeOneBound;\n-        class TupleType;\n-        class NeverType;\n-        class RawPointerType;\n-        class ReferenceType;\n-        class ArrayType;\n-        class SliceType;\n-        class InferredType;\n-        struct MaybeNamedParam;\n-        class BareFunctionType;\n-    }\n-}\n+// rust-type.h\n+class TraitBound;\n+class ImplTraitType;\n+class TraitObjectType;\n+class ParenthesisedType;\n+class ImplTraitTypeOneBound;\n+class TraitObjectTypeOneBound;\n+class TupleType;\n+class NeverType;\n+class RawPointerType;\n+class ReferenceType;\n+class ArrayType;\n+class SliceType;\n+class InferredType;\n+struct MaybeNamedParam;\n+class BareFunctionType;\n+} // namespace AST\n+} // namespace Rust\n \n-#endif\n\\ No newline at end of file\n+#endif"}, {"sha": "58bc372e885c14faff0e336581fe3045f3cc2617", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 57, "deletions": 10, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -1,18 +1,31 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n #ifndef RUST_AST_BASE_H\n #define RUST_AST_BASE_H\n // Base for AST used in gccrs, basically required by all specific ast things\n \n #include \"rust-system.h\"\n-\n-// STL imports\n-#include <memory>\n-#include <string>\n-#include <vector>\n+#include \"rust-hir-map.h\"\n \n // gccrs imports\n // required for AST::Token\n #include \"rust-token.h\"\n-\n #include \"rust-location.h\"\n \n namespace Rust {\n@@ -253,6 +266,10 @@ struct Literal\n   bool is_error () const { return value_as_string == \"\"; }\n };\n \n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n+class AttrInputLiteral;\n+\n /* TODO: move applicable stuff into here or just don't include it because\n  * nothing uses it A segment of a path (maybe) */\n class PathSegment\n@@ -473,7 +490,7 @@ struct Attribute\n   std::string as_string () const;\n \n   // TODO: does this require visitor pattern as not polymorphic?\n-  \n+\n   const SimplePath &get_path () const { return path; }\n   SimplePath &get_path () { return path; }\n \n@@ -768,10 +785,15 @@ class Stmt\n \n   virtual void mark_for_strip () = 0;\n   virtual bool is_marked_for_strip () const = 0;\n+  NodeId get_node_id () const { return node_id; }\n \n protected:\n+  Stmt () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n   // Clone function implementation as pure virtual method\n   virtual Stmt *clone_stmt_impl () const = 0;\n+\n+  NodeId node_id;\n };\n \n // Rust \"item\" AST node (declaration of top-level/module-level allowed stuff)\n@@ -848,10 +870,13 @@ class Expr\n   virtual void mark_for_strip () = 0;\n   virtual bool is_marked_for_strip () const = 0;\n \n+  virtual NodeId get_node_id () const { return node_id; }\n+\n protected:\n   // Constructor\n   Expr (std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n-    : outer_attrs (std::move (outer_attribs))\n+    : outer_attrs (std::move (outer_attribs)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Clone function implementation as pure virtual method\n@@ -863,6 +888,8 @@ class Expr\n   {\n     outer_attrs = std::move (outer_attrs_to_set);\n   }\n+\n+  NodeId node_id;\n };\n \n // AST node for an expression without an accompanying block - abstract\n@@ -978,9 +1005,15 @@ class Pattern\n    * methods. */\n   virtual Location get_locus_slow () const = 0;\n \n+  virtual NodeId get_node_id () const { return node_id; }\n+\n protected:\n   // Clone pattern implementation as pure virtual method\n   virtual Pattern *clone_pattern_impl () const = 0;\n+\n+  Pattern () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n+  NodeId node_id;\n };\n \n // forward decl for Type\n@@ -1015,9 +1048,15 @@ class Type\n \n   virtual Location get_locus_slow () const = 0;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n protected:\n+  Type () : node_id (Analysis::Mappings::get ()->get_next_node_id ()) {}\n+\n   // Clone function implementation as pure virtual method\n   virtual Type *clone_type_impl () const = 0;\n+\n+  NodeId node_id;\n };\n \n // A type without parentheses? - abstract\n@@ -1041,6 +1080,8 @@ class TypeNoBounds : public Type\n   {\n     return clone_type_no_bounds_impl ();\n   }\n+\n+  TypeNoBounds () : Type () {}\n };\n \n /* Abstract base class representing a type param bound - Lifetime and TraitBound\n@@ -1494,19 +1535,22 @@ struct Crate\n    * top-level one)? */\n   std::vector<std::unique_ptr<Item> > items;\n \n+  NodeId node_id;\n+\n public:\n   // Constructor\n   Crate (std::vector<std::unique_ptr<Item> > items,\n \t std::vector<Attribute> inner_attrs, bool has_utf8bom = false,\n \t bool has_shebang = false)\n     : has_utf8bom (has_utf8bom), has_shebang (has_shebang),\n-      inner_attrs (std::move (inner_attrs)), items (std::move (items))\n+      inner_attrs (std::move (inner_attrs)), items (std::move (items)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor with vector clone\n   Crate (Crate const &other)\n     : has_utf8bom (other.has_utf8bom), has_shebang (other.has_shebang),\n-      inner_attrs (other.inner_attrs)\n+      inner_attrs (other.inner_attrs), node_id (other.node_id)\n   {\n     items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n@@ -1521,6 +1565,7 @@ struct Crate\n     inner_attrs = other.inner_attrs;\n     has_shebang = other.has_shebang;\n     has_utf8bom = other.has_utf8bom;\n+    node_id = other.node_id;\n \n     items.reserve (other.items.size ());\n     for (const auto &e : other.items)\n@@ -1546,6 +1591,8 @@ struct Crate\n     items.shrink_to_fit ();\n     // TODO: is this the best way to do this?\n   }\n+\n+  NodeId get_node_id () const { return node_id; }\n };\n \n // Base path expression AST node - abstract"}, {"sha": "de011c1b4aa41f9108df2161f391f4feea5516e2", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -1647,7 +1647,8 @@ class StructExprFieldIdentifierValue : public StructExprFieldWithVal\n \n public:\n   StructExprFieldIdentifierValue (Identifier field_identifier,\n-\t\t\t\t  std::unique_ptr<Expr> field_value, Location locus)\n+\t\t\t\t  std::unique_ptr<Expr> field_value,\n+\t\t\t\t  Location locus)\n     : StructExprFieldWithVal (std::move (field_value)),\n       field_name (std::move (field_identifier)), locus (locus)\n   {}\n@@ -1679,7 +1680,8 @@ class StructExprFieldIndexValue : public StructExprFieldWithVal\n public:\n   StructExprFieldIndexValue (TupleIndex tuple_index,\n \t\t\t     std::unique_ptr<Expr> field_value, Location locus)\n-    : StructExprFieldWithVal (std::move (field_value)), index (tuple_index), locus (locus)\n+    : StructExprFieldWithVal (std::move (field_value)), index (tuple_index),\n+      locus (locus)\n   {}\n \n   std::string as_string () const override;\n@@ -2039,7 +2041,8 @@ class EnumExprFieldIdentifierValue : public EnumExprFieldWithVal\n \n public:\n   EnumExprFieldIdentifierValue (Identifier field_name,\n-\t\t\t\tstd::unique_ptr<Expr> field_value, Location locus)\n+\t\t\t\tstd::unique_ptr<Expr> field_value,\n+\t\t\t\tLocation locus)\n     : EnumExprFieldWithVal (std::move (field_value)),\n       field_name (std::move (field_name)), locus (locus)\n   {}\n@@ -2071,7 +2074,8 @@ class EnumExprFieldIndexValue : public EnumExprFieldWithVal\n public:\n   EnumExprFieldIndexValue (TupleIndex field_index,\n \t\t\t   std::unique_ptr<Expr> field_value, Location locus)\n-    : EnumExprFieldWithVal (std::move (field_value)), index (field_index), locus (locus)\n+    : EnumExprFieldWithVal (std::move (field_value)), index (field_index),\n+      locus (locus)\n   {}\n \n   std::string as_string () const override;\n@@ -2325,6 +2329,15 @@ class CallExpr : public ExprWithoutBlock\n   void mark_for_strip () override { function = nullptr; }\n   bool is_marked_for_strip () const override { return function == nullptr; }\n \n+  void iterate_params (std::function<bool (Expr *)> cb)\n+  {\n+    for (auto it = params.begin (); it != params.end (); it++)\n+      {\n+\tif (!cb (it->get ()))\n+\t  return;\n+      }\n+  }\n+\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<std::unique_ptr<Expr> > &get_params () const\n   {\n@@ -2793,13 +2806,16 @@ class BlockExpr : public ExprWithBlock\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Can be completely empty, so have to have a separate flag.\n-  void mark_for_strip () override\n-  {\n-    marked_for_strip = true;\n-  }\n-  bool is_marked_for_strip () const override\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n+\n+  void iterate_stmts (std::function<bool (Stmt *)> cb)\n   {\n-    return marked_for_strip;\n+    for (auto it = statements.begin (); it != statements.end (); it++)\n+      {\n+\tif (!cb (it->get ()))\n+\t  return;\n+      }\n   }\n \n   // TODO: this mutable getter seems really dodgy. Think up better way."}, {"sha": "4b3a2d58ae14f65d84f5c71d555880e02c1f8469", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -1,23 +1,23 @@\n-#ifndef RUST_AST_ITEM_H\n-#define RUST_AST_ITEM_H\n-/*\n-Copyright (C) 2009-2020 Free Software Foundation, Inc.\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n \n-This file is part of GCC.\n+// This file is part of GCC.\n \n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n \n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n \n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. */\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_ITEM_H\n+#define RUST_AST_ITEM_H\n \n #include \"rust-ast.h\"\n #include \"rust-path.h\"\n@@ -504,11 +504,13 @@ struct FunctionParam\n \t\t std::unique_ptr<Type> param_type,\n \t\t std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)), locus (locus),\n-      param_name (std::move (param_name)), type (std::move (param_type))\n+      param_name (std::move (param_name)), type (std::move (param_type)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor uses clone\n-  FunctionParam (FunctionParam const &other) : locus (other.locus)\n+  FunctionParam (FunctionParam const &other)\n+    : locus (other.locus), node_id (other.node_id)\n   {\n     // guard to prevent nullptr dereference\n     if (other.param_name != nullptr)\n@@ -521,6 +523,7 @@ struct FunctionParam\n   FunctionParam &operator= (FunctionParam const &other)\n   {\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     // guard to prevent nullptr dereference\n     if (other.param_name != nullptr)\n@@ -569,6 +572,10 @@ struct FunctionParam\n     rust_assert (type != nullptr);\n     return type;\n   }\n+  NodeId get_node_id () const { return node_id; }\n+\n+protected:\n+  NodeId node_id;\n };\n \n // Visibility of item - if the item has it, then it is some form of public\n@@ -3320,6 +3327,7 @@ class Trait : public VisItem\n \t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n \t std::vector<Attribute> outer_attrs, std::vector<Attribute> inner_attrs,\n \t Location locus)\n+\n     : VisItem (std::move (vis), std::move (outer_attrs)),\n       has_unsafe (is_unsafe), name (std::move (name)),\n       generic_params (std::move (generic_params)),"}, {"sha": "bd3b0f0610d5668af538bf2f4d7f074bb4c04169", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -240,6 +240,8 @@ class PathExprSegment\n     rust_assert (has_generic_args ());\n     return generic_args;\n   }\n+\n+  PathIdentSegment &get_ident_segment () { return segment_name; }\n };\n \n // AST node representing a pattern that involves a \"path\" - abstract base class\n@@ -276,6 +278,15 @@ class PathPattern : public Pattern\n   // TODO: this seems kinda dodgy\n   std::vector<PathExprSegment> &get_segments () { return segments; }\n   const std::vector<PathExprSegment> &get_segments () const { return segments; }\n+\n+  void iterate_path_segments (std::function<bool (PathExprSegment &)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb (*it))\n+\t  return;\n+      }\n+  }\n };\n \n /* AST node representing a path-in-expression pattern (path that allows generic\n@@ -285,6 +296,8 @@ class PathInExpression : public PathPattern, public PathExpr\n   bool has_opening_scope_resolution;\n   Location locus;\n \n+  NodeId _node_id;\n+\n public:\n   std::string as_string () const override;\n \n@@ -296,7 +309,8 @@ class PathInExpression : public PathPattern, public PathExpr\n \t\t    = std::vector<Attribute> ())\n     : PathPattern (std::move (path_segments)),\n       PathExpr (std::move (outer_attrs)),\n-      has_opening_scope_resolution (has_opening_scope_resolution), locus (locus)\n+      has_opening_scope_resolution (has_opening_scope_resolution),\n+      locus (locus), _node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Creates an error state path in expression.\n@@ -328,6 +342,9 @@ class PathInExpression : public PathPattern, public PathExpr\n   // Invalid if path is empty (error state), so base stripping on that.\n   void mark_for_strip () override { remove_all_segments (); }\n   bool is_marked_for_strip () const override { return is_error (); }\n+  bool opening_scope_resolution () { return has_opening_scope_resolution; }\n+\n+  NodeId get_node_id () const override { return _node_id; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object rather\n@@ -404,6 +421,13 @@ class TypePathSegment\n \n   // not pure virtual as class not abstract\n   virtual void accept_vis (ASTVisitor &vis);\n+\n+  bool get_separating_scope_resolution () const\n+  {\n+    return has_separating_scope_resolution;\n+  }\n+\n+  PathIdentSegment get_ident_segment () { return ident_segment; };\n };\n \n // Segment used in type path with generic args\n@@ -635,7 +659,8 @@ class TypePath : public TypeNoBounds\n   // Constructor\n   TypePath (std::vector<std::unique_ptr<TypePathSegment> > segments,\n \t    Location locus, bool has_opening_scope_resolution = false)\n-    : has_opening_scope_resolution (has_opening_scope_resolution),\n+    : TypeNoBounds (),\n+      has_opening_scope_resolution (has_opening_scope_resolution),\n       segments (std::move (segments)), locus (locus)\n   {}\n \n@@ -689,6 +714,17 @@ class TypePath : public TypeNoBounds\n   {\n     return segments;\n   }\n+\n+  size_t get_num_segments () const { return segments.size (); }\n+\n+  void iterate_segments (std::function<bool (TypePathSegment *)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb ((*it).get ()))\n+\t  return;\n+      }\n+  }\n };\n \n struct QualifiedPathType"}, {"sha": "dc4d48c62fef9026d0918ceac913122cf2fccb03", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -69,16 +69,18 @@ class IdentifierPattern : public Pattern\n   IdentifierPattern (Identifier ident, Location locus, bool is_ref = false,\n \t\t     bool is_mut = false,\n \t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n-    : variable_ident (std::move (ident)), is_ref (is_ref), is_mut (is_mut),\n-      to_bind (std::move (to_bind)), locus (locus)\n+    : Pattern (), variable_ident (std::move (ident)), is_ref (is_ref),\n+      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus)\n   {}\n \n   // Copy constructor with clone\n   IdentifierPattern (IdentifierPattern const &other)\n     : variable_ident (other.variable_ident), is_ref (other.is_ref),\n       is_mut (other.is_mut), locus (other.locus)\n   {\n-    // fix to prevent null pointer dereference\n+    node_id = other.node_id;\n+    // fix to get prevent null pointer dereference\n+\n     if (other.to_bind != nullptr)\n       to_bind = other.to_bind->clone_pattern ();\n   }\n@@ -90,6 +92,7 @@ class IdentifierPattern : public Pattern\n     is_ref = other.is_ref;\n     is_mut = other.is_mut;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     // fix to prevent null pointer dereference\n     if (other.to_bind != nullptr)\n@@ -118,6 +121,9 @@ class IdentifierPattern : public Pattern\n \n   Identifier get_ident () const { return variable_ident; }\n \n+  bool get_is_mut () const { return is_mut; }\n+  bool get_is_ref () const { return is_ref; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "6410fd414bc4ba6a3d6586a84346cb6088ee0a6d", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,249 @@\n+\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_BASE\n+#define RUST_COMPILE_BASE\n+\n+#include \"rust-compile-context.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class HIRCompileBase : public HIR::HIRVisitor\n+{\n+public:\n+  virtual ~HIRCompileBase () {}\n+\n+  // rust-ast.h\n+  // virtual void visit(AttrInput& attr_input) {}\n+  // virtual void visit(TokenTree& token_tree) {}\n+  // virtual void visit(MacroMatch& macro_match) {}\n+  virtual void visit (HIR::Token &tok) {}\n+  virtual void visit (HIR::DelimTokenTree &delim_tok_tree) {}\n+  virtual void visit (HIR::AttrInputMetaItemContainer &input) {}\n+  // virtual void visit(MetaItem& meta_item) {}\n+  // virtual void visit(Stmt& stmt) {}\n+  // virtual void visit(Expr& expr) {}\n+  virtual void visit (HIR::IdentifierExpr &ident_expr) {}\n+  // virtual void visit(Pattern& pattern) {}\n+  // virtual void visit(Type& type) {}\n+  // virtual void visit(TypeParamBound& type_param_bound) {}\n+  virtual void visit (HIR::Lifetime &lifetime) {}\n+  // virtual void visit(GenericParam& generic_param) {}\n+  virtual void visit (HIR::LifetimeParam &lifetime_param) {}\n+  // virtual void visit(TraitItem& trait_item) {}\n+  // virtual void visit(InherentImplItem& inherent_impl_item) {}\n+  // virtual void visit(TraitImplItem& trait_impl_item) {}\n+  virtual void visit (HIR::MacroInvocationSemi &macro) {}\n+\n+  // rust-path.h\n+  virtual void visit (HIR::PathInExpression &path) {}\n+  virtual void visit (HIR::TypePathSegment &segment) {}\n+  virtual void visit (HIR::TypePathSegmentGeneric &segment) {}\n+  virtual void visit (HIR::TypePathSegmentFunction &segment) {}\n+  virtual void visit (HIR::TypePath &path) {}\n+  virtual void visit (HIR::QualifiedPathInExpression &path) {}\n+  virtual void visit (HIR::QualifiedPathInType &path) {}\n+\n+  // rust-expr.h\n+  virtual void visit (HIR::LiteralExpr &expr) {}\n+  virtual void visit (HIR::AttrInputLiteral &attr_input) {}\n+  virtual void visit (HIR::MetaItemLitExpr &meta_item) {}\n+  virtual void visit (HIR::MetaItemPathLit &meta_item) {}\n+  virtual void visit (HIR::BorrowExpr &expr) {}\n+  virtual void visit (HIR::DereferenceExpr &expr) {}\n+  virtual void visit (HIR::ErrorPropagationExpr &expr) {}\n+  virtual void visit (HIR::NegationExpr &expr) {}\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &expr) {}\n+  virtual void visit (HIR::ComparisonExpr &expr) {}\n+  virtual void visit (HIR::LazyBooleanExpr &expr) {}\n+  virtual void visit (HIR::TypeCastExpr &expr) {}\n+  virtual void visit (HIR::AssignmentExpr &expr) {}\n+  virtual void visit (HIR::CompoundAssignmentExpr &expr) {}\n+  virtual void visit (HIR::GroupedExpr &expr) {}\n+  // virtual void visit(ArrayElems& elems) {}\n+  virtual void visit (HIR::ArrayElemsValues &elems) {}\n+  virtual void visit (HIR::ArrayElemsCopied &elems) {}\n+  virtual void visit (HIR::ArrayExpr &expr) {}\n+  virtual void visit (HIR::ArrayIndexExpr &expr) {}\n+  virtual void visit (HIR::TupleExpr &expr) {}\n+  virtual void visit (HIR::TupleIndexExpr &expr) {}\n+  virtual void visit (HIR::StructExprStruct &expr) {}\n+  // virtual void visit(StructExprField& field) {}\n+  virtual void visit (HIR::StructExprFieldIdentifier &field) {}\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &field) {}\n+  virtual void visit (HIR::StructExprFieldIndexValue &field) {}\n+  virtual void visit (HIR::StructExprStructFields &expr) {}\n+  virtual void visit (HIR::StructExprStructBase &expr) {}\n+  virtual void visit (HIR::StructExprTuple &expr) {}\n+  virtual void visit (HIR::StructExprUnit &expr) {}\n+  // virtual void visit(EnumExprField& field) {}\n+  virtual void visit (HIR::EnumExprFieldIdentifier &field) {}\n+  virtual void visit (HIR::EnumExprFieldIdentifierValue &field) {}\n+  virtual void visit (HIR::EnumExprFieldIndexValue &field) {}\n+  virtual void visit (HIR::EnumExprStruct &expr) {}\n+  virtual void visit (HIR::EnumExprTuple &expr) {}\n+  virtual void visit (HIR::EnumExprFieldless &expr) {}\n+  virtual void visit (HIR::CallExpr &expr) {}\n+  virtual void visit (HIR::MethodCallExpr &expr) {}\n+  virtual void visit (HIR::FieldAccessExpr &expr) {}\n+  virtual void visit (HIR::ClosureExprInner &expr) {}\n+  virtual void visit (HIR::BlockExpr &expr) {}\n+  virtual void visit (HIR::ClosureExprInnerTyped &expr) {}\n+  virtual void visit (HIR::ContinueExpr &expr) {}\n+  virtual void visit (HIR::BreakExpr &expr) {}\n+  virtual void visit (HIR::RangeFromToExpr &expr) {}\n+  virtual void visit (HIR::RangeFromExpr &expr) {}\n+  virtual void visit (HIR::RangeToExpr &expr) {}\n+  virtual void visit (HIR::RangeFullExpr &expr) {}\n+  virtual void visit (HIR::RangeFromToInclExpr &expr) {}\n+  virtual void visit (HIR::RangeToInclExpr &expr) {}\n+  virtual void visit (HIR::ReturnExpr &expr) {}\n+  virtual void visit (HIR::UnsafeBlockExpr &expr) {}\n+  virtual void visit (HIR::LoopExpr &expr) {}\n+  virtual void visit (HIR::WhileLoopExpr &expr) {}\n+  virtual void visit (HIR::WhileLetLoopExpr &expr) {}\n+  virtual void visit (HIR::ForLoopExpr &expr) {}\n+  virtual void visit (HIR::IfExpr &expr) {}\n+  virtual void visit (HIR::IfExprConseqElse &expr) {}\n+  virtual void visit (HIR::IfExprConseqIf &expr) {}\n+  virtual void visit (HIR::IfExprConseqIfLet &expr) {}\n+  virtual void visit (HIR::IfLetExpr &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqElse &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqIf &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqIfLet &expr) {}\n+  // virtual void visit(MatchCase& match_case) {}\n+  // virtual void visit (HIR::MatchCaseBlockExpr &match_case) {}\n+  // virtual void visit (HIR::MatchCaseExpr &match_case) {}\n+  virtual void visit (HIR::MatchExpr &expr) {}\n+  virtual void visit (HIR::AwaitExpr &expr) {}\n+  virtual void visit (HIR::AsyncBlockExpr &expr) {}\n+\n+  // rust-item.h\n+  virtual void visit (HIR::TypeParam &param) {}\n+  // virtual void visit(WhereClauseItem& item) {}\n+  virtual void visit (HIR::LifetimeWhereClauseItem &item) {}\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &item) {}\n+  virtual void visit (HIR::Method &method) {}\n+  virtual void visit (HIR::ModuleBodied &module) {}\n+  virtual void visit (HIR::ModuleNoBody &module) {}\n+  virtual void visit (HIR::ExternCrate &crate) {}\n+  // virtual void visit(UseTree& use_tree) {}\n+  virtual void visit (HIR::UseTreeGlob &use_tree) {}\n+  virtual void visit (HIR::UseTreeList &use_tree) {}\n+  virtual void visit (HIR::UseTreeRebind &use_tree) {}\n+  virtual void visit (HIR::UseDeclaration &use_decl) {}\n+  virtual void visit (HIR::Function &function) {}\n+  virtual void visit (HIR::TypeAlias &type_alias) {}\n+  virtual void visit (HIR::StructStruct &struct_item) {}\n+  virtual void visit (HIR::TupleStruct &tuple_struct) {}\n+  virtual void visit (HIR::EnumItem &item) {}\n+  virtual void visit (HIR::EnumItemTuple &item) {}\n+  virtual void visit (HIR::EnumItemStruct &item) {}\n+  virtual void visit (HIR::EnumItemDiscriminant &item) {}\n+  virtual void visit (HIR::Enum &enum_item) {}\n+  virtual void visit (HIR::Union &union_item) {}\n+  virtual void visit (HIR::ConstantItem &const_item) {}\n+  virtual void visit (HIR::StaticItem &static_item) {}\n+  virtual void visit (HIR::TraitItemFunc &item) {}\n+  virtual void visit (HIR::TraitItemMethod &item) {}\n+  virtual void visit (HIR::TraitItemConst &item) {}\n+  virtual void visit (HIR::TraitItemType &item) {}\n+  virtual void visit (HIR::Trait &trait) {}\n+  virtual void visit (HIR::InherentImpl &impl) {}\n+  virtual void visit (HIR::TraitImpl &impl) {}\n+  // virtual void visit(ExternalItem& item) {}\n+  virtual void visit (HIR::ExternalStaticItem &item) {}\n+  virtual void visit (HIR::ExternalFunctionItem &item) {}\n+  virtual void visit (HIR::ExternBlock &block) {}\n+\n+  // rust-macro.h\n+  virtual void visit (HIR::MacroMatchFragment &match) {}\n+  virtual void visit (HIR::MacroMatchRepetition &match) {}\n+  virtual void visit (HIR::MacroMatcher &matcher) {}\n+  virtual void visit (HIR::MacroRulesDefinition &rules_def) {}\n+  virtual void visit (HIR::MacroInvocation &macro_invoc) {}\n+  virtual void visit (HIR::MetaItemPath &meta_item) {}\n+  virtual void visit (HIR::MetaItemSeq &meta_item) {}\n+  virtual void visit (HIR::MetaWord &meta_item) {}\n+  virtual void visit (HIR::MetaNameValueStr &meta_item) {}\n+  virtual void visit (HIR::MetaListPaths &meta_item) {}\n+  virtual void visit (HIR::MetaListNameValueStr &meta_item) {}\n+\n+  // rust-pattern.h\n+  virtual void visit (HIR::LiteralPattern &pattern) {}\n+  virtual void visit (HIR::IdentifierPattern &pattern) {}\n+  virtual void visit (HIR::WildcardPattern &pattern) {}\n+  // virtual void visit(RangePatternBound& bound) {}\n+  virtual void visit (HIR::RangePatternBoundLiteral &bound) {}\n+  virtual void visit (HIR::RangePatternBoundPath &bound) {}\n+  virtual void visit (HIR::RangePatternBoundQualPath &bound) {}\n+  virtual void visit (HIR::RangePattern &pattern) {}\n+  virtual void visit (HIR::ReferencePattern &pattern) {}\n+  // virtual void visit(StructPatternField& field) {}\n+  virtual void visit (HIR::StructPatternFieldTuplePat &field) {}\n+  virtual void visit (HIR::StructPatternFieldIdentPat &field) {}\n+  virtual void visit (HIR::StructPatternFieldIdent &field) {}\n+  virtual void visit (HIR::StructPattern &pattern) {}\n+  // virtual void visit(TupleStructItems& tuple_items) {}\n+  virtual void visit (HIR::TupleStructItemsNoRange &tuple_items) {}\n+  virtual void visit (HIR::TupleStructItemsRange &tuple_items) {}\n+  virtual void visit (HIR::TupleStructPattern &pattern) {}\n+  // virtual void visit(TuplePatternItems& tuple_items) {}\n+  virtual void visit (HIR::TuplePatternItemsMultiple &tuple_items) {}\n+  virtual void visit (HIR::TuplePatternItemsRanged &tuple_items) {}\n+  virtual void visit (HIR::TuplePattern &pattern) {}\n+  virtual void visit (HIR::GroupedPattern &pattern) {}\n+  virtual void visit (HIR::SlicePattern &pattern) {}\n+\n+  // rust-stmt.h\n+  virtual void visit (HIR::EmptyStmt &stmt) {}\n+  virtual void visit (HIR::LetStmt &stmt) {}\n+  virtual void visit (HIR::ExprStmtWithoutBlock &stmt) {}\n+  virtual void visit (HIR::ExprStmtWithBlock &stmt) {}\n+\n+  // rust-type.h\n+  virtual void visit (HIR::TraitBound &bound) {}\n+  virtual void visit (HIR::ImplTraitType &type) {}\n+  virtual void visit (HIR::TraitObjectType &type) {}\n+  virtual void visit (HIR::ParenthesisedType &type) {}\n+  virtual void visit (HIR::ImplTraitTypeOneBound &type) {}\n+  virtual void visit (HIR::TraitObjectTypeOneBound &type) {}\n+  virtual void visit (HIR::TupleType &type) {}\n+  virtual void visit (HIR::NeverType &type) {}\n+  virtual void visit (HIR::RawPointerType &type) {}\n+  virtual void visit (HIR::ReferenceType &type) {}\n+  virtual void visit (HIR::ArrayType &type) {}\n+  virtual void visit (HIR::SliceType &type) {}\n+  virtual void visit (HIR::InferredType &type) {}\n+  virtual void visit (HIR::BareFunctionType &type) {}\n+\n+protected:\n+  HIRCompileBase (Context *ctx) : ctx (ctx) {}\n+\n+  Context *get_context () { return ctx; }\n+\n+  Context *ctx;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_BASE"}, {"sha": "f8906788e1298dac25e0e2d98b173dd0c03d1e4b", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,247 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_CONTEXT\n+#define RUST_COMPILE_CONTEXT\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-backend.h\"\n+#include \"rust-compile-tyty.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+struct fncontext\n+{\n+  ::Bfunction *fndecl;\n+  ::Bvariable *ret_addr;\n+};\n+\n+class Context\n+{\n+public:\n+  Context (::Backend *backend)\n+    : backend (backend), resolver (Resolver::Resolver::get ()),\n+      tyctx (Resolver::TypeCheckContext::get ()),\n+      mappings (Analysis::Mappings::get ())\n+  {\n+    // insert the builtins\n+    auto builtins = resolver->get_builtin_types ();\n+    for (auto it = builtins.begin (); it != builtins.end (); it++)\n+      {\n+\tHirId ref;\n+\trust_assert (\n+\t  tyctx->lookup_type_by_node_id ((*it)->get_node_id (), &ref));\n+\n+\tTyTy::TyBase *lookup;\n+\trust_assert (tyctx->lookup_type (ref, &lookup));\n+\n+\tauto compiled = TyTyCompile::compile (backend, lookup);\n+\tcompiled_type_map[ref] = compiled;\n+      }\n+  }\n+\n+  ~Context () {}\n+\n+  bool lookup_compiled_types (HirId id, ::Btype **type)\n+  {\n+    auto it = compiled_type_map.find (id);\n+    if (it == compiled_type_map.end ())\n+      return false;\n+\n+    *type = it->second;\n+    return true;\n+  }\n+\n+  void insert_compiled_type (HirId id, ::Btype *type)\n+  {\n+    compiled_type_map[id] = type;\n+  }\n+\n+  ::Backend *get_backend () { return backend; }\n+  Resolver::Resolver *get_resolver () { return resolver; }\n+  Resolver::TypeCheckContext *get_tyctx () { return tyctx; }\n+  Analysis::Mappings *get_mappings () { return mappings; }\n+\n+  void push_block (Bblock *scope)\n+  {\n+    scope_stack.push_back (scope);\n+    statements.push_back ({});\n+  }\n+\n+  Bblock *pop_block ()\n+  {\n+    auto block = scope_stack.back ();\n+    scope_stack.pop_back ();\n+\n+    auto stmts = statements.back ();\n+    statements.pop_back ();\n+\n+    backend->block_add_statements (block, stmts);\n+\n+    return block;\n+  }\n+\n+  Bblock *peek_enclosing_scope ()\n+  {\n+    if (scope_stack.size () == 0)\n+      return nullptr;\n+\n+    return scope_stack.back ();\n+  }\n+\n+  void add_statement (Bstatement *stmt) { statements.back ().push_back (stmt); }\n+\n+  void insert_var_decl (HirId id, ::Bvariable *decl)\n+  {\n+    compiled_var_decls[id] = decl;\n+  }\n+\n+  bool lookup_var_decl (HirId id, ::Bvariable **decl)\n+  {\n+    auto it = compiled_var_decls.find (id);\n+    if (it == compiled_var_decls.end ())\n+      return false;\n+\n+    *decl = it->second;\n+    return true;\n+  }\n+\n+  void insert_function_decl (HirId id, ::Bfunction *fn)\n+  {\n+    compiled_fn_map[id] = fn;\n+  }\n+\n+  bool lookup_function_decl (HirId id, ::Bfunction **fn)\n+  {\n+    auto it = compiled_fn_map.find (id);\n+    if (it == compiled_fn_map.end ())\n+      return false;\n+\n+    *fn = it->second;\n+    return true;\n+  }\n+\n+  void push_fn (::Bfunction *fn, ::Bvariable *ret_addr)\n+  {\n+    fn_stack.push_back (fncontext{fn, ret_addr});\n+  }\n+  void pop_fn () { fn_stack.pop_back (); }\n+  fncontext peek_fn () { return fn_stack.back (); }\n+\n+  void push_type (::Btype *t) { type_decls.push_back (t); }\n+  void push_var (::Bvariable *v) { var_decls.push_back (v); }\n+  void push_const (::Bexpression *c) { const_decls.push_back (c); }\n+  void push_function (::Bfunction *f) { func_decls.push_back (f); }\n+\n+  void write_to_backend ()\n+  {\n+    backend->write_global_definitions (type_decls, const_decls, func_decls,\n+\t\t\t\t       var_decls);\n+  }\n+\n+  bool function_completed (Bfunction *fn)\n+  {\n+    for (auto it = func_decls.begin (); it != func_decls.end (); it++)\n+      {\n+\tBfunction *i = (*it);\n+\tif (i == fn)\n+\t  {\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+private:\n+  ::Backend *backend;\n+  Resolver::Resolver *resolver;\n+  Resolver::TypeCheckContext *tyctx;\n+  Analysis::Mappings *mappings;\n+\n+  // state\n+  std::vector<fncontext> fn_stack;\n+  std::map<HirId, ::Bvariable *> compiled_var_decls;\n+  std::map<HirId, ::Btype *> compiled_type_map;\n+  std::map<HirId, ::Bfunction *> compiled_fn_map;\n+  std::vector< ::std::vector<Bstatement *> > statements;\n+  std::vector< ::Bblock *> scope_stack;\n+\n+  // To GCC middle-end\n+  std::vector< ::Btype *> type_decls;\n+  std::vector< ::Bvariable *> var_decls;\n+  std::vector< ::Bexpression *> const_decls;\n+  std::vector< ::Bfunction *> func_decls;\n+};\n+\n+class TyTyResolveCompile : public TyTy::TyVisitor\n+{\n+public:\n+  static ::Btype *compile (Context *ctx, TyTy::TyBase *ty)\n+  {\n+    TyTyResolveCompile compiler (ctx);\n+    ty->accept_vis (compiler);\n+    return compiler.translated;\n+  }\n+\n+  virtual ~TyTyResolveCompile () {}\n+\n+  void visit (TyTy::FnType &type) { gcc_unreachable (); }\n+\n+  void visit (TyTy::BoolType &type)\n+  {\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n+  void visit (TyTy::IntType &type)\n+  {\n+    printf (\"type [%s] has ref: %u\\n\", type.as_string ().c_str (),\n+\t    type.get_ref ());\n+\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n+  void visit (TyTy::UintType &type)\n+  {\n+    ::Btype *compiled_type = nullptr;\n+    bool ok = ctx->lookup_compiled_types (type.get_ref (), &compiled_type);\n+    rust_assert (ok);\n+    translated = compiled_type;\n+  }\n+\n+private:\n+  TyTyResolveCompile (Context *ctx) : ctx (ctx) {}\n+\n+  Context *ctx;\n+  ::Btype *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_CONTEXT"}, {"sha": "7808af2bb4fed72de27e7634891420d608d001ce", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,285 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_EXPR\n+#define RUST_COMPILE_EXPR\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+#include \"rust-compile-resolve-path.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileExpr : public HIRCompileBase\n+{\n+public:\n+  static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n+  {\n+    CompileExpr compiler (ctx);\n+    expr->accept_vis (compiler);\n+    return compiler.translated;\n+  }\n+\n+  virtual ~CompileExpr () {}\n+\n+  void visit (HIR::ReturnExpr &expr)\n+  {\n+    Bexpression *compiled_expr\n+      = CompileExpr::Compile (expr.return_expr.get (), ctx);\n+    rust_assert (compiled_expr != nullptr);\n+\n+    auto fncontext = ctx->peek_fn ();\n+\n+    std::vector<Bexpression *> retstmts;\n+    retstmts.push_back (compiled_expr);\n+    auto s = ctx->get_backend ()->return_statement (fncontext.fndecl, retstmts,\n+\t\t\t\t\t\t    expr.get_locus ());\n+    ctx->add_statement (s);\n+  }\n+\n+  void visit (HIR::CallExpr &expr)\n+  {\n+    Bexpression *fn = ResolvePath::Compile (expr.get_fnexpr (), ctx);\n+    rust_assert (fn != nullptr);\n+\n+    std::vector<Bexpression *> args;\n+    expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+      Bexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+      rust_assert (compiled_expr != nullptr);\n+      args.push_back (compiled_expr);\n+      return true;\n+    });\n+\n+    auto fncontext = ctx->peek_fn ();\n+    translated\n+      = ctx->get_backend ()->call_expression (fncontext.fndecl, fn, args,\n+\t\t\t\t\t      nullptr, expr.get_locus ());\n+  }\n+\n+  void visit (HIR::IdentifierExpr &expr)\n+  {\n+    // need to look up the reference for this identifier\n+    NodeId ref_node_id;\n+    if (!ctx->get_resolver ()->lookup_resolved_name (\n+\t  expr.get_mappings ().get_nodeid (), &ref_node_id))\n+      {\n+\trust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n+\treturn;\n+      }\n+\n+    printf (\"have ast node id %u ref %u for expr [%s]\\n\",\n+\t    expr.get_mappings ().get_nodeid (), ref_node_id,\n+\t    expr.as_string ().c_str ());\n+\n+    // these ref_node_ids will resolve to a pattern declaration but we are\n+    // interested in the definition that this refers to get the parent id\n+    Resolver::Definition def;\n+    if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n+      {\n+\trust_error_at (expr.get_locus (), \"unknown reference\");\n+\treturn;\n+      }\n+\n+    HirId ref;\n+    if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\t  expr.get_mappings ().get_crate_num (), def.parent, &ref))\n+      {\n+\trust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    Bvariable *var = nullptr;\n+    if (!ctx->lookup_var_decl (ref, &var))\n+      {\n+\trust_fatal_error (expr.get_locus (),\n+\t\t\t  \"failed to lookup compiled variable\");\n+\treturn;\n+      }\n+\n+    translated = ctx->get_backend ()->var_expression (var, expr.get_locus ());\n+  }\n+\n+  void visit (HIR::LiteralExpr &expr)\n+  {\n+    switch (expr.get_lit_type ())\n+      {\n+\tcase HIR::Literal::BOOL: {\n+\t  bool bval = expr.as_string ().compare (\"true\") == 0;\n+\t  translated = ctx->get_backend ()->boolean_constant_expression (bval);\n+\t}\n+\treturn;\n+\n+\tcase HIR::Literal::INT: {\n+\t  mpz_t ival;\n+\t  if (mpz_init_set_str (ival, expr.as_string ().c_str (), 10) != 0)\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (), \"bad number in literal\");\n+\t      return;\n+\t    }\n+\n+\t  TyTy::TyBase *tyty = nullptr;\n+\t  if (!ctx->get_tyctx ()->lookup_type (\n+\t\texpr.get_mappings ().get_hirid (), &tyty))\n+\t    {\n+\t      rust_fatal_error (expr.get_locus (),\n+\t\t\t\t\"did not resolve type for this literal expr\");\n+\t      return;\n+\t    }\n+\n+\t  Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\t  translated\n+\t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n+\t}\n+\treturn;\n+\n+      default:\n+\trust_fatal_error (expr.get_locus (), \"unknown literal\");\n+\treturn;\n+      }\n+\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (HIR::AssignmentExpr &expr)\n+  {\n+    fncontext fn = ctx->peek_fn ();\n+    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    Bstatement *assignment\n+      = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, rhs,\n+\t\t\t\t\t\t   expr.get_locus ());\n+    ctx->add_statement (assignment);\n+  }\n+\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr)\n+  {\n+    Operator op;\n+    switch (expr.get_expr_type ())\n+      {\n+      case HIR::ArithmeticOrLogicalExpr::ADD:\n+\top = OPERATOR_PLUS;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::SUBTRACT:\n+\top = OPERATOR_MINUS;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::MULTIPLY:\n+\top = OPERATOR_MULT;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::DIVIDE:\n+\top = OPERATOR_DIV;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::MODULUS:\n+\top = OPERATOR_MOD;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_AND:\n+\top = OPERATOR_AND;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_OR:\n+\top = OPERATOR_OR;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::BITWISE_XOR:\n+\top = OPERATOR_XOR;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n+\top = OPERATOR_LSHIFT;\n+\tbreak;\n+      case HIR::ArithmeticOrLogicalExpr::RIGHT_SHIFT:\n+\top = OPERATOR_RSHIFT;\n+\tbreak;\n+      default:\n+\trust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n+\treturn;\n+      }\n+\n+    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    translated = ctx->get_backend ()->binary_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t expr.get_locus ());\n+  }\n+\n+  void visit (HIR::ComparisonExpr &expr)\n+  {\n+    Operator op;\n+    switch (expr.get_expr_type ())\n+      {\n+      case HIR::ComparisonExpr::EQUAL:\n+\top = OPERATOR_EQEQ;\n+\tbreak;\n+      case HIR::ComparisonExpr::NOT_EQUAL:\n+\top = OPERATOR_NOTEQ;\n+\tbreak;\n+      case HIR::ComparisonExpr::GREATER_THAN:\n+\top = OPERATOR_GT;\n+\tbreak;\n+      case HIR::ComparisonExpr::LESS_THAN:\n+\top = OPERATOR_LT;\n+\tbreak;\n+      case HIR::ComparisonExpr::GREATER_OR_EQUAL:\n+\top = OPERATOR_GE;\n+\tbreak;\n+      case HIR::ComparisonExpr::LESS_OR_EQUAL:\n+\top = OPERATOR_LE;\n+\tbreak;\n+      default:\n+\trust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n+\treturn;\n+      }\n+\n+    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    translated = ctx->get_backend ()->binary_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t expr.get_locus ());\n+  }\n+\n+  void visit (HIR::LazyBooleanExpr &expr)\n+  {\n+    Operator op;\n+    switch (expr.get_expr_type ())\n+      {\n+      case HIR::LazyBooleanExpr::LOGICAL_OR:\n+\top = OPERATOR_OROR;\n+\tbreak;\n+      case HIR::LazyBooleanExpr::LOGICAL_AND:\n+\top = OPERATOR_ANDAND;\n+\tbreak;\n+      default:\n+\trust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n+\treturn;\n+      }\n+\n+    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+    translated = ctx->get_backend ()->binary_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t expr.get_locus ());\n+  }\n+\n+private:\n+  CompileExpr (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n+\n+  Bexpression *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_EXPR"}, {"sha": "dd0743515ed1c1d0ee7f998639ab500a14dc74c5", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,180 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_ITEM\n+#define RUST_COMPILE_ITEM\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+#include \"rust-compile-var-decl.h\"\n+#include \"rust-compile-stmt.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileItem : public HIRCompileBase\n+{\n+public:\n+  static void compile (HIR::Item *item, Context *ctx)\n+  {\n+    CompileItem compiler (ctx);\n+    item->accept_vis (compiler);\n+  }\n+\n+  virtual ~CompileItem () {}\n+\n+  void visit (HIR::Function &function)\n+  {\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (function.get_mappings ().get_hirid (),\n+\t\t\t\t   &lookup))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    printf (\"returning early the function [%s] is completed!\\n\",\n+\t\t    function.as_string ().c_str ());\n+\t    return;\n+\t  }\n+      }\n+\n+    TyTy::TyBase *fnType;\n+    if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n+\t\t\t\t\t &fnType))\n+      {\n+\trust_fatal_error (function.locus, \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    // convert to the actual function type\n+    auto compiled_fn_type = TyTyCompile::compile (ctx->get_backend (), fnType);\n+\n+    Bfunction *fndecl\n+      = ctx->get_backend ()->function (compiled_fn_type, function.function_name,\n+\t\t\t\t       \"\" /* asm_name */, 0 /* flags */,\n+\t\t\t\t       function.get_locus ());\n+    ctx->insert_function_decl (function.get_mappings ().get_hirid (), fndecl);\n+\n+    // setup the params\n+    TyTy::TyBase *tyret = TyTyExtractRetFromFnType::compile (fnType);\n+    std::vector<TyTy::ParamType *> typarams\n+      = TyTyExtractParamsFromFnType::compile (fnType);\n+    std::vector<Bvariable *> param_vars;\n+\n+    for (auto &it : typarams)\n+      {\n+\tauto compiled_param\n+\t  = TyTyCompileParam::compile (ctx->get_backend (), fndecl, it);\n+\tparam_vars.push_back (compiled_param);\n+\n+\tctx->insert_var_decl (it->get_ref (), compiled_param);\n+      }\n+\n+    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+      {\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to setup parameter variables\");\n+\treturn;\n+      }\n+\n+    // lookup locals\n+    auto block_expr = function.function_body.get ();\n+    auto body_mappings = block_expr->get_mappings ();\n+\n+    Resolver::Rib *rib = nullptr;\n+    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n+\t\t\t\t\t      &rib))\n+      {\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to setup locals per block\");\n+\treturn;\n+      }\n+\n+    std::vector<Bvariable *> locals;\n+    rib->iterate_decls ([&] (NodeId n) mutable -> bool {\n+      Resolver::Definition d;\n+      bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n+      rust_assert (ok);\n+\n+      HIR::Stmt *decl = nullptr;\n+      ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+      rust_assert (ok);\n+\n+      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+      locals.push_back (compiled);\n+\n+      return true;\n+    });\n+\n+    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+    HIR::BlockExpr *function_body = function.function_body.get ();\n+\n+    Location start_location = function_body->get_locus ();\n+    Location end_location = function_body->get_closing_locus ();\n+\n+    Bblock *code_block\n+      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t    start_location, end_location);\n+    ctx->push_block (code_block);\n+\n+    Bvariable *return_address = nullptr;\n+    if (function.has_function_return_type ())\n+      {\n+\tBtype *return_type = TyTyCompile::compile (ctx->get_backend (), tyret);\n+\n+\tbool address_is_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\n+\treturn_address = ctx->get_backend ()->temporary_variable (\n+\t  fndecl, code_block, return_type, NULL, address_is_taken,\n+\t  function.get_locus (), &ret_var_stmt);\n+\n+\tctx->add_statement (ret_var_stmt);\n+      }\n+\n+    ctx->push_fn (fndecl, return_address);\n+\n+    // compile the block\n+    function_body->iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+      CompileStmt::Compile (s, ctx);\n+      return true;\n+    });\n+\n+    ctx->pop_block ();\n+    auto body = ctx->get_backend ()->block_statement (code_block);\n+    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n+      {\n+\trust_error_at (function.get_locus (), \"failed to set body to function\");\n+\treturn;\n+      }\n+\n+    ctx->pop_fn ();\n+\n+    ctx->push_function (fndecl);\n+  }\n+\n+private:\n+  CompileItem (Context *ctx) : HIRCompileBase (ctx) {}\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_ITEM"}, {"sha": "e6683fa9f45a083fd24b73d93f3900089eef105b", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,81 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-linemap.h\"\n+#include \"rust-backend.h\"\n+#include \"rust-compile-resolve-path.h\"\n+#include \"rust-compile-item.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+ResolvePath::visit (HIR::PathInExpression &expr)\n+{\n+  // need to look up the reference for this identifier\n+  NodeId ref_node_id;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &ref_node_id))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"failed to look up resolved name\");\n+      return;\n+    }\n+\n+  printf (\"PATHIN have ast node id %u ref %u for expr [%s]\\n\",\n+\t  expr.get_mappings ().get_nodeid (), ref_node_id,\n+\t  expr.as_string ().c_str ());\n+\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // assumes paths are functions for now\n+  Bfunction *fn;\n+  if (!ctx->lookup_function_decl (ref, &fn))\n+    {\n+      printf (\n+\t\"path failed to lookup function attempting to forward resolve!\\n\");\n+\n+      // this might fail because its a forward decl so we can attempt to\n+      // resolve it now\n+      HIR::Item *resolved_item = ctx->get_mappings ()->lookup_hir_item (\n+\texpr.get_mappings ().get_crate_num (), ref);\n+      if (resolved_item == nullptr)\n+\t{\n+\t  rust_fatal_error (expr.get_locus (), \"failed to lookup forward decl\");\n+\t  return;\n+\t}\n+\n+      CompileItem::compile (resolved_item, ctx);\n+      if (!ctx->lookup_function_decl (ref, &fn))\n+\t{\n+\t  rust_fatal_error (expr.get_locus (), \"forward decl was not compiled\");\n+\t  return;\n+\t}\n+    }\n+\n+  resolved\n+    = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "d8f393d5ccff6880894c68305b31d2ec78252b7a", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_RESOLVE_PATH\n+#define RUST_COMPILE_RESOLVE_PATH\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class ResolvePath : public HIRCompileBase\n+{\n+public:\n+  static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n+  {\n+    ResolvePath resolver (ctx);\n+    expr->accept_vis (resolver);\n+    rust_assert (resolver.resolved != nullptr);\n+    return resolver.resolved;\n+  }\n+\n+  virtual ~ResolvePath () {}\n+\n+  void visit (HIR::PathInExpression &expr);\n+\n+private:\n+  ResolvePath (Context *ctx) : HIRCompileBase (ctx), resolved (nullptr) {}\n+\n+  Bexpression *resolved;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_RESOLVE_PATH"}, {"sha": "0a081303332474e5e767454bf5487d1f687645ea", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_STMT\n+#define RUST_COMPILE_STMT\n+\n+#include \"rust-compile-base.h\"\n+#include \"rust-compile-tyty.h\"\n+#include \"rust-compile-expr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileStmt : public HIRCompileBase\n+{\n+public:\n+  static void Compile (HIR::Stmt *stmt, Context *ctx)\n+  {\n+    CompileStmt compiler (ctx);\n+    stmt->accept_vis (compiler);\n+    rust_assert (compiler.ok);\n+  }\n+\n+  virtual ~CompileStmt () {}\n+\n+  void visit (HIR::ExprStmtWithoutBlock &stmt)\n+  {\n+    ok = true;\n+    auto translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n+\n+    // these can be null\n+    if (translated == nullptr)\n+      return;\n+\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (HIR::LetStmt &stmt)\n+  {\n+    // marks that the statement has been looked at\n+    ok = true;\n+\n+    // nothing to do\n+    if (!stmt.has_init_expr ())\n+      return;\n+\n+    Bvariable *var = nullptr;\n+    if (!ctx->lookup_var_decl (stmt.get_mappings ().get_hirid (), &var))\n+      {\n+\trust_fatal_error (stmt.get_locus (),\n+\t\t\t  \"failed to lookup compiled variable decl\");\n+\treturn;\n+      }\n+\n+    auto *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+    auto fnctx = ctx->peek_fn ();\n+    auto s = ctx->get_backend ()->init_statement (fnctx.fndecl, var, init);\n+    ctx->add_statement (s);\n+  }\n+\n+private:\n+  CompileStmt (Context *ctx) : HIRCompileBase (ctx), ok (false) {}\n+\n+  bool ok;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_STMT"}, {"sha": "66d2472265cce0867ba7d6bb9fda734314f2d2e4", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,247 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_TYTY\n+#define RUST_COMPILE_TYTY\n+\n+#include \"rust-system.h\"\n+#include \"rust-location.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-backend.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class TyTyCompile : public TyTy::TyVisitor\n+{\n+public:\n+  static ::Btype *compile (::Backend *backend, TyTy::TyBase *ty)\n+  {\n+    TyTyCompile compiler (backend);\n+    ty->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+    return compiler.translated;\n+  }\n+\n+  ~TyTyCompile () {}\n+\n+  void visit (TyTy::InferType &type) override\n+  {\n+    // there shouldn't be any of these left\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::UnitType &type) override {}\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    Backend::Btyped_identifier receiver;\n+    std::vector<Backend::Btyped_identifier> parameters;\n+    std::vector<Backend::Btyped_identifier> results;\n+\n+    if (!type.get_return_type ()->is_unit ())\n+      {\n+\tauto hir_type = type.get_return_type ();\n+\tauto ret = TyTyCompile::compile (backend, hir_type);\n+\tresults.push_back (Backend::Btyped_identifier (\n+\t  \"_\", ret, mappings->lookup_location (hir_type->get_ref ())));\n+      }\n+\n+    for (size_t i = 0; i < type.num_params (); i++)\n+      {\n+\tauto param_tyty = type.param_at (i);\n+\tauto compiled_param_type\n+\t  = TyTyCompile::compile (backend, param_tyty->get_base_type ());\n+\tauto compiled_param = Backend::Btyped_identifier (\n+\t  param_tyty->get_identifier (), compiled_param_type,\n+\t  mappings->lookup_location (param_tyty->get_ref ()));\n+\n+\tparameters.push_back (compiled_param);\n+      }\n+\n+    translated\n+      = backend->function_type (receiver, parameters, results, NULL,\n+\t\t\t\tmappings->lookup_location (type.get_ref ()));\n+  }\n+\n+  void visit (TyTy::ParamType &type) override {}\n+\n+  void visit (TyTy::BoolType &type) override\n+  {\n+    translated = backend->named_type (\"bool\", backend->bool_type (),\n+\t\t\t\t      Linemap::predeclared_location ());\n+  }\n+\n+  void visit (TyTy::IntType &type) override\n+  {\n+    switch (type.get_kind ())\n+      {\n+      case TyTy::IntType::I8:\n+\ttranslated\n+\t  = backend->named_type (\"i8\", backend->integer_type (false, 8),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I16:\n+\ttranslated\n+\t  = backend->named_type (\"i16\", backend->integer_type (false, 16),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::IntType::I32:\n+\ttranslated\n+\t  = backend->named_type (\"i32\", backend->integer_type (false, 32),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+  void visit (TyTy::UintType &type) override\n+  {\n+    switch (type.get_kind ())\n+      {\n+      case TyTy::UintType::U8:\n+\ttranslated = backend->named_type (\"i8\", backend->integer_type (true, 8),\n+\t\t\t\t\t  Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U16:\n+\ttranslated\n+\t  = backend->named_type (\"i16\", backend->integer_type (true, 16),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+\n+      case TyTy::UintType::U32:\n+\ttranslated\n+\t  = backend->named_type (\"i32\", backend->integer_type (true, 32),\n+\t\t\t\t Linemap::predeclared_location ());\n+\treturn;\n+      }\n+    gcc_unreachable ();\n+  }\n+\n+private:\n+  TyTyCompile (::Backend *backend)\n+    : backend (backend), translated (nullptr),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  ::Backend *backend;\n+  ::Btype *translated;\n+  Analysis::Mappings *mappings;\n+};\n+\n+class TyTyExtractParamsFromFnType : public TyTy::TyVisitor\n+{\n+public:\n+  static std::vector<TyTy::ParamType *> compile (TyTy::TyBase *ty)\n+  {\n+    TyTyExtractParamsFromFnType compiler;\n+    ty->accept_vis (compiler);\n+    rust_assert (compiler.ok);\n+    return compiler.translated;\n+  }\n+\n+  ~TyTyExtractParamsFromFnType () {}\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    ok = true;\n+    for (size_t i = 0; i < type.num_params (); i++)\n+      {\n+\ttranslated.push_back (type.param_at (i));\n+      }\n+  }\n+\n+private:\n+  TyTyExtractParamsFromFnType () : ok (false) {}\n+\n+  bool ok;\n+  std::vector<TyTy::ParamType *> translated;\n+};\n+\n+class TyTyExtractRetFromFnType : public TyTy::TyVisitor\n+{\n+public:\n+  static TyTy::TyBase *compile (TyTy::TyBase *ty)\n+  {\n+    TyTyExtractRetFromFnType compiler;\n+    ty->accept_vis (compiler);\n+    rust_assert (compiler.ok);\n+    return compiler.translated;\n+  }\n+\n+  ~TyTyExtractRetFromFnType () {}\n+\n+  void visit (TyTy::FnType &type) override\n+  {\n+    ok = true;\n+    translated = type.get_return_type ();\n+  }\n+\n+private:\n+  TyTyExtractRetFromFnType () : ok (false), translated (nullptr) {}\n+\n+  bool ok;\n+  TyTy::TyBase *translated;\n+};\n+\n+class TyTyCompileParam : public TyTy::TyVisitor\n+{\n+public:\n+  static ::Bvariable *compile (::Backend *backend, Bfunction *fndecl,\n+\t\t\t       TyTy::TyBase *ty)\n+  {\n+    TyTyCompileParam compiler (backend, fndecl);\n+    ty->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+    return compiler.translated;\n+  }\n+\n+  ~TyTyCompileParam () {}\n+\n+  void visit (TyTy::ParamType &type) override\n+  {\n+    auto btype = TyTyCompile::compile (backend, type.get_base_type ());\n+    bool tree_addressable = false;\n+    translated = backend->parameter_variable (fndecl, type.get_identifier (),\n+\t\t\t\t\t      btype, tree_addressable,\n+\t\t\t\t\t      mappings->lookup_location (\n+\t\t\t\t\t\ttype.get_ref ()));\n+  }\n+\n+private:\n+  TyTyCompileParam (::Backend *backend, ::Bfunction *fndecl)\n+    : backend (backend), translated (nullptr), fndecl (fndecl),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  ::Backend *backend;\n+  ::Bvariable *translated;\n+  ::Bfunction *fndecl;\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_TYTY"}, {"sha": "be3141a2bae200b6b858131ed1e3c1239b20dd60", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,69 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_VAR_DECL\n+#define RUST_COMPILE_VAR_DECL\n+\n+#include \"rust-compile-base.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class CompileVarDecl : public HIRCompileBase\n+{\n+public:\n+  static ::Bvariable *compile (::Bfunction *fndecl, HIR::Stmt *stmt,\n+\t\t\t       Context *ctx)\n+  {\n+    CompileVarDecl compiler (ctx, fndecl);\n+    stmt->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+    ctx->insert_var_decl (stmt->get_mappings ().get_hirid (),\n+\t\t\t  compiler.translated);\n+    return compiler.translated;\n+  }\n+\n+  virtual ~CompileVarDecl () {}\n+\n+  void visit (HIR::LetStmt &stmt)\n+  {\n+    TyTy::TyBase *resolved_type = nullptr;\n+    bool ok = ctx->get_tyctx ()->lookup_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t\t      &resolved_type);\n+    rust_assert (ok);\n+\n+    ::Btype *translated_type = TyTyResolveCompile::compile (ctx, resolved_type);\n+\n+    translated = ctx->get_backend ()->local_variable (\n+      fndecl, stmt.get_pattern ()->as_string (), translated_type,\n+      NULL /*decl_var*/, false /*address_taken*/, stmt.get_locus ());\n+  }\n+\n+private:\n+  CompileVarDecl (Context *ctx, ::Bfunction *fndecl)\n+    : HIRCompileBase (ctx), fndecl (fndecl), translated (nullptr)\n+  {}\n+\n+  ::Bfunction *fndecl;\n+  ::Bvariable *translated;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_VAR_DECL"}, {"sha": "11c380b19251fe9ac0ec6a52c5151183a4f4e9a9", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 26, "deletions": 1480, "changes": 1506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -1,1501 +1,47 @@\n-#include \"rust-compile.h\"\n-#include \"rust-diagnostics.h\"\n-\n-namespace Rust {\n-namespace Compile {\n-\n-#define VISIT_POP(L, S, R, B)                                                  \\\n-  do                                                                           \\\n-    {                                                                          \\\n-      auto before = B.size ();                                                 \\\n-      S->accept_vis (*this);                                                   \\\n-      if (B.size () <= before)                                                 \\\n-\tbreak;                                                                 \\\n-      R = B.back ();                                                           \\\n-      B.pop_back ();                                                           \\\n-    }                                                                          \\\n-  while (0)\n-\n-Compilation::Compilation (AST::Crate &crate, ::Backend *backend)\n-  : crate (crate), backend (backend), scope (backend)\n-{}\n-\n-Compilation::~Compilation () {}\n-\n-bool\n-Compilation::Compile (AST::Crate &crate, ::Backend *backend)\n-{\n-  Compilation resolver (crate, backend);\n-  return resolver.go ();\n-}\n-\n-bool\n-Compilation::go ()\n-{\n-  scope.Push ();\n-\n-  // builtin primitives\n-  scope.InsertType (\"bool\",\n-\t\t    backend->named_type (\"bool\", backend->bool_type (),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"i64\",\n-\t\t    backend->named_type (\"i64\",\n-\t\t\t\t\t backend->integer_type (false, 64),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"i32\",\n-\t\t    backend->named_type (\"i32\",\n-\t\t\t\t\t backend->integer_type (false, 32),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"i16\",\n-\t\t    backend->named_type (\"i16\",\n-\t\t\t\t\t backend->integer_type (false, 16),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"i8\",\n-\t\t    backend->named_type (\"i8\", backend->integer_type (false, 8),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"u64\",\n-\t\t    backend->named_type (\"u64\",\n-\t\t\t\t\t backend->integer_type (true, 64),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"u32\",\n-\t\t    backend->named_type (\"u32\",\n-\t\t\t\t\t backend->integer_type (true, 32),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"u16\",\n-\t\t    backend->named_type (\"u16\",\n-\t\t\t\t\t backend->integer_type (true, 16),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"u8\",\n-\t\t    backend->named_type (\"u8\", backend->integer_type (true, 8),\n-\t\t\t\t\t Linemap::predeclared_location ()));\n-  scope.InsertType (\"f64\", backend->float_type (64));\n-  scope.InsertType (\"f32\", backend->float_type (32));\n-\n-  for (auto &item : crate.items)\n-    item->accept_vis (*this);\n-  scope.Pop ();\n-\n-  // Define all globally declared values.\n-  if (saw_errors ())\n-    return false;\n-\n-  backend->write_global_definitions (type_decls, const_decls, func_decls,\n-\t\t\t\t     var_decls);\n-  return true;\n-}\n-\n-bool\n-Compilation::compileVarDecl (Bfunction *fndecl, AST::LetStmt *stmt,\n-\t\t\t     std::vector<Bvariable *> &vars)\n-{\n-  AST::Type *type = stmt->has_type () ? stmt->get_type ().get () : stmt->inferedType;\n-  translatedType = NULL;\n-  type->accept_vis (*this);\n-  if (translatedType == NULL)\n-    {\n-      rust_error_at (stmt->get_locus (), \"failed to compile type for var decl\");\n-      return false;\n-    }\n-\n-  stmt->get_pattern ()->accept_vis (*this);\n-  for (auto &pattern : patternBuffer)\n-    {\n-      auto var = backend->local_variable (fndecl, pattern.get_ident (),\n-\t\t\t\t\t  translatedType, NULL /*decl_var*/,\n-\t\t\t\t\t  false /*address_taken*/, stmt->get_locus ());\n-      vars.push_back (var);\n-      scope.InsertVar (pattern.get_ident (), var);\n-    }\n-  patternBuffer.clear ();\n-  return true;\n-}\n-\n-Bexpression *\n-Compilation::compileBooleanLiteral (std::string val)\n-{\n-  bool bval = val.compare (\"true\") == 0;\n-  return backend->boolean_constant_expression (bval);\n-}\n-\n-Bexpression *\n-Compilation::compileFloatLiteral (std::string val, Location locus)\n-{\n-  Btype *type = NULL;\n-  bool ok = scope.LookupType (\"f32\", &type);\n-  if (!ok)\n-    {\n-      rust_fatal_error (locus, \"unable to find type\");\n-      return NULL;\n-    }\n-  mpfr_t fval;\n-  if (mpfr_init_set_str (fval, val.c_str (), 10, GMP_RNDN) != 0)\n-    {\n-      rust_fatal_error (locus, \"bad number in literal\");\n-      return NULL;\n-    }\n-  return backend->float_constant_expression (type, fval);\n-}\n-\n-Bexpression *\n-Compilation::compileIntegerLiteral (std::string val, Location locus)\n-{\n-  Btype *type = NULL;\n-  bool ok = scope.LookupType (\"i32\", &type);\n-  if (!ok)\n-    {\n-      rust_fatal_error (locus, \"unable to find type\");\n-      return NULL;\n-    }\n-  mpz_t ival;\n-  if (mpz_init_set_str (ival, val.c_str (), 10) != 0)\n-    {\n-      rust_fatal_error (locus, \"bad number in literal\");\n-      return NULL;\n-    }\n-  return backend->integer_constant_expression (type, ival);\n-}\n-\n-void\n-Compilation::visit (AST::Token &tok)\n-{}\n-\n-void\n-Compilation::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n-\n-void\n-Compilation::visit (AST::AttrInputMetaItemContainer &input)\n-{}\n-\n-void\n-Compilation::visit (AST::IdentifierExpr &ident_expr)\n-{\n-  Bvariable *var = NULL;\n-  if (!scope.LookupVar (ident_expr.as_string (), &var))\n-    {\n-      rust_fatal_error (ident_expr.get_locus (), \"unknown var\");\n-      return;\n-    }\n-  exprs.push_back (backend->var_expression (var, ident_expr.get_locus ()));\n-}\n-\n-void\n-Compilation::visit (AST::Lifetime &lifetime)\n-{}\n-\n-void\n-Compilation::visit (AST::LifetimeParam &lifetime_param)\n-{}\n-\n-void\n-Compilation::visit (AST::MacroInvocationSemi &macro)\n-{}\n-\n-// rust-path.h\n-void\n-Compilation::visit (AST::PathInExpression &path)\n-{\n-  Bfunction *fn = NULL;\n-  if (scope.LookupFunction (path.as_string (), &fn))\n-    {\n-      auto expr\n-\t= backend->function_code_expression (fn, path.get_locus ());\n-      exprs.push_back (expr);\n-      translatedType = scope.GetFnRetType (fn);\n-      return;\n-    }\n-}\n-\n-void\n-Compilation::visit (AST::TypePathSegment &segment)\n-{}\n-void\n-Compilation::visit (AST::TypePathSegmentGeneric &segment)\n-{}\n-void\n-Compilation::visit (AST::TypePathSegmentFunction &segment)\n-{}\n-\n-void\n-Compilation::visit (AST::TypePath &path)\n-{\n-  if (path.get_segments ().size () > 1)\n-    {\n-      rust_error_at (path.get_locus (), \"unable to compile multi segment types yet\");\n-      return;\n-    }\n-\n-  Btype *type = NULL;\n-  if (!scope.LookupType (path.as_string (), &type))\n-    {\n-      rust_error_at (path.get_locus (), \"unknown type\");\n-      return;\n-    }\n-  translatedType = type;\n-}\n-\n-void\n-Compilation::visit (AST::QualifiedPathInExpression &path)\n-{}\n-void\n-Compilation::visit (AST::QualifiedPathInType &path)\n-{}\n-\n-// rust-expr.h\n-void\n-Compilation::visit (AST::LiteralExpr &expr)\n-{\n-  Bexpression *compiled;\n-  switch (expr.get_lit_type ())\n-    {\n-    case AST::Literal::BOOL:\n-      compiled = compileBooleanLiteral (expr.as_string ());\n-      break;\n-\n-    case AST::Literal::FLOAT:\n-      compiled\n-\t= compileFloatLiteral (expr.as_string (), expr.get_locus ());\n-      break;\n-\n-    case AST::Literal::INT:\n-      compiled\n-\t= compileIntegerLiteral (expr.as_string (), expr.get_locus ());\n-      break;\n-\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"unknown literal\");\n-      return;\n-    }\n-\n-  exprs.push_back (compiled);\n-}\n-\n-void\n-Compilation::visit (AST::AttrInputLiteral &attr_input)\n-{}\n-void\n-Compilation::visit (AST::MetaItemLitExpr &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaItemPathLit &meta_item)\n-{}\n-void\n-Compilation::visit (AST::BorrowExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::DereferenceExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::ErrorPropagationExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::NegationExpr &expr)\n-{\n-  Bexpression *root = NULL;\n-  VISIT_POP (expr.get_negated_expr ()->get_locus_slow (), expr.get_negated_expr ().get (), root,\n-\t     exprs);\n-  if (root == NULL)\n-    {\n-      rust_error_at (expr.get_negated_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Operator op;\n-  switch (expr.get_negation_type ())\n-    {\n-    case AST::NegationExpr::NEGATE:\n-      op = OPERATOR_MINUS;\n-      break;\n-    case AST::NegationExpr::NOT:\n-      op = OPERATOR_NOT;\n-      break;\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n-      return;\n-    }\n-\n-  auto unary = backend->unary_expression (op, root, expr.get_locus ());\n-  exprs.push_back (unary);\n-}\n-\n-void\n-Compilation::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{\n-  Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n-  if (lhs == NULL)\n-    {\n-      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Bexpression *rhs = NULL;\n-  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n-  if (rhs == NULL)\n-    {\n-      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Operator op;\n-  switch (expr.get_expr_type ())\n-    {\n-    case AST::ArithmeticOrLogicalExpr::ADD:\n-      op = OPERATOR_PLUS;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::SUBTRACT:\n-      op = OPERATOR_MINUS;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::MULTIPLY:\n-      op = OPERATOR_MULT;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::DIVIDE:\n-      op = OPERATOR_DIV;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::MODULUS:\n-      op = OPERATOR_MOD;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::BITWISE_AND:\n-      op = OPERATOR_AND;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::BITWISE_OR:\n-      op = OPERATOR_OR;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::BITWISE_XOR:\n-      op = OPERATOR_XOR;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n-      op = OPERATOR_LSHIFT;\n-      break;\n-    case AST::ArithmeticOrLogicalExpr::RIGHT_SHIFT:\n-      op = OPERATOR_RSHIFT;\n-      break;\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n-      return;\n-    }\n-\n-  auto binExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n-  exprs.push_back (binExpr);\n-}\n-\n-void\n-Compilation::visit (AST::ComparisonExpr &expr)\n-{\n-  Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n-  if (lhs == NULL)\n-    {\n-      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Bexpression *rhs = NULL;\n-  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n-  if (rhs == NULL)\n-    {\n-      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Operator op;\n-  switch (expr.get_expr_type ())\n-    {\n-    case AST::ComparisonExpr::EQUAL:\n-      op = OPERATOR_EQEQ;\n-      break;\n-    case AST::ComparisonExpr::NOT_EQUAL:\n-      op = OPERATOR_NOTEQ;\n-      break;\n-    case AST::ComparisonExpr::GREATER_THAN:\n-      op = OPERATOR_GT;\n-      break;\n-    case AST::ComparisonExpr::LESS_THAN:\n-      op = OPERATOR_LT;\n-      break;\n-    case AST::ComparisonExpr::GREATER_OR_EQUAL:\n-      op = OPERATOR_GE;\n-      break;\n-    case AST::ComparisonExpr::LESS_OR_EQUAL:\n-      op = OPERATOR_LE;\n-      break;\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n-      return;\n-    }\n-\n-  auto compExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n-  exprs.push_back (compExpr);\n-}\n-\n-void\n-Compilation::visit (AST::LazyBooleanExpr &expr)\n-{\n-  Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n-  if (lhs == NULL)\n-    {\n-      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Bexpression *rhs = NULL;\n-  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n-  if (rhs == NULL)\n-    {\n-      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Operator op;\n-  switch (expr.get_expr_type ())\n-    {\n-    case AST::LazyBooleanExpr::LOGICAL_OR:\n-      op = OPERATOR_OROR;\n-      break;\n-    case AST::LazyBooleanExpr::LOGICAL_AND:\n-      op = OPERATOR_ANDAND;\n-      break;\n-    default:\n-      rust_fatal_error (expr.get_locus (), \"failed to compile operator\");\n-      return;\n-    }\n-\n-  auto compExpr\n-    = backend->binary_expression (op, lhs, rhs, expr.get_locus ());\n-  exprs.push_back (compExpr);\n-}\n-\n-void\n-Compilation::visit (AST::TypeCastExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::AssignmentExpr &expr)\n-{\n-  Bexpression *lhs = NULL;\n-  VISIT_POP (expr.get_left_expr ()->get_locus_slow (), expr.get_left_expr ().get (), lhs, exprs);\n-  if (lhs == NULL)\n-    {\n-      rust_error_at (expr.get_left_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  Bexpression *rhs = NULL;\n-  VISIT_POP (expr.get_right_expr ()->get_locus_slow (), expr.get_right_expr ().get (), rhs, exprs);\n-  if (rhs == NULL)\n-    {\n-      rust_error_at (expr.get_right_expr ()->get_locus_slow (), \"failed to compile\");\n-      return;\n-    }\n-\n-  auto s = backend->assignment_statement (scope.GetCurrentFndecl (), lhs, rhs,\n-\t\t\t\t\t  expr.get_locus ());\n-  scope.AddStatement (s);\n-}\n-\n-void\n-Compilation::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::GroupedExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::ArrayElemsValues &elems)\n-{\n-  std::vector< ::Bexpression *> elements;\n-\n-  bool failed = false;\n-  elems.iterate ([&] (AST::Expr *expr) mutable -> bool {\n-    Bexpression *value = nullptr;\n-    VISIT_POP (expr.get_locus_slow (), expr, value, exprs);\n-    if (value == nullptr)\n-      {\n-\trust_fatal_error (expr->get_locus_slow (),\n-\t\t\t  \"failed to compile value to array initialiser\");\n-\treturn false;\n-      }\n-    elements.push_back (value);\n-    return true;\n-  });\n-\n-  // nothing to do when its failed\n-  if (failed)\n-    return;\n-\n-  arrayConsStack.push_back (elements);\n-}\n-\n-void\n-Compilation::visit (AST::ArrayElemsCopied &elems)\n-{}\n-\n-void\n-Compilation::visit (AST::ArrayExpr &expr)\n-{\n-  translatedType = nullptr;\n-  expr.get_inferred_type ()->accept_vis (*this);\n-  if (translatedType == nullptr)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"failed to compile array type for ArrayExpr\");\n-      return;\n-    }\n-\n-  ::Btype *compiledType = translatedType;\n-  translatedType = nullptr;\n-\n-  auto before = arrayConsStack.size ();\n-  expr.get_array_elems ()->accept_vis (*this);\n-  if (arrayConsStack.size () <= before)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"failed to compile the array constructor\");\n-      return;\n-    }\n-  std::vector< ::Bexpression *> initializer = arrayConsStack.back ();\n-  arrayConsStack.pop_back ();\n-\n-  std::vector<unsigned long> indexes;\n-  for (unsigned long i = 0; i < initializer.size (); ++i)\n-    indexes.push_back (i);\n-\n-  Bexpression *cons\n-    = backend->array_constructor_expression (compiledType, indexes, initializer,\n-\t\t\t\t\t     expr.get_locus_slow ());\n-  exprs.push_back (cons);\n-}\n-\n-void\n-Compilation::visit (AST::ArrayIndexExpr &expr)\n-{\n-  Bexpression *arrayExpr = nullptr;\n-  VISIT_POP (expr.get_array_expr ()->get_locus_slow (), expr.get_array_expr (),\n-\t     arrayExpr, exprs);\n-  if (arrayExpr == nullptr)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"failed to compile value to array expression reference\");\n-      return;\n-    }\n-\n-  Bexpression *indexExpr = nullptr;\n-  VISIT_POP (expr.get_index_expr ()->get_locus_slow (), expr.get_index_expr (),\n-\t     indexExpr, exprs);\n-  if (indexExpr == nullptr)\n-    {\n-      rust_error_at (expr.get_locus_slow (),\n-\t\t     \"failed to compile value to array index expression\");\n-      return;\n-    }\n-\n-  Bexpression *indexExpression\n-    = backend->array_index_expression (arrayExpr, indexExpr,\n-\t\t\t\t       expr.get_locus_slow ());\n-  exprs.push_back (indexExpression);\n-}\n-\n-void\n-Compilation::visit (AST::TupleExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::TupleIndexExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::StructExprStruct &expr)\n-{}\n-// void Compilation::visit(StructExprField& field) {}\n-void\n-Compilation::visit (AST::StructExprFieldIdentifier &field)\n-{}\n-\n-void\n-Compilation::visit (AST::StructExprFieldIdentifierValue &field)\n-{\n-  Bexpression *value = NULL;\n-  VISIT_POP (field.get_value ()->get_locus_slow (), field.get_value ().get (), value, exprs);\n-  if (value == NULL)\n-    {\n-      rust_fatal_error (field.get_value ()->get_locus_slow (),\n-\t\t\t\"failed to compile value to struct\");\n-      return;\n-    }\n-  exprs.push_back (value);\n-}\n-\n-void\n-Compilation::visit (AST::StructExprFieldIndexValue &field)\n-{\n-  Bexpression *value = NULL;\n-  VISIT_POP (field.get_value ()->get_locus_slow (), field.get_value ().get (), value, exprs);\n-  if (value == NULL)\n-    {\n-      rust_fatal_error (field.get_value ()->get_locus_slow (),\n-\t\t\t\"failed to compile value to struct\");\n-      return;\n-    }\n-  exprs.push_back (value);\n-}\n-\n-void\n-Compilation::visit (AST::StructExprStructFields &expr)\n-{\n-  AST::StructStruct *decl = NULL;\n-  if (!scope.LookupStructDecl (expr.get_struct_name ().as_string (), &decl))\n-    {\n-      rust_error_at (expr.get_locus (), \"unknown type\");\n-      return;\n-    }\n-\n-  Btype *structType = NULL;\n-  if (!scope.LookupType (expr.get_struct_name ().as_string (), &structType))\n-    {\n-      rust_fatal_error (expr.get_locus (), \"unknown type\");\n-      return;\n-    }\n-\n-  structBuffer.push_back (decl);\n-  std::vector<Bexpression *> constructor;\n-\n-  // FIXME type resolution pass should ensures these are in correct order\n-  // and have defaults if required\n-  for (auto &field : expr.get_fields ())\n-    {\n-      Bexpression *value = NULL;\n-      VISIT_POP (expr.get_locus (), field, value, exprs);\n-      if (value == NULL)\n-\t{\n-\t  rust_fatal_error (expr.get_locus (),\n-\t\t\t    \"failed to compile value to struct\");\n-\t  return;\n-\t}\n-\n-      constructor.push_back (value);\n-    }\n-\n-  structBuffer.pop_back ();\n-  auto cons = backend->constructor_expression (structType, constructor,\n-\t\t\t\t\t       expr.get_locus ());\n-  exprs.push_back (cons);\n-}\n-\n-void\n-Compilation::visit (AST::StructExprStructBase &expr)\n-{}\n-void\n-Compilation::visit (AST::StructExprTuple &expr)\n-{}\n-void\n-Compilation::visit (AST::StructExprUnit &expr)\n-{}\n-// void Compilation::visit(EnumExprField& field) {}\n-void\n-Compilation::visit (AST::EnumExprFieldIdentifier &field)\n-{}\n-void\n-Compilation::visit (AST::EnumExprFieldIdentifierValue &field)\n-{}\n-void\n-Compilation::visit (AST::EnumExprFieldIndexValue &field)\n-{}\n-void\n-Compilation::visit (AST::EnumExprStruct &expr)\n-{}\n-void\n-Compilation::visit (AST::EnumExprTuple &expr)\n-{}\n-void\n-Compilation::visit (AST::EnumExprFieldless &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::CallExpr &expr)\n-{\n-  Bexpression *fn = NULL;\n-  VISIT_POP (expr.get_function_expr ()->get_locus_slow (), expr.get_function_expr (), fn, exprs);\n-  if (fn == NULL)\n-    {\n-      rust_error_at (expr.get_function_expr ()->get_locus_slow (), \"failed to resolve\");\n-      return;\n-    }\n-\n-  std::vector<Bexpression *> args;\n-  for (auto &param : expr.get_params ())\n-    {\n-      Bexpression *arg = NULL;\n-      VISIT_POP (param->get_locus_slow (), param, arg, exprs);\n-      if (arg == NULL)\n-\t{\n-\t  rust_error_at (param->get_locus_slow (),\n-\t\t\t \"failed to compile argument\");\n-\t  return;\n-\t}\n-\n-      args.push_back (arg);\n-    }\n-\n-  auto call = backend->call_expression (scope.GetCurrentFndecl (), fn, args,\n-\t\t\t\t\tNULL, expr.get_locus ());\n-  exprs.push_back (call);\n-}\n-\n-void\n-Compilation::visit (AST::MethodCallExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::FieldAccessExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::ClosureExprInner &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::BlockExpr &expr)\n-{\n-  Bblock *enclosingScope = NULL;\n-  Location start_location; /* = stmt.locus; FIXME */\n-  Location end_location;   // FIXME\n-\n-  std::vector<Bvariable *> vars;\n-  auto code_block\n-    = backend->block (scope.GetCurrentFndecl (), scope.CurBlock (), vars,\n-\t\t      start_location, end_location);\n-\n-  scope.PushBlock (code_block);\n-  for (auto &stmt : expr.get_statements ())\n-    {\n-      stmt->accept_vis (*this);\n-    }\n-  // dont pop\n-}\n-\n-void\n-Compilation::visit (AST::ClosureExprInnerTyped &expr)\n-{}\n-void\n-Compilation::visit (AST::ContinueExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::BreakExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeFromToExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeFromExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeToExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeFullExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeFromToInclExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::RangeToInclExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::ReturnExpr &expr)\n-{\n-  Bexpression *ret = NULL;\n-  VISIT_POP (expr.get_returned_expr ()->get_locus_slow (), expr.get_returned_expr ().get (), ret, exprs);\n-  if (ret == NULL)\n-    {\n-      rust_fatal_error (expr.get_returned_expr ()->get_locus_slow (),\n-\t\t\t\"failed to compile\");\n-      return;\n-    }\n-\n-  std::vector<Bexpression *> retstmts;\n-  retstmts.push_back (ret);\n-  auto s = backend->return_statement (scope.GetCurrentFndecl (), retstmts,\n-\t\t\t\t      expr.get_locus ());\n-  scope.AddStatement (s);\n-}\n-\n-void\n-Compilation::visit (AST::UnsafeBlockExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::LoopExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::WhileLoopExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::WhileLetLoopExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::ForLoopExpr &expr)\n-{}\n-\n-void\n-Compilation::visit (AST::IfExpr &expr)\n-{\n-  Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n-\t     expr.get_condition_expr ().get (), cond, exprs);\n-  if (cond == NULL)\n-    {\n-      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n-\t\t     \"failed to compile\");\n-      return;\n-    }\n-\n-  expr.vis_if_block (*this);\n-  Bblock *then_block = scope.PopBlock ();\n-\n-  auto stmt = backend->if_statement (scope.GetCurrentFndecl (), cond,\n-\t\t\t\t     then_block, NULL, expr.get_locus ());\n-  stmts.push_back (stmt);\n-}\n-\n-void\n-Compilation::visit (AST::IfExprConseqElse &expr)\n-{\n-  Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n-\t     expr.get_condition_expr ().get (), cond, exprs);\n-  if (cond == NULL)\n-    {\n-      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n-\t\t     \"failed to compile\");\n-      return;\n-    }\n-\n-  expr.vis_if_block (*this);\n-  Bblock *then_block = scope.PopBlock ();\n-\n-  expr.vis_else_block (*this);\n-  Bblock *else_block = scope.PopBlock ();\n-\n-  auto stmt\n-    = backend->if_statement (scope.GetCurrentFndecl (), cond, then_block,\n-\t\t\t     else_block, expr.get_locus ());\n-  stmts.push_back (stmt);\n-}\n-\n-void\n-Compilation::visit (AST::IfExprConseqIf &expr)\n-{\n-  Bexpression *cond = NULL;\n-  VISIT_POP (expr.get_condition_expr ()->get_locus_slow (),\n-\t     expr.get_condition_expr ().get (), cond, exprs);\n-  if (cond == NULL)\n-    {\n-      rust_error_at (expr.get_condition_expr ()->get_locus_slow (),\n-\t\t     \"failed to compile\");\n-      return;\n-    }\n-\n-  expr.vis_if_block (*this);\n-  Bblock *then_block = scope.PopBlock ();\n-\n-  // setup else block\n-  Bblock *enclosingScope = NULL;\n-  Location start_location; /* = stmt.locus; FIXME */\n-  Location end_location;   // FIXME\n-\n-  std::vector<Bvariable *> vars;\n-  auto else_block\n-    = backend->block (scope.GetCurrentFndecl (), scope.CurBlock (), vars,\n-\t\t      start_location, end_location);\n-\n-  scope.PushBlock (else_block);\n-  expr.vis_conseq_if_expr (*this);\n-  // get trailing if required\n-  for (auto &s : stmts)\n-    scope.AddStatement (s);\n-  stmts.clear ();\n-  scope.PopBlock ();\n-\n-  auto stmt\n-    = backend->if_statement (scope.GetCurrentFndecl (), cond, then_block,\n-\t\t\t     else_block, expr.get_locus ());\n-  stmts.push_back (stmt);\n-}\n-\n-void\n-Compilation::visit (AST::IfExprConseqIfLet &expr)\n-{\n-  printf (\"IfExprConseqIfLet %s\\n\", expr.as_string ().c_str ());\n-}\n-void\n-Compilation::visit (AST::IfLetExpr &expr)\n-{\n-  printf (\"IfLetExpr %s\\n\", expr.as_string ().c_str ());\n-}\n-void\n-Compilation::visit (AST::IfLetExprConseqElse &expr)\n-{\n-  printf (\"IfLetExprConseqElse %s\\n\", expr.as_string ().c_str ());\n-}\n-\n-void\n-Compilation::visit (AST::IfLetExprConseqIf &expr)\n-{\n-  printf (\"IfLetExprConseqIf %s\\n\", expr.as_string ().c_str ());\n-}\n-\n-void\n-Compilation::visit (AST::IfLetExprConseqIfLet &expr)\n-{\n-  printf (\"IfLetExprConseqIfLet %s\\n\", expr.as_string ().c_str ());\n-}\n-\n-// void Compilation::visit(MatchCase& match_case) {}\n-/*void\n-Compilation::visit (AST::MatchCaseBlockExpr &match_case)\n-{}*/\n-/*void\n-Compilation::visit (AST::MatchCaseExpr &match_case)\n-{}*/\n-void\n-Compilation::visit (AST::MatchExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::AwaitExpr &expr)\n-{}\n-void\n-Compilation::visit (AST::AsyncBlockExpr &expr)\n-{}\n-\n-// rust-item.h\n-void\n-Compilation::visit (AST::TypeParam &param)\n-{}\n-// void Compilation::visit(WhereClauseItem& item) {}\n-void\n-Compilation::visit (AST::LifetimeWhereClauseItem &item)\n-{}\n-void\n-Compilation::visit (AST::TypeBoundWhereClauseItem &item)\n-{}\n-void\n-Compilation::visit (AST::Method &method)\n-{}\n-void\n-Compilation::visit (AST::ModuleBodied &module)\n-{}\n-void\n-Compilation::visit (AST::ModuleNoBody &module)\n-{}\n-void\n-Compilation::visit (AST::ExternCrate &crate)\n-{}\n-// void Compilation::visit(UseTree& use_tree) {}\n-void\n-Compilation::visit (AST::UseTreeGlob &use_tree)\n-{}\n-void\n-Compilation::visit (AST::UseTreeList &use_tree)\n-{}\n-void\n-Compilation::visit (AST::UseTreeRebind &use_tree)\n-{}\n-void\n-Compilation::visit (AST::UseDeclaration &use_decl)\n-{}\n-\n-void\n-Compilation::visit (AST::Function &function)\n-{\n-  Backend::Btyped_identifier receiver;\n-  std::vector<Backend::Btyped_identifier> parameters;\n-  std::vector<Backend::Btyped_identifier> results;\n-\n-  for (auto &param : function.get_function_params ())\n-    {\n-      // translate the type\n-      translatedType = NULL;\n-      param.get_type ()->accept_vis (*this);\n-      if (translatedType == NULL)\n-\t{\n-\t  rust_error_at (param.get_locus (), \"failed to generate type for parameter\");\n-\t  return;\n-\t}\n-\n-      auto before = patternBuffer.size ();\n-      param.get_pattern ()->accept_vis (*this);\n-      if (patternBuffer.size () <= before)\n-\t{\n-\t  rust_error_at (param.get_locus (), \"failed to analyse parameter name\");\n-\t  return;\n-\t}\n-\n-      auto numParamsPerType = patternBuffer.size () - before;\n-      for (size_t i = 0; i < numParamsPerType; i++)\n-\t{\n-\t  auto paramName = patternBuffer.back ();\n-\t  patternBuffer.pop_back ();\n-\t  parameters.push_back (\n-\t    Backend::Btyped_identifier (paramName.get_ident (),\n-\t\t\t\t\ttranslatedType, param.get_locus ()));\n-\t}\n-    }\n-\n-  Btype *returnType = NULL;\n-  if (function.has_return_type ())\n-    {\n-      translatedType = NULL;\n-      function.get_return_type ()->accept_vis (*this);\n-      if (translatedType == NULL)\n-\t{\n-\t  rust_fatal_error (function.get_locus (),\n-\t\t\t    \"failed to generate type for function\");\n-\t  return;\n-\t}\n-      returnType = translatedType;\n-\n-      // add into the results:\n-      results.push_back (\n-\tBackend::Btyped_identifier (\"_\", translatedType, Location ()));\n-    }\n-\n-  Btype *fntype = backend->function_type (receiver, parameters, results, NULL,\n-\t\t\t\t\t  function.get_locus ());\n-  Bfunction *fndecl\n-    = backend->function (fntype, function.get_function_name (), \"\" /* asm_name */,\n-\t\t\t 0 /* flags */, function.get_locus ());\n-\n-  scope.InsertFunction (function.get_function_name (), fndecl, returnType);\n-  scope.Push ();\n-\n-  // setup the params\n-  std::vector<Bvariable *> param_vars;\n-  for (auto &param : parameters)\n-    {\n-      bool tree_addressable = false;\n-      auto p = backend->parameter_variable (fndecl, param.name, param.btype,\n-\t\t\t\t\t    tree_addressable, param.location);\n-\n-      scope.InsertVar (param.name, p);\n-      param_vars.push_back (p);\n-    }\n-\n-  if (!backend->function_set_parameters (fndecl, param_vars))\n-    {\n-      rust_error_at (function.get_locus (), \"failed to setup parameter variables\");\n-      return;\n-    }\n-\n-  std::vector<Bvariable *> vars;\n-  for (auto &decl : function.locals)\n-    {\n-      if (!compileVarDecl (fndecl, decl, vars))\n-\t{\n-\t  rust_error_at (decl->get_locus (), \"failed to compile var decl\");\n-\t  return;\n-\t}\n-    }\n-\n-  // is null for top level functions - nested functions will have an enclosing\n-  // scope\n-  Bblock *enclosingScope = NULL;\n-  Location start_location = function.get_locus ();\n-  Location end_location;\n-  if (function.get_definition ()->get_statements ().size () > 0)\n-    {\n-      end_location\n-\t= function.get_definition ()->get_statements ().back ()->get_locus_slow ();\n-    }\n-\n-  auto code_block = backend->block (fndecl, enclosingScope, vars,\n-\t\t\t\t    start_location, end_location);\n-\n-  scope.PushBlock (code_block);\n-\n-  Bvariable *retDecl = NULL;\n-  if (function.has_return_type ())\n-    {\n-      bool address_is_taken = false;\n-      Bstatement *ret_var_stmt = NULL;\n-      retDecl = backend->temporary_variable (fndecl, code_block, returnType,\n-\t\t\t\t\t     NULL, address_is_taken,\n-\t\t\t\t\t     function.get_locus (), &ret_var_stmt);\n-      scope.AddStatement (ret_var_stmt);\n-    }\n-  scope.PushCurrentFunction (function.get_function_name (), fndecl, returnType,\n-\t\t\t     retDecl);\n-\n-  for (auto &stmt : function.get_definition ()->get_statements ())\n-    stmt->accept_vis (*this);\n-\n-  scope.PopBlock ();\n-\n-  auto body = backend->block_statement (code_block);\n-  if (!backend->function_set_body (fndecl, body))\n-    {\n-      rust_error_at (function.get_locus (), \"failed to set body to function\");\n-      return;\n-    }\n-\n-  scope.Pop ();\n-  scope.PopCurrentFunction ();\n-\n-  func_decls.push_back (fndecl);\n-}\n-\n-void\n-Compilation::visit (AST::TypeAlias &type_alias)\n-{}\n-\n-void\n-Compilation::visit (AST::StructStruct &struct_item)\n-{\n-  std::vector<Backend::Btyped_identifier> fields;\n-  for (auto &field : struct_item.get_fields ())\n-    {\n-      translatedType = NULL;\n-      field.get_field_type ()->accept_vis (*this);\n-      if (translatedType == NULL)\n-\t{\n-\t  rust_fatal_error (\n-\t    struct_item.get_locus () /* StructField is mi sing locus */,\n-\t    \"failed to compile struct field\");\n-\t  return;\n-\t}\n-\n-      fields.push_back (Backend::Btyped_identifier (\n-\tfield.get_field_name (), translatedType,\n-\tstruct_item.get_locus () /* StructField is mi sing locus */));\n-    }\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n \n-  auto compiledStruct\n-    = backend->placeholder_struct_type (struct_item.get_struct_name (),\n-\t\t\t\t\tstruct_item.get_locus ());\n-  bool ok = backend->set_placeholder_struct_type (compiledStruct, fields);\n-  if (!ok)\n-    {\n-      rust_fatal_error (struct_item.get_locus (), \"failed to compile struct\");\n-      return;\n-    }\n-\n-  type_decls.push_back (compiledStruct);\n-  scope.InsertType (struct_item.get_struct_name (), compiledStruct);\n-  scope.InsertStructDecl (struct_item.get_struct_name (), &struct_item);\n-}\n+// This file is part of GCC.\n \n-void\n-Compilation::visit (AST::TupleStruct &tuple_struct)\n-{}\n-void\n-Compilation::visit (AST::EnumItem &item)\n-{}\n-void\n-Compilation::visit (AST::EnumItemTuple &item)\n-{}\n-void\n-Compilation::visit (AST::EnumItemStruct &item)\n-{}\n-void\n-Compilation::visit (AST::EnumItemDiscriminant &item)\n-{}\n-void\n-Compilation::visit (AST::Enum &enum_item)\n-{}\n-void\n-Compilation::visit (AST::Union &union_item)\n-{}\n-void\n-Compilation::visit (AST::ConstantItem &const_item)\n-{}\n-void\n-Compilation::visit (AST::StaticItem &static_item)\n-{}\n-void\n-Compilation::visit (AST::TraitItemFunc &item)\n-{}\n-void\n-Compilation::visit (AST::TraitItemMethod &item)\n-{}\n-void\n-Compilation::visit (AST::TraitItemConst &item)\n-{}\n-void\n-Compilation::visit (AST::TraitItemType &item)\n-{}\n-void\n-Compilation::visit (AST::Trait &trait)\n-{}\n-void\n-Compilation::visit (AST::InherentImpl &impl)\n-{}\n-void\n-Compilation::visit (AST::TraitImpl &impl)\n-{}\n-// void Compilation::visit(ExternalItem& item) {}\n-void\n-Compilation::visit (AST::ExternalStaticItem &item)\n-{}\n-void\n-Compilation::visit (AST::ExternalFunctionItem &item)\n-{}\n-void\n-Compilation::visit (AST::ExternBlock &block)\n-{}\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n \n-// rust-macro.h\n-void\n-Compilation::visit (AST::MacroMatchFragment &match)\n-{}\n-void\n-Compilation::visit (AST::MacroMatchRepetition &match)\n-{}\n-void\n-Compilation::visit (AST::MacroMatcher &matcher)\n-{}\n-void\n-Compilation::visit (AST::MacroRulesDefinition &rules_def)\n-{}\n-void\n-Compilation::visit (AST::MacroInvocation &macro_invoc)\n-{}\n-void\n-Compilation::visit (AST::MetaItemPath &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaItemSeq &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaWord &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaNameValueStr &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaListPaths &meta_item)\n-{}\n-void\n-Compilation::visit (AST::MetaListNameValueStr &meta_item)\n-{}\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n \n-// rust-pattern.h\n-void\n-Compilation::visit (AST::LiteralPattern &pattern)\n-{\n-  printf (\"LiteralPattern: %s\\n\", pattern.as_string ().c_str ());\n-}\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n \n-void\n-Compilation::visit (AST::IdentifierPattern &pattern)\n-{\n-  patternBuffer.push_back (pattern);\n-}\n+#include \"rust-compile.h\"\n+#include \"rust-compile-item.h\"\n \n-void\n-Compilation::visit (AST::WildcardPattern &pattern)\n-{}\n-// void Compilation::visit(RangePatternBound& bound) {}\n-void\n-Compilation::visit (AST::RangePatternBoundLiteral &bound)\n-{}\n-void\n-Compilation::visit (AST::RangePatternBoundPath &bound)\n-{}\n-void\n-Compilation::visit (AST::RangePatternBoundQualPath &bound)\n-{}\n-void\n-Compilation::visit (AST::RangePattern &pattern)\n-{}\n-void\n-Compilation::visit (AST::ReferencePattern &pattern)\n-{}\n-// void Compilation::visit(StructPatternField& field) {}\n-void\n-Compilation::visit (AST::StructPatternFieldTuplePat &field)\n-{}\n-void\n-Compilation::visit (AST::StructPatternFieldIdentPat &field)\n-{}\n-void\n-Compilation::visit (AST::StructPatternFieldIdent &field)\n-{}\n-void\n-Compilation::visit (AST::StructPattern &pattern)\n-{}\n-// void Compilation::visit(TupleStructItems& tuple_items) {}\n-void\n-Compilation::visit (AST::TupleStructItemsNoRange &tuple_items)\n-{}\n-void\n-Compilation::visit (AST::TupleStructItemsRange &tuple_items)\n-{}\n-void\n-Compilation::visit (AST::TupleStructPattern &pattern)\n-{}\n-// void Compilation::visit(TuplePatternItems& tuple_items) {}\n-void\n-Compilation::visit (AST::TuplePatternItemsMultiple &tuple_items)\n-{}\n-void\n-Compilation::visit (AST::TuplePatternItemsRanged &tuple_items)\n-{}\n-void\n-Compilation::visit (AST::TuplePattern &pattern)\n-{}\n-void\n-Compilation::visit (AST::GroupedPattern &pattern)\n-{}\n-void\n-Compilation::visit (AST::SlicePattern &pattern)\n-{}\n+namespace Rust {\n+namespace Compile {\n \n-// rust-stmt.h\n-void\n-Compilation::visit (AST::EmptyStmt &stmt)\n+CompileCrate::CompileCrate (HIR::Crate &crate, Context *ctx)\n+  : crate (crate), ctx (ctx)\n {}\n-void\n-\n-Compilation::visit (AST::LetStmt &stmt)\n-{\n-  if (!stmt.has_init_expr ())\n-    return;\n-\n-  stmt.get_pattern ()->accept_vis (*this);\n-  for (auto &pattern : patternBuffer)\n-    {\n-      Bvariable *var = NULL;\n-      if (!scope.LookupVar (pattern.get_ident (), &var))\n-\t{\n-\t  rust_error_at (stmt.get_locus (), \"failed to find var decl for %s\",\n-\t\t\t pattern.get_ident ().c_str ());\n-\t  return;\n-\t}\n-\n-      varBuffer.push_back (var);\n-\n-      Bexpression *init = NULL;\n-      VISIT_POP (stmt.get_init_expr ()->get_locus_slow (), stmt.get_init_expr (), init,\n-\t\t exprs);\n-      if (init == NULL)\n-\t{\n-\t  rust_error_at (stmt.get_init_expr ()->get_locus_slow (),\n-\t\t\t \"failed to compile init statement\");\n-\t  return;\n-\t}\n \n-      auto s = backend->init_statement (scope.GetCurrentFndecl (), var, init);\n-      scope.AddStatement (s);\n-\n-      varBuffer.pop_back ();\n-    }\n-  patternBuffer.clear ();\n-}\n+CompileCrate::~CompileCrate () {}\n \n void\n-Compilation::visit (AST::ExprStmtWithoutBlock &stmt)\n-{\n-  stmt.get_expr ()->accept_vis (*this);\n-}\n+CompileCrate::Compile (HIR::Crate &crate, Context *ctx)\n \n-void\n-Compilation::visit (AST::ExprStmtWithBlock &stmt)\n {\n-  Bblock *enclosingScope = NULL;\n-  Location start_location; /* = stmt.locus; FIXME */\n-  Location end_location;   // FIXME\n-\n-  std::vector<Bvariable *> vars;\n-  auto code_block\n-    = backend->block (scope.GetCurrentFndecl (), scope.CurBlock (), vars,\n-\t\t      start_location, end_location);\n-\n-  scope.PushBlock (code_block);\n-  stmt.get_expr ()->accept_vis (*this);\n-\n-  // get trailing if required\n-  for (auto &s : stmts)\n-    {\n-      scope.AddStatement (s);\n-    }\n-  stmts.clear ();\n-\n-  scope.PopBlock ();\n-\n-  auto body = backend->block_statement (code_block);\n-  scope.AddStatement (body);\n+  CompileCrate c (crate, ctx);\n+  c.go ();\n }\n \n-// rust-type.h\n-void\n-Compilation::visit (AST::TraitBound &bound)\n-{}\n-void\n-Compilation::visit (AST::ImplTraitType &type)\n-{}\n-void\n-Compilation::visit (AST::TraitObjectType &type)\n-{}\n-void\n-Compilation::visit (AST::ParenthesisedType &type)\n-{}\n-void\n-Compilation::visit (AST::ImplTraitTypeOneBound &type)\n-{}\n-void\n-Compilation::visit (AST::TraitObjectTypeOneBound &type)\n-{}\n-void\n-Compilation::visit (AST::TupleType &type)\n-{}\n-void\n-Compilation::visit (AST::NeverType &type)\n-{}\n-void\n-Compilation::visit (AST::RawPointerType &type)\n-{}\n-void\n-Compilation::visit (AST::ReferenceType &type)\n-{}\n-\n void\n-Compilation::visit (AST::ArrayType &type)\n+CompileCrate::go ()\n {\n-  Btype *elementType;\n-  translatedType = nullptr;\n-  type.get_elem_type ()->accept_vis (*this);\n-  if (translatedType == nullptr)\n-    {\n-      rust_error_at (type.get_locus (),\n-\t\t     \"Failed to compile element type for array\");\n-      return;\n-    }\n-  elementType = translatedType;\n-\n-  Bexpression *length = nullptr;\n-  VISIT_POP (type.get_size_expr ()->get_locus_slow (), type.get_size_expr (),\n-\t     length, exprs);\n-  if (length == nullptr)\n-    {\n-      rust_error_at (type.get_size_expr ()->get_locus_slow (),\n-\t\t     \"failed to size for array type\");\n-      return;\n-    }\n-\n-  translatedType = backend->array_type (elementType, length);\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    CompileItem::compile (it->get (), ctx);\n }\n \n-void\n-Compilation::visit (AST::SliceType &type)\n-{}\n-void\n-Compilation::visit (AST::InferredType &type)\n-{}\n-void\n-Compilation::visit (AST::BareFunctionType &type)\n-{}\n-\n } // namespace Compile\n } // namespace Rust"}, {"sha": "18f3e54083573b0892a1c1f235e8f35941349e82", "filename": "gcc/rust/backend/rust-compile.h", "status": "modified", "additions": 31, "deletions": 241, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fbackend%2Frust-compile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -1,257 +1,47 @@\n-#pragma once\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n \n-#include \"rust-system.h\"\n-#include \"rust-ast-full.h\"\n-#include \"rust-ast-visitor.h\"\n-#include \"rust-backend.h\"\n-#include \"cscope.h\"\n+// This file is part of GCC.\n \n-namespace Rust {\n-namespace Compile {\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n \n-class Compilation : public AST::ASTVisitor\n-{\n-public:\n-  static bool Compile (AST::Crate &crate, ::Backend *backend);\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n \n-  ~Compilation ();\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n \n-  // visitor impl\n-  // rust-ast.h\n-  // virtual void visit(AttrInput& attr_input);\n-  // virtual void visit(TokenTree& token_tree);\n-  // virtual void visit(MacroMatch& macro_match);\n-  virtual void visit (AST::Token &tok);\n-  virtual void visit (AST::DelimTokenTree &delim_tok_tree);\n-  virtual void visit (AST::AttrInputMetaItemContainer &input);\n-  // virtual void visit(MetaItem& meta_item);\n-  // virtual void vsit(Stmt& stmt);\n-  // virtual void visit(Expr& expr);\n-  virtual void visit (AST::IdentifierExpr &ident_expr);\n-  // virtual void visit(Pattern& pattern);\n-  // virtual void visit(Type& type);\n-  // virtual void visit(TypeParamBound& type_param_bound);\n-  virtual void visit (AST::Lifetime &lifetime);\n-  // virtual void visit(GenericParam& generic_param);\n-  virtual void visit (AST::LifetimeParam &lifetime_param);\n-  // virtual void visit(TraitItem& trait_item);\n-  // virtual void visit(InherentImplItem& inherent_impl_item);\n-  // virtual void visit(TraitImplItem& trait_impl_item);\n-  virtual void visit (AST::MacroInvocationSemi &macro);\n+#ifndef RUST_COMPILE_H\n+#define RUST_COMPILE_H\n \n-  // rust-path.h\n-  virtual void visit (AST::PathInExpression &path);\n-  virtual void visit (AST::TypePathSegment &segment);\n-  virtual void visit (AST::TypePathSegmentGeneric &segment);\n-  virtual void visit (AST::TypePathSegmentFunction &segment);\n-  virtual void visit (AST::TypePath &path);\n-  virtual void visit (AST::QualifiedPathInExpression &path);\n-  virtual void visit (AST::QualifiedPathInType &path);\n-\n-  // rust-expr.h\n-  virtual void visit (AST::LiteralExpr &expr);\n-  virtual void visit (AST::AttrInputLiteral &attr_input);\n-  virtual void visit (AST::MetaItemLitExpr &meta_item);\n-  virtual void visit (AST::MetaItemPathLit &meta_item);\n-  virtual void visit (AST::BorrowExpr &expr);\n-  virtual void visit (AST::DereferenceExpr &expr);\n-  virtual void visit (AST::ErrorPropagationExpr &expr);\n-  virtual void visit (AST::NegationExpr &expr);\n-  virtual void visit (AST::ArithmeticOrLogicalExpr &expr);\n-  virtual void visit (AST::ComparisonExpr &expr);\n-  virtual void visit (AST::LazyBooleanExpr &expr);\n-  virtual void visit (AST::TypeCastExpr &expr);\n-  virtual void visit (AST::AssignmentExpr &expr);\n-  virtual void visit (AST::CompoundAssignmentExpr &expr);\n-  virtual void visit (AST::GroupedExpr &expr);\n-  // virtual void visit(ArrayElems& elems);\n-  virtual void visit (AST::ArrayElemsValues &elems);\n-  virtual void visit (AST::ArrayElemsCopied &elems);\n-  virtual void visit (AST::ArrayExpr &expr);\n-  virtual void visit (AST::ArrayIndexExpr &expr);\n-  virtual void visit (AST::TupleExpr &expr);\n-  virtual void visit (AST::TupleIndexExpr &expr);\n-  virtual void visit (AST::StructExprStruct &expr);\n-  // virtual void visit(StructExprField& field);\n-  virtual void visit (AST::StructExprFieldIdentifier &field);\n-  virtual void visit (AST::StructExprFieldIdentifierValue &field);\n-  virtual void visit (AST::StructExprFieldIndexValue &field);\n-  virtual void visit (AST::StructExprStructFields &expr);\n-  virtual void visit (AST::StructExprStructBase &expr);\n-  virtual void visit (AST::StructExprTuple &expr);\n-  virtual void visit (AST::StructExprUnit &expr);\n-  // virtual void visit(EnumExprField& field);\n-  virtual void visit (AST::EnumExprFieldIdentifier &field);\n-  virtual void visit (AST::EnumExprFieldIdentifierValue &field);\n-  virtual void visit (AST::EnumExprFieldIndexValue &field);\n-  virtual void visit (AST::EnumExprStruct &expr);\n-  virtual void visit (AST::EnumExprTuple &expr);\n-  virtual void visit (AST::EnumExprFieldless &expr);\n-  virtual void visit (AST::CallExpr &expr);\n-  virtual void visit (AST::MethodCallExpr &expr);\n-  virtual void visit (AST::FieldAccessExpr &expr);\n-  virtual void visit (AST::ClosureExprInner &expr);\n-  virtual void visit (AST::BlockExpr &expr);\n-  virtual void visit (AST::ClosureExprInnerTyped &expr);\n-  virtual void visit (AST::ContinueExpr &expr);\n-  virtual void visit (AST::BreakExpr &expr);\n-  virtual void visit (AST::RangeFromToExpr &expr);\n-  virtual void visit (AST::RangeFromExpr &expr);\n-  virtual void visit (AST::RangeToExpr &expr);\n-  virtual void visit (AST::RangeFullExpr &expr);\n-  virtual void visit (AST::RangeFromToInclExpr &expr);\n-  virtual void visit (AST::RangeToInclExpr &expr);\n-  virtual void visit (AST::ReturnExpr &expr);\n-  virtual void visit (AST::UnsafeBlockExpr &expr);\n-  virtual void visit (AST::LoopExpr &expr);\n-  virtual void visit (AST::WhileLoopExpr &expr);\n-  virtual void visit (AST::WhileLetLoopExpr &expr);\n-  virtual void visit (AST::ForLoopExpr &expr);\n-  virtual void visit (AST::IfExpr &expr);\n-  virtual void visit (AST::IfExprConseqElse &expr);\n-  virtual void visit (AST::IfExprConseqIf &expr);\n-  virtual void visit (AST::IfExprConseqIfLet &expr);\n-  virtual void visit (AST::IfLetExpr &expr);\n-  virtual void visit (AST::IfLetExprConseqElse &expr);\n-  virtual void visit (AST::IfLetExprConseqIf &expr);\n-  virtual void visit (AST::IfLetExprConseqIfLet &expr);\n-  // virtual void visit(MatchCase& match_case);\n-  // virtual void visit (AST::MatchCaseBlockExpr &match_case);\n-  // virtual void visit (AST::MatchCaseExpr &match_case);\n-  virtual void visit (AST::MatchExpr &expr);\n-  virtual void visit (AST::AwaitExpr &expr);\n-  virtual void visit (AST::AsyncBlockExpr &expr);\n-\n-  // rust-item.h\n-  virtual void visit (AST::TypeParam &param);\n-  // virtual void visit(WhereClauseItem& item);\n-  virtual void visit (AST::LifetimeWhereClauseItem &item);\n-  virtual void visit (AST::TypeBoundWhereClauseItem &item);\n-  virtual void visit (AST::Method &method);\n-  virtual void visit (AST::ModuleBodied &module);\n-  virtual void visit (AST::ModuleNoBody &module);\n-  virtual void visit (AST::ExternCrate &crate);\n-  // virtual void visit(UseTree& use_tree);\n-  virtual void visit (AST::UseTreeGlob &use_tree);\n-  virtual void visit (AST::UseTreeList &use_tree);\n-  virtual void visit (AST::UseTreeRebind &use_tree);\n-  virtual void visit (AST::UseDeclaration &use_decl);\n-  virtual void visit (AST::Function &function);\n-  virtual void visit (AST::TypeAlias &type_alias);\n-  virtual void visit (AST::StructStruct &struct_item);\n-  virtual void visit (AST::TupleStruct &tuple_struct);\n-  virtual void visit (AST::EnumItem &item);\n-  virtual void visit (AST::EnumItemTuple &item);\n-  virtual void visit (AST::EnumItemStruct &item);\n-  virtual void visit (AST::EnumItemDiscriminant &item);\n-  virtual void visit (AST::Enum &enum_item);\n-  virtual void visit (AST::Union &union_item);\n-  virtual void visit (AST::ConstantItem &const_item);\n-  virtual void visit (AST::StaticItem &static_item);\n-  virtual void visit (AST::TraitItemFunc &item);\n-  virtual void visit (AST::TraitItemMethod &item);\n-  virtual void visit (AST::TraitItemConst &item);\n-  virtual void visit (AST::TraitItemType &item);\n-  virtual void visit (AST::Trait &trait);\n-  virtual void visit (AST::InherentImpl &impl);\n-  virtual void visit (AST::TraitImpl &impl);\n-  // virtual void visit(ExternalItem& item);\n-  virtual void visit (AST::ExternalStaticItem &item);\n-  virtual void visit (AST::ExternalFunctionItem &item);\n-  virtual void visit (AST::ExternBlock &block);\n-\n-  // rust-macro.h\n-  virtual void visit (AST::MacroMatchFragment &match);\n-  virtual void visit (AST::MacroMatchRepetition &match);\n-  virtual void visit (AST::MacroMatcher &matcher);\n-  virtual void visit (AST::MacroRulesDefinition &rules_def);\n-  virtual void visit (AST::MacroInvocation &macro_invoc);\n-  virtual void visit (AST::MetaItemPath &meta_item);\n-  virtual void visit (AST::MetaItemSeq &meta_item);\n-  virtual void visit (AST::MetaWord &meta_item);\n-  virtual void visit (AST::MetaNameValueStr &meta_item);\n-  virtual void visit (AST::MetaListPaths &meta_item);\n-  virtual void visit (AST::MetaListNameValueStr &meta_item);\n+#include \"rust-system.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-compile-context.h\"\n \n-  // rust-pattern.h\n-  virtual void visit (AST::LiteralPattern &pattern);\n-  virtual void visit (AST::IdentifierPattern &pattern);\n-  virtual void visit (AST::WildcardPattern &pattern);\n-  // virtual void visit(RangePatternBound& bound);\n-  virtual void visit (AST::RangePatternBoundLiteral &bound);\n-  virtual void visit (AST::RangePatternBoundPath &bound);\n-  virtual void visit (AST::RangePatternBoundQualPath &bound);\n-  virtual void visit (AST::RangePattern &pattern);\n-  virtual void visit (AST::ReferencePattern &pattern);\n-  // virtual void visit(StructPatternField& field);\n-  virtual void visit (AST::StructPatternFieldTuplePat &field);\n-  virtual void visit (AST::StructPatternFieldIdentPat &field);\n-  virtual void visit (AST::StructPatternFieldIdent &field);\n-  virtual void visit (AST::StructPattern &pattern);\n-  // virtual void visit(TupleStructItems& tuple_items);\n-  virtual void visit (AST::TupleStructItemsNoRange &tuple_items);\n-  virtual void visit (AST::TupleStructItemsRange &tuple_items);\n-  virtual void visit (AST::TupleStructPattern &pattern);\n-  // virtual void visit(TuplePatternItems& tuple_items);\n-  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items);\n-  virtual void visit (AST::TuplePatternItemsRanged &tuple_items);\n-  virtual void visit (AST::TuplePattern &pattern);\n-  virtual void visit (AST::GroupedPattern &pattern);\n-  virtual void visit (AST::SlicePattern &pattern);\n+namespace Rust {\n+namespace Compile {\n \n-  // rust-stmt.h\n-  virtual void visit (AST::EmptyStmt &stmt);\n-  virtual void visit (AST::LetStmt &stmt);\n-  virtual void visit (AST::ExprStmtWithoutBlock &stmt);\n-  virtual void visit (AST::ExprStmtWithBlock &stmt);\n+class CompileCrate\n+{\n+public:\n+  static void Compile (HIR::Crate &crate, Context *ctx);\n \n-  // rust-type.h\n-  virtual void visit (AST::TraitBound &bound);\n-  virtual void visit (AST::ImplTraitType &type);\n-  virtual void visit (AST::TraitObjectType &type);\n-  virtual void visit (AST::ParenthesisedType &type);\n-  virtual void visit (AST::ImplTraitTypeOneBound &type);\n-  virtual void visit (AST::TraitObjectTypeOneBound &type);\n-  virtual void visit (AST::TupleType &type);\n-  virtual void visit (AST::NeverType &type);\n-  virtual void visit (AST::RawPointerType &type);\n-  virtual void visit (AST::ReferenceType &type);\n-  virtual void visit (AST::ArrayType &type);\n-  virtual void visit (AST::SliceType &type);\n-  virtual void visit (AST::InferredType &type);\n-  virtual void visit (AST::BareFunctionType &type);\n+  ~CompileCrate ();\n \n private:\n-  Compilation (AST::Crate &crate, Backend *backend);\n-  bool go ();\n-\n-  AST::Crate &crate;\n-  Backend *backend;\n+  CompileCrate (HIR::Crate &crate, Context *ctx);\n+  void go ();\n \n-  // utils\n-  bool compileVarDecl (Bfunction *fndecl, AST::LetStmt *stmt,\n-\t\t       std::vector<Bvariable *> &vars);\n-\n-  Bexpression *compileBooleanLiteral (std::string val);\n-  Bexpression *compileFloatLiteral (std::string val, Location locus);\n-  Bexpression *compileIntegerLiteral (std::string val, Location locus);\n-\n-  // state\n-  Scope scope;\n-  ::Btype *translatedType;\n-  std::vector<AST::IdentifierPattern> patternBuffer;\n-  std::vector< ::Bexpression *> exprs;\n-  std::vector< ::Bstatement *> stmts;\n-  std::vector< ::Bvariable *> varBuffer;\n-  std::vector<AST::StructStruct *> structBuffer;\n-  std::vector<std::vector< ::Bexpression *> > arrayConsStack;\n-\n-  // careful these are the vectors we pass into the GCC middle-end\n-  std::vector< ::Btype *> type_decls;\n-  std::vector< ::Bvariable *> var_decls;\n-  std::vector< ::Bexpression *> const_decls;\n-  std::vector< ::Bfunction *> func_decls;\n+  HIR::Crate &crate;\n+  Context *ctx;\n };\n \n } // namespace Compile\n } // namespace Rust\n+\n+#endif // RUST_COMPILE_H"}, {"sha": "550d104b2ffe349982226c4a147346971e5f9f5f", "filename": "gcc/rust/hir/README.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2FREADME.md?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,40 @@\n+# GCCRS HIR\n+\n+Working with the AST has proved to become difficult. To overcome non lexical scoping\n+a toplevel scan pass was added to provide lookups for functioins. To get ready for the\n+gimple conversion pass, type resolution scanned blocks to create the list of locals per\n+block. Type Conversion had to create awkward getters/setters on LetStmts to have a Type or\n+InferedType which was more of a hack that what should really be there. ArrayExprs get checked\n+and create their own type to be checked against a possible LetStmt type. All of these things\n+started to become hard to manage.\n+\n+HIR from the RFC defines how they create lookups and IDs for all the nodes which solves the toplevel\n+scan pass. The lowering to HIR allows for cleanup in how types are resolved. Without using\n+the HIR and IDs implementing the shadowing rules was going to become very difficult.\n+\n+\n+## IMPL:\n+\n+* AST-lower - move down to HIR classes - generate mappings and IDs\n+\n+* Name Resolution - Check for path segments naming and map to HirIDS\n+  This should in theory map for example a call expression to already have the HirID to the function ready\n+  Dyn dispatch may need some help here if its a method the receiver could be bound the local name hirid\n+  the resoltion would need to be fixed up in type resolution pass\n+  \n+* Expand - Gather locals per block and fix up returns is it possible to generate return expressions\n+  at this pass?\n+  \n+* Type Resolution - Port over work from AST Type resolver\n+  generate mir from this pass?\n+\n+\n+For now this can then port over to the existing GIMPLE conversion faily easily. But after more\n+of the core data structures work MIR will be needed for all the glue that will need to be generated.\n+\n+\n+## Returns\n+\n+looks like its implemented by an implicit mutable return variable for the function. If were processing\n+a block expression and the last element on the block is an expression we can try to bind it to the mutable\n+return variable."}, {"sha": "093129e4d22d02bc9513d9fbca7a8f72ff5d3dc1", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,251 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_BASE\n+#define RUST_AST_LOWER_BASE\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+// base class to allow derivatives to overload as needed\n+class ASTLoweringBase : public AST::ASTVisitor\n+{\n+public:\n+  virtual ~ASTLoweringBase () {}\n+\n+  // visitor impl\n+  // rust-ast.h\n+  //  virtual void visit(AttrInput& attr_input);\n+  //  virtual void visit(TokenTree& token_tree);\n+  //  virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (AST::Token &tok) {}\n+  virtual void visit (AST::DelimTokenTree &delim_tok_tree) {}\n+  virtual void visit (AST::AttrInputMetaItemContainer &input) {}\n+  //  virtual void visit(MetaItem& meta_item) {}\n+  //  void vsit(Stmt& stmt) {}\n+  //  virtual void visit(Expr& expr) {}\n+  virtual void visit (AST::IdentifierExpr &ident_expr) {}\n+  //  virtual void visit(Pattern& pattern) {}\n+  //  virtual void visit(Type& type) {}\n+  //  virtual void visit(TypeParamBound& type_param_bound) {}\n+  virtual void visit (AST::Lifetime &lifetime) {}\n+  //  virtual void visit(GenericParam& generic_param) {}\n+  virtual void visit (AST::LifetimeParam &lifetime_param) {}\n+  //  virtual void visit(TraitItem& trait_item) {}\n+  //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n+  //  virtual void visit(TraitImplItem& trait_impl_item) {}\n+  virtual void visit (AST::MacroInvocationSemi &macro) {}\n+\n+  // rust-path.h\n+  virtual void visit (AST::PathInExpression &path) {}\n+  virtual void visit (AST::TypePathSegment &segment) {}\n+  virtual void visit (AST::TypePathSegmentGeneric &segment) {}\n+  virtual void visit (AST::TypePathSegmentFunction &segment) {}\n+  virtual void visit (AST::TypePath &path) {}\n+  virtual void visit (AST::QualifiedPathInExpression &path) {}\n+  virtual void visit (AST::QualifiedPathInType &path) {}\n+\n+  // rust-expr.h\n+  virtual void visit (AST::LiteralExpr &expr) {}\n+  virtual void visit (AST::AttrInputLiteral &attr_input) {}\n+  virtual void visit (AST::MetaItemLitExpr &meta_item) {}\n+  virtual void visit (AST::MetaItemPathLit &meta_item) {}\n+  virtual void visit (AST::BorrowExpr &expr) {}\n+  virtual void visit (AST::DereferenceExpr &expr) {}\n+  virtual void visit (AST::ErrorPropagationExpr &expr) {}\n+  virtual void visit (AST::NegationExpr &expr) {}\n+  virtual void visit (AST::ArithmeticOrLogicalExpr &expr) {}\n+  virtual void visit (AST::ComparisonExpr &expr) {}\n+  virtual void visit (AST::LazyBooleanExpr &expr) {}\n+  virtual void visit (AST::TypeCastExpr &expr) {}\n+  virtual void visit (AST::AssignmentExpr &expr) {}\n+  virtual void visit (AST::CompoundAssignmentExpr &expr) {}\n+  virtual void visit (AST::GroupedExpr &expr) {}\n+  //  virtual void visit(ArrayElems& elems) {}\n+  virtual void visit (AST::ArrayElemsValues &elems) {}\n+  virtual void visit (AST::ArrayElemsCopied &elems) {}\n+  virtual void visit (AST::ArrayExpr &expr) {}\n+  virtual void visit (AST::ArrayIndexExpr &expr) {}\n+  virtual void visit (AST::TupleExpr &expr) {}\n+  virtual void visit (AST::TupleIndexExpr &expr) {}\n+  virtual void visit (AST::StructExprStruct &expr) {}\n+  //  virtual void visit(StructExprField& field) {}\n+  virtual void visit (AST::StructExprFieldIdentifier &field) {}\n+  virtual void visit (AST::StructExprFieldIdentifierValue &field) {}\n+  virtual void visit (AST::StructExprFieldIndexValue &field) {}\n+  virtual void visit (AST::StructExprStructFields &expr) {}\n+  virtual void visit (AST::StructExprStructBase &expr) {}\n+  virtual void visit (AST::StructExprTuple &expr) {}\n+  virtual void visit (AST::StructExprUnit &expr) {}\n+  //  virtual void visit(EnumExprField& field) {}\n+  virtual void visit (AST::EnumExprFieldIdentifier &field) {}\n+  virtual void visit (AST::EnumExprFieldIdentifierValue &field) {}\n+  virtual void visit (AST::EnumExprFieldIndexValue &field) {}\n+  virtual void visit (AST::EnumExprStruct &expr) {}\n+  virtual void visit (AST::EnumExprTuple &expr) {}\n+  virtual void visit (AST::EnumExprFieldless &expr) {}\n+  virtual void visit (AST::CallExpr &expr) {}\n+  virtual void visit (AST::MethodCallExpr &expr) {}\n+  virtual void visit (AST::FieldAccessExpr &expr) {}\n+  virtual void visit (AST::ClosureExprInner &expr) {}\n+  virtual void visit (AST::BlockExpr &expr) {}\n+  virtual void visit (AST::ClosureExprInnerTyped &expr) {}\n+  virtual void visit (AST::ContinueExpr &expr) {}\n+  virtual void visit (AST::BreakExpr &expr) {}\n+  virtual void visit (AST::RangeFromToExpr &expr) {}\n+  virtual void visit (AST::RangeFromExpr &expr) {}\n+  virtual void visit (AST::RangeToExpr &expr) {}\n+  virtual void visit (AST::RangeFullExpr &expr) {}\n+  virtual void visit (AST::RangeFromToInclExpr &expr) {}\n+  virtual void visit (AST::RangeToInclExpr &expr) {}\n+  virtual void visit (AST::ReturnExpr &expr) {}\n+  virtual void visit (AST::UnsafeBlockExpr &expr) {}\n+  virtual void visit (AST::LoopExpr &expr) {}\n+  virtual void visit (AST::WhileLoopExpr &expr) {}\n+  virtual void visit (AST::WhileLetLoopExpr &expr) {}\n+  virtual void visit (AST::ForLoopExpr &expr) {}\n+  virtual void visit (AST::IfExpr &expr) {}\n+  virtual void visit (AST::IfExprConseqElse &expr) {}\n+  virtual void visit (AST::IfExprConseqIf &expr) {}\n+  virtual void visit (AST::IfExprConseqIfLet &expr) {}\n+  virtual void visit (AST::IfLetExpr &expr) {}\n+  virtual void visit (AST::IfLetExprConseqElse &expr) {}\n+  virtual void visit (AST::IfLetExprConseqIf &expr) {}\n+  virtual void visit (AST::IfLetExprConseqIfLet &expr) {}\n+  //  virtual void visit(MatchCase& match_case) {}\n+  // virtual void visit (AST::MatchCaseBlockExpr &match_case) {}\n+  // virtual void visit (AST::MatchCaseExpr &match_case) {}\n+  virtual void visit (AST::MatchExpr &expr) {}\n+  virtual void visit (AST::AwaitExpr &expr) {}\n+  virtual void visit (AST::AsyncBlockExpr &expr) {}\n+\n+  // rust-item.h\n+  virtual void visit (AST::TypeParam &param) {}\n+  //  virtual void visit(WhereClauseItem& item) {}\n+  virtual void visit (AST::LifetimeWhereClauseItem &item) {}\n+  virtual void visit (AST::TypeBoundWhereClauseItem &item) {}\n+  virtual void visit (AST::Method &method) {}\n+  virtual void visit (AST::ModuleBodied &module) {}\n+  virtual void visit (AST::ModuleNoBody &module) {}\n+  virtual void visit (AST::ExternCrate &crate) {}\n+  //  virtual void visit(UseTree& use_tree) {}\n+  virtual void visit (AST::UseTreeGlob &use_tree) {}\n+  virtual void visit (AST::UseTreeList &use_tree) {}\n+  virtual void visit (AST::UseTreeRebind &use_tree) {}\n+  virtual void visit (AST::UseDeclaration &use_decl) {}\n+  virtual void visit (AST::Function &function) {}\n+  virtual void visit (AST::TypeAlias &type_alias) {}\n+  virtual void visit (AST::StructStruct &struct_item) {}\n+  virtual void visit (AST::TupleStruct &tuple_struct) {}\n+  virtual void visit (AST::EnumItem &item) {}\n+  virtual void visit (AST::EnumItemTuple &item) {}\n+  virtual void visit (AST::EnumItemStruct &item) {}\n+  virtual void visit (AST::EnumItemDiscriminant &item) {}\n+  virtual void visit (AST::Enum &enum_item) {}\n+  virtual void visit (AST::Union &union_item) {}\n+  virtual void visit (AST::ConstantItem &const_item) {}\n+  virtual void visit (AST::StaticItem &static_item) {}\n+  virtual void visit (AST::TraitItemFunc &item) {}\n+  virtual void visit (AST::TraitItemMethod &item) {}\n+  virtual void visit (AST::TraitItemConst &item) {}\n+  virtual void visit (AST::TraitItemType &item) {}\n+  virtual void visit (AST::Trait &trait) {}\n+  virtual void visit (AST::InherentImpl &impl) {}\n+  virtual void visit (AST::TraitImpl &impl) {}\n+  //  virtual void visit(ExternalItem& item) {}\n+  virtual void visit (AST::ExternalStaticItem &item) {}\n+  virtual void visit (AST::ExternalFunctionItem &item) {}\n+  virtual void visit (AST::ExternBlock &block) {}\n+\n+  // rust-macro.h\n+  virtual void visit (AST::MacroMatchFragment &match) {}\n+  virtual void visit (AST::MacroMatchRepetition &match) {}\n+  virtual void visit (AST::MacroMatcher &matcher) {}\n+  virtual void visit (AST::MacroRulesDefinition &rules_def) {}\n+  virtual void visit (AST::MacroInvocation &macro_invoc) {}\n+  virtual void visit (AST::MetaItemPath &meta_item) {}\n+  virtual void visit (AST::MetaItemSeq &meta_item) {}\n+  virtual void visit (AST::MetaWord &meta_item) {}\n+  virtual void visit (AST::MetaNameValueStr &meta_item) {}\n+  virtual void visit (AST::MetaListPaths &meta_item) {}\n+  virtual void visit (AST::MetaListNameValueStr &meta_item) {}\n+\n+  // rust-pattern.h\n+  virtual void visit (AST::LiteralPattern &pattern) {}\n+  virtual void visit (AST::IdentifierPattern &pattern) {}\n+  virtual void visit (AST::WildcardPattern &pattern) {}\n+  //  virtual void visit(RangePatternBound& bound) {}\n+  virtual void visit (AST::RangePatternBoundLiteral &bound) {}\n+  virtual void visit (AST::RangePatternBoundPath &bound) {}\n+  virtual void visit (AST::RangePatternBoundQualPath &bound) {}\n+  virtual void visit (AST::RangePattern &pattern) {}\n+  virtual void visit (AST::ReferencePattern &pattern) {}\n+  //  virtual void visit(StructPatternField& field) {}\n+  virtual void visit (AST::StructPatternFieldTuplePat &field) {}\n+  virtual void visit (AST::StructPatternFieldIdentPat &field) {}\n+  virtual void visit (AST::StructPatternFieldIdent &field) {}\n+  virtual void visit (AST::StructPattern &pattern) {}\n+  //  virtual void visit(TupleStructItems& tuple_items) {}\n+  virtual void visit (AST::TupleStructItemsNoRange &tuple_items) {}\n+  virtual void visit (AST::TupleStructItemsRange &tuple_items) {}\n+  virtual void visit (AST::TupleStructPattern &pattern) {}\n+  //  virtual void visit(TuplePatternItems& tuple_items) {}\n+  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items) {}\n+  virtual void visit (AST::TuplePatternItemsRanged &tuple_items) {}\n+  virtual void visit (AST::TuplePattern &pattern) {}\n+  virtual void visit (AST::GroupedPattern &pattern) {}\n+  virtual void visit (AST::SlicePattern &pattern) {}\n+\n+  // rust-stmt.h\n+  virtual void visit (AST::EmptyStmt &stmt) {}\n+  virtual void visit (AST::LetStmt &stmt) {}\n+  virtual void visit (AST::ExprStmtWithoutBlock &stmt) {}\n+  virtual void visit (AST::ExprStmtWithBlock &stmt) {}\n+\n+  // rust-type.h\n+  virtual void visit (AST::TraitBound &bound) {}\n+  virtual void visit (AST::ImplTraitType &type) {}\n+  virtual void visit (AST::TraitObjectType &type) {}\n+  virtual void visit (AST::ParenthesisedType &type) {}\n+  virtual void visit (AST::ImplTraitTypeOneBound &type) {}\n+  virtual void visit (AST::TraitObjectTypeOneBound &type) {}\n+  virtual void visit (AST::TupleType &type) {}\n+  virtual void visit (AST::NeverType &type) {}\n+  virtual void visit (AST::RawPointerType &type) {}\n+  virtual void visit (AST::ReferenceType &type) {}\n+  virtual void visit (AST::ArrayType &type) {}\n+  virtual void visit (AST::SliceType &type) {}\n+  virtual void visit (AST::InferredType &type) {}\n+  virtual void visit (AST::BareFunctionType &type) {}\n+\n+protected:\n+  ASTLoweringBase () : mappings (Analysis::Mappings::get ()) {}\n+\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_BASE"}, {"sha": "50e67a81581558ec3ffef66e0ec5f20d37e55bba", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,242 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_EXPR\n+#define RUST_AST_LOWER_EXPR\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringExpr : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Expr *translate (AST::Expr *expr)\n+  {\n+    ASTLoweringExpr resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated != nullptr)\n+      {\n+\tresolver.mappings->insert_hir_expr (\n+\t  resolver.translated->get_mappings ().get_crate_num (),\n+\t  resolver.translated->get_mappings ().get_hirid (),\n+\t  resolver.translated);\n+      }\n+\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringExpr () {}\n+\n+  void visit (AST::PathInExpression &expr)\n+  {\n+    std::vector<HIR::PathExprSegment> path_segments;\n+    expr.iterate_path_segments ([&] (AST::PathExprSegment &s) mutable -> bool {\n+      rust_assert (s.has_generic_args () == false); // TODO\n+\n+      HIR::PathIdentSegment is (s.get_ident_segment ().as_string ());\n+      HIR::PathExprSegment seg (is, s.get_locus ());\n+      path_segments.push_back (seg);\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::PathInExpression (mapping, std::move (path_segments),\n+\t\t\t\t\t    expr.get_locus (),\n+\t\t\t\t\t    expr.opening_scope_resolution ());\n+  }\n+\n+  void visit (AST::ReturnExpr &expr)\n+  {\n+    HIR::Expr *return_expr\n+      = expr.has_returned_expr ()\n+\t  ? ASTLoweringExpr::translate (expr.get_returned_expr ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::ReturnExpr (mapping, expr.get_locus (),\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (return_expr));\n+  }\n+\n+  void visit (AST::CallExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+    HIR::Expr *func\n+      = ASTLoweringExpr::translate (expr.get_function_expr ().get ());\n+    std::vector<std::unique_ptr<HIR::Expr> > params;\n+    expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n+      auto trans = ASTLoweringExpr::translate (p);\n+      params.push_back (std::unique_ptr<HIR::Expr> (trans));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (\n+      crate_num, UNKNOWN_NODEID /* this can map back to the AST*/,\n+      mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::CallExpr (mapping, std::unique_ptr<HIR::Expr> (func),\n+\t\t\t   std::move (params), std::move (outer_attribs),\n+\t\t\t   expr.get_locus ());\n+  }\n+\n+  void visit (AST::AssignmentExpr &expr)\n+  {\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::AssignmentExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t\t expr.get_locus ());\n+  }\n+\n+  void visit (AST::IdentifierExpr &expr)\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::IdentifierExpr (mapping, expr.as_string (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::LiteralExpr &expr)\n+  {\n+    HIR::Literal::LitType type = HIR::Literal::LitType::CHAR;\n+    switch (expr.get_lit_type ())\n+      {\n+      case AST::Literal::LitType::CHAR:\n+\ttype = HIR::Literal::LitType::CHAR;\n+\tbreak;\n+      case AST::Literal::LitType::STRING:\n+\ttype = HIR::Literal::LitType::STRING;\n+\tbreak;\n+      case AST::Literal::LitType::RAW_STRING:\n+\ttype = HIR::Literal::LitType::RAW_STRING;\n+\tbreak;\n+      case AST::Literal::LitType::BYTE:\n+\ttype = HIR::Literal::LitType::BYTE;\n+\tbreak;\n+      case AST::Literal::LitType::BYTE_STRING:\n+\ttype = HIR::Literal::LitType::BYTE_STRING;\n+\tbreak;\n+      case AST::Literal::LitType::RAW_BYTE_STRING:\n+\ttype = HIR::Literal::LitType::RAW_BYTE_STRING;\n+\tbreak;\n+      case AST::Literal::LitType::INT:\n+\ttype = HIR::Literal::LitType::INT;\n+\tbreak;\n+      case AST::Literal::LitType::FLOAT:\n+\ttype = HIR::Literal::LitType::FLOAT;\n+\tbreak;\n+      case AST::Literal::LitType::BOOL:\n+\ttype = HIR::Literal::LitType::BOOL;\n+\tbreak;\n+      }\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::LiteralExpr (mapping, expr.as_string (), type,\n+\t\t\t\t       expr.get_locus ());\n+  }\n+\n+  void visit (AST::ArithmeticOrLogicalExpr &expr)\n+  {\n+    HIR::ArithmeticOrLogicalExpr::ExprType kind\n+      = HIR::ArithmeticOrLogicalExpr::ExprType::ADD;\n+    switch (expr.get_expr_type ())\n+      {\n+      case AST::ArithmeticOrLogicalExpr::ExprType::ADD:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::ADD;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::SUBTRACT:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::SUBTRACT;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::MULTIPLY:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::MULTIPLY;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::DIVIDE:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::DIVIDE;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::MODULUS:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::MODULUS;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::BITWISE_AND:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::BITWISE_AND;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::BITWISE_OR:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::BITWISE_OR;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::BITWISE_XOR:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::BITWISE_XOR;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::LEFT_SHIFT:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::LEFT_SHIFT;\n+\tbreak;\n+      case AST::ArithmeticOrLogicalExpr::ExprType::RIGHT_SHIFT:\n+\tkind = HIR::ArithmeticOrLogicalExpr::ExprType::RIGHT_SHIFT;\n+\tbreak;\n+      }\n+\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    rust_assert (lhs != nullptr);\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+    rust_assert (rhs != nullptr);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::ArithmeticOrLogicalExpr (mapping,\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t\t\t  kind, expr.get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringExpr () : translated (nullptr) {}\n+\n+  HIR::Expr *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_EXPR"}, {"sha": "e6c86b8ca4501b4c2f01ac6b3dc1a440d0f4d04e", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,155 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_ITEM\n+#define RUST_AST_LOWER_ITEM\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-stmt.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringItem : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Item *translate (AST::Item *item)\n+  {\n+    ASTLoweringItem resolver;\n+    item->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringItem () {}\n+\n+  void visit (AST::Function &function)\n+  {\n+    // ignore for now and leave empty\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<HIR::Attribute> outer_attrs;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // need\n+    Identifier function_name = function.get_function_name ();\n+    Location locus = function.get_locus ();\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (function.get_return_type ().get ()))\n+\t\t\t\t    : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n+      }\n+\n+    std::unique_ptr<HIR::BlockExpr> function_body\n+      = std::unique_ptr<HIR::BlockExpr> (\n+\ttranslate (function.get_definition ().get ()));\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    auto fn\n+      = new HIR::Function (mapping, std::move (function_name),\n+\t\t\t   std::move (qualifiers), std::move (generic_params),\n+\t\t\t   std::move (function_params), std::move (return_type),\n+\t\t\t   std::move (where_clause), std::move (function_body),\n+\t\t\t   std::move (vis), std::move (outer_attrs), locus);\n+\n+    mappings->insert_defid_mapping (mapping.get_defid (), translated);\n+    mappings->insert_hir_item (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       fn);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       function.get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : fn->function_params)\n+      {\n+\tmappings->insert_hir_param (mapping.get_crate_num (),\n+\t\t\t\t    param.get_mappings ()->get_hirid (),\n+\t\t\t\t    &param);\n+\tmappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t\t   param.get_locus ());\n+      }\n+\n+    translated = fn;\n+  }\n+\n+  // Helpers\n+\n+  HIR::BlockExpr *translate (AST::BlockExpr *function_body)\n+  {\n+    std::vector<std::unique_ptr<HIR::Stmt> > block_stmts;\n+    std::unique_ptr<HIR::ExprWithoutBlock> block_expr;\n+    std::vector<HIR::Attribute> inner_attribs;\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    function_body->iterate_stmts ([&] (AST::Stmt *s) mutable -> bool {\n+      auto translated_stmt = ASTLoweringStmt::translate (s);\n+      block_stmts.push_back (std::unique_ptr<HIR::Stmt> (translated_stmt));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, function_body->get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    return new HIR::BlockExpr (mapping, std::move (block_stmts),\n+\t\t\t       std::move (block_expr),\n+\t\t\t       std::move (inner_attribs),\n+\t\t\t       std::move (outer_attribs),\n+\t\t\t       function_body->get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringItem () : translated (nullptr) {}\n+\n+  HIR::Item *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_ITEM"}, {"sha": "0d5ce0fb0f423607cc073b22e49256663cbe67bc", "filename": "gcc/rust/hir/rust-ast-lower-pattern.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_PATTERN\n+#define RUST_AST_LOWER_PATTERN\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringPattern : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Pattern *translate (AST::Pattern *pattern)\n+  {\n+    ASTLoweringPattern resolver;\n+    pattern->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringPattern () {}\n+\n+  void visit (AST::IdentifierPattern &pattern)\n+  {\n+    std::unique_ptr<Pattern> to_bind;\n+    translated\n+      = new HIR::IdentifierPattern (pattern.get_ident (), pattern.get_locus (),\n+\t\t\t\t    pattern.get_is_ref (),\n+\t\t\t\t    pattern.get_is_mut (), std::move (to_bind));\n+  }\n+\n+private:\n+  ASTLoweringPattern () : translated (nullptr) {}\n+\n+  HIR::Pattern *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_PATTERN"}, {"sha": "c57d14fbbe2ef6b7a57e1c25ad891f4bcf4d19fc", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,102 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_STMT\n+#define RUST_AST_LOWER_STMT\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringStmt : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Stmt *translate (AST::Stmt *stmt)\n+  {\n+    ASTLoweringStmt resolver;\n+    stmt->accept_vis (resolver);\n+    if (resolver.translated == nullptr)\n+      {\n+\tprintf (\"Failing translating: %s\\n\", stmt->as_string ().c_str ());\n+\trust_assert (resolver.translated != nullptr);\n+      }\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringStmt () {}\n+\n+  void visit (AST::ExprStmtWithoutBlock &stmt)\n+  {\n+    HIR::Expr *expr = ASTLoweringExpr::translate (stmt.get_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::ExprStmtWithoutBlock (mapping,\n+\t\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t       stmt.get_locus ());\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       stmt.get_locus ());\n+    mappings->insert_hir_stmt (crate_num, mapping.get_hirid (), translated);\n+  }\n+\n+  void visit (AST::LetStmt &stmt)\n+  {\n+    std::vector<HIR::Attribute> outer_attrs;\n+    HIR::Pattern *variables\n+      = ASTLoweringPattern::translate (stmt.get_pattern ().get ());\n+    HIR::Type *type = stmt.has_type ()\n+\t\t\t? ASTLoweringType::translate (stmt.get_type ().get ())\n+\t\t\t: nullptr;\n+    HIR::Expr *init_expression\n+      = stmt.has_init_expr ()\n+\t  ? ASTLoweringExpr::translate (stmt.get_init_expr ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::LetStmt (mapping, std::unique_ptr<HIR::Pattern> (variables),\n+\t\t\t  std::unique_ptr<HIR::Expr> (init_expression),\n+\t\t\t  std::unique_ptr<HIR::Type> (type),\n+\t\t\t  std::move (outer_attrs), stmt.get_locus ());\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       stmt.get_locus ());\n+    mappings->insert_hir_stmt (crate_num, mapping.get_hirid (), translated);\n+  }\n+\n+private:\n+  ASTLoweringStmt () : translated (nullptr) {}\n+\n+  HIR::Stmt *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_PATTERN"}, {"sha": "4193415fcbc8938aa04efda88ef1dd650449080e", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_TYPE\n+#define RUST_AST_LOWER_TYPE\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-diagnostics.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringType : public ASTLoweringBase\n+{\n+public:\n+  static HIR::Type *translate (AST::Type *type)\n+  {\n+    ASTLoweringType resolver;\n+    type->accept_vis (resolver);\n+    return resolver.translated;\n+  }\n+\n+  virtual ~ASTLoweringType () {}\n+\n+  virtual void visit (AST::TypePathSegment &segment)\n+  {\n+    HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n+    translated_segment\n+      = new HIR::TypePathSegment (ident,\n+\t\t\t\t  segment.get_separating_scope_resolution (),\n+\t\t\t\t  segment.get_locus ());\n+  }\n+\n+  virtual void visit (AST::TypePath &path)\n+  {\n+    std::vector<std::unique_ptr<HIR::TypePathSegment> > translated_segments;\n+\n+    path.iterate_segments ([&] (AST::TypePathSegment *seg) mutable -> bool {\n+      translated_segment = nullptr;\n+      seg->accept_vis (*this);\n+      if (translated_segment == nullptr)\n+\t{\n+\t  rust_fatal_error (seg->get_locus (),\n+\t\t\t    \"failed to translate AST TypePathSegment\");\n+\t  return false;\n+\t}\n+\n+      translated_segments.push_back (\n+\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, path.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+    translated\n+      = new HIR::TypePath (std::move (mapping), std::move (translated_segments),\n+\t\t\t   path.get_locus (),\n+\t\t\t   path.has_opening_scope_resolution_op ());\n+    mappings->insert_hir_type (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t       translated);\n+  }\n+\n+private:\n+  ASTLoweringType () : translated (nullptr) {}\n+\n+  HIR::Type *translated;\n+\n+  HIR::TypePathSegment *translated_segment;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_TYPE"}, {"sha": "8a514ce7eb3b21692a0e29e91f8c31e4fb96fc66", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower.h\"\n+#include \"rust-ast-lower-item.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+ASTLowering::ASTLowering (AST::Crate &astCrate) : astCrate (astCrate) {}\n+\n+ASTLowering::~ASTLowering () {}\n+\n+HIR::Crate\n+ASTLowering::Resolve (AST::Crate &astCrate)\n+{\n+  ASTLowering resolver (astCrate);\n+  return resolver.go ();\n+}\n+\n+HIR::Crate\n+ASTLowering::go ()\n+{\n+  std::vector<std::unique_ptr<HIR::Item> > items;\n+  std::vector<HIR::Attribute> inner_attrs;\n+  bool has_utf8bom = false;\n+  bool has_shebang = false;\n+\n+  for (auto it = astCrate.items.begin (); it != astCrate.items.end (); it++)\n+    {\n+      auto translated = ASTLoweringItem::translate (it->get ());\n+      if (translated != nullptr)\n+\titems.push_back (std::unique_ptr<HIR::Item> (translated));\n+    }\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  return HIR::Crate (std::move (items), std::move (inner_attrs), mapping,\n+\t\t     has_utf8bom, has_shebang);\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "bdc21ba486b5f9234153ca989260d18664cfabbf", "filename": "gcc/rust/hir/rust-ast-lower.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_LOWER\n+#define RUST_HIR_LOWER\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLowering\n+{\n+public:\n+  static HIR::Crate Resolve (AST::Crate &astCrate);\n+  ~ASTLowering ();\n+\n+private:\n+  ASTLowering (AST::Crate &astCrate);\n+  HIR::Crate go ();\n+\n+  AST::Crate &astCrate;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_HIR_LOWER"}, {"sha": "3a1ddf2aca4572e4245bd1a9a5dc86a8fd528f11", "filename": "gcc/rust/hir/tree/rust-hir-cond-compilation.h", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-cond-compilation.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,248 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_CONDCOMPILATION\n+#define RUST_AST_CONDCOMPILATION\n+\n+#include \"rust-hir.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// Base conditional compilation configuration predicate thing - abstract\n+class ConfigurationPredicate\n+{\n+public:\n+  virtual ~ConfigurationPredicate () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ConfigurationPredicate> clone_configuration_predicate () const\n+  {\n+    return std::unique_ptr<ConfigurationPredicate> (\n+      clone_configuration_predicate_impl ());\n+  }\n+\n+  // not sure if I'll use this but here anyway\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function impl to be overriden in base classes\n+  virtual ConfigurationPredicate *\n+  clone_configuration_predicate_impl () const = 0;\n+};\n+\n+// A configuration option - true if option is set, false if option is not set.\n+class ConfigurationOption : public ConfigurationPredicate\n+{\n+  Identifier option_name;\n+\n+  // bool has_string_literal_option_body;\n+  std::string option_value; // technically a string or raw string literal\n+\n+public:\n+  /* Returns whether the configuration option has a \"value\" part of the\n+   * key-value pair. */\n+  bool has_option_value () const { return !option_value.empty (); }\n+\n+  // Key-value pair constructor\n+  ConfigurationOption (Identifier option_name, std::string option_value)\n+    : option_name (option_name), option_value (option_value)\n+  {}\n+\n+  // Name-only constructor\n+  ConfigurationOption (Identifier option_name) : option_name (option_name) {}\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationOption *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationOption (*this);\n+  }\n+};\n+\n+// TODO: inline\n+struct ConfigurationPredicateList\n+{\n+  std::vector<std::unique_ptr<ConfigurationPredicate> > predicate_list;\n+};\n+\n+// Predicate that returns true if all of the supplied predicates return true.\n+class ConfigurationAll : public ConfigurationPredicate\n+{\n+  std::vector<std::unique_ptr<ConfigurationPredicate> >\n+    predicate_list; // inlined form\n+\n+public:\n+  ConfigurationAll (\n+    std::vector<std::unique_ptr<ConfigurationPredicate> > predicate_list)\n+    : predicate_list (predicate_list)\n+  {}\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationAll *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationAll (*this);\n+  }\n+};\n+\n+// Predicate that returns true if any of the supplied predicates are true.\n+class ConfigurationAny : public ConfigurationPredicate\n+{\n+  std::vector<std::unique_ptr<ConfigurationPredicate> >\n+    predicate_list; // inlined form\n+\n+public:\n+  ConfigurationAny (\n+    std::vector<std::unique_ptr<ConfigurationPredicate> > predicate_list)\n+    : predicate_list (predicate_list)\n+  {}\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationAny *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationAny (*this);\n+  }\n+};\n+\n+/* Predicate that produces the negation of a supplied other configuration\n+ * predicate. */\n+class ConfigurationNot : public ConfigurationPredicate\n+{\n+  std::unique_ptr<ConfigurationPredicate> config_to_negate;\n+\n+public:\n+  ConfigurationNot (ConfigurationPredicate *config_to_negate)\n+    : config_to_negate (config_to_negate)\n+  {}\n+\n+  // Copy constructor with clone\n+  ConfigurationNot (ConfigurationNot const &other)\n+    : config_to_negate (\n+      other.config_to_negate->clone_configuration_predicate ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  ConfigurationNot &operator= (ConfigurationNot const &other)\n+  {\n+    config_to_negate = other.config_to_negate->clone_configuration_predicate ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ConfigurationNot (ConfigurationNot &&other) = default;\n+  ConfigurationNot &operator= (ConfigurationNot &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConfigurationNot *clone_configuration_predicate_impl () const override\n+  {\n+    return new ConfigurationNot (*this);\n+  }\n+};\n+\n+// TODO: relationship to other attributes?\n+class CfgAttribute\n+{\n+  std::unique_ptr<ConfigurationPredicate> config_to_include;\n+\n+public:\n+  CfgAttribute (ConfigurationPredicate *config_to_include)\n+    : config_to_include (config_to_include)\n+  {}\n+\n+  // Copy constructor with clone\n+  CfgAttribute (CfgAttribute const &other)\n+    : config_to_include (\n+      other.config_to_include->clone_configuration_predicate ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  CfgAttribute &operator= (CfgAttribute const &other)\n+  {\n+    config_to_include\n+      = other.config_to_include->clone_configuration_predicate ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CfgAttribute (CfgAttribute &&other) = default;\n+  CfgAttribute &operator= (CfgAttribute &&other) = default;\n+};\n+/* TODO: ok, best thing to do would be eliminating this class, making Attribute\n+ * has a \"is_cfg()\" method, and having attribute path as \"cfg\" and AttrInput as\n+ * ConfigurationPredicate (so make ConfigurationPredicate a subclass of\n+ * AttrInput?). Would need special handling in parser, however. */\n+\n+// TODO: inline\n+struct CfgAttrs\n+{\n+  std::vector<Attribute> cfg_attrs;\n+};\n+\n+// TODO: relationship to other attributes?\n+class CfgAttrAttribute\n+{\n+  std::unique_ptr<ConfigurationPredicate> config_to_include;\n+  std::vector<Attribute> cfg_attrs;\n+\n+public:\n+  CfgAttrAttribute (ConfigurationPredicate *config_to_include,\n+\t\t    std::vector<Attribute> cfg_attrs)\n+    : config_to_include (config_to_include), cfg_attrs (cfg_attrs)\n+  {}\n+\n+  // Copy constructor with clone\n+  CfgAttrAttribute (CfgAttrAttribute const &other)\n+    : config_to_include (\n+      other.config_to_include->clone_configuration_predicate ()),\n+      cfg_attrs (cfg_attrs)\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  CfgAttrAttribute &operator= (CfgAttrAttribute const &other)\n+  {\n+    config_to_include\n+      = other.config_to_include->clone_configuration_predicate ();\n+    cfg_attrs = other.cfg_attrs;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CfgAttrAttribute (CfgAttrAttribute &&other) = default;\n+  CfgAttrAttribute &operator= (CfgAttrAttribute &&other) = default;\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "36c2085578212d00619a070a70339604d8340b4d", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "added", "additions": 4504, "deletions": 0, "changes": 4504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=aa283484a3dffedc404653af18f9413775cbc3df"}, {"sha": "02b9f035fa9446681bcb09aa475fe048ae9f2d1e", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,285 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_FULL_DECLS_H\n+#define RUST_HIR_FULL_DECLS_H\n+// Forward declarations for all HIR classes. Useful for not having to include\n+// all definitions.\n+\n+namespace Rust {\n+namespace HIR {\n+// rust-ast.h\n+class AttrInput;\n+class TokenTree;\n+class MacroMatch;\n+class Token;\n+struct Literal;\n+class DelimTokenTree;\n+class PathSegment;\n+class SimplePathSegment;\n+class SimplePath;\n+struct Attribute;\n+class MetaItemInner;\n+class AttrInputMetaItemContainer;\n+class MetaItem;\n+class Stmt;\n+class Item;\n+class Expr;\n+class ExprWithoutBlock;\n+class IdentifierExpr;\n+class Pattern;\n+class Type;\n+class TypeNoBounds;\n+class TypeParamBound;\n+class Lifetime;\n+class GenericParam;\n+class LifetimeParam;\n+class MacroItem;\n+class TraitItem;\n+class InherentImplItem;\n+class TraitImplItem;\n+class MacroInvocationSemi;\n+struct Crate;\n+class PathExpr;\n+\n+// rust-path.h\n+class PathIdentSegment;\n+struct GenericArgsBinding;\n+struct GenericArgs;\n+class PathExprSegment;\n+class PathPattern;\n+class PathInExpression;\n+class TypePathSegment;\n+class TypePathSegmentGeneric;\n+struct TypePathFunction;\n+class TypePathSegmentFunction;\n+class TypePath;\n+struct QualifiedPathType;\n+class QualifiedPathInExpression;\n+class QualifiedPathInType;\n+\n+// rust-expr.h\n+class ExprWithBlock;\n+class LiteralExpr;\n+class AttrInputLiteral;\n+class MetaItemLitExpr;\n+class MetaItemPathLit;\n+class OperatorExpr;\n+class BorrowExpr;\n+class DereferenceExpr;\n+class ErrorPropagationExpr;\n+class NegationExpr;\n+class ArithmeticOrLogicalExpr;\n+class ComparisonExpr;\n+class LazyBooleanExpr;\n+class TypeCastExpr;\n+class AssignmentExpr;\n+class CompoundAssignmentExpr;\n+class GroupedExpr;\n+class ArrayElems;\n+class ArrayElemsValues;\n+class ArrayElemsCopied;\n+class ArrayExpr;\n+class ArrayIndexExpr;\n+class TupleExpr;\n+class TupleIndexExpr;\n+class StructExpr;\n+class StructExprStruct;\n+struct StructBase;\n+class StructExprField;\n+class StructExprFieldIdentifier;\n+class StructExprFieldWithVal;\n+class StructExprFieldIdentifierValue;\n+class StructExprFieldIndexValue;\n+class StructExprStructFields;\n+class StructExprStructBase;\n+class StructExprTuple;\n+class StructExprUnit;\n+class EnumVariantExpr;\n+class EnumExprField;\n+class EnumExprFieldIdentifier;\n+class EnumExprFieldWithVal;\n+class EnumExprFieldIdentifierValue;\n+class EnumExprFieldIndexValue;\n+class EnumExprStruct;\n+class EnumExprTuple;\n+class EnumExprFieldless;\n+class CallExpr;\n+class MethodCallExpr;\n+class FieldAccessExpr;\n+struct ClosureParam;\n+class ClosureExpr;\n+class ClosureExprInner;\n+class BlockExpr;\n+class ClosureExprInnerTyped;\n+class ContinueExpr;\n+class BreakExpr;\n+class RangeExpr;\n+class RangeFromToExpr;\n+class RangeFromExpr;\n+class RangeToExpr;\n+class RangeFullExpr;\n+class RangeFromToInclExpr;\n+class RangeToInclExpr;\n+class ReturnExpr;\n+class UnsafeBlockExpr;\n+class LoopLabel;\n+class BaseLoopExpr;\n+class LoopExpr;\n+class WhileLoopExpr;\n+class WhileLetLoopExpr;\n+class ForLoopExpr;\n+class IfExpr;\n+class IfExprConseqElse;\n+class IfExprConseqIf;\n+class IfLetExpr;\n+class IfExprConseqIfLet;\n+class IfLetExprConseqElse;\n+class IfLetExprConseqIf;\n+class IfLetExprConseqIfLet;\n+struct MatchArm;\n+// class MatchCase;\n+// class MatchCaseBlockExpr;\n+// class MatchCaseExpr;\n+struct MatchCase;\n+class MatchExpr;\n+class AwaitExpr;\n+class AsyncBlockExpr;\n+\n+// rust-stmt.h\n+class EmptyStmt;\n+class LetStmt;\n+class ExprStmt;\n+class ExprStmtWithoutBlock;\n+class ExprStmtWithBlock;\n+\n+// rust-item.h\n+class TypeParam;\n+class WhereClauseItem;\n+class LifetimeWhereClauseItem;\n+class TypeBoundWhereClauseItem;\n+struct WhereClause;\n+struct SelfParam;\n+struct FunctionQualifiers;\n+struct FunctionParam;\n+struct Visibility;\n+class Method;\n+class VisItem;\n+class Module;\n+class ModuleBodied;\n+class ModuleNoBody;\n+class ExternCrate;\n+class UseTree;\n+class UseTreeGlob;\n+class UseTreeList;\n+class UseTreeRebind;\n+class UseDeclaration;\n+class Function;\n+class TypeAlias;\n+class Struct;\n+struct StructField;\n+class StructStruct;\n+struct TupleField;\n+class TupleStruct;\n+class EnumItem;\n+class EnumItemTuple;\n+class EnumItemStruct;\n+class EnumItemDiscriminant;\n+class Enum;\n+class Union;\n+class ConstantItem;\n+class StaticItem;\n+struct TraitFunctionDecl;\n+class TraitItemFunc;\n+struct TraitMethodDecl;\n+class TraitItemMethod;\n+class TraitItemConst;\n+class TraitItemType;\n+class Trait;\n+class Impl;\n+class InherentImpl;\n+class TraitImpl;\n+class ExternalItem;\n+class ExternalStaticItem;\n+struct NamedFunctionParam;\n+class ExternalFunctionItem;\n+class ExternBlock;\n+\n+// rust-macro.h\n+class MacroMatchFragment;\n+class MacroMatchRepetition;\n+class MacroMatcher;\n+struct MacroTranscriber;\n+struct MacroRule;\n+class MacroRulesDefinition;\n+class MacroInvocation;\n+class MetaItemPath;\n+class MetaItemSeq;\n+class MetaWord;\n+class MetaNameValueStr;\n+class MetaListPaths;\n+class MetaListNameValueStr;\n+\n+// rust-pattern.h\n+class LiteralPattern;\n+class IdentifierPattern;\n+class WildcardPattern;\n+class RangePatternBound;\n+class RangePatternBoundLiteral;\n+class RangePatternBoundPath;\n+class RangePatternBoundQualPath;\n+class RangePattern;\n+class ReferencePattern;\n+struct StructPatternEtc;\n+class StructPatternField;\n+class StructPatternFieldTuplePat;\n+class StructPatternFieldIdentPat;\n+class StructPatternFieldIdent;\n+struct StructPatternElements;\n+class StructPattern;\n+class TupleStructItems;\n+class TupleStructItemsNoRange;\n+class TupleStructItemsRange;\n+class TupleStructPattern;\n+class TuplePatternItems;\n+class TuplePatternItemsMultiple;\n+class TuplePatternItemsRanged;\n+class TuplePattern;\n+class GroupedPattern;\n+class SlicePattern;\n+\n+// rust-type.h\n+class TraitBound;\n+class ImplTraitType;\n+class TraitObjectType;\n+class ParenthesisedType;\n+class ImplTraitTypeOneBound;\n+class TraitObjectTypeOneBound;\n+class TupleType;\n+class NeverType;\n+class RawPointerType;\n+class ReferenceType;\n+class ArrayType;\n+class SliceType;\n+class InferredType;\n+struct MaybeNamedParam;\n+class BareFunctionType;\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "0a87d259b1943ae36dca5e9e582e59aab539652c", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "added", "additions": 6100, "deletions": 0, "changes": 6100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df"}, {"sha": "82525cd9b47b2327551e1a399154d0facc7cc90e", "filename": "gcc/rust/hir/tree/rust-hir-full.h", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,32 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_FULL_H\n+#define RUST_HIR_FULL_H\n+\n+// Use as a fast way of including all aspects of the HIR (i.e. all headers)\n+#include \"rust-hir.h\"\n+#include \"rust-hir-expr.h\"\n+#include \"rust-hir-item.h\"\n+#include \"rust-hir-path.h\"\n+#include \"rust-hir-pattern.h\"\n+#include \"rust-hir-stmt.h\"\n+#include \"rust-hir-type.h\"\n+#include \"rust-hir-macro.h\"\n+\n+#endif // RUST_HIR_FULL_H"}, {"sha": "e0477f438a18c678fbece7fd4a002c02f072b73a", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "added", "additions": 3259, "deletions": 0, "changes": 3259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=aa283484a3dffedc404653af18f9413775cbc3df"}, {"sha": "84b4914ef5740f974fd251291333b20889c6c11b", "filename": "gcc/rust/hir/tree/rust-hir-macro.h", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-macro.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,628 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_MACRO_H\n+#define RUST_HIR_MACRO_H\n+\n+#include \"rust-hir.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// Decls as definitions moved to rust-ast.h\n+class MacroItem;\n+class MacroInvocationSemi;\n+\n+enum MacroFragSpec\n+{\n+  BLOCK,\n+  EXPR,\n+  IDENT,\n+  ITEM,\n+  LIFETIME,\n+  LITERAL,\n+  META,\n+  PAT,\n+  PATH,\n+  STMT,\n+  TT,\n+  TY,\n+  VIS,\n+  INVALID // not really a specifier, but used to mark invalid one passed in\n+};\n+\n+inline MacroFragSpec\n+get_frag_spec_from_str (std::string str)\n+{\n+  if (str == \"block\")\n+    return BLOCK;\n+  else if (str == \"expr\")\n+    return EXPR;\n+  else if (str == \"ident\")\n+    return IDENT;\n+  else if (str == \"item\")\n+    return ITEM;\n+  else if (str == \"lifetime\")\n+    return LIFETIME;\n+  else if (str == \"literal\")\n+    return LITERAL;\n+  else if (str == \"meta\")\n+    return META;\n+  else if (str == \"pat\")\n+    return PAT;\n+  else if (str == \"path\")\n+    return PATH;\n+  else if (str == \"stmt\")\n+    return STMT;\n+  else if (str == \"tt\")\n+    return TT;\n+  else if (str == \"ty\")\n+    return TY;\n+  else if (str == \"vis\")\n+    return VIS;\n+  else\n+    {\n+      // error_at(\"invalid string '%s' used as fragment specifier\",\n+      // str->c_str());\n+      return INVALID;\n+    }\n+}\n+\n+// A macro match that has an identifier and fragment spec\n+class MacroMatchFragment : public MacroMatch\n+{\n+  Identifier ident;\n+  MacroFragSpec frag_spec;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroMatchFragment (Identifier ident, MacroFragSpec frag_spec)\n+    : ident (std::move (ident)), frag_spec (frag_spec)\n+  {}\n+\n+  // Returns whether macro match fragment is in an error state.\n+  bool is_error () const { return frag_spec == INVALID; }\n+\n+  // Creates an error state macro match fragment.\n+  static MacroMatchFragment create_error ()\n+  {\n+    return MacroMatchFragment (std::string (\"\"), INVALID);\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatchFragment *clone_macro_match_impl () const override\n+  {\n+    return new MacroMatchFragment (*this);\n+  }\n+};\n+\n+// A repetition macro match\n+class MacroMatchRepetition : public MacroMatch\n+{\n+public:\n+  enum MacroRepOp\n+  {\n+    NONE,\n+    ASTERISK,\n+    PLUS,\n+    QUESTION_MARK\n+  };\n+\n+private:\n+  std::vector<std::unique_ptr<MacroMatch> > matches;\n+  MacroRepOp op;\n+\n+  // bool has_sep;\n+  typedef Token MacroRepSep;\n+  // any token except delimiters and repetition operators\n+  std::unique_ptr<MacroRepSep> sep;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  // Returns whether macro match repetition has separator token.\n+  bool has_sep () const { return sep != NULL; }\n+\n+  MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch> > matches,\n+\t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep)\n+    : matches (std::move (matches)), op (op), sep (std::move (sep))\n+  {}\n+\n+  // Copy constructor with clone\n+  MacroMatchRepetition (MacroMatchRepetition const &other)\n+    : op (other.op), sep (other.sep->clone_token ())\n+  {\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  MacroMatchRepetition &operator= (MacroMatchRepetition const &other)\n+  {\n+    op = other.op;\n+    sep = other.sep->clone_token ();\n+\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MacroMatchRepetition (MacroMatchRepetition &&other) = default;\n+  MacroMatchRepetition &operator= (MacroMatchRepetition &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatchRepetition *clone_macro_match_impl () const override\n+  {\n+    return new MacroMatchRepetition (*this);\n+  }\n+};\n+\n+// can't inline due to polymorphism\n+class MacroMatcher : public MacroMatch\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<MacroMatch> > matches;\n+\n+  // TODO: think of way to mark invalid that doesn't take up more space\n+  bool is_invalid;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroMatcher (DelimType delim_type,\n+\t\tstd::vector<std::unique_ptr<MacroMatch> > matches)\n+    : delim_type (delim_type), matches (std::move (matches)), is_invalid (false)\n+  {}\n+\n+  // copy constructor with vector clone\n+  MacroMatcher (MacroMatcher const &other) : delim_type (other.delim_type)\n+  {\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  MacroMatcher &operator= (MacroMatcher const &other)\n+  {\n+    delim_type = other.delim_type;\n+\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MacroMatcher (MacroMatcher &&other) = default;\n+  MacroMatcher &operator= (MacroMatcher &&other) = default;\n+\n+  // Creates an error state macro matcher.\n+  static MacroMatcher create_error () { return MacroMatcher (true); }\n+\n+  // Returns whether MacroMatcher is in an error state.\n+  bool is_error () const { return is_invalid; }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatcher *clone_macro_match_impl () const override\n+  {\n+    return new MacroMatcher (*this);\n+  }\n+\n+  // constructor only used to create error matcher\n+  MacroMatcher (bool is_invalid) : delim_type (PARENS), is_invalid (is_invalid)\n+  {}\n+};\n+\n+// TODO: inline?\n+struct MacroTranscriber\n+{\n+private:\n+  DelimTokenTree token_tree;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroTranscriber (DelimTokenTree token_tree)\n+    : token_tree (std::move (token_tree))\n+  {}\n+\n+  std::string as_string () const { return token_tree.as_string (); }\n+};\n+\n+// A macro rule? Matcher and transcriber pair?\n+struct MacroRule\n+{\n+private:\n+  MacroMatcher matcher;\n+  MacroTranscriber transcriber;\n+\n+  // TODO: should store location information?\n+\n+public:\n+  MacroRule (MacroMatcher matcher, MacroTranscriber transcriber)\n+    : matcher (std::move (matcher)), transcriber (std::move (transcriber))\n+  {}\n+\n+  // Returns whether macro rule is in error state.\n+  bool is_error () const { return matcher.is_error (); }\n+\n+  // Creates an error state macro rule.\n+  static MacroRule create_error ()\n+  {\n+    return MacroRule (MacroMatcher::create_error (),\n+\t\t      MacroTranscriber (DelimTokenTree::create_empty ()));\n+  }\n+\n+  std::string as_string () const;\n+};\n+\n+// A macro rules definition item HIR node\n+class MacroRulesDefinition : public MacroItem\n+{\n+  Identifier rule_name;\n+  // MacroRulesDef rules_def; // TODO: inline\n+  // only curly without required semicolon at end\n+  DelimType delim_type;\n+  // MacroRules rules;\n+  std::vector<MacroRule> rules; // inlined form\n+\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  MacroRulesDefinition (Analysis::NodeMapping mappings, Identifier rule_name,\n+\t\t\tDelimType delim_type, std::vector<MacroRule> rules,\n+\t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+    : MacroItem (std::move (mappings), std::move (outer_attrs)),\n+      rule_name (std::move (rule_name)), delim_type (delim_type),\n+      rules (std::move (rules)), locus (locus)\n+  {}\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroRulesDefinition *clone_item_impl () const override\n+  {\n+    return new MacroRulesDefinition (*this);\n+  }\n+};\n+\n+/* HIR node of a macro invocation, which is replaced by the macro result at\n+ * compile time */\n+class MacroInvocation : public TypeNoBounds,\n+\t\t\tpublic Pattern,\n+\t\t\tpublic ExprWithoutBlock\n+{\n+  SimplePath path;\n+  DelimTokenTree token_tree;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  MacroInvocation (Analysis::NodeMapping mappings, SimplePath path,\n+\t\t   DelimTokenTree token_tree,\n+\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : TypeNoBounds (mappings),\n+      ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n+      path (std::move (path)), token_tree (std::move (token_tree)),\n+      locus (locus)\n+  {}\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_pattern_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_expr_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_expr_without_block_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_type_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_type_no_bounds_impl () const override\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+};\n+\n+// more generic meta item path-only form\n+class MetaItemPath : public MetaItem\n+{\n+  SimplePath path;\n+\n+public:\n+  MetaItemPath (SimplePath path) : path (std::move (path)) {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // HACK: used to simplify parsing - returns non-empty only in this case\n+  SimplePath to_path_item () const override\n+  {\n+    // this should copy construct - TODO ensure it does\n+    return path;\n+  }\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaItemPath *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaItemPath (*this);\n+  }\n+};\n+\n+// more generic meta item sequence form\n+class MetaItemSeq : public MetaItem\n+{\n+  SimplePath path;\n+  std::vector<std::unique_ptr<MetaItemInner> > seq;\n+\n+public:\n+  MetaItemSeq (SimplePath path,\n+\t       std::vector<std::unique_ptr<MetaItemInner> > seq)\n+    : path (std::move (path)), seq (std::move (seq))\n+  {}\n+\n+  // copy constructor with vector clone\n+  MetaItemSeq (const MetaItemSeq &other) : path (other.path)\n+  {\n+    seq.reserve (other.seq.size ());\n+    for (const auto &e : other.seq)\n+      seq.push_back (e->clone_meta_item_inner ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  MetaItemSeq &operator= (const MetaItemSeq &other)\n+  {\n+    MetaItem::operator= (other);\n+    path = other.path;\n+\n+    seq.reserve (other.seq.size ());\n+    for (const auto &e : other.seq)\n+      seq.push_back (e->clone_meta_item_inner ());\n+\n+    return *this;\n+  }\n+\n+  // default move constructors\n+  MetaItemSeq (MetaItemSeq &&other) = default;\n+  MetaItemSeq &operator= (MetaItemSeq &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaItemSeq *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaItemSeq (*this);\n+  }\n+};\n+\n+// Preferred specialisation for single-identifier meta items.\n+class MetaWord : public MetaItem\n+{\n+  Identifier ident;\n+\n+public:\n+  MetaWord (Identifier ident) : ident (std::move (ident)) {}\n+\n+  std::string as_string () const override { return ident; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaWord *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaWord (*this);\n+  }\n+};\n+\n+// Preferred specialisation for \"identifier '=' string literal\" meta items.\n+class MetaNameValueStr : public MetaItem\n+{\n+  Identifier ident;\n+  std::string str;\n+\n+public:\n+  MetaNameValueStr (Identifier ident, std::string str)\n+    : ident (std::move (ident)), str (std::move (str))\n+  {}\n+\n+  std::string as_string () const override { return ident + \" = \" + str; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // HACK: used to simplify parsing - creates a copy of this\n+  std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const override\n+  {\n+    return std::unique_ptr<MetaNameValueStr> (clone_meta_item_inner_impl ());\n+  }\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaNameValueStr *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaNameValueStr (*this);\n+  }\n+};\n+\n+// doubles up as MetaListIdents - determine via iterating through each path?\n+// Preferred specialisation for \"identifier '(' SimplePath, SimplePath, ... ')'\"\n+class MetaListPaths : public MetaItem\n+{\n+  Identifier ident;\n+  std::vector<SimplePath> paths;\n+\n+public:\n+  MetaListPaths (Identifier ident, std::vector<SimplePath> paths)\n+    : ident (std::move (ident)), paths (std::move (paths))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaListPaths *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaListPaths (*this);\n+  }\n+};\n+\n+// Preferred specialisation for \"identifier '(' MetaNameValueStr, ... ')'\"\n+class MetaListNameValueStr : public MetaItem\n+{\n+  Identifier ident;\n+  std::vector<MetaNameValueStr> strs;\n+\n+public:\n+  MetaListNameValueStr (Identifier ident, std::vector<MetaNameValueStr> strs)\n+    : ident (std::move (ident)), strs (std::move (strs))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaListNameValueStr *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaListNameValueStr (*this);\n+  }\n+};\n+\n+// Object that parses macros from a token stream.\n+struct MacroParser\n+{\n+private:\n+  std::vector<std::unique_ptr<Token> > token_stream;\n+  /* probably have to make this mutable (mutable int stream_pos) otherwise const\n+   * has to be removed up to DelimTokenTree or further ok since this changing\n+   * would have an effect on the results of the methods run (i.e. not logically\n+   * const), the parsing methods shouldn't be const */\n+  int stream_pos;\n+\n+public:\n+  MacroParser (std::vector<std::unique_ptr<Token> > token_stream,\n+\t       int stream_start_pos = 0)\n+    : token_stream (std::move (token_stream)), stream_pos (stream_start_pos)\n+  {}\n+\n+  ~MacroParser () = default;\n+\n+  std::vector<std::unique_ptr<MetaItemInner> > parse_meta_item_seq ();\n+\n+private:\n+  // Parses a MetaItemInner.\n+  std::unique_ptr<MetaItemInner> parse_meta_item_inner ();\n+  // Returns whether token can end a meta item.\n+  bool is_end_meta_item_tok (TokenId id) const;\n+  // Parses a simple path.\n+  SimplePath parse_simple_path ();\n+  // Parses a segment of a simple path (but not scope resolution operator).\n+  SimplePathSegment parse_simple_path_segment ();\n+  // Parses a MetaItemLitExpr.\n+  std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit ();\n+  // Parses a literal.\n+  Literal parse_literal ();\n+  // Parses a meta item that begins with a simple path.\n+  std::unique_ptr<MetaItem> parse_path_meta_item ();\n+\n+  // TODO: should this be const?\n+  std::unique_ptr<Token> &peek_token (int i = 0)\n+  {\n+    return token_stream[stream_pos + i];\n+  }\n+\n+  void skip_token (int i = 0) { stream_pos += 1 + i; }\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "1bba50687d18b39204e6dd9fa3bede407ff1cedd", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "added", "additions": 845, "deletions": 0, "changes": 845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,845 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_PATH_H\n+#define RUST_HIR_PATH_H\n+\n+#include \"rust-hir.h\"\n+\n+#include <string>\n+#include <vector>\n+\n+namespace Rust {\n+namespace HIR {\n+\n+// The \"identifier\" (not generic args) aspect of each path expression segment\n+class PathIdentSegment\n+{\n+  std::string segment_name;\n+\n+  // TODO: should this have location info stored?\n+\n+  // only allow identifiers, \"super\", \"self\", \"Self\", \"crate\", or \"$crate\"\n+public:\n+  PathIdentSegment (std::string segment_name)\n+    : segment_name (std::move (segment_name))\n+  {}\n+\n+  /* TODO: insert check in constructor for this? Or is this a semantic error\n+   * best handled then? */\n+\n+  /* TODO: does this require visitor? pretty sure this isn't polymorphic, but\n+   * not entirely sure */\n+\n+  // Creates an error PathIdentSegment.\n+  static PathIdentSegment create_error () { return PathIdentSegment (\"\"); }\n+\n+  // Returns whether PathIdentSegment is in an error state.\n+  bool is_error () const { return segment_name.empty (); }\n+\n+  std::string as_string () const { return segment_name; }\n+};\n+\n+// A binding of an identifier to a type used in generic arguments in paths\n+struct GenericArgsBinding\n+{\n+private:\n+  Identifier identifier;\n+  std::unique_ptr<Type> type;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether binding is in an error state.\n+  bool is_error () const\n+  {\n+    return type == nullptr;\n+    // and also identifier is empty, but cheaper computation\n+  }\n+\n+  // Creates an error state generic args binding.\n+  static GenericArgsBinding create_error ()\n+  {\n+    return GenericArgsBinding (\"\", nullptr);\n+  }\n+\n+  // Pointer type for type in constructor to enable polymorphism\n+  GenericArgsBinding (Identifier ident, std::unique_ptr<Type> type_ptr,\n+\t\t      Location locus = Location ())\n+    : identifier (std::move (ident)), type (std::move (type_ptr)), locus (locus)\n+  {}\n+\n+  // Copy constructor has to deep copy the type as it is a unique pointer\n+  GenericArgsBinding (GenericArgsBinding const &other)\n+    : identifier (other.identifier), type (other.type->clone_type ()),\n+      locus (other.locus)\n+  {}\n+\n+  // default destructor\n+  ~GenericArgsBinding () = default;\n+\n+  // Overload assignment operator to deep copy the pointed-to type\n+  GenericArgsBinding &operator= (GenericArgsBinding const &other)\n+  {\n+    identifier = other.identifier;\n+    type = other.type->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgsBinding (GenericArgsBinding &&other) = default;\n+  GenericArgsBinding &operator= (GenericArgsBinding &&other) = default;\n+\n+  std::string as_string () const;\n+};\n+\n+// Generic arguments allowed in each path expression segment - inline?\n+struct GenericArgs\n+{\n+  std::vector<Lifetime> lifetime_args;\n+  std::vector<std::unique_ptr<Type> > type_args;\n+  std::vector<GenericArgsBinding> binding_args;\n+  Location locus;\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  bool has_generic_args () const\n+  {\n+    return !(lifetime_args.empty () && type_args.empty ()\n+\t     && binding_args.empty ());\n+  }\n+\n+  GenericArgs (std::vector<Lifetime> lifetime_args,\n+\t       std::vector<std::unique_ptr<Type> > type_args,\n+\t       std::vector<GenericArgsBinding> binding_args,\n+\t       Location locus = Location ())\n+    : lifetime_args (std::move (lifetime_args)),\n+      type_args (std::move (type_args)),\n+      binding_args (std::move (binding_args)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  GenericArgs (GenericArgs const &other)\n+    : lifetime_args (other.lifetime_args), binding_args (other.binding_args),\n+      locus (other.locus)\n+  {\n+    type_args.reserve (other.type_args.size ());\n+    for (const auto &e : other.type_args)\n+      type_args.push_back (e->clone_type ());\n+  }\n+\n+  ~GenericArgs () = default;\n+\n+  // overloaded assignment operator to vector clone\n+  GenericArgs &operator= (GenericArgs const &other)\n+  {\n+    lifetime_args = other.lifetime_args;\n+    binding_args = other.binding_args;\n+    locus = other.locus;\n+\n+    type_args.reserve (other.type_args.size ());\n+    for (const auto &e : other.type_args)\n+      type_args.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgs (GenericArgs &&other) = default;\n+  GenericArgs &operator= (GenericArgs &&other) = default;\n+\n+  // Creates an empty GenericArgs (no arguments)\n+  static GenericArgs create_empty ()\n+  {\n+    return GenericArgs (std::vector<Lifetime> (),\n+\t\t\tstd::vector<std::unique_ptr<Type> > (),\n+\t\t\tstd::vector<GenericArgsBinding> ());\n+  }\n+\n+  std::string as_string () const;\n+};\n+\n+/* A segment of a path in expression, including an identifier aspect and maybe\n+ * generic args */\n+class PathExprSegment\n+{ // or should this extend PathIdentSegment?\n+private:\n+  PathIdentSegment segment_name;\n+\n+  // bool has_generic_args;\n+  GenericArgs generic_args;\n+\n+  Location locus;\n+\n+  // TODO: does this require visitor? pretty sure not polymorphic\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n+\n+  // Constructor for segment (from IdentSegment and GenericArgs)\n+  PathExprSegment (PathIdentSegment segment_name, Location locus = Location (),\n+\t\t   GenericArgs generic_args = GenericArgs::create_empty ())\n+    : segment_name (std::move (segment_name)),\n+      generic_args (std::move (generic_args)), locus (locus)\n+  {}\n+\n+  /* Constructor for segment with generic arguments (from segment name and all\n+   * args) */\n+  PathExprSegment (std::string segment_name, Location locus,\n+\t\t   std::vector<Lifetime> lifetime_args\n+\t\t   = std::vector<Lifetime> (),\n+\t\t   std::vector<std::unique_ptr<Type> > type_args\n+\t\t   = std::vector<std::unique_ptr<Type> > (),\n+\t\t   std::vector<GenericArgsBinding> binding_args\n+\t\t   = std::vector<GenericArgsBinding> ())\n+    : segment_name (PathIdentSegment (std::move (segment_name))),\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (type_args),\n+\t\t\t\t std::move (binding_args))),\n+      locus (locus)\n+  {}\n+\n+  // Returns whether path expression segment is in an error state.\n+  bool is_error () const { return segment_name.is_error (); }\n+\n+  // Creates an error-state path expression segment.\n+  static PathExprSegment create_error ()\n+  {\n+    return PathExprSegment (PathIdentSegment::create_error ());\n+  }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+};\n+\n+// HIR node representing a pattern that involves a \"path\" - abstract base class\n+class PathPattern : public Pattern\n+{\n+  std::vector<PathExprSegment> segments;\n+\n+protected:\n+  PathPattern (std::vector<PathExprSegment> segments)\n+    : segments (std::move (segments))\n+  {}\n+\n+  // Returns whether path has segments.\n+  bool has_segments () const { return !segments.empty (); }\n+\n+  /* Converts path segments to their equivalent SimplePath segments if possible,\n+   * and creates a SimplePath from them. */\n+  SimplePath convert_to_simple_path (bool with_opening_scope_resolution) const;\n+\n+public:\n+  /* Returns whether the path is a single segment (excluding qualified path\n+   * initial as segment). */\n+  bool is_single_segment () const { return segments.size () == 1; }\n+\n+  std::string as_string () const override;\n+\n+  void iterate_path_segments (std::function<bool (PathExprSegment &)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb (*it))\n+\t  return;\n+      }\n+  }\n+};\n+\n+/* HIR node representing a path-in-expression pattern (path that allows generic\n+ * arguments) */\n+class PathInExpression : public PathPattern, public PathExpr\n+{\n+  bool has_opening_scope_resolution;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor\n+  PathInExpression (Analysis::NodeMapping mappings,\n+\t\t    std::vector<PathExprSegment> path_segments,\n+\t\t    Location locus = Location (),\n+\t\t    bool has_opening_scope_resolution = false,\n+\t\t    std::vector<Attribute> outer_attrs\n+\t\t    = std::vector<Attribute> ())\n+    : PathPattern (std::move (path_segments)),\n+      PathExpr (std::move (mappings), std::move (outer_attrs)),\n+      has_opening_scope_resolution (has_opening_scope_resolution), locus (locus)\n+  {}\n+\n+  // Creates an error state path in expression.\n+  static PathInExpression create_error ()\n+  {\n+    return PathInExpression (Analysis::NodeMapping::get_error (),\n+\t\t\t     std::vector<PathExprSegment> ());\n+  }\n+\n+  // Returns whether path in expression is in an error state.\n+  bool is_error () const { return !has_segments (); }\n+\n+  /* Converts PathInExpression to SimplePath if possible (i.e. no generic\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  SimplePath as_simple_path () const\n+  {\n+    /* delegate to parent class as can't access segments. however,\n+     * QualifiedPathInExpression conversion to simple path wouldn't make sense,\n+     * so the method in the parent class should be protected, not public. Have\n+     * to pass in opening scope resolution as parent class has no access to it.\n+     */\n+    return convert_to_simple_path (has_opening_scope_resolution);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  bool opening_scope_resolution () { return has_opening_scope_resolution; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  PathInExpression *clone_pattern_impl () const override\n+  {\n+    return new PathInExpression (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  PathInExpression *clone_expr_without_block_impl () const override\n+  {\n+    return new PathInExpression (*this);\n+  }\n+};\n+\n+/* Base class for segments used in type paths - not abstract (represents an\n+ * ident-only segment) */\n+class TypePathSegment\n+{\n+  /* TODO: may have to unify TypePathSegment and PathExprSegment (which are\n+   * mostly the same anyway) in order to resolve goddamn syntax ambiguities. One\n+   * difference is that function on TypePathSegment is not allowed if\n+   * GenericArgs are, so could disallow that in constructor, which won't give\n+   * that much size overhead. */\n+  PathIdentSegment ident_segment;\n+\n+  Location locus;\n+\n+protected:\n+  /* This is protected because it is only really used by derived classes, not\n+   * the base. */\n+  bool has_separating_scope_resolution;\n+\n+  // Clone function implementation - not pure virtual as overrided by subclasses\n+  virtual TypePathSegment *clone_type_path_segment_impl () const\n+  {\n+    return new TypePathSegment (*this);\n+  }\n+\n+public:\n+  virtual ~TypePathSegment () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypePathSegment> clone_type_path_segment () const\n+  {\n+    return std::unique_ptr<TypePathSegment> (clone_type_path_segment_impl ());\n+  }\n+\n+  TypePathSegment (PathIdentSegment ident_segment,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : ident_segment (std::move (ident_segment)), locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution)\n+  {}\n+\n+  TypePathSegment (std::string segment_name,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : ident_segment (PathIdentSegment (std::move (segment_name))),\n+      locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution)\n+  {}\n+\n+  virtual std::string as_string () const { return ident_segment.as_string (); }\n+\n+  /* Returns whether the type path segment is in an error state. May be virtual\n+   * in future. */\n+  bool is_error () const { return ident_segment.is_error (); }\n+\n+  /* Returns whether segment is identifier only (as opposed to generic args or\n+   * function). Overriden in derived classes with other segments. */\n+  virtual bool is_ident_only () const { return true; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  // not pure virtual as class not abstract\n+  virtual void accept_vis (HIRVisitor &vis);\n+};\n+\n+// Segment used in type path with generic args\n+class TypePathSegmentGeneric : public TypePathSegment\n+{\n+  GenericArgs generic_args;\n+\n+public:\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n+\n+  bool is_ident_only () const override { return false; }\n+\n+  // Constructor with PathIdentSegment and GenericArgs\n+  TypePathSegmentGeneric (PathIdentSegment ident_segment,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  GenericArgs generic_args, Location locus)\n+    : TypePathSegment (std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (std::move (generic_args))\n+  {}\n+\n+  // Constructor from segment name and all args\n+  TypePathSegmentGeneric (std::string segment_name,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  std::vector<Lifetime> lifetime_args,\n+\t\t\t  std::vector<std::unique_ptr<Type> > type_args,\n+\t\t\t  std::vector<GenericArgsBinding> binding_args,\n+\t\t\t  Location locus)\n+    : TypePathSegment (std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (type_args),\n+\t\t\t\t std::move (binding_args)))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  // Use covariance to override base class method\n+  TypePathSegmentGeneric *clone_type_path_segment_impl () const override\n+  {\n+    return new TypePathSegmentGeneric (*this);\n+  }\n+};\n+\n+// A function as represented in a type path\n+struct TypePathFunction\n+{\n+private:\n+  // TODO: remove\n+  /*bool has_inputs;\n+  TypePathFnInputs inputs;*/\n+  // inlined from TypePathFnInputs\n+  std::vector<std::unique_ptr<Type> > inputs;\n+\n+  // bool has_type;\n+  std::unique_ptr<Type> return_type;\n+\n+  // FIXME: think of better way to mark as invalid than taking up storage\n+  bool is_invalid;\n+\n+  // TODO: should this have location info?\n+\n+protected:\n+  // Constructor only used to create invalid type path functions.\n+  TypePathFunction (bool is_invalid) : is_invalid (is_invalid) {}\n+\n+public:\n+  // Returns whether the return type of the function has been specified.\n+  bool has_return_type () const { return return_type != nullptr; }\n+\n+  // Returns whether the function has inputs.\n+  bool has_inputs () const { return !inputs.empty (); }\n+\n+  // Returns whether function is in an error state.\n+  bool is_error () const { return is_invalid; }\n+\n+  // Creates an error state function.\n+  static TypePathFunction create_error () { return TypePathFunction (true); }\n+\n+  // Constructor\n+  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n+\t\t    Type *type = nullptr)\n+    : inputs (std::move (inputs)), return_type (type), is_invalid (false)\n+  {}\n+  // FIXME: deprecated\n+\n+  // Constructor\n+  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs,\n+\t\t    std::unique_ptr<Type> type = nullptr)\n+    : inputs (std::move (inputs)), return_type (std::move (type)),\n+      is_invalid (false)\n+  {}\n+\n+  // Copy constructor with clone\n+  TypePathFunction (TypePathFunction const &other)\n+    : return_type (other.return_type->clone_type ()),\n+      is_invalid (other.is_invalid)\n+  {\n+    inputs.reserve (other.inputs.size ());\n+    for (const auto &e : other.inputs)\n+      inputs.push_back (e->clone_type ());\n+  }\n+\n+  ~TypePathFunction () = default;\n+\n+  // Overloaded assignment operator to clone type\n+  TypePathFunction &operator= (TypePathFunction const &other)\n+  {\n+    return_type = other.return_type->clone_type ();\n+    is_invalid = other.is_invalid;\n+\n+    inputs.reserve (other.inputs.size ());\n+    for (const auto &e : other.inputs)\n+      inputs.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePathFunction (TypePathFunction &&other) = default;\n+  TypePathFunction &operator= (TypePathFunction &&other) = default;\n+\n+  std::string as_string () const;\n+};\n+\n+// Segment used in type path with a function argument\n+class TypePathSegmentFunction : public TypePathSegment\n+{\n+  TypePathFunction function_path;\n+\n+public:\n+  // Constructor with PathIdentSegment and TypePathFn\n+  TypePathSegmentFunction (PathIdentSegment ident_segment,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (std::move (function_path))\n+  {}\n+\n+  // Constructor with segment name and TypePathFn\n+  TypePathSegmentFunction (std::string segment_name,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (std::move (function_path))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  bool is_ident_only () const override { return false; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  // Use covariance to override base class method\n+  TypePathSegmentFunction *clone_type_path_segment_impl () const override\n+  {\n+    return new TypePathSegmentFunction (*this);\n+  }\n+};\n+\n+// Path used inside types\n+class TypePath : public TypeNoBounds\n+{\n+public:\n+  bool has_opening_scope_resolution;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TypePath *clone_type_impl () const override { return new TypePath (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TypePath *clone_type_no_bounds_impl () const override\n+  {\n+    return new TypePath (*this);\n+  }\n+\n+public:\n+  /* Returns whether the TypePath has an opening scope resolution operator (i.e.\n+   * is global path or crate-relative path, not module-relative) */\n+  bool has_opening_scope_resolution_op () const\n+  {\n+    return has_opening_scope_resolution;\n+  }\n+\n+  // Returns whether the TypePath is in an invalid state.\n+  bool is_error () const { return segments.empty (); }\n+\n+  // Creates an error state TypePath.\n+  static TypePath create_error ()\n+  {\n+    return TypePath (Analysis::NodeMapping::get_error (),\n+\t\t     std::vector<std::unique_ptr<TypePathSegment> > (),\n+\t\t     Location ());\n+  }\n+\n+  // Constructor\n+  TypePath (Analysis::NodeMapping mappings,\n+\t    std::vector<std::unique_ptr<TypePathSegment> > segments,\n+\t    Location locus, bool has_opening_scope_resolution = false)\n+    : TypeNoBounds (mappings),\n+      has_opening_scope_resolution (has_opening_scope_resolution),\n+      segments (std::move (segments)), locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TypePath (TypePath const &other)\n+    : TypeNoBounds (other.mappings),\n+      has_opening_scope_resolution (other.has_opening_scope_resolution),\n+      locus (other.locus)\n+  {\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+  }\n+\n+  // Overloaded assignment operator with clone\n+  TypePath &operator= (TypePath const &other)\n+  {\n+    has_opening_scope_resolution = other.has_opening_scope_resolution;\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePath (TypePath &&other) = default;\n+  TypePath &operator= (TypePath &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  /* Converts TypePath to SimplePath if possible (i.e. no generic or function\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  SimplePath as_simple_path () const;\n+\n+  // Creates a trait bound with a clone of this type path as its only element.\n+  TraitBound *to_trait_bound (bool in_parens) const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  size_t get_num_segments () const { return segments.size (); }\n+\n+  void iterate_segments (std::function<bool (TypePathSegment *)> cb)\n+  {\n+    for (auto it = segments.begin (); it != segments.end (); it++)\n+      {\n+\tif (!cb ((*it).get ()))\n+\t  return;\n+      }\n+  }\n+};\n+\n+struct QualifiedPathType\n+{\n+private:\n+  std::unique_ptr<Type> type_to_invoke_on;\n+\n+  // bool has_as_clause;\n+  TypePath trait_path;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  QualifiedPathType (std::unique_ptr<Type> invoke_on_type,\n+\t\t     Location locus = Location (),\n+\t\t     TypePath trait_path = TypePath::create_error ())\n+    : type_to_invoke_on (std::move (invoke_on_type)),\n+      trait_path (std::move (trait_path)), locus (locus)\n+  {}\n+\n+  // Copy constructor uses custom deep copy for Type to preserve polymorphism\n+  QualifiedPathType (QualifiedPathType const &other)\n+    : type_to_invoke_on (other.type_to_invoke_on->clone_type ()),\n+      trait_path (other.trait_path), locus (other.locus)\n+  {}\n+\n+  // default destructor\n+  ~QualifiedPathType () = default;\n+\n+  // overload assignment operator to use custom clone method\n+  QualifiedPathType &operator= (QualifiedPathType const &other)\n+  {\n+    type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n+    trait_path = other.trait_path;\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructor\n+  QualifiedPathType (QualifiedPathType &&other) = default;\n+  QualifiedPathType &operator= (QualifiedPathType &&other) = default;\n+\n+  // Returns whether the qualified path type has a rebind as clause.\n+  bool has_as_clause () const { return !trait_path.is_error (); }\n+\n+  // Returns whether the qualified path type is in an error state.\n+  bool is_error () const { return type_to_invoke_on == nullptr; }\n+\n+  // Creates an error state qualified path type.\n+  static QualifiedPathType create_error ()\n+  {\n+    return QualifiedPathType (nullptr);\n+  }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+};\n+\n+/* HIR node representing a qualified path-in-expression pattern (path that\n+ * allows specifying trait functions) */\n+class QualifiedPathInExpression : public PathPattern, public PathExpr\n+{\n+  QualifiedPathType path_type;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  QualifiedPathInExpression (Analysis::NodeMapping mappings,\n+\t\t\t     QualifiedPathType qual_path_type,\n+\t\t\t     std::vector<PathExprSegment> path_segments,\n+\t\t\t     Location locus = Location (),\n+\t\t\t     std::vector<Attribute> outer_attrs\n+\t\t\t     = std::vector<Attribute> ())\n+    : PathPattern (std::move (path_segments)),\n+      PathExpr (std::move (mappings), std::move (outer_attrs)),\n+      path_type (std::move (qual_path_type)), locus (locus)\n+  {}\n+\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n+   * as params */\n+\n+  // Returns whether qualified path in expression is in an error state.\n+  bool is_error () const { return path_type.is_error (); }\n+\n+  // Creates an error qualified path in expression.\n+  static QualifiedPathInExpression create_error ()\n+  {\n+    return QualifiedPathInExpression (Analysis::NodeMapping::get_error (),\n+\t\t\t\t      QualifiedPathType::create_error (),\n+\t\t\t\t      std::vector<PathExprSegment> ());\n+  }\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInExpression *clone_pattern_impl () const override\n+  {\n+    return new QualifiedPathInExpression (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInExpression *clone_expr_without_block_impl () const override\n+  {\n+    return new QualifiedPathInExpression (*this);\n+  }\n+};\n+\n+/* Represents a qualified path in a type; used for disambiguating trait function\n+ * calls */\n+class QualifiedPathInType : public TypeNoBounds\n+{\n+  QualifiedPathType path_type;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInType *clone_type_impl () const override\n+  {\n+    return new QualifiedPathInType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  QualifiedPathInType *clone_type_no_bounds_impl () const override\n+  {\n+    return new QualifiedPathInType (*this);\n+  }\n+\n+public:\n+  QualifiedPathInType (\n+    Analysis::NodeMapping mappings, QualifiedPathType qual_path_type,\n+    std::vector<std::unique_ptr<TypePathSegment> > path_segments,\n+    Location locus = Location ())\n+    : TypeNoBounds (mappings), path_type (std::move (qual_path_type)),\n+      segments (std::move (path_segments)), locus (locus)\n+  {}\n+\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType elements\n+   * as params */\n+\n+  // Copy constructor with vector clone\n+  QualifiedPathInType (QualifiedPathInType const &other)\n+    : TypeNoBounds (mappings), path_type (other.path_type), locus (other.locus)\n+  {\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  QualifiedPathInType &operator= (QualifiedPathInType const &other)\n+  {\n+    path_type = other.path_type;\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  QualifiedPathInType (QualifiedPathInType &&other) = default;\n+  QualifiedPathInType &operator= (QualifiedPathInType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "3ff13d27c3d0c76c47db0a45b49a937d955122b3", "filename": "gcc/rust/hir/tree/rust-hir-pattern.h", "status": "added", "additions": 1162, "deletions": 0, "changes": 1162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-pattern.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,1162 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_PATTERN_H\n+#define RUST_HIR_PATTERN_H\n+\n+#include \"rust-hir.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// Literal pattern HIR node (comparing to a literal)\n+class LiteralPattern : public Pattern\n+{\n+  Literal lit;\n+  /* make literal have a type given by enum, etc. rustc uses an extended form of\n+   * its literal token implementation */\n+  // TODO: literal representation - use LiteralExpr? or another thing?\n+\n+  // Minus prefixed to literal (if integer or floating-point)\n+  bool has_minus;\n+  // Actually, this might be a good place to use a template.\n+\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor for a literal pattern\n+  LiteralPattern (Literal lit, Location locus, bool has_minus = false)\n+    : lit (std::move (lit)), has_minus (has_minus), locus (locus)\n+  {}\n+\n+  LiteralPattern (std::string val, Literal::LitType type, Location locus,\n+\t\t  bool has_minus = false)\n+    : lit (Literal (std::move (val), type)), has_minus (has_minus),\n+      locus (locus)\n+  {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  virtual LiteralPattern *clone_pattern_impl () const override\n+  {\n+    return new LiteralPattern (*this);\n+  }\n+};\n+\n+// Identifier pattern HIR node (bind value matched to a variable)\n+class IdentifierPattern : public Pattern\n+{\n+public:\n+  Identifier variable_ident;\n+  bool is_ref;\n+  bool is_mut;\n+\n+  // bool has_pattern;\n+  std::unique_ptr<Pattern> to_bind;\n+\n+  Location locus;\n+\n+  std::string as_string () const;\n+\n+  // Returns whether the IdentifierPattern has a pattern to bind.\n+  bool has_pattern_to_bind () const { return to_bind != nullptr; }\n+\n+  // Constructor\n+  IdentifierPattern (Identifier ident, Location locus, bool is_ref = false,\n+\t\t     bool is_mut = false,\n+\t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n+    : variable_ident (std::move (ident)), is_ref (is_ref), is_mut (is_mut),\n+      to_bind (std::move (to_bind)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  IdentifierPattern (IdentifierPattern const &other)\n+    : variable_ident (other.variable_ident), is_ref (other.is_ref),\n+      is_mut (other.is_mut), locus (other.locus)\n+  {\n+    // fix to get prevent null pointer dereference\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n+  }\n+\n+  // Overload assignment operator to use clone\n+  IdentifierPattern &operator= (IdentifierPattern const &other)\n+  {\n+    variable_ident = other.variable_ident;\n+    is_ref = other.is_ref;\n+    is_mut = other.is_mut;\n+    locus = other.locus;\n+\n+    // fix to get prevent null pointer dereference\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  IdentifierPattern (IdentifierPattern &&other) = default;\n+  IdentifierPattern &operator= (IdentifierPattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  IdentifierPattern *clone_pattern_impl () const override\n+  {\n+    return new IdentifierPattern (*this);\n+  }\n+};\n+\n+// HIR node for using the '_' wildcard \"match any value\" pattern\n+class WildcardPattern : public Pattern\n+{\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override { return std::string (1, '_'); }\n+\n+  WildcardPattern (Location locus) : locus (locus) {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  WildcardPattern *clone_pattern_impl () const override\n+  {\n+    return new WildcardPattern (*this);\n+  }\n+};\n+\n+// Base range pattern bound (lower or upper limit) - abstract\n+class RangePatternBound\n+{\n+public:\n+  virtual ~RangePatternBound () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<RangePatternBound> clone_range_pattern_bound () const\n+  {\n+    return std::unique_ptr<RangePatternBound> (\n+      clone_range_pattern_bound_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual as RangePatternBound is abstract\n+  virtual RangePatternBound *clone_range_pattern_bound_impl () const = 0;\n+};\n+\n+// Literal-based pattern bound\n+class RangePatternBoundLiteral : public RangePatternBound\n+{\n+  Literal literal;\n+  /* Can only be a char, byte, int, or float literal - same impl here as\n+   * previously */\n+\n+  // Minus prefixed to literal (if integer or floating-point)\n+  bool has_minus;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  RangePatternBoundLiteral (Literal literal, Location locus,\n+\t\t\t    bool has_minus = false)\n+    : literal (literal), has_minus (has_minus), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundLiteral *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundLiteral (*this);\n+  }\n+};\n+\n+// Path-based pattern bound\n+class RangePatternBoundPath : public RangePatternBound\n+{\n+  PathInExpression path;\n+\n+  /* TODO: should this be refactored so that PathInExpression is a subclass of\n+   * RangePatternBound? */\n+\n+public:\n+  RangePatternBoundPath (PathInExpression path) : path (std::move (path)) {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundPath *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundPath (*this);\n+  }\n+};\n+\n+// Qualified path-based pattern bound\n+class RangePatternBoundQualPath : public RangePatternBound\n+{\n+  QualifiedPathInExpression path;\n+\n+  /* TODO: should this be refactored so that QualifiedPathInExpression is a\n+   * subclass of RangePatternBound? */\n+\n+public:\n+  RangePatternBoundQualPath (QualifiedPathInExpression path)\n+    : path (std::move (path))\n+  {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundQualPath *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundQualPath (*this);\n+  }\n+};\n+\n+// HIR node for matching within a certain range (range pattern)\n+class RangePattern : public Pattern\n+{\n+  std::unique_ptr<RangePatternBound> lower;\n+  std::unique_ptr<RangePatternBound> upper;\n+\n+  bool has_ellipsis_syntax;\n+\n+  /* location only stored to avoid a dereference - lower pattern should give\n+   * correct location so maybe change in future */\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor\n+  RangePattern (std::unique_ptr<RangePatternBound> lower,\n+\t\tstd::unique_ptr<RangePatternBound> upper, Location locus,\n+\t\tbool has_ellipsis_syntax = false)\n+    : lower (std::move (lower)), upper (std::move (upper)),\n+      has_ellipsis_syntax (has_ellipsis_syntax), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  RangePattern (RangePattern const &other)\n+    : lower (other.lower->clone_range_pattern_bound ()),\n+      upper (other.upper->clone_range_pattern_bound ()),\n+      has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus)\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  RangePattern &operator= (RangePattern const &other)\n+  {\n+    lower = other.lower->clone_range_pattern_bound ();\n+    upper = other.upper->clone_range_pattern_bound ();\n+    has_ellipsis_syntax = other.has_ellipsis_syntax;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RangePattern (RangePattern &&other) = default;\n+  RangePattern &operator= (RangePattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePattern *clone_pattern_impl () const override\n+  {\n+    return new RangePattern (*this);\n+  }\n+};\n+\n+// HIR node for pattern based on dereferencing the pointers given\n+class ReferencePattern : public Pattern\n+{\n+  bool has_two_amps;\n+  bool is_mut;\n+  std::unique_ptr<Pattern> pattern;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ReferencePattern (std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n+\t\t    bool ref_has_two_amps, Location locus)\n+    : has_two_amps (ref_has_two_amps), is_mut (is_mut_reference),\n+      pattern (std::move (pattern)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires clone\n+  ReferencePattern (ReferencePattern const &other)\n+    : has_two_amps (other.has_two_amps), is_mut (other.is_mut),\n+      pattern (other.pattern->clone_pattern ()), locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  ReferencePattern &operator= (ReferencePattern const &other)\n+  {\n+    pattern = other.pattern->clone_pattern ();\n+    is_mut = other.is_mut;\n+    has_two_amps = other.has_two_amps;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ReferencePattern (ReferencePattern &&other) = default;\n+  ReferencePattern &operator= (ReferencePattern &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferencePattern *clone_pattern_impl () const override\n+  {\n+    return new ReferencePattern (*this);\n+  }\n+};\n+\n+// aka StructPatternEtCetera; potential element in struct pattern\n+struct StructPatternEtc\n+{\n+private:\n+  std::vector<Attribute> outer_attrs;\n+\n+  // should this store location data?\n+\n+public:\n+  StructPatternEtc (std::vector<Attribute> outer_attribs)\n+    : outer_attrs (std::move (outer_attribs))\n+  {}\n+\n+  // Creates an empty StructPatternEtc\n+  static StructPatternEtc create_empty ()\n+  {\n+    return StructPatternEtc (std::vector<Attribute> ());\n+  }\n+};\n+\n+// Base class for a single field in a struct pattern - abstract\n+class StructPatternField\n+{\n+  std::vector<Attribute> outer_attrs;\n+  Location locus;\n+\n+public:\n+  virtual ~StructPatternField () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<StructPatternField> clone_struct_pattern_field () const\n+  {\n+    return std::unique_ptr<StructPatternField> (\n+      clone_struct_pattern_field_impl ());\n+  }\n+\n+  virtual std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  StructPatternField (std::vector<Attribute> outer_attribs, Location locus)\n+    : outer_attrs (std::move (outer_attribs)), locus (locus)\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual StructPatternField *clone_struct_pattern_field_impl () const = 0;\n+};\n+\n+// Tuple pattern single field in a struct pattern\n+class StructPatternFieldTuplePat : public StructPatternField\n+{\n+  TupleIndex index;\n+  std::unique_ptr<Pattern> tuple_pattern;\n+\n+public:\n+  StructPatternFieldTuplePat (TupleIndex index,\n+\t\t\t      std::unique_ptr<Pattern> tuple_pattern,\n+\t\t\t      std::vector<Attribute> outer_attribs,\n+\t\t\t      Location locus)\n+    : StructPatternField (std::move (outer_attribs), locus), index (index),\n+      tuple_pattern (std::move (tuple_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat const &other)\n+    : StructPatternField (other), index (other.index),\n+      tuple_pattern (other.tuple_pattern->clone_pattern ())\n+  {}\n+\n+  // Overload assignment operator to perform clone\n+  StructPatternFieldTuplePat &\n+  operator= (StructPatternFieldTuplePat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    tuple_pattern = other.tuple_pattern->clone_pattern ();\n+    index = other.index;\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat &&other) = default;\n+  StructPatternFieldTuplePat &operator= (StructPatternFieldTuplePat &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldTuplePat *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldTuplePat (*this);\n+  }\n+};\n+\n+// Identifier pattern single field in a struct pattern\n+class StructPatternFieldIdentPat : public StructPatternField\n+{\n+  Identifier ident;\n+  std::unique_ptr<Pattern> ident_pattern;\n+\n+public:\n+  StructPatternFieldIdentPat (Identifier ident,\n+\t\t\t      std::unique_ptr<Pattern> ident_pattern,\n+\t\t\t      std::vector<Attribute> outer_attrs,\n+\t\t\t      Location locus)\n+    : StructPatternField (std::move (outer_attrs), locus),\n+      ident (std::move (ident)), ident_pattern (std::move (ident_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat const &other)\n+    : StructPatternField (other), ident (other.ident),\n+      ident_pattern (other.ident_pattern->clone_pattern ())\n+  {}\n+\n+  // Overload assignment operator to clone\n+  StructPatternFieldIdentPat &\n+  operator= (StructPatternFieldIdentPat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    ident = other.ident;\n+    ident_pattern = other.ident_pattern->clone_pattern ();\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat &&other) = default;\n+  StructPatternFieldIdentPat &operator= (StructPatternFieldIdentPat &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdentPat *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldIdentPat (*this);\n+  }\n+};\n+\n+// Identifier only (with no pattern) single field in a struct pattern\n+class StructPatternFieldIdent : public StructPatternField\n+{\n+  bool has_ref;\n+  bool has_mut;\n+  Identifier ident;\n+\n+public:\n+  StructPatternFieldIdent (Identifier ident, bool is_ref, bool is_mut,\n+\t\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : StructPatternField (std::move (outer_attrs), locus), has_ref (is_ref),\n+      has_mut (is_mut), ident (std::move (ident))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdent *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldIdent (*this);\n+  }\n+};\n+\n+// Elements of a struct pattern\n+struct StructPatternElements\n+{\n+private:\n+  // bool has_struct_pattern_fields;\n+  std::vector<std::unique_ptr<StructPatternField> > fields;\n+\n+  bool has_struct_pattern_etc;\n+  StructPatternEtc etc;\n+\n+  // must have at least one of the two and maybe both\n+\n+  // should this store location data?\n+\n+public:\n+  // Returns whether there are any struct pattern fields\n+  bool has_struct_pattern_fields () const { return !fields.empty (); }\n+\n+  /* Returns whether the struct pattern elements is entirely empty (no fields,\n+   * no etc). */\n+  bool is_empty () const\n+  {\n+    return !has_struct_pattern_fields () && !has_struct_pattern_etc;\n+  }\n+\n+  // Constructor for StructPatternElements with both (potentially)\n+  StructPatternElements (\n+    std::vector<std::unique_ptr<StructPatternField> > fields,\n+    StructPatternEtc etc)\n+    : fields (std::move (fields)), has_struct_pattern_etc (true),\n+      etc (std::move (etc))\n+  {}\n+\n+  // Constructor for StructPatternElements with no StructPatternEtc\n+  StructPatternElements (\n+    std::vector<std::unique_ptr<StructPatternField> > fields)\n+    : fields (std::move (fields)), has_struct_pattern_etc (false),\n+      etc (StructPatternEtc::create_empty ())\n+  {}\n+\n+  // Copy constructor with vector clone\n+  StructPatternElements (StructPatternElements const &other)\n+    : has_struct_pattern_etc (other.has_struct_pattern_etc), etc (other.etc)\n+  {\n+    fields.reserve (other.fields.size ());\n+    for (const auto &e : other.fields)\n+      fields.push_back (e->clone_struct_pattern_field ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  StructPatternElements &operator= (StructPatternElements const &other)\n+  {\n+    etc = other.etc;\n+    has_struct_pattern_etc = other.has_struct_pattern_etc;\n+\n+    fields.reserve (other.fields.size ());\n+    for (const auto &e : other.fields)\n+      fields.push_back (e->clone_struct_pattern_field ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  StructPatternElements (StructPatternElements &&other) = default;\n+  StructPatternElements &operator= (StructPatternElements &&other) = default;\n+\n+  // Creates an empty StructPatternElements\n+  static StructPatternElements create_empty ()\n+  {\n+    return StructPatternElements (\n+      std::vector<std::unique_ptr<StructPatternField> > ());\n+  }\n+\n+  std::string as_string () const;\n+};\n+\n+// Struct pattern HIR node representation\n+class StructPattern : public Pattern\n+{\n+  PathInExpression path;\n+\n+  // bool has_struct_pattern_elements;\n+  StructPatternElements elems;\n+\n+  // TODO: should this store location data? Accessor uses path location data.\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructs a struct pattern from specified StructPatternElements\n+  StructPattern (PathInExpression struct_path,\n+\t\t StructPatternElements elems\n+\t\t = StructPatternElements::create_empty ())\n+    : path (std::move (struct_path)), elems (std::move (elems))\n+  {}\n+\n+  /* TODO: constructor to construct via elements included in\n+   * StructPatternElements */\n+\n+  /* Returns whether struct pattern has any struct pattern elements (if not, it\n+   * is empty). */\n+  bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPattern *clone_pattern_impl () const override\n+  {\n+    return new StructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class for patterns used in TupleStructPattern\n+class TupleStructItems\n+{\n+public:\n+  virtual ~TupleStructItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TupleStructItems> clone_tuple_struct_items () const\n+  {\n+    return std::unique_ptr<TupleStructItems> (clone_tuple_struct_items_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TupleStructItems *clone_tuple_struct_items_impl () const = 0;\n+};\n+\n+// Class for non-ranged tuple struct pattern patterns\n+class TupleStructItemsNoRange : public TupleStructItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TupleStructItemsNoRange (std::vector<std::unique_ptr<Pattern> > patterns)\n+    : patterns (std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsNoRange (TupleStructItemsNoRange const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsNoRange (TupleStructItemsNoRange &&other) = default;\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsNoRange *clone_tuple_struct_items_impl () const override\n+  {\n+    return new TupleStructItemsNoRange (*this);\n+  }\n+};\n+\n+// Class for ranged tuple struct pattern patterns\n+class TupleStructItemsRange : public TupleStructItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TupleStructItemsRange (std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+\t\t\t std::vector<std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsRange (TupleStructItemsRange const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TupleStructItemsRange &operator= (TupleStructItemsRange const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsRange (TupleStructItemsRange &&other) = default;\n+  TupleStructItemsRange &operator= (TupleStructItemsRange &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsRange *clone_tuple_struct_items_impl () const override\n+  {\n+    return new TupleStructItemsRange (*this);\n+  }\n+};\n+\n+// HIR node representing a tuple struct pattern\n+class TupleStructPattern : public Pattern\n+{\n+  PathInExpression path;\n+  std::unique_ptr<TupleStructItems> items;\n+\n+  /* TOOD: should this store location data? current accessor uses path location\n+   * data */\n+\n+public:\n+  std::string as_string () const override;\n+\n+  TupleStructPattern (PathInExpression tuple_struct_path,\n+\t\t      std::unique_ptr<TupleStructItems> items)\n+    : path (std::move (tuple_struct_path)), items (std::move (items))\n+  {}\n+\n+  // Copy constructor required to clone\n+  TupleStructPattern (TupleStructPattern const &other)\n+    : path (other.path), items (other.items->clone_tuple_struct_items ())\n+  {}\n+\n+  // Operator overload assignment operator to clone\n+  TupleStructPattern &operator= (TupleStructPattern const &other)\n+  {\n+    path = other.path;\n+    items = other.items->clone_tuple_struct_items ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructPattern (TupleStructPattern &&other) = default;\n+  TupleStructPattern &operator= (TupleStructPattern &&other) = default;\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructPattern *clone_pattern_impl () const override\n+  {\n+    return new TupleStructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class representing TuplePattern patterns\n+class TuplePatternItems\n+{\n+public:\n+  virtual ~TuplePatternItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TuplePatternItems> clone_tuple_pattern_items () const\n+  {\n+    return std::unique_ptr<TuplePatternItems> (\n+      clone_tuple_pattern_items_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TuplePatternItems *clone_tuple_pattern_items_impl () const = 0;\n+};\n+\n+// Class representing TuplePattern patterns where there is only a single pattern\n+/*class TuplePatternItemsSingle : public TuplePatternItems {\n+    // Pattern pattern;\n+    std::unique_ptr<Pattern> pattern;\n+\n+  public:\n+    TuplePatternItemsSingle(Pattern* pattern) : pattern(pattern) {}\n+\n+    // Copy constructor uses clone\n+    TuplePatternItemsSingle(TuplePatternItemsSingle const& other) :\n+      pattern(other.pattern->clone_pattern()) {}\n+\n+    // Destructor - define here if required\n+\n+    // Overload assignment operator to clone\n+    TuplePatternItemsSingle& operator=(TuplePatternItemsSingle const& other) {\n+\tpattern = other.pattern->clone_pattern();\n+\n+\treturn *this;\n+    }\n+\n+    // move constructors\n+    TuplePatternItemsSingle(TuplePatternItemsSingle&& other) = default;\n+    TuplePatternItemsSingle& operator=(TuplePatternItemsSingle&& other) =\n+default;\n+\n+  protected:\n+    // Use covariance to implement clone function as returning this object\n+rather than base virtual TuplePatternItemsSingle*\n+clone_tuple_pattern_items_impl() const override { return new\n+TuplePatternItemsSingle(*this);\n+    }\n+};*/\n+// removed in favour of single-element TuplePatternItemsMultiple\n+\n+// Class representing TuplePattern patterns where there are multiple patterns\n+class TuplePatternItemsMultiple : public TuplePatternItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TuplePatternItemsMultiple (std::vector<std::unique_ptr<Pattern> > patterns)\n+    : patterns (std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple &&other) = default;\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsMultiple *clone_tuple_pattern_items_impl () const override\n+  {\n+    return new TuplePatternItemsMultiple (*this);\n+  }\n+};\n+\n+// Class representing TuplePattern patterns where there are a range of patterns\n+class TuplePatternItemsRanged : public TuplePatternItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TuplePatternItemsRanged (\n+    std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+    std::vector<std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsRanged (TuplePatternItemsRanged const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsRanged (TuplePatternItemsRanged &&other) = default;\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsRanged *clone_tuple_pattern_items_impl () const override\n+  {\n+    return new TuplePatternItemsRanged (*this);\n+  }\n+};\n+\n+// HIR node representing a tuple pattern\n+class TuplePattern : public Pattern\n+{\n+  // bool has_tuple_pattern_items;\n+  std::unique_ptr<TuplePatternItems> items;\n+\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Returns true if the tuple pattern has items\n+  bool has_tuple_pattern_items () const { return items != nullptr; }\n+\n+  TuplePattern (std::unique_ptr<TuplePatternItems> items, Location locus)\n+    : items (std::move (items)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires clone\n+  TuplePattern (TuplePattern const &other)\n+    : items (other.items->clone_tuple_pattern_items ()), locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  TuplePattern &operator= (TuplePattern const &other)\n+  {\n+    items = other.items->clone_tuple_pattern_items ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePattern *clone_pattern_impl () const override\n+  {\n+    return new TuplePattern (*this);\n+  }\n+};\n+\n+// HIR node representing a pattern in parentheses, used to control precedence\n+class GroupedPattern : public Pattern\n+{\n+  std::unique_ptr<Pattern> pattern_in_parens;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override\n+  {\n+    return \"(\" + pattern_in_parens->as_string () + \")\";\n+  }\n+\n+  GroupedPattern (std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n+    : pattern_in_parens (std::move (pattern_in_parens)), locus (locus)\n+  {}\n+\n+  // Copy constructor uses clone\n+  GroupedPattern (GroupedPattern const &other)\n+    : pattern_in_parens (other.pattern_in_parens->clone_pattern ()),\n+      locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  GroupedPattern &operator= (GroupedPattern const &other)\n+  {\n+    pattern_in_parens = other.pattern_in_parens->clone_pattern ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  GroupedPattern (GroupedPattern &&other) = default;\n+  GroupedPattern &operator= (GroupedPattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  GroupedPattern *clone_pattern_impl () const override\n+  {\n+    return new GroupedPattern (*this);\n+  }\n+};\n+\n+// HIR node representing patterns that can match slices and arrays\n+class SlicePattern : public Pattern\n+{\n+  std::vector<std::unique_ptr<Pattern> > items;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  SlicePattern (std::vector<std::unique_ptr<Pattern> > items, Location locus)\n+    : items (std::move (items)), locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  SlicePattern (SlicePattern const &other) : locus (other.locus)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  SlicePattern &operator= (SlicePattern const &other)\n+  {\n+    locus = other.locus;\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SlicePattern (SlicePattern &&other) = default;\n+  SlicePattern &operator= (SlicePattern &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SlicePattern *clone_pattern_impl () const override\n+  {\n+    return new SlicePattern (*this);\n+  }\n+};\n+\n+// Moved definition to rust-path.h\n+class PathPattern;\n+\n+// Forward decls for paths (defined in rust-path.h)\n+class PathInExpression;\n+class QualifiedPathInExpression;\n+\n+// Replaced with forward decl - defined in rust-macro.h\n+class MacroInvocation;\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "c799b5e5fa53c18f82a5e4e702169608d3d1404a", "filename": "gcc/rust/hir/tree/rust-hir-stmt.h", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-stmt.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,240 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_STATEMENT_H\n+#define RUST_HIR_STATEMENT_H\n+\n+#include \"rust-hir.h\"\n+#include \"rust-hir-path.h\"\n+#include \"rust-hir-expr.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// Just a semi-colon, which apparently is a statement.\n+class EmptyStmt : public Stmt\n+{\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override { return std::string (1, ';'); }\n+\n+  EmptyStmt (Analysis::NodeMapping mappings, Location locus)\n+    : Stmt (std::move (mappings)), locus (locus)\n+  {}\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  EmptyStmt *clone_stmt_impl () const override { return new EmptyStmt (*this); }\n+};\n+\n+/* Variable assignment let statement - type of \"declaration statement\" as it\n+ * introduces new name into scope */\n+class LetStmt : public Stmt\n+{\n+  // bool has_outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n+\n+  std::unique_ptr<Pattern> variables_pattern;\n+\n+  // bool has_type;\n+  std::unique_ptr<Type> type;\n+\n+  // bool has_init_expr;\n+  std::unique_ptr<Expr> init_expr;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether let statement has outer attributes.\n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n+  // Returns whether let statement has a given return type.\n+  bool has_type () const { return type != nullptr; }\n+\n+  // Returns whether let statement has an initialisation expression.\n+  bool has_init_expr () const { return init_expr != nullptr; }\n+\n+  std::string as_string () const override;\n+\n+  LetStmt (Analysis::NodeMapping mappings,\n+\t   std::unique_ptr<Pattern> variables_pattern,\n+\t   std::unique_ptr<Expr> init_expr, std::unique_ptr<Type> type,\n+\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : Stmt (std::move (mappings)), outer_attrs (std::move (outer_attrs)),\n+      variables_pattern (std::move (variables_pattern)),\n+      type (std::move (type)), init_expr (std::move (init_expr)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  LetStmt (LetStmt const &other)\n+    : Stmt (other.mappings), outer_attrs (other.outer_attrs),\n+      variables_pattern (other.variables_pattern->clone_pattern ()),\n+      type (other.type->clone_type ()),\n+      init_expr (other.init_expr->clone_expr ()), locus (other.locus)\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  LetStmt &operator= (LetStmt const &other)\n+  {\n+    variables_pattern = other.variables_pattern->clone_pattern ();\n+    init_expr = other.init_expr->clone_expr ();\n+    type = other.type->clone_type ();\n+    outer_attrs = other.outer_attrs;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  LetStmt (LetStmt &&other) = default;\n+  LetStmt &operator= (LetStmt &&other) = default;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  HIR::Type *get_type () { return type.get (); }\n+\n+  HIR::Expr *get_init_expr () { return init_expr.get (); }\n+\n+  HIR::Pattern *get_pattern () { return variables_pattern.get (); }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LetStmt *clone_stmt_impl () const override { return new LetStmt (*this); }\n+};\n+\n+/* Abstract base class for expression statements (statements containing an\n+ * expression) */\n+class ExprStmt : public Stmt\n+{\n+  // TODO: add any useful virtual functions\n+\n+  Location locus;\n+\n+public:\n+  Location get_locus () const { return locus; }\n+\n+protected:\n+  ExprStmt (Analysis::NodeMapping mappings, Location locus)\n+    : Stmt (std::move (mappings)), locus (locus)\n+  {}\n+};\n+\n+/* Statement containing an expression without a block (or, due to technical\n+ * difficulties, can only be guaranteed to hold an expression). */\n+class ExprStmtWithoutBlock : public ExprStmt\n+{\n+  std::unique_ptr<Expr> expr;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ExprStmtWithoutBlock (Analysis::NodeMapping mappings,\n+\t\t\tstd::unique_ptr<Expr> expr, Location locus)\n+    : ExprStmt (std::move (mappings), locus), expr (std::move (expr))\n+  {}\n+\n+  // Copy constructor with clone\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+    expr = other.expr->clone_expr ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock &&other) = default;\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Expr *get_expr () { return expr.get (); }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithoutBlock *clone_stmt_impl () const override\n+  {\n+    return new ExprStmtWithoutBlock (*this);\n+  }\n+};\n+\n+// Statement containing an expression with a block\n+class ExprStmtWithBlock : public ExprStmt\n+{\n+public:\n+  std::unique_ptr<ExprWithBlock> expr;\n+\n+  std::string as_string () const override;\n+\n+  std::vector<LetStmt *> locals;\n+\n+  ExprStmtWithBlock (Analysis::NodeMapping mappings,\n+\t\t     std::unique_ptr<ExprWithBlock> expr, Location locus)\n+    : ExprStmt (std::move (mappings), locus), expr (std::move (expr))\n+  {}\n+\n+  // Copy constructor with clone\n+  ExprStmtWithBlock (ExprStmtWithBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr_with_block ())\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+    expr = other.expr->clone_expr_with_block ();\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithBlock (ExprStmtWithBlock &&other) = default;\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithBlock *clone_stmt_impl () const override\n+  {\n+    return new ExprStmtWithBlock (*this);\n+  }\n+};\n+\n+/* Replaced definition of MacroInvocationSemi with forward decl - defined in\n+ * rust-macro.h */\n+class MacroInvocationSemi;\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "f8c851c811e5eba9cdd426c454434337cec8220f", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "added", "additions": 895, "deletions": 0, "changes": 895, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,895 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_H\n+#define RUST_HIR_TYPE_H\n+\n+#include \"rust-hir.h\"\n+#include \"rust-hir-path.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+// definitions moved to rust-ast.h\n+class TypeParamBound;\n+class Lifetime;\n+\n+// A trait bound\n+class TraitBound : public TypeParamBound\n+{\n+  bool in_parens;\n+  bool opening_question_mark;\n+\n+  // bool has_for_lifetimes;\n+  // LifetimeParams for_lifetimes;\n+  std::vector<LifetimeParam> for_lifetimes; // inlined LifetimeParams\n+\n+  TypePath type_path;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether trait bound has \"for\" lifetimes\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  TraitBound (TypePath type_path, Location locus, bool in_parens = false,\n+\t      bool opening_question_mark = false,\n+\t      std::vector<LifetimeParam> for_lifetimes\n+\t      = std::vector<LifetimeParam> ())\n+    : in_parens (in_parens), opening_question_mark (opening_question_mark),\n+      for_lifetimes (std::move (for_lifetimes)),\n+      type_path (std::move (type_path)), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitBound *clone_type_param_bound_impl () const override\n+  {\n+    return new TraitBound (*this);\n+  }\n+};\n+\n+// definition moved to rust-ast.h\n+class TypeNoBounds;\n+\n+// An impl trait? Poor reference material here.\n+class ImplTraitType : public Type\n+{\n+  // TypeParamBounds type_param_bounds;\n+  // inlined form\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n+\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitType *clone_type_impl () const override\n+  {\n+    return new ImplTraitType (*this);\n+  }\n+\n+public:\n+  ImplTraitType (\n+    Analysis::NodeMapping mappings,\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    Location locus)\n+    : Type (mappings), type_param_bounds (std::move (type_param_bounds)),\n+      locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  ImplTraitType (ImplTraitType const &other)\n+    : Type (other.mappings), locus (other.locus)\n+  {\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  ImplTraitType &operator= (ImplTraitType const &other)\n+  {\n+    locus = other.locus;\n+    mappings = other.mappings;\n+\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ImplTraitType (ImplTraitType &&other) = default;\n+  ImplTraitType &operator= (ImplTraitType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+// An opaque value of another type that implements a set of traits\n+class TraitObjectType : public Type\n+{\n+  bool has_dyn;\n+  // TypeParamBounds type_param_bounds;\n+  std::vector<std::unique_ptr<TypeParamBound> >\n+    type_param_bounds; // inlined form\n+\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectType *clone_type_impl () const override\n+  {\n+    return new TraitObjectType (*this);\n+  }\n+\n+public:\n+  TraitObjectType (\n+    Analysis::NodeMapping mappings,\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    Location locus, bool is_dyn_dispatch = false)\n+    : Type (mappings), has_dyn (is_dyn_dispatch),\n+      type_param_bounds (std::move (type_param_bounds)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  TraitObjectType (TraitObjectType const &other)\n+    : Type (other.mappings), has_dyn (other.has_dyn), locus (other.locus)\n+  {\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TraitObjectType &operator= (TraitObjectType const &other)\n+  {\n+    mappings = other.mappings;\n+    has_dyn = other.has_dyn;\n+    locus = other.locus;\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TraitObjectType (TraitObjectType &&other) = default;\n+  TraitObjectType &operator= (TraitObjectType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+// A type with parentheses around it, used to avoid ambiguity.\n+class ParenthesisedType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> type_in_parens;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ParenthesisedType *clone_type_impl () const override\n+  {\n+    return new ParenthesisedType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ParenthesisedType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ParenthesisedType (*this);\n+  }\n+\n+public:\n+  // Constructor uses Type pointer for polymorphism\n+  ParenthesisedType (Analysis::NodeMapping mappings,\n+\t\t     std::unique_ptr<Type> type_inside_parens, Location locus)\n+    : TypeNoBounds (mappings), type_in_parens (std::move (type_inside_parens)),\n+      locus (locus)\n+  {}\n+\n+  /* Copy constructor uses custom deep copy method for type to preserve\n+   * polymorphism */\n+  ParenthesisedType (ParenthesisedType const &other)\n+    : TypeNoBounds (other.mappings),\n+      type_in_parens (other.type_in_parens->clone_type ()), locus (other.locus)\n+  {}\n+\n+  // overload assignment operator to use custom clone method\n+  ParenthesisedType &operator= (ParenthesisedType const &other)\n+  {\n+    mappings = other.mappings;\n+    type_in_parens = other.type_in_parens->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ParenthesisedType (ParenthesisedType &&other) = default;\n+  ParenthesisedType &operator= (ParenthesisedType &&other) = default;\n+\n+  std::string as_string () const override\n+  {\n+    return \"(\" + type_in_parens->as_string () + \")\";\n+  }\n+\n+  // Creates a trait bound (clone of this one's trait bound) - HACK\n+  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n+  {\n+    /* NOTE: obviously it is unknown whether the internal type is a trait bound\n+     * due to polymorphism, so just let the internal type handle it. As\n+     * parenthesised type, it must be in parentheses. */\n+    return type_in_parens->to_trait_bound (true);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+// Impl trait with a single bound? Poor reference material here.\n+class ImplTraitTypeOneBound : public TypeNoBounds\n+{\n+  TraitBound trait_bound;\n+\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitTypeOneBound *clone_type_impl () const override\n+  {\n+    return new ImplTraitTypeOneBound (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitTypeOneBound *clone_type_no_bounds_impl () const override\n+  {\n+    return new ImplTraitTypeOneBound (*this);\n+  }\n+\n+public:\n+  ImplTraitTypeOneBound (Analysis::NodeMapping mappings, TraitBound trait_bound,\n+\t\t\t Location locus)\n+    : TypeNoBounds (mappings), trait_bound (std::move (trait_bound)),\n+      locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+/* A trait object with a single trait bound. The \"trait bound\" is really just\n+ * the trait. Basically like using an interface as a type in an OOP language. */\n+class TraitObjectTypeOneBound : public TypeNoBounds\n+{\n+  bool has_dyn;\n+  TraitBound trait_bound;\n+\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectTypeOneBound *clone_type_impl () const override\n+  {\n+    return new TraitObjectTypeOneBound (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectTypeOneBound *clone_type_no_bounds_impl () const override\n+  {\n+    return new TraitObjectTypeOneBound (*this);\n+  }\n+\n+public:\n+  TraitObjectTypeOneBound (Analysis::NodeMapping mappings,\n+\t\t\t   TraitBound trait_bound, Location locus,\n+\t\t\t   bool is_dyn_dispatch = false)\n+    : TypeNoBounds (mappings), has_dyn (is_dyn_dispatch),\n+      trait_bound (std::move (trait_bound)), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  // Creates a trait bound (clone of this one's trait bound) - HACK\n+  TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const override\n+  {\n+    /* NOTE: this assumes there is no dynamic dispatch specified- if there was,\n+     * this cloning would not be required as parsing is unambiguous. */\n+    return new HIR::TraitBound (trait_bound);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+class TypePath; // definition moved to \"rust-path.h\"\n+\n+/* A type consisting of the \"product\" of others (the tuple's elements) in a\n+ * specific order */\n+class TupleType : public TypeNoBounds\n+{\n+  std::vector<std::unique_ptr<Type> > elems;\n+  Location locus;\n+\n+public:\n+  // Returns whether the tuple type is the unit type, i.e. has no elements.\n+  bool is_unit_type () const { return elems.empty (); }\n+\n+  TupleType (Analysis::NodeMapping mappings,\n+\t     std::vector<std::unique_ptr<Type> > elems, Location locus)\n+    : TypeNoBounds (mappings), elems (std::move (elems)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  TupleType (TupleType const &other)\n+    : TypeNoBounds (other.mappings), locus (other.locus)\n+  {\n+    mappings = other.mappings;\n+    elems.reserve (other.elems.size ());\n+    for (const auto &e : other.elems)\n+      elems.push_back (e->clone_type ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TupleType &operator= (TupleType const &other)\n+  {\n+    locus = other.locus;\n+\n+    elems.reserve (other.elems.size ());\n+    for (const auto &e : other.elems)\n+      elems.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleType (TupleType &&other) = default;\n+  TupleType &operator= (TupleType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleType *clone_type_impl () const override { return new TupleType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleType *clone_type_no_bounds_impl () const override\n+  {\n+    return new TupleType (*this);\n+  }\n+};\n+\n+/* A type with no values, representing the result of computations that never\n+ * complete. Expressions of NeverType can be coerced into any other types.\n+ * Represented as \"!\". */\n+class NeverType : public TypeNoBounds\n+{\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  NeverType *clone_type_impl () const override { return new NeverType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  NeverType *clone_type_no_bounds_impl () const override\n+  {\n+    return new NeverType (*this);\n+  }\n+\n+public:\n+  NeverType (Analysis::NodeMapping mappings, Location locus)\n+    : TypeNoBounds (mappings), locus (locus)\n+  {}\n+\n+  std::string as_string () const override { return \"! (never type)\"; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+// A type consisting of a pointer without safety or liveness guarantees\n+class RawPointerType : public TypeNoBounds\n+{\n+public:\n+  enum PointerType\n+  {\n+    MUT,\n+    CONST\n+  };\n+\n+private:\n+  PointerType pointer_type;\n+  std::unique_ptr<TypeNoBounds> type;\n+  Location locus;\n+\n+public:\n+  // Returns whether the pointer is mutable or constant.\n+  PointerType get_pointer_type () const { return pointer_type; }\n+\n+  // Constructor requires pointer for polymorphism reasons\n+  RawPointerType (Analysis::NodeMapping mappings, PointerType pointer_type,\n+\t\t  std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus)\n+    : TypeNoBounds (mappings), pointer_type (pointer_type),\n+      type (std::move (type_no_bounds)), locus (locus)\n+  {}\n+\n+  // Copy constructor calls custom polymorphic clone function\n+  RawPointerType (RawPointerType const &other)\n+    : TypeNoBounds (other.mappings), pointer_type (other.pointer_type),\n+      type (other.type->clone_type_no_bounds ()), locus (other.locus)\n+  {}\n+\n+  // overload assignment operator to use custom clone method\n+  RawPointerType &operator= (RawPointerType const &other)\n+  {\n+    mappings = other.mappings;\n+    pointer_type = other.pointer_type;\n+    type = other.type->clone_type_no_bounds ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RawPointerType (RawPointerType &&other) = default;\n+  RawPointerType &operator= (RawPointerType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RawPointerType *clone_type_impl () const override\n+  {\n+    return new RawPointerType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RawPointerType *clone_type_no_bounds_impl () const override\n+  {\n+    return new RawPointerType (*this);\n+  }\n+};\n+\n+// A type pointing to memory owned by another value\n+class ReferenceType : public TypeNoBounds\n+{\n+  // bool has_lifetime; // TODO: handle in lifetime or something?\n+  Lifetime lifetime;\n+\n+  bool has_mut;\n+  std::unique_ptr<TypeNoBounds> type;\n+  Location locus;\n+\n+public:\n+  // Returns whether the reference is mutable or immutable.\n+  bool is_mut () const { return has_mut; }\n+\n+  // Returns whether the reference has a lifetime.\n+  bool has_lifetime () const { return !lifetime.is_error (); }\n+\n+  // Constructor\n+  ReferenceType (Analysis::NodeMapping mappings, bool is_mut,\n+\t\t std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus,\n+\t\t Lifetime lifetime = Lifetime::error ())\n+    : TypeNoBounds (mappings), lifetime (std::move (lifetime)),\n+      has_mut (is_mut), type (std::move (type_no_bounds)), locus (locus)\n+  {}\n+\n+  // Copy constructor with custom clone method\n+  ReferenceType (ReferenceType const &other)\n+    : TypeNoBounds (other.mappings), lifetime (other.lifetime),\n+      has_mut (other.has_mut), type (other.type->clone_type_no_bounds ()),\n+      locus (other.locus)\n+  {}\n+\n+  // Operator overload assignment operator to custom clone the unique pointer\n+  ReferenceType &operator= (ReferenceType const &other)\n+  {\n+    mappings = other.mappings;\n+    lifetime = other.lifetime;\n+    has_mut = other.has_mut;\n+    type = other.type->clone_type_no_bounds ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ReferenceType (ReferenceType &&other) = default;\n+  ReferenceType &operator= (ReferenceType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferenceType *clone_type_impl () const override\n+  {\n+    return new ReferenceType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferenceType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ReferenceType (*this);\n+  }\n+};\n+\n+// A fixed-size sequence of elements of a specified type\n+class ArrayType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> elem_type;\n+  std::unique_ptr<Expr> size;\n+  Location locus;\n+\n+public:\n+  // Constructor requires pointers for polymorphism\n+  ArrayType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t     std::unique_ptr<Expr> array_size, Location locus)\n+    : TypeNoBounds (mappings), elem_type (std::move (type)),\n+      size (std::move (array_size)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires deep copies of both unique pointers\n+  ArrayType (ArrayType const &other)\n+    : TypeNoBounds (mappings), elem_type (other.elem_type->clone_type ()),\n+      size (other.size->clone_expr ()), locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to deep copy pointers\n+  ArrayType &operator= (ArrayType const &other)\n+  {\n+    mappings = other.mappings;\n+    elem_type = other.elem_type->clone_type ();\n+    size = other.size->clone_expr ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ArrayType (ArrayType &&other) = default;\n+  ArrayType &operator= (ArrayType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  Type *get_element_type () { return elem_type.get (); }\n+\n+  Expr *get_size_expr () { return size.get (); }\n+\n+  Location &get_locus () { return locus; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ArrayType *clone_type_impl () const override { return new ArrayType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ArrayType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ArrayType (*this);\n+  }\n+};\n+\n+/* A dynamically-sized type representing a \"view\" into a sequence of elements of\n+ * a type */\n+class SliceType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> elem_type;\n+  Location locus;\n+\n+public:\n+  // Constructor requires pointer for polymorphism\n+  SliceType (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t     Location locus)\n+    : TypeNoBounds (mappings), elem_type (std::move (type)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires deep copy of Type smart pointer\n+  SliceType (SliceType const &other)\n+    : TypeNoBounds (other.mappings), elem_type (other.elem_type->clone_type ()),\n+      locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to deep copy\n+  SliceType &operator= (SliceType const &other)\n+  {\n+    mappings = other.mappings;\n+    elem_type = other.elem_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SliceType (SliceType &&other) = default;\n+  SliceType &operator= (SliceType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SliceType *clone_type_impl () const override { return new SliceType (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SliceType *clone_type_no_bounds_impl () const override\n+  {\n+    return new SliceType (*this);\n+  }\n+};\n+\n+/* Type used in generic arguments to explicitly request type inference (wildcard\n+ * pattern) */\n+class InferredType : public TypeNoBounds\n+{\n+  Location locus;\n+\n+  // e.g. Vec<_> = whatever\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  InferredType *clone_type_impl () const override\n+  {\n+    return new InferredType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  InferredType *clone_type_no_bounds_impl () const override\n+  {\n+    return new InferredType (*this);\n+  }\n+\n+public:\n+  InferredType (Analysis::NodeMapping mappings, Location locus)\n+    : TypeNoBounds (mappings), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+};\n+\n+class QualifiedPathInType; // definition moved to \"rust-path.h\"\n+\n+// A possibly named param used in a BaseFunctionType\n+struct MaybeNamedParam\n+{\n+public:\n+  enum ParamKind\n+  {\n+    UNNAMED,\n+    IDENTIFIER,\n+    WILDCARD\n+  };\n+\n+private:\n+  std::unique_ptr<Type> param_type;\n+\n+  ParamKind param_kind;\n+  Identifier name; // technically, can be an identifier or '_'\n+\n+  Location locus;\n+\n+public:\n+  MaybeNamedParam (Identifier name, ParamKind param_kind,\n+\t\t   std::unique_ptr<Type> param_type, Location locus)\n+    : param_type (std::move (param_type)), param_kind (param_kind),\n+      name (std::move (name)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  MaybeNamedParam (MaybeNamedParam const &other)\n+    : param_type (other.param_type->clone_type ()),\n+      param_kind (other.param_kind), name (other.name), locus (other.locus)\n+  {}\n+\n+  ~MaybeNamedParam () = default;\n+\n+  // Overloaded assignment operator with clone\n+  MaybeNamedParam &operator= (MaybeNamedParam const &other)\n+  {\n+    name = other.name;\n+    param_kind = other.param_kind;\n+    param_type = other.param_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MaybeNamedParam (MaybeNamedParam &&other) = default;\n+  MaybeNamedParam &operator= (MaybeNamedParam &&other) = default;\n+\n+  std::string as_string () const;\n+\n+  // Returns whether the param is in an error state.\n+  bool is_error () const { return param_type == nullptr; }\n+\n+  // Creates an error state param.\n+  static MaybeNamedParam create_error ()\n+  {\n+    return MaybeNamedParam (\"\", UNNAMED, nullptr, Location ());\n+  }\n+\n+  Location get_locus () const { return locus; }\n+};\n+\n+/* A function pointer type - can be created via coercion from function items and\n+ * non- capturing closures. */\n+class BareFunctionType : public TypeNoBounds\n+{\n+  // bool has_for_lifetimes;\n+  // ForLifetimes for_lifetimes;\n+  std::vector<LifetimeParam> for_lifetimes; // inlined version\n+\n+  FunctionQualifiers function_qualifiers;\n+  std::vector<MaybeNamedParam> params;\n+  bool is_variadic;\n+\n+  // bool has_return_type;\n+  // BareFunctionReturnType return_type;\n+  std::unique_ptr<TypeNoBounds> return_type; // inlined version\n+\n+  Location locus;\n+\n+public:\n+  // Whether a return type is defined with the function.\n+  bool has_return_type () const { return return_type != nullptr; }\n+\n+  // Whether the function has ForLifetimes.\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  BareFunctionType (Analysis::NodeMapping mappings,\n+\t\t    std::vector<LifetimeParam> lifetime_params,\n+\t\t    FunctionQualifiers qualifiers,\n+\t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n+\t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n+    : TypeNoBounds (mappings), for_lifetimes (std::move (lifetime_params)),\n+      function_qualifiers (std::move (qualifiers)),\n+      params (std::move (named_params)), is_variadic (is_variadic),\n+      return_type (std::move (type)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  BareFunctionType (BareFunctionType const &other)\n+    : TypeNoBounds (other.mappings), for_lifetimes (other.for_lifetimes),\n+      function_qualifiers (other.function_qualifiers), params (other.params),\n+      is_variadic (other.is_variadic),\n+      return_type (other.return_type->clone_type_no_bounds ()),\n+      locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to deep copy\n+  BareFunctionType &operator= (BareFunctionType const &other)\n+  {\n+    mappings = other.mappings;\n+    for_lifetimes = other.for_lifetimes;\n+    function_qualifiers = other.function_qualifiers;\n+    params = other.params;\n+    is_variadic = other.is_variadic;\n+    return_type = other.return_type->clone_type_no_bounds ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  BareFunctionType (BareFunctionType &&other) = default;\n+  BareFunctionType &operator= (BareFunctionType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  BareFunctionType *clone_type_impl () const override\n+  {\n+    return new BareFunctionType (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  BareFunctionType *clone_type_no_bounds_impl () const override\n+  {\n+    return new BareFunctionType (*this);\n+  }\n+};\n+\n+// Forward decl - defined in rust-macro.h\n+class MacroInvocation;\n+\n+/* TODO: possible types\n+ * struct type?\n+ * \"enum\" (tagged union) type?\n+ * C-like union type?\n+ * function item type?\n+ * closure expression types?\n+ * primitive types (bool, int, float, char, str (the slice))\n+ * Although supposedly TypePaths are used to reference these types (including\n+ * primitives) */\n+\n+/* FIXME: Incomplete spec references:\n+ *  anonymous type parameters, aka \"impl Trait in argument position\" - impl then\n+ * trait bounds abstract return types, aka \"impl Trait in return position\" -\n+ * impl then trait bounds */\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "abb84f595bcb21573468201187023c132ad388e6", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,244 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_VISITOR_H\n+#define RUST_HIR_VISITOR_H\n+// Visitor base for HIR\n+\n+// full include not required - only forward decls\n+#include \"rust-hir-full-decls.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+/* Pure abstract class that provides an interface for accessing different\n+ * classes of the HIR. */\n+class HIRVisitor\n+{\n+public:\n+  // only concrete class overloads are required\n+\n+  // rust-ast.h\n+  // virtual void visit(AttrInput& attr_input) = 0;\n+  // virtual void visit(TokenTree& token_tree) = 0;\n+  // virtual void visit(MacroMatch& macro_match) = 0;\n+  virtual void visit (Token &tok) = 0;\n+  virtual void visit (DelimTokenTree &delim_tok_tree) = 0;\n+  virtual void visit (AttrInputMetaItemContainer &input) = 0;\n+  // virtual void visit(MetaItem& meta_item) = 0;\n+  // virtual void visit(Stmt& stmt) = 0;\n+  // virtual void visit(Expr& expr) = 0;\n+  virtual void visit (IdentifierExpr &ident_expr) = 0;\n+  // virtual void visit(Pattern& pattern) = 0;\n+  // virtual void visit(Type& type) = 0;\n+  // virtual void visit(TypeParamBound& type_param_bound) = 0;\n+  virtual void visit (Lifetime &lifetime) = 0;\n+  // virtual void visit(GenericParam& generic_param) = 0;\n+  virtual void visit (LifetimeParam &lifetime_param) = 0;\n+  // virtual void visit(TraitItem& trait_item) = 0;\n+  // virtual void visit(InherentImplItem& inherent_impl_item) = 0;\n+  // virtual void visit(TraitImplItem& trait_impl_item) = 0;\n+  virtual void visit (MacroInvocationSemi &macro) = 0;\n+\n+  // rust-path.h\n+  virtual void visit (PathInExpression &path) = 0;\n+  virtual void visit (TypePathSegment &segment) = 0;\n+  virtual void visit (TypePathSegmentGeneric &segment) = 0;\n+  virtual void visit (TypePathSegmentFunction &segment) = 0;\n+  virtual void visit (TypePath &path) = 0;\n+  virtual void visit (QualifiedPathInExpression &path) = 0;\n+  virtual void visit (QualifiedPathInType &path) = 0;\n+\n+  // rust-expr.h\n+  virtual void visit (LiteralExpr &expr) = 0;\n+  virtual void visit (AttrInputLiteral &attr_input) = 0;\n+  virtual void visit (MetaItemLitExpr &meta_item) = 0;\n+  virtual void visit (MetaItemPathLit &meta_item) = 0;\n+  virtual void visit (BorrowExpr &expr) = 0;\n+  virtual void visit (DereferenceExpr &expr) = 0;\n+  virtual void visit (ErrorPropagationExpr &expr) = 0;\n+  virtual void visit (NegationExpr &expr) = 0;\n+  virtual void visit (ArithmeticOrLogicalExpr &expr) = 0;\n+  virtual void visit (ComparisonExpr &expr) = 0;\n+  virtual void visit (LazyBooleanExpr &expr) = 0;\n+  virtual void visit (TypeCastExpr &expr) = 0;\n+  virtual void visit (AssignmentExpr &expr) = 0;\n+  virtual void visit (CompoundAssignmentExpr &expr) = 0;\n+  virtual void visit (GroupedExpr &expr) = 0;\n+  // virtual void visit(ArrayElems& elems) = 0;\n+  virtual void visit (ArrayElemsValues &elems) = 0;\n+  virtual void visit (ArrayElemsCopied &elems) = 0;\n+  virtual void visit (ArrayExpr &expr) = 0;\n+  virtual void visit (ArrayIndexExpr &expr) = 0;\n+  virtual void visit (TupleExpr &expr) = 0;\n+  virtual void visit (TupleIndexExpr &expr) = 0;\n+  virtual void visit (StructExprStruct &expr) = 0;\n+  // virtual void visit(StructExprField& field) = 0;\n+  virtual void visit (StructExprFieldIdentifier &field) = 0;\n+  virtual void visit (StructExprFieldIdentifierValue &field) = 0;\n+  virtual void visit (StructExprFieldIndexValue &field) = 0;\n+  virtual void visit (StructExprStructFields &expr) = 0;\n+  virtual void visit (StructExprStructBase &expr) = 0;\n+  virtual void visit (StructExprTuple &expr) = 0;\n+  virtual void visit (StructExprUnit &expr) = 0;\n+  // virtual void visit(EnumExprField& field) = 0;\n+  virtual void visit (EnumExprFieldIdentifier &field) = 0;\n+  virtual void visit (EnumExprFieldIdentifierValue &field) = 0;\n+  virtual void visit (EnumExprFieldIndexValue &field) = 0;\n+  virtual void visit (EnumExprStruct &expr) = 0;\n+  virtual void visit (EnumExprTuple &expr) = 0;\n+  virtual void visit (EnumExprFieldless &expr) = 0;\n+  virtual void visit (CallExpr &expr) = 0;\n+  virtual void visit (MethodCallExpr &expr) = 0;\n+  virtual void visit (FieldAccessExpr &expr) = 0;\n+  virtual void visit (ClosureExprInner &expr) = 0;\n+  virtual void visit (BlockExpr &expr) = 0;\n+  virtual void visit (ClosureExprInnerTyped &expr) = 0;\n+  virtual void visit (ContinueExpr &expr) = 0;\n+  virtual void visit (BreakExpr &expr) = 0;\n+  virtual void visit (RangeFromToExpr &expr) = 0;\n+  virtual void visit (RangeFromExpr &expr) = 0;\n+  virtual void visit (RangeToExpr &expr) = 0;\n+  virtual void visit (RangeFullExpr &expr) = 0;\n+  virtual void visit (RangeFromToInclExpr &expr) = 0;\n+  virtual void visit (RangeToInclExpr &expr) = 0;\n+  virtual void visit (ReturnExpr &expr) = 0;\n+  virtual void visit (UnsafeBlockExpr &expr) = 0;\n+  virtual void visit (LoopExpr &expr) = 0;\n+  virtual void visit (WhileLoopExpr &expr) = 0;\n+  virtual void visit (WhileLetLoopExpr &expr) = 0;\n+  virtual void visit (ForLoopExpr &expr) = 0;\n+  virtual void visit (IfExpr &expr) = 0;\n+  virtual void visit (IfExprConseqElse &expr) = 0;\n+  virtual void visit (IfExprConseqIf &expr) = 0;\n+  virtual void visit (IfExprConseqIfLet &expr) = 0;\n+  virtual void visit (IfLetExpr &expr) = 0;\n+  virtual void visit (IfLetExprConseqElse &expr) = 0;\n+  virtual void visit (IfLetExprConseqIf &expr) = 0;\n+  virtual void visit (IfLetExprConseqIfLet &expr) = 0;\n+  // virtual void visit(MatchCase& match_case) = 0;\n+  // virtual void visit (MatchCaseBlockExpr &match_case) = 0;\n+  // virtual void visit (MatchCaseExpr &match_case) = 0;\n+  virtual void visit (MatchExpr &expr) = 0;\n+  virtual void visit (AwaitExpr &expr) = 0;\n+  virtual void visit (AsyncBlockExpr &expr) = 0;\n+\n+  // rust-item.h\n+  virtual void visit (TypeParam &param) = 0;\n+  // virtual void visit(WhereClauseItem& item) = 0;\n+  virtual void visit (LifetimeWhereClauseItem &item) = 0;\n+  virtual void visit (TypeBoundWhereClauseItem &item) = 0;\n+  virtual void visit (Method &method) = 0;\n+  virtual void visit (ModuleBodied &module) = 0;\n+  virtual void visit (ModuleNoBody &module) = 0;\n+  virtual void visit (ExternCrate &crate) = 0;\n+  // virtual void visit(UseTree& use_tree) = 0;\n+  virtual void visit (UseTreeGlob &use_tree) = 0;\n+  virtual void visit (UseTreeList &use_tree) = 0;\n+  virtual void visit (UseTreeRebind &use_tree) = 0;\n+  virtual void visit (UseDeclaration &use_decl) = 0;\n+  virtual void visit (Function &function) = 0;\n+  virtual void visit (TypeAlias &type_alias) = 0;\n+  virtual void visit (StructStruct &struct_item) = 0;\n+  virtual void visit (TupleStruct &tuple_struct) = 0;\n+  virtual void visit (EnumItem &item) = 0;\n+  virtual void visit (EnumItemTuple &item) = 0;\n+  virtual void visit (EnumItemStruct &item) = 0;\n+  virtual void visit (EnumItemDiscriminant &item) = 0;\n+  virtual void visit (Enum &enum_item) = 0;\n+  virtual void visit (Union &union_item) = 0;\n+  virtual void visit (ConstantItem &const_item) = 0;\n+  virtual void visit (StaticItem &static_item) = 0;\n+  virtual void visit (TraitItemFunc &item) = 0;\n+  virtual void visit (TraitItemMethod &item) = 0;\n+  virtual void visit (TraitItemConst &item) = 0;\n+  virtual void visit (TraitItemType &item) = 0;\n+  virtual void visit (Trait &trait) = 0;\n+  virtual void visit (InherentImpl &impl) = 0;\n+  virtual void visit (TraitImpl &impl) = 0;\n+  // virtual void visit(ExternalItem& item) = 0;\n+  virtual void visit (ExternalStaticItem &item) = 0;\n+  virtual void visit (ExternalFunctionItem &item) = 0;\n+  virtual void visit (ExternBlock &block) = 0;\n+\n+  // rust-macro.h\n+  virtual void visit (MacroMatchFragment &match) = 0;\n+  virtual void visit (MacroMatchRepetition &match) = 0;\n+  virtual void visit (MacroMatcher &matcher) = 0;\n+  virtual void visit (MacroRulesDefinition &rules_def) = 0;\n+  virtual void visit (MacroInvocation &macro_invoc) = 0;\n+  virtual void visit (MetaItemPath &meta_item) = 0;\n+  virtual void visit (MetaItemSeq &meta_item) = 0;\n+  virtual void visit (MetaWord &meta_item) = 0;\n+  virtual void visit (MetaNameValueStr &meta_item) = 0;\n+  virtual void visit (MetaListPaths &meta_item) = 0;\n+  virtual void visit (MetaListNameValueStr &meta_item) = 0;\n+\n+  // rust-pattern.h\n+  virtual void visit (LiteralPattern &pattern) = 0;\n+  virtual void visit (IdentifierPattern &pattern) = 0;\n+  virtual void visit (WildcardPattern &pattern) = 0;\n+  // virtual void visit(RangePatternBound& bound) = 0;\n+  virtual void visit (RangePatternBoundLiteral &bound) = 0;\n+  virtual void visit (RangePatternBoundPath &bound) = 0;\n+  virtual void visit (RangePatternBoundQualPath &bound) = 0;\n+  virtual void visit (RangePattern &pattern) = 0;\n+  virtual void visit (ReferencePattern &pattern) = 0;\n+  // virtual void visit(StructPatternField& field) = 0;\n+  virtual void visit (StructPatternFieldTuplePat &field) = 0;\n+  virtual void visit (StructPatternFieldIdentPat &field) = 0;\n+  virtual void visit (StructPatternFieldIdent &field) = 0;\n+  virtual void visit (StructPattern &pattern) = 0;\n+  // virtual void visit(TupleStructItems& tuple_items) = 0;\n+  virtual void visit (TupleStructItemsNoRange &tuple_items) = 0;\n+  virtual void visit (TupleStructItemsRange &tuple_items) = 0;\n+  virtual void visit (TupleStructPattern &pattern) = 0;\n+  // virtual void visit(TuplePatternItems& tuple_items) = 0;\n+  virtual void visit (TuplePatternItemsMultiple &tuple_items) = 0;\n+  virtual void visit (TuplePatternItemsRanged &tuple_items) = 0;\n+  virtual void visit (TuplePattern &pattern) = 0;\n+  virtual void visit (GroupedPattern &pattern) = 0;\n+  virtual void visit (SlicePattern &pattern) = 0;\n+\n+  // rust-stmt.h\n+  virtual void visit (EmptyStmt &stmt) = 0;\n+  virtual void visit (LetStmt &stmt) = 0;\n+  virtual void visit (ExprStmtWithoutBlock &stmt) = 0;\n+  virtual void visit (ExprStmtWithBlock &stmt) = 0;\n+\n+  // rust-type.h\n+  virtual void visit (TraitBound &bound) = 0;\n+  virtual void visit (ImplTraitType &type) = 0;\n+  virtual void visit (TraitObjectType &type) = 0;\n+  virtual void visit (ParenthesisedType &type) = 0;\n+  virtual void visit (ImplTraitTypeOneBound &type) = 0;\n+  virtual void visit (TraitObjectTypeOneBound &type) = 0;\n+  virtual void visit (TupleType &type) = 0;\n+  virtual void visit (NeverType &type) = 0;\n+  virtual void visit (RawPointerType &type) = 0;\n+  virtual void visit (ReferenceType &type) = 0;\n+  virtual void visit (ArrayType &type) = 0;\n+  virtual void visit (SliceType &type) = 0;\n+  virtual void visit (InferredType &type) = 0;\n+  virtual void visit (BareFunctionType &type) = 0;\n+\n+  // TODO: rust-cond-compilation.h visiting? not currently used\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "cbaa2e9ae66793999ef4bdfa289f9f8d81ff4037", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "added", "additions": 1467, "deletions": 0, "changes": 1467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,1467 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_BASE_H\n+#define RUST_HIR_BASE_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-token.h\"\n+#include \"rust-location.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+typedef std::string Identifier;\n+typedef int TupleIndex;\n+\n+namespace HIR {\n+// foward decl: ast visitor\n+class HIRVisitor;\n+\n+// Delimiter types - used in macros and whatever.\n+enum DelimType\n+{\n+  PARENS,\n+  SQUARE,\n+  CURLY\n+};\n+\n+// Attribute body - abstract base class\n+class AttrInput\n+{\n+public:\n+  virtual ~AttrInput () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<AttrInput> clone_attr_input () const\n+  {\n+    return std::unique_ptr<AttrInput> (clone_attr_input_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  // Parse attribute input to meta item, if possible\n+  virtual AttrInput *parse_to_meta_item () const { return nullptr; }\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual AttrInput *clone_attr_input_impl () const = 0;\n+};\n+\n+// forward decl for use in token tree method\n+class Token;\n+\n+// A tree of tokens (or a single token) - abstract base class\n+class TokenTree\n+{\n+public:\n+  virtual ~TokenTree () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TokenTree> clone_token_tree () const\n+  {\n+    return std::unique_ptr<TokenTree> (clone_token_tree_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  /* Converts token tree to a flat token stream. Tokens must be pointer to avoid\n+   * mutual dependency with Token. */\n+  virtual std::vector<std::unique_ptr<Token> > to_token_stream () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TokenTree *clone_token_tree_impl () const = 0;\n+};\n+\n+// Abstract base class for a macro match\n+class MacroMatch\n+{\n+public:\n+  virtual ~MacroMatch () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<MacroMatch> clone_macro_match () const\n+  {\n+    return std::unique_ptr<MacroMatch> (clone_macro_match_impl ());\n+  }\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual MacroMatch *clone_macro_match_impl () const = 0;\n+};\n+\n+// A token is a kind of token tree (except delimiter tokens)\n+class Token : public TokenTree, public MacroMatch\n+{\n+  // A token is a kind of token tree (except delimiter tokens)\n+  // A token is a kind of MacroMatch (except $ and delimiter tokens)\n+  // TODO: improve member variables - current ones are the same as lexer token\n+  // Token kind.\n+  TokenId token_id;\n+  // Token location.\n+  Location locus;\n+  // Associated text (if any) of token.\n+  std::string str;\n+  // Token type hint (if any).\n+  PrimitiveCoreType type_hint;\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Token> clone_token () const\n+  {\n+    return std::unique_ptr<Token> (clone_token_impl ());\n+  }\n+\n+  /* constructor from general text - avoid using if lexer const_TokenPtr is\n+   * available */\n+  Token (TokenId token_id, Location locus, std::string str,\n+\t PrimitiveCoreType type_hint)\n+    : token_id (token_id), locus (locus), str (std::move (str)),\n+      type_hint (type_hint)\n+  {}\n+\n+  // Constructor from lexer const_TokenPtr\n+  /* TODO: find workaround for std::string being nullptr - probably have to\n+   * introduce new method in lexer Token, or maybe make conversion method\n+   * there */\n+  Token (const_TokenPtr lexer_token_ptr)\n+    : token_id (lexer_token_ptr->get_id ()),\n+      locus (lexer_token_ptr->get_locus ()), str (\"\"),\n+      type_hint (lexer_token_ptr->get_type_hint ())\n+  {\n+    // FIXME: change to \"should have str\" later?\n+    if (lexer_token_ptr->has_str ())\n+      {\n+\tstr = lexer_token_ptr->get_str ();\n+\n+\t// DEBUG\n+\tfprintf (stderr, \"ast token created with str '%s'\\n\", str.c_str ());\n+      }\n+    else\n+      {\n+\t// FIXME: is this returning correct thing?\n+\tstr = lexer_token_ptr->get_token_description ();\n+\n+\t// DEBUG\n+\tfprintf (stderr, \"ast token created with string '%s'\\n\", str.c_str ());\n+      }\n+\n+    // DEBUG\n+    if (lexer_token_ptr->should_have_str () && !lexer_token_ptr->has_str ())\n+      {\n+\tfprintf (stderr,\n+\t\t \"BAD: for token '%s', should have string but does not!\\n\",\n+\t\t lexer_token_ptr->get_token_description ());\n+      }\n+  }\n+\n+  bool is_string_lit () const\n+  {\n+    switch (token_id)\n+      {\n+      case STRING_LITERAL:\n+      case BYTE_STRING_LITERAL:\n+\treturn true;\n+      default:\n+\treturn false;\n+      }\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // Return copy of itself but in token stream form.\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n+\n+  TokenId get_id () const { return token_id; }\n+\n+  Location get_locus () const { return locus; }\n+\n+protected:\n+  // No virtual for now as not polymorphic but can be in future\n+  /*virtual*/ Token *clone_token_impl () const { return new Token (*this); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Token *clone_token_tree_impl () const override { return clone_token_impl (); }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Token *clone_macro_match_impl () const override\n+  {\n+    return clone_token_impl ();\n+  }\n+};\n+\n+// A literal - value with a type. Used in LiteralExpr and LiteralPattern.\n+struct Literal\n+{\n+public:\n+  enum LitType\n+  {\n+    CHAR,\n+    STRING,\n+    RAW_STRING,\n+    BYTE,\n+    BYTE_STRING,\n+    RAW_BYTE_STRING,\n+    INT,\n+    FLOAT,\n+    BOOL\n+  };\n+\n+private:\n+  /* TODO: maybe make subclasses of each type of literal with their typed values\n+   * (or generics) */\n+  std::string value_as_string;\n+  LitType type;\n+\n+public:\n+  std::string as_string () const { return value_as_string; }\n+\n+  LitType get_lit_type () const { return type; }\n+\n+  Literal (std::string value_as_string, LitType type)\n+    : value_as_string (std::move (value_as_string)), type (type)\n+  {}\n+\n+  static Literal create_error () { return Literal (\"\", CHAR); }\n+\n+  // Returns whether literal is in an invalid state.\n+  bool is_error () const { return value_as_string == \"\"; }\n+};\n+\n+// A token tree with delimiters\n+class DelimTokenTree : public TokenTree, public AttrInput\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n+  Location locus;\n+\n+protected:\n+  DelimTokenTree *clone_delim_tok_tree_impl () const\n+  {\n+    return new DelimTokenTree (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_attr_input_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning a DelimTokenTree\n+   * object */\n+  DelimTokenTree *clone_token_tree_impl () const override\n+  {\n+    return clone_delim_tok_tree_impl ();\n+  }\n+\n+public:\n+  DelimTokenTree (DelimType delim_type,\n+\t\t  std::vector<std::unique_ptr<TokenTree> > token_trees\n+\t\t  = std::vector<std::unique_ptr<TokenTree> > (),\n+\t\t  Location locus = Location ())\n+    : delim_type (delim_type), token_trees (std::move (token_trees)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  DelimTokenTree (DelimTokenTree const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n+  {\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  DelimTokenTree &operator= (DelimTokenTree const &other)\n+  {\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  DelimTokenTree (DelimTokenTree &&other) = default;\n+  DelimTokenTree &operator= (DelimTokenTree &&other) = default;\n+\n+  static DelimTokenTree create_empty () { return DelimTokenTree (PARENS); }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  AttrInput *parse_to_meta_item () const override;\n+\n+  std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n+\n+  std::unique_ptr<DelimTokenTree> clone_delim_token_tree () const\n+  {\n+    return std::unique_ptr<DelimTokenTree> (clone_delim_tok_tree_impl ());\n+  }\n+};\n+\n+/* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to\n+ * be defined */\n+class AttrInputLiteral;\n+\n+/* TODO: move applicable stuff into here or just don't include it because\n+ * nothing uses it A segment of a path (maybe) */\n+class PathSegment\n+{\n+public:\n+  virtual ~PathSegment () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  // TODO: add visitor here?\n+};\n+\n+// A segment of a simple path without generic or type arguments\n+class SimplePathSegment : public PathSegment\n+{\n+  std::string segment_name;\n+  Location locus;\n+\n+  // only allow identifiers, \"super\", \"self\", \"crate\", or \"$crate\"\n+public:\n+  // TODO: put checks in constructor to enforce this rule?\n+  SimplePathSegment (std::string segment_name, Location locus = Location ())\n+    : segment_name (std::move (segment_name)), locus (locus)\n+  {}\n+\n+  /* Returns whether simple path segment is in an invalid state (currently, if\n+   * empty). */\n+  bool is_error () const { return segment_name.empty (); }\n+\n+  // Creates an error SimplePathSegment\n+  static SimplePathSegment create_error ()\n+  {\n+    return SimplePathSegment (std::string (\"\"));\n+  }\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const { return locus; }\n+\n+  // TODO: visitor pattern?\n+};\n+\n+// A simple path without generic or type arguments\n+class SimplePath\n+{\n+  bool has_opening_scope_resolution;\n+  std::vector<SimplePathSegment> segments;\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  SimplePath (std::vector<SimplePathSegment> path_segments,\n+\t      bool has_opening_scope_resolution = false,\n+\t      Location locus = Location ())\n+    : has_opening_scope_resolution (has_opening_scope_resolution),\n+      segments (std::move (path_segments)), locus (locus)\n+  {}\n+\n+  // Creates an empty SimplePath.\n+  static SimplePath create_empty ()\n+  {\n+    return SimplePath (std::vector<SimplePathSegment> ());\n+  }\n+\n+  // Returns whether the SimplePath is empty, i.e. has path segments.\n+  bool is_empty () const { return segments.empty (); }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  // does this need visitor if not polymorphic? probably not\n+\n+  // path-to-string comparison operator\n+  bool operator== (const std::string &rhs)\n+  {\n+    return !has_opening_scope_resolution && segments.size () == 1\n+\t   && segments[0].as_string () == rhs;\n+  }\n+\n+  /* Creates a single-segment SimplePath from a string. This will not check to\n+   * ensure that this is a valid identifier in path, so be careful. Also, this\n+   * will have no location data.\n+   * TODO have checks? */\n+  static SimplePath from_str (std::string str)\n+  {\n+    std::vector<HIR::SimplePathSegment> single_segments\n+      = {HIR::SimplePathSegment (std::move (str))};\n+    return SimplePath (std::move (single_segments));\n+  }\n+};\n+\n+// aka Attr\n+// Attribute HIR representation\n+struct Attribute\n+{\n+private:\n+  SimplePath path;\n+\n+  // bool has_attr_input;\n+  std::unique_ptr<AttrInput> attr_input;\n+\n+  Location locus;\n+\n+  // TODO: maybe a variable storing whether attr input is parsed or not\n+\n+public:\n+  // Returns whether Attribute has AttrInput\n+  bool has_attr_input () const { return attr_input != nullptr; }\n+\n+  // Constructor has pointer AttrInput for polymorphism reasons\n+  Attribute (SimplePath path, std::unique_ptr<AttrInput> input,\n+\t     Location locus = Location ())\n+    : path (std::move (path)), attr_input (std::move (input)), locus (locus)\n+  {}\n+\n+  // default destructor\n+  ~Attribute () = default;\n+\n+  // Copy constructor must deep copy attr_input as unique pointer\n+  Attribute (Attribute const &other) : path (other.path), locus (other.locus)\n+  {\n+    // guard to protect from null pointer dereference\n+    if (other.attr_input != nullptr)\n+      attr_input = other.attr_input->clone_attr_input ();\n+  }\n+\n+  // overload assignment operator to use custom clone method\n+  Attribute &operator= (Attribute const &other)\n+  {\n+    path = other.path;\n+    locus = other.locus;\n+    // guard to protect from null pointer dereference\n+    if (other.attr_input != nullptr)\n+      attr_input = other.attr_input->clone_attr_input ();\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  Attribute (Attribute &&other) = default;\n+  Attribute &operator= (Attribute &&other) = default;\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Attribute> clone_attribute () const\n+  {\n+    return std::unique_ptr<Attribute> (clone_attribute_impl ());\n+  }\n+\n+  // Creates an empty attribute (which is invalid)\n+  static Attribute create_empty ()\n+  {\n+    return Attribute (SimplePath::create_empty (), nullptr);\n+  }\n+\n+  // Returns whether the attribute is considered an \"empty\" attribute.\n+  bool is_empty () const { return attr_input == nullptr && path.is_empty (); }\n+\n+  /* e.g.:\n+      #![crate_type = \"lib\"]\n+      #[test]\n+      #[cfg(target_os = \"linux\")]\n+      #[allow(non_camel_case_types)]\n+      #![allow(unused_variables)]\n+  */\n+\n+  // Full built-in attribute list:\n+  /*   cfg\n+   *   cfg_attr\n+   *   test\n+   *   ignore\n+   *   should_panic\n+   *   derive\n+   *   macro_export\n+   *   macro_use\n+   *   proc_macro\n+   *   proc_macro_derive\n+   *   proc_macro_attribute\n+   *   allow\n+   *   warn\n+   *   deny\n+   *   forbid\n+   *   deprecated\n+   *   must_use\n+   *   link\n+   *   link_name\n+   *   no_link\n+   *   repr\n+   *   crate_type\n+   *   no_main\n+   *   export_name\n+   *   link_section\n+   *   no_mangle\n+   *   used\n+   *   crate_name\n+   *   inline\n+   *   cold\n+   *   no_builtins\n+   *   target_feature\n+   *   doc\n+   *   no_std\n+   *   no_implicit_prelude\n+   *   path\n+   *   recursion_limit\n+   *   type_length_limit\n+   *   panic_handler\n+   *   global_allocator\n+   *   windows_subsystem\n+   *   feature     */\n+\n+  std::string as_string () const;\n+\n+  // TODO: does this require visitor pattern as not polymorphic?\n+\n+  // Maybe change to const-reference in future\n+  SimplePath get_path () const { return path; }\n+\n+  // Call to parse attribute body to meta item syntax.\n+  void parse_attr_to_meta_item ();\n+\n+protected:\n+  // not virtual as currently no subclasses of Attribute, but could be in future\n+  /*virtual*/ Attribute *clone_attribute_impl () const\n+  {\n+    return new Attribute (*this);\n+  }\n+};\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaNameValueStr;\n+\n+// abstract base meta item inner class\n+class MetaItemInner\n+{\n+protected:\n+  // pure virtual as MetaItemInner\n+  virtual MetaItemInner *clone_meta_item_inner_impl () const = 0;\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<MetaItemInner> clone_meta_item_inner () const\n+  {\n+    return std::unique_ptr<MetaItemInner> (clone_meta_item_inner_impl ());\n+  }\n+\n+  virtual ~MetaItemInner () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  /* HACK: used to simplify parsing - creates a copy of that type, or returns\n+   * null */\n+  virtual std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const\n+  {\n+    return nullptr;\n+  }\n+\n+  // HACK: used to simplify parsing - same thing\n+  virtual SimplePath to_path_item () const\n+  {\n+    return SimplePath::create_empty ();\n+  }\n+\n+  virtual Attribute to_attribute () const { return Attribute::create_empty (); }\n+};\n+\n+// Container used to store MetaItems as AttrInput (bridge-ish kinda thing)\n+class AttrInputMetaItemContainer : public AttrInput\n+{\n+  std::vector<std::unique_ptr<MetaItemInner> > items;\n+\n+public:\n+  AttrInputMetaItemContainer (\n+    std::vector<std::unique_ptr<MetaItemInner> > items)\n+    : items (std::move (items))\n+  {}\n+\n+  // no destructor definition required\n+\n+  // default move constructors\n+  AttrInputMetaItemContainer (AttrInputMetaItemContainer &&other) = default;\n+  AttrInputMetaItemContainer &operator= (AttrInputMetaItemContainer &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // Clones this object.\n+  std::unique_ptr<AttrInputMetaItemContainer>\n+  clone_attr_input_meta_item_container () const\n+  {\n+    return std::unique_ptr<AttrInputMetaItemContainer> (\n+      clone_attr_input_meta_item_container_impl ());\n+  }\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  AttrInputMetaItemContainer *clone_attr_input_impl () const override\n+  {\n+    return clone_attr_input_meta_item_container_impl ();\n+  }\n+\n+  AttrInputMetaItemContainer *clone_attr_input_meta_item_container_impl () const\n+  {\n+    return new AttrInputMetaItemContainer (*this);\n+  }\n+\n+  // copy constructor with vector clone\n+  AttrInputMetaItemContainer (const AttrInputMetaItemContainer &other)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_meta_item_inner ());\n+  }\n+\n+  // copy assignment operator with vector clone\n+  AttrInputMetaItemContainer &\n+  operator= (const AttrInputMetaItemContainer &other)\n+  {\n+    AttrInput::operator= (other);\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_meta_item_inner ());\n+\n+    return *this;\n+  }\n+};\n+\n+// abstract base meta item class\n+class MetaItem : public MetaItemInner\n+{\n+};\n+\n+// Forward decl - defined in rust-expr.h\n+class MetaItemLitExpr;\n+\n+// Forward decl - defined in rust-expr.h\n+class MetaItemPathLit;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaItemPath;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaItemSeq;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaWord;\n+\n+// Forward decl - defined in rust-macro.h\n+class MetaListPaths;\n+\n+// Forward decl - defined in rust-macro.h\n+struct MetaListNameValueStr;\n+\n+/* Base statement abstract class. Note that most \"statements\" are not allowed in\n+ * top-level module scope - only a subclass of statements called \"items\" are. */\n+class Stmt\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Stmt> clone_stmt () const\n+  {\n+    return std::unique_ptr<Stmt> (clone_stmt_impl ());\n+  }\n+\n+  virtual ~Stmt () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  /* HACK: slow way of getting location from base expression through virtual\n+   * methods. */\n+  virtual Location get_locus_slow () const { return Location (); }\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+\n+protected:\n+  Stmt (Analysis::NodeMapping mappings) : mappings (std::move (mappings)) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Stmt *clone_stmt_impl () const = 0;\n+\n+  Analysis::NodeMapping mappings;\n+};\n+\n+// Rust \"item\" HIR node (declaration of top-level/module-level allowed stuff)\n+class Item : public Stmt\n+{\n+  std::vector<Attribute> outer_attrs;\n+\n+  // TODO: should outer attrs be defined here or in each derived class?\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Item> clone_item () const\n+  {\n+    return std::unique_ptr<Item> (clone_item_impl ());\n+  }\n+\n+  std::string as_string () const;\n+\n+  /* Adds crate names to the vector passed by reference, if it can\n+   * (polymorphism). */\n+  virtual void\n+  add_crate_name (std::vector<std::string> &names ATTRIBUTE_UNUSED) const\n+  {}\n+\n+  virtual void accept_vis (HIRVisitor &vis ATTRIBUTE_UNUSED) {}\n+\n+protected:\n+  // Constructor\n+  Item (Analysis::NodeMapping mappings,\n+\tstd::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+    : Stmt (std::move (mappings)), outer_attrs (std::move (outer_attribs))\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Item *clone_item_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making\n+   * statement clone return item clone. Hopefully won't affect performance too\n+   * much. */\n+  Item *clone_stmt_impl () const override { return clone_item_impl (); }\n+};\n+\n+// forward decl of ExprWithoutBlock\n+class ExprWithoutBlock;\n+\n+// Base expression HIR node - abstract\n+class Expr\n+{\n+  // TODO: move outer attribute data to derived classes?\n+  std::vector<Attribute> outer_attrs;\n+\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Expr> clone_expr () const\n+  {\n+    return std::unique_ptr<Expr> (clone_expr_impl ());\n+  }\n+\n+  /* TODO: public methods that could be useful:\n+   *  - get_type() - returns type of expression. set_type() may also be useful\n+   * for some?\n+   *  - evaluate() - evaluates expression if constant? can_evaluate()? */\n+\n+  /* HACK: downcasting without dynamic_cast (if possible) via polymorphism -\n+   * overrided in subclasses of ExprWithoutBlock */\n+  virtual ExprWithoutBlock *as_expr_without_block () const { return nullptr; }\n+\n+  // TODO: make pure virtual if move out outer attributes to derived classes\n+  virtual std::string as_string () const;\n+\n+  virtual ~Expr () {}\n+\n+  /* HACK: slow way of getting location from base expression through virtual\n+   * methods. */\n+  virtual Location get_locus_slow () const { return Location (); }\n+\n+  // HACK: strictly not needed, but faster than full downcast clone\n+  virtual bool is_expr_without_block () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+\n+protected:\n+  // Constructor\n+  Expr (Analysis::NodeMapping mappings,\n+\tstd::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n+    : outer_attrs (std::move (outer_attribs)), mappings (std::move (mappings))\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Expr *clone_expr_impl () const = 0;\n+\n+  // TODO: think of less hacky way to implement this kind of thing\n+  // Sets outer attributes.\n+  void set_outer_attrs (std::vector<Attribute> outer_attrs_to_set)\n+  {\n+    outer_attrs = std::move (outer_attrs_to_set);\n+  }\n+};\n+\n+// HIR node for an expression without an accompanying block - abstract\n+class ExprWithoutBlock : public Expr\n+{\n+protected:\n+  // Constructor\n+  ExprWithoutBlock (Analysis::NodeMapping mappings,\n+\t\t    std::vector<Attribute> outer_attribs\n+\t\t    = std::vector<Attribute> ())\n+    : Expr (std::move (mappings), std::move (outer_attribs))\n+  {}\n+\n+  // pure virtual clone implementation\n+  virtual ExprWithoutBlock *clone_expr_without_block_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making expr\n+   * clone return exprwithoutblock clone. Hopefully won't affect performance too\n+   * much. */\n+  ExprWithoutBlock *clone_expr_impl () const override\n+  {\n+    return clone_expr_without_block_impl ();\n+  }\n+\n+  bool is_expr_without_block () const final override { return true; };\n+\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<ExprWithoutBlock> clone_expr_without_block () const\n+  {\n+    return std::unique_ptr<ExprWithoutBlock> (clone_expr_without_block_impl ());\n+  }\n+\n+  /* downcasting hack from expr to use pratt parsing with\n+   * parse_expr_without_block */\n+  ExprWithoutBlock *as_expr_without_block () const override\n+  {\n+    return clone_expr_without_block_impl ();\n+  }\n+};\n+\n+/* HACK: IdentifierExpr, delete when figure out identifier vs expr problem in\n+ * Pratt parser */\n+/* Alternatively, identifiers could just be represented as single-segment paths\n+ */\n+class IdentifierExpr : public ExprWithoutBlock\n+{\n+  Identifier ident;\n+\n+public:\n+  Location locus;\n+\n+  IdentifierExpr (Analysis::NodeMapping mappings, Identifier ident,\n+\t\t  Location locus = Location (),\n+\t\t  std::vector<Attribute> outer_attrs\n+\t\t  = std::vector<Attribute> ())\n+    : ExprWithoutBlock (std::move (mappings), std::move (outer_attrs)),\n+      ident (std::move (ident)), locus (locus)\n+  {}\n+\n+  std::string as_string () const override { return ident; }\n+\n+  Location get_locus () const { return locus; }\n+  Location get_locus_slow () const override { return get_locus (); }\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // Clones this object.\n+  std::unique_ptr<IdentifierExpr> clone_identifier_expr () const\n+  {\n+    return std::unique_ptr<IdentifierExpr> (clone_identifier_expr_impl ());\n+  }\n+\n+protected:\n+  // Clone method implementation\n+  IdentifierExpr *clone_expr_without_block_impl () const override\n+  {\n+    return clone_identifier_expr_impl ();\n+  }\n+\n+  IdentifierExpr *clone_identifier_expr_impl () const\n+  {\n+    return new IdentifierExpr (*this);\n+  }\n+\n+  IdentifierExpr (IdentifierExpr const &other) = default;\n+  IdentifierExpr &operator= (IdentifierExpr const &other) = default;\n+};\n+\n+// Pattern base HIR node\n+class Pattern\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Pattern> clone_pattern () const\n+  {\n+    return std::unique_ptr<Pattern> (clone_pattern_impl ());\n+  }\n+\n+  // possible virtual methods: is_refutable()\n+\n+  virtual ~Pattern () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // Clone pattern implementation as pure virtual method\n+  virtual Pattern *clone_pattern_impl () const = 0;\n+};\n+\n+// forward decl for Type\n+class TraitBound;\n+\n+// Base class for types as represented in HIR - abstract\n+class Type\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<Type> clone_type () const\n+  {\n+    return std::unique_ptr<Type> (clone_type_impl ());\n+  }\n+\n+  // virtual destructor\n+  virtual ~Type () {}\n+\n+  virtual std::string as_string () const = 0;\n+\n+  /* HACK: convert to trait bound. Virtual method overriden by classes that\n+   * enable this. */\n+  virtual TraitBound *to_trait_bound (bool in_parens ATTRIBUTE_UNUSED) const\n+  {\n+    return nullptr;\n+  }\n+  /* as pointer, shouldn't require definition beforehand, only forward\n+   * declaration. */\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+  virtual Analysis::NodeMapping get_mappings () { return mappings; }\n+\n+protected:\n+  Type (Analysis::NodeMapping mappings) : mappings (mappings) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual Type *clone_type_impl () const = 0;\n+\n+  Analysis::NodeMapping mappings;\n+};\n+\n+// A type without parentheses? - abstract\n+class TypeNoBounds : public Type\n+{\n+public:\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypeNoBounds> clone_type_no_bounds () const\n+  {\n+    return std::unique_ptr<TypeNoBounds> (clone_type_no_bounds_impl ());\n+  }\n+\n+protected:\n+  TypeNoBounds (Analysis::NodeMapping mappings) : Type (mappings) {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual TypeNoBounds *clone_type_no_bounds_impl () const = 0;\n+\n+  /* Save having to specify two clone methods in derived classes by making type\n+   * clone return typenobounds clone. Hopefully won't affect performance too\n+   * much. */\n+  TypeNoBounds *clone_type_impl () const override\n+  {\n+    return clone_type_no_bounds_impl ();\n+  }\n+};\n+\n+/* Abstract base class representing a type param bound - Lifetime and TraitBound\n+ * extends it */\n+class TypeParamBound\n+{\n+public:\n+  virtual ~TypeParamBound () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypeParamBound> clone_type_param_bound () const\n+  {\n+    return std::unique_ptr<TypeParamBound> (clone_type_param_bound_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual TypeParamBound *clone_type_param_bound_impl () const = 0;\n+};\n+\n+// Represents a lifetime (and is also a kind of type param bound)\n+class Lifetime : public TypeParamBound\n+{\n+public:\n+  enum LifetimeType\n+  {\n+    NAMED,   // corresponds to LIFETIME_OR_LABEL\n+    STATIC,  // corresponds to 'static\n+    WILDCARD // corresponds to '_\n+  };\n+\n+private:\n+  LifetimeType lifetime_type;\n+\n+  // TODO: LIFETIME_OR_LABEL (aka lifetime token) is only field\n+  // find way of enclosing token or something\n+  std::string lifetime_name;\n+  // only applies for NAMED lifetime_type\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  Lifetime (LifetimeType type, std::string name = std::string (),\n+\t    Location locus = Location ())\n+    : lifetime_type (type), lifetime_name (std::move (name)), locus (locus)\n+  {}\n+\n+  // Creates an \"error\" lifetime.\n+  static Lifetime error () { return Lifetime (NAMED, std::string (\"\")); }\n+\n+  // Returns true if the lifetime is in an error state.\n+  bool is_error () const\n+  {\n+    return lifetime_type == NAMED && lifetime_name.empty ();\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  Lifetime *clone_type_param_bound_impl () const override\n+  {\n+    return new Lifetime (*this);\n+  }\n+};\n+\n+/* Base generic parameter in HIR. Abstract - can be represented by a Lifetime or\n+ * Type param */\n+class GenericParam\n+{\n+public:\n+  virtual ~GenericParam () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<GenericParam> clone_generic_param () const\n+  {\n+    return std::unique_ptr<GenericParam> (clone_generic_param_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual GenericParam *clone_generic_param_impl () const = 0;\n+};\n+\n+// A lifetime generic parameter (as opposed to a type generic parameter)\n+class LifetimeParam : public GenericParam\n+{\n+  Lifetime lifetime;\n+\n+  // bool has_lifetime_bounds;\n+  // LifetimeBounds lifetime_bounds;\n+  std::vector<Lifetime> lifetime_bounds; // inlined LifetimeBounds\n+\n+  // bool has_outer_attribute;\n+  // std::unique_ptr<Attribute> outer_attr;\n+  Attribute outer_attr;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether the lifetime param has any lifetime bounds.\n+  bool has_lifetime_bounds () const { return !lifetime_bounds.empty (); }\n+\n+  // Returns whether the lifetime param has an outer attribute.\n+  bool has_outer_attribute () const { return !outer_attr.is_empty (); }\n+\n+  // Creates an error state lifetime param.\n+  static LifetimeParam create_error ()\n+  {\n+    return LifetimeParam (Lifetime::error ());\n+  }\n+\n+  // Returns whether the lifetime param is in an error state.\n+  bool is_error () const { return lifetime.is_error (); }\n+\n+  // Constructor\n+  LifetimeParam (Lifetime lifetime, Location locus = Location (),\n+\t\t std::vector<Lifetime> lifetime_bounds\n+\t\t = std::vector<Lifetime> (),\n+\t\t Attribute outer_attr = Attribute::create_empty ())\n+    : lifetime (std::move (lifetime)),\n+      lifetime_bounds (std::move (lifetime_bounds)),\n+      outer_attr (std::move (outer_attr)), locus (locus)\n+  {}\n+\n+  // TODO: remove copy and assignment operator definitions - not required\n+\n+  // Copy constructor with clone\n+  LifetimeParam (LifetimeParam const &other)\n+    : lifetime (other.lifetime), lifetime_bounds (other.lifetime_bounds),\n+      outer_attr (other.outer_attr), locus (other.locus)\n+  {}\n+\n+  // Overloaded assignment operator to clone attribute\n+  LifetimeParam &operator= (LifetimeParam const &other)\n+  {\n+    lifetime = other.lifetime;\n+    lifetime_bounds = other.lifetime_bounds;\n+    outer_attr = other.outer_attr;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  LifetimeParam (LifetimeParam &&other) = default;\n+  LifetimeParam &operator= (LifetimeParam &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LifetimeParam *clone_generic_param_impl () const override\n+  {\n+    return new LifetimeParam (*this);\n+  }\n+};\n+\n+// A macro item HIR node - potentially abstract base class\n+class MacroItem : public Item\n+{\n+  /*public:\n+  std::string as_string() const;*/\n+protected:\n+  MacroItem (Analysis::NodeMapping mappings,\n+\t     std::vector<Attribute> outer_attribs)\n+    : Item (std::move (mappings), std::move (outer_attribs))\n+  {}\n+};\n+\n+// Item used in trait declarations - abstract base class\n+class TraitItem\n+{\n+  // bool has_outer_attrs;\n+  // TODO: remove and rely on virtual functions and VisItem-derived attributes?\n+  // std::vector<Attribute> outer_attrs;\n+\n+  // NOTE: all children should have outer attributes\n+\n+protected:\n+  // Constructor\n+  /*TraitItem(std::vector<Attribute> outer_attrs = std::vector<Attribute>())\n+    : outer_attrs(std::move(outer_attrs)) {}*/\n+\n+  // Clone function implementation as pure virtual method\n+  virtual TraitItem *clone_trait_item_impl () const = 0;\n+\n+public:\n+  virtual ~TraitItem () {}\n+\n+  // Returns whether TraitItem has outer attributes.\n+  /*bool has_outer_attrs() const {\n+      return !outer_attrs.empty();\n+  }*/\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TraitItem> clone_trait_item () const\n+  {\n+    return std::unique_ptr<TraitItem> (clone_trait_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+};\n+\n+/* Abstract base class for items used within an inherent impl block (the impl\n+ * name {} one) */\n+class InherentImplItem\n+{\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual InherentImplItem *clone_inherent_impl_item_impl () const = 0;\n+\n+public:\n+  virtual ~InherentImplItem () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<InherentImplItem> clone_inherent_impl_item () const\n+  {\n+    return std::unique_ptr<InherentImplItem> (clone_inherent_impl_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+};\n+\n+// Abstract base class for items used in a trait impl\n+class TraitImplItem\n+{\n+protected:\n+  virtual TraitImplItem *clone_trait_impl_item_impl () const = 0;\n+\n+public:\n+  virtual ~TraitImplItem (){};\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TraitImplItem> clone_trait_impl_item () const\n+  {\n+    return std::unique_ptr<TraitImplItem> (clone_trait_impl_item_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (HIRVisitor &vis) = 0;\n+};\n+\n+/* A macro invocation item (or statement) HIR node (i.e. semi-coloned macro\n+ * invocation) */\n+class MacroInvocationSemi : public MacroItem,\n+\t\t\t    public TraitItem,\n+\t\t\t    public InherentImplItem,\n+\t\t\t    public TraitImplItem\n+{\n+  SimplePath path;\n+  // all delim types except curly must have invocation end with a semicolon\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<TokenTree> > token_trees;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  MacroInvocationSemi (Analysis::NodeMapping mappings, SimplePath macro_path,\n+\t\t       DelimType delim_type,\n+\t\t       std::vector<std::unique_ptr<TokenTree> > token_trees,\n+\t\t       std::vector<Attribute> outer_attribs, Location locus)\n+    : MacroItem (std::move (mappings), std::move (outer_attribs)),\n+      path (std::move (macro_path)), delim_type (delim_type),\n+      token_trees (std::move (token_trees)), locus (locus)\n+  {}\n+  /* TODO: possible issue with Item and TraitItem hierarchies both having outer\n+   * attributes\n+   * - storage inefficiency at least.\n+   * Best current idea is to make Item preferred and have TraitItem get virtual\n+   * functions for attributes or something. Or just redo the \"composition\"\n+   * approach, but then this prevents polymorphism and would entail redoing\n+   * quite a bit of the parser. */\n+\n+  // Move constructors\n+  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n+  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  // Clones this macro invocation semi.\n+  std::unique_ptr<MacroInvocationSemi> clone_macro_invocation_semi () const\n+  {\n+    return std::unique_ptr<MacroInvocationSemi> (\n+      clone_macro_invocation_semi_impl ());\n+  }\n+\n+protected:\n+  // Copy constructor with vector clone\n+  MacroInvocationSemi (MacroInvocationSemi const &other)\n+    : MacroItem (other), TraitItem (other), InherentImplItem (other),\n+      TraitImplItem (other), path (other.path), delim_type (other.delim_type),\n+      locus (other.locus)\n+  {\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  MacroInvocationSemi &operator= (MacroInvocationSemi const &other)\n+  {\n+    MacroItem::operator= (other);\n+    TraitItem::operator= (other);\n+    InherentImplItem::operator= (other);\n+    TraitImplItem::operator= (other);\n+    path = other.path;\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    token_trees.reserve (other.token_trees.size ());\n+    for (const auto &e : other.token_trees)\n+      token_trees.push_back (e->clone_token_tree ());\n+\n+    return *this;\n+  }\n+\n+  MacroInvocationSemi *clone_macro_invocation_semi_impl () const\n+  {\n+    return new MacroInvocationSemi (*this);\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_inherent_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_trait_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n+\n+  // FIXME: remove if item impl virtual override works properly\n+  // Use covariance to implement clone function as returning this object rather\n+  // than base\n+  /*MacroInvocationSemi* clone_statement_impl() const override {\n+      return clone_macro_invocation_semi_impl ();\n+  }*/\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocationSemi *clone_trait_item_impl () const override\n+  {\n+    return clone_macro_invocation_semi_impl ();\n+  }\n+};\n+\n+// A crate HIR object - holds all the data for a single compilation unit\n+struct Crate\n+{\n+  bool has_utf8bom;\n+  bool has_shebang;\n+\n+  std::vector<Attribute> inner_attrs;\n+  // dodgy spacing required here\n+  /* TODO: is it better to have a vector of items here or a module (implicit\n+   * top-level one)? */\n+  std::vector<std::unique_ptr<Item> > items;\n+\n+  Analysis::NodeMapping mappings;\n+\n+public:\n+  // Constructor\n+  Crate (std::vector<std::unique_ptr<Item> > items,\n+\t std::vector<Attribute> inner_attrs, Analysis::NodeMapping mappings,\n+\t bool has_utf8bom = false, bool has_shebang = false)\n+    : has_utf8bom (has_utf8bom), has_shebang (has_shebang),\n+      inner_attrs (std::move (inner_attrs)), items (std::move (items)),\n+      mappings (mappings)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  Crate (Crate const &other)\n+    : has_utf8bom (other.has_utf8bom), has_shebang (other.has_shebang),\n+      inner_attrs (other.inner_attrs), mappings (other.mappings)\n+  {\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_item ());\n+  }\n+\n+  ~Crate () = default;\n+\n+  // Overloaded assignment operator with vector clone\n+  Crate &operator= (Crate const &other)\n+  {\n+    inner_attrs = other.inner_attrs;\n+    has_shebang = other.has_shebang;\n+    has_utf8bom = other.has_utf8bom;\n+    mappings = other.mappings;\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_item ());\n+\n+    return *this;\n+  }\n+\n+  // Move constructors\n+  Crate (Crate &&other) = default;\n+  Crate &operator= (Crate &&other) = default;\n+\n+  // Get crate representation as string (e.g. for debugging).\n+  std::string as_string () const;\n+\n+  const Analysis::NodeMapping &get_mappings () const { return mappings; }\n+};\n+\n+// Base path expression HIR node - abstract\n+class PathExpr : public ExprWithoutBlock\n+{\n+protected:\n+  PathExpr (Analysis::NodeMapping mappings,\n+\t    std::vector<Attribute> outer_attribs)\n+    : ExprWithoutBlock (std::move (mappings), std::move (outer_attribs))\n+  {}\n+\n+public:\n+  // TODO: think of a better and less hacky way to allow this\n+\n+  /* Replaces the outer attributes of this path expression with the given outer\n+   * attributes. */\n+  void replace_outer_attrs (std::vector<Attribute> outer_attrs)\n+  {\n+    set_outer_attrs (std::move (outer_attrs));\n+  }\n+};\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif"}, {"sha": "cc60055b8fdafc058b4f060457599de213d9bbe3", "filename": "gcc/rust/resolve/rust-ast-resolve-base.h", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-base.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,258 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_BASE_H\n+#define RUST_AST_RESOLVE_BASE_H\n+\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-name-resolver.h\"\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolverBase : public AST::ASTVisitor\n+{\n+public:\n+  virtual ~ResolverBase () {}\n+\n+  // visitor impl\n+  // rust-ast.h\n+  //  virtual void visit(AttrInput& attr_input);\n+  //  virtual void visit(TokenTree& token_tree);\n+  //  virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (AST::Token &tok) {}\n+  virtual void visit (AST::DelimTokenTree &delim_tok_tree) {}\n+  virtual void visit (AST::AttrInputMetaItemContainer &input) {}\n+  //  virtual void visit(MetaItem& meta_item) {}\n+  //  void vsit(Stmt& stmt) {}\n+  //  virtual void visit(Expr& expr) {}\n+  virtual void visit (AST::IdentifierExpr &ident_expr) {}\n+  //  virtual void visit(Pattern& pattern) {}\n+  //  virtual void visit(Type& type) {}\n+  //  virtual void visit(TypeParamBound& type_param_bound) {}\n+  virtual void visit (AST::Lifetime &lifetime) {}\n+  //  virtual void visit(GenericParam& generic_param) {}\n+  virtual void visit (AST::LifetimeParam &lifetime_param) {}\n+  //  virtual void visit(TraitItem& trait_item) {}\n+  //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n+  //  virtual void visit(TraitImplItem& trait_impl_item) {}\n+  virtual void visit (AST::MacroInvocationSemi &macro) {}\n+\n+  // rust-path.h\n+  virtual void visit (AST::PathInExpression &path) {}\n+  virtual void visit (AST::TypePathSegment &segment) {}\n+  virtual void visit (AST::TypePathSegmentGeneric &segment) {}\n+  virtual void visit (AST::TypePathSegmentFunction &segment) {}\n+  virtual void visit (AST::TypePath &path) {}\n+  virtual void visit (AST::QualifiedPathInExpression &path) {}\n+  virtual void visit (AST::QualifiedPathInType &path) {}\n+\n+  // rust-expr.h\n+  virtual void visit (AST::LiteralExpr &expr) {}\n+  virtual void visit (AST::AttrInputLiteral &attr_input) {}\n+  virtual void visit (AST::MetaItemLitExpr &meta_item) {}\n+  virtual void visit (AST::MetaItemPathLit &meta_item) {}\n+  virtual void visit (AST::BorrowExpr &expr) {}\n+  virtual void visit (AST::DereferenceExpr &expr) {}\n+  virtual void visit (AST::ErrorPropagationExpr &expr) {}\n+  virtual void visit (AST::NegationExpr &expr) {}\n+  virtual void visit (AST::ArithmeticOrLogicalExpr &expr) {}\n+  virtual void visit (AST::ComparisonExpr &expr) {}\n+  virtual void visit (AST::LazyBooleanExpr &expr) {}\n+  virtual void visit (AST::TypeCastExpr &expr) {}\n+  virtual void visit (AST::AssignmentExpr &expr) {}\n+  virtual void visit (AST::CompoundAssignmentExpr &expr) {}\n+  virtual void visit (AST::GroupedExpr &expr) {}\n+  //  virtual void visit(ArrayElems& elems) {}\n+  virtual void visit (AST::ArrayElemsValues &elems) {}\n+  virtual void visit (AST::ArrayElemsCopied &elems) {}\n+  virtual void visit (AST::ArrayExpr &expr) {}\n+  virtual void visit (AST::ArrayIndexExpr &expr) {}\n+  virtual void visit (AST::TupleExpr &expr) {}\n+  virtual void visit (AST::TupleIndexExpr &expr) {}\n+  virtual void visit (AST::StructExprStruct &expr) {}\n+  //  virtual void visit(StructExprField& field) {}\n+  virtual void visit (AST::StructExprFieldIdentifier &field) {}\n+  virtual void visit (AST::StructExprFieldIdentifierValue &field) {}\n+  virtual void visit (AST::StructExprFieldIndexValue &field) {}\n+  virtual void visit (AST::StructExprStructFields &expr) {}\n+  virtual void visit (AST::StructExprStructBase &expr) {}\n+  virtual void visit (AST::StructExprTuple &expr) {}\n+  virtual void visit (AST::StructExprUnit &expr) {}\n+  //  virtual void visit(EnumExprField& field) {}\n+  virtual void visit (AST::EnumExprFieldIdentifier &field) {}\n+  virtual void visit (AST::EnumExprFieldIdentifierValue &field) {}\n+  virtual void visit (AST::EnumExprFieldIndexValue &field) {}\n+  virtual void visit (AST::EnumExprStruct &expr) {}\n+  virtual void visit (AST::EnumExprTuple &expr) {}\n+  virtual void visit (AST::EnumExprFieldless &expr) {}\n+  virtual void visit (AST::CallExpr &expr) {}\n+  virtual void visit (AST::MethodCallExpr &expr) {}\n+  virtual void visit (AST::FieldAccessExpr &expr) {}\n+  virtual void visit (AST::ClosureExprInner &expr) {}\n+  virtual void visit (AST::BlockExpr &expr) {}\n+  virtual void visit (AST::ClosureExprInnerTyped &expr) {}\n+  virtual void visit (AST::ContinueExpr &expr) {}\n+  virtual void visit (AST::BreakExpr &expr) {}\n+  virtual void visit (AST::RangeFromToExpr &expr) {}\n+  virtual void visit (AST::RangeFromExpr &expr) {}\n+  virtual void visit (AST::RangeToExpr &expr) {}\n+  virtual void visit (AST::RangeFullExpr &expr) {}\n+  virtual void visit (AST::RangeFromToInclExpr &expr) {}\n+  virtual void visit (AST::RangeToInclExpr &expr) {}\n+  virtual void visit (AST::ReturnExpr &expr) {}\n+  virtual void visit (AST::UnsafeBlockExpr &expr) {}\n+  virtual void visit (AST::LoopExpr &expr) {}\n+  virtual void visit (AST::WhileLoopExpr &expr) {}\n+  virtual void visit (AST::WhileLetLoopExpr &expr) {}\n+  virtual void visit (AST::ForLoopExpr &expr) {}\n+  virtual void visit (AST::IfExpr &expr) {}\n+  virtual void visit (AST::IfExprConseqElse &expr) {}\n+  virtual void visit (AST::IfExprConseqIf &expr) {}\n+  virtual void visit (AST::IfExprConseqIfLet &expr) {}\n+  virtual void visit (AST::IfLetExpr &expr) {}\n+  virtual void visit (AST::IfLetExprConseqElse &expr) {}\n+  virtual void visit (AST::IfLetExprConseqIf &expr) {}\n+  virtual void visit (AST::IfLetExprConseqIfLet &expr) {}\n+  //  virtual void visit(MatchCase& match_case) {}\n+  // virtual void visit (AST::MatchCaseBlockExpr &match_case) {}\n+  // virtual void visit (AST::MatchCaseExpr &match_case) {}\n+  virtual void visit (AST::MatchExpr &expr) {}\n+  virtual void visit (AST::AwaitExpr &expr) {}\n+  virtual void visit (AST::AsyncBlockExpr &expr) {}\n+\n+  // rust-item.h\n+  virtual void visit (AST::TypeParam &param) {}\n+  //  virtual void visit(WhereClauseItem& item) {}\n+  virtual void visit (AST::LifetimeWhereClauseItem &item) {}\n+  virtual void visit (AST::TypeBoundWhereClauseItem &item) {}\n+  virtual void visit (AST::Method &method) {}\n+  virtual void visit (AST::ModuleBodied &module) {}\n+  virtual void visit (AST::ModuleNoBody &module) {}\n+  virtual void visit (AST::ExternCrate &crate) {}\n+  //  virtual void visit(UseTree& use_tree) {}\n+  virtual void visit (AST::UseTreeGlob &use_tree) {}\n+  virtual void visit (AST::UseTreeList &use_tree) {}\n+  virtual void visit (AST::UseTreeRebind &use_tree) {}\n+  virtual void visit (AST::UseDeclaration &use_decl) {}\n+  virtual void visit (AST::Function &function) {}\n+  virtual void visit (AST::TypeAlias &type_alias) {}\n+  virtual void visit (AST::StructStruct &struct_item) {}\n+  virtual void visit (AST::TupleStruct &tuple_struct) {}\n+  virtual void visit (AST::EnumItem &item) {}\n+  virtual void visit (AST::EnumItemTuple &item) {}\n+  virtual void visit (AST::EnumItemStruct &item) {}\n+  virtual void visit (AST::EnumItemDiscriminant &item) {}\n+  virtual void visit (AST::Enum &enum_item) {}\n+  virtual void visit (AST::Union &union_item) {}\n+  virtual void visit (AST::ConstantItem &const_item) {}\n+  virtual void visit (AST::StaticItem &static_item) {}\n+  virtual void visit (AST::TraitItemFunc &item) {}\n+  virtual void visit (AST::TraitItemMethod &item) {}\n+  virtual void visit (AST::TraitItemConst &item) {}\n+  virtual void visit (AST::TraitItemType &item) {}\n+  virtual void visit (AST::Trait &trait) {}\n+  virtual void visit (AST::InherentImpl &impl) {}\n+  virtual void visit (AST::TraitImpl &impl) {}\n+  //  virtual void visit(ExternalItem& item) {}\n+  virtual void visit (AST::ExternalStaticItem &item) {}\n+  virtual void visit (AST::ExternalFunctionItem &item) {}\n+  virtual void visit (AST::ExternBlock &block) {}\n+\n+  // rust-macro.h\n+  virtual void visit (AST::MacroMatchFragment &match) {}\n+  virtual void visit (AST::MacroMatchRepetition &match) {}\n+  virtual void visit (AST::MacroMatcher &matcher) {}\n+  virtual void visit (AST::MacroRulesDefinition &rules_def) {}\n+  virtual void visit (AST::MacroInvocation &macro_invoc) {}\n+  virtual void visit (AST::MetaItemPath &meta_item) {}\n+  virtual void visit (AST::MetaItemSeq &meta_item) {}\n+  virtual void visit (AST::MetaWord &meta_item) {}\n+  virtual void visit (AST::MetaNameValueStr &meta_item) {}\n+  virtual void visit (AST::MetaListPaths &meta_item) {}\n+  virtual void visit (AST::MetaListNameValueStr &meta_item) {}\n+\n+  // rust-pattern.h\n+  virtual void visit (AST::LiteralPattern &pattern) {}\n+  virtual void visit (AST::IdentifierPattern &pattern) {}\n+  virtual void visit (AST::WildcardPattern &pattern) {}\n+  //  virtual void visit(RangePatternBound& bound) {}\n+  virtual void visit (AST::RangePatternBoundLiteral &bound) {}\n+  virtual void visit (AST::RangePatternBoundPath &bound) {}\n+  virtual void visit (AST::RangePatternBoundQualPath &bound) {}\n+  virtual void visit (AST::RangePattern &pattern) {}\n+  virtual void visit (AST::ReferencePattern &pattern) {}\n+  //  virtual void visit(StructPatternField& field) {}\n+  virtual void visit (AST::StructPatternFieldTuplePat &field) {}\n+  virtual void visit (AST::StructPatternFieldIdentPat &field) {}\n+  virtual void visit (AST::StructPatternFieldIdent &field) {}\n+  virtual void visit (AST::StructPattern &pattern) {}\n+  //  virtual void visit(TupleStructItems& tuple_items) {}\n+  virtual void visit (AST::TupleStructItemsNoRange &tuple_items) {}\n+  virtual void visit (AST::TupleStructItemsRange &tuple_items) {}\n+  virtual void visit (AST::TupleStructPattern &pattern) {}\n+  //  virtual void visit(TuplePatternItems& tuple_items) {}\n+  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items) {}\n+  virtual void visit (AST::TuplePatternItemsRanged &tuple_items) {}\n+  virtual void visit (AST::TuplePattern &pattern) {}\n+  virtual void visit (AST::GroupedPattern &pattern) {}\n+  virtual void visit (AST::SlicePattern &pattern) {}\n+\n+  // rust-stmt.h\n+  virtual void visit (AST::EmptyStmt &stmt) {}\n+  virtual void visit (AST::LetStmt &stmt) {}\n+  virtual void visit (AST::ExprStmtWithoutBlock &stmt) {}\n+  virtual void visit (AST::ExprStmtWithBlock &stmt) {}\n+\n+  // rust-type.h\n+  virtual void visit (AST::TraitBound &bound) {}\n+  virtual void visit (AST::ImplTraitType &type) {}\n+  virtual void visit (AST::TraitObjectType &type) {}\n+  virtual void visit (AST::ParenthesisedType &type) {}\n+  virtual void visit (AST::ImplTraitTypeOneBound &type) {}\n+  virtual void visit (AST::TraitObjectTypeOneBound &type) {}\n+  virtual void visit (AST::TupleType &type) {}\n+  virtual void visit (AST::NeverType &type) {}\n+  virtual void visit (AST::RawPointerType &type) {}\n+  virtual void visit (AST::ReferenceType &type) {}\n+  virtual void visit (AST::ArrayType &type) {}\n+  virtual void visit (AST::SliceType &type) {}\n+  virtual void visit (AST::InferredType &type) {}\n+  virtual void visit (AST::BareFunctionType &type) {}\n+\n+protected:\n+  ResolverBase (NodeId parent)\n+    : resolver (Resolver::get ()), resolved_node (UNKNOWN_NODEID),\n+      parent (parent), locus (Location ())\n+  {}\n+\n+  bool resolved () const { return resolved_node != UNKNOWN_NODEID; }\n+\n+  Resolver *resolver;\n+  NodeId resolved_node;\n+  NodeId parent;\n+  Location locus;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_BASE_H"}, {"sha": "9e98fda08628d79179abff48199574c6d018ede9", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,105 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_EXPR_H\n+#define RUST_AST_RESOLVE_EXPR_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveExpr : public ResolverBase\n+{\n+public:\n+  static void go (AST::Expr *expr, NodeId parent)\n+  {\n+    ResolveExpr resolver (parent);\n+    expr->accept_vis (resolver);\n+  };\n+\n+  ~ResolveExpr () {}\n+\n+  void visit (AST::PathInExpression &expr)\n+  {\n+    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+      {\n+\trust_error_at (expr.get_locus (), \"unknown path %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+    else\n+      {\n+\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t\t Definition{expr.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+  }\n+\n+  void visit (AST::ReturnExpr &expr)\n+  {\n+    if (expr.has_returned_expr ())\n+      ResolveExpr::go (expr.get_returned_expr ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::CallExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_function_expr ().get (), expr.get_node_id ());\n+    expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n+      ResolveExpr::go (p, expr.get_node_id ());\n+      return true;\n+    });\n+    // resolver->insert_resolved_name(NodeId refId,NodeId defId)\n+  }\n+\n+  void visit (AST::AssignmentExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+  }\n+\n+  void visit (AST::IdentifierExpr &expr)\n+  {\n+    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+      {\n+\trust_error_at (expr.get_locus (), \"failed to find name: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+    resolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t     Definition{expr.get_node_id (), parent});\n+  }\n+\n+  void visit (AST::ArithmeticOrLogicalExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+    ResolveExpr::go (expr.get_right_expr ().get (), expr.get_node_id ());\n+  }\n+\n+private:\n+  ResolveExpr (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_EXPR_H"}, {"sha": "2c21a5212dcd4ecb7fe7d4a3a46a216db0b0ee51", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_ITEM_H\n+#define RUST_AST_RESOLVE_ITEM_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-stmt.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveItem : public ResolverBase\n+{\n+public:\n+  static void go (AST::Item *item)\n+  {\n+    ResolveItem resolver;\n+    item->accept_vis (resolver);\n+  };\n+\n+  ~ResolveItem () {}\n+\n+  void visit (AST::Function &function)\n+  {\n+    if (function.has_return_type ())\n+      ResolveType::go (function.get_return_type ().get (),\n+\t\t       function.get_node_id ());\n+\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+      }\n+\n+    // setup parent scoping for names\n+    NodeId scope_node_id = function.get_definition ()->get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+    function.get_definition ()->iterate_stmts (\n+      [&] (AST::Stmt *s) mutable -> bool {\n+\tResolveStmt::go (s, s->get_node_id ());\n+\treturn true;\n+      });\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n+private:\n+  ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_ITEM_H"}, {"sha": "fc2da703e6cbebe76d15fbe95998c7b1bf521d61", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,97 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_PATTERN_H\n+#define RUST_AST_RESOLVE_PATTERN_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolvePattern : public ResolverBase\n+{\n+public:\n+  static void go (AST::Pattern *pattern, NodeId parent)\n+  {\n+    ResolvePattern resolver (parent);\n+\n+    pattern->accept_vis (resolver);\n+    if (resolver.resolved_node == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (resolver.locus, \"failed to resolve pattern %s\",\n+\t\t       pattern->as_string ().c_str ());\n+      }\n+  };\n+\n+  ~ResolvePattern () {}\n+\n+  void visit (AST::IdentifierPattern &pattern)\n+  {\n+    if (resolver->get_name_scope ().lookup (pattern.get_ident (),\n+\t\t\t\t\t    &resolved_node))\n+      {\n+\tresolver->insert_resolved_name (pattern.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (pattern.get_node_id (),\n+\t\t\t\t\t Definition{pattern.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+  }\n+\n+private:\n+  ResolvePattern (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+class PatternDeclaration : public ResolverBase\n+{\n+public:\n+  static void go (AST::Pattern *pattern, NodeId parent)\n+  {\n+    PatternDeclaration resolver (parent);\n+\n+    pattern->accept_vis (resolver);\n+    if (resolver.resolved_node != UNKNOWN_NODEID)\n+      {\n+\t// print both locations?!\n+\trust_error_at (resolver.locus, \"duplicate pattern %s\",\n+\t\t       pattern->as_string ().c_str ());\n+      }\n+  };\n+\n+  ~PatternDeclaration () {}\n+\n+  void visit (AST::IdentifierPattern &pattern)\n+  {\n+    // if we have a duplicate id this then allows for shadowing correctly\n+    // as new refs to this decl will match back here so it is ok to overwrite\n+    resolver->get_name_scope ().insert (pattern.get_ident (),\n+\t\t\t\t\tpattern.get_node_id ());\n+    resolver->insert_new_definition (pattern.get_node_id (),\n+\t\t\t\t     Definition{pattern.get_node_id (),\n+\t\t\t\t\t\tparent});\n+  }\n+\n+private:\n+  PatternDeclaration (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_PATTERN_H"}, {"sha": "20d40f1c1a595e6e711603487bfe2b7b5f0d9af0", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,64 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_STMT_H\n+#define RUST_AST_RESOLVE_STMT_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveStmt : public ResolverBase\n+{\n+public:\n+  static void go (AST::Stmt *stmt, NodeId parent)\n+  {\n+    ResolveStmt resolver (parent);\n+    stmt->accept_vis (resolver);\n+  };\n+\n+  ~ResolveStmt () {}\n+\n+  void visit (AST::ExprStmtWithoutBlock &stmt)\n+  {\n+    ResolveExpr::go (stmt.get_expr ().get (), stmt.get_node_id ());\n+  }\n+\n+  void visit (AST::LetStmt &stmt)\n+  {\n+    PatternDeclaration::go (stmt.get_pattern ().get (), stmt.get_node_id ());\n+    if (stmt.has_type ())\n+      ResolveType::go (stmt.get_type ().get (), stmt.get_node_id ());\n+\n+    if (stmt.has_init_expr ())\n+      ResolveExpr::go (stmt.get_init_expr ().get (), stmt.get_node_id ());\n+  }\n+\n+private:\n+  ResolveStmt (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_STMT_H"}, {"sha": "fcc9663f2d602dffbb446e3f24628907beeec3d0", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,54 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_TOPLEVEL_H\n+#define RUST_AST_RESOLVE_TOPLEVEL_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveTopLevel : public ResolverBase\n+{\n+public:\n+  static void go (AST::Item *item)\n+  {\n+    ResolveTopLevel resolver;\n+    item->accept_vis (resolver);\n+  };\n+\n+  ~ResolveTopLevel () {}\n+\n+  void visit (AST::Function &function)\n+  {\n+    // function_names are simple std::String identifiers so this can be a\n+    // NodeId mapping to the Function node\n+    resolver->get_name_scope ().insert (function.get_function_name (),\n+\t\t\t\t\tfunction.get_node_id ());\n+  }\n+\n+private:\n+  ResolveTopLevel () : ResolverBase (UNKNOWN_NODEID) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_TOPLEVEL_H"}, {"sha": "3cffa77d5b9e7243cc153ef3b99cd06c9e35c531", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_TYPE_H\n+#define RUST_AST_RESOLVE_TYPE_H\n+\n+#include \"rust-ast-resolve-base.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveType : public ResolverBase\n+{\n+public:\n+  static void go (AST::Type *type, NodeId parent)\n+  {\n+    ResolveType resolver (parent);\n+\n+    type->accept_vis (resolver);\n+    if (resolver.resolved_node == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (resolver.locus, \"failed to resolve type %s\",\n+\t\t       type->as_string ().c_str ());\n+      }\n+  };\n+\n+  ~ResolveType () {}\n+\n+  virtual void visit (AST::TypePath &path)\n+  {\n+    // this will need changed to handle mod/crate/use globs and look\n+    // at the segments in granularity\n+    locus = path.get_locus ();\n+    if (resolver->get_type_scope ().lookup (path.as_string (), &resolved_node))\n+      {\n+\tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n+\tresolver->insert_new_definition (path.get_node_id (),\n+\t\t\t\t\t Definition{path.get_node_id (),\n+\t\t\t\t\t\t    parent});\n+      }\n+  }\n+\n+private:\n+  ResolveType (NodeId parent) : ResolverBase (parent) {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_TYPE_H"}, {"sha": "57bd0f3d12d9e506483356790c0994fd9c987b95", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,252 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve.h\"\n+#include \"rust-ast-resolve-toplevel.h\"\n+#include \"rust-ast-resolve-item.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-tyty.h\"\n+\n+#define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      AST::PathIdentSegment seg (_X);                                          \\\n+      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n+\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n+\t\t\t\t  Linemap::predeclared_location ()));          \\\n+      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n+      segs.push_back (::std::move (typePath));                                 \\\n+      auto builtin_type                                                        \\\n+\t= new AST::TypePath (::std::move (segs),                               \\\n+\t\t\t     Linemap::predeclared_location (), false);         \\\n+      _R.push_back (builtin_type);                                             \\\n+      tyctx->insert_builtin (_TY->get_ref (), builtin_type->get_node_id (),    \\\n+\t\t\t     _TY);                                             \\\n+    }                                                                          \\\n+  while (0)\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// Resolver\n+\n+Resolver::Resolver ()\n+  : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n+    name_scope (Scope (mappings->get_current_crate ())),\n+    type_scope (Scope (mappings->get_current_crate ()))\n+{\n+  generate_builtins ();\n+}\n+\n+Resolver *\n+Resolver::get ()\n+{\n+  static Resolver *instance;\n+  if (instance == nullptr)\n+    instance = new Resolver ();\n+\n+  return instance;\n+}\n+\n+void\n+Resolver::push_new_name_rib (Rib *r)\n+{\n+  rust_assert (name_ribs.find (r->get_node_id ()) == name_ribs.end ());\n+  name_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_type_rib (Rib *r)\n+{\n+  if (type_ribs.size () == 0)\n+    global_type_node_id = r->get_node_id ();\n+\n+  rust_assert (type_ribs.find (r->get_node_id ()) == type_ribs.end ());\n+  type_ribs[r->get_node_id ()] = r;\n+}\n+\n+bool\n+Resolver::find_name_rib (NodeId id, Rib **rib)\n+{\n+  auto it = name_ribs.find (id);\n+  if (it == name_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+bool\n+Resolver::find_type_rib (NodeId id, Rib **rib)\n+{\n+  auto it = type_ribs.find (id);\n+  if (it == type_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_builtin_types (Rib *r)\n+{\n+  auto builtins = get_builtin_types ();\n+  for (auto it = builtins.begin (); it != builtins.end (); it++)\n+    r->insert_name ((*it)->as_string (), (*it)->get_node_id ());\n+}\n+\n+std::vector<AST::TypePath *> &\n+Resolver::get_builtin_types ()\n+{\n+  return builtins;\n+}\n+\n+void\n+Resolver::generate_builtins ()\n+{\n+  auto u8\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U8);\n+  auto u16\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U16);\n+  auto u32\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U32);\n+  auto i8 = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I8);\n+  auto i16\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I16);\n+  auto i32\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I32);\n+  auto rbool = new TyTy::BoolType (mappings->get_next_hir_id ());\n+\n+  MKBUILTIN_TYPE (\"u8\", builtins, u8);\n+  MKBUILTIN_TYPE (\"u16\", builtins, u16);\n+  MKBUILTIN_TYPE (\"u32\", builtins, u32);\n+  MKBUILTIN_TYPE (\"i8\", builtins, i8);\n+  MKBUILTIN_TYPE (\"i16\", builtins, i16);\n+  MKBUILTIN_TYPE (\"i32\", builtins, i32);\n+  MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n+}\n+\n+void\n+Resolver::insert_new_definition (NodeId id, Definition def)\n+{\n+  auto it = name_definitions.find (id);\n+  rust_assert (it == name_definitions.end ());\n+\n+  name_definitions[id] = def;\n+}\n+\n+bool\n+Resolver::lookup_definition (NodeId id, Definition *def)\n+{\n+  auto it = name_definitions.find (id);\n+  if (it == name_definitions.end ())\n+    return false;\n+\n+  *def = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_names.find (refId);\n+  rust_assert (it == resolved_names.end ());\n+\n+  resolved_names[refId] = defId;\n+}\n+\n+bool\n+Resolver::lookup_resolved_name (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_names.find (refId);\n+  if (it == resolved_names.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_types.find (refId);\n+  rust_assert (it == resolved_types.end ());\n+\n+  resolved_types[refId] = defId;\n+}\n+\n+bool\n+Resolver::lookup_resolved_type (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_types.find (refId);\n+  if (it == resolved_types.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+// NameResolution\n+\n+NameResolution *\n+NameResolution::get ()\n+{\n+  static NameResolution *instance;\n+  if (instance == nullptr)\n+    instance = new NameResolution ();\n+\n+  return instance;\n+}\n+\n+NameResolution::NameResolution ()\n+  : resolver (Resolver::get ()), mappings (Analysis::Mappings::get ())\n+{\n+  // these are global\n+  resolver->get_type_scope ().push (mappings->get_next_node_id ());\n+  resolver->insert_builtin_types (resolver->get_type_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+}\n+\n+void\n+NameResolution::Resolve (AST::Crate &crate)\n+{\n+  auto resolver = get ();\n+  resolver->go (crate);\n+}\n+\n+void\n+NameResolution::go (AST::Crate &crate)\n+{\n+  // setup parent scoping for names\n+  resolver->get_name_scope ().push (crate.get_node_id ());\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  // setup parent scoping for new types\n+  resolver->get_type_scope ().push (mappings->get_next_node_id ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+  // first gather the top-level namespace names then we drill down\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    ResolveTopLevel::go (it->get ());\n+\n+  // next we can drill down into the items and their scopes\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    ResolveItem::go (it->get ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "29ae0ab8ab9fc9f2bc7da81b5c2cc4a30f32f34c", "filename": "gcc/rust/resolve/rust-ast-resolve.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-ast-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_RESOLVE_H\n+#define RUST_AST_RESOLVE_H\n+\n+#include \"rust-name-resolver.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class NameResolution\n+{\n+public:\n+  static void Resolve (AST::Crate &crate);\n+\n+  static NameResolution *get ();\n+\n+  ~NameResolution () {}\n+\n+private:\n+  void go (AST::Crate &crate);\n+\n+  NameResolution ();\n+\n+  Resolver *resolver;\n+  Analysis::Mappings *mappings;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_AST_RESOLVE_H"}, {"sha": "2aa592c5e11d80e7269a3bee596a4f386d39071b", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,222 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_NAME_RESOLVER_H\n+#define RUST_NAME_RESOLVER_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class Rib\n+{\n+public:\n+  // Rusts uses local_def_ids assigned by def_collector on the AST\n+  // lets use NodeId instead\n+  Rib (CrateNum crateNum, NodeId node_id)\n+    : crate_num (crateNum), node_id (node_id)\n+  {}\n+\n+  ~Rib () {}\n+\n+  void insert_name (std::string ident, NodeId id)\n+  {\n+    mappings[ident] = id;\n+    decls_within_rib.insert (id);\n+  }\n+\n+  bool lookup_name (std::string ident, NodeId *id)\n+  {\n+    auto it = mappings.find (ident);\n+    if (it == mappings.end ())\n+      return false;\n+\n+    *id = it->second;\n+    return true;\n+  }\n+\n+  CrateNum get_crate_num () const { return crate_num; }\n+  NodeId get_node_id () const { return node_id; }\n+\n+  void iterate_decls (std::function<bool (NodeId)> cb)\n+  {\n+    for (auto it : decls_within_rib)\n+      {\n+\tif (!cb (it))\n+\t  return;\n+      }\n+  }\n+\n+private:\n+  CrateNum crate_num;\n+  NodeId node_id;\n+  std::map<std::string, NodeId> mappings;\n+  std::set<NodeId> decls_within_rib;\n+};\n+\n+class Scope\n+{\n+public:\n+  Scope (CrateNum crate_num) : crate_num (crate_num) {}\n+  ~Scope () {}\n+\n+  void insert (std::string ident, NodeId id)\n+  {\n+    peek ()->insert_name (ident, id);\n+  }\n+\n+  bool lookup (std::string ident, NodeId *id)\n+  {\n+    NodeId lookup = UNKNOWN_NODEID;\n+    iterate ([&] (Rib *r) mutable -> bool {\n+      if (r->lookup_name (ident, &lookup))\n+\treturn false;\n+      return true;\n+    });\n+\n+    *id = lookup;\n+    return lookup != UNKNOWN_NODEID;\n+  }\n+\n+  void iterate (std::function<bool (Rib *)> cb)\n+  {\n+    for (auto it = stack.rbegin (); it != stack.rend (); ++it)\n+      {\n+\tif (!cb (*it))\n+\t  return;\n+      }\n+  }\n+\n+  Rib *peek () { return stack.back (); }\n+\n+  void push (NodeId id) { stack.push_back (new Rib (get_crate_num (), id)); }\n+\n+  Rib *pop ()\n+  {\n+    Rib *r = peek ();\n+    stack.pop_back ();\n+    return r;\n+  }\n+\n+  CrateNum get_crate_num () const { return crate_num; }\n+\n+private:\n+  CrateNum crate_num;\n+  std::vector<Rib *> stack;\n+};\n+\n+// This can map simple NodeIds for names to their parent node\n+// for example:\n+//\n+// var x = y + 1;\n+//\n+// say y has node id=1 and the plus_expression has id=2\n+// then the Definition will have\n+// Definition { node=1, parent=2 }\n+// this will be used later to gather the ribs for the type inferences context\n+//\n+// if parent is UNKNOWN_NODEID then this is a root declaration\n+// say the var_decl hasa node_id=4;\n+// the parent could be a BLOCK_Expr node_id but lets make it UNKNOWN_NODE_ID so\n+// we know when it terminates\n+struct Definition\n+{\n+  NodeId node;\n+  NodeId parent;\n+  // add kind ?\n+};\n+\n+class Resolver\n+{\n+public:\n+  static Resolver *get ();\n+  ~Resolver () {}\n+\n+  // these builtin types\n+  void insert_builtin_types (Rib *r);\n+\n+  // these will be required for type resolution passes to\n+  // map back to tyty nodes\n+  std::vector<AST::TypePath *> &get_builtin_types ();\n+\n+  void push_new_name_rib (Rib *r);\n+  void push_new_type_rib (Rib *r);\n+\n+  bool find_name_rib (NodeId id, Rib **rib);\n+  bool find_type_rib (NodeId id, Rib **rib);\n+\n+  void insert_new_definition (NodeId id, Definition def);\n+  bool lookup_definition (NodeId id, Definition *def);\n+\n+  void insert_resolved_name (NodeId refId, NodeId defId);\n+  bool lookup_resolved_name (NodeId refId, NodeId *defId);\n+\n+  void insert_resolved_type (NodeId refId, NodeId defId);\n+  bool lookup_resolved_type (NodeId refId, NodeId *defId);\n+\n+  // proxy for scoping\n+  Scope &get_name_scope () { return name_scope; }\n+  Scope &get_type_scope () { return type_scope; }\n+\n+  NodeId get_global_type_node_id () { return global_type_node_id; }\n+\n+private:\n+  Resolver ();\n+\n+  void generate_builtins ();\n+\n+  Analysis::Mappings *mappings;\n+  TypeCheckContext *tyctx;\n+\n+  std::vector<AST::TypePath *> builtins;\n+\n+  Scope name_scope;\n+  Scope type_scope;\n+\n+  NodeId global_type_node_id;\n+\n+  // map a AST Node to a Rib\n+  std::map<NodeId, Rib *> name_ribs;\n+  std::map<NodeId, Rib *> type_ribs;\n+\n+  // map any Node to its Definition\n+  // ie any name or type usage\n+  std::map<NodeId, Definition> name_definitions;\n+\n+  // Rust uses DefIds to namespace these under a crate_num\n+  // but then it uses the def_collector to assign local_defids\n+  // to each ast node as well. not sure if this is going to fit\n+  // with gcc very well to compile a full crate in one go but we will\n+  // see.\n+\n+  // these are of the form ref->Def-NodeId\n+  // we need two namespaces one for names and ones for types\n+  std::map<NodeId, NodeId> resolved_names;\n+  std::map<NodeId, NodeId> resolved_types;\n+\n+  std::map<NodeId, std::set<NodeId> > nameDefNodeIdToRibs;\n+  std::map<NodeId, std::set<NodeId> > typeDefNodeIdToRibs;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_NAME_RESOLVER_H"}, {"sha": "17ff24ae5d799e9199dd3536a4caf6a5fc66ef92", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 77, "deletions": 14, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -1,5 +1,23 @@\n-#include \"rust-session-manager.h\"\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+// #include \"rust-session-manager.h\"\n \n+#include \"rust-session-manager.h\"\n #include \"rust-diagnostics.h\"\n #include \"diagnostic.h\"\n #include \"input.h\"\n@@ -8,17 +26,15 @@\n #include \"tm.h\"\n #include \"tm_p.h\"\n \n+#include \"rust-target.h\"\n+\n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n-#include \"rust-scan.h\"\n-#include \"rust-name-resolution.h\"\n-#include \"rust-type-resolution.h\"\n-#include \"rust-compile.h\"\n #include \"rust-macro-expand.h\"\n-\n-#include \"rust-target.h\"\n-\n-#include <algorithm>\n+#include \"rust-ast-resolve.h\"\n+#include \"rust-ast-lower.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-compile.h\"\n \n extern Linemap *\n rust_get_linemap ();\n@@ -381,6 +397,10 @@ Session::enable_dump (std::string arg)\n       // return false;\n       options.dump_option = CompileOptions::TARGET_OPTION_DUMP;\n     }\n+  else if (arg == \"hir\")\n+    {\n+      options.dump_option = CompileOptions::HIR_DUMP;\n+    }\n   else if (arg == \"\")\n     {\n       rust_error_at (Location (), \"dump option was not given a name. choose \"\n@@ -405,6 +425,7 @@ Session::parse_files (int num_files, const char **files)\n {\n   for (int i = 0; i < num_files; i++)\n     {\n+      printf (\"Attempting to parse file: %s\\n\", files[i]);\n       parse_file (files[i]);\n     }\n   /* TODO: should semantic analysis be dealed with here? or per file? for now,\n@@ -431,6 +452,10 @@ Session::parse_file (const char *filename)\n   // generate crate from parser\n   auto parsed_crate = parser.parse_crate ();\n \n+  // setup the mappings for this AST\n+  auto mappings = Analysis::Mappings::get ();\n+  mappings->insert_ast_crate (&parsed_crate);\n+\n   // give a chance to give some debug\n   switch (options.dump_option)\n     {\n@@ -504,11 +529,35 @@ Session::parse_file (const char *filename)\n       // TODO: what do I dump here? resolved names? AST with resolved names?\n     }\n \n+  if (saw_errors ())\n+    return;\n+\n+  // lower AST to HIR\n+  HIR::Crate hir = lower_ast (parsed_crate);\n+  if (options.dump_option == CompileOptions::HIR_DUMP)\n+    {\n+      fprintf (stderr, \"%s\", hir.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (saw_errors ())\n+    return;\n+\n+  // type resolve\n+  type_resolution (hir);\n+\n   if (saw_errors ())\n     return;\n \n   // do compile\n-  Compile::Compilation::Compile (parsed_crate, backend);\n+  Compile::Context ctx (backend);\n+  Compile::CompileCrate::Compile (hir, &ctx);\n+\n+  if (saw_errors ())\n+    return;\n+\n+  // pass to GCC\n+  ctx.write_to_backend ();\n }\n \n // TODO: actually implement method\n@@ -736,13 +785,27 @@ void\n Session::resolution (AST::Crate &crate)\n {\n   fprintf (stderr, \"started name resolution\\n\");\n-  Analysis::TopLevelScan toplevel (crate);\n-  // Name resolution must be in front of type resolution\n-  Analysis::NameResolution::Resolve (crate, toplevel);\n-  Analysis::TypeResolution::Resolve (crate, toplevel);\n+  Resolver::NameResolution::Resolve (crate);\n   fprintf (stderr, \"finished name resolution\\n\");\n }\n \n+HIR::Crate\n+Session::lower_ast (AST::Crate &crate)\n+{\n+  fprintf (stderr, \"started lowering AST\\n\");\n+  auto hir = HIR::ASTLowering::Resolve (crate);\n+  fprintf (stderr, \"finished lowering AST\\n\");\n+  return hir;\n+}\n+\n+void\n+Session::type_resolution (HIR::Crate &crate)\n+{\n+  fprintf (stderr, \"started type resolution\\n\");\n+  Resolver::TypeResolution::Resolve (crate);\n+  fprintf (stderr, \"finished type resolution\\n\");\n+}\n+\n void\n TargetOptions::dump_target_options () const\n {"}, {"sha": "4836cc8dcbf5125969d3f8f286c85813adf7cc75", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -1,6 +1,24 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+// #include \"rust-session-manager.h\"\n+\n #ifndef RUST_SESSION_MANAGER_H\n #define RUST_SESSION_MANAGER_H\n-// Session manager - controls compiler session.\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -11,12 +29,6 @@\n #include \"rust-linemap.h\"\n #include \"rust-backend.h\"\n \n-#include <string>\n-#include <unordered_map>\n-#include <unordered_set>\n-#include <vector>\n-#include <utility>\n-\n namespace Rust {\n // parser forward decl\n template <typename ManagedTokenSource> class Parser;\n@@ -25,14 +37,18 @@ class Lexer;\n namespace AST {\n struct Crate;\n }\n+// crate forward decl\n+namespace HIR {\n+struct Crate;\n+}\n \n /* Data related to target, most useful for conditional compilation and\n  * whatever. */\n struct TargetOptions\n {\n   /* TODO: maybe make private and access through helpers to allow changes to\n    * impl */\n-  std::unordered_map<std::string, std::unordered_set<std::string>> features;\n+  std::unordered_map<std::string, std::unordered_set<std::string> > features;\n \n public:\n   // Returns whether a key is defined in the feature set.\n@@ -160,6 +176,7 @@ struct CompileOptions\n     EXPANSION_DUMP,\n     RESOLUTION_DUMP,\n     TARGET_OPTION_DUMP,\n+    HIR_DUMP,\n     // TODO: add more?\n   } dump_option;\n \n@@ -227,6 +244,11 @@ struct Session\n    * Performs name resolution and type resolution, maybe complete gated\n    * feature checking, maybe create buffered lints in future. */\n   void resolution (AST::Crate &crate);\n+  /* This lowers the AST down to HIR and assigns all mappings from AST\n+   * NodeIds back to HirIds */\n+  HIR::Crate lower_ast (AST::Crate &crate);\n+  /* This adds the type resolution process */\n+  void type_resolution (HIR::Crate &crate);\n };\n } // namespace Rust\n "}, {"sha": "26c9b335c76648eef4a795e7a95ab501d5137278", "filename": "gcc/rust/rust-system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -40,6 +40,7 @@\n #include <string>\n #include <deque>\n #include <functional>\n+#include <memory>\n \n // Rust frontend requires C++11 minimum, so will have unordered_map and set\n #include <unordered_map>\n@@ -56,7 +57,7 @@\n #include \"coretypes.h\"\n \n #include \"diagnostic-core.h\" /* For error_at and friends.  */\n-#include \"intl.h\"\t    /* For _().  */\n+#include \"intl.h\"\t     /* For _().  */\n \n // When using gcc, rust_assert is just gcc_assert.\n #define rust_assert(EXPR) gcc_assert (EXPR)"}, {"sha": "78afff956abb3c483de3ae69ea44b1a0cf8439f3", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,256 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_BASE\n+#define RUST_HIR_TYPE_CHECK_BASE\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-name-resolver.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// base class to allow derivatives to overload as needed\n+class TypeCheckBase : public HIR::HIRVisitor\n+{\n+public:\n+  virtual ~TypeCheckBase () {}\n+\n+  // visitor impl\n+  // rust-ast.h\n+  //  virtual void visit(AttrInput& attr_input);\n+  //  virtual void visit(TokenTree& token_tree);\n+  //  virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (HIR::Token &tok) {}\n+  virtual void visit (HIR::DelimTokenTree &delim_tok_tree) {}\n+  virtual void visit (HIR::AttrInputMetaItemContainer &input) {}\n+  //  virtual void visit(MetaItem& meta_item) {}\n+  //  void vsit(Stmt& stmt) {}\n+  //  virtual void visit(Expr& expr) {}\n+  virtual void visit (HIR::IdentifierExpr &ident_expr) {}\n+  //  virtual void visit(Pattern& pattern) {}\n+  //  virtual void visit(Type& type) {}\n+  //  virtual void visit(TypeParamBound& type_param_bound) {}\n+  virtual void visit (HIR::Lifetime &lifetime) {}\n+  //  virtual void visit(GenericParam& generic_param) {}\n+  virtual void visit (HIR::LifetimeParam &lifetime_param) {}\n+  //  virtual void visit(TraitItem& trait_item) {}\n+  //  virtual void visit(InherentImplItem& inherent_impl_item) {}\n+  //  virtual void visit(TraitImplItem& trait_impl_item) {}\n+  virtual void visit (HIR::MacroInvocationSemi &macro) {}\n+\n+  // rust-path.h\n+  virtual void visit (HIR::PathInExpression &path) {}\n+  virtual void visit (HIR::TypePathSegment &segment) {}\n+  virtual void visit (HIR::TypePathSegmentGeneric &segment) {}\n+  virtual void visit (HIR::TypePathSegmentFunction &segment) {}\n+  virtual void visit (HIR::TypePath &path) {}\n+  virtual void visit (HIR::QualifiedPathInExpression &path) {}\n+  virtual void visit (HIR::QualifiedPathInType &path) {}\n+\n+  // rust-expr.h\n+  virtual void visit (HIR::LiteralExpr &expr) {}\n+  virtual void visit (HIR::AttrInputLiteral &attr_input) {}\n+  virtual void visit (HIR::MetaItemLitExpr &meta_item) {}\n+  virtual void visit (HIR::MetaItemPathLit &meta_item) {}\n+  virtual void visit (HIR::BorrowExpr &expr) {}\n+  virtual void visit (HIR::DereferenceExpr &expr) {}\n+  virtual void visit (HIR::ErrorPropagationExpr &expr) {}\n+  virtual void visit (HIR::NegationExpr &expr) {}\n+  virtual void visit (HIR::ArithmeticOrLogicalExpr &expr) {}\n+  virtual void visit (HIR::ComparisonExpr &expr) {}\n+  virtual void visit (HIR::LazyBooleanExpr &expr) {}\n+  virtual void visit (HIR::TypeCastExpr &expr) {}\n+  virtual void visit (HIR::AssignmentExpr &expr) {}\n+  virtual void visit (HIR::CompoundAssignmentExpr &expr) {}\n+  virtual void visit (HIR::GroupedExpr &expr) {}\n+  //  virtual void visit(ArrayElems& elems) {}\n+  virtual void visit (HIR::ArrayElemsValues &elems) {}\n+  virtual void visit (HIR::ArrayElemsCopied &elems) {}\n+  virtual void visit (HIR::ArrayExpr &expr) {}\n+  virtual void visit (HIR::ArrayIndexExpr &expr) {}\n+  virtual void visit (HIR::TupleExpr &expr) {}\n+  virtual void visit (HIR::TupleIndexExpr &expr) {}\n+  virtual void visit (HIR::StructExprStruct &expr) {}\n+  //  virtual void visit(StructExprField& field) {}\n+  virtual void visit (HIR::StructExprFieldIdentifier &field) {}\n+  virtual void visit (HIR::StructExprFieldIdentifierValue &field) {}\n+  virtual void visit (HIR::StructExprFieldIndexValue &field) {}\n+  virtual void visit (HIR::StructExprStructFields &expr) {}\n+  virtual void visit (HIR::StructExprStructBase &expr) {}\n+  virtual void visit (HIR::StructExprTuple &expr) {}\n+  virtual void visit (HIR::StructExprUnit &expr) {}\n+  //  virtual void visit(EnumExprField& field) {}\n+  virtual void visit (HIR::EnumExprFieldIdentifier &field) {}\n+  virtual void visit (HIR::EnumExprFieldIdentifierValue &field) {}\n+  virtual void visit (HIR::EnumExprFieldIndexValue &field) {}\n+  virtual void visit (HIR::EnumExprStruct &expr) {}\n+  virtual void visit (HIR::EnumExprTuple &expr) {}\n+  virtual void visit (HIR::EnumExprFieldless &expr) {}\n+  virtual void visit (HIR::CallExpr &expr) {}\n+  virtual void visit (HIR::MethodCallExpr &expr) {}\n+  virtual void visit (HIR::FieldAccessExpr &expr) {}\n+  virtual void visit (HIR::ClosureExprInner &expr) {}\n+  virtual void visit (HIR::BlockExpr &expr) {}\n+  virtual void visit (HIR::ClosureExprInnerTyped &expr) {}\n+  virtual void visit (HIR::ContinueExpr &expr) {}\n+  virtual void visit (HIR::BreakExpr &expr) {}\n+  virtual void visit (HIR::RangeFromToExpr &expr) {}\n+  virtual void visit (HIR::RangeFromExpr &expr) {}\n+  virtual void visit (HIR::RangeToExpr &expr) {}\n+  virtual void visit (HIR::RangeFullExpr &expr) {}\n+  virtual void visit (HIR::RangeFromToInclExpr &expr) {}\n+  virtual void visit (HIR::RangeToInclExpr &expr) {}\n+  virtual void visit (HIR::ReturnExpr &expr) {}\n+  virtual void visit (HIR::UnsafeBlockExpr &expr) {}\n+  virtual void visit (HIR::LoopExpr &expr) {}\n+  virtual void visit (HIR::WhileLoopExpr &expr) {}\n+  virtual void visit (HIR::WhileLetLoopExpr &expr) {}\n+  virtual void visit (HIR::ForLoopExpr &expr) {}\n+  virtual void visit (HIR::IfExpr &expr) {}\n+  virtual void visit (HIR::IfExprConseqElse &expr) {}\n+  virtual void visit (HIR::IfExprConseqIf &expr) {}\n+  virtual void visit (HIR::IfExprConseqIfLet &expr) {}\n+  virtual void visit (HIR::IfLetExpr &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqElse &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqIf &expr) {}\n+  virtual void visit (HIR::IfLetExprConseqIfLet &expr) {}\n+  //  virtual void visit(MatchCase& match_case) {}\n+  // virtual void visit (HIR::MatchCaseBlockExpr &match_case) {}\n+  // virtual void visit (HIR::MatchCaseExpr &match_case) {}\n+  virtual void visit (HIR::MatchExpr &expr) {}\n+  virtual void visit (HIR::AwaitExpr &expr) {}\n+  virtual void visit (HIR::AsyncBlockExpr &expr) {}\n+\n+  // rust-item.h\n+  virtual void visit (HIR::TypeParam &param) {}\n+  //  virtual void visit(WhereClauseItem& item) {}\n+  virtual void visit (HIR::LifetimeWhereClauseItem &item) {}\n+  virtual void visit (HIR::TypeBoundWhereClauseItem &item) {}\n+  virtual void visit (HIR::Method &method) {}\n+  virtual void visit (HIR::ModuleBodied &module) {}\n+  virtual void visit (HIR::ModuleNoBody &module) {}\n+  virtual void visit (HIR::ExternCrate &crate) {}\n+  //  virtual void visit(UseTree& use_tree) {}\n+  virtual void visit (HIR::UseTreeGlob &use_tree) {}\n+  virtual void visit (HIR::UseTreeList &use_tree) {}\n+  virtual void visit (HIR::UseTreeRebind &use_tree) {}\n+  virtual void visit (HIR::UseDeclaration &use_decl) {}\n+  virtual void visit (HIR::Function &function) {}\n+  virtual void visit (HIR::TypeAlias &type_alias) {}\n+  virtual void visit (HIR::StructStruct &struct_item) {}\n+  virtual void visit (HIR::TupleStruct &tuple_struct) {}\n+  virtual void visit (HIR::EnumItem &item) {}\n+  virtual void visit (HIR::EnumItemTuple &item) {}\n+  virtual void visit (HIR::EnumItemStruct &item) {}\n+  virtual void visit (HIR::EnumItemDiscriminant &item) {}\n+  virtual void visit (HIR::Enum &enum_item) {}\n+  virtual void visit (HIR::Union &union_item) {}\n+  virtual void visit (HIR::ConstantItem &const_item) {}\n+  virtual void visit (HIR::StaticItem &static_item) {}\n+  virtual void visit (HIR::TraitItemFunc &item) {}\n+  virtual void visit (HIR::TraitItemMethod &item) {}\n+  virtual void visit (HIR::TraitItemConst &item) {}\n+  virtual void visit (HIR::TraitItemType &item) {}\n+  virtual void visit (HIR::Trait &trait) {}\n+  virtual void visit (HIR::InherentImpl &impl) {}\n+  virtual void visit (HIR::TraitImpl &impl) {}\n+  //  virtual void visit(ExternalItem& item) {}\n+  virtual void visit (HIR::ExternalStaticItem &item) {}\n+  virtual void visit (HIR::ExternalFunctionItem &item) {}\n+  virtual void visit (HIR::ExternBlock &block) {}\n+\n+  // rust-macro.h\n+  virtual void visit (HIR::MacroMatchFragment &match) {}\n+  virtual void visit (HIR::MacroMatchRepetition &match) {}\n+  virtual void visit (HIR::MacroMatcher &matcher) {}\n+  virtual void visit (HIR::MacroRulesDefinition &rules_def) {}\n+  virtual void visit (HIR::MacroInvocation &macro_invoc) {}\n+  virtual void visit (HIR::MetaItemPath &meta_item) {}\n+  virtual void visit (HIR::MetaItemSeq &meta_item) {}\n+  virtual void visit (HIR::MetaWord &meta_item) {}\n+  virtual void visit (HIR::MetaNameValueStr &meta_item) {}\n+  virtual void visit (HIR::MetaListPaths &meta_item) {}\n+  virtual void visit (HIR::MetaListNameValueStr &meta_item) {}\n+\n+  // rust-pattern.h\n+  virtual void visit (HIR::LiteralPattern &pattern) {}\n+  virtual void visit (HIR::IdentifierPattern &pattern) {}\n+  virtual void visit (HIR::WildcardPattern &pattern) {}\n+  //  virtual void visit(RangePatternBound& bound) {}\n+  virtual void visit (HIR::RangePatternBoundLiteral &bound) {}\n+  virtual void visit (HIR::RangePatternBoundPath &bound) {}\n+  virtual void visit (HIR::RangePatternBoundQualPath &bound) {}\n+  virtual void visit (HIR::RangePattern &pattern) {}\n+  virtual void visit (HIR::ReferencePattern &pattern) {}\n+  //  virtual void visit(StructPatternField& field) {}\n+  virtual void visit (HIR::StructPatternFieldTuplePat &field) {}\n+  virtual void visit (HIR::StructPatternFieldIdentPat &field) {}\n+  virtual void visit (HIR::StructPatternFieldIdent &field) {}\n+  virtual void visit (HIR::StructPattern &pattern) {}\n+  //  virtual void visit(TupleStructItems& tuple_items) {}\n+  virtual void visit (HIR::TupleStructItemsNoRange &tuple_items) {}\n+  virtual void visit (HIR::TupleStructItemsRange &tuple_items) {}\n+  virtual void visit (HIR::TupleStructPattern &pattern) {}\n+  //  virtual void visit(TuplePatternItems& tuple_items) {}\n+  virtual void visit (HIR::TuplePatternItemsMultiple &tuple_items) {}\n+  virtual void visit (HIR::TuplePatternItemsRanged &tuple_items) {}\n+  virtual void visit (HIR::TuplePattern &pattern) {}\n+  virtual void visit (HIR::GroupedPattern &pattern) {}\n+  virtual void visit (HIR::SlicePattern &pattern) {}\n+\n+  // rust-stmt.h\n+  virtual void visit (HIR::EmptyStmt &stmt) {}\n+  virtual void visit (HIR::LetStmt &stmt) {}\n+  virtual void visit (HIR::ExprStmtWithoutBlock &stmt) {}\n+  virtual void visit (HIR::ExprStmtWithBlock &stmt) {}\n+\n+  // rust-type.h\n+  virtual void visit (HIR::TraitBound &bound) {}\n+  virtual void visit (HIR::ImplTraitType &type) {}\n+  virtual void visit (HIR::TraitObjectType &type) {}\n+  virtual void visit (HIR::ParenthesisedType &type) {}\n+  virtual void visit (HIR::ImplTraitTypeOneBound &type) {}\n+  virtual void visit (HIR::TraitObjectTypeOneBound &type) {}\n+  virtual void visit (HIR::TupleType &type) {}\n+  virtual void visit (HIR::NeverType &type) {}\n+  virtual void visit (HIR::RawPointerType &type) {}\n+  virtual void visit (HIR::ReferenceType &type) {}\n+  virtual void visit (HIR::ArrayType &type) {}\n+  virtual void visit (HIR::SliceType &type) {}\n+  virtual void visit (HIR::InferredType &type) {}\n+  virtual void visit (HIR::BareFunctionType &type) {}\n+\n+protected:\n+  TypeCheckBase ()\n+    : mappings (Analysis::Mappings::get ()), resolver (Resolver::get ()),\n+      context (TypeCheckContext::get ())\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver *resolver;\n+  TypeCheckContext *context;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_BASE"}, {"sha": "32a5d8b2da45e84d44f50a79196dbabbb1e8388f", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,188 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_EXPR\n+#define RUST_HIR_TYPE_CHECK_EXPR\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-call.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckExpr : public TypeCheckBase\n+{\n+public:\n+  static TyTy::TyBase *Resolve (HIR::Expr *expr)\n+  {\n+    TypeCheckExpr resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.infered != nullptr)\n+      resolver.context->insert_type (expr->get_mappings ().get_hirid (),\n+\t\t\t\t     resolver.infered);\n+\n+    return resolver.infered;\n+  }\n+\n+  void visit (HIR::ReturnExpr &expr)\n+  {\n+    auto ret = context->peek_return_type ();\n+    rust_assert (ret != nullptr);\n+\n+    auto expr_ty = TypeCheckExpr::Resolve (expr.get_expr ());\n+    infered = ret->combine (expr_ty);\n+  }\n+\n+  void visit (HIR::CallExpr &expr)\n+  {\n+    auto fn = expr.get_fnexpr ();\n+    auto fn_node_id = fn->get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id;\n+    if (!resolver->lookup_resolved_name (fn_node_id, &ref_node_id))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"Failed to lookup reference for node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref_node_id, &ref))\n+      {\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    // check if this has a type\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (ref, &lookup))\n+      {\n+\t// FIXME we need to be able to lookup the location info for the\n+\t// reference here\n+\trust_error_at (expr.get_locus (), \"consider giving this a type: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    infered = TyTy::TypeCheckCallExpr::go (lookup, expr);\n+  }\n+\n+  void visit (HIR::AssignmentExpr &expr)\n+  {\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+    infered = lhs->combine (rhs);\n+  }\n+\n+  void visit (HIR::IdentifierExpr &expr)\n+  {\n+    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id;\n+    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"Failed to lookup reference for node: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // these ref_node_ids will resolve to a pattern declaration but we are\n+    // interested in the definition that this refers to get the parent id\n+    Definition def;\n+    if (!resolver->lookup_definition (ref_node_id, &def))\n+      {\n+\trust_error_at (expr.get_locus (), \"unknown reference\");\n+\treturn;\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       def.parent, &ref))\n+      {\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    // the base reference for this name _must_ have a type set\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (ref, &lookup))\n+      {\n+\t// FIXME we need to be able to lookup the location info for the\n+\t// reference here\n+\trust_error_at (expr.get_locus (), \"consider giving this a type: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // FIXME this needs to be cloned for memory management later on\n+    infered = lookup;\n+  }\n+\n+  void visit (HIR::LiteralExpr &expr)\n+  {\n+    switch (expr.get_lit_type ())\n+      {\n+\tcase HIR::Literal::LitType::INT: {\n+\t  // FIXME:\n+\t  // assume i32 let the combiner functions figure it out\n+\t  // this should look at the suffix of the literal value to check\n+\t  auto ok = context->lookup_builtin (\"i32\", &infered);\n+\t  rust_assert (ok);\n+\t}\n+\tbreak;\n+\n+\tcase HIR::Literal::LitType::BOOL: {\n+\t  auto ok = context->lookup_builtin (\"bool\", &infered);\n+\t  rust_assert (ok);\n+\t}\n+\tbreak;\n+\n+      default:\n+\tgcc_unreachable ();\n+\tbreak;\n+      }\n+  }\n+\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr)\n+  {\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n+\n+    infered = lhs->combine (rhs);\n+  }\n+\n+private:\n+  TypeCheckExpr () : TypeCheckBase (), infered (nullptr) {}\n+\n+  TyTy::TyBase *infered;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_EXPR"}, {"sha": "ab964a9bd6f97c23eb9ccbfdb20f9b39dc3cb238", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_ITEM\n+#define RUST_HIR_TYPE_CHECK_ITEM\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-stmt.h\"\n+#include \"rust-tyty-visitor.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveFnType : public TyTy::TyVisitor\n+{\n+public:\n+  ResolveFnType (TyTy::TyBase *base) : base (base), state (nullptr) {}\n+\n+  TyTy::TyBase *go ()\n+  {\n+    base->accept_vis (*this);\n+    if (state == nullptr)\n+      gcc_unreachable ();\n+\n+    return state;\n+  }\n+\n+  void visit (TyTy::FnType &type) override { state = type.return_type (); }\n+\n+private:\n+  TyTy::TyBase *base;\n+  TyTy::TyBase *state;\n+};\n+\n+class TypeCheckItem : public TypeCheckBase\n+{\n+public:\n+  static void Resolve (HIR::Item *item)\n+  {\n+    TypeCheckItem resolver;\n+    item->accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::Function &function)\n+  {\n+    TyTy::TyBase *fnType;\n+    if (!context->lookup_type (function.get_mappings ().get_hirid (), &fnType))\n+      {\n+\trust_error_at (function.locus, \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    // need to get the return type from this\n+    ResolveFnType resolve_fn_type (fnType);\n+    context->push_return_type (resolve_fn_type.go ());\n+\n+    // walk statements to make sure they are all typed correctly and they match\n+    // up\n+    function.function_body->iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+      TypeCheckStmt::Resolve (s);\n+      return true;\n+    });\n+\n+    context->pop_return_type ();\n+  }\n+\n+private:\n+  TypeCheckItem () : TypeCheckBase () {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_ITEM"}, {"sha": "ccf11388cd44131a75cecfc9f8956622f41fca57", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,91 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_STMT\n+#define RUST_HIR_TYPE_CHECK_STMT\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckStmt : public TypeCheckBase\n+{\n+public:\n+  static void Resolve (HIR::Stmt *stmt)\n+  {\n+    TypeCheckStmt resolver;\n+    stmt->accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::ExprStmtWithoutBlock &stmt)\n+  {\n+    TypeCheckExpr::Resolve (stmt.get_expr ());\n+  }\n+\n+  void visit (HIR::LetStmt &stmt)\n+  {\n+    TyTy::TyBase *init_expr_ty = nullptr;\n+    if (stmt.has_init_expr ())\n+      init_expr_ty = TypeCheckExpr::Resolve (stmt.get_init_expr ());\n+\n+    TyTy::TyBase *specified_ty = nullptr;\n+    if (stmt.has_type ())\n+      specified_ty = TypeCheckType::Resolve (stmt.get_type ());\n+\n+    // let x:i32 = 123;\n+    if (specified_ty != nullptr && init_expr_ty != nullptr)\n+      {\n+\tcontext->insert_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t      specified_ty->combine (init_expr_ty));\n+      }\n+    else\n+      {\n+\t// let x:i32;\n+\tif (specified_ty != nullptr)\n+\t  {\n+\t    context->insert_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t  specified_ty);\n+\t  }\n+\t// let x = 123;\n+\telse if (init_expr_ty != nullptr)\n+\t  {\n+\t    context->insert_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t  init_expr_ty);\n+\t  }\n+\t// let x;\n+\telse\n+\t  {\n+\t    context->insert_type (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t  new TyTy::InferType (\n+\t\t\t\t    stmt.get_mappings ().get_hirid ()));\n+\t  }\n+      }\n+  }\n+\n+private:\n+  TypeCheckStmt () : TypeCheckBase () {}\n+}; // namespace Resolver\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_STMT"}, {"sha": "25e6c0bb9b583c8c466db05c682193415ccbabd4", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,72 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_TOPLEVEL\n+#define RUST_HIR_TYPE_CHECK_TOPLEVEL\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckTopLevel : public TypeCheckBase\n+{\n+public:\n+  static void Resolve (HIR::Item *item)\n+  {\n+    TypeCheckTopLevel resolver;\n+    item->accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::Function &function)\n+  {\n+    TyTy::TyBase *ret_type = nullptr;\n+    if (!function.has_function_return_type ())\n+      ret_type = new TyTy::UnitType (function.get_mappings ().get_hirid ());\n+    else\n+      ret_type = TypeCheckType::Resolve (function.return_type.get ());\n+\n+    std::vector<TyTy::ParamType *> params;\n+    for (auto &param : function.function_params)\n+      {\n+\t// get the name as well required for later on\n+\tauto param_type = TypeCheckType::Resolve (param.type.get ());\n+\tauto param_tyty\n+\t  = new TyTy::ParamType (param.get_mappings ()->get_hirid (),\n+\t\t\t\t param.param_name->as_string (), param_type);\n+\tparams.push_back (param_tyty);\n+\n+\tcontext->insert_type (param.get_mappings ()->get_hirid (), param_tyty);\n+      }\n+\n+    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t\t    params, ret_type);\n+    context->insert_type (function.get_mappings ().get_hirid (), fnType);\n+  }\n+\n+private:\n+  TypeCheckTopLevel () : TypeCheckBase () {}\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_TOPLEVEL"}, {"sha": "beab77a838d11d8a746e2f70664f15f25b3e0d89", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,82 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK_TYPE\n+#define RUST_HIR_TYPE_CHECK_TYPE\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckType : public TypeCheckBase\n+{\n+public:\n+  static TyTy::TyBase *Resolve (HIR::Type *type)\n+  {\n+    TypeCheckType resolver;\n+    type->accept_vis (resolver);\n+\n+    if (resolver.translated != nullptr)\n+      resolver.context->insert_type (type->get_mappings ().get_hirid (),\n+\t\t\t\t     resolver.translated);\n+\n+    return resolver.translated;\n+  }\n+\n+  virtual void visit (HIR::TypePath &path)\n+  {\n+    // check if this is already defined or not\n+    if (context->lookup_type (path.get_mappings ().get_hirid (), &translated))\n+      return;\n+\n+    // lookup the Node this resolves to\n+    NodeId ref;\n+    if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t\t &ref))\n+      {\n+\trust_error_at (path.get_locus (), \"Type was not resolved\");\n+\treturn;\n+      }\n+\n+    // reverse lookup the hir node from ast node id\n+    HirId hir_lookup;\n+    if (context->lookup_type_by_node_id (ref, &hir_lookup))\n+      {\n+\t// we got an HIR node\n+\tif (context->lookup_type (hir_lookup, &translated))\n+\t  return;\n+      }\n+\n+    // this might be a struct type (TyTy::ADT) reference\n+    // TODO\n+    printf (\"UNREACHABLE %s\\n\", path.as_string ().c_str ());\n+    gcc_unreachable ();\n+  }\n+\n+private:\n+  TypeCheckType () : TypeCheckBase (), translated (nullptr) {}\n+\n+  TyTy::TyBase *translated;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK_TYPE"}, {"sha": "f9dbe495484146ffba5c57863d682539428a3696", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-type-check-toplevel.h\"\n+#include \"rust-hir-type-check-item.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeResolution::Resolve (HIR::Crate &crate)\n+{\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    TypeCheckTopLevel::Resolve (it->get ());\n+\n+  for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n+    TypeCheckItem::Resolve (it->get ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "6deecddfd747b3d6287128a3dbdbaad95bc8e90f", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TYPE_CHECK\n+#define RUST_HIR_TYPE_CHECK\n+\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeCheckContext\n+{\n+public:\n+  static TypeCheckContext *get ();\n+\n+  ~TypeCheckContext ();\n+\n+  bool lookup_builtin (std::string name, TyTy::TyBase **type);\n+  void insert_builtin (HirId id, NodeId ref, TyTy::TyBase *type);\n+\n+  void insert_type (HirId id, TyTy::TyBase *type);\n+  bool lookup_type (HirId id, TyTy::TyBase **type);\n+\n+  void insert_type_by_node_id (NodeId ref, HirId id);\n+  bool lookup_type_by_node_id (NodeId ref, HirId *id);\n+\n+  TyTy::TyBase *peek_return_type ();\n+  void push_return_type (TyTy::TyBase *return_type);\n+  void pop_return_type ();\n+\n+private:\n+  TypeCheckContext ();\n+\n+  std::map<NodeId, HirId> node_id_refs;\n+  std::map<HirId, TyTy::TyBase *> resolved;\n+  std::vector<std::unique_ptr<TyTy::TyBase> > builtins;\n+  std::vector<TyTy::TyBase *> return_type_stack;\n+};\n+\n+class TypeResolution\n+{\n+public:\n+  static void Resolve (HIR::Crate &crate);\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TYPE_CHECK"}, {"sha": "8869e34b36ca5bfeec8a63f5bd3858a54899906a", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,116 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TypeCheckContext *\n+TypeCheckContext::get ()\n+{\n+  static TypeCheckContext *instance;\n+  if (instance == nullptr)\n+    instance = new TypeCheckContext ();\n+\n+  return instance;\n+}\n+\n+TypeCheckContext::TypeCheckContext () {}\n+\n+TypeCheckContext::~TypeCheckContext () {}\n+\n+bool\n+TypeCheckContext::lookup_builtin (std::string name, TyTy::TyBase **type)\n+{\n+  for (auto &builtin : builtins)\n+    {\n+      if (name.compare (builtin->as_string ()) == 0)\n+\t{\n+\t  *type = builtin.get ();\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+void\n+TypeCheckContext::insert_builtin (HirId id, NodeId ref, TyTy::TyBase *type)\n+{\n+  node_id_refs[ref] = id;\n+  resolved[id] = type;\n+  builtins.push_back (std::unique_ptr<TyTy::TyBase> (type));\n+}\n+\n+void\n+TypeCheckContext::insert_type (HirId id, TyTy::TyBase *type)\n+{\n+  rust_assert (resolved.find (id) == resolved.end ());\n+  rust_assert (type != nullptr);\n+  resolved[id] = type;\n+}\n+\n+bool\n+TypeCheckContext::lookup_type (HirId id, TyTy::TyBase **type)\n+{\n+  auto it = resolved.find (id);\n+  if (it == resolved.end ())\n+    return false;\n+\n+  *type = it->second;\n+  return true;\n+}\n+\n+void\n+TypeCheckContext::insert_type_by_node_id (NodeId ref, HirId id)\n+{\n+  rust_assert (node_id_refs.find (ref) == node_id_refs.end ());\n+  node_id_refs[ref] = id;\n+}\n+\n+bool\n+TypeCheckContext::lookup_type_by_node_id (NodeId ref, HirId *id)\n+{\n+  auto it = node_id_refs.find (ref);\n+  if (it == node_id_refs.end ())\n+    return false;\n+\n+  *id = it->second;\n+  return true;\n+}\n+\n+TyTy::TyBase *\n+TypeCheckContext::peek_return_type ()\n+{\n+  return return_type_stack.back ();\n+}\n+\n+void\n+TypeCheckContext::push_return_type (TyTy::TyBase *return_type)\n+{\n+  return_type_stack.push_back (return_type);\n+}\n+\n+void\n+TypeCheckContext::pop_return_type ()\n+{\n+  return_type_stack.pop_back ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "d1341df6472d85142860cf8a164333878bc437d8", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,53 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_CALL\n+#define RUST_TYTY_CALL\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class TypeCheckCallExpr : private TyVisitor\n+{\n+public:\n+  static TyBase *go (TyBase *ref, HIR::CallExpr &call)\n+  {\n+    TypeCheckCallExpr checker (call);\n+    ref->accept_vis (checker);\n+    return checker.resolved;\n+  }\n+  ~TypeCheckCallExpr () {}\n+\n+  void visit (FnType &type) override;\n+\n+private:\n+  TypeCheckCallExpr (HIR::CallExpr &c) : resolved (nullptr), call (c) {}\n+\n+  TyBase *resolved;\n+  HIR::CallExpr &call;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_CALL"}, {"sha": "372229bfd4f782432cc8c721b7d388c3ca4aaeaa", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,241 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_RULES\n+#define RUST_TYTY_RULES\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseRules : public TyVisitor\n+{\n+public:\n+  virtual ~BaseRules () {}\n+\n+  virtual void visit (UnitType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (InferType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FnType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ParamType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (BoolType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (IntType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (UintType &type) override\n+  {\n+    Location locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (locus, \"expected [%s] got [%s]\", base->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+protected:\n+  BaseRules (TyBase *base) : mappings (Analysis::Mappings::get ()), base (base)\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+\n+private:\n+  TyBase *base;\n+};\n+\n+class InferRules : protected BaseRules\n+{\n+public:\n+  InferRules (InferType *base)\n+    : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~InferRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+private:\n+  InferType *base;\n+  TyBase *resolved;\n+};\n+\n+class UnitRules : protected BaseRules\n+{\n+public:\n+  UnitRules (UnitType *base) : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~UnitRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+private:\n+  UnitType *base;\n+  TyBase *resolved;\n+};\n+\n+class FnRules : protected BaseRules\n+{\n+public:\n+  FnRules (FnType *base) : BaseRules (base), base (base), resolved (nullptr) {}\n+  ~FnRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+private:\n+  FnType *base;\n+  TyBase *resolved;\n+};\n+\n+class ParamRules : protected BaseRules\n+{\n+public:\n+  ParamRules (ParamType *base)\n+    : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~ParamRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    // we only case about the base type of a param\n+    return base->get_base_type ()->combine (other);\n+  }\n+\n+private:\n+  ParamType *base;\n+  TyBase *resolved;\n+};\n+\n+class BoolRules : protected BaseRules\n+{\n+public:\n+  BoolRules (BoolType *base) : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~BoolRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+  void visit (BoolType &type) override\n+  {\n+    resolved = new BoolType (type.get_ref ());\n+  }\n+\n+private:\n+  BoolType *base;\n+  TyBase *resolved;\n+};\n+\n+class IntRules : protected BaseRules\n+{\n+public:\n+  IntRules (IntType *base) : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~IntRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    // FIXME we should look at the IntTypeKind and check if i8 vs i16 etc..\n+    resolved = new IntType (type.get_ref (), type.get_kind ());\n+  }\n+\n+private:\n+  IntType *base;\n+  TyBase *resolved;\n+};\n+\n+class UintRules : protected BaseRules\n+{\n+public:\n+  UintRules (UintType *base) : BaseRules (base), base (base), resolved (nullptr)\n+  {}\n+  ~UintRules () {}\n+\n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    return resolved;\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    // FIXME we should look at the IntTypeKind and check if u8 vs u16 etc..\n+    resolved = new UintType (type.get_ref (), type.get_kind ());\n+  }\n+\n+private:\n+  UintType *base;\n+  TyBase *resolved;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_RULES"}, {"sha": "68a8a433187df8e30736624827f764d6b872702e", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_VISITOR\n+#define RUST_TYTY_VISITOR\n+\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class TyVisitor\n+{\n+public:\n+  virtual void visit (UnitType &type) {}\n+  virtual void visit (InferType &type) {}\n+  virtual void visit (FnType &type) {}\n+  virtual void visit (ParamType &type) {}\n+  virtual void visit (BoolType &type) {}\n+  virtual void visit (IntType &type) {}\n+  virtual void visit (UintType &type) {}\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_VISITOR"}, {"sha": "4a36d4f4315ae9a3cbf4b9170924ba2fcc2e3964", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,223 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-tyty-call.h\"\n+#include \"rust-hir-type-check-expr.h\"\n+#include \"rust-tyty-rules.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+void\n+UnitType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+UnitType::as_string () const\n+{\n+  return \"()\";\n+}\n+\n+TyBase *\n+UnitType::combine (TyBase *other)\n+{\n+  UnitRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+InferType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+InferType::as_string () const\n+{\n+  return \"[_]\";\n+}\n+\n+TyBase *\n+InferType::combine (TyBase *other)\n+{\n+  InferRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+FnType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+FnType::as_string () const\n+{\n+  std::string params_str = \"\";\n+  for (auto &param : params)\n+    {\n+      params_str += param->as_string ();\n+      params_str += \",\";\n+    }\n+\n+  std::string ret_str = type->as_string ();\n+  return \"fn (\" + params_str + \") -> \" + ret_str;\n+}\n+\n+TyBase *\n+FnType::combine (TyBase *other)\n+{\n+  FnRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+ParamType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+ParamType::as_string () const\n+{\n+  return \"(\" + identifier + \" :\" + type->as_string () + \")\";\n+}\n+\n+TyBase *\n+ParamType::combine (TyBase *other)\n+{\n+  ParamRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+BoolType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+BoolType::as_string () const\n+{\n+  return \"bool\";\n+}\n+\n+TyBase *\n+BoolType::combine (TyBase *other)\n+{\n+  BoolRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+IntType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+IntType::as_string () const\n+{\n+  switch (int_kind)\n+    {\n+    case I8:\n+      return \"i8\";\n+    case I16:\n+      return \"i16\";\n+    case I32:\n+      return \"i32\";\n+    }\n+  gcc_unreachable ();\n+  return \"__unknown_int_type\";\n+}\n+\n+TyBase *\n+IntType::combine (TyBase *other)\n+{\n+  IntRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+UintType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+UintType::as_string () const\n+{\n+  switch (uint_kind)\n+    {\n+    case U8:\n+      return \"u8\";\n+    case U16:\n+      return \"u16\";\n+    case U32:\n+      return \"u32\";\n+    }\n+  gcc_unreachable ();\n+  return \"__unknown_uint_type\";\n+}\n+\n+TyBase *\n+UintType::combine (TyBase *other)\n+{\n+  UintRules r (this);\n+  return r.combine (other);\n+}\n+\n+void\n+TypeCheckCallExpr::visit (FnType &type)\n+{\n+  if (call.num_params () != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (), \"differing number of arguments\");\n+      return;\n+    }\n+\n+  size_t i = 0;\n+  call.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+    TyBase *pt = type.param_at (i);\n+    auto t = Resolver::TypeCheckExpr::Resolve (p);\n+    if (t == nullptr)\n+      {\n+\trust_error_at (p->get_locus_slow (), \"failed to resolve type\");\n+\treturn false;\n+      }\n+\n+    auto res = pt->combine (t);\n+    if (res == nullptr)\n+      return false;\n+\n+    i++;\n+    return true;\n+  });\n+\n+  if (i != call.num_params ())\n+    return;\n+\n+  resolved = type.get_return_type ();\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "4e044906d2fc3e5698e90270a541a6eadb78f703", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,213 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY\n+#define RUST_TYTY\n+\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+// https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variants\n+enum TypeKind\n+{\n+  INFER,\n+  ADT,\n+  STR,\n+  REF,\n+  PARAM,\n+  ARRAY,\n+  FNDEF,\n+  TUPLE,\n+  BOOL,\n+  CHAR,\n+  INT,\n+  UINT,\n+  FLOAT,\n+  UNIT,\n+  // there are more to add...\n+};\n+\n+class TyVisitor;\n+class TyBase\n+{\n+public:\n+  ~TyBase () {}\n+\n+  HirId get_ref () const { return ref; }\n+\n+  virtual void accept_vis (TyVisitor &vis) = 0;\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual TyBase *combine (TyBase *other) = 0;\n+\n+  virtual bool is_unit () const { return kind == TypeKind::UNIT; }\n+\n+protected:\n+  TyBase (HirId ref, TypeKind kind) : kind (kind), ref (ref) {}\n+\n+  TypeKind kind;\n+  HirId ref;\n+};\n+\n+class InferType : public TyBase\n+{\n+public:\n+  InferType (HirId ref) : TyBase (ref, TypeKind::INFER) {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  bool is_unit () const override { return true; }\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+};\n+\n+class UnitType : public TyBase\n+{\n+public:\n+  UnitType (HirId ref) : TyBase (ref, TypeKind::UNIT) {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  bool is_unit () const override { return true; }\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+};\n+\n+class ParamType : public TyBase\n+{\n+public:\n+  ParamType (HirId ref, std::string identifier, TyBase *type)\n+    : TyBase (ref, TypeKind::PARAM), identifier (identifier), type (type)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  std::string get_identifier () const { return identifier; }\n+\n+  TyBase *get_base_type () { return type; }\n+\n+private:\n+  std::string identifier;\n+  TyBase *type;\n+};\n+\n+class FnType : public TyBase\n+{\n+public:\n+  FnType (HirId ref, std::vector<ParamType *> params, TyBase *type)\n+    : TyBase (ref, TypeKind::FNDEF), params (params), type (type)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *return_type () { return type; }\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  size_t num_params () const { return params.size (); }\n+\n+  ParamType *param_at (size_t idx) { return params[idx]; }\n+\n+  TyBase *get_return_type () { return type; }\n+\n+private:\n+  std::vector<ParamType *> params;\n+  TyBase *type;\n+};\n+\n+class BoolType : public TyBase\n+{\n+public:\n+  BoolType (HirId ref) : TyBase (ref, TypeKind::BOOL) {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+};\n+\n+class IntType : public TyBase\n+{\n+public:\n+  enum IntKind\n+  {\n+    I8,\n+    I16,\n+    I32,\n+  };\n+\n+  IntType (HirId ref, IntKind kind)\n+    : TyBase (ref, TypeKind::INT), int_kind (kind)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  IntKind get_kind () const { return int_kind; }\n+\n+private:\n+  IntKind int_kind;\n+};\n+\n+class UintType : public TyBase\n+{\n+public:\n+  enum UintKind\n+  {\n+    U8,\n+    U16,\n+    U32,\n+  };\n+\n+  UintType (HirId ref, UintKind kind)\n+    : TyBase (ref, TypeKind::UINT), uint_kind (kind)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  UintKind get_kind () const { return uint_kind; }\n+\n+private:\n+  UintKind uint_kind;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY"}, {"sha": "bdf487e8c158c8d841068c3b75f4dc4ff207109f", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=aa283484a3dffedc404653af18f9413775cbc3df", "patch": "@@ -0,0 +1,447 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-map.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+NodeMapping::NodeMapping (CrateNum crateNum, NodeId nodeId, HirId hirId,\n+\t\t\t  LocalDefId localDefId)\n+  : crateNum (crateNum), nodeId (nodeId), hirId (hirId), localDefId (localDefId)\n+{}\n+\n+NodeMapping::~NodeMapping () {}\n+\n+NodeMapping\n+NodeMapping::get_error ()\n+{\n+  return NodeMapping (UNKNOWN_CREATENUM, UNKNOWN_NODEID, UNKNOWN_HIRID,\n+\t\t      UNKNOWN_LOCAL_DEFID);\n+}\n+\n+CrateNum\n+NodeMapping::get_crate_num () const\n+{\n+  return crateNum;\n+}\n+\n+NodeId\n+NodeMapping::get_nodeid () const\n+{\n+  return nodeId;\n+}\n+\n+HirId\n+NodeMapping::get_hirid () const\n+{\n+  return hirId;\n+}\n+\n+LocalDefId\n+NodeMapping::get_local_defid () const\n+{\n+  return localDefId;\n+}\n+\n+DefId\n+NodeMapping::get_defid () const\n+{\n+  return get_defid (get_crate_num (), get_local_defid ());\n+}\n+\n+DefId\n+NodeMapping::get_defid (CrateNum crate_num, LocalDefId local_defid)\n+{\n+  DefId val = 0;\n+  val |= crate_num;\n+  val = val << sizeof (uint32_t);\n+  val |= local_defid;\n+  return val;\n+}\n+\n+std::string\n+NodeMapping::as_string () const\n+{\n+  std::ostringstream ss;\n+  ss << \"[\"\n+     << \"C: \" << get_crate_num ();\n+  if (get_nodeid () != UNKNOWN_NODEID)\n+    ss << \" Nid: \" << get_nodeid ();\n+\n+  if (get_hirid () != UNKNOWN_HIRID)\n+    ss << \" Hid: \" << get_hirid ();\n+\n+  if (get_local_defid () != UNKNOWN_LOCAL_DEFID)\n+    ss << \" Lid: \" << get_local_defid ();\n+\n+  ss << \"]\";\n+  return ss.str ();\n+}\n+\n+// Mappings Class now\n+\n+Mappings::Mappings () {}\n+\n+Mappings::~Mappings () {}\n+\n+Mappings *\n+Mappings::get ()\n+{\n+  static std::unique_ptr<Mappings> instance;\n+  if (!instance)\n+    instance = std::move (std::unique_ptr<Mappings> (new Mappings ()));\n+\n+  return instance.get ();\n+}\n+\n+CrateNum\n+Mappings::get_next_crate_num ()\n+{\n+  return crateNumItr++;\n+}\n+\n+void\n+Mappings::set_current_crate (CrateNum crateNum)\n+{\n+  currentCrateNum = crateNum;\n+}\n+\n+CrateNum\n+Mappings::get_current_crate ()\n+{\n+  // HACK\n+  if (hirIdIter.find (currentCrateNum) == hirIdIter.end ())\n+    {\n+      hirIdIter[currentCrateNum] = UNKNOWN_HIRID;\n+      nodeIdIter[currentCrateNum] = UNKNOWN_NODEID;\n+      localIdIter[currentCrateNum] = UNKNOWN_LOCAL_DEFID;\n+      nodeIdToHirMappings[currentCrateNum] = {};\n+      locations[currentCrateNum] = {};\n+    }\n+\n+  return currentCrateNum;\n+}\n+\n+NodeId\n+Mappings::get_next_node_id (CrateNum crateNum)\n+{\n+  auto it = nodeIdIter.find (crateNum);\n+  rust_assert (it != nodeIdIter.end ());\n+\n+  auto id = it->second + 1;\n+  nodeIdIter[crateNum] = id;\n+  return id;\n+}\n+\n+HirId\n+Mappings::get_next_hir_id (CrateNum crateNum)\n+{\n+  auto it = hirIdIter.find (crateNum);\n+  rust_assert (it != hirIdIter.end ());\n+\n+  auto id = it->second + 1;\n+  hirIdIter[crateNum] = id;\n+  return id;\n+}\n+\n+LocalDefId\n+Mappings::get_next_localdef_id (CrateNum crateNum)\n+{\n+  auto it = localIdIter.find (crateNum);\n+  rust_assert (it != localIdIter.end ());\n+\n+  auto id = it->second + 1;\n+  localIdIter[crateNum] = id;\n+  return id;\n+}\n+\n+AST::Crate *\n+Mappings::get_ast_crate (CrateNum crateNum)\n+{\n+  auto it = astCrateMappings.find (crateNum);\n+  if (it == astCrateMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_ast_crate (AST::Crate *crate)\n+{\n+  CrateNum crateNum = get_current_crate ();\n+  rust_assert (get_ast_crate (crateNum) == nullptr);\n+\n+  astCrateMappings[crateNum] = crate;\n+}\n+\n+HIR::Crate *\n+Mappings::get_hir_crate (CrateNum crateNum)\n+{\n+  auto it = hirCrateMappings.find (crateNum);\n+  if (it == hirCrateMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_crate (HIR::Crate *crate)\n+{\n+  CrateNum crateNum = crate->get_mappings ().get_crate_num ();\n+  rust_assert (get_hir_crate (crateNum) == nullptr);\n+\n+  hirCrateMappings[crateNum] = crate;\n+}\n+\n+void\n+Mappings::insert_defid_mapping (DefId id, HIR::Item *item)\n+{\n+  CrateNum crateNum = (id & DEF_ID_CRATE_MASK) >> sizeof (uint32_t);\n+  LocalDefId localDefId = id & DEF_ID_LOCAL_DEF_MASK;\n+\n+  rust_assert (lookup_defid (id) == nullptr);\n+  rust_assert (lookup_local_defid (crateNum, localDefId) == nullptr);\n+\n+  defIdMappings[id] = item;\n+  insert_local_defid_mapping (crateNum, localDefId, item);\n+}\n+\n+HIR::Item *\n+Mappings::lookup_defid (DefId id)\n+{\n+  auto it = defIdMappings.find (id);\n+  if (it == defIdMappings.end ())\n+    return nullptr;\n+\n+  return it->second;\n+}\n+\n+void\n+Mappings::insert_hir_item (CrateNum crateNum, HirId id, HIR::Item *item)\n+{\n+  rust_assert (lookup_hir_item (crateNum, id) == nullptr);\n+\n+  hirItemMappings[crateNum][id] = item;\n+  nodeIdToHirMappings[crateNum][item->get_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::Item *\n+Mappings::lookup_hir_item (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirItemMappings.find (crateNum);\n+  if (it == hirItemMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::insert_hir_expr (CrateNum crateNum, HirId id, HIR::Expr *expr)\n+{\n+  rust_assert (lookup_hir_expr (crateNum, id) == nullptr);\n+\n+  hirExprMappings[crateNum][id] = expr;\n+  nodeIdToHirMappings[crateNum][expr->get_mappings ().get_nodeid ()] = id;\n+  insert_location (crateNum, id, expr->get_locus_slow ());\n+}\n+\n+HIR::Expr *\n+Mappings::lookup_hir_expr (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirExprMappings.find (crateNum);\n+  if (it == hirExprMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::insert_hir_type (CrateNum crateNum, HirId id, HIR::Type *type)\n+{\n+  rust_assert (lookup_hir_type (crateNum, id) == nullptr);\n+\n+  hirTypeMappings[crateNum][id] = type;\n+  nodeIdToHirMappings[crateNum][type->get_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::Type *\n+Mappings::lookup_hir_type (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirTypeMappings.find (crateNum);\n+  if (it == hirTypeMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::insert_hir_stmt (CrateNum crateNum, HirId id, HIR::Stmt *type)\n+{\n+  rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n+\n+  hirStmtMappings[crateNum][id] = type;\n+  nodeIdToHirMappings[crateNum][type->get_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::Stmt *\n+Mappings::lookup_hir_stmt (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirStmtMappings.find (crateNum);\n+  if (it == hirStmtMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::insert_hir_param (CrateNum crateNum, HirId id,\n+\t\t\t    HIR::FunctionParam *param)\n+{\n+  rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n+\n+  printf (\"inserting param with node id %u hir id: %u\\n\",\n+\t  param->get_mappings ()->get_nodeid (), id);\n+  hirParamMappings[crateNum][id] = param;\n+  nodeIdToHirMappings[crateNum][param->get_mappings ()->get_nodeid ()] = id;\n+}\n+\n+HIR::FunctionParam *\n+Mappings::lookup_hir_param (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirParamMappings.find (crateNum);\n+  if (it == hirParamMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::insert_local_defid_mapping (CrateNum crateNum, LocalDefId id,\n+\t\t\t\t      HIR::Item *item)\n+{\n+  rust_assert (lookup_local_defid (crateNum, id) == nullptr);\n+\n+  localDefIdMappings[crateNum][id] = item;\n+}\n+\n+HIR::Item *\n+Mappings::lookup_local_defid (CrateNum crateNum, LocalDefId id)\n+{\n+  auto it = localDefIdMappings.find (crateNum);\n+  if (it == localDefIdMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n+void\n+Mappings::walk_local_defids_for_crate (CrateNum crateNum,\n+\t\t\t\t       std::function<bool (HIR::Item *)> cb)\n+{\n+  auto it = localDefIdMappings.find (crateNum);\n+  if (it == localDefIdMappings.end ())\n+    return;\n+\n+  for (auto iy = it->second.begin (); iy != it->second.end (); iy++)\n+    {\n+      if (!cb (iy->second))\n+\treturn;\n+    }\n+}\n+\n+bool\n+Mappings::lookup_node_to_hir (CrateNum crate, NodeId id, HirId *ref)\n+{\n+  auto it = nodeIdToHirMappings.find (crate);\n+  if (it == nodeIdToHirMappings.end ())\n+    return false;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return false;\n+\n+  *ref = iy->second;\n+  return true;\n+}\n+\n+void\n+Mappings::insert_location (CrateNum crate, HirId id, Location locus)\n+{\n+  locations[crate][id] = locus;\n+}\n+\n+Location\n+Mappings::lookup_location (CrateNum crate, HirId id)\n+{\n+  auto it = locations.find (crate);\n+  if (it == locations.end ())\n+    return Location ();\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return Location ();\n+\n+  return iy->second;\n+}\n+\n+bool\n+Mappings::resolve_nodeid_to_stmt (CrateNum crate, NodeId id, HIR::Stmt **stmt)\n+{\n+  auto it = nodeIdToHirMappings.find (crate);\n+  if (it == nodeIdToHirMappings.end ())\n+    return false;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return false;\n+\n+  HirId resolved = iy->second;\n+  auto resolved_stmt = lookup_hir_stmt (crate, resolved);\n+  *stmt = resolved_stmt;\n+  return resolved_stmt != nullptr;\n+}\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "a400265428bf8fd9307d2ccb885840021f13663a", "filename": "gcc/rust/util/rust-hir-map.h", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa283484a3dffedc404653af18f9413775cbc3df/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=aa283484a3dffedc404653af18f9413775cbc3df"}]}