{"sha": "bd431d26de02180d7fac1a794e2b9d3aaa4df34d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ0MzFkMjZkZTAyMTgwZDdmYWMxYTc5NGUyYjlkM2FhYTRkZjM0ZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-05T15:08:11Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-10-05T17:48:55Z"}, "message": "Import various range-op fixes from ranger branch.\n\nThis patch imports three fixes from the ranger branch:\n\n1. Fold division by zero into varying instead of undefined.\nThis provides compatibility with existing stuff on trunk.\n\n2. Solver changes for lshift.\nThis should not affect anything on trunk, as it only involves\nthe GORI solver which is yet to be contributed.\n\n3. Preserve existing behavior for ABS([-MIN,-MIN]).\nThis is actually unrepresentable, but trunk has traditionally\ntreated this as [-MIN,-MIN] so this patch just syncs range-ops\nwith the rest of trunk.\n\ngcc/ChangeLog:\n\n\t* range-op.cc (operator_div::wi_fold): Return varying for\n\tdivision by zero.\n\t(class operator_rshift): Move class up.\n\t(operator_abs::wi_fold): Return [-MIN,-MIN] for ABS([-MIN,-MIN]).\n\t(operator_tests): Adjust tests.", "tree": {"sha": "98227b77c21cfeccca6cdae466ffdf4897b56a65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98227b77c21cfeccca6cdae466ffdf4897b56a65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd431d26de02180d7fac1a794e2b9d3aaa4df34d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd431d26de02180d7fac1a794e2b9d3aaa4df34d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd431d26de02180d7fac1a794e2b9d3aaa4df34d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd431d26de02180d7fac1a794e2b9d3aaa4df34d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac1c65ad1a16d83ec63674efa07c00b062562f15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1c65ad1a16d83ec63674efa07c00b062562f15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1c65ad1a16d83ec63674efa07c00b062562f15"}], "stats": {"total": 164, "additions": 114, "deletions": 50}, "files": [{"sha": "11e847f02c14c37b7b872873b39bc4b26b4767ce", "filename": "gcc/range-op.cc", "status": "modified", "additions": 114, "deletions": 50, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd431d26de02180d7fac1a794e2b9d3aaa4df34d/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd431d26de02180d7fac1a794e2b9d3aaa4df34d/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=bd431d26de02180d7fac1a794e2b9d3aaa4df34d", "patch": "@@ -1317,10 +1317,10 @@ operator_div::wi_fold (irange &r, tree type,\n \t\t       const wide_int &lh_lb, const wide_int &lh_ub,\n \t\t       const wide_int &rh_lb, const wide_int &rh_ub) const\n {\n-  // If we know we will divide by zero, return undefined.\n+  // If we know we will divide by zero...\n   if (rh_lb == 0 && rh_ub == 0)\n     {\n-      r.set_undefined ();\n+      r.set_varying (type);\n       return;\n     }\n \n@@ -1430,6 +1430,27 @@ class operator_lshift : public cross_product_operator\n \t\t\t\tconst wide_int &) const;\n } op_lshift;\n \n+class operator_rshift : public cross_product_operator\n+{\n+public:\n+  virtual bool fold_range (irange &r, tree type,\n+\t\t\t   const irange &op1,\n+\t\t\t   const irange &op2) const;\n+  virtual void wi_fold (irange &r, tree type,\n+\t\t\tconst wide_int &lh_lb,\n+\t\t\tconst wide_int &lh_ub,\n+\t\t\tconst wide_int &rh_lb,\n+\t\t\tconst wide_int &rh_ub) const;\n+  virtual bool wi_op_overflows (wide_int &res,\n+\t\t\t\ttree type,\n+\t\t\t\tconst wide_int &w0,\n+\t\t\t\tconst wide_int &w1) const;\n+  virtual bool op1_range (irange &, tree type,\n+\t\t\t  const irange &lhs,\n+\t\t\t  const irange &op2) const;\n+} op_rshift;\n+\n+\n bool\n operator_lshift::fold_range (irange &r, tree type,\n \t\t\t     const irange &op1,\n@@ -1546,60 +1567,47 @@ operator_lshift::op1_range (irange &r,\n   tree shift_amount;\n   if (op2.singleton_p (&shift_amount))\n     {\n-      int_range<1> shifted (shift_amount, shift_amount), ub, lb;\n-      const range_operator *rshift_op = range_op_handler (RSHIFT_EXPR, type);\n-      rshift_op->fold_range (ub, type, lhs, shifted);\n-      if (TYPE_UNSIGNED (type))\n+      wide_int shift = wi::to_wide (shift_amount);\n+      gcc_checking_assert (wi::gt_p (shift, 0, SIGNED));\n+\n+      // Work completely in unsigned mode to start.\n+      tree utype = type;\n+      if (TYPE_SIGN (type) == SIGNED)\n \t{\n-\t  r = ub;\n-\t  return true;\n+\t  int_range_max tmp = lhs;\n+\t  utype = unsigned_type_for (type);\n+\t  range_cast (tmp, utype);\n+\t  op_rshift.fold_range (r, utype, tmp, op2);\n \t}\n-      // For signed types, we can't just do an arithmetic rshift,\n-      // because that will propagate the sign bit.\n-      //\n-      //  LHS\n-      // 1110 = OP1 << 1\n-      //\n-      // Assuming a 4-bit signed integer, a right shift will result in\n-      // OP1=1111, but OP1 could have also been 0111.  What we want is\n-      // a range from 0111 to 1111.  That is, a range from the logical\n-      // rshift (0111) to the arithmetic rshift (1111).\n-      //\n-      // Perform a logical rshift by doing the rshift as unsigned.\n-      tree unsigned_type = unsigned_type_for (type);\n-      int_range_max unsigned_lhs = lhs;\n-      range_cast (unsigned_lhs, unsigned_type);\n-      rshift_op = range_op_handler (RSHIFT_EXPR, unsigned_type);\n-      rshift_op->fold_range (lb, unsigned_type, unsigned_lhs, shifted);\n-      range_cast (lb, type);\n-      r = lb;\n-      r.union_ (ub);\n+      else\n+\top_rshift.fold_range (r, utype, lhs, op2);\n+\n+      // Start with ranges which can produce the LHS by right shifting the\n+      // result by the shift amount.\n+      // ie   [0x08, 0xF0] = op1 << 2 will start with\n+      //      [00001000, 11110000] = op1 << 2\n+      //  [0x02, 0x4C] aka [00000010, 00111100]\n+\n+      // Then create a range from the LB with the least significant upper bit\n+      // set, to the upper bound with all the bits set.\n+      // This would be [0x42, 0xFC] aka [01000010, 11111100].\n+\n+      // Ideally we do this for each subrange, but just lump them all for now.\n+      unsigned low_bits = TYPE_PRECISION (utype)\n+\t\t\t  - TREE_INT_CST_LOW (shift_amount);\n+      wide_int up_mask = wi::mask (low_bits, true, TYPE_PRECISION (utype));\n+      wide_int new_ub = wi::bit_or (up_mask, r.upper_bound ());\n+      wide_int new_lb = wi::set_bit (r.lower_bound (), low_bits);\n+      int_range<2> fill_range (utype, new_lb, new_ub);\n+      r.union_ (fill_range);\n+\n+      if (utype != type)\n+\trange_cast (r, type);\n       return true;\n     }\n   return false;\n }\n \n-\n-class operator_rshift : public cross_product_operator\n-{\n-public:\n-  virtual bool fold_range (irange &r, tree type,\n-\t\t\t   const irange &op1,\n-\t\t\t   const irange &op2) const;\n-  virtual void wi_fold (irange &r, tree type,\n-\t\t        const wide_int &lh_lb,\n-\t\t        const wide_int &lh_ub,\n-\t\t        const wide_int &rh_lb,\n-\t\t        const wide_int &rh_ub) const;\n-  virtual bool wi_op_overflows (wide_int &res,\n-\t\t\t\ttree type,\n-\t\t\t\tconst wide_int &w0,\n-\t\t\t\tconst wide_int &w1) const;\n-  virtual bool op1_range (irange &, tree type,\n-\t\t\t  const irange &lhs,\n-\t\t\t  const irange &op2) const;\n-} op_rshift;\n-\n bool\n operator_rshift::op1_range (irange &r,\n \t\t\t    tree type,\n@@ -2825,9 +2833,19 @@ operator_abs::wi_fold (irange &r, tree type,\n   // ABS_EXPR may flip the range around, if the original range\n   // included negative values.\n   if (wi::eq_p (lh_lb, min_value))\n-    min = max_value;\n+    {\n+      // ABS ([-MIN, -MIN]) isn't representable, but we have traditionally\n+      // returned [-MIN,-MIN] so this preserves that behaviour.  PR37078\n+      if (wi::eq_p (lh_ub, min_value))\n+\t{\n+\t  r = int_range<1> (type, min_value, min_value);\n+\t  return;\n+\t}\n+      min = max_value;\n+    }\n   else\n     min = wi::abs (lh_lb);\n+\n   if (wi::eq_p (lh_ub, min_value))\n     max = max_value;\n   else\n@@ -3552,6 +3570,52 @@ operator_tests ()\n       negatives.intersect (op1);\n       ASSERT_TRUE (negatives.undefined_p ());\n     }\n+\n+  if (TYPE_PRECISION (unsigned_type_node) > 31)\n+    {\n+      // unsigned VARYING = op1 << 1 should be VARYING.\n+      int_range<2> lhs (unsigned_type_node);\n+      int_range<2> shift (INT (1), INT (1));\n+      int_range_max op1;\n+      op_lshift.op1_range (op1, unsigned_type_node, lhs, shift);\n+      ASSERT_TRUE (op1.varying_p ());\n+\n+      // 0 = op1 << 1  should be [0,0], [0x8000000, 0x8000000].\n+      int_range<2> zero (UINT (0), UINT (0));\n+      op_lshift.op1_range (op1, unsigned_type_node, zero, shift);\n+      ASSERT_TRUE (op1.num_pairs () == 2);\n+      // Remove the [0,0] range.\n+      op1.intersect (zero);\n+      ASSERT_TRUE (op1.num_pairs () == 1);\n+      //  op1 << 1   should be [0x8000,0x8000] << 1,\n+      //  which should result in [0,0].\n+      int_range_max result;\n+      op_lshift.fold_range (result, unsigned_type_node, op1, shift);\n+      ASSERT_TRUE (result == zero);\n+    }\n+  // signed VARYING = op1 << 1 should be VARYING.\n+  if (TYPE_PRECISION (integer_type_node) > 31)\n+    {\n+      // unsigned VARYING = op1 << 1  hould be VARYING.\n+      int_range<2> lhs (integer_type_node);\n+      int_range<2> shift (INT (1), INT (1));\n+      int_range_max op1;\n+      op_lshift.op1_range (op1, integer_type_node, lhs, shift);\n+      ASSERT_TRUE (op1.varying_p ());\n+\n+      //  0 = op1 << 1  should be [0,0], [0x8000000, 0x8000000].\n+      int_range<2> zero (INT (0), INT (0));\n+      op_lshift.op1_range (op1, integer_type_node, zero, shift);\n+      ASSERT_TRUE (op1.num_pairs () == 2);\n+      // Remove the [0,0] range.\n+      op1.intersect (zero);\n+      ASSERT_TRUE (op1.num_pairs () == 1);\n+      //  op1 << 1   shuould be [0x8000,0x8000] << 1,\n+      //  which should result in [0,0].\n+      int_range_max result;\n+      op_lshift.fold_range (result, unsigned_type_node, op1, shift);\n+      ASSERT_TRUE (result == zero);\n+    }\n }\n \n // Run all of the selftests within this file."}]}