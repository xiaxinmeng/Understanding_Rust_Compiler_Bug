{"sha": "07cdc2b892ca3969fd5d8c6a281cf77f559cea43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdjZGMyYjg5MmNhMzk2OWZkNWQ4YzZhMjgxY2Y3N2Y1NTljZWE0Mw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-03T12:02:35Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-03T12:02:35Z"}, "message": "fold-const.c (fold_mathfn_compare): Remove.\n\n2015-07-03  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.c (fold_mathfn_compare): Remove.\n\t(fold_inf_compare): Likewise.\n\t(fold_comparison): Move floating point comparison simplifications...\n\t* match.pd: ... to patterns here.  Introduce simple_comparisons\n\toperator list and use it for patterns formerly in fold_comparison.\n\nFrom-SVN: r225375", "tree": {"sha": "8a704d2f67cd1491047c25ff7a2ed93cd6275ab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a704d2f67cd1491047c25ff7a2ed93cd6275ab1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07cdc2b892ca3969fd5d8c6a281cf77f559cea43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07cdc2b892ca3969fd5d8c6a281cf77f559cea43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07cdc2b892ca3969fd5d8c6a281cf77f559cea43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07cdc2b892ca3969fd5d8c6a281cf77f559cea43/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8083fc05cb95d660edd12602b062f3d7adc43e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8083fc05cb95d660edd12602b062f3d7adc43e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8083fc05cb95d660edd12602b062f3d7adc43e3"}], "stats": {"total": 506, "additions": 203, "deletions": 303}, "files": [{"sha": "821ffbc60879c89fb7837a72760c105c3f16716e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdc2b892ca3969fd5d8c6a281cf77f559cea43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdc2b892ca3969fd5d8c6a281cf77f559cea43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07cdc2b892ca3969fd5d8c6a281cf77f559cea43", "patch": "@@ -1,3 +1,11 @@\n+2015-07-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.c (fold_mathfn_compare): Remove.\n+\t(fold_inf_compare): Likewise.\n+\t(fold_comparison): Move floating point comparison simplifications...\n+\t* match.pd: ... to patterns here.  Introduce simple_comparisons\n+\toperator list and use it for patterns formerly in fold_comparison.\n+\n 2015-07-03  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \tPR tree-optimization/66119"}, {"sha": "d896d7a16750b80b7054ac61cb22832d2165938d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 286, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdc2b892ca3969fd5d8c6a281cf77f559cea43/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdc2b892ca3969fd5d8c6a281cf77f559cea43/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=07cdc2b892ca3969fd5d8c6a281cf77f559cea43", "patch": "@@ -145,10 +145,6 @@ static tree fold_binary_op_with_conditional_arg (location_t,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t tree, tree,\n \t\t\t\t\t\t tree, tree, int);\n-static tree fold_mathfn_compare (location_t,\n-\t\t\t\t enum built_in_function, enum tree_code,\n-\t\t\t\t tree, tree, tree);\n-static tree fold_inf_compare (location_t, enum tree_code, tree, tree, tree);\n static tree fold_div_compare (location_t, enum tree_code, tree, tree, tree);\n static bool reorder_operands_p (const_tree, const_tree);\n static tree fold_negate_const (tree, tree);\n@@ -6418,199 +6414,6 @@ fold_real_zero_addition_p (const_tree type, const_tree addend, int negate)\n   return negate && !HONOR_SIGN_DEPENDENT_ROUNDING (element_mode (type));\n }\n \n-/* Subroutine of fold() that checks comparisons of built-in math\n-   functions against real constants.\n-\n-   FCODE is the DECL_FUNCTION_CODE of the built-in, CODE is the comparison\n-   operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR, GE_EXPR or LE_EXPR.  TYPE\n-   is the type of the result and ARG0 and ARG1 are the operands of the\n-   comparison.  ARG1 must be a TREE_REAL_CST.\n-\n-   The function returns the constant folded tree if a simplification\n-   can be made, and NULL_TREE otherwise.  */\n-\n-static tree\n-fold_mathfn_compare (location_t loc,\n-\t\t     enum built_in_function fcode, enum tree_code code,\n-\t\t     tree type, tree arg0, tree arg1)\n-{\n-  REAL_VALUE_TYPE c;\n-\n-  if (BUILTIN_SQRT_P (fcode))\n-    {\n-      tree arg = CALL_EXPR_ARG (arg0, 0);\n-      machine_mode mode = TYPE_MODE (TREE_TYPE (arg0));\n-\n-      c = TREE_REAL_CST (arg1);\n-      if (REAL_VALUE_NEGATIVE (c))\n-\t{\n-\t  /* sqrt(x) < y is always false, if y is negative.  */\n-\t  if (code == EQ_EXPR || code == LT_EXPR || code == LE_EXPR)\n-\t    return omit_one_operand_loc (loc, type, integer_zero_node, arg);\n-\n-\t  /* sqrt(x) > y is always true, if y is negative and we\n-\t     don't care about NaNs, i.e. negative values of x.  */\n-\t  if (code == NE_EXPR || !HONOR_NANS (mode))\n-\t    return omit_one_operand_loc (loc, type, integer_one_node, arg);\n-\n-\t  /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n-\t  return fold_build2_loc (loc, GE_EXPR, type, arg,\n-\t\t\t      build_real (TREE_TYPE (arg), dconst0));\n-\t}\n-      else if (code == GT_EXPR || code == GE_EXPR)\n-\t{\n-\t  REAL_VALUE_TYPE c2;\n-\n-\t  REAL_ARITHMETIC (c2, MULT_EXPR, c, c);\n-\t  real_convert (&c2, mode, &c2);\n-\n-\t  if (REAL_VALUE_ISINF (c2))\n-\t    {\n-\t      /* sqrt(x) > y is x == +Inf, when y is very large.  */\n-\t      if (HONOR_INFINITIES (mode))\n-\t\treturn fold_build2_loc (loc, EQ_EXPR, type, arg,\n-\t\t\t\t    build_real (TREE_TYPE (arg), c2));\n-\n-\t      /* sqrt(x) > y is always false, when y is very large\n-\t\t and we don't care about infinities.  */\n-\t      return omit_one_operand_loc (loc, type, integer_zero_node, arg);\n-\t    }\n-\n-\t  /* sqrt(x) > c is the same as x > c*c.  */\n-\t  return fold_build2_loc (loc, code, type, arg,\n-\t\t\t      build_real (TREE_TYPE (arg), c2));\n-\t}\n-      else if (code == LT_EXPR || code == LE_EXPR)\n-\t{\n-\t  REAL_VALUE_TYPE c2;\n-\n-\t  REAL_ARITHMETIC (c2, MULT_EXPR, c, c);\n-\t  real_convert (&c2, mode, &c2);\n-\n-\t  if (REAL_VALUE_ISINF (c2))\n-\t    {\n-\t      /* sqrt(x) < y is always true, when y is a very large\n-\t\t value and we don't care about NaNs or Infinities.  */\n-\t      if (! HONOR_NANS (mode) && ! HONOR_INFINITIES (mode))\n-\t\treturn omit_one_operand_loc (loc, type, integer_one_node, arg);\n-\n-\t      /* sqrt(x) < y is x != +Inf when y is very large and we\n-\t\t don't care about NaNs.  */\n-\t      if (! HONOR_NANS (mode))\n-\t\treturn fold_build2_loc (loc, NE_EXPR, type, arg,\n-\t\t\t\t    build_real (TREE_TYPE (arg), c2));\n-\n-\t      /* sqrt(x) < y is x >= 0 when y is very large and we\n-\t\t don't care about Infinities.  */\n-\t      if (! HONOR_INFINITIES (mode))\n-\t\treturn fold_build2_loc (loc, GE_EXPR, type, arg,\n-\t\t\t\t    build_real (TREE_TYPE (arg), dconst0));\n-\n-\t      /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n-\t      arg = save_expr (arg);\n-\t      return fold_build2_loc (loc, TRUTH_ANDIF_EXPR, type,\n-\t\t\t\t  fold_build2_loc (loc, GE_EXPR, type, arg,\n-\t\t\t\t\t       build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t   dconst0)),\n-\t\t\t\t  fold_build2_loc (loc, NE_EXPR, type, arg,\n-\t\t\t\t\t       build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t   c2)));\n-\t    }\n-\n-\t  /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n-\t  if (! HONOR_NANS (mode))\n-\t    return fold_build2_loc (loc, code, type, arg,\n-\t\t\t\tbuild_real (TREE_TYPE (arg), c2));\n-\n-\t  /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n-\t  arg = save_expr (arg);\n-\t  return fold_build2_loc (loc, TRUTH_ANDIF_EXPR, type,\n-\t\t\t\t  fold_build2_loc (loc, GE_EXPR, type, arg,\n-\t\t\t\t\t       build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t   dconst0)),\n-\t\t\t\t  fold_build2_loc (loc, code, type, arg,\n-\t\t\t\t\t       build_real (TREE_TYPE (arg),\n-\t\t\t\t\t\t\t   c2)));\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Subroutine of fold() that optimizes comparisons against Infinities,\n-   either +Inf or -Inf.\n-\n-   CODE is the comparison operator: EQ_EXPR, NE_EXPR, GT_EXPR, LT_EXPR,\n-   GE_EXPR or LE_EXPR.  TYPE is the type of the result and ARG0 and ARG1\n-   are the operands of the comparison.  ARG1 must be a TREE_REAL_CST.\n-\n-   The function returns the constant folded tree if a simplification\n-   can be made, and NULL_TREE otherwise.  */\n-\n-static tree\n-fold_inf_compare (location_t loc, enum tree_code code, tree type,\n-\t\t  tree arg0, tree arg1)\n-{\n-  machine_mode mode;\n-  REAL_VALUE_TYPE max;\n-  tree temp;\n-  bool neg;\n-\n-  mode = TYPE_MODE (TREE_TYPE (arg0));\n-\n-  /* For negative infinity swap the sense of the comparison.  */\n-  neg = REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg1));\n-  if (neg)\n-    code = swap_tree_comparison (code);\n-\n-  switch (code)\n-    {\n-    case GT_EXPR:\n-      /* x > +Inf is always false, if with ignore sNANs.  */\n-      if (HONOR_SNANS (mode))\n-        return NULL_TREE;\n-      return omit_one_operand_loc (loc, type, integer_zero_node, arg0);\n-\n-    case LE_EXPR:\n-      /* x <= +Inf is always true, if we don't case about NaNs.  */\n-      if (! HONOR_NANS (mode))\n-\treturn omit_one_operand_loc (loc, type, integer_one_node, arg0);\n-\n-      /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n-      arg0 = save_expr (arg0);\n-      return fold_build2_loc (loc, EQ_EXPR, type, arg0, arg0);\n-\n-    case EQ_EXPR:\n-    case GE_EXPR:\n-      /* x == +Inf and x >= +Inf are always equal to x > DBL_MAX.  */\n-      real_maxval (&max, neg, mode);\n-      return fold_build2_loc (loc, neg ? LT_EXPR : GT_EXPR, type,\n-\t\t\t  arg0, build_real (TREE_TYPE (arg0), max));\n-\n-    case LT_EXPR:\n-      /* x < +Inf is always equal to x <= DBL_MAX.  */\n-      real_maxval (&max, neg, mode);\n-      return fold_build2_loc (loc, neg ? GE_EXPR : LE_EXPR, type,\n-\t\t\t  arg0, build_real (TREE_TYPE (arg0), max));\n-\n-    case NE_EXPR:\n-      /* x != +Inf is always equal to !(x > DBL_MAX).  */\n-      real_maxval (&max, neg, mode);\n-      if (! HONOR_NANS (mode))\n-\treturn fold_build2_loc (loc, neg ? GE_EXPR : LE_EXPR, type,\n-\t\t\t    arg0, build_real (TREE_TYPE (arg0), max));\n-\n-      temp = fold_build2_loc (loc, neg ? LT_EXPR : GT_EXPR, type,\n-\t\t\t  arg0, build_real (TREE_TYPE (arg0), max));\n-      return fold_build1_loc (loc, TRUTH_NOT_EXPR, type, temp);\n-\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Subroutine of fold() that optimizes comparisons of a division by\n    a nonzero integer constant against an integer constant, i.e.\n    X/C1 op C2.\n@@ -9075,95 +8878,6 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n   if (tem)\n     return tem;\n \n-  if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n-    {\n-      tree targ0 = strip_float_extensions (arg0);\n-      tree targ1 = strip_float_extensions (arg1);\n-      tree newtype = TREE_TYPE (targ0);\n-\n-      if (TYPE_PRECISION (TREE_TYPE (targ1)) > TYPE_PRECISION (newtype))\n-\tnewtype = TREE_TYPE (targ1);\n-\n-      /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n-      if (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n-\treturn fold_build2_loc (loc, code, type,\n-\t\t\t    fold_convert_loc (loc, newtype, targ0),\n-\t\t\t    fold_convert_loc (loc, newtype, targ1));\n-\n-      if (TREE_CODE (arg1) == REAL_CST)\n-\t{\n-\t  REAL_VALUE_TYPE cst;\n-\t  cst = TREE_REAL_CST (arg1);\n-\n-\t  /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n-\t  /* a CMP (-0) -> a CMP 0  */\n-\t  if (REAL_VALUE_MINUS_ZERO (cst))\n-\t    return fold_build2_loc (loc, code, type, arg0,\n-\t\t\t\tbuild_real (TREE_TYPE (arg1), dconst0));\n-\n-\t  /* x != NaN is always true, other ops are always false.  */\n-\t  if (REAL_VALUE_ISNAN (cst)\n-\t      && ! HONOR_SNANS (arg1))\n-\t    {\n-\t      tem = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n-\t      return omit_one_operand_loc (loc, type, tem, arg0);\n-\t    }\n-\n-\t  /* Fold comparisons against infinity.  */\n-\t  if (REAL_VALUE_ISINF (cst)\n-\t      && MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (arg1))))\n-\t    {\n-\t      tem = fold_inf_compare (loc, code, type, arg0, arg1);\n-\t      if (tem != NULL_TREE)\n-\t\treturn tem;\n-\t    }\n-\t}\n-\n-      /* If this is a comparison of a real constant with a PLUS_EXPR\n-\t or a MINUS_EXPR of a real constant, we can convert it into a\n-\t comparison with a revised real constant as long as no overflow\n-\t occurs when unsafe_math_optimizations are enabled.  */\n-      if (flag_unsafe_math_optimizations\n-\t  && TREE_CODE (arg1) == REAL_CST\n-\t  && (TREE_CODE (arg0) == PLUS_EXPR\n-\t      || TREE_CODE (arg0) == MINUS_EXPR)\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t  && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t\t      arg1, TREE_OPERAND (arg0, 1)))\n-\t  && !TREE_OVERFLOW (tem))\n-\treturn fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0), tem);\n-\n-      /* Likewise, we can simplify a comparison of a real constant with\n-         a MINUS_EXPR whose first operand is also a real constant, i.e.\n-         (c1 - x) < c2 becomes x > c1-c2.  Reordering is allowed on\n-         floating-point types only if -fassociative-math is set.  */\n-      if (flag_associative_math\n-\t  && TREE_CODE (arg1) == REAL_CST\n-\t  && TREE_CODE (arg0) == MINUS_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == REAL_CST\n-\t  && 0 != (tem = const_binop (MINUS_EXPR, TREE_OPERAND (arg0, 0),\n-\t\t\t\t      arg1))\n-\t  && !TREE_OVERFLOW (tem))\n-\treturn fold_build2_loc (loc, swap_tree_comparison (code), type,\n-\t\t\t    TREE_OPERAND (arg0, 1), tem);\n-\n-      /* Fold comparisons against built-in math functions.  */\n-      if (TREE_CODE (arg1) == REAL_CST\n-\t  && flag_unsafe_math_optimizations\n-\t  && ! flag_errno_math)\n-\t{\n-\t  enum built_in_function fcode = builtin_mathfn_code (arg0);\n-\n-\t  if (fcode != END_BUILTINS)\n-\t    {\n-\t      tem = fold_mathfn_compare (loc, fcode, code, type, arg0, arg1);\n-\t      if (tem != NULL_TREE)\n-\t\treturn tem;\n-\t    }\n-\t}\n-    }\n-\n   if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE\n       && CONVERT_EXPR_P (arg0))\n     {"}, {"sha": "7d1d4dfbcb1cadfbabf1556484d6c069b11eeb35", "filename": "gcc/match.pd", "status": "modified", "additions": 195, "deletions": 17, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07cdc2b892ca3969fd5d8c6a281cf77f559cea43/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07cdc2b892ca3969fd5d8c6a281cf77f559cea43/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=07cdc2b892ca3969fd5d8c6a281cf77f559cea43", "patch": "@@ -40,6 +40,19 @@ along with GCC; see the file COPYING3.  If not see\n   unge ungt ne eq unlt unle ordered   unordered ge   gt   le   lt   ltgt uneq)\n (define_operator_list swapped_tcc_comparison\n   gt   ge   eq ne le   lt   unordered ordered   ungt unge unlt unle uneq ltgt)\n+(define_operator_list simple_comparison         lt   le   eq ne ge   gt)\n+(define_operator_list swapped_simple_comparison gt   ge   eq ne le   lt)\n+\n+(define_operator_list LOG BUILT_IN_LOGF BUILT_IN_LOG BUILT_IN_LOGL)\n+(define_operator_list EXP BUILT_IN_EXPF BUILT_IN_EXP BUILT_IN_EXPL)\n+(define_operator_list LOG2 BUILT_IN_LOG2F BUILT_IN_LOG2 BUILT_IN_LOG2L)\n+(define_operator_list EXP2 BUILT_IN_EXP2F BUILT_IN_EXP2 BUILT_IN_EXP2L)\n+(define_operator_list LOG10 BUILT_IN_LOG10F BUILT_IN_LOG10 BUILT_IN_LOG10L)\n+(define_operator_list EXP10 BUILT_IN_EXP10F BUILT_IN_EXP10 BUILT_IN_EXP10L)\n+(define_operator_list POW BUILT_IN_POWF BUILT_IN_POW BUILT_IN_POWL)\n+(define_operator_list POW10 BUILT_IN_POW10F BUILT_IN_POW10 BUILT_IN_POW10L)\n+(define_operator_list SQRT BUILT_IN_SQRTF BUILT_IN_SQRT BUILT_IN_SQRTL)\n+(define_operator_list CBRT BUILT_IN_CBRTF BUILT_IN_CBRT BUILT_IN_CBRTL)\n \n \n /* Simplifications of operations with one constant operand and\n@@ -1329,8 +1342,8 @@ along with GCC; see the file COPYING3.  If not see\n    signed arithmetic case.  That form is created by the compiler\n    often enough for folding it to be of value.  One example is in\n    computing loop trip counts after Operator Strength Reduction.  */\n-(for cmp (tcc_comparison)\n-     scmp (swapped_tcc_comparison)\n+(for cmp (simple_comparison)\n+     scmp (swapped_simple_comparison)\n  (simplify\n   (cmp (mult @0 INTEGER_CST@1) integer_zerop@2)\n   /* Handle unfolded multiplication by zero.  */\n@@ -1363,19 +1376,196 @@ along with GCC; see the file COPYING3.  If not see\n    { constant_boolean_node (false, type); })))\n \n /* Fold ~X op ~Y as Y op X.  */\n-(for cmp (tcc_comparison)\n+(for cmp (simple_comparison)\n  (simplify\n   (cmp (bit_not @0) (bit_not @1))\n   (cmp @1 @0)))\n \n /* Fold ~X op C as X op' ~C, where op' is the swapped comparison.  */\n-(for cmp (tcc_comparison)\n-     scmp (swapped_tcc_comparison)\n+(for cmp (simple_comparison)\n+     scmp (swapped_simple_comparison)\n  (simplify\n   (cmp (bit_not @0) CONSTANT_CLASS_P@1)\n   (if (TREE_CODE (@1) == INTEGER_CST || TREE_CODE (@1) == VECTOR_CST)\n    (scmp @0 (bit_not @1)))))\n \n+(for cmp (simple_comparison)\n+ /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n+ (simplify\n+  (cmp (convert@2 @0) (convert? @1))\n+  (if (FLOAT_TYPE_P (TREE_TYPE (@0))\n+       && (DECIMAL_FLOAT_TYPE_P (TREE_TYPE (@2))\n+\t   == DECIMAL_FLOAT_TYPE_P (TREE_TYPE (@0)))\n+       && (DECIMAL_FLOAT_TYPE_P (TREE_TYPE (@2))\n+\t   == DECIMAL_FLOAT_TYPE_P (TREE_TYPE (@1))))\n+   (with\n+    {\n+      tree type1 = TREE_TYPE (@1);\n+      if (TREE_CODE (@1) == REAL_CST && !DECIMAL_FLOAT_TYPE_P (type1))\n+        {\n+\t  REAL_VALUE_TYPE orig = TREE_REAL_CST (@1);\n+\t  if (TYPE_PRECISION (type1) > TYPE_PRECISION (float_type_node)\n+\t      && exact_real_truncate (TYPE_MODE (float_type_node), &orig))\n+\t    type1 = float_type_node;\n+\t  if (TYPE_PRECISION (type1) > TYPE_PRECISION (double_type_node)\n+\t      && exact_real_truncate (TYPE_MODE (double_type_node), &orig))\n+\t    type1 = double_type_node;\n+        }\n+      tree newtype\n+        = (TYPE_PRECISION (TREE_TYPE (@0)) > TYPE_PRECISION (type1)\n+\t   ? TREE_TYPE (@0) : type1); \n+    }\n+    (if (TYPE_PRECISION (TREE_TYPE (@2)) > TYPE_PRECISION (newtype))\n+     (cmp (convert:newtype @0) (convert:newtype @1))))))\n+ \n+ (simplify\n+  (cmp @0 REAL_CST@1)\n+  /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n+  /* a CMP (-0) -> a CMP 0  */\n+  (if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (@1)))\n+   (cmp @0 { build_real (TREE_TYPE (@1), dconst0); }))\n+  /* x != NaN is always true, other ops are always false.  */\n+  (if (REAL_VALUE_ISNAN (TREE_REAL_CST (@1))\n+       && ! HONOR_SNANS (@1))\n+   { constant_boolean_node (cmp == NE_EXPR, type); })\n+  /* Fold comparisons against infinity.  */\n+  (if (REAL_VALUE_ISINF (TREE_REAL_CST (@1))\n+       && MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (@1))))\n+   (with\n+    {\n+      REAL_VALUE_TYPE max;\n+      enum tree_code code = cmp;\n+      bool neg = REAL_VALUE_NEGATIVE (TREE_REAL_CST (@1));\n+      if (neg)\n+        code = swap_tree_comparison (code);\n+    }\n+    /* x > +Inf is always false, if with ignore sNANs.  */\n+    (if (code == GT_EXPR\n+    \t && ! HONOR_SNANS (@0))\n+     { constant_boolean_node (false, type); })\n+    (if (code == LE_EXPR)\n+     /* x <= +Inf is always true, if we don't case about NaNs.  */\n+     (if (! HONOR_NANS (@0))\n+      { constant_boolean_node (true, type); })\n+     /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n+     (eq @0 @0))\n+    /* x == +Inf and x >= +Inf are always equal to x > DBL_MAX.  */\n+    (if (code == EQ_EXPR || code == GE_EXPR)\n+     (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n+      (if (neg)\n+       (lt @0 { build_real (TREE_TYPE (@0), max); }))\n+      (gt @0 { build_real (TREE_TYPE (@0), max); })))\n+    /* x < +Inf is always equal to x <= DBL_MAX.  */\n+    (if (code == LT_EXPR)\n+     (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n+      (if (neg)\n+       (ge @0 { build_real (TREE_TYPE (@0), max); }))\n+      (le @0 { build_real (TREE_TYPE (@0), max); })))\n+    /* x != +Inf is always equal to !(x > DBL_MAX).  */\n+    (if (code == NE_EXPR)\n+     (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n+      (if (! HONOR_NANS (@0))\n+       (if (neg)\n+        (ge @0 { build_real (TREE_TYPE (@0), max); }))\n+       (le @0 { build_real (TREE_TYPE (@0), max); }))\n+      (if (neg)\n+       (bit_xor (lt @0 { build_real (TREE_TYPE (@0), max); })\n+\t        { build_one_cst (type); }))\n+      (bit_xor (gt @0 { build_real (TREE_TYPE (@0), max); })\n+       { build_one_cst (type); }))))))\n+\n+ /* If this is a comparison of a real constant with a PLUS_EXPR\n+    or a MINUS_EXPR of a real constant, we can convert it into a\n+    comparison with a revised real constant as long as no overflow\n+    occurs when unsafe_math_optimizations are enabled.  */\n+ (if (flag_unsafe_math_optimizations)\n+  (for op (plus minus)\n+   (simplify\n+    (cmp (op @0 REAL_CST@1) REAL_CST@2)\n+    (with\n+     {\n+       tree tem = const_binop (op == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR,\n+\t\t\t       TREE_TYPE (@1), @2, @1);\n+     }\n+     (if (!TREE_OVERFLOW (tem))\n+      (cmp @0 { tem; }))))))\n+\n+ /* Likewise, we can simplify a comparison of a real constant with\n+    a MINUS_EXPR whose first operand is also a real constant, i.e.\n+    (c1 - x) < c2 becomes x > c1-c2.  Reordering is allowed on\n+    floating-point types only if -fassociative-math is set.  */\n+ (if (flag_associative_math)\n+  (simplify\n+   (cmp (minus REAL_CST@0 @1) @2)\n+   (with { tree tem = const_binop (MINUS_EXPR, TREE_TYPE (@1), @0, @2); }\n+    (if (!TREE_OVERFLOW (tem))\n+     (cmp { tem; } @1)))))\n+\n+ /* Fold comparisons against built-in math functions.  */\n+ (if (flag_unsafe_math_optimizations\n+      && ! flag_errno_math)\n+  (for sq (SQRT)\n+   (simplify\n+    (cmp (sq @0) REAL_CST@1)\n+    (if (REAL_VALUE_NEGATIVE (TREE_REAL_CST (@1)))\n+     /* sqrt(x) < y is always false, if y is negative.  */\n+     (if (cmp == EQ_EXPR || cmp == LT_EXPR || cmp == LE_EXPR)\n+      { constant_boolean_node (false, type); })\n+     /* sqrt(x) > y is always true, if y is negative and we\n+\tdon't care about NaNs, i.e. negative values of x.  */\n+     (if (cmp == NE_EXPR || !HONOR_NANS (@0))\n+      { constant_boolean_node (true, type); })\n+     /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n+     (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))\n+    (if (cmp == GT_EXPR || cmp == GE_EXPR)\n+     (with\n+      {\n+       \tREAL_VALUE_TYPE c2;\n+\tREAL_ARITHMETIC (c2, MULT_EXPR, TREE_REAL_CST (@1), TREE_REAL_CST (@1));\n+\treal_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);\n+      }\n+      (if (REAL_VALUE_ISINF (c2))\n+       /* sqrt(x) > y is x == +Inf, when y is very large.  */\n+       (if (HONOR_INFINITIES (@0))\n+        (eq @0 { build_real (TREE_TYPE (@0), c2); }))\n+       { constant_boolean_node (false, type); })\n+      /* sqrt(x) > c is the same as x > c*c.  */\n+      (cmp @0 { build_real (TREE_TYPE (@0), c2); })))\n+    (if (cmp == LT_EXPR || cmp == LE_EXPR)\n+     (with\n+      {\n+       \tREAL_VALUE_TYPE c2;\n+\tREAL_ARITHMETIC (c2, MULT_EXPR, TREE_REAL_CST (@1), TREE_REAL_CST (@1));\n+\treal_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);\n+      }\n+      (if (REAL_VALUE_ISINF (c2))\n+       /* sqrt(x) < y is always true, when y is a very large\n+\t  value and we don't care about NaNs or Infinities.  */\n+       (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))\n+        { constant_boolean_node (true, type); })\n+       /* sqrt(x) < y is x != +Inf when y is very large and we\n+\t  don't care about NaNs.  */\n+       (if (! HONOR_NANS (@0))\n+        (ne @0 { build_real (TREE_TYPE (@0), c2); }))\n+       /* sqrt(x) < y is x >= 0 when y is very large and we\n+\t  don't care about Infinities.  */\n+       (if (! HONOR_INFINITIES (@0))\n+        (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))\n+       /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n+       (if (GENERIC)\n+        (truth_andif\n+\t (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n+\t (ne @0 { build_real (TREE_TYPE (@0), c2); }))))\n+      /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n+      (if (! REAL_VALUE_ISINF (c2)\n+           && ! HONOR_NANS (@0))\n+       (cmp @0 { build_real (TREE_TYPE (@0), c2); }))\n+      /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n+      (if (! REAL_VALUE_ISINF (c2)\n+           && GENERIC)\n+       (truth_andif\n+        (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n+\t(cmp @0 { build_real (TREE_TYPE (@0), c2); })))))))))\n \n /* Unordered tests if either argument is a NaN.  */\n (simplify\n@@ -1442,18 +1632,6 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Simplification of math builtins.  */\n \n-(define_operator_list LOG BUILT_IN_LOGF BUILT_IN_LOG BUILT_IN_LOGL)\n-(define_operator_list EXP BUILT_IN_EXPF BUILT_IN_EXP BUILT_IN_EXPL)\n-(define_operator_list LOG2 BUILT_IN_LOG2F BUILT_IN_LOG2 BUILT_IN_LOG2L)\n-(define_operator_list EXP2 BUILT_IN_EXP2F BUILT_IN_EXP2 BUILT_IN_EXP2L)\n-(define_operator_list LOG10 BUILT_IN_LOG10F BUILT_IN_LOG10 BUILT_IN_LOG10L)\n-(define_operator_list EXP10 BUILT_IN_EXP10F BUILT_IN_EXP10 BUILT_IN_EXP10L)\n-(define_operator_list POW BUILT_IN_POWF BUILT_IN_POW BUILT_IN_POWL)\n-(define_operator_list POW10 BUILT_IN_POW10F BUILT_IN_POW10 BUILT_IN_POW10L)\n-(define_operator_list SQRT BUILT_IN_SQRTF BUILT_IN_SQRT BUILT_IN_SQRTL)\n-(define_operator_list CBRT BUILT_IN_CBRTF BUILT_IN_CBRT BUILT_IN_CBRTL)\n-\n-\n /* fold_builtin_logarithm */\n (if (flag_unsafe_math_optimizations)\n  /* Special case, optimize logN(expN(x)) = x.  */"}]}