{"sha": "67f6e64994b49ec330708e1655065dbd9741e1d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdmNmU2NDk5NGI0OWVjMzMwNzA4ZTE2NTUwNjVkYmQ5NzQxZTFkNg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-09-06T06:58:42Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-09-06T06:58:42Z"}, "message": "Remove support for repo files (PR c++/91125).\n\n2019-09-06  Martin Liska  <mliska@suse.cz>\n\n\tPR c++/91125\n\t* Makefile.in: Remove tlink.o.\n\t* collect2.c (do_link): New function isolated\n\tfrom do_tlink.\n\t(main): Use.\n\t* collect2.h (do_tlink): Remove declaration of do_tlink.\n\t* doc/extend.texi: Remove documentation of -frepo.\n\t* doc/invoke.texi: Likewise.\n\t* doc/sourcebuild.texi: Remove cleanup-repo-files.\n\t* tlink.c: Remove.\n2019-09-06  Martin Liska  <mliska@suse.cz>\n\n\tPR c++/91125\n\t* c-common.c: Remove definition of flag_use_repository.\n\t* c-common.h: Likewise.\n\t* c-opts.c (c_common_handle_option):\n\tDo not handle OPT_frepo option.\n\t* c.opt: Mark the option with Deprecated.\n2019-09-06  Martin Liska  <mliska@suse.cz>\n\n\tPR c++/91125\n\t* Make-lang.in: Remove repo.o.\n\t* config-lang.in: Likewise.\n\t* cp-tree.h (init_repo): Remove declarations\n\tof repo-related functions.\n\t(repo_emit_p): Likewise.\n\t(repo_export_class_p): Likewise.\n\t(finish_repo): Likewise.\n\t* decl2.c (import_export_class): Always\n\tset -1 value/\n\t(mark_needed): Remove -frepo from comment.\n\t(import_export_decl): Similarly here.\n\t(c_parse_final_cleanups): Remove call of finish_repo.\n\t* lex.c (cxx_init): Remove call to init_repo.\n\t* optimize.c (can_alias_cdtor): Remove dead condition.\n\t* pt.c (push_template_decl_real): Update comment.\n\t(instantiate_decl): Remove dead code used for -frepo.\n\t* repo.c: Remove.\n2019-09-06  Martin Liska  <mliska@suse.cz>\n\n\tPR c++/91125\n\t* g++.dg/parse/repo1.C: Remove.\n\t* g++.dg/rtti/repo1.C: Remove.\n\t* g++.dg/template/repo1.C: Remove.\n\t* g++.dg/template/repo10.C: Remove.\n\t* g++.dg/template/repo11.C: Remove.\n\t* g++.dg/template/repo2.C: Remove.\n\t* g++.dg/template/repo3.C: Remove.\n\t* g++.dg/template/repo4.C: Remove.\n\t* g++.dg/template/repo5.C: Remove.\n\t* g++.dg/template/repo6.C: Remove.\n\t* g++.dg/template/repo7.C: Remove.\n\t* g++.dg/template/repo8.C: Remove.\n\t* g++.dg/template/repo9.C: Remove.\n\t* g++.old-deja/g++.pt/instantiate4.C: Remove.\n\t* g++.old-deja/g++.pt/instantiate6.C: Remove.\n\t* g++.old-deja/g++.pt/repo1.C: Remove.\n\t* g++.old-deja/g++.pt/repo2.C: Remove.\n\t* g++.old-deja/g++.pt/repo3.C: Remove.\n\t* g++.old-deja/g++.pt/repo4.C: Remove.\n\t* lib/g++.exp: Remove removal of repo files.\n\t* lib/gcc-dg.exp: Likewise.\n\t* lib/obj-c++.exp: Likewise.\n\nFrom-SVN: r275450", "tree": {"sha": "46ebc6701f5d6390841af0ca16cc9e0c51bf23e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46ebc6701f5d6390841af0ca16cc9e0c51bf23e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67f6e64994b49ec330708e1655065dbd9741e1d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f6e64994b49ec330708e1655065dbd9741e1d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f6e64994b49ec330708e1655065dbd9741e1d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f6e64994b49ec330708e1655065dbd9741e1d6/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebd247d4b3813f3d1ab83d04e338ed566d10de3e"}], "stats": {"total": 1967, "additions": 112, "deletions": 1855}, "files": [{"sha": "233072eeb581312e18305b7cf7650486587f8e5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -1,3 +1,16 @@\n+2019-09-06  Martin Liska  <mliska@suse.cz>\n+\n+\tPR c++/91125\n+\t* Makefile.in: Remove tlink.o.\n+\t* collect2.c (do_link): New function isolated\n+\tfrom do_tlink.\n+\t(main): Use.\n+\t* collect2.h (do_tlink): Remove declaration of do_tlink.\n+\t* doc/extend.texi: Remove documentation of -frepo.\n+\t* doc/invoke.texi: Likewise.\n+\t* doc/sourcebuild.texi: Remove cleanup-repo-files.\n+\t* tlink.c: Remove.\n+\n 2019-09-05  Jakub Jelinek  <jakub@redhat.com>\n \t    Jim Wilson  <jimw@sifive.com>\n "}, {"sha": "99d88a46f1d2be6ea8c8d2de82caf4a3c7bd0633", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -2118,7 +2118,7 @@ gcc-ranlib.c: gcc-ar.c\n gcc-nm.c: gcc-ar.c\n \tcp $^ $@\n \n-COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o vec.o ggc-none.o \\\n+COLLECT2_OBJS = collect2.o collect2-aix.o vec.o ggc-none.o \\\n   collect-utils.o file-find.o hash-table.o selftest.o\n COLLECT2_LIBS = @COLLECT2_LIBS@\n collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)"}, {"sha": "6e20cb478eeaa0f92e95a0e5b7be81962197527c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -1,3 +1,12 @@\n+2019-09-06  Martin Liska  <mliska@suse.cz>\n+\n+\tPR c++/91125\n+\t* c-common.c: Remove definition of flag_use_repository.\n+\t* c-common.h: Likewise.\n+\t* c-opts.c (c_common_handle_option):\n+\tDo not handle OPT_frepo option.\n+\t* c.opt: Mark the option with Deprecated.\n+\n 2019-09-04  Marek Polacek  <polacek@redhat.com>\n \n \t* c.opt (fdeduce-init-list): Ignored."}, {"sha": "3756219e5cf6921df320f8eeddf34ecb900b964d", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -249,11 +249,6 @@ const char *constant_string_class_name;\n \n int warn_abi_version = -1;\n \n-/* Nonzero means generate separate instantiation control files and\n-   juggle them at link time.  */\n-\n-int flag_use_repository;\n-\n /* The C++ dialect being used.  Default set in c_common_post_options.  */\n \n enum cxx_dialect cxx_dialect = cxx_unset;"}, {"sha": "a9f4d0c5c11e38b93db2a985da840c6532879176", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -701,11 +701,6 @@ extern int warn_abi_version;\n    != (warn_abi_version == 0\t\t\t\\\n        || warn_abi_version >= (N)))\n \n-/* Nonzero means generate separate instantiation control files and\n-   juggle them at link time.  */\n-\n-extern int flag_use_repository;\n-\n /* The supported C++ dialects.  */\n \n enum cxx_dialect {"}, {"sha": "23ab4cf739ed9d4da76b1e96b8cbc7e08755b3aa", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -501,12 +501,6 @@ c_common_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n \tcpp_opts->track_macro_expansion = 2;\n       break;\n \n-    case OPT_frepo:\n-      flag_use_repository = value;\n-      if (value)\n-\tflag_implicit_templates = 0;\n-      break;\n-\n     case OPT_ftabstop_:\n       /* It is documented that we silently ignore silly values.  */\n       if (value >= 1 && value <= 100)"}, {"sha": "ec54666302948cbcbc182ea07769c5e5c2e69b34", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -1763,8 +1763,8 @@ ObjC ObjC++ LTO Var(flag_replace_objc_classes)\n Used in Fix-and-Continue mode to indicate that object files may be swapped in at runtime.\n \n frepo\n-C++ ObjC++\n-Enable automatic template instantiation.\n+C++ ObjC++ Deprecated\n+Deprecated in GCC 10.  This switch has no effect.\n \n frtti\n C++ ObjC++ Optimization Var(flag_rtti) Init(1)"}, {"sha": "497207281f3e8e76be8cf47a3435a57b96c43e0d", "filename": "gcc/collect2.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -825,6 +825,30 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n   else\n     post_ld_pass (false); /* No LTO objects were found, no temp file.  */\n }\n+/* Entry point for linker invoation.  Called from main in collect2.c.\n+   LD_ARGV is an array of arguments for the linker.  */\n+\n+static void\n+do_link (char **ld_argv)\n+{\n+  struct pex_obj *pex;\n+  const char *prog = \"ld\";\n+  pex = collect_execute (prog, ld_argv, NULL, NULL,\n+\t\t\t PEX_LAST | PEX_SEARCH,\n+\t\t\t HAVE_GNU_LD && at_file_supplied);\n+  int ret = collect_wait (prog, pex);\n+  if (ret)\n+    {\n+      error (\"ld returned %d exit status\", ret);\n+      exit (ret);\n+    }\n+  else\n+    {\n+      /* We have just successfully produced an output file, so assume that we\n+\t may unlink it if need be for now on.  */\n+      may_unlink_output_file = true;\n+    }\n+}\n \f\n /* Main program.  */\n \n@@ -1704,7 +1728,7 @@ main (int argc, char **argv)\n        functions from precise cross reference insertions by the compiler.  */\n \n     if (early_exit || ld1_filter != SCAN_NOTHING)\n-      do_tlink (ld1_argv, object_lst);\n+      do_link (ld1_argv);\n \n     if (early_exit)\n       {\n@@ -1762,10 +1786,10 @@ main (int argc, char **argv)\n #endif\n       )\n     {\n-      /* Do tlink without additional code generation now if we didn't\n+      /* Do link without additional code generation now if we didn't\n \t do it earlier for scanning purposes.  */\n       if (ld1_filter == SCAN_NOTHING)\n-\tdo_tlink (ld1_argv, object_lst);\n+\tdo_link (ld1_argv);\n \n       if (lto_mode)\n         maybe_run_lto_and_relink (ld1_argv, object_lst, object, false);\n@@ -1868,13 +1892,13 @@ main (int argc, char **argv)\n \n   fork_execute (\"gcc\",  c_argv, at_file_supplied);\n #ifdef COLLECT_EXPORT_LIST\n-  /* On AIX we must call tlink because of possible templates resolution.  */\n-  do_tlink (ld2_argv, object_lst);\n+  /* On AIX we must call link because of possible templates resolution.  */\n+  do_link (ld2_argv);\n \n   if (lto_mode)\n     maybe_run_lto_and_relink (ld2_argv, object_lst, object, false);\n #else\n-  /* Otherwise, simply call ld because tlink is already done.  */\n+  /* Otherwise, simply call ld because link is already done.  */\n   if (lto_mode)\n     maybe_run_lto_and_relink (ld2_argv, object_lst, object, true);\n   else"}, {"sha": "77bb645e6cd94dbbe134ce1b533da69502b96edf", "filename": "gcc/collect2.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcollect2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcollect2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.h?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -1,4 +1,4 @@\n-/* Header file for collect/tlink routines.\n+/* Header file for collect routines.\n    Copyright (C) 1998-2019 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -20,8 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_COLLECT2_H\n #define GCC_COLLECT2_H\n \n-extern void do_tlink (char **, char **);\n-\n extern struct pex_obj *collect_execute (const char *, char **, const char *,\n \t\t\t\t\tconst char *, int flags);\n "}, {"sha": "c1c728210d795a794680776847ae74249bf3fb2a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -1,3 +1,24 @@\n+2019-09-06  Martin Liska  <mliska@suse.cz>\n+\n+\tPR c++/91125\n+\t* Make-lang.in: Remove repo.o.\n+\t* config-lang.in: Likewise.\n+\t* cp-tree.h (init_repo): Remove declarations\n+\tof repo-related functions.\n+\t(repo_emit_p): Likewise.\n+\t(repo_export_class_p): Likewise.\n+\t(finish_repo): Likewise.\n+\t* decl2.c (import_export_class): Always\n+\tset -1 value/\n+\t(mark_needed): Remove -frepo from comment.\n+\t(import_export_decl): Similarly here.\n+\t(c_parse_final_cleanups): Remove call of finish_repo.\n+\t* lex.c (cxx_init): Remove call to init_repo.\n+\t* optimize.c (can_alias_cdtor): Remove dead condition.\n+\t* pt.c (push_template_decl_real): Update comment.\n+\t(instantiate_decl): Remove dead code used for -frepo.\n+\t* repo.c: Remove.\n+\n 2019-09-05  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/91644 - ICE with constinit in function template."}, {"sha": "8430c4c4683f8bc58ee3edd5cfe44e0963b8ffc5", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -83,7 +83,7 @@ CXX_AND_OBJCXX_OBJS = \\\n \tcp/mangle.o cp/method.o \\\n \tcp/name-lookup.o cp/optimize.o \\\n \tcp/parser.o cp/pt.o cp/ptree.o \\\n-\tcp/repo.o cp/rtti.o \\\n+\tcp/rtti.o \\\n \tcp/search.o cp/semantics.o \\\n \tcp/tree.o cp/typeck.o cp/typeck2.o \\\n \tcp/vtable-class-hierarchy.o $(CXX_C_OBJS)"}, {"sha": "6e5f04677d69efce9eaea242c3c9ed44fc7e1379", "filename": "gcc/cp/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconfig-lang.in?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -49,7 +49,7 @@ gtfiles=\"\\\n \\$(srcdir)/cp/mangle.c \\$(srcdir)/cp/method.c \\\n \\$(srcdir)/cp/name-lookup.c \\\n \\$(srcdir)/cp/parser.c \\$(srcdir)/cp/pt.c \\\n-\\$(srcdir)/cp/repo.c \\$(srcdir)/cp/rtti.c \\\n+\\$(srcdir)/cp/rtti.c \\\n \\$(srcdir)/cp/semantics.c \\\n \\$(srcdir)/cp/tree.c \\$(srcdir)/cp/typeck2.c \\\n \\$(srcdir)/cp/vtable-class-hierarchy.c \\"}, {"sha": "a045214f7f9552831a4902dbf7eecba9ef5c1760", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -6903,12 +6903,6 @@ extern bool copy_guide_p\t\t\t(const_tree);\n extern bool template_guide_p\t\t\t(const_tree);\n extern void store_explicit_specifier\t\t(tree, tree);\n \n-/* in repo.c */\n-extern void init_repo\t\t\t\t(void);\n-extern int repo_emit_p\t\t\t\t(tree);\n-extern bool repo_export_class_p\t\t\t(const_tree);\n-extern void finish_repo\t\t\t\t(void);\n-\n /* in rtti.c */\n /* A vector of all tinfo decls that haven't been emitted yet.  */\n extern GTY(()) vec<tree, va_gc> *unemitted_tinfo_decls;"}, {"sha": "d4bb8814f14a4ff81949d2890b5945d6e10b9b53", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -2079,7 +2079,7 @@ import_export_class (tree ctype)\n        repository.  If the virtual table is assigned to this\n        translation unit, then export the class; otherwise, import\n        it.  */\n-      import_export = repo_export_class_p (ctype) ? 1 : -1;\n+      import_export = -1;\n   else if (TYPE_POLYMORPHIC_P (ctype))\n     {\n       /* The ABI specifies that the virtual table and associated\n@@ -2135,7 +2135,7 @@ mark_needed (tree decl)\n       struct cgraph_node *node = cgraph_node::get_create (decl);\n       node->forced_by_abi = true;\n \n-      /* #pragma interface and -frepo code can call mark_needed for\n+      /* #pragma interface can call mark_needed for\n           maybe-in-charge 'tors; mark the clones as well.  */\n       tree clone;\n       FOR_EACH_CLONE (clone, decl)\n@@ -2969,7 +2969,6 @@ tentative_decl_linkage (tree decl)\n void\n import_export_decl (tree decl)\n {\n-  int emit_p;\n   bool comdat_p;\n   bool import_p;\n   tree class_type = NULL_TREE;\n@@ -2980,11 +2979,7 @@ import_export_decl (tree decl)\n   /* We cannot determine what linkage to give to an entity with vague\n      linkage until the end of the file.  For example, a virtual table\n      for a class will be defined if and only if the key method is\n-     defined in this translation unit.  As a further example, consider\n-     that when compiling a translation unit that uses PCH file with\n-     \"-frepo\" it would be incorrect to make decisions about what\n-     entities to emit when building the PCH; those decisions must be\n-     delayed until the repository information has been processed.  */\n+     defined in this translation unit.  */\n   gcc_assert (at_eof);\n   /* Object file linkage for explicit instantiations is handled in\n      mark_decl_instantiated.  For static variables in functions with\n@@ -3030,27 +3025,7 @@ import_export_decl (tree decl)\n      unit.  */\n   import_p = false;\n \n-  /* See if the repository tells us whether or not to emit DECL in\n-     this translation unit.  */\n-  emit_p = repo_emit_p (decl);\n-  if (emit_p == 0)\n-    import_p = true;\n-  else if (emit_p == 1)\n-    {\n-      /* The repository indicates that this entity should be defined\n-\t here.  Make sure the back end honors that request.  */\n-      mark_needed (decl);\n-      /* Output the definition as an ordinary strong definition.  */\n-      DECL_EXTERNAL (decl) = 0;\n-      DECL_INTERFACE_KNOWN (decl) = 1;\n-      return;\n-    }\n-\n-  if (import_p)\n-    /* We have already decided what to do with this DECL; there is no\n-       need to check anything further.  */\n-    ;\n-  else if (VAR_P (decl) && DECL_VTABLE_OR_VTT_P (decl))\n+  if (VAR_P (decl) && DECL_VTABLE_OR_VTT_P (decl))\n     {\n       class_type = DECL_CONTEXT (decl);\n       import_export_class (class_type);\n@@ -3156,8 +3131,7 @@ import_export_decl (tree decl)\n     {\n       /* DECL is an implicit instantiation of a function or static\n \t data member.  */\n-      if ((flag_implicit_templates\n-\t   && !flag_use_repository)\n+      if (flag_implicit_templates\n \t  || (flag_implicit_inline_templates\n \t      && TREE_CODE (decl) == FUNCTION_DECL\n \t      && DECL_DECLARED_INLINE_P (decl)))\n@@ -5142,7 +5116,6 @@ c_parse_final_cleanups (void)\n \n   perform_deferred_noexcept_checks ();\n \n-  finish_repo ();\n   fini_constexpr ();\n \n   /* The entire file is now complete.  If requested, dump everything"}, {"sha": "25529e7ab1e50cc4ebe47ff78156cfed6bde5aae", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -332,8 +332,6 @@ cxx_init (void)\n \n   init_cp_pragma ();\n \n-  init_repo ();\n-\n   input_location = saved_loc;\n   return true;\n }"}, {"sha": "994ee9148c06bf3ceeeec13079ff76500b83e9e0", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -223,9 +223,6 @@ can_alias_cdtor (tree fn)\n   /* We can't use an alias if there are virtual bases.  */\n   if (CLASSTYPE_VBASECLASSES (DECL_CONTEXT (fn)))\n     return false;\n-  /* ??? Why not use aliases with -frepo?  */\n-  if (flag_use_repository)\n-    return false;\n   gcc_assert (DECL_MAYBE_IN_CHARGE_CDTOR_P (fn));\n   /* Don't use aliases for weak/linkonce definitions unless we can put both\n      symbols in the same COMDAT group.  */"}, {"sha": "c5915a5ecd08d3b52dc4b027d94c6059e0b0f9b7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -5835,7 +5835,7 @@ push_template_decl_real (tree decl, bool is_friend)\n       && TREE_PUBLIC (decl)\n       && VAR_OR_FUNCTION_DECL_P (decl))\n     /* Set DECL_COMDAT on template instantiations; if we force\n-       them to be emitted by explicit instantiation or -frepo,\n+       them to be emitted by explicit instantiation,\n        mark_needed will tell cgraph to do the right thing.  */\n     DECL_COMDAT (decl) = true;\n \n@@ -24671,22 +24671,6 @@ instantiate_decl (tree d, bool defer_ok, bool expl_inst_class_mem_p)\n \tadd_pending_template (d);\n       goto out;\n     }\n-  /* Tell the repository that D is available in this translation unit\n-     -- and see if it is supposed to be instantiated here.  */\n-  if (TREE_PUBLIC (d) && !DECL_REALLY_EXTERN (d) && !repo_emit_p (d))\n-    {\n-      /* In a PCH file, despite the fact that the repository hasn't\n-\t requested instantiation in the PCH it is still possible that\n-\t an instantiation will be required in a file that includes the\n-\t PCH.  */\n-      if (pch_file)\n-\tadd_pending_template (d);\n-      /* Instantiate inline functions so that the inliner can do its\n-\t job, even though we'll not be emitting a copy of this\n-\t function.  */\n-      if (!(TREE_CODE (d) == FUNCTION_DECL && possibly_inlined_p (d)))\n-\tgoto out;\n-    }\n \n   bool push_to_top, nested;\n   tree fn_context;"}, {"sha": "4c44a07f40c50bab57d1a09b7aab71c44f7e4df3", "filename": "gcc/cp/repo.c", "status": "removed", "additions": 0, "deletions": 374, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Fcp%2Frepo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Fcp%2Frepo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frepo.c?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,374 +0,0 @@\n-/* Code to maintain a C++ template repository.\n-   Copyright (C) 1995-2019 Free Software Foundation, Inc.\n-   Contributed by Jason Merrill (jason@cygnus.com)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* My strategy here is as follows:\n-\n-   Everything should be emitted in a translation unit where it is used.\n-   The results of the automatic process should be easily reproducible with\n-   explicit code.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"cp-tree.h\"\n-#include \"stringpool.h\"\n-#include \"toplev.h\"\n-\n-static const char *extract_string (const char **);\n-static const char *get_base_filename (const char *);\n-static FILE *open_repo_file (const char *);\n-static char *afgets (FILE *);\n-static FILE *reopen_repo_file_for_write (void);\n-\n-static GTY(()) vec<tree, va_gc> *pending_repo;\n-static char *repo_name;\n-\n-static const char *old_args, *old_dir, *old_main;\n-\n-static struct obstack temporary_obstack;\n-static bool temporary_obstack_initialized_p;\n-\n-/* Parse a reasonable subset of shell quoting syntax.  */\n-\n-static const char *\n-extract_string (const char **pp)\n-{\n-  const char *p = *pp;\n-  int backquote = 0;\n-  int inside = 0;\n-\n-  for (;;)\n-    {\n-      char c = *p;\n-      if (c == '\\0')\n-\tbreak;\n-      ++p;\n-      if (backquote)\n-\t{\n-\t  obstack_1grow (&temporary_obstack, c);\n-\t  backquote = 0;\n-\t}\n-      else if (! inside && c == ' ')\n-\tbreak;\n-      else if (! inside && c == '\\\\')\n-\tbackquote = 1;\n-      else if (c == '\\'')\n-\tinside = !inside;\n-      else\n-\tobstack_1grow (&temporary_obstack, c);\n-    }\n-\n-  obstack_1grow (&temporary_obstack, '\\0');\n-  *pp = p;\n-  return (char *) obstack_finish (&temporary_obstack);\n-}\n-\n-static const char *\n-get_base_filename (const char *filename)\n-{\n-  const char *p = getenv (\"COLLECT_GCC_OPTIONS\");\n-  const char *output = NULL;\n-  int compiling = 0;\n-\n-  while (p && *p)\n-    {\n-      const char *q = extract_string (&p);\n-\n-      if (strcmp (q, \"-o\") == 0)\n-\t{\n-\t  if (flag_compare_debug)\n-\t    /* Just in case aux_base_name was based on a name with two\n-\t       or more '.'s, add an arbitrary extension that will be\n-\t       stripped by the caller.  */\n-\t    output = concat (aux_base_name, \".o\", NULL);\n-\t  else\n-\t    output = extract_string (&p);\n-\t}\n-      else if (strcmp (q, \"-c\") == 0)\n-\tcompiling = 1;\n-    }\n-\n-  if (compiling && output)\n-    return output;\n-\n-  if (p && ! compiling)\n-    {\n-      warning (0, \"%<-frepo%> must be used with %<-c%>\");\n-      flag_use_repository = 0;\n-      return NULL;\n-    }\n-\n-  return lbasename (filename);\n-}\n-\n-static FILE *\n-open_repo_file (const char *filename)\n-{\n-  const char *p;\n-  const char *s = get_base_filename (filename);\n-\n-  if (s == NULL)\n-    return NULL;\n-\n-  p = lbasename (s);\n-  p = strrchr (p, '.');\n-  if (! p)\n-    p = s + strlen (s);\n-\n-  repo_name = XNEWVEC (char, p - s + 5);\n-  memcpy (repo_name, s, p - s);\n-  memcpy (repo_name + (p - s), \".rpo\", 5);\n-\n-  return fopen (repo_name, \"r\");\n-}\n-\n-static char *\n-afgets (FILE *stream)\n-{\n-  int c;\n-  while ((c = getc (stream)) != EOF && c != '\\n')\n-    obstack_1grow (&temporary_obstack, c);\n-  if (obstack_object_size (&temporary_obstack) == 0)\n-    return NULL;\n-  obstack_1grow (&temporary_obstack, '\\0');\n-  return (char *) obstack_finish (&temporary_obstack);\n-}\n-\n-void\n-init_repo (void)\n-{\n-  char *buf;\n-  const char *p;\n-  FILE *repo_file;\n-\n-  if (! flag_use_repository)\n-    return;\n-\n-  /* When a PCH file is loaded, the entire identifier table is\n-     replaced, with the result that IDENTIFIER_REPO_CHOSEN is cleared.\n-     So, we have to reread the repository file.  */\n-  lang_post_pch_load = init_repo;\n-\n-  if (!temporary_obstack_initialized_p)\n-    gcc_obstack_init (&temporary_obstack);\n-\n-  repo_file = open_repo_file (main_input_filename);\n-\n-  if (repo_file == 0)\n-    return;\n-\n-  while ((buf = afgets (repo_file)))\n-    {\n-      switch (buf[0])\n-\t{\n-\tcase 'A':\n-\t  old_args = ggc_strdup (buf + 2);\n-\t  break;\n-\tcase 'D':\n-\t  old_dir = ggc_strdup (buf + 2);\n-\t  break;\n-\tcase 'M':\n-\t  old_main = ggc_strdup (buf + 2);\n-\t  break;\n-\tcase 'O':\n-\t  /* A symbol that we were able to define the last time this\n-\t     file was compiled.  */\n-\t  break;\n-\tcase 'C':\n-\t  /* A symbol that the prelinker has requested that we\n-\t     define.  */\n-\t  {\n-\t    tree id = get_identifier (buf + 2);\n-\t    IDENTIFIER_REPO_CHOSEN (id) = 1;\n-\t  }\n-\t  break;\n-\tdefault:\n-\t  error (\"mysterious repository information in %s\", repo_name);\n-\t}\n-      obstack_free (&temporary_obstack, buf);\n-    }\n-  fclose (repo_file);\n-\n-  if (old_args && !get_random_seed (true)\n-      && (p = strstr (old_args, \"'-frandom-seed=\")))\n-    set_random_seed (extract_string (&p) + strlen (\"-frandom-seed=\"));\n-}\n-\n-static FILE *\n-reopen_repo_file_for_write (void)\n-{\n-  FILE *repo_file = fopen (repo_name, \"w\");\n-\n-  if (repo_file == 0)\n-    {\n-      error (\"cannot create repository information file %qs\", repo_name);\n-      flag_use_repository = 0;\n-    }\n-\n-  return repo_file;\n-}\n-\n-/* Emit any pending repos.  */\n-\n-void\n-finish_repo (void)\n-{\n-  tree val;\n-  char *dir, *args;\n-  FILE *repo_file;\n-  unsigned ix;\n-\n-  if (!flag_use_repository || flag_compare_debug)\n-    return;\n-\n-  if (seen_error ())\n-    return;\n-\n-  repo_file = reopen_repo_file_for_write ();\n-  if (repo_file == 0)\n-    goto out;\n-\n-  fprintf (repo_file, \"M %s\\n\", main_input_filename);\n-  dir = getpwd ();\n-  fprintf (repo_file, \"D %s\\n\", dir);\n-  args = getenv (\"COLLECT_GCC_OPTIONS\");\n-  if (args)\n-    {\n-      fprintf (repo_file, \"A %s\", args);\n-      /* If -frandom-seed is not among the ARGS, then add the value\n-\t that we chose.  That will ensure that the names of types from\n-\t anonymous namespaces will get the same mangling when this\n-\t file is recompiled.  */\n-      if (!strstr (args, \"'-frandom-seed=\"))\n-\tfprintf (repo_file, \" '-frandom-seed=\" HOST_WIDE_INT_PRINT_HEX_PURE \"'\", \n-\t\t get_random_seed (false));\n-      fprintf (repo_file, \"\\n\");\n-    }\n-\n-  FOR_EACH_VEC_SAFE_ELT_REVERSE (pending_repo, ix, val)\n-    {\n-      tree name = DECL_ASSEMBLER_NAME (val);\n-      char type = IDENTIFIER_REPO_CHOSEN (name) ? 'C' : 'O';\n-      fprintf (repo_file, \"%c %s\\n\", type, IDENTIFIER_POINTER (name));\n-    }\n-\n- out:\n-  if (repo_file)\n-    fclose (repo_file);\n-}\n-\n-/* DECL is a FUNCTION_DECL or VAR_DECL with vague linkage whose\n-   definition is available in this translation unit.  Returns 0 if\n-   this definition should not be emitted in this translation unit\n-   because it will be emitted elsewhere.  Returns 1 if the repository\n-   file indicates that that DECL should be emitted in this translation\n-   unit, or 2 if the repository file is not in use.  */\n-\n-int\n-repo_emit_p (tree decl)\n-{\n-  int ret = 0;\n-  gcc_assert (TREE_PUBLIC (decl));\n-  gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));\n-  gcc_assert (!DECL_REALLY_EXTERN (decl)\n-\t      /* A clone might not have its linkage flags updated yet\n-\t\t because we call import_export_decl before\n-\t\t maybe_clone_body.  */\n-\t      || DECL_ABSTRACT_ORIGIN (decl));\n-\n-  /* When not using the repository, emit everything.  */\n-  if (!flag_use_repository)\n-    return 2;\n-\n-  /* Only template instantiations are managed by the repository.  This\n-     is an artificial restriction; the code in the prelinker and here\n-     will work fine if all entities with vague linkage are managed by\n-     the repository.  */\n-  if (VAR_P (decl))\n-    {\n-      tree type = NULL_TREE;\n-      if (DECL_VTABLE_OR_VTT_P (decl))\n-\ttype = DECL_CONTEXT (decl);\n-      else if (DECL_TINFO_P (decl))\n-\ttype = TREE_TYPE (DECL_NAME (decl));\n-      if (!DECL_TEMPLATE_INSTANTIATION (decl)\n-\t  && (!TYPE_LANG_SPECIFIC (type)\n-\t      || !CLASSTYPE_TEMPLATE_INSTANTIATION (type)))\n-\treturn 2;\n-      /* Const static data members initialized by constant expressions must\n-\t be processed where needed so that their definitions are\n-\t available.  Still record them into *.rpo files, so if they\n-\t weren't actually emitted and collect2 requests them, they can\n-\t be provided.  */\n-      if (decl_maybe_constant_var_p (decl)\n-\t  && DECL_CLASS_SCOPE_P (decl))\n-\tret = 2;\n-    }\n-  else if (!DECL_TEMPLATE_INSTANTIATION (decl))\n-    return 2;\n-\n-  if (DECL_EXPLICIT_INSTANTIATION (decl))\n-    return 2;\n-\n-  /* For constructors and destructors, the repository contains\n-     information about the clones -- not the original function --\n-     because only the clones are emitted in the object file.  */\n-  if (DECL_MAYBE_IN_CHARGE_CDTOR_P (decl))\n-    {\n-      int emit_p = 0;\n-      tree clone;\n-      /* There is no early exit from this loop because we want to\n-\t ensure that all of the clones are marked as available in this\n-\t object file.  */\n-      FOR_EACH_CLONE (clone, decl)\n-\t/* The only possible results from the recursive call to\n-\t   repo_emit_p are 0 or 1.  */\n-\tif (repo_emit_p (clone))\n-\t  emit_p = 1;\n-      return emit_p;\n-    }\n-\n-  /* Keep track of all available entities.  */\n-  if (!DECL_REPO_AVAILABLE_P (decl))\n-    {\n-      DECL_REPO_AVAILABLE_P (decl) = 1;\n-      vec_safe_push (pending_repo, decl);\n-    }\n-\n-  return IDENTIFIER_REPO_CHOSEN (DECL_ASSEMBLER_NAME (decl)) ? 1 : ret;\n-}\n-\n-/* Returns true iff the prelinker has explicitly marked CLASS_TYPE for\n-   export from this translation unit.  */\n-\n-bool\n-repo_export_class_p (const_tree class_type)\n-{\n-  if (!flag_use_repository)\n-    return false;\n-  if (!CLASSTYPE_VTABLES (class_type))\n-    return false;\n-  /* If the virtual table has been assigned to this translation unit,\n-     export the class.  */\n-  return (IDENTIFIER_REPO_CHOSEN\n-\t  (DECL_ASSEMBLER_NAME (CLASSTYPE_VTABLES (class_type))));\n-}\n-\n-#include \"gt-cp-repo.h\""}, {"sha": "a922f5ca77a63498cc609f46245e7ec97e3cc510", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -24423,31 +24423,6 @@ fine-grained control when necessary. It is also the most portable\n alternative and programs using this approach will work with most modern\n compilers.\n \n-@item\n-@opindex frepo\n-Compile your template-using code with @option{-frepo}.  The compiler\n-generates files with the extension @samp{.rpo} listing all of the\n-template instantiations used in the corresponding object files that\n-could be instantiated there; the link wrapper, @samp{collect2},\n-then updates the @samp{.rpo} files to tell the compiler where to place\n-those instantiations and rebuild any affected object files.  The\n-link-time overhead is negligible after the first pass, as the compiler\n-continues to place the instantiations in the same files.\n-\n-This can be a suitable option for application code written for the Borland\n-model, as it usually just works.  Code written for the Cfront model \n-needs to be modified so that the template definitions are available at\n-one or more points of instantiation; usually this is as simple as adding\n-@code{#include <tmethods.cc>} to the end of each template header.\n-\n-For library code, if you want the library to provide all of the template\n-instantiations it needs, just try to link all of its object files\n-together; the link will fail, but cause the instantiations to be\n-generated as a side effect.  Be warned, however, that this may cause\n-conflicts if multiple libraries try to provide the same instantiations.\n-For greater control, use explicit instantiation as described in the next\n-option.\n-\n @item\n @opindex fno-implicit-templates\n Compile your code with @option{-fno-implicit-templates} to disable the"}, {"sha": "bfcd76e47bdddcd91300baa7356eee7cc94df18c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -222,7 +222,7 @@ in the following sections.\n -fno-nonansi-builtins  -fnothrow-opt  -fno-operator-names @gol\n -fno-optional-diags  -fpermissive @gol\n -fno-pretty-templates @gol\n--frepo  -fno-rtti  -fsized-deallocation @gol\n+-fno-rtti  -fsized-deallocation @gol\n -ftemplate-backtrace-limit=@var{n} @gol\n -ftemplate-depth=@var{n} @gol\n -fno-threadsafe-statics  -fuse-cxa-atexit @gol\n@@ -2701,12 +2701,6 @@ the default template arguments for that template.  If either of these\n behaviors make it harder to understand the error message rather than\n easier, you can use @option{-fno-pretty-templates} to disable them.\n \n-@item -frepo\n-@opindex frepo\n-Enable automatic template instantiation at link time.  This option also\n-implies @option{-fno-implicit-templates}.  @xref{Template\n-Instantiation}, for more information.\n-\n @item -fno-rtti\n @opindex fno-rtti\n @opindex frtti"}, {"sha": "d713c08f762598b377b78f0f9f902db07d51c289", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -2864,9 +2864,6 @@ int main() @{ return 0; @}\n @item cleanup-profile-file\n Removes profiling files generated for this test.\n \n-@item cleanup-repo-files\n-Removes files generated for this test for @option{-frepo}.\n-\n @end table\n \n @node Ada Tests"}, {"sha": "9a544bc27a63ab33129e792d250b5de547eb4e03", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -1,3 +1,29 @@\n+2019-09-06  Martin Liska  <mliska@suse.cz>\n+\n+\tPR c++/91125\n+\t* g++.dg/parse/repo1.C: Remove.\n+\t* g++.dg/rtti/repo1.C: Remove.\n+\t* g++.dg/template/repo1.C: Remove.\n+\t* g++.dg/template/repo10.C: Remove.\n+\t* g++.dg/template/repo11.C: Remove.\n+\t* g++.dg/template/repo2.C: Remove.\n+\t* g++.dg/template/repo3.C: Remove.\n+\t* g++.dg/template/repo4.C: Remove.\n+\t* g++.dg/template/repo5.C: Remove.\n+\t* g++.dg/template/repo6.C: Remove.\n+\t* g++.dg/template/repo7.C: Remove.\n+\t* g++.dg/template/repo8.C: Remove.\n+\t* g++.dg/template/repo9.C: Remove.\n+\t* g++.old-deja/g++.pt/instantiate4.C: Remove.\n+\t* g++.old-deja/g++.pt/instantiate6.C: Remove.\n+\t* g++.old-deja/g++.pt/repo1.C: Remove.\n+\t* g++.old-deja/g++.pt/repo2.C: Remove.\n+\t* g++.old-deja/g++.pt/repo3.C: Remove.\n+\t* g++.old-deja/g++.pt/repo4.C: Remove.\n+\t* lib/g++.exp: Remove removal of repo files.\n+\t* lib/gcc-dg.exp: Likewise.\n+\t* lib/obj-c++.exp: Likewise.\n+\n 2019-09-05  Jakub Jelinek  <jakub@redhat.com>\n \t    Jim Wilson  <jimw@sifive.com>\n "}, {"sha": "efadd58723eb1473694b1a9b889c439a94cff351", "filename": "gcc/testsuite/g++.dg/parse/repo1.C", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Frepo1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Frepo1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Frepo1.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,10 +0,0 @@\n-// { dg-options \"-frepo\" }\n-// { dg-require-host-local \"\" }\n-\n-extern \"C\" inline void f() {}\n-\n-int main () {\n-  f();\n-}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "f72a9730ab994fa99c597e43b7fc1d57897b883c", "filename": "gcc/testsuite/g++.dg/rtti/repo1.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frtti%2Frepo1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frtti%2Frepo1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Frtti%2Frepo1.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,19 +0,0 @@\n-// PR c++/22204\n-// { dg-options \"-frepo\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-#include <typeinfo>\n-template<int>\n-struct function1\n-{\n-  function1()\n-  {\n-    typeid(int[100]);\n-  }\n-};\n-function1<1> b;\n-\n-int main () {}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "342993eca144f878e3c4763420f12dd5cfb94bb0", "filename": "gcc/testsuite/g++.dg/template/repo1.C", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo1.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,20 +0,0 @@\n-// { dg-options \"-frepo\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-struct A {\n-  A();\n-};\n-\n-A::A() {}\n-\n-template <typename T>\n-struct B : public A {\n-  B() {} // { dg-bogus \"\" }\n-};\n-\n-B<int> b;\n-\n-int main () {}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "c92f7a52b60d40040308321cc2020f6e32c74101", "filename": "gcc/testsuite/g++.dg/template/repo10.C", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo10.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,16 +0,0 @@\n-// PR c++/51910\n-// { dg-options -frepo }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-// { dg-final cleanup-repo-files }\n-\n-template<typename T>\n-struct Foo\n-{\n-  virtual ~Foo() { }\n-};\n-\n-int main( int, char*[] )\n-{\n-  Foo<int> test;\n-}"}, {"sha": "5cabfd452ede048c27910ce87fd0de217fd5871e", "filename": "gcc/testsuite/g++.dg/template/repo11.C", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo11.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,31 +0,0 @@\n-// PR c++/64521\n-// { dg-options \"-frepo -std=c++11\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-// { dg-final cleanup-repo-files }\n-\n-template <typename H> struct J { J(H) {} };\n-template <unsigned long, typename...> struct K;\n-template <unsigned long I> struct K<I> {};\n-template <unsigned long I, typename H, typename... T>\n-struct K<I, H, T...> : K<I + 1, T...>, J<H> {\n-  K(const H &p1, const T &... p2) : K<I + 1, T...>(p2...), J<H>(p1) {}\n-};\n-template <typename... E> struct C : K<0, E...> {\n-  C(const E &... p1) : K<0, E...>(p1...) {}\n-};\n-template <typename> struct A {\n-  A() = default;\n-};\n-struct M;\n-template <typename> struct L {\n-  struct B {\n-    template <typename> static M *__test(...);\n-    typedef A<int> _Del;\n-    typedef decltype(__test<_Del>()) type;\n-  };\n-  C<typename B::type, A<M>> _M_t;\n-  L(typename B::type) : _M_t(0, A<M>()) {}\n-};\n-struct M {};\n-int main() { L<int>(new M); }"}, {"sha": "e3224155e97c47b2e4e77120a5576aef3e7d340f", "filename": "gcc/testsuite/g++.dg/template/repo2.C", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo2.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,18 +0,0 @@\n-// PR c++/17163\n-// { dg-options \"-frepo\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-template <int __inst>\n-struct __Atomicity_lock\n-{\n-  static unsigned char _S_atomicity_lock;\n-};\n-template <int __inst>\n-unsigned char __Atomicity_lock<__inst>::_S_atomicity_lock = 0;\n-template unsigned char __Atomicity_lock<0>::_S_atomicity_lock;\n-\n-int main () {\n-}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "cfa38a9e435375d019e595da5f9fbfa3c0801906", "filename": "gcc/testsuite/g++.dg/template/repo3.C", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo3.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,11 +0,0 @@\n-// { dg-options \"-frepo -DF='a'\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-template <typename A, typename B> void f () {}\n-template <typename A, typename B> void g () { f<int,int>(); }\n-int main () { g<int,int>(); }\n-\n-char c = F;\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "64882a8c694304c1a2c853c3dae08ab87f33f315", "filename": "gcc/testsuite/g++.dg/template/repo4.C", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo4.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,18 +0,0 @@\n-// PR c++/17775\n-// { dg-options \"-frepo\" }\n-// { dg-final { cleanup-repo-files } }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-namespace { \n-  struct Foo {}; \n-} \n- \n-template <typename Tp> \n-void foo(Tp) {} \n- \n-int \n-main() \n-{ \n-  foo(Foo()); \n-} "}, {"sha": "e45ade7df48cba8d170f0e99d0aac3bb1f648882", "filename": "gcc/testsuite/g++.dg/template/repo5.C", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo5.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,14 +0,0 @@\n-// PR c++/25625\n-// { dg-options \"-frepo\" } \n-// { dg-final { cleanup-repo-files } }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-template< typename T, T N > struct integral_c {\n-  static const T value = N;\n-  typedef integral_c< T, value + 1 > next;\n-};\n-template< typename T, T N > T const integral_c< T, N >::value;\n-integral_c<int,0> a;\n-\n-int main () {}"}, {"sha": "4b7178e2ad36200aab14b5a90ba54983569fa44a", "filename": "gcc/testsuite/g++.dg/template/repo6.C", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo6.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,26 +0,0 @@\n-// PR c++/34178\n-// { dg-options \"-frepo\" }\n-// { dg-final { cleanup-repo-files } }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-template<typename T>\n-class A\n-{\n-private:\n-  static const int x;\n-  static int y;\n-\n-public:\n-  int getX () { return x + y; }\n-};\n-\n-template<typename T> const int A<T>::x = 0;\n-template<typename T> int A<T>::y = 0;\n-\n-int\n-main ()\n-{\n-  A<int> a;\n-  return a.getX();\n-}"}, {"sha": "dafb3f5597c1c165094df7fe1f3e81559fa88a57", "filename": "gcc/testsuite/g++.dg/template/repo7.C", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo7.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,25 +0,0 @@\n-// PR c++/34340\n-// { dg-options \"-frepo\" }\n-// { dg-final { cleanup-repo-files } }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-struct A\n-{\n-  int a;\n-};\n-\n-template <typename T> struct D\n-{\n-  static const A b;\n-};\n-\n-template<typename T> const A D<T>::b = { 2 };\n-template class D<A>;\n-\n-const A *x = &D<A>::b;\n-\n-int\n-main ()\n-{\n-}"}, {"sha": "c51592c934919e5e499d8a76b85402f75984d375", "filename": "gcc/testsuite/g++.dg/template/repo8.C", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo8.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,24 +0,0 @@\n-// PR c++/34340\n-// { dg-options \"-frepo\" }\n-// { dg-final { cleanup-repo-files } }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-struct A\n-{\n-  int a;\n-};\n-\n-template <typename T> struct D\n-{\n-  static const A b;\n-};\n-\n-template<typename T> const A D<T>::b = { 2 };\n-\n-const A *x = &D<A>::b;\n-\n-int\n-main ()\n-{\n-}"}, {"sha": "7ddc6bf56d3e1075d98e2be13ef02215d08ebe1e", "filename": "gcc/testsuite/g++.dg/template/repo9.C", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frepo9.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,49 +0,0 @@\n-// PR c++/36364\n-// { dg-options \"-frepo\" }\n-// { dg-final { cleanup-repo-files } }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-template <typename C> struct A\n-{\n-  static void assign (C &c1, const C &c2) { c1 = c2; }\n-};\n-\n-template <typename C, typename T> struct B\n-{\n-  struct D\n-  {\n-    static const C terminal;\n-    static unsigned long stor[];\n-    static D &empty_rep ()\n-    {\n-      void *p = reinterpret_cast <void *>(&stor);\n-      return *reinterpret_cast <D *>(p);\n-    }\n-    void test (unsigned long n)\n-    {\n-      T::assign (this->refdata ()[n], terminal);\n-    }\n-    C *refdata () throw ()\n-    {\n-      return reinterpret_cast <C *>(this + 1);\n-    }\n-  };\n-  C *dataplus;\n-  C *data () const { return dataplus; }\n-  D *rep () const { return &((reinterpret_cast < D * >(data ()))[-1]); }\n-  static D & empty_rep () { return D::empty_rep (); }\n-  B () : dataplus (empty_rep ().refdata ()) { }\n-  ~B () { }\n-  void push_back (C c) { rep ()->test (10); }\n-};\n-\n-template <typename C, typename T> const C B <C, T>::D::terminal = C ();\n-template <typename C, typename T> unsigned long B <C, T>::D::stor[64];\n-\n-int\n-main ()\n-{\n-  B <char, A <char> > s;\n-  s.push_back ('a');\n-}"}, {"sha": "d7a8cab31c541293a2d8de8f66f0983f5a4b407c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/instantiate4.C", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate4.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,31 +0,0 @@\n-// { dg-do link }\n-// { dg-options \"-frepo -Werror\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-\n-// Submitted by Melissa O'Neill <oneill@cs.sfu.ca>\n-// the vtable of Foo<int> wouldn't be generated\n-\n-template <typename A>\n-struct Foo {\n-   virtual void foo() {}\n-};\n-\n-template <typename A>\n-struct Bar {   \n-   void bar();\n-};\n-\n-template <typename A> \n-void Bar<A>::bar() {\n-   Foo<A> oof;\n-}\n-\n-int main () {\n-    Bar<int> rab;\n-    \n-    rab.bar();\n-}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "6726b216673e061062384f15e4854c76cfe985a0", "filename": "gcc/testsuite/g++.old-deja/g++.pt/instantiate6.C", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finstantiate6.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,29 +0,0 @@\n-// { dg-do link }\n-// { dg-options \"-frepo\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-// Simplified from testcase by Erez Louidor Lior <s3824888@techst02.technion.ac.il>\n-\n-template <class T>\n-class foo{\n-public:\n-  void g();\n-  void h();\n-};\n-\n-template <class T>\n-void foo<T>::g() {\n-  h();\n-}\n-\n-template <class T>\n-void foo<T>::h() {\n-}\n-\n-int main() {\n-  foo<int> f;\n-  f.g();\n-}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "bdfe306b4ad5dd4b6b701169e4a366c437da2991", "filename": "gcc/testsuite/g++.old-deja/g++.pt/repo1.C", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo1.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,24 +0,0 @@\n-// { dg-do link }\n-// { dg-options \"-frepo\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-// Bug: g++ complains about duplicate explicit instantiations with -frepo.\n-// From Jason Merrill <jason@cygnus.com>\n-\n-// Build then link:\n-\n-template <class T> struct A {\n-  virtual ~A () { }\n-};\n-\n-template <class T> void g (T t) { }\n-\n-template class A<int>;\n-\n-int main ()\n-{\n-  g (42);\n-}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "a8d8b1217a165c52afeab7c89d31aa77dc1ad534", "filename": "gcc/testsuite/g++.old-deja/g++.pt/repo2.C", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo2.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,28 +0,0 @@\n-// { dg-do link  }\n-// { dg-options \"-frepo\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-// Test that collect2 isn't confused by GNU ld's \"In function `foo':\" message.\n-// Contributed by Jason Merrill <jason@cygnus.com>\n-\n-// Build then link:\n-\n-template <class T>\n-T f (T t)\n-{\n-  return t;\n-}\n-\n-template <class T>\n-T g (T t)\n-{\n-  return f (t);\n-}\n-\n-int main ()\n-{\n-  int i = g (42);\n-}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "2f62139660ed5df41e1cdb73e8c26b2903fba04e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/repo3.C", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo3.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,39 +0,0 @@\n-// { dg-do link }\n-// { dg-options \"-frepo\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-// Test that we properly generate the vtable and such for C.\n-// Contributed by scott snyder <snyder@fnal.gov>\n-\n-// Build then link:\n-\n-struct A\n-{\n-  virtual ~A () {}\n-};\n-\n-template <typename T>\n-struct B : virtual public A\n-{\n-  virtual void foo () {}\n-};\n-\n-template <typename T>\n-struct C : virtual public A\n-{\n-};\n-\n-template <typename T>\n-struct D : public B<T>, public C<T>\n-{\n-};\n-\n-int\n-main ()\n-{\n-  D<int> x;\n-  return 0;\n-}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "84575cd9469ed8922477226d316889d4deac5635", "filename": "gcc/testsuite/g++.old-deja/g++.pt/repo4.C", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Frepo4.C?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,19 +0,0 @@\n-// { dg-do link }\n-// { dg-options \"-frepo\" }\n-// { dg-require-host-local \"\" }\n-// { dg-skip-if \"dkms are not final links\" { vxworks_kernel } }\n-\n-template <class T>\n-struct S {\n-  ~S ();\n-};\n-\n-template <class T>\n-S<T>::~S () {}\n-\n-int main ()\n-{\n-  S<int> s;\n-}\n-\n-// { dg-final { cleanup-repo-files } }"}, {"sha": "bccabbc84d705373cd457580f29e929807958068", "filename": "gcc/testsuite/lib/g++.exp", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fg%2B%2B.exp?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -317,12 +317,6 @@ proc g++_target_compile { source dest type options } {\n \n     set options [concat \"$ALWAYS_CXXFLAGS\" $options]\n \n-    if { [regexp \"(^| )-frepo( |$)\" $options] && \\\n-\t [regexp \"\\.o(|bj)$\" $dest] } then {\n-\tregsub \"\\.o(|bj)$\" $dest \".rpo\" rponame\n-\texec rm -f $rponame\n-    }\n-\n     # bind_pic_locally adds -fpie/-fPIE flags to flags_to_postpone and it is\n     # appended here to multilib_flags as it can be overridden by the latter\n     # if it was added earlier. After the target_compile, multilib_flags is"}, {"sha": "1df645e283c46c9c5debfc7f1762f1a05e71cc65", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -242,14 +242,6 @@ proc gcc-dg-test-1 { target_compile prog do_what extra_tool_flags } {\n \n     set options [list]\n \n-    # Tests should be able to use \"dg-do repo\".  However, the dg test\n-    # driver checks the argument to dg-do against a list of acceptable\n-    # options, and \"repo\" is not among them.  Therefore, we resort to\n-    # this ugly approach.\n-    if [string match \"*-frepo*\" $extra_tool_flags] then {\n-\tset do_what \"repo\"\n-    }\n-\n     switch $do_what {\n \t\"preprocess\" {\n \t    set compile_type \"preprocess\"\n@@ -724,24 +716,6 @@ proc cleanup-coverage-files { } {\n     }\n }\n \n-# Remove compiler-generated files from -repo for the current test.\n-proc cleanup-repo-files { } {\n-    global additional_sources_used\n-    set testcase [testname-for-summary]\n-    # The name might include a list of options; extract the file name.\n-    set testcase [lindex $testcase 0]\n-    remove-build-file \"[file rootname [file tail $testcase]].o\"\n-    remove-build-file \"[file rootname [file tail $testcase]].rpo\"\n-\n-    # Clean up files for additional source files.\n-    if [info exists additional_sources_used] {\n-\tforeach srcfile $additional_sources_used {\n-\t    remove-build-file \"[file rootname [file tail $srcfile]].o\"\n-\t    remove-build-file \"[file rootname [file tail $srcfile]].rpo\"\n-\t}\n-    }\n-}\n-\n # Remove a final insns dump file for the current test.\n proc cleanup-final-insns-dump { } {\n     set testcase [testname-for-summary]"}, {"sha": "7e7bd3cbe6532a7d31a74838426d41c301a88e95", "filename": "gcc/testsuite/lib/obj-c++.exp", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Ftestsuite%2Flib%2Fobj-c%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f6e64994b49ec330708e1655065dbd9741e1d6/gcc%2Ftestsuite%2Flib%2Fobj-c%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fobj-c%2B%2B.exp?ref=67f6e64994b49ec330708e1655065dbd9741e1d6", "patch": "@@ -377,12 +377,6 @@ proc obj-c++_target_compile { source dest type options } {\n \n     set options [concat \"$ALWAYS_OBJCXXFLAGS\" $options];\n \n-    if { [regexp \"(^| )-frepo( |$)\" $options] && \\\n-\t [regexp \"\\.o(|bj)$\" $dest] } then {\n-\tregsub \"\\.o(|bj)$\" $dest \".rpo\" rponame\n-\texec rm -f $rponame\n-    }\n-\n     set options [dg-additional-files-options $options $source]\n \n     set result [target_compile $source $dest $type $options]"}, {"sha": "485000b54663bbf888d64bec493a129dd97943df", "filename": "gcc/tlink.c", "status": "removed", "additions": 0, "deletions": 867, "changes": 867, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebd247d4b3813f3d1ab83d04e338ed566d10de3e/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=ebd247d4b3813f3d1ab83d04e338ed566d10de3e", "patch": "@@ -1,867 +0,0 @@\n-/* Scan linker error messages for missing template instantiations and provide\n-   them.\n-\n-   Copyright (C) 1995-2019 Free Software Foundation, Inc.\n-   Contributed by Jason Merrill (jason@cygnus.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"intl.h\"\n-#include \"obstack.h\"\n-#include \"demangle.h\"\n-#include \"collect2.h\"\n-#include \"collect-utils.h\"\n-#include \"filenames.h\"\n-#include \"diagnostic-core.h\"\n-\n-/* TARGET_64BIT may be defined to use driver specific functionality. */\n-#undef TARGET_64BIT\n-#define TARGET_64BIT TARGET_64BIT_DEFAULT\n-\n-#define MAX_ITERATIONS 17\n-\n-/* Defined in the automatically-generated underscore.c.  */\n-extern int prepends_underscore;\n-\n-static int tlink_verbose;\n-\n-static char *initial_cwd;\n-\f\n-/* Hash table boilerplate for working with htab_t.  We have hash tables\n-   for symbol names, file names, and demangled symbols.  */\n-\n-typedef struct symbol_hash_entry\n-{\n-  const char *key;\n-  struct file_hash_entry *file;\n-  int chosen;\n-  int tweaking;\n-  int tweaked;\n-} symbol;\n-\n-typedef struct file_hash_entry\n-{\n-  const char *key;\n-  const char *args;\n-  const char *dir;\n-  const char *main;\n-  int tweaking;\n-} file;\n-\n-typedef const char *str;\n-\n-typedef struct demangled_hash_entry\n-{\n-  const char *key;\n-  vec<str> mangled;\n-} demangled;\n-\n-/* Hash and comparison functions for these hash tables.  */\n-\n-static int hash_string_eq (const void *, const void *);\n-static hashval_t hash_string_hash (const void *);\n-\n-static int\n-hash_string_eq (const void *s1_p, const void *s2_p)\n-{\n-  const char *const *s1 = (const char *const *) s1_p;\n-  const char *s2 = (const char *) s2_p;\n-  return strcmp (*s1, s2) == 0;\n-}\n-\n-static hashval_t\n-hash_string_hash (const void *s_p)\n-{\n-  const char *const *s = (const char *const *) s_p;\n-  return (*htab_hash_string) (*s);\n-}\n-\n-static htab_t symbol_table;\n-\n-static struct symbol_hash_entry * symbol_hash_lookup (const char *, int);\n-static struct file_hash_entry * file_hash_lookup (const char *);\n-static struct demangled_hash_entry *demangled_hash_lookup (const char *, int);\n-static void symbol_push (symbol *);\n-static symbol * symbol_pop (void);\n-static void file_push (file *);\n-static file * file_pop (void);\n-static char * frob_extension (const char *, const char *);\n-static char * obstack_fgets (FILE *, struct obstack *);\n-static char * tfgets (FILE *);\n-static char * pfgets (FILE *);\n-static void freadsym (FILE *, file *, int);\n-static void read_repo_file (file *);\n-static void maybe_tweak (char *, file *);\n-static int recompile_files (void);\n-static int read_repo_files (char **);\n-static void demangle_new_symbols (void);\n-static int scan_linker_output (const char *);\n-\n-/* Look up an entry in the symbol hash table.  */\n-\n-static struct symbol_hash_entry *\n-symbol_hash_lookup (const char *string, int create)\n-{\n-  void **e;\n-  e = htab_find_slot_with_hash (symbol_table, string,\n-\t\t\t\t(*htab_hash_string) (string),\n-\t\t\t\tcreate ? INSERT : NO_INSERT);\n-  if (e == NULL)\n-    return NULL;\n-  if (*e == NULL)\n-    {\n-      struct symbol_hash_entry *v;\n-      *e = v = XCNEW (struct symbol_hash_entry);\n-      v->key = xstrdup (string);\n-    }\n-  return (struct symbol_hash_entry *) *e;\n-}\n-\n-static htab_t file_table;\n-\n-/* Look up an entry in the file hash table.  */\n-\n-static struct file_hash_entry *\n-file_hash_lookup (const char *string)\n-{\n-  void **e;\n-  e = htab_find_slot_with_hash (file_table, string,\n-\t\t\t\t(*htab_hash_string) (string),\n-\t\t\t\tINSERT);\n-  if (*e == NULL)\n-    {\n-      struct file_hash_entry *v;\n-      *e = v = XCNEW (struct file_hash_entry);\n-      v->key = xstrdup (string);\n-    }\n-  return (struct file_hash_entry *) *e;\n-}\n-\n-static htab_t demangled_table;\n-\n-/* Look up an entry in the demangled name hash table.  */\n-\n-static struct demangled_hash_entry *\n-demangled_hash_lookup (const char *string, int create)\n-{\n-  void **e;\n-  e = htab_find_slot_with_hash (demangled_table, string,\n-\t\t\t\t(*htab_hash_string) (string),\n-\t\t\t\tcreate ? INSERT : NO_INSERT);\n-  if (e == NULL)\n-    return NULL;\n-  if (*e == NULL)\n-    {\n-      struct demangled_hash_entry *v;\n-      *e = v = XCNEW (struct demangled_hash_entry);\n-      v->key = xstrdup (string);\n-    }\n-  return (struct demangled_hash_entry *) *e;\n-}\n-\f\n-/* Stack code.  */\n-\n-struct symbol_stack_entry\n-{\n-  symbol *value;\n-  struct symbol_stack_entry *next;\n-};\n-struct obstack symbol_stack_obstack;\n-struct symbol_stack_entry *symbol_stack;\n-\n-struct file_stack_entry\n-{\n-  file *value;\n-  struct file_stack_entry *next;\n-};\n-struct obstack file_stack_obstack;\n-struct file_stack_entry *file_stack;\n-\n-static void\n-symbol_push (symbol *p)\n-{\n-  struct symbol_stack_entry *ep\n-    = XOBNEW (&symbol_stack_obstack, struct symbol_stack_entry);\n-  ep->value = p;\n-  ep->next = symbol_stack;\n-  symbol_stack = ep;\n-}\n-\n-static symbol *\n-symbol_pop (void)\n-{\n-  struct symbol_stack_entry *ep = symbol_stack;\n-  symbol *p;\n-  if (ep == NULL)\n-    return NULL;\n-  p = ep->value;\n-  symbol_stack = ep->next;\n-  obstack_free (&symbol_stack_obstack, ep);\n-  return p;\n-}\n-\n-static void\n-file_push (file *p)\n-{\n-  struct file_stack_entry *ep;\n-\n-  if (p->tweaking)\n-    return;\n-\n-  ep = XOBNEW (&file_stack_obstack, struct file_stack_entry);\n-  ep->value = p;\n-  ep->next = file_stack;\n-  file_stack = ep;\n-  p->tweaking = 1;\n-}\n-\n-static file *\n-file_pop (void)\n-{\n-  struct file_stack_entry *ep = file_stack;\n-  file *p;\n-  if (ep == NULL)\n-    return NULL;\n-  p = ep->value;\n-  file_stack = ep->next;\n-  obstack_free (&file_stack_obstack, ep);\n-  p->tweaking = 0;\n-  return p;\n-}\n-\f\n-/* Other machinery.  */\n-\n-/* Initialize the tlink machinery.  Called from do_tlink.  */\n-\n-static void\n-tlink_init (void)\n-{\n-  const char *p;\n-\n-  symbol_table = htab_create (500, hash_string_hash, hash_string_eq,\n-\t\t\t      NULL);\n-  file_table = htab_create (500, hash_string_hash, hash_string_eq,\n-\t\t\t    NULL);\n-  demangled_table = htab_create (500, hash_string_hash, hash_string_eq,\n-\t\t\t\t NULL);\n-\n-  obstack_begin (&symbol_stack_obstack, 0);\n-  obstack_begin (&file_stack_obstack, 0);\n-\n-  p = getenv (\"TLINK_VERBOSE\");\n-  if (p)\n-    tlink_verbose = atoi (p);\n-  else\n-    {\n-      tlink_verbose = 1;\n-      if (verbose)\n-\ttlink_verbose = 2;\n-      if (debug)\n-\ttlink_verbose = 3;\n-    }\n-\n-  initial_cwd = getpwd ();\n-}\n-\n-static int\n-tlink_execute (const char *prog, char **argv, const char *outname,\n-\t       const char *errname, bool use_atfile)\n-{\n-  struct pex_obj *pex;\n-\n-  pex = collect_execute (prog, argv, outname, errname,\n-\t\t\t PEX_LAST | PEX_SEARCH, use_atfile);\n-  return collect_wait (prog, pex);\n-}\n-\n-static char *\n-frob_extension (const char *s, const char *ext)\n-{\n-  const char *p;\n-\n-  p = strrchr (lbasename (s), '.');\n-  if (! p)\n-    p = s + strlen (s);\n-\n-  obstack_grow (&temporary_obstack, s, p - s);\n-  return (char *) obstack_copy0 (&temporary_obstack, ext, strlen (ext));\n-}\n-\n-static char *\n-obstack_fgets (FILE *stream, struct obstack *ob)\n-{\n-  int c;\n-  while ((c = getc (stream)) != EOF && c != '\\n')\n-    obstack_1grow (ob, c);\n-  if (obstack_object_size (ob) == 0)\n-    return NULL;\n-  obstack_1grow (ob, '\\0');\n-  return XOBFINISH (ob, char *);\n-}\n-\n-static char *\n-tfgets (FILE *stream)\n-{\n-  return obstack_fgets (stream, &temporary_obstack);\n-}\n-\n-static char *\n-pfgets (FILE *stream)\n-{\n-  return xstrdup (tfgets (stream));\n-}\n-\f\n-/* Real tlink code.  */\n-\n-/* Subroutine of read_repo_file.  We are reading the repo file for file F,\n-   which is coming in on STREAM, and the symbol that comes next in STREAM\n-   is offered, chosen or provided if CHOSEN is 0, 1 or 2, respectively.\n-\n-   XXX \"provided\" is unimplemented, both here and in the compiler.  */\n-\n-static void\n-freadsym (FILE *stream, file *f, int chosen)\n-{\n-  symbol *sym;\n-\n-  {\n-    const char *name = tfgets (stream);\n-    sym = symbol_hash_lookup (name, true);\n-  }\n-\n-  if (sym->file == NULL)\n-    {\n-      /* We didn't have this symbol already, so we choose this file.  */\n-\n-      symbol_push (sym);\n-      sym->file = f;\n-      sym->chosen = chosen;\n-    }\n-  else if (chosen)\n-    {\n-      /* We want this file; cast aside any pretender.  */\n-\n-      if (sym->chosen && sym->file != f)\n-\t{\n-\t  if (sym->chosen == 1)\n-\t    file_push (sym->file);\n-\t  else\n-\t    {\n-\t      file_push (f);\n-\t      f = sym->file;\n-\t      chosen = sym->chosen;\n-\t    }\n-\t}\n-      sym->file = f;\n-      sym->chosen = chosen;\n-    }\n-}\n-\n-/* Read in the repo file denoted by F, and record all its information.  */\n-\n-static void\n-read_repo_file (file *f)\n-{\n-  char c;\n-  FILE *stream = fopen (f->key, \"r\");\n-\n-  if (tlink_verbose >= 2)\n-    fprintf (stderr, _(\"collect: reading %s\\n\"), f->key);\n-\n-  while (fscanf (stream, \"%c \", &c) == 1)\n-    {\n-      switch (c)\n-\t{\n-\tcase 'A':\n-\t  f->args = pfgets (stream);\n-\t  break;\n-\tcase 'D':\n-\t  f->dir = pfgets (stream);\n-\t  break;\n-\tcase 'M':\n-\t  f->main = pfgets (stream);\n-\t  break;\n-\tcase 'P':\n-\t  freadsym (stream, f, 2);\n-\t  break;\n-\tcase 'C':\n-\t  freadsym (stream, f, 1);\n-\t  break;\n-\tcase 'O':\n-\t  freadsym (stream, f, 0);\n-\t  break;\n-\t}\n-      obstack_free (&temporary_obstack, temporary_firstobj);\n-    }\n-  fclose (stream);\n-  if (f->args == NULL)\n-    f->args = getenv (\"COLLECT_GCC_OPTIONS\");\n-  if (f->dir == NULL)\n-    f->dir = \".\";\n-}\n-\n-/* We might want to modify LINE, which is a symbol line from file F.  We do\n-   this if either we saw an error message referring to the symbol in\n-   question, or we have already allocated the symbol to another file and\n-   this one wants to emit it as well.  */\n-\n-static void\n-maybe_tweak (char *line, file *f)\n-{\n-  symbol *sym = symbol_hash_lookup (line + 2, false);\n-\n-  if ((sym->file == f && sym->tweaking)\n-      || (sym->file != f && line[0] == 'C'))\n-    {\n-      sym->tweaking = 0;\n-      sym->tweaked = 1;\n-\n-      if (line[0] == 'O')\n-\t{\n-\t  line[0] = 'C';\n-\t  sym->chosen = 1;\n-\t}\n-      else\n-\t{\n-\t  line[0] = 'O';\n-\t  sym->chosen = 0;\n-\t}\n-    }\n-}\n-\n-/* Update the repo files for each of the object files we have adjusted and\n-   recompile.  */\n-\n-static int\n-recompile_files (void)\n-{\n-  file *f;\n-\n-  putenv (xstrdup (\"COMPILER_PATH=\"));\n-  putenv (xstrdup (\"LIBRARY_PATH=\"));\n-\n-  while ((f = file_pop ()) != NULL)\n-    {\n-      char *line;\n-      const char *p, *q;\n-      char **argv;\n-      struct obstack arg_stack;\n-      FILE *stream = fopen (f->key, \"r\");\n-      const char *const outname = frob_extension (f->key, \".rnw\");\n-      FILE *output = fopen (outname, \"w\");\n-\n-      while ((line = tfgets (stream)) != NULL)\n-\t{\n-\t  switch (line[0])\n-\t    {\n-\t    case 'C':\n-\t    case 'O':\n-\t      maybe_tweak (line, f);\n-\t    }\n-\t  fprintf (output, \"%s\\n\", line);\n-\t}\n-      fclose (stream);\n-      fclose (output);\n-      /* On Windows \"rename\" returns -1 and sets ERRNO to EACCESS if\n-\t the new file name already exists.  Therefore, we explicitly\n-\t remove the old file first.  */\n-      if (remove (f->key) == -1)\n-\tfatal_error (input_location,\n-\t\t     \"removing repository file %qs: %m\", f->key);\n-      if (rename (outname, f->key) == -1)\n-\tfatal_error (input_location, \"renaming repository file from \"\n-\t\t     \"%qs to %qs: %m\", outname, f->key);\n-\n-      if (!f->args)\n-\t{\n-\t  error (\"repository file %qs does not contain command-line \"\n-\t\t \"arguments\", f->key);\n-\t  return 0;\n-\t}\n-\n-      /* Build a null-terminated argv array suitable for\n-\t tlink_execute().  Manipulate arguments on the arg_stack while\n-\t building argv on the temporary_obstack.  */\n-\n-      obstack_init (&arg_stack);\n-      obstack_ptr_grow (&temporary_obstack, c_file_name);\n-\n-      for (p = f->args; *p != '\\0'; p = q + 1)\n-\t{\n-\t  /* Arguments are delimited by single-quotes.  Find the\n-\t     opening quote.  */\n-\t  p = strchr (p, '\\'');\n-\t  if (!p)\n-\t    goto done;\n-\n-\t  /* Find the closing quote.  */\n-\t  q = strchr (p + 1, '\\'');\n-\t  if (!q)\n-\t    goto done;\n-\n-\t  obstack_grow (&arg_stack, p + 1, q - (p + 1));\n-\n-\t  /* Replace '\\'' with '.  This is how set_collect_gcc_options\n-\t     encodes a single-quote.  */\n-\t  while (q[1] == '\\\\' && q[2] == '\\'' && q[3] == '\\'')\n-\t    {\n-\t      const char *r;\n-\n-\t      r = strchr (q + 4, '\\'');\n-\t      if (!r)\n-\t\tgoto done;\n-\n-\t      obstack_grow (&arg_stack, q + 3, r - (q + 3));\n-\t      q = r;\n-\t    }\n-\n-\t  obstack_1grow (&arg_stack, '\\0');\n-\t  obstack_ptr_grow (&temporary_obstack, obstack_finish (&arg_stack));\n-\t}\n-    done:\n-      obstack_ptr_grow (&temporary_obstack, f->main);\n-      obstack_ptr_grow (&temporary_obstack, NULL);\n-      argv = XOBFINISH (&temporary_obstack, char **);\n-\n-      if (tlink_verbose)\n-\tfprintf (stderr, _(\"collect: recompiling %s\\n\"), f->main);\n-\n-      if (chdir (f->dir) != 0\n-\t  || tlink_execute (c_file_name, argv, NULL, NULL, false) != 0\n-\t  || chdir (initial_cwd) != 0)\n-\treturn 0;\n-\n-      read_repo_file (f);\n-\n-      obstack_free (&arg_stack, NULL);\n-      obstack_free (&temporary_obstack, temporary_firstobj);\n-    }\n-  return 1;\n-}\n-\n-/* The first phase of processing: determine which object files have\n-   .rpo files associated with them, and read in the information.  */\n-\n-static int\n-read_repo_files (char **object_lst)\n-{\n-  char **object = object_lst;\n-\n-  for (; *object; object++)\n-    {\n-      const char *p;\n-      file *f;\n-\n-      /* Don't bother trying for ld flags.  */\n-      if (*object[0] == '-')\n-\tcontinue;\n-\n-      p = frob_extension (*object, \".rpo\");\n-\n-      if (! file_exists (p))\n-\tcontinue;\n-\n-      f = file_hash_lookup (p);\n-\n-      read_repo_file (f);\n-    }\n-\n-  if (file_stack != NULL && ! recompile_files ())\n-    return 0;\n-\n-  return (symbol_stack != NULL);\n-}\n-\n-/* Add the demangled forms of any new symbols to the hash table.  */\n-\n-static void\n-demangle_new_symbols (void)\n-{\n-  symbol *sym;\n-\n-  while ((sym = symbol_pop ()) != NULL)\n-    {\n-      demangled *dem;\n-      const char *p = cplus_demangle (sym->key, DMGL_PARAMS | DMGL_ANSI);\n-\n-      if (! p)\n-\tcontinue;\n-\n-      dem = demangled_hash_lookup (p, true);\n-      dem->mangled.safe_push (sym->key);\n-    }\n-}\n-\n-/* We want to tweak symbol SYM.  Return true if all is well, false on\n-   error.  */\n-\n-static bool\n-start_tweaking (symbol *sym)\n-{\n-  if (sym && sym->tweaked)\n-    {\n-      error (\"%qs was assigned to %qs, but was not defined \"\n-\t     \"during recompilation, or vice versa\",\n-\t     sym->key, sym->file->key);\n-      return 0;\n-    }\n-  if (sym && !sym->tweaking)\n-    {\n-      if (tlink_verbose >= 2)\n-\tfprintf (stderr, _(\"collect: tweaking %s in %s\\n\"),\n-\t\t sym->key, sym->file->key);\n-      sym->tweaking = 1;\n-      file_push (sym->file);\n-    }\n-  return true;\n-}\n-\n-/* Step through the output of the linker, in the file named FNAME, and\n-   adjust the settings for each symbol encountered.  */\n-\n-static int\n-scan_linker_output (const char *fname)\n-{\n-  FILE *stream = fopen (fname, \"r\");\n-  char *line;\n-  int skip_next_in_line = 0;\n-\n-  while ((line = tfgets (stream)) != NULL)\n-    {\n-      char *p = line, *q;\n-      symbol *sym;\n-      demangled *dem = 0;\n-      int end;\n-      int ok = 0;\n-      unsigned ix;\n-      str s;\n-\n-      /* On darwin9, we might have to skip \" in \" lines as well.  */\n-      if (skip_next_in_line\n-\t  && strstr (p, \" in \"))\n-\t  continue;\n-      skip_next_in_line = 0;\n-\n-      while (*p && ISSPACE ((unsigned char) *p))\n-\t++p;\n-\n-      if (! *p)\n-\tcontinue;\n-\n-      for (q = p; *q && ! ISSPACE ((unsigned char) *q); ++q)\n-\t;\n-\n-      /* Try the first word on the line.  */\n-      if (*p == '.')\n-\t++p;\n-      if (!strncmp (p, USER_LABEL_PREFIX, strlen (USER_LABEL_PREFIX)))\n-\tp += strlen (USER_LABEL_PREFIX);\n-\n-      end = ! *q;\n-      *q = 0;\n-      sym = symbol_hash_lookup (p, false);\n-\n-      /* Some SVR4 linkers produce messages like\n-\t ld: 0711-317 ERROR: Undefined symbol: .g__t3foo1Zi\n-\t */\n-      if (! sym && ! end && strstr (q + 1, \"Undefined symbol: \"))\n-\t{\n-\t  char *p = strrchr (q + 1, ' ');\n-\t  p++;\n-\t  if (*p == '.')\n-\t    p++;\n-\t  if (!strncmp (p, USER_LABEL_PREFIX, strlen (USER_LABEL_PREFIX)))\n-\t    p += strlen (USER_LABEL_PREFIX);\n-\t  sym = symbol_hash_lookup (p, false);\n-\t}\n-\n-      if (! sym && ! end)\n-\t/* Try a mangled name in quotes.  */\n-\t{\n-\t  char *oldq = q + 1;\n-\t  q = 0;\n-\n-\t  /* On darwin9, we look for \"foo\" referenced from:\\n\\(.* in .*\\n\\)*  */\n-\t  if (strcmp (oldq, \"referenced from:\") == 0)\n-\t    {\n-\t      /* We have to remember that we found a symbol to tweak.  */\n-\t      ok = 1;\n-\n-\t      /* We actually want to start from the first word on the\n-\t\t line.  */\n-\t      oldq = p;\n-\n-\t      /* Since the format is multiline, we have to skip\n-\t\t following lines with \" in \".  */\n-\t      skip_next_in_line = 1;\n-\t    }\n-\n-\t  /* First try `GNU style'.  */\n-\t  p = strchr (oldq, '`');\n-\t  if (p)\n-\t    p++, q = strchr (p, '\\'');\n-\t  /* Then try \"double quotes\".  */\n-\t  else if (p = strchr (oldq, '\"'), p)\n-\t    p++, q = strchr (p, '\"');\n-\t  /* Then try 'single quotes'.  */\n-\t  else if (p = strchr (oldq, '\\''), p)\n-\t    p++, q = strchr (p, '\\'');\n-\t  else {\n-\t    /* Then try entire line.  */\n-\t    q = strchr (oldq, 0);\n-\t    if (q != oldq)\n-\t      p = (char *)oldq;\n-\t  }\n-\n-\t  if (p)\n-\t    {\n-\t      /* Don't let the strstr's below see the demangled name; we\n-\t\t might get spurious matches.  */\n-\t      p[-1] = '\\0';\n-\n-\t      /* powerpc64-linux references .foo when calling function foo.  */\n-\t      if (*p == '.')\n-\t\tp++;\n-\t    }\n-\n-\t  /* We need to check for certain error keywords here, or we would\n-\t     mistakenly use GNU ld's \"In function `foo':\" message.  */\n-\t  if (q && (ok\n-\t\t    || strstr (oldq, \"ndefined\")\n-\t\t    || strstr (oldq, \"nresolved\")\n-\t\t    || strstr (oldq, \"nsatisfied\")\n-\t\t    || strstr (oldq, \"ultiple\")))\n-\t    {\n-\t      *q = 0;\n-\t      dem = demangled_hash_lookup (p, false);\n-\t      if (!dem)\n-\t\t{\n-\t\t  if (!strncmp (p, USER_LABEL_PREFIX,\n-\t\t\t\tstrlen (USER_LABEL_PREFIX)))\n-\t\t    p += strlen (USER_LABEL_PREFIX);\n-\t\t  sym = symbol_hash_lookup (p, false);\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (dem)\n-\t{\n-\t  /* We found a demangled name.  If this is the name of a\n-\t     constructor or destructor, there can be several mangled names\n-\t     that match it, so choose or unchoose all of them.  If some are\n-\t     chosen and some not, leave the later ones that don't match\n-\t     alone for now; either this will cause the link to succeed, or\n-\t     on the next attempt we will switch all of them the other way\n-\t     and that will cause it to succeed.  */\n-\t  int chosen = 0;\n-\t  int len = dem->mangled.length ();\n-\t  ok = true;\n-\t  FOR_EACH_VEC_ELT (dem->mangled, ix, s)\n-\t    {\n-\t      sym = symbol_hash_lookup (s, false);\n-\t      if (ix == 0)\n-\t\tchosen = sym->chosen;\n-\t      else if (sym->chosen != chosen)\n-\t\t/* Mismatch.  */\n-\t\tcontinue;\n-\t      /* Avoid an error about re-tweaking when we guess wrong in\n-\t\t the case of mismatch.  */\n-\t      if (len > 1)\n-\t\tsym->tweaked = false;\n-\t      ok = start_tweaking (sym);\n-\t    }\n-\t}\n-      else\n-\tok = start_tweaking (sym);\n-\n-      obstack_free (&temporary_obstack, temporary_firstobj);\n-\n-      if (!ok)\n-\t{\n-\t  fclose (stream);\n-\t  return 0;\n-\t}\n-    }\n-\n-  fclose (stream);\n-  return (file_stack != NULL);\n-}\n-\n-/* Entry point for tlink.  Called from main in collect2.c.\n-\n-   Iteratively try to provide definitions for all the unresolved symbols\n-   mentioned in the linker error messages.\n-\n-   LD_ARGV is an array of arguments for the linker.\n-   OBJECT_LST is an array of object files that we may be able to recompile\n-     to provide missing definitions.  Currently ignored.  */\n-\n-void\n-do_tlink (char **ld_argv, char **object_lst ATTRIBUTE_UNUSED)\n-{\n-  int ret = tlink_execute (\"ld\", ld_argv, ldout, lderrout,\n-\t\t\t   HAVE_GNU_LD && at_file_supplied);\n-\n-  tlink_init ();\n-\n-  if (ret)\n-    {\n-      int i = 0;\n-\n-      /* Until collect does a better job of figuring out which are object\n-\t files, assume that everything on the command line could be.  */\n-      if (read_repo_files (ld_argv))\n-\twhile (ret && i++ < MAX_ITERATIONS)\n-\t  {\n-\t    if (tlink_verbose >= 3)\n-\t      {\n-\t\tdump_ld_file (ldout, stdout);\n-\t\tdump_ld_file (lderrout, stderr);\n-\t      }\n-\t    demangle_new_symbols ();\n-\t    if (! scan_linker_output (ldout)\n-\t\t&& ! scan_linker_output (lderrout))\n-\t      break;\n-\t    if (! recompile_files ())\n-\t      break;\n-\t    if (tlink_verbose)\n-\t      fprintf (stderr, _(\"collect: relinking\\n\"));\n-\t    ret = tlink_execute (\"ld\", ld_argv, ldout, lderrout,\n-\t\t\t\t HAVE_GNU_LD && at_file_supplied);\n-\t  }\n-    }\n-\n-  dump_ld_file (ldout, stdout);\n-  unlink (ldout);\n-  dump_ld_file (lderrout, stderr);\n-  unlink (lderrout);\n-  if (ret)\n-    {\n-      error (\"ld returned %d exit status\", ret);\n-      exit (ret);\n-    }\n-  else\n-    {\n-      /* We have just successfully produced an output file, so assume that we\n-\t may unlink it if need be for now on.  */ \n-      may_unlink_output_file = true;\n-    }\n-}"}]}