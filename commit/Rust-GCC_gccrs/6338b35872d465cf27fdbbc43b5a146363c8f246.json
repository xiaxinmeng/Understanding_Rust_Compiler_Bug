{"sha": "6338b35872d465cf27fdbbc43b5a146363c8f246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMzOGIzNTg3MmQ0NjVjZjI3ZmRiYmM0M2I1YTE0NjM2M2M4ZjI0Ng==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2003-04-23T22:44:06Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2003-04-23T22:44:06Z"}, "message": "Makefile.in (c-lex.o, [...]): Update.\n\n\t* Makefile.in (c-lex.o, LIBCPP_OBJS, cpplex.o): Update.\n\t* c-lex.c (MULTIBYTE_CHARS): Remove conditionals.\n\t(lex_string): Take cpp_string with full spelling.\n\t(cb_ident): Update.\n\t(c_lex): Update diagnostics.\n\t* cpplex.c (SPELL_NUMBER, SPELL_STRING): Combine into SPELL_LITERAL.\n\t(create_literal): New.\n\t(lex_string): Unterminated literals have type CPP_OTHER.\n\t(_cpp_lex_direct): Update calls to lex_string.  Use create_literal\n\tfor CPP_OTHER.\n\t(cpp_token_len, cpp_spell_token, cpp_output_token): Simplify.\n\t(_cpp_equiv_tokens, cpp_interpret_charconst): Update.\n\t* cpplib.c (parse_include, do_line, do_linemarker,\n\tdestringize_and_run): Update for token storing full spelling.\n\t* cpplib.h: Update token spelling types.\n\t* cppmacro.c (stringify_arg, check_trad_stringification):\n\tUpdate for token storing full spelling.\ncp:\n\t* Make-lang.in (lex.o): Remove mbchar.h.\n\t* lex.c (MULTIBYTE_CHARS): Lose.\n\t* parser.c (cp_lexer_get_preprocessor_token): CPP_OTHER handled\n\tin c-lex.c.\ntestsuite:\n\t* gcc.dg/cpp/include2.c: Update.\n\t* gcc.dg/cpp/multiline-2.c: New.\n\t* gcc.dg/cpp/multiline.c: Update.\n\t* gcc.dg/cpp/strify2.c: Update.\n\t* gcc.dg/cpp/trad/literals-2.c: Update.\n\nFrom-SVN: r66019", "tree": {"sha": "e4f819e101d1dc188ae9d2012e0cb8ab2239160d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4f819e101d1dc188ae9d2012e0cb8ab2239160d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6338b35872d465cf27fdbbc43b5a146363c8f246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6338b35872d465cf27fdbbc43b5a146363c8f246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6338b35872d465cf27fdbbc43b5a146363c8f246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6338b35872d465cf27fdbbc43b5a146363c8f246/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "06f5e63748eeb66140858914bbffb149406789a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06f5e63748eeb66140858914bbffb149406789a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06f5e63748eeb66140858914bbffb149406789a9"}], "stats": {"total": 414, "additions": 189, "deletions": 225}, "files": [{"sha": "2f4ed04596a60e81b64c3491eafea91913483e0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -1,3 +1,23 @@\n+2003-04-23  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Makefile.in (c-lex.o, LIBCPP_OBJS, cpplex.o): Update.\n+\t* c-lex.c (MULTIBYTE_CHARS): Remove conditionals.\n+\t(lex_string): Take cpp_string with full spelling.\n+\t(cb_ident): Update.\n+\t(c_lex): Update diagnostics.\n+\t* cpplex.c (SPELL_NUMBER, SPELL_STRING): Combine into SPELL_LITERAL.\n+\t(create_literal): New.\n+\t(lex_string): Unterminated literals have type CPP_OTHER.\n+\t(_cpp_lex_direct): Update calls to lex_string.  Use create_literal\n+\tfor CPP_OTHER.\n+\t(cpp_token_len, cpp_spell_token, cpp_output_token): Simplify.\n+\t(_cpp_equiv_tokens, cpp_interpret_charconst): Update.\n+\t* cpplib.c (parse_include, do_line, do_linemarker,\n+\tdestringize_and_run): Update for token storing full spelling.\n+\t* cpplib.h: Update token spelling types.\n+\t* cppmacro.c (stringify_arg, check_trad_stringification):\n+\tUpdate for token storing full spelling.\n+\n 2003-04-23  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.c (s390_expand_cmpstr): Disable CLC loop."}, {"sha": "50e236a469f188d0366107183baaccb5b7b3c0c5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -1267,7 +1267,7 @@ c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TR\n c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(RTL_H) debug.h $(C_TREE_H) c-common.h real.h c-incpath.h cppdefault.h \\\n     c-pragma.h input.h intl.h flags.h toplev.h output.h \\\n-    mbchar.h $(CPPLIB_H) $(EXPR_H) $(TM_P_H)\n+    $(CPPLIB_H) $(EXPR_H) $(TM_P_H)\n c-ppoutput.o : c-ppoutput.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n     c-common.h $(TREE_H) $(CPPLIB_H) cpphash.h $(TM_P_H) c-pragma.h\n c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -2326,7 +2326,7 @@ PREPROCESSOR_DEFINES = \\\n \n LIBCPP_OBJS =\tcpplib.o cpplex.o cppmacro.o cppexp.o cppfiles.o cpptrad.o \\\n \t\tcpphash.o cpperror.o cppinit.o cppcharset.o \\\n-\t\thashtable.o line-map.o mkdeps.o mbchar.o cpppch.o\n+\t\thashtable.o line-map.o mkdeps.o cpppch.o\n \n LIBCPP_DEPS =\t$(CPPLIB_H) cpphash.h line-map.h hashtable.h intl.h \\\n \t\t$(OBSTACK_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\n@@ -2341,7 +2341,7 @@ libcpp.a: $(LIBCPP_OBJS)\n cppcharset.o: cppcharset.c $(LIBCPP_DEPS)\n cpperror.o: cpperror.c $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(LIBCPP_DEPS)\n-cpplex.o:   cpplex.c   $(LIBCPP_DEPS) mbchar.h\n+cpplex.o:   cpplex.c   $(LIBCPP_DEPS)\n cppmacro.o: cppmacro.c $(LIBCPP_DEPS)\n cpplib.o:   cpplib.c   $(LIBCPP_DEPS)\n cpphash.o:  cpphash.c  $(LIBCPP_DEPS)"}, {"sha": "eb0934c1158f28b9ce1d46267e73ed3efe4bff52", "filename": "gcc/c-lex.c", "status": "modified", "additions": 27, "deletions": 56, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -42,11 +42,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"splay-tree.h\"\n #include \"debug.h\"\n \n-#ifdef MULTIBYTE_CHARS\n-#include \"mbchar.h\"\n-#include <locale.h>\n-#endif /* MULTIBYTE_CHARS */\n-\n /* The current line map.  */\n static const struct line_map *map;\n \n@@ -78,8 +73,7 @@ static enum integer_type_kind\n   narrowest_unsigned_type\tPARAMS ((tree, unsigned int));\n static enum integer_type_kind\n   narrowest_signed_type\t\tPARAMS ((tree, unsigned int));\n-static tree lex_string\t\tPARAMS ((const unsigned char *, unsigned int,\n-\t\t\t\t\t int));\n+static tree lex_string\t\tPARAMS ((const cpp_string *));\n static tree lex_charconst\tPARAMS ((const cpp_token *));\n static void update_header_times\tPARAMS ((const char *));\n static int dump_one_header\tPARAMS ((splay_tree_node, void *));\n@@ -201,7 +195,7 @@ cb_ident (pfile, line, str)\n   if (! flag_no_ident)\n     {\n       /* Convert escapes in the string.  */\n-      tree value ATTRIBUTE_UNUSED = lex_string (str->text, str->len, 0);\n+      tree value ATTRIBUTE_UNUSED = lex_string (str);\n       ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (value));\n     }\n #endif\n@@ -329,7 +323,7 @@ c_lex (value)\n {\n   const cpp_token *tok;\n \n-  retry:\n+ retry:\n   timevar_push (TV_CPP);\n   do\n     tok = cpp_get_token (parse_in);\n@@ -344,11 +338,6 @@ c_lex (value)\n   *value = NULL_TREE;\n   switch (tok->type)\n     {\n-    case CPP_OTHER:\n-      error (\"stray token \\\"%s\\\" in program\",\n-\t     cpp_token_as_text (parse_in, tok));\n-      goto retry;\n-      \n     case CPP_NAME:\n       *value = HT_IDENT_TO_GCC_IDENT (HT_NODE (tok->val.node));\n       break;\n@@ -378,15 +367,27 @@ c_lex (value)\n       }\n       break;\n \n+    case CPP_OTHER:\n+      {\n+\tcppchar_t c = tok->val.str.text[0];\n+\n+\tif (c == '\"' || c == '\\'')\n+\t  error (\"missing terminating %c character\", (int) c);\n+\telse if (ISGRAPH (c))\n+\t  error (\"stray '%c' in program\", (int) c);\n+\telse\n+\t  error (\"stray '\\\\%o' in program\", (int) c);\n+      }\n+      goto retry;\n+\n     case CPP_CHAR:\n     case CPP_WCHAR:\n       *value = lex_charconst (tok);\n       break;\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n-      *value = lex_string (tok->val.str.text, tok->val.str.len,\n-\t\t\t   tok->type == CPP_WSTRING);\n+      *value = lex_string (&tok->val.str);\n       break;\n \n       /* These tokens should not be visible outside cpplib.  */\n@@ -601,43 +602,23 @@ interpret_float (token, flags)\n }\n \n static tree\n-lex_string (str, len, wide)\n-     const unsigned char *str;\n-     unsigned int len;\n-     int wide;\n+lex_string (str)\n+     const cpp_string *str;\n {\n+  bool wide;\n   tree value;\n-  char *buf = alloca ((len + 1) * (wide ? WCHAR_BYTES : 1));\n-  char *q = buf;\n-  const unsigned char *p = str, *limit = str + len;\n+  char *buf, *q;\n   cppchar_t c;\n-\n-#ifdef MULTIBYTE_CHARS\n-  /* Reset multibyte conversion state.  */\n-  (void) local_mbtowc (NULL, NULL, 0);\n-#endif\n+  const unsigned char *p, *limit;\n+  \n+  wide = str->text[0] == 'L';\n+  p = str->text + 1 + wide;\n+  limit = str->text + str->len - 1;\n+  q = buf = alloca ((str->len + 1) * (wide ? WCHAR_BYTES : 1));\n \n   while (p < limit)\n     {\n-#ifdef MULTIBYTE_CHARS\n-      wchar_t wc;\n-      int char_len;\n-\n-      char_len = local_mbtowc (&wc, (const char *) p, limit - p);\n-      if (char_len == -1)\n-\t{\n-\t  warning (\"ignoring invalid multibyte character\");\n-\t  char_len = 1;\n-\t  c = *p++;\n-\t}\n-      else\n-\t{\n-\t  p += char_len;\n-\t  c = wc;\n-\t}\n-#else\n       c = *p++;\n-#endif\n \n       if (c == '\\\\' && !ignore_escape_flag)\n \tc = cpp_parse_escape (parse_in, &p, limit, wide);\n@@ -664,16 +645,6 @@ lex_string (str, len, wide)\n \t    }\n \t  q += WCHAR_BYTES;\n \t}\n-#ifdef MULTIBYTE_CHARS\n-      else if (char_len > 1)\n-\t{\n-\t  /* We're dealing with a multibyte character.  */\n-\t  for ( ; char_len >0; --char_len)\n-\t    {\n-\t      *q++ = *(p - char_len);\n-\t    }\n-\t}\n-#endif\n       else\n \t{\n \t  *q++ = c;"}, {"sha": "13d2c54adfb1428cd997530e8dcee25a07cbfe33", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -1,3 +1,10 @@\n+2003-04-23  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* Make-lang.in (lex.o): Remove mbchar.h.\n+\t* lex.c (MULTIBYTE_CHARS): Lose.\n+\t* parser.c (cp_lexer_get_preprocessor_token): CPP_OTHER handled\n+\tin c-lex.c.\n+\n 2003-04-23  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/9847"}, {"sha": "c8d27ab86e902317979fc3e3f55419e93b2b8514", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -228,7 +228,7 @@ CXX_TREE_H = $(TREE_H) cp/name-lookup.h cp/cp-tree.h c-common.h \\\n \t$(srcdir)/../include/hashtab.h $(srcdir)/../include/splay-tree.h\n \n cp/lex.o: cp/lex.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h \\\n-  c-pragma.h toplev.h output.h mbchar.h input.h diagnostic.h \\\n+  c-pragma.h toplev.h output.h input.h diagnostic.h \\\n   cp/operators.def $(TM_P_H)\n cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h langhooks.h \\\n   $(LANGHOOKS_DEF_H) c-common.h"}, {"sha": "5ecb03ef9b23fd1f8b01888ae28a2f3188bd2ba4", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -40,11 +40,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n \n-#ifdef MULTIBYTE_CHARS\n-#include \"mbchar.h\"\n-#include <locale.h>\n-#endif\n-\n static int interface_strcmp PARAMS ((const char *));\n static void init_cp_pragma PARAMS ((void));\n "}, {"sha": "2d54e7ef84a8599ff04d6a306ea98569cbd590f5", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -644,10 +644,6 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n \t  error (\"invalid token\");\n \t  break;\n \n-\tcase CPP_OTHER:\n-\t  /* These tokens are already warned about by c_lex.  */\n-\t  break;\n-\n \tdefault:\n \t  /* This is a good token, so we exit the loop.  */\n \t  done = true;"}, {"sha": "c9c064143c3533e5cfea2d90807c4ff0d49a69a4", "filename": "gcc/cpplex.c", "status": "modified", "additions": 71, "deletions": 114, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -26,14 +26,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-/* Tokens with SPELL_STRING store their spelling in the token list,\n-   and it's length in the token->val.name.len.  */\n enum spell_type\n {\n   SPELL_OPERATOR = 0,\n   SPELL_IDENT,\n-  SPELL_NUMBER,\n-  SPELL_STRING,\n+  SPELL_LITERAL,\n   SPELL_NONE\n };\n \n@@ -61,9 +58,11 @@ static void skip_whitespace PARAMS ((cpp_reader *, cppchar_t));\n static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n static void lex_number PARAMS ((cpp_reader *, cpp_string *));\n static bool forms_identifier_p PARAMS ((cpp_reader *, int));\n-static void lex_string PARAMS ((cpp_reader *, cpp_token *));\n+static void lex_string PARAMS ((cpp_reader *, cpp_token *, const uchar *));\n static void save_comment PARAMS ((cpp_reader *, cpp_token *, const uchar *,\n \t\t\t\t  cppchar_t));\n+static void create_literal PARAMS ((cpp_reader *, cpp_token *, const uchar *,\n+\t\t\t\t    unsigned int, enum cpp_ttype));\n static int name_p PARAMS ((cpp_reader *, const cpp_string *));\n static cppchar_t maybe_read_ucn PARAMS ((cpp_reader *, const uchar **));\n static tokenrun *next_tokenrun PARAMS ((tokenrun *));\n@@ -468,63 +467,77 @@ lex_number (pfile, number)\n   number->text = dest;\n }\n \n+/* Create a token of type TYPE with a literal spelling.  */\n+static void\n+create_literal (pfile, token, base, len, type)\n+     cpp_reader *pfile;\n+     cpp_token *token;\n+     const uchar *base;\n+     unsigned int len;\n+     enum cpp_ttype type;\n+{\n+  uchar *dest = _cpp_unaligned_alloc (pfile, len + 1);\n+\n+  memcpy (dest, base, len);\n+  dest[len] = '\\0';\n+  token->type = type;\n+  token->val.str.len = len;\n+  token->val.str.text = dest;\n+}\n+\n /* Lexes a string, character constant, or angle-bracketed header file\n-   name.  The stored string is guaranteed NUL-terminated, but it is\n-   not guaranteed that this is the first NUL since embedded NULs are\n-   preserved.  */\n+   name.  The stored string contains the spelling, including opening\n+   quote and leading any leading 'L'.  It returns the type of the\n+   literal, or CPP_OTHER if it was not properly terminated.\n+\n+   The spelling is NUL-terminated, but it is not guaranteed that this\n+   is the first NUL since embedded NULs are preserved.  */\n static void\n-lex_string (pfile, token)\n+lex_string (pfile, token, base)\n      cpp_reader *pfile;\n      cpp_token *token;\n+     const uchar *base;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-  bool warned_nulls = false;\n-  const uchar *base;\n-  uchar *dest;\n+  bool saw_NUL = false;\n+  const uchar *cur;\n   cppchar_t terminator;\n-\n-  base = buffer->cur;\n-  terminator = base[-1];\n-  if (terminator == '<')\n-    terminator = '>';\n+  enum cpp_ttype type;\n+\n+  cur = base;\n+  terminator = *cur++;\n+  if (terminator == 'L')\n+    terminator = *cur++;\n+  if (terminator == '\\\"')\n+    type = *base == 'L' ? CPP_WSTRING: CPP_STRING;\n+  else if (terminator == '\\'')\n+    type = *base == 'L' ? CPP_WCHAR: CPP_CHAR;\n+  else\n+    terminator = '>', type = CPP_HEADER_NAME;\n \n   for (;;)\n     {\n-      cppchar_t c = *buffer->cur++;\n+      cppchar_t c = *cur++;\n \n       /* In #include-style directives, terminators are not escapable.  */\n-      if (c == '\\\\' && !pfile->state.angled_headers && *buffer->cur != '\\n')\n-\tbuffer->cur++;\n-      else if (c == terminator || c == '\\n')\n+      if (c == '\\\\' && !pfile->state.angled_headers && *cur != '\\n')\n+\tcur++;\n+      else if (c == terminator)\n \tbreak;\n-      else if (c == '\\0')\n+      else if (c == '\\n')\n \t{\n-\t  if (!warned_nulls)\n-\t    {\n-\t      warned_nulls = true;\n-\t      cpp_error (pfile, DL_WARNING,\n-\t\t\t \"null character(s) preserved in literal\");\n-\t    }\n+\t  cur--;\n+\t  type = CPP_OTHER;\n+\t  break;\n \t}\n+      else if (c == '\\0')\n+\tsaw_NUL = true;\n     }\n \n-  token->val.str.len = buffer->cur - base - 1;\n-  dest = _cpp_unaligned_alloc (pfile, token->val.str.len + 1);\n-  memcpy (dest, base, token->val.str.len);\n-  dest[token->val.str.len] = '\\0';\n-  token->val.str.text = dest;\n+  if (saw_NUL && !pfile->state.skipping)\n+    cpp_error (pfile, DL_WARNING, \"null character(s) preserved in literal\");\n \n-  if (buffer->cur[-1] == '\\n')\n-    {\n-      /* No string literal may extend over multiple lines.  In\n-\t assembly language, suppress the error except for <>\n-\t includes.  This is a kludge around not knowing where\n-\t comments are.  */\n-      if (CPP_OPTION (pfile, lang) != CLK_ASM || terminator == '>')\n-\tcpp_error (pfile, DL_ERROR, \"missing terminating %c character\",\n-\t\t   (int) terminator);\n-      buffer->cur--;\n-    }\n+  pfile->buffer->cur = cur;\n+  create_literal (pfile, token, base, cur - base, type);\n }\n \n /* The stored comment includes the comment start and any terminator.  */\n@@ -817,9 +830,7 @@ _cpp_lex_direct (pfile)\n       /* 'L' may introduce wide characters or strings.  */\n       if (*buffer->cur == '\\'' || *buffer->cur == '\"')\n \t{\n-\t  result->type = (*buffer->cur == '\"' ? CPP_WSTRING: CPP_WCHAR);\n-\t  buffer->cur++;\n-\t  lex_string (pfile, result);\n+\t  lex_string (pfile, result, buffer->cur - 1);\n \t  break;\n \t}\n       /* Fall through.  */\n@@ -848,8 +859,7 @@ _cpp_lex_direct (pfile)\n \n     case '\\'':\n     case '\"':\n-      result->type = c == '\"' ? CPP_STRING: CPP_CHAR;\n-      lex_string (pfile, result);\n+      lex_string (pfile, result, buffer->cur - 1);\n       break;\n \n     case '/':\n@@ -905,8 +915,7 @@ _cpp_lex_direct (pfile)\n     case '<':\n       if (pfile->state.angled_headers)\n \t{\n-\t  result->type = CPP_HEADER_NAME;\n-\t  lex_string (pfile, result);\n+\t  lex_string (pfile, result, buffer->cur - 1);\n \t  break;\n \t}\n \n@@ -1078,15 +1087,8 @@ _cpp_lex_direct (pfile)\n       }\n \n     default:\n-      {\n-\tuchar *dest = _cpp_unaligned_alloc (pfile, 1 + 1);\n-\tdest[0] = c;\n-\tdest[1] = '\\0';\n-\tresult->type = CPP_OTHER;\n-\tresult->val.str.len = 1;\n-\tresult->val.str.text = dest;\n-\tbreak;\n-      }\n+      create_literal (pfile, result, buffer->cur - 1, 1, CPP_OTHER);\n+      break;\n     }\n \n   return result;\n@@ -1103,8 +1105,7 @@ cpp_token_len (token)\n   switch (TOKEN_SPELL (token))\n     {\n     default:\t\tlen = 0;\t\t\t\tbreak;\n-    case SPELL_NUMBER:\n-    case SPELL_STRING:\tlen = token->val.str.len;\t\tbreak;\n+    case SPELL_LITERAL:\tlen = token->val.str.len;\t\tbreak;\n     case SPELL_IDENT:\tlen = NODE_LEN (token->val.node);\tbreak;\n     }\n   /* 1 for whitespace, 4 for comment delimiters.  */\n@@ -1147,34 +1148,11 @@ cpp_spell_token (pfile, token, buffer)\n       buffer += NODE_LEN (token->val.node);\n       break;\n \n-    case SPELL_NUMBER:\n+    case SPELL_LITERAL:\n       memcpy (buffer, token->val.str.text, token->val.str.len);\n       buffer += token->val.str.len;\n       break;\n \n-    case SPELL_STRING:\n-      {\n-\tint left, right, tag;\n-\tswitch (token->type)\n-\t  {\n-\t  case CPP_STRING:\tleft = '\"';  right = '\"';  tag = '\\0'; break;\n-\t  case CPP_WSTRING:\tleft = '\"';  right = '\"';  tag = 'L';  break;\n-\t  case CPP_CHAR:\tleft = '\\''; right = '\\''; tag = '\\0'; break;\n-    \t  case CPP_WCHAR:\tleft = '\\''; right = '\\''; tag = 'L';  break;\n-\t  case CPP_HEADER_NAME:\tleft = '<';  right = '>';  tag = '\\0'; break;\n-\t  default:\n-\t    cpp_error (pfile, DL_ICE, \"unknown string token %s\\n\",\n-\t\t       TOKEN_NAME (token));\n-\t    return buffer;\n-\t  }\n-\tif (tag) *buffer++ = tag;\n-\t*buffer++ = left;\n-\tmemcpy (buffer, token->val.str.text, token->val.str.len);\n-\tbuffer += token->val.str.len;\n-\t*buffer++ = right;\n-      }\n-      break;\n-\n     case SPELL_NONE:\n       cpp_error (pfile, DL_ICE, \"unspellable token %s\", TOKEN_NAME (token));\n       break;\n@@ -1243,31 +1221,10 @@ cpp_output_token (token, fp)\n       fwrite (NODE_NAME (token->val.node), 1, NODE_LEN (token->val.node), fp);\n     break;\n \n-    case SPELL_NUMBER:\n+    case SPELL_LITERAL:\n       fwrite (token->val.str.text, 1, token->val.str.len, fp);\n       break;\n \n-    case SPELL_STRING:\n-      {\n-\tint left, right, tag;\n-\tswitch (token->type)\n-\t  {\n-\t  case CPP_STRING:\tleft = '\"';  right = '\"';  tag = '\\0'; break;\n-\t  case CPP_WSTRING:\tleft = '\"';  right = '\"';  tag = 'L';  break;\n-\t  case CPP_CHAR:\tleft = '\\''; right = '\\''; tag = '\\0'; break;\n-    \t  case CPP_WCHAR:\tleft = '\\''; right = '\\''; tag = 'L';  break;\n-\t  case CPP_HEADER_NAME:\tleft = '<';  right = '>';  tag = '\\0'; break;\n-\t  default:\n-\t    fprintf (stderr, \"impossible STRING token %s\\n\", TOKEN_NAME (token));\n-\t    return;\n-\t  }\n-\tif (tag) putc (tag, fp);\n-\tputc (left, fp);\n-\tfwrite (token->val.str.text, 1, token->val.str.len, fp);\n-\tputc (right, fp);\n-      }\n-      break;\n-\n     case SPELL_NONE:\n       /* An error, most probably.  */\n       break;\n@@ -1289,8 +1246,7 @@ _cpp_equiv_tokens (a, b)\n \treturn (a->type != CPP_MACRO_ARG || a->val.arg_no == b->val.arg_no);\n       case SPELL_IDENT:\n \treturn a->val.node == b->val.node;\n-      case SPELL_NUMBER:\n-      case SPELL_STRING:\n+      case SPELL_LITERAL:\n \treturn (a->val.str.len == b->val.str.len\n \t\t&& !memcmp (a->val.str.text, b->val.str.text,\n \t\t\t    a->val.str.len));\n@@ -1588,14 +1544,15 @@ cpp_interpret_charconst (pfile, token, pchars_seen, unsignedp)\n      unsigned int *pchars_seen;\n      int *unsignedp;\n {\n-  const unsigned char *str = token->val.str.text;\n-  const unsigned char *limit = str + token->val.str.len;\n+  const unsigned char *str, *limit;\n   unsigned int chars_seen = 0;\n   size_t width, max_chars;\n   cppchar_t c, mask, result = 0;\n   bool unsigned_p;\n \n-  /* Width in bits.  */\n+  str = token->val.str.text + 1 + (token->type == CPP_WCHAR);\n+  limit = token->val.str.text + token->val.str.len - 1;\n+\n   if (token->type == CPP_CHAR)\n     {\n       width = CPP_OPTION (pfile, char_precision);"}, {"sha": "9b95ac950cffd5cc07e85945ba7206b6d475609e", "filename": "gcc/cpplib.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -627,9 +627,9 @@ parse_include (pfile, pangle_brackets)\n   header = get_token_no_padding (pfile);\n   if (header->type == CPP_STRING || header->type == CPP_HEADER_NAME)\n     {\n-      fname = xmalloc (header->val.str.len + 1);\n-      memcpy (fname, header->val.str.text, header->val.str.len);\n-      fname[header->val.str.len] = '\\0';\n+      fname = xmalloc (header->val.str.len - 1);\n+      memcpy (fname, header->val.str.text + 1, header->val.str.len - 2);\n+      fname[header->val.str.len - 2] = '\\0';\n       *pangle_brackets = header->type == CPP_HEADER_NAME;\n     }\n   else if (header->type == CPP_LESS)\n@@ -832,8 +832,8 @@ do_line (pfile)\n   token = cpp_get_token (pfile);\n   if (token->type == CPP_STRING)\n     {\n-      new_file = (const char *) dequote_string (pfile, token->val.str.text,\n-\t\t\t\t\t\ttoken->val.str.len);\n+      new_file = (const char *) dequote_string (pfile, token->val.str.text + 1,\n+\t\t\t\t\t\ttoken->val.str.len - 2);\n       check_eol (pfile);\n     }\n   else if (token->type != CPP_EOF)\n@@ -881,8 +881,8 @@ do_linemarker (pfile)\n   token = cpp_get_token (pfile);\n   if (token->type == CPP_STRING)\n     {\n-      new_file = (const char *) dequote_string (pfile, token->val.str.text,\n-\t\t\t\t\t\ttoken->val.str.len);\n+      new_file = (const char *) dequote_string (pfile, token->val.str.text + 1,\n+\t\t\t\t\t\ttoken->val.str.len - 2);\n       new_sysp = 0;\n       flag = read_flag (pfile, 0);\n       if (flag == 1)\n@@ -1369,8 +1369,10 @@ destringize_and_run (pfile, in)\n   const unsigned char *src, *limit;\n   char *dest, *result;\n \n-  dest = result = alloca (in->len + 1);\n-  for (src = in->text, limit = src + in->len; src < limit;)\n+  dest = result = alloca (in->len - 1);\n+  src = in->text + 1 + (in->text[0] == 'L');\n+  limit = in->text + in->len - 1;\n+  while (src < limit)\n     {\n       /* We know there is a character following the backslash.  */\n       if (*src == '\\\\' && (src[1] == '\\\\' || src[1] == '\"'))"}, {"sha": "90977d1edb9d2988b3cb4dede4cff948776a7178", "filename": "gcc/cpplib.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -124,18 +124,18 @@ struct file_name_map_list;\n   OP(CPP_ATSIGN,\t\"@\")  /* used in Objective-C */ \\\n \\\n   TK(CPP_NAME,\t\tSPELL_IDENT)\t/* word */\t\t\t\\\n-  TK(CPP_NUMBER,\tSPELL_NUMBER)\t/* 34_be+ta  */\t\t\t\\\n+  TK(CPP_NUMBER,\tSPELL_LITERAL)\t/* 34_be+ta  */\t\t\t\\\n \\\n-  TK(CPP_CHAR,\t\tSPELL_STRING)\t/* 'char' */\t\t\t\\\n-  TK(CPP_WCHAR,\t\tSPELL_STRING)\t/* L'char' */\t\t\t\\\n-  TK(CPP_OTHER,\t\tSPELL_NUMBER)\t/* stray punctuation */\t\t\\\n+  TK(CPP_CHAR,\t\tSPELL_LITERAL)\t/* 'char' */\t\t\t\\\n+  TK(CPP_WCHAR,\t\tSPELL_LITERAL)\t/* L'char' */\t\t\t\\\n+  TK(CPP_OTHER,\t\tSPELL_LITERAL)\t/* stray punctuation */\t\t\\\n \\\n-  TK(CPP_STRING,\tSPELL_STRING)\t/* \"string\" */\t\t\t\\\n-  TK(CPP_WSTRING,\tSPELL_STRING)\t/* L\"string\" */\t\t\t\\\n-  TK(CPP_HEADER_NAME,\tSPELL_STRING)\t/* <stdio.h> in #include */\t\\\n+  TK(CPP_STRING,\tSPELL_LITERAL)\t/* \"string\" */\t\t\t\\\n+  TK(CPP_WSTRING,\tSPELL_LITERAL)\t/* L\"string\" */\t\t\t\\\n+  TK(CPP_HEADER_NAME,\tSPELL_LITERAL)\t/* <stdio.h> in #include */\t\\\n \\\n-  TK(CPP_COMMENT,\tSPELL_NUMBER)\t/* Only if output comments.  */ \\\n-                                        /* SPELL_NUMBER happens to DTRT.  */ \\\n+  TK(CPP_COMMENT,\tSPELL_LITERAL)\t/* Only if output comments.  */ \\\n+                                        /* SPELL_LITERAL happens to DTRT.  */ \\\n   TK(CPP_MACRO_ARG,\tSPELL_NONE)\t/* Macro argument.  */\t\t\\\n   TK(CPP_PADDING,\tSPELL_NONE)\t/* Whitespace for cpp0.  */\n "}, {"sha": "b0b10ae92d755f3e4d624a742b6c444016ab2bde", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -340,11 +340,16 @@ stringify_arg (pfile, arg)\n      cpp_reader *pfile;\n      macro_arg *arg;\n {\n-  unsigned char *dest = BUFF_FRONT (pfile->u_buff);\n+  unsigned char *dest;\n   unsigned int i, escape_it, backslash_count = 0;\n   const cpp_token *source = NULL;\n   size_t len;\n \n+  if (BUFF_ROOM (pfile->u_buff) < 3)\n+    _cpp_extend_buff (pfile, &pfile->u_buff, 3);\n+  dest = BUFF_FRONT (pfile->u_buff);\n+  *dest++ = '\"';\n+\n   /* Loop, reading in the argument's tokens.  */\n   for (i = 0; i < arg->count; i++)\n     {\n@@ -361,11 +366,11 @@ stringify_arg (pfile, arg)\n \t\t   || token->type == CPP_CHAR || token->type == CPP_WCHAR);\n \n       /* Room for each char being written in octal, initial space and\n-\t final NUL.  */\n+\t final quote and NUL.  */\n       len = cpp_token_len (token);\n       if (escape_it)\n \tlen *= 4;\n-      len += 2;\n+      len += 3;\n \n       if ((size_t) (BUFF_LIMIT (pfile->u_buff) - dest) < len)\n \t{\n@@ -375,7 +380,7 @@ stringify_arg (pfile, arg)\n \t}\n \n       /* Leading white space?  */\n-      if (dest != BUFF_FRONT (pfile->u_buff))\n+      if (dest - 1 != BUFF_FRONT (pfile->u_buff))\n \t{\n \t  if (source == NULL)\n \t    source = token;\n@@ -410,12 +415,7 @@ stringify_arg (pfile, arg)\n     }\n \n   /* Commit the memory, including NUL, and return the token.  */\n-  if ((size_t) (BUFF_LIMIT (pfile->u_buff) - dest) < 1)\n-    {\n-      size_t len_so_far = dest - BUFF_FRONT (pfile->u_buff);\n-      _cpp_extend_buff (pfile, &pfile->u_buff, 1);\n-      dest = BUFF_FRONT (pfile->u_buff) + len_so_far;\n-    }\n+  *dest++ = '\"';\n   len = dest - BUFF_FRONT (pfile->u_buff);\n   BUFF_FRONT (pfile->u_buff) = dest + 1;\n   return new_string_token (pfile, dest - len, len);\n@@ -1638,10 +1638,11 @@ check_trad_stringification (pfile, macro, string)\n      const cpp_string *string;\n {\n   unsigned int i, len;\n-  const uchar *p, *q, *limit = string->text + string->len;\n+  const uchar *p, *q, *limit;\n \n   /* Loop over the string.  */\n-  for (p = string->text; p < limit; p = q)\n+  limit = string->text + string->len - 1;\n+  for (p = string->text + 1; p < limit; p = q)\n     {\n       /* Find the start of an identifier.  */\n       while (p < limit && !is_idstart (*p))"}, {"sha": "5a90c05cc5c63580664a958c110456020bb57f44", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -1,3 +1,11 @@\n+2003-04-23  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* gcc.dg/cpp/include2.c: Update.\n+\t* gcc.dg/cpp/multiline-2.c: New.\n+\t* gcc.dg/cpp/multiline.c: Update.\n+\t* gcc.dg/cpp/strify2.c: Update.\n+\t* gcc.dg/cpp/trad/literals-2.c: Update.\n+\n 2003-04-23  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* g++.dg/other/packed1.C: XFAIL hppa*-*-*."}, {"sha": "efeeb94447a384605e15d435c688e377b4e8efa2", "filename": "gcc/testsuite/gcc.dg/cpp/include2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Finclude2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Finclude2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Finclude2.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -8,10 +8,9 @@\n /* Source: Neil Booth, 4 Nov 2000.  */\n \n #include <silly\\>>  /* { dg-warning \"extra tokens\" \"\" } */\n-#include \"silly\\\"\"  /* { dg-error \"missing\" \"\" } */\n+#include \"silly\\\"\"  /* { dg-warning \"extra tokens\" \"\" } */\n \n /* These first 2 errors are No such file or directory.  However, this\n    message is locale-dependent, so don't test for it.  */\n /* { dg-error \"silly\" \"\" { target *-*-* } 10 } */\n /* { dg-error \"silly\" \"\" { target *-*-* } 11 } */\n-/* { dg-warning \"extra tokens\" \"\" { target *-*-* } 11 } */"}, {"sha": "6a674b4dcd1b757de2a3dbb06780af7d429ef61e", "filename": "gcc/testsuite/gcc.dg/cpp/multiline-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmultiline-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmultiline-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmultiline-2.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -0,0 +1,14 @@\n+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.  */\n+\n+/* { dg-do compile } */\n+\n+/* Test that multi-line tokens are rejected by the compiler.  Source:\n+   Neil Booth.  */\n+\n+const char *p = \"line 1\n+\"\n+\"\";\t\t\t      /* The compiler front end sees this.  */\n+\n+/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 8 } */\n+/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 9 } */\n+"}, {"sha": "103f9f6f4617d88cc883f8c3bce4db3026d99710", "filename": "gcc/testsuite/gcc.dg/cpp/multiline.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmultiline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmultiline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmultiline.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+/* Copyright (C) 2000, 2003 Free Software Foundation, Inc.  */\n /* { dg-do preprocess } */\n /* { dg-options \"-C\" } */\n /* Test that multi-line tokens are recognized by cpp0 as being\n@@ -22,11 +22,5 @@ L\"line 1\n    { dg-final { if \\{ [grep multiline.i \"^$\"] == \"\" \\} \\{               } }\n    { dg-final { return \\}                                               } }\n    { dg-final { fail \"multiline.c: multi-line tokens\"                   } } */\n-/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 11 } */\n-/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 14 } */\n-/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 15 } */\n-/* { dg-error \"missing term\" \"multiline strings\" { target *-*-* } 18 } */\n-/* { dg-bogus \"warning\" \"warning in place of error\" { target *-*-* } 11 } */\n-/* { dg-bogus \"warning\" \"warning in place of error\" { target *-*-* } 14 } */\n+/* { dg-bogus \"missing term\" \"multiline strings\" { target *-*-* } 11 } */\n /* { dg-bogus \"warning\" \"warning in place of error\" { target *-*-* } 15 } */\n-/* { dg-bogus \"warning\" \"warning in place of error\" { target *-*-* } 18 } */"}, {"sha": "2c768dcd05ec8ab3df510e3bc0f2a35a4a7cfef5", "filename": "gcc/testsuite/gcc.dg/cpp/strify2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fstrify2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fstrify2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fstrify2.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -1,7 +1,7 @@\n /* Copyright (C) 2000 Free Software Foundation, Inc.  */\n \n /* { dg-do run } */\n-/* { dg-options \"-std=c99 -pedantic-errors\" } */\n+/* { dg-options \"-std=c99 -pedantic-errors -fno-show-column\" } */\n \n /* Tests a whole bunch of things are correctly stringified.  */\n "}, {"sha": "29ffcbfbdeec763e140304de943da65e31fe01d6", "filename": "gcc/testsuite/gcc.dg/cpp/trad/literals-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fliterals-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6338b35872d465cf27fdbbc43b5a146363c8f246/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fliterals-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Ftrad%2Fliterals-2.c?ref=6338b35872d465cf27fdbbc43b5a146363c8f246", "patch": "@@ -3,6 +3,6 @@\n \n /* { dg-do preprocess } */\n \n-/* { dg-error \"missing terminating\" \"bad charconst\" { target *-*-* } 7 } */\n+/* { dg-error \"not valid\" \"bad charconst\" { target *-*-* } 7 } */\n #if 'x\n #endif"}]}