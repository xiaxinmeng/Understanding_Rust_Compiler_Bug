{"sha": "bb576017726e893e26146f21dd75f4002c8acc74", "node_id": "C_kwDOANBUbNoAKGJiNTc2MDE3NzI2ZTg5M2UyNjE0NmYyMWRkNzVmNDAwMmM4YWNjNzQ", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-04-21T21:15:04Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-12-09T01:37:03Z"}, "message": "Implement hwasan target_hook.\n\ngcc/ChangeLog:\n\n\t* doc/invoke.texi (x86 options): Document\n\t-mlam={none,u48,u57}.\n\t* config/i386/i386-opts.h (enum lam_type): New enum.\n\t* config/i386/i386.cc (ix86_memtag_can_tag_addresses): New.\n\t(ix86_memtag_set_tag): Ditto.\n\t(ix86_memtag_extract_tag): Ditto.\n\t(ix86_memtag_add_tag): Ditto.\n\t(ix86_memtag_tag_size): Ditto.\n\t(ix86_memtag_untagged_pointer): Ditto.\n\t(TARGET_MEMTAG_CAN_TAG_ADDRESSES): New.\n\t(TARGET_MEMTAG_ADD_TAG): Ditto.\n\t(TARGET_MEMTAG_SET_TAG): Ditto.\n\t(TARGET_MEMTAG_EXTRACT_TAG): Ditto.\n\t(TARGET_MEMTAG_UNTAGGED_POINTER): Ditto.\n\t(TARGET_MEMTAG_TAG_SIZE): Ditto.\n\t(IX86_HWASAN_SHIFT): Ditto.\n\t(IX86_HWASAN_TAG_SIZE): Ditto.\n\t* config/i386/i386-expand.cc (ix86_expand_call): Untag code\n\tpointer.\n\t* config/i386/i386-options.cc (ix86_option_override_internal):\n\tError when enable -mlam=[u48|u57] for 32-bit code.\n\t* config/i386/i386.opt: Add -mlam=[none|u48|u57].\n\t* config/i386/i386-protos.h (ix86_memtag_untagged_pointer):\n\tDeclare.\n\t(ix86_memtag_can_tag_addresses): Ditto.", "tree": {"sha": "27516170a2cc96590b3d60f3b558264b6d83481c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27516170a2cc96590b3d60f3b558264b6d83481c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb576017726e893e26146f21dd75f4002c8acc74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb576017726e893e26146f21dd75f4002c8acc74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb576017726e893e26146f21dd75f4002c8acc74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb576017726e893e26146f21dd75f4002c8acc74/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d61c0357ebc771166d5d48743f80aa339b4183dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d61c0357ebc771166d5d48743f80aa339b4183dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d61c0357ebc771166d5d48743f80aa339b4183dc"}], "stats": {"total": 171, "additions": 170, "deletions": 1}, "files": [{"sha": "a45640f9a963b68be54363cd658d23f283e7998f", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=bb576017726e893e26146f21dd75f4002c8acc74", "patch": "@@ -92,6 +92,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"i386-options.h\"\n #include \"i386-builtins.h\"\n #include \"i386-expand.h\"\n+#include \"asan.h\"\n \n /* Split one or more double-mode RTL references into pairs of half-mode\n    references.  The RTL can be REG, offsettable MEM, integer constant, or\n@@ -9465,6 +9466,17 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n       fnaddr = gen_rtx_MEM (QImode, copy_to_mode_reg (word_mode, fnaddr));\n     }\n \n+  /* PR100665: Hwasan may tag code pointer which is not supported by LAM,\n+     mask off code pointers here.\n+     TODO: also need to handle indirect jump.  */\n+  if (ix86_memtag_can_tag_addresses () && !fndecl\n+      && sanitize_flags_p (SANITIZE_HWADDRESS))\n+    {\n+      rtx untagged_addr = ix86_memtag_untagged_pointer (XEXP (fnaddr, 0),\n+\t\t\t\t\t\t\tNULL_RTX);\n+      fnaddr = gen_rtx_MEM (QImode, untagged_addr);\n+    }\n+\n   call = gen_rtx_CALL (VOIDmode, fnaddr, callarg1);\n \n   if (retval)"}, {"sha": "25f21ac2a49ffae7940a72500a21f723c9e66943", "filename": "gcc/config/i386/i386-options.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386-options.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386-options.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.cc?ref=bb576017726e893e26146f21dd75f4002c8acc74", "patch": "@@ -2033,6 +2033,9 @@ ix86_option_override_internal (bool main_args_p,\n   if (TARGET_UINTR && !TARGET_64BIT)\n     error (\"%<-muintr%> not supported for 32-bit code\");\n \n+  if (ix86_lam_type && !TARGET_LP64)\n+    error (\"%<-mlam=%> option: [u48|u57] not supported for 32-bit code\");\n+\n   if (!opts->x_ix86_arch_string)\n     opts->x_ix86_arch_string\n       = TARGET_64BIT_P (opts->x_ix86_isa_flags)"}, {"sha": "d3bfeed0af2c4c7fb219b4644164a27950ec9855", "filename": "gcc/config/i386/i386-opts.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-opts.h?ref=bb576017726e893e26146f21dd75f4002c8acc74", "patch": "@@ -128,4 +128,10 @@ enum harden_sls {\n   harden_sls_all = harden_sls_return | harden_sls_indirect_jmp\n };\n \n+enum lam_type {\n+  lam_none = 0,\n+  lam_u48 = 1,\n+  lam_u57\n+};\n+\n #endif"}, {"sha": "abd123c9efcaaa1335f2c4127d283c863c35fcb1", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=bb576017726e893e26146f21dd75f4002c8acc74", "patch": "@@ -228,6 +228,8 @@ extern void ix86_expand_atomic_fetch_op_loop (rtx, rtx, rtx, enum rtx_code,\n extern void ix86_expand_cmpxchg_loop (rtx *, rtx, rtx, rtx, rtx, rtx,\n \t\t\t\t      bool, rtx_code_label *);\n extern rtx ix86_expand_fast_convert_bf_to_sf (rtx);\n+extern rtx ix86_memtag_untagged_pointer (rtx, rtx);\n+extern bool ix86_memtag_can_tag_addresses (void);\n \n #ifdef TREE_CODE\n extern void init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);"}, {"sha": "518cc9ffd1f5df2ff2c74b03fb1868da163b53bb", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=bb576017726e893e26146f21dd75f4002c8acc74", "patch": "@@ -24274,6 +24274,111 @@ ix86_push_rounding (poly_int64 bytes)\n   return ROUND_UP (bytes, UNITS_PER_WORD);\n }\n \n+/* Use 8 bits metadata start from bit48 for LAM_U48,\n+   6 bits metadat start from bit57 for LAM_U57.  */\n+#define IX86_HWASAN_SHIFT (ix86_lam_type == lam_u48\t\t\\\n+\t\t\t   ? 48\t\t\t\t\t\\\n+\t\t\t   : (ix86_lam_type == lam_u57 ? 57 : 0))\n+#define IX86_HWASAN_TAG_SIZE (ix86_lam_type == lam_u48\t\t\\\n+\t\t\t      ? 8\t\t\t\t\\\n+\t\t\t      : (ix86_lam_type == lam_u57 ? 6 : 0))\n+\n+/* Implement TARGET_MEMTAG_CAN_TAG_ADDRESSES.  */\n+bool\n+ix86_memtag_can_tag_addresses ()\n+{\n+  return ix86_lam_type != lam_none && TARGET_LP64;\n+}\n+\n+/* Implement TARGET_MEMTAG_TAG_SIZE.  */\n+unsigned char\n+ix86_memtag_tag_size ()\n+{\n+  return IX86_HWASAN_TAG_SIZE;\n+}\n+\n+/* Implement TARGET_MEMTAG_SET_TAG.  */\n+rtx\n+ix86_memtag_set_tag (rtx untagged, rtx tag, rtx target)\n+{\n+  /* default_memtag_insert_random_tag may\n+     generate tag with value more than 6 bits.  */\n+  if (ix86_lam_type == lam_u57)\n+    {\n+      unsigned HOST_WIDE_INT and_imm\n+\t= (HOST_WIDE_INT_1U << IX86_HWASAN_TAG_SIZE) - 1;\n+\n+      emit_insn (gen_andqi3 (tag, tag, GEN_INT (and_imm)));\n+    }\n+  tag = expand_simple_binop (Pmode, ASHIFT, tag,\n+\t\t\t     GEN_INT (IX86_HWASAN_SHIFT), NULL_RTX,\n+\t\t\t     /* unsignedp = */1, OPTAB_WIDEN);\n+  rtx ret = expand_simple_binop (Pmode, IOR, untagged, tag, target,\n+\t\t\t\t /* unsignedp = */1, OPTAB_DIRECT);\n+  return ret;\n+}\n+\n+/* Implement TARGET_MEMTAG_EXTRACT_TAG.  */\n+rtx\n+ix86_memtag_extract_tag (rtx tagged_pointer, rtx target)\n+{\n+  rtx tag = expand_simple_binop (Pmode, LSHIFTRT, tagged_pointer,\n+\t\t\t\t GEN_INT (IX86_HWASAN_SHIFT), target,\n+\t\t\t\t /* unsignedp = */0,\n+\t\t\t\t OPTAB_DIRECT);\n+  rtx ret = gen_reg_rtx (QImode);\n+  /* Mask off bit63 when LAM_U57.  */\n+  if (ix86_lam_type == lam_u57)\n+    {\n+      unsigned HOST_WIDE_INT and_imm\n+\t= (HOST_WIDE_INT_1U << IX86_HWASAN_TAG_SIZE) - 1;\n+      emit_insn (gen_andqi3 (ret, gen_lowpart (QImode, tag),\n+\t\t\t     gen_int_mode (and_imm, QImode)));\n+    }\n+  else\n+    emit_move_insn (ret, gen_lowpart (QImode, tag));\n+  return ret;\n+}\n+\n+/* The default implementation of TARGET_MEMTAG_UNTAGGED_POINTER.  */\n+rtx\n+ix86_memtag_untagged_pointer (rtx tagged_pointer, rtx target)\n+{\n+  /* Leave bit63 alone.  */\n+  rtx tag_mask = gen_int_mode (((HOST_WIDE_INT_1U << IX86_HWASAN_SHIFT)\n+\t\t\t\t+ (HOST_WIDE_INT_1U << 63) - 1),\n+\t\t\t       Pmode);\n+  rtx untagged_base = expand_simple_binop (Pmode, AND, tagged_pointer,\n+\t\t\t\t\t   tag_mask, target, true,\n+\t\t\t\t\t   OPTAB_DIRECT);\n+  gcc_assert (untagged_base);\n+  return untagged_base;\n+}\n+\n+/* Implement TARGET_MEMTAG_ADD_TAG.  */\n+rtx\n+ix86_memtag_add_tag (rtx base, poly_int64 offset, unsigned char tag_offset)\n+{\n+  rtx base_tag = gen_reg_rtx (QImode);\n+  rtx base_addr = gen_reg_rtx (Pmode);\n+  rtx tagged_addr = gen_reg_rtx (Pmode);\n+  rtx new_tag = gen_reg_rtx (QImode);\n+  unsigned HOST_WIDE_INT and_imm\n+    = (HOST_WIDE_INT_1U << IX86_HWASAN_SHIFT) - 1;\n+\n+  /* When there's \"overflow\" in tag adding,\n+     need to mask the most significant bit off.  */\n+  emit_move_insn (base_tag, ix86_memtag_extract_tag (base, NULL_RTX));\n+  emit_move_insn (base_addr,\n+\t\t  ix86_memtag_untagged_pointer (base, NULL_RTX));\n+  emit_insn (gen_add2_insn (base_tag, gen_int_mode (tag_offset, QImode)));\n+  emit_move_insn (new_tag, base_tag);\n+  emit_insn (gen_andqi3 (new_tag, new_tag, gen_int_mode (and_imm, QImode)));\n+  emit_move_insn (tagged_addr,\n+\t\t  ix86_memtag_set_tag (base_addr, new_tag, NULL_RTX));\n+  return plus_constant (Pmode, tagged_addr, offset);\n+}\n+\n /* Target-specific selftests.  */\n \n #if CHECKING_P\n@@ -25068,6 +25173,24 @@ ix86_libgcc_floating_mode_supported_p\n # define TARGET_ASM_RELOC_RW_MASK ix86_reloc_rw_mask\n #endif\n \n+#undef TARGET_MEMTAG_CAN_TAG_ADDRESSES\n+#define TARGET_MEMTAG_CAN_TAG_ADDRESSES ix86_memtag_can_tag_addresses\n+\n+#undef TARGET_MEMTAG_ADD_TAG\n+#define TARGET_MEMTAG_ADD_TAG ix86_memtag_add_tag\n+\n+#undef TARGET_MEMTAG_SET_TAG\n+#define TARGET_MEMTAG_SET_TAG ix86_memtag_set_tag\n+\n+#undef TARGET_MEMTAG_EXTRACT_TAG\n+#define TARGET_MEMTAG_EXTRACT_TAG ix86_memtag_extract_tag\n+\n+#undef TARGET_MEMTAG_UNTAGGED_POINTER\n+#define TARGET_MEMTAG_UNTAGGED_POINTER ix86_memtag_untagged_pointer\n+\n+#undef TARGET_MEMTAG_TAG_SIZE\n+#define TARGET_MEMTAG_TAG_SIZE ix86_memtag_tag_size\n+\n static bool ix86_libc_has_fast_function (int fcode ATTRIBUTE_UNUSED)\n {\n #ifdef OPTION_GLIBC"}, {"sha": "fb4e57ada7c19022ca69e38d9bc1fefb15b70f4c", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=bb576017726e893e26146f21dd75f4002c8acc74", "patch": "@@ -1250,3 +1250,19 @@ Support RAOINT built-in functions and code generation.\n munroll-only-small-loops\n Target Var(ix86_unroll_only_small_loops) Init(0) Save\n Enable conservative small loop unrolling.\n+\n+mlam=\n+Target RejectNegative Joined Enum(lam_type) Var(ix86_lam_type) Init(lam_none)\n+-mlam=[none|u48|u57] Instrument meta data position in user data pointers.\n+\n+Enum\n+Name(lam_type) Type(enum lam_type) UnknownError(unknown lam type %qs)\n+\n+EnumValue\n+Enum(lam_type) String(none) Value(lam_none)\n+\n+EnumValue\n+Enum(lam_type) String(u48) Value(lam_u48)\n+\n+EnumValue\n+Enum(lam_type) String(u57) Value(lam_u57)"}, {"sha": "cb40b38b73af0ce311e0d65c721a176dc15e06c2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb576017726e893e26146f21dd75f4002c8acc74/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bb576017726e893e26146f21dd75f4002c8acc74", "patch": "@@ -1448,7 +1448,7 @@ See RS/6000 and PowerPC Options.\n -mindirect-branch=@var{choice}  -mfunction-return=@var{choice} @gol\n -mindirect-branch-register -mharden-sls=@var{choice} @gol\n -mindirect-branch-cs-prefix -mneeded -mno-direct-extern-access @gol\n--munroll-only-small-loops}\n+-munroll-only-small-loops -mlam=@var{choice}}\n \n @emph{x86 Windows Options}\n @gccoptlist{-mconsole  -mcygwin  -mno-cygwin  -mdll @gol\n@@ -33891,6 +33891,13 @@ Controls conservative small loop unrolling. It is default enabled by\n O2, and unrolls loop with less than 4 insns by 1 time. Explicit\n -f[no-]unroll-[all-]loops would disable this flag to avoid any\n unintended unrolling behavior that user does not want.\n+\n+@item -mlam=@var{choice}\n+@opindex mlam\n+LAM(linear-address masking) allows special bits in the pointer to be used\n+for metadata. The default is @samp{none}. With @samp{u48}, pointer bits in\n+positions 62:48 can be used for metadata; With @samp{u57}, pointer bits in\n+positions 62:57 can be used for metadata.\n @end table\n \n @node x86 Windows Options"}]}