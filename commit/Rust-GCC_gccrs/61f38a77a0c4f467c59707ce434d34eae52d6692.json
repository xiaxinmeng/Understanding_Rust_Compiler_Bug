{"sha": "61f38a77a0c4f467c59707ce434d34eae52d6692", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmMzhhNzdhMGM0ZjQ2N2M1OTcwN2NlNDM0ZDM0ZWFlNTJkNjY5Mg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-08-17T18:39:15Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-08-17T18:39:15Z"}, "message": "Initial revision\n\nFrom-SVN: r44969", "tree": {"sha": "b8e0afefff8ad4f413b4d19a28a69f1e15de225b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8e0afefff8ad4f413b4d19a28a69f1e15de225b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61f38a77a0c4f467c59707ce434d34eae52d6692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f38a77a0c4f467c59707ce434d34eae52d6692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f38a77a0c4f467c59707ce434d34eae52d6692", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f38a77a0c4f467c59707ce434d34eae52d6692/comments", "author": null, "committer": null, "parents": [{"sha": "b38a75e57d32c479904ae185ad716f66ab44c591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38a75e57d32c479904ae185ad716f66ab44c591", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38a75e57d32c479904ae185ad716f66ab44c591"}], "stats": {"total": 11927, "additions": 11927, "deletions": 0}, "files": [{"sha": "a5d24c6550ee14589f8a7cac91d0974b5dae5d3c", "filename": "boehm-gc/Makefile.direct", "status": "added", "additions": 597, "deletions": 0, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2FMakefile.direct", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2FMakefile.direct", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.direct?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,597 @@\n+# This is the original manually generated Makefile.  It may still be used\n+# to build the collector.\n+#\n+# Primary targets:\n+# gc.a - builds basic library\n+# c++ - adds C++ interface to library\n+# cords - adds cords (heavyweight strings) to library\n+# test - prints porting information, then builds basic version of gc.a,\n+#      \t and runs some tests of collector and cords.  Does not add cords or\n+#\t c++ interface to gc.a\n+# cord/de - builds dumb editor based on cords.\n+ABI_FLAG= \n+CC=cc $(ABI_FLAG)\n+CXX=g++ $(ABI_FLAG)\n+AS=as $(ABI_FLAG)\n+#  The above doesn't work with gas, which doesn't run cpp.\n+#  Define AS as `gcc -c -x assembler-with-cpp' instead.\n+#  Under Irix 6, you will have to specify the ABI (-o32, -n32, or -64)\n+#  if you use something other than the default ABI on your machine.\n+\n+# Redefining srcdir allows object code for the nonPCR version of the collector\n+# to be generated in different directories.\n+srcdir= .\n+VPATH= $(srcdir)\n+\n+CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_PERMISSION -DSILENT -DALL_INTERIOR_POINTERS\n+\n+# To build the parallel collector on Linux, add to the above:\n+# -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC\n+# To build the parallel collector n a static library on HP/UX, add to the above:\n+# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -DUSE_HPUX_TLS -D_POSIX_C_SOURCE=199506L\n+\n+# HOSTCC and HOSTCFLAGS are used to build executables that will be run as\n+# part of the build process, i.e. on the build machine.  These will usually\n+# be the same as CC and CFLAGS, except in a cross-compilation environment.\n+# Note that HOSTCFLAGS should include any -D flags that affect thread support.\n+HOSTCC=$(CC)\n+HOSTCFLAGS=$(CFLAGS)\n+\n+# For dynamic library builds, it may be necessary to add flags to generate\n+# PIC code, e.g. -fPIC on Linux.\n+\n+# Setjmp_test may yield overly optimistic results when compiled\n+# without optimization.\n+\n+# These define arguments influence the collector configuration:\n+# -DSILENT disables statistics printing, and improves performance.\n+# -DFIND_LEAK causes GC_find_leak to be initially set.\n+#   This causes the collector to assume that all inaccessible\n+#   objects should have been explicitly deallocated, and reports exceptions.\n+#   Finalization and the test program are not usable in this mode.\n+# -DGC_SOLARIS_THREADS enables support for Solaris (thr_) threads.\n+#   (Clients should also define GC_SOLARIS_THREADS and then include\n+#   gc.h before performing thr_ or dl* or GC_ operations.)\n+#   Must also define -D_REENTRANT.\n+# -DGC_SOLARIS_PTHREADS enables support for Solaris pthreads.\n+#   Define SOLARIS_THREADS as well.\n+# -DGC_IRIX_THREADS enables support for Irix pthreads.  See README.irix.\n+# -DGC_HPUX_THREADS enables support for HP/UX 11 pthreads.\n+#   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.\n+# -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads.\n+#   see README.linux.  -D_REENTRANT may also be required.\n+# -DALL_INTERIOR_POINTERS allows all pointers to the interior\n+#   of objects to be recognized.  (See gc_priv.h for consequences.)\n+#   Alternatively, GC_all_interior_pointers can be set at process\n+#   initialization time.\n+# -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n+#   usually causing it to use less space in such situations.\n+#   Incremental collection no longer works in this case.\n+# -DLARGE_CONFIG tunes the collector for unusually large heaps.\n+#   Necessary for heaps larger than about 500 MB on most machines.\n+#   Recommended for heaps larger than about 64 MB.\n+# -DDONT_ADD_BYTE_AT_END is meaningful only with -DALL_INTERIOR_POINTERS or\n+#   GC_all_interior_pointers = 1.  Normally -DALL_INTERIOR_POINTERS\n+#   causes all objects to be padded so that pointers just past the end of\n+#   an object can be recognized.  This can be expensive.  (The padding\n+#   is normally more than one byte due to alignment constraints.)\n+#   -DDONT_ADD_BYTE_AT_END disables the padding.\n+# -DNO_SIGNALS does not disable signals during critical parts of\n+#   the GC process.  This is no less correct than many malloc \n+#   implementations, and it sometimes has a significant performance\n+#   impact.  However, it is dangerous for many not-quite-ANSI C\n+#   programs that call things like printf in asynchronous signal handlers.\n+#   This is on by default.  Turning it off has not been extensively tested with\n+#   compilers that reorder stores.  It should have been.\n+# -DNO_EXECUTE_PERMISSION may cause some or all of the heap to not\n+#   have execute permission, i.e. it may be impossible to execute\n+#   code from the heap.  Currently this only affects the incremental\n+#   collector on UNIX machines.  It may greatly improve its performance,\n+#   since this may avoid some expensive cache synchronization.\n+# -DGC_NO_OPERATOR_NEW_ARRAY declares that the C++ compiler does not support\n+#   the  new syntax \"operator new[]\" for allocating and deleting arrays.\n+#   See gc_cpp.h for details.  No effect on the C part of the collector.\n+#   This is defined implicitly in a few environments.  Must also be defined\n+#   by clients that use gc_cpp.h.\n+# -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n+#   as aliases for X, GC_realloc, and GC_free, respectively.\n+#   Calloc is redefined in terms of the new malloc.  X should\n+#   be either GC_malloc or GC_malloc_uncollectable, or\n+#   GC_debug_malloc_replacement.  (The latter invokes GC_debug_malloc\n+#   with dummy source location information, but still results in\n+#   properly remembered call stacks on Linux/X86 and Solaris/SPARC.)\n+#   The former is occasionally useful for working around leaks in code\n+#   you don't want to (or can't) look at.  It may not work for\n+#   existing code, but it often does.  Neither works on all platforms,\n+#   since some ports use malloc or calloc to obtain system memory.\n+#   (Probably works for UNIX, and win32.)\n+# -DREDIRECT_REALLOC=X causes GC_realloc to be redirected to X.\n+#   The canonical use is -DREDIRECT_REALLOC=GC_debug_realloc_replacement,\n+#   together with -DREDIRECT_MALLOC=GC_debug_malloc_replacement to\n+#   generate leak reports with call stacks for both malloc and realloc.\n+# -DIGNORE_FREE turns calls to free into a noop.  Only useful with\n+#   -DREDIRECT_MALLOC.\n+# -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.\n+#   Reduces code size slightly at the expense of debuggability.\n+# -DJAVA_FINALIZATION makes it somewhat safer to finalize objects out of\n+#   order by specifying a nonstandard finalization mark procedure  (see\n+#   finalize.c).  Objects reachable from finalizable objects will be marked\n+#   in a sepearte postpass, and hence their memory won't be reclaimed.\n+#   Not recommended unless you are implementing a language that specifies\n+#   these semantics.  Since 5.0, determines only only the initial value\n+#   of GC_java_finalization variable.\n+# -DFINALIZE_ON_DEMAND causes finalizers to be run only in response\n+#   to explicit GC_invoke_finalizers() calls.\n+#   In 5.0 this became runtime adjustable, and this only determines the\n+#   initial value of GC_finalize_on_demand.\n+# -DATOMIC_UNCOLLECTABLE includes code for GC_malloc_atomic_uncollectable.\n+#   This is useful if either the vendor malloc implementation is poor,\n+#   or if REDIRECT_MALLOC is used.\n+# -DHBLKSIZE=ddd, where ddd is a power of 2 between 512 and 16384, explicitly\n+#   sets the heap block size.  Each heap block is devoted to a single size and\n+#   kind of object.  For the incremental collector it makes sense to match\n+#   the most likely page size.  Otherwise large values result in more\n+#   fragmentation, but generally better performance for large heaps.\n+# -DUSE_MMAP use MMAP instead of sbrk to get new memory.\n+#   Works for Solaris and Irix.\n+# -DUSE_MUNMAP causes memory to be returned to the OS under the right\n+#   circumstances.  This currently disables VM-based incremental collection.\n+#   This is currently experimental, and works only under some Unix and\n+#   Linux versions.\n+# -DMMAP_STACKS (for Solaris threads) Use mmap from /dev/zero rather than\n+#   GC_scratch_alloc() to get stack memory.\n+# -DPRINT_BLACK_LIST Whenever a black list entry is added, i.e. whenever\n+#   the garbage collector detects a value that looks almost, but not quite,\n+#   like a pointer, print both the address containing the value, and the\n+#   value of the near-bogus-pointer.  Can be used to identifiy regions of\n+#   memory that are likely to contribute misidentified pointers.\n+# -DKEEP_BACK_PTRS Add code to save back pointers in debugging headers\n+#   for objects allocated with the debugging allocator.  If all objects\n+#   through GC_MALLOC with GC_DEBUG defined, this allows the client\n+#   to determine how particular or randomly chosen objects are reachable\n+#   for debugging/profiling purposes.  The gc_backptr.h interface is\n+#   implemented only if this is defined.\n+# -DGC_ASSERTIONS Enable some internal GC assertion checking.  Currently\n+#   this facility is only used in a few places.  It is intended primarily\n+#   for debugging of the garbage collector itself, but could also\n+# -DDBG_HDRS_ALL Make sure that all objects have debug headers.  Increases\n+#   the reliability (from 99.9999% to 100%) of some of the debugging\n+#   code (especially KEEP_BACK_PTRS).  Makes -DSHORT_DBG_HDRS possible.\n+#   Assumes that all client allocation is done through debugging\n+#   allocators.\n+# -DSHORT_DBG_HDRS Assume that all objects have debug headers.  Shorten\n+#   the headers to minimize object size, at the expense of checking for\n+#   writes past the end of an object.  This is intended for environments\n+#   in which most client code is written in a \"safe\" language, such as\n+#   Scheme or Java.  Assumes that all client allocation is done using\n+#   the GC_debug_ functions, or through the macros that expand to these,\n+#   or by redirecting malloc to GC_debug_malloc_replacement.\n+#   (Also eliminates the field for the requested object size.)\n+#   occasionally be useful for debugging of client code.  Slows down the\n+#   collector somewhat, but not drastically.\n+# -DSAVE_CALL_COUNT=<n> Set the number of call frames saved with objects\n+#   allocated through the debugging interface.  Affects the amount of\n+#   information generated in leak reports.  Only matters on platforms\n+#   on which we can quickly generate call stacks, currently Linux/(X86 & SPARC)\n+#   and Solaris/SPARC.  Turns on call chain saving on X86.  On X86, client\n+#   code should NOT be compiled with -fomit-frame-pointer.\n+# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n+#   altered stubborn objects, at substantial performance cost.\n+#   Use only for debugging of the incremental collector.\n+# -DGC_GCJ_SUPPORT includes support for gcj (and possibly other systems\n+#   that include a pointer to a type descriptor in each allocated object).\n+#   Building this way requires an ANSI C compiler.\n+# -DUSE_I686_PREFETCH causes the collector to issue Pentium III style\n+#   prefetch instructions.  No effect except on X86 Linux platforms.\n+#   Assumes a very recent gcc-compatible compiler and assembler.\n+#   (Gas prefetcht0 support was added around May 1999.)\n+#   Empirically the code appears to still run correctly on Pentium II\n+#   processors, though with no performance benefit.  May not run on other\n+#   X86 processors?  In some cases this improves performance by\n+#   15% or so.\n+# -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style\n+#   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.\n+#   UNTESTED!!\n+# -DGC_USE_LD_WRAP in combination with the gld flags listed in README.linux\n+#   causes the collector some system and pthread calls in a more transparent\n+#   fashion than the usual macro-based approach.  Requires GNU ld, and\n+#   currently probably works only with Linux.\n+# -DTHREAD_LOCAL_ALLOC defines GC_local_malloc(), GC_local_malloc_atomic()\n+#   and GC_local_gcj_malloc().  Needed for gc_gcj.h interface.  These allocate\n+#   in a way that usually does not involve acquisition of a global lock.\n+#   Currently requires -DGC_LINUX_THREADS, but should be easy to port to\n+#   other pthreads environments.  Recommended for multiprocessors.\n+# -DPARALLEL_MARK allows the marker to run in multiple threads.  Recommended\n+#   for multiprocessors.  Currently requires Linux on X86 or IA64, though\n+#   support for other Posix platforms should be fairly easy to add,\n+#   if the thread implementation is otherwise supported.\n+# -DNO_GETENV prevents the collector from looking at environment variables.\n+#   These may otherwise alter its configuration, or turn off GC altogether.\n+#   I don't know of a reason to disable this, except possibly if the\n+#   resulting process runs as a privileged user?\n+# -DSTUBBORN_ALLOC allows allocation of \"hard to change\" objects, and thus\n+#   makes incremental collection easier.  Was enabled by default until 6.0.\n+#   Rarely used, to my knowledge.\n+#\n+\n+CXXFLAGS= $(CFLAGS) \n+AR= ar\n+RANLIB= ranlib\n+\n+\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o\n+\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c\n+\n+CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC\n+\n+CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n+\n+SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n+    sparc_mach_dep.s include/gc.h include/gc_typed.h \\\n+    include/private/gc_hdrs.h include/private/gc_priv.h \\\n+    include/private/gcconfig.h include/private/gc_pmark.h \\\n+    include/gc_inl.h include/gc_inline.h include/gc_mark.h \\\n+    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc include/gc_cpp.h \\\n+    gcname.c include/weakpointer.h include/private/gc_locks.h \\\n+    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h \\\n+    include/new_gc_alloc.h include/javaxfc.h sparc_sunos4_mach_dep.s \\\n+    sparc_netbsd_mach_dep.s \\\n+    include/private/solaris_threads.h include/gc_backptr.h \\\n+    hpux_test_and_clear.s include/gc_gcj.h \\\n+    include/gc_local_alloc.h include/private/dbg_mlc.h \\\n+    include/private/specific.h powerpc_macosx_mach_dep.s \\\n+    include/leak_detector.h include/gc_amiga_redirects.h \\\n+    include/gc_pthread_redirects.h $(CORD_SRCS)\n+\n+DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \\\n+\tdoc/README.amiga doc/README.cords doc/debugging.html \\\n+\tdoc/README.dj doc/README.hp doc/README.linux doc/README.rs6000 \\\n+\tdoc/README.sgi doc/README.solaris2 doc/README.uts \\\n+\tdoc/README.win32 doc/barrett_diagram doc/README \\\n+        doc/README.contributors doc/README.changes doc/gc.man \\\n+\tdoc/README.environment doc/tree.html doc/gcdescr.html \\\n+\tdoc/README.autoconf doc/README.macros\n+\n+TESTS= tests/test.c tests/test_cpp.cc tests/trace_test.c \\\n+\ttests/leak_test.c tests/thread_leak_test.c\n+\n+GNU_BUILD_FILES= configure.in Makefile.am configure acinclude.m4 \\\n+\t\t libtool.m4 install-sh configure.host Makefile.in \\\n+\t\t aclocal.m4 config.sub config.guess ltconfig \\\n+\t\t ltmain.sh mkinstalldirs\n+\n+OTHER_MAKEFILES= OS2_MAKEFILE NT_MAKEFILE NT_THREADS_MAKEFILE gc.mak \\\n+\t\t BCC_MAKEFILE EMX_MAKEFILE WCC_MAKEFILE Makefile.dj \\\n+\t\t PCR-Makefile SMakefile.amiga Makefile.DLLs \\\n+\t\t digimars.mak Makefile.direct\n+#\tMakefile and Makefile.direct are copies of each other.\n+\n+OTHER_FILES= Makefile setjmp_t.c callprocs pc_excludes \\\n+           MacProjects.sit.hqx MacOS.c \\\n+           Mac_files/datastart.c Mac_files/dataend.c \\\n+           Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n+           add_gc_prefix.c gc_cpp.cpp win32_threads.c \\\n+\t   version.h AmigaOS.c \\\n+\t   $(TESTS) $(GNU_BUILD_FILES) $(OTHER_MAKEFILES)\n+\n+CORD_INCLUDE_FILES= $(srcdir)/include/gc.h $(srcdir)/include/cord.h \\\n+\t$(srcdir)/include/ec.h $(srcdir)/include/private/cord_pos.h\n+\n+UTILS= if_mach if_not_there threadlibs\n+\n+# Libraries needed for curses applications.  Only needed for de.\n+CURSES= -lcurses -ltermlib\n+\n+# The following is irrelevant on most systems.  But a few\n+# versions of make otherwise fork the shell specified in\n+# the SHELL environment variable.\n+SHELL= /bin/sh\n+\n+SPECIALCFLAGS = -I$(srcdir)/include\n+# Alternative flags to the C compiler for mach_dep.c.\n+# Mach_dep.c often doesn't like optimization, and it's\n+# not time-critical anyway.\n+# Set SPECIALCFLAGS to -q nodirect_code on Encore.\n+\n+all: gc.a gctest\n+\n+BSD-pkg-all: bsd-libgc.a\n+\n+bsd-libgc.a:\n+\t$(MAKE) CFLAGS=\"$(CFLAGS)\" clean c++-t\n+\tmv gc.a bsd-libgc.a\n+\n+BSD-pkg-install: BSD-pkg-all\n+\t${CP} bsd-libgc.a libgc.a\n+\t${INSTALL_DATA} libgc.a ${PREFIX}/lib\n+\t${INSTALL_DATA} gc.h gc_cpp.h ${PREFIX}/include\n+\n+pcr: PCR-Makefile include/private/gc_private.h include/private/gc_hdrs.h \\\n+include/private/gc_locks.h include/gc.h include/private/gcconfig.h \\\n+mach_dep.o $(SRCS)\n+\t$(MAKE) -f PCR-Makefile depend\n+\t$(MAKE) -f PCR-Makefile\n+\n+$(OBJS) tests/test.o dyn_load.o dyn_load_sunos53.o: \\\n+    $(srcdir)/include/private/gc_priv.h \\\n+    $(srcdir)/include/private/gc_hdrs.h $(srcdir)/include/private/gc_locks.h \\\n+    $(srcdir)/include/gc.h \\\n+    $(srcdir)/include/private/gcconfig.h $(srcdir)/include/gc_typed.h \\\n+    Makefile\n+# The dependency on Makefile is needed.  Changing\n+# options such as -DSILENT affects the size of GC_arrays,\n+# invalidating all .o files that rely on gc_priv.h\n+\n+mark.o typd_mlc.o finalize.o ptr_chck.o: $(srcdir)/include/gc_mark.h $(srcdir)/include/private/gc_pmark.h\n+\n+specific.o linux_threads.o: $(srcdir)/include/private/specific.h\n+\n+solaris_threads.o solaris_pthreads.o: $(srcdir)/include/private/solaris_threads.h\n+\n+dbg_mlc.o gcj_mlc.o: $(srcdir)/include/private/dbg_mlc.h\n+\n+tests/test.o: tests $(srcdir)/tests/test.c\n+\t$(CC) $(CFLAGS) -c $(srcdir)/tests/test.c\n+\tmv test.o tests/test.o\n+\n+tests:\n+\tmkdir tests\n+\n+base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)\n+\techo > base_lib\n+\trm -f dont_ar_1\n+\t./if_mach SPARC SUNOS5 touch dont_ar_1\n+\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(OBJS) dyn_load.o\n+\t./if_mach M68K AMIGA touch dont_ar_1\n+\t./if_mach M68K AMIGA $(AR) -vrus gc.a $(OBJS) dyn_load.o\n+\t./if_not_there dont_ar_1 $(AR) ru gc.a $(OBJS) dyn_load.o\n+\t./if_not_there dont_ar_1 $(RANLIB) gc.a || cat /dev/null\n+#\tignore ranlib failure; that usually means it doesn't exist, and isn't needed\n+\n+cords: $(CORD_OBJS) cord/cordtest $(UTILS)\n+\trm -f dont_ar_3\n+\t./if_mach SPARC SUNOS5 touch dont_ar_3\n+\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(CORD_OBJS)\n+\t./if_mach M68K AMIGA touch dont_ar_3\n+\t./if_mach M68K AMIGA $(AR) -vrus gc.a $(CORD_OBJS)\n+\t./if_not_there dont_ar_3 $(AR) ru gc.a $(CORD_OBJS)\n+\t./if_not_there dont_ar_3 $(RANLIB) gc.a || cat /dev/null\n+\n+gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/include/gc_cpp.h $(srcdir)/include/gc.h Makefile\n+\t$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc\n+\n+test_cpp: $(srcdir)/tests/test_cpp.cc $(srcdir)/include/gc_cpp.h gc_cpp.o $(srcdir)/include/gc.h \\\n+base_lib $(UTILS)\n+\trm -f test_cpp\n+\t./if_mach HP_PA HPUX $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a -ldld `./threadlibs`\n+\t./if_not_there test_cpp $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a `./threadlibs`\n+\n+c++-t: c++\n+\t./test_cpp 1\n+\n+c++-nt: c++\n+\t@echo \"Use ./test_cpp 1 to test the leak library\"\n+\n+c++: gc_cpp.o $(srcdir)/include/gc_cpp.h test_cpp\n+\trm -f dont_ar_4\n+\t./if_mach SPARC SUNOS5 touch dont_ar_4\n+\t./if_mach SPARC SUNOS5 $(AR) rus gc.a gc_cpp.o\n+\t./if_mach M68K AMIGA touch dont_ar_4\n+\t./if_mach M68K AMIGA $(AR) -vrus gc.a gc_cpp.o\n+\t./if_not_there dont_ar_4 $(AR) ru gc.a gc_cpp.o\n+\t./if_not_there dont_ar_4 $(RANLIB) gc.a || cat /dev/null\n+\t./test_cpp 1\n+\techo > c++\n+\n+dyn_load_sunos53.o: dyn_load.c\n+\t$(CC) $(CFLAGS) -DSUNOS53_SHARED_LIB -c $(srcdir)/dyn_load.c -o $@\n+\n+# SunOS5 shared library version of the collector\n+sunos5gc.so: $(OBJS) dyn_load_sunos53.o\n+\t$(CC) -G -o sunos5gc.so $(OBJS) dyn_load_sunos53.o -ldl\n+\tln sunos5gc.so libgc.so\n+\n+# Alpha/OSF shared library version of the collector\n+libalphagc.so: $(OBJS)\n+\tld -shared -o libalphagc.so $(OBJS) dyn_load.o -lc\n+\tln libalphagc.so libgc.so\n+\n+# IRIX shared library version of the collector\n+libirixgc.so: $(OBJS) dyn_load.o\n+\tld -shared $(ABI_FLAG) -o libirixgc.so $(OBJS) dyn_load.o -lc\n+\tln libirixgc.so libgc.so\n+\n+# Linux shared library version of the collector\n+liblinuxgc.so: $(OBJS) dyn_load.o\n+\tgcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o\n+\tln liblinuxgc.so libgc.so\n+\n+# Alternative Linux rule.  This is preferable, but is likely to break the\n+# Makefile for some non-linux platforms.\n+# LIBOBJS= $(patsubst %.o, %.lo, $(OBJS))\n+#\n+#.SUFFIXES: .lo $(SUFFIXES)\n+#\n+#.c.lo:\n+#\t$(CC) $(CFLAGS) $(CPPFLAGS) -fPIC -c $< -o $@\n+#\n+# liblinuxgc.so: $(LIBOBJS) dyn_load.lo\n+# \tgcc -shared -Wl,-soname=libgc.so.0 -o libgc.so.0 $(LIBOBJS) dyn_load.lo\n+#\ttouch liblinuxgc.so\n+\n+mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s \\\n+            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_macosx_mach_dep.s $(UTILS)\n+\trm -f mach_dep.o\n+\t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n+\t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n+\t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n+\t./if_mach RS6000 \"\" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s\n+\t./if_mach POWERPC MACOSX $(AS) -o mach_dep.o $(srcdir)/powerpc_macosx_mach_dep.s\n+#\t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.s\n+#\talpha_mach_dep.s assumes that pointers are not saved in fp registers.\n+#\tGcc on a 21264 can spill pointers to fp registers.  Oops.\n+\t./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.s\n+\t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n+\t./if_mach SPARC OPENBSD $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n+\t./if_mach SPARC NETBSD $(AS) -o mach_dep.o $(srcdir)/sparc_netbsd_mach_dep.s\n+\t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n+\n+mark_rts.o: $(srcdir)/mark_rts.c $(UTILS)\n+\trm -f mark_rts.o\n+\t-./if_mach ALPHA OSF1 $(CC) -c $(CFLAGS) -Wo,-notail $(srcdir)/mark_rts.c\n+\t./if_not_there mark_rts.o $(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c\n+#\tWork-around for DEC optimizer tail recursion elimination bug.\n+#  The ALPHA-specific line should be removed if gcc is used.\n+\n+alloc.o: version.h\n+\n+cord:\n+\tmkdir cord\n+\n+cord/cordbscs.o: cord $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordbscs.c\n+\tmv cordbscs.o cord/cordbscs.o\n+#  not all compilers understand -o filename\n+\n+cord/cordxtra.o: cord $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordxtra.c\n+\tmv cordxtra.o cord/cordxtra.o\n+\n+cord/cordprnt.o: cord $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordprnt.c\n+\tmv cordprnt.o cord/cordprnt.o\n+\n+cord/cordtest: $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS)\n+\trm -f cord/cordtest\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -lucb\n+\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -ldld `./threadlibs`\n+\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`\n+\t./if_not_there cord/cordtest $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`\n+\n+cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)\n+\trm -f cord/de\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb `./threadlibs`\n+\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld `./threadlibs`\n+\t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_mach POWERPC MACOSX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n+\t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n+\t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n+\t./if_mach IA64 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n+\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) `./threadlibs`\n+\n+if_mach: $(srcdir)/if_mach.c $(srcdir)/include/private/gcconfig.h\n+\t$(HOSTCC) $(HOSTCFLAGS) -o if_mach $(srcdir)/if_mach.c\n+\n+threadlibs: $(srcdir)/threadlibs.c $(srcdir)/include/private/gcconfig.h Makefile\n+\t$(HOSTCC) $(HOSTCFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n+\n+if_not_there: $(srcdir)/if_not_there.c\n+\t$(HOSTCC) $(HOSTCFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n+\n+clean: \n+\trm -f gc.a *.o *.exe tests/*.o gctest gctest_dyn_link test_cpp \\\n+\t      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \\\n+\t      threadlibs $(CORD_OBJS) cord/cordtest cord/de\n+\t-rm -f *~\n+\n+gctest: tests/test.o gc.a $(UTILS)\n+\trm -f gctest\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -lucb\n+\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -ldld `./threadlibs`\n+\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o gctest  tests/test.o gc.a `./threadlibs`\n+\t./if_not_there gctest $(CC) $(CFLAGS) -o gctest tests/test.o gc.a `./threadlibs`\n+\n+# If an optimized setjmp_test generates a segmentation fault,\n+# odds are your compiler is broken.  Gctest may still work.\n+# Try compiling setjmp_t.c unoptimized.\n+setjmp_test: $(srcdir)/setjmp_t.c $(srcdir)/include/gc.h $(UTILS)\n+\t$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c\n+\n+test:  KandRtest cord/cordtest\n+\tcord/cordtest\n+\n+# Those tests that work even with a K&R C compiler:\n+KandRtest: setjmp_test gctest\n+\t./setjmp_test\n+\t./gctest\n+\n+add_gc_prefix: $(srcdir)/add_gc_prefix.c $(srcdir)/version.h\n+\t$(CC) -o add_gc_prefix $(srcdir)/add_gc_prefix.c\n+\n+gcname: $(srcdir)/gcname.c $(srcdir)/version.h\n+\t$(CC) -o gcname $(srcdir)/gcname.c\n+\n+gc.tar: $(SRCS) $(DOC_FILES) $(OTHER_FILES) add_gc_prefix gcname\n+\tcp Makefile Makefile.old\n+\tcp Makefile.direct Makefile\n+\trm -f `./gcname`\n+\tln -s . `./gcname`\n+\t./add_gc_prefix $(SRCS) $(DOC_FILES) $(OTHER_FILES) > /tmp/gc.tar-files\n+\ttar cvfh gc.tar `cat /tmp/gc.tar-files`\n+\tcp gc.tar `./gcname`.tar\n+\tgzip `./gcname`.tar\n+\trm `./gcname`\n+\n+pc_gc.tar: $(SRCS) $(OTHER_FILES)\n+\ttar cvfX pc_gc.tar pc_excludes $(SRCS) $(OTHER_FILES)\n+\n+floppy: pc_gc.tar\n+\t-mmd a:/cord\n+\t-mmd a:/cord/private\n+\t-mmd a:/include\n+\t-mmd a:/include/private\n+\tmkdir /tmp/pc_gc\n+\tcat pc_gc.tar | (cd /tmp/pc_gc; tar xvf -)\n+\t-mcopy -tmn /tmp/pc_gc/* a:\n+\t-mcopy -tmn /tmp/pc_gc/cord/* a:/cord\n+\t-mcopy -mn /tmp/pc_gc/cord/de_win.ICO a:/cord\n+\t-mcopy -tmn /tmp/pc_gc/cord/private/* a:/cord/private\n+\t-mcopy -tmn /tmp/pc_gc/include/* a:/include\n+\t-mcopy -tmn /tmp/pc_gc/include/private/* a:/include/private\n+\trm -r /tmp/pc_gc\n+\n+gc.tar.Z: gc.tar\n+\tcompress gc.tar\n+\n+gc.tar.gz: gc.tar\n+\tgzip gc.tar\n+\n+lint: $(CSRCS) tests/test.c\n+\tlint -DLINT $(CSRCS) tests/test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall|change in ANSI|improper alignment\"\n+\n+# BTL: added to test shared library version of collector.\n+# Currently works only under SunOS5.  Requires GC_INIT call from statically\n+# loaded client code.\n+ABSDIR = `pwd`\n+gctest_dyn_link: tests/test.o libgc.so\n+\t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link tests/test.o -lgc -ldl -lthread\n+\n+gctest_irix_dyn_link: tests/test.o libirixgc.so\n+\t$(CC) -L$(ABSDIR) -o gctest_irix_dyn_link tests/test.o -lirixgc\n+\n+# The following appear to be dead, especially since libgc_globals.h\n+# is apparently lost.\n+test_dll.o: tests/test.c libgc_globals.h\n+\t$(CC) $(CFLAGS) -DGC_USE_DLL -c tests/test.c -o test_dll.o\n+\n+test_dll: test_dll.o libgc_dll.a libgc.dll\n+\t$(CC) test_dll.o -L$(ABSDIR) -lgc_dll -o test_dll\n+\n+SYM_PREFIX-libgc=GC\n+\n+# Uncomment the following line to build a GNU win32 DLL\n+# include Makefile.DLLs\n+\n+reserved_namespace: $(SRCS)\n+\tfor file in $(SRCS) tests/test.c tests/test_cpp.cc; do \\\n+\t\tsed s/GC_/_GC_/g < $$file > tmp; \\\n+\t\tcp tmp $$file; \\\n+\t\tdone\n+\n+user_namespace: $(SRCS)\n+\tfor file in $(SRCS) tests/test.c tests/test_cpp.cc; do \\\n+\t\tsed s/_GC_/GC_/g < $$file > tmp; \\\n+\t\tcp tmp $$file; \\\n+\t\tdone"}, {"sha": "e1b5871708010cf0962a293681cd941b915125e3", "filename": "boehm-gc/config.guess", "status": "added", "additions": 1121, "deletions": 0, "changes": 1121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fconfig.guess", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fconfig.guess", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfig.guess?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,1121 @@\n+#! /bin/sh\n+# Attempt to guess a canonical system name.\n+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999\n+#   Free Software Foundation, Inc.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+#\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+# Written by Per Bothner <bothner@cygnus.com>.\n+# The master version of this file is at the FSF in /home/gd/gnu/lib.\n+# Please send patches to <autoconf-patches@gnu.org>.\n+#\n+# This script attempts to guess a canonical system name similar to\n+# config.sub.  If it succeeds, it prints the system name on stdout, and\n+# exits with 0.  Otherwise, it exits with 1.\n+#\n+# The plan is that this can be called by configure scripts if you\n+# don't specify an explicit system type (host/target name).\n+#\n+# Only a few systems have been added to this list; please add others\n+# (but try to keep the structure clean).\n+#\n+\n+# Use $HOST_CC if defined. $CC may point to a cross-compiler\n+if test x\"$CC_FOR_BUILD\" = x; then\n+  if test x\"$HOST_CC\" != x; then\n+    CC_FOR_BUILD=\"$HOST_CC\"\n+  else\n+    if test x\"$CC\" != x; then\n+      CC_FOR_BUILD=\"$CC\"\n+    else\n+      CC_FOR_BUILD=cc\n+    fi\n+  fi\n+fi\n+\n+\n+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.\n+# (ghazi@noc.rutgers.edu 8/24/94.)\n+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then\n+\tPATH=$PATH:/.attbin ; export PATH\n+fi\n+\n+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown\n+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown\n+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown\n+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown\n+\n+dummy=dummy-$$\n+trap 'rm -f $dummy.c $dummy.o $dummy; exit 1' 1 2 15\n+\n+# Note: order is significant - the case branches are not exclusive.\n+\n+case \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" in\n+    alpha:OSF1:*:*)\n+\tif test $UNAME_RELEASE = \"V4.0\"; then\n+\t\tUNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`\n+\tfi\n+\t# A Vn.n version is a released version.\n+\t# A Tn.n version is a released field test version.\n+\t# A Xn.n version is an unreleased experimental baselevel.\n+\t# 1.2 uses \"1.2\" for uname -r.\n+\tcat <<EOF >$dummy.s\n+\t.globl main\n+\t.ent main\n+main:\n+\t.frame \\$30,0,\\$26,0\n+\t.prologue 0\n+\t.long 0x47e03d80 # implver $0\n+\tlda \\$2,259\n+\t.long 0x47e20c21 # amask $2,$1\n+\tsrl \\$1,8,\\$2\n+\tsll \\$2,2,\\$2\n+\tsll \\$0,3,\\$0\n+\taddl \\$1,\\$0,\\$0\n+\taddl \\$2,\\$0,\\$0\n+\tret \\$31,(\\$26),1\n+\t.end main\n+EOF\n+\t$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null\n+\tif test \"$?\" = 0 ; then\n+\t\t./$dummy\n+\t\tcase \"$?\" in\n+\t\t\t7)\n+\t\t\t\tUNAME_MACHINE=\"alpha\"\n+\t\t\t\t;;\n+\t\t\t15)\n+\t\t\t\tUNAME_MACHINE=\"alphaev5\"\n+\t\t\t\t;;\n+\t\t\t14)\n+\t\t\t\tUNAME_MACHINE=\"alphaev56\"\n+\t\t\t\t;;\n+\t\t\t10)\n+\t\t\t\tUNAME_MACHINE=\"alphapca56\"\n+\t\t\t\t;;\n+\t\t\t16)\n+\t\t\t\tUNAME_MACHINE=\"alphaev6\"\n+\t\t\t\t;;\n+\t\tesac\n+\tfi\n+\trm -f $dummy.s $dummy\n+\techo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n+\texit 0 ;;\n+    Alpha\\ *:Windows_NT*:*)\n+\t# How do we know it's Interix rather than the generic POSIX subsystem?\n+\t# Should we change UNAME_MACHINE based on the output of uname instead\n+\t# of the specific Alpha model?\n+\techo alpha-pc-interix\n+\texit 0 ;;\n+    21064:Windows_NT:50:3)\n+\techo alpha-dec-winnt3.5\n+\texit 0 ;;\n+    Amiga*:UNIX_System_V:4.0:*)\n+\techo m68k-cbm-sysv4\n+\texit 0;;\n+    amiga:NetBSD:*:*)\n+      echo m68k-cbm-netbsd${UNAME_RELEASE}\n+      exit 0 ;;\n+    amiga:OpenBSD:*:*)\n+\techo m68k-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    *:[Aa]miga[Oo][Ss]:*:*)\n+\techo ${UNAME_MACHINE}-unknown-amigaos\n+\texit 0 ;;\n+    arc64:OpenBSD:*:*)\n+\techo mips64el-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    arc:OpenBSD:*:*)\n+\techo mipsel-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    hkmips:OpenBSD:*:*)\n+\techo mips-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    pmax:OpenBSD:*:*)\n+\techo mipsel-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    sgi:OpenBSD:*:*)\n+\techo mips-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    wgrisc:OpenBSD:*:*)\n+\techo mipsel-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    *:OS/390:*:*)\n+\techo i370-ibm-openedition\n+\texit 0 ;;\n+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)\n+\techo arm-acorn-riscix${UNAME_RELEASE}\n+\texit 0;;\n+    arm32:NetBSD:*:*)\n+\techo arm-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\\./'`\n+\texit 0 ;;\n+    SR2?01:HI-UX/MPP:*:*)\n+\techo hppa1.1-hitachi-hiuxmpp\n+\texit 0;;\n+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)\n+\t# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.\n+\tif test \"`(/bin/universe) 2>/dev/null`\" = att ; then\n+\t\techo pyramid-pyramid-sysv3\n+\telse\n+\t\techo pyramid-pyramid-bsd\n+\tfi\n+\texit 0 ;;\n+    NILE*:*:*:dcosx)\n+\techo pyramid-pyramid-svr4\n+\texit 0 ;;\n+    sun4H:SunOS:5.*:*)\n+\techo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit 0 ;;\n+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)\n+\techo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit 0 ;;\n+    i86pc:SunOS:5.*:*)\n+\techo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit 0 ;;\n+    sun4*:SunOS:6*:*)\n+\t# According to config.sub, this is the proper way to canonicalize\n+\t# SunOS6.  Hard to guess exactly what SunOS6 will be like, but\n+\t# it's likely to be more like Solaris than SunOS4.\n+\techo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit 0 ;;\n+    sun4*:SunOS:*:*)\n+\tcase \"`/usr/bin/arch -k`\" in\n+\t    Series*|S4*)\n+\t\tUNAME_RELEASE=`uname -v`\n+\t\t;;\n+\tesac\n+\t# Japanese Language versions have a version number like `4.1.3-JL'.\n+\techo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`\n+\texit 0 ;;\n+    sun3*:SunOS:*:*)\n+\techo m68k-sun-sunos${UNAME_RELEASE}\n+\texit 0 ;;\n+    sun*:*:4.2BSD:*)\n+\tUNAME_RELEASE=`(head -1 /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`\n+\ttest \"x${UNAME_RELEASE}\" = \"x\" && UNAME_RELEASE=3\n+\tcase \"`/bin/arch`\" in\n+\t    sun3)\n+\t\techo m68k-sun-sunos${UNAME_RELEASE}\n+\t\t;;\n+\t    sun4)\n+\t\techo sparc-sun-sunos${UNAME_RELEASE}\n+\t\t;;\n+\tesac\n+\texit 0 ;;\n+    aushp:SunOS:*:*)\n+\techo sparc-auspex-sunos${UNAME_RELEASE}\n+\texit 0 ;;\n+    atari*:NetBSD:*:*)\n+\techo m68k-atari-netbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    atari*:OpenBSD:*:*)\n+\techo m68k-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    # The situation for MiNT is a little confusing.  The machine name\n+    # can be virtually everything (everything which is not\n+    # \"atarist\" or \"atariste\" at least should have a processor \n+    # > m68000).  The system name ranges from \"MiNT\" over \"FreeMiNT\"\n+    # to the lowercase version \"mint\" (or \"freemint\").  Finally\n+    # the system name \"TOS\" denotes a system which is actually not\n+    # MiNT.  But MiNT is downward compatible to TOS, so this should\n+    # be no problem.\n+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)\n+        echo m68k-atari-mint${UNAME_RELEASE}\n+\texit 0 ;;\n+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)\n+\techo m68k-atari-mint${UNAME_RELEASE}\n+        exit 0 ;;\n+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)\n+        echo m68k-atari-mint${UNAME_RELEASE}\n+\texit 0 ;;\n+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)\n+        echo m68k-milan-mint${UNAME_RELEASE}\n+        exit 0 ;;\n+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)\n+        echo m68k-hades-mint${UNAME_RELEASE}\n+        exit 0 ;;\n+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)\n+        echo m68k-unknown-mint${UNAME_RELEASE}\n+        exit 0 ;;\n+    sun3*:NetBSD:*:*)\n+\techo m68k-sun-netbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    sun3*:OpenBSD:*:*)\n+\techo m68k-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    mac68k:NetBSD:*:*)\n+\techo m68k-apple-netbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    mac68k:OpenBSD:*:*)\n+\techo m68k-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    mvme68k:OpenBSD:*:*)\n+\techo m68k-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    mvme88k:OpenBSD:*:*)\n+\techo m88k-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    powerpc:machten:*:*)\n+\techo powerpc-apple-machten${UNAME_RELEASE}\n+\texit 0 ;;\n+    macppc:NetBSD:*:*)\n+        echo powerpc-apple-netbsd${UNAME_RELEASE}\n+        exit 0 ;;\n+    RISC*:Mach:*:*)\n+\techo mips-dec-mach_bsd4.3\n+\texit 0 ;;\n+    RISC*:ULTRIX:*:*)\n+\techo mips-dec-ultrix${UNAME_RELEASE}\n+\texit 0 ;;\n+    VAX*:ULTRIX*:*:*)\n+\techo vax-dec-ultrix${UNAME_RELEASE}\n+\texit 0 ;;\n+    2020:CLIX:*:* | 2430:CLIX:*:*)\n+\techo clipper-intergraph-clix${UNAME_RELEASE}\n+\texit 0 ;;\n+    mips:*:*:UMIPS | mips:*:*:RISCos)\n+\tsed 's/^\t//' << EOF >$dummy.c\n+#ifdef __cplusplus\n+\tint main (int argc, char *argv[]) {\n+#else\n+\tint main (argc, argv) int argc; char *argv[]; {\n+#endif\n+\t#if defined (host_mips) && defined (MIPSEB)\n+\t#if defined (SYSTYPE_SYSV)\n+\t  printf (\"mips-mips-riscos%ssysv\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#if defined (SYSTYPE_SVR4)\n+\t  printf (\"mips-mips-riscos%ssvr4\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)\n+\t  printf (\"mips-mips-riscos%sbsd\\n\", argv[1]); exit (0);\n+\t#endif\n+\t#endif\n+\t  exit (-1);\n+\t}\n+EOF\n+\t$CC_FOR_BUILD $dummy.c -o $dummy \\\n+\t  && ./$dummy `echo \"${UNAME_RELEASE}\" | sed -n 's/\\([0-9]*\\).*/\\1/p'` \\\n+\t  && rm $dummy.c $dummy && exit 0\n+\trm -f $dummy.c $dummy\n+\techo mips-mips-riscos${UNAME_RELEASE}\n+\texit 0 ;;\n+    Night_Hawk:Power_UNIX:*:*)\n+\techo powerpc-harris-powerunix\n+\texit 0 ;;\n+    m88k:CX/UX:7*:*)\n+\techo m88k-harris-cxux7\n+\texit 0 ;;\n+    m88k:*:4*:R4*)\n+\techo m88k-motorola-sysv4\n+\texit 0 ;;\n+    m88k:*:3*:R3*)\n+\techo m88k-motorola-sysv3\n+\texit 0 ;;\n+    AViiON:dgux:*:*)\n+        # DG/UX returns AViiON for all architectures\n+        UNAME_PROCESSOR=`/usr/bin/uname -p`\n+\tif [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110]\n+\tthen\n+\t    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \\\n+\t       [ ${TARGET_BINARY_INTERFACE}x = x ]\n+\t    then\n+\t\techo m88k-dg-dgux${UNAME_RELEASE}\n+\t    else\n+\t\techo m88k-dg-dguxbcs${UNAME_RELEASE}\n+\t    fi\n+\telse\n+\t    echo i586-dg-dgux${UNAME_RELEASE}\n+\tfi\n+ \texit 0 ;;\n+    M88*:DolphinOS:*:*)\t# DolphinOS (SVR3)\n+\techo m88k-dolphin-sysv3\n+\texit 0 ;;\n+    M88*:*:R3*:*)\n+\t# Delta 88k system running SVR3\n+\techo m88k-motorola-sysv3\n+\texit 0 ;;\n+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)\n+\techo m88k-tektronix-sysv3\n+\texit 0 ;;\n+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)\n+\techo m68k-tektronix-bsd\n+\texit 0 ;;\n+    *:IRIX*:*:*)\n+\techo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`\n+\texit 0 ;;\n+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.\n+\techo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id\n+\texit 0 ;;              # Note that: echo \"'`uname -s`'\" gives 'AIX '\n+    i?86:AIX:*:*)\n+\techo i386-ibm-aix\n+\texit 0 ;;\n+    *:AIX:2:3)\n+\tif grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then\n+\t\tsed 's/^\t\t//' << EOF >$dummy.c\n+\t\t#include <sys/systemcfg.h>\n+\n+\t\tmain()\n+\t\t\t{\n+\t\t\tif (!__power_pc())\n+\t\t\t\texit(1);\n+\t\t\tputs(\"powerpc-ibm-aix3.2.5\");\n+\t\t\texit(0);\n+\t\t\t}\n+EOF\n+\t\t$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm $dummy.c $dummy && exit 0\n+\t\trm -f $dummy.c $dummy\n+\t\techo rs6000-ibm-aix3.2.5\n+\telif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then\n+\t\techo rs6000-ibm-aix3.2.4\n+\telse\n+\t\techo rs6000-ibm-aix3.2\n+\tfi\n+\texit 0 ;;\n+    *:AIX:*:4)\n+\tIBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -1 | awk '{ print $1 }'`\n+\tif /usr/sbin/lsattr -EHl ${IBM_CPU_ID} | grep POWER >/dev/null 2>&1; then\n+\t\tIBM_ARCH=rs6000\n+\telse\n+\t\tIBM_ARCH=powerpc\n+\tfi\n+\tif [ -x /usr/bin/oslevel ] ; then\n+\t\tIBM_REV=`/usr/bin/oslevel`\n+\telse\n+\t\tIBM_REV=4.${UNAME_RELEASE}\n+\tfi\n+\techo ${IBM_ARCH}-ibm-aix${IBM_REV}\n+\texit 0 ;;\n+    *:AIX:*:*)\n+\techo rs6000-ibm-aix\n+\texit 0 ;;\n+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)\n+\techo romp-ibm-bsd4.4\n+\texit 0 ;;\n+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and\n+\techo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to\n+\texit 0 ;;                           # report: romp-ibm BSD 4.3\n+    *:BOSX:*:*)\n+\techo rs6000-bull-bosx\n+\texit 0 ;;\n+    DPX/2?00:B.O.S.:*:*)\n+\techo m68k-bull-sysv3\n+\texit 0 ;;\n+    9000/[34]??:4.3bsd:1.*:*)\n+\techo m68k-hp-bsd\n+\texit 0 ;;\n+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)\n+\techo m68k-hp-bsd4.4\n+\texit 0 ;;\n+    9000/[34678]??:HP-UX:*:*)\n+\tcase \"${UNAME_MACHINE}\" in\n+\t    9000/31? )            HP_ARCH=m68000 ;;\n+\t    9000/[34]?? )         HP_ARCH=m68k ;;\n+\t    9000/[678][0-9][0-9])\n+              sed 's/^              //' << EOF >$dummy.c\n+              #include <stdlib.h>\n+              #include <unistd.h>\n+\n+              int main ()\n+              {\n+              #if defined(_SC_KERNEL_BITS)\n+                  long bits = sysconf(_SC_KERNEL_BITS);\n+              #endif\n+                  long cpu  = sysconf (_SC_CPU_VERSION);\n+\n+                  switch (cpu)\n+              \t{\n+              \tcase CPU_PA_RISC1_0: puts (\"hppa1.0\"); break;\n+              \tcase CPU_PA_RISC1_1: puts (\"hppa1.1\"); break;\n+              \tcase CPU_PA_RISC2_0:\n+              #if defined(_SC_KERNEL_BITS)\n+              \t    switch (bits)\n+              \t\t{\n+              \t\tcase 64: puts (\"hppa2.0w\"); break;\n+              \t\tcase 32: puts (\"hppa2.0n\"); break;\n+              \t\tdefault: puts (\"hppa2.0\"); break;\n+              \t\t} break;\n+              #else  /* !defined(_SC_KERNEL_BITS) */\n+              \t    puts (\"hppa2.0\"); break;\n+              #endif\n+              \tdefault: puts (\"hppa1.0\"); break;\n+              \t}\n+                  exit (0);\n+              }\n+EOF\n+\t(CCOPTS= $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null ) && HP_ARCH=`./$dummy`\n+\trm -f $dummy.c $dummy\n+\tesac\n+\tHPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`\n+\techo ${HP_ARCH}-hp-hpux${HPUX_REV}\n+\texit 0 ;;\n+    3050*:HI-UX:*:*)\n+\tsed 's/^\t//' << EOF >$dummy.c\n+\t#include <unistd.h>\n+\tint\n+\tmain ()\n+\t{\n+\t  long cpu = sysconf (_SC_CPU_VERSION);\n+\t  /* The order matters, because CPU_IS_HP_MC68K erroneously returns\n+\t     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct\n+\t     results, however.  */\n+\t  if (CPU_IS_PA_RISC (cpu))\n+\t    {\n+\t      switch (cpu)\n+\t\t{\n+\t\t  case CPU_PA_RISC1_0: puts (\"hppa1.0-hitachi-hiuxwe2\"); break;\n+\t\t  case CPU_PA_RISC1_1: puts (\"hppa1.1-hitachi-hiuxwe2\"); break;\n+\t\t  case CPU_PA_RISC2_0: puts (\"hppa2.0-hitachi-hiuxwe2\"); break;\n+\t\t  default: puts (\"hppa-hitachi-hiuxwe2\"); break;\n+\t\t}\n+\t    }\n+\t  else if (CPU_IS_HP_MC68K (cpu))\n+\t    puts (\"m68k-hitachi-hiuxwe2\");\n+\t  else puts (\"unknown-hitachi-hiuxwe2\");\n+\t  exit (0);\n+\t}\n+EOF\n+\t$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm $dummy.c $dummy && exit 0\n+\trm -f $dummy.c $dummy\n+\techo unknown-hitachi-hiuxwe2\n+\texit 0 ;;\n+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )\n+\techo hppa1.1-hp-bsd\n+\texit 0 ;;\n+    9000/8??:4.3bsd:*:*)\n+\techo hppa1.0-hp-bsd\n+\texit 0 ;;\n+    *9??*:MPE/iX:*:*)\n+\techo hppa1.0-hp-mpeix\n+\texit 0 ;;\n+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )\n+\techo hppa1.1-hp-osf\n+\texit 0 ;;\n+    hp8??:OSF1:*:*)\n+\techo hppa1.0-hp-osf\n+\texit 0 ;;\n+    i?86:OSF1:*:*)\n+\tif [ -x /usr/sbin/sysversion ] ; then\n+\t    echo ${UNAME_MACHINE}-unknown-osf1mk\n+\telse\n+\t    echo ${UNAME_MACHINE}-unknown-osf1\n+\tfi\n+\texit 0 ;;\n+    parisc*:Lites*:*:*)\n+\techo hppa1.1-hp-lites\n+\texit 0 ;;\n+    hppa*:OpenBSD:*:*)\n+\techo hppa-unknown-openbsd\n+\texit 0 ;;\n+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)\n+\techo c1-convex-bsd\n+        exit 0 ;;\n+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)\n+\tif getsysinfo -f scalar_acc\n+\tthen echo c32-convex-bsd\n+\telse echo c2-convex-bsd\n+\tfi\n+        exit 0 ;;\n+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)\n+\techo c34-convex-bsd\n+        exit 0 ;;\n+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)\n+\techo c38-convex-bsd\n+        exit 0 ;;\n+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)\n+\techo c4-convex-bsd\n+        exit 0 ;;\n+    CRAY*X-MP:*:*:*)\n+\techo xmp-cray-unicos\n+        exit 0 ;;\n+    CRAY*Y-MP:*:*:*)\n+\techo ymp-cray-unicos${UNAME_RELEASE}\n+\texit 0 ;;\n+    CRAY*[A-Z]90:*:*:*)\n+\techo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \\\n+\t| sed -e 's/CRAY.*\\([A-Z]90\\)/\\1/' \\\n+\t      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/\n+\texit 0 ;;\n+    CRAY*TS:*:*:*)\n+\techo t90-cray-unicos${UNAME_RELEASE}\n+\texit 0 ;;\n+    CRAY*T3E:*:*:*)\n+\techo alpha-cray-unicosmk${UNAME_RELEASE}\n+\texit 0 ;;\n+    CRAY-2:*:*:*)\n+\techo cray2-cray-unicos\n+        exit 0 ;;\n+    F300:UNIX_System_V:*:*)\n+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\\///'`\n+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`\n+        echo \"f300-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}\"\n+        exit 0 ;;\n+    F301:UNIX_System_V:*:*)\n+       echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`\n+       exit 0 ;;\n+    hp3[0-9][05]:NetBSD:*:*)\n+\techo m68k-hp-netbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    hp300:OpenBSD:*:*)\n+\techo m68k-unknown-openbsd${UNAME_RELEASE}\n+\texit 0 ;;\n+    i?86:BSD/386:*:* | i?86:BSD/OS:*:*)\n+\techo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}\n+\texit 0 ;;\n+    sparc*:BSD/OS:*:*)\n+\techo sparc-unknown-bsdi${UNAME_RELEASE}\n+\texit 0 ;;\n+    *:BSD/OS:*:*)\n+\techo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}\n+\texit 0 ;;\n+    *:FreeBSD:*:*)\n+\tif test -x /usr/bin/objformat; then\n+\t    if test \"elf\" = \"`/usr/bin/objformat`\"; then\n+\t\techo ${UNAME_MACHINE}-unknown-freebsdelf`echo ${UNAME_RELEASE}|sed -e 's/[-_].*//'`\n+\t\texit 0\n+\t    fi\n+\tfi\n+\techo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`\n+\texit 0 ;;\n+    *:NetBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*//'`\n+\texit 0 ;;\n+    *:OpenBSD:*:*)\n+\techo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\\./'`\n+\texit 0 ;;\n+    i*:CYGWIN*:*)\n+\techo ${UNAME_MACHINE}-pc-cygwin\n+\texit 0 ;;\n+    i*:MINGW*:*)\n+\techo ${UNAME_MACHINE}-pc-mingw32\n+\texit 0 ;;\n+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)\n+\t# How do we know it's Interix rather than the generic POSIX subsystem?\n+\t# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we\n+\t# UNAME_MACHINE based on the output of uname instead of i386?\n+\techo i386-pc-interix\n+\texit 0 ;;\n+    i*:UWIN*:*)\n+\techo ${UNAME_MACHINE}-pc-uwin\n+\texit 0 ;;\n+    p*:CYGWIN*:*)\n+\techo powerpcle-unknown-cygwin\n+\texit 0 ;;\n+    prep*:SunOS:5.*:*)\n+\techo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`\n+\texit 0 ;;\n+    *:GNU:*:*)\n+\techo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`\n+\texit 0 ;;\n+    *:Linux:*:*)\n+\n+\t# The BFD linker knows what the default object file format is, so\n+\t# first see if it will tell us. cd to the root directory to prevent\n+\t# problems with other programs or directories called `ld' in the path.\n+\tld_help_string=`cd /; ld --help 2>&1`\n+\tld_supported_emulations=`echo $ld_help_string \\\n+\t\t\t | sed -ne '/supported emulations:/!d\n+\t\t\t\t    s/[ \t][ \t]*/ /g\n+\t\t\t\t    s/.*supported emulations: *//\n+\t\t\t\t    s/ .*//\n+\t\t\t\t    p'`\n+        case \"$ld_supported_emulations\" in\n+\t  *ia64)\n+\t\techo \"${UNAME_MACHINE}-unknown-linux\"\n+\t\texit 0\n+\t\t;;\n+\t  i?86linux)\n+\t\techo \"${UNAME_MACHINE}-pc-linux-gnuaout\"\n+\t\texit 0\n+\t\t;;\n+\t  i?86coff)\n+\t\techo \"${UNAME_MACHINE}-pc-linux-gnucoff\"\n+\t\texit 0\n+\t\t;;\n+\t  sparclinux)\n+\t\techo \"${UNAME_MACHINE}-unknown-linux-gnuaout\"\n+\t\texit 0\n+\t\t;;\n+\t  armlinux)\n+\t\techo \"${UNAME_MACHINE}-unknown-linux-gnuaout\"\n+\t\texit 0\n+\t\t;;\n+\t  elf32arm*)\n+\t\techo \"${UNAME_MACHINE}-unknown-linux-gnu\"\n+\t\texit 0\n+\t\t;;\n+\t  armelf_linux*)\n+\t\techo \"${UNAME_MACHINE}-unknown-linux-gnu\"\n+\t\texit 0\n+\t\t;;\n+\t  m68klinux)\n+\t\techo \"${UNAME_MACHINE}-unknown-linux-gnuaout\"\n+\t\texit 0\n+\t\t;;\n+\t  elf32ppc)\n+\t\t# Determine Lib Version\n+\t\tcat >$dummy.c <<EOF\n+#include <features.h>\n+#if defined(__GLIBC__)\n+extern char __libc_version[];\n+extern char __libc_release[];\n+#endif\n+main(argc, argv)\n+     int argc;\n+     char *argv[];\n+{\n+#if defined(__GLIBC__)\n+  printf(\"%s %s\\n\", __libc_version, __libc_release);\n+#else\n+  printf(\"unkown\\n\");\n+#endif\n+  return 0;\n+}\n+EOF\n+\t\tLIBC=\"\"\n+\t\t$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null\n+\t\tif test \"$?\" = 0 ; then\n+\t\t\t./$dummy | grep 1\\.99 > /dev/null\n+\t\t\tif test \"$?\" = 0 ; then\n+\t\t\t\tLIBC=\"libc1\"\n+\t\t\tfi\n+\t\tfi\t\n+\t\trm -f $dummy.c $dummy\n+\t\techo powerpc-unknown-linux-gnu${LIBC}\n+\t\texit 0\n+\t\t;;\n+\tesac\n+\n+\tif test \"${UNAME_MACHINE}\" = \"alpha\" ; then\n+\t\tsed 's/^\t//'  <<EOF >$dummy.s\n+\t\t.globl main\n+\t\t.ent main\n+\tmain:\n+\t\t.frame \\$30,0,\\$26,0\n+\t\t.prologue 0\n+\t\t.long 0x47e03d80 # implver $0\n+\t\tlda \\$2,259\n+\t\t.long 0x47e20c21 # amask $2,$1\n+\t\tsrl \\$1,8,\\$2\n+\t\tsll \\$2,2,\\$2\n+\t\tsll \\$0,3,\\$0\n+\t\taddl \\$1,\\$0,\\$0\n+\t\taddl \\$2,\\$0,\\$0\n+\t\tret \\$31,(\\$26),1\n+\t\t.end main\n+EOF\n+\t\tLIBC=\"\"\n+\t\t$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null\n+\t\tif test \"$?\" = 0 ; then\n+\t\t\t./$dummy\n+\t\t\tcase \"$?\" in\n+\t\t\t7)\n+\t\t\t\tUNAME_MACHINE=\"alpha\"\n+\t\t\t\t;;\n+\t\t\t15)\n+\t\t\t\tUNAME_MACHINE=\"alphaev5\"\n+\t\t\t\t;;\n+\t\t\t14)\n+\t\t\t\tUNAME_MACHINE=\"alphaev56\"\n+\t\t\t\t;;\n+\t\t\t10)\n+\t\t\t\tUNAME_MACHINE=\"alphapca56\"\n+\t\t\t\t;;\n+\t\t\t16)\n+\t\t\t\tUNAME_MACHINE=\"alphaev6\"\n+\t\t\t\t;;\n+\t\t\tesac\n+\n+\t\t\tobjdump --private-headers $dummy | \\\n+\t\t\t  grep ld.so.1 > /dev/null\n+\t\t\tif test \"$?\" = 0 ; then\n+\t\t\t\tLIBC=\"libc1\"\n+\t\t\tfi\n+\t\tfi\n+\t\trm -f $dummy.s $dummy\n+\t\techo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC} ; exit 0\n+\telif test \"${UNAME_MACHINE}\" = \"mips\" ; then\n+\t  cat >$dummy.c <<EOF\n+#ifdef __cplusplus\n+\tint main (int argc, char *argv[]) {\n+#else\n+\tint main (argc, argv) int argc; char *argv[]; {\n+#endif\n+#ifdef __MIPSEB__\n+  printf (\"%s-unknown-linux-gnu\\n\", argv[1]);\n+#endif\n+#ifdef __MIPSEL__\n+  printf (\"%sel-unknown-linux-gnu\\n\", argv[1]);\n+#endif\n+  return 0;\n+}\n+EOF\n+\t  $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy \"${UNAME_MACHINE}\" && rm $dummy.c $dummy && exit 0\n+\t  rm -f $dummy.c $dummy\n+\telse\n+\t  # Either a pre-BFD a.out linker (linux-gnuoldld)\n+\t  # or one that does not give us useful --help.\n+\t  # GCC wants to distinguish between linux-gnuoldld and linux-gnuaout.\n+\t  # If ld does not provide *any* \"supported emulations:\"\n+\t  # that means it is gnuoldld.\n+\t  echo \"$ld_help_string\" | grep >/dev/null 2>&1 \"supported emulations:\"\n+\t  test $? != 0 && echo \"${UNAME_MACHINE}-pc-linux-gnuoldld\" && exit 0\n+\n+\t  case \"${UNAME_MACHINE}\" in\n+\t  i?86)\n+\t    VENDOR=pc;\n+\t    ;;\n+\t  *)\n+\t    VENDOR=unknown;\n+\t    ;;\n+\t  esac\n+\t  # Determine whether the default compiler is a.out or elf\n+\t  cat >$dummy.c <<EOF\n+#include <features.h>\n+#ifdef __cplusplus\n+\tint main (int argc, char *argv[]) {\n+#else\n+\tint main (argc, argv) int argc; char *argv[]; {\n+#endif\n+#ifdef __ELF__\n+# ifdef __GLIBC__\n+#  if __GLIBC__ >= 2\n+    printf (\"%s-${VENDOR}-linux-gnu\\n\", argv[1]);\n+#  else\n+    printf (\"%s-${VENDOR}-linux-gnulibc1\\n\", argv[1]);\n+#  endif\n+# else\n+   printf (\"%s-${VENDOR}-linux-gnulibc1\\n\", argv[1]);\n+# endif\n+#else\n+  printf (\"%s-${VENDOR}-linux-gnuaout\\n\", argv[1]);\n+#endif\n+  return 0;\n+}\n+EOF\n+\t  $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy \"${UNAME_MACHINE}\" && rm $dummy.c $dummy && exit 0\n+\t  rm -f $dummy.c $dummy\n+\tfi ;;\n+# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions\n+# are messed up and put the nodename in both sysname and nodename.\n+    i?86:DYNIX/ptx:4*:*)\n+\techo i386-sequent-sysv4\n+\texit 0 ;;\n+    i?86:UNIX_SV:4.2MP:2.*)\n+        # Unixware is an offshoot of SVR4, but it has its own version\n+        # number series starting with 2...\n+        # I am not positive that other SVR4 systems won't match this,\n+\t# I just have to hope.  -- rms.\n+        # Use sysv4.2uw... so that sysv4* matches it.\n+\techo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}\n+\texit 0 ;;\n+    i?86:*:4.*:* | i?86:SYSTEM_V:4.*:*)\n+\tUNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\\/MP$//'`\n+\tif grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then\n+\t\techo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}\n+\telse\n+\t\techo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}\n+\tfi\n+\texit 0 ;;\n+    i?86:*:5:7*)\n+        # Fixed at (any) Pentium or better\n+        UNAME_MACHINE=i586\n+        if [ ${UNAME_SYSTEM} = \"UnixWare\" ] ; then\n+\t    echo ${UNAME_MACHINE}-sco-sysv${UNAME_RELEASE}uw${UNAME_VERSION}\n+\telse\n+\t    echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}\n+\tfi\n+\texit 0 ;;\n+    i?86:*:3.2:*)\n+\tif test -f /usr/options/cb.name; then\n+\t\tUNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`\n+\t\techo ${UNAME_MACHINE}-pc-isc$UNAME_REL\n+\telif /bin/uname -X 2>/dev/null >/dev/null ; then\n+\t\tUNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`\n+\t\t(/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486\n+\t\t(/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i586\n+\t\t(/bin/uname -X|egrep '^Machine.*Pent ?II' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i686\n+\t\t(/bin/uname -X|egrep '^Machine.*Pentium Pro' >/dev/null) \\\n+\t\t\t&& UNAME_MACHINE=i686\n+\t\techo ${UNAME_MACHINE}-pc-sco$UNAME_REL\n+\telse\n+\t\techo ${UNAME_MACHINE}-pc-sysv32\n+\tfi\n+\texit 0 ;;\n+    pc:*:*:*)\n+        # uname -m prints for DJGPP always 'pc', but it prints nothing about\n+        # the processor, so we play safe by assuming i386.\n+\techo i386-pc-msdosdjgpp\n+        exit 0 ;;\n+    Intel:Mach:3*:*)\n+\techo i386-pc-mach3\n+\texit 0 ;;\n+    paragon:*:*:*)\n+\techo i860-intel-osf1\n+\texit 0 ;;\n+    i860:*:4.*:*) # i860-SVR4\n+\tif grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then\n+\t  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4\n+\telse # Add other i860-SVR4 vendors below as they are discovered.\n+\t  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4\n+\tfi\n+\texit 0 ;;\n+    mini*:CTIX:SYS*5:*)\n+\t# \"miniframe\"\n+\techo m68010-convergent-sysv\n+\texit 0 ;;\n+    M68*:*:R3V[567]*:*)\n+\ttest -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;\n+    3[34]??:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)\n+\tOS_REL=''\n+\ttest -r /etc/.relid \\\n+\t&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \\([0-9][0-9]\\).*/\\1/p' < /etc/.relid`\n+\t/bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+\t  && echo i486-ncr-sysv4.3${OS_REL} && exit 0\n+\t/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \\\n+\t  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;\n+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)\n+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \\\n+          && echo i486-ncr-sysv4 && exit 0 ;;\n+    m68*:LynxOS:2.*:*)\n+\techo m68k-unknown-lynxos${UNAME_RELEASE}\n+\texit 0 ;;\n+    mc68030:UNIX_System_V:4.*:*)\n+\techo m68k-atari-sysv4\n+\texit 0 ;;\n+    i?86:LynxOS:2.*:* | i?86:LynxOS:3.[01]*:*)\n+\techo i386-unknown-lynxos${UNAME_RELEASE}\n+\texit 0 ;;\n+    TSUNAMI:LynxOS:2.*:*)\n+\techo sparc-unknown-lynxos${UNAME_RELEASE}\n+\texit 0 ;;\n+    rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)\n+\techo rs6000-unknown-lynxos${UNAME_RELEASE}\n+\texit 0 ;;\n+    SM[BE]S:UNIX_SV:*:*)\n+\techo mips-dde-sysv${UNAME_RELEASE}\n+\texit 0 ;;\n+    RM*:ReliantUNIX-*:*:*)\n+\techo mips-sni-sysv4\n+\texit 0 ;;\n+    RM*:SINIX-*:*:*)\n+\techo mips-sni-sysv4\n+\texit 0 ;;\n+    *:SINIX-*:*:*)\n+\tif uname -p 2>/dev/null >/dev/null ; then\n+\t\tUNAME_MACHINE=`(uname -p) 2>/dev/null`\n+\t\techo ${UNAME_MACHINE}-sni-sysv4\n+\telse\n+\t\techo ns32k-sni-sysv\n+\tfi\n+\texit 0 ;;\n+    PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort\n+                           # says <Richard.M.Bartel@ccMail.Census.GOV>\n+        echo i586-unisys-sysv4\n+        exit 0 ;;\n+    *:UNIX_System_V:4*:FTX*)\n+\t# From Gerald Hewes <hewes@openmarket.com>.\n+\t# How about differentiating between stratus architectures? -djm\n+\techo hppa1.1-stratus-sysv4\n+\texit 0 ;;\n+    *:*:*:FTX*)\n+\t# From seanf@swdc.stratus.com.\n+\techo i860-stratus-sysv4\n+\texit 0 ;;\n+    mc68*:A/UX:*:*)\n+\techo m68k-apple-aux${UNAME_RELEASE}\n+\texit 0 ;;\n+    news*:NEWS-OS:*:6*)\n+\techo mips-sony-newsos6\n+\texit 0 ;;\n+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)\n+\tif [ -d /usr/nec ]; then\n+\t        echo mips-nec-sysv${UNAME_RELEASE}\n+\telse\n+\t        echo mips-unknown-sysv${UNAME_RELEASE}\n+\tfi\n+        exit 0 ;;\n+    BeBox:BeOS:*:*)\t# BeOS running on hardware made by Be, PPC only.\n+\techo powerpc-be-beos\n+\texit 0 ;;\n+    BeMac:BeOS:*:*)\t# BeOS running on Mac or Mac clone, PPC only.\n+\techo powerpc-apple-beos\n+\texit 0 ;;\n+    BePC:BeOS:*:*)\t# BeOS running on Intel PC compatible.\n+\techo i586-pc-beos\n+\texit 0 ;;\n+    SX-4:SUPER-UX:*:*)\n+\techo sx4-nec-superux${UNAME_RELEASE}\n+\texit 0 ;;\n+    SX-5:SUPER-UX:*:*)\n+\techo sx5-nec-superux${UNAME_RELEASE}\n+\texit 0 ;;\n+    Power*:Rhapsody:*:*)\n+\techo powerpc-apple-rhapsody${UNAME_RELEASE}\n+\texit 0 ;;\n+    *:Rhapsody:*:*)\n+\techo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}\n+\texit 0 ;;\n+    *:QNX:*:4*)\n+\techo i386-qnx-qnx${UNAME_VERSION}\n+\texit 0 ;;\n+esac\n+\n+#echo '(No uname command or uname output not recognized.)' 1>&2\n+#echo \"${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}\" 1>&2\n+\n+cat >$dummy.c <<EOF\n+#ifdef _SEQUENT_\n+# include <sys/types.h>\n+# include <sys/utsname.h>\n+#endif\n+main ()\n+{\n+#if defined (sony)\n+#if defined (MIPSEB)\n+  /* BFD wants \"bsd\" instead of \"newsos\".  Perhaps BFD should be changed,\n+     I don't know....  */\n+  printf (\"mips-sony-bsd\\n\"); exit (0);\n+#else\n+#include <sys/param.h>\n+  printf (\"m68k-sony-newsos%s\\n\",\n+#ifdef NEWSOS4\n+          \"4\"\n+#else\n+\t  \"\"\n+#endif\n+         ); exit (0);\n+#endif\n+#endif\n+\n+#if defined (__arm) && defined (__acorn) && defined (__unix)\n+  printf (\"arm-acorn-riscix\"); exit (0);\n+#endif\n+\n+#if defined (hp300) && !defined (hpux)\n+  printf (\"m68k-hp-bsd\\n\"); exit (0);\n+#endif\n+\n+#if defined (NeXT)\n+#if !defined (__ARCHITECTURE__)\n+#define __ARCHITECTURE__ \"m68k\"\n+#endif\n+  int version;\n+  version=`(hostinfo | sed -n 's/.*NeXT Mach \\([0-9]*\\).*/\\1/p') 2>/dev/null`;\n+  if (version < 4)\n+    printf (\"%s-next-nextstep%d\\n\", __ARCHITECTURE__, version);\n+  else\n+    printf (\"%s-next-openstep%d\\n\", __ARCHITECTURE__, version);\n+  exit (0);\n+#endif\n+\n+#if defined (MULTIMAX) || defined (n16)\n+#if defined (UMAXV)\n+  printf (\"ns32k-encore-sysv\\n\"); exit (0);\n+#else\n+#if defined (CMU)\n+  printf (\"ns32k-encore-mach\\n\"); exit (0);\n+#else\n+  printf (\"ns32k-encore-bsd\\n\"); exit (0);\n+#endif\n+#endif\n+#endif\n+\n+#if defined (__386BSD__)\n+  printf (\"i386-pc-bsd\\n\"); exit (0);\n+#endif\n+\n+#if defined (sequent)\n+#if defined (i386)\n+  printf (\"i386-sequent-dynix\\n\"); exit (0);\n+#endif\n+#if defined (ns32000)\n+  printf (\"ns32k-sequent-dynix\\n\"); exit (0);\n+#endif\n+#endif\n+\n+#if defined (_SEQUENT_)\n+    struct utsname un;\n+\n+    uname(&un);\n+\n+    if (strncmp(un.version, \"V2\", 2) == 0) {\n+\tprintf (\"i386-sequent-ptx2\\n\"); exit (0);\n+    }\n+    if (strncmp(un.version, \"V1\", 2) == 0) { /* XXX is V1 correct? */\n+\tprintf (\"i386-sequent-ptx1\\n\"); exit (0);\n+    }\n+    printf (\"i386-sequent-ptx\\n\"); exit (0);\n+\n+#endif\n+\n+#if defined (vax)\n+#if !defined (ultrix)\n+  printf (\"vax-dec-bsd\\n\"); exit (0);\n+#else\n+  printf (\"vax-dec-ultrix\\n\"); exit (0);\n+#endif\n+#endif\n+\n+#if defined (alliant) && defined (i860)\n+  printf (\"i860-alliant-bsd\\n\"); exit (0);\n+#endif\n+\n+  exit (1);\n+}\n+EOF\n+\n+$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm $dummy.c $dummy && exit 0\n+rm -f $dummy.c $dummy\n+\n+# Apollos put the system type in the environment.\n+\n+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }\n+\n+# Convex versions that predate uname can use getsysinfo(1)\n+\n+if [ -x /usr/convex/getsysinfo ]\n+then\n+    case `getsysinfo -f cpu_type` in\n+    c1*)\n+\techo c1-convex-bsd\n+\texit 0 ;;\n+    c2*)\n+\tif getsysinfo -f scalar_acc\n+\tthen echo c32-convex-bsd\n+\telse echo c2-convex-bsd\n+\tfi\n+\texit 0 ;;\n+    c34*)\n+\techo c34-convex-bsd\n+\texit 0 ;;\n+    c38*)\n+\techo c38-convex-bsd\n+\texit 0 ;;\n+    c4*)\n+\techo c4-convex-bsd\n+\texit 0 ;;\n+    esac\n+fi\n+\n+#echo '(Unable to guess system type)' 1>&2\n+\n+exit 1"}, {"sha": "28426bb8fa0abac1f35de4b4b587faeff310a936", "filename": "boehm-gc/config.sub", "status": "added", "additions": 1232, "deletions": 0, "changes": 1232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fconfig.sub", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fconfig.sub", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfig.sub?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,1232 @@\n+#! /bin/sh\n+# Configuration validation subroutine script, version 1.1.\n+#   Copyright (C) 1991, 92-97, 1998, 1999 Free Software Foundation, Inc.\n+# This file is (in principle) common to ALL GNU software.\n+# The presence of a machine in this file suggests that SOME GNU software\n+# can handle that machine.  It does not imply ALL GNU software can.\n+#\n+# This file is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+# Configuration subroutine to validate and canonicalize a configuration type.\n+# Supply the specified configuration type as an argument.\n+# If it is invalid, we print an error message on stderr and exit with code 1.\n+# Otherwise, we print the canonical config type on stdout and succeed.\n+\n+# This file is supposed to be the same for all GNU packages\n+# and recognize all the CPU types, system types and aliases\n+# that are meaningful with *any* GNU software.\n+# Each package is responsible for reporting which valid configurations\n+# it does not support.  The user should be able to distinguish\n+# a failure to support a valid configuration from a meaningless\n+# configuration.\n+\n+# The goal of this file is to map all the various variations of a given\n+# machine specification into a single specification in the form:\n+#\tCPU_TYPE-MANUFACTURER-OPERATING_SYSTEM\n+# or in some cases, the newer four-part form:\n+#\tCPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM\n+# It is wrong to echo any other type of specification.\n+\n+if [ x$1 = x ]\n+then\n+\techo Configuration name missing. 1>&2\n+\techo \"Usage: $0 CPU-MFR-OPSYS\" 1>&2\n+\techo \"or     $0 ALIAS\" 1>&2\n+\techo where ALIAS is a recognized configuration type. 1>&2\n+\texit 1\n+fi\n+\n+# First pass through any local machine types.\n+case $1 in\n+\t*local*)\n+\t\techo $1\n+\t\texit 0\n+\t\t;;\n+\t*)\n+\t;;\n+esac\n+\n+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).\n+# Here we must recognize all the valid KERNEL-OS combinations.\n+maybe_os=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\2/'`\n+case $maybe_os in\n+  linux-gnu*)\n+    os=-$maybe_os\n+    basic_machine=`echo $1 | sed 's/^\\(.*\\)-\\([^-]*-[^-]*\\)$/\\1/'`\n+    ;;\n+  *)\n+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`\n+    if [ $basic_machine != $1 ]\n+    then os=`echo $1 | sed 's/.*-/-/'`\n+    else os=; fi\n+    ;;\n+esac\n+\n+### Let's recognize common machines as not being operating systems so\n+### that things like config.sub decstation-3100 work.  We also\n+### recognize some manufacturers as not being operating systems, so we\n+### can provide default operating systems below.\n+case $os in\n+\t-sun*os*)\n+\t\t# Prevent following clause from handling this invalid input.\n+\t\t;;\n+\t-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \\\n+\t-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \\\n+\t-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \\\n+\t-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\\\n+\t-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \\\n+\t-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \\\n+\t-apple)\n+\t\tos=\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-sim | -cisco | -oki | -wec | -winbond)\n+\t\tos=\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-scout)\n+\t\t;;\n+\t-wrs)\n+\t\tos=-vxworks\n+\t\tbasic_machine=$1\n+\t\t;;\n+\t-hiux*)\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\t-sco5)\n+\t\tos=-sco3.2v5\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco4)\n+\t\tos=-sco3.2v4\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco3.2.[4-9]*)\n+\t\tos=`echo $os | sed -e 's/sco3.2./sco3.2v/'`\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco3.2v[4-9]*)\n+\t\t# Don't forget version if it is 3.2v4 or newer.\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-sco*)\n+\t\tos=-sco3.2v2\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-udk*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-isc)\n+\t\tos=-isc2.2\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-clix*)\n+\t\tbasic_machine=clipper-intergraph\n+\t\t;;\n+\t-isc*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`\n+\t\t;;\n+\t-lynx*)\n+\t\tos=-lynxos\n+\t\t;;\n+\t-ptx*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`\n+\t\t;;\n+\t-windowsnt*)\n+\t\tos=`echo $os | sed -e 's/windowsnt/winnt/'`\n+\t\t;;\n+\t-psos*)\n+\t\tos=-psos\n+\t\t;;\n+\t-mint | -mint[0-9]*)\n+\t\tbasic_machine=m68k-atari\n+\t\tos=-mint\n+\t\t;;\n+esac\n+\n+# Decode aliases for certain CPU-COMPANY combinations.\n+case $basic_machine in\n+\t# Recognize the basic CPU types without company name.\n+\t# Some are omitted here because they have special meanings below.\n+\ttahoe | i860 | ia64 | m32r | m68k | m68000 | m88k | ns32k | arc | arm \\\n+\t\t| arme[lb] | pyramid | mn10200 | mn10300 | tron | a29k \\\n+\t\t| 580 | i960 | h8300 \\\n+\t\t| hppa | hppa1.0 | hppa1.1 | hppa2.0 | hppa2.0w | hppa2.0n \\\n+\t\t| alpha | alphaev[4-7] | alphaev56 | alphapca5[67] \\\n+\t\t| we32k | ns16k | clipper | i370 | sh | powerpc | powerpcle \\\n+\t\t| 1750a | dsp16xx | pdp11 | mips16 | mips64 | mipsel | mips64el \\\n+\t\t| mips64orion | mips64orionel | mipstx39 | mipstx39el \\\n+\t\t| mips64vr4300 | mips64vr4300el | mips64vr4100 | mips64vr4100el \\\n+\t\t| mips64vr5000 | miprs64vr5000el | mcore \\\n+\t\t| sparc | sparclet | sparclite | sparc64 | sparcv9 | v850 | c4x \\\n+\t\t| thumb | d10v | fr30)\n+\t\tbasic_machine=$basic_machine-unknown\n+\t\t;;\n+\tm88110 | m680[12346]0 | m683?2 | m68360 | m5200 | z8k | v70 | h8500 | w65 | pj | pjl)\n+\t\t;;\n+\n+\t# We use `pc' rather than `unknown'\n+\t# because (1) that's what they normally are, and\n+\t# (2) the word \"unknown\" tends to confuse beginning users.\n+\ti[34567]86)\n+\t  basic_machine=$basic_machine-pc\n+\t  ;;\n+\t# Object if more than one company name word.\n+\t*-*-*)\n+\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+\t# Recognize the basic CPU types with company name.\n+\t# FIXME: clean up the formatting here.\n+\tvax-* | tahoe-* | i[34567]86-* | i860-* | ia64-* | m32r-* | m68k-* | m68000-* \\\n+\t      | m88k-* | sparc-* | ns32k-* | fx80-* | arc-* | arm-* | c[123]* \\\n+\t      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \\\n+\t      | power-* | none-* | 580-* | cray2-* | h8300-* | h8500-* | i960-* \\\n+\t      | xmp-* | ymp-* \\\n+\t      | hppa-* | hppa1.0-* | hppa1.1-* | hppa2.0-* | hppa2.0w-* | hppa2.0n-* \\\n+\t      | alpha-* | alphaev[4-7]-* | alphaev56-* | alphapca5[67]-* \\\n+\t      | we32k-* | cydra-* | ns16k-* | pn-* | np1-* | xps100-* \\\n+\t      | clipper-* | orion-* \\\n+\t      | sparclite-* | pdp11-* | sh-* | powerpc-* | powerpcle-* \\\n+\t      | sparc64-* | sparcv9-* | sparc86x-* | mips16-* | mips64-* | mipsel-* \\\n+\t      | mips64el-* | mips64orion-* | mips64orionel-* \\\n+\t      | mips64vr4100-* | mips64vr4100el-* | mips64vr4300-* | mips64vr4300el-* \\\n+\t      | mipstx39-* | mipstx39el-* | mcore-* \\\n+\t      | f301-* | armv*-* | t3e-* \\\n+\t      | m88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | d10v-* \\\n+\t      | thumb-* | v850-* | d30v-* | tic30-* | c30-* | fr30-* )\n+\t\t;;\n+\t# Recognize the various machine names and aliases which stand\n+\t# for a CPU type and a company and sometimes even an OS.\n+\t386bsd)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-bsd\n+\t\t;;\n+\t3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)\n+\t\tbasic_machine=m68000-att\n+\t\t;;\n+\t3b*)\n+\t\tbasic_machine=we32k-att\n+\t\t;;\n+\ta29khif)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tadobe68k)\n+\t\tbasic_machine=m68010-adobe\n+\t\tos=-scout\n+\t\t;;\n+\talliant | fx80)\n+\t\tbasic_machine=fx80-alliant\n+\t\t;;\n+\taltos | altos3068)\n+\t\tbasic_machine=m68k-altos\n+\t\t;;\n+\tam29k)\n+\t\tbasic_machine=a29k-none\n+\t\tos=-bsd\n+\t\t;;\n+\tamdahl)\n+\t\tbasic_machine=580-amdahl\n+\t\tos=-sysv\n+\t\t;;\n+\tamiga | amiga-*)\n+\t\tbasic_machine=m68k-cbm\n+\t\t;;\n+\tamigaos | amigados)\n+\t\tbasic_machine=m68k-cbm\n+\t\tos=-amigaos\n+\t\t;;\n+\tamigaunix | amix)\n+\t\tbasic_machine=m68k-cbm\n+\t\tos=-sysv4\n+\t\t;;\n+\tapollo68)\n+\t\tbasic_machine=m68k-apollo\n+\t\tos=-sysv\n+\t\t;;\n+\tapollo68bsd)\n+\t\tbasic_machine=m68k-apollo\n+\t\tos=-bsd\n+\t\t;;\n+\taux)\n+\t\tbasic_machine=m68k-apple\n+\t\tos=-aux\n+\t\t;;\n+\tbalance)\n+\t\tbasic_machine=ns32k-sequent\n+\t\tos=-dynix\n+\t\t;;\n+\tconvex-c1)\n+\t\tbasic_machine=c1-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c2)\n+\t\tbasic_machine=c2-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c32)\n+\t\tbasic_machine=c32-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c34)\n+\t\tbasic_machine=c34-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tconvex-c38)\n+\t\tbasic_machine=c38-convex\n+\t\tos=-bsd\n+\t\t;;\n+\tcray | ymp)\n+\t\tbasic_machine=ymp-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tcray2)\n+\t\tbasic_machine=cray2-cray\n+\t\tos=-unicos\n+\t\t;;\n+\t[ctj]90-cray)\n+\t\tbasic_machine=c90-cray\n+\t\tos=-unicos\n+\t\t;;\n+\tcrds | unos)\n+\t\tbasic_machine=m68k-crds\n+\t\t;;\n+\tda30 | da30-*)\n+\t\tbasic_machine=m68k-da30\n+\t\t;;\n+\tdecstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)\n+\t\tbasic_machine=mips-dec\n+\t\t;;\n+\tdelta | 3300 | motorola-3300 | motorola-delta \\\n+\t      | 3300-motorola | delta-motorola)\n+\t\tbasic_machine=m68k-motorola\n+\t\t;;\n+\tdelta88)\n+\t\tbasic_machine=m88k-motorola\n+\t\tos=-sysv3\n+\t\t;;\n+\tdpx20 | dpx20-*)\n+\t\tbasic_machine=rs6000-bull\n+\t\tos=-bosx\n+\t\t;;\n+\tdpx2* | dpx2*-bull)\n+\t\tbasic_machine=m68k-bull\n+\t\tos=-sysv3\n+\t\t;;\n+\tebmon29k)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-ebmon\n+\t\t;;\n+\telxsi)\n+\t\tbasic_machine=elxsi-elxsi\n+\t\tos=-bsd\n+\t\t;;\n+\tencore | umax | mmax)\n+\t\tbasic_machine=ns32k-encore\n+\t\t;;\n+\tes1800 | OSE68k | ose68k | ose | OSE)\n+\t\tbasic_machine=m68k-ericsson\n+\t\tos=-ose\n+\t\t;;\n+\tfx2800)\n+\t\tbasic_machine=i860-alliant\n+\t\t;;\n+\tgenix)\n+\t\tbasic_machine=ns32k-ns\n+\t\t;;\n+\tgmicro)\n+\t\tbasic_machine=tron-gmicro\n+\t\tos=-sysv\n+\t\t;;\n+\th3050r* | hiux*)\n+\t\tbasic_machine=hppa1.1-hitachi\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\th8300hms)\n+\t\tbasic_machine=h8300-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\th8300xray)\n+\t\tbasic_machine=h8300-hitachi\n+\t\tos=-xray\n+\t\t;;\n+\th8500hms)\n+\t\tbasic_machine=h8500-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\tharris)\n+\t\tbasic_machine=m88k-harris\n+\t\tos=-sysv3\n+\t\t;;\n+\thp300-*)\n+\t\tbasic_machine=m68k-hp\n+\t\t;;\n+\thp300bsd)\n+\t\tbasic_machine=m68k-hp\n+\t\tos=-bsd\n+\t\t;;\n+\thp300hpux)\n+\t\tbasic_machine=m68k-hp\n+\t\tos=-hpux\n+\t\t;;\n+\thp3k9[0-9][0-9] | hp9[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thp9k2[0-9][0-9] | hp9k31[0-9])\n+\t\tbasic_machine=m68000-hp\n+\t\t;;\n+\thp9k3[2-9][0-9])\n+\t\tbasic_machine=m68k-hp\n+\t\t;;\n+\thp9k6[0-9][0-9] | hp6[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thp9k7[0-79][0-9] | hp7[0-79][0-9])\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k78[0-9] | hp78[0-9])\n+\t\t# FIXME: really hppa2.0-hp\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)\n+\t\t# FIXME: really hppa2.0-hp\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[0-9][13679] | hp8[0-9][13679])\n+\t\tbasic_machine=hppa1.1-hp\n+\t\t;;\n+\thp9k8[0-9][0-9] | hp8[0-9][0-9])\n+\t\tbasic_machine=hppa1.0-hp\n+\t\t;;\n+\thppa-next)\n+\t\tos=-nextstep3\n+\t\t;;\n+\thppaosf)\n+\t\tbasic_machine=hppa1.1-hp\n+\t\tos=-osf\n+\t\t;;\n+\thppro)\n+\t\tbasic_machine=hppa1.1-hp\n+\t\tos=-proelf\n+\t\t;;\n+\ti370-ibm* | ibm*)\n+\t\tbasic_machine=i370-ibm\n+\t\t;;\n+# I'm not sure what \"Sysv32\" means.  Should this be sysv3.2?\n+\ti[34567]86v32)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv32\n+\t\t;;\n+\ti[34567]86v4*)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv4\n+\t\t;;\n+\ti[34567]86v)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-sysv\n+\t\t;;\n+\ti[34567]86sol2)\n+\t\tbasic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`\n+\t\tos=-solaris2\n+\t\t;;\n+\ti386mach)\n+\t\tbasic_machine=i386-mach\n+\t\tos=-mach\n+\t\t;;\n+\ti386-vsta | vsta)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-vsta\n+\t\t;;\n+\ti386-go32 | go32)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-go32\n+\t\t;;\n+\ti386-mingw32 | mingw32)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-mingw32\n+\t\t;;\n+\ti386-qnx | qnx)\n+\t\tbasic_machine=i386-qnx\n+\t\t;;\n+\tiris | iris4d)\n+\t\tbasic_machine=mips-sgi\n+\t\tcase $os in\n+\t\t    -irix*)\n+\t\t\t;;\n+\t\t    *)\n+\t\t\tos=-irix4\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\tisi68 | isi)\n+\t\tbasic_machine=m68k-isi\n+\t\tos=-sysv\n+\t\t;;\n+\tm88k-omron*)\n+\t\tbasic_machine=m88k-omron\n+\t\t;;\n+\tmagnum | m3230)\n+\t\tbasic_machine=mips-mips\n+\t\tos=-sysv\n+\t\t;;\n+\tmerlin)\n+\t\tbasic_machine=ns32k-utek\n+\t\tos=-sysv\n+\t\t;;\n+\tminiframe)\n+\t\tbasic_machine=m68000-convergent\n+\t\t;;\n+\t*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)\n+\t\tbasic_machine=m68k-atari\n+\t\tos=-mint\n+\t\t;;\n+\tmipsel*-linux*)\n+\t\tbasic_machine=mipsel-unknown\n+\t\tos=-linux-gnu\n+\t\t;;\n+\tmips*-linux*)\n+\t\tbasic_machine=mips-unknown\n+\t\tos=-linux-gnu\n+\t\t;;\n+\tmips3*-*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`\n+\t\t;;\n+\tmips3*)\n+\t\tbasic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown\n+\t\t;;\n+\tmonitor)\n+\t\tbasic_machine=m68k-rom68k\n+\t\tos=-coff\n+\t\t;;\n+\tmsdos)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-msdos\n+\t\t;;\n+\tmvs)\n+\t\tbasic_machine=i370-ibm\n+\t\tos=-mvs\n+\t\t;;\n+\tncr3000)\n+\t\tbasic_machine=i486-ncr\n+\t\tos=-sysv4\n+\t\t;;\n+\tnetbsd386)\n+\t\tbasic_machine=i386-unknown\n+\t\tos=-netbsd\n+\t\t;;\n+\tnetwinder)\n+\t\tbasic_machine=armv4l-rebel\n+\t\tos=-linux\n+\t\t;;\n+\tnews | news700 | news800 | news900)\n+\t\tbasic_machine=m68k-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnews1000)\n+\t\tbasic_machine=m68030-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnews-3600 | risc-news)\n+\t\tbasic_machine=mips-sony\n+\t\tos=-newsos\n+\t\t;;\n+\tnecv70)\n+\t\tbasic_machine=v70-nec\n+\t\tos=-sysv\n+\t\t;;\n+\tnext | m*-next )\n+\t\tbasic_machine=m68k-next\n+\t\tcase $os in\n+\t\t    -nextstep* )\n+\t\t\t;;\n+\t\t    -ns2*)\n+\t\t      os=-nextstep2\n+\t\t\t;;\n+\t\t    *)\n+\t\t      os=-nextstep3\n+\t\t\t;;\n+\t\tesac\n+\t\t;;\n+\tnh3000)\n+\t\tbasic_machine=m68k-harris\n+\t\tos=-cxux\n+\t\t;;\n+\tnh[45]000)\n+\t\tbasic_machine=m88k-harris\n+\t\tos=-cxux\n+\t\t;;\n+\tnindy960)\n+\t\tbasic_machine=i960-intel\n+\t\tos=-nindy\n+\t\t;;\n+\tmon960)\n+\t\tbasic_machine=i960-intel\n+\t\tos=-mon960\n+\t\t;;\n+\tnp1)\n+\t\tbasic_machine=np1-gould\n+\t\t;;\n+\top50n-* | op60c-*)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\tos=-proelf\n+\t\t;;\n+\tOSE68000 | ose68000)\n+\t\tbasic_machine=m68000-ericsson\n+\t\tos=-ose\n+\t\t;;\n+\tos68k)\n+\t\tbasic_machine=m68k-none\n+\t\tos=-os68k\n+\t\t;;\n+\tpa-hitachi)\n+\t\tbasic_machine=hppa1.1-hitachi\n+\t\tos=-hiuxwe2\n+\t\t;;\n+\tparagon)\n+\t\tbasic_machine=i860-intel\n+\t\tos=-osf\n+\t\t;;\n+\tpbd)\n+\t\tbasic_machine=sparc-tti\n+\t\t;;\n+\tpbb)\n+\t\tbasic_machine=m68k-tti\n+\t\t;;\n+        pc532 | pc532-*)\n+\t\tbasic_machine=ns32k-pc532\n+\t\t;;\n+\tpentium | p5 | k5 | k6 | nexen)\n+\t\tbasic_machine=i586-pc\n+\t\t;;\n+\tpentiumpro | p6 | 6x86)\n+\t\tbasic_machine=i686-pc\n+\t\t;;\n+\tpentiumii | pentium2)\n+\t\tbasic_machine=i786-pc\n+\t\t;;\n+\tpentium-* | p5-* | k5-* | k6-* | nexen-*)\n+\t\tbasic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentiumpro-* | p6-* | 6x86-*)\n+\t\tbasic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpentiumii-* | pentium2-*)\n+\t\tbasic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tpn)\n+\t\tbasic_machine=pn-gould\n+\t\t;;\n+\tpower)\tbasic_machine=rs6000-ibm\n+\t\t;;\n+\tppc)\tbasic_machine=powerpc-unknown\n+\t        ;;\n+\tppc-*)\tbasic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tppcle | powerpclittle | ppc-le | powerpc-little)\n+\t\tbasic_machine=powerpcle-unknown\n+\t        ;;\n+\tppcle-* | powerpclittle-*)\n+\t\tbasic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`\n+\t\t;;\n+\tps2)\n+\t\tbasic_machine=i386-ibm\n+\t\t;;\n+\trom68k)\n+\t\tbasic_machine=m68k-rom68k\n+\t\tos=-coff\n+\t\t;;\n+\trm[46]00)\n+\t\tbasic_machine=mips-siemens\n+\t\t;;\n+\trtpc | rtpc-*)\n+\t\tbasic_machine=romp-ibm\n+\t\t;;\n+\tsa29200)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tsequent)\n+\t\tbasic_machine=i386-sequent\n+\t\t;;\n+\tsh)\n+\t\tbasic_machine=sh-hitachi\n+\t\tos=-hms\n+\t\t;;\n+\tsparclite-wrs)\n+\t\tbasic_machine=sparclite-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tsps7)\n+\t\tbasic_machine=m68k-bull\n+\t\tos=-sysv2\n+\t\t;;\n+\tspur)\n+\t\tbasic_machine=spur-unknown\n+\t\t;;\n+\tst2000)\n+\t\tbasic_machine=m68k-tandem\n+\t\t;;\n+\tstratus)\n+\t\tbasic_machine=i860-stratus\n+\t\tos=-sysv4\n+\t\t;;\n+\tsun2)\n+\t\tbasic_machine=m68000-sun\n+\t\t;;\n+\tsun2os3)\n+\t\tbasic_machine=m68000-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun2os4)\n+\t\tbasic_machine=m68000-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun3os3)\n+\t\tbasic_machine=m68k-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun3os4)\n+\t\tbasic_machine=m68k-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun4os3)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-sunos3\n+\t\t;;\n+\tsun4os4)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-sunos4\n+\t\t;;\n+\tsun4sol2)\n+\t\tbasic_machine=sparc-sun\n+\t\tos=-solaris2\n+\t\t;;\n+\tsun3 | sun3-*)\n+\t\tbasic_machine=m68k-sun\n+\t\t;;\n+\tsun4)\n+\t\tbasic_machine=sparc-sun\n+\t\t;;\n+\tsun386 | sun386i | roadrunner)\n+\t\tbasic_machine=i386-sun\n+\t\t;;\n+\tsymmetry)\n+\t\tbasic_machine=i386-sequent\n+\t\tos=-dynix\n+\t\t;;\n+\tt3e)\n+\t\tbasic_machine=t3e-cray\n+\t\tos=-unicos\n+\t\t;;\n+\ttx39)\n+\t\tbasic_machine=mipstx39-unknown\n+\t\t;;\n+\ttx39el)\n+\t\tbasic_machine=mipstx39el-unknown\n+\t\t;;\n+\ttower | tower-32)\n+\t\tbasic_machine=m68k-ncr\n+\t\t;;\n+\tudi29k)\n+\t\tbasic_machine=a29k-amd\n+\t\tos=-udi\n+\t\t;;\n+\tultra3)\n+\t\tbasic_machine=a29k-nyu\n+\t\tos=-sym1\n+\t\t;;\n+\tv810 | necv810)\n+\t\tbasic_machine=v810-nec\n+\t\tos=-none\n+\t\t;;\n+\tvaxv)\n+\t\tbasic_machine=vax-dec\n+\t\tos=-sysv\n+\t\t;;\n+\tvms)\n+\t\tbasic_machine=vax-dec\n+\t\tos=-vms\n+\t\t;;\n+\tvpp*|vx|vx-*)\n+               basic_machine=f301-fujitsu\n+               ;;\n+\tvxworks960)\n+\t\tbasic_machine=i960-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tvxworks68)\n+\t\tbasic_machine=m68k-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tvxworks29k)\n+\t\tbasic_machine=a29k-wrs\n+\t\tos=-vxworks\n+\t\t;;\n+\tw65*)\n+\t\tbasic_machine=w65-wdc\n+\t\tos=-none\n+\t\t;;\n+\tw89k-*)\n+\t\tbasic_machine=hppa1.1-winbond\n+\t\tos=-proelf\n+\t\t;;\n+\txmp)\n+\t\tbasic_machine=xmp-cray\n+\t\tos=-unicos\n+\t\t;;\n+        xps | xps100)\n+\t\tbasic_machine=xps100-honeywell\n+\t\t;;\n+\tz8k-*-coff)\n+\t\tbasic_machine=z8k-unknown\n+\t\tos=-sim\n+\t\t;;\n+\tnone)\n+\t\tbasic_machine=none-none\n+\t\tos=-none\n+\t\t;;\n+\n+# Here we handle the default manufacturer of certain CPU types.  It is in\n+# some cases the only manufacturer, in others, it is the most popular.\n+\tw89k)\n+\t\tbasic_machine=hppa1.1-winbond\n+\t\t;;\n+\top50n)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\t;;\n+\top60c)\n+\t\tbasic_machine=hppa1.1-oki\n+\t\t;;\n+\tmips)\n+\t\tif [ x$os = x-linux-gnu ]; then\n+\t\t\tbasic_machine=mips-unknown\n+\t\telse\n+\t\t\tbasic_machine=mips-mips\n+\t\tfi\n+\t\t;;\n+\tromp)\n+\t\tbasic_machine=romp-ibm\n+\t\t;;\n+\trs6000)\n+\t\tbasic_machine=rs6000-ibm\n+\t\t;;\n+\tvax)\n+\t\tbasic_machine=vax-dec\n+\t\t;;\n+\tpdp11)\n+\t\tbasic_machine=pdp11-dec\n+\t\t;;\n+\twe32k)\n+\t\tbasic_machine=we32k-att\n+\t\t;;\n+\tsparc | sparcv9)\n+\t\tbasic_machine=sparc-sun\n+\t\t;;\n+        cydra)\n+\t\tbasic_machine=cydra-cydrome\n+\t\t;;\n+\torion)\n+\t\tbasic_machine=orion-highlevel\n+\t\t;;\n+\torion105)\n+\t\tbasic_machine=clipper-highlevel\n+\t\t;;\n+\tmac | mpw | mac-mpw)\n+\t\tbasic_machine=m68k-apple\n+\t\t;;\n+\tpmac | pmac-mpw)\n+\t\tbasic_machine=powerpc-apple\n+\t\t;;\n+\tc4x*)\n+\t\tbasic_machine=c4x-none\n+\t\tos=-coff\n+\t\t;;\n+\t*)\n+\t\techo Invalid configuration \\`$1\\': machine \\`$basic_machine\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+\n+# Here we canonicalize certain aliases for manufacturers.\n+case $basic_machine in\n+\t*-digital*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`\n+\t\t;;\n+\t*-commodore*)\n+\t\tbasic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`\n+\t\t;;\n+\t*)\n+\t\t;;\n+esac\n+\n+# Decode manufacturer-specific aliases for certain operating systems.\n+\n+if [ x\"$os\" != x\"\" ]\n+then\n+case $os in\n+        # First match some system type aliases\n+        # that might get confused with valid system types.\n+\t# -solaris* is a basic system type, with this one exception.\n+\t-solaris1 | -solaris1.*)\n+\t\tos=`echo $os | sed -e 's|solaris1|sunos4|'`\n+\t\t;;\n+\t-solaris)\n+\t\tos=-solaris2\n+\t\t;;\n+\t-svr4*)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-unixware*)\n+\t\tos=-sysv4.2uw\n+\t\t;;\n+\t-gnu/linux*)\n+\t\tos=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`\n+\t\t;;\n+\t# First accept the basic system types.\n+\t# The portable systems comes first.\n+\t# Each alternative MUST END IN A *, to match a version number.\n+\t# -sysv* is not here because it comes later, after sysvr4.\n+\t-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \\\n+\t      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\\\n+\t      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \\\n+\t      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \\\n+\t      | -aos* \\\n+\t      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \\\n+\t      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \\\n+\t      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \\\n+\t      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \\\n+\t      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \\\n+\t      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \\\n+\t      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \\\n+\t      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \\\n+\t      | -interix* | -uwin* | -rhapsody* | -opened* | -openstep* | -oskit*)\n+\t# Remember, each alternative MUST END IN *, to match a version number.\n+\t\t;;\n+\t-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \\\n+\t      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \\\n+\t      | -macos* | -mpw* | -magic* | -mon960* | -lnews*)\n+\t\t;;\n+\t-mac*)\n+\t\tos=`echo $os | sed -e 's|mac|macos|'`\n+\t\t;;\n+\t-linux*)\n+\t\tos=`echo $os | sed -e 's|linux|linux-gnu|'`\n+\t\t;;\n+\t-sunos5*)\n+\t\tos=`echo $os | sed -e 's|sunos5|solaris2|'`\n+\t\t;;\n+\t-sunos6*)\n+\t\tos=`echo $os | sed -e 's|sunos6|solaris3|'`\n+\t\t;;\n+\t-opened*)\n+\t\tos=-openedition\n+\t\t;;\n+\t-osfrose*)\n+\t\tos=-osfrose\n+\t\t;;\n+\t-osf*)\n+\t\tos=-osf\n+\t\t;;\n+\t-utek*)\n+\t\tos=-bsd\n+\t\t;;\n+\t-dynix*)\n+\t\tos=-bsd\n+\t\t;;\n+\t-acis*)\n+\t\tos=-aos\n+\t\t;;\n+\t-386bsd)\n+\t\tos=-bsd\n+\t\t;;\n+\t-ctix* | -uts*)\n+\t\tos=-sysv\n+\t\t;;\n+\t-ns2 )\n+\t        os=-nextstep2\n+\t\t;;\n+\t# Preserve the version number of sinix5.\n+\t-sinix5.*)\n+\t\tos=`echo $os | sed -e 's|sinix|sysv|'`\n+\t\t;;\n+\t-sinix*)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-triton*)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-oss*)\n+\t\tos=-sysv3\n+\t\t;;\n+        -qnx)\n+\t\tos=-qnx4\n+\t\t;;\n+\t-svr4)\n+\t\tos=-sysv4\n+\t\t;;\n+\t-svr3)\n+\t\tos=-sysv3\n+\t\t;;\n+\t-sysvr4)\n+\t\tos=-sysv4\n+\t\t;;\n+\t# This must come after -sysvr4.\n+\t-sysv*)\n+\t\t;;\n+\t-ose*)\n+\t\tos=-ose\n+\t\t;;\n+\t-es1800*)\n+\t\tos=-ose\n+\t\t;;\n+\t-xenix)\n+\t\tos=-xenix\n+\t\t;;\n+        -*mint | -*MiNT)\n+\t        os=-mint\n+\t\t;;\n+\t-none)\n+\t\t;;\n+\t*)\n+\t\t# Get rid of the `-' at the beginning of $os.\n+\t\tos=`echo $os | sed 's/[^-]*-//'`\n+\t\techo Invalid configuration \\`$1\\': system \\`$os\\' not recognized 1>&2\n+\t\texit 1\n+\t\t;;\n+esac\n+else\n+\n+# Here we handle the default operating systems that come with various machines.\n+# The value should be what the vendor currently ships out the door with their\n+# machine or put another way, the most popular os provided with the machine.\n+\n+# Note that if you're going to try to match \"-MANUFACTURER\" here (say,\n+# \"-sun\"), then you have to tell the case statement up towards the top\n+# that MANUFACTURER isn't an operating system.  Otherwise, code above\n+# will signal an error saying that MANUFACTURER isn't an operating\n+# system, and we'll never get to this point.\n+\n+case $basic_machine in\n+\t*-acorn)\n+\t\tos=-riscix1.2\n+\t\t;;\n+\tarm*-rebel)\n+\t\tos=-linux\n+\t\t;;\n+\tarm*-semi)\n+\t\tos=-aout\n+\t\t;;\n+        pdp11-*)\n+\t\tos=-none\n+\t\t;;\n+\t*-dec | vax-*)\n+\t\tos=-ultrix4.2\n+\t\t;;\n+\tm68*-apollo)\n+\t\tos=-domain\n+\t\t;;\n+\ti386-sun)\n+\t\tos=-sunos4.0.2\n+\t\t;;\n+\tm68000-sun)\n+\t\tos=-sunos3\n+\t\t# This also exists in the configure program, but was not the\n+\t\t# default.\n+\t\t# os=-sunos4\n+\t\t;;\n+\tm68*-cisco)\n+\t\tos=-aout\n+\t\t;;\n+\tmips*-cisco)\n+\t\tos=-elf\n+\t\t;;\n+\tmips*-*)\n+\t\tos=-elf\n+\t\t;;\n+\t*-tti)\t# must be before sparc entry or we get the wrong os.\n+\t\tos=-sysv3\n+\t\t;;\n+\tsparc-* | *-sun)\n+\t\tos=-sunos4.1.1\n+\t\t;;\n+\t*-be)\n+\t\tos=-beos\n+\t\t;;\n+\t*-ibm)\n+\t\tos=-aix\n+\t\t;;\n+\t*-wec)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-winbond)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-oki)\n+\t\tos=-proelf\n+\t\t;;\n+\t*-hp)\n+\t\tos=-hpux\n+\t\t;;\n+\t*-hitachi)\n+\t\tos=-hiux\n+\t\t;;\n+\ti860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)\n+\t\tos=-sysv\n+\t\t;;\n+\t*-cbm)\n+\t\tos=-amigaos\n+\t\t;;\n+\t*-dg)\n+\t\tos=-dgux\n+\t\t;;\n+\t*-dolphin)\n+\t\tos=-sysv3\n+\t\t;;\n+\tm68k-ccur)\n+\t\tos=-rtu\n+\t\t;;\n+\tm88k-omron*)\n+\t\tos=-luna\n+\t\t;;\n+\t*-next )\n+\t\tos=-nextstep\n+\t\t;;\n+\t*-sequent)\n+\t\tos=-ptx\n+\t\t;;\n+\t*-crds)\n+\t\tos=-unos\n+\t\t;;\n+\t*-ns)\n+\t\tos=-genix\n+\t\t;;\n+\ti370-*)\n+\t\tos=-mvs\n+\t\t;;\n+\t*-next)\n+\t\tos=-nextstep3\n+\t\t;;\n+        *-gould)\n+\t\tos=-sysv\n+\t\t;;\n+        *-highlevel)\n+\t\tos=-bsd\n+\t\t;;\n+\t*-encore)\n+\t\tos=-bsd\n+\t\t;;\n+        *-sgi)\n+\t\tos=-irix\n+\t\t;;\n+        *-siemens)\n+\t\tos=-sysv4\n+\t\t;;\n+\t*-masscomp)\n+\t\tos=-rtu\n+\t\t;;\n+\tf301-fujitsu)\n+\t\tos=-uxpv\n+\t\t;;\n+\t*-rom68k)\n+\t\tos=-coff\n+\t\t;;\n+\t*-*bug)\n+\t\tos=-coff\n+\t\t;;\n+\t*-apple)\n+\t\tos=-macos\n+\t\t;;\n+\t*-atari*)\n+\t\tos=-mint\n+\t\t;;\n+\t*)\n+\t\tos=-none\n+\t\t;;\n+esac\n+fi\n+\n+# Here we handle the case where we know the os, and the CPU type, but not the\n+# manufacturer.  We pick the logical manufacturer.\n+vendor=unknown\n+case $basic_machine in\n+\t*-unknown)\n+\t\tcase $os in\n+\t\t\t-riscix*)\n+\t\t\t\tvendor=acorn\n+\t\t\t\t;;\n+\t\t\t-sunos*)\n+\t\t\t\tvendor=sun\n+\t\t\t\t;;\n+\t\t\t-aix*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-beos*)\n+\t\t\t\tvendor=be\n+\t\t\t\t;;\n+\t\t\t-hpux*)\n+\t\t\t\tvendor=hp\n+\t\t\t\t;;\n+\t\t\t-mpeix*)\n+\t\t\t\tvendor=hp\n+\t\t\t\t;;\n+\t\t\t-hiux*)\n+\t\t\t\tvendor=hitachi\n+\t\t\t\t;;\n+\t\t\t-unos*)\n+\t\t\t\tvendor=crds\n+\t\t\t\t;;\n+\t\t\t-dgux*)\n+\t\t\t\tvendor=dg\n+\t\t\t\t;;\n+\t\t\t-luna*)\n+\t\t\t\tvendor=omron\n+\t\t\t\t;;\n+\t\t\t-genix*)\n+\t\t\t\tvendor=ns\n+\t\t\t\t;;\n+\t\t\t-mvs* | -opened*)\n+\t\t\t\tvendor=ibm\n+\t\t\t\t;;\n+\t\t\t-ptx*)\n+\t\t\t\tvendor=sequent\n+\t\t\t\t;;\n+\t\t\t-vxsim* | -vxworks*)\n+\t\t\t\tvendor=wrs\n+\t\t\t\t;;\n+\t\t\t-aux*)\n+\t\t\t\tvendor=apple\n+\t\t\t\t;;\n+\t\t\t-hms*)\n+\t\t\t\tvendor=hitachi\n+\t\t\t\t;;\n+\t\t\t-mpw* | -macos*)\n+\t\t\t\tvendor=apple\n+\t\t\t\t;;\n+\t\t\t-*mint | -*MiNT)\n+\t\t\t\tvendor=atari\n+\t\t\t\t;;\n+\t\tesac\n+\t\tbasic_machine=`echo $basic_machine | sed \"s/unknown/$vendor/\"`\n+\t\t;;\n+esac\n+\n+echo $basic_machine$os"}, {"sha": "9778feee97624ea5745e384fe7148259c6a52d27", "filename": "boehm-gc/digimars.mak", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdigimars.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdigimars.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdigimars.mak?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,90 @@\n+# Makefile to build Hans Boehm garbage collector using the Digital Mars\r\n+# compiler from www.digitalmars.com\r\n+# Written by Walter Bright\r\n+\r\n+\r\n+DEFINES=-DNDEBUG -DSILENT -DGC_BUILD -D_WINDOWS -DGC_DLL -DALL_INTERIOR_POINTERS -D__STDC__ -DWIN32_THREADS\r\n+CFLAGS=-Iinclude $(DEFINES) -wx -g\r\n+LFLAGS=/ma/implib/co\r\n+CC=sc\r\n+\r\n+.c.obj:\r\n+\t$(CC) -c $(CFLAGS) $*\r\n+\r\n+.cpp.obj:\r\n+\t$(CC) -c $(CFLAGS) -Aa $*\r\n+\r\n+OBJS=\t\\\r\n+\tallchblk.obj\\\r\n+\talloc.obj\\\r\n+\tblacklst.obj\\\r\n+\tchecksums.obj\\\r\n+\tdbg_mlc.obj\\\r\n+\tdyn_load.obj\\\r\n+\tfinalize.obj\\\r\n+\tgc_cpp.obj\\\r\n+\theaders.obj\\\r\n+\tmach_dep.obj\\\r\n+\tmalloc.obj\\\r\n+\tmallocx.obj\\\r\n+\tmark.obj\\\r\n+\tmark_rts.obj\\\r\n+\tmisc.obj\\\r\n+\tnew_hblk.obj\\\r\n+\tobj_map.obj\\\r\n+\tos_dep.obj\\\r\n+\tptr_chck.obj\\\r\n+\treclaim.obj\\\r\n+\tstubborn.obj\\\r\n+\ttypd_mlc.obj\\\r\n+\twin32_threads.obj\r\n+\r\n+targets: gc.dll gc.lib gctest.exe\r\n+\r\n+gc.dll: $(OBJS) gc.def digimars.mak\r\n+\tsc -ogc.dll $(OBJS) -L$(LFLAGS) gc.def \tkernel32.lib user32.lib\r\n+\r\n+gc.def: digimars.mak\r\n+\techo LIBRARY GC >gc.def\r\n+\techo DESCRIPTION \"Hans Boehm Garbage Collector\" >>gc.def\r\n+\techo EXETYPE NT\t>>gc.def\r\n+\techo EXPORTS >>gc.def\r\n+\techo GC_is_visible_print_proc >>gc.def\r\n+\techo GC_is_valid_displacement_print_proc >>gc.def\r\n+\r\n+clean:\r\n+\tdel gc.def\r\n+\tdel $(OBJS)\r\n+\r\n+\r\n+gctest.exe : gc.lib tests\\test.obj\r\n+\tsc -ogctest.exe tests\\test.obj gc.lib\r\n+\r\n+tests\\test.obj : tests\\test.c\r\n+\t$(CC) -c -g -DNDEBUG -DSILENT -DGC_BUILD -D_WINDOWS -DGC_DLL \\\r\n+\t-DALL_INTERIOR_POINTERS -DWIN32_THREADS \\\r\n+\t-Iinclude tests\\test.c -otests\\test.obj\r\n+\r\n+allchblk.obj: allchblk.c\r\n+alloc.obj: alloc.c\r\n+blacklst.obj: blacklst.c\r\n+checksums.obj: checksums.c\r\n+dbg_mlc.obj: dbg_mlc.c\r\n+dyn_load.obj: dyn_load.c\r\n+finalize.obj: finalize.c\r\n+gc_cpp.obj: gc_cpp.cpp\r\n+headers.obj: headers.c\r\n+mach_dep.obj: mach_dep.c\r\n+malloc.obj: malloc.c\r\n+mallocx.obj: mallocx.c\r\n+mark.obj: mark.c\r\n+mark_rts.obj: mark_rts.c\r\n+misc.obj: misc.c\r\n+new_hblk.obj: new_hblk.c\r\n+obj_map.obj: obj_map.c\r\n+os_dep.obj: os_dep.c\r\n+ptr_chck.obj: ptr_chck.c\r\n+reclaim.obj: reclaim.c\r\n+stubborn.obj: stubborn.c\r\n+typd_mlc.obj: typd_mlc.c\r\n+win32_threads.obj: win32_threads.c\r"}, {"sha": "53fcf5a50b3f8abb71468c521590e02036d75a59", "filename": "boehm-gc/doc/README.autoconf", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2FREADME.autoconf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2FREADME.autoconf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.autoconf?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,59 @@\n+As of GC6.0alpha8, we attempt to support GNU-style builds based on automake,\n+autoconf and libtool.  This is based almost entirely on Tom Tromey's work\n+with gcj.\n+\n+To build and install libraries use\n+\n+configure; make; make install\n+\n+The advantages of this process are:\n+\n+1) It should eventually do a better job of automatically determining the\n+right compiler to use, etc.  It probably already does in some cases.\n+\n+2) It tries to automatically set a good set of default GC parameters for\n+the platform (e.g. thread support).  It provides an easier way to configure\n+some of the others.\n+\n+3) It integrates better with other projects using a GNU-style build process.\n+\n+4) It builds both dynamic and static libraries.\n+\n+The known disadvantages are:\n+\n+1) The build scripts are much more complex and harder to debug (though largely\n+standard).  I don't understand them all, and there's probably lots of redundant\n+stuff.\n+\n+2) It probably doesn't work on all Un*x-like platforms yet.  It probably will\n+never work on the rest.\n+\n+3) The scripts are not yet complete.  Some of the standard GNU targets don't\n+yet work.  (Corrections/additions are very welcome.)\n+\n+The distribution should contain all files needed to run \"configure\" and \"make\",\n+as well as the sources needed to regenerate the derived files.  (If I missed\n+some, please let me know.)\n+\n+Note that the distribution comes with a \"Makefile\" which will be overwritten\n+by \"configure\" with one that is not at all equiavelent to the original.  The\n+distribution contains a copy of the original \"Makefile\" in \"Makefile.direct\". \n+\n+Important options to configure:\n+\n+  --prefix=PREFIX         install architecture-independent files in PREFIX\n+                          [/usr/local]\n+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX\n+                          [same as prefix]\n+  --enable-threads=TYPE   choose threading package\n+  --enable-parallel-mark  parallelize marking and free list construction\n+  --enable-full-debug\tinclude full support for pointer backtracing etc.\n+\n+Unless --prefix is set (or --exec-prefix or one of the more obscure options),\n+make install will install libgc.a and libgc.so in /usr/local/bin, which\n+would typically require the \"make install\" to be run as root.\n+\n+Most commonly --enable-threads=posix or will be needed.  --enable-parallel-mark\n+is recommended for multiprocessors if it is supported on the platform.\n+\n+"}, {"sha": "d9df8dd31a6e2460de77eb8bc96ad43272b3afaf", "filename": "boehm-gc/doc/README.macros", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2FREADME.macros", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2FREADME.macros", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.macros?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,78 @@\n+The collector uses a large amount of conditional compilation in order to\n+deal with platform dependencies.  This violates a number of known coding\n+standards.  On the other hand, it seems to be the only practical way to\n+support this many platforms without excessive code duplication. \n+\n+A few guidelines have mostly been followed in order to keep this manageable:\n+\n+1) #if and #ifdef directives are properly indented whenever easily possible.\n+All known C compilers allow whitespace between the \"#\" and the \"if\" to make\n+this possible.  ANSI C also allows white space before the \"#\", though we\n+avoid that.  It has the known disadvantages that it differs from the normal\n+GNU conventions, and that it makes patches larger than otherwise necessary.\n+In my opinion, it's still well worth it, for the same reason that we indent\n+ordinary \"if\" statements.\n+\n+2) Whenever possible, tests are performed on the macros defined in gcconfig.h\n+instead of directly testing patform-specific predefined macros.  This makes it\n+relatively easy to adapt to new compilers with a different set of predefined\n+macros.  Currently these macros generally identify platforms instead of\n+features.  In many cases, this is a mistake.\n+\n+3) The code currently avoids #elif, eventhough that would make it more\n+readable.  This was done since #elif would need to be understood by ALL\n+compilers used to build the collector, and that hasn't always been the case.\n+It makes sense to reconsider this decision at some point, since #elif has been\n+standardized at least since 1989.\n+\n+Many of the tested configuration macros are at least somewhat defined in\n+either include/private/gcconfig.h or in Makefile.direct.  Here is an attempt\n+at defining some of the remainder:  (Thanks to Walter Bright for suggesting\n+this.  This is a work in progress)\n+\n+MACRO\t\tEXPLANATION\n+-----\t\t-----------\n+\n+__DMC__\tAlways #define'd by the Digital Mars compiler. Expands\n+\t\tto the compiler version number in hex, i.e. 0x810 is\n+\t\tversion 8.1b0\n+\n+_ENABLE_ARRAYNEW\n+\t\t#define'd by the Digital Mars C++ compiler when\n+\t\toperator new[] and delete[] are separately\n+\t\toverloadable. Used in gc_cpp.h.\n+\n+_MSC_VER\tExpands to the Visual C++ compiler version.  Assumed to\n+\t\tnot be defined for other compilers (at least if they behave\n+\t\tappreciably differently).\n+\n+_DLL\t\tDefined by Visual C++ if dynamic libraries are being built\n+\t\tor used.  Used to test whether __declspec(dllimport) or\n+\t\t__declspec(dllexport) needs to be added to declarations\n+\t\tto support the case in which the collector is in a dll.\n+\n+GC_DLL\t\tUser-settable macro that forces the effect of _DLL.\n+\n+GC_NOT_DLL\tUser-settable macro that overrides _DLL, e.g. if dynamic\n+\t\tlibraries are used, but the collector is in a static library.\n+\n+__STDC__\tAssumed to be defined only by compilers that understand\n+\t\tprototypes and other C89 features.  Its value is generally\n+\t\tnot used, since we are fine with most nonconforming extensions.\n+\n+SUNOS5SIGS\tSolaris-like signal handling.  This is probably misnamed,\n+\t\tsince it really doesn't guarantee much more than Posix.\n+\t\tCurrently set only for Solaris2.X, HPUX, and DRSNX.  Should\n+\t\tprobably be set for some other platforms.\n+\n+PCR\t\tSet if the collector is being built as part of the Xerox\n+\t\tPortable Common Runtime.\n+\n+SRC_M3\t\tSet if the collector is being built as a replacement of the\n+\t\tone in the DEC/Compaq SRC Modula-3 runtime.  I suspect this\n+\t\twas last used around 1994, and no doubt broke a long time ago.\n+\t\tIt's there primarily incase someone wants to port to a similar\n+\t\tsystem.\n+\n+\n+"}, {"sha": "a186ff507a01807fa374917f000efe192e5df42d", "filename": "boehm-gc/doc/debugging.html", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2Fdebugging.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2Fdebugging.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fdebugging.html?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,289 @@\n+<HTML>\n+<HEAD>\n+<TITLE>Debugging Garbage Collector Related Problems</title>\n+</head>\n+<BODY>\n+<H1>Debugging Garbage Collector Related Problems</h1>\n+This page contains some hints on\n+debugging issues specific to\n+the Boehm-Demers-Weiser conservative garbage collector.\n+It applies both to debugging issues in client code that manifest themselves\n+as collector misbehavior, and to debugging the collector itself.\n+<P>\n+If you suspect a bug in the collector itself, it is strongly recommended\n+that you try the latest collector release, even if it is labelled as \"alpha\",\n+before proceeding.\n+<H2>Bus Errors and Segmentation Violations</h2>\n+<P>\n+If the fault occurred in GC_find_limit, or with incremental collection enabled,\n+this is probably normal.  The collector installs handlers to take care of\n+these.  You will not see these unless you are using a debugger.\n+Your debugger <I>should</i> allow you to continue.\n+It's often preferable to tell the debugger to ignore SIGBUS and SIGSEGV\n+(\"<TT>handle SIGSEGV SIGBUS nostop noprint</tt>\" in gdb,\n+\"<TT>ignore SIGSEGV SIGBUS</tt>\" in most versions of dbx)\n+and set a breakpoint in <TT>abort</tt>.\n+The collector will call abort if the signal had another cause,\n+and there was not other handler previously installed.\n+<P>\n+We recommend debugging without incremental collection if possible.\n+(This applies directly to UNIX systems.\n+Debugging with incremental collection under win32 is worse.  See README.win32.)\n+<P>\n+If the application generates an unhandled SIGSEGV or equivalent, it may\n+often be easiest to set the environment variable GC_LOOP_ON_ABORT.  On many\n+platforms, this will cause the collector to loop in a handler when the\n+SIGSEGV is encountered (or when the collector aborts for some other reason),\n+and a debugger can then be attached to the looping\n+process.  This sidesteps common operating system problems related\n+to incomplete core files for multithreaded applications, etc.\n+<H2>Other Signals</h2>\n+On most platforms, the multithreaded version of the collector needs one or\n+two other signals for internal use by the collector in stopping threads.\n+It is normally wise to tell the debugger to ignore these.  On Linux,\n+the collector currently uses SIGPWR and SIGXCPU by default.\n+<H2>Warning Messages About Needing to Allocate Blacklisted Blocks</h2>\n+The garbage collector generates warning messages of the form\n+<PRE>\n+Needed to allocate blacklisted block at 0x...\n+</pre>\n+when it needs to allocate a block at a location that it knows to be\n+referenced by a false pointer.  These false pointers can be either permanent\n+(<I>e.g.</i> a static integer variable that never changes) or temporary.\n+In the latter case, the warning is largely spurious, and the block will\n+eventually be reclaimed normally.\n+In the former case, the program will still run correctly, but the block\n+will never be reclaimed.  Unless the block is intended to be\n+permanent, the warning indicates a memory leak.\n+<OL>\n+<LI>Ignore these warnings while you are using GC_DEBUG.  Some of the routines\n+mentioned below don't have debugging equivalents.  (Alternatively, write\n+the missing routines and send them to me.)\n+<LI>Replace allocator calls that request large blocks with calls to\n+<TT>GC_malloc_ignore_off_page</tt> or\n+<TT>GC_malloc_atomic_ignore_off_page</tt>.  You may want to set a\n+breakpoint in <TT>GC_default_warn_proc</tt> to help you identify such calls.\n+Make sure that a pointer to somewhere near the beginning of the resulting block\n+is maintained in a (preferably volatile) variable as long as\n+the block is needed.\n+<LI>\n+If the large blocks are allocated with realloc, we suggest instead allocating\n+them with something like the following.  Note that the realloc size increment\n+should be fairly large (e.g. a factor of 3/2) for this to exhibit reasonable\n+performance.  But we all know we should do that anyway.\n+<PRE>\n+void * big_realloc(void *p, size_t new_size)\n+{\n+    size_t old_size = GC_size(p);\n+    void * result;\n+ \n+    if (new_size <= 10000) return(GC_realloc(p, new_size));\n+    if (new_size <= old_size) return(p);\n+    result = GC_malloc_ignore_off_page(new_size);\n+    if (result == 0) return(0);\n+    memcpy(result,p,old_size);\n+    GC_free(p);\n+    return(result);\n+}\n+</pre>\n+\n+<LI> In the unlikely case that even relatively small object\n+(&lt;20KB) allocations are triggering these warnings, then your address\n+space contains lots of \"bogus pointers\", i.e. values that appear to\n+be pointers but aren't.  Usually this can be solved by using GC_malloc_atomic\n+or the routines in gc_typed.h to allocate large pointer-free regions of bitmaps, etc.  Sometimes the problem can be solved with trivial changes of encoding\n+in certain values.  It is possible, to identify the source of the bogus\n+pointers by building the collector with <TT>-DPRINT_BLACK_LIST</tt>,\n+which will cause it to print the \"bogus pointers\", along with their location.\n+\n+<LI> If you get only a fixed number of these warnings, you are probably only\n+introducing a bounded leak by ignoring them.  If the data structures being\n+allocated are intended to be permanent, then it is also safe to ignore them.\n+The warnings can be turned off by calling GC_set_warn_proc with a procedure\n+that ignores these warnings (e.g. by doing absolutely nothing).\n+</ol>\n+\n+<H2>The Collector References a Bad Address in <TT>GC_malloc</tt></h2>\n+\n+This typically happens while the collector is trying to remove an entry from\n+its free list, and the free list pointer is bad because the free list link\n+in the last allocated object was bad.\n+<P>\n+With &gt; 99% probability, you wrote past the end of an allocated object.\n+Try setting <TT>GC_DEBUG</tt> before including <TT>gc.h</tt> and\n+allocating with <TT>GC_MALLOC</tt>.  This will try to detect such\n+overwrite errors.\n+\n+<H2>Unexpectedly Large Heap</h2>\n+\n+Unexpected heap growth can be due to one of the following:\n+<OL>\n+<LI> Data structures that are being unintentionally retained.  This\n+is commonly caused by data structures that are no longer being used,\n+but were not cleared, or by caches growing without bounds.\n+<LI> Pointer misidentification.  The garbage collector is interpreting\n+integers or other data as pointers and retaining the \"referenced\"\n+objects.\n+<LI> Heap fragmentation.  This should never result in unbounded growth,\n+but it may account for larger heaps.  This is most commonly caused\n+by allocation of large objects.  On some platforms it can be reduced\n+by building with -DUSE_MUNMAP, which will cause the collector to unmap\n+memory corresponding to pages that have not been recently used.\n+<LI> Per object overhead.  This is usually a relatively minor effect, but\n+it may be worth considering.  If the collector recognizes interior\n+pointers, object sizes are increased, so that one-past-the-end pointers\n+are correctly recognized.  The collector can be configured not to do this\n+(<TT>-DDONT_ADD_BYTE_AT_END</tt>).\n+<P>\n+The collector rounds up object sizes so the result fits well into the\n+chunk size (<TT>HBLKSIZE</tt>, normally 4K on 32 bit machines, 8K\n+on 64 bit machines) used by the collector.   Thus it may be worth avoiding\n+objects of size 2K + 1 (or 2K if a byte is being added at the end.)\n+</ol>\n+The last two cases can often be identified by looking at the output\n+of a call to <TT>GC_dump()</tt>.  Among other things, it will print the\n+list of free heap blocks, and a very brief description of all chunks in\n+the heap, the object sizes they correspond to, and how many live objects\n+were found in the chunk at the last collection.\n+<P>\n+Growing data structures can usually be identified by\n+<OL>\n+<LI> Building the collector with <TT>-DKEEP_BACK_PTRS</tt>,\n+<LI> Preferably using debugging allocation (defining <TT>GC_DEBUG</tt>\n+before including <TT>gc.h</tt> and allocating with <TT>GC_MALLOC</tt>),\n+so that objects will be identified by their allocation site,\n+<LI> Running the application long enough so\n+that most of the heap is composed of \"leaked\" memory, and\n+<LI> Then calling <TT>GC_generate_random_backtrace()</tt> from backptr.h\n+a few times to determine why some randomly sampled objects in the heap are\n+being retained.\n+</ol>\n+<P>\n+The same technique can often be used to identify problems with false\n+pointers, by noting whether the reference chains printed by\n+<TT>GC_generate_random_backtrace()</tt> involve any misidentified pointers.\n+An alternate technique is to build the collector with\n+<TT>-DPRINT_BLACK_LIST</tt> which will cause it to report values that\n+are almost, but not quite, look like heap pointers.  It is very likely that\n+actual false pointers will come from similar sources.\n+<P>\n+In the unlikely case that false pointers are an issue, it can usually\n+be resolved using one or more of the following techniques:\n+<OL>\n+<LI> Use <TT>GC_malloc_atomic</tt> for objects containing no pointers.\n+This is especially important for large arrays containing compressed data,\n+pseudo-random numbers, and the like.  It is also likely to improve GC\n+performance, perhaps drastically so if the application is paging.\n+<LI> If you allocate large objects containing only\n+one or two pointers at the beginning, either try the typed allocation\n+primitives is <TT>gc_typed.h</tt>, or separate out the pointerfree component.\n+<LI> Consider using <TT>GC_malloc_ignore_off_page()</tt>\n+to allocate large objects.  (See <TT>gc.h</tt> and above for details.\n+Large means &gt; 100K in most environments.)\n+</ol>\n+<H2>Prematurely Reclaimed Objects</h2>\n+The usual symptom of this is a segmentation fault, or an obviously overwritten\n+value in a heap object.  This should, of course, be impossible.  In practice,\n+it may happen for reasons like the following:\n+<OL>\n+<LI> The collector did not intercept the creation of threads correctly in\n+a multithreaded application, <I>e.g.</i> because the client called\n+<TT>pthread_create</tt> without including <TT>gc.h</tt>, which redefines it.\n+<LI> The last pointer to an object in the garbage collected heap was stored\n+somewhere were the collector couldn't see it, <I>e.g.</i> in an\n+object allocated with system <TT>malloc</tt>, in certain types of\n+<TT>mmap</tt>ed files,\n+or in some data structure visible only to the OS.  (On some platforms,\n+thread-local storage is one of these.)\n+<LI> The last pointer to an object was somehow disguised, <I>e.g.</i> by\n+XORing it with another pointer.\n+<LI> Incorrect use of <TT>GC_malloc_atomic</tt> or typed allocation.\n+<LI> An incorrect <TT>GC_free</tt> call.\n+<LI> The client program overwrote an internal garbage collector data structure.\n+<LI> A garbage collector bug.\n+<LI> (Empirically less likely than any of the above.) A compiler optimization\n+that disguised the last pointer.\n+</ol>\n+The following relatively simple techniques should be tried first to narrow\n+down the problem:\n+<OL>\n+<LI> If you are using the incremental collector try turning it off for\n+debugging.\n+<LI> Try to reproduce the problem with fully debuggable unoptimized code.\n+This will eliminate the last possibility, as well as making debugging easier.\n+<LI> Try replacing any suspect typed allocation and <TT>GC_malloc_atomic</tt>\n+calls with calls to <TT>GC_malloc</tt>.\n+<LI> Try removing any GC_free calls (<I>e.g.</i> with a suitable\n+<TT>#define</tt>).\n+<LI> Rebuild the collector with <TT>-DGC_ASSERTIONS</tt>.\n+<LI> If the following works on your platform (i.e. if gctest still works\n+if you do this), try building the collector with\n+<TT>-DREDIRECT_MALLOC=GC_malloc_uncollectable</tt>.  This will cause\n+the collector to scan memory allocated with malloc.\n+</ol>\n+If all else fails, you will have to attack this with a debugger.\n+Suggested steps:\n+<OL>\n+<LI> Call <TT>GC_dump()</tt> from the debugger around the time of the failure.  Verify\n+that the collectors idea of the root set (i.e. static data regions which\n+it should scan for pointers) looks plausible.  If not, i.e. if it doesn't\n+include some static variables, report this as\n+a collector bug.  Be sure to describe your platform precisely, since this sort\n+of problem is nearly always very platform dependent.\n+<LI> Especially if the failure is not deterministic, try to isolate it to\n+a relatively small test case.\n+<LI> Set a break point in <TT>GC_finish_collection</tt>.  This is a good\n+point to examine what has been marked, i.e. found reachable, by the\n+collector.\n+<LI> If the failure is deterministic, run the process\n+up to the last collection before the failure.\n+Note that the variable <TT>GC_gc_no</tt> counts collections and can be used\n+to set a conditional breakpoint in the right one.  It is incremented just\n+before the call to GC_finish_collection.\n+If object <TT>p</tt> was prematurely recycled, it may be helpful to\n+look at <TT>*GC_find_header(p)</tt> at the failure point.\n+The <TT>hb_last_reclaimed</tt> field will identify the collection number\n+during which its block was last swept.\n+<LI> Verify that the offending object still has its correct contents at\n+this point.\n+The call <TT>GC_is_marked(p)</tt> from the debugger to verify that the\n+object has not been marked, and is about to be reclaimed.\n+<LI> Determine a path from a root, i.e. static variable, stack, or\n+register variable,\n+to the reclaimed object.  Call <TT>GC_is_marked(q)</tt> for each object\n+<TT>q</tt> along the path, trying to locate the first unmarked object, say\n+<TT>r</tt>.\n+<LI> If <TT>r</tt> is pointed to by a static root,\n+verify that the location\n+pointing to it is part of the root set printed by <TT>GC_dump()</tt>.  If it\n+is on the stack in the main (or only) thread, verify that\n+<TT>GC_stackbottom</tt> is set correctly to the base of the stack.  If it is\n+in another thread stack, check the collector's thread data structure\n+(<TT>GC_thread[]</tt> on several platforms) to make sure that stack bounds\n+are set correctly.\n+<LI> If <TT>r</tt> is pointed to by heap object <TT>s</tt>, check that the\n+collector's layout description for <TT>s</tt> is such that the pointer field\n+will be scanned.  Call <TT>*GC_find_header(s)</tt> to look at the descriptor\n+for the heap chunk.  The <TT>hb_descr</tt> field specifies the layout\n+of objects in that chunk.  See gc_mark.h for the meaning of the descriptor.\n+(If it's low order 2 bits are zero, then it is just the length of the\n+object prefix to be scanned.  This form is always used for objects allocated\n+with <TT>GC_malloc</tt> or <TT>GC_malloc_atomic</tt>.)\n+<LI> If the failure is not deterministic, you may still be able to apply some\n+of the above technique at the point of failure.  But remember that objects\n+allocated since the last collection will not have been marked, even if the\n+collector is functioning properly.  On some platforms, the collector\n+can be configured to save call chains in objects for debugging.\n+Enabling this feature will also cause it to save the call stack at the\n+point of the last GC in GC_arrays._last_stack.\n+<LI> When looking at GC internal data structures remember that a number\n+of <TT>GC_</tt><I>xxx</i> variables are really macro defined to\n+<TT>GC_arrays._</tt><I>xxx</i>, so that\n+the collector can avoid scanning them.\n+</ol>\n+</body>\n+</html>\n+\n+\n+\n+"}, {"sha": "65e8a8f61c9f81bea9d5643ad478217b3e9e468b", "filename": "boehm-gc/doc/gcdescr.html", "status": "added", "additions": 438, "deletions": 0, "changes": 438, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2Fgcdescr.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2Fgcdescr.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fgcdescr.html?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,438 @@\n+<HTML>\n+<HEAD>\n+    <TITLE> Conservative GC Algorithmic Overview </TITLE>\n+    <AUTHOR> Hans-J. Boehm, Silicon Graphics</author>\n+</HEAD>\n+<BODY>\n+<H1> <I>This is under construction</i> </h1>\n+<H1> Conservative GC Algorithmic Overview </h1>\n+<P>\n+This is a description of the algorithms and data structures used in our\n+conservative garbage collector.  I expect the level of detail to increase\n+with time.  For a survey of GC algorithms, see for example\n+<A HREF=\"ftp://ftp.cs.utexas.edu/pub/garbage/gcsurvey.ps\"> Paul Wilson's\n+excellent paper</a>.  For an overview of the collector interface,\n+see <A HREF=\"gcinterface.html\">here</a>.\n+<P>\n+This description is targeted primarily at someone trying to understand the\n+source code.  It specifically refers to variable and function names.\n+It may also be useful for understanding the algorithms at a higher level.\n+<P>\n+The description here assumes that the collector is used in default mode.\n+In particular, we assume that it used as a garbage collector, and not just\n+a leak detector.  We initially assume that it is used in stop-the-world,\n+non-incremental mode, though the presence of the incremental collector\n+will be apparent in the design.\n+We assume the default finalization model, but the code affected by that\n+is very localized.\n+<H2> Introduction </h2>\n+The garbage collector uses a modified mark-sweep algorithm.  Conceptually\n+it operates roughly in four phases:\n+\n+<OL>\n+\n+<LI>\n+<I>Preparation</i> Clear all mark bits, indicating that all objects\n+are potentially unreachable.\n+\n+<LI>\n+<I>Mark phase</i> Marks all objects that can be reachable via chains of\n+pointers from variables.  Normally the collector has no real information\n+about the location of pointer variables in the heap, so it\n+views all static data areas, stacks and registers as potentially containing\n+containing pointers.  Any bit patterns that represent addresses inside\n+heap objects managed by the collector are viewed as pointers.\n+Unless the client program has made heap object layout information\n+available to the collector, any heap objects found to be reachable from\n+variables are again scanned similarly.\n+\n+<LI>\n+<I>Sweep phase</i> Scans the heap for inaccessible, and hence unmarked,\n+objects, and returns them to an appropriate free list for reuse.  This is\n+not really a separate phase; even in non incremental mode this is operation\n+is usually performed on demand during an allocation that discovers an empty\n+free list.  Thus the sweep phase is very unlikely to touch a page that\n+would not have been touched shortly thereafter anyway.\n+\n+<LI>\n+<I>Finalization phase</i> Unreachable objects which had been registered\n+for finalization are enqueued for finalization outside the collector.\n+\n+</ol>\n+\n+<P>\n+The remaining sections describe the memory allocation data structures,\n+and then the last 3 collection phases in more detail. We conclude by\n+outlining some of the additional features implemented in the collector.\n+\n+<H2>Allocation</h2>\n+The collector includes its own memory allocator.  The allocator obtains\n+memory from the system in a platform-dependent way.  Under UNIX, it\n+uses either <TT>malloc</tt>, <TT>sbrk</tt>, or <TT>mmap</tt>.\n+<P>\n+Most static data used by the allocator, as well as that needed by the\n+rest of the garbage collector is stored inside the\n+<TT>_GC_arrays</tt> structure.\n+This allows the garbage collector to easily ignore the collectors own\n+data structures when it searches for root pointers.  Other allocator\n+and collector internal data structures are allocated dynamically\n+with <TT>GC_scratch_alloc</tt>. <TT>GC_scratch_alloc</tt> does not\n+allow for deallocation, and is therefore used only for permanent data\n+structures.\n+<P>\n+The allocator allocates objects of different <I>kinds</i>.\n+Different kinds are handled somewhat differently by certain parts\n+of the garbage collector.  Certain kinds are scanned for pointers,\n+others are not.  Some may have per-object type descriptors that\n+determine pointer locations.  Or a specific kind may correspond\n+to one specific object layout.  Two built-in kinds are uncollectable.\n+One (<TT>STUBBORN</tt>) is immutable without special precautions.\n+In spite of that, it is very likely that most applications currently\n+use at most two kinds: <TT>NORMAL</tt> and <TT>PTRFREE</tt> objects.\n+<P>\n+The collector uses a two level allocator.  A large block is defined to\n+be one larger than half of <TT>HBLKSIZE</tt>, which is a power of 2,\n+typically on the order of the page size.\n+<P>\n+Large block sizes are rounded up to\n+the next multiple of <TT>HBLKSIZE</tt> and then allocated by\n+<TT>GC_allochblk</tt>.  This uses roughly what Paul Wilson has termed\n+a \"next fit\" algorithm, i.e. first-fit with a rotating pointer.\n+The implementation does check for a better fitting immediately\n+adjacent block, which gives it somewhat better fragmentation characteristics.\n+I'm now convinced it should use a best fit algorithm.  The actual\n+implementation of <TT>GC_allochblk</tt>\n+is significantly complicated by black-listing issues\n+(see below).\n+<P>\n+Small blocks are allocated in blocks of size <TT>HBLKSIZE</tt>.\n+Each block is\n+dedicated to only one object size and kind.  The allocator maintains\n+separate free lists for each size and kind of object.\n+<P>\n+In order to avoid allocating blocks for too many distinct object sizes,\n+the collector normally does not directly allocate objects of every possible\n+request size.  Instead request are rounded up to one of a smaller number\n+of allocated sizes, for which free lists are maintained.  The exact\n+allocated sizes are computed on demand, but subject to the constraint\n+that they increase roughly in geometric progression.  Thus objects\n+requested early in the execution are likely to be allocated with exactly\n+the requested size, subject to alignment constraints.\n+See <TT>GC_init_size_map</tt> for details.\n+<P>\n+The actual size rounding operation during small object allocation is\n+implemented as a table lookup in <TT>GC_size_map</tt>.\n+<P>\n+Both collector initialization and computation of allocated sizes are\n+handled carefully so that they do not slow down the small object fast\n+allocation path.  An attempt to allocate before the collector is initialized,\n+or before the appropriate <TT>GC_size_map</tt> entry is computed,\n+will take the same path as an allocation attempt with an empty free list.\n+This results in a call to the slow path code (<TT>GC_generic_malloc_inner</tt>)\n+which performs the appropriate initialization checks.\n+<P>\n+In non-incremental mode, we make a decision about whether to garbage collect\n+whenever an allocation would otherwise have failed with the current heap size.\n+If the total amount of allocation since the last collection is less than\n+the heap size divided by <TT>GC_free_space_divisor</tt>, we try to\n+expand the heap.  Otherwise, we initiate a garbage collection.  This ensures\n+that the amount of garbage collection work per allocated byte remains\n+constant.\n+<P>\n+The above is in fat an oversimplification of the real heap expansion\n+heuristic, which adjusts slightly for root size and certain kinds of\n+fragmentation.  In particular, programs with a large root set size and\n+little live heap memory will expand the heap to amortize the cost of\n+scanning the roots.\n+<P>\n+Versions 5.x of the collector actually collect more frequently in\n+nonincremental mode.  The large block allocator usually refuses to split\n+large heap blocks once the garbage collection threshold is\n+reached.  This often has the effect of collecting well before the\n+heap fills up, thus reducing fragmentation and working set size at the\n+expense of GC time.  6.x will chose an intermediate strategy depending\n+on how much large object allocation has taken place in the past.\n+(If the collector is configured to unmap unused pages, versions 6.x\n+will use the 5.x strategy.)\n+<P>\n+(It has been suggested that this should be adjusted so that we favor\n+expansion if the resulting heap still fits into physical memory.\n+In many cases, that would no doubt help.  But it is tricky to do this\n+in a way that remains robust if multiple application are contending\n+for a single pool of physical memory.)\n+\n+<H2>Mark phase</h2>\n+\n+The marker maintains an explicit stack of memory regions that are known\n+to be accessible, but that have not yet been searched for contained pointers.\n+Each stack entry contains the starting address of the block to be scanned,\n+as well as a descriptor of the block.  If no layout information is\n+available for the block, then the descriptor is simply a length.\n+(For other possibilities, see <TT>gc_mark.h</tt>.)\n+<P>\n+At the beginning of the mark phase, all root segments are pushed on the\n+stack by <TT>GC_push_roots</tt>.  If <TT>ALL_INTERIOR_PTRS</tt> is not\n+defined, then stack roots require special treatment.  In this case, the\n+normal marking code ignores interior pointers, but <TT>GC_push_all_stack</tt>\n+explicitly checks for interior pointers and pushes descriptors for target\n+objects.\n+<P>\n+The marker is structured to allow incremental marking.\n+Each call to <TT>GC_mark_some</tt> performs a small amount of\n+work towards marking the heap.\n+It maintains\n+explicit state in the form of <TT>GC_mark_state</tt>, which\n+identifies a particular sub-phase.  Some other pieces of state, most\n+notably the mark stack, identify how much work remains to be done\n+in each sub-phase.  The normal progression of mark states for\n+a stop-the-world collection is:\n+<OL>\n+<LI> <TT>MS_INVALID</tt> indicating that there may be accessible unmarked\n+objects.  In this case <TT>GC_objects_are_marked</tt> will simultaneously\n+be false, so the mark state is advanced to\n+<LI> <TT>MS_PUSH_UNCOLLECTABLE</tt> indicating that it suffices to push\n+uncollectable objects, roots, and then mark everything reachable from them.\n+<TT>Scan_ptr</tt> is advanced through the heap until all uncollectable\n+objects are pushed, and objects reachable from them are marked.\n+At that point, the next call to <TT>GC_mark_some</tt> calls\n+<TT>GC_push_roots</tt> to push the roots.  It the advances the\n+mark state to\n+<LI> <TT>MS_ROOTS_PUSHED</tt> asserting that once the mark stack is\n+empty, all reachable objects are marked.  Once in this state, we work\n+only on emptying the mark stack.  Once this is completed, the state\n+changes to\n+<LI> <TT>MS_NONE</tt> indicating that reachable objects are marked.\n+</ol>\n+\n+The core mark routine <TT>GC_mark_from_mark_stack</tt>, is called\n+repeatedly by several of the sub-phases when the mark stack starts to fill\n+up.  It is also called repeatedly in <TT>MS_ROOTS_PUSHED</tt> state\n+to empty the mark stack.\n+The routine is designed to only perform a limited amount of marking at\n+each call, so that it can also be used by the incremental collector.\n+It is fairly carefully tuned, since it usually consumes a large majority\n+of the garbage collection time.\n+<P>\n+The marker correctly handles mark stack overflows.  Whenever the mark stack\n+overflows, the mark state is reset to <TT>MS_INVALID</tt>.\n+Since there are already marked objects in the heap,\n+this eventually forces a complete\n+scan of the heap, searching for pointers, during which any unmarked objects\n+referenced by marked objects are again pushed on the mark stack.  This\n+process is repeated until the mark phase completes without a stack overflow.\n+Each time the stack overflows, an attempt is made to grow the mark stack.\n+All pieces of the collector that push regions onto the mark stack have to be\n+careful to ensure forward progress, even in case of repeated mark stack\n+overflows.  Every mark attempt results in additional marked objects.\n+<P>\n+Each mark stack entry is processed by examining all candidate pointers\n+in the range described by the entry.  If the region has no associated\n+type information, then this typically requires that each 4-byte aligned\n+quantity (8-byte aligned with 64-bit pointers) be considered a candidate\n+pointer.\n+<P>\n+We determine whether a candidate pointer is actually the address of\n+a heap block.  This is done in the following steps:\n+<NL>\n+<LI> The candidate pointer is checked against rough heap bounds.\n+These heap bounds are maintained such that all actual heap objects\n+fall between them.  In order to facilitate black-listing (see below)\n+we also include address regions that the heap is likely to expand into.\n+Most non-pointers fail this initial test.\n+<LI> The candidate pointer is divided into two pieces; the most significant\n+bits identify a <TT>HBLKSIZE</tt>-sized page in the address space, and\n+the least significant bits specify an offset within that page.\n+(A hardware page may actually consist of multiple such pages.\n+HBLKSIZE is usually the page size divided by a small power of two.)\n+<LI>\n+The page address part of the candidate pointer is looked up in a\n+<A HREF=\"tree.html\">table</a>.\n+Each table entry contains either 0, indicating that the page is not part\n+of the garbage collected heap, a small integer <I>n</i>, indicating\n+that the page is part of large object, starting at least <I>n</i> pages\n+back, or a pointer to a descriptor for the page.  In the first case,\n+the candidate pointer i not a true pointer and can be safely ignored.\n+In the last two cases, we can obtain a descriptor for the page containing\n+the beginning of the object.\n+<LI>\n+The starting address of the referenced object is computed.\n+The page descriptor contains the size of the object(s)\n+in that page, the object kind, and the necessary mark bits for those\n+objects.  The size information can be used to map the candidate pointer\n+to the object starting address.  To accelerate this process, the page header\n+also contains a pointer to a precomputed map of page offsets to displacements\n+from the beginning of an object.  The use of this map avoids a\n+potentially slow integer remainder operation in computing the object\n+start address.\n+<LI>\n+The mark bit for the target object is checked and set.  If the object\n+was previously unmarked, the object is pushed on the mark stack.\n+The descriptor is read from the page descriptor.  (This is computed\n+from information <TT>GC_obj_kinds</tt> when the page is first allocated.)\n+</nl>\n+<P>\n+At the end of the mark phase, mark bits for left-over free lists are cleared,\n+in case a free list was accidentally marked due to a stray pointer.\n+\n+<H2>Sweep phase</h2>\n+\n+At the end of the mark phase, all blocks in the heap are examined.\n+Unmarked large objects are immediately returned to the large object free list.\n+Each small object page is checked to see if all mark bits are clear.\n+If so, the entire page is returned to the large object free list.\n+Small object pages containing some reachable object are queued for later\n+sweeping.\n+<P>\n+This initial sweep pass touches only block headers, not\n+the blocks themselves.  Thus it does not require significant paging, even\n+if large sections of the heap are not in physical memory.\n+<P>\n+Nonempty small object pages are swept when an allocation attempt\n+encounters an empty free list for that object size and kind.\n+Pages for the correct size and kind are repeatedly swept until at\n+least one empty block is found.  Sweeping such a page involves\n+scanning the mark bit array in the page header, and building a free\n+list linked through the first words in the objects themselves.\n+This does involve touching the appropriate data page, but in most cases\n+it will be touched only just before it is used for allocation.\n+Hence any paging is essentially unavoidable.\n+<P>\n+Except in the case of pointer-free objects, we maintain the invariant\n+that any object in a small object free list is cleared (except possibly\n+for the link field).  Thus it becomes the burden of the small object\n+sweep routine to clear objects.  This has the advantage that we can\n+easily recover from accidentally marking a free list, though that could\n+also be handled by other means.  The collector currently spends a fair\n+amount of time clearing objects, and this approach should probably be\n+revisited.\n+<P>\n+In most configurations, we use specialized sweep routines to handle common\n+small object sizes.  Since we allocate one mark bit per word, it becomes\n+easier to examine the relevant mark bits if the object size divides\n+the word length evenly.  We also suitably unroll the inner sweep loop\n+in each case.  (It is conceivable that profile-based procedure cloning\n+in the compiler could make this unnecessary and counterproductive.  I\n+know of no existing compiler to which this applies.)\n+<P>\n+The sweeping of small object pages could be avoided completely at the expense\n+of examining mark bits directly in the allocator.  This would probably\n+be more expensive, since each allocation call would have to reload\n+a large amount of state (e.g. next object address to be swept, position\n+in mark bit table) before it could do its work.  The current scheme\n+keeps the allocator simple and allows useful optimizations in the sweeper.\n+\n+<H2>Finalization</h2>\n+Both <TT>GC_register_disappearing_link</tt> and\n+<TT>GC_register_finalizer</tt> add the request to a corresponding hash\n+table.  The hash table is allocated out of collected memory, but\n+the reference to the finalizable object is hidden from the collector.\n+Currently finalization requests are processed non-incrementally at the\n+end of a mark cycle.  \n+<P>\n+The collector makes an initial pass over the table of finalizable objects,\n+pushing the contents of unmarked objects onto the mark stack.\n+After pushing each object, the marker is invoked to mark all objects\n+reachable from it.  The object itself is not explicitly marked.\n+This assures that objects on which a finalizer depends are neither\n+collected nor finalized.\n+<P>\n+If in the process of marking from an object the\n+object itself becomes marked, we have uncovered\n+a cycle involving the object.  This usually results in a warning from the\n+collector.  Such objects are not finalized, since it may be\n+unsafe to do so.  See the more detailed\n+<A HREF=\"finalization.html\"> discussion of finalization semantics</a>.\n+<P>\n+Any objects remaining unmarked at the end of this process are added to\n+a queue of objects whose finalizers can be run.  Depending on collector\n+configuration, finalizers are dequeued and run either implicitly during\n+allocation calls, or explicitly in response to a user request.\n+<P>\n+The collector provides a mechanism for replacing the procedure that is\n+used to mark through objects.  This is used both to provide support for\n+Java-style unordered finalization, and to ignore certain kinds of cycles,\n+<I>e.g.</i> those arising from C++ implementations of virtual inheritance.\n+\n+<H2>Generational Collection and Dirty Bits</h2>\n+We basically use the parallel and generational GC algorithm described in\n+<A HREF=\"papers/pldi91.ps.gz\">\"Mostly Parallel Garbage Collection\"</a>,\n+by Boehm, Demers, and Shenker.\n+<P>\n+The most significant modification is that\n+the collector always runs in the allocating thread.\n+There is no separate garbage collector thread.\n+If an allocation attempt either requests a large object, or encounters\n+an empty small object free list, and notices that there is a collection\n+in progress, it immediately performs a small amount of marking work\n+as described above.\n+<P>\n+This change was made both because we wanted to easily accommodate\n+single-threaded environments, and because a separate GC thread requires\n+very careful control over the scheduler to prevent the mutator from\n+out-running the collector, and hence provoking unneeded heap growth.\n+<P>\n+In incremental mode, the heap is always expanded when we encounter\n+insufficient space for an allocation.  Garbage collection is triggered\n+whenever we notice that more than\n+<TT>GC_heap_size</tt>/2 * <TT>GC_free_space_divisor</tt>\n+bytes of allocation have taken place.\n+After <TT>GC_full_freq</tt> minor collections a major collection\n+is started.\n+<P>\n+All collections initially run interrupted until a predetermined\n+amount of time (50 msecs by default) has expired.  If this allows\n+the collection to complete entirely, we can avoid correcting\n+for data structure modifications during the collection.  If it does\n+not complete, we return control to the mutator, and perform small\n+amounts of additional GC work during those later allocations that\n+cannot be satisfied from small object free lists. When marking completes,\n+the set of modified pages is retrieved, and we mark once again from\n+marked objects on those pages, this time with the mutator stopped.\n+<P>\n+We keep track of modified pages using one of three distinct mechanisms:\n+<OL>\n+<LI>\n+Through explicit mutator cooperation.  Currently this requires\n+the use of <TT>GC_malloc_stubborn</tt>.\n+<LI>\n+By write-protecting physical pages and catching write faults.  This is\n+implemented for many Unix-like systems and for win32.  It is not possible\n+in a few environments.\n+<LI>\n+By retrieving dirty bit information from /proc.  (Currently only Sun's\n+Solaris supports this.  Though this is considerably cleaner, performance\n+may actually be better with mprotect and signals.)\n+</ol>\n+\n+<H2>Thread support</h2>\n+We support several different threading models.  Unfortunately Pthreads,\n+the only reasonably well standardized thread model, supports too narrow\n+an interface for conservative garbage collection.  There appears to be\n+no portable way to allow the collector to coexist with various Pthreads\n+implementations.  Hence we currently support only a few of the more\n+common Pthreads implementations.\n+<P>\n+In particular, it is very difficult for the collector to stop all other\n+threads in the system and examine the register contents.  This is currently\n+accomplished with very different mechanisms for different Pthreads\n+implementations.  The Solaris implementation temporarily disables much\n+of the user-level threads implementation by stopping kernel-level threads\n+(\"lwp\"s).  The Irix implementation sends signals to individual Pthreads\n+and has them wait in the signal handler.  The Linux implementation\n+is similar in spirit to the Irix one.\n+<P>\n+The Irix implementation uses\n+only documented Pthreads calls, but relies on extensions to their semantics,\n+notably the use of mutexes and condition variables from signal\n+handlers.  The Linux implementation should be far closer to\n+portable, though impirically it is not completely portable.\n+<P>\n+All implementations must\n+intercept thread creation and a few other thread-specific calls to allow\n+enumeration of threads and location of thread stacks.  This is current\n+accomplished with <TT># define</tt>'s in <TT>gc.h</tt>, or optionally\n+by using ld's function call wrapping mechanism under Linux.\n+<P>\n+Comments are appreciated.  Please send mail to\n+<A HREF=\"mailto:boehm@acm.org\"><TT>boehm@acm.org</tt></a>\n+</body>"}, {"sha": "89c515da76577e6b2d0b866e71389c7435ee035a", "filename": "boehm-gc/doc/tree.html", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2Ftree.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fdoc%2Ftree.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Ftree.html?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,198 @@\n+<HTML>\n+<HEAD>\n+    <TITLE>  Two-Level Tree Structure for Fast Pointer Lookup</TITLE>\n+    <AUTHOR> Hans-J. Boehm, Silicon Graphics</author>\n+</HEAD>\n+<BODY>\n+<H1>Two-Level Tree Structure for Fast Pointer Lookup</h1>\n+<P>\n+The conservative garbage collector described\n+<A HREF=\"gc.html\">here</a> uses a 2-level tree\n+data structure to aid in fast pointer identification.\n+This data structure is described in a bit more detail here, since\n+<OL>\n+<LI> Variations of the data structure are more generally useful.\n+<LI> It appears to be hard to understand by reading the code.\n+<LI> Some other collectors appear to use inferior data structures to\n+solve the same problem.\n+<LI> It is central to fast collector operation.\n+</ol>\n+A candidate pointer is divided into three sections, the <I>high</i>,\n+<I>middle</i>, and <I>low</i> bits.  The exact division between these\n+three groups of bits is dependent on the detailed collector configuration.\n+<P>\n+The high and middle bits are used to look up an entry in the table described\n+here.  The resulting table entry consists of either a block descriptor\n+(<TT>struct hblkhdr *</tt> or <TT>hdr *</tt>)\n+identifying the layout of objects in the block, or an indication that this\n+address range corresponds to the middle of a large block, together with a\n+hint for locating the actual block descriptor.  Such a hint consist\n+of a displacement that can be subtracted from the middle bits of the candidate\n+pointer without leaving the object.\n+<P>\n+In either case, the block descriptor (<TT>struct hblkhdr</tt>)\n+refers to a table of object starting addresses (the <TT>hb_map</tt> field).\n+The starting address table is indexed by the low bits if the candidate pointer.\n+The resulting entry contains a displacement to the beginning of the object,\n+or an indication that this cannot be a valid object pointer.\n+(If all interior pointer are recognized, pointers into large objects\n+are handled specially, as appropriate.)\n+\n+<H2>The Tree</h2>\n+<P>\n+The rest of this discussion focuses on the two level data structure\n+used to map the high and middle bits to the block descriptor.\n+<P>\n+The high bits are used as an index into the <TT>GC_top_index</tt> (really\n+<TT>GC_arrays._top_index</tt>) array.  Each entry points to a\n+<TT>bottom_index</tt> data structure.  This structure in turn consists\n+mostly of an array <TT>index</tt> indexed by the middle bits of\n+the candidate pointer.  The <TT>index</tt> array contains the actual\n+<TT>hdr</tt> pointers. \n+<P>\n+Thus a pointer lookup consists primarily of a handful of memory references,\n+and can be quite fast:\n+<OL>\n+<LI> The appropriate <TT>bottom_index</tt> pointer is looked up in\n+<TT>GC_top_index</tt>, based on the high bits of the candidate pointer.\n+<LI> The appropriate <TT>hdr</tt> pointer is looked up in the\n+<TT>bottom_index</tt> structure, based on the middle bits.\n+<LI> The block layout map pointer is retrieved from the <TT>hdr</tt>\n+structure.  (This memory reference is necessary since we try to share\n+block layout maps.)\n+<LI> The displacement to the beginning of the object is retrieved from the\n+above map.\n+</ol>\n+<P>\n+In order to conserve space, not all <TT>GC_top_index</tt> entries in fact\n+point to distinct <TT>bottom_index</tt> structures.  If no address with\n+the corresponding high bits is part of the heap, then the entry points\n+to <TT>GC_all_nils</tt>, a single <TT>bottom_index</tt> structure consisting\n+only of NULL <TT>hdr</tt> pointers.\n+<P>\n+<TT>Bottom_index</tt> structures contain slightly more information than\n+just <TT>hdr</tt> pointers.  The <TT>asc_link</tt> field is used to link\n+all <TT>bottom_index</tt> structures in ascending order for fast traversal.\n+This list is pointed to be <TT>GC_all_bottom_indices</tt>.\n+It is maintained with the aid of <TT>key</tt> field that contains the\n+high bits corresponding to the <TT>bottom_index</tt>.\n+\n+<H2>64 bit addresses</h2>\n+<P>\n+In the case of 64 bit addresses, this picture is complicated slightly\n+by the fact that one of the index structures would have to be huge to\n+cover the entire address space with a two level tree.  We deal with this\n+by turning <TT>GC_top_index</tt> into a chained hash table, instead of\n+a simple array.  This adds a <TT>hash_link</tt> field to the\n+<TT>bottom_index</tt> structure.\n+<P>\n+The \"hash function\" consists of dropping the high bits.  This is cheap to\n+compute, and guarantees that there will be no collisions if the heap\n+is contiguous and not excessively large.\n+\n+<H2>A picture</h2>\n+<P>\n+The following is an ASCII diagram of the data structure.\n+This was contributed by Dave Barrett several years ago.\n+<PRE>\n+\n+\t\tData Structure used by GC_base in gc3.7:\n+\t\t\t      21-Apr-94\n+\t\t\t \n+\t\t\t\n+\n+\n+    63                  LOG_TOP_SZ[11]  LOG_BOTTOM_SZ[10]   LOG_HBLKSIZE[13]\n+   +------------------+----------------+------------------+------------------+\n+ p:|                  |   TL_HASH(hi)  |                  |   HBLKDISPL(p)   |\n+   +------------------+----------------+------------------+------------------+\n+    \\-----------------------HBLKPTR(p)-------------------/\n+    \\------------hi-------------------/ \n+                      \\______ ________/ \\________ _______/ \\________ _______/\n+                             V                   V                  V\n+                             |                   |                  |\n+           GC_top_index[]    |                   |                  | \n+ ---      +--------------+   |                   |                  |  \n+  ^       |              |   |                   |                  |   \n+  |       |              |   |                   |                  |   \n+ TOP      +--------------+<--+                   |                  |      \n+ _SZ   +-<|      []      | *                     |                  |     \n+(items)|  +--------------+  if 0 < bi< HBLKSIZE  |                  |    \n+  |    |  |              | then large object     |                  |    \n+  |    |  |              | starts at the bi'th   |                  |    \n+  v    |  |              | HBLK before p.        |             i    |    \n+ ---   |  +--------------+                       |          (word-  |    \n+       v                                         |         aligned) |    \n+   bi= |GET_BI(p){->hash_link}->key==hi          |                  |   \n+       v                                         |                  |    \n+       |   (bottom_index)  \\ scratch_alloc'd     |                  |    \n+       |   ( struct  bi )  / by get_index()      |                  |    \n+ ---   +->+--------------+                       |                  |    \n+  ^       |              |                       |                  |\n+  ^       |              |                       |                  |\n+ BOTTOM   |              |   ha=GET_HDR_ADDR(p)  |                  |\n+_SZ(items)+--------------+<----------------------+          +-------+\n+  |   +--<|   index[]    |                                  |         \n+  |   |   +--------------+                      GC_obj_map: v              \n+  |   |   |              |              from      / +-+-+-----+-+-+-+-+  --- \n+  v   |   |              |              GC_add   < 0| | |     | | | | |   ^  \n+ ---  |   +--------------+             _map_entry \\ +-+-+-----+-+-+-+-+   |  \n+      |   |   asc_link   |                          +-+-+-----+-+-+-+-+ MAXOBJSZ\n+      |   +--------------+                      +-->| | |  j  | | | | |  +1   \n+      |   |     key      |                      |   +-+-+-----+-+-+-+-+   |  \n+      |   +--------------+                      |   +-+-+-----+-+-+-+-+   | \n+      |   |  hash_link   |                      |   | | |     | | | | |   v \n+      |   +--------------+                      |   +-+-+-----+-+-+-+-+  ---\n+      |                                         |   |<--MAX_OFFSET--->|   \n+      |                                         |         (bytes)\n+HDR(p)| GC_find_header(p)                       |   |<--MAP_ENTRIES-->| \n+      |                           \\ from        |    =HBLKSIZE/WORDSZ   \n+      |    (hdr) (struct hblkhdr) / alloc_hdr() |    (1024 on Alpha)\n+      +-->+----------------------+              |    (8/16 bits each)\n+GET_HDR(p)| word   hb_sz (words) |              |          \n+          +----------------------+              |     \n+          | struct hblk *hb_next |              |\n+          +----------------------+              |       \n+          |mark_proc hb_mark_proc|              |\n+          +----------------------+              |\n+          | char * hb_map        |>-------------+\n+          +----------------------+           \n+          | ushort hb_obj_kind   |           \n+          +----------------------+           \n+          |   hb_last_reclaimed  |           \n+ ---      +----------------------+                \n+  ^       |                      |\n+ MARK_BITS|       hb_marks[]     | *if hdr is free, hb_sz + DISCARD_WORDS\n+_SZ(words)|                      |  is the size of a heap chunk (struct hblk)\n+  v       |                      |  of at least MININCR*HBLKSIZE bytes (below),\n+ ---      +----------------------+  otherwise, size of each object in chunk.\n+\n+Dynamic data structures above are interleaved throughout the heap in blocks of \n+size MININCR * HBLKSIZE bytes as done by gc_scratch_alloc which cannot be\n+freed; free lists are used (e.g. alloc_hdr).  HBLK's below are collected.\n+\n+\t      (struct hblk)      \n+ ---      +----------------------+ < HBLKSIZE ---         ---          DISCARD_\n+  ^       |garbage[DISCARD_WORDS]|   aligned   ^           ^ HDR_BYTES WORDS\n+  |       |                      |             |           v (bytes)   (words)\n+  |       +-----hb_body----------+ < WORDSZ    |          ---   ---   \n+  |       |                      |   aligned   |           ^     ^\n+  |       |      Object 0        |             |           hb_sz |\n+  |       |                      |           i |(word-    (words)|\n+  |       |                      |      (bytes)|aligned)   v     |\n+  |       + - - - - - - - - - - -+ ---         |          ---    |\n+  |       |                      |  ^          |           ^     |\n+  n *     |                      |  j (words)  |          hb_sz BODY_SZ \n+ HBLKSIZE |      Object 1        |  v          v           |   (words)\n+ (bytes)  |                      |---------------          v   MAX_OFFSET\n+  |       + - - - - - - - - - - -+                        ---  (bytes)\n+  |       |                      | !All_INTERIOR_PTRS      ^     |\n+  |       |                      | sets j only for       hb_sz   |\n+  |       |      Object N        | valid object offsets.   |     |\n+  v       |                      | All objects WORDSZ      v     v\n+ ---      +----------------------+ aligned.               ---   ---\n+\n+DISCARD_WORDS is normally zero.  Indeed the collector has not been tested\n+with another value in ages.\n+</pre>\n+</body>"}, {"sha": "e2119d7996402c70352796c363867d7841118b87", "filename": "boehm-gc/gcname.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fgcname.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fgcname.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcname.c?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,13 @@\n+#include <stdio.h>\n+#include \"version.h\"\n+\n+int main()\n+{\n+    if (GC_ALPHA_VERSION == GC_NOT_ALPHA) {\n+\tprintf(\"gc%d.%d\", GC_VERSION_MAJOR, GC_VERSION_MINOR);\n+    } else {\n+\tprintf(\"gc%d.%dalpha%d\", GC_VERSION_MAJOR,\n+\t\t\t\t GC_VERSION_MINOR, GC_ALPHA_VERSION);\n+    }\n+    return 0;\n+}"}, {"sha": "e9de23842dcd44d2953129c866b1ad25f7e1f1d9", "filename": "boehm-gc/install-sh", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Finstall-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Finstall-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finstall-sh?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,251 @@\n+#!/bin/sh\n+#\n+# install - install a program, script, or datafile\n+# This comes from X11R5 (mit/util/scripts/install.sh).\n+#\n+# Copyright 1991 by the Massachusetts Institute of Technology\n+#\n+# Permission to use, copy, modify, distribute, and sell this software and its\n+# documentation for any purpose is hereby granted without fee, provided that\n+# the above copyright notice appear in all copies and that both that\n+# copyright notice and this permission notice appear in supporting\n+# documentation, and that the name of M.I.T. not be used in advertising or\n+# publicity pertaining to distribution of the software without specific,\n+# written prior permission.  M.I.T. makes no representations about the\n+# suitability of this software for any purpose.  It is provided \"as is\"\n+# without express or implied warranty.\n+#\n+# Calling this script install-sh is preferred over install.sh, to prevent\n+# `make' implicit rules from creating a file called install from it\n+# when there is no Makefile.\n+#\n+# This script is compatible with the BSD install script, but was written\n+# from scratch.  It can only install one file at a time, a restriction\n+# shared with many OS's install programs.\n+\n+\n+# set DOITPROG to echo to test this script\n+\n+# Don't use :- since 4.3BSD and earlier shells don't like it.\n+doit=\"${DOITPROG-}\"\n+\n+\n+# put in absolute paths if you don't have them in your path; or use env. vars.\n+\n+mvprog=\"${MVPROG-mv}\"\n+cpprog=\"${CPPROG-cp}\"\n+chmodprog=\"${CHMODPROG-chmod}\"\n+chownprog=\"${CHOWNPROG-chown}\"\n+chgrpprog=\"${CHGRPPROG-chgrp}\"\n+stripprog=\"${STRIPPROG-strip}\"\n+rmprog=\"${RMPROG-rm}\"\n+mkdirprog=\"${MKDIRPROG-mkdir}\"\n+\n+transformbasename=\"\"\n+transform_arg=\"\"\n+instcmd=\"$mvprog\"\n+chmodcmd=\"$chmodprog 0755\"\n+chowncmd=\"\"\n+chgrpcmd=\"\"\n+stripcmd=\"\"\n+rmcmd=\"$rmprog -f\"\n+mvcmd=\"$mvprog\"\n+src=\"\"\n+dst=\"\"\n+dir_arg=\"\"\n+\n+while [ x\"$1\" != x ]; do\n+    case $1 in\n+\t-c) instcmd=\"$cpprog\"\n+\t    shift\n+\t    continue;;\n+\n+\t-d) dir_arg=true\n+\t    shift\n+\t    continue;;\n+\n+\t-m) chmodcmd=\"$chmodprog $2\"\n+\t    shift\n+\t    shift\n+\t    continue;;\n+\n+\t-o) chowncmd=\"$chownprog $2\"\n+\t    shift\n+\t    shift\n+\t    continue;;\n+\n+\t-g) chgrpcmd=\"$chgrpprog $2\"\n+\t    shift\n+\t    shift\n+\t    continue;;\n+\n+\t-s) stripcmd=\"$stripprog\"\n+\t    shift\n+\t    continue;;\n+\n+\t-t=*) transformarg=`echo $1 | sed 's/-t=//'`\n+\t    shift\n+\t    continue;;\n+\n+\t-b=*) transformbasename=`echo $1 | sed 's/-b=//'`\n+\t    shift\n+\t    continue;;\n+\n+\t*)  if [ x\"$src\" = x ]\n+\t    then\n+\t\tsrc=$1\n+\t    else\n+\t\t# this colon is to work around a 386BSD /bin/sh bug\n+\t\t:\n+\t\tdst=$1\n+\t    fi\n+\t    shift\n+\t    continue;;\n+    esac\n+done\n+\n+if [ x\"$src\" = x ]\n+then\n+\techo \"install:\tno input file specified\"\n+\texit 1\n+else\n+\ttrue\n+fi\n+\n+if [ x\"$dir_arg\" != x ]; then\n+\tdst=$src\n+\tsrc=\"\"\n+\t\n+\tif [ -d $dst ]; then\n+\t\tinstcmd=:\n+\t\tchmodcmd=\"\"\n+\telse\n+\t\tinstcmd=mkdir\n+\tfi\n+else\n+\n+# Waiting for this to be detected by the \"$instcmd $src $dsttmp\" command\n+# might cause directories to be created, which would be especially bad \n+# if $src (and thus $dsttmp) contains '*'.\n+\n+\tif [ -f $src -o -d $src ]\n+\tthen\n+\t\ttrue\n+\telse\n+\t\techo \"install:  $src does not exist\"\n+\t\texit 1\n+\tfi\n+\t\n+\tif [ x\"$dst\" = x ]\n+\tthen\n+\t\techo \"install:\tno destination specified\"\n+\t\texit 1\n+\telse\n+\t\ttrue\n+\tfi\n+\n+# If destination is a directory, append the input filename; if your system\n+# does not like double slashes in filenames, you may need to add some logic\n+\n+\tif [ -d $dst ]\n+\tthen\n+\t\tdst=\"$dst\"/`basename $src`\n+\telse\n+\t\ttrue\n+\tfi\n+fi\n+\n+## this sed command emulates the dirname command\n+dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`\n+\n+# Make sure that the destination directory exists.\n+#  this part is taken from Noah Friedman's mkinstalldirs script\n+\n+# Skip lots of stat calls in the usual case.\n+if [ ! -d \"$dstdir\" ]; then\n+defaultIFS='\t\n+'\n+IFS=\"${IFS-${defaultIFS}}\"\n+\n+oIFS=\"${IFS}\"\n+# Some sh's can't handle IFS=/ for some reason.\n+IFS='%'\n+set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`\n+IFS=\"${oIFS}\"\n+\n+pathcomp=''\n+\n+while [ $# -ne 0 ] ; do\n+\tpathcomp=\"${pathcomp}${1}\"\n+\tshift\n+\n+\tif [ ! -d \"${pathcomp}\" ] ;\n+        then\n+\t\t$mkdirprog \"${pathcomp}\"\n+\telse\n+\t\ttrue\n+\tfi\n+\n+\tpathcomp=\"${pathcomp}/\"\n+done\n+fi\n+\n+if [ x\"$dir_arg\" != x ]\n+then\n+\t$doit $instcmd $dst &&\n+\n+\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dst; else true ; fi &&\n+\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&\n+\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dst; else true ; fi &&\n+\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dst; else true ; fi\n+else\n+\n+# If we're going to rename the final executable, determine the name now.\n+\n+\tif [ x\"$transformarg\" = x ] \n+\tthen\n+\t\tdstfile=`basename $dst`\n+\telse\n+\t\tdstfile=`basename $dst $transformbasename | \n+\t\t\tsed $transformarg`$transformbasename\n+\tfi\n+\n+# don't allow the sed command to completely eliminate the filename\n+\n+\tif [ x\"$dstfile\" = x ] \n+\tthen\n+\t\tdstfile=`basename $dst`\n+\telse\n+\t\ttrue\n+\tfi\n+\n+# Make a temp file name in the proper directory.\n+\n+\tdsttmp=$dstdir/#inst.$$#\n+\n+# Move or copy the file name to the temp name\n+\n+\t$doit $instcmd $src $dsttmp &&\n+\n+\ttrap \"rm -f ${dsttmp}\" 0 &&\n+\n+# and set any options; do chmod last to preserve setuid bits\n+\n+# If any of these fail, we abort the whole thing.  If we want to\n+# ignore errors from any of these, just make sure not to ignore\n+# errors from the above \"$doit $instcmd $src $dsttmp\" command.\n+\n+\tif [ x\"$chowncmd\" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&\n+\tif [ x\"$chgrpcmd\" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&\n+\tif [ x\"$stripcmd\" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&\n+\tif [ x\"$chmodcmd\" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&\n+\n+# Now rename the file to the real destination.\n+\n+\t$doit $rmcmd -f $dstdir/$dstfile &&\n+\t$doit $mvcmd $dsttmp $dstdir/$dstfile \n+\n+fi &&\n+\n+\n+exit 0"}, {"sha": "c857149a9d631bc371f50faed06ff494736a774b", "filename": "boehm-gc/libtool.m4", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Flibtool.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Flibtool.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flibtool.m4?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,435 @@\n+## libtool.m4 - Configure libtool for the target system. -*-Shell-script-*-\n+## Copyright (C) 1996-1999 Free Software Foundation, Inc.\n+## Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n+##\n+## This program is free software; you can redistribute it and/or modify\n+## it under the terms of the GNU General Public License as published by\n+## the Free Software Foundation; either version 2 of the License, or\n+## (at your option) any later version.\n+##\n+## This program is distributed in the hope that it will be useful, but\n+## WITHOUT ANY WARRANTY; without even the implied warranty of\n+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+## General Public License for more details.\n+##\n+## You should have received a copy of the GNU General Public License\n+## along with this program; if not, write to the Free Software\n+## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+##\n+## As a special exception to the GNU General Public License, if you\n+## distribute this file as part of a program that contains a\n+## configuration script generated by Autoconf, you may include it under\n+## the same distribution terms that you use for the rest of that program.\n+\n+# serial 40 AC_PROG_LIBTOOL\n+AC_DEFUN(AC_PROG_LIBTOOL,\n+[AC_REQUIRE([AC_LIBTOOL_SETUP])dnl\n+\n+# Save cache, so that ltconfig can load it\n+AC_CACHE_SAVE\n+\n+# Actually configure libtool.  ac_aux_dir is where install-sh is found.\n+CC=\"$CC\" CFLAGS=\"$CFLAGS\" CPPFLAGS=\"$CPPFLAGS\" \\\n+LD=\"$LD\" LDFLAGS=\"$LDFLAGS\" LIBS=\"$LIBS\" \\\n+LN_S=\"$LN_S\" NM=\"$NM\" RANLIB=\"$RANLIB\" \\\n+DLLTOOL=\"$DLLTOOL\" AS=\"$AS\" OBJDUMP=\"$OBJDUMP\" \\\n+${CONFIG_SHELL-/bin/sh} $ac_aux_dir/ltconfig --no-reexec \\\n+$libtool_flags --no-verify $ac_aux_dir/ltmain.sh $lt_target \\\n+|| AC_MSG_ERROR([libtool configure failed])\n+\n+# Reload cache, that may have been modified by ltconfig\n+AC_CACHE_LOAD\n+\n+# This can be used to rebuild libtool when needed\n+LIBTOOL_DEPS=\"$ac_aux_dir/ltconfig $ac_aux_dir/ltmain.sh\"\n+\n+# Always use our own libtool.\n+LIBTOOL='$(SHELL) $(top_builddir)/libtool'\n+AC_SUBST(LIBTOOL)dnl\n+\n+# Redirect the config.log output again, so that the ltconfig log is not\n+# clobbered by the next message.\n+exec 5>>./config.log\n+])\n+\n+AC_DEFUN(AC_LIBTOOL_SETUP,\n+[AC_PREREQ(2.13)dnl\n+AC_REQUIRE([AC_ENABLE_SHARED])dnl\n+AC_REQUIRE([AC_ENABLE_STATIC])dnl\n+AC_REQUIRE([AC_ENABLE_FAST_INSTALL])dnl\n+AC_REQUIRE([AC_CANONICAL_HOST])dnl\n+AC_REQUIRE([AC_CANONICAL_BUILD])dnl\n+AC_REQUIRE([AC_PROG_RANLIB])dnl\n+AC_REQUIRE([AC_PROG_CC])dnl\n+AC_REQUIRE([AC_PROG_LD])dnl\n+AC_REQUIRE([AC_PROG_NM])dnl\n+AC_REQUIRE([AC_PROG_LN_S])dnl\n+dnl\n+\n+case \"$target\" in\n+NONE) lt_target=\"$host\" ;;\n+*) lt_target=\"$target\" ;;\n+esac\n+\n+# Check for any special flags to pass to ltconfig.\n+#\n+# the following will cause an existing older ltconfig to fail, so\n+# we ignore this at the expense of the cache file... Checking this \n+# will just take longer ... bummer!\n+#libtool_flags=\"--cache-file=$cache_file\"\n+#\n+test \"$enable_shared\" = no && libtool_flags=\"$libtool_flags --disable-shared\"\n+test \"$enable_static\" = no && libtool_flags=\"$libtool_flags --disable-static\"\n+test \"$enable_fast_install\" = no && libtool_flags=\"$libtool_flags --disable-fast-install\"\n+test \"$ac_cv_prog_gcc\" = yes && libtool_flags=\"$libtool_flags --with-gcc\"\n+test \"$ac_cv_prog_gnu_ld\" = yes && libtool_flags=\"$libtool_flags --with-gnu-ld\"\n+ifdef([AC_PROVIDE_AC_LIBTOOL_DLOPEN],\n+[libtool_flags=\"$libtool_flags --enable-dlopen\"])\n+ifdef([AC_PROVIDE_AC_LIBTOOL_WIN32_DLL],\n+[libtool_flags=\"$libtool_flags --enable-win32-dll\"])\n+AC_ARG_ENABLE(libtool-lock,\n+  [  --disable-libtool-lock  avoid locking (might break parallel builds)])\n+test \"x$enable_libtool_lock\" = xno && libtool_flags=\"$libtool_flags --disable-lock\"\n+test x\"$silent\" = xyes && libtool_flags=\"$libtool_flags --silent\"\n+\n+# Some flags need to be propagated to the compiler or linker for good\n+# libtool support.\n+case \"$lt_target\" in\n+*-*-irix6*)\n+  # Find out which ABI we are using.\n+  echo '[#]line __oline__ \"configure\"' > conftest.$ac_ext\n+  if AC_TRY_EVAL(ac_compile); then\n+    case \"`/usr/bin/file conftest.o`\" in\n+    *32-bit*)\n+      LD=\"${LD-ld} -32\"\n+      ;;\n+    *N32*)\n+      LD=\"${LD-ld} -n32\"\n+      ;;\n+    *64-bit*)\n+      LD=\"${LD-ld} -64\"\n+      ;;\n+    esac\n+  fi\n+  rm -rf conftest*\n+  ;;\n+\n+*-*-sco3.2v5*)\n+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n+  SAVE_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -belf\"\n+  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n+    [AC_TRY_LINK([],[],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])])\n+  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n+    CFLAGS=\"$SAVE_CFLAGS\"\n+  fi\n+  ;;\n+\n+ifdef([AC_PROVIDE_AC_LIBTOOL_WIN32_DLL],\n+[*-*-cygwin* | *-*-mingw*)\n+  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n+  AC_CHECK_TOOL(AS, as, false)\n+  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n+  ;;\n+])\n+esac\n+])\n+\n+# AC_LIBTOOL_DLOPEN - enable checks for dlopen support\n+AC_DEFUN(AC_LIBTOOL_DLOPEN, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])])\n+\n+# AC_LIBTOOL_WIN32_DLL - declare package support for building win32 dll's\n+AC_DEFUN(AC_LIBTOOL_WIN32_DLL, [AC_BEFORE([$0], [AC_LIBTOOL_SETUP])])\n+\n+# AC_ENABLE_SHARED - implement the --enable-shared flag\n+# Usage: AC_ENABLE_SHARED[(DEFAULT)]\n+#   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to\n+#   `yes'.\n+AC_DEFUN(AC_ENABLE_SHARED, [dnl\n+define([AC_ENABLE_SHARED_DEFAULT], ifelse($1, no, no, yes))dnl\n+AC_ARG_ENABLE(shared,\n+changequote(<<, >>)dnl\n+<<  --enable-shared[=PKGS]  build shared libraries [default=>>AC_ENABLE_SHARED_DEFAULT],\n+changequote([, ])dnl\n+[p=${PACKAGE-default}\n+case \"$enableval\" in\n+yes) enable_shared=yes ;;\n+no) enable_shared=no ;;\n+*)\n+  enable_shared=no\n+  # Look at the argument we got.  We use all the common list separators.\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:,\"\n+  for pkg in $enableval; do\n+    if test \"X$pkg\" = \"X$p\"; then\n+      enable_shared=yes\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+  ;;\n+esac],\n+enable_shared=AC_ENABLE_SHARED_DEFAULT)dnl\n+])\n+\n+# AC_DISABLE_SHARED - set the default shared flag to --disable-shared\n+AC_DEFUN(AC_DISABLE_SHARED, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+AC_ENABLE_SHARED(no)])\n+\n+# AC_ENABLE_STATIC - implement the --enable-static flag\n+# Usage: AC_ENABLE_STATIC[(DEFAULT)]\n+#   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to\n+#   `yes'.\n+AC_DEFUN(AC_ENABLE_STATIC, [dnl\n+define([AC_ENABLE_STATIC_DEFAULT], ifelse($1, no, no, yes))dnl\n+AC_ARG_ENABLE(static,\n+changequote(<<, >>)dnl\n+<<  --enable-static[=PKGS]  build static libraries [default=>>AC_ENABLE_STATIC_DEFAULT],\n+changequote([, ])dnl\n+[p=${PACKAGE-default}\n+case \"$enableval\" in\n+yes) enable_static=yes ;;\n+no) enable_static=no ;;\n+*)\n+  enable_static=no\n+  # Look at the argument we got.  We use all the common list separators.\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:,\"\n+  for pkg in $enableval; do\n+    if test \"X$pkg\" = \"X$p\"; then\n+      enable_static=yes\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+  ;;\n+esac],\n+enable_static=AC_ENABLE_STATIC_DEFAULT)dnl\n+])\n+\n+# AC_DISABLE_STATIC - set the default static flag to --disable-static\n+AC_DEFUN(AC_DISABLE_STATIC, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+AC_ENABLE_STATIC(no)])\n+\n+\n+# AC_ENABLE_FAST_INSTALL - implement the --enable-fast-install flag\n+# Usage: AC_ENABLE_FAST_INSTALL[(DEFAULT)]\n+#   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to\n+#   `yes'.\n+AC_DEFUN(AC_ENABLE_FAST_INSTALL, [dnl\n+define([AC_ENABLE_FAST_INSTALL_DEFAULT], ifelse($1, no, no, yes))dnl\n+AC_ARG_ENABLE(fast-install,\n+changequote(<<, >>)dnl\n+<<  --enable-fast-install[=PKGS]  optimize for fast installation [default=>>AC_ENABLE_FAST_INSTALL_DEFAULT],\n+changequote([, ])dnl\n+[p=${PACKAGE-default}\n+case \"$enableval\" in\n+yes) enable_fast_install=yes ;;\n+no) enable_fast_install=no ;;\n+*)\n+  enable_fast_install=no\n+  # Look at the argument we got.  We use all the common list separators.\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:,\"\n+  for pkg in $enableval; do\n+    if test \"X$pkg\" = \"X$p\"; then\n+      enable_fast_install=yes\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+  ;;\n+esac],\n+enable_fast_install=AC_ENABLE_FAST_INSTALL_DEFAULT)dnl\n+])\n+\n+# AC_ENABLE_FAST_INSTALL - set the default to --disable-fast-install\n+AC_DEFUN(AC_DISABLE_FAST_INSTALL, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+AC_ENABLE_FAST_INSTALL(no)])\n+\n+# AC_PROG_LD - find the path to the GNU or non-GNU linker\n+AC_DEFUN(AC_PROG_LD,\n+[AC_ARG_WITH(gnu-ld,\n+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],\n+test \"$withval\" = no || with_gnu_ld=yes, with_gnu_ld=no)\n+AC_REQUIRE([AC_PROG_CC])dnl\n+AC_REQUIRE([AC_CANONICAL_HOST])dnl\n+AC_REQUIRE([AC_CANONICAL_BUILD])dnl\n+ac_prog=ld\n+if test \"$ac_cv_prog_gcc\" = yes; then\n+  # Check if gcc -print-prog-name=ld gives a path.\n+  AC_MSG_CHECKING([for ld used by GCC])\n+  ac_prog=`($CC -print-prog-name=ld) 2>&5`\n+  case \"$ac_prog\" in\n+    # Accept absolute paths.\n+changequote(,)dnl\n+    [\\\\/]* | [A-Za-z]:[\\\\/]*)\n+      re_direlt='/[^/][^/]*/\\.\\./'\n+changequote([,])dnl\n+      # Canonicalize the path of ld\n+      ac_prog=`echo $ac_prog| sed 's%\\\\\\\\%/%g'`\n+      while echo $ac_prog | grep \"$re_direlt\" > /dev/null 2>&1; do\n+\tac_prog=`echo $ac_prog| sed \"s%$re_direlt%/%\"`\n+      done\n+      test -z \"$LD\" && LD=\"$ac_prog\"\n+      ;;\n+  \"\")\n+    # If it fails, then pretend we aren't using GCC.\n+    ac_prog=ld\n+    ;;\n+  *)\n+    # If it is relative, then search for the first ld in PATH.\n+    with_gnu_ld=unknown\n+    ;;\n+  esac\n+elif test \"$with_gnu_ld\" = yes; then\n+  AC_MSG_CHECKING([for GNU ld])\n+else\n+  AC_MSG_CHECKING([for non-GNU ld])\n+fi\n+AC_CACHE_VAL(ac_cv_path_LD,\n+[if test -z \"$LD\"; then\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}${PATH_SEPARATOR-:}\"\n+  for ac_dir in $PATH; do\n+    test -z \"$ac_dir\" && ac_dir=.\n+    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n+      ac_cv_path_LD=\"$ac_dir/$ac_prog\"\n+      # Check to see if the program is GNU ld.  I'd rather use --version,\n+      # but apparently some GNU ld's only accept -v.\n+      # Break only if it was the GNU/non-GNU ld that we prefer.\n+      if \"$ac_cv_path_LD\" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then\n+\ttest \"$with_gnu_ld\" != no && break\n+      else\n+\ttest \"$with_gnu_ld\" != yes && break\n+      fi\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+else\n+  ac_cv_path_LD=\"$LD\" # Let the user override the test with a path.\n+fi])\n+LD=\"$ac_cv_path_LD\"\n+if test -n \"$LD\"; then\n+  AC_MSG_RESULT($LD)\n+else\n+  AC_MSG_RESULT(no)\n+fi\n+test -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n+AC_PROG_LD_GNU\n+])\n+\n+AC_DEFUN(AC_PROG_LD_GNU,\n+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], ac_cv_prog_gnu_ld,\n+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.\n+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then\n+  ac_cv_prog_gnu_ld=yes\n+else\n+  ac_cv_prog_gnu_ld=no\n+fi])\n+])\n+\n+# AC_PROG_NM - find the path to a BSD-compatible name lister\n+AC_DEFUN(AC_PROG_NM,\n+[AC_MSG_CHECKING([for BSD-compatible nm])\n+AC_CACHE_VAL(ac_cv_path_NM,\n+[if test -n \"$NM\"; then\n+  # Let the user override the test.\n+  ac_cv_path_NM=\"$NM\"\n+else\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}${PATH_SEPARATOR-:}\"\n+  for ac_dir in $PATH /usr/ccs/bin /usr/ucb /bin; do\n+    test -z \"$ac_dir\" && ac_dir=.\n+    if test -f $ac_dir/nm || test -f $ac_dir/nm$ac_exeext ; then\n+      # Check to see if the nm accepts a BSD-compat flag.\n+      # Adding the `sed 1q' prevents false positives on HP-UX, which says:\n+      #   nm: unknown option \"B\" ignored\n+      if ($ac_dir/nm -B /dev/null 2>&1 | sed '1q'; exit 0) | egrep /dev/null >/dev/null; then\n+\tac_cv_path_NM=\"$ac_dir/nm -B\"\n+\tbreak\n+      elif ($ac_dir/nm -p /dev/null 2>&1 | sed '1q'; exit 0) | egrep /dev/null >/dev/null; then\n+\tac_cv_path_NM=\"$ac_dir/nm -p\"\n+\tbreak\n+      else\n+\tac_cv_path_NM=${ac_cv_path_NM=\"$ac_dir/nm\"} # keep the first match, but\n+\tcontinue # so that we can try to find one that supports BSD flags\n+      fi\n+    fi\n+  done\n+  IFS=\"$ac_save_ifs\"\n+  test -z \"$ac_cv_path_NM\" && ac_cv_path_NM=nm\n+fi])\n+NM=\"$ac_cv_path_NM\"\n+AC_MSG_RESULT([$NM])\n+])\n+\n+# AC_CHECK_LIBM - check for math library\n+AC_DEFUN(AC_CHECK_LIBM,\n+[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n+LIBM=\n+case \"$lt_target\" in\n+*-*-beos* | *-*-cygwin*)\n+  # These system don't have libm\n+  ;;\n+*-ncr-sysv4.3*)\n+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n+  AC_CHECK_LIB(m, main, LIBM=\"$LIBM -lm\")\n+  ;;\n+*)\n+  AC_CHECK_LIB(m, main, LIBM=\"-lm\")\n+  ;;\n+esac\n+])\n+\n+# AC_LIBLTDL_CONVENIENCE[(dir)] - sets LIBLTDL to the link flags for\n+# the libltdl convenience library, adds --enable-ltdl-convenience to\n+# the configure arguments.  Note that LIBLTDL is not AC_SUBSTed, nor\n+# is AC_CONFIG_SUBDIRS called.  If DIR is not provided, it is assumed\n+# to be `${top_builddir}/libltdl'.  Make sure you start DIR with\n+# '${top_builddir}/' (note the single quotes!) if your package is not\n+# flat, and, if you're not using automake, define top_builddir as\n+# appropriate in the Makefiles.\n+AC_DEFUN(AC_LIBLTDL_CONVENIENCE, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+  case \"$enable_ltdl_convenience\" in\n+  no) AC_MSG_ERROR([this package needs a convenience libltdl]) ;;\n+  \"\") enable_ltdl_convenience=yes\n+      ac_configure_args=\"$ac_configure_args --enable-ltdl-convenience\" ;;\n+  esac\n+  LIBLTDL=ifelse($#,1,$1,['${top_builddir}/libltdl'])/libltdlc.la\n+  INCLTDL=ifelse($#,1,-I$1,['-I${top_builddir}/libltdl'])\n+])\n+\n+# AC_LIBLTDL_INSTALLABLE[(dir)] - sets LIBLTDL to the link flags for\n+# the libltdl installable library, and adds --enable-ltdl-install to\n+# the configure arguments.  Note that LIBLTDL is not AC_SUBSTed, nor\n+# is AC_CONFIG_SUBDIRS called.  If DIR is not provided, it is assumed\n+# to be `${top_builddir}/libltdl'.  Make sure you start DIR with\n+# '${top_builddir}/' (note the single quotes!) if your package is not\n+# flat, and, if you're not using automake, define top_builddir as\n+# appropriate in the Makefiles.\n+# In the future, this macro may have to be called after AC_PROG_LIBTOOL.\n+AC_DEFUN(AC_LIBLTDL_INSTALLABLE, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+  AC_CHECK_LIB(ltdl, main,\n+  [test x\"$enable_ltdl_install\" != xyes && enable_ltdl_install=no],\n+  [if test x\"$enable_ltdl_install\" = xno; then\n+     AC_MSG_WARN([libltdl not installed, but installation disabled])\n+   else\n+     enable_ltdl_install=yes\n+   fi\n+  ])\n+  if test x\"$enable_ltdl_install\" = x\"yes\"; then\n+    ac_configure_args=\"$ac_configure_args --enable-ltdl-install\"\n+    LIBLTDL=ifelse($#,1,$1,['${top_builddir}/libltdl'])/libltdl.la\n+    INCLTDL=ifelse($#,1,-I$1,['-I${top_builddir}/libltdl'])\n+  else\n+    ac_configure_args=\"$ac_configure_args --enable-ltdl-install=no\"\n+    LIBLTDL=\"-lltdl\"\n+    INCLTDL=\n+  fi\n+])\n+\n+dnl old names\n+AC_DEFUN(AM_PROG_LIBTOOL, [indir([AC_PROG_LIBTOOL])])dnl\n+AC_DEFUN(AM_ENABLE_SHARED, [indir([AC_ENABLE_SHARED], $@)])dnl\n+AC_DEFUN(AM_ENABLE_STATIC, [indir([AC_ENABLE_STATIC], $@)])dnl\n+AC_DEFUN(AM_DISABLE_SHARED, [indir([AC_DISABLE_SHARED], $@)])dnl\n+AC_DEFUN(AM_DISABLE_STATIC, [indir([AC_DISABLE_STATIC], $@)])dnl\n+AC_DEFUN(AM_PROG_LD, [indir([AC_PROG_LD])])dnl\n+AC_DEFUN(AM_PROG_NM, [indir([AC_PROG_NM])])dnl\n+\n+dnl This is just to silence aclocal about the macro not being used\n+ifelse([AC_DISABLE_FAST_INSTALL])dnl"}, {"sha": "a01334f9212c3a8e6a99db2b4d21f3380ccbfe80", "filename": "boehm-gc/ltconfig", "status": "added", "additions": 3078, "deletions": 0, "changes": 3078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fltconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fltconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fltconfig?ref=61f38a77a0c4f467c59707ce434d34eae52d6692"}, {"sha": "50515ad0b9ee92bb43e26ec0df55270fb013ff0f", "filename": "boehm-gc/ltmain.sh", "status": "added", "additions": 4012, "deletions": 0, "changes": 4012, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fltmain.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fltmain.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fltmain.sh?ref=61f38a77a0c4f467c59707ce434d34eae52d6692"}, {"sha": "cc8783edce301ef5e36ec6b3ca54bf347ed77be4", "filename": "boehm-gc/mkinstalldirs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fmkinstalldirs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f38a77a0c4f467c59707ce434d34eae52d6692/boehm-gc%2Fmkinstalldirs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmkinstalldirs?ref=61f38a77a0c4f467c59707ce434d34eae52d6692", "patch": "@@ -0,0 +1,36 @@\n+#! /bin/sh\n+# mkinstalldirs --- make directory hierarchy\n+# Author: Noah Friedman <friedman@prep.ai.mit.edu>\n+# Created: 1993-05-16\n+# Last modified: 1994-03-25\n+# Public domain\n+\n+errstatus=0\n+\n+for file in ${1+\"$@\"} ; do \n+   set fnord `echo \":$file\" | sed -ne 's/^:\\//#/;s/^://;s/\\// /g;s/^#/\\//;p'`\n+   shift\n+\n+   pathcomp=\n+   for d in ${1+\"$@\"} ; do\n+     pathcomp=\"$pathcomp$d\"\n+     case \"$pathcomp\" in\n+       -* ) pathcomp=./$pathcomp ;;\n+     esac\n+\n+     if test ! -d \"$pathcomp\"; then\n+        echo \"mkdir $pathcomp\" 1>&2\n+        mkdir \"$pathcomp\" > /dev/null 2>&1 || lasterr=$?\n+     fi\n+\n+     if test ! -d \"$pathcomp\"; then\n+\terrstatus=$lasterr\n+     fi\n+\n+     pathcomp=\"$pathcomp/\"\n+   done\n+done\n+\n+exit $errstatus\n+\n+# mkinstalldirs ends here"}]}