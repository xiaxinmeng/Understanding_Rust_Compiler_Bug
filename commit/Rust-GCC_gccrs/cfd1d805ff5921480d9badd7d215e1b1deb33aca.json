{"sha": "cfd1d805ff5921480d9badd7d215e1b1deb33aca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZkMWQ4MDVmZjU5MjE0ODBkOWJhZGQ3ZDIxNWUxYjFkZWIzM2FjYQ==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-09T08:40:23Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2021-02-09T08:40:23Z"}, "message": "Unified Tokens partially in preparation for macro expansion", "tree": {"sha": "12a37dff57cc99e26f36acda1083b84b4887fcd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12a37dff57cc99e26f36acda1083b84b4887fcd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfd1d805ff5921480d9badd7d215e1b1deb33aca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfd1d805ff5921480d9badd7d215e1b1deb33aca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfd1d805ff5921480d9badd7d215e1b1deb33aca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfd1d805ff5921480d9badd7d215e1b1deb33aca/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f97711dce5c48e46a9a64c5517fa6ae10db5e04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f97711dce5c48e46a9a64c5517fa6ae10db5e04"}], "stats": {"total": 242, "additions": 63, "deletions": 179}, "files": [{"sha": "2c196a07e03465201c83937d01f4e3606fcba09f", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=cfd1d805ff5921480d9badd7d215e1b1deb33aca", "patch": "@@ -290,13 +290,17 @@ DelimTokenTree::as_string () const\n std::string\n Token::as_string () const\n {\n-  /* FIXME: only works when not identifier or literal or whatever, i.e. when\n-   * doesn't store string value */\n-  // return get_token_description(token_id);\n+  if (tok_ref->has_str ())\n+    {\n+      std::string str = tok_ref->get_str ();\n \n-  // maybe fixed - stores everything as string though, so storage-inefficient\n-  std::string quote = is_string_lit () ? \"\\\"\" : \"\";\n-  return quote + str + quote;\n+      std::string quote = is_string_lit () ? \"\\\"\" : \"\";\n+      return quote + str + quote;\n+    }\n+  else\n+    {\n+      return tok_ref->get_token_description ();\n+    }\n }\n \n std::string\n@@ -4375,9 +4379,10 @@ DelimTokenTree::to_token_stream () const\n   std::vector<std::unique_ptr<Token> > tokens;\n \n   // simulate presence of delimiters\n+  const_TokenPtr left_paren\n+    = Rust::Token::make (LEFT_PAREN, Linemap::unknown_location ());\n   tokens.push_back (\n-    std::unique_ptr<Token> (new Token (LEFT_PAREN, Linemap::unknown_location (),\n-\t\t\t\t       \"\", CORETYPE_UNKNOWN)));\n+    std::unique_ptr<Token> (new Token (std::move (left_paren))));\n \n   for (const auto &tree : token_trees)\n     {\n@@ -4387,9 +4392,10 @@ DelimTokenTree::to_token_stream () const\n \t\t     std::make_move_iterator (stream.end ()));\n     }\n \n-  tokens.push_back (std::unique_ptr<Token> (\n-    new Token (RIGHT_PAREN, Linemap::unknown_location (), \"\",\n-\t       CORETYPE_UNKNOWN)));\n+  const_TokenPtr right_paren\n+    = Rust::Token::make (RIGHT_PAREN, Linemap::unknown_location ());\n+  tokens.push_back (\n+    std::unique_ptr<Token> (new Token (std::move (right_paren))));\n \n   tokens.shrink_to_fit ();\n \n@@ -4545,8 +4551,7 @@ AttrInputMetaItemContainer::check_cfg_predicate (const Session &session) const\n }\n \n bool\n-MetaItemLitExpr::check_cfg_predicate (\n-  const Session &session ATTRIBUTE_UNUSED) const\n+MetaItemLitExpr::check_cfg_predicate (const Session &) const\n {\n   /* as far as I can tell, a literal expr can never be a valid cfg body, so\n    * false */\n@@ -4653,10 +4658,7 @@ bool\n MetaListPaths::check_path_exists_in_cfg (const Session &session,\n \t\t\t\t\t const SimplePath &path) const\n {\n-  auto it = session.options.target_data.features.find (path.as_string ());\n-  if (it != session.options.target_data.features.end ())\n-    return true;\n-  return false;\n+  return session.options.target_data.has_key (path.as_string ());\n }\n \n bool\n@@ -4710,10 +4712,7 @@ MetaItemSeq::check_cfg_predicate (const Session &session) const\n bool\n MetaWord::check_cfg_predicate (const Session &session) const\n {\n-  auto it = session.options.target_data.features.find (ident);\n-  if (it != session.options.target_data.features.end ())\n-    return true;\n-  return false;\n+  return session.options.target_data.has_key (ident);\n }\n \n bool\n@@ -4723,10 +4722,7 @@ MetaItemPath::check_cfg_predicate (const Session &session) const\n    * relating to SimplePath being identifier. Currently, it would return true\n    * if path as identifier existed, and if the path in string form existed\n    * (though this shouldn't occur). */\n-  auto it = session.options.target_data.features.find (path.as_string ());\n-  if (it != session.options.target_data.features.end ())\n-    return true;\n-  return false;\n+  return session.options.target_data.has_key (path.as_string ());\n }\n \n bool\n@@ -4853,8 +4849,8 @@ AttrInputMetaItemContainer::separate_cfg_attrs () const\n       Attribute attr = (*it)->to_attribute ();\n       if (attr.is_empty ())\n \t{\n-\t  // TODO should this be an error that causes us to chuck out\n-\t  // everything?\n+\t  /* TODO should this be an error that causes us to chuck out\n+\t   * everything? */\n \t  continue;\n \t}\n       attrs.push_back (std::move (attr));"}, {"sha": "14816e20785d806708a0994c96eba9eb9c22d9f1", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 28, "deletions": 113, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=cfd1d805ff5921480d9badd7d215e1b1deb33aca", "patch": "@@ -129,6 +129,7 @@ class Token : public TokenTree, public MacroMatch\n {\n   // A token is a kind of token tree (except delimiter tokens)\n   // A token is a kind of MacroMatch (except $ and delimiter tokens)\n+#if 0\n   // TODO: improve member variables - current ones are the same as lexer token\n   // Token kind.\n   TokenId token_id;\n@@ -138,6 +139,13 @@ class Token : public TokenTree, public MacroMatch\n   std::string str;\n   // Token type hint (if any).\n   PrimitiveCoreType type_hint;\n+#endif\n+\n+  const_TokenPtr tok_ref;\n+\n+  /* new idea: wrapper around const_TokenPtr used for heterogeneuous storage in\n+   * token trees. rather than convert back and forth when parsing macros, just \n+   * wrap it. */\n \n public:\n   // Unique pointer custom clone function\n@@ -146,15 +154,19 @@ class Token : public TokenTree, public MacroMatch\n     return std::unique_ptr<Token> (clone_token_impl ());\n   }\n \n+#if 0\n   /* constructor from general text - avoid using if lexer const_TokenPtr is\n    * available */\n   Token (TokenId token_id, Location locus, std::string str,\n \t PrimitiveCoreType type_hint)\n     : token_id (token_id), locus (locus), str (std::move (str)),\n       type_hint (type_hint)\n   {}\n+#endif\n+  // not doable with new implementation - will have to make a const_TokenPtr\n \n   // Constructor from lexer const_TokenPtr\n+#if 0\n   /* TODO: find workaround for std::string being nullptr - probably have to\n    * introduce new method in lexer Token, or maybe make conversion method\n    * there */\n@@ -188,10 +200,12 @@ class Token : public TokenTree, public MacroMatch\n \t\t lexer_token_ptr->get_token_description ());\n       }\n   }\n+#endif\n+  Token (const_TokenPtr lexer_tok_ptr) : tok_ref (std::move (lexer_tok_ptr)) {}\n \n   bool is_string_lit () const\n   {\n-    switch (token_id)\n+    switch (get_id ())\n       {\n       case STRING_LITERAL:\n       case BYTE_STRING_LITERAL:\n@@ -208,11 +222,14 @@ class Token : public TokenTree, public MacroMatch\n   // Return copy of itself but in token stream form.\n   std::vector<std::unique_ptr<Token> > to_token_stream () const override;\n \n-  TokenId get_id () const { return token_id; }\n+  TokenId get_id () const { return tok_ref->get_id (); }\n \n-  Location get_locus () const { return locus; }\n+  Location get_locus () const { return tok_ref->get_locus (); }\n \n-  PrimitiveCoreType get_type_hint () const { return type_hint; }\n+  PrimitiveCoreType get_type_hint () const { return tok_ref->get_type_hint (); }\n+\n+  // Get a new token pointer copy.\n+  const_TokenPtr get_tok_ptr () const { return tok_ref; }\n \n protected:\n   // No virtual for now as not polymorphic but can be in future\n@@ -1190,15 +1207,8 @@ class GenericParam\n class LifetimeParam : public GenericParam\n {\n   Lifetime lifetime;\n-\n-  // bool has_lifetime_bounds;\n-  // LifetimeBounds lifetime_bounds;\n-  std::vector<Lifetime> lifetime_bounds; // inlined LifetimeBounds\n-\n-  // bool has_outer_attribute;\n-  // std::unique_ptr<Attribute> outer_attr;\n+  std::vector<Lifetime> lifetime_bounds; \n   Attribute outer_attr;\n-\n   Location locus;\n \n public:\n@@ -1211,45 +1221,21 @@ class LifetimeParam : public GenericParam\n   // Creates an error state lifetime param.\n   static LifetimeParam create_error ()\n   {\n-    return LifetimeParam (Lifetime::error ());\n+    return LifetimeParam (Lifetime::error (), {}, Attribute::create_empty (), Location ());\n   }\n \n   // Returns whether the lifetime param is in an error state.\n   bool is_error () const { return lifetime.is_error (); }\n \n   // Constructor\n-  LifetimeParam (Lifetime lifetime, Location locus = Location (),\n-\t\t std::vector<Lifetime> lifetime_bounds\n-\t\t = std::vector<Lifetime> (),\n-\t\t Attribute outer_attr = Attribute::create_empty ())\n+  LifetimeParam (Lifetime lifetime, \n+\t\t std::vector<Lifetime> lifetime_bounds,\n+\t\t Attribute outer_attr, Location locus)\n     : lifetime (std::move (lifetime)),\n       lifetime_bounds (std::move (lifetime_bounds)),\n       outer_attr (std::move (outer_attr)), locus (locus)\n   {}\n \n-  // TODO: remove copy and assignment operator definitions - not required\n-\n-  // Copy constructor with clone\n-  LifetimeParam (LifetimeParam const &other)\n-    : lifetime (other.lifetime), lifetime_bounds (other.lifetime_bounds),\n-      outer_attr (other.outer_attr), locus (other.locus)\n-  {}\n-\n-  // Overloaded assignment operator to clone attribute\n-  LifetimeParam &operator= (LifetimeParam const &other)\n-  {\n-    lifetime = other.lifetime;\n-    lifetime_bounds = other.lifetime_bounds;\n-    outer_attr = other.outer_attr;\n-    locus = other.locus;\n-\n-    return *this;\n-  }\n-\n-  // move constructors\n-  LifetimeParam (LifetimeParam &&other) = default;\n-  LifetimeParam &operator= (LifetimeParam &&other) = default;\n-\n   std::string as_string () const override;\n \n   void accept_vis (ASTVisitor &vis) override;\n@@ -1263,28 +1249,13 @@ class LifetimeParam : public GenericParam\n   }\n };\n \n-// A macro item AST node - potentially abstract base class\n+// A macro item AST node - abstract base class\n class MacroItem : public Item\n-{\n-  /*public:\n-  std::string as_string() const;*/\n-  // std::vector<Attribute> outer_attrs;\n-\n-protected:\n-  /*MacroItem (std::vector<Attribute> outer_attribs)\n-    : outer_attrs (std::move (outer_attribs))\n-  {}*/\n-};\n+{};\n \n // Item used in trait declarations - abstract base class\n class TraitItem\n {\n-  // bool has_outer_attrs;\n-  // TODO: remove and rely on virtual functions and VisItem-derived attributes?\n-  // std::vector<Attribute> outer_attrs;\n-\n-  // NOTE: all children should have outer attributes\n-\n protected:\n   // Clone function implementation as pure virtual method\n   virtual TraitItem *clone_trait_item_impl () const = 0;\n@@ -1468,69 +1439,18 @@ class MacroInvocationSemi : public MacroItem,\n \t\t\t    public ExternalItem\n {\n   std::vector<Attribute> outer_attrs;\n-#if 0\n-  SimplePath path;\n-  // all delim types except curly must have invocation end with a semicolon\n-  DelimType delim_type;\n-  std::vector<std::unique_ptr<TokenTree> > token_trees;\n-#endif\n   MacroInvocData invoc_data;\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  /*MacroInvocationSemi (SimplePath macro_path, DelimType delim_type,\n-\t\t       std::vector<std::unique_ptr<TokenTree> > token_trees,\n-\t\t       std::vector<Attribute> outer_attribs, Location locus)\n-    : outer_attrs (std::move (outer_attribs)), path (std::move (macro_path)),\n-      delim_type (delim_type), token_trees (std::move (token_trees)),\n-      locus (locus)\n-  {}*/\n   MacroInvocationSemi (MacroInvocData invoc_data,\n \t\t       std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)),\n       invoc_data (std::move (invoc_data)), locus (locus)\n   {}\n \n-  /*\n-  // Copy constructor with vector clone\n-  MacroInvocationSemi (MacroInvocationSemi const &other)\n-    : MacroItem (other), TraitItem (other), InherentImplItem (other),\n-      TraitImplItem (other), outer_attrs (other.outer_attrs), path (other.path),\n-      delim_type (other.delim_type), locus (other.locus)\n-  {\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-  }*/\n-\n-  /*\n-  // Overloaded assignment operator to vector clone\n-  MacroInvocationSemi &operator= (MacroInvocationSemi const &other)\n-  {\n-    MacroItem::operator= (other);\n-    TraitItem::operator= (other);\n-    InherentImplItem::operator= (other);\n-    TraitImplItem::operator= (other);\n-    outer_attrs = other.outer_attrs;\n-    path = other.path;\n-    delim_type = other.delim_type;\n-    locus = other.locus;\n-\n-    token_trees.reserve (other.token_trees.size ());\n-    for (const auto &e : other.token_trees)\n-      token_trees.push_back (e->clone_token_tree ());\n-\n-    return *this;\n-  }*/\n-\n-  /*\n-  // Move constructors\n-  MacroInvocationSemi (MacroInvocationSemi &&other) = default;\n-  MacroInvocationSemi &operator= (MacroInvocationSemi &&other) = default;\n-  */\n-\n   void accept_vis (ASTVisitor &vis) override;\n \n   // Clones this macro invocation semi.\n@@ -1540,11 +1460,6 @@ class MacroInvocationSemi : public MacroItem,\n       clone_macro_invocation_semi_impl ());\n   }\n \n-  /*\n-  // Invalid if path is empty, so base stripping on that.\n-  void mark_for_strip () override { path = SimplePath::create_empty (); }\n-  bool is_marked_for_strip () const override { return path.is_empty (); }\n-  */\n   void mark_for_strip () override { invoc_data.mark_for_strip (); }\n   bool is_marked_for_strip () const override\n   {"}, {"sha": "51220e470033f4e74d65fac7e7c05435b3f48977", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=cfd1d805ff5921480d9badd7d215e1b1deb33aca", "patch": "@@ -361,19 +361,12 @@ class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic ExprWithoutBlock\n {\n   std::vector<Attribute> outer_attrs;\n-  /*SimplePath path;\n-  DelimTokenTree token_tree;*/\n   MacroInvocData invoc_data;\n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  /*MacroInvocation (SimplePath path, DelimTokenTree token_tree,\n-\t\t   std::vector<Attribute> outer_attrs, Location locus)\n-    : ExprWithoutBlock (std::move (outer_attrs)), path (std::move (path)),\n-      token_tree (std::move (token_tree)), locus (locus)\n-  {}*/\n   MacroInvocation (MacroInvocData invoc_data,\n \t\t   std::vector<Attribute> outer_attrs, Location locus)\n     : outer_attrs (std::move (outer_attrs)),\n@@ -694,11 +687,8 @@ struct ASTFragment\n struct MacroParser\n {\n private:\n+  // TODO: might as well rewrite to use lexer tokens\n   std::vector<std::unique_ptr<Token> > token_stream;\n-  /* probably have to make this mutable (mutable int stream_pos) otherwise const\n-   * has to be removed up to DelimTokenTree or further ok since this changing\n-   * would have an effect on the results of the methods run (i.e. not logically\n-   * const), the parsing methods shouldn't be const */\n   int stream_pos;\n \n public:"}, {"sha": "6070244959396240ef2b5aef875be545cc9a2ae8", "filename": "gcc/rust/lex/rust-token.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=cfd1d805ff5921480d9badd7d215e1b1deb33aca", "patch": "@@ -317,13 +317,6 @@ class Token\n     return TokenPtr (new Token (IDENTIFIER, locus, str));\n   }\n \n-  // Makes and returns a new TokenPtr of type INT_LITERAL.\n-  /*static TokenPtr make_int (Location locus, const std::string &str)\n-  {\n-    //return TokenPtr (new Token (INT_LITERAL, locus, str));\n-    return std::make_shared<Token>(INT_LITERAL, locus, str);\n-  }*/\n-\n   // Makes and returns a new TokenPtr of type INT_LITERAL.\n   static TokenPtr make_int (Location locus, const std::string &str,\n \t\t\t    PrimitiveCoreType type_hint = CORETYPE_UNKNOWN)\n@@ -332,13 +325,6 @@ class Token\n     return TokenPtr (new Token (INT_LITERAL, locus, str, type_hint));\n   }\n \n-  // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n-  /*static TokenPtr make_float (Location locus, const std::string &str)\n-  {\n-    return TokenPtr (new Token (FLOAT_LITERAL, locus, str));\n-    return std::make_shared<Token>(FLOAT_LITERAL, locus, str);\n-  }*/\n-\n   // Makes and returns a new TokenPtr of type FLOAT_LITERAL.\n   static TokenPtr make_float (Location locus, const std::string &str,\n \t\t\t      PrimitiveCoreType type_hint = CORETYPE_UNKNOWN)"}, {"sha": "4a9f3a3f63b71740a6fe5f5dc4d6af3f45a633b5", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfd1d805ff5921480d9badd7d215e1b1deb33aca/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=cfd1d805ff5921480d9badd7d215e1b1deb33aca", "patch": "@@ -972,8 +972,7 @@ Parser<ManagedTokenSource>::parse_token_tree ()\n     default:\n       // parse token itself as TokenTree\n       lexer.skip_token ();\n-      // TODO: fix that token constructor, possibly with c++11 features\n-      return std::unique_ptr<AST::Token> (new AST::Token (t));\n+      return std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n     }\n }\n \n@@ -1805,7 +1804,7 @@ Parser<ManagedTokenSource>::parse_macro_match ()\n     default:\n       // just the token\n       lexer.skip_token ();\n-      return std::unique_ptr<AST::Token> (new AST::Token (t));\n+      return std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n     }\n }\n \n@@ -1913,7 +1912,7 @@ Parser<ManagedTokenSource>::parse_macro_match_repetition ()\n       break;\n     default:\n       // separator does exist\n-      separator = std::unique_ptr<AST::Token> (new AST::Token (t));\n+      separator = std::unique_ptr<AST::Token> (new AST::Token (std::move (t)));\n       lexer.skip_token ();\n       break;\n     }\n@@ -2665,9 +2664,9 @@ Parser<ManagedTokenSource>::parse_generic_params ()\n \t}\n \n       std::unique_ptr<AST::LifetimeParam> param (\n-\tnew AST::LifetimeParam (std::move (lifetime), locus,\n+\tnew AST::LifetimeParam (std::move (lifetime), \n \t\t\t\tstd::move (lifetime_bounds),\n-\t\t\t\tstd::move (outer_attr)));\n+\t\t\t\tstd::move (outer_attr), locus));\n       generic_params.push_back (std::move (param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n@@ -2841,9 +2840,9 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n \t}\n \n       std::unique_ptr<AST::LifetimeParam> param (\n-\tnew AST::LifetimeParam (std::move (lifetime), locus,\n+\tnew AST::LifetimeParam (std::move (lifetime),\n \t\t\t\tstd::move (lifetime_bounds),\n-\t\t\t\tstd::move (outer_attr)));\n+\t\t\t\tstd::move (outer_attr), locus));\n       generic_params.push_back (std::move (param));\n \n       if (lexer.peek_token ()->get_id () != COMMA)\n@@ -3166,9 +3165,9 @@ Parser<ManagedTokenSource>::parse_lifetime_param ()\n       // TODO: have end token passed in?\n     }\n \n-  return AST::LifetimeParam (std::move (lifetime), lifetime_tok->get_locus (),\n+  return AST::LifetimeParam (std::move (lifetime), \n \t\t\t     std::move (lifetime_bounds),\n-\t\t\t     std::move (outer_attr));\n+\t\t\t     std::move (outer_attr), lifetime_tok->get_locus ());\n }\n \n // Parses type generic parameters. Will also consume any trailing comma.\n@@ -3693,13 +3692,11 @@ Parser<ManagedTokenSource>::parse_trait_bound ()\n       lexer.skip_token ();\n     }\n \n-  // parse for lifetimes, if it exists (although empty for lifetimes is ok to\n-  // handle this)\n+  /* parse for lifetimes, if it exists (although empty for lifetimes is ok to\n+   * handle this) */\n   std::vector<AST::LifetimeParam> for_lifetimes;\n   if (lexer.peek_token ()->get_id () == FOR)\n-    {\n       for_lifetimes = parse_for_lifetimes ();\n-    }\n \n   // handle TypePath\n   AST::TypePath type_path = parse_type_path ();"}]}