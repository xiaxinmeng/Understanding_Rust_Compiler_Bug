{"sha": "6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFlMDM2YjMzMDAwNDE0ZjI3M2I5YWQyYTdjYTdjMWE2NjhkMGIzMQ==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2017-06-13T17:18:51Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2017-06-13T17:18:51Z"}, "message": "rs6000: Comment fixes + some leftovers\n\n\n\t* config/rs6000/rs6000.c: Update all comments that mentioned SPE.\n\t(rs6000_expand_builtin): Remove RS6000_BTC_EVSEL.\n\t* config/rs6000/rs6000.h (RS6000_BTC_EVSEL): Delete.\n\t* config/rs6000/vxworks.h (VXCPU_FOR_8548): Delete.  Adjust former use.\n\t* config/rs6000/vxworksae.h (VXCPU_FOR_8548): Delete.\n\t* config/rs6000/vxworksmils.h (VXCPU_FOR_8548): Delete.\n\nFrom-SVN: r249170", "tree": {"sha": "7fe0577bf2dbbd002652290ad4898bb64c7a94fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fe0577bf2dbbd002652290ad4898bb64c7a94fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d20ae4d7dab9768e5698f948e18ef2bb3042451d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d20ae4d7dab9768e5698f948e18ef2bb3042451d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d20ae4d7dab9768e5698f948e18ef2bb3042451d"}], "stats": {"total": 109, "additions": 42, "deletions": 67}, "files": [{"sha": "ab872e158cc4a90f2e6caf8c7caf7840dfe11d8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "patch": "@@ -1,3 +1,12 @@\n+2017-06-13  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000.c: Update all comments that mentioned SPE.\n+\t(rs6000_expand_builtin): Remove RS6000_BTC_EVSEL.\n+\t* config/rs6000/rs6000.h (RS6000_BTC_EVSEL): Delete.\n+\t* config/rs6000/vxworks.h (VXCPU_FOR_8548): Delete.  Adjust former use.\n+\t* config/rs6000/vxworksae.h (VXCPU_FOR_8548): Delete.\n+\t* config/rs6000/vxworksmils.h (VXCPU_FOR_8548): Delete.\n+\n 2017-06-13  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/rs6000-opts.h (enum rs6000_vector): Delete VECTOR_SPE."}, {"sha": "6b28658efa9d3fc668cafe0b54309f0bc06f68d5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 30, "deletions": 49, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "patch": "@@ -2014,10 +2014,6 @@ rs6000_cpu_name_lookup (const char *name)\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   For the SPE, GPRs are 64 bits but only 32 bits are visible in\n-   scalar instructions.  The upper 32 bits are only available to the\n-   SIMD instructions.\n-\n    POWER and PowerPC GPRs hold 32 bits worth;\n    PowerPC64 GPRs and FPRs point register holds 64 bits worth.  */\n \n@@ -2901,9 +2897,7 @@ rs6000_setup_reg_addr_masks (void)\n \t\taddr_mask |= RELOAD_REG_INDEXED;\n \n \t      /* Figure out if we can do PRE_INC, PRE_DEC, or PRE_MODIFY\n-\t\t addressing.  Restrict addressing on SPE for 64-bit types\n-\t\t because of the SUBREG hackery used to address 64-bit floats in\n-\t\t '32-bit' GPRs.  If we allow scalars into Altivec registers,\n+\t\t addressing.  If we allow scalars into Altivec registers,\n \t\t don't allow PRE_INC, PRE_DEC, or PRE_MODIFY.  */\n \n \t      if (TARGET_UPDATE\n@@ -3171,7 +3165,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n       rs6000_vector_align[TImode] = align64;\n     }\n \n-  /* TODO add SPE and paired floating point vector support.  */\n+  /* TODO add paired floating point vector support.  */\n \n   /* Register class constraints for the constraints that depend on compile\n      switches. When the VSX code was added, different constraints were added\n@@ -3827,8 +3821,7 @@ darwin_rs6000_override_options (void)\n \n /* Return the builtin mask of the various options used that could affect which\n    builtins were used.  In the past we used target_flags, but we've run out of\n-   bits, and some options like SPE and PAIRED are no longer in\n-   target_flags.  */\n+   bits, and some options like PAIRED are no longer in target_flags.  */\n \n HOST_WIDE_INT\n rs6000_builtin_mask_calculate (void)\n@@ -5479,8 +5472,7 @@ rs6000_option_override_internal (bool global_init_p)\n \n   /* Set the builtin mask of the various options used that could affect which\n      builtins were used.  In the past we used target_flags, but we've run out\n-     of bits, and some options like SPE and PAIRED are no longer in\n-     target_flags.  */\n+     of bits, and some options like PAIRED are no longer in target_flags.  */\n   rs6000_builtin_mask = rs6000_builtin_mask_calculate ();\n   if (TARGET_DEBUG_BUILTIN || TARGET_DEBUG_TARGET)\n     rs6000_print_builtin_options (stderr, 0, \"builtin mask\",\n@@ -11767,7 +11759,6 @@ function_arg_padding (machine_mode mode, const_tree type)\n    However, we're stuck with this because changing the ABI might break\n    existing library interfaces.\n \n-   Doubleword align SPE vectors.\n    Quadword align Altivec/VSX vectors.\n    Quadword align large synthetic vector types.   */\n \n@@ -12188,18 +12179,17 @@ rs6000_function_arg_advance_1 (CUMULATIVE_ARGS *cum, machine_mode mode,\n \t  int n_words = rs6000_arg_size (mode, type);\n \t  int gregno = cum->sysv_gregno;\n \n-\t  /* Long long and SPE vectors are put in (r3,r4), (r5,r6),\n-\t     (r7,r8) or (r9,r10).  As does any other 2 word item such\n-\t     as complex int due to a historical mistake.  */\n+\t  /* Long long is put in (r3,r4), (r5,r6), (r7,r8) or (r9,r10).\n+\t     As does any other 2 word item such as complex int due to a\n+\t     historical mistake.  */\n \t  if (n_words == 2)\n \t    gregno += (1 - gregno) & 1;\n \n \t  /* Multi-reg args are not split between registers and stack.  */\n \t  if (gregno + n_words - 1 > GP_ARG_MAX_REG)\n \t    {\n-\t      /* Long long and SPE vectors are aligned on the stack.\n-\t\t So are other 2 word items such as complex int due to\n-\t\t a historical mistake.  */\n+\t      /* Long long is aligned on the stack.  So are other 2 word\n+\t\t items such as complex int due to a historical mistake.  */\n \t      if (n_words == 2)\n \t\tcum->words += cum->words & 1;\n \t      cum->words += n_words;\n@@ -12736,9 +12726,9 @@ rs6000_function_arg (cumulative_args_t cum_v, machine_mode mode,\n \t  int n_words = rs6000_arg_size (mode, type);\n \t  int gregno = cum->sysv_gregno;\n \n-\t  /* Long long and SPE vectors are put in (r3,r4), (r5,r6),\n-\t     (r7,r8) or (r9,r10).  As does any other 2 word item such\n-\t     as complex int due to a historical mistake.  */\n+\t  /* Long long is put in (r3,r4), (r5,r6), (r7,r8) or (r9,r10).\n+\t     As does any other 2 word item such as complex int due to a\n+\t     historical mistake.  */\n \t  if (n_words == 2)\n \t    gregno += (1 - gregno) & 1;\n \n@@ -13675,9 +13665,8 @@ rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n       lab_false = create_artificial_label (input_location);\n       lab_over = create_artificial_label (input_location);\n \n-      /* Long long and SPE vectors are aligned in the registers.\n-\t As are any other 2 gpr item such as complex int due to a\n-\t historical mistake.  */\n+      /* Long long is aligned in the registers.  As are any other 2 gpr\n+\t item such as complex int due to a historical mistake.  */\n       u = reg;\n       if (n_reg == 2 && reg == gpr)\n \t{\n@@ -16623,7 +16612,6 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \tcase RS6000_BTC_TERNARY:   name3 = \"ternary\";\tbreak;\n \tcase RS6000_BTC_PREDICATE: name3 = \"predicate\";\tbreak;\n \tcase RS6000_BTC_ABS:\t   name3 = \"abs\";\tbreak;\n-\tcase RS6000_BTC_EVSEL:\t   name3 = \"evsel\";\tbreak;\n \tcase RS6000_BTC_DST:\t   name3 = \"dst\";\tbreak;\n \t}\n \n@@ -17011,11 +16999,11 @@ rs6000_init_builtins (void)\n   pixel_V8HI_type_node = rs6000_vector_type (\"__vector __pixel\",\n \t\t\t\t\t     pixel_type_node, 8);\n \n-  /* Paired and SPE builtins are only available if you build a compiler with\n-     the appropriate options, so only create those builtins with the\n-     appropriate compiler option.  Create Altivec and VSX builtins on machines\n-     with at least the general purpose extensions (970 and newer) to allow the\n-     use of the target attribute.  */\n+  /* Paired builtins are only available if you build a compiler with the\n+     appropriate options, so only create those builtins with the appropriate\n+     compiler option.  Create Altivec and VSX builtins on machines with at\n+     least the general purpose extensions (970 and newer) to allow the use of\n+     the target attribute.  */\n   if (TARGET_PAIRED_FLOAT)\n     paired_init_builtins ();\n   if (TARGET_EXTRA_BUILTINS)\n@@ -18147,11 +18135,11 @@ rs6000_common_init_builtins (void)\n       builtin_mode_to_type[V2SFmode][0] = opaque_V2SF_type_node;\n     }\n \n-  /* Paired and SPE builtins are only available if you build a compiler with\n-     the appropriate options, so only create those builtins with the\n-     appropriate compiler option.  Create Altivec and VSX builtins on machines\n-     with at least the general purpose extensions (970 and newer) to allow the\n-     use of the target attribute..  */\n+  /* Paired builtins are only available if you build a compiler with the\n+     appropriate options, so only create those builtins with the appropriate\n+     compiler option.  Create Altivec and VSX builtins on machines with at\n+     least the general purpose extensions (970 and newer) to allow the use of\n+     the target attribute..  */\n \n   if (TARGET_EXTRA_BUILTINS)\n     builtin_mask |= RS6000_BTM_COMMON;\n@@ -18395,7 +18383,7 @@ rs6000_common_init_builtins (void)\n \t  mode0 = insn_data[icode].operand[0].mode;\n \t  if (mode0 == V2SImode)\n \t    {\n-\t      /* code for SPE */\n+\t      /* code for paired single */\n \t      if (! (type = v2si_ftype))\n \t\t{\n \t\t  v2si_ftype\n@@ -23109,7 +23097,7 @@ print_operand (FILE *file, rtx x, int code)\n \t}\n       return;\n \n-      /* Print AltiVec or SPE memory operand.  */\n+      /* Print AltiVec memory operand.  */\n     case 'y':\n       {\n \trtx tmp;\n@@ -26155,10 +26143,6 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \t\t+---------------------------------------+\n \t\t| Save area for VRSAVE register (Z)\t| 8+P+A+V+L+X+W+Y\n \t\t+---------------------------------------+\n-\t\t| SPE: area for 64-bit GP registers\t|\n-\t\t+---------------------------------------+\n-\t\t| SPE alignment padding\t\t\t|\n-\t\t+---------------------------------------+\n \t\t| saved CR (C)\t\t\t\t| 8+P+A+V+L+X+W+Y+Z\n \t\t+---------------------------------------+\n \t\t| Save area for GP registers (G)\t| 8+P+A+V+L+X+W+Y+Z+C\n@@ -29956,7 +29940,6 @@ rs6000_emit_epilogue (int sibcall)\n \t  if (regno == INVALID_REGNUM)\n \t    break;\n \n-\t  /* Note: possible use of r0 here to address SPE regs.  */\n \t  mem = gen_frame_mem_offset (reg_mode, frame_reg_rtx,\n \t\t\t\t      info->ehrd_offset + frame_off\n \t\t\t\t      + reg_size * (int) i);\n@@ -36986,7 +36969,7 @@ altivec_expand_vec_perm_const (rtx operands[4])\n   return false;\n }\n \n-/* Expand a Paired Single, VSX Permute Doubleword, or SPE constant permutation.\n+/* Expand a Paired Single or VSX Permute Doubleword constant permutation.\n    Return true if we match an efficient implementation.  */\n \n static bool\n@@ -37213,10 +37196,8 @@ rs6000_parallel_return (machine_mode mode,\n \n /* Target hook for TARGET_FUNCTION_VALUE.\n \n-   On the SPE, both FPs and vectors are returned in r3.\n-\n-   On RS/6000 an integer value is in r3 and a floating-point value is in\n-   fp1, unless -msoft-float.  */\n+   An integer value is in r3 and a floating-point value is in fp1,\n+   unless -msoft-float.  */\n \n static rtx\n rs6000_function_value (const_tree valtype,\n@@ -37428,7 +37409,7 @@ rs6000_initial_elimination_offset (int from, int to)\n   return offset;\n }\n \n-/* Fill in sizes for SPE register high parts in table used by unwinder.  */\n+/* Fill in sizes of registers used by unwinder.  */\n \n static void\n rs6000_init_dwarf_reg_sizes_extra (tree address)"}, {"sha": "9b73be1e1766398aaab4fbed1ebe88d1ccdfb7a2", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "patch": "@@ -698,8 +698,8 @@ extern int rs6000_vector_align[];\n /* For power systems, we want to enable Altivec and VSX builtins even if the\n    user did not use -maltivec or -mvsx to allow the builtins to be used inside\n    of #pragma GCC target or the target attribute to change the code level for a\n-   given system.  The SPE and Paired builtins are only enabled if you configure\n-   the compiler for those builtins, and those machines don't support altivec or\n+   given system.  The Paired builtins are only enabled if you configure the\n+   compiler for those builtins, and those machines don't support altivec or\n    VSX.  */\n \n #define TARGET_EXTRA_BUILTINS\t(!TARGET_PAIRED_FLOAT\t\t\t \\\n@@ -2553,7 +2553,6 @@ extern int frame_pointer_needed;\n #define RS6000_BTC_TERNARY\t0x00000003\t/* normal ternary function.  */\n #define RS6000_BTC_PREDICATE\t0x00000004\t/* predicate function.  */\n #define RS6000_BTC_ABS\t\t0x00000005\t/* Altivec/VSX ABS function.  */\n-#define RS6000_BTC_EVSEL\t0x00000006\t/* SPE EVSEL function.  */\n #define RS6000_BTC_DST\t\t0x00000007\t/* Altivec DST function.  */\n #define RS6000_BTC_TYPE_MASK\t0x0000000f\t/* Mask to isolate types */\n "}, {"sha": "97cc349efa15d636f23d541cdeb60107f0482f58", "filename": "gcc/config/rs6000/vxworks.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvxworks.h?ref=6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "patch": "@@ -60,12 +60,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #define SUBTARGET_EXTRA_SPECS /* none needed */\n \n-/* VxWorks and VxWorksAE (aka 653) expect different CPU values to designate\n-   SPE on 8548.  We define a dedicated macro for the base VxWorks here, which\n-   the AE configuration will override.  */\n-\n-#define VXCPU_FOR_8548 \"PPC85XX\"\n-\n /* FIXME: The only reason we allow no -mcpu switch at all is because\n    config-ml.in insists on a \".\" multilib. */\n #define CPP_SPEC \\\n@@ -79,7 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n      mcpu=604 : -DCPU=PPC604  ; \\\n      mcpu=860 : -DCPU=PPC860  ; \\\n      mcpu=8540: -DCPU=PPC85XX ; \\\n-     mcpu=8548: -DCPU=\" VXCPU_FOR_8548 \"; \\\n+     mcpu=8548: -DCPU=PPC85XX ; \\\n               : -DCPU=PPC604  }}\" \\\n VXWORKS_ADDITIONAL_CPP_SPEC\n "}, {"sha": "9f21e913aa730b24b7209ac271976839be456499", "filename": "gcc/config/rs6000/vxworksae.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Fvxworksae.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Fvxworksae.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvxworksae.h?ref=6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "patch": "@@ -18,10 +18,6 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* VxWorksAE for E500V2 expects a specific CPU value to designate 8548.  */\n-#undef VXCPU_FOR_8548\n-#define VXCPU_FOR_8548 \"PPCE500V2\"\n-\n /* This platform supports the probing method of stack checking and\n    requires 4K of space for executing a possible last chance handler.  */\n #undef STACK_CHECK_PROTECT"}, {"sha": "a14deb45d16a99595cb2fc412e3ac66458344a67", "filename": "gcc/config/rs6000/vxworksmils.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Fvxworksmils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ae036b33000414f273b9ad2a7ca7c1a668d0b31/gcc%2Fconfig%2Frs6000%2Fvxworksmils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvxworksmils.h?ref=6ae036b33000414f273b9ad2a7ca7c1a668d0b31", "patch": "@@ -23,7 +23,3 @@ along with GCC; see the file COPYING3.  If not see\n    requires 4K of space for executing a possible last chance handler.  */\n #undef STACK_CHECK_PROTECT\n #define STACK_CHECK_PROTECT 4096\n-\n-/* VxWorksMILS for E500V2 expects a specific CPU value to designate 8548.  */\n-#undef VXCPU_FOR_8548\n-#define VXCPU_FOR_8548 \"PPC85XX\""}]}