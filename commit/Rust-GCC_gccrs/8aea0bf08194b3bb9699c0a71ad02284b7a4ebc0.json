{"sha": "8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFlYTBiZjA4MTk0YjNiYjk2OTljMGE3MWFkMDIyODRiN2E0ZWJjMA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-04-02T12:51:37Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-04-02T12:51:37Z"}, "message": "re PR tree-optimization/14495 ([tree-ssa] Propagate range info into a switch statement)\n\n2008-04-02  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/14495\n\t* tree-vrp.c (vrp_visit_cond_stmt): Do not handle\n\tSWITCH_EXPR here ...\n\t(vrp_visit_switch_stmt): ... but here (new function).\n\t(find_case_label_index): New helper function.\n\t(vrp_visit_stmt): Dispatch to vrp_visit_switch_stmt.\n\n\t* gcc.dg/tree-ssa/vrp40.c: New testcase.\n\nFrom-SVN: r133834", "tree": {"sha": "23a10d74974f7021e66efdb167fb9636ec9973c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23a10d74974f7021e66efdb167fb9636ec9973c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f1c2278049e83b151ed3a2abbc31b8ac5b54f60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1c2278049e83b151ed3a2abbc31b8ac5b54f60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1c2278049e83b151ed3a2abbc31b8ac5b54f60"}], "stats": {"total": 182, "additions": 176, "deletions": 6}, "files": [{"sha": "c9d8a4812a4198cf17e8bbcb64c19947440848b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "patch": "@@ -1,3 +1,12 @@\n+2008-04-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/14495\n+\t* tree-vrp.c (vrp_visit_cond_stmt): Do not handle\n+\tSWITCH_EXPR here ...\n+\t(vrp_visit_switch_stmt): ... but here (new function).\n+\t(find_case_label_index): New helper function.\n+\t(vrp_visit_stmt): Dispatch to vrp_visit_switch_stmt.\n+\n 2008-04-02  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* fwprop.c: Fix ISO-C99ism."}, {"sha": "03ac5b43e38cadc93947d5d88c3d3102134b28e5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "patch": "@@ -1,3 +1,8 @@\n+2008-04-02  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/14495\n+\t* gcc.dg/tree-ssa/vrp40.c: New testcase.\n+\n 2008-04-02  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/discr_record_constant.ads: New test."}, {"sha": "23f080acfe4f02007f54829a2b0950c99e98bf60", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp40.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp40.c?ref=8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-vrp1\" } */\n+\n+int f(int a) {\n+    switch (a & 1) {\n+      case 0:\n+      case 1: return  3;\n+      case 2: return  5;\n+      case 3: return  7;\n+      case 4: return 11;\n+      case 5: return 13;\n+      case 6: return 17;\n+      case 7: return 19;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 3;\" \"vrp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"vrp1\" } } */"}, {"sha": "1d8ade783a9fe375a75d0d7b87ca74aaff43514b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 144, "deletions": 6, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8aea0bf08194b3bb9699c0a71ad02284b7a4ebc0", "patch": "@@ -5439,11 +5439,6 @@ vrp_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n   bool sop;\n \n   *taken_edge_p = NULL;\n-\n-  /* FIXME.  Handle SWITCH_EXPRs.  */\n-  if (TREE_CODE (stmt) == SWITCH_EXPR)\n-    return SSA_PROP_VARYING;\n-\n   cond = COND_EXPR_COND (stmt);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -5537,6 +5532,147 @@ vrp_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n }\n \n \n+/* Searches the case label vector VEC for the index *IDX the CASE_LABEL\n+   includes the value VAL.  The search starts at index START_IDX and\n+   true is returned if *IDX corresponds to such an index.  False is\n+   returned in case VAL hits the default case label and *IDX in this\n+   case is the next higher or the next lower case label index.  */\n+\n+static bool\n+find_case_label_index (tree vec, size_t start_idx, tree val, size_t *idx)\n+{\n+  size_t n = TREE_VEC_LENGTH (vec);\n+  size_t low, high, i = start_idx;\n+\n+  /* Find case label for minimum of the value range or the next one.  */\n+  for (low = start_idx - 1, high = n - 1; high - low > 1; )\n+    {\n+      tree t;\n+      int cmp;\n+      i = (high + low) / 2;\n+      t = TREE_VEC_ELT (vec, i);\n+\n+      /* Cache the result of comparing CASE_LOW and val.  */\n+      cmp = tree_int_cst_compare (CASE_LOW (t), val);\n+\n+      if (cmp > 0)\n+        high = i;\n+      else\n+        low = i;\n+\n+      if (CASE_HIGH (t) == NULL)\n+        {\n+          /* A singe-valued case label.  */\n+          if (cmp == 0)\n+\t    {\n+\t      *idx = i;\n+\t      return true;\n+\t    }\n+        }\n+      else\n+        {\n+          /* A case range.  We can only handle integer ranges.  */\n+          if (cmp <= 0 && tree_int_cst_compare (CASE_HIGH (t), val) >= 0)\n+\t    {\n+\t      *idx = i;\n+\t      return true;\n+\t    }\n+        }\n+    }\n+\n+  *idx = i;\n+  return false;\n+}\n+\n+/* Visit switch statement STMT.  If we can determine which edge\n+   will be taken out of STMT's basic block, record it in\n+   *TAKEN_EDGE_P and return SSA_PROP_INTERESTING.  Otherwise, return\n+   SSA_PROP_VARYING.  */\n+\n+static enum ssa_prop_result\n+vrp_visit_switch_stmt (tree stmt, edge *taken_edge_p)\n+{\n+  tree op, val;\n+  value_range_t *vr;\n+  size_t i = 0, j = 0, n;\n+  tree vec;\n+  bool min_take_default, max_take_default;\n+\n+  *taken_edge_p = NULL;\n+  op = TREE_OPERAND (stmt, 0);\n+  if (TREE_CODE (op) != SSA_NAME)\n+    return SSA_PROP_VARYING;\n+\n+  vr = get_value_range (op);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nVisiting switch expression with operand \");\n+      print_generic_expr (dump_file, op, 0);\n+      fprintf (dump_file, \" with known range \");\n+      dump_value_range (dump_file, vr);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (vr->type != VR_RANGE\n+      || symbolic_range_p (vr))\n+    return SSA_PROP_VARYING;\n+\n+  /* Find the single edge that is taken from the switch expression.  */\n+  vec = SWITCH_LABELS (stmt);\n+  n = TREE_VEC_LENGTH (vec);\n+\n+  /* Find case label for minimum of the value range or the next one.  */\n+  min_take_default = !find_case_label_index (vec, 0, vr->min, &i);\n+\n+  /* Find case label for maximum of the value range or the previous one.  */\n+  max_take_default = !find_case_label_index (vec, i, vr->max, &j);\n+\n+  /* Check if we reach the default label only.  */\n+  if (j < i)\n+    val = TREE_VEC_ELT (vec, n - 1);\n+  /* Check if we reach exactly one label and not the default label.  */\n+  else if (i == j\n+\t   && !min_take_default\n+\t   && !max_take_default)\n+    val = TREE_VEC_ELT (vec, i);\n+  else\n+    {\n+      /* Check if labels with index i to j are all reaching the same label.\n+         If we don't hit a single case label only, the default case also has\n+         to branch to the same label.  */\n+      val = TREE_VEC_ELT (vec, i);\n+      if (CASE_LABEL (TREE_VEC_ELT (vec, n - 1)) != CASE_LABEL (val))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"  not a single destination for this \"\n+\t\t     \"range\\n\");\n+          return SSA_PROP_VARYING;\n+\t}\n+      for (++i; i <= j; ++i)\n+        {\n+          if (CASE_LABEL (TREE_VEC_ELT (vec, i)) != CASE_LABEL (val))\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"  not a single destination for this \"\n+\t\t\t \"range\\n\");\n+\t      return SSA_PROP_VARYING;\n+\t    }\n+        }\n+    }\n+\n+  *taken_edge_p = find_edge (bb_for_stmt (stmt),\n+\t\t\t     label_to_block (CASE_LABEL (val)));\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  will take edge to \");\n+      print_generic_stmt (dump_file, CASE_LABEL (val), 0);\n+    }\n+\n+  return SSA_PROP_INTERESTING;\n+}\n+\n+\n /* Evaluate statement STMT.  If the statement produces a useful range,\n    return SSA_PROP_INTERESTING and record the SSA name with the\n    interesting range into *OUTPUT_P.\n@@ -5575,8 +5711,10 @@ vrp_visit_stmt (tree stmt, edge *taken_edge_p, tree *output_p)\n \t  || ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n \treturn vrp_visit_assignment (stmt, output_p);\n     }\n-  else if (TREE_CODE (stmt) == COND_EXPR || TREE_CODE (stmt) == SWITCH_EXPR)\n+  else if (TREE_CODE (stmt) == COND_EXPR)\n     return vrp_visit_cond_stmt (stmt, taken_edge_p);\n+  else if (TREE_CODE (stmt) == SWITCH_EXPR)\n+    return vrp_visit_switch_stmt (stmt, taken_edge_p);\n \n   /* All other statements produce nothing of interest for VRP, so mark\n      their outputs varying and prevent further simulation.  */"}]}