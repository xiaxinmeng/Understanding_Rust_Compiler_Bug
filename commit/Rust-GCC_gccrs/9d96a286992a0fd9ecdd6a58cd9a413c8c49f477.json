{"sha": "9d96a286992a0fd9ecdd6a58cd9a413c8c49f477", "node_id": "C_kwDOANBUbNoAKDlkOTZhMjg2OTkyYTBmZDllY2RkNmE1OGNkOWE0MTNjOGM0OWY0Nzc", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-13T06:14:16Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-11-08T15:53:41Z"}, "message": "[PR24021] Implement PLUS_EXPR range-op entry for floats.\n\nThis is the range-op entry for floating point PLUS_EXPR.  It's the\nmost intricate range entry we have so far, because we need to keep\ntrack of rounding and target FP formats.  This will be the last FP\nentry I commit, mostly to avoid disturbing the tree any further, and\nalso because what we have so far is enough for a solid VRP.\n\nSo far we track NANs and signs correctly.  We also handle relationals\n(symbolics and numeric), both ordered and unordered, ABS_EXPR and\nNEGATE_EXPR which are used to fold __builtin_isinf, and __builtin_sign\n(__builtin_copysign is coming up).  All in all, I think this provide\nmore than enough for basic VRP on floats, as well as provide a basis\nto flesh out the rest if there's interest.\n\nMy goal with this entry is to provide a template for additional binary\noperators, as they tend to follow a similar pattern: handle NANs, do\nthe arithmetic while keeping track of rounding, and adjust for NAN.  I\nmay abstract the general parts as we do for irange's fold_range and\nwi_fold.\n\n\tPR tree-optimization/24021\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (propagate_nans): New.\n\t(frange_nextafter): New.\n\t(frange_arithmetic): New.\n\t(class foperator_plus): New.\n\t(floating_op_table::floating_op_table): Add PLUS_EXPR entry.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/vrp-float-plus.c: New test.", "tree": {"sha": "4bd4bc254eaf5645d478cb2a6d2a757a29f4bed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4bd4bc254eaf5645d478cb2a6d2a757a29f4bed2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e0ab430c0441ea3921e8b3a3987f73156412088", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0ab430c0441ea3921e8b3a3987f73156412088", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e0ab430c0441ea3921e8b3a3987f73156412088"}], "stats": {"total": 148, "additions": 148, "deletions": 0}, "files": [{"sha": "3bc6cc8849db0b2db60e8f977ed2a065a9e06020", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=9d96a286992a0fd9ecdd6a58cd9a413c8c49f477", "patch": "@@ -192,6 +192,80 @@ frelop_early_resolve (irange &r, tree type,\n \t  && relop_early_resolve (r, type, op1, op2, rel, my_rel));\n }\n \n+// If either operand is a NAN, set R to NAN and return TRUE.\n+\n+inline bool\n+propagate_nans (frange &r, const frange &op1, const frange &op2)\n+{\n+  if (op1.known_isnan () || op2.known_isnan ())\n+    {\n+      r.set_nan (op1.type ());\n+      return true;\n+    }\n+  return false;\n+}\n+\n+// Set VALUE to its next real value, or INF if the operation overflows.\n+\n+inline void\n+frange_nextafter (enum machine_mode mode,\n+\t\t  REAL_VALUE_TYPE &value,\n+\t\t  const REAL_VALUE_TYPE &inf)\n+{\n+  const real_format *fmt = REAL_MODE_FORMAT (mode);\n+  REAL_VALUE_TYPE tmp;\n+  real_nextafter (&tmp, fmt, &value, &inf);\n+  value = tmp;\n+}\n+\n+// Like real_arithmetic, but round the result to INF if the operation\n+// produced inexact results.\n+//\n+// ?? There is still one problematic case, i387.  With\n+// -fexcess-precision=standard we perform most SF/DFmode arithmetic in\n+// XFmode (long_double_type_node), so that case is OK.  But without\n+// -mfpmath=sse, all the SF/DFmode computations are in XFmode\n+// precision (64-bit mantissa) and only occassionally rounded to\n+// SF/DFmode (when storing into memory from the 387 stack).  Maybe\n+// this is ok as well though it is just occassionally more precise. ??\n+\n+static void\n+frange_arithmetic (enum tree_code code, tree type,\n+\t\t   REAL_VALUE_TYPE &result,\n+\t\t   const REAL_VALUE_TYPE &op1,\n+\t\t   const REAL_VALUE_TYPE &op2,\n+\t\t   const REAL_VALUE_TYPE &inf)\n+{\n+  REAL_VALUE_TYPE value;\n+  enum machine_mode mode = TYPE_MODE (type);\n+  bool mode_composite = MODE_COMPOSITE_P (mode);\n+\n+  bool inexact = real_arithmetic (&value, code, &op1, &op2);\n+  real_convert (&result, mode, &value);\n+\n+  // Be extra careful if there may be discrepancies between the\n+  // compile and runtime results.\n+  if ((mode_composite || (real_isneg (&inf) ? real_less (&result, &value)\n+\t\t\t  : !real_less (&value, &result)))\n+      && (inexact || !real_identical (&result, &value)))\n+    {\n+      if (mode_composite)\n+\t{\n+\t  if (real_isdenormal (&result, mode)\n+\t      || real_iszero (&result))\n+\t    {\n+\t      // IBM extended denormals only have DFmode precision.\n+\t      REAL_VALUE_TYPE tmp;\n+\t      real_convert (&tmp, DFmode, &value);\n+\t      frange_nextafter (DFmode, tmp, inf);\n+\t      real_convert (&result, mode, &tmp);\n+\t      return;\n+\t    }\n+\t}\n+      frange_nextafter (mode, result, inf);\n+    }\n+}\n+\n // Crop R to [-INF, MAX] where MAX is the maximum representable number\n // for TYPE.\n \n@@ -1746,6 +1820,58 @@ foperator_unordered_equal::op1_range (frange &r, tree type,\n   return true;\n }\n \n+class foperator_plus : public range_operator_float\n+{\n+  using range_operator_float::fold_range;\n+\n+public:\n+  bool fold_range (frange &r, tree type,\n+\t\t   const frange &lh,\n+\t\t   const frange &rh,\n+\t\t   relation_trio = TRIO_VARYING) const final override;\n+} fop_plus;\n+\n+bool\n+foperator_plus::fold_range (frange &r, tree type,\n+\t\t\t    const frange &op1, const frange &op2,\n+\t\t\t    relation_trio) const\n+{\n+  if (empty_range_varying (r, type, op1, op2))\n+    return true;\n+  if (propagate_nans (r, op1, op2))\n+    return true;\n+\n+  REAL_VALUE_TYPE lb, ub;\n+  frange_arithmetic (PLUS_EXPR, type, lb,\n+\t\t     op1.lower_bound (), op2.lower_bound (), dconstninf);\n+  frange_arithmetic (PLUS_EXPR, type, ub,\n+\t\t     op1.upper_bound (), op2.upper_bound (), dconstinf);\n+\n+  // Handle possible NANs by saturating to the appropriate INF if only\n+  // one end is a NAN.  If both ends are a NAN, just return a NAN.\n+  bool lb_nan = real_isnan (&lb);\n+  bool ub_nan = real_isnan (&ub);\n+  if (lb_nan && ub_nan)\n+    {\n+      r.set_nan (type);\n+      return true;\n+    }\n+  if (lb_nan)\n+    lb = dconstninf;\n+  else if (ub_nan)\n+    ub = dconstinf;\n+\n+  r.set (type, lb, ub);\n+\n+  if (lb_nan || ub_nan)\n+    // Keep the default NAN (with a varying sign) set by the setter.\n+    ;\n+  else if (!op1.maybe_isnan () && !op2.maybe_isnan ())\n+    r.clear_nan ();\n+\n+  return true;\n+}\n+\n // Instantiate a range_op_table for floating point operations.\n static floating_op_table global_floating_table;\n \n@@ -1778,6 +1904,7 @@ floating_op_table::floating_op_table ()\n \n   set (ABS_EXPR, fop_abs);\n   set (NEGATE_EXPR, fop_negate);\n+  set (PLUS_EXPR, fop_plus);\n }\n \n // Return a pointer to the range_operator_float instance, if there is"}, {"sha": "3739ea4e810bd4b7900b2543ef322696e564999a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp-float-plus.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-plus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d96a286992a0fd9ecdd6a58cd9a413c8c49f477/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-plus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp-float-plus.c?ref=9d96a286992a0fd9ecdd6a58cd9a413c8c49f477", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -fno-tree-fre -fno-tree-dominator-opts -fno-thread-jumps -fdump-tree-vrp2\" }\n+\n+double BG_SplineLength ()\n+{\n+  double lastPoint;\n+  double i;\n+\n+  for (i = 0.01;i<=1;i+=0.1f)\n+    if (!(i != 0.0))\n+      {\n+        lastPoint = i;\n+      }\n+    else\n+      {\n+        lastPoint = 2;\n+      }\n+  return lastPoint;\n+}\n+\n+// { dg-final { scan-tree-dump-times \"return 2\\\\.0e\" 1 \"vrp2\" } }"}]}