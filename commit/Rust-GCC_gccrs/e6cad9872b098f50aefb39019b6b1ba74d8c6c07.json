{"sha": "e6cad9872b098f50aefb39019b6b1ba74d8c6c07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZjYWQ5ODcyYjA5OGY1MGFlZmIzOTAxOWI2YjFiYTc0ZDhjNmMwNw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-06-27T20:23:20Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2018-06-27T20:23:20Z"}, "message": "stl_vector.h (struct _Vector_base<>::_Vector_impl_data): New.\n\n2018-06-27  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/stl_vector.h\n\t(struct _Vector_base<>::_Vector_impl_data): New.\n\t(struct _Vector_base<>::_Vector_impl): Inherit from latter.\n\t(_Vector_base<>::_Vector_impl::_M_swap_data): Move...\n\t(_Vector_base<>::_Vector_impl_data::_M_swap_data): ...here.\n\t(_Vector_base<>::_Vector_impl()): Add noexcept qualification.\n\t(_Vector_base<>::_Vector_impl(_Vector_impl&&)): New.\n\t(_Vector_base<>::_Vector_impl(_Tp_alloc_type&&, _Vector_impl&&)): New.\n\t(_Vector_base(const allocator_type&, _Vector_base&&)): New, use latter.\n\t(_Vector_base()): Default.\n\t(_Vector_base(_Vector_base&&)): Default.\n\t(_Vector_base(size_t)) [_GLIBCXX_INLINE_VERSION]: Delete.\n\t(_Vector_base(_Tp_alloc_type&&)) [_GLIBCXX_INLINE_VERSION]: Delete.\n\t(_Vector_base::_M_create_storage(size_t)): Make protected.\n\t(vector()): Default.\n\t(vector(vector&&)): Default.\n\t(vector(vector&&, const allocator_type&, true_type)): New.\n\t(vector(vector&&, const allocator_type&, false_type)): New.\n\t(vector(vector&&, const allocator_type&)): Use latters.\n\t(vector(_InputIte, _InputIte, const allocator_type&)): Call\n\t_M_range_initialize directly.\n\t* include/debug/vector\n\t(vector(vector&&, const allocator_type&)): Add noexcept qualification.\n\t* testsuite/23_containers/vector/allocator/default_init.cc: New.\n\t* testsuite/23_containers/vector/cons/noexcept_move_construct.cc: Add\n\tstatic assertions.\n\nFrom-SVN: r262194", "tree": {"sha": "323954c644643ed2b3667fbcfaf24694dc0d5709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/323954c644643ed2b3667fbcfaf24694dc0d5709"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6cad9872b098f50aefb39019b6b1ba74d8c6c07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6cad9872b098f50aefb39019b6b1ba74d8c6c07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6cad9872b098f50aefb39019b6b1ba74d8c6c07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/comments", "author": null, "committer": null, "parents": [{"sha": "f8dc0f2bf410d4fc5136c60cb3590c88d5db0995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8dc0f2bf410d4fc5136c60cb3590c88d5db0995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8dc0f2bf410d4fc5136c60cb3590c88d5db0995"}], "stats": {"total": 268, "additions": 225, "deletions": 43}, "files": [{"sha": "e421efcbbd1fd0ecb62e2faca32a7d8b9becc021", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e6cad9872b098f50aefb39019b6b1ba74d8c6c07", "patch": "@@ -1,3 +1,32 @@\n+2018-06-27  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/stl_vector.h\n+\t(struct _Vector_base<>::_Vector_impl_data): New.\n+\t(struct _Vector_base<>::_Vector_impl): Inherit from latter.\n+\t(_Vector_base<>::_Vector_impl::_M_swap_data): Move...\n+\t(_Vector_base<>::_Vector_impl_data::_M_swap_data): ...here.\n+\t(_Vector_base<>::_Vector_impl()): Add noexcept qualification.\n+\t(_Vector_base<>::_Vector_impl(_Vector_impl&&)): New.\n+\t(_Vector_base<>::_Vector_impl(_Tp_alloc_type&&, _Vector_impl&&)): New.\n+\t(_Vector_base(const allocator_type&, _Vector_base&&)): New, use latter.\n+\t(_Vector_base()): Default.\n+\t(_Vector_base(_Vector_base&&)): Default.\n+\t(_Vector_base(size_t)) [_GLIBCXX_INLINE_VERSION]: Delete.\n+\t(_Vector_base(_Tp_alloc_type&&)) [_GLIBCXX_INLINE_VERSION]: Delete.\n+\t(_Vector_base::_M_create_storage(size_t)): Make protected.\n+\t(vector()): Default.\n+\t(vector(vector&&)): Default.\n+\t(vector(vector&&, const allocator_type&, true_type)): New.\n+\t(vector(vector&&, const allocator_type&, false_type)): New.\n+\t(vector(vector&&, const allocator_type&)): Use latters.\n+\t(vector(_InputIte, _InputIte, const allocator_type&)): Call\n+\t_M_range_initialize directly.\n+\t* include/debug/vector\n+\t(vector(vector&&, const allocator_type&)): Add noexcept qualification.\n+\t* testsuite/23_containers/vector/allocator/default_init.cc: New.\n+\t* testsuite/23_containers/vector/cons/noexcept_move_construct.cc: Add\n+\tstatic assertions.\n+\n 2018-06-27  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/cpp_type_traits.h [__cplusplus >= 201703]"}, {"sha": "d2be98883b3f1207aed4fa8bcbfb1b52f8a6054e", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 96, "deletions": 42, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=e6cad9872b098f50aefb39019b6b1ba74d8c6c07", "patch": "@@ -85,34 +85,58 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer\n        \tpointer;\n \n-      struct _Vector_impl\n-      : public _Tp_alloc_type\n+      struct _Vector_impl_data\n       {\n \tpointer _M_start;\n \tpointer _M_finish;\n \tpointer _M_end_of_storage;\n \n-\t_Vector_impl()\n-\t: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()\n-\t{ }\n-\n-\t_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT\n-\t: _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()\n+\t_Vector_impl_data() _GLIBCXX_NOEXCEPT\n+\t: _M_start(), _M_finish(), _M_end_of_storage()\n \t{ }\n \n #if __cplusplus >= 201103L\n-\t_Vector_impl(_Tp_alloc_type&& __a) noexcept\n-\t: _Tp_alloc_type(std::move(__a)),\n-\t  _M_start(), _M_finish(), _M_end_of_storage()\n-\t{ }\n+\t_Vector_impl_data(_Vector_impl_data&& __x) noexcept\n+\t: _M_start(__x._M_start), _M_finish(__x._M_finish),\n+\t  _M_end_of_storage(__x._M_end_of_storage)\n+\t{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }\n #endif\n \n-\tvoid _M_swap_data(_Vector_impl& __x) _GLIBCXX_NOEXCEPT\n+\tvoid\n+\t_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT\n \t{\n \t  std::swap(_M_start, __x._M_start);\n \t  std::swap(_M_finish, __x._M_finish);\n \t  std::swap(_M_end_of_storage, __x._M_end_of_storage);\n \t}\n+      };\n+\n+      struct _Vector_impl\n+\t: public _Tp_alloc_type, public _Vector_impl_data\n+      {\n+\t_Vector_impl() _GLIBCXX_NOEXCEPT_IF( noexcept(_Tp_alloc_type()) )\n+\t: _Tp_alloc_type()\n+\t{ }\n+\n+\t_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT\n+\t: _Tp_alloc_type(__a)\n+\t{ }\n+\n+#if __cplusplus >= 201103L\n+\t// Not defaulted, to enforce noexcept(true) even when\n+\t// !is_nothrow_move_constructible<_Tp_alloc_type>.\n+\t_Vector_impl(_Vector_impl&& __x) noexcept\n+\t: _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))\n+\t{ }\n+\n+\t_Vector_impl(_Tp_alloc_type&& __a) noexcept\n+\t: _Tp_alloc_type(std::move(__a))\n+\t{ }\n+\n+\t_Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept\n+\t: _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))\n+\t{ }\n+#endif\n \n #if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR\n \ttemplate<typename = _Tp_alloc_type>\n@@ -235,38 +259,44 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       _Tp_alloc_type&\n       _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT\n-      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }\n+      { return this->_M_impl; }\n \n       const _Tp_alloc_type&\n       _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT\n-      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }\n+      { return this->_M_impl; }\n \n       allocator_type\n       get_allocator() const _GLIBCXX_NOEXCEPT\n       { return allocator_type(_M_get_Tp_allocator()); }\n \n-      _Vector_base()\n-      : _M_impl() { }\n+#if __cplusplus >= 201103L\n+      _Vector_base() = default;\n+#else\n+      _Vector_base() { }\n+#endif\n \n       _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT\n       : _M_impl(__a) { }\n \n+      // Kept for ABI compatibility.\n+#if !_GLIBCXX_INLINE_VERSION\n       _Vector_base(size_t __n)\n       : _M_impl()\n       { _M_create_storage(__n); }\n+#endif\n \n       _Vector_base(size_t __n, const allocator_type& __a)\n       : _M_impl(__a)\n       { _M_create_storage(__n); }\n \n #if __cplusplus >= 201103L\n+      _Vector_base(_Vector_base&&) = default;\n+\n+      // Kept for ABI compatibility.\n+# if !_GLIBCXX_INLINE_VERSION\n       _Vector_base(_Tp_alloc_type&& __a) noexcept\n       : _M_impl(std::move(__a)) { }\n \n-      _Vector_base(_Vector_base&& __x) noexcept\n-      : _M_impl(std::move(__x._M_get_Tp_allocator()))\n-      { this->_M_impl._M_swap_data(__x._M_impl); }\n-\n       _Vector_base(_Vector_base&& __x, const allocator_type& __a)\n       : _M_impl(__a)\n       {\n@@ -278,6 +308,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    _M_create_storage(__n);\n \t  }\n       }\n+# endif\n+\n+      _Vector_base(const allocator_type& __a, _Vector_base&& __x)\n+      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))\n+      { }\n #endif\n \n       ~_Vector_base() _GLIBCXX_NOEXCEPT\n@@ -304,7 +339,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  _Tr::deallocate(_M_impl, __p, __n);\n       }\n \n-    private:\n+    protected:\n       void\n       _M_create_storage(size_t __n)\n       {\n@@ -388,11 +423,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       /**\n        *  @brief  Creates a %vector with no elements.\n        */\n-      vector()\n #if __cplusplus >= 201103L\n-      noexcept(is_nothrow_default_constructible<_Alloc>::value)\n+      vector() = default;\n+#else\n+      vector() { }\n #endif\n-      : _Base() { }\n \n       /**\n        *  @brief  Creates a %vector with no elements.\n@@ -468,13 +503,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n #if __cplusplus >= 201103L\n       /**\n        *  @brief  %Vector move constructor.\n-       *  @param  __x  A %vector of identical element and allocator types.\n        *\n-       *  The newly-created %vector contains the exact contents of @a __x.\n-       *  The contents of @a __x are a valid, but unspecified %vector.\n+       *  The newly-created %vector contains the exact contents of the\n+       *  moved instance.\n+       *  The contents of the moved instance are a valid, but unspecified\n+       *  %vector.\n        */\n-      vector(vector&& __x) noexcept\n-      : _Base(std::move(__x)) { }\n+      vector(vector&&) noexcept = default;\n \n       /// Copy constructor with alternative allocator\n       vector(const vector& __x, const allocator_type& __a)\n@@ -486,13 +521,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t\t\t      _M_get_Tp_allocator());\n       }\n \n-      /// Move constructor with alternative allocator\n-      vector(vector&& __rv, const allocator_type& __m)\n-      noexcept(_Alloc_traits::_S_always_equal())\n-      : _Base(std::move(__rv), __m)\n+    private:\n+      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept\n+      : _Base(__m, std::move(__rv))\n+      { }\n+\n+      vector(vector&& __rv, const allocator_type& __m, false_type)\n+      : _Base(__m)\n       {\n-\tif (__rv.get_allocator() != __m)\n+\tif (__rv.get_allocator() == __m)\n+\t  this->_M_impl._M_swap_data(__rv._M_impl);\n+\telse if (!__rv.empty())\n \t  {\n+\t    this->_M_create_storage(__rv.size());\n \t    this->_M_impl._M_finish =\n \t      std::__uninitialized_move_a(__rv.begin(), __rv.end(),\n \t\t\t\t\t  this->_M_impl._M_start,\n@@ -501,6 +542,15 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t  }\n       }\n \n+    public:\n+      /// Move constructor with alternative allocator\n+      vector(vector&& __rv, const allocator_type& __m)\n+      noexcept( noexcept(\n+\tvector(std::declval<vector&&>(), std::declval<const allocator_type&>(),\n+\t       std::declval<typename _Alloc_traits::is_always_equal>())) )\n+      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})\n+      { }\n+\n       /**\n        *  @brief  Builds a %vector from an initializer list.\n        *  @param  __l  An initializer_list.\n@@ -543,7 +593,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \tvector(_InputIterator __first, _InputIterator __last,\n \t       const allocator_type& __a = allocator_type())\n \t: _Base(__a)\n-\t{ _M_initialize_dispatch(__first, __last, __false_type()); }\n+\t{\n+\t  _M_range_initialize(__first, __last,\n+\t\t\t      std::__iterator_category(__first));\n+\t}\n #else\n       template<typename _InputIterator>\n \tvector(_InputIterator __first, _InputIterator __last,\n@@ -1414,6 +1467,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       // Called by the range constructor to implement [23.1.1]/9\n \n+#if __cplusplus < 201103L\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 438. Ambiguity in the \"do the right thing\" clause\n       template<typename _Integer>\n@@ -1432,10 +1486,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n \t\t\t       __false_type)\n \t{\n-\t  typedef typename std::iterator_traits<_InputIterator>::\n-\t    iterator_category _IterCategory;\n-\t  _M_range_initialize(__first, __last, _IterCategory());\n+\t  _M_range_initialize(__first, __last,\n+\t\t\t      std::__iterator_category(__first));\n \t}\n+#endif\n \n       // Called by the second initialize_dispatch above\n       template<typename _InputIterator>\n@@ -1674,7 +1728,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // moved, either because the source's allocator will move too\n       // or because the allocators are equal.\n       void\n-      _M_move_assign(vector&& __x, std::true_type) noexcept\n+      _M_move_assign(vector&& __x, true_type) noexcept\n       {\n \tvector __tmp(get_allocator());\n \tthis->_M_impl._M_swap_data(__tmp._M_impl);\n@@ -1685,10 +1739,10 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       // Do move assignment when it might not be possible to move source\n       // object's memory, resulting in a linear-time operation.\n       void\n-      _M_move_assign(vector&& __x, std::false_type)\n+      _M_move_assign(vector&& __x, false_type)\n       {\n \tif (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())\n-\t  _M_move_assign(std::move(__x), std::true_type());\n+\t  _M_move_assign(std::move(__x), true_type());\n \telse\n \t  {\n \t    // The rvalue's allocator cannot be moved and is not equal,"}, {"sha": "802f4fd6b78a41a059763e954f5d14b3617ba366", "filename": "libstdc++-v3/include/debug/vector", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector?ref=e6cad9872b098f50aefb39019b6b1ba74d8c6c07", "patch": "@@ -199,6 +199,8 @@ namespace __debug\n       : _Base(__x, __a) { }\n \n       vector(vector&& __x, const allocator_type& __a)\n+\tnoexcept( noexcept(\n+\t  _Base(std::declval<_Base&&>()), std::declval<const allocator_type&>()) )\n       : _Safe(std::move(__x._M_safe()), __a),\n \t_Base(std::move(__x._M_base()), __a),\n \t_Safe_vector(std::move(__x)) { }"}, {"sha": "5981b8f86b3d2349069d92baa77859b8d6477272", "filename": "libstdc++-v3/testsuite/23_containers/vector/allocator/default_init.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fdefault_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fdefault_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fallocator%2Fdefault_init.cc?ref=e6cad9872b098f50aefb39019b6b1ba74d8c6c07", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+// { dg-options \"-O0\" }\n+// { dg-xfail-run-if \"PR c++/65816\" { *-*-* } }\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+#include <ext/aligned_buffer.h>\n+\n+using T = int;\n+\n+using __gnu_test::default_init_allocator;\n+\n+void test01()\n+{\n+  typedef default_init_allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type;\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+void test02()\n+{\n+  typedef default_init_allocator<T> alloc_type;\n+  typedef std::vector<T, alloc_type> test_type;\n+\n+  __gnu_cxx::__aligned_buffer<test_type> buf;\n+  __builtin_memset(buf._M_addr(), ~0, sizeof(test_type));\n+\n+  test_type *tmp = ::new(buf._M_addr()) test_type();\n+\n+  VERIFY( tmp->get_allocator().state == 0 );\n+\n+  tmp->~test_type();\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "4d414866047d8d36322276a73b0aaa6ee32c3082", "filename": "libstdc++-v3/testsuite/23_containers/vector/cons/noexcept_move_construct.cc", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fnoexcept_move_construct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6cad9872b098f50aefb39019b6b1ba74d8c6c07/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fnoexcept_move_construct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fcons%2Fnoexcept_move_construct.cc?ref=e6cad9872b098f50aefb39019b6b1ba74d8c6c07", "patch": "@@ -23,4 +23,34 @@\n \n typedef std::vector<int> vtype;\n \n-static_assert(std::is_nothrow_move_constructible<vtype>::value, \"Error\");\n+static_assert( std::is_nothrow_move_constructible<vtype>::value,\n+\t       \"noexcept move constructor\" );\n+static_assert( std::is_nothrow_constructible<vtype,\n+\t       vtype&&, const typename vtype::allocator_type&>::value,\n+\t       \"noexcept move constructor with allocator\" );\n+\n+template<typename Type>\n+  class not_noexcept_move_constructor_alloc : public std::allocator<Type>\n+  {\n+  public:\n+    not_noexcept_move_constructor_alloc() noexcept { }\n+\n+    not_noexcept_move_constructor_alloc(\n+\tconst not_noexcept_move_constructor_alloc& x) noexcept\n+    : std::allocator<Type>(x)\n+    { }\n+\n+    not_noexcept_move_constructor_alloc(\n+\tnot_noexcept_move_constructor_alloc&& x) noexcept(false)\n+    : std::allocator<Type>(std::move(x))\n+    { }\n+\n+    template<typename _Tp1>\n+      struct rebind\n+      { typedef not_noexcept_move_constructor_alloc<_Tp1> other; };\n+  };\n+\n+typedef std::vector<int, not_noexcept_move_constructor_alloc<int>> vtype2;\n+\n+static_assert( std::is_nothrow_move_constructible<vtype2>::value,\n+\t       \"noexcept move constructor with not noexcept alloc\" );"}]}