{"sha": "ec748ec83a9a9a0cba3dce016e2c52c4a5a36816", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM3NDhlYzgzYTlhOWEwY2JhM2RjZTAxNmUyYzUyYzRhNWEzNjgxNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-11-18T03:19:44Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-11-18T03:19:44Z"}, "message": "* df.c: Fix formatting.\n\nFrom-SVN: r59203", "tree": {"sha": "41f2c99336fcd7a51ce3cb5fb071cdb31891a5e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41f2c99336fcd7a51ce3cb5fb071cdb31891a5e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec748ec83a9a9a0cba3dce016e2c52c4a5a36816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec748ec83a9a9a0cba3dce016e2c52c4a5a36816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec748ec83a9a9a0cba3dce016e2c52c4a5a36816", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec748ec83a9a9a0cba3dce016e2c52c4a5a36816/comments", "author": null, "committer": null, "parents": [{"sha": "cf0cec73f6cc3661afa18a9a0f0664a147a8ddb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf0cec73f6cc3661afa18a9a0f0664a147a8ddb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf0cec73f6cc3661afa18a9a0f0664a147a8ddb9"}], "stats": {"total": 150, "additions": 78, "deletions": 72}, "files": [{"sha": "63caf1d7ca2eb782957cb495f047bb7fc857ac65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec748ec83a9a9a0cba3dce016e2c52c4a5a36816/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec748ec83a9a9a0cba3dce016e2c52c4a5a36816/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec748ec83a9a9a0cba3dce016e2c52c4a5a36816", "patch": "@@ -1,3 +1,7 @@\n+2002-11-17  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* df.c: Fix formatting.\n+\n 2002-11-17  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (two anonymous patterns): Fix insn"}, {"sha": "4228e0d6ebd7a015bcbae04ee401f1d967c17c56", "filename": "gcc/df.c", "status": "modified", "additions": 74, "deletions": 72, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec748ec83a9a9a0cba3dce016e2c52c4a5a36816/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec748ec83a9a9a0cba3dce016e2c52c4a5a36816/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=ec748ec83a9a9a0cba3dce016e2c52c4a5a36816", "patch": "@@ -169,11 +169,14 @@ Perhaps there should be a bitmap argument to df_analyse to specify\n #include \"df.h\"\n #include \"fibheap.h\"\n \n-#define FOR_EACH_BB_IN_BITMAP(BITMAP, MIN, BB, CODE)\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  unsigned int node_;\t\t\t\t\t\t\\\n-  EXECUTE_IF_SET_IN_BITMAP (BITMAP, MIN, node_, \t\t\\\n-    {(BB) = BASIC_BLOCK (node_); CODE;});} while (0)\n+#define FOR_EACH_BB_IN_BITMAP(BITMAP, MIN, BB, CODE)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      unsigned int node_;\t\t\t\t\\\n+      EXECUTE_IF_SET_IN_BITMAP (BITMAP, MIN, node_,\t\\\n+      {(BB) = BASIC_BLOCK (node_); CODE;});\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n \n static struct obstack df_ref_obstack;\n static struct df *ddf;\n@@ -375,7 +378,7 @@ df_def_table_realloc (df, size)\n \n   /* Link all the new refs together, overloading the chain field.  */\n   for (i = 0; i < size - 1; i++)\n-      refs[i].chain = (struct df_link *)(refs + i + 1);\n+    refs[i].chain = (struct df_link *) (refs + i + 1);\n   refs[size - 1].chain = 0;\n }\n #endif\n@@ -392,7 +395,7 @@ df_bitmaps_alloc (df, flags)\n   basic_block bb;\n \n   /* Free the bitmaps if they need resizing.  */\n-  if ((flags & DF_LR) && df->n_regs < (unsigned int)max_reg_num ())\n+  if ((flags & DF_LR) && df->n_regs < (unsigned int) max_reg_num ())\n     dflags |= DF_LR | DF_RU;\n   if ((flags & DF_RU) && df->n_uses < df->use_id)\n     dflags |= DF_RU;\n@@ -936,7 +939,7 @@ df_def_record_1 (df, x, bb, insn)\n       int i;\n \n       for (i = XVECLEN (dst, 0) - 1; i >= 0; i--)\n-\t  df_def_record_1 (df, XVECEXP (dst, 0, i), bb, insn);\n+\tdf_def_record_1 (df, XVECEXP (dst, 0, i), bb, insn);\n       return;\n     }\n \n@@ -972,9 +975,9 @@ df_def_record_1 (df, x, bb, insn)\n       flags |= DF_REF_READ_WRITE;\n     }\n \n-    if (GET_CODE (dst) == REG\n-\t|| (GET_CODE (dst) == SUBREG && GET_CODE (SUBREG_REG (dst)) == REG))\n-      df_ref_record (df, dst, loc, insn, DF_REF_REG_DEF, flags);\n+  if (GET_CODE (dst) == REG\n+      || (GET_CODE (dst) == SUBREG && GET_CODE (SUBREG_REG (dst)) == REG))\n+    df_ref_record (df, dst, loc, insn, DF_REF_REG_DEF, flags);\n }\n \n \n@@ -1236,12 +1239,12 @@ df_insn_refs_record (df, bb, insn)\n \t  {\n \t    switch (REG_NOTE_KIND (note))\n \t      {\n-\t\tcase REG_EQUIV:\n-\t\tcase REG_EQUAL:\n-\t\t  df_uses_record (df, &XEXP (note, 0), DF_REF_REG_USE,\n-\t\t\t\t  bb, insn, 0);\n-\t\tdefault:\n-\t\t  break;\n+\t      case REG_EQUIV:\n+\t      case REG_EQUAL:\n+\t\tdf_uses_record (df, &XEXP (note, 0), DF_REF_REG_USE,\n+\t\t\t\tbb, insn, 0);\n+\t      default:\n+\t\tbreak;\n \t      }\n \t  }\n \n@@ -1992,7 +1995,7 @@ df_analyse_1 (df, blocks, flags, update)\n     aflags |= DF_LR;\n \n   if (! blocks)\n-      blocks = df->all_blocks;\n+    blocks = df->all_blocks;\n \n   df->flags = flags;\n   if (update)\n@@ -2040,21 +2043,21 @@ df_analyse_1 (df, blocks, flags, update)\n       df_reg_use_chain_create (df, blocks);\n     }\n \n-  df->dfs_order = xmalloc (sizeof(int) * n_basic_blocks);\n-  df->rc_order = xmalloc (sizeof(int) * n_basic_blocks);\n-  df->rts_order = xmalloc (sizeof(int) * n_basic_blocks);\n-  df->inverse_dfs_map = xmalloc (sizeof(int) * last_basic_block);\n-  df->inverse_rc_map = xmalloc (sizeof(int) * last_basic_block);\n-  df->inverse_rts_map = xmalloc (sizeof(int) * last_basic_block);\n+  df->dfs_order = xmalloc (sizeof (int) * n_basic_blocks);\n+  df->rc_order = xmalloc (sizeof (int) * n_basic_blocks);\n+  df->rts_order = xmalloc (sizeof (int) * n_basic_blocks);\n+  df->inverse_dfs_map = xmalloc (sizeof (int) * last_basic_block);\n+  df->inverse_rc_map = xmalloc (sizeof (int) * last_basic_block);\n+  df->inverse_rts_map = xmalloc (sizeof (int) * last_basic_block);\n \n   flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n   flow_reverse_top_sort_order_compute (df->rts_order);\n-  for (i = 0; i < n_basic_blocks; i ++)\n-   {\n-     df->inverse_dfs_map[df->dfs_order[i]] = i;\n-     df->inverse_rc_map[df->rc_order[i]] = i;\n-     df->inverse_rts_map[df->rts_order[i]] = i;\n-   }\n+  for (i = 0; i < n_basic_blocks; i++)\n+    {\n+      df->inverse_dfs_map[df->dfs_order[i]] = i;\n+      df->inverse_rc_map[df->rc_order[i]] = i;\n+      df->inverse_rts_map[df->rts_order[i]] = i;\n+    }\n   if (aflags & DF_RD)\n     {\n       /* Compute the sets of gens and kills for the defs of each bb.  */\n@@ -2128,7 +2131,7 @@ df_analyse_1 (df, blocks, flags, update)\n \n   /* Free up bitmaps that are no longer required.  */\n   if (dflags)\n-     df_bitmaps_free (df, dflags);\n+    df_bitmaps_free (df, dflags);\n \n   if (aflags & DF_LR)\n     {\n@@ -2274,7 +2277,7 @@ df_refs_update (df)\n   basic_block bb;\n   int count = 0;\n \n-  if ((unsigned int)max_reg_num () >= df->reg_size)\n+  if ((unsigned int) max_reg_num () >= df->reg_size)\n     df_reg_table_realloc (df, 0);\n \n   df_refs_queue (df);\n@@ -2497,8 +2500,7 @@ df_insn_modify (df, bb, insn)\n }\n \n \n-typedef struct replace_args\n-{\n+typedef struct replace_args {\n   rtx match;\n   rtx replacement;\n   rtx insn;\n@@ -3427,42 +3429,42 @@ df_dump (df, flags, file)\n \t       && (reg_info[j].n_uses || reg_info[j].n_defs))\n \t      || ((flags & DF_RD_CHAIN) && reg_info[j].defs)\n \t      || ((flags & DF_RU_CHAIN) && reg_info[j].uses))\n-\t  {\n-\t    fprintf (file, \"reg %d\", j);\n-\t    if ((flags & DF_RD_CHAIN) && (flags & DF_RU_CHAIN))\n-\t      {\n-\t\tbasic_block bb = df_regno_bb (df, j);\n+\t    {\n+\t      fprintf (file, \"reg %d\", j);\n+\t      if ((flags & DF_RD_CHAIN) && (flags & DF_RU_CHAIN))\n+\t\t{\n+\t\t  basic_block bb = df_regno_bb (df, j);\n \n-\t\tif (bb)\n-\t\t  fprintf (file, \" bb %d\", bb->index);\n-\t\telse\n-\t\t  fprintf (file, \" bb ?\");\n-\t      }\n-\t    if (flags & DF_REG_INFO)\n-\t      {\n-\t\tfprintf (file, \" life %d\", reg_info[j].lifetime);\n-\t      }\n+\t\t  if (bb)\n+\t\t    fprintf (file, \" bb %d\", bb->index);\n+\t\t  else\n+\t\t    fprintf (file, \" bb ?\");\n+\t\t}\n+\t      if (flags & DF_REG_INFO)\n+\t\t{\n+\t\t  fprintf (file, \" life %d\", reg_info[j].lifetime);\n+\t\t}\n \n-\t    if ((flags & DF_REG_INFO) || (flags & DF_RD_CHAIN))\n-\t      {\n-\t\tfprintf (file, \" defs \");\n-\t\tif (flags & DF_REG_INFO)\n-\t\t  fprintf (file, \"%d \", reg_info[j].n_defs);\n-\t\tif (flags & DF_RD_CHAIN)\n-\t\t  df_chain_dump (reg_info[j].defs, file);\n-\t      }\n+\t      if ((flags & DF_REG_INFO) || (flags & DF_RD_CHAIN))\n+\t\t{\n+\t\t  fprintf (file, \" defs \");\n+\t\t  if (flags & DF_REG_INFO)\n+\t\t    fprintf (file, \"%d \", reg_info[j].n_defs);\n+\t\t  if (flags & DF_RD_CHAIN)\n+\t\t    df_chain_dump (reg_info[j].defs, file);\n+\t\t}\n \n-\t    if ((flags & DF_REG_INFO) || (flags & DF_RU_CHAIN))\n-\t      {\n-\t\tfprintf (file, \" uses \");\n-\t\tif (flags & DF_REG_INFO)\n-\t\t  fprintf (file, \"%d \", reg_info[j].n_uses);\n-\t\tif (flags & DF_RU_CHAIN)\n-\t\t  df_chain_dump (reg_info[j].uses, file);\n-\t      }\n+\t      if ((flags & DF_REG_INFO) || (flags & DF_RU_CHAIN))\n+\t\t{\n+\t\t  fprintf (file, \" uses \");\n+\t\t  if (flags & DF_REG_INFO)\n+\t\t    fprintf (file, \"%d \", reg_info[j].n_uses);\n+\t\t  if (flags & DF_RU_CHAIN)\n+\t\t    df_chain_dump (reg_info[j].uses, file);\n+\t\t}\n \n-\t    fprintf (file, \"\\n\");\n-\t  }\n+\t      fprintf (file, \"\\n\");\n+\t    }\n \t}\n     }\n   fprintf (file, \"\\n\");\n@@ -3484,7 +3486,7 @@ df_insn_debug (df, insn, file)\n \n   if (df->insns[uid].defs)\n     bbi = DF_REF_BBNO (df->insns[uid].defs->ref);\n-  else  if (df->insns[uid].uses)\n+  else if (df->insns[uid].uses)\n     bbi = DF_REF_BBNO (df->insns[uid].uses->ref);\n   else\n     bbi = -1;\n@@ -3512,7 +3514,7 @@ df_insn_debug_regno (df, insn, file)\n \n   if (df->insns[uid].defs)\n     bbi = DF_REF_BBNO (df->insns[uid].defs->ref);\n-  else  if (df->insns[uid].uses)\n+  else if (df->insns[uid].uses)\n     bbi = DF_REF_BBNO (df->insns[uid].uses->ref);\n   else\n     bbi = -1;\n@@ -3637,7 +3639,7 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n   int changed;\n   int i = block->index;\n   edge e;\n-  basic_block bb= block;\n+  basic_block bb = block;\n   SET_BIT (visited, block->index);\n   if (TEST_BIT (pending, block->index))\n     {\n@@ -3663,7 +3665,7 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n       else\n \t{\n \t  /* Calculate <conf_op> of successor ins */\n-\t  bitmap_zero(out[i]);\n+\t  bitmap_zero (out[i]);\n \t  for (e = bb->succ; e != 0; e = e->succ_next)\n \t    {\n \t      if (e->dest == EXIT_BLOCK_PTR)\n@@ -3748,7 +3750,7 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n   int changed;\n   int i = block->index;\n   edge e;\n-  basic_block bb= block;\n+  basic_block bb = block;\n   SET_BIT (visited, block->index);\n   if (TEST_BIT (pending, block->index))\n     {\n@@ -3774,7 +3776,7 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n       else\n \t{\n \t  /* Calculate <conf_op> of successor ins */\n-\t  sbitmap_zero(out[i]);\n+\t  sbitmap_zero (out[i]);\n \t  for (e = bb->succ; e != 0; e = e->succ_next)\n \t    {\n \t      if (e->dest == EXIT_BLOCK_PTR)"}]}