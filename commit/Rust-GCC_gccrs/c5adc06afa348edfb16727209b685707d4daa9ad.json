{"sha": "c5adc06afa348edfb16727209b685707d4daa9ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhZGMwNmFmYTM0OGVkZmIxNjcyNzIwOWI2ODU3MDdkNGRhYTlhZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-19T19:22:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-19T19:22:20Z"}, "message": "final.c (get_decl_from_op): New function.\n\n\t* final.c (get_decl_from_op): New function.\n\t(output_asm_insn): Call it; write \"*\" when item with decl is address.\n\nFrom-SVN: r46355", "tree": {"sha": "e2676f26e7dc0f3c61424c3a59d7c9e55c30095c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2676f26e7dc0f3c61424c3a59d7c9e55c30095c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5adc06afa348edfb16727209b685707d4daa9ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5adc06afa348edfb16727209b685707d4daa9ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5adc06afa348edfb16727209b685707d4daa9ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5adc06afa348edfb16727209b685707d4daa9ad/comments", "author": null, "committer": null, "parents": [{"sha": "d51feceac1e7388aec95a28e7bea9f009c123cd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d51feceac1e7388aec95a28e7bea9f009c123cd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d51feceac1e7388aec95a28e7bea9f009c123cd0"}], "stats": {"total": 59, "additions": 54, "deletions": 5}, "files": [{"sha": "30b3685464b007474d0273f2d5842a4f86efe299", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5adc06afa348edfb16727209b685707d4daa9ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5adc06afa348edfb16727209b685707d4daa9ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5adc06afa348edfb16727209b685707d4daa9ad", "patch": "@@ -1,3 +1,8 @@\n+Fri Oct 19 15:24:39 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* final.c (get_decl_from_op): New function.\n+\t(output_asm_insn): Call it; write \"*\" when item with decl is address.\n+\n 2001-10-19  Janis Johnson  <janis187@us.ibm.com>\n \n \t* doc/install.texi (Specific, sparc-sun-solaris2*) Copy documentation"}, {"sha": "33d2ff68f263113a6c58e2adc0da8e85e9262cfb", "filename": "gcc/final.c", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5adc06afa348edfb16727209b685707d4daa9ad/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5adc06afa348edfb16727209b685707d4daa9ad/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=c5adc06afa348edfb16727209b685707d4daa9ad", "patch": "@@ -244,6 +244,7 @@ static int add_bb_string\tPARAMS ((const char *, int));\n static void notice_source_line\tPARAMS ((rtx));\n static rtx walk_alter_subreg\tPARAMS ((rtx));\n static void output_asm_name\tPARAMS ((void));\n+static tree get_decl_from_op\tPARAMS ((rtx, int *));\n static void output_operand\tPARAMS ((rtx, int));\n #ifdef LEAF_REGISTERS\n static void leaf_renumber_regs\tPARAMS ((rtx));\n@@ -3288,6 +3289,49 @@ output_asm_name ()\n     }\n }\n \n+/* If OP is a REG or MEM and we can find a decl corresponding to it or\n+   its address, return that decl.  Set *PADDRESSP to 1 if the decl\n+   corresponds to the address of the object and 0 if to the object.  */\n+\n+static tree\n+get_decl_from_op (op, paddressp)\n+     rtx op;\n+     int *paddressp;\n+{\n+  tree decl;\n+  int inner_addressp;\n+\n+  *paddressp = 0;\n+\n+  if (GET_CODE (op) == REG)\n+    return REGNO_DECL (ORIGINAL_REGNO (op));\n+  else if (GET_CODE (op) != MEM)\n+    return 0;\n+\n+  if (MEM_DECL (op) != 0)\n+    return MEM_DECL (op);\n+\n+  /* Otherwise we have an address, so indicate it and look at the address.  */\n+  *paddressp = 1;\n+  op = XEXP (op, 0);\n+\n+  /* First check if we have a decl for the address, then look at the right side\n+     if it is a PLUS.  Otherwise, strip off arithmetic and keep looking.\n+     But don't allow the address to itself be indirect.  */\n+  if ((decl = get_decl_from_op (op, &inner_addressp)) && ! inner_addressp)\n+    return decl;\n+  else if (GET_CODE (op) == PLUS\n+\t   && (decl = get_decl_from_op (XEXP (op, 1), &inner_addressp)))\n+    return decl;\n+\n+  while (GET_RTX_CLASS (GET_CODE (op)) == '1'\n+\t || GET_RTX_CLASS (GET_CODE (op)) == '2')\n+    op = XEXP (op, 0);\n+\n+  decl = get_decl_from_op (op, &inner_addressp);\n+  return inner_addressp ? 0 : decl;\n+}\n+  \n /* Output text from TEMPLATE to the assembler output file,\n    obeying %-directions to substitute operands taken from\n    the vector OPERANDS.\n@@ -3497,14 +3541,14 @@ output_asm_insn (template, operands)\n \n       for (i = 0; i < ops; i++)\n \t{\n-\t  rtx op = operands[oporder[i]];\n-\t  tree decl = (GET_CODE (op) == REG ? REGNO_DECL (ORIGINAL_REGNO (op))\n-\t\t       : GET_CODE (op) == MEM ? MEM_DECL (op)\n-\t\t       : 0);\n+\t  int addressp;\n+\t  tree decl = get_decl_from_op (operands[oporder[i]], &addressp);\n \n \t  if (decl && DECL_NAME (decl))\n \t    {\n-\t      fprintf (asm_out_file, \"%s %s\", wrote ? \",\" : ASM_COMMENT_START,\n+\t      fprintf (asm_out_file, \"%s %s%s\",\n+\t\t       wrote ? \",\" : ASM_COMMENT_START,\n+\t\t       addressp ? \"*\" : \"\",\n \t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n \t      wrote = 1;\n \t    }"}]}