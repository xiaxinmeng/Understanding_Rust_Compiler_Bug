{"sha": "724ee5a0093da443563ae98ec5cb76164c36be80", "node_id": "C_kwDOANBUbNoAKDcyNGVlNWEwMDkzZGE0NDM1NjNhZTk4ZWM1Y2I3NjE2NGMzNmJlODA", "commit": {"author": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2021-10-14T14:57:12Z"}, "committer": {"name": "Kwok Cheung Yeung", "email": "kcy@codesourcery.com", "date": "2021-10-14T16:16:36Z"}, "message": "openmp, fortran: Add support for OpenMP declare variant directive in Fortran\n\n2021-10-14  Kwok Cheung Yeung  <kcy@codesourcery.com>\n\ngcc/c-family/\n\n\t* c-omp.c (c_omp_check_context_selector): Rename to\n\tomp_check_context_selector and move to omp-general.c.\n\t(c_omp_mark_declare_variant): Rename to omp_mark_declare_variant and\n\tmove to omp-general.c.\n\ngcc/c/\n\n\t* c-parser.c (c_finish_omp_declare_variant): Change call from\n\tc_omp_check_context_selector to omp_check_context_selector. Change\n\tcall from c_omp_mark_declare_variant to omp_mark_declare_variant.\n\ngcc/cp/\n\n\t* decl.c (omp_declare_variant_finalize_one): Change call from\n\tc_omp_mark_declare_variant to omp_mark_declare_variant.\n\t* parser.c (cp_finish_omp_declare_variant): Change call from\n\tc_omp_check_context_selector to omp_check_context_selector.\n\ngcc/fortran/\n\n\t* gfortran.h (enum gfc_statement): Add ST_OMP_DECLARE_VARIANT.\n\t(enum gfc_omp_trait_property_kind): New.\n\t(struct gfc_omp_trait_property): New.\n\t(gfc_get_omp_trait_property): New macro.\n\t(struct gfc_omp_selector): New.\n\t(gfc_get_omp_selector): New macro.\n\t(struct gfc_omp_set_selector): New.\n\t(gfc_get_omp_set_selector): New macro.\n\t(struct gfc_omp_declare_variant): New.\n\t(gfc_get_omp_declare_variant): New macro.\n\t(struct gfc_namespace): Add omp_declare_variant field.\n\t(gfc_free_omp_declare_variant_list): New prototype.\n\t* match.h (gfc_match_omp_declare_variant): New prototype.\n\t* openmp.c (gfc_free_omp_trait_property_list): New.\n\t(gfc_free_omp_selector_list): New.\n\t(gfc_free_omp_set_selector_list): New.\n\t(gfc_free_omp_declare_variant_list): New.\n\t(gfc_match_omp_clauses): Add extra optional argument.  Handle end of\n\tclauses for context selectors.\n\t(omp_construct_selectors, omp_device_selectors,\n\tomp_implementation_selectors, omp_user_selectors): New.\n\t(gfc_match_omp_context_selector): New.\n\t(gfc_match_omp_context_selector_specification): New.\n\t(gfc_match_omp_declare_variant): New.\n\t* parse.c: Include tree-core.h and omp-general.h.\n\t(decode_omp_directive): Handle 'declare variant'.\n\t(case_omp_decl): Include ST_OMP_DECLARE_VARIANT.\n\t(gfc_ascii_statement): Handle ST_OMP_DECLARE_VARIANT.\n\t(gfc_parse_file): Initialize omp_requires_mask.\n\t* symbol.c (gfc_free_namespace): Call\n\tgfc_free_omp_declare_variant_list.\n\t* trans-decl.c (gfc_get_extern_function_decl): Call\n\tgfc_trans_omp_declare_variant.\n\t(gfc_create_function_decl): Call gfc_trans_omp_declare_variant.\n\t* trans-openmp.c (gfc_trans_omp_declare_variant): New.\n\t* trans-stmt.h (gfc_trans_omp_declare_variant): New prototype.\n\ngcc/\n\n\t* omp-general.c (omp_check_context_selector):  Move from c-omp.c.\n\t(omp_mark_declare_variant): Move from c-omp.c.\n\t(omp_context_name_list_prop): Update for Fortran strings.\n\t* omp-general.h (omp_check_context_selector): New prototype.\n\t(omp_mark_declare_variant): New prototype.\n\ngcc/testsuite/\n\n\t* gfortran.dg/gomp/declare-variant-1.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-10.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-11.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-12.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-13.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-14.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-15.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-16.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-17.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-18.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-19.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-2.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-2a.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-3.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-4.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-5.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-6.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-7.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-8.f90: New test.\n\t* gfortran.dg/gomp/declare-variant-9.f90: New test.\n\nlibgomp/\n\n\t* testsuite/libgomp.fortran/declare-variant-1.f90: New test.", "tree": {"sha": "7e2bc7d3eb89510e2e6bf866cfd866cb5bed4380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e2bc7d3eb89510e2e6bf866cfd866cb5bed4380"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/724ee5a0093da443563ae98ec5cb76164c36be80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/724ee5a0093da443563ae98ec5cb76164c36be80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/724ee5a0093da443563ae98ec5cb76164c36be80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/724ee5a0093da443563ae98ec5cb76164c36be80/comments", "author": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "k-yeung", "id": 16960193, "node_id": "MDQ6VXNlcjE2OTYwMTkz", "avatar_url": "https://avatars.githubusercontent.com/u/16960193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/k-yeung", "html_url": "https://github.com/k-yeung", "followers_url": "https://api.github.com/users/k-yeung/followers", "following_url": "https://api.github.com/users/k-yeung/following{/other_user}", "gists_url": "https://api.github.com/users/k-yeung/gists{/gist_id}", "starred_url": "https://api.github.com/users/k-yeung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/k-yeung/subscriptions", "organizations_url": "https://api.github.com/users/k-yeung/orgs", "repos_url": "https://api.github.com/users/k-yeung/repos", "events_url": "https://api.github.com/users/k-yeung/events{/privacy}", "received_events_url": "https://api.github.com/users/k-yeung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73f34f4d02d72dd61e4573402a202b35cf3cce0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73f34f4d02d72dd61e4573402a202b35cf3cce0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73f34f4d02d72dd61e4573402a202b35cf3cce0f"}], "stats": {"total": 3051, "additions": 2903, "deletions": 148}, "files": [{"sha": "af9eba8d00899085df622df5690fe71d8ff34d68", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -2911,143 +2911,6 @@ c_omp_predetermined_mapping (tree decl)\n }\n \n \n-/* Diagnose errors in an OpenMP context selector, return CTX if\n-   it is correct or error_mark_node otherwise.  */\n-\n-tree\n-c_omp_check_context_selector (location_t loc, tree ctx)\n-{\n-  /* Each trait-set-selector-name can only be specified once.\n-     There are just 4 set names.  */\n-  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n-    for (tree t2 = TREE_CHAIN (t1); t2; t2 = TREE_CHAIN (t2))\n-      if (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n-\t{\n-\t  error_at (loc, \"selector set %qs specified more than once\",\n-\t  \t    IDENTIFIER_POINTER (TREE_PURPOSE (t1)));\n-\t  return error_mark_node;\n-\t}\n-  for (tree t = ctx; t; t = TREE_CHAIN (t))\n-    {\n-      /* Each trait-selector-name can only be specified once.  */\n-      if (list_length (TREE_VALUE (t)) < 5)\n-\t{\n-\t  for (tree t1 = TREE_VALUE (t); t1; t1 = TREE_CHAIN (t1))\n-\t    for (tree t2 = TREE_CHAIN (t1); t2; t2 = TREE_CHAIN (t2))\n-\t      if (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n-\t\t{\n-\t\t  error_at (loc,\n-\t\t\t    \"selector %qs specified more than once in set %qs\",\n-\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n-\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n-\t\t  return error_mark_node;\n-\t\t}\n-\t}\n-      else\n-\t{\n-\t  hash_set<tree> pset;\n-\t  for (tree t1 = TREE_VALUE (t); t1; t1 = TREE_CHAIN (t1))\n-\t    if (pset.add (TREE_PURPOSE (t1)))\n-\t      {\n-\t\terror_at (loc,\n-\t\t\t  \"selector %qs specified more than once in set %qs\",\n-\t\t\t  IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n-\t\t\t  IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n-\t\treturn error_mark_node;\n-\t      }\n-\t}\n-\n-      static const char *const kind[] = {\n-\t\"host\", \"nohost\", \"cpu\", \"gpu\", \"fpga\", \"any\", NULL };\n-      static const char *const vendor[] = {\n-\t\"amd\", \"arm\", \"bsc\", \"cray\", \"fujitsu\", \"gnu\", \"ibm\", \"intel\",\n-\t\"llvm\", \"nvidia\", \"pgi\", \"ti\", \"unknown\", NULL };\n-      static const char *const extension[] = { NULL };\n-      static const char *const atomic_default_mem_order[] = {\n-\t\"seq_cst\", \"relaxed\", \"acq_rel\", NULL };\n-      struct known_properties { const char *set; const char *selector;\n-\t\t\t\tconst char *const *props; };\n-      known_properties props[] = {\n-\t{ \"device\", \"kind\", kind },\n-\t{ \"implementation\", \"vendor\", vendor },\n-\t{ \"implementation\", \"extension\", extension },\n-\t{ \"implementation\", \"atomic_default_mem_order\",\n-\t  atomic_default_mem_order } };\n-      for (tree t1 = TREE_VALUE (t); t1; t1 = TREE_CHAIN (t1))\n-\tfor (unsigned i = 0; i < ARRAY_SIZE (props); i++)\n-\t  if (!strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n-\t\t\t\t\t   props[i].selector)\n-\t      && !strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t)),\n-\t\t\t\t\t      props[i].set))\n-\t    for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n-\t      for (unsigned j = 0; ; j++)\n-\t\t{\n-\t\t  if (props[i].props[j] == NULL)\n-\t\t    {\n-\t\t      if (TREE_PURPOSE (t2)\n-\t\t\t  && !strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n-\t\t\t\t      \" score\"))\n-\t\t\tbreak;\n-\t\t      if (props[i].props == atomic_default_mem_order)\n-\t\t\t{\n-\t\t\t  error_at (loc,\n-\t\t\t\t    \"incorrect property %qs of %qs selector\",\n-\t\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n-\t\t\t\t    \"atomic_default_mem_order\");\n-\t\t\t  return error_mark_node;\n-\t\t\t}\n-\t\t      else if (TREE_PURPOSE (t2))\n-\t\t\twarning_at (loc, 0,\n-\t\t\t\t    \"unknown property %qs of %qs selector\",\n-\t\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n-\t\t\t\t    props[i].selector);\n-\t\t      else\n-\t\t\twarning_at (loc, 0,\n-\t\t\t\t    \"unknown property %qE of %qs selector\",\n-\t\t\t\t    TREE_VALUE (t2), props[i].selector);\n-\t\t      break;\n-\t\t    }\n-\t\t  else if (TREE_PURPOSE (t2) == NULL_TREE)\n-\t\t    {\n-\t\t      const char *str = TREE_STRING_POINTER (TREE_VALUE (t2));\n-\t\t      if (!strcmp (str, props[i].props[j])\n-\t\t\t  && ((size_t) TREE_STRING_LENGTH (TREE_VALUE (t2))\n-\t\t\t      == strlen (str) + 1))\n-\t\t\tbreak;\n-\t\t    }\n-\t\t  else if (!strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n-\t\t\t\t    props[i].props[j]))\n-\t\t    break;\n-\t\t}\n-    }\n-  return ctx;\n-}\n-\n-/* Register VARIANT as variant of some base function marked with\n-   #pragma omp declare variant.  CONSTRUCT is corresponding construct\n-   selector set.  */\n-\n-void\n-c_omp_mark_declare_variant (location_t loc, tree variant, tree construct)\n-{\n-  tree attr = lookup_attribute (\"omp declare variant variant\",\n-\t\t\t\tDECL_ATTRIBUTES (variant));\n-  if (attr == NULL_TREE)\n-    {\n-      attr = tree_cons (get_identifier (\"omp declare variant variant\"),\n-\t\t\tunshare_expr (construct),\n-\t\t\tDECL_ATTRIBUTES (variant));\n-      DECL_ATTRIBUTES (variant) = attr;\n-      return;\n-    }\n-  if ((TREE_VALUE (attr) != NULL_TREE) != (construct != NULL_TREE)\n-      || (construct != NULL_TREE\n-\t  && omp_context_selector_set_compare (\"construct\", TREE_VALUE (attr),\n-\t\t\t\t\t       construct)))\n-    error_at (loc, \"%qD used as a variant with incompatible %<construct%> \"\n-\t\t   \"selector sets\", variant);\n-}\n-\n /* For OpenACC, the OMP_CLAUSE_MAP_KIND of an OMP_CLAUSE_MAP is used internally\n    to distinguish clauses as seen by the user.  Return the \"friendly\" clause\n    name for error messages etc., where possible.  See also"}, {"sha": "80dd61d599ef49a7c58f87bc93ecdcfc27c56fcf", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -21694,7 +21694,7 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n   tree ctx = c_parser_omp_context_selector_specification (parser, parms);\n   if (ctx == error_mark_node)\n     goto fail;\n-  ctx = c_omp_check_context_selector (match_loc, ctx);\n+  ctx = omp_check_context_selector (match_loc, ctx);\n   if (ctx != error_mark_node && variant != error_mark_node)\n     {\n       if (TREE_CODE (variant) != FUNCTION_DECL)\n@@ -21724,7 +21724,7 @@ c_finish_omp_declare_variant (c_parser *parser, tree fndecl, tree parms)\n \t{\n \t  C_DECL_USED (variant) = 1;\n \t  tree construct = omp_get_context_selector (ctx, \"construct\", NULL);\n-\t  c_omp_mark_declare_variant (match_loc, variant, construct);\n+\t  omp_mark_declare_variant (match_loc, variant, construct);\n \t  if (omp_context_selector_matches (ctx))\n \t    {\n \t      tree attr"}, {"sha": "242429d9ef4a2a95ce1b6a368fd1833cb5062f2e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -7768,7 +7768,7 @@ omp_declare_variant_finalize_one (tree decl, tree attr)\n       else\n \t{\n \t  tree construct = omp_get_context_selector (ctx, \"construct\", NULL);\n-\t  c_omp_mark_declare_variant (match_loc, variant, construct);\n+\t  omp_mark_declare_variant (match_loc, variant, construct);\n \t  if (!omp_context_selector_matches (ctx))\n \t    return true;\n \t  TREE_PURPOSE (TREE_VALUE (attr)) = variant;"}, {"sha": "865778e4d301e9a6e97f3abed8a99498ecdc7331", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -45319,7 +45319,7 @@ cp_finish_omp_declare_variant (cp_parser *parser, cp_token *pragma_tok,\n   tree ctx = cp_parser_omp_context_selector_specification (parser, true);\n   if (ctx == error_mark_node)\n     goto fail;\n-  ctx = c_omp_check_context_selector (match_loc, ctx);\n+  ctx = omp_check_context_selector (match_loc, ctx);\n   if (ctx != error_mark_node && variant != error_mark_node)\n     {\n       tree match_loc_node = maybe_wrap_with_location (integer_zero_node,"}, {"sha": "5b9f89748d2504adf81b700049af7b7420b18718", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 72, "deletions": 1, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -239,7 +239,7 @@ enum gfc_statement\n   ST_OMP_DO_SIMD, ST_OMP_END_DO_SIMD, ST_OMP_PARALLEL_DO_SIMD,\n   ST_OMP_END_PARALLEL_DO_SIMD, ST_OMP_DECLARE_SIMD, ST_OMP_DECLARE_REDUCTION,\n   ST_OMP_TARGET, ST_OMP_END_TARGET, ST_OMP_TARGET_DATA, ST_OMP_END_TARGET_DATA,\n-  ST_OMP_TARGET_UPDATE, ST_OMP_DECLARE_TARGET,\n+  ST_OMP_TARGET_UPDATE, ST_OMP_DECLARE_TARGET, ST_OMP_DECLARE_VARIANT,\n   ST_OMP_TEAMS, ST_OMP_END_TEAMS, ST_OMP_DISTRIBUTE, ST_OMP_END_DISTRIBUTE,\n   ST_OMP_DISTRIBUTE_SIMD, ST_OMP_END_DISTRIBUTE_SIMD,\n   ST_OMP_DISTRIBUTE_PARALLEL_DO, ST_OMP_END_DISTRIBUTE_PARALLEL_DO,\n@@ -1553,6 +1553,73 @@ typedef struct gfc_omp_declare_simd\n gfc_omp_declare_simd;\n #define gfc_get_omp_declare_simd() XCNEW (gfc_omp_declare_simd)\n \n+\n+enum gfc_omp_trait_property_kind\n+{\n+  CTX_PROPERTY_NONE,\n+  CTX_PROPERTY_USER,\n+  CTX_PROPERTY_NAME_LIST,\n+  CTX_PROPERTY_ID,\n+  CTX_PROPERTY_EXPR,\n+  CTX_PROPERTY_SIMD\n+};\n+\n+typedef struct gfc_omp_trait_property\n+{\n+  struct gfc_omp_trait_property *next;\n+  enum gfc_omp_trait_property_kind property_kind;\n+  bool is_name : 1;\n+\n+  union\n+    {\n+      gfc_expr *expr;\n+      gfc_symbol *sym;\n+      gfc_omp_clauses *clauses;\n+      char *name;\n+    };\n+} gfc_omp_trait_property;\n+#define gfc_get_omp_trait_property() XCNEW (gfc_omp_trait_property)\n+\n+typedef struct gfc_omp_selector\n+{\n+  struct gfc_omp_selector *next;\n+\n+  char *trait_selector_name;\n+  gfc_expr *score;\n+  struct gfc_omp_trait_property *properties;\n+} gfc_omp_selector;\n+#define gfc_get_omp_selector() XCNEW (gfc_omp_selector)\n+\n+typedef struct gfc_omp_set_selector\n+{\n+  struct gfc_omp_set_selector *next;\n+\n+  const char *trait_set_selector_name;\n+  struct gfc_omp_selector *trait_selectors;\n+} gfc_omp_set_selector;\n+#define gfc_get_omp_set_selector() XCNEW (gfc_omp_set_selector)\n+\n+\n+/* Node in the linked list used for storing !$omp declare variant\n+   constructs.  */\n+\n+typedef struct gfc_omp_declare_variant\n+{\n+  struct gfc_omp_declare_variant *next;\n+  locus where; /* Where the !$omp declare variant construct occurred.  */\n+\n+  struct gfc_symtree *base_proc_symtree;\n+  struct gfc_symtree *variant_proc_symtree;\n+\n+  gfc_omp_set_selector *set_selectors;\n+\n+  bool checked_p : 1; /* Set if previously checked for errors.  */\n+  bool error_p : 1; /* Set if error found in directive.  */\n+}\n+gfc_omp_declare_variant;\n+#define gfc_get_omp_declare_variant() XCNEW (gfc_omp_declare_variant)\n+\n+\n typedef struct gfc_omp_udr\n {\n   struct gfc_omp_udr *next;\n@@ -2022,6 +2089,9 @@ typedef struct gfc_namespace\n   /* Linked list of !$omp declare simd constructs.  */\n   struct gfc_omp_declare_simd *omp_declare_simd;\n \n+  /* Linked list of !$omp declare variant constructs.  */\n+  struct gfc_omp_declare_variant *omp_declare_variant;\n+\n   /* A hash set for the the gfc expressions that have already\n      been finalized in this namespace.  */\n \n@@ -3422,6 +3492,7 @@ bool gfc_omp_requires_add_clause (gfc_omp_requires_kind, const char *,\n void gfc_check_omp_requires (gfc_namespace *, int);\n void gfc_free_omp_clauses (gfc_omp_clauses *);\n void gfc_free_oacc_declare_clauses (struct gfc_oacc_declare *);\n+void gfc_free_omp_declare_variant_list (gfc_omp_declare_variant *list);\n void gfc_free_omp_declare_simd (gfc_omp_declare_simd *);\n void gfc_free_omp_declare_simd_list (gfc_omp_declare_simd *);\n void gfc_free_omp_udr (gfc_omp_udr *);"}, {"sha": "21e94f79d9502da0dcc9fa406e4add8adc495420", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -160,6 +160,7 @@ match gfc_match_omp_critical (void);\n match gfc_match_omp_declare_reduction (void);\n match gfc_match_omp_declare_simd (void);\n match gfc_match_omp_declare_target (void);\n+match gfc_match_omp_declare_variant (void);\n match gfc_match_omp_depobj (void);\n match gfc_match_omp_distribute (void);\n match gfc_match_omp_distribute_parallel_do (void);"}, {"sha": "2a161f3304c5fcd3580e465a4dc13f0dded2b31f", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 511, "deletions": 2, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -168,6 +168,70 @@ gfc_free_omp_declare_simd_list (gfc_omp_declare_simd *list)\n     }\n }\n \n+static void\n+gfc_free_omp_trait_property_list (gfc_omp_trait_property *list)\n+{\n+  while (list)\n+    {\n+      gfc_omp_trait_property *current = list;\n+      list = list->next;\n+      switch (current->property_kind)\n+\t{\n+\tcase CTX_PROPERTY_ID:\n+\t  free (current->name);\n+\t  break;\n+\tcase CTX_PROPERTY_NAME_LIST:\n+\t  if (current->is_name)\n+\t    free (current->name);\n+\t  break;\n+\tcase CTX_PROPERTY_SIMD:\n+\t  gfc_free_omp_clauses (current->clauses);\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      free (current);\n+    }\n+}\n+\n+static void\n+gfc_free_omp_selector_list (gfc_omp_selector *list)\n+{\n+  while (list)\n+    {\n+      gfc_omp_selector *current = list;\n+      list = list->next;\n+      gfc_free_omp_trait_property_list (current->properties);\n+      free (current);\n+    }\n+}\n+\n+static void\n+gfc_free_omp_set_selector_list (gfc_omp_set_selector *list)\n+{\n+  while (list)\n+    {\n+      gfc_omp_set_selector *current = list;\n+      list = list->next;\n+      gfc_free_omp_selector_list (current->trait_selectors);\n+      free (current);\n+    }\n+}\n+\n+/* Free an !$omp declare variant construct list.  */\n+\n+void\n+gfc_free_omp_declare_variant_list (gfc_omp_declare_variant *list)\n+{\n+  while (list)\n+    {\n+      gfc_omp_declare_variant *current = list;\n+      list = list->next;\n+      gfc_free_omp_set_selector_list (current->set_selectors);\n+      free (current);\n+    }\n+}\n+\n /* Free an !$omp declare reduction.  */\n \n void\n@@ -1353,7 +1417,7 @@ gfc_match_dupl_atomic (bool not_dupl, const char *name)\n static match\n gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\t       bool first = true, bool needs_space = true,\n-\t\t       bool openacc = false)\n+\t\t       bool openacc = false, bool context_selector = false)\n {\n   bool error = false;\n   gfc_omp_clauses *c = gfc_get_omp_clauses ();\n@@ -2843,7 +2907,9 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n     }\n \n end:\n-  if (error || gfc_match_omp_eos () != MATCH_YES)\n+  if (error\n+      || (context_selector && gfc_peek_ascii_char () != ')')\n+      || (!context_selector && gfc_match_omp_eos () != MATCH_YES))\n     {\n       if (!gfc_error_flag_test ())\n \tgfc_error (\"Failed to match clause at %C\");\n@@ -4429,6 +4495,449 @@ gfc_match_omp_declare_target (void)\n }\n \n \n+static const char *const omp_construct_selectors[] = {\n+  \"simd\", \"target\", \"teams\", \"parallel\", \"do\", NULL };\n+static const char *const omp_device_selectors[] = {\n+  \"kind\", \"isa\", \"arch\", NULL };\n+static const char *const omp_implementation_selectors[] = {\n+  \"vendor\", \"extension\", \"atomic_default_mem_order\", \"unified_address\",\n+  \"unified_shared_memory\", \"dynamic_allocators\", \"reverse_offload\", NULL };\n+static const char *const omp_user_selectors[] = {\n+  \"condition\", NULL };\n+\n+\n+/* OpenMP 5.0:\n+\n+   trait-selector:\n+     trait-selector-name[([trait-score:]trait-property[,trait-property[,...]])]\n+\n+   trait-score:\n+     score(score-expression)  */\n+\n+match\n+gfc_match_omp_context_selector (gfc_omp_set_selector *oss)\n+{\n+  do\n+    {\n+      char selector[GFC_MAX_SYMBOL_LEN + 1];\n+\n+      if (gfc_match_name (selector) != MATCH_YES)\n+\t{\n+\t  gfc_error (\"expected trait selector name at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      gfc_omp_selector *os = gfc_get_omp_selector ();\n+      os->trait_selector_name = XNEWVEC (char, strlen (selector) + 1);\n+      strcpy (os->trait_selector_name, selector);\n+      os->next = oss->trait_selectors;\n+      oss->trait_selectors = os;\n+\n+      const char *const *selectors = NULL;\n+      bool allow_score = true;\n+      bool allow_user = false;\n+      int property_limit = 0;\n+      enum gfc_omp_trait_property_kind property_kind = CTX_PROPERTY_NONE;\n+      switch (oss->trait_set_selector_name[0])\n+\t{\n+\tcase 'c': /* construct */\n+\t  selectors = omp_construct_selectors;\n+\t  allow_score = false;\n+\t  property_limit = 1;\n+\t  property_kind = CTX_PROPERTY_SIMD;\n+\t  break;\n+\tcase 'd': /* device */\n+\t  selectors = omp_device_selectors;\n+\t  allow_score = false;\n+\t  allow_user = true;\n+\t  property_limit = 3;\n+\t  property_kind = CTX_PROPERTY_NAME_LIST;\n+\t  break;\n+\tcase 'i': /* implementation */\n+\t  selectors = omp_implementation_selectors;\n+\t  allow_user = true;\n+\t  property_limit = 3;\n+\t  property_kind = CTX_PROPERTY_NAME_LIST;\n+\t  break;\n+\tcase 'u': /* user */\n+\t  selectors = omp_user_selectors;\n+\t  property_limit = 1;\n+\t  property_kind = CTX_PROPERTY_EXPR;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      for (int i = 0; ; i++)\n+\t{\n+\t  if (selectors[i] == NULL)\n+\t    {\n+\t      if (allow_user)\n+\t\t{\n+\t\t  property_kind = CTX_PROPERTY_USER;\n+\t\t  break;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gfc_error (\"selector '%s' not allowed for context selector \"\n+\t\t\t     \"set '%s' at %C\",\n+\t\t\t     selector, oss->trait_set_selector_name);\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t    }\n+\t  if (i == property_limit)\n+\t    property_kind = CTX_PROPERTY_NONE;\n+\t  if (strcmp (selectors[i], selector) == 0)\n+\t    break;\n+\t}\n+      if (property_kind == CTX_PROPERTY_NAME_LIST\n+\t  && oss->trait_set_selector_name[0] == 'i'\n+\t  && strcmp (selector, \"atomic_default_mem_order\") == 0)\n+\tproperty_kind = CTX_PROPERTY_ID;\n+\n+      if (gfc_match (\" (\") == MATCH_YES)\n+\t{\n+\t  if (property_kind == CTX_PROPERTY_NONE)\n+\t    {\n+\t      gfc_error (\"selector '%s' does not accept any properties at %C\",\n+\t\t\t selector);\n+\t      return MATCH_ERROR;\n+\t    }\n+\n+\t  if (allow_score && gfc_match (\" score\") == MATCH_YES)\n+\t    {\n+\t      if (gfc_match (\" (\") != MATCH_YES)\n+\t\t{\n+\t\t  gfc_error (\"expected '(' at %C\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t      if (gfc_match_expr (&os->score) != MATCH_YES\n+\t\t  || !gfc_resolve_expr (os->score)\n+\t\t  || os->score->ts.type != BT_INTEGER\n+\t\t  || os->score->rank != 0)\n+\t\t{\n+\t\t  gfc_error (\"score argument must be constant integer \"\n+\t\t\t     \"expression at %C\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\n+\t      if (os->score->expr_type == EXPR_CONSTANT\n+\t\t  && mpz_sgn (os->score->value.integer) < 0)\n+\t\t{\n+\t\t  gfc_error (\"score argument must be non-negative at %C\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\n+\t      if (gfc_match (\" )\") != MATCH_YES)\n+\t\t{\n+\t\t  gfc_error (\"expected ')' at %C\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\n+\t      if (gfc_match (\" :\") != MATCH_YES)\n+\t\t{\n+\t\t  gfc_error (\"expected : at %C\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t    }\n+\n+\t  gfc_omp_trait_property *otp = gfc_get_omp_trait_property ();\n+\t  otp->property_kind = property_kind;\n+\t  otp->next = os->properties;\n+\t  os->properties = otp;\n+\n+\t  switch (property_kind)\n+\t    {\n+\t    case CTX_PROPERTY_USER:\n+\t      do\n+\t\t{\n+\t\t  if (gfc_match_expr (&otp->expr) != MATCH_YES)\n+\t\t    {\n+\t\t      gfc_error (\"property must be constant integer \"\n+\t\t\t\t \"expression or string literal at %C\");\n+\t\t      return MATCH_ERROR;\n+\t\t    }\n+\n+\t\t  if (gfc_match (\" ,\") != MATCH_YES)\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      break;\n+\t    case CTX_PROPERTY_ID:\n+\t      {\n+\t\tchar buf[GFC_MAX_SYMBOL_LEN + 1];\n+\t\tif (gfc_match_name (buf) == MATCH_YES)\n+\t\t  {\n+\t\t    otp->name = XNEWVEC (char, strlen (buf) + 1);\n+\t\t    strcpy (otp->name, buf);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    gfc_error (\"expected identifier at %C\");\n+\t\t    return MATCH_ERROR;\n+\t\t  }\n+\t      }\n+\t      break;\n+\t    case CTX_PROPERTY_NAME_LIST:\n+\t      do\n+\t\t{\n+\t\t  char buf[GFC_MAX_SYMBOL_LEN + 1];\n+\t\t  if (gfc_match_name (buf) == MATCH_YES)\n+\t\t    {\n+\t\t      otp->name = XNEWVEC (char, strlen (buf) + 1);\n+\t\t      strcpy (otp->name, buf);\n+\t\t      otp->is_name = true;\n+\t\t    }\n+\t\t  else if (gfc_match_literal_constant (&otp->expr, 0)\n+\t\t\t   != MATCH_YES\n+\t\t\t   || otp->expr->ts.type != BT_CHARACTER)\n+\t\t    {\n+\t\t      gfc_error (\"expected identifier or string literal \"\n+\t\t\t\t \"at %C\");\n+\t\t      return MATCH_ERROR;\n+\t\t    }\n+\n+\t\t  if (gfc_match (\" ,\") == MATCH_YES)\n+\t\t    {\n+\t\t      otp = gfc_get_omp_trait_property ();\n+\t\t      otp->property_kind = property_kind;\n+\t\t      otp->next = os->properties;\n+\t\t      os->properties = otp;\n+\t\t    }\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t      while (1);\n+\t      break;\n+\t    case CTX_PROPERTY_EXPR:\n+\t      if (gfc_match_expr (&otp->expr) != MATCH_YES)\n+\t\t{\n+\t\t  gfc_error (\"expected expression at %C\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t      if (!gfc_resolve_expr (otp->expr)\n+\t\t  || (otp->expr->ts.type != BT_LOGICAL\n+\t\t      && otp->expr->ts.type != BT_INTEGER)\n+\t\t  || otp->expr->rank != 0)\n+\t\t{\n+\t\t  gfc_error (\"property must be constant integer or logical \"\n+\t\t\t     \"expression at %C\");\n+\t\t  return MATCH_ERROR;\n+\t\t}\n+\t      break;\n+\t    case CTX_PROPERTY_SIMD:\n+\t      {\n+\t\tif (gfc_match_omp_clauses (&otp->clauses,\n+\t\t\t\t\t   OMP_DECLARE_SIMD_CLAUSES,\n+\t\t\t\t\t   true, false, false, true)\n+\t\t    != MATCH_YES)\n+\t\t  {\n+\t\t  gfc_error (\"expected simd clause at %C\");\n+\t\t    return MATCH_ERROR;\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    default:\n+\t      gcc_unreachable ();\n+\t    }\n+\n+\t  if (gfc_match (\" )\") != MATCH_YES)\n+\t    {\n+\t      gfc_error (\"expected ')' at %C\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\t}\n+      else if (property_kind == CTX_PROPERTY_NAME_LIST\n+\t       || property_kind == CTX_PROPERTY_ID\n+\t       || property_kind == CTX_PROPERTY_EXPR)\n+\t{\n+\t  if (gfc_match (\" (\") != MATCH_YES)\n+\t    {\n+\t      gfc_error (\"expected '(' at %C\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\t}\n+\n+      if (gfc_match (\" ,\") != MATCH_YES)\n+\tbreak;\n+    }\n+  while (1);\n+\n+  return MATCH_YES;\n+}\n+\n+/* OpenMP 5.0:\n+\n+   trait-set-selector[,trait-set-selector[,...]]\n+\n+   trait-set-selector:\n+     trait-set-selector-name = { trait-selector[, trait-selector[, ...]] }\n+\n+   trait-set-selector-name:\n+     constructor\n+     device\n+     implementation\n+     user  */\n+\n+match\n+gfc_match_omp_context_selector_specification (gfc_omp_declare_variant *odv)\n+{\n+  do\n+    {\n+      match m;\n+      const char *selector_sets[] = { \"construct\", \"device\",\n+\t\t\t\t      \"implementation\", \"user\" };\n+      const int selector_set_count\n+\t= sizeof (selector_sets) / sizeof (*selector_sets);\n+      int i;\n+      char buf[GFC_MAX_SYMBOL_LEN + 1];\n+\n+      m = gfc_match_name (buf);\n+      if (m == MATCH_YES)\n+\tfor (i = 0; i < selector_set_count; i++)\n+\t  if (strcmp (buf, selector_sets[i]) == 0)\n+\t    break;\n+\n+      if (m != MATCH_YES || i == selector_set_count)\n+\t{\n+\t  gfc_error (\"expected 'construct', 'device', 'implementation' or \"\n+\t\t     \"'user' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      m = gfc_match (\" =\");\n+      if (m != MATCH_YES)\n+\t{\n+\t  gfc_error (\"expected '=' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      m = gfc_match (\" {\");\n+      if (m != MATCH_YES)\n+\t{\n+\t  gfc_error (\"expected '{' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      gfc_omp_set_selector *oss = gfc_get_omp_set_selector ();\n+      oss->next = odv->set_selectors;\n+      oss->trait_set_selector_name = selector_sets[i];\n+      odv->set_selectors = oss;\n+\n+      if (gfc_match_omp_context_selector (oss) != MATCH_YES)\n+\treturn MATCH_ERROR;\n+\n+      m = gfc_match (\" }\");\n+      if (m != MATCH_YES)\n+\t{\n+\t  gfc_error (\"expected '}' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      m = gfc_match (\" ,\");\n+      if (m != MATCH_YES)\n+\tbreak;\n+    }\n+  while (1);\n+\n+  return MATCH_YES;\n+}\n+\n+\n+match\n+gfc_match_omp_declare_variant (void)\n+{\n+  bool first_p = true;\n+  char buf[GFC_MAX_SYMBOL_LEN + 1];\n+\n+  if (gfc_match (\" (\") != MATCH_YES)\n+    {\n+      gfc_error (\"expected '(' at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  gfc_symtree *base_proc_st, *variant_proc_st;\n+  if (gfc_match_name (buf) != MATCH_YES)\n+    {\n+      gfc_error (\"expected name at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (gfc_get_ha_sym_tree (buf, &base_proc_st))\n+    return MATCH_ERROR;\n+\n+  if (gfc_match (\" :\") == MATCH_YES)\n+    {\n+      if (gfc_match_name (buf) != MATCH_YES)\n+\t{\n+\t  gfc_error (\"expected variant name at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      if (gfc_get_ha_sym_tree (buf, &variant_proc_st))\n+\treturn MATCH_ERROR;\n+    }\n+  else\n+    {\n+      /* Base procedure not specified.  */\n+      variant_proc_st = base_proc_st;\n+      base_proc_st = NULL;\n+    }\n+\n+  gfc_omp_declare_variant *odv;\n+  odv = gfc_get_omp_declare_variant ();\n+  odv->where = gfc_current_locus;\n+  odv->variant_proc_symtree = variant_proc_st;\n+  odv->base_proc_symtree = base_proc_st;\n+  odv->next = NULL;\n+  odv->error_p = false;\n+\n+  /* Add the new declare variant to the end of the list.  */\n+  gfc_omp_declare_variant **prev_next = &gfc_current_ns->omp_declare_variant;\n+  while (*prev_next)\n+    prev_next = &((*prev_next)->next);\n+  *prev_next = odv;\n+\n+  if (gfc_match (\" )\") != MATCH_YES)\n+    {\n+      gfc_error (\"expected ')' at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n+  for (;;)\n+    {\n+      if (gfc_match (\" match\") != MATCH_YES)\n+\t{\n+\t  if (first_p)\n+\t    {\n+\t      gfc_error (\"expected 'match' at %C\");\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+\n+      if (gfc_match (\" (\") != MATCH_YES)\n+\t{\n+\t  gfc_error (\"expected '(' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      if (gfc_match_omp_context_selector_specification (odv) != MATCH_YES)\n+\treturn MATCH_ERROR;\n+\n+      if (gfc_match (\" )\") != MATCH_YES)\n+\t{\n+\t  gfc_error (\"expected ')' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n+      first_p = false;\n+    }\n+\n+  return MATCH_YES;\n+}\n+\n+\n match\n gfc_match_omp_threadprivate (void)\n {"}, {"sha": "2a454be79b0d8d3438c223669137f571a0e7b74d", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -26,6 +26,8 @@ along with GCC; see the file COPYING3.  If not see\n #include <setjmp.h>\n #include \"match.h\"\n #include \"parse.h\"\n+#include \"tree-core.h\"\n+#include \"omp-general.h\"\n \n /* Current statement label.  Zero means no statement label.  Because new_st\n    can get wiped during statement matching, we have to keep it separate.  */\n@@ -860,6 +862,8 @@ decode_omp_directive (void)\n \t       ST_OMP_DECLARE_SIMD);\n       matchdo (\"declare target\", gfc_match_omp_declare_target,\n \t       ST_OMP_DECLARE_TARGET);\n+      matchdo (\"declare variant\", gfc_match_omp_declare_variant,\n+\t       ST_OMP_DECLARE_VARIANT);\n       break;\n     case 's':\n       matchs (\"simd\", gfc_match_omp_simd, ST_OMP_SIMD);\n@@ -1718,6 +1722,7 @@ next_statement (void)\n \n #define case_omp_decl case ST_OMP_THREADPRIVATE: case ST_OMP_DECLARE_SIMD: \\\n   case ST_OMP_DECLARE_TARGET: case ST_OMP_DECLARE_REDUCTION: \\\n+  case ST_OMP_DECLARE_VARIANT: \\\n   case ST_OMP_REQUIRES: case ST_OACC_ROUTINE: case ST_OACC_DECLARE\n \n /* Block end statements.  Errors associated with interchanging these\n@@ -2361,6 +2366,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_DECLARE_TARGET:\n       p = \"!$OMP DECLARE TARGET\";\n       break;\n+    case ST_OMP_DECLARE_VARIANT:\n+      p = \"!$OMP DECLARE VARIANT\";\n+      break;\n     case ST_OMP_DEPOBJ:\n       p = \"!$OMP DEPOBJ\";\n       break;\n@@ -6793,6 +6801,24 @@ gfc_parse_file (void)\n        gfc_current_ns = gfc_current_ns->sibling)\n     gfc_check_omp_requires (gfc_current_ns, omp_requires);\n \n+  /* Populate omp_requires_mask (needed for resolving OpenMP\n+     metadirectives and declare variant).  */\n+  switch (omp_requires & OMP_REQ_ATOMIC_MEM_ORDER_MASK)\n+    {\n+    case OMP_REQ_ATOMIC_MEM_ORDER_SEQ_CST:\n+      omp_requires_mask\n+\t= (enum omp_requires) (omp_requires_mask | OMP_MEMORY_ORDER_SEQ_CST);\n+      break;\n+    case OMP_REQ_ATOMIC_MEM_ORDER_ACQ_REL:\n+      omp_requires_mask\n+\t= (enum omp_requires) (omp_requires_mask | OMP_MEMORY_ORDER_ACQ_REL);\n+      break;\n+    case OMP_REQ_ATOMIC_MEM_ORDER_RELAXED:\n+      omp_requires_mask\n+\t= (enum omp_requires) (omp_requires_mask | OMP_MEMORY_ORDER_RELAXED);\n+      break;\n+    }\n+\n   /* Do the parse tree dump.  */\n   gfc_current_ns = flag_dump_fortran_original ? gfc_global_ns_list : NULL;\n "}, {"sha": "2c4acd5abe17211b41efc8b3e63cdbdfa9757ab2", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -4046,6 +4046,7 @@ gfc_free_namespace (gfc_namespace *ns)\n   free_tb_tree (ns->tb_uop_root);\n   gfc_free_finalizer_list (ns->finalizers);\n   gfc_free_omp_declare_simd_list (ns->omp_declare_simd);\n+  gfc_free_omp_declare_variant_list (ns->omp_declare_variant);\n   gfc_free_charlen (ns->cl_list, NULL);\n   free_st_labels (ns->st_labels);\n "}, {"sha": "7da1d2ebdcf14172e880b7b15d97416cd7f64a51", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -2362,9 +2362,13 @@ gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args,\n     pushdecl_top_level (fndecl);\n \n   if (sym->formal_ns\n-      && sym->formal_ns->proc_name == sym\n-      && sym->formal_ns->omp_declare_simd)\n-    gfc_trans_omp_declare_simd (sym->formal_ns);\n+      && sym->formal_ns->proc_name == sym)\n+    {\n+      if (sym->formal_ns->omp_declare_simd)\n+\tgfc_trans_omp_declare_simd (sym->formal_ns);\n+      if (flag_openmp)\n+\tgfc_trans_omp_declare_variant (sym->formal_ns);\n+    }\n \n   return fndecl;\n }\n@@ -3112,6 +3116,12 @@ gfc_create_function_decl (gfc_namespace * ns, bool global)\n \n   if (ns->omp_declare_simd)\n     gfc_trans_omp_declare_simd (ns);\n+\n+  /* Handle 'declare variant' directives.  The applicable directives might\n+     be declared in a parent namespace, so this needs to be called even if\n+     there are no local directives.  */\n+  if (flag_openmp)\n+    gfc_trans_omp_declare_variant (ns);\n }\n \n /* Return the decl used to hold the function return value.  If"}, {"sha": "37d23310e3e8b3c5fc424c99e6d476ad595ba32a", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -7258,3 +7258,207 @@ gfc_trans_omp_declare_simd (gfc_namespace *ns)\n       DECL_ATTRIBUTES (fndecl) = c;\n     }\n }\n+\n+void\n+gfc_trans_omp_declare_variant (gfc_namespace *ns)\n+{\n+  tree base_fn_decl = ns->proc_name->backend_decl;\n+  gfc_namespace *search_ns = ns;\n+  gfc_omp_declare_variant *next;\n+\n+  for (gfc_omp_declare_variant *odv = search_ns->omp_declare_variant;\n+       search_ns; odv = next)\n+    {\n+      /* Look in the parent namespace if there are no more directives in the\n+\t current namespace.  */\n+      if (!odv)\n+\t{\n+\t  search_ns = search_ns->parent;\n+\t  if (search_ns)\n+\t    next = search_ns->omp_declare_variant;\n+\t  continue;\n+\t}\n+\n+      next = odv->next;\n+\n+      if (odv->error_p)\n+\tcontinue;\n+\n+      /* Check directive the first time it is encountered.  */\n+      bool error_found = true;\n+\n+      if (odv->checked_p)\n+\terror_found = false;\n+      if (odv->base_proc_symtree == NULL)\n+\t{\n+\t  if (!search_ns->proc_name->attr.function\n+\t      && !search_ns->proc_name->attr.subroutine)\n+\t    gfc_error (\"The base name for 'declare variant' must be \"\n+\t\t       \"specified at %L \", &odv->where);\n+\t  else\n+\t    error_found = false;\n+\t}\n+      else\n+\t{\n+\t  if (!search_ns->contained\n+\t      && strcmp (odv->base_proc_symtree->name,\n+\t\t\t ns->proc_name->name))\n+\t    gfc_error (\"The base name at %L does not match the name of the \"\n+\t\t       \"current procedure\", &odv->where);\n+\t  else if (odv->base_proc_symtree->n.sym->attr.entry)\n+\t    gfc_error (\"The base name at %L must not be an entry name\",\n+\t\t\t&odv->where);\n+\t  else if (odv->base_proc_symtree->n.sym->attr.generic)\n+\t    gfc_error (\"The base name at %L must not be a generic name\",\n+\t\t\t&odv->where);\n+\t  else if (odv->base_proc_symtree->n.sym->attr.proc_pointer)\n+\t    gfc_error (\"The base name at %L must not be a procedure pointer\",\n+\t\t\t&odv->where);\n+\t  else if (odv->base_proc_symtree->n.sym->attr.implicit_type)\n+\t    gfc_error (\"The base procedure at %L must have an explicit \"\n+\t\t\t\"interface\", &odv->where);\n+\t  else\n+\t    error_found = false;\n+\t}\n+\n+      odv->checked_p = true;\n+      if (error_found)\n+\t{\n+\t  odv->error_p = true;\n+\t  continue;\n+\t}\n+\n+      /* Ignore directives that do not apply to the current procedure.  */\n+      if ((odv->base_proc_symtree == NULL && search_ns != ns)\n+\t  || (odv->base_proc_symtree != NULL\n+\t      && strcmp (odv->base_proc_symtree->name, ns->proc_name->name)))\n+\tcontinue;\n+\n+      tree set_selectors = NULL_TREE;\n+      gfc_omp_set_selector *oss;\n+\n+      for (oss = odv->set_selectors; oss; oss = oss->next)\n+\t{\n+\t  tree selectors = NULL_TREE;\n+\t  gfc_omp_selector *os;\n+\t  for (os = oss->trait_selectors; os; os = os->next)\n+\t    {\n+\t      tree properties = NULL_TREE;\n+\t      gfc_omp_trait_property *otp;\n+\n+\t      for (otp = os->properties; otp; otp = otp->next)\n+\t\t{\n+\t\t  switch (otp->property_kind)\n+\t\t    {\n+\t\t    case CTX_PROPERTY_USER:\n+\t\t    case CTX_PROPERTY_EXPR:\n+\t\t      {\n+\t\t\tgfc_se se;\n+\t\t\tgfc_init_se (&se, NULL);\n+\t\t\tgfc_conv_expr (&se, otp->expr);\n+\t\t\tproperties = tree_cons (NULL_TREE, se.expr,\n+\t\t\t\t\t\tproperties);\n+\t\t      }\n+\t\t      break;\n+\t\t    case CTX_PROPERTY_ID:\n+\t\t      properties = tree_cons (get_identifier (otp->name),\n+\t\t\t\t\t      NULL_TREE, properties);\n+\t\t      break;\n+\t\t    case CTX_PROPERTY_NAME_LIST:\n+\t\t      {\n+\t\t\ttree prop = NULL_TREE, value = NULL_TREE;\n+\t\t\tif (otp->is_name)\n+\t\t\t  prop = get_identifier (otp->name);\n+\t\t\telse\n+\t\t\t  value = gfc_conv_constant_to_tree (otp->expr);\n+\n+\t\t\tproperties = tree_cons (prop, value, properties);\n+\t\t      }\n+\t\t      break;\n+\t\t    case CTX_PROPERTY_SIMD:\n+\t\t      properties = gfc_trans_omp_clauses (NULL, otp->clauses,\n+\t\t\t\t\t\t\t  odv->where, true);\n+\t\t      break;\n+\t\t    default:\n+\t\t      gcc_unreachable ();\n+\t\t    }\n+\t\t}\n+\n+\t      if (os->score)\n+\t\t{\n+\t\t  gfc_se se;\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  gfc_conv_expr (&se, os->score);\n+\t\t  properties = tree_cons (get_identifier (\" score\"),\n+\t\t\t\t\t  se.expr, properties);\n+\t\t}\n+\n+\t      selectors = tree_cons (get_identifier (os->trait_selector_name),\n+\t\t\t\t     properties, selectors);\n+\t    }\n+\n+\t  set_selectors\n+\t    = tree_cons (get_identifier (oss->trait_set_selector_name),\n+\t\t\t selectors, set_selectors);\n+\t}\n+\n+      const char *variant_proc_name = odv->variant_proc_symtree->name;\n+      gfc_symbol *variant_proc_sym = odv->variant_proc_symtree->n.sym;\n+      if (variant_proc_sym == NULL || variant_proc_sym->attr.implicit_type)\n+\t{\n+\t  gfc_symtree *proc_st;\n+\t  gfc_find_sym_tree (variant_proc_name, gfc_current_ns, 1, &proc_st);\n+\t  variant_proc_sym = proc_st->n.sym;\n+\t}\n+      if (variant_proc_sym == NULL)\n+\t{\n+\t  gfc_error (\"Cannot find symbol %qs\", variant_proc_name);\n+\t  continue;\n+\t}\n+      set_selectors = omp_check_context_selector\n+\t  (gfc_get_location (&odv->where), set_selectors);\n+      if (set_selectors != error_mark_node)\n+\t{\n+\t  if (!variant_proc_sym->attr.implicit_type\n+\t      && !variant_proc_sym->attr.subroutine\n+\t      && !variant_proc_sym->attr.function)\n+\t    {\n+\t      gfc_error (\"variant %qs at %L is not a function or subroutine\",\n+\t\t\t variant_proc_name, &odv->where);\n+\t      variant_proc_sym = NULL;\n+\t    }\n+\t  else if (omp_get_context_selector (set_selectors, \"construct\",\n+\t\t\t\t\t     \"simd\") == NULL_TREE)\n+\t    {\n+\t      char err[256];\n+\t      if (!gfc_compare_interfaces (ns->proc_name, variant_proc_sym,\n+\t\t\t\t\t   variant_proc_sym->name, 0, 1,\n+\t\t\t\t\t   err, sizeof (err), NULL, NULL))\n+\t\t{\n+\t\t  gfc_error (\"variant %qs and base %qs at %L have \"\n+\t\t\t     \"incompatible types: %s\",\n+\t\t\t     variant_proc_name, ns->proc_name->name,\n+\t\t\t     &odv->where, err);\n+\t\t  variant_proc_sym = NULL;\n+\t\t}\n+\t    }\n+\t  if (variant_proc_sym != NULL)\n+\t    {\n+\t      gfc_set_sym_referenced (variant_proc_sym);\n+\t      tree construct = omp_get_context_selector (set_selectors,\n+\t\t\t\t\t\t\t \"construct\", NULL);\n+\t      omp_mark_declare_variant (gfc_get_location (&odv->where),\n+\t\t\t\t\tgfc_get_symbol_decl (variant_proc_sym),\n+\t\t\t\t\tconstruct);\n+\t      if (omp_context_selector_matches (set_selectors))\n+\t\t{\n+\t\t  tree id = get_identifier (\"omp declare variant base\");\n+\t\t  tree variant = gfc_get_symbol_decl (variant_proc_sym);\n+\t\t  DECL_ATTRIBUTES (base_fn_decl)\n+\t\t    = tree_cons (id, build_tree_list (variant, set_selectors),\n+\t\t\t\t DECL_ATTRIBUTES (base_fn_decl));\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}"}, {"sha": "1a24d9b4cdc23b1402e170f602f22d7cd6d92acb", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -71,6 +71,7 @@ tree gfc_trans_deallocate_array (tree);\n /* trans-openmp.c */\n tree gfc_trans_omp_directive (gfc_code *);\n void gfc_trans_omp_declare_simd (gfc_namespace *);\n+void gfc_trans_omp_declare_variant (gfc_namespace *);\n tree gfc_trans_oacc_directive (gfc_code *);\n tree gfc_trans_oacc_declare (gfc_namespace *);\n "}, {"sha": "44527552413456ab8df83e73387bf2aa9a2f41c8", "filename": "gcc/omp-general.c", "status": "modified", "additions": 142, "deletions": 1, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -1095,6 +1095,146 @@ omp_maybe_offloaded (void)\n   return false;\n }\n \n+\n+/* Diagnose errors in an OpenMP context selector, return CTX if\n+   it is correct or error_mark_node otherwise.  */\n+\n+tree\n+omp_check_context_selector (location_t loc, tree ctx)\n+{\n+  /* Each trait-set-selector-name can only be specified once.\n+     There are just 4 set names.  */\n+  for (tree t1 = ctx; t1; t1 = TREE_CHAIN (t1))\n+    for (tree t2 = TREE_CHAIN (t1); t2; t2 = TREE_CHAIN (t2))\n+      if (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n+\t{\n+\t  error_at (loc, \"selector set %qs specified more than once\",\n+\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t1)));\n+\t  return error_mark_node;\n+\t}\n+  for (tree t = ctx; t; t = TREE_CHAIN (t))\n+    {\n+      /* Each trait-selector-name can only be specified once.  */\n+      if (list_length (TREE_VALUE (t)) < 5)\n+\t{\n+\t  for (tree t1 = TREE_VALUE (t); t1; t1 = TREE_CHAIN (t1))\n+\t    for (tree t2 = TREE_CHAIN (t1); t2; t2 = TREE_CHAIN (t2))\n+\t      if (TREE_PURPOSE (t1) == TREE_PURPOSE (t2))\n+\t\t{\n+\t\t  error_at (loc,\n+\t\t\t    \"selector %qs specified more than once in set %qs\",\n+\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n+\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n+\t\t  return error_mark_node;\n+\t\t}\n+\t}\n+      else\n+\t{\n+\t  hash_set<tree> pset;\n+\t  for (tree t1 = TREE_VALUE (t); t1; t1 = TREE_CHAIN (t1))\n+\t    if (pset.add (TREE_PURPOSE (t1)))\n+\t      {\n+\t\terror_at (loc,\n+\t\t\t  \"selector %qs specified more than once in set %qs\",\n+\t\t\t  IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n+\t\t\t  IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n+\t\treturn error_mark_node;\n+\t      }\n+\t}\n+\n+      static const char *const kind[] = {\n+\t\"host\", \"nohost\", \"cpu\", \"gpu\", \"fpga\", \"any\", NULL };\n+      static const char *const vendor[] = {\n+\t\"amd\", \"arm\", \"bsc\", \"cray\", \"fujitsu\", \"gnu\", \"ibm\", \"intel\",\n+\t\"llvm\", \"nvidia\", \"pgi\", \"ti\", \"unknown\", NULL };\n+      static const char *const extension[] = { NULL };\n+      static const char *const atomic_default_mem_order[] = {\n+\t\"seq_cst\", \"relaxed\", \"acq_rel\", NULL };\n+      struct known_properties { const char *set; const char *selector;\n+\t\t\t\tconst char *const *props; };\n+      known_properties props[] = {\n+\t{ \"device\", \"kind\", kind },\n+\t{ \"implementation\", \"vendor\", vendor },\n+\t{ \"implementation\", \"extension\", extension },\n+\t{ \"implementation\", \"atomic_default_mem_order\",\n+\t  atomic_default_mem_order } };\n+      for (tree t1 = TREE_VALUE (t); t1; t1 = TREE_CHAIN (t1))\n+\tfor (unsigned i = 0; i < ARRAY_SIZE (props); i++)\n+\t  if (!strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t1)),\n+\t\t\t\t\t   props[i].selector)\n+\t      && !strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t)),\n+\t\t\t\t\t      props[i].set))\n+\t    for (tree t2 = TREE_VALUE (t1); t2; t2 = TREE_CHAIN (t2))\n+\t      for (unsigned j = 0; ; j++)\n+\t\t{\n+\t\t  if (props[i].props[j] == NULL)\n+\t\t    {\n+\t\t      if (TREE_PURPOSE (t2)\n+\t\t\t  && !strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t      \" score\"))\n+\t\t\tbreak;\n+\t\t      if (props[i].props == atomic_default_mem_order)\n+\t\t\t{\n+\t\t\t  error_at (loc,\n+\t\t\t\t    \"incorrect property %qs of %qs selector\",\n+\t\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t    \"atomic_default_mem_order\");\n+\t\t\t  return error_mark_node;\n+\t\t\t}\n+\t\t      else if (TREE_PURPOSE (t2))\n+\t\t\twarning_at (loc, 0,\n+\t\t\t\t    \"unknown property %qs of %qs selector\",\n+\t\t\t\t    IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t    props[i].selector);\n+\t\t      else\n+\t\t\twarning_at (loc, 0,\n+\t\t\t\t    \"unknown property %qE of %qs selector\",\n+\t\t\t\t    TREE_VALUE (t2), props[i].selector);\n+\t\t      break;\n+\t\t    }\n+\t\t  else if (TREE_PURPOSE (t2) == NULL_TREE)\n+\t\t    {\n+\t\t      const char *str = TREE_STRING_POINTER (TREE_VALUE (t2));\n+\t\t      if (!strcmp (str, props[i].props[j])\n+\t\t\t  && ((size_t) TREE_STRING_LENGTH (TREE_VALUE (t2))\n+\t\t\t      == strlen (str) + (lang_GNU_Fortran () ? 0 : 1)))\n+\t\t\tbreak;\n+\t\t    }\n+\t\t  else if (!strcmp (IDENTIFIER_POINTER (TREE_PURPOSE (t2)),\n+\t\t\t\t    props[i].props[j]))\n+\t\t    break;\n+\t\t}\n+    }\n+  return ctx;\n+}\n+\n+\n+/* Register VARIANT as variant of some base function marked with\n+   #pragma omp declare variant.  CONSTRUCT is corresponding construct\n+   selector set.  */\n+\n+void\n+omp_mark_declare_variant (location_t loc, tree variant, tree construct)\n+{\n+  tree attr = lookup_attribute (\"omp declare variant variant\",\n+\t\t\t\tDECL_ATTRIBUTES (variant));\n+  if (attr == NULL_TREE)\n+    {\n+      attr = tree_cons (get_identifier (\"omp declare variant variant\"),\n+\t\t\tunshare_expr (construct),\n+\t\t\tDECL_ATTRIBUTES (variant));\n+      DECL_ATTRIBUTES (variant) = attr;\n+      return;\n+    }\n+  if ((TREE_VALUE (attr) != NULL_TREE) != (construct != NULL_TREE)\n+      || (construct != NULL_TREE\n+\t  && omp_context_selector_set_compare (\"construct\", TREE_VALUE (attr),\n+\t\t\t\t\t       construct)))\n+    error_at (loc, \"%qD used as a variant with incompatible %<construct%> \"\n+\t\t   \"selector sets\", variant);\n+}\n+\n+\n /* Return a name from PROP, a property in selectors accepting\n    name lists.  */\n \n@@ -1106,7 +1246,8 @@ omp_context_name_list_prop (tree prop)\n   else\n     {\n       const char *ret = TREE_STRING_POINTER (TREE_VALUE (prop));\n-      if ((size_t) TREE_STRING_LENGTH (TREE_VALUE (prop)) == strlen (ret) + 1)\n+      if ((size_t) TREE_STRING_LENGTH (TREE_VALUE (prop))\n+\t  == strlen (ret) + (lang_GNU_Fortran () ? 0 : 1))\n \treturn ret;\n       return NULL;\n     }"}, {"sha": "8fe744c6a7af0b25939931d81461fcace2eca409", "filename": "gcc/omp-general.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -104,6 +104,9 @@ extern tree find_combined_omp_for (tree *, int *, void *);\n extern poly_uint64 omp_max_vf (void);\n extern int omp_max_simt_vf (void);\n extern int omp_constructor_traits_to_codes (tree, enum tree_code *);\n+extern tree omp_check_context_selector (location_t loc, tree ctx);\n+extern void omp_mark_declare_variant (location_t loc, tree variant,\n+\t\t\t\t      tree construct);\n extern int omp_context_selector_matches (tree);\n extern int omp_context_selector_set_compare (const char *, tree, tree);\n extern tree omp_get_context_selector (tree, const char *, const char *);"}, {"sha": "de09dbfe8062ddca6865b41f9d3383df7c95313c", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-1.f90", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-1.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,93 @@\n+module main\n+  implicit none\n+\n+  interface\n+    integer function foo (a, b, c)\n+      integer, intent(in) :: a, b\n+      integer, intent(inout) :: c\n+    end function\n+\n+    integer function bar (a, b, c)\n+      integer, intent(in) :: a, b\n+      integer, intent(inout) :: c\n+    end function\n+\n+    integer function baz (a, b, c)\n+      integer, intent(in) :: a, b\n+      integer, intent(inout) :: c\n+\n+      !$omp declare variant (foo) &\n+      !$omp & match (construct={parallel,do}, &\n+      !$omp & device={isa(avx512f,avx512vl),kind(host,cpu)}, &\n+      !$omp & implementation={vendor(score(0):gnu),unified_shared_memory}, &\n+      !$omp & user={condition(score(0):0)})\n+      !$omp declare variant (bar) &\n+      !$omp & match (device={arch(x86_64,powerpc64),isa(avx512f,popcntb)}, &\n+      !$omp & implementation={atomic_default_mem_order(seq_cst),made_up_selector(\"foo\", 13, \"bar\")}, &\n+      !$omp & user={condition(3-3)})\n+    end function\n+\n+    subroutine quux\n+    end subroutine quux\n+\n+    integer function baz3 (x, y, z)\n+      integer, intent(in) :: x, y\n+      integer, intent(inout) :: z\n+\n+      !$omp declare variant (bar) match &\n+      !$omp & (implementation={atomic_default_mem_order(score(3): acq_rel)})\n+    end function\n+  end interface\n+contains\n+  integer function qux ()\n+    integer :: i = 3\n+\n+    qux = baz (1, 2, i)\n+  end function\n+\n+  subroutine corge\n+    integer :: i\n+    !$omp declare variant (quux) match (construct={parallel,do})\n+\n+    interface\n+      subroutine waldo (x)\n+        integer, intent(in) :: x\n+      end subroutine\n+    end interface\n+\n+    call waldo (5)\n+    !$omp parallel do\n+      do i = 1, 3\n+\tcall waldo (6)\n+      end do\n+    !$omp end parallel do\n+\n+    !$omp parallel\n+      !$omp taskgroup\n+\t!$omp do\n+\t  do i = 1, 3\n+\t    call waldo (7)\n+\t  end do\n+        !$omp end do\n+      !$omp end taskgroup\n+    !$omp end parallel\n+\n+    !$omp parallel\n+      !$omp master\n+        call waldo (8)\n+      !$omp end master\n+    !$omp end parallel\n+  end subroutine\n+\n+  integer function baz2 (x, y, z)\n+    integer, intent(in) :: x, y\n+    integer, intent(inout) :: z\n+\n+    !$omp declare variant (bar) match &\n+    !$omp & (implementation={atomic_default_mem_order(relaxed), &\n+    !$omp &\t\t   unified_address, unified_shared_memory, &\n+    !$omp &\t\t   dynamic_allocators, reverse_offload})\n+\n+    baz2 = x + y + z\n+  end function\n+end module"}, {"sha": "d6d2c8c262b4fe21cdd192ce5964550a63d7811b", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-10.f90", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-10.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,97 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-cpp -foffload=disable -fdump-tree-gimple\" }\n+! { dg-additional-options \"-mavx512bw\" { target { i?86-*-* x86_64-*-* } } }\n+\n+#undef i386\n+\n+program main\n+  !$omp declare target to (test3)\n+contains\n+  subroutine f01 ()\n+  end subroutine\n+  subroutine f02 ()\n+    !$omp declare variant (f01) match (device={isa(avx512f,avx512bw)})\n+  end subroutine\n+  subroutine f03 ()\n+  end subroutine\n+  subroutine f04 ()\n+    !$omp declare variant (f03) match (device={kind(\"any\"),arch(x86_64),isa(avx512f,avx512bw)})\n+  end subroutine\n+  subroutine f05 ()\n+  end subroutine\n+  subroutine f06 ()\n+    !$omp declare variant (f05) match (device={kind(gpu)})\n+  end subroutine\n+  subroutine f07 ()\n+  end subroutine\n+  subroutine f08 ()\n+    !$omp declare variant (f07) match (device={kind(cpu)})\n+  end subroutine\n+  subroutine f09 ()\n+  end subroutine\n+  subroutine f10 ()\n+    !$omp declare variant (f09) match (device={isa(sm_35)})\n+  end subroutine\n+  subroutine f11 ()\n+  end subroutine\n+  subroutine f12 ()\n+    !$omp declare variant (f11) match (device={arch(\"nvptx\")})\n+  end subroutine\n+  subroutine f13 ()\n+  end subroutine\n+  subroutine f14 ()\n+    !$omp declare variant (f13) match (device={arch(i386),isa(\"sse4\")})\n+  end subroutine\n+  subroutine f15 ()\n+  end subroutine\n+  subroutine f16 ()\n+    !$omp declare variant (f15) match (device={isa(sse4,ssse3),arch(i386)})\n+  end subroutine\n+  subroutine f17 ()\n+  end subroutine\n+  subroutine f18 ()\n+    !$omp declare variant (f17) match (device={kind(any,fpga)})\n+  end subroutine\n+\n+  subroutine test1 ()\n+    !$omp declare target\n+    integer :: i\n+\n+    call f02 ()\t  ! { dg-final { scan-tree-dump-times \"f01 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } }\n+\t\t  ! { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } }\n+    call f14 ()\t  ! { dg-final { scan-tree-dump-times \"f13 \\\\\\(\\\\\\);\" 1 \"gimple\" { target ia32 } } }\n+\t\t  ! { dg-final { scan-tree-dump-times \"f14 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! ia32 } } } }\n+    call f18 ()\t  ! { dg-final { scan-tree-dump-times \"f18 \\\\\\(\\\\\\);\" 1 \"gimple\" } } */\n+  end subroutine\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+  __attribute__((target (\"avx512f,avx512bw\")))\n+#endif\n+  subroutine test2 ()\n+    !$omp target\n+      call f04 ()\t! { dg-final { scan-tree-dump-times \"f03 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && lp64 } } } }\n+\t\t\t! { dg-final { scan-tree-dump-times \"f04 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { ! lp64 } || { ! { i?86-*-* x86_64-*-* } } } } } }\n+    !$omp end target\n+    !$omp target\n+      call f16 ()\t! { dg-final { scan-tree-dump-times \"f15 \\\\\\(\\\\\\);\" 1 \"gimple\" { target ia32 } } }\n+\t\t\t! { dg-final { scan-tree-dump-times \"f16 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! ia32 } } } }\n+    !$omp end target\n+  end subroutine\n+\n+  subroutine test3 ()\n+    call f06 ()\t  ! { dg-final { scan-tree-dump-times \"f06 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } }\n+    call f08 ()\t  ! { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } }\n+  end subroutine\n+\n+  subroutine test4 ()\n+    !$omp target\n+      call f10 ()\t! { dg-final { scan-tree-dump-times \"f10 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } }\n+    !$omp end target\n+\n+    !$omp target\n+      call f12 ()\t! { dg-final { scan-tree-dump-times \"f12 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* } } } } }\n+\t\t\t! { dg-final { scan-tree-dump-times \"f11 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { nvptx*-*-* } } } }\n+    !$omp end target\n+  end subroutine\n+end program\n+"}, {"sha": "60aa0fcb3b09f0638787bdc19170f8396ee8ea7c", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-11.f90", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-11.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,134 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-foffload=disable -fdump-tree-gimple\" }\n+! { dg-additional-options \"-mavx512bw -mavx512vl\" { target { i?86-*-* x86_64-*-* } } }\n+\n+program main\n+  implicit none\n+contains\n+  subroutine f01 ()\n+  end subroutine\n+\n+  subroutine f02 ()\n+  end subroutine\n+\n+  subroutine f03 ()\n+    !$omp declare variant (f01) match (device={isa(avx512f,\"avx512vl\")})\n+    !$omp declare variant (f02) match (device={isa(avx512bw,avx512vl,\"avx512f\")})\n+  end subroutine\n+\n+  subroutine f04 ()\n+  end subroutine\n+\n+  subroutine f05 ()\n+  end subroutine\n+\n+  subroutine f06 ()\n+    !$omp declare variant (f04) match (device={isa(avx512f,avx512vl)})\n+    !$omp declare variant (f05) match (device={isa(avx512bw,avx512vl,avx512f)})\n+  end subroutine\n+\n+  subroutine f07 ()\n+  end subroutine\n+\n+  subroutine f08 ()\n+  end subroutine\n+\n+  subroutine f09 ()\n+    !$omp declare variant (f07) match (device={isa(sse4,\"sse4.1\",\"sse4.2\",sse3,\"avx\")})\n+    !$omp declare variant (f08) match (device={isa(\"avx\",sse3)})\n+  end subroutine\n+\n+  subroutine f10 ()\n+  end subroutine\n+\n+  subroutine f11 ()\n+  end subroutine\n+\n+  subroutine f12 ()\n+  end subroutine\n+\n+  subroutine f13 ()\n+    !$omp declare variant (f10) match (device={isa(\"avx512f\")})\n+    !$omp declare variant (f11) match (user={condition(1)},device={isa(avx512f)},implementation={vendor(gnu)})\n+    !$omp declare variant (f12) match (user={condition(2 + 1)},device={isa(avx512f)})\n+  end subroutine\n+\n+  subroutine f14 ()\n+  end subroutine\n+\n+  subroutine f15 ()\n+  end subroutine\n+\n+  subroutine f16 ()\n+  end subroutine\n+\n+  subroutine f17 ()\n+  end subroutine\n+\n+  subroutine f18 ()\n+    !$omp declare variant (f14) match (construct={teams,do})\n+    !$omp declare variant (f15) match (construct={teams,parallel,do})\n+    !$omp declare variant (f16) match (construct={do})\n+    !$omp declare variant (f17) match (construct={parallel,do})\n+  end subroutine\n+\n+  subroutine f19 ()\n+  end subroutine\n+\n+  subroutine f20 ()\n+  end subroutine\n+\n+  subroutine f21 ()\n+  end subroutine\n+\n+  subroutine f22 ()\n+  end subroutine\n+\n+  subroutine f23 ()\n+    !$omp declare variant (f19) match (construct={teams,do})\n+    !$omp declare variant (f20) match (construct={teams,parallel,do})\n+    !$omp declare variant (f21) match (construct={do})\n+    !$omp declare variant (f22) match (construct={parallel,do})\n+  end subroutine\n+\n+  subroutine f24 ()\n+  end subroutine\n+\n+  subroutine f25 ()\n+  end subroutine\n+\n+  subroutine f26 ()\n+  end subroutine\n+\n+  subroutine f27 ()\n+    !$omp declare variant (f24) match (device={kind(cpu)})\n+    !$omp declare variant (f25) match (device={kind(cpu),isa(avx512f),arch(x86_64)})\n+    !$omp declare variant (f26) match (device={arch(x86_64),kind(cpu)})\n+  end subroutine\n+\n+  subroutine test1\n+    integer :: i\n+    call f03 ()\t! { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } }\n+\t\t! { dg-final { scan-tree-dump-times \"f03 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } }\n+    call f09 ()\t! { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } }\n+\t\t! { dg-final { scan-tree-dump-times \"f09 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } }\n+    call f13 ()\t! { dg-final { scan-tree-dump-times \"f11 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } }\n+\t\t! { dg-final { scan-tree-dump-times \"f13 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } }\n+    !$omp teams distribute parallel do\n+    do i = 1, 2\n+      call f18 ()\t! { dg-final { scan-tree-dump-times \"f15 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    end do\n+    !$omp end teams distribute parallel do\n+\n+    !$omp parallel do\n+    do i = 1, 2\n+      call f23 ()\t! { dg-final { scan-tree-dump-times \"f22 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    end do\n+    !$omp end parallel do\n+\n+    call f27 ()\t! { dg-final { scan-tree-dump-times \"f25 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && lp64 } } } }\n+\t\t! { dg-final { scan-tree-dump-times \"f24 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } }\n+\t\t! { dg-final { scan-tree-dump-times \"f24 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* i?86-*-* x86_64-*-* } } } } }\n+\t\t! { dg-final { scan-tree-dump-times \"f27 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { nvptx*-*-* amdgcn*-*-* } } } }\n+  end subroutine\n+end program"}, {"sha": "610693e98070c740bdd3f2e92d526ee852f88bbe", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-12.f90", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-12.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,159 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-foffload=disable -fdump-tree-gimple\" }\n+! { dg-additional-options \"-mavx512bw -mavx512vl\" { target { i?86-*-* x86_64-*-* } } }\n+\n+program main\n+  !$omp requires atomic_default_mem_order(seq_cst)\n+contains\n+  subroutine f01 ()\n+  end subroutine\n+\n+  subroutine f02 ()\n+  end subroutine\n+\n+  subroutine f03 ()\n+  end subroutine\n+\n+  subroutine f04 ()\n+    !$omp declare variant (f01) match (device={isa(\"avx512f\",\"avx512vl\")}) ! 16\n+    !$omp declare variant (f02) match (implementation={vendor(score(15):gnu)})\n+    !$omp declare variant (f03) match (user={condition(score(11):1)})\n+  end subroutine\n+\n+  subroutine f05 ()\n+  end subroutine\n+\n+  subroutine f06 ()\n+  end subroutine\n+\n+  subroutine f07 ()\n+  end subroutine\n+\n+  subroutine f08 ()\n+    !$omp declare variant (f05) match (device={isa(avx512f,avx512vl)}) ! 16\n+    !$omp declare variant (f06) match (implementation={vendor(score(15):gnu)})\n+    !$omp declare variant (f07) match (user={condition(score(17):1)})\n+  end subroutine\n+\n+  subroutine f09 ()\n+  end subroutine\n+\n+  subroutine f10 ()\n+  end subroutine\n+\n+  subroutine f11 ()\n+  end subroutine\n+\n+  subroutine f12 ()\n+  end subroutine\n+\n+  subroutine f13 ()\n+    !$omp declare variant (f09) match (device={arch(x86_64)},user={condition(score(65):1)}) ! 64+65\n+    !$omp declare variant (f10) match (implementation={vendor(score(127):\"gnu\")})\n+    !$omp declare variant (f11) match (device={isa(ssse3)}) ! 128\n+    !$omp declare variant (f12) match (implementation={atomic_default_mem_order(score(126):seq_cst)})\n+  end subroutine\n+\n+  subroutine f14 ()\n+  end subroutine\n+\n+  subroutine f15 ()\n+  end subroutine\n+\n+  subroutine f16 ()\n+  end subroutine\n+\n+  subroutine f17 ()\n+    !$omp declare variant (f14) match (construct={teams,parallel,do}) ! 16+8+4\n+    !$omp declare variant (f15) match (construct={parallel},user={condition(score(19):1)}) ! 8+19\n+    !$omp declare variant (f16) match (implementation={atomic_default_mem_order(score(27):seq_cst)})\n+  end subroutine\n+\n+  subroutine f18 ()\n+  end subroutine\n+\n+  subroutine f19 ()\n+  end subroutine\n+\n+  subroutine f20 ()\n+  end subroutine\n+\n+  subroutine f21 ()\n+    !$omp declare variant (f18) match (construct={teams,parallel,do}) ! 16+8+4\n+    !$omp declare variant (f19) match (construct={do},user={condition(score(25):1)}) ! 4+25\n+    !$omp declare variant (f20) match (implementation={atomic_default_mem_order(score(28):seq_cst)})\n+  end subroutine\n+\n+  subroutine f22 ()\n+  end subroutine\n+\n+  subroutine f23 ()\n+  end subroutine\n+\n+  subroutine f24 ()\n+  end subroutine\n+\n+  subroutine f25 ()\n+    !$omp declare variant (f22) match (construct={parallel,do}) ! 2+1\n+    !$omp declare variant (f23) match (construct={do}) ! 0\n+    !$omp declare variant (f24) match (implementation={atomic_default_mem_order(score(2):seq_cst)})\n+  end subroutine\n+\n+  subroutine f26 ()\n+  end subroutine\n+\n+  subroutine f27 ()\n+  end subroutine\n+\n+  subroutine f28 ()\n+  end subroutine\n+\n+  subroutine f29 ()\n+    !$omp declare variant (f26) match (construct={parallel,do}) ! 2+1\n+    !$omp declare variant (f27) match (construct={do},user={condition(1)}) ! 4\n+    !$omp declare variant (f28) match (implementation={atomic_default_mem_order(score(3):seq_cst)})\n+  end subroutine\n+\n+  subroutine test1 ()\n+    integer :: i, j\n+\n+    !$omp parallel do\t! 2 constructs in OpenMP context, isa has score 2^4.\n+    do i = 1, 2\n+      call f04 ()\t! { dg-final { scan-tree-dump-times \"f01 \\\\\\(\\\\\\);\" 1 \"gimple\" { target i?86-*-* x86_64-*-* } } }\n+\t\t\t! { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } }\n+    end do\n+    !$omp end parallel do\n+\n+    !$omp target teams\t! 2 constructs in OpenMP context, isa has score 2^4.\n+      call f08 ()\t! { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    !$omp end target teams\n+\n+    !$omp teams\n+    !$omp parallel do\n+    do i = 1, 2\n+      !$omp parallel do\t! 5 constructs in OpenMP context, arch is 2^6, isa 2^7.\n+      do j = 1, 2\n+\t  call f13 ()\t! { dg-final { scan-tree-dump-times \"f09 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && lp64 } } } }\n+\t\t\t! { dg-final { scan-tree-dump-times \"f11 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { { i?86-*-* x86_64-*-* } && { ! lp64 } } } } }\n+\t\t\t! { dg-final { scan-tree-dump-times \"f10 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { i?86-*-* x86_64-*-* } } } } }\n+\t  call f17 ()\t! { dg-final { scan-tree-dump-times \"f14 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+\t  call f21 ()\t! { dg-final { scan-tree-dump-times \"f19 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+      end do\n+      !$omp end parallel do\n+    end do\n+    !$omp end parallel do\n+    !$omp end teams\n+\n+    !$omp do\n+    do i = 1, 2\n+      !$omp parallel do\n+      do j = 1, 2\n+\tcall f25 ();\t! { dg-final { scan-tree-dump-times \"f22 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+\tcall f29 ();\t! { dg-final { scan-tree-dump-times \"f27 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+      end do\n+      !$omp end parallel do\n+    end do\n+    !$omp end do\n+  end subroutine\n+end program\n+"}, {"sha": "91648f9bcf4b9c030dcdfe89a48c2853375fe4d3", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-13.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-13.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do compile { target vect_simd_clones } }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+! { dg-additional-options \"-mno-sse3\" { target { i?86-*-* x86_64-*-* } } }\n+\n+program main\n+  implicit none\n+contains\n+  integer function f01 (x)\n+    integer, intent(in) :: x\n+    f01 = x\n+  end function\n+\n+  integer function f02 (x)\n+    integer, intent(in) :: x\n+    f02 = x\n+  end function\n+\n+  integer function f03 (x)\n+    integer, intent(in) :: x\n+    f03 = x\n+  end function\n+\n+  integer function f04 (x)\n+    integer, intent(in) :: x\n+    f04 = x\n+  end function\n+\n+  integer function f05 (x)\n+    integer, intent(in) :: x\n+\n+    !$omp declare variant (f01) match (device={isa(\"avx512f\")}) ! 4 or 8\n+    !$omp declare variant (f02) match (implementation={vendor(score(3):gnu)},device={kind(cpu)}) ! (1 or 2) + 3\n+    !$omp declare variant (f03) match (user={condition(score(9):1)})\n+    !$omp declare variant (f04) match (implementation={vendor(score(6):gnu)},device={kind(host)}) ! (1 or 2) + 6\n+    f05 = x\n+  end function\n+\n+  integer function test1 (x)\n+    !$omp declare simd\n+    integer, intent(in) :: x\n+\n+    ! 0 or 1 (the latter if in a declare simd clone) constructs in OpenMP context,\n+    ! isa has score 2^2 or 2^3.  We can't decide on whether avx512f will match or\n+    ! not, that also depends on whether it is a declare simd clone or not and which\n+    ! one, but the f03 variant has a higher score anyway.  */\n+    test1 = f05 (x)\t! { dg-final { scan-tree-dump-times \"f03 \\\\\\(x\" 1 \"gimple\" } }\n+  end function\n+end program"}, {"sha": "06c9a5d1ed8f9a5c0bbb4201e505f4309ef56222", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-14.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-14.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile { target vect_simd_clones } }\n+! { dg-additional-options \"-O0 -fdump-tree-gimple -fdump-tree-optimized\" }\n+! { dg-additional-options \"-mno-sse3\" { target { i?86-*-* x86_64-*-* } } }\n+\n+module main\n+  implicit none\n+contains\n+  integer function f01 (x)\n+    integer, intent (in) :: x\n+    f01 = x\n+  end function\n+\n+  integer function f02 (x)\n+    integer, intent (in) :: x\n+    f02 = x\n+  end function\n+\n+  integer function f03 (x)\n+    integer, intent (in) :: x\n+    f03 = x\n+  end function\n+\n+  integer function f04 (x)\n+    integer, intent(in) :: x\n+\n+    !$omp declare variant (f01) match (device={isa(\"avx512f\")}) ! 4 or 8\n+    !$omp declare variant (f02) match (implementation={vendor(score(3):gnu)},device={kind(cpu)}) ! (1 or 2) + 3\n+    !$omp declare variant (f03) match (implementation={vendor(score(5):gnu)},device={kind(host)}) ! (1 or 2) + 5\n+    f04 = x\n+  end function\n+\n+  integer function test1 (x)\n+    !$omp declare simd\n+    integer, intent (in) :: x\n+    integer :: a, b\n+\n+    ! At gimplification time, we can't decide yet which function to call.\n+    ! { dg-final { scan-tree-dump-times \"f04 \\\\\\(x\" 2 \"gimple\" } }\n+    ! After simd clones are created, the original non-clone test1 shall\n+    ! call f03 (score 6), the sse2/avx/avx2 clones too, but avx512f clones\n+    ! shall call f01 with score 8.\n+    ! { dg-final { scan-tree-dump-not \"f04 \\\\\\(x\" \"optimized\" } }\n+    ! { dg-final { scan-tree-dump-times \"f03 \\\\\\(x\" 14 \"optimized\" } }\n+    ! { dg-final { scan-tree-dump-times \"f01 \\\\\\(x\" 4 \"optimized\" } }\n+    a = f04 (x)\n+    b = f04 (x)\n+    test1 = a + b\n+  end function\n+end module"}, {"sha": "b2ad96a899883f833797a86ab348f8cb5c468a33", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-15.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-15.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+\n+! Test 'declare variant' directive with an explicit base procedure name.\n+\n+module main\n+  implicit none\n+  \n+  !$omp declare variant (base: variant) match (construct={target,parallel})\n+contains\n+  subroutine variant ()\n+  end subroutine\n+\n+  subroutine base ()\n+  end subroutine\n+\n+  subroutine test1 ()\n+    !$omp target\n+      !$omp parallel\n+\tcall base ()\t! { dg-final { scan-tree-dump-times \"variant \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+      !$omp end parallel\n+    !$omp end target\n+  end subroutine\n+end module"}, {"sha": "fc97322e667d9cee73edf7e3a751d353726e1ae1", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-16.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-16.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+\n+! Test that 'declare variant' works when applied to an external subroutine\n+\n+module main\n+  implicit none\n+  \n+  interface\n+    subroutine base ()\n+      !$omp declare variant (variant) match (construct={parallel})\n+    end subroutine\n+  end interface\n+\n+contains\n+  subroutine variant ()\n+  end subroutine\n+\n+  subroutine test ()\n+    !$omp parallel\n+      call base ()  ! { dg-final { scan-tree-dump-times \"variant \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    !$omp end parallel\n+  end subroutine\n+end module"}, {"sha": "df57f9c089cfd043683bbb57f58c83bc3a175f2f", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-17.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-17.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+\n+! Declare variant directives should only appear in the specification parts.\n+\n+program main\n+  implicit none\n+\n+  continue\n+\n+  !$omp declare variant (base: variant) match (construct={parallel})  ! { dg-error \"Unexpected \\\\\\!\\\\\\$OMP DECLARE VARIANT statement at .1.\" }\n+contains\n+  subroutine base ()\n+    continue\n+\n+    !$omp declare variant (variant) match (construct={parallel})  ! { dg-error \"Unexpected \\\\\\!\\\\\\$OMP DECLARE VARIANT statement at .1.\" }\n+  end subroutine\n+end program"}, {"sha": "f97cf34a28a7333900def57563daa1a2b3e4a9e3", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-18.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-18.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+\n+! The base procedure must have an accessible explicit interface when the\n+! directive appears.\n+\n+program main\n+  interface\n+    subroutine base_proc ()\n+    end subroutine\n+  end interface\n+\n+  !$omp declare variant (base_proc: variant_proc) match (construct={parallel})\n+  !$omp declare variant (base_proc2: variant_proc) match (construct={parallel}) ! { dg-error \"The base procedure at .1. must have an explicit interface\" }\n+contains\n+  subroutine variant_proc ()\n+  end subroutine\n+end program"}, {"sha": "d387f5e90659de5acd1cb1aec03c3880826f466e", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-19.f90", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-19.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-19.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-19.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,49 @@\n+! { dg-do compile }\n+\n+! Test Fortran-specific compilation failures.\n+\n+module main\n+  implicit none\n+  \n+  interface base_gen\n+    subroutine base_gen_int (x)\n+      integer :: x\n+    end subroutine\n+\n+    subroutine base_gen_real (x)\n+      real :: x\n+    end subroutine\n+  end interface\n+\n+  interface\n+    subroutine base_p ()\n+    end subroutine\n+  end interface\n+\n+  procedure (base_p), pointer :: base_proc_ptr\n+\n+  !$omp declare variant (base_entry: variant) match (construct={parallel}) ! { dg-error \"The base name at .1. must not be an entry name\" }\n+  !$omp declare variant (base_proc_ptr: variant) match (construct={parallel}) ! { dg-error \"The base name at .1. must not be a procedure pointer\" }\n+  !$omp declare variant (base_gen: variant2) match (construct={parallel}) ! { dg-error \"The base name at .1. must not be a generic name\" }\n+  !$omp declare variant (variant) match (construct={parallel}) ! { dg-error \"The base name for 'declare variant' must be specified at .1.\" }\n+  \n+contains\n+  subroutine base ()\n+    entry base_entry\n+  end subroutine\n+\n+  subroutine base2 ()\n+    !$omp declare variant (variant2) match (construct={parallel})   ! { dg-error \"variant .variant2. and base .base2. at .1. have incompatible types: .variant2. has the wrong number of arguments\" }\n+  end subroutine\n+\n+  subroutine base3 ()\n+    !$omp declare variant (base: variant2) match (construct={parallel}) ! { dg-error \"The base name at .1. does not match the name of the current procedure\" }\n+  end subroutine\n+\n+  subroutine variant ()\n+  end subroutine\n+\n+  subroutine variant2 (x)\n+    integer :: x\n+  end subroutine\n+end module"}, {"sha": "63d777801961643f7ea01c8e3d345aa9a5dec8e8", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-2.f90", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-2.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,197 @@\n+module main\n+  implicit none\n+contains\n+  subroutine f0 ()\n+  end subroutine\n+  subroutine f1 ()\n+  end subroutine\n+  subroutine f2 ()\n+    !$omp declare variant\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f3 ()\n+    !$omp declare variant (\t! { dg-error \"\" }\n+  end subroutine\n+  subroutine f4 ()\n+    !$omp declare variant ()\t! { dg-error \"\" }\n+  end subroutine\n+  subroutine f5 ()\n+    !$omp declare variant match(user={condition(0)})\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f6 ()\n+    !$omp declare variant (f1)\t! { dg-error \"expected 'match' at .1.\" }\n+  end subroutine\n+  subroutine f7 ()\n+    !$omp declare variant (f1) simd\t! { dg-error \"expected 'match' at .1.\" }\n+  end subroutine\n+  subroutine f8 ()\n+    !$omp declare variant (f1) match\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f9 ()\n+    !$omp declare variant (f1) match(\t! { dg-error \"expected 'construct', 'device', 'implementation' or 'user' at .1.\" }\n+  end subroutine\n+  subroutine f10 ()\n+    !$omp declare variant (f1) match()\t! { dg-error \"expected 'construct', 'device', 'implementation' or 'user' at .1.\" }\n+  end subroutine\n+  subroutine f11 ()\n+    !$omp declare variant (f1) match(foo)\t! { dg-error \"expected 'construct', 'device', 'implementation' or 'user' at .1.\" }\n+  end subroutine\n+  subroutine f12 ()\n+    !$omp declare variant (f1) match(something={something})\t! { dg-error \"expected 'construct', 'device', 'implementation' or 'user' at .1.\" }\n+  end subroutine\n+  subroutine f13 ()\n+    !$omp declare variant (f1) match(user)\t! { dg-error \"expected '=' at .1.\" }\n+  end subroutine\n+  subroutine f14 ()\n+    !$omp declare variant (f1) match(user=)\t! { dg-error \"expected '\\\\\\{' at .1.\" }\n+  end subroutine\n+  subroutine f15 ()\n+    !$omp declare variant (f1) match(user=\t! { dg-error \"expected '\\\\\\{' at .1.\" }\n+  end subroutine\n+  subroutine f16 ()\n+    !$omp declare variant (f1) match(user={)\t! { dg-error \"expected trait selector name at .1.\" }\n+  end subroutine\n+  subroutine f17 ()\n+    !$omp declare variant (f1) match(user={})\t! { dg-error \"expected trait selector name at .1.\" }\n+  end subroutine\n+  subroutine f18 ()\n+    !$omp declare variant (f1) match(user={condition})\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f19 ()\n+    !$omp declare variant (f1) match(user={condition(})\t! { dg-error \"expected expression at .1.\" }\n+  end subroutine\n+  subroutine f20 ()\n+    !$omp declare variant (f1) match(user={condition()})\t! { dg-error \"expected expression at .1.\" }\n+  end subroutine\n+  subroutine f21 ()\n+    !$omp declare variant (f1) match(user={condition(f1)})\t! { dg-error \"expected expression at .1.\" }\n+  end subroutine\n+  subroutine f22 ()\n+    !$omp declare variant (f1) match(user={condition(1, 2, 3)})\t! { dg-error \"expected '\\\\)' at .1.\" }\n+  end subroutine\n+  subroutine f23 ()\n+    !$omp declare variant (f1) match(construct={master})\t! { dg-error \"selector 'master' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f24 ()\n+    !$omp declare variant (f1) match(construct={teams,parallel,master,do})\t! { dg-error \"selector 'master' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f25 ()\n+    !$omp declare variant (f1) match(construct={parallel(1\t! { dg-error \"selector 'parallel' does not accept any properties at .1.\" }\n+  end subroutine\n+  subroutine f26 ()\n+    !$omp declare variant (f1) match(construct={parallel(1)})\t! { dg-error \"selector 'parallel' does not accept any properties at .1.\" }\n+  end subroutine\n+  subroutine f27 ()\n+    !$omp declare variant (f0) match(construct={simd(12)})\t! { dg-error \"expected simd clause at .1.\" }\n+  end subroutine\n+  subroutine f32 ()\n+    !$omp declare variant (f1) match(device={kind})\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f33 ()\n+    !$omp declare variant (f1) match(device={isa})\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f34 ()\n+    !$omp declare variant (f1) match(device={arch})\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f35 ()\n+    !$omp declare variant (f1) match(device={kind,isa,arch})\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f36 ()\n+    !$omp declare variant (f1) match(device={kind(})\t! { dg-error \"expected identifier or string literal at .1.\" }\n+  end subroutine\n+  subroutine f39 ()\n+    !$omp declare variant (f1) match(device={isa(1)})\t! { dg-error \"expected identifier or string literal at .1.\" }\n+  end subroutine\n+  subroutine f40 ()\n+    !$omp declare variant (f1) match(device={arch(17)})\t! { dg-error \"expected identifier or string literal at .1.\" }\n+  end subroutine\n+  subroutine f41 ()\n+    !$omp declare variant (f1) match(device={foobar(3)})\n+  end subroutine\n+  subroutine f43 ()\n+    !$omp declare variant (f1) match(implementation={foobar(3)})\n+  end subroutine\n+  subroutine f44 ()\n+    !$omp declare variant (f1) match(implementation={vendor})\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f45 ()\n+    !$omp declare variant (f1) match(implementation={extension})\t! { dg-error \"expected '\\\\(' at .1.\" }\n+  end subroutine\n+  subroutine f45a ()\n+    !$omp declare variant (f1) match(implementation={vendor()})\t! { dg-error \"expected identifier or string literal at .1.\" }\n+  end subroutine\n+  subroutine f46 ()\n+    !$omp declare variant (f1) match(implementation={vendor(123-234)})\t! { dg-error \"expected identifier or string literal at .1.\" }\n+  end subroutine\n+  subroutine f48 ()\n+    !$omp declare variant (f1) match(implementation={unified_address(yes)})\t! { dg-error \"selector 'unified_address' does not accept any properties at .1.\" }\n+  end subroutine\n+  subroutine f49 ()\n+    !$omp declare variant (f1) match(implementation={unified_shared_memory(no)})\t! { dg-error \"selector 'unified_shared_memory' does not accept any properties at .1.\" }\n+  end subroutine\n+  subroutine f50 ()\n+    !$omp declare variant (f1) match(implementation={dynamic_allocators(42)})\t! { dg-error \"selector 'dynamic_allocators' does not accept any properties at .1.\" }\n+  end subroutine\n+  subroutine f51 ()\n+    !$omp declare variant (f1) match(implementation={reverse_offload()})\t! { dg-error \"selector 'reverse_offload' does not accept any properties at .1.\" }\n+  end subroutine\n+  subroutine f52 ()\n+    !$omp declare variant (f1) match(implementation={atomic_default_mem_order})\t! { dg-error \"expected '\\\\('\" }\n+  end subroutine\n+  subroutine f56 ()\n+    !$omp declare variant (f1) match(implementation={atomic_default_mem_order(relaxed,seq_cst)})\t! { dg-error \"expected '\\\\)' at .1.\" }\n+  end subroutine\n+  subroutine f58 ()\n+    !$omp declare variant (f1) match(user={foobar(3)})\t! { dg-error \"selector 'foobar' not allowed for context selector set 'user' at .1.\" }\n+  end subroutine\n+  subroutine f59 ()\n+    !$omp declare variant (f1) match(construct={foobar(3)})\t! { dg-error \"selector 'foobar' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f60 ()\n+    !$omp declare variant (f1) match(construct={parallel},foobar={bar})\t! { dg-error \"expected 'construct', 'device', 'implementation' or 'user' at .1.\" }\n+  end subroutine\n+  subroutine f64 ()\n+    !$omp declare variant (f1) match(construct={single})\t! { dg-error \"selector 'single' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f65 ()\n+    !$omp declare variant (f1) match(construct={taskgroup})\t! { dg-error \"selector 'taskgroup' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f66 ()\n+    !$omp declare variant (f1) match(construct={for})\t! { dg-error \"selector 'for' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f67 ()\n+    !$omp declare variant (f1) match(construct={threadprivate})\t! { dg-error \"selector 'threadprivate' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f68 ()\n+    !$omp declare variant (f1) match(construct={critical})\t! { dg-error \"selector 'critical' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f69 ()\n+    !$omp declare variant (f1) match(construct={task})\t! { dg-error \"selector 'task' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f70 ()\n+    !$omp declare variant (f1) match(construct={taskloop})\t! { dg-error \"selector 'taskloop' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f71 ()\n+    !$omp declare variant (f1) match(construct={sections})\t! { dg-error \"selector 'sections' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f72 ()\n+    !$omp declare variant (f1) match(construct={section})\t! { dg-error \"selector 'section' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f73 ()\n+    !$omp declare variant (f1) match(construct={workshare})\t! { dg-error \"selector 'workshare' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f74 ()\n+    !$omp declare variant (f1) match(construct={requires})\t! { dg-error \"selector 'requires' not allowed for context selector set 'construct' at .1.\" }\n+  end subroutine\n+  subroutine f75 ()\n+    !$omp declare variant (f1),match(construct={parallel})\t! { dg-error \"expected 'match' at .1.\" }\n+  end subroutine\n+  subroutine f76 ()\n+    !$omp declare variant (f1) match(implementation={atomic_default_mem_order(\"relaxed\")})\t! { dg-error \"expected identifier at .1.\" }\n+  end subroutine\n+  subroutine f77 ()\n+    !$omp declare variant (f1) match(user={condition(score(f76):1)})  ! { dg-error \"score argument must be constant integer expression at .1.\" }\n+  end subroutine\n+  subroutine f78 ()\n+    !$omp declare variant (f1) match(user={condition(score(-130):1)}) ! { dg-error \"score argument must be non-negative\" }\n+  end subroutine\n+end module"}, {"sha": "56de117778991c7ba17858da24be4135da0daa0f", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-2a.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-2a.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-2a.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-2a.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,53 @@\n+module main\n+  implicit none\n+contains\n+  subroutine f1 ()\n+  end subroutine\n+  subroutine f28 ()\n+    !$omp declare variant (f1) match(construct={parallel},construct={do})  ! { dg-error \"selector set 'construct' specified more than once\" }\n+  end subroutine\n+  subroutine f29 ()\n+    !$omp declare variant (f1) match(construct={parallel},construct={parallel}) ! { dg-error \"selector set 'construct' specified more than once\" }\n+  end subroutine\n+  subroutine f30 ()\n+    !$omp declare variant (f1) match(user={condition(0)},construct={target},user={condition(0)})  ! { dg-error \"selector set 'user' specified more than once\" }\n+  end subroutine\n+  subroutine f31 ()\n+    !$omp declare variant (f1) match(user={condition(0)},user={condition(1)}) ! { dg-error \"selector set 'user' specified more than once\" }\n+  end subroutine\n+  subroutine f37 ()\n+    !$omp declare variant (f1) match(device={kind(unknown)})  ! { dg-warning \"unknown property 'unknown' of 'kind' selector\" }\n+  end subroutine\n+  subroutine f38 ()\n+    !$omp declare variant (f1) match(device={kind(unknown,foobar)})\t! { dg-warning \"unknown property 'unknown' of 'kind' selector\" }\n+\t\t\t\t\t\t\t\t\t! { dg-warning \"unknown property 'foobar' of 'kind' selector\" \"\" { target *-*-* } 22 }\n+  end subroutine\n+  subroutine f42 ()\n+    !$omp declare variant (f1) match(device={arch(x86_64)},device={isa(avx512vl)})  ! { dg-error \"selector set 'device' specified more than once\" }\n+  end subroutine\n+  subroutine f47 ()\n+    !$omp declare variant (f1) match(implementation={vendor(\"foobar\")}) ! { dg-warning \"unknown property '.foobar.' of 'vendor' selector\" }\n+  end subroutine\n+  subroutine f53 ()\n+    !$omp declare variant (f1) match(implementation={atomic_default_mem_order(acquire)})  ! { dg-error \"incorrect property 'acquire' of 'atomic_default_mem_order' selector\" }\n+  end subroutine\n+  subroutine f54 ()\n+    !$omp declare variant (f1) match(implementation={atomic_default_mem_order(release)})  ! { dg-error \"incorrect property 'release' of 'atomic_default_mem_order' selector\" }\n+  end subroutine\n+  subroutine f55 ()\n+    !$omp declare variant (f1) match(implementation={atomic_default_mem_order(foobar)}) ! { dg-error \"incorrect property 'foobar' of 'atomic_default_mem_order' selector\" }\n+  end subroutine\n+  subroutine f57 ()\n+    !$omp declare variant (f1) match(implementation={atomic_default_mem_order(relaxed)},&\n+    !$omp & implementation={atomic_default_mem_order(relaxed)}) ! { dg-error \"selector set 'implementation' specified more than once\" \"\" { target *-*-* } 41  }\n+  end subroutine\n+  subroutine f61 ()\n+    !$omp declare variant (f1) match(construct={parallel,parallel}) ! { dg-error \"selector 'parallel' specified more than once in set 'construct'\" }\n+  end subroutine\n+  subroutine f62 ()\n+    !$omp declare variant (f1) match(construct={target,parallel,do,simd,parallel}) ! { dg-error \"selector 'parallel' specified more than once in set 'construct'\" }\n+  end subroutine\n+  subroutine f63 ()\n+    !$omp declare variant (f1) match(construct={target,teams,teams})  ! { dg-error \"selector 'teams' specified more than once in set 'construct'\" }\n+  end subroutine\n+end module"}, {"sha": "c62622b607b9308ab873b03ef21bf27ddbc62ffc", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-3.f90", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-3.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,237 @@\n+module main\n+contains\n+  subroutine f1 ()\n+  end subroutine\n+  subroutine f2 ()\n+    !$omp declare variant (f1) match (construct={target})\n+  end subroutine\n+  subroutine f3 ()\n+  end subroutine\n+  subroutine f4 ()\n+    !$omp declare variant (f3) match (construct={teams})\n+  end subroutine\n+  subroutine f5 ()\n+  end subroutine\n+  subroutine f6 ()\n+    !$omp declare variant (f5) match (construct={parallel})\n+  end subroutine\n+  subroutine f7 ()\n+  end subroutine\n+  subroutine f8 ()\n+    !$omp declare variant (f7) match (construct={do})\n+  end subroutine\n+  subroutine f9 ()\n+  end subroutine\n+  subroutine f10 ()\n+    !$omp declare variant (f9) match (construct={target,teams,parallel,do})\n+  end subroutine\n+  subroutine f11 ()\n+  end subroutine\n+  subroutine f12 ()\n+    !$omp declare variant (f11) match (construct={teams,do,parallel})\n+  end subroutine\n+  subroutine f13 ()\n+  end subroutine\n+  subroutine f14 ()\n+    !$omp declare variant (f13) match (device={kind(any)})\n+  end subroutine\n+  subroutine f15 ()\n+    !$omp declare variant (f13) match (device={kind(\"host\")})\n+  end subroutine\n+  subroutine f16 ()\n+    !$omp declare variant (f13) match (device={kind(nohost)})\n+  end subroutine\n+  subroutine f17 ()\n+    !$omp declare variant (f13) match (device={kind(cpu)})\n+  end subroutine\n+  subroutine f18 ()\n+    !$omp declare variant (f13) match (device={kind(\"gpu\")})\n+  end subroutine\n+  subroutine f19 ()\n+    !$omp declare variant (f13) match (device={kind(fpga)})\n+  end subroutine\n+  subroutine f20 ()\n+    !$omp declare variant (f13) match (device={kind(any,any)})\n+  end subroutine\n+  subroutine f21 ()\n+    !$omp declare variant (f13) match (device={kind(host,nohost)})\n+  end subroutine\n+  subroutine f22 ()\n+    !$omp declare variant (f13) match (device={kind(\"cpu\",\"gpu\",\"fpga\")})\n+  end subroutine\n+  subroutine f23 ()\n+    !$omp declare variant (f13) match (device={kind(any,cpu,nohost)})\n+  end subroutine\n+  subroutine f24 ()\n+    !$omp declare variant (f13) match (device={isa(avx)})\n+  end subroutine\n+  subroutine f25 ()\n+    !$omp declare variant (f13) match (device={isa(sse4,\"avx512f\",avx512vl,avx512bw)})\n+  end subroutine\n+  subroutine f26 ()\n+    !$omp declare variant (f13) match (device={arch(\"x86_64\")})\n+  end subroutine\n+  subroutine f27 ()\n+    !$omp declare variant (f13) match (device={arch(riscv64)})\n+  end subroutine\n+  subroutine f28 ()\n+    !$omp declare variant (f13) match (device={arch(nvptx)})\n+  end subroutine\n+  subroutine f29 ()\n+    !$omp declare variant (f13) match (device={arch(x86_64),isa(\"avx512f\",\"avx512vl\"),kind(cpu)})\n+  end subroutine\n+  subroutine f30 ()\n+    !$omp declare variant (f13) match (implementation={vendor(amd)})\n+  end subroutine\n+  subroutine f31 ()\n+    !$omp declare variant (f13) match (implementation={vendor(arm)})\n+  end subroutine\n+  subroutine f32 ()\n+    !$omp declare variant (f13) match (implementation={vendor(\"bsc\")})\n+  end subroutine\n+  subroutine f33 ()\n+    !$omp declare variant (f13) match (implementation={vendor(cray)})\n+  end subroutine\n+  subroutine f34 ()\n+    !$omp declare variant (f13) match (implementation={vendor(fujitsu)})\n+  end subroutine\n+  subroutine f35 ()\n+    !$omp declare variant (f13) match (implementation={vendor(gnu)})\n+  end subroutine\n+  subroutine f36 ()\n+    !$omp declare variant (f13) match (implementation={vendor(ibm)})\n+  end subroutine\n+  subroutine f37 ()\n+    !$omp declare variant (f13) match (implementation={vendor(\"intel\")})\n+  end subroutine\n+  subroutine f38 ()\n+    !$omp declare variant (f13) match (implementation={vendor(llvm)})\n+  end subroutine\n+  subroutine f39 ()\n+    !$omp declare variant (f13) match (implementation={vendor(pgi)})\n+  end subroutine\n+  subroutine f40 ()\n+    !$omp declare variant (f13) match (implementation={vendor(ti)})\n+  end subroutine\n+  subroutine f41 ()\n+    !$omp declare variant (f13) match (implementation={vendor(unknown)})\n+  end subroutine\n+  subroutine f42 ()\n+    !$omp declare variant (f13) match (implementation={vendor(gnu,llvm,intel,ibm)})\n+  end subroutine\n+  subroutine f43 ()\n+    !$omp declare variant (f13) match (implementation={extension(my_cute_extension)})\t! { dg-warning \"unknown property 'my_cute_extension' of 'extension' selector\" }\n+  end subroutine\n+  subroutine f44 ()\n+    !$omp declare variant (f13) match (implementation={extension(some_other_ext,another_ext)})\t! { dg-warning \"unknown property 'some_other_ext' of 'extension' selector\" }\n+\t\t\t\t\t\t\t\t\t\t\t\t! { dg-warning \"unknown property 'another_ext' of 'extension' selector\" \"\" { target *-*-* } .-1 }\n+  end subroutine\n+  subroutine f45 ()\n+    !$omp declare variant (f13) match (implementation={unified_shared_memory})\n+  end subroutine\n+  subroutine f46 ()\n+    !$omp declare variant (f13) match (implementation={unified_address})\n+  end subroutine\n+  subroutine f47 ()\n+    !$omp declare variant (f13) match (implementation={dynamic_allocators})\n+  end subroutine\n+  subroutine f48 ()\n+    !$omp declare variant (f13) match (implementation={reverse_offload})\n+  end subroutine\n+  subroutine f49 ()\n+    !$omp declare variant (f13) match (implementation={atomic_default_mem_order(seq_cst)})\n+  end subroutine\n+  subroutine f50 ()\n+    !$omp declare variant (f13) match (implementation={atomic_default_mem_order(relaxed)})\n+  end subroutine\n+  subroutine f51 ()\n+    !$omp declare variant (f13) match (implementation={atomic_default_mem_order(acq_rel)})\n+  end subroutine\n+  subroutine f52 ()\n+    !$omp declare variant (f14) match (implementation={atomic_default_mem_order(acq_rel),vendor(gnu),&\n+    !$omp&\t\t\t\t\t       unified_address,extension(foobar)}) ! { dg-warning \"unknown property 'foobar' of 'extension' selector\" \"\" { target *-*-* } .-1 }\n+  end subroutine\n+  subroutine f53 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(3):amd)})\n+  end subroutine\n+  subroutine f54 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(4):\"arm\")})\n+  end subroutine\n+  subroutine f55 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(5):bsc)})\n+  end subroutine\n+  subroutine f56 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(6):cray)})\n+  end subroutine\n+  subroutine f57 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(7):fujitsu)})\n+  end subroutine\n+  subroutine f58 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(8):gnu)})\n+  end subroutine\n+  subroutine f59 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(9):ibm)})\n+  end subroutine\n+  subroutine f60 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(10):intel)})\n+  end subroutine\n+  subroutine f61 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(11):llvm)})\n+  end subroutine\n+  subroutine f62 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(12):pgi)})\n+  end subroutine\n+  subroutine f63 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(13):\"ti\")})\n+  end subroutine\n+  subroutine f64 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(14):unknown)})\n+  end subroutine\n+  subroutine f65 ()\n+    !$omp declare variant (f13) match (implementation={vendor(score(15):gnu,llvm,intel,ibm)})\n+  end subroutine\n+  subroutine f66 ()\n+    !$omp declare variant (f13) match (implementation={extension(score(16):my_cute_extension)})\t! { dg-warning \"unknown property 'my_cute_extension' of 'extension' selector\" }\n+  end subroutine\n+  subroutine f67 ()\n+    !$omp declare variant (f13) match (implementation={extension(score(17):some_other_ext,another_ext)})\t! { dg-warning \"unknown property 'some_other_ext' of 'extension' selector\" }\n+  end subroutine\t\t\t\t\t\t\t\t\t\t\t\t! { dg-warning \"unknown property 'another_ext' of 'extension' selector\" \"\" { target *-*-* } .-1 }\n+  subroutine f68 ()\n+    !$omp declare variant (f13) match (implementation={atomic_default_mem_order(score(18):seq_cst)})\n+  end subroutine\n+  subroutine f69 ()\n+    !$omp declare variant (f13) match (implementation={atomic_default_mem_order(score(19):relaxed)})\n+  end subroutine\n+  subroutine f70 ()\n+    !$omp declare variant (f13) match (implementation={atomic_default_mem_order(score(20):acq_rel)})\n+  end subroutine\n+  subroutine f71 ()\n+    !$omp declare variant (f13) match (implementation={atomic_default_mem_order(score(21):acq_rel),&\n+    !$omp&\t\t\t\t\t       vendor(score(22):gnu),unified_address,extension(score(22):foobar)})\t! { dg-warning \"unknown property 'foobar' of 'extension' selector\" \"\" { target *-*-* } .-1 }\n+  end subroutine\n+  subroutine f72 ()\n+    !$omp declare variant (f13) match (user={condition(0)})\n+  end subroutine\n+  subroutine f73 ()\n+    !$omp declare variant (f13) match (user={condition(272-272*1)})\n+  end subroutine\n+  subroutine f74 ()\n+    !$omp declare variant (f13) match (user={condition(score(25):1)})\n+  end subroutine\n+  subroutine f75 ()\n+    !$omp declare variant (f13) match (device={kind(any,\"any\")})\n+  end subroutine\n+  subroutine f76 ()\n+    !$omp declare variant (f13) match (device={kind(\"any\",\"any\")})\n+  end subroutine\n+  subroutine f77 ()\n+    !$omp declare variant (f13) match (device={kind(\"any\",any)})\n+  end subroutine\n+  subroutine f78 ()\n+    !$omp declare variant (f13) match (implementation={vendor(nvidia)})\n+  end subroutine\n+  subroutine f79 ()\n+    !$omp declare variant (f13) match (user={condition(score(0):0)})\n+  end subroutine\n+\n+  end module"}, {"sha": "bc4f41647b44dde27f331a9774ed9d897472956a", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-4.f90", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-4.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,62 @@\n+program main\n+  implicit none\n+contains\n+  function f6 (x, y, z)\n+    real (kind = 8) :: f6\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real (kind = 4), intent(in) :: z\n+\n+    interface\n+      function f1 (x, y, z)\n+        real (kind = 8) :: f1\n+        integer, intent(in) :: x\n+        integer (kind = 8), intent(in) :: y\n+        real (kind = 4), intent(in) :: z\n+      end function\n+\n+      function f2 (x, y, z)\n+        real (kind = 8) :: f2\n+        integer, intent(in) :: x\n+        integer (kind = 8), intent(in) :: y\n+        real (kind = 4), intent(in) :: z\n+      end function\n+\n+      function f3 (x, y, z)\n+        real (kind = 8) :: f3\n+        integer, intent(in) :: x\n+        integer (kind = 8), intent(in) :: y\n+        real (kind = 4), intent(in) :: z\n+      end function\n+\n+      function f4 (x, y, z)\n+        real (kind = 8) :: f4\n+        integer, intent(in) :: x\n+        integer (kind = 8), intent(in) :: y\n+        real (kind = 4), intent(in) :: z\n+      end function\n+\n+      function f5 (x, y, z)\n+        real (kind = 8) :: f5\n+        integer, intent(in) :: x\n+        integer (kind = 8), intent(in) :: y\n+        real (kind = 4), intent(in) :: z\n+      end function\n+    end interface\n+\n+    !$omp declare variant (f1) match (user={condition(1)})\n+    !$omp declare variant (f2) match (user={condition(score(1):1)})\n+    !$omp declare variant (f3) match (user={condition(score(3):1)})\n+    !$omp declare variant (f4) match (user={condition(score(2):1)})\n+    !$omp declare variant (f5) match (implementation={vendor(gnu)})\n+\n+    f6 = z + x + y\n+  end function\n+\n+  function test (x)\n+    real (kind = 8) :: test\n+    integer, intent(in) :: x\n+\n+    test = f6 (x, int (x, kind = 8), 3.5)\n+  end function\n+end program"}, {"sha": "ad7acb9842d59172e592937233d1e2808d963e67", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-5.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-5.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,75 @@\n+! { dg-do compile { target i?86-*-* x86_64-*-* } }\n+! { dg-additional-options \"-mavx2\" }\n+\n+module main\n+  implicit none\n+contains\n+  function f1 (x, y, z)\n+    integer, dimension(4) :: f1\n+    real, dimension(4), intent(in) :: x, y\n+    real, intent(out) :: z\n+\n+    f1 = x\n+  end function\n+\n+  function f2 (x, y, z)\n+    integer, dimension(8) :: f2\n+    real, dimension(8), intent(in) :: x, y\n+    real, intent(out) :: z\n+\n+    f2 = x\n+  end function\n+\n+  function f3 (x, y, z)\n+    integer, dimension(4) :: f3\n+    real, dimension(4), intent(in) :: x, z\n+    integer, intent(in) :: y\n+\n+    f3 = x\n+  end function\n+\n+  integer function f4 (x, y, z)\n+    real, intent(in) :: x, y\n+    real, intent(out) :: z\n+    !$omp declare variant (f1) match (construct={parallel,do,simd(simdlen(4),notinbranch,uniform(z),aligned(z:16))})\n+    !$omp declare variant (f2) match (construct={do,simd(uniform(z),simdlen(8),notinbranch)})\n+  end function\n+\n+  integer function f5 (x, y)\n+    integer, intent(in) :: x, y\n+    !$omp declare variant (f3) match (construct={simd(simdlen(4),inbranch,linear(y:1))})\n+  end function\n+\n+  subroutine test (x, y, z, w)\n+    integer, dimension(8192), intent(inout) :: x\n+    real, dimension(8192), intent(inout) :: y, z\n+    real, pointer, intent(out) :: w\n+    integer :: i\n+\n+    !$omp parallel\n+    !$omp do simd aligned (w:16)\n+    do i = 1, 1024\n+      x(i) = f4 (y(i), z(i), w)\n+    end do\n+    !$omp end do simd\n+    !$omp end parallel\n+\n+    !$omp parallel do simd aligned (w:16) simdlen(4)\n+    do i = 1025, 2048\n+      x(i) = f4 (y(i), z(i), w)\n+    end do\n+    !$omp end parallel do simd\n+\n+    !$omp simd aligned (w:16)\n+    do i = 2049, 4096\n+      x(i) = f4 (y(i), z(i), w)\n+    end do\n+    !$omp end simd\n+\n+    !$omp simd\n+    do i = 4097, 8192\n+      if (x(i) .gt. 10) x(i) = f5 (x(i), i)\n+    end do\n+    !$omp end simd\n+  end subroutine\n+end module"}, {"sha": "3f33f38b9bc4bddda4809f14b26f01e8daea9302", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-6.f90", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-6.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,188 @@\n+module main\n+  implicit none\n+contains\n+  function f1 (x, y, z)\n+    real (kind = 8) :: f1\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+\n+    f1 = 0.0\n+  end function\n+\n+  function f2 (x, y, z)\n+    real (kind = 8) :: f2\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+\n+    f2 = 0.0\n+  end function\n+\n+  function f3 (x, y, z)\n+    real (kind = 8) :: f3\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f1) match (user={condition(0)},construct={parallel})\n+    f3 = 0.0\n+  end function\n+\n+  function f4 (x, y, z)\n+    real (kind = 8) :: f4\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f1) match (construct={parallel},user={condition(score(1):1)})\n+    f4 = 0.0\n+  end function\n+\n+  function f5 (x, y, z)\n+    real (kind = 8) :: f5\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    f5 = 0.0\n+  end function\n+\n+  function f6 (x, y, z)\n+    real (kind = 8) :: f6\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f5) match (user={condition(0)})  ! { dg-error \"'f5' used as a variant with incompatible 'construct' selector sets\" }\n+    f6 = 0.0\n+  end function\n+\n+  function f7 (x, y, z)\n+    real (kind = 8) :: f7\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f5) match (construct={parallel},user={condition(score(1):1)})\n+    f7 = 0.0\n+  end function\n+\n+  function f8 (x, y, z)\n+    real (kind = 8) :: f8\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    f8 = 0.0\n+  end function\n+\n+  function f9 (x, y, z)\n+    real (kind = 8) :: f9\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f8) match (user={condition(0)},construct={do})  ! { dg-error \"'f8' used as a variant with incompatible 'construct' selector sets\" }\n+    f9 = 0.0\n+  end function\n+\n+  function f10 (x, y, z)\n+    real (kind = 8) :: f10\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f8) match (user={condition(1)})\n+    f10 = 0.0\n+  end function\n+\n+  function f11 (x, y, z)\n+    real (kind = 8) :: f11\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    f11 = 0.0\n+  end function\n+\n+  function f12 (x, y, z)\n+    real (kind = 8) :: f12\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f11) match (construct={target,teams,parallel,do})  ! { dg-error \"'f11' used as a variant with incompatible 'construct' selector sets\" }\n+    f12 = 0.0\n+  end function\n+\n+  function f13 (x, y, z)\n+    real (kind = 8) :: f13\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f11) match (user={condition(score(1):1)},construct={target,teams,parallel,do})  ! { dg-error \"'f11' used as a variant with incompatible 'construct' selector sets\" }\n+    f13 = 0.0\n+  end function\n+\n+  function f14 (x, y, z)\n+    real (kind = 8) :: f14\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f11) match (implementation={vendor(gnu)},construct={target,teams,parallel})  ! { dg-error \"'f11' used as a variant with incompatible 'construct' selector sets\" }\n+    f14 = 0.0\n+  end function\n+\n+  function f15 (x, y, z)\n+    real (kind = 8) :: f15\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f11) match (device={kind(any)},construct={teams,parallel})\n+    f15 = 0.0\n+  end function\n+\n+  function f16 (x, y, z)\n+    real (kind = 8) :: f16\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    f16 = 0.0\n+  end function\n+\n+  function f17 (x, y, z)\n+    real (kind = 8) :: f17\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f16) match (construct={teams,parallel})  ! { dg-error \"'f16' used as a variant with incompatible 'construct' selector sets\" }\n+    f17 = 0.0\n+  end function\n+\n+  function f18 (x, y, z)\n+    real (kind = 8) :: f18\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f16) match(construct={teams,parallel,do})\n+    f18 = 0.0\n+  end function\n+\n+  function f19 (x, y, z)\n+    real (kind = 8) :: f19\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    f19 = 0.0\n+  end function\n+\n+  function f20 (x, y, z)\n+    real (kind = 8) :: f20\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f19) match (construct={parallel})  ! { dg-error \"'f19' used as a variant with incompatible 'construct' selector sets\" }\n+    f20 = 0.0\n+  end function\n+\n+  function f21 (x, y, z)\n+    real (kind = 8) :: f21\n+    integer, intent(in) :: x\n+    integer (kind = 8), intent(in) :: y\n+    real :: z\n+    !$omp declare variant (f19) match (construct={do},implementation={vendor(gnu,llvm)})\n+    f21 = 0.0\n+  end function\n+\n+end module"}, {"sha": "1590a2a26f084c40fbdef44f6bfaa02716ce5063", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-7.f90", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-7.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,93 @@\n+! { dg-do compile { target i?86-*-* x86_64-*-* } }\n+! { dg-additional-options \"-mavx2\" }\n+\n+module main\n+  implicit none\n+contains\n+  function f1 (x, y, z)\n+    integer, dimension(4) :: f1\n+    real, dimension(4), intent(in) :: x, y\n+    real, intent(out) :: z\n+\n+    f1 = x\n+  end function\n+\n+  function f2 (x, y, z)\n+    integer, dimension(8) :: f2\n+    real, dimension(8), intent(in) :: x, y\n+    real, intent(out) :: z\n+\n+    f2 = x\n+  end function\n+\n+  function f3 (x, y, z)\n+    integer, dimension(4) :: f3\n+    real, dimension(4), intent(in) :: x, z\n+    integer, intent(in) :: y\n+\n+    f3 = x\n+  end function\n+\n+  integer function f4 (x, y, z)\n+    real, intent(in) :: x, y\n+    real, pointer, intent(out) :: z\n+    !$omp declare variant (f1) match (construct={parallel,do,simd(simdlen(4),notinbranch,uniform(z),aligned(z:16))})\t! { dg-error \"'f1' used as a variant with incompatible 'construct' selector sets\" }\n+  end function\n+\n+  integer function f5 (u, v, w)\n+    real, intent(in) :: u, v\n+    real, pointer, intent(out) :: w\n+    !$omp declare variant (f1) match (construct={parallel,do,simd(uniform(w),simdlen(8*2-12),aligned(w:16),notinbranch)})\t! { dg-error \"'f1' used as a variant with incompatible 'construct' selector sets\" }\n+  end function\n+\n+  integer function f6 (u, v, w)\n+    real, intent(in) :: u, v\n+    real, pointer, intent(out) :: w\n+    !$omp declare variant (f1) match (construct={parallel,do,simd(linear(w),notinbranch,simdlen(4),aligned(w:16))})\t! { dg-error \"'f1' used as a variant with incompatible 'construct' selector sets\" }\n+  end function\n+\n+  integer function f7 (u, v, w)\n+    real, intent(in) :: u, v\n+    real, pointer, intent(out) :: w\n+    !$omp declare variant (f1) match (construct={parallel,do,simd(uniform(w),notinbranch,simdlen(4),aligned(w:8))})\t! { dg-error \"'f1' used as a variant with incompatible 'construct' selector sets\" }\n+  end function\n+\n+  integer function f8 (u, v, w)\n+    real, intent(in) :: u, v\n+    real, pointer, intent(out) :: w\n+    !$omp declare variant (f1) match (construct={parallel,do,simd(uniform(w),notinbranch,simdlen(4),aligned(w))})\n+  end function\n+\n+  integer function f9 (x, y, z)\n+    real, intent(in) :: x, y\n+    real, pointer, intent(out) :: z\n+    !$omp declare variant (f2) match (construct={do,simd(uniform(z),simdlen(8),notinbranch)})\t! { dg-error \"'f2' used as a variant with incompatible 'construct' selector sets\" }\n+  end function\n+\n+  integer function f10 (x, y, q)\n+    real, intent(in) :: x, y\n+    real, pointer, intent(out) :: q\n+    !$omp declare variant (f2) match (construct={do,simd(notinbranch,simdlen(2+2+4),uniform (q))})\t! { dg-error \"'f2' used as a variant with incompatible 'construct' selector sets\" }\n+  end function\n+\n+  integer function f11 (x, y, z)\n+    real, intent(in) :: x, y\n+    real, pointer, intent(out) :: z\n+    !$omp declare variant (f2) match (construct={do,simd(linear(z:2),simdlen(8),notinbranch)})\n+  end function\n+\n+  integer function f12 (x, y)\n+    integer, intent(in) :: x, y\n+    !$omp declare variant (f3) match (construct={simd(simdlen(4),inbranch,linear(y:1))})\t! { dg-error \"'f3' used as a variant with incompatible 'construct' selector sets\" }\n+  end function\n+\n+  integer function f13 (x, q)\n+    integer, intent(in) :: x, q\n+    !$omp declare variant (f3) match (construct={simd(inbranch, simdlen (5-1), linear (q:4-3))})\t! { dg-error \"'f3' used as a variant with incompatible 'construct' selector sets\" }\n+  end function\n+\n+  integer function f14 (x, q)\n+    integer, intent(in) :: x, q\n+    !$omp declare variant (f3) match (construct={simd(inbranch,simdlen(4),linear(q:2))})\n+  end function\n+end module"}, {"sha": "c751489a5db58ae5fbf8490099cc06201a3611d6", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-8.f90", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-8.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,218 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+\n+program main\n+  !$omp requires atomic_default_mem_order(seq_cst)\n+  !$omp declare target to (test3)\n+contains\n+  subroutine f01 ()\n+  end subroutine\n+\n+  subroutine f02 ()\n+    !$omp declare variant (f01) match (user={condition(6 == 7)},implementation={vendor(gnu)})\n+  end subroutine\n+\n+  subroutine f03 ()\n+  end subroutine\n+\n+  subroutine f04 ()\n+    !$omp declare variant (f03) match (user={condition(6 == 6)},implementation={atomic_default_mem_order(seq_cst)})\n+  end subroutine\n+\n+  subroutine f05 ()\n+  end subroutine\n+\n+  subroutine f06 ()\n+    !$omp declare variant (f05) match (user={condition(1)},implementation={atomic_default_mem_order(relaxed)})\n+  end subroutine\n+\n+  subroutine f07 ()\n+  end subroutine\n+\n+  subroutine f08 ()\n+    !$omp declare variant (f07) match (construct={parallel,do},device={kind(\"any\")})\n+  end subroutine\n+\n+  subroutine f09 ()\n+  end subroutine\n+\n+  subroutine f10 ()\n+    !$omp declare variant (f09) match (construct={parallel,do},implementation={vendor(\"gnu\")})\n+  end subroutine\n+\n+  subroutine f11 ()\n+  end subroutine\n+\n+  subroutine f12 ()\n+    !$omp declare variant (f11) match (construct={parallel,do})\n+  end subroutine\n+\n+  subroutine f13 ()\n+  end subroutine\n+\n+  subroutine f14 ()\n+    !$omp declare variant (f13) match (construct={parallel,do})\n+  end subroutine\n+\n+  subroutine f15 ()\n+    !$omp declare target to (f13, f14)\n+  end subroutine\n+\n+  subroutine f16 ()\n+    !$omp declare variant (f15) match (implementation={vendor(llvm)})\n+  end subroutine\n+\n+  subroutine f17 ()\n+  end subroutine\n+\n+  subroutine f18 ()\n+    !$omp declare variant (f17) match (construct={target,parallel})\n+  end subroutine\n+\n+  subroutine f19 ()\n+  end subroutine\n+\n+  subroutine f20 ()\n+    !$omp declare variant (f19) match (construct={target,parallel})\n+  end subroutine\n+\n+  subroutine f22 ()\n+    !$omp declare variant (f21) match (construct={teams,parallel})\n+  end subroutine\n+\n+  subroutine f23 ()\n+  end subroutine\n+\n+  subroutine f24 ()\n+    !$omp declare variant (f23) match (construct={teams,parallel,do})\n+  end subroutine\n+\n+  subroutine f25 ()\n+  end subroutine\n+\n+  subroutine f27 ()\n+  end subroutine\n+\n+  subroutine f28 ()\n+    !$omp declare variant (f27) match (construct={teams,parallel,do})\n+  end subroutine\n+\n+  subroutine f30 ()\n+    !$omp declare variant (f29) match (implementation={vendor(gnu)})\n+  end subroutine\n+\n+  subroutine f31 ()\n+  end subroutine\n+\n+  subroutine f32 ()\n+    !$omp declare variant (f31) match (construct={teams,parallel,do})\n+  end subroutine\n+\n+  subroutine f33 ()\n+  end subroutine\n+\n+  subroutine f34 ()\n+    !$omp declare variant (f33) match (device={kind(\"any\\0any\")})\t! { dg-warning \"unknown property '.any..0any.' of 'kind' selector\" }\n+  end subroutine\n+\n+  subroutine f35 ()\n+  end subroutine\n+\n+  subroutine f36 ()\n+    !$omp declare variant (f35) match (implementation={vendor(\"gnu\\0\")})\t! { dg-warning \"unknown property '.gnu..0.' of 'vendor' selector\" }\n+  end subroutine\n+\n+  subroutine test1 ()\n+    integer :: i\n+\n+    call f02 ()\t! { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    call f04 ()\t! { dg-final { scan-tree-dump-times \"f03 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    call f06 ()\t! { dg-final { scan-tree-dump-times \"f06 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+\n+    !$omp parallel\n+      !$omp do\n+      do i = 1, 2\n+\tcall f08 ()\t\t! { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+      end do\n+      !$omp end do\n+    !$omp end parallel\n+\n+    !$omp parallel do\n+      do i = 1, 2\n+\tcall f10 ()\t\t! { dg-final { scan-tree-dump-times \"f09 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+      end do\n+    !$omp end parallel do\n+\n+    !$omp do\n+      do i = 1, 2\n+\t!$omp parallel\n+\t  call f12 ()\t! { dg-final { scan-tree-dump-times \"f12 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+\t!$omp end parallel\n+      end do\n+    !$omp end do\n+\n+    !$omp parallel\n+      !$omp target\n+\t!$omp do\n+\tdo i = 1, 2\n+\t  call f14 ()\t\t! { dg-final { scan-tree-dump-times \"f14 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+\tend do\n+\t!$omp end do\n+      !$omp end target\n+    !$omp end parallel\n+\n+    call f16 ()\t! { dg-final { scan-tree-dump-times \"f16 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    call f34 ()\t! { dg-final { scan-tree-dump-times \"f34 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    call f36 ()\t! { dg-final { scan-tree-dump-times \"f36 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+  end subroutine\n+\n+  subroutine test2 ()\n+    ! OpenMP 5.0 specifies that the 'target' trait should be added for\n+    ! functions within a declare target block, but Fortran does not have\n+    ! the notion of a declare target _block_, so the variant is not used here.\n+    ! This may change in later versions of OpenMP.\n+\n+    !$omp declare target\n+    !$omp parallel\n+      call f18 ()\t! { dg-final { scan-tree-dump-times \"f18 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    !$omp end parallel\n+  end subroutine\n+\n+  subroutine test3 ()\n+    ! In the C version, this test was used to check that the\n+    ! 'declare target to' form of the directive did not result in the variant\n+    ! being used.\n+    !$omp parallel\n+      call f20 ()\t! { dg-final { scan-tree-dump-times \"f20 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    !$omp end parallel\n+  end subroutine\n+\n+  subroutine f21 ()\n+    integer :: i\n+    !$omp do\n+      do i = 1, 2\n+\tcall f24 ()\t! { dg-final { scan-tree-dump-times \"f23 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+      end do\n+    !$omp end do\n+  end subroutine\n+\n+  subroutine f26 ()\n+    !$omp declare variant (f25) match (construct={teams,parallel})\n+\n+    integer :: i\n+    !$omp do\n+      do i = 1, 2\n+\tcall f28 ()\t! { dg-final { scan-tree-dump-times \"f28 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+      end do\n+    !$omp end do\n+  end subroutine\n+\n+  subroutine f29 ()\n+    integer :: i\n+    !$omp do\n+      do i = 1, 2\n+\tcall f32 ()\t! { dg-final { scan-tree-dump-times \"f32 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+      end do\n+    !$omp end do\n+  end subroutine\n+end program"}, {"sha": "ebd066609f3a7d20f96d6446db4c5ffc5dcbae3b", "filename": "gcc/testsuite/gfortran.dg/gomp/declare-variant-9.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdeclare-variant-9.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-cpp -fdump-tree-gimple\" }\n+! { dg-additional-options \"-mno-sse3\" { target { i?86-*-* x86_64-*-* } } }\n+\n+program main\n+  implicit none\n+contains\n+  subroutine f01 ()\n+  end subroutine\n+  subroutine f02 ()\n+    !$omp declare variant (f01) match (device={isa(\"avx512f\",avx512bw)})\n+  end subroutine\n+  subroutine f05 ()\n+  end subroutine\n+  subroutine f06 ()\n+    !$omp declare variant (f05) match (device={kind(gpu)})\n+  end subroutine\n+  subroutine f07 ()\n+  end subroutine\n+  subroutine f08 ()\n+    !$omp declare variant (f07) match (device={kind(\"cpu\")})\n+  end subroutine\n+  subroutine f09 ()\n+  end subroutine\n+  subroutine f10 ()\n+    !$omp declare variant (f09) match (device={isa(sm_35)})\n+  end subroutine\n+  subroutine f11 ()\n+  end subroutine\n+  subroutine f12 ()\n+    !$omp declare variant (f11) match (device={arch(nvptx)})\n+  end subroutine\n+  subroutine f13 ()\n+  end subroutine\n+  subroutine f14 ()\n+    !$omp declare variant (f13) match (device={arch(\"i386\"),isa(sse4)})\n+  end subroutine\n+  subroutine f17 ()\n+  end subroutine\n+  subroutine f18 ()\n+    !$omp declare variant (f17) match (device={kind(\"any\",\"fpga\")})\n+  end subroutine\n+\n+  subroutine test1 ()\n+    integer ::  i;\n+    call f02 ()\t! { dg-final { scan-tree-dump-times \"f02 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    call f14 ()\t! { dg-final { scan-tree-dump-times \"f14 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+    call f18 ()\t! { dg-final { scan-tree-dump-times \"f18 \\\\\\(\\\\\\);\" 1 \"gimple\" } }\n+  end subroutine\n+\n+  subroutine test3 ()\n+    call f06 ()\t! { dg-final { scan-tree-dump-times \"f06 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } }\n+    call f08 ()\t! { dg-final { scan-tree-dump-times \"f07 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } }\n+    call f10 ()\t! { dg-final { scan-tree-dump-times \"f10 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* amdgcn*-*-* } } } } }\n+    call f12 ()\t! { dg-final { scan-tree-dump-times \"f12 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { ! { nvptx*-*-* } } } } }\n+\t\t! { dg-final { scan-tree-dump-times \"f11 \\\\\\(\\\\\\);\" 1 \"gimple\" { target { nvptx*-*-* } } } }\n+  end subroutine\n+end program"}, {"sha": "e6f69dccb4940b68ea574bc1f22bfe74e68111bb", "filename": "libgomp/testsuite/libgomp.fortran/declare-variant-1.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724ee5a0093da443563ae98ec5cb76164c36be80/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-variant-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724ee5a0093da443563ae98ec5cb76164c36be80/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-variant-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdeclare-variant-1.f90?ref=724ee5a0093da443563ae98ec5cb76164c36be80", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+\n+program main\n+  implicit none\n+\n+  integer :: v\n+  !$omp target map(from:v)\n+  v = on ()\n+  !$omp end target\n+\n+  select case (v)\n+    case default\n+      write (*,*) \"Host fallback or unknown offloading\"\n+    case (1)\n+      write (*,*) \"Offloading to NVidia PTX\"\n+    case (2)\n+      write (*,*) \"Offloading to AMD GCN\"\n+  end select\n+contains\n+  integer function on_nvptx ()\n+    on_nvptx = 1\n+  end function\n+\n+  integer function on_gcn ()\n+    on_gcn = 2\n+  end function\n+\n+  integer function on ()\n+    !$omp declare variant (on_nvptx) match(construct={target},device={arch(nvptx)})\n+    !$omp declare variant (on_gcn) match(construct={target},device={arch(gcn)})\n+    on = 0\n+  end function\n+end program"}]}