{"sha": "35b15a461e43ed3183153a6887a43a4041a0f816", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzViMTVhNDYxZTQzZWQzMTgzMTUzYTY4ODdhNDNhNDA0MWEwZjgxNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-08-10T14:50:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-08-10T14:50:34Z"}, "message": "i386.c (ix86_compute_frame_layout): Re-align stack after saving registers.\n\n\t* config/i386/i386.c (ix86_compute_frame_layout): Re-align stack\n\tafter saving registers.  Assert that SSE registers are only saved\n\twith a sufficiently aligned frame.\n\t(ix86_emit_save_reg_using_mov): Assert realigned only with DRAP;\n\tremove stack_realign_fp handling.\n\t(ix86_expand_prologue): Save int registers before stack_realign_fp,\n\tand do not mark the stack alignment as frame related.\n\t(ix86_expand_epilogue): SP is now invalid with stack_realign_fp.\n\n\t* dwarf2out.c (dwarf2out_frame_debug_expr): Flush queued register\n\tsaves when re-aligning the stack.\n\nFrom-SVN: r163068", "tree": {"sha": "8ebe3015e0fc34e492f6826b258f707768517b3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ebe3015e0fc34e492f6826b258f707768517b3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35b15a461e43ed3183153a6887a43a4041a0f816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b15a461e43ed3183153a6887a43a4041a0f816", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b15a461e43ed3183153a6887a43a4041a0f816", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b15a461e43ed3183153a6887a43a4041a0f816/comments", "author": null, "committer": null, "parents": [{"sha": "67536dcb631d1df0b5cf067b0aaab5df61689575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67536dcb631d1df0b5cf067b0aaab5df61689575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67536dcb631d1df0b5cf067b0aaab5df61689575"}], "stats": {"total": 155, "additions": 84, "deletions": 71}, "files": [{"sha": "4b3719b1905b4da9fac06d9eb60da1c6ecc3d16f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b15a461e43ed3183153a6887a43a4041a0f816/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b15a461e43ed3183153a6887a43a4041a0f816/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35b15a461e43ed3183153a6887a43a4041a0f816", "patch": "@@ -1,3 +1,17 @@\n+2010-08-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_compute_frame_layout): Re-align stack\n+\tafter saving registers.  Assert that SSE registers are only saved\n+\twith a sufficiently aligned frame.\n+\t(ix86_emit_save_reg_using_mov): Assert realigned only with DRAP;\n+\tremove stack_realign_fp handling.\n+\t(ix86_expand_prologue): Save int registers before stack_realign_fp,\n+\tand do not mark the stack alignment as frame related.\n+\t(ix86_expand_epilogue): SP is now invalid with stack_realign_fp.\n+\n+\t* dwarf2out.c (dwarf2out_frame_debug_expr): Flush queued register\n+\tsaves when re-aligning the stack.\n+\n 2010-08-10  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* basic-block.h (alloc_aux_for_block, alloc_aux_for_edge): Delete."}, {"sha": "3f370664a5b88ea83c94c2b8f439ffa5eb4fbaf2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 66, "deletions": 71, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b15a461e43ed3183153a6887a43a4041a0f816/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b15a461e43ed3183153a6887a43a4041a0f816/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=35b15a461e43ed3183153a6887a43a4041a0f816", "patch": "@@ -8404,22 +8404,29 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n \n   frame->hard_frame_pointer_offset = offset;\n \n-  /* Set offset to aligned because the realigned frame starts from here.  */\n-  if (stack_realign_fp)\n-    offset = (offset + stack_alignment_needed -1) & -stack_alignment_needed;\n-\n   /* Register save area */\n   offset += frame->nregs * UNITS_PER_WORD;\n   frame->reg_save_offset = offset;\n \n   /* Align and set SSE register save area.  */\n   if (frame->nsseregs)\n     {\n+      /* The only ABI that has saved SSE registers (Win64) also has a\n+         16-byte aligned default stack, and thus we don't need to be\n+\t within the re-aligned local stack frame to save them.  */\n+      gcc_assert (INCOMING_STACK_BOUNDARY >= 128);\n       offset = (offset + 16 - 1) & -16;\n       offset += frame->nsseregs * 16;\n     }\n   frame->sse_reg_save_offset = offset;\n \n+  /* The re-aligned stack starts here.  Values before this point are not\n+     directly comparable with values below this point.  In order to make\n+     sure that no value happens to be the same before and after, force\n+     the alignment computation below to add a non-zero value.  */\n+  if (stack_realign_fp)\n+    offset = (offset + stack_alignment_needed) & -stack_alignment_needed;\n+\n   /* Va-arg area */\n   frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;\n   offset += frame->va_arg_size;\n@@ -8621,7 +8628,9 @@ ix86_emit_save_reg_using_mov (enum machine_mode mode, unsigned int regno,\n      any tricky guessing by dwarf2out.  */\n   if (m->fs.realigned)\n     {\n-      if (stack_realign_drap && regno == REGNO (crtl->drap_reg))\n+      gcc_checking_assert (stack_realign_drap);\n+\n+      if (regno == REGNO (crtl->drap_reg))\n \t{\n \t  /* A bit of a hack.  We force the DRAP register to be saved in\n \t     the re-aligned stack frame, which provides us with a copy\n@@ -8632,21 +8641,6 @@ ix86_emit_save_reg_using_mov (enum machine_mode mode, unsigned int regno,\n \t  mem = gen_rtx_MEM (mode, addr);\n \t  add_reg_note (insn, REG_CFA_DEF_CFA, mem);\n \t}\n-      else if (stack_realign_fp)\n-\t{\n-\t  /* The stack pointer may or may not be varying within the\n-\t     function.  If it is, then we can't use it as a stable\n-\t     reference to the locations within the frame.  Instead,\n-\t     simply compute the location of the aligned frame from\n-\t     the frame pointer.  */\n-\t  addr = GEN_INT (-(HOST_WIDE_INT)crtl->stack_alignment_needed\n-\t\t\t  / BITS_PER_UNIT);\n-\t  addr = gen_rtx_AND (Pmode, hard_frame_pointer_rtx, addr);\n-\t  addr = plus_constant (addr, -cfa_offset);\n-\t  mem = gen_rtx_MEM (mode, addr);\n-\t  add_reg_note (insn, REG_CFA_EXPRESSION,\n-\t\t\tgen_rtx_SET (VOIDmode, mem, reg));\n-\t}\n       else\n \t{\n \t  /* The frame pointer is a stable reference within the\n@@ -9391,7 +9385,7 @@ ix86_expand_prologue (void)\n   bool pic_reg_used;\n   struct ix86_frame frame;\n   HOST_WIDE_INT allocate;\n-  bool int_registers_saved = false;\n+  bool int_registers_saved;\n \n   ix86_finalize_stack_realign_flags ();\n \n@@ -9560,33 +9554,59 @@ ix86_expand_prologue (void)\n       m->fs.fp_valid = true;\n     }\n \n+  int_registers_saved = (frame.nregs == 0);\n+\n+  if (!int_registers_saved)\n+    {\n+      /* If saving registers via PUSH, do so now.  */\n+      if (!frame.save_regs_using_mov)\n+\t{\n+\t  ix86_emit_save_regs ();\n+\t  int_registers_saved = true;\n+\t  gcc_assert (m->fs.sp_offset == frame.reg_save_offset);\n+\t}\n+\n+      /* When using red zone we may start register saving before allocating\n+\t the stack frame saving one cycle of the prologue.  However, avoid\n+\t doing this if we have to probe the stack; at least on x86_64 the\n+\t stack probe can turn into a call that clobbers a red zone location. */\n+      else if (ix86_using_red_zone ()\n+\t       && (! TARGET_STACK_PROBE\n+\t\t   || frame.stack_pointer_offset < CHECK_STACK_LIMIT))\n+\t{\n+\t  ix86_emit_save_regs_using_mov (frame.reg_save_offset);\n+\t  int_registers_saved = true;\n+\t}\n+    }\n+\n   if (stack_realign_fp)\n     {\n       int align_bytes = crtl->stack_alignment_needed / BITS_PER_UNIT;\n       gcc_assert (align_bytes > MIN_STACK_BOUNDARY / BITS_PER_UNIT);\n \n+      /* The computation of the size of the re-aligned stack frame means\n+\t that we must allocate the size of the register save area before\n+\t performing the actual alignment.  Otherwise we cannot guarantee\n+\t that there's enough storage above the realignment point.  */\n+      if (m->fs.sp_offset != frame.sse_reg_save_offset)\n+        pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t   GEN_INT (m->fs.sp_offset\n+\t\t\t\t\t    - frame.sse_reg_save_offset),\n+\t\t\t\t   -1, false);\n+\n       /* Align the stack.  */\n       insn = emit_insn (ix86_gen_andsp (stack_pointer_rtx,\n \t\t\t\t\tstack_pointer_rtx,\n \t\t\t\t\tGEN_INT (-align_bytes)));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n \n-      /* For the purposes of register save area addressing, the frame\n-         pointer is no longer valid.  */\n-      /* ??? There's no need to place the register save area into the\n-\t aligned local stack frame.  We should do this later, after\n-\t the register saves.  */\n-      m->fs.sp_offset = (m->fs.sp_offset + align_bytes - 1) & -align_bytes;\n-      m->fs.fp_valid = false;\n-      m->fs.realigned = true;\n+      /* For the purposes of register save area addressing, the stack\n+         pointer is no longer valid.  As for the value of sp_offset,\n+\t see ix86_compute_frame_layout, which we need to match in order\n+\t to pass verification of stack_pointer_offset at the end.  */\n+      m->fs.sp_offset = (m->fs.sp_offset + align_bytes) & -align_bytes;\n+      m->fs.sp_valid = false;\n     }\n \n-  if (!frame.save_regs_using_mov)\n-    {\n-      ix86_emit_save_regs ();\n-      int_registers_saved = true;\n-      gcc_assert (m->fs.sp_offset == frame.reg_save_offset);\n-    }\n   allocate = frame.stack_pointer_offset - m->fs.sp_offset;\n \n   /* The stack has already been decremented by the instruction calling us\n@@ -9615,21 +9635,10 @@ ix86_expand_prologue (void)\n \t}\n     }\n \n-  /* When using red zone we may start register saving before allocating the\n-     stack frame saving one cycle of the prologue.  However, avoid doing this\n-     if we have to probe the stack; at least on x86_64 the stack probe can\n-     turn into a call that clobbers a red zone location.  */\n-  if (!int_registers_saved\n-      && ix86_using_red_zone ()\n-      && (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT))\n-    {\n-      ix86_emit_save_regs_using_mov (frame.reg_save_offset);\n-      int_registers_saved = true;\n-    }\n-\n   if (allocate == 0)\n     ;\n-  else if (!ix86_target_stack_probe () || allocate < CHECK_STACK_LIMIT)\n+  else if (!ix86_target_stack_probe ()\n+\t   || frame.stack_pointer_offset < CHECK_STACK_LIMIT)\n     {\n       pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t         GEN_INT (-allocate), -1,\n@@ -9918,19 +9927,14 @@ ix86_expand_epilogue (int style)\n   ix86_finalize_stack_realign_flags ();\n   ix86_compute_frame_layout (&frame);\n \n-  /* When stack is realigned, SP must be valid.  */\n   m->fs.sp_valid = (!frame_pointer_needed\n-\t\t    || current_function_sp_is_unchanging\n-\t\t    || stack_realign_fp);\n+\t\t    || (current_function_sp_is_unchanging\n+\t\t\t&& !stack_realign_fp));\n   gcc_assert (!m->fs.sp_valid\n \t      || m->fs.sp_offset == frame.stack_pointer_offset);\n \n-  /* The FP must be valid if the frame pointer is present, but not\n-     if the register save area is in the re-aligned local frame and\n-     the FP points to the unaligned argument frame.  */\n-  gcc_assert (frame_pointer_needed\n-\t      ? stack_realign_fp != m->fs.fp_valid\n-\t      : !m->fs.fp_valid);\n+  /* The FP must be valid if the frame pointer is present.  */\n+  gcc_assert (frame_pointer_needed == m->fs.fp_valid);\n   gcc_assert (!m->fs.fp_valid\n \t      || m->fs.fp_offset == frame.hard_frame_pointer_offset);\n \n@@ -9955,10 +9959,10 @@ ix86_expand_epilogue (int style)\n       /* The red-zone begins below the return address.  */\n       m->fs.red_zone_offset = RED_ZONE_SIZE + UNITS_PER_WORD;\n \n-      /* Since the register save area is in the aligned portion of\n+      /* When the register save area is in the aligned portion of\n          the stack, determine the maximum runtime displacement that\n \t matches up with the aligned frame.  */\n-      if (crtl->stack_realign_needed)\n+      if (stack_realign_drap)\n \tm->fs.red_zone_offset -= (crtl->stack_alignment_needed / BITS_PER_UNIT\n \t\t\t\t  + UNITS_PER_WORD);\n     }\n@@ -10030,7 +10034,7 @@ ix86_expand_epilogue (int style)\n \t  rtx insn, sa = EH_RETURN_STACKADJ_RTX;\n \n \t  /* Stack align doesn't work with eh_return.  */\n-\t  gcc_assert (!crtl->stack_realign_needed);\n+\t  gcc_assert (!stack_realign_drap);\n \t  /* Neither does regparm nested functions.  */\n \t  gcc_assert (!ix86_static_chain_on_stack);\n \n@@ -10109,17 +10113,8 @@ ix86_expand_epilogue (int style)\n \n   /* If we used a stack pointer and haven't already got rid of it,\n      then do so now.  */\n-  if (m->fs.fp_valid || stack_realign_fp)\n+  if (m->fs.fp_valid)\n     {\n-      if (stack_realign_fp)\n-\t{\n-\t  /* We're re-defining what it means to be the local stack\n-\t     frame.  Thus the FP is suddenly valid and the SP isn't.  */\n-\t  m->fs.fp_valid = true;\n-\t  m->fs.sp_valid = false;\n-\t  m->fs.realigned = false;\n-\t}\n-\n       /* If the stack pointer is valid and pointing at the frame\n \t pointer store address, then we only need a pop.  */\n       if (m->fs.sp_valid && m->fs.sp_offset == frame.hard_frame_pointer_offset)"}, {"sha": "4b4042adb684fc449ef24705ed152b19fe690917", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b15a461e43ed3183153a6887a43a4041a0f816/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b15a461e43ed3183153a6887a43a4041a0f816/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=35b15a461e43ed3183153a6887a43a4041a0f816", "patch": "@@ -2456,6 +2456,10 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t     alignment.  */\n           if (fde && XEXP (src, 0) == stack_pointer_rtx)\n             {\n+\t      /* We interpret reg_save differently with stack_realign set.\n+\t\t Thus we must flush whatever we have queued first.  */\n+\t      flush_queued_reg_saves ();\n+\n               gcc_assert (cfa_store.reg == REGNO (XEXP (src, 0)));\n               fde->stack_realign = 1;\n               fde->stack_realignment = INTVAL (XEXP (src, 1));"}]}