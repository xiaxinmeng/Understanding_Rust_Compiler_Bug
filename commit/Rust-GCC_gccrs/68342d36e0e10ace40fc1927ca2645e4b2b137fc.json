{"sha": "68342d36e0e10ace40fc1927ca2645e4b2b137fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgzNDJkMzZlMGUxMGFjZTQwZmMxOTI3Y2EyNjQ1ZTRiMmIxMzdmYw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-08-12T02:42:27Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-08-12T02:42:27Z"}, "message": "(reg_equiv_replace): New variable.\n\n(update_equiv_regs): Set reg_equiv_replacement for all REG_EQUIV\nnotes encountered or generated.\n\nFrom-SVN: r12618", "tree": {"sha": "52b51e2443db20ff8129dcc7203bd4d2080c78f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52b51e2443db20ff8129dcc7203bd4d2080c78f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68342d36e0e10ace40fc1927ca2645e4b2b137fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68342d36e0e10ace40fc1927ca2645e4b2b137fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68342d36e0e10ace40fc1927ca2645e4b2b137fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68342d36e0e10ace40fc1927ca2645e4b2b137fc/comments", "author": null, "committer": null, "parents": [{"sha": "6a305f32b2e218608299b9c0dc5cbf8264a98ce5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a305f32b2e218608299b9c0dc5cbf8264a98ce5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a305f32b2e218608299b9c0dc5cbf8264a98ce5"}], "stats": {"total": 56, "additions": 35, "deletions": 21}, "files": [{"sha": "de19b2fd88dfc176a77452bbb64be894065bc1fb", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68342d36e0e10ace40fc1927ca2645e4b2b137fc/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68342d36e0e10ace40fc1927ca2645e4b2b137fc/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=68342d36e0e10ace40fc1927ca2645e4b2b137fc", "patch": "@@ -236,7 +236,10 @@ static int this_insn_number;\n static rtx this_insn;\n \n /* Used to communicate changes made by update_equiv_regs to\n-   memref_referenced_p.  */\n+   memref_referenced_p.  reg_equiv_replacement is set for any REG_EQUIV note\n+   found or created, so that we can keep track of what memory accesses might\n+   be created later, e.g. by reload.  */\n+\n static rtx *reg_equiv_replacement;\n \n static void alloc_qty\t\tPROTO((int, enum machine_mode, int, int));\n@@ -955,12 +958,17 @@ static void\n update_equiv_regs ()\n {\n   rtx *reg_equiv_init_insn = (rtx *) alloca (max_regno * sizeof (rtx *));\n+  /* Set when an attempt should be made to replace a register with the\n+     associated reg_equiv_replacement entry at the end of this function.  */\n+  char *reg_equiv_replace\n+    = (char *) alloca (max_regno * sizeof *reg_equiv_replace);\n   rtx insn;\n \n   reg_equiv_replacement = (rtx *) alloca (max_regno * sizeof (rtx *));\n \n   bzero ((char *) reg_equiv_init_insn, max_regno * sizeof (rtx *));\n   bzero ((char *) reg_equiv_replacement, max_regno * sizeof (rtx *));\n+  bzero ((char *) reg_equiv_replace, max_regno * sizeof *reg_equiv_replace);\n \n   init_alias_analysis ();\n \n@@ -1069,32 +1077,38 @@ update_equiv_regs ()\n \tREG_NOTES (insn) = note = gen_rtx (EXPR_LIST, REG_EQUIV, SET_SRC (set),\n \t\t\t\t\t   REG_NOTES (insn));\n \n-      /* Don't mess with things live during setjmp.  */\n-      if (note && reg_live_length[regno] >= 0)\n+      if (note)\n \t{\n \t  int regno = REGNO (dest);\n \n-\t  /* Note that the statement below does not affect the priority\n-\t     in local-alloc!  */\n-\t  reg_live_length[regno] *= 2;\n+\t  reg_equiv_replacement[regno] = XEXP (note, 0);\n+\n+\t  /* Don't mess with things live during setjmp.  */\n+\t  if (reg_live_length[regno] >= 0)\n+\t    {\n+\t      /* Note that the statement below does not affect the priority\n+\t\t in local-alloc!  */\n+\t      reg_live_length[regno] *= 2;\n \n-\t  /* If the register is referenced exactly twice, meaning it is set\n-\t     once and used once, indicate that the reference may be replaced\n-\t     by the equivalence we computed above.  If the register is only\n-\t     used in one basic block, this can't succeed or combine would\n-\t     have done it.\n \n-\t     It would be nice to use \"loop_depth * 2\" in the compare\n-\t     below.  Unfortunately, LOOP_DEPTH need not be constant within\n-\t     a basic block so this would be too complicated.\n+\t      /* If the register is referenced exactly twice, meaning it is\n+\t\t set once and used once, indicate that the reference may be\n+\t\t replaced by the equivalence we computed above.  If the\n+\t\t register is only used in one basic block, this can't succeed\n+\t\t or combine would have done it.\n \n-\t     This case normally occurs when a parameter is read from memory\n-\t     and then used exactly once, not in a loop.  */\n+\t\t It would be nice to use \"loop_depth * 2\" in the compare\n+\t\t below.  Unfortunately, LOOP_DEPTH need not be constant within\n+\t\t a basic block so this would be too complicated.\n \n-\t  if (reg_n_refs[regno] == 2\n-\t      && reg_basic_block[regno] < 0\n-\t      && rtx_equal_p (XEXP (note, 0), SET_SRC (set)))\n-\t    reg_equiv_replacement[regno] = SET_SRC (set);\n+\t\t This case normally occurs when a parameter is read from\n+\t\t memory and then used exactly once, not in a loop.  */\n+\n+\t\tif (reg_n_refs[regno] == 2\n+\t\t    && reg_basic_block[regno] < 0\n+\t\t    && rtx_equal_p (XEXP (note, 0), SET_SRC (set)))\n+\t\t  reg_equiv_replace[regno] = 1;\n+\t    }\n \t}\n     }\n \n@@ -1115,7 +1129,7 @@ update_equiv_regs ()\n \t  {\n \t    int regno = REGNO (XEXP (link, 0));\n \n-\t    if (reg_equiv_replacement[regno]\n+\t    if (reg_equiv_replace[regno]\n \t\t&& validate_replace_rtx (regno_reg_rtx[regno],\n \t\t\t\t\t reg_equiv_replacement[regno], insn))\n \t      {"}]}