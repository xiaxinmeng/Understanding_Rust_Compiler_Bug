{"sha": "91987857e694109fa312c9d2d83785aee5fb9c28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE5ODc4NTdlNjk0MTA5ZmEzMTJjOWQyZDgzNzg1YWVlNWZiOWMyOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:24:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:24:02Z"}, "message": "[27/46] Remove duplicated stmt_vec_info lookups\n\nVarious places called vect_dr_stmt or vinfo_for_stmt multiple times\non the same input.  This patch makes them reuse the earlier result.\nIt also splits a couple of single vinfo_for_stmt calls out into\nseparate statements so that they can be reused in later patches.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence)\n\t(vect_slp_analyze_node_dependences, vect_analyze_data_ref_accesses)\n\t(vect_permute_store_chain, vect_permute_load_chain)\n\t(vect_shift_permute_load_chain, vect_transform_grouped_load): Avoid\n\trepeated stmt_vec_info lookups.\n\t* tree-vect-loop-manip.c (vect_can_advance_ivs_p): Likewise.\n\t(vect_update_ivs_after_vectorizer): Likewise.\n\t* tree-vect-loop.c (vect_is_simple_reduction): Likewise.\n\t(vect_create_epilog_for_reduction, vectorizable_reduction): Likewise.\n\t* tree-vect-patterns.c (adjust_bool_stmts): Likewise.\n\t* tree-vect-slp.c (vect_analyze_slp_instance): Likewise.\n\t(vect_bb_slp_scalar_cost): Likewise.\n\t* tree-vect-stmts.c (get_group_alias_ptr_type): Likewise.\n\nFrom-SVN: r263142", "tree": {"sha": "3b452bba62175cb7ca1c21add51e201f53792dd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b452bba62175cb7ca1c21add51e201f53792dd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91987857e694109fa312c9d2d83785aee5fb9c28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91987857e694109fa312c9d2d83785aee5fb9c28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91987857e694109fa312c9d2d83785aee5fb9c28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91987857e694109fa312c9d2d83785aee5fb9c28/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "beb456c375ea71d57e35400e9b7107e09e996965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb456c375ea71d57e35400e9b7107e09e996965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beb456c375ea71d57e35400e9b7107e09e996965"}], "stats": {"total": 96, "additions": 61, "deletions": 35}, "files": [{"sha": "453e96c9e64515f42524f8d239d9656b65bceefd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91987857e694109fa312c9d2d83785aee5fb9c28", "patch": "@@ -1,3 +1,19 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence)\n+\t(vect_slp_analyze_node_dependences, vect_analyze_data_ref_accesses)\n+\t(vect_permute_store_chain, vect_permute_load_chain)\n+\t(vect_shift_permute_load_chain, vect_transform_grouped_load): Avoid\n+\trepeated stmt_vec_info lookups.\n+\t* tree-vect-loop-manip.c (vect_can_advance_ivs_p): Likewise.\n+\t(vect_update_ivs_after_vectorizer): Likewise.\n+\t* tree-vect-loop.c (vect_is_simple_reduction): Likewise.\n+\t(vect_create_epilog_for_reduction, vectorizable_reduction): Likewise.\n+\t* tree-vect-patterns.c (adjust_bool_stmts): Likewise.\n+\t* tree-vect-slp.c (vect_analyze_slp_instance): Likewise.\n+\t(vect_bb_slp_scalar_cost): Likewise.\n+\t* tree-vect-stmts.c (get_group_alias_ptr_type): Likewise.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-data-refs.c (vect_check_gather_scatter): Pass the"}, {"sha": "76b0699c3872a102684b355d0da94c1df9dcb571", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=91987857e694109fa312c9d2d83785aee5fb9c28", "patch": "@@ -472,8 +472,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t\t... = a[i];\n \t\ta[i+1] = ...;\n \t     where loads from the group interleave with the store.  */\n-\t  if (!vect_preserves_scalar_order_p (vect_dr_stmt(dra),\n-\t\t\t\t\t      vect_dr_stmt (drb)))\n+\t  if (!vect_preserves_scalar_order_p (stmtinfo_a, stmtinfo_b))\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -673,6 +672,7 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n      in NODE verifying we can sink them up to the last stmt in the\n      group.  */\n   stmt_vec_info last_access_info = vect_find_last_scalar_stmt_in_slp (node);\n+  vec_info *vinfo = last_access_info->vinfo;\n   for (unsigned k = 0; k < SLP_INSTANCE_GROUP_SIZE (instance); ++k)\n     {\n       stmt_vec_info access_info = SLP_TREE_SCALAR_STMTS (node)[k];\n@@ -691,7 +691,8 @@ vect_slp_analyze_node_dependences (slp_instance instance, slp_tree node,\n \n \t  /* If we couldn't record a (single) data reference for this\n \t     stmt we have to resort to the alias oracle.  */\n-\t  data_reference *dr_b = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt));\n+\t  stmt_vec_info stmt_info = vinfo->lookup_stmt (stmt);\n+\t  data_reference *dr_b = STMT_VINFO_DATA_REF (stmt_info);\n \t  if (!dr_b)\n \t    {\n \t      /* We are moving a store or sinking a load - this means\n@@ -2951,7 +2952,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t      || data_ref_compare_tree (DR_BASE_ADDRESS (dra),\n \t\t\t\t\tDR_BASE_ADDRESS (drb)) != 0\n \t      || data_ref_compare_tree (DR_OFFSET (dra), DR_OFFSET (drb)) != 0\n-\t      || !can_group_stmts_p (vect_dr_stmt (dra), vect_dr_stmt (drb)))\n+\t      || !can_group_stmts_p (stmtinfo_a, stmtinfo_b))\n \t    break;\n \n \t  /* Check that the data-refs have the same constant size.  */\n@@ -3040,11 +3041,11 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t  /* Link the found element into the group list.  */\n \t  if (!DR_GROUP_FIRST_ELEMENT (stmtinfo_a))\n \t    {\n-\t      DR_GROUP_FIRST_ELEMENT (stmtinfo_a) = vect_dr_stmt (dra);\n+\t      DR_GROUP_FIRST_ELEMENT (stmtinfo_a) = stmtinfo_a;\n \t      lastinfo = stmtinfo_a;\n \t    }\n-\t  DR_GROUP_FIRST_ELEMENT (stmtinfo_b) = vect_dr_stmt (dra);\n-\t  DR_GROUP_NEXT_ELEMENT (lastinfo) = vect_dr_stmt (drb);\n+\t  DR_GROUP_FIRST_ELEMENT (stmtinfo_b) = stmtinfo_a;\n+\t  DR_GROUP_NEXT_ELEMENT (lastinfo) = stmtinfo_b;\n \t  lastinfo = stmtinfo_b;\n \t}\n     }\n@@ -5219,9 +5220,10 @@ vect_permute_store_chain (vec<tree> dr_chain,\n \t\t\t  gimple_stmt_iterator *gsi,\n \t\t\t  vec<tree> *result_chain)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vect1, vect2, high, low;\n   gimple *perm_stmt;\n-  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   tree perm_mask_low, perm_mask_high;\n   tree data_ref;\n   tree perm3_mask_low, perm3_mask_high;\n@@ -5840,11 +5842,12 @@ vect_permute_load_chain (vec<tree> dr_chain,\n \t\t\t gimple_stmt_iterator *gsi,\n \t\t\t vec<tree> *result_chain)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree data_ref, first_vect, second_vect;\n   tree perm_mask_even, perm_mask_odd;\n   tree perm3_mask_low, perm3_mask_high;\n   gimple *perm_stmt;\n-  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   unsigned int i, j, log_length = exact_log2 (length);\n \n   result_chain->quick_grow (length);\n@@ -6043,14 +6046,14 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t\t\t       gimple_stmt_iterator *gsi,\n \t\t\t       vec<tree> *result_chain)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vect[3], vect_shift[3], data_ref, first_vect, second_vect;\n   tree perm2_mask1, perm2_mask2, perm3_mask;\n   tree select_mask, shift1_mask, shift2_mask, shift3_mask, shift4_mask;\n   gimple *perm_stmt;\n \n-  tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   unsigned int i;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n \n   unsigned HOST_WIDE_INT nelt, vf;\n@@ -6310,6 +6313,7 @@ void\n vect_transform_grouped_load (gimple *stmt, vec<tree> dr_chain, int size,\n \t\t\t     gimple_stmt_iterator *gsi)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   machine_mode mode;\n   vec<tree> result_chain = vNULL;\n \n@@ -6321,7 +6325,7 @@ vect_transform_grouped_load (gimple *stmt, vec<tree> dr_chain, int size,\n   /* If reassociation width for vector type is 2 or greater target machine can\n      execute 2 or more vector instructions in parallel.  Otherwise try to\n      get chain for loads group using vect_shift_permute_load_chain.  */\n-  mode = TYPE_MODE (STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt)));\n+  mode = TYPE_MODE (STMT_VINFO_VECTYPE (stmt_info));\n   if (targetm.sched.reassociation_width (VEC_PERM_EXPR, mode) > 1\n       || pow2p_hwi (size)\n       || !vect_shift_permute_load_chain (dr_chain, size, stmt,"}, {"sha": "662f556283269316ef9e7373fc78fd5213445b08", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=91987857e694109fa312c9d2d83785aee5fb9c28", "patch": "@@ -1377,6 +1377,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n       tree evolution_part;\n \n       gphi *phi = gsi.phi ();\n+      stmt_vec_info phi_info = loop_vinfo->lookup_stmt (phi);\n       if (dump_enabled_p ())\n \t{\n           dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n@@ -1397,8 +1398,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \n       /* Analyze the evolution function.  */\n \n-      evolution_part\n-\t= STMT_VINFO_LOOP_PHI_EVOLUTION_PART (vinfo_for_stmt (phi));\n+      evolution_part = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (phi_info);\n       if (evolution_part == NULL_TREE)\n         {\n \t  if (dump_enabled_p ())\n@@ -1500,6 +1500,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo,\n \n       gphi *phi = gsi.phi ();\n       gphi *phi1 = gsi1.phi ();\n+      stmt_vec_info phi_info = loop_vinfo->lookup_stmt (phi);\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1517,7 +1518,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo,\n \t}\n \n       type = TREE_TYPE (gimple_phi_result (phi));\n-      step_expr = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (vinfo_for_stmt (phi));\n+      step_expr = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (phi_info);\n       step_expr = unshare_expr (step_expr);\n \n       /* FORNOW: We do not support IVs whose evolution function is a polynomial"}, {"sha": "3060d848b90f4e9301263b8f62828ea0054b11cf", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=91987857e694109fa312c9d2d83785aee5fb9c28", "patch": "@@ -3252,7 +3252,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n     }\n \n   /* Dissolve group eventually half-built by vect_is_slp_reduction.  */\n-  stmt_vec_info first = REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (def_stmt));\n+  stmt_vec_info first = REDUC_GROUP_FIRST_ELEMENT (def_stmt_info);\n   while (first)\n     {\n       stmt_vec_info next = REDUC_GROUP_NEXT_ELEMENT (first);\n@@ -4784,7 +4784,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n      # b1 = phi <b2, b0>\n      a2 = operation (a1)\n      b2 = operation (b1)  */\n-  slp_reduc = (slp_node && !REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)));\n+  slp_reduc = (slp_node && !REDUC_GROUP_FIRST_ELEMENT (stmt_info));\n \n   /* True if we should implement SLP_REDUC using native reduction operations\n      instead of scalar operations.  */\n@@ -4799,7 +4799,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \n      we may end up with more than one vector result.  Here we reduce them to\n      one vector.  */\n-  if (REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) || direct_slp_reduc)\n+  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info) || direct_slp_reduc)\n     {\n       tree first_vect = PHI_RESULT (new_phis[0]);\n       gassign *new_vec_stmt = NULL;\n@@ -5544,7 +5544,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n      necessary, hence we set here REDUC_GROUP_SIZE to 1.  SCALAR_DEST is the\n      LHS of the last stmt in the reduction chain, since we are looking for\n      the loop exit phi node.  */\n-  if (REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+  if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     {\n       stmt_vec_info dest_stmt_info\n \t= SLP_TREE_SCALAR_STMTS (slp_node)[group_size - 1];\n@@ -6095,8 +6095,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree cond_reduc_val = NULL_TREE;\n \n   /* Make sure it was already recognized as a reduction computation.  */\n-  if (STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_reduction_def\n-      && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_nested_cycle)\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def\n+      && STMT_VINFO_DEF_TYPE (stmt_info) != vect_nested_cycle)\n     return false;\n \n   if (nested_in_vect_loop_p (loop, stmt))\n@@ -6789,7 +6789,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (reduction_type == FOLD_LEFT_REDUCTION\n       && slp_node\n-      && !REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)))\n+      && !REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     {\n       /* We cannot use in-order reductions in this case because there is\n \t an implicit reassociation of the operations involved.  */\n@@ -6818,7 +6818,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   /* Check extra constraints for variable-length unchained SLP reductions.  */\n   if (STMT_SLP_TYPE (stmt_info)\n-      && !REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n+      && !REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n       && !nunits_out.is_constant ())\n     {\n       /* We checked above that we could build the initial vector when"}, {"sha": "909444184e65fa19cad23284dcc3a4b5b2e10891", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=91987857e694109fa312c9d2d83785aee5fb9c28", "patch": "@@ -3505,6 +3505,8 @@ static tree\n adjust_bool_stmts (hash_set <gimple *> &bool_stmt_set,\n \t\t   tree out_type, gimple *stmt)\n {\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\n   /* Gather original stmts in the bool pattern in their order of appearance\n      in the IL.  */\n   auto_vec<gimple *> bool_stmts (bool_stmt_set.elements ());\n@@ -3517,11 +3519,11 @@ adjust_bool_stmts (hash_set <gimple *> &bool_stmt_set,\n   hash_map <tree, tree> defs;\n   for (unsigned i = 0; i < bool_stmts.length (); ++i)\n     adjust_bool_pattern (gimple_assign_lhs (bool_stmts[i]),\n-\t\t\t out_type, vinfo_for_stmt (stmt), defs);\n+\t\t\t out_type, stmt_info, defs);\n \n   /* Pop the last pattern seq stmt and install it as pattern root for STMT.  */\n   gimple *pattern_stmt\n-    = gimple_seq_last_stmt (STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (stmt)));\n+    = gimple_seq_last_stmt (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info));\n   return gimple_assign_lhs (pattern_stmt);\n }\n "}, {"sha": "efa887cbb74f1b142bacea462714ebf6a23249ac", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=91987857e694109fa312c9d2d83785aee5fb9c28", "patch": "@@ -2157,8 +2157,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n      vector size.  */\n   unsigned HOST_WIDE_INT const_nunits;\n   if (is_a <bb_vec_info> (vinfo)\n-      && STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt))\n-      && DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n+      && STMT_VINFO_GROUPED_ACCESS (stmt_info)\n+      && DR_GROUP_FIRST_ELEMENT (stmt_info)\n       && nunits.is_constant (&const_nunits))\n     {\n       /* We consider breaking the group only on VF boundaries from the existing\n@@ -2693,6 +2693,7 @@ vect_bb_slp_scalar_cost (basic_block bb,\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n     {\n       gimple *stmt = stmt_info->stmt;\n+      vec_info *vinfo = stmt_info->vinfo;\n       ssa_op_iter op_iter;\n       def_operand_p def_p;\n \n@@ -2709,12 +2710,14 @@ vect_bb_slp_scalar_cost (basic_block bb,\n \t  imm_use_iterator use_iter;\n \t  gimple *use_stmt;\n \t  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, DEF_FROM_PTR (def_p))\n-\t    if (!is_gimple_debug (use_stmt)\n-\t\t&& (! vect_stmt_in_region_p (stmt_info->vinfo, use_stmt)\n-\t\t    || ! PURE_SLP_STMT (vinfo_for_stmt (use_stmt))))\n+\t    if (!is_gimple_debug (use_stmt))\n \t      {\n-\t\t(*life)[i] = true;\n-\t\tBREAK_FROM_IMM_USE_STMT (use_iter);\n+\t\tstmt_vec_info use_stmt_info = vinfo->lookup_stmt (use_stmt);\n+\t\tif (!use_stmt_info || !PURE_SLP_STMT (use_stmt_info))\n+\t\t  {\n+\t\t    (*life)[i] = true;\n+\t\t    BREAK_FROM_IMM_USE_STMT (use_iter);\n+\t\t  }\n \t      }\n \t}\n       if ((*life)[i])"}, {"sha": "71d595ef9ef8780ea0568f06e0bba7def09ae913", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91987857e694109fa312c9d2d83785aee5fb9c28/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=91987857e694109fa312c9d2d83785aee5fb9c28", "patch": "@@ -6193,11 +6193,11 @@ ensure_base_align (struct data_reference *dr)\n static tree\n get_group_alias_ptr_type (gimple *first_stmt)\n {\n+  stmt_vec_info first_stmt_info = vinfo_for_stmt (first_stmt);\n   struct data_reference *first_dr, *next_dr;\n \n-  first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-  stmt_vec_info next_stmt_info\n-    = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first_stmt));\n+  first_dr = STMT_VINFO_DATA_REF (first_stmt_info);\n+  stmt_vec_info next_stmt_info = DR_GROUP_NEXT_ELEMENT (first_stmt_info);\n   while (next_stmt_info)\n     {\n       next_dr = STMT_VINFO_DATA_REF (next_stmt_info);"}]}