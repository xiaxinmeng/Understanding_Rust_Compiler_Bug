{"sha": "383987620e8637d9e0dfccac57ca2674e4c6d0fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgzOTg3NjIwZTg2MzdkOWUwZGZjY2FjNTdjYTI2NzRlNGM2ZDBmZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-12-14T12:14:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1991-12-14T12:14:54Z"}, "message": "Initial revision\n\nFrom-SVN: r117", "tree": {"sha": "5c3630e94b2fa74a09f6a656e556174b3afc66a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c3630e94b2fa74a09f6a656e556174b3afc66a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/383987620e8637d9e0dfccac57ca2674e4c6d0fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383987620e8637d9e0dfccac57ca2674e4c6d0fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/383987620e8637d9e0dfccac57ca2674e4c6d0fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/383987620e8637d9e0dfccac57ca2674e4c6d0fd/comments", "author": null, "committer": null, "parents": [{"sha": "616f7d0077116d92a440dd69dc8c56dc9cdd7e36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/616f7d0077116d92a440dd69dc8c56dc9cdd7e36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/616f7d0077116d92a440dd69dc8c56dc9cdd7e36"}], "stats": {"total": 1470, "additions": 1470, "deletions": 0}, "files": [{"sha": "928043c57c2b8cca596ac8f6cfcc6149534c43ba", "filename": "gcc/global.c", "status": "added", "additions": 1470, "deletions": 0, "changes": 1470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/383987620e8637d9e0dfccac57ca2674e4c6d0fd/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/383987620e8637d9e0dfccac57ca2674e4c6d0fd/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=383987620e8637d9e0dfccac57ca2674e4c6d0fd", "patch": "@@ -0,0 +1,1470 @@\n+/* Allocate registers for pseudo-registers that span basic blocks.\n+   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+#include \"basic-block.h\"\n+#include \"hard-reg-set.h\"\n+#include \"regs.h\"\n+#include \"insn-config.h\"\n+#include \"output.h\"\n+\n+/* This pass of the compiler performs global register allocation.\n+   It assigns hard register numbers to all the pseudo registers\n+   that were not handled in local_alloc.  Assignments are recorded\n+   in the vector reg_renumber, not by changing the rtl code.\n+   (Such changes are made by final).  The entry point is\n+   the function global_alloc.\n+\n+   After allocation is complete, the reload pass is run as a subroutine\n+   of this pass, so that when a pseudo reg loses its hard reg due to\n+   spilling it is possible to make a second attempt to find a hard\n+   reg for it.  The reload pass is independent in other respects\n+   and it is run even when stupid register allocation is in use.\n+\n+   1. count the pseudo-registers still needing allocation\n+   and assign allocation-numbers (allocnos) to them.\n+   Set up tables reg_allocno and allocno_reg to map \n+   reg numbers to allocnos and vice versa.\n+   max_allocno gets the number of allocnos in use.\n+\n+   2. Allocate a max_allocno by max_allocno conflict bit matrix and clear it.\n+   Allocate a max_allocno by FIRST_PSEUDO_REGISTER conflict matrix\n+   for conflicts between allocnos and explicit hard register use\n+   (which includes use of pseudo-registers allocated by local_alloc).\n+\n+   3. for each basic block\n+    walk forward through the block, recording which\n+    unallocated registers and which hardware registers are live.\n+    Build the conflict matrix between the unallocated registers\n+    and another of unallocated registers versus hardware registers.\n+    Also record the preferred hardware registers\n+    for each unallocated one.\n+\n+   4. Sort a table of the allocnos into order of\n+   desirability of the variables.\n+\n+   5. Allocate the variables in that order; each if possible into\n+   a preferred register, else into another register.  */\n+\f\n+/* Number of pseudo-registers still requiring allocation\n+   (not allocated by local_allocate).  */\n+\n+static int max_allocno;\n+\n+/* Indexed by (pseudo) reg number, gives the allocno, or -1\n+   for pseudo registers already allocated by local_allocate.  */\n+\n+static int *reg_allocno;\n+\n+/* Indexed by allocno, gives the reg number.  */\n+\n+static int *allocno_reg;\n+\n+/* A vector of the integers from 0 to max_allocno-1,\n+   sorted in the order of first-to-be-allocated first.  */\n+\n+static int *allocno_order;\n+\n+/* Indexed by an allocno, gives the number of consecutive\n+   hard registers needed by that pseudo reg.  */\n+\n+static int *allocno_size;\n+\n+/* Indexed by (pseudo) reg number, gives the number of another\n+   lower-numbered pseudo reg which can share a hard reg with this peudo\n+   *even if the two pseudos would otherwise appear to conflict*.  */\n+\n+static int *reg_may_share;\n+\n+/* max_allocno by max_allocno array of bits,\n+   recording whether two allocno's conflict (can't go in the same\n+   hardware register).\n+\n+   `conflicts' is not symmetric; a conflict between allocno's i and j\n+   is recorded either in element i,j or in element j,i.  */\n+\n+static int *conflicts;\n+\n+/* Number of ints require to hold max_allocno bits.\n+   This is the length of a row in `conflicts'.  */\n+\n+static int allocno_row_words;\n+\n+/* Two macros to test or store 1 in an element of `conflicts'.  */\n+\n+#define CONFLICTP(I, J) \\\n+ (conflicts[(I) * allocno_row_words + (J) / INT_BITS]\t\\\n+  & (1 << ((J) % INT_BITS)))\n+\n+#define SET_CONFLICT(I, J) \\\n+ (conflicts[(I) * allocno_row_words + (J) / INT_BITS]\t\\\n+  |= (1 << ((J) % INT_BITS)))\n+\n+/* Set of hard regs currently live (during scan of all insns).  */\n+\n+static HARD_REG_SET hard_regs_live;\n+\n+/* Indexed by N, set of hard regs conflicting with allocno N.  */\n+\n+static HARD_REG_SET *hard_reg_conflicts;\n+\n+/* Indexed by N, set of hard regs preferred by allocno N.\n+   This is used to make allocnos go into regs that are copied to or from them,\n+   when possible, to reduce register shuffling.  */\n+\n+static HARD_REG_SET *hard_reg_preferences;\n+\n+/* Similar, but just counts register preferences made in simple copy\n+   operations, rather than arithmetic.  These are given priority because\n+   we can always eliminate an insn by using these, but using a register\n+   in the above list won't always eliminate an insn.  */\n+\n+static HARD_REG_SET *hard_reg_copy_preferences;\n+\n+/* Similar to hard_reg_preferences, but includes bits for subsequent\n+   registers when an allocno is multi-word.  The above variable is used for\n+   allocation while this is used to build reg_someone_prefers, below.  */\n+\n+static HARD_REG_SET *hard_reg_full_preferences;\n+\n+/* Indexed by N, set of hard registers that some later allocno has a\n+   preference for.  */\n+\n+static HARD_REG_SET *regs_someone_prefers;\n+\n+/* Set of registers that global-alloc isn't supposed to use.  */\n+\n+static HARD_REG_SET no_global_alloc_regs;\n+\n+/* Set of registers used so far.  */\n+\n+static HARD_REG_SET regs_used_so_far;\n+\n+/* Number of calls crossed by each allocno.  */\n+\n+static int *allocno_calls_crossed;\n+\n+/* Number of refs (weighted) to each allocno.  */\n+\n+static int *allocno_n_refs;\n+\n+/* Guess at live length of each allocno.\n+   This is actually the max of the live lengths of the regs.  */\n+\n+static int *allocno_live_length;\n+\n+/* Test a bit in TABLE, a vector of HARD_REG_SETs,\n+   for vector element I, and hard register number J.  */\n+\n+#define REGBITP(TABLE, I, J)     TEST_HARD_REG_BIT (TABLE[I], J)\n+\n+/* Set to 1 a bit in a vector of HARD_REG_SETs.  Works like REGBITP.  */\n+\n+#define SET_REGBIT(TABLE, I, J)  SET_HARD_REG_BIT (TABLE[I], J)\n+\n+/* Bit mask for allocnos live at current point in the scan.  */\n+\n+static int *allocnos_live;\n+\n+#define INT_BITS HOST_BITS_PER_INT\n+\n+/* Test, set or clear bit number I in allocnos_live,\n+   a bit vector indexed by allocno.  */\n+\n+#define ALLOCNO_LIVE_P(I) \\\n+  (allocnos_live[(I) / INT_BITS] & (1 << ((I) % INT_BITS)))\n+\n+#define SET_ALLOCNO_LIVE(I) \\\n+  (allocnos_live[(I) / INT_BITS] |= (1 << ((I) % INT_BITS)))\n+\n+#define CLEAR_ALLOCNO_LIVE(I) \\\n+  (allocnos_live[(I) / INT_BITS] &= ~(1 << ((I) % INT_BITS)))\n+\n+/* This is turned off because it doesn't work right for DImode.\n+   (And it is only used for DImode, so the other cases are worthless.)\n+   The problem is that it isn't true that there is NO possibility of conflict;\n+   only that there is no conflict if the two pseudos get the exact same regs.\n+   If they were allocated with a partial overlap, there would be a conflict.\n+   We can't safely turn off the conflict unless we have another way to\n+   prevent the partial overlap.\n+\n+   Idea: change hard_reg_conflicts so that instead of recording which\n+   hard regs the allocno may not overlap, it records where the allocno\n+   may not start.  Change both where it is used and where it is updated.\n+   Then there is a way to record that (reg:DI 108) may start at 10\n+   but not at 9 or 11.  There is still the question of how to record\n+   this semi-conflict between two pseudos.  */\n+#if 0\n+/* Reg pairs for which conflict after the current insn\n+   is inhibited by a REG_NO_CONFLICT note.\n+   If the table gets full, we ignore any other notes--that is conservative.  */\n+#define NUM_NO_CONFLICT_PAIRS 4\n+/* Number of pairs in use in this insn.  */\n+int n_no_conflict_pairs;\n+static struct { int allocno1, allocno2;}\n+  no_conflict_pairs[NUM_NO_CONFLICT_PAIRS];\n+#endif /* 0 */\n+\n+/* Record all regs that are set in any one insn.\n+   Communication from mark_reg_{store,clobber} and global_conflicts.  */\n+\n+static rtx *regs_set;\n+static int n_regs_set;\n+\n+/* All register that can be eliminated.  */\n+\n+static HARD_REG_SET eliminable_regset;\n+\n+static int allocno_compare ();\n+static void mark_reg_store ();\n+static void mark_reg_clobber ();\n+static void mark_reg_live_nc ();\n+static void mark_reg_death ();\n+static void dump_conflicts ();\n+void dump_global_regs ();\n+static void find_reg ();\n+static void global_conflicts ();\n+static void expand_preferences ();\n+static void prune_preferences ();\n+static void record_conflicts ();\n+static void set_preference ();\n+\f\n+/* Perform allocation of pseudo-registers not allocated by local_alloc.\n+   FILE is a file to output debugging information on,\n+   or zero if such output is not desired.  */\n+\n+void\n+global_alloc (file)\n+     FILE *file;\n+{\n+#ifdef ELIMINABLE_REGS\n+  static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n+#endif\n+  register int i;\n+  rtx x;\n+\n+  max_allocno = 0;\n+\n+  /* A machine may have certain hard registers that\n+     are safe to use only within a basic block.  */\n+\n+  CLEAR_HARD_REG_SET (no_global_alloc_regs);\n+#ifdef OVERLAPPING_REGNO_P\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (OVERLAPPING_REGNO_P (i))\n+      SET_HARD_REG_BIT (no_global_alloc_regs, i);\n+#endif\n+\n+  /* Build the regset of all eliminable registers and show we can't use those\n+     that we already know won't be eliminated.  */\n+#ifdef ELIMINABLE_REGS\n+  for (i = 0; i < sizeof eliminables / sizeof eliminables[0]; i++)\n+    {\n+      SET_HARD_REG_BIT (eliminable_regset, eliminables[i].from);\n+\n+      if (! CAN_ELIMINATE (eliminables[i].from, eliminables[i].to)\n+\t  || (eliminables[i].from == FRAME_POINTER_REGNUM\n+\t      && (! flag_omit_frame_pointer || FRAME_POINTER_REQUIRED\n+\t\t  || caller_save_needed)))\n+\tSET_HARD_REG_BIT (no_global_alloc_regs, eliminables[i].from);\n+    }\n+#else\n+  SET_HARD_REG_BIT (eliminable_regset, FRAME_POINTER_REGNUM);\n+\n+  /* If we know we will definitely not be eliminating the frame pointer,\n+     don't allocate it.  */\n+  if (! flag_omit_frame_pointer || FRAME_POINTER_REQUIRED\n+      || caller_save_needed)\n+    SET_HARD_REG_BIT (no_global_alloc_regs, FRAME_POINTER_REGNUM);\n+#endif\n+\n+  /* Track which registers have already been used.  Start with registers\n+     explicitly in the rtl, then registers allocated by local register\n+     allocation.\n+     \n+     We consider registers that do not have to be saved over calls as if\n+     they were already used since there is no cost in using them.  */\n+\n+  CLEAR_HARD_REG_SET (regs_used_so_far);\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (regs_ever_live[i] || call_used_regs[i])\n+      SET_HARD_REG_BIT (regs_used_so_far, i);\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    if (reg_renumber[i] >= 0)\n+      SET_HARD_REG_BIT (regs_used_so_far, reg_renumber[i]);\n+\n+  /* Establish mappings from register number to allocation number\n+     and vice versa.  In the process, count the allocnos.  */\n+\n+  reg_allocno = (int *) alloca (max_regno * sizeof (int));\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    reg_allocno[i] = -1;\n+\n+  /* Initialize the shared-hard-reg mapping\n+     from the list of pairs that may share.  */\n+  reg_may_share = (int *) alloca (max_regno * sizeof (int));\n+  bzero (reg_may_share, max_regno * sizeof (int));\n+  for (x = regs_may_share; x; x = XEXP (XEXP (x, 1), 1))\n+    {\n+      int r1 = REGNO (XEXP (x, 0));\n+      int r2 = REGNO (XEXP (XEXP (x, 1), 0));\n+      if (r1 > r2)\n+\treg_may_share[r1] = r2;\n+      else\n+\treg_may_share[r2] = r1;\n+    }\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    /* Note that reg_live_length[i] < 0 indicates a \"constant\" reg\n+       that we are supposed to refrain from putting in a hard reg.\n+       -2 means do make an allocno but don't allocate it.  */\n+    if (reg_n_refs[i] != 0 && reg_renumber[i] < 0 && reg_live_length[i] != -1\n+\t/* Don't allocate pseudos that cross calls,\n+\t   if this function receives a nonlocal goto.  */\n+\t&& (! current_function_has_nonlocal_label\n+\t    || reg_n_calls_crossed[i] == 0))\n+      {\n+\tif (reg_may_share[i] && reg_allocno[reg_may_share[i]] >= 0)\n+\t  reg_allocno[i] = reg_allocno[reg_may_share[i]];\n+\telse\n+\t  reg_allocno[i] = max_allocno++;\n+\tif (reg_live_length[i] == 0)\n+\t  abort ();\n+      }\n+    else\n+      reg_allocno[i] = -1;\n+\n+  allocno_reg = (int *) alloca (max_allocno * sizeof (int));\n+  allocno_size = (int *) alloca (max_allocno * sizeof (int));\n+  allocno_calls_crossed = (int *) alloca (max_allocno * sizeof (int));\n+  allocno_n_refs = (int *) alloca (max_allocno * sizeof (int));\n+  allocno_live_length = (int *) alloca (max_allocno * sizeof (int));\n+  bzero (allocno_size, max_allocno * sizeof (int));\n+  bzero (allocno_calls_crossed, max_allocno * sizeof (int));\n+  bzero (allocno_n_refs, max_allocno * sizeof (int));\n+  bzero (allocno_live_length, max_allocno * sizeof (int));\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+    if (reg_allocno[i] >= 0)\n+      {\n+\tint allocno = reg_allocno[i];\n+\tallocno_reg[allocno] = i;\n+\tallocno_size[allocno] = PSEUDO_REGNO_SIZE (i);\n+\tallocno_calls_crossed[allocno] += reg_n_calls_crossed[i];\n+\tallocno_n_refs[allocno] += reg_n_refs[i];\n+\tif (allocno_live_length[allocno] < reg_live_length[i])\n+\t  allocno_live_length[allocno] = reg_live_length[i];\n+      }\n+\n+  /* Allocate the space for the conflict and preference tables and\n+     initialize them.  */\n+\n+  hard_reg_conflicts\n+    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n+  bzero (hard_reg_conflicts, max_allocno * sizeof (HARD_REG_SET));\n+\n+  hard_reg_preferences\n+    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n+  bzero (hard_reg_preferences, max_allocno * sizeof (HARD_REG_SET));\n+  \n+  hard_reg_copy_preferences\n+    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n+  bzero (hard_reg_copy_preferences, max_allocno * sizeof (HARD_REG_SET));\n+  \n+  hard_reg_full_preferences\n+    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n+  bzero (hard_reg_full_preferences, max_allocno * sizeof (HARD_REG_SET));\n+  \n+  regs_someone_prefers\n+    = (HARD_REG_SET *) alloca (max_allocno * sizeof (HARD_REG_SET));\n+  bzero (regs_someone_prefers, max_allocno * sizeof (HARD_REG_SET));\n+\n+  allocno_row_words = (max_allocno + INT_BITS - 1) / INT_BITS;\n+\n+  conflicts = (int *) alloca (max_allocno * allocno_row_words * sizeof (int));\n+  bzero (conflicts, max_allocno * allocno_row_words * sizeof (int));\n+\n+  allocnos_live = (int *) alloca (allocno_row_words * sizeof (int));\n+\n+  /* If there is work to be done (at least one reg to allocate),\n+     perform global conflict analysis and allocate the regs.  */\n+\n+  if (max_allocno > 0)\n+    {\n+      /* Scan all the insns and compute the conflicts among allocnos\n+\t and between allocnos and hard regs.  */\n+\n+      global_conflicts ();\n+\n+      /* Eliminate conflicts between pseudos and eliminable registers.  If\n+\t the register is not eliminated, the pseudo won't really be able to\n+\t live in the eliminable register, so the conflict doesn't matter.\n+\t If we do eliminate the register, the conflict will no longer exist.\n+\t So in either case, we can ignore the conflict.  */\n+\n+      for (i = 0; i < max_allocno; i++)\n+\tAND_COMPL_HARD_REG_SET (hard_reg_conflicts[i], eliminable_regset);\n+\n+      /* Try to expand the preferences by merging them between allocnos.  */\n+\n+      expand_preferences ();\n+\n+      /* Determine the order to allocate the remaining pseudo registers.  */\n+\n+      allocno_order = (int *) alloca (max_allocno * sizeof (int));\n+      for (i = 0; i < max_allocno; i++)\n+\tallocno_order[i] = i;\n+\n+      /* Default the size to 1, since allocno_compare uses it to divide by.\n+\t Also convert allocno_live_length of zero to -1.  A length of zero\n+\t can occur when all the registers for that allocno have reg_live_length\n+\t equal to -2.  In this case, we want to make an allocno, but not\n+\t allocate it.  So avoid the divide-by-zero and set it to a low\n+\t priority.  */\n+\n+      for (i = 0; i < max_allocno; i++)\n+\t{\n+\t  if (allocno_size[i] == 0)\n+\t    allocno_size[i] = 1;\n+\t  if (allocno_live_length[i] == 0)\n+\t    allocno_live_length[i] = -1;\n+\t}\n+\n+      qsort (allocno_order, max_allocno, sizeof (int), allocno_compare);\n+      \n+      prune_preferences ();\n+\n+      if (file)\n+\tdump_conflicts (file);\n+\n+      /* Try allocating them, one by one, in that order,\n+\t except for parameters marked with reg_live_length[regno] == -2.  */\n+\n+      for (i = 0; i < max_allocno; i++)\n+\tif (reg_live_length[allocno_reg[allocno_order[i]]] >= 0)\n+\t  {\n+\t    /* If we have more than one register class,\n+\t       first try allocating in the class that is cheapest\n+\t       for this pseudo-reg.  If that fails, try any reg.  */\n+\t    if (N_REG_CLASSES > 1)\n+\t      {\n+\t\tfind_reg (allocno_order[i], HARD_CONST (0), 0, 0);\n+\t\tif (reg_renumber[allocno_reg[allocno_order[i]]] >= 0)\n+\t\t  continue;\n+\t      }\n+\t    if (!reg_preferred_or_nothing (allocno_reg[allocno_order[i]]))\n+\t      find_reg (allocno_order[i], HARD_CONST (0), 1, 0);\n+\t  }\n+    }\n+\n+  /* Do the reloads now while the allocno data still exist, so that we can\n+     try to assign new hard regs to any pseudo regs that are spilled.  */\n+\n+  if (n_basic_blocks > 0)\n+    reload (basic_block_head[0], 1, file);\n+}\n+\n+/* Sort predicate for ordering the allocnos.\n+   Returns -1 (1) if *v1 should be allocated before (after) *v2.  */\n+\n+static int\n+allocno_compare (v1, v2)\n+     int *v1, *v2;\n+{\n+  /* Note that the quotient will never be bigger than\n+     the value of floor_log2 times the maximum number of\n+     times a register can occur in one insn (surely less than 100).\n+     Multiplying this by 10000 can't overflow.  */\n+  register int pri1\n+    = (((double) (floor_log2 (allocno_n_refs[*v1]) * allocno_n_refs[*v1])\n+\t/ (allocno_live_length[*v1] * allocno_size[*v1]))\n+       * 10000);\n+  register int pri2\n+    = (((double) (floor_log2 (allocno_n_refs[*v2]) * allocno_n_refs[*v2])\n+\t/ (allocno_live_length[*v2] * allocno_size[*v2]))\n+       * 10000);\n+  if (pri2 - pri1)\n+    return pri2 - pri1;\n+\n+  /* If regs are equally good, sort by allocno,\n+     so that the results of qsort leave nothing to chance.  */\n+  return *v1 - *v2;\n+}\n+\f\n+/* Scan the rtl code and record all conflicts and register preferences in the\n+   conflict matrices and preference tables.  */\n+\n+static void\n+global_conflicts ()\n+{\n+  register int b, i;\n+  register rtx insn;\n+  short *block_start_allocnos;\n+\n+  /* Make a vector that mark_reg_{store,clobber} will store in.  */\n+  regs_set = (rtx *) alloca (max_parallel * sizeof (rtx) * 2);\n+\n+  block_start_allocnos = (short *) alloca (max_allocno * sizeof (short));\n+\n+  for (b = 0; b < n_basic_blocks; b++)\n+    {\n+      bzero (allocnos_live, allocno_row_words * sizeof (int));\n+\n+      /* Initialize table of registers currently live\n+\t to the state at the beginning of this basic block.\n+\t This also marks the conflicts among them.\n+\n+\t For pseudo-regs, there is only one bit for each one\n+\t no matter how many hard regs it occupies.\n+\t This is ok; we know the size from PSEUDO_REGNO_SIZE.\n+\t For explicit hard regs, we cannot know the size that way\n+\t since one hard reg can be used with various sizes.\n+\t Therefore, we must require that all the hard regs\n+\t implicitly live as part of a multi-word hard reg\n+\t are explicitly marked in basic_block_live_at_start.  */\n+\n+      {\n+\tregister int offset, bit;\n+\tregister regset old = basic_block_live_at_start[b];\n+\tint ax = 0;\n+\n+#ifdef HARD_REG_SET\n+\thard_regs_live = old[0];\n+#else\n+\tCOPY_HARD_REG_SET (hard_regs_live, old);\n+#endif\n+\tfor (offset = 0, i = 0; offset < regset_size; offset++)\n+\t  if (old[offset] == 0)\n+\t    i += HOST_BITS_PER_INT;\n+\t  else\n+\t    for (bit = 1; bit; bit <<= 1, i++)\n+\t      {\n+\t\tif (i >= max_regno)\n+\t\t  break;\n+\t\tif (old[offset] & bit)\n+\t\t  {\n+\t\t    register int a = reg_allocno[i];\n+\t\t    if (a >= 0)\n+\t\t      {\n+\t\t\tSET_ALLOCNO_LIVE (a);\n+\t\t\tblock_start_allocnos[ax++] = a;\n+\t\t      }\n+\t\t    else if ((a = reg_renumber[i]) >= 0)\n+\t\t      mark_reg_live_nc (a, PSEUDO_REGNO_MODE (i));\n+\t\t  }\n+\t      }\n+\n+\t/* Record that each allocno now live conflicts with each other\n+\t   allocno now live, and with each hard reg now live.  */\n+\n+\trecord_conflicts (block_start_allocnos, ax);\n+      }\n+\n+      insn = basic_block_head[b];\n+\n+      /* Scan the code of this basic block, noting which allocnos\n+\t and hard regs are born or die.  When one is born,\n+\t record a conflict with all others currently live.  */\n+\n+      while (1)\n+\t{\n+\t  register RTX_CODE code = GET_CODE (insn);\n+\t  register rtx link;\n+\n+\t  /* Make regs_set an empty set.  */\n+\n+\t  n_regs_set = 0;\n+\n+\t  if (code == INSN || code == CALL_INSN || code == JUMP_INSN)\n+\t    {\n+\t      int i = 0;\n+\n+#if 0\n+\t      for (link = REG_NOTES (insn);\n+\t\t   link && i < NUM_NO_CONFLICT_PAIRS;\n+\t\t   link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) == REG_NO_CONFLICT)\n+\t\t  {\n+\t\t    no_conflict_pairs[i].allocno1\n+\t\t      = reg_allocno[REGNO (SET_DEST (PATTERN (insn)))];\n+\t\t    no_conflict_pairs[i].allocno2\n+\t\t      = reg_allocno[REGNO (XEXP (link, 0))];\n+\t\t    i++;\n+\t\t  }\n+#endif /* 0 */\n+\n+\t      /* Mark any registers clobbered by INSN as live,\n+\t\t so they conflict with the inputs.  */\n+\n+\t      note_stores (PATTERN (insn), mark_reg_clobber);\n+\n+\t      /* Mark any registers dead after INSN as dead now.  */\n+\n+\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) == REG_DEAD)\n+\t\t  mark_reg_death (XEXP (link, 0));\n+\n+\t      /* Mark any registers set in INSN as live,\n+\t\t and mark them as conflicting with all other live regs.\n+\t\t Clobbers are processed again, so they conflict with\n+\t\t the registers that are set.  */\n+\n+\t      note_stores (PATTERN (insn), mark_reg_store);\n+\n+#ifdef AUTO_INC_DEC\n+\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) == REG_INC)\n+\t\t  mark_reg_store (XEXP (link, 0), 0);\n+#endif\n+\n+\t      /* Mark any registers set in INSN and then never used.  */\n+\n+\t      while (n_regs_set > 0)\n+\t\tif (find_regno_note (insn, REG_UNUSED,\n+\t\t\t\t     REGNO (regs_set[--n_regs_set])))\n+\t\t  mark_reg_death (regs_set[n_regs_set]);\n+\t    }\n+\n+\t  if (insn == basic_block_end[b])\n+\t    break;\n+\t  insn = NEXT_INSN (insn);\n+\t}\n+    }\n+}\n+/* Expand the preference information by looking for cases where one allocno\n+   dies in an insn that sets an allocno.  If those two allocnos don't conflict,\n+   merge any preferences between those allocnos.  */\n+\n+static void\n+expand_preferences ()\n+{\n+  rtx insn;\n+  rtx link;\n+  rtx set;\n+\n+  /* We only try to handle the most common cases here.  Most of the cases\n+     where this wins are reg-reg copies.  */\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t&& (set = single_set (insn)) != 0\n+\t&& GET_CODE (SET_DEST (set)) == REG\n+\t&& reg_allocno[REGNO (SET_DEST (set))] >= 0)\n+      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\tif (REG_NOTE_KIND (link) == REG_DEAD\n+\t    && GET_CODE (XEXP (link, 0)) == REG\n+\t    && reg_allocno[REGNO (XEXP (link, 0))] >= 0\n+\t    && ! CONFLICTP (reg_allocno[REGNO (SET_DEST (set))],\n+\t\t\t    reg_allocno[REGNO (XEXP (link, 0))])\n+\t    && ! CONFLICTP (reg_allocno[REGNO (XEXP (link, 0))],\n+\t\t\t    reg_allocno[REGNO (SET_DEST (set))]))\n+\t  {\n+\t    int a1 = reg_allocno[REGNO (SET_DEST (set))];\n+\t    int a2 = reg_allocno[REGNO (XEXP (link, 0))];\n+\n+\t    if (XEXP (link, 0) == SET_SRC (set))\n+\t      {\n+\t\tIOR_HARD_REG_SET (hard_reg_copy_preferences[a1],\n+\t\t\t\t  hard_reg_copy_preferences[a2]);\n+\t\tIOR_HARD_REG_SET (hard_reg_copy_preferences[a2],\n+\t\t\t\t  hard_reg_copy_preferences[a1]);\n+\t      }\n+\n+\t    IOR_HARD_REG_SET (hard_reg_preferences[a1],\n+\t\t\t      hard_reg_preferences[a2]);\n+\t    IOR_HARD_REG_SET (hard_reg_preferences[a2],\n+\t\t\t      hard_reg_preferences[a1]);\n+\t    IOR_HARD_REG_SET (hard_reg_full_preferences[a1],\n+\t\t\t      hard_reg_full_preferences[a2]);\n+\t    IOR_HARD_REG_SET (hard_reg_full_preferences[a2],\n+\t\t\t      hard_reg_full_preferences[a1]);\n+\t  }\n+}\n+\f\n+/* Prune the preferences for global registers to exclude registers that cannot\n+   be used.\n+   \n+   Compute `regs_someone_prefers', which is a bitmask of the hard registers\n+   that are preferred by conflicting registers of lower priority.  If possible,\n+   we will avoid using these registers.  */\n+   \n+static void\n+prune_preferences ()\n+{\n+  int i, j;\n+  int allocno;\n+  \n+  /* Scan least most important to most important.\n+     For each allocno, remove from preferences registers that cannot be used,\n+     either because of conflicts or register type.  Then compute all registers\n+     prefered by each lower-priority register that conflicts.  */\n+\n+  for (i = max_allocno - 1; i >= 0; i--)\n+    {\n+      HARD_REG_SET temp;\n+\n+      allocno = allocno_order[i];\n+      COPY_HARD_REG_SET (temp, hard_reg_conflicts[allocno]);\n+\n+      if (allocno_calls_crossed[allocno] == 0)\n+\tIOR_HARD_REG_SET (temp, fixed_reg_set);\n+      else\n+\tIOR_HARD_REG_SET (temp,\tcall_used_reg_set);\n+\n+      IOR_COMPL_HARD_REG_SET\n+\t(temp,\n+\t reg_class_contents[(int) reg_preferred_class (allocno_reg[allocno])]);\n+\n+      AND_COMPL_HARD_REG_SET (hard_reg_preferences[allocno], temp);\n+      AND_COMPL_HARD_REG_SET (hard_reg_copy_preferences[allocno], temp);\n+      AND_COMPL_HARD_REG_SET (hard_reg_full_preferences[allocno], temp);\n+\n+      CLEAR_HARD_REG_SET (regs_someone_prefers[allocno]);\n+\n+      /* Merge in the preferences of lower-priority registers (they have\n+\t already been pruned).  If we also prefer some of those registers,\n+\t don't exclude them unless we are of a smaller size (in which case\n+\t we want to give the lower-priority allocno the first chance for\n+\t these registers).  */\n+      for (j = i + 1; j < max_allocno; j++)\n+\tif (CONFLICTP (allocno, allocno_order[j]))\n+\t  {\n+\t    COPY_HARD_REG_SET (temp,\n+\t\t\t       hard_reg_full_preferences[allocno_order[j]]);\n+\t    if (allocno_size[allocno_order[j]] <= allocno_size[allocno])\n+\t      AND_COMPL_HARD_REG_SET (temp,\n+\t\t\t\t      hard_reg_full_preferences[allocno]);\n+\t\t\t       \n+\t    IOR_HARD_REG_SET (regs_someone_prefers[allocno], temp);\n+\t  }\n+    }\n+}\n+\f\n+/* Assign a hard register to ALLOCNO; look for one that is the beginning\n+   of a long enough stretch of hard regs none of which conflicts with ALLOCNO.\n+   The registers marked in PREFREGS are tried first.\n+\n+   LOSERS, if non-zero, is a HARD_REG_SET indicating registers that cannot\n+   be used for this allocation.\n+\n+   If ALL_REGS_P is zero, consider only the preferred class of ALLOCNO's reg.\n+   Otherwise ignore that preferred class.\n+\n+   If ACCEPT_CALL_CLOBBERED is nonzero, accept a call-clobbered hard reg that\n+   will have to be saved and restored at calls.\n+\n+   If we find one, record it in reg_renumber.\n+   If not, do nothing.  */\n+\n+static void\n+find_reg (allocno, losers, all_regs_p, accept_call_clobbered)\n+     int allocno;\n+     HARD_REG_SET losers;\n+     int all_regs_p;\n+     int accept_call_clobbered;\n+{\n+  register int i, best_reg, pass;\n+#ifdef HARD_REG_SET\n+  register\t\t/* Declare it register if it's a scalar.  */\n+#endif\n+    HARD_REG_SET used, used1;\n+\n+  enum reg_class class \n+    = all_regs_p ? ALL_REGS : reg_preferred_class (allocno_reg[allocno]);\n+  enum machine_mode mode = PSEUDO_REGNO_MODE (allocno_reg[allocno]);\n+\n+  if (accept_call_clobbered)\n+    COPY_HARD_REG_SET (used1, call_fixed_reg_set);\n+  else if (allocno_calls_crossed[allocno] == 0)\n+    COPY_HARD_REG_SET (used1, fixed_reg_set);\n+  else\n+    COPY_HARD_REG_SET (used1, call_used_reg_set);\n+\n+  /* Some registers should not be allocated in global-alloc.  */\n+  IOR_HARD_REG_SET (used1, no_global_alloc_regs);\n+  if (losers)\n+    IOR_HARD_REG_SET (used1, losers);\n+\n+  IOR_COMPL_HARD_REG_SET (used1, reg_class_contents[(int) class]);\n+  IOR_HARD_REG_SET (used1, hard_reg_conflicts[allocno]);\n+\n+  /* Try each hard reg to see if it fits.  Do this in two passes.\n+     In the first pass, skip registers that are prefered by some other pseudo\n+     to give it a better chance of getting one of those registers.  Only if\n+     we can't get a register when excluding those do we take one of them.\n+     However, we never allocate a register for the first time in pass 0.  */\n+\n+  COPY_HARD_REG_SET (used, used1);\n+  IOR_COMPL_HARD_REG_SET (used, regs_used_so_far);\n+  IOR_HARD_REG_SET (used, regs_someone_prefers[allocno]);\n+  \n+  best_reg = -1;\n+  for (i = FIRST_PSEUDO_REGISTER, pass = 0;\n+       pass <= 1 && i >= FIRST_PSEUDO_REGISTER;\n+       pass++)\n+    {\n+      if (pass == 1)\n+\tCOPY_HARD_REG_SET (used, used1);\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t{\n+#ifdef REG_ALLOC_ORDER\n+\t  int regno = reg_alloc_order[i];\n+#else\n+\t  int regno = i;\n+#endif\n+\t  if (! TEST_HARD_REG_BIT (used, regno)\n+\t      && HARD_REGNO_MODE_OK (regno, mode))\n+\t    {\n+\t      register int j;\n+\t      register int lim = regno + HARD_REGNO_NREGS (regno, mode);\n+\t      for (j = regno + 1;\n+\t\t   (j < lim\n+\t\t    && ! TEST_HARD_REG_BIT (used, j));\n+\t\t   j++);\n+\t      if (j == lim)\n+\t\t{\n+\t\t  best_reg = regno;\n+\t\t  break;\n+\t\t}\n+#ifndef REG_ALLOC_ORDER\n+\t      i = j;\t\t\t/* Skip starting points we know will lose */\n+#endif\n+\t    }\n+\t  }\n+      }\n+\n+  /* See if there is a preferred register with the same class as the register\n+     we allocated above.  Making this restriction prevents register\n+     preferencing from creating worse register allocation.\n+\n+     Remove from the preferred registers and conflicting registers.  Note that\n+     additional conflicts may have been added after `prune_preferences' was\n+     called. \n+\n+     First do this for those register with copy preferences, then all\n+     preferred registers.  */\n+\n+  AND_COMPL_HARD_REG_SET (hard_reg_copy_preferences[allocno], used);\n+  GO_IF_HARD_REG_SUBSET (hard_reg_copy_preferences[allocno],\n+\t\t\t reg_class_contents[(int) NO_REGS], no_copy_prefs);\n+\n+  if (best_reg >= 0)\n+    {\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (TEST_HARD_REG_BIT (hard_reg_copy_preferences[allocno], i)\n+\t    && HARD_REGNO_MODE_OK (i, mode)\n+\t    && (REGNO_REG_CLASS (i) == REGNO_REG_CLASS (best_reg)\n+\t\t|| reg_class_subset_p (REGNO_REG_CLASS (i),\n+\t\t\t\t       REGNO_REG_CLASS (best_reg))\n+\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg),\n+\t\t\t\t       REGNO_REG_CLASS (i))))\n+\t    {\n+\t      register int j;\n+\t      register int lim = i + HARD_REGNO_NREGS (i, mode);\n+\t      for (j = i + 1;\n+\t\t   (j < lim\n+\t\t    && ! TEST_HARD_REG_BIT (used, j)\n+\t\t    && (REGNO_REG_CLASS (j)\n+\t\t    \t== REGNO_REG_CLASS (best_reg + (j - i))\n+\t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (j),\n+\t\t\t\t\t       REGNO_REG_CLASS (best_reg + (j - i)))\n+\t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg + (j - i)),\n+\t\t\t\t\t       REGNO_REG_CLASS (j))));\n+\t\t   j++);\n+\t      if (j == lim)\n+\t\t{\n+\t\t  best_reg = i;\n+\t\t  goto no_prefs;\n+\t\t}\n+\t    }\n+    }\n+ no_copy_prefs:\n+\n+  AND_COMPL_HARD_REG_SET (hard_reg_preferences[allocno], used);\n+  GO_IF_HARD_REG_SUBSET (hard_reg_preferences[allocno],\n+\t\t\t reg_class_contents[(int) NO_REGS], no_prefs);\n+\n+  if (best_reg >= 0)\n+    {\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (TEST_HARD_REG_BIT (hard_reg_preferences[allocno], i)\n+\t    && HARD_REGNO_MODE_OK (i, mode)\n+\t    && (REGNO_REG_CLASS (i) == REGNO_REG_CLASS (best_reg)\n+\t\t|| reg_class_subset_p (REGNO_REG_CLASS (i),\n+\t\t\t\t       REGNO_REG_CLASS (best_reg))\n+\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg),\n+\t\t\t\t       REGNO_REG_CLASS (i))))\n+\t    {\n+\t      register int j;\n+\t      register int lim = i + HARD_REGNO_NREGS (i, mode);\n+\t      for (j = i + 1;\n+\t\t   (j < lim\n+\t\t    && ! TEST_HARD_REG_BIT (used, j)\n+\t\t    && (REGNO_REG_CLASS (j)\n+\t\t    \t== REGNO_REG_CLASS (best_reg + (j - i))\n+\t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (j),\n+\t\t\t\t\t       REGNO_REG_CLASS (best_reg + (j - i)))\n+\t\t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg + (j - i)),\n+\t\t\t\t\t       REGNO_REG_CLASS (j))));\n+\t\t   j++);\n+\t      if (j == lim)\n+\t\t{\n+\t\t  best_reg = i;\n+\t\t  break;\n+\t\t}\n+\t    }\n+    }\n+ no_prefs:\n+\n+  /* Did we find a register?  */\n+\n+  if (best_reg >= 0)\n+    {\n+      register int lim, j;\n+      HARD_REG_SET this_reg;\n+\n+      /* Yes.  Record it as the hard register of this pseudo-reg.  */\n+      reg_renumber[allocno_reg[allocno]] = best_reg;\n+      /* Also of any pseudo-regs that share with it.  */\n+      if (reg_may_share[allocno_reg[allocno]])\n+\tfor (j = FIRST_PSEUDO_REGISTER; j < max_regno; j++)\n+\t  if (reg_allocno[j] == allocno)\n+\t    reg_renumber[j] = best_reg;\n+\n+      /* Make a set of the hard regs being allocated.  */\n+      CLEAR_HARD_REG_SET (this_reg);\n+      lim = best_reg + HARD_REGNO_NREGS (best_reg, mode);\n+      for (j = best_reg; j < lim; j++)\n+\t{\n+\t  SET_HARD_REG_BIT (this_reg, j);\n+\t  SET_HARD_REG_BIT (regs_used_so_far, j);\n+\t}\n+      /* For each other pseudo-reg conflicting with this one,\n+\t mark it as conflicting with the hard regs this one occupies.  */\n+      lim = allocno;\n+      for (j = 0; j < max_allocno; j++)\n+\tif (CONFLICTP (lim, j) || CONFLICTP (j, lim))\n+\t  {\n+\t    IOR_HARD_REG_SET (hard_reg_conflicts[j], this_reg);\n+\t  }\n+    }\n+  else if (flag_caller_saves)\n+    {\n+      /* Did not find a register.  If it would be profitable to\n+\t allocate a call-clobbered register and save and restore it\n+\t around calls, do that.  */\n+      if (! accept_call_clobbered\n+\t  && allocno_calls_crossed[allocno] != 0\n+\t  && CALLER_SAVE_PROFITABLE (allocno_n_refs[allocno],\n+\t\t\t\t     allocno_calls_crossed[allocno]))\n+\t{\n+\t  find_reg (allocno, losers, all_regs_p, 1);\n+\t  if (reg_renumber[allocno_reg[allocno]] >= 0)\n+\t    caller_save_needed = 1;\n+\t}\n+    }\n+}\n+\f\n+/* Called from `reload' to look for a hard reg to put pseudo reg REGNO in.\n+   Perhaps it had previously seemed not worth a hard reg,\n+   or perhaps its old hard reg has been commandeered for reloads.\n+   FORBIDDEN_REGS indicates certain hard regs that may not be used, even if\n+   they do not appear to be allocated.\n+   If FORBIDDEN_REGS is zero, no regs are forbidden.  */\n+\n+void\n+retry_global_alloc (regno, forbidden_regs)\n+     int regno;\n+     HARD_REG_SET forbidden_regs;\n+{\n+  int allocno = reg_allocno[regno];\n+  if (allocno >= 0)\n+    {\n+      /* If we have more than one register class,\n+\t first try allocating in the class that is cheapest\n+\t for this pseudo-reg.  If that fails, try any reg.  */\n+      if (N_REG_CLASSES > 1)\n+\tfind_reg (allocno, forbidden_regs, 0, 0);\n+      if (reg_renumber[regno] < 0\n+\t  && !reg_preferred_or_nothing (regno))\n+\tfind_reg (allocno, forbidden_regs, 1, 0);\n+\n+      /* If we found a register, modify the RTL for the register to\n+\t show the hard register, and mark that register live.  */\n+      if (reg_renumber[regno] >= 0)\n+\t{\n+\t  REGNO (regno_reg_rtx[regno]) = reg_renumber[regno];\n+\t  mark_home_live (regno);\n+\t}\n+    }\n+}\n+\f\n+/* Record a conflict between register REGNO\n+   and everything currently live.\n+   REGNO must not be a pseudo reg that was allocated\n+   by local_alloc; such numbers must be translated through\n+   reg_renumber before calling here.  */\n+\n+static void\n+record_one_conflict (regno)\n+     int regno;\n+{\n+  register int j;\n+\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    /* When a hard register becomes live,\n+       record conflicts with live pseudo regs.  */\n+    for (j = 0; j < max_allocno; j++)\n+      {\n+\tif (ALLOCNO_LIVE_P (j))\n+\t  SET_HARD_REG_BIT (hard_reg_conflicts[j], regno);\n+      }\n+  else\n+    /* When a pseudo-register becomes live,\n+       record conflicts first with hard regs,\n+       then with other pseudo regs.  */\n+    {\n+      register int ialloc = reg_allocno[regno];\n+      register int ialloc_prod = ialloc * allocno_row_words;\n+      IOR_HARD_REG_SET (hard_reg_conflicts[ialloc], hard_regs_live);\n+      for (j = allocno_row_words - 1; j >= 0; j--)\n+\t{\n+#if 0\n+\t  int k;\n+\t  for (k = 0; k < n_no_conflict_pairs; k++)\n+\t    if (! ((j == no_conflict_pairs[k].allocno1\n+\t\t    && ialloc == no_conflict_pairs[k].allocno2)\n+\t\t   ||\n+\t\t   (j == no_conflict_pairs[k].allocno2\n+\t\t    && ialloc == no_conflict_pairs[k].allocno1)))\n+#endif /* 0 */\n+\t      conflicts[ialloc_prod + j] |= allocnos_live[j];\n+\t}\n+    }\n+}\n+\n+/* Record all allocnos currently live as conflicting\n+   with each other and with all hard regs currently live.\n+   ALLOCNO_VEC is a vector of LEN allocnos, all allocnos that\n+   are currently live.  Their bits are also flagged in allocnos_live.  */\n+\n+static void\n+record_conflicts (allocno_vec, len)\n+     register short *allocno_vec;\n+     register int len;\n+{\n+  register int allocno;\n+  register int j;\n+  register int ialloc_prod;\n+\n+  while (--len >= 0)\n+    {\n+      allocno = allocno_vec[len];\n+      ialloc_prod = allocno * allocno_row_words;\n+      IOR_HARD_REG_SET (hard_reg_conflicts[allocno], hard_regs_live);\n+      for (j = allocno_row_words - 1; j >= 0; j--)\n+\tconflicts[ialloc_prod + j] |= allocnos_live[j];\n+    }\n+}\n+\f\n+/* Handle the case where REG is set by the insn being scanned,\n+   during the forward scan to accumulate conflicts.\n+   Store a 1 in regs_live or allocnos_live for this register, record how many\n+   consecutive hardware registers it actually needs,\n+   and record a conflict with all other registers already live.\n+\n+   Note that even if REG does not remain alive after this insn,\n+   we must mark it here as live, to ensure a conflict between\n+   REG and any other regs set in this insn that really do live.\n+   This is because those other regs could be considered after this.\n+\n+   REG might actually be something other than a register;\n+   if so, we do nothing.\n+\n+   SETTER is 0 if this register was modified by an auto-increment (i.e.,\n+   a REG_INC note was found for it).\n+\n+   CLOBBERs are processed here by calling mark_reg_clobber.  */ \n+\n+static void\n+mark_reg_store (orig_reg, setter)\n+     rtx orig_reg, setter;\n+{\n+  register int regno;\n+  register rtx reg = orig_reg;\n+\n+  /* WORD is which word of a multi-register group is being stored.\n+     For the case where the store is actually into a SUBREG of REG.\n+     Except we don't use it; I believe the entire REG needs to be\n+     made live.  */\n+  int word = 0;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    {\n+      word = SUBREG_WORD (reg);\n+      reg = SUBREG_REG (reg);\n+    }\n+\n+  if (GET_CODE (reg) != REG)\n+    return;\n+\n+  if (setter && GET_CODE (setter) == CLOBBER)\n+    {\n+      /* A clobber of a register should be processed here too.  */\n+      mark_reg_clobber (orig_reg, setter);\n+      return;\n+    }\n+\n+  regs_set[n_regs_set++] = reg;\n+\n+  if (setter)\n+    set_preference (reg, SET_SRC (setter));\n+\n+  regno = REGNO (reg);\n+\n+  if (reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno] /* + word */;\n+\n+  /* Either this is one of the max_allocno pseudo regs not allocated,\n+     or it is or has a hardware reg.  First handle the pseudo-regs.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (reg_allocno[regno] >= 0)\n+\t{\n+\t  SET_ALLOCNO_LIVE (reg_allocno[regno]);\n+\t  record_one_conflict (regno);\n+\t}\n+    }\n+  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n+  else if (! fixed_regs[regno])\n+    {\n+      register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (regno < last)\n+\t{\n+\t  record_one_conflict (regno);\n+\t  SET_HARD_REG_BIT (hard_regs_live, regno);\n+\t  regno++;\n+\t}\n+    }\n+}\n+\f\n+/* Like mark_reg_set except notice just CLOBBERs; ignore SETs.  */\n+\n+static void\n+mark_reg_clobber (reg, setter)\n+     rtx reg, setter;\n+{\n+  register int regno;\n+\n+  /* WORD is which word of a multi-register group is being stored.\n+     For the case where the store is actually into a SUBREG of REG.\n+     Except we don't use it; I believe the entire REG needs to be\n+     made live.  */\n+  int word = 0;\n+\n+  if (GET_CODE (setter) != CLOBBER)\n+    return;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    {\n+      word = SUBREG_WORD (reg);\n+      reg = SUBREG_REG (reg);\n+    }\n+\n+  if (GET_CODE (reg) != REG)\n+    return;\n+\n+  regs_set[n_regs_set++] = reg;\n+\n+  regno = REGNO (reg);\n+\n+  if (reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno] /* + word */;\n+\n+  /* Either this is one of the max_allocno pseudo regs not allocated,\n+     or it is or has a hardware reg.  First handle the pseudo-regs.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (reg_allocno[regno] >= 0)\n+\t{\n+\t  SET_ALLOCNO_LIVE (reg_allocno[regno]);\n+\t  record_one_conflict (regno);\n+\t}\n+    }\n+  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n+  else if (! fixed_regs[regno])\n+    {\n+      register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (regno < last)\n+\t{\n+\t  record_one_conflict (regno);\n+\t  SET_HARD_REG_BIT (hard_regs_live, regno);\n+\t  regno++;\n+\t}\n+    }\n+}\n+\f\n+/* Mark REG as being dead (following the insn being scanned now).\n+   Store a 0 in regs_live or allocnos_live for this register.  */\n+\n+static void\n+mark_reg_death (reg)\n+     rtx reg;\n+{\n+  register int regno = REGNO (reg);\n+\n+  /* For pseudo reg, see if it has been assigned a hardware reg.  */\n+  if (reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno];\n+\n+  /* Either this is one of the max_allocno pseudo regs not allocated,\n+     or it is a hardware reg.  First handle the pseudo-regs.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (reg_allocno[regno] >= 0)\n+\tCLEAR_ALLOCNO_LIVE (reg_allocno[regno]);\n+    }\n+  /* Handle hardware regs (and pseudos allocated to hard regs).  */\n+  else if (! fixed_regs[regno])\n+    {\n+      /* Pseudo regs already assigned hardware regs are treated\n+\t almost the same as explicit hardware regs.  */\n+      register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      while (regno < last)\n+\t{\n+\t  CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n+\t  regno++;\n+\t}\n+    }\n+}\n+\n+/* Mark hard reg REGNO as currently live, assuming machine mode MODE\n+   for the value stored in it.  MODE determines how many consecutive\n+   registers are actually in use.  Do not record conflicts;\n+   it is assumed that the caller will do that.  */\n+\n+static void\n+mark_reg_live_nc (regno, mode)\n+     register int regno;\n+     enum machine_mode mode;\n+{\n+  register int last = regno + HARD_REGNO_NREGS (regno, mode);\n+  while (regno < last)\n+    {\n+      SET_HARD_REG_BIT (hard_regs_live, regno);\n+      regno++;\n+    }\n+}\n+\f\n+/* Try to set a preference for an allocno to a hard register.\n+   We are passed DEST and SRC which are the operands of a SET.  It is known\n+   that SRC is a register.  If SRC or the first operand of SRC is a register,\n+   try to set a preference.  If one of the two is a hard register and the other\n+   is a pseudo-register, mark the preference.\n+   \n+   Note that we are not as agressive as local-alloc in trying to tie a\n+   pseudo-register to a hard register.  */\n+\n+static void\n+set_preference (dest, src)\n+     rtx dest, src;\n+{\n+  int src_regno, dest_regno;\n+  /* Amount to add to the hard regno for SRC, or subtract from that for DEST,\n+     to compensate for subregs in SRC or DEST.  */\n+  int offset = 0;\n+  int i;\n+  int copy = 1;\n+\n+  if (GET_RTX_FORMAT (GET_CODE (src))[0] == 'e')\n+    src = XEXP (src, 0), copy = 0;\n+\n+  /* Get the reg number for both SRC and DEST.\n+     If neither is a reg, give up.  */\n+\n+  if (GET_CODE (src) == REG)\n+    src_regno = REGNO (src);\n+  else if (GET_CODE (src) == SUBREG && GET_CODE (SUBREG_REG (src)) == REG)\n+    {\n+      src_regno = REGNO (SUBREG_REG (src));\n+      offset += SUBREG_WORD (src);\n+    }\n+  else\n+    return;\n+\n+  if (GET_CODE (dest) == REG)\n+    dest_regno = REGNO (dest);\n+  else if (GET_CODE (dest) == SUBREG && GET_CODE (SUBREG_REG (dest)) == REG)\n+    {\n+      dest_regno = REGNO (SUBREG_REG (dest));\n+      offset -= SUBREG_WORD (dest);\n+    }\n+  else\n+    return;\n+\n+  /* Convert either or both to hard reg numbers.  */\n+\n+  if (reg_renumber[src_regno] >= 0)\n+    src_regno = reg_renumber[src_regno];\n+\n+  if (reg_renumber[dest_regno] >= 0)\n+    dest_regno = reg_renumber[dest_regno];\n+\n+  /* Now if one is a hard reg and the other is a global pseudo\n+     then give the other a preference.  */\n+\n+  if (dest_regno < FIRST_PSEUDO_REGISTER && src_regno >= FIRST_PSEUDO_REGISTER\n+      && reg_allocno[src_regno] >= 0)\n+    {\n+      dest_regno -= offset;\n+      if (dest_regno >= 0 && dest_regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  if (copy)\n+\t    SET_REGBIT (hard_reg_copy_preferences,\n+\t\t\treg_allocno[src_regno], dest_regno);\n+\n+\t  SET_REGBIT (hard_reg_preferences,\n+\t\t      reg_allocno[src_regno], dest_regno);\n+\t  for (i = dest_regno;\n+\t       i < dest_regno + HARD_REGNO_NREGS (dest_regno, GET_MODE (dest));\n+\t       i++)\n+\t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[src_regno], i);\n+\t}\n+    }\n+\n+  if (src_regno < FIRST_PSEUDO_REGISTER && dest_regno >= FIRST_PSEUDO_REGISTER\n+      && reg_allocno[dest_regno] >= 0)\n+    {\n+      src_regno += offset;\n+      if (src_regno >= 0 && src_regno < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  if (copy)\n+\t    SET_REGBIT (hard_reg_copy_preferences,\n+\t\t\treg_allocno[dest_regno], src_regno);\n+\n+\t  SET_REGBIT (hard_reg_preferences,\n+\t\t      reg_allocno[dest_regno], src_regno);\n+\t  for (i = src_regno;\n+\t       i < src_regno + HARD_REGNO_NREGS (src_regno, GET_MODE (src));\n+\t       i++)\n+\t    SET_REGBIT (hard_reg_full_preferences, reg_allocno[dest_regno], i);\n+\t}\n+    }\n+}\n+\f\n+/* Indicate that hard register number FROM was eliminated and replaced with\n+   an offset from hard register number TO.  The status of hard registers live\n+   at the start of a basic block is updated by replacing a use of FROM with\n+   a use of TO.  */\n+\n+void\n+mark_elimination (from, to)\n+     int from, to;\n+{\n+  int i;\n+\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if ((basic_block_live_at_start[i][from / HOST_BITS_PER_INT]\n+\t & (1 << (from % HOST_BITS_PER_INT))) != 0)\n+      {\n+\tbasic_block_live_at_start[i][from / HOST_BITS_PER_INT]\n+\t  &= ~ (1 << (from % HOST_BITS_PER_INT));\n+\tbasic_block_live_at_start[i][to / HOST_BITS_PER_INT]\n+\t  |= (1 << (to % HOST_BITS_PER_INT));\n+      }\n+}\n+\f\n+/* Print debugging trace information if -greg switch is given,\n+   showing the information on which the allocation decisions are based.  */\n+\n+static void\n+dump_conflicts (file)\n+     FILE *file;\n+{\n+  register int i;\n+  register int has_preferences;\n+  fprintf (file, \";; %d regs to allocate:\", max_allocno);\n+  for (i = 0; i < max_allocno; i++)\n+    {\n+      int j;\n+      fprintf (file, \" %d\", allocno_reg[allocno_order[i]]);\n+      for (j = 0; j < max_regno; j++)\n+\tif (reg_allocno[j] == allocno_order[i]\n+\t    && j != allocno_reg[allocno_order[i]])\n+\t  fprintf (file, \"+%d\", j);\n+      if (allocno_size[allocno_order[i]] != 1)\n+\tfprintf (file, \" (%d)\", allocno_size[allocno_order[i]]);\n+    }\n+  fprintf (file, \"\\n\");\n+\n+  for (i = 0; i < max_allocno; i++)\n+    {\n+      register int j;\n+      fprintf (file, \";; %d conflicts:\", allocno_reg[i]);\n+      for (j = 0; j < max_allocno; j++)\n+\tif (CONFLICTP (i, j) || CONFLICTP (j, i))\n+\t  fprintf (file, \" %d\", allocno_reg[j]);\n+      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\tif (TEST_HARD_REG_BIT (hard_reg_conflicts[i], j))\n+\t  fprintf (file, \" %d\", j);\n+      fprintf (file, \"\\n\");\n+\n+      has_preferences = 0;\n+      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\tif (TEST_HARD_REG_BIT (hard_reg_preferences[i], j))\n+\t  has_preferences = 1;\n+\n+      if (! has_preferences)\n+\tcontinue;\n+      fprintf (file, \";; %d preferences:\", allocno_reg[i]);\n+      for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\tif (TEST_HARD_REG_BIT (hard_reg_preferences[i], j))\n+\t  fprintf (file, \" %d\", j);\n+      fprintf (file, \"\\n\");\n+    }\n+  fprintf (file, \"\\n\");\n+}\n+\n+void\n+dump_global_regs (file)\n+     FILE *file;\n+{\n+  register int i, j;\n+  \n+  fprintf (file, \";; Register dispositions:\\n\");\n+  for (i = FIRST_PSEUDO_REGISTER, j = 0; i < max_regno; i++)\n+    if (reg_renumber[i] >= 0)\n+      {\n+\tfprintf (file, \"%d in %d  \", i, reg_renumber[i]);\n+        if (++j % 6 == 0)\n+\t  fprintf (file, \"\\n\");\n+      }\n+\n+  fprintf (file, \"\\n\\n;; Hard regs used: \");\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (regs_ever_live[i])\n+      fprintf (file, \" %d\", i);\n+  fprintf (file, \"\\n\\n\");\n+}"}]}