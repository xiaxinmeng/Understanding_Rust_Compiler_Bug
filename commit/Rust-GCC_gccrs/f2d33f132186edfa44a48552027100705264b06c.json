{"sha": "f2d33f132186edfa44a48552027100705264b06c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJkMzNmMTMyMTg2ZWRmYTQ0YTQ4NTUyMDI3MTAwNzA1MjY0YjA2Yw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-04T17:19:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-04T17:19:30Z"}, "message": "calls.c (ECF_MALLOC, [...]): New constants.\n\n\n\t* calls.c (ECF_MALLOC, ECF_MAY_BE_ALLOCA, ECF_RETURNS_TWICE,\n\t ECF_LONGJMP, ECF_FORK_OR_EXEC):  New constants.\n\t(ECF_IS_CONST): Rename to ECF_CONST.\n\t(special_function_p): Make static, change interface.\n\t(flags_from_decl_or_type, try_to_integrate): Break out from ...\n\t(expand_call) ... here; convert number of variables to flags.\n\t(emit_library_call_vlue_1): Likewise.\n\t(setjmp_call_p): New function.\n\t(initialize_argument_information): Accepts flags as argument;\n\treturn flags.\n\t(precompute_arguments): Likewise.\n\t* tree.h (special_function_p): Remove.\n\t(setjmp_call_p): Add prototype.\n\nFrom-SVN: r32904", "tree": {"sha": "bdb5cef3522e575e3ca3dbc9e34d7cf7e1bb6417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdb5cef3522e575e3ca3dbc9e34d7cf7e1bb6417"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2d33f132186edfa44a48552027100705264b06c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d33f132186edfa44a48552027100705264b06c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2d33f132186edfa44a48552027100705264b06c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d33f132186edfa44a48552027100705264b06c/comments", "author": null, "committer": null, "parents": [{"sha": "be340b974a62611b639ca5e2c8eacfa1144460b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be340b974a62611b639ca5e2c8eacfa1144460b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be340b974a62611b639ca5e2c8eacfa1144460b1"}], "stats": {"total": 508, "additions": 283, "deletions": 225}, "files": [{"sha": "aae5c5a86a468b8fc5ac59aafb168974b230dd69", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d33f132186edfa44a48552027100705264b06c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d33f132186edfa44a48552027100705264b06c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2d33f132186edfa44a48552027100705264b06c", "patch": "@@ -1,3 +1,19 @@\n+Tue Apr  4 19:17:20 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* calls.c (ECF_MALLOC, ECF_MAY_BE_ALLOCA, ECF_RETURNS_TWICE,\n+\t ECF_LONGJMP, ECF_FORK_OR_EXEC):  New constants.\n+\t(ECF_IS_CONST): Rename to ECF_CONST.\n+\t(special_function_p): Make static, change interface.\n+\t(flags_from_decl_or_type, try_to_integrate): Break out from ...\n+\t(expand_call) ... here; convert number of variables to flags.\n+\t(emit_library_call_vlue_1): Likewise.\n+\t(setjmp_call_p): New function.\n+\t(initialize_argument_information): Accepts flags as argument;\n+\treturn flags.\n+\t(precompute_arguments): Likewise.\n+\t* tree.h (special_function_p): Remove.\n+\t(setjmp_call_p): Add prototype.\n+\n 2000-04-04  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/sparc.h (RTX_OK_FOR_OFFSET_P): Leave minor margin"}, {"sha": "b38038635185184a0c90a841a2aefb30c6ae5b35", "filename": "gcc/calls.c", "status": "modified", "additions": 263, "deletions": 213, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d33f132186edfa44a48552027100705264b06c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d33f132186edfa44a48552027100705264b06c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=f2d33f132186edfa44a48552027100705264b06c", "patch": "@@ -150,9 +150,25 @@ int stack_arg_under_construction;\n static int calls_function\tPARAMS ((tree, int));\n static int calls_function_1\tPARAMS ((tree, int));\n \n-#define ECF_IS_CONST\t\t1\n-#define ECF_NOTHROW\t\t2\n-#define ECF_SIBCALL\t\t4\n+/* Nonzero if this is a call to a `const' function. */\n+#define ECF_CONST\t\t1\n+/* Nonzero if this is a call to a `volatile' function.  */\n+#define ECF_NORETURN\t\t2\n+/* Nonzero if this is a call to malloc or a related function. */\n+#define ECF_MALLOC\t\t4\n+/* Nonzero if it is plausible that this is a call to alloca.  */\n+#define ECF_MAY_BE_ALLOCA\t8\n+/* Nonzero if this is a call to a function that won't throw an exception.  */\n+#define ECF_NOTHROW\t\t16\n+/* Nonzero if this is a call to setjmp or a related function.  */\n+#define ECF_RETURNS_TWICE\t32\n+/* Nonzero if this is a call to `longjmp'.  */\n+#define ECF_LONGJMP\t\t64\n+/* Nonzero if this is a syscall that makes a new process in the image of\n+   the current one.  */\n+#define ECF_FORK_OR_EXEC\t128\n+#define ECF_SIBCALL\t\t256\n+\n static void emit_call_1\t\tPARAMS ((rtx, tree, tree, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT, rtx,\n \t\t\t\t\t rtx, int, rtx, int));\n@@ -178,7 +194,7 @@ static void initialize_argument_information\tPARAMS ((int,\n \t\t\t\t\t\t\t int, tree, tree,\n \t\t\t\t\t\t\t CUMULATIVE_ARGS *,\n \t\t\t\t\t\t\t int, rtx *, int *,\n-\t\t\t\t\t\t\t int *, int *, int));\n+\t\t\t\t\t\t\t int *, int *));\n static void compute_argument_addresses\t\tPARAMS ((struct arg_data *,\n \t\t\t\t\t\t\t rtx, int));\n static rtx rtx_for_function_call\t\tPARAMS ((tree, tree));\n@@ -188,6 +204,10 @@ static int libfunc_nothrow\t\t\tPARAMS ((rtx));\n static rtx emit_library_call_value_1 \t\tPARAMS ((int, rtx, rtx, int,\n \t\t\t\t\t\t\t enum machine_mode,\n \t\t\t\t\t\t\t int, va_list));\n+static int special_function_p\t\t\tPARAMS ((tree, int));\n+static int flags_from_decl_or_type \t\tPARAMS ((tree));\n+static rtx try_to_integrate\t\t\tPARAMS ((tree, tree, rtx,\n+\t\t\t\t\t\t\t int, tree, rtx));\n \n #ifdef REG_PARM_STACK_SPACE\n static rtx save_fixed_argument_area\tPARAMS ((int, rtx, int *, int *));\n@@ -401,9 +421,7 @@ prepare_call_address (funexp, fndecl, call_fusage, reg_parm_seen)\n    We restore `inhibit_defer_pop' to that value.\n \n    CALL_FUSAGE is either empty or an EXPR_LIST of USE expressions that\n-   denote registers used by the called function.\n-\n-   IS_CONST is true if this is a `const' call.  */\n+   denote registers used by the called function.  */\n \n static void\n emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n@@ -553,7 +571,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n     CALL_INSN_FUNCTION_USAGE (call_insn) = call_fusage;\n \n   /* If this is a const call, then set the insn's unchanging bit.  */\n-  if (ecf_flags & ECF_IS_CONST)\n+  if (ecf_flags & ECF_CONST)\n     CONST_CALL_P (call_insn) = 1;\n \n   /* If this call can't throw, attach a REG_EH_REGION reg note to that\n@@ -592,7 +610,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n       if (rounded_stack_size != 0)\n \t{\n \t  if (flag_defer_pop && inhibit_defer_pop == 0\n-\t      && !(ecf_flags & ECF_IS_CONST))\n+\t      && !(ecf_flags & ECF_CONST))\n \t    pending_stack_adjust += rounded_stack_size;\n \t  else\n \t    adjust_stack (rounded_stack_size_rtx);\n@@ -619,33 +637,20 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n    For example, if the function might return more than one time (setjmp), then\n    set RETURNS_TWICE to a nonzero value.\n \n-   Similarly set IS_LONGJMP for if the function is in the longjmp family.\n+   Similarly set LONGJMP for if the function is in the longjmp family.\n \n-   Set IS_MALLOC for any of the standard memory allocation functions which\n+   Set MALLOC for any of the standard memory allocation functions which\n    allocate from the heap.\n \n    Set MAY_BE_ALLOCA for any memory allocation function that might allocate\n    space from the stack such as alloca.  */\n \n-void\n-special_function_p (fndecl, returns_twice, is_longjmp, fork_or_exec,\n-\t\t    is_malloc, may_be_alloca)\n+static int\n+special_function_p (fndecl, flags)\n      tree fndecl;\n-     int *returns_twice;\n-     int *is_longjmp;\n-     int *fork_or_exec;\n-     int *is_malloc;\n-     int *may_be_alloca;\n+     int flags;\n {\n-  *returns_twice = 0;\n-  *is_longjmp = 0;\n-  *fork_or_exec = 0;\n-  *may_be_alloca = 0;\n-\n-  /* The function decl may have the `malloc' attribute.  */\n-  *is_malloc = fndecl && DECL_IS_MALLOC (fndecl);\n-\n-  if (! *is_malloc \n+  if (! (flags & ECF_MALLOC)\n       && fndecl && DECL_NAME (fndecl)\n       && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) <= 17\n       /* Exclude functions not at the file scope, or not `extern',\n@@ -659,13 +664,13 @@ special_function_p (fndecl, returns_twice, is_longjmp, fork_or_exec,\n       /* We assume that alloca will always be called by name.  It\n \t makes no sense to pass it as a pointer-to-function to\n \t anything that does not understand its behavior.  */\n-      *may_be_alloca\n-\t= (((IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6\n-\t     && name[0] == 'a'\n-\t     && ! strcmp (name, \"alloca\"))\n-\t    || (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 16\n-\t\t&& name[0] == '_'\n-\t\t&& ! strcmp (name, \"__builtin_alloca\"))));\n+      if (((IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 6\n+\t    && name[0] == 'a'\n+\t    && ! strcmp (name, \"alloca\"))\n+\t   || (IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 16\n+\t       && name[0] == '_'\n+\t       && ! strcmp (name, \"__builtin_alloca\"))))\n+\tflags |= ECF_MAY_BE_ALLOCA;\n \n       /* Disregard prefix _, __ or __x.  */\n       if (name[0] == '_')\n@@ -680,27 +685,28 @@ special_function_p (fndecl, returns_twice, is_longjmp, fork_or_exec,\n \n       if (tname[0] == 's')\n \t{\n-\t  *returns_twice\n-\t     = ((tname[1] == 'e'\n-\t\t && (! strcmp (tname, \"setjmp\")\n-\t\t     || ! strcmp (tname, \"setjmp_syscall\")))\n-\t        || (tname[1] == 'i'\n-\t\t    && ! strcmp (tname, \"sigsetjmp\"))\n-\t        || (tname[1] == 'a'\n-\t\t    && ! strcmp (tname, \"savectx\")));\n+\t  if ((tname[1] == 'e'\n+\t       && (! strcmp (tname, \"setjmp\")\n+\t\t   || ! strcmp (tname, \"setjmp_syscall\")))\n+\t      || (tname[1] == 'i'\n+\t\t  && ! strcmp (tname, \"sigsetjmp\"))\n+\t      || (tname[1] == 'a'\n+\t\t  && ! strcmp (tname, \"savectx\")))\n+\t    flags |= ECF_RETURNS_TWICE;\n+\n \t  if (tname[1] == 'i'\n \t      && ! strcmp (tname, \"siglongjmp\"))\n-\t    *is_longjmp = 1;\n+\t    flags |= ECF_LONGJMP;\n \t}\n       else if ((tname[0] == 'q' && tname[1] == 's'\n \t\t&& ! strcmp (tname, \"qsetjmp\"))\n \t       || (tname[0] == 'v' && tname[1] == 'f'\n \t\t   && ! strcmp (tname, \"vfork\")))\n-\t*returns_twice = 1;\n+\tflags |= ECF_RETURNS_TWICE;\n \n       else if (tname[0] == 'l' && tname[1] == 'o'\n \t       && ! strcmp (tname, \"longjmp\"))\n-\t*is_longjmp = 1;\n+\tflags |= ECF_LONGJMP;\n \n       else if ((tname[0] == 'f' && tname[1] == 'o'\n \t\t&& ! strcmp (tname, \"fork\"))\n@@ -714,7 +720,7 @@ special_function_p (fndecl, returns_twice, is_longjmp, fork_or_exec,\n \t\t   && (tname[5] == '\\0'\n \t\t       || ((tname[5] == 'p' || tname[5] == 'e')\n \t\t\t   && tname[6] == '\\0'))))\n-\t*fork_or_exec = 1;\n+\tflags |= ECF_FORK_OR_EXEC;\n \n       /* Do not add any more malloc-like functions to this list,\n          instead mark them as malloc functions using the malloc attribute.\n@@ -727,10 +733,46 @@ special_function_p (fndecl, returns_twice, is_longjmp, fork_or_exec,\n \t       && (! strcmp (tname, \"malloc\")\n \t\t   || ! strcmp (tname, \"calloc\")\n \t\t   || ! strcmp (tname, \"strdup\")))\n-\t*is_malloc = 1;\n+\tflags |= ECF_MALLOC;\n+    }\n+  return flags;\n+}\n+\n+/* Return nonzero when tree represent call to longjmp.  */\n+int\n+setjmp_call_p (fndecl)\n+     tree fndecl;\n+{\n+  return special_function_p (fndecl, 0) & ECF_RETURNS_TWICE;\n+}\n+\n+/* Detect flags (function attributes) from the function type node.  */\n+static int\n+flags_from_decl_or_type (exp)\n+     tree exp;\n+{\n+  int flags = 0;\n+  /* ??? We can't set IS_MALLOC for function types?  */\n+  if (DECL_P (exp))\n+    {\n+      /* The function exp may have the `malloc' attribute.  */\n+      if (DECL_P (exp) && DECL_IS_MALLOC (exp))\n+\tflags |= ECF_MALLOC;\n+\n+      if (TREE_NOTHROW (exp))\n+\tflags |= ECF_NOTHROW;\n     }\n+\n+  if (TREE_READONLY (exp) && !TREE_THIS_VOLATILE (exp))\n+    flags |= ECF_CONST;\n+\n+  if (TREE_THIS_VOLATILE (exp))\n+    flags |= ECF_NORETURN;\n+\n+  return flags;\n }\n \n+\n /* Precompute all register parameters as described by ARGS, storing values\n    into fields within the ARGS array.\n \n@@ -990,14 +1032,14 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n    OLD_STACK_LEVEL is a pointer to an rtx which olds the old stack level\n    and may be modified by this routine.\n \n-   OLD_PENDING_ADJ, MUST_PREALLOCATE and IS_CONST are pointers to integer\n+   OLD_PENDING_ADJ, MUST_PREALLOCATE and FLAGS are pointers to integer\n    flags which may may be modified by this routine.  */\n \n static void\n initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t\t\t\t actparms, fndecl, args_so_far,\n \t\t\t\t reg_parm_stack_space, old_stack_level,\n-\t\t\t\t old_pending_adj, must_preallocate, is_const,\n+\t\t\t\t old_pending_adj, must_preallocate,\n \t\t\t\t ecf_flags)\n      int num_actuals ATTRIBUTE_UNUSED;\n      struct arg_data *args;\n@@ -1010,8 +1052,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n      rtx *old_stack_level;\n      int *old_pending_adj;\n      int *must_preallocate;\n-     int *is_const;\n-     int ecf_flags ATTRIBUTE_UNUSED;\n+     int *ecf_flags;\n {\n   /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n   int inc;\n@@ -1154,7 +1195,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t      MEM_SET_IN_STRUCT_P (copy, AGGREGATE_TYPE_P (type));\n \n \t      store_expr (args[i].tree_value, copy, 0);\n-\t      *is_const = 0;\n+\t      *ecf_flags &= ~ECF_CONST;\n \n \t      args[i].tree_value = build1 (ADDR_EXPR,\n \t\t\t\t\t   build_pointer_type (type),\n@@ -1213,7 +1254,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n       /* If this is an addressable type, we cannot pre-evaluate it.  Thus,\n \t we cannot consider this function call constant.  */\n       if (TREE_ADDRESSABLE (type))\n-\t*is_const = 0;\n+\t*ecf_flags &= ~ECF_CONST;\n \n       /* Compute the stack-size of this argument.  */\n       if (args[i].reg == 0 || args[i].partial != 0\n@@ -1358,7 +1399,7 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n \n /* Precompute parameters as needed for a function call.\n \n-   IS_CONST indicates the target function is a pure function.\n+   FLAGS is mask of ECF_* constants.\n \n    MUST_PREALLOCATE indicates that we must preallocate stack space for\n    any stack arguments.\n@@ -1371,8 +1412,8 @@ compute_argument_block_size (reg_parm_stack_space, args_size,\n    ARGS_SIZE contains information about the size of the arg list.  */\n \n static void\n-precompute_arguments (is_const, must_preallocate, num_actuals, args, args_size)\n-     int is_const;\n+precompute_arguments (flags, must_preallocate, num_actuals, args, args_size)\n+     int flags;\n      int must_preallocate;\n      int num_actuals;\n      struct arg_data *args;\n@@ -1394,7 +1435,7 @@ precompute_arguments (is_const, must_preallocate, num_actuals, args, args_size)\n      which have already been stored into the stack.  */\n \n   for (i = 0; i < num_actuals; i++)\n-    if (is_const\n+    if ((flags & ECF_CONST)\n \t|| ((args_size->var != 0 || args_size->constant != 0)\n \t    && calls_function (args[i].tree_value, 1))\n \t|| (must_preallocate\n@@ -1691,6 +1732,122 @@ load_register_parameters (args, num_actuals, call_fusage)\n     }\n }\n \n+/* Try to integreate function.  See expand_inline_function for documentation\n+   about the parameters.  */\n+\n+static rtx\n+try_to_integrate (fndecl, actparms, target, ignore, type, structure_value_addr)\n+     tree fndecl;\n+     tree actparms;\n+     rtx target;\n+     int ignore;\n+     tree type;\n+     rtx structure_value_addr;\n+{\n+  rtx temp;\n+  rtx before_call;\n+  int i;\n+  rtx old_stack_level = 0;\n+  int reg_parm_stack_space;\n+\n+#ifdef REG_PARM_STACK_SPACE\n+#ifdef MAYBE_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n+#else\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n+#endif\n+#endif\n+\n+  before_call = get_last_insn ();\n+\n+  temp = expand_inline_function (fndecl, actparms, target,\n+\t\t\t\t ignore, type,\n+\t\t\t\t structure_value_addr);\n+\n+  /* If inlining succeeded, return.  */\n+  if (temp != (rtx) (HOST_WIDE_INT) - 1)\n+    {\n+      if (ACCUMULATE_OUTGOING_ARGS)\n+\t{\n+\t  /* If the outgoing argument list must be preserved, push\n+\t     the stack before executing the inlined function if it\n+\t     makes any calls.  */\n+\n+\t  for (i = reg_parm_stack_space - 1; i >= 0; i--)\n+\t    if (i < highest_outgoing_arg_in_use && stack_usage_map[i] != 0)\n+\t      break;\n+\n+\t  if (stack_arg_under_construction || i >= 0)\n+\t    {\n+\t      rtx first_insn\n+\t\t= before_call ? NEXT_INSN (before_call) : get_insns ();\n+\t      rtx insn = NULL_RTX, seq;\n+\n+\t      /* Look for a call in the inline function code.\n+\t         If DECL_SAVED_INSNS (fndecl)->outgoing_args_size is\n+\t         nonzero then there is a call and it is not necessary\n+\t         to scan the insns.  */\n+\n+\t      if (DECL_SAVED_INSNS (fndecl)->outgoing_args_size == 0)\n+\t\tfor (insn = first_insn; insn; insn = NEXT_INSN (insn))\n+\t\t  if (GET_CODE (insn) == CALL_INSN)\n+\t\t    break;\n+\n+\t      if (insn)\n+\t\t{\n+\t\t  /* Reserve enough stack space so that the largest\n+\t\t     argument list of any function call in the inline\n+\t\t     function does not overlap the argument list being\n+\t\t     evaluated.  This is usually an overestimate because\n+\t\t     allocate_dynamic_stack_space reserves space for an\n+\t\t     outgoing argument list in addition to the requested\n+\t\t     space, but there is no way to ask for stack space such\n+\t\t     that an argument list of a certain length can be\n+\t\t     safely constructed. \n+\n+\t\t     Add the stack space reserved for register arguments, if\n+\t\t     any, in the inline function.  What is really needed is the\n+\t\t     largest value of reg_parm_stack_space in the inline\n+\t\t     function, but that is not available.  Using the current\n+\t\t     value of reg_parm_stack_space is wrong, but gives\n+\t\t     correct results on all supported machines.  */\n+\n+\t\t  int adjust = (DECL_SAVED_INSNS (fndecl)->outgoing_args_size\n+\t\t\t\t+ reg_parm_stack_space);\n+\n+\t\t  start_sequence ();\n+\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n+\t\t  allocate_dynamic_stack_space (GEN_INT (adjust),\n+\t\t\t\t\t\tNULL_RTX, BITS_PER_UNIT);\n+\t\t  seq = get_insns ();\n+\t\t  end_sequence ();\n+\t\t  emit_insns_before (seq, first_insn);\n+\t\t  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* If the result is equivalent to TARGET, return TARGET to simplify\n+         checks in store_expr.  They can be equivalent but not equal in the\n+         case of a function that returns BLKmode.  */\n+      if (temp != target && rtx_equal_p (temp, target))\n+\treturn target;\n+      return temp;\n+    }\n+\n+  /* If inlining failed, mark FNDECL as needing to be compiled\n+     separately after all.  If function was declared inline,\n+     give a warning.  */\n+  if (DECL_INLINE (fndecl) && warn_inline && !flag_no_inline\n+      && optimize > 0 && !TREE_ADDRESSABLE (fndecl))\n+    {\n+      warning_with_decl (fndecl, \"inlining failed in call to `%s'\");\n+      warning (\"called from here\");\n+    }\n+  mark_addressable (fndecl);\n+  return (rtx) (HOST_WIDE_INT) - 1;\n+}\n+\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -1722,7 +1879,6 @@ expand_call (exp, target, ignore)\n      or 0 if the function is computed (not known by name).  */\n   tree fndecl = 0;\n   char *name = 0;\n-  rtx before_call;\n   rtx insn;\n   int try_tail_call;\n   int pass;\n@@ -1781,26 +1937,10 @@ expand_call (exp, target, ignore)\n      (on machines that lack push insns), or 0 if space not preallocated.  */\n   rtx argblock = 0;\n \n-  /* Nonzero if it is plausible that this is a call to alloca.  */\n-  int may_be_alloca;\n-  /* Nonzero if this is a call to malloc or a related function. */\n-  int is_malloc;\n-  /* Nonzero if this is a call to setjmp or a related function.  */\n-  int returns_twice;\n-  /* Nonzero if this is a call to `longjmp'.  */\n-  int is_longjmp;\n-  /* Nonzero if this is a syscall that makes a new process in the image of\n-     the current one.  */\n-  int fork_or_exec;\n+  /* Mask of ECF_ flags.  */\n+  int flags = 0;\n   /* Nonzero if this is a call to an inline function.  */\n   int is_integrable = 0;\n-  /* Nonzero if this is a call to a `const' function.\n-     Note that only explicitly named functions are handled as `const' here.  */\n-  int is_const = 0;\n-  /* Nonzero if this is a call to a `volatile' function.  */\n-  int is_volatile = 0;\n-  /* Nonzero if this is a call to a function that won't throw an exception.  */\n-  int nothrow = TREE_NOTHROW (exp);\n #ifdef REG_PARM_STACK_SPACE\n   /* Define the boundary of the register parm stack space that needs to be\n      save, if any.  */\n@@ -1828,6 +1968,10 @@ expand_call (exp, target, ignore)\n   if (current_function_check_memory_usage)\n     target = 0;\n \n+  /* See if this is \"nothrow\" function call.  */\n+  if (TREE_NOTHROW (exp))\n+    flags |= ECF_NOTHROW;\n+\n   /* See if we can find a DECL-node for the actual function.\n      As a result, decide whether this is a call to an integrable function.  */\n \n@@ -1861,24 +2005,15 @@ expand_call (exp, target, ignore)\n \t      mark_addressable (fndecl);\n \t    }\n \n-\t  if (TREE_READONLY (fndecl) && ! TREE_THIS_VOLATILE (fndecl)\n-\t      && TYPE_MODE (TREE_TYPE (exp)) != VOIDmode)\n-\t    is_const = 1;\n-\n-\t  if (TREE_THIS_VOLATILE (fndecl))\n-\t    is_volatile = 1;\n-\n-\t  if (TREE_NOTHROW (fndecl))\n-\t    nothrow = 1;\n+\t  flags |= flags_from_decl_or_type (fndecl);\n \t}\n     }\n \n   /* If we don't have specific function to call, see if we have a \n-     constant or `noreturn' function from the type.  */\n+     attributes set in the type.  */\n   if (fndecl == 0)\n     {\n-      is_const = TREE_READONLY (TREE_TYPE (TREE_TYPE (p)));\n-      is_volatile = TREE_THIS_VOLATILE (TREE_TYPE (TREE_TYPE (p)));\n+      flags |= flags_from_decl_or_type (TREE_TYPE (TREE_TYPE (p)));\n     }\n \n #ifdef REG_PARM_STACK_SPACE\n@@ -1905,7 +2040,7 @@ expand_call (exp, target, ignore)\n   if (aggregate_value_p (exp))\n     {\n       /* This call returns a big structure.  */\n-      is_const = 0;\n+      flags &= ~ECF_CONST;\n \n #ifdef PCC_STATIC_STRUCT_RETURN\n       {\n@@ -1956,95 +2091,11 @@ expand_call (exp, target, ignore)\n \n   if (is_integrable)\n     {\n-      rtx temp;\n-\n-      before_call = get_last_insn ();\n-\n-      temp = expand_inline_function (fndecl, actparms, target,\n-\t\t\t\t     ignore, TREE_TYPE (exp),\n-\t\t\t\t     structure_value_addr);\n-\n-      /* If inlining succeeded, return.  */\n-      if (temp != (rtx) (HOST_WIDE_INT) -1)\n-\t{\n-\t  if (ACCUMULATE_OUTGOING_ARGS)\n-\t    {\n-\t      /* If the outgoing argument list must be preserved, push\n-\t\t the stack before executing the inlined function if it\n-\t\t makes any calls.  */\n-\n-\t      for (i = reg_parm_stack_space - 1; i >= 0; i--)\n-\t\tif (i < highest_outgoing_arg_in_use && stack_usage_map[i] != 0)\n-\t\t  break;\n-\n-\t      if (stack_arg_under_construction || i >= 0)\n-\t\t{\n-\t\t  rtx first_insn\n-\t\t    = before_call ? NEXT_INSN (before_call) : get_insns ();\n-\t\t  rtx insn = NULL_RTX, seq;\n-\n-\t\t  /* Look for a call in the inline function code.\n-\t\t     If DECL_SAVED_INSNS (fndecl)->outgoing_args_size is\n-\t\t     nonzero then there is a call and it is not necessary\n-\t\t     to scan the insns.  */\n-\n-\t\t  if (DECL_SAVED_INSNS (fndecl)->outgoing_args_size == 0)\n-\t\t    for (insn = first_insn; insn; insn = NEXT_INSN (insn))\n-\t\t      if (GET_CODE (insn) == CALL_INSN)\n-\t\t\tbreak;\n-\n-\t\t  if (insn)\n-\t\t    {\n-\t\t      /* Reserve enough stack space so that the largest\n-\t\t\t argument list of any function call in the inline\n-\t\t\t function does not overlap the argument list being\n-\t\t\t evaluated.  This is usually an overestimate because\n-\t\t\t allocate_dynamic_stack_space reserves space for an\n-\t\t\t outgoing argument list in addition to the requested\n-\t\t\t space, but there is no way to ask for stack space such\n-\t\t\t that an argument list of a certain length can be\n-\t\t\t safely constructed. \n-\n-\t\t\t Add the stack space reserved for register arguments, if\n-\t\t\t any, in the inline function.  What is really needed is the\n-\t\t\t largest value of reg_parm_stack_space in the inline\n-\t\t\t function, but that is not available.  Using the current\n-\t\t\t value of reg_parm_stack_space is wrong, but gives\n-\t\t\t correct results on all supported machines.  */\n-\n-\t\t      int adjust = (DECL_SAVED_INSNS (fndecl)->outgoing_args_size\n-\t\t\t\t    + reg_parm_stack_space);\n-\n-\t\t      start_sequence ();\n-\t\t      emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n-\t\t      allocate_dynamic_stack_space (GEN_INT (adjust),\n-\t\t\t\t\t\t    NULL_RTX, BITS_PER_UNIT);\n-\t\t      seq = get_insns ();\n-\t\t      end_sequence ();\n-\t\t      emit_insns_before (seq, first_insn);\n-\t\t      emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  /* If the result is equivalent to TARGET, return TARGET to simplify\n-\t     checks in store_expr.  They can be equivalent but not equal in the\n-\t     case of a function that returns BLKmode.  */\n-\t  if (temp != target && rtx_equal_p (temp, target))\n-\t    return target;\n-\t  return temp;\n-\t}\n-\n-      /* If inlining failed, mark FNDECL as needing to be compiled\n-\t separately after all.  If function was declared inline,\n-\t give a warning.  */\n-      if (DECL_INLINE (fndecl) && warn_inline && !flag_no_inline\n-\t  && optimize > 0 && ! TREE_ADDRESSABLE (fndecl))\n-\t{\n-\t  warning_with_decl (fndecl, \"inlining failed in call to `%s'\");\n-\t  warning (\"called from here\");\n-\t}\n-      mark_addressable (fndecl);\n+      rtx temp = try_to_integrate (fndecl, actparms, target,\n+\t\t\t\t   ignore, TREE_TYPE (exp),\n+\t\t\t\t   structure_value_addr);\n+      if (temp != (rtx) (HOST_WIDE_INT) - 1)\n+\treturn temp;\n     }\n \n   currently_expanding_call++;\n@@ -2162,10 +2213,9 @@ expand_call (exp, target, ignore)\n \n   /* See if this is a call to a function that can return more than once\n      or a call to longjmp or malloc.  */\n-  special_function_p (fndecl, &returns_twice, &is_longjmp, &fork_or_exec,\n-\t\t      &is_malloc, &may_be_alloca);\n+  flags |= special_function_p (fndecl, flags);\n \n-  if (may_be_alloca)\n+  if (flags & ECF_MAY_BE_ALLOCA)\n     current_function_calls_alloca = 1;\n \n   /* Operand 0 is a pointer-to-function; get the type of the function.  */\n@@ -2225,9 +2275,13 @@ expand_call (exp, target, ignore)\n \t  save_pending_stack_adjust = pending_stack_adjust;\n \t  save_stack_pointer_delta = stack_pointer_delta;\n \t}\n+      if (pass)\n+\tflags &= ~ECF_SIBCALL;\n+      else\n+\tflags |= ECF_SIBCALL;\n \n       /* Other state variables that we must reinitialize each time\n-\t through the loop (that are not initialized by the loop itself.  */\n+\t through the loop (that are not initialized by the loop itself).  */\n       argblock = 0;\n       call_fusage = 0;\n \n@@ -2239,19 +2293,19 @@ expand_call (exp, target, ignore)\n \n       /* When calling a const function, we must pop the stack args right away,\n \t so that the pop is deleted or moved with the call.  */\n-      if (is_const)\n+      if (flags & ECF_CONST)\n \tNO_DEFER_POP;\n \n       /* Don't let pending stack adjusts add up to too much.\n \t Also, do all pending adjustments now if there is any chance\n \t this might be a call to alloca or if we are expanding a sibling\n \t call sequence.  */\n       if (pending_stack_adjust >= 32\n-\t  || (pending_stack_adjust > 0 && may_be_alloca)\n+\t  || (pending_stack_adjust > 0 && (flags & ECF_MAY_BE_ALLOCA))\n \t  || pass == 0)\n \tdo_pending_stack_adjust ();\n \n-      if (profile_arc_flag && fork_or_exec)\n+      if (profile_arc_flag && (flags & ECF_FORK_OR_EXEC))\n \t{\n \t  /* A fork duplicates the profile information, and an exec discards\n \t     it.  We can't rely on fork/exec to be paired.  So write out the\n@@ -2344,8 +2398,7 @@ expand_call (exp, target, ignore)\n \t\t\t\t       n_named_args, actparms, fndecl,\n \t\t\t\t       &args_so_far, reg_parm_stack_space,\n \t\t\t\t       &old_stack_level, &old_pending_adj,\n-\t\t\t\t       &must_preallocate, &is_const,\n-\t\t\t\t       (pass == 0) ? ECF_SIBCALL : 0);\n+\t\t\t\t       &must_preallocate, &flags);\n \n #ifdef FINAL_REG_PARM_STACK_SPACE\n       reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n@@ -2361,7 +2414,7 @@ expand_call (exp, target, ignore)\n \n \t     Also do not make a sibling call.  */\n \n-\t  is_const = 0;\n+\t  flags &= ~ECF_CONST;\n \t  must_preallocate = 1;\n \t  sibcall_failure = 1;\n \t}\n@@ -2410,12 +2463,12 @@ expand_call (exp, target, ignore)\n \tstructure_value_addr = copy_to_reg (structure_value_addr);\n \n       /* Precompute any arguments as needed.  */\n-      precompute_arguments (is_const, must_preallocate, num_actuals,\n+      precompute_arguments (flags, must_preallocate, num_actuals,\n \t\t\t    args, &args_size);\n \n       /* Now we are about to start emitting insns that can be deleted\n \t if a libcall is deleted.  */\n-      if (is_const || is_malloc)\n+      if (flags & (ECF_CONST | ECF_MALLOC))\n \tstart_sequence ();\n \n       old_stack_allocated =  stack_pointer_delta - pending_stack_adjust;\n@@ -2598,7 +2651,7 @@ expand_call (exp, target, ignore)\n \t{\n \t  /* When the stack adjustment is pending, we get better code\n \t     by combining the adjustments.  */\n-\t  if (pending_stack_adjust && ! is_const\n+\t  if (pending_stack_adjust && ! (flags & ECF_CONST)\n \t      && ! inhibit_defer_pop)\n \t    {\n \t      int adjust;\n@@ -2661,7 +2714,7 @@ expand_call (exp, target, ignore)\n \n       for (i = 0; i < num_actuals; i++)\n \tif (args[i].reg == 0 || args[i].pass_on_stack)\n-\t  store_one_arg (&args[i], argblock, may_be_alloca,\n+\t  store_one_arg (&args[i], argblock, flags & ECF_MAY_BE_ALLOCA,\n \t\t\t args_size.var != 0, reg_parm_stack_space);\n \n       /* If we have a parm that is passed in registers but not in memory\n@@ -2676,7 +2729,7 @@ expand_call (exp, target, ignore)\n       if (reg_parm_seen)\n \tfor (i = 0; i < num_actuals; i++)\n \t  if (args[i].partial != 0 && ! args[i].pass_on_stack)\n-\t    store_one_arg (&args[i], argblock, may_be_alloca,\n+\t    store_one_arg (&args[i], argblock, flags & ECF_MAY_BE_ALLOCA,\n \t\t\t   args_size.var != 0, reg_parm_stack_space);\n \n #ifdef PREFERRED_STACK_BOUNDARY\n@@ -2749,9 +2802,7 @@ expand_call (exp, target, ignore)\n       emit_call_1 (funexp, fndecl, funtype, unadjusted_args_size,\n \t\t   args_size.constant, struct_value_size,\n \t\t   next_arg_reg, valreg, old_inhibit_defer_pop, call_fusage,\n-\t\t   ((is_const ? ECF_IS_CONST : 0)\n-\t\t    | (nothrow ? ECF_NOTHROW : 0)\n-\t\t    | (pass == 0 ? ECF_SIBCALL : 0)));\n+\t\t   flags);\n \n       /* Verify that we've deallocated all the stack we used.  */\n       if (pass\n@@ -2762,7 +2813,7 @@ expand_call (exp, target, ignore)\n \t Test valreg so we don't crash; may safely ignore `const'\n \t if return type is void.  Disable for PARALLEL return values, because\n \t we have no way to move such values into a pseudo register.  */\n-      if (is_const && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n+      if ((flags & ECF_CONST) && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n \t{\n \t  rtx note = 0;\n \t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n@@ -2789,15 +2840,15 @@ expand_call (exp, target, ignore)\n   \n \t  valreg = temp;\n \t}\n-      else if (is_const)\n+      else if (flags & ECF_CONST)\n \t{\n \t  /* Otherwise, just write out the sequence without a note.  */\n \t  rtx insns = get_insns ();\n \n \t  end_sequence ();\n \t  emit_insns (insns);\n \t}\n-      else if (is_malloc)\n+      else if (flags & ECF_MALLOC)\n \t{\n \t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n \t  rtx last, insns;\n@@ -2825,7 +2876,7 @@ expand_call (exp, target, ignore)\n \t if nonvolatile values are live.  For functions that cannot return,\n \t inform flow that control does not fall through.  */\n \n-      if (returns_twice || is_volatile || is_longjmp || pass == 0)\n+      if ((flags & (ECF_RETURNS_TWICE | ECF_NORETURN | ECF_LONGJMP)) || pass == 0)\n \t{\n \t  /* The barrier or NOTE_INSN_SETJMP note must be emitted\n \t     immediately after the CALL_INSN.  Some ports emit more\n@@ -2840,7 +2891,7 @@ expand_call (exp, target, ignore)\n \t\tabort ();\n \t    }\n \n-\t  if (returns_twice)\n+\t  if (flags & ECF_RETURNS_TWICE)\n \t    {\n \t      emit_note_after (NOTE_INSN_SETJMP, last);\n \t      current_function_calls_setjmp = 1;\n@@ -2850,7 +2901,7 @@ expand_call (exp, target, ignore)\n \t    emit_barrier_after (last);\n \t}\n \n-      if (is_longjmp)\n+      if (flags & ECF_LONGJMP)\n \tcurrent_function_calls_longjmp = 1, sibcall_failure = 1;\n \n       /* If this function is returning into a memory location marked as\n@@ -3008,7 +3059,7 @@ expand_call (exp, target, ignore)\n \t Check for the handler slots since we might not have a save area\n \t for non-local gotos.  */\n \n-      if (may_be_alloca && nonlocal_goto_handler_slots != 0)\n+      if ((flags & ECF_MAY_BE_ALLOCA) && nonlocal_goto_handler_slots != 0)\n \temit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, NULL_RTX);\n \n       pop_temp_slots ();\n@@ -3144,9 +3195,8 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n   rtx mem_value = 0;\n   int pcc_struct_value = 0;\n   int struct_value_size = 0;\n-  int is_const;\n+  int flags = 0;\n   int reg_parm_stack_space = 0;\n-  int nothrow;\n   int needed;\n \n #ifdef REG_PARM_STACK_SPACE\n@@ -3168,10 +3218,12 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n #endif\n #endif\n \n-  is_const = no_queue;\n+  if (no_queue)\n+    flags |= ECF_CONST;\n   fun = orgfun;\n \n-  nothrow = libfunc_nothrow (fun);\n+  if (libfunc_nothrow (fun))\n+    flags |= ECF_NOTHROW;\n \n #ifdef PREFERRED_STACK_BOUNDARY\n   /* Ensure current function's preferred stack boundary is at least\n@@ -3201,7 +3253,7 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n #endif\n \n       /* This call returns a big structure.  */\n-      is_const = 0;\n+      flags &= ~ECF_CONST;\n     }\n \n   /* ??? Unfinished: must pass the memory address as an argument.  */\n@@ -3645,9 +3697,7 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \t       struct_value_size,\n \t       FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1),\n \t       mem_value == 0 && outmode != VOIDmode ? hard_libcall_value (outmode) : NULL_RTX,\n-\t       old_inhibit_defer_pop + 1, call_fusage,\n-\t       ((is_const ? ECF_IS_CONST : 0)\n-\t\t| (nothrow ? ECF_NOTHROW : 0)));\n+\t       old_inhibit_defer_pop + 1, call_fusage, flags);\n \n   /* Now restore inhibit_defer_pop to its actual original value.  */\n   OK_DEFER_POP;\n@@ -3729,7 +3779,7 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \n    NO_QUEUE will be true if and only if the library call is a `const' call\n    which will be enclosed in REG_LIBCALL/REG_RETVAL notes; it is equivalent\n-   to the variable is_const in expand_call.\n+   to the flag ECF_CONST in expand_call.\n \n    NO_QUEUE must be true for const calls, because if it isn't, then\n    any pending increment will be emitted between REG_LIBCALL/REG_RETVAL notes,"}, {"sha": "0bd4b2115cdd5830dd6029005d8db5d3a8d8b757", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d33f132186edfa44a48552027100705264b06c/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d33f132186edfa44a48552027100705264b06c/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=f2d33f132186edfa44a48552027100705264b06c", "patch": "@@ -748,20 +748,11 @@ calls_setjmp_r (tp, walk_subtrees, data)\n      int *walk_subtrees ATTRIBUTE_UNUSED;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  int setjmp_p;\n-  int longjmp_p;\n-  int fork_or_exec_p;\n-  int malloc_p;\n-  int alloca_p;\n-\n   /* We're only interested in FUNCTION_DECLS.  */\n   if (TREE_CODE (*tp) != FUNCTION_DECL)\n     return NULL_TREE;\n \n-  special_function_p (*tp, &setjmp_p, &longjmp_p, &fork_or_exec_p, &malloc_p,\n-\t\t      &alloca_p);\n-\n-  return setjmp_p ? *tp : NULL_TREE;\n+  return setjmp_call_p (*tp);\n }\n \n /* Returns non-zero if FN calls `setjmp' or some other function that"}, {"sha": "0264cccd895af5ec01723ac6c76bb3fc399d34a4", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d33f132186edfa44a48552027100705264b06c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d33f132186edfa44a48552027100705264b06c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=f2d33f132186edfa44a48552027100705264b06c", "patch": "@@ -2551,8 +2551,9 @@ extern struct rtx_def *emit_line_note\t\tPARAMS ((const char *, int));\n extern struct rtx_def *emit_line_note_force\tPARAMS ((const char *, int));\n \n /* In calls.c */\n-extern void special_function_p\t        PARAMS ((tree, int *, int *,\n-\t\t\t\t\t\tint *, int *, int *));\n+\n+/* Flags used by special_function_p.  */\n+extern int setjmp_call_p\t\tPARAMS ((tree));\n \n /* In c-typeck.c */\n extern int mark_addressable\t\tPARAMS ((tree));"}]}