{"sha": "b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc1NThhMmMxZjg3ZTM3NGM0OGZhMmJlOGUzYWI5M2UxYjNjNjhiMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-10-06T21:24:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-10-06T21:24:40Z"}, "message": "C++17 copy elision improvements.\n\n\t* call.c (build_temp, convert_like_real): Don't re-copy\n\tTARGET_EXPR.  Handle packed fields.\n\t(build_x_va_arg): Wrap it in a TARGET_EXPR.\n\t(build_over_call): Add sanity check.\n\t* cvt.c (early_elide_copy): New.\n\t(ocp_convert): Use it.\n\t* except.c (build_throw): Use it.\n\t* init.c (get_nsdmi): Put back the TARGET_EXPR.\n\t(expand_default_init): Call early_elide_copy.\n\t* typeck.c (cp_build_modify_expr): Call early_elide_copy.\n\nFrom-SVN: r240845", "tree": {"sha": "c9167e38db4b5297835f67da69fdb6b691450d9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9167e38db4b5297835f67da69fdb6b691450d9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "937ec71aba5b3c633bd5979d6346254e83f46d1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/937ec71aba5b3c633bd5979d6346254e83f46d1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/937ec71aba5b3c633bd5979d6346254e83f46d1c"}], "stats": {"total": 175, "additions": 133, "deletions": 42}, "files": [{"sha": "553658f42d152ce3bc249eacfdccc03dea93d7e9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -1,3 +1,16 @@\n+2016-10-06  Jason Merrill  <jason@redhat.com>\n+\n+\t* call.c (build_temp, convert_like_real): Don't re-copy\n+\tTARGET_EXPR.  Handle packed fields.\n+\t(build_x_va_arg): Wrap it in a TARGET_EXPR.\n+\t(build_over_call): Add sanity check.\n+\t* cvt.c (early_elide_copy): New.\n+\t(ocp_convert): Use it.\n+\t* except.c (build_throw): Use it.\n+\t* init.c (get_nsdmi): Put back the TARGET_EXPR.\n+\t(expand_default_init): Call early_elide_copy.\n+\t* typeck.c (cp_build_modify_expr): Call early_elide_copy.\n+\n 2016-10-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tImplement P0258R2 - helper for C++17"}, {"sha": "6feaf7e22c9563132a08f401b186a29bf27ad74c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -6365,6 +6365,22 @@ build_temp (tree expr, tree type, int flags,\n   int savew, savee;\n   vec<tree, va_gc> *args;\n \n+  *diagnostic_kind = DK_UNSPECIFIED;\n+\n+  if (TREE_CODE (expr) == CONSTRUCTOR)\n+    expr = get_target_expr_sfinae (expr, complain);\n+  if (early_elide_copy (type, expr))\n+    return expr;\n+\n+  /* If the source is a packed field, calling the copy constructor will require\n+     binding the field to the reference parameter to the copy constructor, and\n+     we'll end up with an infinite loop.  If we can use a bitwise copy, then\n+     do that now.  */\n+  if ((lvalue_kind (expr) & clk_packed)\n+      && CLASS_TYPE_P (TREE_TYPE (expr))\n+      && !type_has_nontrivial_copy_init (TREE_TYPE (expr)))\n+    return get_target_expr_sfinae (expr, complain);\n+\n   savew = warningcount + werrorcount, savee = errorcount;\n   args = make_tree_vector_single (expr);\n   expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n@@ -6374,8 +6390,6 @@ build_temp (tree expr, tree type, int flags,\n     *diagnostic_kind = DK_WARNING;\n   else if (errorcount > savee)\n     *diagnostic_kind = DK_ERROR;\n-  else\n-    *diagnostic_kind = DK_UNSPECIFIED;\n   return expr;\n }\n \n@@ -6778,10 +6792,6 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tflags |= LOOKUP_ONLYCONVERTING;\n       if (convs->rvaluedness_matches_p)\n \tflags |= LOOKUP_PREFER_RVALUE;\n-      if (TREE_CODE (expr) == TARGET_EXPR\n-\t  && TARGET_EXPR_LIST_INIT_P (expr))\n-\t/* Copy-list-initialization doesn't actually involve a copy.  */\n-\treturn expr;\n       expr = build_temp (expr, totype, flags, &diag_kind, complain);\n       if (diag_kind && complain)\n \t{\n@@ -7068,7 +7078,12 @@ build_x_va_arg (source_location loc, tree expr, tree type)\n       return convert_from_reference (expr);\n     }\n \n-  return build_va_arg (loc, expr, type);\n+  tree ret = build_va_arg (loc, expr, type);\n+  if (CLASS_TYPE_P (type))\n+    /* Wrap the VA_ARG_EXPR in a TARGET_EXPR now so other code doesn't need to\n+       know how to handle it.  */\n+    ret = get_target_expr (ret);\n+  return ret;\n }\n \n /* TYPE has been given to va_arg.  Apply the default conversions which\n@@ -7806,6 +7821,15 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       else\n \targ = cp_build_indirect_ref (arg, RO_NULL, complain);\n \n+      /* In C++17 we shouldn't be copying a TARGET_EXPR except into a base\n+\t subobject.  */\n+      if (CHECKING_P && cxx_dialect >= cxx1z)\n+\tgcc_assert (TREE_CODE (arg) != TARGET_EXPR\n+\t\t    // FIXME we shouldn't copy for direct-init either\n+\t\t    || !(flags & LOOKUP_ONLYCONVERTING)\n+\t\t    /* See unsafe_copy_elision_p.  */\n+\t\t    || DECL_BASE_CONSTRUCTOR_P (fn));\n+\n       /* [class.copy]: the copy constructor is implicitly defined even if\n \t the implementation elided its use.  */\n       if (!trivial || DECL_DELETED_FN (fn))"}, {"sha": "9282bbe388302a416ad1b5a0d8459ea86d1169b4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -5692,6 +5692,7 @@ extern tree convert_to_reference\t\t(tree, tree, int, int, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree convert_from_reference\t\t(tree);\n extern tree force_rvalue\t\t\t(tree, tsubst_flags_t);\n+extern bool early_elide_copy\t\t\t(tree, tree);\n extern tree ocp_convert\t\t\t\t(tree, tree, int, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_convert\t\t\t\t(tree, tree, tsubst_flags_t);"}, {"sha": "063457f1c5e5c8cf28a244e4aea358649858aa87", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -658,6 +658,27 @@ cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n   return result;\n }\n \n+/* Returns true if we should avoid even doing overload resolution for copying\n+   EXPR to initialize a TYPE.  */\n+\n+bool\n+early_elide_copy (tree type, tree expr)\n+{\n+  if (TREE_CODE (expr) != TARGET_EXPR)\n+    return false;\n+  /* List-initialization and direct-initialization don't involve a copy.  */\n+  if (TARGET_EXPR_LIST_INIT_P (expr)\n+      || TARGET_EXPR_DIRECT_INIT_P (expr))\n+    return true;\n+  /* In C++17, \"If the initializer expression is a prvalue and the\n+     cv-unqualified version of the source type is the same class as the class\n+     of the destination, the initializer expression is used to initialize the\n+     destination object.\"  */\n+  return (cxx_dialect >= cxx1z\n+\t  && (same_type_ignoring_top_level_qualifiers_p\n+\t      (type, TREE_TYPE (expr))));\n+}\n+\n /* Conversion...\n \n    FLAGS indicates how we should behave.  */\n@@ -694,10 +715,8 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n     return error_mark_node;\n \n   if (MAYBE_CLASS_TYPE_P (type) && (convtype & CONV_FORCE_TEMP)\n-      && !(cxx_dialect >= cxx1z\n-\t   && TREE_CODE (e) == TARGET_EXPR))\n-    /* We need a new temporary; don't take this shortcut.  But in C++17, don't\n-       force a temporary if we already have one.  */;\n+      && !early_elide_copy (type, e))\n+    /* We need a new temporary; don't take this shortcut.  */;\n   else if (same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (e)))\n     {\n       if (same_type_p (type, TREE_TYPE (e)))"}, {"sha": "2f88082bf5e7ba2f0f2a4813dbf85b5f4b22751f", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -683,7 +683,7 @@ build_throw (tree exp)\n       object = cp_build_indirect_ref (object, RO_NULL, tf_warning_or_error);\n \n       /* And initialize the exception object.  */\n-      if (CLASS_TYPE_P (temp_type))\n+      if (CLASS_TYPE_P (temp_type) && !early_elide_copy (temp_type, exp))\n \t{\n \t  int flags = LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING;\n \t  vec<tree, va_gc> *exp_vec;"}, {"sha": "63c3dab9b643ccff287c11331e476db1ca3d46f7", "filename": "gcc/cp/init.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -584,9 +584,13 @@ get_nsdmi (tree member, bool in_ctor)\n \t}\n       /* Strip redundant TARGET_EXPR so we don't need to remap it, and\n \t so the aggregate init code below will see a CONSTRUCTOR.  */\n-      if (init && SIMPLE_TARGET_EXPR_P (init))\n+      bool simple_target = (init && SIMPLE_TARGET_EXPR_P (init));\n+      if (simple_target)\n \tinit = TARGET_EXPR_INITIAL (init);\n       init = break_out_target_exprs (init);\n+      if (simple_target && TREE_CODE (init) != CONSTRUCTOR)\n+\t/* Now put it back so C++17 copy elision works.  */\n+\tinit = get_target_expr (init);\n     }\n   current_class_ptr = save_ccp;\n   current_class_ref = save_ccr;\n@@ -1638,6 +1642,13 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n \tinit = reshape_init (type, init, complain);\n     }\n \n+  /* Also pull out a TARGET_EXPR that we want to avoid copying.  */\n+  if (init && true_exp == exp\n+      && TREE_CODE (init) == TREE_LIST\n+      && list_length (init) == 1\n+      && early_elide_copy (type, TREE_VALUE (init)))\n+    init = TREE_VALUE (init);\n+\n   if (init && BRACE_ENCLOSED_INITIALIZER_P (init)\n       && CP_AGGREGATE_TYPE_P (type))\n     /* A brace-enclosed initializer for an aggregate.  In C++0x this can\n@@ -1648,14 +1659,12 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n      initializer, whether that happened just above or in\n      cp_parser_late_parsing_nsdmi.\n \n-     A TARGET_EXPR with TARGET_EXPR_DIRECT_INIT_P or TARGET_EXPR_LIST_INIT_P\n-     set represents the whole initialization, so we shouldn't build up\n-     another ctor call.  */\n+     A TARGET_EXPR for which early_elide_copy is true represents the whole\n+     initialization, so we shouldn't build up another ctor call.  */\n+\n   if (init\n       && (TREE_CODE (init) == CONSTRUCTOR\n-\t  || (TREE_CODE (init) == TARGET_EXPR\n-\t      && (TARGET_EXPR_DIRECT_INIT_P (init)\n-\t\t  || TARGET_EXPR_LIST_INIT_P (init))))\n+\t  || early_elide_copy (type, init))\n       && same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (init), type))\n     {\n       /* Early initialization via a TARGET_EXPR only works for"}, {"sha": "f1abb40a775edaa295215a80590804df97b3f591", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -7616,6 +7616,8 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t}\n       else if (! MAYBE_CLASS_TYPE_P (lhstype))\n \t/* Do the default thing.  */;\n+      else if (early_elide_copy (lhstype, rhs))\n+\t/* Do the default thing.  */;\n       else\n \t{\n \t  vec<tree, va_gc> *rhs_vec = make_tree_vector_single (rhs);"}, {"sha": "22af6e4567381bbcc528fae66779233d64dc7b55", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -2325,7 +2325,11 @@ release of G++.\n The C++ standard allows an implementation to omit creating a temporary\n that is only used to initialize another object of the same type.\n Specifying this option disables that optimization, and forces G++ to\n-call the copy constructor in all cases.\n+call the copy constructor in all cases.  This option also causes G++\n+to call trivial member functions which otherwise would be expanded inline.\n+\n+In C++17, the compiler is required to omit these temporaries, but this\n+option still affects trivial member functions.\n \n @item -fno-enforce-eh-specs\n @opindex fno-enforce-eh-specs"}, {"sha": "8d1ebcd94f174a13e58b8ea82957815fd8aab399", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-ctor14a.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor14a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor14a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-ctor14a.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -8,7 +8,7 @@ struct A\n };\n \n constexpr A a;\n-constexpr A b = A();\t\t// { dg-error \"\" }\n+constexpr A b = A();\t\t// { dg-error \"\" \"\" { target c++14_down } }\n \n #define SA(X) static_assert ((X), #X)\n SA(a.p == &a);"}, {"sha": "ef806d0c8b7db2b4cfcf25cc243120479d6a94be", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist9.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist9.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -8,7 +8,7 @@ struct b\n   b() = default;\n   ~b() = default;\n   b& operator=(const b&) = delete;\n-  b(const b&) = delete;\t\t// { dg-message \"declared\" }\n+  b(const b&) = delete;\t\t// { dg-message \"declared\" \"\" { target c++14_down } }\n \n   b(bool _t): t (_t) { }\n };\n@@ -19,7 +19,7 @@ int main()\n   b tst1 = { false };\n \n   // copy initialization.\n-  b tst2 = false;\t\t// { dg-error \"use\" }\n+  b tst2 = false;\t\t// { dg-error \"use\" \"\" { target c++14_down } }\n \n   // direct list initialization\n   b tst3 { false };"}, {"sha": "b630b23a3c429aac020a2dbfff2882bd15a4243c", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept23.C", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept23.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -10,5 +10,10 @@ void a(A) noexcept {}\n \n void f()\n {\n-  static_assert(!noexcept(a(A{})), \"\");\n+#if __cplusplus <= 201402L\n+  const bool val = false;\n+#else\n+  const bool val = true;\n+#endif\n+  static_assert(noexcept(a(A{})) == val, \"\");\n }"}, {"sha": "60ca44395b282c2c472217109395925d799544fc", "filename": "gcc/testsuite/g++.dg/cpp0x/noexcept24.C", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnoexcept24.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -13,7 +13,12 @@ void a(A<T>) noexcept {}\n template<typename T>\n void f()\n {\n-  static_assert(!noexcept(a(A<T>{})), \"\");\n+#if __cplusplus <= 201402L\n+  const bool val = false;\n+#else\n+  const bool val = true;\n+#endif\n+  static_assert(val == noexcept(a(A<T>{})), \"\");\n }\n \n void g()"}, {"sha": "71476e239709a05bca702d415a5ca607c9dc620a", "filename": "gcc/testsuite/g++.dg/cpp1z/elide1.C", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Felide1.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -14,3 +14,12 @@ A a2 = (42, A());\n A f();\n A a3 = f();\n A a4 = b ? A() : f();\n+\n+void g(A);\n+A f() {\n+  g(A());\n+  if (b)\n+    throw A();\n+  else\n+    return A();\n+}"}, {"sha": "cfc739439284caf016ec046e9a00626555da495f", "filename": "gcc/testsuite/g++.dg/init/copy3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fcopy3.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run }\n+// { dg-do run { target c++14_down } }\n // { dg-options \"-fno-elide-constructors\" }\n \n int copies;"}, {"sha": "9507c027252791a928c31e10440bfd63a1987ee6", "filename": "gcc/testsuite/g++.dg/overload/arg3.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Farg3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Farg3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Farg3.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -11,12 +11,12 @@ struct A {};\n struct B : A\n {\n   B(int);\n-  B(B&);  // { dg-message \"note\" \"\" }\n+  B(B&);  // { dg-message \"note\" \"\" { target c++14_down } }\n };\n \n-void foo(B);\t\t\t// { dg-message \"initializing\" }\n+void foo(B);\t\t\t// { dg-message \"initializing\" \"\" { target c++14_down } }\n \n void bar()\n {\n-  foo(0); // { dg-error \"\" }\n+  foo(0); // { dg-error \"\" \"\" { target c++14_down } }\n }"}, {"sha": "a34221df38b649b33479f953fe0b4b0feb55f284", "filename": "gcc/testsuite/g++.dg/template/copy1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcopy1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcopy1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcopy1.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -6,9 +6,9 @@\n \n struct A\n {\n-  A(A&);\t\t\t// { dg-message \"A::A\" }\n-  template <class T> A(T); \t// { dg-message \"A::A\" }\n+  A(A&);\t\t\t// { dg-message \"A::A\" \"\" { target c++14_down } }\n+  template <class T> A(T); \t// { dg-message \"A::A\" \"\" { target c++14_down } }\n };\n \n-A a = 0; // { dg-error \"\" }\n+A a = 0; // { dg-error \"\" \"\" { target c++14_down } }\n "}, {"sha": "21b27d707f2878c7355adcc33861698597056087", "filename": "gcc/testsuite/g++.old-deja/g++.eh/ctor1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fctor1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fctor1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fctor1.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -2,16 +2,16 @@\n struct A\n {\n   A();\n-  A(A&);\t\t\t// { dg-message \"A::A|no known conversion\" } referenced below\n+  A(A&);\t\t\t// { dg-message \"A::A|no known conversion\" \"\" { target c++14_down } } referenced below\n };\n \n int\n main ()\n {\n   try\n     {\n-      throw A();\t\t// { dg-error \"rvalue\" \"\" } can't copy\n-// { dg-error \"thrown expression\" \"expr\" { target *-*-* } 13 }\n+      throw A();\t\t// { dg-error \"rvalue\" \"\" { target c++14_down } } can't copy\n+      // { dg-error \"thrown expression\" \"expr\" { target c++14_down } 13 }\n     }\n   catch (...) { }\n }"}, {"sha": "c855f8f4a076ec21380a5440052f5738d90d5e5c", "filename": "gcc/testsuite/g++.old-deja/g++.jason/temporary2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemporary2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemporary2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemporary2.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -3,7 +3,7 @@ class X // Indentation has been done so to see the similarities.\n {\n public:\n   X() {}\n-         X(X& x) {x.i=7;} // { dg-message \"note\" } Both functions modify the\n+         X(X& x) {x.i=7;} // { dg-message \"note\" \"\" { target c++14_down } } Both functions modify the\n   void bar(X& x) {x.i=7;} // { dg-message \"note\" } reference parameter x.\n   int i;\n };\n@@ -12,6 +12,6 @@ X foo() { X x; return x; }\n \n int main() \n {\n-  X   x(foo()); // { dg-error \"rvalue\" } Compiler doesn't warn about temporary reference.\n+  X   x(foo()); // { dg-error \"rvalue\" \"\" { target c++14_down } } Compiler doesn't warn about temporary reference.\n   x.bar(foo()); // { dg-error \"rvalue\" } The same mistake is warned about in this case.\n }"}, {"sha": "d990a106e55c1864a2dc810bc27fdcfd1afd38c0", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p2431.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp2431.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp2431.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp2431.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -3,7 +3,7 @@\n class A\n {\n \tpublic:\n-      A(A &); // { dg-message \"note\" }\n+      A(A &); // { dg-message \"note\" \"\" { target c++14_down } }\n };\n \n class B\n@@ -18,6 +18,6 @@ class C\n \tC()\n \t{\n \t\tB\tb;\n-\t\tA a = b;// { dg-error \"rvalue\" }\n+\t\tA a = b;// { dg-error \"rvalue\" \"\" { target c++14_down } }\n \t}\n };"}, {"sha": "35e1cc264ccf1bbfd20ef09ff74c86c96db68596", "filename": "gcc/testsuite/g++.old-deja/g++.pt/auto_ptr.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fauto_ptr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fauto_ptr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fauto_ptr.C?ref=b7558a2c1f87e374c48fa2be8e3ab93e1b3c68b0", "patch": "@@ -9,7 +9,7 @@ template<typename X> struct auto_ptr {\n    typedef X element_type;\n \n    explicit auto_ptr(X* p =0) throw() : px(p) {}\n-   auto_ptr(auto_ptr& r) throw() : px(r.release()) {} // { dg-message \"note\" } candidate\n+   auto_ptr(auto_ptr& r) throw() : px(r.release()) {} // { dg-message \"note\" \"\" { target c++14_down } } candidate\n    template<typename Y>\n       auto_ptr(auto_ptr<Y>& r) throw() : px(r.release()) {}\n \n@@ -44,12 +44,12 @@ struct Derived : Base { Derived() {} };\n \n auto_ptr<Derived> f() { auto_ptr<Derived> null(0); return null; }\n void g(auto_ptr<Derived>) { }\n-void h(auto_ptr<Base>) { }\t// { dg-message \"initializing\" }\n+void h(auto_ptr<Base>) { }\t// { dg-message \"initializing\" \"\" { target c++14_down } }\n \n int main() {\n     auto_ptr<Base> x(f());\n     auto_ptr<Derived> y(f());\n     x = y;\n     g(f());\n-    h(f());\t\t\t// { dg-error \"rvalue\" \"\" } no usable copy ctor\n+    h(f());\t\t\t// { dg-error \"rvalue\" \"\" { target c++14_down } } no usable copy ctor\n }"}]}