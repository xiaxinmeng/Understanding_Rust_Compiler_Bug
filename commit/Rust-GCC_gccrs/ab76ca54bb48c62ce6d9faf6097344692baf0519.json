{"sha": "ab76ca54bb48c62ce6d9faf6097344692baf0519", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI3NmNhNTRiYjQ4YzYyY2U2ZDlmYWY2MDk3MzQ0NjkyYmFmMDUxOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-30T00:26:03Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-30T00:26:03Z"}, "message": "c-common.c: Include c-common.h, not c-lex.h or c-tree.h.\n\n\t* c-common.c: Include c-common.h, not c-lex.h or c-tree.h.\n\t* c-common.h (flag_const_strings): Declare.\n\t(warn_format): Likewise.\n\t(flag_traditional): Likewise.\n\t(flag_isoc99): Likewise.\n\t(warn_parentheses): Likewise.\n\t(warn_conversion): Likewise.\n\t(C_TYPE_OBJECT_P): Likewise.\n\t(C_TYPE_INCOMPLETE_P): Likewise.\n\t(C_TYPE_FUNCTION_P): Likewise.\n\t(C_TYPE_OBJECT_OR_INCOMPLETE_P): Likewise.\n\t(C_EXP_ORIGINAL_CODE): Likewise.\n\t(build_unary_op): Likewise.\n\t(build_binary_op): Likewise.\n\t(lvalue_p): Likewise.\n\t(default_conversion): Likewise.\n\t(common_type): Likewise.\n\t* c-tree.h (C_TYPE_OBJECT_P): Remove.\n\t(C_TYPE_INCOMPLETE_P): Likewise.\n\t(C_TYPE_FUNCTION_P): Likewise.\n\t(C_TYPE_OBJECT_OR_INCOMPLETE_P): Likewise.\n\t(C_EXP_ORIGINAL_CODE): Likewise.\n\t(common_type): Likewise.\n\t(default_conversion): Likewise.\n\t(build_binary_op): Likewise.\n\t(build_unary_op): Likewise.\n\t(lvalue_p): Likewise.\n\t(flag_const_strings): Likewise.\n\t(warn_format): Likewise.\n\t(warn_conversion): Likewise.\n\t(flag_traditional): Likewise.\n\t(flag_isoc99): Likewise.\n\t(warn_parentheses): Likewise.\n\n\t* cp-tree.h (flag_const_strings): Remove.\n\t(warn_parentheses): Likewise.\n\t(warn_format): Likewise.\n\t(common_type): Likewise.\n\t(default_conversion): Likewise.\n\t(build_binary_op): Likewise.\n\t(cp_build_binary_op): New macro.\n\t* call.c (build_new_op): Use cp_build_binary_op instead of\n\tbuild_binary_op.\n\t* class.c (build_vtable_entry_ref): Likewise.\n\t* decl.c (expand_static_init): Likewise.\n\t(compute_array_index_type): Likewise.\n\t(build_enumerator): Likewise.\n\t* decl2.c (delete_sanity): Likewise.\n\t(start_static_initialization_or_destruction): Likewise.\n\t* error.c (dump_type_suffix): Likewise.\n\t* init.c (resolve_offset_ref): Likewise.\n\t(build_new): Likewise.\n\t(build_new_1): Likewise.\n\t(build_vec_delete_1): Likewise.\n\t(build_vec_init): Likewise.\n\t(build_delete): Likewise.\n\t* rtti.c (synthesize_tinfo_fn): Likewise.\n\t(synthesize_tinfo_var): Likewise.\n\t* search.c (expand_upcast_fixups): Likewise.\n\t(fixup_all_virtual_upcast_offsets): Likewise.\n\t* typeck.c (build_array_ref): Likewise.\n\t(get_member_function_from_ptrfunc): Likewise.\n\t(build_binary_op): Add parameter.\n\t(pointer_int_sum): Use cp_build_binary_op.\n\t(pointer_diff): Likewise.\n\t(build_modify_expr): Likewise.\n\t(get_delta_difference): Likewise.\n\t(build_ptrmemfunc): Likewise.\n\nFrom-SVN: r34796", "tree": {"sha": "f2e62f4c68101bf124b22d5914f5f71fe65475d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2e62f4c68101bf124b22d5914f5f71fe65475d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab76ca54bb48c62ce6d9faf6097344692baf0519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab76ca54bb48c62ce6d9faf6097344692baf0519", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab76ca54bb48c62ce6d9faf6097344692baf0519", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab76ca54bb48c62ce6d9faf6097344692baf0519/comments", "author": null, "committer": null, "parents": [{"sha": "6eaeeb553ad4319869928b00f6e6546b03c22d0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eaeeb553ad4319869928b00f6e6546b03c22d0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eaeeb553ad4319869928b00f6e6546b03c22d0f"}], "stats": {"total": 461, "additions": 267, "deletions": 194}, "files": [{"sha": "493e1eab14bcc1bb2dc2dcb991be29c277de6153", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -1,3 +1,39 @@\n+2000-06-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-common.c: Include c-common.h, not c-lex.h or c-tree.h.\n+\t* c-common.h (flag_const_strings): Declare.\n+\t(warn_format): Likewise.\n+\t(flag_traditional): Likewise.\n+\t(flag_isoc99): Likewise.\n+\t(warn_parentheses): Likewise.\n+\t(warn_conversion): Likewise.\n+\t(C_TYPE_OBJECT_P): Likewise.\n+\t(C_TYPE_INCOMPLETE_P): Likewise.\n+\t(C_TYPE_FUNCTION_P): Likewise.\n+\t(C_TYPE_OBJECT_OR_INCOMPLETE_P): Likewise.\n+\t(C_EXP_ORIGINAL_CODE): Likewise.\n+\t(build_unary_op): Likewise.\n+\t(build_binary_op): Likewise.\n+\t(lvalue_p): Likewise.\n+\t(default_conversion): Likewise.\n+\t(common_type): Likewise.\n+\t* c-tree.h (C_TYPE_OBJECT_P): Remove.\n+\t(C_TYPE_INCOMPLETE_P): Likewise.\n+\t(C_TYPE_FUNCTION_P): Likewise.\n+\t(C_TYPE_OBJECT_OR_INCOMPLETE_P): Likewise.\n+\t(C_EXP_ORIGINAL_CODE): Likewise.\n+\t(common_type): Likewise.\n+\t(default_conversion): Likewise.\n+\t(build_binary_op): Likewise.\n+\t(build_unary_op): Likewise.\n+\t(lvalue_p): Likewise.\n+\t(flag_const_strings): Likewise.\n+\t(warn_format): Likewise.\n+\t(warn_conversion): Likewise.\n+\t(flag_traditional): Likewise.\n+\t(flag_isoc99): Likewise.\n+\t(warn_parentheses): Likewise.\n+\t\n 2000-06-29  James E. Wilson  <wilson@cygnus.com>\n \n \t* config/ia64/linux.h (LINK_SPEC): Change so.1 to so.2."}, {"sha": "5fffa79f41b7b854275775b42eba8608d9d8646a", "filename": "gcc/c-common.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -22,8 +22,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n-#include \"c-lex.h\"\n-#include \"c-tree.h\"\n+#include \"c-common.h\"\n #include \"flags.h\"\n #include \"toplev.h\"\n #include \"output.h\""}, {"sha": "9db6c8b1b6d39d7ed3ee904d602c2db0a21afe38", "filename": "gcc/c-common.h", "status": "modified", "additions": 80, "deletions": 16, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -54,21 +54,6 @@ enum c_tree_index\n     CTI_MAX\n };\n \n-extern tree c_global_trees[CTI_MAX];\n-\n-typedef enum c_language_kind\n-{\n-  clk_c,           /* A dialect of C: K&R C, ANSI/ISO C89, C2000,\n-\t\t       etc. */\n-  clk_cplusplus,   /* ANSI/ISO C++ */\n-  clk_objective_c  /* Objective C */\n-} \n-c_language_kind;\n-\n-/* The variant of the C language being processed.  Each C language\n-   front-end defines this variable.  */\n-extern c_language_kind c_language;\n-\n #define wchar_type_node\t\t\tc_global_trees[CTI_WCHAR_TYPE]\n #define signed_wchar_type_node\t\tc_global_trees[CTI_SIGNED_WCHAR_TYPE]\n #define unsigned_wchar_type_node\tc_global_trees[CTI_UNSIGNED_WCHAR_TYPE]\n@@ -98,6 +83,67 @@ extern c_language_kind c_language;\n #define g77_longint_type_node\t\tc_global_trees[CTI_G77_LONGINT_TYPE]\n #define g77_ulongint_type_node\t\tc_global_trees[CTI_G77_ULONGINT_TYPE]\n \n+extern tree c_global_trees[CTI_MAX];\n+\n+typedef enum c_language_kind\n+{\n+  clk_c,           /* A dialect of C: K&R C, ANSI/ISO C89, C2000,\n+\t\t       etc. */\n+  clk_cplusplus,   /* ANSI/ISO C++ */\n+  clk_objective_c  /* Objective C */\n+} \n+c_language_kind;\n+\n+/* The variant of the C language being processed.  Each C language\n+   front-end defines this variable.  */\n+\n+extern c_language_kind c_language;\n+\n+/* Nonzero means give string constants the type `const char *', rather\n+   than `char *'.  */\n+\n+extern int flag_const_strings;\n+\n+/* Warn about *printf or *scanf format/argument anomalies. */\n+\n+extern int warn_format;\n+\n+/* Nonzero means do some things the same way PCC does.  */\n+\n+extern int flag_traditional;\n+\n+/* Nonzero means use the ISO C99 dialect of C.  */\n+\n+extern int flag_isoc99;\n+\n+/* Nonzero means warn about suggesting putting in ()'s.  */\n+\n+extern int warn_parentheses;\n+\n+/* Warn if a type conversion is done that might have confusing results.  */\n+\n+extern int warn_conversion;\n+\n+/* C types are partitioned into three subsets: object, function, and\n+   incomplete types.  */\n+#define C_TYPE_OBJECT_P(type) \\\n+  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type))\n+\n+#define C_TYPE_INCOMPLETE_P(type) \\\n+  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type) == 0)\n+\n+#define C_TYPE_FUNCTION_P(type) \\\n+  (TREE_CODE (type) == FUNCTION_TYPE)\n+\n+/* For convenience we define a single macro to identify the class of\n+   object or incomplete types.  */\n+#define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n+  (!C_TYPE_FUNCTION_P (type))\n+\n+/* Record in each node resulting from a binary operator\n+   what operator was specified for it.  */\n+#define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n+\n /* Pointer to function to generate the VAR_DECL for __FUNCTION__ etc.\n    ID is the identifier to use, NAME is the string.\n    TYPE_DEP indicates whether it depends on type of the function or not\n@@ -125,6 +171,7 @@ extern void constant_expression_warning\t\tPARAMS ((tree));\n extern tree convert_and_check\t\t\tPARAMS ((tree, tree));\n extern void overflow_warning\t\t\tPARAMS ((tree));\n extern void unsigned_conversion_warning\t\tPARAMS ((tree, tree));\n+\n /* Read the rest of the current #-directive line.  */\n #if USE_CPPLIB\n extern char *get_directive_line\t\t\tPARAMS ((void));\n@@ -164,7 +211,7 @@ extern tree build_va_arg\t\t\tPARAMS ((tree, tree));\n extern int self_promoting_args_p\t\tPARAMS ((tree));\n extern tree simple_type_promotes_to\t\tPARAMS ((tree));\n \n-\n+\f\n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n \n@@ -306,3 +353,20 @@ enum c_tree_code {\n #undef DEFTREECODE\n \n extern void add_c_tree_codes\t\t        PARAMS ((void));\n+\f\n+\n+/* These functions must be defined by each front-end which implements\n+   a variant of the C language.  They are used in c-common.c.  */\n+\n+extern tree build_unary_op                      PARAMS ((enum tree_code,\n+\t\t\t\t\t\t\t tree, int));\n+extern tree build_binary_op                     PARAMS ((enum tree_code,\n+\t\t\t\t\t\t\t tree, tree, int));\n+extern int lvalue_p\t\t\t\tPARAMS ((tree));\n+extern tree default_conversion                  PARAMS ((tree));\n+\n+/* Given two integer or real types, return the type for their sum.\n+   Given two compatible ANSI C types, returns the merged type.  */\n+\n+extern tree common_type                         PARAMS ((tree, tree));\n+"}, {"sha": "8619071a55c4c7d6643eef6e8a3f4928216ebb2d", "filename": "gcc/c-tree.h", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -83,22 +83,6 @@ extern int pedantic;\n    nonzero if the definition of the type has already started.  */\n #define C_TYPE_BEING_DEFINED(type) TYPE_LANG_FLAG_0 (type)\n \n-/* C types are partitioned into three subsets: object, function, and\n-   incomplete types.  */\n-#define C_TYPE_OBJECT_P(type) \\\n-  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type))\n-\n-#define C_TYPE_FUNCTION_P(type) \\\n-  (TREE_CODE (type) == FUNCTION_TYPE)\n-\n-#define C_TYPE_INCOMPLETE_P(type) \\\n-  (TREE_CODE (type) != FUNCTION_TYPE && TYPE_SIZE (type) == 0)\n-\n-/* For convenience we define a single macro to identify the class of\n-   object or incomplete types.  */\n-#define C_TYPE_OBJECT_OR_INCOMPLETE_P(type) \\\n-  (!C_TYPE_FUNCTION_P (type))\n-\n /* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n struct lang_type\n {\n@@ -115,10 +99,6 @@ struct lang_type\n #define C_TYPE_VARIABLE_SIZE(type) TYPE_LANG_FLAG_1 (type)\n #define C_DECL_VARIABLE_SIZE(type) DECL_LANG_FLAG_0 (type)\n \n-/* Record in each node resulting from a binary operator\n-   what operator was specified for it.  */\n-#define C_EXP_ORIGINAL_CODE(exp) ((enum tree_code) TREE_COMPLEXITY (exp))\n-\n #if 0 /* Not used.  */\n /* Record whether a decl for a function or function pointer has\n    already been mentioned (in a warning) because it was called\n@@ -251,28 +231,19 @@ extern tree xref_tag                            PARAMS ((enum tree_code, tree));\n /* in c-typeck.c */\n extern tree require_complete_type\t\tPARAMS ((tree));\n extern void incomplete_type_error\t\tPARAMS ((tree, tree));\n-/* Given two integer or real types, return the type for their sum.\n-   Given two compatible ANSI C types, returns the merged type.  */\n-extern tree common_type                         PARAMS ((tree, tree));\n extern int comptypes\t\t\t\tPARAMS ((tree, tree));\n extern tree c_sizeof                            PARAMS ((tree));\n extern tree c_sizeof_nowarn                     PARAMS ((tree));\n extern tree c_size_in_bytes                     PARAMS ((tree));\n extern tree c_alignof\t\t\t\tPARAMS ((tree));\n extern tree c_alignof_expr\t\t\tPARAMS ((tree));\n-extern tree default_conversion                  PARAMS ((tree));\n extern tree build_component_ref                 PARAMS ((tree, tree));\n extern tree build_indirect_ref                  PARAMS ((tree, const char *));\n extern tree build_array_ref                     PARAMS ((tree, tree));\n extern tree build_external_ref\t\t\tPARAMS ((tree, int));\n extern tree build_function_call                 PARAMS ((tree, tree));\n extern tree parser_build_binary_op              PARAMS ((enum tree_code,\n \t\t\t\t\t\t\t tree, tree));\n-extern tree build_binary_op                     PARAMS ((enum tree_code,\n-\t\t\t\t\t\t\t tree, tree, int));\n-extern tree build_unary_op                      PARAMS ((enum tree_code,\n-\t\t\t\t\t\t\t tree, int));\n-extern int lvalue_p\t\t\t\tPARAMS ((tree));\n extern int lvalue_or_else\t\t\tPARAMS ((tree, const char *));\n extern void readonly_warning\t\t\tPARAMS ((tree, const char *));\n extern int mark_addressable\t\t\tPARAMS ((tree));\n@@ -345,12 +316,6 @@ extern int flag_hosted;\n \n extern int warn_implicit;\n \n-/* Nonzero means give string constants the type `const char *'\n-   to get extra warnings from them.  These warnings will be too numerous\n-   to be useful, except in thoroughly ANSIfied programs.  */\n-\n-extern int flag_const_strings;\n-\n /* Nonzero means warn about sizeof (function) or addition/subtraction\n    of function pointers.  */\n \n@@ -392,38 +357,18 @@ extern int warn_missing_noreturn;\n \n extern int warn_traditional;\n \n-/* Warn about *printf or *scanf format/argument anomalies. */\n-\n-extern int warn_format;\n-\n /* Warn about a subscript that has type char.  */\n \n extern int warn_char_subscripts;\n \n-/* Warn if a type conversion is done that might have confusing results.  */\n-\n-extern int warn_conversion;\n-\n /* Warn if main is suspicious. */\n \n extern int warn_main;\n \n-/* Nonzero means do some things the same way PCC does.  */\n-\n-extern int flag_traditional;\n-\n-/* Nonzero means use the ISO C99 dialect of C.  */\n-\n-extern int flag_isoc99;\n-\n /* Nonzero means to allow single precision math even if we're generally\n    being traditional. */\n extern int flag_allow_single_precision;\n \n-/* Nonzero means warn about suggesting putting in ()'s.  */\n-\n-extern int warn_parentheses;\n-\n /* Warn if initializer is not completely bracketed.  */\n \n extern int warn_missing_braces;"}, {"sha": "ef87879749497b2f00311b6abce19d62b953211f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -1,3 +1,40 @@\n+2000-06-29  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (flag_const_strings): Remove.\n+\t(warn_parentheses): Likewise.\n+\t(warn_format): Likewise.\n+\t(common_type): Likewise.\n+\t(default_conversion): Likewise.\n+\t(build_binary_op): Likewise.\n+\t(cp_build_binary_op): New macro.\n+\t* call.c (build_new_op): Use cp_build_binary_op instead of\n+\tbuild_binary_op.\n+\t* class.c (build_vtable_entry_ref): Likewise.\n+\t* decl.c (expand_static_init): Likewise.\n+\t(compute_array_index_type): Likewise.\n+\t(build_enumerator): Likewise.\n+\t* decl2.c (delete_sanity): Likewise.\n+\t(start_static_initialization_or_destruction): Likewise.\n+\t* error.c (dump_type_suffix): Likewise.\n+\t* init.c (resolve_offset_ref): Likewise.\n+\t(build_new): Likewise.\n+\t(build_new_1): Likewise.\n+\t(build_vec_delete_1): Likewise.\n+\t(build_vec_init): Likewise.\n+\t(build_delete): Likewise.\n+\t* rtti.c (synthesize_tinfo_fn): Likewise.\n+\t(synthesize_tinfo_var): Likewise.\n+\t* search.c (expand_upcast_fixups): Likewise.\n+\t(fixup_all_virtual_upcast_offsets): Likewise.\n+\t* typeck.c (build_array_ref): Likewise.\n+\t(get_member_function_from_ptrfunc): Likewise.\n+\t(build_binary_op): Add parameter.\n+\t(pointer_int_sum): Use cp_build_binary_op.\n+\t(pointer_diff): Likewise.\n+\t(build_modify_expr): Likewise.\n+\t(get_delta_difference): Likewise.\n+\t(build_ptrmemfunc): Likewise.\n+\t\n 2000-06-29  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (SET_DECL_ARTIFICIAL): Remove."}, {"sha": "1dd6a291a6a40fb0d5cd3aa4db6a00906cc19117", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -3444,7 +3444,7 @@ build_new_op (code, flags, arg1, arg2, arg3)\n     case BIT_XOR_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n-      return build_binary_op (code, arg1, arg2);\n+      return cp_build_binary_op (code, arg1, arg2);\n \n     case CONVERT_EXPR:\n     case NEGATE_EXPR:"}, {"sha": "2ec325ba2998fe36b372b8892a410691a3006fba", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -507,7 +507,7 @@ build_vtable_entry_ref (basetype, vtbl, idx)\n   i = build_c_cast (ptrdiff_type_node, build_unary_op (ADDR_EXPR, i, 0));\n   i2 = build_array_ref (vtbl, build_int_2(0,0));\n   i2 = build_c_cast (ptrdiff_type_node, build_unary_op (ADDR_EXPR, i2, 0));\n-  i = build_binary_op (MINUS_EXPR, i, i2);\n+  i = cp_build_binary_op (MINUS_EXPR, i, i2);\n   i = build_tree_list (build_string (1, \"i\"), i);\n \n   finish_asm_stmt (ridpointers[RID_VOLATILE],"}, {"sha": "f98c5ea225e5300834ed9c61ede8b1c4035a0d17", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -1086,11 +1086,6 @@ extern int warn_ctor_dtor_privacy;\n \n extern int warn_return_type;\n \n-/* Nonzero means give string constants the type `const char *', as mandated\n-   by the standard.  */\n-\n-extern int flag_const_strings;\n-\n /* If non-NULL, dump the tree structure for the entire translation\n    unit to this file.  */\n \n@@ -1106,10 +1101,6 @@ extern int warn_write_strings;\n \n extern int warn_pointer_arith;\n \n-/* Nonzero means warn about suggesting putting in ()'s.  */\n-\n-extern int warn_parentheses;\n-\n /* Nonzero means warn about multiple (redundant) decls for the same single\n    variable or function.  */\n \n@@ -1136,10 +1127,6 @@ extern int warn_char_subscripts;\n \n extern int warn_cast_qual;\n \n-/* Warn about *printf or *scanf format/argument anomalies.  */\n-\n-extern int warn_format;\n-\n /* Nonzero means warn about non virtual destructors in classes that have\n    virtual functions.  */\n \n@@ -4622,7 +4609,6 @@ extern tree complete_type_or_else               PARAMS ((tree, tree));\n extern int type_unknown_p\t\t\tPARAMS ((tree));\n extern tree commonparms\t\t\t\tPARAMS ((tree, tree));\n extern tree original_type\t\t\tPARAMS ((tree));\n-extern tree common_type\t\t\t\tPARAMS ((tree, tree));\n extern int comp_except_specs\t\t\tPARAMS ((tree, tree, int));\n extern int comptypes\t\t\t\tPARAMS ((tree, tree, int));\n extern int comp_target_types\t\t\tPARAMS ((tree, tree, int));\n@@ -4639,7 +4625,6 @@ extern tree c_sizeof_nowarn\t\t\tPARAMS ((tree));\n extern tree c_alignof\t\t\t\tPARAMS ((tree));\n extern tree inline_conversion\t\t\tPARAMS ((tree));\n extern tree decay_conversion\t\t\tPARAMS ((tree));\n-extern tree default_conversion\t\t\tPARAMS ((tree));\n extern tree build_object_ref\t\t\tPARAMS ((tree, tree, tree));\n extern tree build_component_ref_1\t\tPARAMS ((tree, tree, int));\n extern tree build_component_ref\t\t\tPARAMS ((tree, tree, tree, int));\n@@ -4654,9 +4639,7 @@ extern tree build_function_call\t\t\tPARAMS ((tree, tree));\n extern tree build_function_call_maybe\t\tPARAMS ((tree, tree));\n extern tree convert_arguments\t\t\tPARAMS ((tree, tree, tree, int));\n extern tree build_x_binary_op\t\t\tPARAMS ((enum tree_code, tree, tree));\n-extern tree build_binary_op\t\t\tPARAMS ((enum tree_code, tree, tree));\n extern tree build_x_unary_op\t\t\tPARAMS ((enum tree_code, tree));\n-extern tree build_unary_op\t\t\tPARAMS ((enum tree_code, tree, int));\n extern tree unary_complex_lvalue\t\tPARAMS ((enum tree_code, tree));\n extern int mark_addressable\t\t\tPARAMS ((tree));\n extern tree build_x_conditional_expr\t\tPARAMS ((tree, tree, tree));\n@@ -4690,6 +4673,8 @@ extern tree type_after_usual_arithmetic_conversions PARAMS ((tree, tree));\n extern tree composite_pointer_type              PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t\t       const char*));\n extern tree check_return_expr                   PARAMS ((tree));\n+#define cp_build_binary_op(code, arg1, arg2) \\\n+  build_binary_op(code, arg1, arg2, 1)\n \n /* in typeck2.c */\n extern tree error_not_base_type\t\t\tPARAMS ((tree, tree));"}, {"sha": "dea99029b0984ead01e31b622fbc4f1fb568e5df", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -8607,8 +8607,8 @@ expand_static_init (decl, init)\n \n       /* Begin the conditional initialization.  */\n       if_stmt = begin_if_stmt ();\n-      finish_if_stmt_cond (build_binary_op (EQ_EXPR, temp,\n-\t\t\t\t\t    integer_zero_node),\n+      finish_if_stmt_cond (cp_build_binary_op (EQ_EXPR, temp,\n+\t\t\t\t\t       integer_zero_node),\n \t\t\t   if_stmt);\n       then_clause = begin_compound_stmt (/*has_no_scope=*/0);\n \n@@ -9421,10 +9421,10 @@ compute_array_index_type (name, size)\n   /* Compute the index of the largest element in the array.  It is\n      one less than the number of elements in the array.  */\n   itype\n-    = fold (build_binary_op (MINUS_EXPR,\n-\t\t\t     cp_convert (ssizetype, size),\n-\t\t\t     cp_convert (ssizetype,\n-\t\t\t\t\t integer_one_node)));\n+    = fold (cp_build_binary_op (MINUS_EXPR,\n+\t\t\t\tcp_convert (ssizetype, size),\n+\t\t\t\tcp_convert (ssizetype,\n+\t\t\t\t\t    integer_one_node)));\n \n   /* Check for variable-sized arrays.  We allow such things as an\n      extension, even though they are not allowed in ANSI/ISO C++.  */\n@@ -13377,9 +13377,9 @@ build_enumerator (name, value, enumtype)\n \t      /* The next value is the previous value ... */\n \t      prev_value = DECL_INITIAL (TREE_VALUE (TYPE_VALUES (enumtype)));\n \t      /* ... plus one.  */\n-\t      value = build_binary_op (PLUS_EXPR,\n-\t\t\t\t       prev_value,\n-\t\t\t\t       integer_one_node);\n+\t      value = cp_build_binary_op (PLUS_EXPR,\n+\t\t\t\t\t  prev_value,\n+\t\t\t\t\t  integer_one_node);\n \n \t      if (tree_int_cst_lt (value, prev_value))\n \t\tcp_error (\"overflow in enumeration values at `%D'\", name);"}, {"sha": "f21187e92c96ad62af5365017d849dc1a78a8af3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -1266,7 +1266,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n \n   if (doing_vec == 2)\n     {\n-      maxindex = build_binary_op (MINUS_EXPR, size, integer_one_node);\n+      maxindex = cp_build_binary_op (MINUS_EXPR, size, integer_one_node);\n       pedwarn (\"anachronistic use of array size in vector delete\");\n     }\n \n@@ -3248,14 +3248,14 @@ start_static_initialization_or_destruction (decl, initp)\n   /* Conditionalize this initialization on being in the right priority\n      and being initializing/finalizing appropriately.  */\n   sentry_if_stmt = begin_if_stmt ();\n-  cond = build_binary_op (EQ_EXPR,\n-\t\t\t  priority_decl,\n-\t\t\t  build_int_2 (priority, 0));\n+  cond = cp_build_binary_op (EQ_EXPR,\n+\t\t\t     priority_decl,\n+\t\t\t     build_int_2 (priority, 0));\n   init_cond = initp ? integer_one_node : integer_zero_node;\n-  init_cond = build_binary_op (EQ_EXPR,\n-\t\t\t       initialize_p_decl,\n-\t\t\t       init_cond);\n-  cond = build_binary_op (TRUTH_ANDIF_EXPR, cond, init_cond);\n+  init_cond = cp_build_binary_op (EQ_EXPR,\n+\t\t\t\t  initialize_p_decl,\n+\t\t\t\t  init_cond);\n+  cond = cp_build_binary_op (TRUTH_ANDIF_EXPR, cond, init_cond);\n \n   /* We need a sentry if this is an object with external linkage that\n      might be initialized in more than one place.  (For example, a\n@@ -3275,19 +3275,21 @@ start_static_initialization_or_destruction (decl, initp)\n \t only if the SENTRY is one, i.e., if we are the last to\n \t destroy the variable.  */\n       if (initp)\n-\tsentry_cond = build_binary_op (EQ_EXPR,\n-\t\t\t\t       build_unary_op (PREINCREMENT_EXPR,\n-\t\t\t\t\t\t       sentry,\n-\t\t\t\t\t\t       /*noconvert=*/1),\n-\t\t\t\t       integer_one_node);\n+\tsentry_cond \n+\t  = cp_build_binary_op (EQ_EXPR,\n+\t\t\t\tbuild_unary_op (PREINCREMENT_EXPR,\n+\t\t\t\t\t\tsentry,\n+\t\t\t\t\t\t/*noconvert=*/1),\n+\t\t\t\tinteger_one_node);\n       else\n-\tsentry_cond = build_binary_op (EQ_EXPR,\n-\t\t\t\t       build_unary_op (PREDECREMENT_EXPR,\n-\t\t\t\t\t\t       sentry,\n-\t\t\t\t\t\t       /*noconvert=*/1),\n-\t\t\t\t       integer_zero_node);\n-\n-      cond = build_binary_op (TRUTH_ANDIF_EXPR, cond, sentry_cond);\n+\tsentry_cond \n+\t  = cp_build_binary_op (EQ_EXPR,\n+\t\t\t\tbuild_unary_op (PREDECREMENT_EXPR,\n+\t\t\t\t\t\tsentry,\n+\t\t\t\t\t\t/*noconvert=*/1),\n+\t\t\t\tinteger_zero_node);\n+\n+      cond = cp_build_binary_op (TRUTH_ANDIF_EXPR, cond, sentry_cond);\n     }\n \n   finish_if_stmt_cond (cond, sentry_if_stmt);"}, {"sha": "4639ba0facca7f75891c24d3ad080baf443f0b11", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -725,7 +725,7 @@ dump_type_suffix (t, flags)\n \t    dump_expr (TREE_OPERAND (TYPE_MAX_VALUE (TYPE_DOMAIN (t)), 0),\n \t               flags & ~TS_EXPR_PARENS);\n \t  else\n-\t    dump_expr (fold (build_binary_op\n+\t    dump_expr (fold (cp_build_binary_op\n \t\t\t     (PLUS_EXPR, TYPE_MAX_VALUE (TYPE_DOMAIN (t)),\n \t\t\t      integer_one_node)),\n \t               flags & ~TS_EXPR_PARENS);"}, {"sha": "a78da11eca3fe67ea3a930d13b804e2bea711697", "filename": "gcc/cp/init.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -1899,9 +1899,9 @@ resolve_offset_ref (exp)\n \t/* Pointer to data members are offset by one, so that a null\n \t   pointer with a real value of 0 is distinguishable from an\n \t   offset of the first member of a structure.  */\n-\tmember = build_binary_op (MINUS_EXPR, member,\n-\t\t\t\t  cp_convert (ptrdiff_type_node, \n-\t\t\t\t\t      integer_one_node));\n+\tmember = cp_build_binary_op (MINUS_EXPR, member,\n+\t\t\t\t     cp_convert (ptrdiff_type_node, \n+\t\t\t\t\t\t integer_one_node));\n \n       return build1 (INDIRECT_REF, type,\n \t\t     build (PLUS_EXPR, build_pointer_type (type),\n@@ -2047,7 +2047,7 @@ build_new (placement, decl, init, use_global_new)\n \t\t      nelts = integer_zero_node;\n \t\t    }\n \t\t  else\n-\t\t    nelts = build_binary_op (MULT_EXPR, nelts, this_nelts);\n+\t\t    nelts = cp_build_binary_op (MULT_EXPR, nelts, this_nelts);\n \t\t}\n \t    }\n \t  else\n@@ -2258,16 +2258,16 @@ build_new_1 (exp)\n   while (TREE_CODE (true_type) == ARRAY_TYPE)\n     {\n       tree this_nelts = array_type_nelts_top (true_type);\n-      nelts = build_binary_op (MULT_EXPR, nelts, this_nelts);\n+      nelts = cp_build_binary_op (MULT_EXPR, nelts, this_nelts);\n       true_type = TREE_TYPE (true_type);\n     }\n \n   if (!complete_type_or_else (true_type, exp))\n     return error_mark_node;\n \n   if (has_array)\n-    size = fold (build_binary_op (MULT_EXPR, size_in_bytes (true_type),\n-\t\t\t\t  nelts));\n+    size = fold (cp_build_binary_op (MULT_EXPR, size_in_bytes (true_type),\n+\t\t\t\t     nelts));\n   else\n     size = size_in_bytes (type);\n \n@@ -2393,7 +2393,7 @@ build_new_1 (exp)\n     {\n       tree cookie, exp1;\n       rval = convert (string_type_node, rval); /* for ptr arithmetic */\n-      rval = save_expr (build_binary_op (PLUS_EXPR, rval, cookie_size));\n+      rval = save_expr (cp_build_binary_op (PLUS_EXPR, rval, cookie_size));\n       /* Store the number of bytes allocated so that we can know how\n \t many elements to destroy later.  */\n       if (flag_new_abi)\n@@ -2507,7 +2507,7 @@ build_new_1 (exp)\n \trval = (build_vec_init\n \t\t(NULL_TREE, \n \t\t save_expr (rval),\n-\t\t build_binary_op (MINUS_EXPR, nelts, integer_one_node),\n+\t\t cp_build_binary_op (MINUS_EXPR, nelts, integer_one_node),\n \t\t init,\n \t\t /*from_array=*/0));\n \n@@ -2581,8 +2581,8 @@ build_new_1 (exp)\n   if (check_new && alloc_expr)\n     {\n       /* Did we modify the storage?  */\n-      tree ifexp = build_binary_op (NE_EXPR, alloc_node,\n-\t\t\t\t    integer_zero_node);\n+      tree ifexp = cp_build_binary_op (NE_EXPR, alloc_node,\n+\t\t\t\t       integer_zero_node);\n       rval = build_conditional_expr (ifexp, rval, alloc_node);\n     }\n \n@@ -2690,9 +2690,10 @@ build_vec_delete_1 (base, maxindex, type, auto_delete_vec, use_global_delete)\n \t  cookie_size = get_cookie_size (type);\n \t  base_tbd \n \t    = cp_convert (ptype,\n-\t\t\t  build_binary_op (MINUS_EXPR,\n-\t\t\t\t\t   cp_convert (string_type_node, base),\n-\t\t\t\t\t   cookie_size));\n+\t\t\t  cp_build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t      cp_convert (string_type_node, \n+\t\t\t\t\t\t\t  base),\n+\t\t\t\t\t      cookie_size));\n \t  /* True size with header.  */\n \t  virtual_size = size_binop (PLUS_EXPR, virtual_size, cookie_size);\n \t}\n@@ -3052,8 +3053,8 @@ build_vec_init (decl, base, maxindex, init, from_array)\n       finish_compound_stmt (/*has_no_scope=*/1, try_body);\n       finish_cleanup_try_block (try_block);\n       e = build_vec_delete_1 (rval,\n-\t\t\t      build_binary_op (MINUS_EXPR, maxindex, \n-\t\t\t\t\t       iterator),\n+\t\t\t      cp_build_binary_op (MINUS_EXPR, maxindex, \n+\t\t\t\t\t\t  iterator),\n \t\t\t      type,\n \t\t\t      sfk_base_destructor,\n \t\t\t      /*use_global_delete=*/0);\n@@ -3248,7 +3249,7 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \tifexp = integer_one_node;\n       else\n \t/* Handle deleting a null pointer.  */\n-\tifexp = fold (build_binary_op (NE_EXPR, addr, integer_zero_node));\n+\tifexp = fold (cp_build_binary_op (NE_EXPR, addr, integer_zero_node));\n \n       if (ifexp != integer_one_node)\n \texpr = build (COND_EXPR, void_type_node,"}, {"sha": "376d3846e708eed20152177b3d689ab94350571e", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -1217,7 +1217,7 @@ synthesize_tinfo_fn (fndecl)\n   if_stmt = begin_if_stmt ();\n   tmp = cp_convert (build_pointer_type (ptr_type_node), addr);\n   tmp = build_indirect_ref (tmp, 0);\n-  tmp = build_binary_op (EQ_EXPR, tmp, integer_zero_node);\n+  tmp = cp_build_binary_op (EQ_EXPR, tmp, integer_zero_node);\n   finish_if_stmt_cond (tmp, if_stmt);\n   then_clause = begin_compound_stmt (/*has_no_scope=*/0);\n \n@@ -1651,10 +1651,10 @@ synthesize_tinfo_var (target_type, real_name)\n               is_simple = 0;\n               \n               /* combine offset and flags into one field */\n-              offset = build_binary_op (LSHIFT_EXPR, offset,\n-                                        build_int_2 (8, 0));\n-              offset = build_binary_op (BIT_IOR_EXPR, offset,\n-                                        build_int_2 (flags, 0));\n+              offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n+\t\t\t\t\t   build_int_2 (8, 0));\n+              offset = cp_build_binary_op (BIT_IOR_EXPR, offset,\n+\t\t\t\t\t   build_int_2 (flags, 0));\n               base_init = tree_cons (NULL_TREE, offset, base_init);\n               base_init = tree_cons (NULL_TREE, tinfo, base_init);\n               base_init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, base_init);"}, {"sha": "e0a42a23063d9f3e728ea591f69a4eaac391b990", "filename": "gcc/cp/search.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -2664,8 +2664,8 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n \n \t  /* This is a upcast, so we have to add the offset for the\n \t     virtual base.  */\n-\t  old_delta = build_binary_op (PLUS_EXPR, old_delta,\n-\t\t\t\t       TREE_VALUE (delta));\n+\t  old_delta = cp_build_binary_op (PLUS_EXPR, old_delta,\n+\t\t\t\t\t  TREE_VALUE (delta));\n \t  if (vc)\n \t    {\n \t      /* If this is set, we need to subtract out the delta\n@@ -2689,7 +2689,7 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n    \n \t      /* This is a downcast, so we have to subtract the offset\n \t\t for the virtual base.  */\n-\t      old_delta = build_binary_op (MINUS_EXPR, old_delta, vc_delta);\n+\t      old_delta = cp_build_binary_op (MINUS_EXPR, old_delta, vc_delta);\n \t    }\n \n \t  TREE_READONLY (new_delta) = 0;\n@@ -2758,8 +2758,8 @@ fixup_all_virtual_upcast_offsets (decl_ptr)\n   if (!in_charge_node)\n     /* There's no need for any fixups in this case.  */\n     return;\n-  in_charge_node = build_binary_op (EQ_EXPR, \n-\t\t\t\t    in_charge_node, integer_zero_node);\n+  in_charge_node = cp_build_binary_op (EQ_EXPR, \n+\t\t\t\t       in_charge_node, integer_zero_node);\n   if_stmt = begin_if_stmt ();\n   finish_if_stmt_cond (in_charge_node, if_stmt);\n   "}, {"sha": "d84d4d6c6254a695d25dd409bc1495c37ed47859", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab76ca54bb48c62ce6d9faf6097344692baf0519/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ab76ca54bb48c62ce6d9faf6097344692baf0519", "patch": "@@ -2502,7 +2502,7 @@ build_array_ref (array, idx)\n \treturn error_mark_node;\n       }\n \n-    return build_indirect_ref (build_binary_op (PLUS_EXPR, ar, ind),\n+    return build_indirect_ref (cp_build_binary_op (PLUS_EXPR, ar, ind),\n \t\t\t       \"array indexing\");\n   }\n }\n@@ -2853,21 +2853,21 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t easier to make this change.  */\n       if (flag_new_abi)\n \t{\n-\t  idx = build_binary_op (TRUNC_DIV_EXPR, \n-\t\t\t\t build1 (NOP_EXPR, vtable_index_type, e3),\n-\t\t\t\t TYPE_SIZE_UNIT (vtable_entry_type));\n-\t  e1 = build_binary_op (BIT_AND_EXPR,\n-\t\t\t\tbuild1 (NOP_EXPR, vtable_index_type, e3),\n-\t\t\t\tinteger_one_node);\n+\t  idx = cp_build_binary_op (TRUNC_DIV_EXPR, \n+\t\t\t\t    build1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t\t    TYPE_SIZE_UNIT (vtable_entry_type));\n+\t  e1 = cp_build_binary_op (BIT_AND_EXPR,\n+\t\t\t\t   build1 (NOP_EXPR, vtable_index_type, e3),\n+\t\t\t\t   integer_one_node);\n \t}\n       else\n \t{\n \t  idx = save_expr (default_conversion\n \t\t       (build_component_ref (function,\n \t\t\t\t\t     index_identifier,\n \t\t\t\t\t     NULL_TREE, 0)));\n-\t  e1 = build_binary_op (GE_EXPR, idx, integer_zero_node);\n-\t  idx = build_binary_op (MINUS_EXPR, idx, integer_one_node);\n+\t  e1 = cp_build_binary_op (GE_EXPR, idx, integer_zero_node);\n+\t  idx = cp_build_binary_op (MINUS_EXPR, idx, integer_one_node);\n \t}\n \n       vtbl = convert_pointer_to (ptr_type_node, instance);\n@@ -2891,7 +2891,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t{\n \t  aref = save_expr (aref);\n \t  \n-\t  delta = build_binary_op\n+\t  delta = cp_build_binary_op\n \t    (PLUS_EXPR,\n \t     build_conditional_expr (e1,\n \t\t\t\t     build_component_ref (aref,\n@@ -3269,9 +3269,10 @@ build_x_binary_op (code, arg1, arg2)\n    multiple inheritance, and deal with pointer to member functions.  */\n \n tree\n-build_binary_op (code, orig_op0, orig_op1)\n+build_binary_op (code, orig_op0, orig_op1, convert_p)\n      enum tree_code code;\n      tree orig_op0, orig_op1;\n+     int convert_p ATTRIBUTE_UNUSED;\n {\n   tree op0, op1;\n   register enum tree_code code0, code1;\n@@ -3633,7 +3634,7 @@ build_binary_op (code, orig_op0, orig_op1)\n \t  result_type = TREE_TYPE (op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type1) && null_ptr_cst_p (op0))\n-\treturn build_binary_op (code, op1, op0);\n+\treturn cp_build_binary_op (code, op1, op0);\n       else if (TYPE_PTRMEMFUNC_P (type0) && TYPE_PTRMEMFUNC_P (type1)\n \t       && same_type_p (type0, type1))\n \t{\n@@ -3664,14 +3665,14 @@ build_binary_op (code, orig_op0, orig_op1)\n \t\t\t\t\t    NULL_TREE, 0);\n \t      delta1 = build_component_ref (op1, delta_identifier,\n \t\t\t\t\t    NULL_TREE, 0);\n-\t      e1 = build_binary_op (EQ_EXPR, delta0, delta1);\n-\t      e2 = build_binary_op (NE_EXPR, \n-\t\t\t\t    pfn0,\n-\t\t\t\t    cp_convert (TREE_TYPE (pfn0),\n-\t\t\t\t\t\tinteger_zero_node));\n-\t      e1 = build_binary_op (TRUTH_ORIF_EXPR, e1, e2);\n+\t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n+\t      e2 = cp_build_binary_op (NE_EXPR, \n+\t\t\t\t       pfn0,\n+\t\t\t\t       cp_convert (TREE_TYPE (pfn0),\n+\t\t\t\t\t\t   integer_zero_node));\n+\t      e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2);\n \t      e2 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n-\t      e = build_binary_op (TRUTH_ANDIF_EXPR, e2, e1);\n+\t      e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1);\n \t    }\n \t  else\n \t    {\n@@ -3691,21 +3692,23 @@ build_binary_op (code, orig_op0, orig_op1)\n \t      tree delta21 = DELTA2_FROM_PTRMEMFUNC (op1);\n \t      tree e3;\n \t      tree integer_neg_one_node\n-\t\t= build_binary_op (MINUS_EXPR, integer_zero_node,\n-\t\t\t\t   integer_one_node);\n-\t      e1 = build_binary_op (EQ_EXPR, index0, index1);\n-\t      e2 = build_binary_op (NE_EXPR, index1, integer_neg_one_node);\n-\t      e2 = build_binary_op (TRUTH_ANDIF_EXPR, e2,\n-\t\t\t\t    build_binary_op (EQ_EXPR, delta20, delta21));\n-\t      /* We can't use build_binary_op for this cmp because it would get\n-\t     confused by the ptr to method types and think we want pmfs.  */\n+\t\t= cp_build_binary_op (MINUS_EXPR, integer_zero_node,\n+\t\t\t\t      integer_one_node);\n+\t      e1 = cp_build_binary_op (EQ_EXPR, index0, index1);\n+\t      e2 = cp_build_binary_op (NE_EXPR, index1, integer_neg_one_node);\n+\t      e2 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2,\n+\t\t\t\t       cp_build_binary_op (EQ_EXPR, \n+\t\t\t\t\t\t\t   delta20, delta21));\n+\t      /* We can't use build_binary_op for this cmp because it\n+\t\t would get confused by the ptr to method types and\n+\t\t think we want pmfs.  */\n \t      e3 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n-\t      e2 = build_binary_op (TRUTH_ORIF_EXPR, e2, e3);\n-\t      e = build_binary_op (TRUTH_ANDIF_EXPR, e1, e2);\n+\t      e2 = cp_build_binary_op (TRUTH_ORIF_EXPR, e2, e3);\n+\t      e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e1, e2);\n \t    }\n \t  if (code == EQ_EXPR)\n \t    return e;\n-\t  return build_binary_op (EQ_EXPR, e, integer_zero_node);\n+\t  return cp_build_binary_op (EQ_EXPR, e, integer_zero_node);\n \t}\n       else if ((TYPE_PTRMEMFUNC_P (type0)\n \t\t&& same_type_p (TYPE_PTRMEMFUNC_FN_TYPE (type0), type1))\n@@ -4161,7 +4164,7 @@ pointer_int_sum (resultcode, ptrop, intop)\n       enum tree_code subcode = resultcode;\n       if (TREE_CODE (intop) == MINUS_EXPR)\n \tsubcode = (subcode == PLUS_EXPR ? MINUS_EXPR : PLUS_EXPR);\n-      ptrop = build_binary_op (subcode, ptrop, TREE_OPERAND (intop, 1));\n+      ptrop = cp_build_binary_op (subcode, ptrop, TREE_OPERAND (intop, 1));\n       intop = TREE_OPERAND (intop, 0);\n     }\n \n@@ -4176,9 +4179,9 @@ pointer_int_sum (resultcode, ptrop, intop)\n      pointer type (actually unsigned integral).  */\n \n   intop = cp_convert (result_type,\n-\t\t      build_binary_op (MULT_EXPR, intop,\n-\t\t\t\t       cp_convert (TREE_TYPE (intop),\n-\t\t\t\t\t\t   size_exp)));\n+\t\t      cp_build_binary_op (MULT_EXPR, intop,\n+\t\t\t\t\t  cp_convert (TREE_TYPE (intop),\n+\t\t\t\t\t\t      size_exp)));\n \n   /* Create the sum or difference.  */\n \n@@ -4220,8 +4223,9 @@ pointer_diff (op0, op1, ptrtype)\n   /* First do the subtraction as integers;\n      then drop through to build the divide operator.  */\n \n-  op0 = build_binary_op (MINUS_EXPR, cp_convert (restype, op0),\n-\t\t\t cp_convert (restype, op1));\n+  op0 = cp_build_binary_op (MINUS_EXPR, \n+\t\t\t    cp_convert (restype, op0),\n+\t\t\t    cp_convert (restype, op1));\n \n   /* This generates an error if op1 is a pointer to an incomplete type.  */\n   if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (op1))))\n@@ -4652,8 +4656,8 @@ build_unary_op (code, xarg, noconvert)\n \t{\n \t  if (mark_addressable (TREE_OPERAND (arg, 0)) == 0)\n \t    return error_mark_node;\n-\t  return build_binary_op (PLUS_EXPR, TREE_OPERAND (arg, 0),\n-\t\t\t\t  TREE_OPERAND (arg, 1));\n+\t  return cp_build_binary_op (PLUS_EXPR, TREE_OPERAND (arg, 0),\n+\t\t\t\t     TREE_OPERAND (arg, 1));\n \t}\n \n       /* Uninstantiated types are all functions.  Taking the\n@@ -5692,7 +5696,7 @@ build_modify_expr (lhs, modifycode, rhs)\n   else\n     {\n       lhs = stabilize_reference (lhs);\n-      newrhs = build_binary_op (modifycode, lhs, rhs);\n+      newrhs = cp_build_binary_op (modifycode, lhs, rhs);\n       if (newrhs == error_mark_node)\n \t{\n \t  cp_error (\"  in evaluation of `%Q(%#T, %#T)'\", modifycode,\n@@ -6016,9 +6020,9 @@ get_delta_difference (from, to, force)\n       delta = BINFO_OFFSET (binfo);\n       delta = cp_convert (ptrdiff_type_node, delta);\n       \n-      return build_binary_op (MINUS_EXPR,\n-\t\t\t      integer_zero_node,\n-\t\t\t      delta);\n+      return cp_build_binary_op (MINUS_EXPR,\n+\t\t\t\t integer_zero_node,\n+\t\t\t\t delta);\n     }\n \n   if (binfo_from_vbase (binfo))\n@@ -6184,7 +6188,7 @@ build_ptrmemfunc (type, pfn, force)\n \t  n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n \t\t\t\t    TYPE_PTRMEMFUNC_OBJECT_TYPE (to_type),\n \t\t\t\t    force);\n-\t  delta = build_binary_op (PLUS_EXPR, delta, n);\n+\t  delta = cp_build_binary_op (PLUS_EXPR, delta, n);\n \t  return build_ptrmemfunc1 (to_type, delta, NULL_TREE, npfn,\n \t\t\t\t    NULL_TREE);\n \t}\n@@ -6215,8 +6219,8 @@ build_ptrmemfunc (type, pfn, force)\n       n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n \t\t\t\tTYPE_PTRMEMFUNC_OBJECT_TYPE (to_type),\n \t\t\t\tforce);\n-      delta = build_binary_op (PLUS_EXPR, ndelta, n);\n-      delta2 = build_binary_op (PLUS_EXPR, ndelta2, n);\n+      delta = cp_build_binary_op (PLUS_EXPR, ndelta, n);\n+      delta2 = cp_build_binary_op (PLUS_EXPR, ndelta2, n);\n       e1 = fold (build (GT_EXPR, boolean_type_node, idx, integer_zero_node));\n \t  \n       /* If it's a virtual function, this is what we want.  */"}]}