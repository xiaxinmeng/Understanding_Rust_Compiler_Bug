{"sha": "2b3d67a55b8f6589dd52eea452e464c628d20bdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIzZDY3YTU1YjhmNjU4OWRkNTJlZWE0NTJlNDY0YzYyOGQyMGJkZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T09:04:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-11T09:04:40Z"}, "message": "[multiple changes]\n\n2010-10-11  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_prag.adb, sem_aggr.adb, sprint.adb: Minor reformatting.\n\n2010-10-11  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch5.ads, exp_ch6.ads (Expand_N_Extended_Return_Statement): Moved\n\tto exp_ch6.\n\t(Expand_N_Simple_Return_Statement): Moved to exp_ch6.\n\t* exp_ch5.adb, exp_ch6.adb (Expand_Non_Function_Return): Moved to\n\texp_ch6.\n\t(Expand_Simple_Function_Return): Move to exp_ch6.\n\t(Expand_N_Extended_Return_Statement): Moved to exp_ch6.\n\t(Expand_N_Simple_Return_Statement): Moved to exp_ch6.\n\n2010-10-11  Robert Dewar  <dewar@adacore.com>\n\n\t* snames.ads-tmpl: Add names for aspects.\n\t* aspects.ads, aspects.adb: New.\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\nFrom-SVN: r165281", "tree": {"sha": "04579e5de4cf8cf5f0426dbd1e60ff0cbd0869be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04579e5de4cf8cf5f0426dbd1e60ff0cbd0869be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b3d67a55b8f6589dd52eea452e464c628d20bdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3d67a55b8f6589dd52eea452e464c628d20bdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b3d67a55b8f6589dd52eea452e464c628d20bdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b3d67a55b8f6589dd52eea452e464c628d20bdf/comments", "author": null, "committer": null, "parents": [{"sha": "fb468a944c0dae2086e811b18d2da7935f642fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb468a944c0dae2086e811b18d2da7935f642fc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb468a944c0dae2086e811b18d2da7935f642fc5"}], "stats": {"total": 3477, "additions": 1891, "deletions": 1586}, "files": [{"sha": "1c548973c67e9808b5fa1a263c0aa17229ae9c31", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -1,3 +1,23 @@\n+2010-10-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_prag.adb, sem_aggr.adb, sprint.adb: Minor reformatting.\n+\n+2010-10-11  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch5.ads, exp_ch6.ads (Expand_N_Extended_Return_Statement): Moved\n+\tto exp_ch6.\n+\t(Expand_N_Simple_Return_Statement): Moved to exp_ch6.\n+\t* exp_ch5.adb, exp_ch6.adb (Expand_Non_Function_Return): Moved to\n+\texp_ch6.\n+\t(Expand_Simple_Function_Return): Move to exp_ch6.\n+\t(Expand_N_Extended_Return_Statement): Moved to exp_ch6.\n+\t(Expand_N_Simple_Return_Statement): Moved to exp_ch6.\n+\n+2010-10-11  Robert Dewar  <dewar@adacore.com>\n+\n+\t* snames.ads-tmpl: Add names for aspects.\n+\t* aspects.ads, aspects.adb: New.\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n 2010-10-11  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_ch6.adb (Expand_Actuals): If an actual is the current instance of"}, {"sha": "a0382e788f427ff1f4a692610af1f65b4cc2ccf9", "filename": "gcc/ada/aspects.adb", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Faspects.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Faspects.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.adb?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -0,0 +1,104 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              A S P E C T S                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2010, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Snames; use Snames;\n+\n+package body Aspects is\n+\n+   type Aspect_Entry is record\n+      Nam : Name_Id;\n+      Asp : Aspect_Id;\n+   end record;\n+\n+   Aspect_Names : constant array (Integer range <>) of Aspect_Entry := (\n+     (Name_Ada_2005,                     Aspect_Ada_2005),\n+     (Name_Ada_2012,                     Aspect_Ada_2012),\n+     (Name_Address,                      Aspect_Address),\n+     (Name_Aliased,                      Aspect_Aliased),\n+     (Name_Alignment,                    Aspect_Alignment),\n+     (Name_Atomic,                       Aspect_Atomic),\n+     (Name_Atomic_Components,            Aspect_Atomic_Components),\n+     (Name_Bit_Order,                    Aspect_Bit_Order),\n+     (Name_C_Pass_By_Copy,               Aspect_C_Pass_By_Copy),\n+     (Name_Component_Size,               Aspect_Component_Size),\n+     (Name_Discard_Names,                Aspect_Discard_Names),\n+     (Name_External_Tag,                 Aspect_External_Tag),\n+     (Name_Favor_Top_Level,              Aspect_Favor_Top_Level),\n+     (Name_Inline,                       Aspect_Inline),\n+     (Name_Inline_Always,                Aspect_Inline_Always),\n+     (Name_Invariant,                    Aspect_Invariant),\n+     (Name_Machine_Radix,                Aspect_Machine_Radix),\n+     (Name_Object_Size,                  Aspect_Object_Size),\n+     (Name_Pack,                         Aspect_Pack),\n+     (Name_Persistent_BSS,               Aspect_Persistent_BSS),\n+     (Name_Post,                         Aspect_Post),\n+     (Name_Postcondition,                Aspect_Postcondition),\n+     (Name_Pre,                          Aspect_Pre),\n+     (Name_Precondition,                 Aspect_Precondition),\n+     (Name_Predicate,                    Aspect_Predicate),\n+     (Name_Preelaborable_Initialization, Aspect_Preelaborable_Initialization),\n+     (Name_Psect_Object,                 Aspect_Psect_Object),\n+     (Name_Pure_Function,                Aspect_Pure_Function),\n+     (Name_Shared,                       Aspect_Shared),\n+     (Name_Size,                         Aspect_Size),\n+     (Name_Storage_Pool,                 Aspect_Storage_Pool),\n+     (Name_Storage_Size,                 Aspect_Storage_Size),\n+     (Name_Stream_Size,                  Aspect_Stream_Size),\n+     (Name_Suppress,                     Aspect_Suppress),\n+     (Name_Suppress_Debug_Info,          Aspect_Suppress_Debug_Info),\n+     (Name_Unchecked_Union,              Aspect_Unchecked_Union),\n+     (Name_Universal_Aliasing,           Aspect_Universal_Aliasing),\n+     (Name_Unmodified,                   Aspect_Unmodified),\n+     (Name_Unreferenced,                 Aspect_Unreferenced),\n+     (Name_Unreferenced_Objects,         Aspect_Unreferenced_Objects),\n+     (Name_Unsuppress,                   Aspect_Unsuppress),\n+     (Name_Value_Size,                   Aspect_Value_Size),\n+     (Name_Volatile,                     Aspect_Volatile),\n+     (Name_Volatile_Components,          Aspect_Volatile_Components),\n+     (Name_Warnings,                     Aspect_Warnings),\n+     (Name_Weak_External,                Aspect_Weak_External));\n+\n+   -------------------\n+   -- Get_Aspect_Id --\n+   -------------------\n+\n+   function Get_Aspect_Id (Name : Name_Id) return Aspect_Id is\n+   begin\n+      for J in Aspect_Names'Range loop\n+         if Aspect_Names (J).Nam = Name then\n+            return Aspect_Names (J).Asp;\n+         end if;\n+      end loop;\n+\n+      return No_Aspect;\n+   end Get_Aspect_Id;\n+\n+end Aspects;"}, {"sha": "ac9e231de576b1cf2e1a138905c23243df7ba374", "filename": "gcc/ada/aspects.ads", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -0,0 +1,161 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              A S P E C T S                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2010, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package defines the aspects that are recognized in aspect\n+--  specifications. We separate this off in its own packages to that\n+--  it can be accessed by the parser without dragging in Sem_Asp\n+\n+with Namet; use Namet;\n+\n+package Aspects is\n+\n+   type Aspect_Id is\n+     (No_Aspect,                            -- Dummy entry for no aspect\n+      Aspect_Ada_2005,                      -- GNAT\n+      Aspect_Ada_2012,                      -- GNAT\n+      Aspect_Address,\n+      Aspect_Aliased,\n+      Aspect_Alignment,\n+      Aspect_Atomic,\n+      Aspect_Atomic_Components,\n+      Aspect_Bit_Order,\n+      Aspect_C_Pass_By_Copy,\n+      Aspect_Component_Size,\n+      Aspect_Discard_Names,\n+      Aspect_External_Tag,\n+      Aspect_Favor_Top_Level,               -- GNAT\n+      Aspect_Inline,\n+      Aspect_Inline_Always,                 -- GNAT\n+      Aspect_Invariant,\n+      Aspect_Machine_Radix,\n+      Aspect_Object_Size,                   -- GNAT\n+      Aspect_Pack,\n+      Aspect_Persistent_BSS,                -- GNAT\n+      Aspect_Post,\n+      Aspect_Postcondition,                 -- GNAT (equivalent to Post)\n+      Aspect_Pre,\n+      Aspect_Precondition,                  -- GNAT (equivalent to Pre)\n+      Aspect_Predicate,                     -- GNAT???\n+      Aspect_Preelaborable_Initialization,\n+      Aspect_Psect_Object,                  -- GNAT\n+      Aspect_Pure_Function,                 -- GNAT\n+      Aspect_Shared,                        -- GNAT (equivalent to Atomic)\n+      Aspect_Size,\n+      Aspect_Storage_Pool,\n+      Aspect_Storage_Size,\n+      Aspect_Stream_Size,\n+      Aspect_Suppress,\n+      Aspect_Suppress_Debug_Info,           -- GNAT\n+      Aspect_Unchecked_Union,\n+      Aspect_Universal_Aliasing,            -- GNAT\n+      Aspect_Unmodified,                    -- GNAT\n+      Aspect_Unreferenced,                  -- GNAT\n+      Aspect_Unreferenced_Objects,          -- GNAT\n+      Aspect_Unsuppress,\n+      Aspect_Value_Size,                    -- GNAT\n+      Aspect_Volatile,\n+      Aspect_Volatile_Components,\n+      Aspect_Warnings,                      -- GNAT\n+      Aspect_Weak_External);                -- GNAT\n+\n+   --  The following array indicates aspects that accept 'Class\n+\n+   Class_Aspect_OK : constant array (Aspect_Id) of Boolean :=\n+                       (Aspect_Invariant     => True,\n+                        Aspect_Pre           => True,\n+                        Aspect_Precondition  => True,\n+                        Aspect_Post          => True,\n+                        Aspect_Postcondition => True,\n+                        others               => False);\n+\n+   --  The following type is used for indicating allowed expression forms\n+\n+   type Aspect_Expression is\n+     (Optional,               -- Optional boolean expression\n+      Expression,             -- Required non-boolean expression\n+      Name);                  -- Required name\n+\n+   --  The following array indicates what argument type is required\n+\n+   Aspect_Argument : constant array (Aspect_Id) of Aspect_Expression :=\n+                       (No_Aspect                           => Optional,\n+                        Aspect_Ada_2005                     => Optional,\n+                        Aspect_Ada_2012                     => Optional,\n+                        Aspect_Address                      => Expression,\n+                        Aspect_Aliased                      => Optional,\n+                        Aspect_Alignment                    => Expression,\n+                        Aspect_Atomic                       => Optional,\n+                        Aspect_Atomic_Components            => Optional,\n+                        Aspect_Bit_Order                    => Expression,\n+                        Aspect_C_Pass_By_Copy               => Optional,\n+                        Aspect_Component_Size               => Expression,\n+                        Aspect_Discard_Names                => Optional,\n+                        Aspect_External_Tag                 => Expression,\n+                        Aspect_Favor_Top_Level              => Optional,\n+                        Aspect_Inline                       => Optional,\n+                        Aspect_Inline_Always                => Optional,\n+                        Aspect_Invariant                    => Expression,\n+                        Aspect_Machine_Radix                => Expression,\n+                        Aspect_Object_Size                  => Expression,\n+                        Aspect_Pack                         => Optional,\n+                        Aspect_Persistent_BSS               => Optional,\n+                        Aspect_Post                         => Expression,\n+                        Aspect_Postcondition                => Expression,\n+                        Aspect_Pre                          => Expression,\n+                        Aspect_Precondition                 => Expression,\n+                        Aspect_Predicate                    => Expression,\n+                        Aspect_Preelaborable_Initialization => Optional,\n+                        Aspect_Psect_Object                 => Optional,\n+                        Aspect_Pure_Function                => Optional,\n+                        Aspect_Shared                       => Optional,\n+                        Aspect_Size                         => Expression,\n+                        Aspect_Storage_Pool                 => Expression,\n+                        Aspect_Storage_Size                 => Expression,\n+                        Aspect_Stream_Size                  => Expression,\n+                        Aspect_Suppress                     => Name,\n+                        Aspect_Suppress_Debug_Info          => Optional,\n+                        Aspect_Unchecked_Union              => Optional,\n+                        Aspect_Universal_Aliasing           => Optional,\n+                        Aspect_Unmodified                   => Optional,\n+                        Aspect_Unreferenced                 => Optional,\n+                        Aspect_Unreferenced_Objects         => Optional,\n+                        Aspect_Unsuppress                   => Name,\n+                        Aspect_Value_Size                   => Expression,\n+                        Aspect_Volatile                     => Optional,\n+                        Aspect_Volatile_Components          => Optional,\n+                        Aspect_Warnings                     => Name,\n+                        Aspect_Weak_External                => Optional);\n+\n+   function Get_Aspect_Id (Name : Name_Id) return Aspect_Id;\n+   --  Given a name Nam, returns the corresponding aspect id value. If the name\n+   --  does not match any aspect, then No_Aspect is returned as the result.\n+\n+end Aspects;"}, {"sha": "6ca2c8c8f3f5f4272871d872d825dda8a5966504", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 0, "deletions": 1488, "changes": 1488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -27,7 +27,6 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n-with Exp_Atag; use Exp_Atag;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n@@ -104,16 +103,6 @@ package body Exp_Ch5 is\n    --  clause (this last case is required because holes in the tagged type\n    --  might be filled with components from child types).\n \n-   procedure Expand_Non_Function_Return (N : Node_Id);\n-   --  Called by Expand_N_Simple_Return_Statement in case we're returning from\n-   --  a procedure body, entry body, accept statement, or extended return\n-   --  statement.  Note that all non-function returns are simple return\n-   --  statements.\n-\n-   procedure Expand_Simple_Function_Return (N : Node_Id);\n-   --  Expand simple return from function. In the case where we are returning\n-   --  from a function body this is called by Expand_N_Simple_Return_Statement.\n-\n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n    --  Generate the necessary code for controlled and tagged assignment, that\n    --  is to say, finalization of the target before, adjustment of the target\n@@ -2450,728 +2439,6 @@ package body Exp_Ch5 is\n       Adjust_Condition (Condition (N));\n    end Expand_N_Exit_Statement;\n \n-   ----------------------------------------\n-   -- Expand_N_Extended_Return_Statement --\n-   ----------------------------------------\n-\n-   --  If there is a Handled_Statement_Sequence, we rewrite this:\n-\n-   --     return Result : T := <expression> do\n-   --        <handled_seq_of_stms>\n-   --     end return;\n-\n-   --  to be:\n-\n-   --     declare\n-   --        Result : T := <expression>;\n-   --     begin\n-   --        <handled_seq_of_stms>\n-   --        return Result;\n-   --     end;\n-\n-   --  Otherwise (no Handled_Statement_Sequence), we rewrite this:\n-\n-   --     return Result : T := <expression>;\n-\n-   --  to be:\n-\n-   --     return <expression>;\n-\n-   --  unless it's build-in-place or there's no <expression>, in which case\n-   --  we generate:\n-\n-   --     declare\n-   --        Result : T := <expression>;\n-   --     begin\n-   --        return Result;\n-   --     end;\n-\n-   --  Note that this case could have been written by the user as an extended\n-   --  return statement, or could have been transformed to this from a simple\n-   --  return statement.\n-\n-   --  That is, we need to have a reified return object if there are statements\n-   --  (which might refer to it) or if we're doing build-in-place (so we can\n-   --  set its address to the final resting place or if there is no expression\n-   --  (in which case default initial values might need to be set).\n-\n-   procedure Expand_N_Extended_Return_Statement (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-\n-      Return_Object_Entity : constant Entity_Id :=\n-                               First_Entity (Return_Statement_Entity (N));\n-      Return_Object_Decl   : constant Node_Id :=\n-                               Parent (Return_Object_Entity);\n-      Parent_Function      : constant Entity_Id :=\n-                               Return_Applies_To (Return_Statement_Entity (N));\n-      Parent_Function_Typ  : constant Entity_Id := Etype (Parent_Function);\n-      Is_Build_In_Place    : constant Boolean :=\n-                               Is_Build_In_Place_Function (Parent_Function);\n-\n-      Return_Stm      : Node_Id;\n-      Statements      : List_Id;\n-      Handled_Stm_Seq : Node_Id;\n-      Result          : Node_Id;\n-      Exp             : Node_Id;\n-\n-      function Has_Controlled_Parts (Typ : Entity_Id) return Boolean;\n-      --  Determine whether type Typ is controlled or contains a controlled\n-      --  subcomponent.\n-\n-      function Move_Activation_Chain return Node_Id;\n-      --  Construct a call to System.Tasking.Stages.Move_Activation_Chain\n-      --  with parameters:\n-      --    From         current activation chain\n-      --    To           activation chain passed in by the caller\n-      --    New_Master   master passed in by the caller\n-\n-      function Move_Final_List return Node_Id;\n-      --  Construct call to System.Finalization_Implementation.Move_Final_List\n-      --  with parameters:\n-      --\n-      --    From         finalization list of the return statement\n-      --    To           finalization list passed in by the caller\n-\n-      --------------------------\n-      -- Has_Controlled_Parts --\n-      --------------------------\n-\n-      function Has_Controlled_Parts (Typ : Entity_Id) return Boolean is\n-      begin\n-         return\n-           Is_Controlled (Typ)\n-             or else Has_Controlled_Component (Typ);\n-      end Has_Controlled_Parts;\n-\n-      ---------------------------\n-      -- Move_Activation_Chain --\n-      ---------------------------\n-\n-      function Move_Activation_Chain return Node_Id is\n-         Activation_Chain_Formal : constant Entity_Id :=\n-                                     Build_In_Place_Formal\n-                                       (Parent_Function, BIP_Activation_Chain);\n-         To                      : constant Node_Id :=\n-                                     New_Reference_To\n-                                       (Activation_Chain_Formal, Loc);\n-         Master_Formal           : constant Entity_Id :=\n-                                     Build_In_Place_Formal\n-                                       (Parent_Function, BIP_Master);\n-         New_Master              : constant Node_Id :=\n-                                     New_Reference_To (Master_Formal, Loc);\n-\n-         Chain_Entity : Entity_Id;\n-         From         : Node_Id;\n-\n-      begin\n-         Chain_Entity := First_Entity (Return_Statement_Entity (N));\n-         while Chars (Chain_Entity) /= Name_uChain loop\n-            Chain_Entity := Next_Entity (Chain_Entity);\n-         end loop;\n-\n-         From :=\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Reference_To (Chain_Entity, Loc),\n-             Attribute_Name => Name_Unrestricted_Access);\n-         --  ??? Not clear why \"Make_Identifier (Loc, Name_uChain)\" doesn't\n-         --  work, instead of \"New_Reference_To (Chain_Entity, Loc)\" above.\n-\n-         return\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Reference_To (RTE (RE_Move_Activation_Chain), Loc),\n-             Parameter_Associations => New_List (From, To, New_Master));\n-      end Move_Activation_Chain;\n-\n-      ---------------------\n-      -- Move_Final_List --\n-      ---------------------\n-\n-      function Move_Final_List return Node_Id is\n-         Flist : constant Entity_Id  :=\n-                   Finalization_Chain_Entity (Return_Statement_Entity (N));\n-\n-         From : constant Node_Id := New_Reference_To (Flist, Loc);\n-\n-         Caller_Final_List : constant Entity_Id :=\n-                               Build_In_Place_Formal\n-                                 (Parent_Function, BIP_Final_List);\n-\n-         To : constant Node_Id := New_Reference_To (Caller_Final_List, Loc);\n-\n-      begin\n-         --  Catch cases where a finalization chain entity has not been\n-         --  associated with the return statement entity.\n-\n-         pragma Assert (Present (Flist));\n-\n-         --  Build required call\n-\n-         return\n-           Make_If_Statement (Loc,\n-             Condition =>\n-               Make_Op_Ne (Loc,\n-                 Left_Opnd  => New_Copy (From),\n-                 Right_Opnd => New_Node (N_Null, Loc)),\n-             Then_Statements =>\n-               New_List (\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Reference_To (RTE (RE_Move_Final_List), Loc),\n-                   Parameter_Associations => New_List (From, To))));\n-      end Move_Final_List;\n-\n-   --  Start of processing for Expand_N_Extended_Return_Statement\n-\n-   begin\n-      if Nkind (Return_Object_Decl) = N_Object_Declaration then\n-         Exp := Expression (Return_Object_Decl);\n-      else\n-         Exp := Empty;\n-      end if;\n-\n-      Handled_Stm_Seq := Handled_Statement_Sequence (N);\n-\n-      --  Build a simple_return_statement that returns the return object when\n-      --  there is a statement sequence, or no expression, or the result will\n-      --  be built in place. Note however that we currently do this for all\n-      --  composite cases, even though nonlimited composite results are not yet\n-      --  built in place (though we plan to do so eventually).\n-\n-      if Present (Handled_Stm_Seq)\n-        or else Is_Composite_Type (Etype (Parent_Function))\n-        or else No (Exp)\n-      then\n-         if No (Handled_Stm_Seq) then\n-            Statements := New_List;\n-\n-         --  If the extended return has a handled statement sequence, then wrap\n-         --  it in a block and use the block as the first statement.\n-\n-         else\n-            Statements :=\n-              New_List (Make_Block_Statement (Loc,\n-                          Declarations => New_List,\n-                          Handled_Statement_Sequence => Handled_Stm_Seq));\n-         end if;\n-\n-         --  If control gets past the above Statements, we have successfully\n-         --  completed the return statement. If the result type has controlled\n-         --  parts and the return is for a build-in-place function, then we\n-         --  call Move_Final_List to transfer responsibility for finalization\n-         --  of the return object to the caller. An alternative would be to\n-         --  declare a Success flag in the function, initialize it to False,\n-         --  and set it to True here. Then move the Move_Final_List call into\n-         --  the cleanup code, and check Success. If Success then make a call\n-         --  to Move_Final_List else do finalization. Then we can remove the\n-         --  abort-deferral and the nulling-out of the From parameter from\n-         --  Move_Final_List. Note that the current method is not quite correct\n-         --  in the rather obscure case of a select-then-abort statement whose\n-         --  abortable part contains the return statement.\n-\n-         --  Check the type of the function to determine whether to move the\n-         --  finalization list. A special case arises when processing a simple\n-         --  return statement which has been rewritten as an extended return.\n-         --  In that case check the type of the returned object or the original\n-         --  expression.\n-\n-         if Is_Build_In_Place\n-           and then\n-               (Has_Controlled_Parts (Parent_Function_Typ)\n-                 or else (Is_Class_Wide_Type (Parent_Function_Typ)\n-                           and then\n-                        Has_Controlled_Parts (Root_Type (Parent_Function_Typ)))\n-                 or else Has_Controlled_Parts (Etype (Return_Object_Entity))\n-                 or else (Present (Exp)\n-                           and then Has_Controlled_Parts (Etype (Exp))))\n-         then\n-            Append_To (Statements, Move_Final_List);\n-         end if;\n-\n-         --  Similarly to the above Move_Final_List, if the result type\n-         --  contains tasks, we call Move_Activation_Chain. Later, the cleanup\n-         --  code will call Complete_Master, which will terminate any\n-         --  unactivated tasks belonging to the return statement master. But\n-         --  Move_Activation_Chain updates their master to be that of the\n-         --  caller, so they will not be terminated unless the return statement\n-         --  completes unsuccessfully due to exception, abort, goto, or exit.\n-         --  As a formality, we test whether the function requires the result\n-         --  to be built in place, though that's necessarily true for the case\n-         --  of result types with task parts.\n-\n-         if Is_Build_In_Place and Has_Task (Etype (Parent_Function)) then\n-            Append_To (Statements, Move_Activation_Chain);\n-         end if;\n-\n-         --  Build a simple_return_statement that returns the return object\n-\n-         Return_Stm :=\n-           Make_Simple_Return_Statement (Loc,\n-             Expression => New_Occurrence_Of (Return_Object_Entity, Loc));\n-         Append_To (Statements, Return_Stm);\n-\n-         Handled_Stm_Seq :=\n-           Make_Handled_Sequence_Of_Statements (Loc, Statements);\n-      end if;\n-\n-      --  Case where we build a block\n-\n-      if Present (Handled_Stm_Seq) then\n-         Result :=\n-           Make_Block_Statement (Loc,\n-             Declarations => Return_Object_Declarations (N),\n-             Handled_Statement_Sequence => Handled_Stm_Seq);\n-\n-         --  We set the entity of the new block statement to be that of the\n-         --  return statement. This is necessary so that various fields, such\n-         --  as Finalization_Chain_Entity carry over from the return statement\n-         --  to the block. Note that this block is unusual, in that its entity\n-         --  is an E_Return_Statement rather than an E_Block.\n-\n-         Set_Identifier\n-           (Result, New_Occurrence_Of (Return_Statement_Entity (N), Loc));\n-\n-         --  If the object decl was already rewritten as a renaming, then\n-         --  we don't want to do the object allocation and transformation of\n-         --  of the return object declaration to a renaming. This case occurs\n-         --  when the return object is initialized by a call to another\n-         --  build-in-place function, and that function is responsible for the\n-         --  allocation of the return object.\n-\n-         if Is_Build_In_Place\n-           and then\n-             Nkind (Return_Object_Decl) = N_Object_Renaming_Declaration\n-         then\n-            pragma Assert (Nkind (Original_Node (Return_Object_Decl)) =\n-                            N_Object_Declaration\n-              and then Is_Build_In_Place_Function_Call\n-                         (Expression (Original_Node (Return_Object_Decl))));\n-\n-            Set_By_Ref (Return_Stm);  -- Return build-in-place results by ref\n-\n-         elsif Is_Build_In_Place then\n-\n-            --  Locate the implicit access parameter associated with the\n-            --  caller-supplied return object and convert the return\n-            --  statement's return object declaration to a renaming of a\n-            --  dereference of the access parameter. If the return object's\n-            --  declaration includes an expression that has not already been\n-            --  expanded as separate assignments, then add an assignment\n-            --  statement to ensure the return object gets initialized.\n-\n-            --  declare\n-            --     Result : T [:= <expression>];\n-            --  begin\n-            --     ...\n-\n-            --  is converted to\n-\n-            --  declare\n-            --     Result : T renames FuncRA.all;\n-            --     [Result := <expression;]\n-            --  begin\n-            --     ...\n-\n-            declare\n-               Return_Obj_Id    : constant Entity_Id :=\n-                                    Defining_Identifier (Return_Object_Decl);\n-               Return_Obj_Typ   : constant Entity_Id := Etype (Return_Obj_Id);\n-               Return_Obj_Expr  : constant Node_Id :=\n-                                    Expression (Return_Object_Decl);\n-               Result_Subt      : constant Entity_Id :=\n-                                    Etype (Parent_Function);\n-               Constr_Result    : constant Boolean :=\n-                                    Is_Constrained (Result_Subt);\n-               Obj_Alloc_Formal : Entity_Id;\n-               Object_Access    : Entity_Id;\n-               Obj_Acc_Deref    : Node_Id;\n-               Init_Assignment  : Node_Id := Empty;\n-\n-            begin\n-               --  Build-in-place results must be returned by reference\n-\n-               Set_By_Ref (Return_Stm);\n-\n-               --  Retrieve the implicit access parameter passed by the caller\n-\n-               Object_Access :=\n-                 Build_In_Place_Formal (Parent_Function, BIP_Object_Access);\n-\n-               --  If the return object's declaration includes an expression\n-               --  and the declaration isn't marked as No_Initialization, then\n-               --  we need to generate an assignment to the object and insert\n-               --  it after the declaration before rewriting it as a renaming\n-               --  (otherwise we'll lose the initialization). The case where\n-               --  the result type is an interface (or class-wide interface)\n-               --  is also excluded because the context of the function call\n-               --  must be unconstrained, so the initialization will always\n-               --  be done as part of an allocator evaluation (storage pool\n-               --  or secondary stack), never to a constrained target object\n-               --  passed in by the caller. Besides the assignment being\n-               --  unneeded in this case, it avoids problems with trying to\n-               --  generate a dispatching assignment when the return expression\n-               --  is a nonlimited descendant of a limited interface (the\n-               --  interface has no assignment operation).\n-\n-               if Present (Return_Obj_Expr)\n-                 and then not No_Initialization (Return_Object_Decl)\n-                 and then not Is_Interface (Return_Obj_Typ)\n-               then\n-                  Init_Assignment :=\n-                    Make_Assignment_Statement (Loc,\n-                      Name       => New_Reference_To (Return_Obj_Id, Loc),\n-                      Expression => Relocate_Node (Return_Obj_Expr));\n-                  Set_Etype (Name (Init_Assignment), Etype (Return_Obj_Id));\n-                  Set_Assignment_OK (Name (Init_Assignment));\n-                  Set_No_Ctrl_Actions (Init_Assignment);\n-\n-                  Set_Parent (Name (Init_Assignment), Init_Assignment);\n-                  Set_Parent (Expression (Init_Assignment), Init_Assignment);\n-\n-                  Set_Expression (Return_Object_Decl, Empty);\n-\n-                  if Is_Class_Wide_Type (Etype (Return_Obj_Id))\n-                    and then not Is_Class_Wide_Type\n-                                   (Etype (Expression (Init_Assignment)))\n-                  then\n-                     Rewrite (Expression (Init_Assignment),\n-                       Make_Type_Conversion (Loc,\n-                         Subtype_Mark =>\n-                           New_Occurrence_Of\n-                             (Etype (Return_Obj_Id), Loc),\n-                         Expression =>\n-                           Relocate_Node (Expression (Init_Assignment))));\n-                  end if;\n-\n-                  --  In the case of functions where the calling context can\n-                  --  determine the form of allocation needed, initialization\n-                  --  is done with each part of the if statement that handles\n-                  --  the different forms of allocation (this is true for\n-                  --  unconstrained and tagged result subtypes).\n-\n-                  if Constr_Result\n-                    and then not Is_Tagged_Type (Underlying_Type (Result_Subt))\n-                  then\n-                     Insert_After (Return_Object_Decl, Init_Assignment);\n-                  end if;\n-               end if;\n-\n-               --  When the function's subtype is unconstrained, a run-time\n-               --  test is needed to determine the form of allocation to use\n-               --  for the return object. The function has an implicit formal\n-               --  parameter indicating this. If the BIP_Alloc_Form formal has\n-               --  the value one, then the caller has passed access to an\n-               --  existing object for use as the return object. If the value\n-               --  is two, then the return object must be allocated on the\n-               --  secondary stack. Otherwise, the object must be allocated in\n-               --  a storage pool (currently only supported for the global\n-               --  heap, user-defined storage pools TBD ???). We generate an\n-               --  if statement to test the implicit allocation formal and\n-               --  initialize a local access value appropriately, creating\n-               --  allocators in the secondary stack and global heap cases.\n-               --  The special formal also exists and must be tested when the\n-               --  function has a tagged result, even when the result subtype\n-               --  is constrained, because in general such functions can be\n-               --  called in dispatching contexts and must be handled similarly\n-               --  to functions with a class-wide result.\n-\n-               if not Constr_Result\n-                 or else Is_Tagged_Type (Underlying_Type (Result_Subt))\n-               then\n-                  Obj_Alloc_Formal :=\n-                    Build_In_Place_Formal (Parent_Function, BIP_Alloc_Form);\n-\n-                  declare\n-                     Ref_Type       : Entity_Id;\n-                     Ptr_Type_Decl  : Node_Id;\n-                     Alloc_Obj_Id   : Entity_Id;\n-                     Alloc_Obj_Decl : Node_Id;\n-                     Alloc_If_Stmt  : Node_Id;\n-                     SS_Allocator   : Node_Id;\n-                     Heap_Allocator : Node_Id;\n-\n-                  begin\n-                     --  Reuse the itype created for the function's implicit\n-                     --  access formal. This avoids the need to create a new\n-                     --  access type here, plus it allows assigning the access\n-                     --  formal directly without applying a conversion.\n-\n-                     --  Ref_Type := Etype (Object_Access);\n-\n-                     --  Create an access type designating the function's\n-                     --  result subtype.\n-\n-                     Ref_Type := Make_Temporary (Loc, 'A');\n-\n-                     Ptr_Type_Decl :=\n-                       Make_Full_Type_Declaration (Loc,\n-                         Defining_Identifier => Ref_Type,\n-                         Type_Definition =>\n-                           Make_Access_To_Object_Definition (Loc,\n-                             All_Present => True,\n-                             Subtype_Indication =>\n-                               New_Reference_To (Return_Obj_Typ, Loc)));\n-\n-                     Insert_Before (Return_Object_Decl, Ptr_Type_Decl);\n-\n-                     --  Create an access object that will be initialized to an\n-                     --  access value denoting the return object, either coming\n-                     --  from an implicit access value passed in by the caller\n-                     --  or from the result of an allocator.\n-\n-                     Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n-                     Set_Etype (Alloc_Obj_Id, Ref_Type);\n-\n-                     Alloc_Obj_Decl :=\n-                       Make_Object_Declaration (Loc,\n-                         Defining_Identifier => Alloc_Obj_Id,\n-                         Object_Definition   => New_Reference_To\n-                                                  (Ref_Type, Loc));\n-\n-                     Insert_Before (Return_Object_Decl, Alloc_Obj_Decl);\n-\n-                     --  Create allocators for both the secondary stack and\n-                     --  global heap. If there's an initialization expression,\n-                     --  then create these as initialized allocators.\n-\n-                     if Present (Return_Obj_Expr)\n-                       and then not No_Initialization (Return_Object_Decl)\n-                     then\n-                        --  Always use the type of the expression for the\n-                        --  qualified expression, rather than the result type.\n-                        --  In general we cannot always use the result type\n-                        --  for the allocator, because the expression might be\n-                        --  of a specific type, such as in the case of an\n-                        --  aggregate or even a nonlimited object when the\n-                        --  result type is a limited class-wide interface type.\n-\n-                        Heap_Allocator :=\n-                          Make_Allocator (Loc,\n-                            Expression =>\n-                              Make_Qualified_Expression (Loc,\n-                                Subtype_Mark =>\n-                                  New_Reference_To\n-                                    (Etype (Return_Obj_Expr), Loc),\n-                                Expression =>\n-                                  New_Copy_Tree (Return_Obj_Expr)));\n-\n-                     else\n-                        --  If the function returns a class-wide type we cannot\n-                        --  use the return type for the allocator. Instead we\n-                        --  use the type of the expression, which must be an\n-                        --  aggregate of a definite type.\n-\n-                        if Is_Class_Wide_Type (Return_Obj_Typ) then\n-                           Heap_Allocator :=\n-                             Make_Allocator (Loc,\n-                               Expression =>\n-                                 New_Reference_To\n-                                   (Etype (Return_Obj_Expr), Loc));\n-                        else\n-                           Heap_Allocator :=\n-                             Make_Allocator (Loc,\n-                               Expression =>\n-                                 New_Reference_To (Return_Obj_Typ, Loc));\n-                        end if;\n-\n-                        --  If the object requires default initialization then\n-                        --  that will happen later following the elaboration of\n-                        --  the object renaming. If we don't turn it off here\n-                        --  then the object will be default initialized twice.\n-\n-                        Set_No_Initialization (Heap_Allocator);\n-                     end if;\n-\n-                     --  If the No_Allocators restriction is active, then only\n-                     --  an allocator for secondary stack allocation is needed.\n-                     --  It's OK for such allocators to have Comes_From_Source\n-                     --  set to False, because gigi knows not to flag them as\n-                     --  being a violation of No_Implicit_Heap_Allocations.\n-\n-                     if Restriction_Active (No_Allocators) then\n-                        SS_Allocator   := Heap_Allocator;\n-                        Heap_Allocator := Make_Null (Loc);\n-\n-                     --  Otherwise the heap allocator may be needed, so we make\n-                     --  another allocator for secondary stack allocation.\n-\n-                     else\n-                        SS_Allocator := New_Copy_Tree (Heap_Allocator);\n-\n-                        --  The heap allocator is marked Comes_From_Source\n-                        --  since it corresponds to an explicit user-written\n-                        --  allocator (that is, it will only be executed on\n-                        --  behalf of callers that call the function as\n-                        --  initialization for such an allocator). This\n-                        --  prevents errors when No_Implicit_Heap_Allocations\n-                        --  is in force.\n-\n-                        Set_Comes_From_Source (Heap_Allocator, True);\n-                     end if;\n-\n-                     --  The allocator is returned on the secondary stack. We\n-                     --  don't do this on VM targets, since the SS is not used.\n-\n-                     if VM_Target = No_VM then\n-                        Set_Storage_Pool (SS_Allocator, RTE (RE_SS_Pool));\n-                        Set_Procedure_To_Call\n-                          (SS_Allocator, RTE (RE_SS_Allocate));\n-\n-                        --  The allocator is returned on the secondary stack,\n-                        --  so indicate that the function return, as well as\n-                        --  the block that encloses the allocator, must not\n-                        --  release it. The flags must be set now because the\n-                        --  decision to use the secondary stack is done very\n-                        --  late in the course of expanding the return\n-                        --  statement, past the point where these flags are\n-                        --  normally set.\n-\n-                        Set_Sec_Stack_Needed_For_Return (Parent_Function);\n-                        Set_Sec_Stack_Needed_For_Return\n-                          (Return_Statement_Entity (N));\n-                        Set_Uses_Sec_Stack (Parent_Function);\n-                        Set_Uses_Sec_Stack (Return_Statement_Entity (N));\n-                     end if;\n-\n-                     --  Create an if statement to test the BIP_Alloc_Form\n-                     --  formal and initialize the access object to either the\n-                     --  BIP_Object_Access formal (BIP_Alloc_Form = 0), the\n-                     --  result of allocating the object in the secondary stack\n-                     --  (BIP_Alloc_Form = 1), or else an allocator to create\n-                     --  the return object in the heap (BIP_Alloc_Form = 2).\n-\n-                     --  ??? An unchecked type conversion must be made in the\n-                     --  case of assigning the access object formal to the\n-                     --  local access object, because a normal conversion would\n-                     --  be illegal in some cases (such as converting access-\n-                     --  to-unconstrained to access-to-constrained), but the\n-                     --  the unchecked conversion will presumably fail to work\n-                     --  right in just such cases. It's not clear at all how to\n-                     --  handle this. ???\n-\n-                     Alloc_If_Stmt :=\n-                       Make_If_Statement (Loc,\n-                         Condition       =>\n-                           Make_Op_Eq (Loc,\n-                             Left_Opnd =>\n-                               New_Reference_To (Obj_Alloc_Formal, Loc),\n-                             Right_Opnd =>\n-                               Make_Integer_Literal (Loc,\n-                                 UI_From_Int (BIP_Allocation_Form'Pos\n-                                                (Caller_Allocation)))),\n-                         Then_Statements =>\n-                           New_List (Make_Assignment_Statement (Loc,\n-                                       Name       =>\n-                                         New_Reference_To\n-                                           (Alloc_Obj_Id, Loc),\n-                                       Expression =>\n-                                         Make_Unchecked_Type_Conversion (Loc,\n-                                           Subtype_Mark =>\n-                                             New_Reference_To (Ref_Type, Loc),\n-                                           Expression =>\n-                                             New_Reference_To\n-                                               (Object_Access, Loc)))),\n-                         Elsif_Parts     =>\n-                           New_List (Make_Elsif_Part (Loc,\n-                                       Condition       =>\n-                                         Make_Op_Eq (Loc,\n-                                           Left_Opnd =>\n-                                             New_Reference_To\n-                                               (Obj_Alloc_Formal, Loc),\n-                                           Right_Opnd =>\n-                                             Make_Integer_Literal (Loc,\n-                                               UI_From_Int (\n-                                                 BIP_Allocation_Form'Pos\n-                                                    (Secondary_Stack)))),\n-                                       Then_Statements =>\n-                                          New_List\n-                                            (Make_Assignment_Statement (Loc,\n-                                               Name       =>\n-                                                 New_Reference_To\n-                                                   (Alloc_Obj_Id, Loc),\n-                                               Expression =>\n-                                                 SS_Allocator)))),\n-                         Else_Statements =>\n-                           New_List (Make_Assignment_Statement (Loc,\n-                                        Name       =>\n-                                          New_Reference_To\n-                                            (Alloc_Obj_Id, Loc),\n-                                        Expression =>\n-                                          Heap_Allocator)));\n-\n-                     --  If a separate initialization assignment was created\n-                     --  earlier, append that following the assignment of the\n-                     --  implicit access formal to the access object, to ensure\n-                     --  that the return object is initialized in that case.\n-                     --  In this situation, the target of the assignment must\n-                     --  be rewritten to denote a dereference of the access to\n-                     --  the return object passed in by the caller.\n-\n-                     if Present (Init_Assignment) then\n-                        Rewrite (Name (Init_Assignment),\n-                          Make_Explicit_Dereference (Loc,\n-                            Prefix => New_Reference_To (Alloc_Obj_Id, Loc)));\n-                        Set_Etype\n-                          (Name (Init_Assignment), Etype (Return_Obj_Id));\n-\n-                        Append_To\n-                          (Then_Statements (Alloc_If_Stmt),\n-                           Init_Assignment);\n-                     end if;\n-\n-                     Insert_Before (Return_Object_Decl, Alloc_If_Stmt);\n-\n-                     --  Remember the local access object for use in the\n-                     --  dereference of the renaming created below.\n-\n-                     Object_Access := Alloc_Obj_Id;\n-                  end;\n-               end if;\n-\n-               --  Replace the return object declaration with a renaming of a\n-               --  dereference of the access value designating the return\n-               --  object.\n-\n-               Obj_Acc_Deref :=\n-                 Make_Explicit_Dereference (Loc,\n-                   Prefix => New_Reference_To (Object_Access, Loc));\n-\n-               Rewrite (Return_Object_Decl,\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier => Return_Obj_Id,\n-                   Access_Definition   => Empty,\n-                   Subtype_Mark        => New_Occurrence_Of\n-                                            (Return_Obj_Typ, Loc),\n-                   Name                => Obj_Acc_Deref));\n-\n-               Set_Renamed_Object (Return_Obj_Id, Obj_Acc_Deref);\n-            end;\n-         end if;\n-\n-      --  Case where we do not build a block\n-\n-      else\n-         --  We're about to drop Return_Object_Declarations on the floor, so\n-         --  we need to insert it, in case it got expanded into useful code.\n-         --  Remove side effects from expression, which may be duplicated in\n-         --  subsequent checks (see Expand_Simple_Function_Return).\n-\n-         Insert_List_Before (N, Return_Object_Declarations (N));\n-         Remove_Side_Effects (Exp);\n-\n-         --  Build simple_return_statement that returns the expression directly\n-\n-         Return_Stm := Make_Simple_Return_Statement (Loc, Expression => Exp);\n-\n-         Result := Return_Stm;\n-      end if;\n-\n-      --  Set the flag to prevent infinite recursion\n-\n-      Set_Comes_From_Extended_Return_Statement (Return_Stm);\n-\n-      Rewrite (N, Result);\n-      Analyze (N);\n-   end Expand_N_Extended_Return_Statement;\n-\n    -----------------------------\n    -- Expand_N_Goto_Statement --\n    -----------------------------\n@@ -3671,761 +2938,6 @@ package body Exp_Ch5 is\n       end if;\n    end Expand_N_Loop_Statement;\n \n-   --------------------------------------\n-   -- Expand_N_Simple_Return_Statement --\n-   --------------------------------------\n-\n-   procedure Expand_N_Simple_Return_Statement (N : Node_Id) is\n-   begin\n-      --  Defend against previous errors (i.e. the return statement calls a\n-      --  function that is not available in configurable runtime).\n-\n-      if Present (Expression (N))\n-        and then Nkind (Expression (N)) = N_Empty\n-      then\n-         return;\n-      end if;\n-\n-      --  Distinguish the function and non-function cases:\n-\n-      case Ekind (Return_Applies_To (Return_Statement_Entity (N))) is\n-\n-         when E_Function          |\n-              E_Generic_Function  =>\n-            Expand_Simple_Function_Return (N);\n-\n-         when E_Procedure         |\n-              E_Generic_Procedure |\n-              E_Entry             |\n-              E_Entry_Family      |\n-              E_Return_Statement =>\n-            Expand_Non_Function_Return (N);\n-\n-         when others =>\n-            raise Program_Error;\n-      end case;\n-\n-   exception\n-      when RE_Not_Available =>\n-         return;\n-   end Expand_N_Simple_Return_Statement;\n-\n-   --------------------------------\n-   -- Expand_Non_Function_Return --\n-   --------------------------------\n-\n-   procedure Expand_Non_Function_Return (N : Node_Id) is\n-      pragma Assert (No (Expression (N)));\n-\n-      Loc         : constant Source_Ptr := Sloc (N);\n-      Scope_Id    : Entity_Id :=\n-                      Return_Applies_To (Return_Statement_Entity (N));\n-      Kind        : constant Entity_Kind := Ekind (Scope_Id);\n-      Call        : Node_Id;\n-      Acc_Stat    : Node_Id;\n-      Goto_Stat   : Node_Id;\n-      Lab_Node    : Node_Id;\n-\n-   begin\n-      --  Call _Postconditions procedure if procedure with active\n-      --  postconditions. Here, we use the Postcondition_Proc attribute, which\n-      --  is needed for implicitly-generated returns. Functions never\n-      --  have implicitly-generated returns, and there's no room for\n-      --  Postcondition_Proc in E_Function, so we look up the identifier\n-      --  Name_uPostconditions for function returns (see\n-      --  Expand_Simple_Function_Return).\n-\n-      if Ekind (Scope_Id) = E_Procedure\n-        and then Has_Postconditions (Scope_Id)\n-      then\n-         pragma Assert (Present (Postcondition_Proc (Scope_Id)));\n-         Insert_Action (N,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Reference_To (Postcondition_Proc (Scope_Id), Loc)));\n-      end if;\n-\n-      --  If it is a return from a procedure do no extra steps\n-\n-      if Kind = E_Procedure or else Kind = E_Generic_Procedure then\n-         return;\n-\n-      --  If it is a nested return within an extended one, replace it with a\n-      --  return of the previously declared return object.\n-\n-      elsif Kind = E_Return_Statement then\n-         Rewrite (N,\n-           Make_Simple_Return_Statement (Loc,\n-             Expression =>\n-               New_Occurrence_Of (First_Entity (Scope_Id), Loc)));\n-         Set_Comes_From_Extended_Return_Statement (N);\n-         Set_Return_Statement_Entity (N, Scope_Id);\n-         Expand_Simple_Function_Return (N);\n-         return;\n-      end if;\n-\n-      pragma Assert (Is_Entry (Scope_Id));\n-\n-      --  Look at the enclosing block to see whether the return is from an\n-      --  accept statement or an entry body.\n-\n-      for J in reverse 0 .. Scope_Stack.Last loop\n-         Scope_Id := Scope_Stack.Table (J).Entity;\n-         exit when Is_Concurrent_Type (Scope_Id);\n-      end loop;\n-\n-      --  If it is a return from accept statement it is expanded as call to\n-      --  RTS Complete_Rendezvous and a goto to the end of the accept body.\n-\n-      --  (cf : Expand_N_Accept_Statement, Expand_N_Selective_Accept,\n-      --  Expand_N_Accept_Alternative in exp_ch9.adb)\n-\n-      if Is_Task_Type (Scope_Id) then\n-\n-         Call :=\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => New_Reference_To (RTE (RE_Complete_Rendezvous), Loc));\n-         Insert_Before (N, Call);\n-         --  why not insert actions here???\n-         Analyze (Call);\n-\n-         Acc_Stat := Parent (N);\n-         while Nkind (Acc_Stat) /= N_Accept_Statement loop\n-            Acc_Stat := Parent (Acc_Stat);\n-         end loop;\n-\n-         Lab_Node := Last (Statements\n-           (Handled_Statement_Sequence (Acc_Stat)));\n-\n-         Goto_Stat := Make_Goto_Statement (Loc,\n-           Name => New_Occurrence_Of\n-             (Entity (Identifier (Lab_Node)), Loc));\n-\n-         Set_Analyzed (Goto_Stat);\n-\n-         Rewrite (N, Goto_Stat);\n-         Analyze (N);\n-\n-      --  If it is a return from an entry body, put a Complete_Entry_Body call\n-      --  in front of the return.\n-\n-      elsif Is_Protected_Type (Scope_Id) then\n-         Call :=\n-           Make_Procedure_Call_Statement (Loc,\n-             Name =>\n-               New_Reference_To (RTE (RE_Complete_Entry_Body), Loc),\n-             Parameter_Associations => New_List (\n-               Make_Attribute_Reference (Loc,\n-                 Prefix =>\n-                   New_Reference_To\n-                     (Find_Protection_Object (Current_Scope), Loc),\n-                 Attribute_Name =>\n-                   Name_Unchecked_Access)));\n-\n-         Insert_Before (N, Call);\n-         Analyze (Call);\n-      end if;\n-   end Expand_Non_Function_Return;\n-\n-   -----------------------------------\n-   -- Expand_Simple_Function_Return --\n-   -----------------------------------\n-\n-   --  The \"simple\" comes from the syntax rule simple_return_statement.\n-   --  The semantics are not at all simple!\n-\n-   procedure Expand_Simple_Function_Return (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-\n-      Scope_Id : constant Entity_Id :=\n-                   Return_Applies_To (Return_Statement_Entity (N));\n-      --  The function we are returning from\n-\n-      R_Type : constant Entity_Id := Etype (Scope_Id);\n-      --  The result type of the function\n-\n-      Utyp : constant Entity_Id := Underlying_Type (R_Type);\n-\n-      Exp : constant Node_Id := Expression (N);\n-      pragma Assert (Present (Exp));\n-\n-      Exptyp : constant Entity_Id := Etype (Exp);\n-      --  The type of the expression (not necessarily the same as R_Type)\n-\n-      Subtype_Ind : Node_Id;\n-      --  If the result type of the function is class-wide and the\n-      --  expression has a specific type, then we use the expression's\n-      --  type as the type of the return object. In cases where the\n-      --  expression is an aggregate that is built in place, this avoids\n-      --  the need for an expensive conversion of the return object to\n-      --  the specific type on assignments to the individual components.\n-\n-   begin\n-      if Is_Class_Wide_Type (R_Type)\n-        and then not Is_Class_Wide_Type (Etype (Exp))\n-      then\n-         Subtype_Ind := New_Occurrence_Of (Etype (Exp), Loc);\n-      else\n-         Subtype_Ind := New_Occurrence_Of (R_Type, Loc);\n-      end if;\n-\n-      --  For the case of a simple return that does not come from an extended\n-      --  return, in the case of Ada 2005 where we are returning a limited\n-      --  type, we rewrite \"return <expression>;\" to be:\n-\n-      --    return _anon_ : <return_subtype> := <expression>\n-\n-      --  The expansion produced by Expand_N_Extended_Return_Statement will\n-      --  contain simple return statements (for example, a block containing\n-      --  simple return of the return object), which brings us back here with\n-      --  Comes_From_Extended_Return_Statement set. The reason for the barrier\n-      --  checking for a simple return that does not come from an extended\n-      --  return is to avoid this infinite recursion.\n-\n-      --  The reason for this design is that for Ada 2005 limited returns, we\n-      --  need to reify the return object, so we can build it \"in place\", and\n-      --  we need a block statement to hang finalization and tasking stuff.\n-\n-      --  ??? In order to avoid disruption, we avoid translating to extended\n-      --  return except in the cases where we really need to (Ada 2005 for\n-      --  inherently limited). We might prefer to do this translation in all\n-      --  cases (except perhaps for the case of Ada 95 inherently limited),\n-      --  in order to fully exercise the Expand_N_Extended_Return_Statement\n-      --  code. This would also allow us to do the build-in-place optimization\n-      --  for efficiency even in cases where it is semantically not required.\n-\n-      --  As before, we check the type of the return expression rather than the\n-      --  return type of the function, because the latter may be a limited\n-      --  class-wide interface type, which is not a limited type, even though\n-      --  the type of the expression may be.\n-\n-      if not Comes_From_Extended_Return_Statement (N)\n-        and then Is_Immutably_Limited_Type (Etype (Expression (N)))\n-        and then Ada_Version >= Ada_05\n-        and then not Debug_Flag_Dot_L\n-      then\n-         declare\n-            Return_Object_Entity : constant Entity_Id :=\n-                                     Make_Temporary (Loc, 'R', Exp);\n-            Obj_Decl : constant Node_Id :=\n-                         Make_Object_Declaration (Loc,\n-                           Defining_Identifier => Return_Object_Entity,\n-                           Object_Definition   => Subtype_Ind,\n-                           Expression          => Exp);\n-\n-            Ext : constant Node_Id := Make_Extended_Return_Statement (Loc,\n-                    Return_Object_Declarations => New_List (Obj_Decl));\n-            --  Do not perform this high-level optimization if the result type\n-            --  is an interface because the \"this\" pointer must be displaced.\n-\n-         begin\n-            Rewrite (N, Ext);\n-            Analyze (N);\n-            return;\n-         end;\n-      end if;\n-\n-      --  Here we have a simple return statement that is part of the expansion\n-      --  of an extended return statement (either written by the user, or\n-      --  generated by the above code).\n-\n-      --  Always normalize C/Fortran boolean result. This is not always needed,\n-      --  but it seems a good idea to minimize the passing around of non-\n-      --  normalized values, and in any case this handles the processing of\n-      --  barrier functions for protected types, which turn the condition into\n-      --  a return statement.\n-\n-      if Is_Boolean_Type (Exptyp)\n-        and then Nonzero_Is_True (Exptyp)\n-      then\n-         Adjust_Condition (Exp);\n-         Adjust_Result_Type (Exp, Exptyp);\n-      end if;\n-\n-      --  Do validity check if enabled for returns\n-\n-      if Validity_Checks_On\n-        and then Validity_Check_Returns\n-      then\n-         Ensure_Valid (Exp);\n-      end if;\n-\n-      --  Check the result expression of a scalar function against the subtype\n-      --  of the function by inserting a conversion. This conversion must\n-      --  eventually be performed for other classes of types, but for now it's\n-      --  only done for scalars.\n-      --  ???\n-\n-      if Is_Scalar_Type (Exptyp) then\n-         Rewrite (Exp, Convert_To (R_Type, Exp));\n-\n-         --  The expression is resolved to ensure that the conversion gets\n-         --  expanded to generate a possible constraint check.\n-\n-         Analyze_And_Resolve (Exp, R_Type);\n-      end if;\n-\n-      --  Deal with returning variable length objects and controlled types\n-\n-      --  Nothing to do if we are returning by reference, or this is not a\n-      --  type that requires special processing (indicated by the fact that\n-      --  it requires a cleanup scope for the secondary stack case).\n-\n-      if Is_Immutably_Limited_Type (Exptyp)\n-        or else Is_Limited_Interface (Exptyp)\n-      then\n-         null;\n-\n-      elsif not Requires_Transient_Scope (R_Type) then\n-\n-         --  Mutable records with no variable length components are not\n-         --  returned on the sec-stack, so we need to make sure that the\n-         --  backend will only copy back the size of the actual value, and not\n-         --  the maximum size. We create an actual subtype for this purpose.\n-\n-         declare\n-            Ubt  : constant Entity_Id := Underlying_Type (Base_Type (Exptyp));\n-            Decl : Node_Id;\n-            Ent  : Entity_Id;\n-         begin\n-            if Has_Discriminants (Ubt)\n-              and then not Is_Constrained (Ubt)\n-              and then not Has_Unchecked_Union (Ubt)\n-            then\n-               Decl := Build_Actual_Subtype (Ubt, Exp);\n-               Ent := Defining_Identifier (Decl);\n-               Insert_Action (Exp, Decl);\n-               Rewrite (Exp, Unchecked_Convert_To (Ent, Exp));\n-               Analyze_And_Resolve (Exp);\n-            end if;\n-         end;\n-\n-      --  Here if secondary stack is used\n-\n-      else\n-         --  Make sure that no surrounding block will reclaim the secondary\n-         --  stack on which we are going to put the result. Not only may this\n-         --  introduce secondary stack leaks but worse, if the reclamation is\n-         --  done too early, then the result we are returning may get\n-         --  clobbered.\n-\n-         declare\n-            S : Entity_Id;\n-         begin\n-            S := Current_Scope;\n-            while Ekind (S) = E_Block or else Ekind (S) = E_Loop loop\n-               Set_Sec_Stack_Needed_For_Return (S, True);\n-               S := Enclosing_Dynamic_Scope (S);\n-            end loop;\n-         end;\n-\n-         --  Optimize the case where the result is a function call. In this\n-         --  case either the result is already on the secondary stack, or is\n-         --  already being returned with the stack pointer depressed and no\n-         --  further processing is required except to set the By_Ref flag to\n-         --  ensure that gigi does not attempt an extra unnecessary copy.\n-         --  (actually not just unnecessary but harmfully wrong in the case\n-         --  of a controlled type, where gigi does not know how to do a copy).\n-         --  To make up for a gcc 2.8.1 deficiency (???), we perform\n-         --  the copy for array types if the constrained status of the\n-         --  target type is different from that of the expression.\n-\n-         if Requires_Transient_Scope (Exptyp)\n-           and then\n-              (not Is_Array_Type (Exptyp)\n-                or else Is_Constrained (Exptyp) = Is_Constrained (R_Type)\n-                or else CW_Or_Has_Controlled_Part (Utyp))\n-           and then Nkind (Exp) = N_Function_Call\n-         then\n-            Set_By_Ref (N);\n-\n-            --  Remove side effects from the expression now so that other parts\n-            --  of the expander do not have to reanalyze this node without this\n-            --  optimization\n-\n-            Rewrite (Exp, Duplicate_Subexpr_No_Checks (Exp));\n-\n-         --  For controlled types, do the allocation on the secondary stack\n-         --  manually in order to call adjust at the right time:\n-\n-         --    type Anon1 is access R_Type;\n-         --    for Anon1'Storage_pool use ss_pool;\n-         --    Anon2 : anon1 := new R_Type'(expr);\n-         --    return Anon2.all;\n-\n-         --  We do the same for classwide types that are not potentially\n-         --  controlled (by the virtue of restriction No_Finalization) because\n-         --  gigi is not able to properly allocate class-wide types.\n-\n-         elsif CW_Or_Has_Controlled_Part (Utyp) then\n-            declare\n-               Loc        : constant Source_Ptr := Sloc (N);\n-               Acc_Typ    : constant Entity_Id := Make_Temporary (Loc, 'A');\n-               Alloc_Node : Node_Id;\n-               Temp       : Entity_Id;\n-\n-            begin\n-               Set_Ekind (Acc_Typ, E_Access_Type);\n-\n-               Set_Associated_Storage_Pool (Acc_Typ, RTE (RE_SS_Pool));\n-\n-               --  This is an allocator for the secondary stack, and it's fine\n-               --  to have Comes_From_Source set False on it, as gigi knows not\n-               --  to flag it as a violation of No_Implicit_Heap_Allocations.\n-\n-               Alloc_Node :=\n-                 Make_Allocator (Loc,\n-                   Expression =>\n-                     Make_Qualified_Expression (Loc,\n-                       Subtype_Mark => New_Reference_To (Etype (Exp), Loc),\n-                       Expression   => Relocate_Node (Exp)));\n-\n-               --  We do not want discriminant checks on the declaration,\n-               --  given that it gets its value from the allocator.\n-\n-               Set_No_Initialization (Alloc_Node);\n-\n-               Temp := Make_Temporary (Loc, 'R', Alloc_Node);\n-\n-               Insert_List_Before_And_Analyze (N, New_List (\n-                 Make_Full_Type_Declaration (Loc,\n-                   Defining_Identifier => Acc_Typ,\n-                   Type_Definition     =>\n-                     Make_Access_To_Object_Definition (Loc,\n-                       Subtype_Indication => Subtype_Ind)),\n-\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Object_Definition   => New_Reference_To (Acc_Typ, Loc),\n-                   Expression          => Alloc_Node)));\n-\n-               Rewrite (Exp,\n-                 Make_Explicit_Dereference (Loc,\n-                 Prefix => New_Reference_To (Temp, Loc)));\n-\n-               Analyze_And_Resolve (Exp, R_Type);\n-            end;\n-\n-         --  Otherwise use the gigi mechanism to allocate result on the\n-         --  secondary stack.\n-\n-         else\n-            Check_Restriction (No_Secondary_Stack, N);\n-            Set_Storage_Pool (N, RTE (RE_SS_Pool));\n-\n-            --  If we are generating code for the VM do not use\n-            --  SS_Allocate since everything is heap-allocated anyway.\n-\n-            if VM_Target = No_VM then\n-               Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n-            end if;\n-         end if;\n-      end if;\n-\n-      --  Implement the rules of 6.5(8-10), which require a tag check in the\n-      --  case of a limited tagged return type, and tag reassignment for\n-      --  nonlimited tagged results. These actions are needed when the return\n-      --  type is a specific tagged type and the result expression is a\n-      --  conversion or a formal parameter, because in that case the tag of the\n-      --  expression might differ from the tag of the specific result type.\n-\n-      if Is_Tagged_Type (Utyp)\n-        and then not Is_Class_Wide_Type (Utyp)\n-        and then (Nkind_In (Exp, N_Type_Conversion,\n-                                 N_Unchecked_Type_Conversion)\n-                    or else (Is_Entity_Name (Exp)\n-                               and then Ekind (Entity (Exp)) in Formal_Kind))\n-      then\n-         --  When the return type is limited, perform a check that the\n-         --  tag of the result is the same as the tag of the return type.\n-\n-         if Is_Limited_Type (R_Type) then\n-            Insert_Action (Exp,\n-              Make_Raise_Constraint_Error (Loc,\n-                Condition =>\n-                  Make_Op_Ne (Loc,\n-                    Left_Opnd =>\n-                      Make_Selected_Component (Loc,\n-                        Prefix => Duplicate_Subexpr (Exp),\n-                        Selector_Name =>\n-                          Make_Identifier (Loc, Chars => Name_uTag)),\n-                    Right_Opnd =>\n-                      Make_Attribute_Reference (Loc,\n-                        Prefix => New_Occurrence_Of (Base_Type (Utyp), Loc),\n-                        Attribute_Name => Name_Tag)),\n-                Reason => CE_Tag_Check_Failed));\n-\n-         --  If the result type is a specific nonlimited tagged type, then we\n-         --  have to ensure that the tag of the result is that of the result\n-         --  type. This is handled by making a copy of the expression in the\n-         --  case where it might have a different tag, namely when the\n-         --  expression is a conversion or a formal parameter. We create a new\n-         --  object of the result type and initialize it from the expression,\n-         --  which will implicitly force the tag to be set appropriately.\n-\n-         else\n-            declare\n-               ExpR       : constant Node_Id   := Relocate_Node (Exp);\n-               Result_Id  : constant Entity_Id :=\n-                              Make_Temporary (Loc, 'R', ExpR);\n-               Result_Exp : constant Node_Id   :=\n-                              New_Reference_To (Result_Id, Loc);\n-               Result_Obj : constant Node_Id   :=\n-                              Make_Object_Declaration (Loc,\n-                                Defining_Identifier => Result_Id,\n-                                Object_Definition   =>\n-                                  New_Reference_To (R_Type, Loc),\n-                                Constant_Present    => True,\n-                                Expression          => ExpR);\n-\n-            begin\n-               Set_Assignment_OK (Result_Obj);\n-               Insert_Action (Exp, Result_Obj);\n-\n-               Rewrite (Exp, Result_Exp);\n-               Analyze_And_Resolve (Exp, R_Type);\n-            end;\n-         end if;\n-\n-      --  Ada 2005 (AI-344): If the result type is class-wide, then insert\n-      --  a check that the level of the return expression's underlying type\n-      --  is not deeper than the level of the master enclosing the function.\n-      --  Always generate the check when the type of the return expression\n-      --  is class-wide, when it's a type conversion, or when it's a formal\n-      --  parameter. Otherwise, suppress the check in the case where the\n-      --  return expression has a specific type whose level is known not to\n-      --  be statically deeper than the function's result type.\n-\n-      --  Note: accessibility check is skipped in the VM case, since there\n-      --  does not seem to be any practical way to implement this check.\n-\n-      elsif Ada_Version >= Ada_05\n-        and then Tagged_Type_Expansion\n-        and then Is_Class_Wide_Type (R_Type)\n-        and then not Scope_Suppress (Accessibility_Check)\n-        and then\n-          (Is_Class_Wide_Type (Etype (Exp))\n-            or else Nkind_In (Exp, N_Type_Conversion,\n-                                   N_Unchecked_Type_Conversion)\n-            or else (Is_Entity_Name (Exp)\n-                       and then Ekind (Entity (Exp)) in Formal_Kind)\n-            or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n-                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))\n-      then\n-         declare\n-            Tag_Node : Node_Id;\n-\n-         begin\n-            --  Ada 2005 (AI-251): In class-wide interface objects we displace\n-            --  \"this\" to reference the base of the object --- required to get\n-            --  access to the TSD of the object.\n-\n-            if Is_Class_Wide_Type (Etype (Exp))\n-              and then Is_Interface (Etype (Exp))\n-              and then Nkind (Exp) = N_Explicit_Dereference\n-            then\n-               Tag_Node :=\n-                 Make_Explicit_Dereference (Loc,\n-                   Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                     Make_Function_Call (Loc,\n-                       Name => New_Reference_To (RTE (RE_Base_Address), Loc),\n-                       Parameter_Associations => New_List (\n-                         Unchecked_Convert_To (RTE (RE_Address),\n-                           Duplicate_Subexpr (Prefix (Exp)))))));\n-            else\n-               Tag_Node :=\n-                 Make_Attribute_Reference (Loc,\n-                   Prefix => Duplicate_Subexpr (Exp),\n-                   Attribute_Name => Name_Tag);\n-            end if;\n-\n-            Insert_Action (Exp,\n-              Make_Raise_Program_Error (Loc,\n-                Condition =>\n-                  Make_Op_Gt (Loc,\n-                    Left_Opnd =>\n-                      Build_Get_Access_Level (Loc, Tag_Node),\n-                    Right_Opnd =>\n-                      Make_Integer_Literal (Loc,\n-                        Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n-                Reason => PE_Accessibility_Check_Failed));\n-         end;\n-\n-      --  AI05-0073: If function has a controlling access result, check that\n-      --  the tag of the return value, if it is not null, matches designated\n-      --  type of return type.\n-\n-      --  The \"or else True\" needs commenting here ???\n-\n-      elsif Ekind (R_Type) = E_Anonymous_Access_Type\n-        and then Has_Controlling_Result (Scope_Id)\n-      then\n-         Insert_Action (N,\n-           Make_Raise_Constraint_Error (Loc,\n-             Condition =>\n-               Make_And_Then (Loc,\n-                 Left_Opnd  =>\n-                   Make_Op_Ne (Loc,\n-                     Left_Opnd  => Exp,\n-                     Right_Opnd => Make_Null (Loc)),\n-                 Right_Opnd => Make_Op_Ne (Loc,\n-                   Left_Opnd  =>\n-                     Make_Selected_Component (Loc,\n-                       Prefix        => Duplicate_Subexpr (Exp),\n-                       Selector_Name =>\n-                         Make_Identifier (Loc, Chars => Name_uTag)),\n-                   Right_Opnd =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         =>\n-                         New_Occurrence_Of (Designated_Type (R_Type), Loc),\n-                       Attribute_Name => Name_Tag))),\n-             Reason    => CE_Tag_Check_Failed),\n-             Suppress  => All_Checks);\n-      end if;\n-\n-      --  If we are returning an object that may not be bit-aligned, then copy\n-      --  the value into a temporary first. This copy may need to expand to a\n-      --  loop of component operations.\n-\n-      if Is_Possibly_Unaligned_Slice (Exp)\n-        or else Is_Possibly_Unaligned_Object (Exp)\n-      then\n-         declare\n-            ExpR : constant Node_Id   := Relocate_Node (Exp);\n-            Tnn  : constant Entity_Id := Make_Temporary (Loc, 'T', ExpR);\n-         begin\n-            Insert_Action (Exp,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Tnn,\n-                Constant_Present    => True,\n-                Object_Definition   => New_Occurrence_Of (R_Type, Loc),\n-                Expression          => ExpR),\n-              Suppress            => All_Checks);\n-            Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n-         end;\n-      end if;\n-\n-      --  Generate call to postcondition checks if they are present\n-\n-      if Ekind (Scope_Id) = E_Function\n-        and then Has_Postconditions (Scope_Id)\n-      then\n-         --  We are going to reference the returned value twice in this case,\n-         --  once in the call to _Postconditions, and once in the actual return\n-         --  statement, but we can't have side effects happening twice, and in\n-         --  any case for efficiency we don't want to do the computation twice.\n-\n-         --  If the returned expression is an entity name, we don't need to\n-         --  worry since it is efficient and safe to reference it twice, that's\n-         --  also true for literals other than string literals, and for the\n-         --  case of X.all where X is an entity name.\n-\n-         if Is_Entity_Name (Exp)\n-           or else Nkind_In (Exp, N_Character_Literal,\n-                                  N_Integer_Literal,\n-                                  N_Real_Literal)\n-           or else (Nkind (Exp) = N_Explicit_Dereference\n-                      and then Is_Entity_Name (Prefix (Exp)))\n-         then\n-            null;\n-\n-         --  Otherwise we are going to need a temporary to capture the value\n-\n-         else\n-            declare\n-               ExpR : constant Node_Id   := Relocate_Node (Exp);\n-               Tnn  : constant Entity_Id := Make_Temporary (Loc, 'T', ExpR);\n-\n-            begin\n-               --  For a complex expression of an elementary type, capture\n-               --  value in the temporary and use it as the reference.\n-\n-               if Is_Elementary_Type (R_Type) then\n-                  Insert_Action (Exp,\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Tnn,\n-                      Constant_Present    => True,\n-                      Object_Definition   => New_Occurrence_Of (R_Type, Loc),\n-                      Expression          => ExpR),\n-                    Suppress => All_Checks);\n-\n-                  Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n-\n-               --  If we have something we can rename, generate a renaming of\n-               --  the object and replace the expression with a reference\n-\n-               elsif Is_Object_Reference (Exp) then\n-                  Insert_Action (Exp,\n-                    Make_Object_Renaming_Declaration (Loc,\n-                      Defining_Identifier => Tnn,\n-                      Subtype_Mark        => New_Occurrence_Of (R_Type, Loc),\n-                      Name                => ExpR),\n-                    Suppress => All_Checks);\n-\n-                  Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n-\n-               --  Otherwise we have something like a string literal or an\n-               --  aggregate. We could copy the value, but that would be\n-               --  inefficient. Instead we make a reference to the value and\n-               --  capture this reference with a renaming, the expression is\n-               --  then replaced by a dereference of this renaming.\n-\n-               else\n-                  --  For now, copy the value, since the code below does not\n-                  --  seem to work correctly ???\n-\n-                  Insert_Action (Exp,\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Tnn,\n-                      Constant_Present    => True,\n-                      Object_Definition   => New_Occurrence_Of (R_Type, Loc),\n-                      Expression          => Relocate_Node (Exp)),\n-                    Suppress => All_Checks);\n-\n-                  Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n-\n-                  --  Insert_Action (Exp,\n-                  --    Make_Object_Renaming_Declaration (Loc,\n-                  --      Defining_Identifier => Tnn,\n-                  --      Access_Definition =>\n-                  --        Make_Access_Definition (Loc,\n-                  --          All_Present  => True,\n-                  --          Subtype_Mark => New_Occurrence_Of (R_Type, Loc)),\n-                  --      Name =>\n-                  --        Make_Reference (Loc,\n-                  --          Prefix => Relocate_Node (Exp))),\n-                  --    Suppress => All_Checks);\n-\n-                  --  Rewrite (Exp,\n-                  --    Make_Explicit_Dereference (Loc,\n-                  --      Prefix => New_Occurrence_Of (Tnn, Loc)));\n-               end if;\n-            end;\n-         end if;\n-\n-         --  Generate call to _postconditions\n-\n-         Insert_Action (Exp,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name => Make_Identifier (Loc, Name_uPostconditions),\n-             Parameter_Associations => New_List (Duplicate_Subexpr (Exp))));\n-      end if;\n-\n-      --  Ada 2005 (AI-251): If this return statement corresponds with an\n-      --  simple return statement associated with an extended return statement\n-      --  and the type of the returned object is an interface then generate an\n-      --  implicit conversion to force displacement of the \"this\" pointer.\n-\n-      if Ada_Version >= Ada_05\n-        and then Comes_From_Extended_Return_Statement (N)\n-        and then Nkind (Expression (N)) = N_Identifier\n-        and then Is_Interface (Utyp)\n-        and then Utyp /= Underlying_Type (Exptyp)\n-      then\n-         Rewrite (Exp, Convert_To (Utyp, Relocate_Node (Exp)));\n-         Analyze_And_Resolve (Exp);\n-      end if;\n-   end Expand_Simple_Function_Return;\n-\n    ------------------------------\n    -- Make_Tag_Ctrl_Assignment --\n    ------------------------------"}, {"sha": "7967164729d4b5dde40a5224fd48d783bcf83974", "filename": "gcc/ada/exp_ch5.ads", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fexp_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fexp_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.ads?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,9 +32,7 @@ package Exp_Ch5 is\n    procedure Expand_N_Block_Statement           (N : Node_Id);\n    procedure Expand_N_Case_Statement            (N : Node_Id);\n    procedure Expand_N_Exit_Statement            (N : Node_Id);\n-   procedure Expand_N_Extended_Return_Statement (N : Node_Id);\n    procedure Expand_N_Goto_Statement            (N : Node_Id);\n    procedure Expand_N_If_Statement              (N : Node_Id);\n    procedure Expand_N_Loop_Statement            (N : Node_Id);\n-   procedure Expand_N_Simple_Return_Statement   (N : Node_Id);\n end Exp_Ch5;"}, {"sha": "c439a91e01ddaae417b72a71b82a7f60a9e0a33f", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1490, "deletions": 0, "changes": 1490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -69,6 +69,7 @@ with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n with Validsw;  use Validsw;\n@@ -202,6 +203,12 @@ package body Exp_Ch6 is\n    --  expressions in the body must be converted to the desired type (which\n    --  is simply not noted in the tree without inline expansion).\n \n+   procedure Expand_Non_Function_Return (N : Node_Id);\n+   --  Called by Expand_N_Simple_Return_Statement in case we're returning from\n+   --  a procedure body, entry body, accept statement, or extended return\n+   --  statement.  Note that all non-function returns are simple return\n+   --  statements.\n+\n    function Expand_Protected_Object_Reference\n      (N    : Node_Id;\n       Scop : Entity_Id) return Node_Id;\n@@ -219,6 +226,10 @@ package body Exp_Ch6 is\n    --  Predicate to recognize stubbed procedures and null procedures, which\n    --  can be inlined unconditionally in all cases.\n \n+   procedure Expand_Simple_Function_Return (N : Node_Id);\n+   --  Expand simple return from function. In the case where we are returning\n+   --  from a function body this is called by Expand_N_Simple_Return_Statement.\n+\n    ----------------------------------------------\n    -- Add_Access_Actual_To_Build_In_Place_Call --\n    ----------------------------------------------\n@@ -4076,6 +4087,728 @@ package body Exp_Ch6 is\n       end loop;\n    end Expand_Inlined_Call;\n \n+   ----------------------------------------\n+   -- Expand_N_Extended_Return_Statement --\n+   ----------------------------------------\n+\n+   --  If there is a Handled_Statement_Sequence, we rewrite this:\n+\n+   --     return Result : T := <expression> do\n+   --        <handled_seq_of_stms>\n+   --     end return;\n+\n+   --  to be:\n+\n+   --     declare\n+   --        Result : T := <expression>;\n+   --     begin\n+   --        <handled_seq_of_stms>\n+   --        return Result;\n+   --     end;\n+\n+   --  Otherwise (no Handled_Statement_Sequence), we rewrite this:\n+\n+   --     return Result : T := <expression>;\n+\n+   --  to be:\n+\n+   --     return <expression>;\n+\n+   --  unless it's build-in-place or there's no <expression>, in which case\n+   --  we generate:\n+\n+   --     declare\n+   --        Result : T := <expression>;\n+   --     begin\n+   --        return Result;\n+   --     end;\n+\n+   --  Note that this case could have been written by the user as an extended\n+   --  return statement, or could have been transformed to this from a simple\n+   --  return statement.\n+\n+   --  That is, we need to have a reified return object if there are statements\n+   --  (which might refer to it) or if we're doing build-in-place (so we can\n+   --  set its address to the final resting place or if there is no expression\n+   --  (in which case default initial values might need to be set).\n+\n+   procedure Expand_N_Extended_Return_Statement (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Return_Object_Entity : constant Entity_Id :=\n+                               First_Entity (Return_Statement_Entity (N));\n+      Return_Object_Decl   : constant Node_Id :=\n+                               Parent (Return_Object_Entity);\n+      Parent_Function      : constant Entity_Id :=\n+                               Return_Applies_To (Return_Statement_Entity (N));\n+      Parent_Function_Typ  : constant Entity_Id := Etype (Parent_Function);\n+      Is_Build_In_Place    : constant Boolean :=\n+                               Is_Build_In_Place_Function (Parent_Function);\n+\n+      Return_Stm      : Node_Id;\n+      Statements      : List_Id;\n+      Handled_Stm_Seq : Node_Id;\n+      Result          : Node_Id;\n+      Exp             : Node_Id;\n+\n+      function Has_Controlled_Parts (Typ : Entity_Id) return Boolean;\n+      --  Determine whether type Typ is controlled or contains a controlled\n+      --  subcomponent.\n+\n+      function Move_Activation_Chain return Node_Id;\n+      --  Construct a call to System.Tasking.Stages.Move_Activation_Chain\n+      --  with parameters:\n+      --    From         current activation chain\n+      --    To           activation chain passed in by the caller\n+      --    New_Master   master passed in by the caller\n+\n+      function Move_Final_List return Node_Id;\n+      --  Construct call to System.Finalization_Implementation.Move_Final_List\n+      --  with parameters:\n+      --\n+      --    From         finalization list of the return statement\n+      --    To           finalization list passed in by the caller\n+\n+      --------------------------\n+      -- Has_Controlled_Parts --\n+      --------------------------\n+\n+      function Has_Controlled_Parts (Typ : Entity_Id) return Boolean is\n+      begin\n+         return\n+           Is_Controlled (Typ)\n+             or else Has_Controlled_Component (Typ);\n+      end Has_Controlled_Parts;\n+\n+      ---------------------------\n+      -- Move_Activation_Chain --\n+      ---------------------------\n+\n+      function Move_Activation_Chain return Node_Id is\n+         Activation_Chain_Formal : constant Entity_Id :=\n+                                     Build_In_Place_Formal\n+                                       (Parent_Function, BIP_Activation_Chain);\n+         To                      : constant Node_Id :=\n+                                     New_Reference_To\n+                                       (Activation_Chain_Formal, Loc);\n+         Master_Formal           : constant Entity_Id :=\n+                                     Build_In_Place_Formal\n+                                       (Parent_Function, BIP_Master);\n+         New_Master              : constant Node_Id :=\n+                                     New_Reference_To (Master_Formal, Loc);\n+\n+         Chain_Entity : Entity_Id;\n+         From         : Node_Id;\n+\n+      begin\n+         Chain_Entity := First_Entity (Return_Statement_Entity (N));\n+         while Chars (Chain_Entity) /= Name_uChain loop\n+            Chain_Entity := Next_Entity (Chain_Entity);\n+         end loop;\n+\n+         From :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Reference_To (Chain_Entity, Loc),\n+             Attribute_Name => Name_Unrestricted_Access);\n+         --  ??? Not clear why \"Make_Identifier (Loc, Name_uChain)\" doesn't\n+         --  work, instead of \"New_Reference_To (Chain_Entity, Loc)\" above.\n+\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To (RTE (RE_Move_Activation_Chain), Loc),\n+             Parameter_Associations => New_List (From, To, New_Master));\n+      end Move_Activation_Chain;\n+\n+      ---------------------\n+      -- Move_Final_List --\n+      ---------------------\n+\n+      function Move_Final_List return Node_Id is\n+         Flist : constant Entity_Id  :=\n+                   Finalization_Chain_Entity (Return_Statement_Entity (N));\n+\n+         From : constant Node_Id := New_Reference_To (Flist, Loc);\n+\n+         Caller_Final_List : constant Entity_Id :=\n+                               Build_In_Place_Formal\n+                                 (Parent_Function, BIP_Final_List);\n+\n+         To : constant Node_Id := New_Reference_To (Caller_Final_List, Loc);\n+\n+      begin\n+         --  Catch cases where a finalization chain entity has not been\n+         --  associated with the return statement entity.\n+\n+         pragma Assert (Present (Flist));\n+\n+         --  Build required call\n+\n+         return\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Op_Ne (Loc,\n+                 Left_Opnd  => New_Copy (From),\n+                 Right_Opnd => New_Node (N_Null, Loc)),\n+             Then_Statements =>\n+               New_List (\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name => New_Reference_To (RTE (RE_Move_Final_List), Loc),\n+                   Parameter_Associations => New_List (From, To))));\n+      end Move_Final_List;\n+\n+   --  Start of processing for Expand_N_Extended_Return_Statement\n+\n+   begin\n+      if Nkind (Return_Object_Decl) = N_Object_Declaration then\n+         Exp := Expression (Return_Object_Decl);\n+      else\n+         Exp := Empty;\n+      end if;\n+\n+      Handled_Stm_Seq := Handled_Statement_Sequence (N);\n+\n+      --  Build a simple_return_statement that returns the return object when\n+      --  there is a statement sequence, or no expression, or the result will\n+      --  be built in place. Note however that we currently do this for all\n+      --  composite cases, even though nonlimited composite results are not yet\n+      --  built in place (though we plan to do so eventually).\n+\n+      if Present (Handled_Stm_Seq)\n+        or else Is_Composite_Type (Etype (Parent_Function))\n+        or else No (Exp)\n+      then\n+         if No (Handled_Stm_Seq) then\n+            Statements := New_List;\n+\n+         --  If the extended return has a handled statement sequence, then wrap\n+         --  it in a block and use the block as the first statement.\n+\n+         else\n+            Statements :=\n+              New_List (Make_Block_Statement (Loc,\n+                          Declarations => New_List,\n+                          Handled_Statement_Sequence => Handled_Stm_Seq));\n+         end if;\n+\n+         --  If control gets past the above Statements, we have successfully\n+         --  completed the return statement. If the result type has controlled\n+         --  parts and the return is for a build-in-place function, then we\n+         --  call Move_Final_List to transfer responsibility for finalization\n+         --  of the return object to the caller. An alternative would be to\n+         --  declare a Success flag in the function, initialize it to False,\n+         --  and set it to True here. Then move the Move_Final_List call into\n+         --  the cleanup code, and check Success. If Success then make a call\n+         --  to Move_Final_List else do finalization. Then we can remove the\n+         --  abort-deferral and the nulling-out of the From parameter from\n+         --  Move_Final_List. Note that the current method is not quite correct\n+         --  in the rather obscure case of a select-then-abort statement whose\n+         --  abortable part contains the return statement.\n+\n+         --  Check the type of the function to determine whether to move the\n+         --  finalization list. A special case arises when processing a simple\n+         --  return statement which has been rewritten as an extended return.\n+         --  In that case check the type of the returned object or the original\n+         --  expression.\n+\n+         if Is_Build_In_Place\n+           and then\n+               (Has_Controlled_Parts (Parent_Function_Typ)\n+                 or else (Is_Class_Wide_Type (Parent_Function_Typ)\n+                           and then\n+                        Has_Controlled_Parts (Root_Type (Parent_Function_Typ)))\n+                 or else Has_Controlled_Parts (Etype (Return_Object_Entity))\n+                 or else (Present (Exp)\n+                           and then Has_Controlled_Parts (Etype (Exp))))\n+         then\n+            Append_To (Statements, Move_Final_List);\n+         end if;\n+\n+         --  Similarly to the above Move_Final_List, if the result type\n+         --  contains tasks, we call Move_Activation_Chain. Later, the cleanup\n+         --  code will call Complete_Master, which will terminate any\n+         --  unactivated tasks belonging to the return statement master. But\n+         --  Move_Activation_Chain updates their master to be that of the\n+         --  caller, so they will not be terminated unless the return statement\n+         --  completes unsuccessfully due to exception, abort, goto, or exit.\n+         --  As a formality, we test whether the function requires the result\n+         --  to be built in place, though that's necessarily true for the case\n+         --  of result types with task parts.\n+\n+         if Is_Build_In_Place and Has_Task (Etype (Parent_Function)) then\n+            Append_To (Statements, Move_Activation_Chain);\n+         end if;\n+\n+         --  Build a simple_return_statement that returns the return object\n+\n+         Return_Stm :=\n+           Make_Simple_Return_Statement (Loc,\n+             Expression => New_Occurrence_Of (Return_Object_Entity, Loc));\n+         Append_To (Statements, Return_Stm);\n+\n+         Handled_Stm_Seq :=\n+           Make_Handled_Sequence_Of_Statements (Loc, Statements);\n+      end if;\n+\n+      --  Case where we build a block\n+\n+      if Present (Handled_Stm_Seq) then\n+         Result :=\n+           Make_Block_Statement (Loc,\n+             Declarations => Return_Object_Declarations (N),\n+             Handled_Statement_Sequence => Handled_Stm_Seq);\n+\n+         --  We set the entity of the new block statement to be that of the\n+         --  return statement. This is necessary so that various fields, such\n+         --  as Finalization_Chain_Entity carry over from the return statement\n+         --  to the block. Note that this block is unusual, in that its entity\n+         --  is an E_Return_Statement rather than an E_Block.\n+\n+         Set_Identifier\n+           (Result, New_Occurrence_Of (Return_Statement_Entity (N), Loc));\n+\n+         --  If the object decl was already rewritten as a renaming, then\n+         --  we don't want to do the object allocation and transformation of\n+         --  of the return object declaration to a renaming. This case occurs\n+         --  when the return object is initialized by a call to another\n+         --  build-in-place function, and that function is responsible for the\n+         --  allocation of the return object.\n+\n+         if Is_Build_In_Place\n+           and then\n+             Nkind (Return_Object_Decl) = N_Object_Renaming_Declaration\n+         then\n+            pragma Assert (Nkind (Original_Node (Return_Object_Decl)) =\n+                            N_Object_Declaration\n+              and then Is_Build_In_Place_Function_Call\n+                         (Expression (Original_Node (Return_Object_Decl))));\n+\n+            Set_By_Ref (Return_Stm);  -- Return build-in-place results by ref\n+\n+         elsif Is_Build_In_Place then\n+\n+            --  Locate the implicit access parameter associated with the\n+            --  caller-supplied return object and convert the return\n+            --  statement's return object declaration to a renaming of a\n+            --  dereference of the access parameter. If the return object's\n+            --  declaration includes an expression that has not already been\n+            --  expanded as separate assignments, then add an assignment\n+            --  statement to ensure the return object gets initialized.\n+\n+            --  declare\n+            --     Result : T [:= <expression>];\n+            --  begin\n+            --     ...\n+\n+            --  is converted to\n+\n+            --  declare\n+            --     Result : T renames FuncRA.all;\n+            --     [Result := <expression;]\n+            --  begin\n+            --     ...\n+\n+            declare\n+               Return_Obj_Id    : constant Entity_Id :=\n+                                    Defining_Identifier (Return_Object_Decl);\n+               Return_Obj_Typ   : constant Entity_Id := Etype (Return_Obj_Id);\n+               Return_Obj_Expr  : constant Node_Id :=\n+                                    Expression (Return_Object_Decl);\n+               Result_Subt      : constant Entity_Id :=\n+                                    Etype (Parent_Function);\n+               Constr_Result    : constant Boolean :=\n+                                    Is_Constrained (Result_Subt);\n+               Obj_Alloc_Formal : Entity_Id;\n+               Object_Access    : Entity_Id;\n+               Obj_Acc_Deref    : Node_Id;\n+               Init_Assignment  : Node_Id := Empty;\n+\n+            begin\n+               --  Build-in-place results must be returned by reference\n+\n+               Set_By_Ref (Return_Stm);\n+\n+               --  Retrieve the implicit access parameter passed by the caller\n+\n+               Object_Access :=\n+                 Build_In_Place_Formal (Parent_Function, BIP_Object_Access);\n+\n+               --  If the return object's declaration includes an expression\n+               --  and the declaration isn't marked as No_Initialization, then\n+               --  we need to generate an assignment to the object and insert\n+               --  it after the declaration before rewriting it as a renaming\n+               --  (otherwise we'll lose the initialization). The case where\n+               --  the result type is an interface (or class-wide interface)\n+               --  is also excluded because the context of the function call\n+               --  must be unconstrained, so the initialization will always\n+               --  be done as part of an allocator evaluation (storage pool\n+               --  or secondary stack), never to a constrained target object\n+               --  passed in by the caller. Besides the assignment being\n+               --  unneeded in this case, it avoids problems with trying to\n+               --  generate a dispatching assignment when the return expression\n+               --  is a nonlimited descendant of a limited interface (the\n+               --  interface has no assignment operation).\n+\n+               if Present (Return_Obj_Expr)\n+                 and then not No_Initialization (Return_Object_Decl)\n+                 and then not Is_Interface (Return_Obj_Typ)\n+               then\n+                  Init_Assignment :=\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Reference_To (Return_Obj_Id, Loc),\n+                      Expression => Relocate_Node (Return_Obj_Expr));\n+                  Set_Etype (Name (Init_Assignment), Etype (Return_Obj_Id));\n+                  Set_Assignment_OK (Name (Init_Assignment));\n+                  Set_No_Ctrl_Actions (Init_Assignment);\n+\n+                  Set_Parent (Name (Init_Assignment), Init_Assignment);\n+                  Set_Parent (Expression (Init_Assignment), Init_Assignment);\n+\n+                  Set_Expression (Return_Object_Decl, Empty);\n+\n+                  if Is_Class_Wide_Type (Etype (Return_Obj_Id))\n+                    and then not Is_Class_Wide_Type\n+                                   (Etype (Expression (Init_Assignment)))\n+                  then\n+                     Rewrite (Expression (Init_Assignment),\n+                       Make_Type_Conversion (Loc,\n+                         Subtype_Mark =>\n+                           New_Occurrence_Of\n+                             (Etype (Return_Obj_Id), Loc),\n+                         Expression =>\n+                           Relocate_Node (Expression (Init_Assignment))));\n+                  end if;\n+\n+                  --  In the case of functions where the calling context can\n+                  --  determine the form of allocation needed, initialization\n+                  --  is done with each part of the if statement that handles\n+                  --  the different forms of allocation (this is true for\n+                  --  unconstrained and tagged result subtypes).\n+\n+                  if Constr_Result\n+                    and then not Is_Tagged_Type (Underlying_Type (Result_Subt))\n+                  then\n+                     Insert_After (Return_Object_Decl, Init_Assignment);\n+                  end if;\n+               end if;\n+\n+               --  When the function's subtype is unconstrained, a run-time\n+               --  test is needed to determine the form of allocation to use\n+               --  for the return object. The function has an implicit formal\n+               --  parameter indicating this. If the BIP_Alloc_Form formal has\n+               --  the value one, then the caller has passed access to an\n+               --  existing object for use as the return object. If the value\n+               --  is two, then the return object must be allocated on the\n+               --  secondary stack. Otherwise, the object must be allocated in\n+               --  a storage pool (currently only supported for the global\n+               --  heap, user-defined storage pools TBD ???). We generate an\n+               --  if statement to test the implicit allocation formal and\n+               --  initialize a local access value appropriately, creating\n+               --  allocators in the secondary stack and global heap cases.\n+               --  The special formal also exists and must be tested when the\n+               --  function has a tagged result, even when the result subtype\n+               --  is constrained, because in general such functions can be\n+               --  called in dispatching contexts and must be handled similarly\n+               --  to functions with a class-wide result.\n+\n+               if not Constr_Result\n+                 or else Is_Tagged_Type (Underlying_Type (Result_Subt))\n+               then\n+                  Obj_Alloc_Formal :=\n+                    Build_In_Place_Formal (Parent_Function, BIP_Alloc_Form);\n+\n+                  declare\n+                     Ref_Type       : Entity_Id;\n+                     Ptr_Type_Decl  : Node_Id;\n+                     Alloc_Obj_Id   : Entity_Id;\n+                     Alloc_Obj_Decl : Node_Id;\n+                     Alloc_If_Stmt  : Node_Id;\n+                     SS_Allocator   : Node_Id;\n+                     Heap_Allocator : Node_Id;\n+\n+                  begin\n+                     --  Reuse the itype created for the function's implicit\n+                     --  access formal. This avoids the need to create a new\n+                     --  access type here, plus it allows assigning the access\n+                     --  formal directly without applying a conversion.\n+\n+                     --  Ref_Type := Etype (Object_Access);\n+\n+                     --  Create an access type designating the function's\n+                     --  result subtype.\n+\n+                     Ref_Type := Make_Temporary (Loc, 'A');\n+\n+                     Ptr_Type_Decl :=\n+                       Make_Full_Type_Declaration (Loc,\n+                         Defining_Identifier => Ref_Type,\n+                         Type_Definition =>\n+                           Make_Access_To_Object_Definition (Loc,\n+                             All_Present => True,\n+                             Subtype_Indication =>\n+                               New_Reference_To (Return_Obj_Typ, Loc)));\n+\n+                     Insert_Before (Return_Object_Decl, Ptr_Type_Decl);\n+\n+                     --  Create an access object that will be initialized to an\n+                     --  access value denoting the return object, either coming\n+                     --  from an implicit access value passed in by the caller\n+                     --  or from the result of an allocator.\n+\n+                     Alloc_Obj_Id := Make_Temporary (Loc, 'R');\n+                     Set_Etype (Alloc_Obj_Id, Ref_Type);\n+\n+                     Alloc_Obj_Decl :=\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => Alloc_Obj_Id,\n+                         Object_Definition   => New_Reference_To\n+                                                  (Ref_Type, Loc));\n+\n+                     Insert_Before (Return_Object_Decl, Alloc_Obj_Decl);\n+\n+                     --  Create allocators for both the secondary stack and\n+                     --  global heap. If there's an initialization expression,\n+                     --  then create these as initialized allocators.\n+\n+                     if Present (Return_Obj_Expr)\n+                       and then not No_Initialization (Return_Object_Decl)\n+                     then\n+                        --  Always use the type of the expression for the\n+                        --  qualified expression, rather than the result type.\n+                        --  In general we cannot always use the result type\n+                        --  for the allocator, because the expression might be\n+                        --  of a specific type, such as in the case of an\n+                        --  aggregate or even a nonlimited object when the\n+                        --  result type is a limited class-wide interface type.\n+\n+                        Heap_Allocator :=\n+                          Make_Allocator (Loc,\n+                            Expression =>\n+                              Make_Qualified_Expression (Loc,\n+                                Subtype_Mark =>\n+                                  New_Reference_To\n+                                    (Etype (Return_Obj_Expr), Loc),\n+                                Expression =>\n+                                  New_Copy_Tree (Return_Obj_Expr)));\n+\n+                     else\n+                        --  If the function returns a class-wide type we cannot\n+                        --  use the return type for the allocator. Instead we\n+                        --  use the type of the expression, which must be an\n+                        --  aggregate of a definite type.\n+\n+                        if Is_Class_Wide_Type (Return_Obj_Typ) then\n+                           Heap_Allocator :=\n+                             Make_Allocator (Loc,\n+                               Expression =>\n+                                 New_Reference_To\n+                                   (Etype (Return_Obj_Expr), Loc));\n+                        else\n+                           Heap_Allocator :=\n+                             Make_Allocator (Loc,\n+                               Expression =>\n+                                 New_Reference_To (Return_Obj_Typ, Loc));\n+                        end if;\n+\n+                        --  If the object requires default initialization then\n+                        --  that will happen later following the elaboration of\n+                        --  the object renaming. If we don't turn it off here\n+                        --  then the object will be default initialized twice.\n+\n+                        Set_No_Initialization (Heap_Allocator);\n+                     end if;\n+\n+                     --  If the No_Allocators restriction is active, then only\n+                     --  an allocator for secondary stack allocation is needed.\n+                     --  It's OK for such allocators to have Comes_From_Source\n+                     --  set to False, because gigi knows not to flag them as\n+                     --  being a violation of No_Implicit_Heap_Allocations.\n+\n+                     if Restriction_Active (No_Allocators) then\n+                        SS_Allocator   := Heap_Allocator;\n+                        Heap_Allocator := Make_Null (Loc);\n+\n+                     --  Otherwise the heap allocator may be needed, so we make\n+                     --  another allocator for secondary stack allocation.\n+\n+                     else\n+                        SS_Allocator := New_Copy_Tree (Heap_Allocator);\n+\n+                        --  The heap allocator is marked Comes_From_Source\n+                        --  since it corresponds to an explicit user-written\n+                        --  allocator (that is, it will only be executed on\n+                        --  behalf of callers that call the function as\n+                        --  initialization for such an allocator). This\n+                        --  prevents errors when No_Implicit_Heap_Allocations\n+                        --  is in force.\n+\n+                        Set_Comes_From_Source (Heap_Allocator, True);\n+                     end if;\n+\n+                     --  The allocator is returned on the secondary stack. We\n+                     --  don't do this on VM targets, since the SS is not used.\n+\n+                     if VM_Target = No_VM then\n+                        Set_Storage_Pool (SS_Allocator, RTE (RE_SS_Pool));\n+                        Set_Procedure_To_Call\n+                          (SS_Allocator, RTE (RE_SS_Allocate));\n+\n+                        --  The allocator is returned on the secondary stack,\n+                        --  so indicate that the function return, as well as\n+                        --  the block that encloses the allocator, must not\n+                        --  release it. The flags must be set now because the\n+                        --  decision to use the secondary stack is done very\n+                        --  late in the course of expanding the return\n+                        --  statement, past the point where these flags are\n+                        --  normally set.\n+\n+                        Set_Sec_Stack_Needed_For_Return (Parent_Function);\n+                        Set_Sec_Stack_Needed_For_Return\n+                          (Return_Statement_Entity (N));\n+                        Set_Uses_Sec_Stack (Parent_Function);\n+                        Set_Uses_Sec_Stack (Return_Statement_Entity (N));\n+                     end if;\n+\n+                     --  Create an if statement to test the BIP_Alloc_Form\n+                     --  formal and initialize the access object to either the\n+                     --  BIP_Object_Access formal (BIP_Alloc_Form = 0), the\n+                     --  result of allocating the object in the secondary stack\n+                     --  (BIP_Alloc_Form = 1), or else an allocator to create\n+                     --  the return object in the heap (BIP_Alloc_Form = 2).\n+\n+                     --  ??? An unchecked type conversion must be made in the\n+                     --  case of assigning the access object formal to the\n+                     --  local access object, because a normal conversion would\n+                     --  be illegal in some cases (such as converting access-\n+                     --  to-unconstrained to access-to-constrained), but the\n+                     --  the unchecked conversion will presumably fail to work\n+                     --  right in just such cases. It's not clear at all how to\n+                     --  handle this. ???\n+\n+                     Alloc_If_Stmt :=\n+                       Make_If_Statement (Loc,\n+                         Condition       =>\n+                           Make_Op_Eq (Loc,\n+                             Left_Opnd =>\n+                               New_Reference_To (Obj_Alloc_Formal, Loc),\n+                             Right_Opnd =>\n+                               Make_Integer_Literal (Loc,\n+                                 UI_From_Int (BIP_Allocation_Form'Pos\n+                                                (Caller_Allocation)))),\n+                         Then_Statements =>\n+                           New_List (Make_Assignment_Statement (Loc,\n+                                       Name       =>\n+                                         New_Reference_To\n+                                           (Alloc_Obj_Id, Loc),\n+                                       Expression =>\n+                                         Make_Unchecked_Type_Conversion (Loc,\n+                                           Subtype_Mark =>\n+                                             New_Reference_To (Ref_Type, Loc),\n+                                           Expression =>\n+                                             New_Reference_To\n+                                               (Object_Access, Loc)))),\n+                         Elsif_Parts     =>\n+                           New_List (Make_Elsif_Part (Loc,\n+                                       Condition       =>\n+                                         Make_Op_Eq (Loc,\n+                                           Left_Opnd =>\n+                                             New_Reference_To\n+                                               (Obj_Alloc_Formal, Loc),\n+                                           Right_Opnd =>\n+                                             Make_Integer_Literal (Loc,\n+                                               UI_From_Int (\n+                                                 BIP_Allocation_Form'Pos\n+                                                    (Secondary_Stack)))),\n+                                       Then_Statements =>\n+                                          New_List\n+                                            (Make_Assignment_Statement (Loc,\n+                                               Name       =>\n+                                                 New_Reference_To\n+                                                   (Alloc_Obj_Id, Loc),\n+                                               Expression =>\n+                                                 SS_Allocator)))),\n+                         Else_Statements =>\n+                           New_List (Make_Assignment_Statement (Loc,\n+                                        Name       =>\n+                                          New_Reference_To\n+                                            (Alloc_Obj_Id, Loc),\n+                                        Expression =>\n+                                          Heap_Allocator)));\n+\n+                     --  If a separate initialization assignment was created\n+                     --  earlier, append that following the assignment of the\n+                     --  implicit access formal to the access object, to ensure\n+                     --  that the return object is initialized in that case.\n+                     --  In this situation, the target of the assignment must\n+                     --  be rewritten to denote a dereference of the access to\n+                     --  the return object passed in by the caller.\n+\n+                     if Present (Init_Assignment) then\n+                        Rewrite (Name (Init_Assignment),\n+                          Make_Explicit_Dereference (Loc,\n+                            Prefix => New_Reference_To (Alloc_Obj_Id, Loc)));\n+                        Set_Etype\n+                          (Name (Init_Assignment), Etype (Return_Obj_Id));\n+\n+                        Append_To\n+                          (Then_Statements (Alloc_If_Stmt),\n+                           Init_Assignment);\n+                     end if;\n+\n+                     Insert_Before (Return_Object_Decl, Alloc_If_Stmt);\n+\n+                     --  Remember the local access object for use in the\n+                     --  dereference of the renaming created below.\n+\n+                     Object_Access := Alloc_Obj_Id;\n+                  end;\n+               end if;\n+\n+               --  Replace the return object declaration with a renaming of a\n+               --  dereference of the access value designating the return\n+               --  object.\n+\n+               Obj_Acc_Deref :=\n+                 Make_Explicit_Dereference (Loc,\n+                   Prefix => New_Reference_To (Object_Access, Loc));\n+\n+               Rewrite (Return_Object_Decl,\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier => Return_Obj_Id,\n+                   Access_Definition   => Empty,\n+                   Subtype_Mark        => New_Occurrence_Of\n+                                            (Return_Obj_Typ, Loc),\n+                   Name                => Obj_Acc_Deref));\n+\n+               Set_Renamed_Object (Return_Obj_Id, Obj_Acc_Deref);\n+            end;\n+         end if;\n+\n+      --  Case where we do not build a block\n+\n+      else\n+         --  We're about to drop Return_Object_Declarations on the floor, so\n+         --  we need to insert it, in case it got expanded into useful code.\n+         --  Remove side effects from expression, which may be duplicated in\n+         --  subsequent checks (see Expand_Simple_Function_Return).\n+\n+         Insert_List_Before (N, Return_Object_Declarations (N));\n+         Remove_Side_Effects (Exp);\n+\n+         --  Build simple_return_statement that returns the expression directly\n+\n+         Return_Stm := Make_Simple_Return_Statement (Loc, Expression => Exp);\n+\n+         Result := Return_Stm;\n+      end if;\n+\n+      --  Set the flag to prevent infinite recursion\n+\n+      Set_Comes_From_Extended_Return_Statement (Return_Stm);\n+\n+      Rewrite (N, Result);\n+      Analyze (N);\n+   end Expand_N_Extended_Return_Statement;\n+\n    ----------------------------\n    -- Expand_N_Function_Call --\n    ----------------------------\n@@ -4109,6 +4842,45 @@ package body Exp_Ch6 is\n       Expand_Call (N);\n    end Expand_N_Procedure_Call_Statement;\n \n+   --------------------------------------\n+   -- Expand_N_Simple_Return_Statement --\n+   --------------------------------------\n+\n+   procedure Expand_N_Simple_Return_Statement (N : Node_Id) is\n+   begin\n+      --  Defend against previous errors (i.e. the return statement calls a\n+      --  function that is not available in configurable runtime).\n+\n+      if Present (Expression (N))\n+        and then Nkind (Expression (N)) = N_Empty\n+      then\n+         return;\n+      end if;\n+\n+      --  Distinguish the function and non-function cases:\n+\n+      case Ekind (Return_Applies_To (Return_Statement_Entity (N))) is\n+\n+         when E_Function          |\n+              E_Generic_Function  =>\n+            Expand_Simple_Function_Return (N);\n+\n+         when E_Procedure         |\n+              E_Generic_Procedure |\n+              E_Entry             |\n+              E_Entry_Family      |\n+              E_Return_Statement =>\n+            Expand_Non_Function_Return (N);\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+\n+   exception\n+      when RE_Not_Available =>\n+         return;\n+   end Expand_N_Simple_Return_Statement;\n+\n    ------------------------------\n    -- Expand_N_Subprogram_Body --\n    ------------------------------\n@@ -4619,6 +5391,122 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_N_Subprogram_Declaration;\n \n+   --------------------------------\n+   -- Expand_Non_Function_Return --\n+   --------------------------------\n+\n+   procedure Expand_Non_Function_Return (N : Node_Id) is\n+      pragma Assert (No (Expression (N)));\n+\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Scope_Id    : Entity_Id :=\n+                      Return_Applies_To (Return_Statement_Entity (N));\n+      Kind        : constant Entity_Kind := Ekind (Scope_Id);\n+      Call        : Node_Id;\n+      Acc_Stat    : Node_Id;\n+      Goto_Stat   : Node_Id;\n+      Lab_Node    : Node_Id;\n+\n+   begin\n+      --  Call _Postconditions procedure if procedure with active\n+      --  postconditions. Here, we use the Postcondition_Proc attribute, which\n+      --  is needed for implicitly-generated returns. Functions never\n+      --  have implicitly-generated returns, and there's no room for\n+      --  Postcondition_Proc in E_Function, so we look up the identifier\n+      --  Name_uPostconditions for function returns (see\n+      --  Expand_Simple_Function_Return).\n+\n+      if Ekind (Scope_Id) = E_Procedure\n+        and then Has_Postconditions (Scope_Id)\n+      then\n+         pragma Assert (Present (Postcondition_Proc (Scope_Id)));\n+         Insert_Action (N,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To (Postcondition_Proc (Scope_Id), Loc)));\n+      end if;\n+\n+      --  If it is a return from a procedure do no extra steps\n+\n+      if Kind = E_Procedure or else Kind = E_Generic_Procedure then\n+         return;\n+\n+      --  If it is a nested return within an extended one, replace it with a\n+      --  return of the previously declared return object.\n+\n+      elsif Kind = E_Return_Statement then\n+         Rewrite (N,\n+           Make_Simple_Return_Statement (Loc,\n+             Expression =>\n+               New_Occurrence_Of (First_Entity (Scope_Id), Loc)));\n+         Set_Comes_From_Extended_Return_Statement (N);\n+         Set_Return_Statement_Entity (N, Scope_Id);\n+         Expand_Simple_Function_Return (N);\n+         return;\n+      end if;\n+\n+      pragma Assert (Is_Entry (Scope_Id));\n+\n+      --  Look at the enclosing block to see whether the return is from an\n+      --  accept statement or an entry body.\n+\n+      for J in reverse 0 .. Scope_Stack.Last loop\n+         Scope_Id := Scope_Stack.Table (J).Entity;\n+         exit when Is_Concurrent_Type (Scope_Id);\n+      end loop;\n+\n+      --  If it is a return from accept statement it is expanded as call to\n+      --  RTS Complete_Rendezvous and a goto to the end of the accept body.\n+\n+      --  (cf : Expand_N_Accept_Statement, Expand_N_Selective_Accept,\n+      --  Expand_N_Accept_Alternative in exp_ch9.adb)\n+\n+      if Is_Task_Type (Scope_Id) then\n+\n+         Call :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To (RTE (RE_Complete_Rendezvous), Loc));\n+         Insert_Before (N, Call);\n+         --  why not insert actions here???\n+         Analyze (Call);\n+\n+         Acc_Stat := Parent (N);\n+         while Nkind (Acc_Stat) /= N_Accept_Statement loop\n+            Acc_Stat := Parent (Acc_Stat);\n+         end loop;\n+\n+         Lab_Node := Last (Statements\n+           (Handled_Statement_Sequence (Acc_Stat)));\n+\n+         Goto_Stat := Make_Goto_Statement (Loc,\n+           Name => New_Occurrence_Of\n+             (Entity (Identifier (Lab_Node)), Loc));\n+\n+         Set_Analyzed (Goto_Stat);\n+\n+         Rewrite (N, Goto_Stat);\n+         Analyze (N);\n+\n+      --  If it is a return from an entry body, put a Complete_Entry_Body call\n+      --  in front of the return.\n+\n+      elsif Is_Protected_Type (Scope_Id) then\n+         Call :=\n+           Make_Procedure_Call_Statement (Loc,\n+             Name =>\n+               New_Reference_To (RTE (RE_Complete_Entry_Body), Loc),\n+             Parameter_Associations => New_List (\n+               Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   New_Reference_To\n+                     (Find_Protection_Object (Current_Scope), Loc),\n+                 Attribute_Name =>\n+                   Name_Unchecked_Access)));\n+\n+         Insert_Before (N, Call);\n+         Analyze (Call);\n+      end if;\n+   end Expand_Non_Function_Return;\n+\n    ---------------------------------------\n    -- Expand_Protected_Object_Reference --\n    ---------------------------------------\n@@ -4789,6 +5677,608 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Protected_Subprogram_Call;\n \n+   -----------------------------------\n+   -- Expand_Simple_Function_Return --\n+   -----------------------------------\n+\n+   --  The \"simple\" comes from the syntax rule simple_return_statement.\n+   --  The semantics are not at all simple!\n+\n+   procedure Expand_Simple_Function_Return (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Scope_Id : constant Entity_Id :=\n+                   Return_Applies_To (Return_Statement_Entity (N));\n+      --  The function we are returning from\n+\n+      R_Type : constant Entity_Id := Etype (Scope_Id);\n+      --  The result type of the function\n+\n+      Utyp : constant Entity_Id := Underlying_Type (R_Type);\n+\n+      Exp : constant Node_Id := Expression (N);\n+      pragma Assert (Present (Exp));\n+\n+      Exptyp : constant Entity_Id := Etype (Exp);\n+      --  The type of the expression (not necessarily the same as R_Type)\n+\n+      Subtype_Ind : Node_Id;\n+      --  If the result type of the function is class-wide and the\n+      --  expression has a specific type, then we use the expression's\n+      --  type as the type of the return object. In cases where the\n+      --  expression is an aggregate that is built in place, this avoids\n+      --  the need for an expensive conversion of the return object to\n+      --  the specific type on assignments to the individual components.\n+\n+   begin\n+      if Is_Class_Wide_Type (R_Type)\n+        and then not Is_Class_Wide_Type (Etype (Exp))\n+      then\n+         Subtype_Ind := New_Occurrence_Of (Etype (Exp), Loc);\n+      else\n+         Subtype_Ind := New_Occurrence_Of (R_Type, Loc);\n+      end if;\n+\n+      --  For the case of a simple return that does not come from an extended\n+      --  return, in the case of Ada 2005 where we are returning a limited\n+      --  type, we rewrite \"return <expression>;\" to be:\n+\n+      --    return _anon_ : <return_subtype> := <expression>\n+\n+      --  The expansion produced by Expand_N_Extended_Return_Statement will\n+      --  contain simple return statements (for example, a block containing\n+      --  simple return of the return object), which brings us back here with\n+      --  Comes_From_Extended_Return_Statement set. The reason for the barrier\n+      --  checking for a simple return that does not come from an extended\n+      --  return is to avoid this infinite recursion.\n+\n+      --  The reason for this design is that for Ada 2005 limited returns, we\n+      --  need to reify the return object, so we can build it \"in place\", and\n+      --  we need a block statement to hang finalization and tasking stuff.\n+\n+      --  ??? In order to avoid disruption, we avoid translating to extended\n+      --  return except in the cases where we really need to (Ada 2005 for\n+      --  inherently limited). We might prefer to do this translation in all\n+      --  cases (except perhaps for the case of Ada 95 inherently limited),\n+      --  in order to fully exercise the Expand_N_Extended_Return_Statement\n+      --  code. This would also allow us to do the build-in-place optimization\n+      --  for efficiency even in cases where it is semantically not required.\n+\n+      --  As before, we check the type of the return expression rather than the\n+      --  return type of the function, because the latter may be a limited\n+      --  class-wide interface type, which is not a limited type, even though\n+      --  the type of the expression may be.\n+\n+      if not Comes_From_Extended_Return_Statement (N)\n+        and then Is_Immutably_Limited_Type (Etype (Expression (N)))\n+        and then Ada_Version >= Ada_05\n+        and then not Debug_Flag_Dot_L\n+      then\n+         declare\n+            Return_Object_Entity : constant Entity_Id :=\n+                                     Make_Temporary (Loc, 'R', Exp);\n+            Obj_Decl : constant Node_Id :=\n+                         Make_Object_Declaration (Loc,\n+                           Defining_Identifier => Return_Object_Entity,\n+                           Object_Definition   => Subtype_Ind,\n+                           Expression          => Exp);\n+\n+            Ext : constant Node_Id := Make_Extended_Return_Statement (Loc,\n+                    Return_Object_Declarations => New_List (Obj_Decl));\n+            --  Do not perform this high-level optimization if the result type\n+            --  is an interface because the \"this\" pointer must be displaced.\n+\n+         begin\n+            Rewrite (N, Ext);\n+            Analyze (N);\n+            return;\n+         end;\n+      end if;\n+\n+      --  Here we have a simple return statement that is part of the expansion\n+      --  of an extended return statement (either written by the user, or\n+      --  generated by the above code).\n+\n+      --  Always normalize C/Fortran boolean result. This is not always needed,\n+      --  but it seems a good idea to minimize the passing around of non-\n+      --  normalized values, and in any case this handles the processing of\n+      --  barrier functions for protected types, which turn the condition into\n+      --  a return statement.\n+\n+      if Is_Boolean_Type (Exptyp)\n+        and then Nonzero_Is_True (Exptyp)\n+      then\n+         Adjust_Condition (Exp);\n+         Adjust_Result_Type (Exp, Exptyp);\n+      end if;\n+\n+      --  Do validity check if enabled for returns\n+\n+      if Validity_Checks_On\n+        and then Validity_Check_Returns\n+      then\n+         Ensure_Valid (Exp);\n+      end if;\n+\n+      --  Check the result expression of a scalar function against the subtype\n+      --  of the function by inserting a conversion. This conversion must\n+      --  eventually be performed for other classes of types, but for now it's\n+      --  only done for scalars.\n+      --  ???\n+\n+      if Is_Scalar_Type (Exptyp) then\n+         Rewrite (Exp, Convert_To (R_Type, Exp));\n+\n+         --  The expression is resolved to ensure that the conversion gets\n+         --  expanded to generate a possible constraint check.\n+\n+         Analyze_And_Resolve (Exp, R_Type);\n+      end if;\n+\n+      --  Deal with returning variable length objects and controlled types\n+\n+      --  Nothing to do if we are returning by reference, or this is not a\n+      --  type that requires special processing (indicated by the fact that\n+      --  it requires a cleanup scope for the secondary stack case).\n+\n+      if Is_Immutably_Limited_Type (Exptyp)\n+        or else Is_Limited_Interface (Exptyp)\n+      then\n+         null;\n+\n+      elsif not Requires_Transient_Scope (R_Type) then\n+\n+         --  Mutable records with no variable length components are not\n+         --  returned on the sec-stack, so we need to make sure that the\n+         --  backend will only copy back the size of the actual value, and not\n+         --  the maximum size. We create an actual subtype for this purpose.\n+\n+         declare\n+            Ubt  : constant Entity_Id := Underlying_Type (Base_Type (Exptyp));\n+            Decl : Node_Id;\n+            Ent  : Entity_Id;\n+         begin\n+            if Has_Discriminants (Ubt)\n+              and then not Is_Constrained (Ubt)\n+              and then not Has_Unchecked_Union (Ubt)\n+            then\n+               Decl := Build_Actual_Subtype (Ubt, Exp);\n+               Ent := Defining_Identifier (Decl);\n+               Insert_Action (Exp, Decl);\n+               Rewrite (Exp, Unchecked_Convert_To (Ent, Exp));\n+               Analyze_And_Resolve (Exp);\n+            end if;\n+         end;\n+\n+      --  Here if secondary stack is used\n+\n+      else\n+         --  Make sure that no surrounding block will reclaim the secondary\n+         --  stack on which we are going to put the result. Not only may this\n+         --  introduce secondary stack leaks but worse, if the reclamation is\n+         --  done too early, then the result we are returning may get\n+         --  clobbered.\n+\n+         declare\n+            S : Entity_Id;\n+         begin\n+            S := Current_Scope;\n+            while Ekind (S) = E_Block or else Ekind (S) = E_Loop loop\n+               Set_Sec_Stack_Needed_For_Return (S, True);\n+               S := Enclosing_Dynamic_Scope (S);\n+            end loop;\n+         end;\n+\n+         --  Optimize the case where the result is a function call. In this\n+         --  case either the result is already on the secondary stack, or is\n+         --  already being returned with the stack pointer depressed and no\n+         --  further processing is required except to set the By_Ref flag to\n+         --  ensure that gigi does not attempt an extra unnecessary copy.\n+         --  (actually not just unnecessary but harmfully wrong in the case\n+         --  of a controlled type, where gigi does not know how to do a copy).\n+         --  To make up for a gcc 2.8.1 deficiency (???), we perform\n+         --  the copy for array types if the constrained status of the\n+         --  target type is different from that of the expression.\n+\n+         if Requires_Transient_Scope (Exptyp)\n+           and then\n+              (not Is_Array_Type (Exptyp)\n+                or else Is_Constrained (Exptyp) = Is_Constrained (R_Type)\n+                or else CW_Or_Has_Controlled_Part (Utyp))\n+           and then Nkind (Exp) = N_Function_Call\n+         then\n+            Set_By_Ref (N);\n+\n+            --  Remove side effects from the expression now so that other parts\n+            --  of the expander do not have to reanalyze this node without this\n+            --  optimization\n+\n+            Rewrite (Exp, Duplicate_Subexpr_No_Checks (Exp));\n+\n+         --  For controlled types, do the allocation on the secondary stack\n+         --  manually in order to call adjust at the right time:\n+\n+         --    type Anon1 is access R_Type;\n+         --    for Anon1'Storage_pool use ss_pool;\n+         --    Anon2 : anon1 := new R_Type'(expr);\n+         --    return Anon2.all;\n+\n+         --  We do the same for classwide types that are not potentially\n+         --  controlled (by the virtue of restriction No_Finalization) because\n+         --  gigi is not able to properly allocate class-wide types.\n+\n+         elsif CW_Or_Has_Controlled_Part (Utyp) then\n+            declare\n+               Loc        : constant Source_Ptr := Sloc (N);\n+               Acc_Typ    : constant Entity_Id := Make_Temporary (Loc, 'A');\n+               Alloc_Node : Node_Id;\n+               Temp       : Entity_Id;\n+\n+            begin\n+               Set_Ekind (Acc_Typ, E_Access_Type);\n+\n+               Set_Associated_Storage_Pool (Acc_Typ, RTE (RE_SS_Pool));\n+\n+               --  This is an allocator for the secondary stack, and it's fine\n+               --  to have Comes_From_Source set False on it, as gigi knows not\n+               --  to flag it as a violation of No_Implicit_Heap_Allocations.\n+\n+               Alloc_Node :=\n+                 Make_Allocator (Loc,\n+                   Expression =>\n+                     Make_Qualified_Expression (Loc,\n+                       Subtype_Mark => New_Reference_To (Etype (Exp), Loc),\n+                       Expression   => Relocate_Node (Exp)));\n+\n+               --  We do not want discriminant checks on the declaration,\n+               --  given that it gets its value from the allocator.\n+\n+               Set_No_Initialization (Alloc_Node);\n+\n+               Temp := Make_Temporary (Loc, 'R', Alloc_Node);\n+\n+               Insert_List_Before_And_Analyze (N, New_List (\n+                 Make_Full_Type_Declaration (Loc,\n+                   Defining_Identifier => Acc_Typ,\n+                   Type_Definition     =>\n+                     Make_Access_To_Object_Definition (Loc,\n+                       Subtype_Indication => Subtype_Ind)),\n+\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Temp,\n+                   Object_Definition   => New_Reference_To (Acc_Typ, Loc),\n+                   Expression          => Alloc_Node)));\n+\n+               Rewrite (Exp,\n+                 Make_Explicit_Dereference (Loc,\n+                 Prefix => New_Reference_To (Temp, Loc)));\n+\n+               Analyze_And_Resolve (Exp, R_Type);\n+            end;\n+\n+         --  Otherwise use the gigi mechanism to allocate result on the\n+         --  secondary stack.\n+\n+         else\n+            Check_Restriction (No_Secondary_Stack, N);\n+            Set_Storage_Pool (N, RTE (RE_SS_Pool));\n+\n+            --  If we are generating code for the VM do not use\n+            --  SS_Allocate since everything is heap-allocated anyway.\n+\n+            if VM_Target = No_VM then\n+               Set_Procedure_To_Call (N, RTE (RE_SS_Allocate));\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  Implement the rules of 6.5(8-10), which require a tag check in the\n+      --  case of a limited tagged return type, and tag reassignment for\n+      --  nonlimited tagged results. These actions are needed when the return\n+      --  type is a specific tagged type and the result expression is a\n+      --  conversion or a formal parameter, because in that case the tag of the\n+      --  expression might differ from the tag of the specific result type.\n+\n+      if Is_Tagged_Type (Utyp)\n+        and then not Is_Class_Wide_Type (Utyp)\n+        and then (Nkind_In (Exp, N_Type_Conversion,\n+                                 N_Unchecked_Type_Conversion)\n+                    or else (Is_Entity_Name (Exp)\n+                               and then Ekind (Entity (Exp)) in Formal_Kind))\n+      then\n+         --  When the return type is limited, perform a check that the\n+         --  tag of the result is the same as the tag of the return type.\n+\n+         if Is_Limited_Type (R_Type) then\n+            Insert_Action (Exp,\n+              Make_Raise_Constraint_Error (Loc,\n+                Condition =>\n+                  Make_Op_Ne (Loc,\n+                    Left_Opnd =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix => Duplicate_Subexpr (Exp),\n+                        Selector_Name =>\n+                          Make_Identifier (Loc, Chars => Name_uTag)),\n+                    Right_Opnd =>\n+                      Make_Attribute_Reference (Loc,\n+                        Prefix => New_Occurrence_Of (Base_Type (Utyp), Loc),\n+                        Attribute_Name => Name_Tag)),\n+                Reason => CE_Tag_Check_Failed));\n+\n+         --  If the result type is a specific nonlimited tagged type, then we\n+         --  have to ensure that the tag of the result is that of the result\n+         --  type. This is handled by making a copy of the expression in the\n+         --  case where it might have a different tag, namely when the\n+         --  expression is a conversion or a formal parameter. We create a new\n+         --  object of the result type and initialize it from the expression,\n+         --  which will implicitly force the tag to be set appropriately.\n+\n+         else\n+            declare\n+               ExpR       : constant Node_Id   := Relocate_Node (Exp);\n+               Result_Id  : constant Entity_Id :=\n+                              Make_Temporary (Loc, 'R', ExpR);\n+               Result_Exp : constant Node_Id   :=\n+                              New_Reference_To (Result_Id, Loc);\n+               Result_Obj : constant Node_Id   :=\n+                              Make_Object_Declaration (Loc,\n+                                Defining_Identifier => Result_Id,\n+                                Object_Definition   =>\n+                                  New_Reference_To (R_Type, Loc),\n+                                Constant_Present    => True,\n+                                Expression          => ExpR);\n+\n+            begin\n+               Set_Assignment_OK (Result_Obj);\n+               Insert_Action (Exp, Result_Obj);\n+\n+               Rewrite (Exp, Result_Exp);\n+               Analyze_And_Resolve (Exp, R_Type);\n+            end;\n+         end if;\n+\n+      --  Ada 2005 (AI-344): If the result type is class-wide, then insert\n+      --  a check that the level of the return expression's underlying type\n+      --  is not deeper than the level of the master enclosing the function.\n+      --  Always generate the check when the type of the return expression\n+      --  is class-wide, when it's a type conversion, or when it's a formal\n+      --  parameter. Otherwise, suppress the check in the case where the\n+      --  return expression has a specific type whose level is known not to\n+      --  be statically deeper than the function's result type.\n+\n+      --  Note: accessibility check is skipped in the VM case, since there\n+      --  does not seem to be any practical way to implement this check.\n+\n+      elsif Ada_Version >= Ada_05\n+        and then Tagged_Type_Expansion\n+        and then Is_Class_Wide_Type (R_Type)\n+        and then not Scope_Suppress (Accessibility_Check)\n+        and then\n+          (Is_Class_Wide_Type (Etype (Exp))\n+            or else Nkind_In (Exp, N_Type_Conversion,\n+                                   N_Unchecked_Type_Conversion)\n+            or else (Is_Entity_Name (Exp)\n+                       and then Ekind (Entity (Exp)) in Formal_Kind)\n+            or else Scope_Depth (Enclosing_Dynamic_Scope (Etype (Exp))) >\n+                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))\n+      then\n+         declare\n+            Tag_Node : Node_Id;\n+\n+         begin\n+            --  Ada 2005 (AI-251): In class-wide interface objects we displace\n+            --  \"this\" to reference the base of the object --- required to get\n+            --  access to the TSD of the object.\n+\n+            if Is_Class_Wide_Type (Etype (Exp))\n+              and then Is_Interface (Etype (Exp))\n+              and then Nkind (Exp) = N_Explicit_Dereference\n+            then\n+               Tag_Node :=\n+                 Make_Explicit_Dereference (Loc,\n+                   Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                     Make_Function_Call (Loc,\n+                       Name => New_Reference_To (RTE (RE_Base_Address), Loc),\n+                       Parameter_Associations => New_List (\n+                         Unchecked_Convert_To (RTE (RE_Address),\n+                           Duplicate_Subexpr (Prefix (Exp)))))));\n+            else\n+               Tag_Node :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix => Duplicate_Subexpr (Exp),\n+                   Attribute_Name => Name_Tag);\n+            end if;\n+\n+            Insert_Action (Exp,\n+              Make_Raise_Program_Error (Loc,\n+                Condition =>\n+                  Make_Op_Gt (Loc,\n+                    Left_Opnd =>\n+                      Build_Get_Access_Level (Loc, Tag_Node),\n+                    Right_Opnd =>\n+                      Make_Integer_Literal (Loc,\n+                        Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n+                Reason => PE_Accessibility_Check_Failed));\n+         end;\n+\n+      --  AI05-0073: If function has a controlling access result, check that\n+      --  the tag of the return value, if it is not null, matches designated\n+      --  type of return type.\n+      --  The return expression is referenced twice in the code below, so\n+      --  it must be made free of side effects. Given that different compilers\n+      --  may evaluate these parameters in different order, both occurrences\n+      --  perform a copy.\n+\n+      elsif Ekind (R_Type) = E_Anonymous_Access_Type\n+        and then Has_Controlling_Result (Scope_Id)\n+      then\n+         Insert_Action (N,\n+           Make_Raise_Constraint_Error (Loc,\n+             Condition =>\n+               Make_And_Then (Loc,\n+                 Left_Opnd  =>\n+                   Make_Op_Ne (Loc,\n+                     Left_Opnd  => Duplicate_Subexpr (Exp),\n+                     Right_Opnd => Make_Null (Loc)),\n+                 Right_Opnd => Make_Op_Ne (Loc,\n+                   Left_Opnd  =>\n+                     Make_Selected_Component (Loc,\n+                       Prefix        => Duplicate_Subexpr (Exp),\n+                       Selector_Name =>\n+                         Make_Identifier (Loc, Chars => Name_uTag)),\n+                   Right_Opnd =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         =>\n+                         New_Occurrence_Of (Designated_Type (R_Type), Loc),\n+                       Attribute_Name => Name_Tag))),\n+             Reason    => CE_Tag_Check_Failed),\n+             Suppress  => All_Checks);\n+      end if;\n+\n+      --  If we are returning an object that may not be bit-aligned, then copy\n+      --  the value into a temporary first. This copy may need to expand to a\n+      --  loop of component operations.\n+\n+      if Is_Possibly_Unaligned_Slice (Exp)\n+        or else Is_Possibly_Unaligned_Object (Exp)\n+      then\n+         declare\n+            ExpR : constant Node_Id   := Relocate_Node (Exp);\n+            Tnn  : constant Entity_Id := Make_Temporary (Loc, 'T', ExpR);\n+         begin\n+            Insert_Action (Exp,\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Tnn,\n+                Constant_Present    => True,\n+                Object_Definition   => New_Occurrence_Of (R_Type, Loc),\n+                Expression          => ExpR),\n+              Suppress            => All_Checks);\n+            Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n+         end;\n+      end if;\n+\n+      --  Generate call to postcondition checks if they are present\n+\n+      if Ekind (Scope_Id) = E_Function\n+        and then Has_Postconditions (Scope_Id)\n+      then\n+         --  We are going to reference the returned value twice in this case,\n+         --  once in the call to _Postconditions, and once in the actual return\n+         --  statement, but we can't have side effects happening twice, and in\n+         --  any case for efficiency we don't want to do the computation twice.\n+\n+         --  If the returned expression is an entity name, we don't need to\n+         --  worry since it is efficient and safe to reference it twice, that's\n+         --  also true for literals other than string literals, and for the\n+         --  case of X.all where X is an entity name.\n+\n+         if Is_Entity_Name (Exp)\n+           or else Nkind_In (Exp, N_Character_Literal,\n+                                  N_Integer_Literal,\n+                                  N_Real_Literal)\n+           or else (Nkind (Exp) = N_Explicit_Dereference\n+                      and then Is_Entity_Name (Prefix (Exp)))\n+         then\n+            null;\n+\n+         --  Otherwise we are going to need a temporary to capture the value\n+\n+         else\n+            declare\n+               ExpR : constant Node_Id   := Relocate_Node (Exp);\n+               Tnn  : constant Entity_Id := Make_Temporary (Loc, 'T', ExpR);\n+\n+            begin\n+               --  For a complex expression of an elementary type, capture\n+               --  value in the temporary and use it as the reference.\n+\n+               if Is_Elementary_Type (R_Type) then\n+                  Insert_Action (Exp,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Tnn,\n+                      Constant_Present    => True,\n+                      Object_Definition   => New_Occurrence_Of (R_Type, Loc),\n+                      Expression          => ExpR),\n+                    Suppress => All_Checks);\n+\n+                  Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n+\n+               --  If we have something we can rename, generate a renaming of\n+               --  the object and replace the expression with a reference\n+\n+               elsif Is_Object_Reference (Exp) then\n+                  Insert_Action (Exp,\n+                    Make_Object_Renaming_Declaration (Loc,\n+                      Defining_Identifier => Tnn,\n+                      Subtype_Mark        => New_Occurrence_Of (R_Type, Loc),\n+                      Name                => ExpR),\n+                    Suppress => All_Checks);\n+\n+                  Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n+\n+               --  Otherwise we have something like a string literal or an\n+               --  aggregate. We could copy the value, but that would be\n+               --  inefficient. Instead we make a reference to the value and\n+               --  capture this reference with a renaming, the expression is\n+               --  then replaced by a dereference of this renaming.\n+\n+               else\n+                  --  For now, copy the value, since the code below does not\n+                  --  seem to work correctly ???\n+\n+                  Insert_Action (Exp,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Tnn,\n+                      Constant_Present    => True,\n+                      Object_Definition   => New_Occurrence_Of (R_Type, Loc),\n+                      Expression          => Relocate_Node (Exp)),\n+                    Suppress => All_Checks);\n+\n+                  Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n+\n+                  --  Insert_Action (Exp,\n+                  --    Make_Object_Renaming_Declaration (Loc,\n+                  --      Defining_Identifier => Tnn,\n+                  --      Access_Definition =>\n+                  --        Make_Access_Definition (Loc,\n+                  --          All_Present  => True,\n+                  --          Subtype_Mark => New_Occurrence_Of (R_Type, Loc)),\n+                  --      Name =>\n+                  --        Make_Reference (Loc,\n+                  --          Prefix => Relocate_Node (Exp))),\n+                  --    Suppress => All_Checks);\n+\n+                  --  Rewrite (Exp,\n+                  --    Make_Explicit_Dereference (Loc,\n+                  --      Prefix => New_Occurrence_Of (Tnn, Loc)));\n+               end if;\n+            end;\n+         end if;\n+\n+         --  Generate call to _postconditions\n+\n+         Insert_Action (Exp,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => Make_Identifier (Loc, Name_uPostconditions),\n+             Parameter_Associations => New_List (Duplicate_Subexpr (Exp))));\n+      end if;\n+\n+      --  Ada 2005 (AI-251): If this return statement corresponds with an\n+      --  simple return statement associated with an extended return statement\n+      --  and the type of the returned object is an interface then generate an\n+      --  implicit conversion to force displacement of the \"this\" pointer.\n+\n+      if Ada_Version >= Ada_05\n+        and then Comes_From_Extended_Return_Statement (N)\n+        and then Nkind (Expression (N)) = N_Identifier\n+        and then Is_Interface (Utyp)\n+        and then Utyp /= Underlying_Type (Exptyp)\n+      then\n+         Rewrite (Exp, Convert_To (Utyp, Relocate_Node (Exp)));\n+         Analyze_And_Resolve (Exp);\n+      end if;\n+   end Expand_Simple_Function_Return;\n+\n    --------------------------------\n    -- Is_Build_In_Place_Function --\n    --------------------------------"}, {"sha": "e04e217e80e76aa19890e315664357ae08fce6d4", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,11 +29,13 @@ with Types; use Types;\n \n package Exp_Ch6 is\n \n-   procedure Expand_N_Function_Call            (N : Node_Id);\n-   procedure Expand_N_Subprogram_Body          (N : Node_Id);\n-   procedure Expand_N_Subprogram_Body_Stub     (N : Node_Id);\n-   procedure Expand_N_Subprogram_Declaration   (N : Node_Id);\n-   procedure Expand_N_Procedure_Call_Statement (N : Node_Id);\n+   procedure Expand_N_Extended_Return_Statement (N : Node_Id);\n+   procedure Expand_N_Function_Call             (N : Node_Id);\n+   procedure Expand_N_Procedure_Call_Statement  (N : Node_Id);\n+   procedure Expand_N_Simple_Return_Statement   (N : Node_Id);\n+   procedure Expand_N_Subprogram_Body           (N : Node_Id);\n+   procedure Expand_N_Subprogram_Body_Stub      (N : Node_Id);\n+   procedure Expand_N_Subprogram_Declaration    (N : Node_Id);\n \n    procedure Expand_Call (N : Node_Id);\n    --  This procedure contains common processing for Expand_N_Function_Call,"}, {"sha": "c76e17514089fa92cef562275eda5e8a35e4fe7b", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 94, "deletions": 84, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -126,6 +126,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/ada.o\t\\\n  ada/ali.o\t\\\n  ada/alloc.o\t\\\n+ ada/aspects.o  \\\n  ada/atree.o\t\\\n  ada/butil.o\t\\\n  ada/casing.o\t\\\n@@ -1346,15 +1347,24 @@ ada/ali.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads ada/a-uncdea.ads \\\n \n ada/alloc.o : ada/alloc.ads ada/system.ads \n \n+ada/aspects.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n+   ada/a-uncdea.ads ada/alloc.ads ada/aspects.ads ada/aspects.adb \\\n+   ada/debug.ads ada/hostparm.ads ada/namet.ads ada/opt.ads ada/output.ads \\\n+   ada/snames.ads ada/system.ads ada/s-exctab.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/tree_io.ads ada/types.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads\n+\n ada/atree.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n    ada/casing.ads ada/debug.ads ada/einfo.ads ada/hostparm.ads \\\n    ada/namet.ads ada/nlists.ads ada/nlists.adb ada/opt.ads ada/output.ads \\\n    ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads \\\n-   ada/system.ads ada/s-exctab.ads ada/s-imenne.ads ada/s-memory.ads \\\n-   ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/system.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n \n ada/back_end.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n@@ -1498,13 +1508,13 @@ ada/comperr.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nlists.adb ada/opt.ads ada/osint.ads ada/output.ads ada/output.adb \\\n    ada/rident.ads ada/sdefault.ads ada/sinfo.ads ada/sinfo.adb \\\n    ada/sinput.ads ada/snames.ads ada/sprint.ads ada/system.ads \\\n-   ada/s-exctab.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads \\\n-   ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n-   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tree_io.ads \\\n-   ada/treepr.ads ada/types.ads ada/uintp.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads \n+   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-secsta.ads \\\n+   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n+   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n+   ada/tree_io.ads ada/treepr.ads ada/types.ads ada/uintp.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n \n ada/csets.o : ada/ada.ads ada/a-unccon.ads ada/a-uncdea.ads ada/csets.ads \\\n    ada/csets.adb ada/hostparm.ads ada/opt.ads ada/system.ads \\\n@@ -1546,11 +1556,11 @@ ada/debug_a.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/einfo.ads ada/hostparm.ads ada/namet.ads ada/nlists.ads \\\n    ada/nlists.adb ada/opt.ads ada/output.ads ada/sinfo.ads ada/sinfo.adb \\\n    ada/sinput.ads ada/snames.ads ada/system.ads ada/s-exctab.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-stalib.ads ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/tree_io.ads \\\n-   ada/types.ads ada/uintp.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads \n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads \n \n ada/einfo.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -1881,32 +1891,32 @@ ada/exp_ch5.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/casing.ads ada/checks.ads ada/checks.adb ada/csets.ads \\\n    ada/debug.ads ada/einfo.ads ada/einfo.adb ada/elists.ads \\\n    ada/err_vars.ads ada/errout.ads ada/erroutc.ads ada/eval_fat.ads \\\n-   ada/exp_aggr.ads ada/exp_atag.ads ada/exp_ch11.ads ada/exp_ch2.ads \\\n-   ada/exp_ch4.ads ada/exp_ch5.ads ada/exp_ch5.adb ada/exp_ch6.ads \\\n-   ada/exp_ch7.ads ada/exp_dbug.ads ada/exp_disp.ads ada/exp_pakd.ads \\\n-   ada/exp_tss.ads ada/exp_util.ads ada/exp_util.adb ada/fname.ads \\\n-   ada/fname-uf.ads ada/freeze.ads ada/get_targ.ads ada/gnat.ads \\\n-   ada/g-htable.ads ada/hostparm.ads ada/inline.ads ada/interfac.ads \\\n-   ada/itypes.ads ada/lib.ads ada/lib-xref.ads ada/namet.ads ada/namet.adb \\\n-   ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads \\\n-   ada/output.ads ada/restrict.ads ada/restrict.adb ada/rident.ads \\\n-   ada/rtsfind.ads ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb \\\n-   ada/sem.ads ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads \\\n-   ada/sem_ch13.ads ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch8.ads \\\n-   ada/sem_disp.ads ada/sem_eval.ads ada/sem_eval.adb ada/sem_res.ads \\\n-   ada/sem_type.ads ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads \\\n-   ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads \\\n-   ada/sprint.ads ada/stand.ads ada/stringt.ads ada/stringt.adb \\\n-   ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n-   ada/system.ads ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-rident.ads ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads \\\n-   ada/table.ads ada/table.adb ada/targparm.ads ada/tbuild.ads \\\n-   ada/tbuild.adb ada/tree_io.ads ada/ttypes.ads ada/types.ads \\\n-   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads ada/validsw.ads ada/widechar.ads \n+   ada/exp_aggr.ads ada/exp_ch11.ads ada/exp_ch2.ads ada/exp_ch4.ads \\\n+   ada/exp_ch5.ads ada/exp_ch5.adb ada/exp_ch6.ads ada/exp_ch7.ads \\\n+   ada/exp_dbug.ads ada/exp_disp.ads ada/exp_pakd.ads ada/exp_tss.ads \\\n+   ada/exp_util.ads ada/exp_util.adb ada/fname.ads ada/fname-uf.ads \\\n+   ada/freeze.ads ada/get_targ.ads ada/gnat.ads ada/g-htable.ads \\\n+   ada/hostparm.ads ada/inline.ads ada/interfac.ads ada/itypes.ads \\\n+   ada/lib.ads ada/lib-xref.ads ada/namet.ads ada/namet.adb ada/nlists.ads \\\n+   ada/nlists.adb ada/nmake.ads ada/nmake.adb ada/opt.ads ada/output.ads \\\n+   ada/restrict.ads ada/restrict.adb ada/rident.ads ada/rtsfind.ads \\\n+   ada/scans.ads ada/scn.ads ada/scng.ads ada/scng.adb ada/sem.ads \\\n+   ada/sem_attr.ads ada/sem_aux.ads ada/sem_cat.ads ada/sem_ch13.ads \\\n+   ada/sem_ch3.ads ada/sem_ch6.ads ada/sem_ch8.ads ada/sem_disp.ads \\\n+   ada/sem_eval.ads ada/sem_eval.adb ada/sem_res.ads ada/sem_type.ads \\\n+   ada/sem_util.ads ada/sem_util.adb ada/sem_warn.ads ada/sinfo.ads \\\n+   ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/sprint.ads \\\n+   ada/stand.ads ada/stringt.ads ada/stringt.adb ada/style.ads \\\n+   ada/styleg.ads ada/styleg.adb ada/stylesw.ads ada/system.ads \\\n+   ada/s-crc32.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads \\\n+   ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/targparm.ads ada/tbuild.ads ada/tbuild.adb \\\n+   ada/tree_io.ads ada/ttypes.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/urealp.ads ada/validsw.ads ada/widechar.ads \n \n ada/exp_ch6.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -2376,12 +2386,12 @@ ada/expander.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/nlists.adb ada/nmake.ads ada/opt.ads ada/output.ads ada/rtsfind.ads \\\n    ada/sem.ads ada/sem_ch8.ads ada/sem_util.ads ada/sinfo.ads \\\n    ada/sinfo.adb ada/sinput.ads ada/snames.ads ada/system.ads \\\n-   ada/s-exctab.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n-   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads \n+   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-soflin.ads ada/s-stache.ads \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads \\\n+   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n \n ada/fmap.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/debug.ads ada/fmap.ads ada/fmap.adb \\\n@@ -2811,10 +2821,10 @@ ada/nlists.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/casing.ads ada/debug.ads ada/einfo.ads ada/hostparm.ads \\\n    ada/namet.ads ada/nlists.ads ada/nlists.adb ada/opt.ads ada/output.ads \\\n    ada/sinfo.ads ada/sinfo.adb ada/sinput.ads ada/snames.ads \\\n-   ada/system.ads ada/s-exctab.ads ada/s-imenne.ads ada/s-memory.ads \\\n-   ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/system.ads ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads \\\n+   ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n    ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n \n ada/nmake.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n@@ -2823,11 +2833,11 @@ ada/nmake.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/namet.ads ada/nlists.ads ada/nlists.adb ada/nmake.ads ada/nmake.adb \\\n    ada/opt.ads ada/output.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n    ada/snames.ads ada/stand.ads ada/system.ads ada/s-exctab.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-stalib.ads ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/tree_io.ads \\\n-   ada/types.ads ada/uintp.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads \n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads \n \n ada/opt.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads ada/a-uncdea.ads \\\n    ada/gnatvsn.ads ada/hostparm.ads ada/opt.ads ada/opt.adb ada/system.ads \\\n@@ -3190,11 +3200,11 @@ ada/scil_ll.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/namet.ads ada/nlists.ads ada/nlists.adb ada/opt.ads ada/output.ads \\\n    ada/scil_ll.ads ada/scil_ll.adb ada/sinfo.ads ada/sinfo.adb \\\n    ada/sinput.ads ada/snames.ads ada/system.ads ada/s-exctab.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-stalib.ads ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/tree_io.ads \\\n-   ada/types.ads ada/uintp.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads \n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads \n \n ada/scn.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads ada/a-uncdea.ads \\\n    ada/alloc.ads ada/atree.ads ada/atree.adb ada/casing.ads ada/csets.ads \\\n@@ -3506,11 +3516,11 @@ ada/sem_ch2.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/restrict.ads ada/rident.ads ada/sem_ch2.ads ada/sem_ch2.adb \\\n    ada/sem_ch8.ads ada/sinfo.ads ada/sinfo.adb ada/sinput.ads \\\n    ada/snames.ads ada/stand.ads ada/system.ads ada/s-carun8.ads \\\n-   ada/s-exctab.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-rident.ads ada/s-stalib.ads ada/s-string.ads \\\n-   ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads \\\n-   ada/table.adb ada/tree_io.ads ada/types.ads ada/types.adb ada/uintp.ads \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n+   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-rident.ads ada/s-stalib.ads \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/tree_io.ads ada/types.ads ada/types.adb \\\n+   ada/uintp.ads ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n \n ada/sem_ch3.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n@@ -4126,11 +4136,11 @@ ada/sinfo.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/g-htable.ads ada/hostparm.ads ada/namet.ads ada/nlists.ads \\\n    ada/nlists.adb ada/opt.ads ada/output.ads ada/sinfo.ads ada/sinfo.adb \\\n    ada/sinput.ads ada/snames.ads ada/system.ads ada/s-exctab.ads \\\n-   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-stalib.ads ada/s-string.ads ada/s-traent.ads \\\n-   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/uintp.adb \\\n-   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n+   ada/s-htable.ads ada/s-htable.adb ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-stalib.ads ada/s-strhas.ads \\\n+   ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads ada/s-wchcon.ads \\\n+   ada/table.ads ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads \n \n ada/sinput-c.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/casing.ads ada/debug.ads \\\n@@ -4163,25 +4173,25 @@ ada/sinput-l.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/sinput-l.ads ada/sinput-l.adb ada/snames.ads ada/stringt.ads \\\n    ada/style.ads ada/styleg.ads ada/styleg.adb ada/stylesw.ads \\\n    ada/system.ads ada/s-crc32.ads ada/s-crc32.adb ada/s-exctab.ads \\\n-   ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads ada/s-parame.ads \\\n-   ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n-   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n+   ada/s-parame.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-utf_32.ads ada/s-wchcon.ads ada/table.ads \\\n+   ada/table.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/unchconv.ads ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/sinput.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/atree.ads ada/atree.adb \\\n    ada/casing.ads ada/debug.ads ada/einfo.ads ada/hostparm.ads \\\n    ada/interfac.ads ada/namet.ads ada/namet.adb ada/nlists.ads \\\n    ada/nlists.adb ada/opt.ads ada/output.ads ada/sinfo.ads ada/sinfo.adb \\\n    ada/sinput.ads ada/sinput.adb ada/snames.ads ada/system.ads \\\n-   ada/s-exctab.ads ada/s-imenne.ads ada/s-memory.ads ada/s-os_lib.ads \\\n-   ada/s-parame.ads ada/s-secsta.ads ada/s-stalib.ads ada/s-stoele.ads \\\n-   ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/tree_io.ads \\\n-   ada/types.ads ada/uintp.ads ada/unchconv.ads ada/unchdeal.ads \\\n-   ada/urealp.ads ada/widechar.ads \n+   ada/s-exctab.ads ada/s-htable.ads ada/s-imenne.ads ada/s-memory.ads \\\n+   ada/s-os_lib.ads ada/s-parame.ads ada/s-secsta.ads ada/s-stalib.ads \\\n+   ada/s-stoele.ads ada/s-stoele.adb ada/s-string.ads ada/s-traent.ads \\\n+   ada/s-unstyp.ads ada/s-wchcon.ads ada/table.ads ada/table.adb \\\n+   ada/tree_io.ads ada/types.ads ada/uintp.ads ada/unchconv.ads \\\n+   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n \n ada/snames.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n    ada/a-uncdea.ads ada/alloc.ads ada/debug.ads ada/hostparm.ads \\"}, {"sha": "a3eb1da7eeab6d1b2d84660ac7a23c67d8281209", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -529,8 +529,8 @@ package body Sem_Aggr is\n       --  N is an array (sub-)aggregate. Dim is the dimension corresponding\n       --  to (sub-)aggregate N. This procedure collects and removes the side\n       --  effects of the constrained N_Range nodes corresponding to each index\n-      --  dimension of our aggregate itype.\n-      --  These N_Range nodes are collected in Aggr_Range above.\n+      --  dimension of our aggregate itype. These N_Range nodes are collected\n+      --  in Aggr_Range above.\n       --\n       --  Likewise collect in Aggr_Low & Aggr_High above the low and high\n       --  bounds of each index dimension. If, when collecting, two bounds"}, {"sha": "2379a41405471311cc2f59050bfcb20ef049c2dd", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -10404,7 +10404,7 @@ package body Sem_Prag is\n \n          --  pragma Passive [(PASSIVE_FORM)];\n \n-         --   PASSIVE_FORM ::= Semaphore | No\n+         --  PASSIVE_FORM ::= Semaphore | No\n \n          when Pragma_Passive =>\n             GNAT_Pragma;\n@@ -10475,6 +10475,8 @@ package body Sem_Prag is\n          -- Persistent_BSS --\n          --------------------\n \n+         --  pragma Persistent_BSS [(object_NAME)];\n+\n          when Pragma_Persistent_BSS => Persistent_BSS :  declare\n             Decl : Node_Id;\n             Ent  : Entity_Id;"}, {"sha": "ad43f3a0e437b773803771c0da49cd31d831fc38", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -134,6 +134,14 @@ package Snames is\n    Name_Space                          : constant Name_Id := N + $;\n    Name_Time                           : constant Name_Id := N + $;\n \n+   --  Names of aspects for which there are no matching pragmas or attributes\n+   --  so that they need to be included for aspect specification use.\n+\n+   Name_Invariant                      : constant Name_Id := N + $;\n+   Name_Post                           : constant Name_Id := N + $;\n+   Name_Pre                            : constant Name_Id := N + $;\n+   Name_Predicate                      : constant Name_Id := N + $;\n+\n    --  Some special names used by the expander. Note that the lower case u's\n    --  at the start of these names get translated to extra underscores. These\n    --  names are only referenced internally by expander generated code."}, {"sha": "c35ef0df03971ab5583d83a16d99d1a2b3b6a791", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b3d67a55b8f6589dd52eea452e464c628d20bdf/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=2b3d67a55b8f6589dd52eea452e464c628d20bdf", "patch": "@@ -801,7 +801,6 @@ package body Sprint is\n       --  Select print circuit based on node kind\n \n       case Nkind (Node) is\n-\n          when N_Abort_Statement =>\n             Write_Indent_Str_Sloc (\"abort \");\n             Sprint_Comma_List (Names (Node));\n@@ -3091,7 +3090,6 @@ package body Sprint is\n                   Write_Char (';');\n                end if;\n             end if;\n-\n       end case;\n \n       if Nkind (Node) in N_Subexpr"}]}