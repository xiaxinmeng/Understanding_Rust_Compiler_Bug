{"sha": "9d4ac06e0235697c7fa3144b6790b779e6385ea5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ0YWMwNmUwMjM1Njk3YzdmYTMxNDRiNjc5MGI3NzllNjM4NWVhNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-05-25T06:48:47Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-05-25T06:48:47Z"}, "message": "Add an \"else\" argument to IFN_COND_* functions\n\nAs suggested by Richard B, this patch changes the IFN_COND_*\nfunctions so that they take the else value of the ?: operation\nas a final argument, rather than always using argument 1.\n\nAll current callers will still use the equivalent of argument 1,\nso this patch makes the SVE code assert that for now.  Later patches\nadd the general case.\n\n2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* doc/md.texi: Update the documentation of the cond_* optabs\n\tto mention the new final operand.  Fix GET_MODE_NUNITS call.\n\tDescribe the scalar case too.\n\t* internal-fn.def (IFN_EXTRACT_LAST): Change type to fold_left.\n\t* internal-fn.c (expand_cond_unary_optab_fn): Expect 3 operands\n\tinstead of 2.\n\t(expand_cond_binary_optab_fn): Expect 4 operands instead of 3.\n\t(get_conditional_internal_fn): Update comment.\n\t* tree-vect-loop.c (vectorizable_reduction): Pass the original\n\taccumulator value as a final argument to conditional functions.\n\t* config/aarch64/aarch64-sve.md (cond_<optab><mode>): Turn into\n\ta define_expand and add an \"else\" operand.  Assert for now that\n\tthe else operand is equal to operand 2.  Use SVE_INT_BINARY and\n\tSVE_COND_FP_BINARY instead of SVE_COND_INT_OP and SVE_COND_FP_OP.\n\t(*cond_<optab><mode>): New patterns.\n\t* config/aarch64/iterators.md (UNSPEC_COND_SMAX, UNSPEC_COND_UMAX)\n\t(UNSPEC_COND_SMIN, UNSPEC_COND_UMIN, UNSPEC_COND_AND, UNSPEC_COND_ORR)\n\t(UNSPEC_COND_EOR): Delete.\n\t(optab): Remove associated mappings.\n\t(SVE_INT_BINARY): New code iterator.\n\t(sve_int_op): Remove int attribute and add \"minus\" to the code\n\tattribute.\n\t(SVE_COND_INT_OP): Delete.\n\t(SVE_COND_FP_OP): Rename to...\n\t(SVE_COND_FP_BINARY): ...this.\n\nFrom-SVN: r260707", "tree": {"sha": "76c1c854e1471b931585d5223486aaf8844c1f8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76c1c854e1471b931585d5223486aaf8844c1f8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d4ac06e0235697c7fa3144b6790b779e6385ea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d4ac06e0235697c7fa3144b6790b779e6385ea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d4ac06e0235697c7fa3144b6790b779e6385ea5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d4ac06e0235697c7fa3144b6790b779e6385ea5/comments", "author": null, "committer": null, "parents": [{"sha": "b883fc9b54d360b5f73bf226bb489e8612502298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b883fc9b54d360b5f73bf226bb489e8612502298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b883fc9b54d360b5f73bf226bb489e8612502298"}], "stats": {"total": 170, "additions": 113, "deletions": 57}, "files": [{"sha": "c258af3d255944e916d87f43cf0e8be1d9f2a13a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d4ac06e0235697c7fa3144b6790b779e6385ea5", "patch": "@@ -1,3 +1,31 @@\n+2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* doc/md.texi: Update the documentation of the cond_* optabs\n+\tto mention the new final operand.  Fix GET_MODE_NUNITS call.\n+\tDescribe the scalar case too.\n+\t* internal-fn.def (IFN_EXTRACT_LAST): Change type to fold_left.\n+\t* internal-fn.c (expand_cond_unary_optab_fn): Expect 3 operands\n+\tinstead of 2.\n+\t(expand_cond_binary_optab_fn): Expect 4 operands instead of 3.\n+\t(get_conditional_internal_fn): Update comment.\n+\t* tree-vect-loop.c (vectorizable_reduction): Pass the original\n+\taccumulator value as a final argument to conditional functions.\n+\t* config/aarch64/aarch64-sve.md (cond_<optab><mode>): Turn into\n+\ta define_expand and add an \"else\" operand.  Assert for now that\n+\tthe else operand is equal to operand 2.  Use SVE_INT_BINARY and\n+\tSVE_COND_FP_BINARY instead of SVE_COND_INT_OP and SVE_COND_FP_OP.\n+\t(*cond_<optab><mode>): New patterns.\n+\t* config/aarch64/iterators.md (UNSPEC_COND_SMAX, UNSPEC_COND_UMAX)\n+\t(UNSPEC_COND_SMIN, UNSPEC_COND_UMIN, UNSPEC_COND_AND, UNSPEC_COND_ORR)\n+\t(UNSPEC_COND_EOR): Delete.\n+\t(optab): Remove associated mappings.\n+\t(SVE_INT_BINARY): New code iterator.\n+\t(sve_int_op): Remove int attribute and add \"minus\" to the code\n+\tattribute.\n+\t(SVE_COND_INT_OP): Delete.\n+\t(SVE_COND_FP_OP): Rename to...\n+\t(SVE_COND_FP_BINARY): ...this.\n+\n 2018-05-25  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* optabs.c (can_reuse_operands_p): New function."}, {"sha": "4f918492ae497ed2db1bfab69dd1224b3d1eac0c", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=9d4ac06e0235697c7fa3144b6790b779e6385ea5", "patch": "@@ -1757,14 +1757,31 @@\n   \"<maxmin_uns_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n )\n \n+;; Predicated integer operations with select.\n+(define_expand \"cond_<optab><mode>\"\n+  [(set (match_operand:SVE_I 0 \"register_operand\")\n+\t(unspec:SVE_I\n+\t  [(match_operand:<VPRED> 1 \"register_operand\")\n+\t   (SVE_INT_BINARY:SVE_I\n+\t     (match_operand:SVE_I 2 \"register_operand\")\n+\t     (match_operand:SVE_I 3 \"register_operand\"))\n+\t   (match_operand:SVE_I 4 \"register_operand\")]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+{\n+  gcc_assert (rtx_equal_p (operands[2], operands[4]));\n+})\n+\n ;; Predicated integer operations.\n-(define_insn \"cond_<optab><mode>\"\n+(define_insn \"*cond_<optab><mode>\"\n   [(set (match_operand:SVE_I 0 \"register_operand\" \"=w\")\n \t(unspec:SVE_I\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (match_operand:SVE_I 2 \"register_operand\" \"0\")\n-\t   (match_operand:SVE_I 3 \"register_operand\" \"w\")]\n-\t  SVE_COND_INT_OP))]\n+\t   (SVE_INT_BINARY:SVE_I\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"0\")\n+\t     (match_operand:SVE_I 3 \"register_operand\" \"w\"))\n+\t   (match_dup 2)]\n+\t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n   \"<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n )\n@@ -2536,14 +2553,35 @@\n   }\n )\n \n+;; Predicated floating-point operations with select.\n+(define_expand \"cond_<optab><mode>\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\")\n+\t   (unspec:SVE_F\n+\t     [(match_dup 1)\n+\t      (match_operand:SVE_F 2 \"register_operand\")\n+\t      (match_operand:SVE_F 3 \"register_operand\")]\n+\t     SVE_COND_FP_BINARY)\n+\t   (match_operand:SVE_F 4 \"register_operand\")]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+{\n+  gcc_assert (rtx_equal_p (operands[2], operands[4]));\n+})\n+\n ;; Predicated floating-point operations.\n-(define_insn \"cond_<optab><mode>\"\n+(define_insn \"*cond_<optab><mode>\"\n   [(set (match_operand:SVE_F 0 \"register_operand\" \"=w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (match_operand:SVE_F 2 \"register_operand\" \"0\")\n-\t   (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n-\t  SVE_COND_FP_OP))]\n+\t   (unspec:SVE_F\n+\t     [(match_dup 1)\n+\t      (match_operand:SVE_F 2 \"register_operand\" \"0\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n+\t     SVE_COND_FP_BINARY)\n+\t   (match_dup 2)]\n+\t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n   \"<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n )"}, {"sha": "b57c7e221f8eb434c29ac091df44b190ca8f4541", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 6, "deletions": 33, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=9d4ac06e0235697c7fa3144b6790b779e6385ea5", "patch": "@@ -464,13 +464,6 @@\n     UNSPEC_UMUL_HIGHPART ; Used in aarch64-sve.md.\n     UNSPEC_COND_ADD\t; Used in aarch64-sve.md.\n     UNSPEC_COND_SUB\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_SMAX\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_UMAX\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_SMIN\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_UMIN\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_AND\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_ORR\t; Used in aarch64-sve.md.\n-    UNSPEC_COND_EOR\t; Used in aarch64-sve.md.\n     UNSPEC_COND_LT\t; Used in aarch64-sve.md.\n     UNSPEC_COND_LE\t; Used in aarch64-sve.md.\n     UNSPEC_COND_EQ\t; Used in aarch64-sve.md.\n@@ -1207,6 +1200,9 @@\n ;; SVE floating-point unary operations.\n (define_code_iterator SVE_FP_UNARY [neg abs sqrt])\n \n+(define_code_iterator SVE_INT_BINARY [plus minus smax umax smin umin\n+\t\t\t\t      and ior xor])\n+\n ;; SVE integer comparisons.\n (define_code_iterator SVE_INT_CMP [lt le eq ne ge gt ltu leu geu gtu])\n \n@@ -1377,6 +1373,7 @@\n \n ;; The integer SVE instruction that implements an rtx code.\n (define_code_attr sve_int_op [(plus \"add\")\n+\t\t\t      (minus \"sub\")\n \t\t\t      (neg \"neg\")\n \t\t\t      (smin \"smin\")\n \t\t\t      (smax \"smax\")\n@@ -1532,14 +1529,7 @@\n \n (define_int_iterator MUL_HIGHPART [UNSPEC_SMUL_HIGHPART UNSPEC_UMUL_HIGHPART])\n \n-(define_int_iterator SVE_COND_INT_OP [UNSPEC_COND_ADD UNSPEC_COND_SUB\n-\t\t\t\t      UNSPEC_COND_SMAX UNSPEC_COND_UMAX\n-\t\t\t\t      UNSPEC_COND_SMIN UNSPEC_COND_UMIN\n-\t\t\t\t      UNSPEC_COND_AND\n-\t\t\t\t      UNSPEC_COND_ORR\n-\t\t\t\t      UNSPEC_COND_EOR])\n-\n-(define_int_iterator SVE_COND_FP_OP [UNSPEC_COND_ADD UNSPEC_COND_SUB])\n+(define_int_iterator SVE_COND_FP_BINARY [UNSPEC_COND_ADD UNSPEC_COND_SUB])\n \n (define_int_iterator SVE_COND_FP_CMP [UNSPEC_COND_LT UNSPEC_COND_LE\n \t\t\t\t      UNSPEC_COND_EQ UNSPEC_COND_NE\n@@ -1569,14 +1559,7 @@\n \t\t\t(UNSPEC_IORV \"ior\")\n \t\t\t(UNSPEC_XORV \"xor\")\n \t\t\t(UNSPEC_COND_ADD \"add\")\n-\t\t\t(UNSPEC_COND_SUB \"sub\")\n-\t\t\t(UNSPEC_COND_SMAX \"smax\")\n-\t\t\t(UNSPEC_COND_UMAX \"umax\")\n-\t\t\t(UNSPEC_COND_SMIN \"smin\")\n-\t\t\t(UNSPEC_COND_UMIN \"umin\")\n-\t\t\t(UNSPEC_COND_AND \"and\")\n-\t\t\t(UNSPEC_COND_ORR \"ior\")\n-\t\t\t(UNSPEC_COND_EOR \"xor\")])\n+\t\t\t(UNSPEC_COND_SUB \"sub\")])\n \n (define_int_attr  maxmin_uns [(UNSPEC_UMAXV \"umax\")\n \t\t\t      (UNSPEC_UMINV \"umin\")\n@@ -1787,15 +1770,5 @@\n \t\t\t (UNSPEC_COND_GE \"ge\")\n \t\t\t (UNSPEC_COND_GT \"gt\")])\n \n-(define_int_attr sve_int_op [(UNSPEC_COND_ADD \"add\")\n-\t\t\t     (UNSPEC_COND_SUB \"sub\")\n-\t\t\t     (UNSPEC_COND_SMAX \"smax\")\n-\t\t\t     (UNSPEC_COND_UMAX \"umax\")\n-\t\t\t     (UNSPEC_COND_SMIN \"smin\")\n-\t\t\t     (UNSPEC_COND_UMIN \"umin\")\n-\t\t\t     (UNSPEC_COND_AND \"and\")\n-\t\t\t     (UNSPEC_COND_ORR \"orr\")\n-\t\t\t     (UNSPEC_COND_EOR \"eor\")])\n-\n (define_int_attr sve_fp_op [(UNSPEC_COND_ADD \"fadd\")\n \t\t\t    (UNSPEC_COND_SUB \"fsub\")])"}, {"sha": "ce46320b418748a51a1d90d6530d4ebade960ab4", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=9d4ac06e0235697c7fa3144b6790b779e6385ea5", "patch": "@@ -6349,13 +6349,21 @@ operand 0, otherwise (operand 2 + operand 3) is moved.\n @itemx @samp{cond_smax@var{mode}}\n @itemx @samp{cond_umin@var{mode}}\n @itemx @samp{cond_umax@var{mode}}\n-Perform an elementwise operation on vector operands 2 and 3,\n-under the control of the vector mask in operand 1, and store the result\n-in operand 0.  This is equivalent to:\n+When operand 1 is true, perform an operation on operands 2 and 3 and\n+store the result in operand 0, otherwise store operand 4 in operand 0.\n+The operation works elementwise if the operands are vectors.\n+\n+The scalar case is equivalent to:\n+\n+@smallexample\n+op0 = op1 ? op2 @var{op} op3 : op4;\n+@end smallexample\n+\n+while the vector case is equivalent to:\n \n @smallexample\n-for (i = 0; i < GET_MODE_NUNITS (@var{n}); i++)\n-  op0[i] = op1[i] ? op2[i] @var{op} op3[i] : op2[i];\n+for (i = 0; i < GET_MODE_NUNITS (@var{m}); i++)\n+  op0[i] = op1[i] ? op2[i] @var{op} op3[i] : op4[i];\n @end smallexample\n \n where, for example, @var{op} is @code{+} for @samp{cond_add@var{mode}}.\n@@ -6364,8 +6372,9 @@ When defined for floating-point modes, the contents of @samp{op3[i]}\n are not interpreted if @var{op1[i]} is false, just like they would not\n be in a normal C @samp{?:} condition.\n \n-Operands 0, 2 and 3 all have mode @var{m}, while operand 1 has the mode\n-returned by @code{TARGET_VECTORIZE_GET_MASK_MODE}.\n+Operands 0, 2, 3 and 4 all have mode @var{m}.  Operand 1 is a scalar\n+integer if @var{m} is scalar, otherwise it has the mode returned by\n+@code{TARGET_VECTORIZE_GET_MASK_MODE}.\n \n @cindex @code{neg@var{mode}cc} instruction pattern\n @item @samp{neg@var{mode}cc}"}, {"sha": "6765a7708197cd0860e1d47c7132887c516574e5", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=9d4ac06e0235697c7fa3144b6790b779e6385ea5", "patch": "@@ -2988,10 +2988,10 @@ expand_while_optab_fn (internal_fn, gcall *stmt, convert_optab optab)\n   expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n \n #define expand_cond_unary_optab_fn(FN, STMT, OPTAB) \\\n-  expand_direct_optab_fn (FN, STMT, OPTAB, 2)\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n \n #define expand_cond_binary_optab_fn(FN, STMT, OPTAB) \\\n-  expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n+  expand_direct_optab_fn (FN, STMT, OPTAB, 4)\n \n #define expand_fold_extract_optab_fn(FN, STMT, OPTAB) \\\n   expand_direct_optab_fn (FN, STMT, OPTAB, 3)\n@@ -3219,12 +3219,19 @@ static void (*const internal_fn_expanders[]) (internal_fn, gcall *) = {\n   0\n };\n \n-/* Return a function that performs the conditional form of CODE, i.e.:\n+/* Return a function that only performs CODE when a certain condition is met\n+   and that uses a given fallback value otherwise.  For example, if CODE is\n+   a binary operation associated with conditional function FN:\n+\n+     LHS = FN (COND, A, B, ELSE)\n+\n+   is equivalent to the C expression:\n+\n+     LHS = COND ? A CODE B : ELSE;\n \n-     LHS = RHS1 ? RHS2 CODE RHS3 : RHS2\n+   operating elementwise if the operands are vectors.\n \n-   (operating elementwise if the operands are vectors).  Return IFN_LAST\n-   if no such function exists.  */\n+   Return IFN_LAST if no such function exists.  */\n \n internal_fn\n get_conditional_internal_fn (tree_code code)"}, {"sha": "c56b731addbd2cf2ab3a4cb06466e98f540976c0", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=9d4ac06e0235697c7fa3144b6790b779e6385ea5", "patch": "@@ -173,7 +173,7 @@ DEF_INTERNAL_OPTAB_FN (REDUC_XOR, ECF_CONST | ECF_NOTHROW,\n \n /* Extract the last active element from a vector.  */\n DEF_INTERNAL_OPTAB_FN (EXTRACT_LAST, ECF_CONST | ECF_NOTHROW,\n-\t\t       extract_last, cond_unary)\n+\t\t       extract_last, fold_left)\n \n /* Same, but return the first argument if no elements are active.  */\n DEF_INTERNAL_OPTAB_FN (FOLD_EXTRACT_LAST, ECF_CONST | ECF_NOTHROW,"}, {"sha": "2507bbcb1f14604259680a4c048f8630c8f36533", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d4ac06e0235697c7fa3144b6790b779e6385ea5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9d4ac06e0235697c7fa3144b6790b779e6385ea5", "patch": "@@ -7222,8 +7222,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t}\n \t      tree mask = vect_get_loop_mask (gsi, masks, vec_num * ncopies,\n \t\t\t\t\t      vectype_in, i * ncopies + j);\n-\t      gcall *call = gimple_build_call_internal (cond_fn, 3, mask,\n-\t\t\t\t\t\t\tvop[0], vop[1]);\n+\t      gcall *call = gimple_build_call_internal (cond_fn, 4, mask,\n+\t\t\t\t\t\t\tvop[0], vop[1],\n+\t\t\t\t\t\t\tvop[0]);\n \t      new_temp = make_ssa_name (vec_dest, call);\n \t      gimple_call_set_lhs (call, new_temp);\n \t      gimple_call_set_nothrow (call, true);"}]}