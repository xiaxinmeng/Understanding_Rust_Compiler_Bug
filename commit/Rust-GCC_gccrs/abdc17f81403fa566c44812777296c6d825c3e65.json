{"sha": "abdc17f81403fa566c44812777296c6d825c3e65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJkYzE3ZjgxNDAzZmE1NjZjNDQ4MTI3NzcyOTZjNmQ4MjVjM2U2NQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2014-09-25T07:37:36Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2014-09-25T07:37:36Z"}, "message": "[multiple changes]\n\n2014-09-25  Andreas Arnez  <arnez@linux.vnet.ibm.com>\n\n\tPR 63300/debug\n\t* tree.c (check_base_type): New.\n\t(check_qualified_type): Exploit new helper function above.\n\t* tree.h (check_base_type): New prototype.\n\t* dwarf2out.c (get_nearest_type_subqualifiers): New.\n\t(modified_type_die): Fix handling for qualifiers.  Qualifiers to\n\t\"peel off\" are now determined using get_nearest_type_subqualifiers.\n\n2014-09-25  Mark Wielaard  <mjw@redhat.com>\n\n\tPR 63300/debug\n\t* gcc.dg/debug/dwarf2/stacked-qualified-types-1.c: New testcase.\n\t* gcc.dg/debug/dwarf2/stacked-qualified-types-2.c: Likewise.\n\t* gcc.dg/guality/pr63300-const-volatile.c: New testcase.\n\nFrom-SVN: r215582", "tree": {"sha": "1eb41a28a86278bb43999debd91dff6244dd8c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1eb41a28a86278bb43999debd91dff6244dd8c2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abdc17f81403fa566c44812777296c6d825c3e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdc17f81403fa566c44812777296c6d825c3e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abdc17f81403fa566c44812777296c6d825c3e65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdc17f81403fa566c44812777296c6d825c3e65/comments", "author": null, "committer": null, "parents": [{"sha": "d90c0a5980ceedb40f9f7536c32f17856997435a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d90c0a5980ceedb40f9f7536c32f17856997435a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d90c0a5980ceedb40f9f7536c32f17856997435a"}], "stats": {"total": 165, "additions": 131, "deletions": 34}, "files": [{"sha": "b5fcfa430992c7ac0a05179a0aa84eebc6e9ea20", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 66, "deletions": 30, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=abdc17f81403fa566c44812777296c6d825c3e65", "patch": "@@ -10461,6 +10461,40 @@ decl_quals (const_tree decl)\n \t     ? TYPE_QUAL_VOLATILE : TYPE_UNQUALIFIED));\n }\n \n+/* Determine the TYPE whose qualifiers match the largest strict subset\n+   of the given TYPE_QUALS, and return its qualifiers.  Ignore all\n+   qualifiers outside QUAL_MASK.  */\n+\n+static int\n+get_nearest_type_subqualifiers (tree type, int type_quals, int qual_mask)\n+{\n+  tree t;\n+  int best_rank = 0, best_qual = 0, max_rank;\n+\n+  type_quals &= qual_mask;\n+  max_rank = popcount_hwi (type_quals) - 1;\n+\n+  for (t = TYPE_MAIN_VARIANT (type); t && best_rank < max_rank;\n+       t = TYPE_NEXT_VARIANT (t))\n+    {\n+      int q = TYPE_QUALS (t) & qual_mask;\n+\n+      if ((q & type_quals) == q && q != type_quals\n+\t  && check_base_type (t, type))\n+\t{\n+\t  int rank = popcount_hwi (q);\n+\n+\t  if (rank > best_rank)\n+\t    {\n+\t      best_rank = rank;\n+\t      best_qual = q;\n+\t    }\n+\t}\n+    }\n+\n+  return best_qual;\n+}\n+\n /* Given a pointer to an arbitrary ..._TYPE tree node, return a debugging\n    entry that chains various modifiers in front of the given type.  */\n \n@@ -10474,12 +10508,14 @@ modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n   tree qualified_type;\n   tree name, low, high;\n   dw_die_ref mod_scope;\n+  /* Only these cv-qualifiers are currently handled.  */\n+  const int cv_qual_mask = (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE\n+\t\t\t    | TYPE_QUAL_RESTRICT);\n \n   if (code == ERROR_MARK)\n     return NULL;\n \n-  /* Only these cv-qualifiers are currently handled.  */\n-  cv_quals &= (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT);\n+  cv_quals &= cv_qual_mask;\n \n   /* Don't emit DW_TAG_restrict_type for DWARFv2, since it is a type\n      tag modifier (and not an attribute) old consumers won't be able\n@@ -10530,7 +10566,7 @@ modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n       else\n \t{\n \t  int dquals = TYPE_QUALS_NO_ADDR_SPACE (dtype);\n-\t  dquals &= (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE | TYPE_QUAL_RESTRICT);\n+\t  dquals &= cv_qual_mask;\n \t  if ((dquals & ~cv_quals) != TYPE_UNQUALIFIED\n \t      || (cv_quals == dquals && DECL_ORIGINAL_TYPE (name) != type))\n \t    /* cv-unqualified version of named type.  Just use\n@@ -10543,33 +10579,33 @@ modified_type_die (tree type, int cv_quals, dw_die_ref context_die)\n \n   mod_scope = scope_die_for (type, context_die);\n \n-  if ((cv_quals & TYPE_QUAL_CONST)\n-      /* If there are multiple type modifiers, prefer a path which\n-\t leads to a qualified type.  */\n-      && (((cv_quals & ~TYPE_QUAL_CONST) == TYPE_UNQUALIFIED)\n-\t  || get_qualified_type (type, cv_quals) == NULL_TREE\n-\t  || (get_qualified_type (type, cv_quals & ~TYPE_QUAL_CONST)\n-\t      != NULL_TREE)))\n-    {\n-      mod_type_die = new_die (DW_TAG_const_type, mod_scope, type);\n-      sub_die = modified_type_die (type, cv_quals & ~TYPE_QUAL_CONST,\n-\t\t\t\t   context_die);\n-    }\n-  else if ((cv_quals & TYPE_QUAL_VOLATILE)\n-\t   && (((cv_quals & ~TYPE_QUAL_VOLATILE) == TYPE_UNQUALIFIED)\n-\t       || get_qualified_type (type, cv_quals) == NULL_TREE\n-\t       || (get_qualified_type (type, cv_quals & ~TYPE_QUAL_VOLATILE)\n-\t\t   != NULL_TREE)))\n-    {\n-      mod_type_die = new_die (DW_TAG_volatile_type, mod_scope, type);\n-      sub_die = modified_type_die (type, cv_quals & ~TYPE_QUAL_VOLATILE,\n-\t\t\t\t   context_die);\n-    }\n-  else if (cv_quals & TYPE_QUAL_RESTRICT)\n-    {\n-      mod_type_die = new_die (DW_TAG_restrict_type, mod_scope, type);\n-      sub_die = modified_type_die (type, cv_quals & ~TYPE_QUAL_RESTRICT,\n-\t\t\t\t   context_die);\n+  if (cv_quals)\n+    {\n+      struct qual_info { int q; enum dwarf_tag t; };\n+      static const struct qual_info qual_info[] =\n+\t{\n+\t  { TYPE_QUAL_RESTRICT, DW_TAG_restrict_type },\n+\t  { TYPE_QUAL_VOLATILE, DW_TAG_volatile_type },\n+\t  { TYPE_QUAL_CONST, DW_TAG_const_type },\n+\t};\n+      int sub_quals;\n+      unsigned i;\n+\n+      /* Determine a lesser qualified type that most closely matches\n+\t this one.  Then generate DW_TAG_* entries for the remaining\n+\t qualifiers.  */\n+      sub_quals = get_nearest_type_subqualifiers (type, cv_quals,\n+\t\t\t\t\t\t  cv_qual_mask);\n+      mod_type_die = modified_type_die (type, sub_quals, context_die);\n+\n+      for (i = 0; i < sizeof (qual_info) / sizeof (qual_info[0]); i++)\n+\tif (qual_info[i].q & cv_quals & ~sub_quals)\n+\t  {\n+\t    dw_die_ref d = new_die (qual_info[i].t, mod_scope, type);\n+\t    if (mod_type_die)\n+\t      add_AT_die_ref (d, DW_AT_type, mod_type_die);\n+\t    mod_type_die = d;\n+\t  }\n     }\n   else if (code == POINTER_TYPE)\n     {"}, {"sha": "6f40901f3a1b25e07b1e5f5669d5e147f216f19f", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/stacked-qualified-types-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fstacked-qualified-types-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fstacked-qualified-types-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fstacked-qualified-types-1.c?ref=abdc17f81403fa566c44812777296c6d825c3e65", "patch": "@@ -0,0 +1,18 @@\n+/* PR63300 make sure we don't duplicate type qualifiers unneeded.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-gdwarf -dA\" } */\n+\n+/* This should give us:\n+   - One const type pointing to a char\n+   - One volatile type pointing to a char\n+   - Either one const type pointing to the volatile type pointing to a char\n+     or one volatile type pointing to the const type pointing to a char.\n+     But not both.  */\n+\n+char a;\n+const char b;\n+volatile const char c;\n+volatile char d;\n+const volatile char e;\n+\n+/* { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_(?:const|volatile)_type\" 3 } } */"}, {"sha": "5a8d3a07aa3d557350f271e3b9ec607fe7018e42", "filename": "gcc/testsuite/gcc.dg/debug/dwarf2/stacked-qualified-types-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fstacked-qualified-types-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fstacked-qualified-types-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fdwarf2%2Fstacked-qualified-types-2.c?ref=abdc17f81403fa566c44812777296c6d825c3e65", "patch": "@@ -0,0 +1,19 @@\n+/* PR63300 make sure we don't duplicate type qualifiers unneeded.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c99 -gdwarf-4 -dA\" } */\n+\n+/* This should give us:\n+   - One restrict type pointing to a char pointer.\n+   - One volatile type pointing to the restrict type.\n+   - One const type pointing to the restrict type.\n+   - Either one const type pointing to the volatile type pointing to\n+     the restrict type or one volatile type pointing to the const type\n+     pointing to the restrict type.  But not both.  */\n+\n+char * restrict a;\n+char * const restrict b;\n+char * const volatile restrict c;\n+char * volatile restrict d;\n+\n+/* { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_restrict_type\" 1 } } */\n+/* { dg-final { scan-assembler-times \"DIE \\\\(\\[^\\n\\]*\\\\) DW_TAG_(?:const|volatile)_type\" 3 } } */"}, {"sha": "b8d75ed40a84800f42fc9573eefbf5d8918b4022", "filename": "gcc/testsuite/gcc.dg/guality/pr63300-const-volatile.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr63300-const-volatile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr63300-const-volatile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr63300-const-volatile.c?ref=abdc17f81403fa566c44812777296c6d825c3e65", "patch": "@@ -0,0 +1,12 @@\n+/* PR63300 'const volatile' sometimes stripped in debug info */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  const volatile int v = argc;\n+  return v - argc;\n+}\n+\n+/* { dg-final { gdb-test 9 \"type:v\" \"const volatile int\" } } */"}, {"sha": "2f4d194dee56937081329bab88b8ceccde484c5d", "filename": "gcc/tree.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=abdc17f81403fa566c44812777296c6d825c3e65", "patch": "@@ -6185,13 +6185,12 @@ set_type_quals (tree type, int type_quals)\n   TYPE_ADDR_SPACE (type) = DECODE_QUAL_ADDR_SPACE (type_quals);\n }\n \n-/* Returns true iff CAND is equivalent to BASE with TYPE_QUALS.  */\n+/* Returns true iff unqualified CAND and BASE are equivalent.  */\n \n bool\n-check_qualified_type (const_tree cand, const_tree base, int type_quals)\n+check_base_type (const_tree cand, const_tree base)\n {\n-  return (TYPE_QUALS (cand) == type_quals\n-\t  && TYPE_NAME (cand) == TYPE_NAME (base)\n+  return (TYPE_NAME (cand) == TYPE_NAME (base)\n \t  /* Apparently this is needed for Objective-C.  */\n \t  && TYPE_CONTEXT (cand) == TYPE_CONTEXT (base)\n \t  /* Check alignment.  */\n@@ -6200,6 +6199,15 @@ check_qualified_type (const_tree cand, const_tree base, int type_quals)\n \t\t\t\t   TYPE_ATTRIBUTES (base)));\n }\n \n+/* Returns true iff CAND is equivalent to BASE with TYPE_QUALS.  */\n+\n+bool\n+check_qualified_type (const_tree cand, const_tree base, int type_quals)\n+{\n+  return (TYPE_QUALS (cand) == type_quals\n+\t  && check_base_type (cand, base));\n+}\n+\n /* Returns true iff CAND is equivalent to BASE with ALIGN.  */\n \n static bool"}, {"sha": "254129a420af75cb1680aafa6ffc78f31ed1906e", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abdc17f81403fa566c44812777296c6d825c3e65/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=abdc17f81403fa566c44812777296c6d825c3e65", "patch": "@@ -3829,6 +3829,10 @@ extern tree merge_dllimport_decl_attributes (tree, tree);\n extern tree handle_dll_attribute (tree *, tree, tree, int, bool *);\n #endif\n \n+/* Returns true iff unqualified CAND and BASE are equivalent.  */\n+\n+extern bool check_base_type (const_tree cand, const_tree base);\n+\n /* Check whether CAND is suitable to be returned from get_qualified_type\n    (BASE, TYPE_QUALS).  */\n "}]}