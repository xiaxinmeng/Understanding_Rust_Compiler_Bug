{"sha": "3c55880a94aeb7595b6e109c406749f48791901e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M1NTg4MGE5NGFlYjc1OTViNmUxMDljNDA2NzQ5ZjQ4NzkxOTAxZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-06-24T23:27:09Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-06-24T23:27:09Z"}, "message": "ira-build.c (merge_hard_reg_conflicts): New function.\n\n\t* ira-build.c (merge_hard_reg_conflicts): New function.\n\t(create_cap_allocno, copy_info_to_removed_store_destinations,\n\tpropagate_some_info_from_allocno, propagate_allocno_info): Use it.\n\t(move_allocno_live_ranges, copy_allocno_live_ranges): New functions.\n\t(remove_unnecessary_allocnos, remove_low_level_allocnos)\n\tcopy_nifo_to_removed_store_destination): Use them.\n\t* ira-lives.c (make_hard_regno_born): New function, split out of\n\tmake_regno_born.\n\t(make_allocno_born): Likewise.\n\t(make_hard_regno_dead): New function, split out of make_regno_dead.\n\t(make_allocno_dead): Likewise.\n\t(inc_register_pressure): New function, split out of set_allocno_live.\n\t(dec_register_pressure): New function, split out of clear_allocno_live.\n\t(mark_pseudo_regno_live): New function, split out of mark_reg_live.\n\t(mark_hard_reg_live): Likewise.  Use inc_register_pressure.\n\t(mark_pseudo_regno_dead): New function, split out of mark_reg_dead.\n\t(mark_hard_reg_dead): Likewise.  Use dec_register_pressure.\n\t(make_pseudo_conflict): Use mark_pseudo_regno_dead and\n\tmark_pseudo_regno_live.\n\t(process_bb_node_lives): Use mark_pseudo_regno_live,\n\tmake_hard_regno_born and make_allocno_dead.\n\t(make_regno_born, make_regno_dead, mark_reg_live, mark_reg_dead,\n\tset_allocno_live, clear_allocno_live): Delete functions.\n\nFrom-SVN: r161346", "tree": {"sha": "e566c9e259e2e7e0e8d25800fa52da8e75a46b22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e566c9e259e2e7e0e8d25800fa52da8e75a46b22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c55880a94aeb7595b6e109c406749f48791901e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c55880a94aeb7595b6e109c406749f48791901e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c55880a94aeb7595b6e109c406749f48791901e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c55880a94aeb7595b6e109c406749f48791901e/comments", "author": null, "committer": null, "parents": [{"sha": "dd2e0807ccfe17c27241b50beb016a6acf538fec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd2e0807ccfe17c27241b50beb016a6acf538fec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd2e0807ccfe17c27241b50beb016a6acf538fec"}], "stats": {"total": 520, "additions": 238, "deletions": 282}, "files": [{"sha": "843447c63bc0b1389f00d8db532c503720e3775c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c55880a94aeb7595b6e109c406749f48791901e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c55880a94aeb7595b6e109c406749f48791901e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c55880a94aeb7595b6e109c406749f48791901e", "patch": "@@ -2,6 +2,30 @@\n \n \t* ira.c (allocno_pool, copy_pool, allocno_live_range_pool): Delete.\n \n+\t* ira-build.c (merge_hard_reg_conflicts): New function.\n+\t(create_cap_allocno, copy_info_to_removed_store_destinations,\n+\tpropagate_some_info_from_allocno, propagate_allocno_info): Use it.\n+\t(move_allocno_live_ranges, copy_allocno_live_ranges): New functions.\n+\t(remove_unnecessary_allocnos, remove_low_level_allocnos)\n+\tcopy_nifo_to_removed_store_destination): Use them.\n+\t* ira-lives.c (make_hard_regno_born): New function, split out of\n+\tmake_regno_born.\n+\t(make_allocno_born): Likewise.\n+\t(make_hard_regno_dead): New function, split out of make_regno_dead.\n+\t(make_allocno_dead): Likewise.\n+\t(inc_register_pressure): New function, split out of set_allocno_live.\n+\t(dec_register_pressure): New function, split out of clear_allocno_live.\n+\t(mark_pseudo_regno_live): New function, split out of mark_reg_live.\n+\t(mark_hard_reg_live): Likewise.  Use inc_register_pressure.\n+\t(mark_pseudo_regno_dead): New function, split out of mark_reg_dead.\n+\t(mark_hard_reg_dead): Likewise.  Use dec_register_pressure.\n+\t(make_pseudo_conflict): Use mark_pseudo_regno_dead and\n+\tmark_pseudo_regno_live.\n+\t(process_bb_node_lives): Use mark_pseudo_regno_live,\n+\tmake_hard_regno_born and make_allocno_dead.\n+\t(make_regno_born, make_regno_dead, mark_reg_live, mark_reg_dead,\n+\tset_allocno_live, clear_allocno_live): Delete functions.\n+\n 2010-06-24  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* thumb2.md (thumb2_tlobits_cbranch): Delete."}, {"sha": "6900f44221b97f84575ca54586aad9ad8137c340", "filename": "gcc/ira-build.c", "status": "modified", "additions": 68, "deletions": 81, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c55880a94aeb7595b6e109c406749f48791901e/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c55880a94aeb7595b6e109c406749f48791901e/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=3c55880a94aeb7595b6e109c406749f48791901e", "patch": "@@ -504,6 +504,25 @@ ira_set_allocno_cover_class (ira_allocno_t a, enum reg_class cover_class)\n \t\t\t  reg_class_contents[cover_class]);\n }\n \n+/* Merge hard register conflicts from allocno FROM into allocno TO.  If\n+   TOTAL_ONLY is true, we ignore ALLOCNO_CONFLICT_HARD_REGS.  */\n+static void\n+merge_hard_reg_conflicts (ira_allocno_t from, ira_allocno_t to,\n+\t\t\t  bool total_only)\n+{\n+  if (!total_only)\n+    IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (to),\n+\t\t      ALLOCNO_CONFLICT_HARD_REGS (from));\n+  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (to),\n+\t\t    ALLOCNO_TOTAL_CONFLICT_HARD_REGS (from));\n+#ifdef STACK_REGS\n+  if (!total_only && ALLOCNO_NO_STACK_REG_P (from))\n+    ALLOCNO_NO_STACK_REG_P (to) = true;\n+  if (ALLOCNO_TOTAL_NO_STACK_REG_P (from))\n+    ALLOCNO_TOTAL_NO_STACK_REG_P (to) = true;\n+#endif\n+}\n+\n /* Return TRUE if the conflict vector with NUM elements is more\n    profitable than conflict bit vector for A.  */\n bool\n@@ -781,15 +800,8 @@ create_cap_allocno (ira_allocno_t a)\n   ALLOCNO_NREFS (cap) = ALLOCNO_NREFS (a);\n   ALLOCNO_FREQ (cap) = ALLOCNO_FREQ (a);\n   ALLOCNO_CALL_FREQ (cap) = ALLOCNO_CALL_FREQ (a);\n-  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (cap),\n-\t\t    ALLOCNO_CONFLICT_HARD_REGS (a));\n-  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (cap),\n-\t\t    ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+  merge_hard_reg_conflicts (a, cap, false);\n   ALLOCNO_CALLS_CROSSED_NUM (cap) = ALLOCNO_CALLS_CROSSED_NUM (a);\n-#ifdef STACK_REGS\n-  ALLOCNO_NO_STACK_REG_P (cap) = ALLOCNO_NO_STACK_REG_P (a);\n-  ALLOCNO_TOTAL_NO_STACK_REG_P (cap) = ALLOCNO_TOTAL_NO_STACK_REG_P (a);\n-#endif\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     {\n       fprintf (ira_dump_file, \"    Creating cap \");\n@@ -1603,12 +1615,7 @@ propagate_allocno_info (void)\n \t  ALLOCNO_NREFS (parent_a) += ALLOCNO_NREFS (a);\n \t  ALLOCNO_FREQ (parent_a) += ALLOCNO_FREQ (a);\n \t  ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n-#ifdef STACK_REGS\n-\t  if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n-\t    ALLOCNO_TOTAL_NO_STACK_REG_P (parent_a) = true;\n-#endif\n-\t  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (parent_a),\n-\t\t\t    ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+\t  merge_hard_reg_conflicts (a, parent_a, true);\n \t  ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n \t    += ALLOCNO_CALLS_CROSSED_NUM (a);\n \t  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n@@ -1657,6 +1664,46 @@ change_allocno_in_range_list (allocno_live_range_t r, ira_allocno_t a)\n     r->allocno = a;\n }\n \n+/* Move all live ranges associated with allocno FROM to allocno TO.  */\n+static void\n+move_allocno_live_ranges (ira_allocno_t from, ira_allocno_t to)\n+{\n+  allocno_live_range_t lr = ALLOCNO_LIVE_RANGES (from);\n+\n+  if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n+    {\n+      fprintf (ira_dump_file,\n+\t       \"      Moving ranges of a%dr%d to a%dr%d: \",\n+\t       ALLOCNO_NUM (from), ALLOCNO_REGNO (from),\n+\t       ALLOCNO_NUM (to), ALLOCNO_REGNO (to));\n+      ira_print_live_range_list (ira_dump_file, lr);\n+    }\n+  change_allocno_in_range_list (lr, to);\n+  ALLOCNO_LIVE_RANGES (to)\n+    = ira_merge_allocno_live_ranges (lr, ALLOCNO_LIVE_RANGES (to));\n+  ALLOCNO_LIVE_RANGES (from) = NULL;\n+}\n+\n+/* Copy all live ranges associated with allocno FROM to allocno TO.  */\n+static void\n+copy_allocno_live_ranges (ira_allocno_t from, ira_allocno_t to)\n+{\n+  allocno_live_range_t lr = ALLOCNO_LIVE_RANGES (from);\n+\n+  if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n+    {\n+      fprintf (ira_dump_file,\n+\t       \"      Copying ranges of a%dr%d to a%dr%d: \",\n+\t       ALLOCNO_NUM (from), ALLOCNO_REGNO (from),\n+\t       ALLOCNO_NUM (to), ALLOCNO_REGNO (to));\n+      ira_print_live_range_list (ira_dump_file, lr);\n+    }\n+  lr = ira_copy_allocno_live_range_list (lr);\n+  change_allocno_in_range_list (lr, to);\n+  ALLOCNO_LIVE_RANGES (to)\n+    = ira_merge_allocno_live_ranges (lr, ALLOCNO_LIVE_RANGES (to));\n+}\n+\n /* Return TRUE if NODE represents a loop with low register\n    pressure.  */\n static bool\n@@ -1890,26 +1937,15 @@ propagate_some_info_from_allocno (ira_allocno_t a, ira_allocno_t from_a)\n {\n   enum reg_class cover_class;\n \n-  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n-\t\t    ALLOCNO_CONFLICT_HARD_REGS (from_a));\n-#ifdef STACK_REGS\n-  if (ALLOCNO_NO_STACK_REG_P (from_a))\n-    ALLOCNO_NO_STACK_REG_P (a) = true;\n-#endif\n+  merge_hard_reg_conflicts (from_a, a, false);\n   ALLOCNO_NREFS (a) += ALLOCNO_NREFS (from_a);\n   ALLOCNO_FREQ (a) += ALLOCNO_FREQ (from_a);\n   ALLOCNO_CALL_FREQ (a) += ALLOCNO_CALL_FREQ (from_a);\n-  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n-\t\t    ALLOCNO_TOTAL_CONFLICT_HARD_REGS (from_a));\n   ALLOCNO_CALLS_CROSSED_NUM (a) += ALLOCNO_CALLS_CROSSED_NUM (from_a);\n   ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a)\n     += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (from_a);\n   if (! ALLOCNO_BAD_SPILL_P (from_a))\n     ALLOCNO_BAD_SPILL_P (a) = false;\n-#ifdef STACK_REGS\n-  if (ALLOCNO_TOTAL_NO_STACK_REG_P (from_a))\n-    ALLOCNO_TOTAL_NO_STACK_REG_P (a) = true;\n-#endif\n   cover_class = ALLOCNO_COVER_CLASS (from_a);\n   ira_assert (cover_class == ALLOCNO_COVER_CLASS (a));\n   ira_allocate_and_accumulate_costs (&ALLOCNO_HARD_REG_COSTS (a), cover_class,\n@@ -1930,7 +1966,6 @@ remove_unnecessary_allocnos (void)\n   bool merged_p, rebuild_p;\n   ira_allocno_t a, prev_a, next_a, parent_a;\n   ira_loop_tree_node_t a_node, parent;\n-  allocno_live_range_t r;\n \n   merged_p = false;\n   regno_allocnos = NULL;\n@@ -1971,13 +2006,8 @@ remove_unnecessary_allocnos (void)\n \t\t    ira_regno_allocno_map[regno] = next_a;\n \t\t  else\n \t\t    ALLOCNO_NEXT_REGNO_ALLOCNO (prev_a) = next_a;\n-\t\t  r = ALLOCNO_LIVE_RANGES (a);\n-\t\t  change_allocno_in_range_list (r, parent_a);\n-\t\t  ALLOCNO_LIVE_RANGES (parent_a)\n-\t\t    = ira_merge_allocno_live_ranges\n-\t\t      (r, ALLOCNO_LIVE_RANGES (parent_a));\n+\t\t  move_allocno_live_ranges (a, parent_a);\n \t\t  merged_p = true;\n-\t\t  ALLOCNO_LIVE_RANGES (a) = NULL;\n \t\t  propagate_some_info_from_allocno (parent_a, a);\n \t\t  /* Remove it from the corresponding regno allocno\n \t\t     map to avoid info propagation of subsequent\n@@ -2011,7 +2041,6 @@ remove_low_level_allocnos (void)\n   bool merged_p, propagate_p;\n   ira_allocno_t a, top_a;\n   ira_loop_tree_node_t a_node, parent;\n-  allocno_live_range_t r;\n   ira_allocno_iterator ai;\n \n   merged_p = false;\n@@ -2030,12 +2059,8 @@ remove_low_level_allocnos (void)\n       propagate_p = a_node->parent->regno_allocno_map[regno] == NULL;\n       /* Remove the allocno and update info of allocno in the upper\n \t region.  */\n-      r = ALLOCNO_LIVE_RANGES (a);\n-      change_allocno_in_range_list (r, top_a);\n-      ALLOCNO_LIVE_RANGES (top_a)\n-\t= ira_merge_allocno_live_ranges (r, ALLOCNO_LIVE_RANGES (top_a));\n+      move_allocno_live_ranges (a, top_a);\n       merged_p = true;\n-      ALLOCNO_LIVE_RANGES (a) = NULL;\n       if (propagate_p)\n \tpropagate_some_info_from_allocno (top_a, a);\n     }\n@@ -2402,7 +2427,6 @@ copy_info_to_removed_store_destinations (int regno)\n   ira_allocno_t a;\n   ira_allocno_t parent_a = NULL;\n   ira_loop_tree_node_t parent;\n-  allocno_live_range_t r;\n   bool merged_p;\n \n   merged_p = false;\n@@ -2425,26 +2449,8 @@ copy_info_to_removed_store_destinations (int regno)\n \t  break;\n       if (parent == NULL || parent_a == NULL)\n \tcontinue;\n-      if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n-\t{\n-\t  fprintf\n-\t    (ira_dump_file,\n-\t     \"      Coping ranges of a%dr%d to a%dr%d: \",\n-\t     ALLOCNO_NUM (a), REGNO (ALLOCNO_REG (a)),\n-\t     ALLOCNO_NUM (parent_a), REGNO (ALLOCNO_REG (parent_a)));\n-\t  ira_print_live_range_list (ira_dump_file,\n-\t\t\t\t     ALLOCNO_LIVE_RANGES (a));\n-\t}\n-      r = ira_copy_allocno_live_range_list (ALLOCNO_LIVE_RANGES (a));\n-      change_allocno_in_range_list (r, parent_a);\n-      ALLOCNO_LIVE_RANGES (parent_a)\n-\t= ira_merge_allocno_live_ranges (r, ALLOCNO_LIVE_RANGES (parent_a));\n-      IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (parent_a),\n-\t\t\tALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n-#ifdef STACK_REGS\n-      if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n-\tALLOCNO_TOTAL_NO_STACK_REG_P (parent_a) = true;\n-#endif\n+      copy_allocno_live_ranges (a, parent_a);\n+      merge_hard_reg_conflicts (a, parent_a, true);\n       ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n       ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n \t+= ALLOCNO_CALLS_CROSSED_NUM (a);\n@@ -2522,28 +2528,9 @@ ira_flattening (int max_regno_before_emit, int ira_max_point_before_emit)\n \t    mem_dest_p = true;\n \t  if (REGNO (ALLOCNO_REG (a)) == REGNO (ALLOCNO_REG (parent_a)))\n \t    {\n-\t      IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (parent_a),\n-\t\t\t\tALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n-#ifdef STACK_REGS\n-\t      if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n-\t\tALLOCNO_TOTAL_NO_STACK_REG_P (parent_a) = true;\n-#endif\n-\t      if (internal_flag_ira_verbose > 4 && ira_dump_file != NULL)\n-\t\t{\n-\t\t  fprintf (ira_dump_file,\n-\t\t\t   \"      Moving ranges of a%dr%d to a%dr%d: \",\n-\t\t\t   ALLOCNO_NUM (a), REGNO (ALLOCNO_REG (a)),\n-\t\t\t   ALLOCNO_NUM (parent_a),\n-\t\t\t   REGNO (ALLOCNO_REG (parent_a)));\n-\t\t  ira_print_live_range_list (ira_dump_file,\n-\t\t\t\t\t     ALLOCNO_LIVE_RANGES (a));\n-\t\t}\n-\t      change_allocno_in_range_list (ALLOCNO_LIVE_RANGES (a), parent_a);\n-\t      ALLOCNO_LIVE_RANGES (parent_a)\n-\t\t= ira_merge_allocno_live_ranges\n-\t\t  (ALLOCNO_LIVE_RANGES (a), ALLOCNO_LIVE_RANGES (parent_a));\n+\t      merge_hard_reg_conflicts (a, parent_a, true);\n+\t      move_allocno_live_ranges (a, parent_a);\n \t      merged_p = true;\n-\t      ALLOCNO_LIVE_RANGES (a) = NULL;\n \t      ALLOCNO_MEM_OPTIMIZED_DEST_P (parent_a)\n \t\t= (ALLOCNO_MEM_OPTIMIZED_DEST_P (parent_a)\n \t\t   || ALLOCNO_MEM_OPTIMIZED_DEST_P (a));"}, {"sha": "3034805bbe9beb0909a9dbb975eaf649ffda3d4b", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 146, "deletions": 201, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c55880a94aeb7595b6e109c406749f48791901e/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c55880a94aeb7595b6e109c406749f48791901e/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=3c55880a94aeb7595b6e109c406749f48791901e", "patch": "@@ -81,33 +81,44 @@ static int last_call_num;\n /* The number of last call at which given allocno was saved.  */\n static int *allocno_saved_at_call;\n \n-/* The function processing birth of register REGNO.  It updates living\n-   hard regs and conflict hard regs for living allocnos or starts a\n-   new live range for the allocno corresponding to REGNO if it is\n-   necessary.  */\n+/* Record the birth of hard register REGNO, updating hard_regs_live\n+   and hard reg conflict information for living allocno.  */\n static void\n-make_regno_born (int regno)\n+make_hard_regno_born (int regno)\n {\n   unsigned int i;\n-  ira_allocno_t a;\n-  allocno_live_range_t p;\n \n-  if (regno < FIRST_PSEUDO_REGISTER)\n+  SET_HARD_REG_BIT (hard_regs_live, regno);\n+  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n     {\n-      SET_HARD_REG_BIT (hard_regs_live, regno);\n-      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-        {\n-\t  SET_HARD_REG_BIT (ALLOCNO_CONFLICT_HARD_REGS (ira_allocnos[i]),\n-\t\t\t    regno);\n-\t  SET_HARD_REG_BIT (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (ira_allocnos[i]),\n-\t\t\t    regno);\n-\t}\n-      return;\n+      SET_HARD_REG_BIT (ALLOCNO_CONFLICT_HARD_REGS (ira_allocnos[i]),\n+\t\t\tregno);\n+      SET_HARD_REG_BIT (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (ira_allocnos[i]),\n+\t\t\tregno);\n     }\n-  a = ira_curr_regno_allocno_map[regno];\n-  if (a == NULL)\n-    return;\n-  if ((p = ALLOCNO_LIVE_RANGES (a)) == NULL\n+}\n+\n+/* Process the death of hard register REGNO.  This updates\n+   hard_regs_live.  */\n+static void\n+make_hard_regno_dead (int regno)\n+{\n+  CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n+}\n+\n+/* Record the birth of allocno A, starting a new live range for\n+   it if necessary, and updating hard reg conflict information.  We also\n+   record it in allocnos_live.  */\n+static void\n+make_allocno_born (ira_allocno_t a)\n+{\n+  allocno_live_range_t p = ALLOCNO_LIVE_RANGES (a);\n+\n+  sparseset_set_bit (allocnos_live, ALLOCNO_NUM (a));\n+  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a), hard_regs_live);\n+  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), hard_regs_live);\n+\n+  if (p == NULL\n       || (p->finish != curr_point && p->finish + 1 != curr_point))\n     ALLOCNO_LIVE_RANGES (a)\n       = ira_create_allocno_live_range (a, curr_point, -1,\n@@ -137,56 +148,39 @@ update_allocno_pressure_excess_length (ira_allocno_t a)\n     }\n }\n \n-/* Process the death of register REGNO.  This updates hard_regs_live\n-   or finishes the current live range for the allocno corresponding to\n-   REGNO.  */\n+/* Process the death of allocno A.  This finishes the current live\n+   range for it.  */\n static void\n-make_regno_dead (int regno)\n+make_allocno_dead (ira_allocno_t a)\n {\n-  ira_allocno_t a;\n   allocno_live_range_t p;\n \n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n-      return;\n-    }\n-  a = ira_curr_regno_allocno_map[regno];\n-  if (a == NULL)\n-    return;\n   p = ALLOCNO_LIVE_RANGES (a);\n   ira_assert (p != NULL);\n   p->finish = curr_point;\n   update_allocno_pressure_excess_length (a);\n+  sparseset_clear_bit (allocnos_live, ALLOCNO_NUM (a));\n }\n \n /* The current register pressures for each cover class for the current\n    basic block.  */\n static int curr_reg_pressure[N_REG_CLASSES];\n \n-/* Mark allocno A as currently living and update current register\n-   pressure, maximal register pressure for the current BB, start point\n-   of the register pressure excess, and conflicting hard registers of\n-   A.  */\n+/* Record that register pressure for COVER_CLASS increased by N\n+   registers.  Update the current register pressure, maximal register\n+   pressure for the current BB and the start point of the register\n+   pressure excess.  */\n static void\n-set_allocno_live (ira_allocno_t a)\n+inc_register_pressure (enum reg_class cover_class, int n)\n {\n   int i;\n-  enum reg_class cover_class, cl;\n+  enum reg_class cl;\n \n-  /* Invalidate because it is referenced.  */\n-  allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n-  if (sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n-    return;\n-  sparseset_set_bit (allocnos_live, ALLOCNO_NUM (a));\n-  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a), hard_regs_live);\n-  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a), hard_regs_live);\n-  cover_class = ALLOCNO_COVER_CLASS (a);\n   for (i = 0;\n        (cl = ira_reg_class_super_classes[cover_class][i]) != LIM_REG_CLASSES;\n        i++)\n     {\n-      curr_reg_pressure[cl] += ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n+      curr_reg_pressure[cl] += n;\n       if (high_pressure_start_point[cl] < 0\n \t  && (curr_reg_pressure[cl] > ira_available_class_regs[cl]))\n \thigh_pressure_start_point[cl] = curr_point;\n@@ -195,110 +189,87 @@ set_allocno_live (ira_allocno_t a)\n     }\n }\n \n-/* Mark allocno A as currently not living and update current register\n-   pressure, start point of the register pressure excess, and register\n-   pressure excess length for living allocnos.  */\n+/* Record that register pressure for COVER_CLASS has decreased by\n+   NREGS registers; update current register pressure, start point of\n+   the register pressure excess, and register pressure excess length\n+   for living allocnos.  */\n+\n static void\n-clear_allocno_live (ira_allocno_t a)\n+dec_register_pressure (enum reg_class cover_class, int nregs)\n {\n   int i;\n   unsigned int j;\n-  enum reg_class cover_class, cl;\n-  bool set_p;\n+  enum reg_class cl;\n+  bool set_p = false;\n \n-  /* Invalidate because it is referenced.  */\n-  allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n-  if (sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n+  for (i = 0;\n+       (cl = ira_reg_class_super_classes[cover_class][i]) != LIM_REG_CLASSES;\n+       i++)\n     {\n-      cover_class = ALLOCNO_COVER_CLASS (a);\n-      set_p = false;\n+      curr_reg_pressure[cl] -= nregs;\n+      ira_assert (curr_reg_pressure[cl] >= 0);\n+      if (high_pressure_start_point[cl] >= 0\n+\t  && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n+\tset_p = true;\n+    }\n+  if (set_p)\n+    {\n+      EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, j)\n+\tupdate_allocno_pressure_excess_length (ira_allocnos[j]);\n       for (i = 0;\n \t   (cl = ira_reg_class_super_classes[cover_class][i])\n \t     != LIM_REG_CLASSES;\n \t   i++)\n-\t{\n-\t  curr_reg_pressure[cl] -= ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n-\t  ira_assert (curr_reg_pressure[cl] >= 0);\n-\t  if (high_pressure_start_point[cl] >= 0\n-\t      && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n-\t    set_p = true;\n-\t}\n-      if (set_p)\n-\t{\n-\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, j)\n-\t    update_allocno_pressure_excess_length (ira_allocnos[j]);\n-\t  for (i = 0;\n-\t       (cl = ira_reg_class_super_classes[cover_class][i])\n-\t\t != LIM_REG_CLASSES;\n-\t       i++)\n-\t    if (high_pressure_start_point[cl] >= 0\n-\t\t&& curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n-\t      high_pressure_start_point[cl] = -1;\n-\n-\t}\n+\tif (high_pressure_start_point[cl] >= 0\n+\t    && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n+\t  high_pressure_start_point[cl] = -1;\n     }\n-  sparseset_clear_bit (allocnos_live, ALLOCNO_NUM (a));\n }\n \n-/* Mark the register REG as live.  Store a 1 in hard_regs_live or\n-   allocnos_live for this register or the corresponding allocno,\n-   record how many consecutive hardware registers it actually\n-   needs.  */\n+/* Mark the pseudo register REGNO as live.  Update all information about\n+   live ranges and register pressure.  */\n static void\n-mark_reg_live (rtx reg)\n+mark_pseudo_regno_live (int regno)\n {\n-  int i, regno;\n+  ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n+  enum reg_class cl;\n+  int nregs;\n \n-  gcc_assert (REG_P (reg));\n-  regno = REGNO (reg);\n+  if (a == NULL)\n+    return;\n \n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n+  /* Invalidate because it is referenced.  */\n+  allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n \n-      if (a != NULL)\n-\t{\n-\t  if (sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n-\t    {\n-\t      /* Invalidate because it is referenced.  */\n-\t      allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n-\t      return;\n-\t    }\n-\t  set_allocno_live (a);\n-\t}\n-      make_regno_born (regno);\n-    }\n-  else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n+  if (sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n+    return;\n+\n+  cl = ALLOCNO_COVER_CLASS (a);\n+  nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n+  inc_register_pressure (cl, nregs);\n+  make_allocno_born (a);\n+}\n+\n+/* Mark the hard register REG as live.  Store a 1 in hard_regs_live\n+   for this register, record how many consecutive hardware registers\n+   it actually needs.  */\n+static void\n+mark_hard_reg_live (rtx reg)\n+{\n+  int regno = REGNO (reg);\n+\n+  if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n       int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n-      enum reg_class cover_class, cl;\n \n       while (regno < last)\n \t{\n \t  if (! TEST_HARD_REG_BIT (hard_regs_live, regno)\n \t      && ! TEST_HARD_REG_BIT (eliminable_regset, regno))\n \t    {\n-\t      cover_class = ira_hard_regno_cover_class[regno];\n-\t      for (i = 0;\n-\t\t   (cl = ira_reg_class_super_classes[cover_class][i])\n-\t\t     != LIM_REG_CLASSES;\n-\t\t   i++)\n-\t\t{\n-\t\t  curr_reg_pressure[cl]++;\n-\t\t  if (high_pressure_start_point[cl] < 0\n-\t\t      && (curr_reg_pressure[cl]\n-\t\t\t  > ira_available_class_regs[cl]))\n-\t\t    high_pressure_start_point[cl] = curr_point;\n-\t\t}\n-\t      make_regno_born (regno);\n-\t      for (i = 0;\n-\t\t   (cl = ira_reg_class_super_classes[cover_class][i])\n-\t\t     != LIM_REG_CLASSES;\n-\t\t   i++)\n-\t\t{\n-\t\t  if (curr_bb_node->reg_pressure[cl] < curr_reg_pressure[cl])\n-\t\t    curr_bb_node->reg_pressure[cl] = curr_reg_pressure[cl];\n-\t\t}\n+\t      enum reg_class cover_class = ira_hard_regno_cover_class[regno];\n+\t      inc_register_pressure (cover_class, 1);\n+\t      make_hard_regno_born (regno);\n \t    }\n \t  regno++;\n \t}\n@@ -314,74 +285,55 @@ mark_ref_live (df_ref ref)\n   reg = DF_REF_REG (ref);\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n-  mark_reg_live (reg);\n+  if (REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+    mark_pseudo_regno_live (REGNO (reg));\n+  else\n+    mark_hard_reg_live (reg);\n }\n \n-/* Mark the register REG as dead.  Store a 0 in hard_regs_live or\n-   allocnos_live for the register.  */\n+/* Mark the pseudo register REGNO as dead.  Update all information about\n+   live ranges and register pressure.  */\n static void\n-mark_reg_dead (rtx reg)\n+mark_pseudo_regno_dead (int regno)\n {\n-  int regno;\n+  ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n+  enum reg_class cl;\n+  int nregs;\n \n-  gcc_assert (REG_P (reg));\n-  regno = REGNO (reg);\n+  if (a == NULL)\n+    return;\n \n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    {\n-      ira_allocno_t a = ira_curr_regno_allocno_map[regno];\n+  /* Invalidate because it is referenced.  */\n+  allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n \n-      if (a != NULL)\n-\t{\n-\t  if (! sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n-\t    {\n-\t      /* Invalidate because it is referenced.  */\n-\t      allocno_saved_at_call[ALLOCNO_NUM (a)] = 0;\n-\t      return;\n-\t    }\n-\t  clear_allocno_live (a);\n-\t}\n-      make_regno_dead (regno);\n-    }\n-  else if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n+  if (! sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)))\n+    return;\n+\n+  cl = ALLOCNO_COVER_CLASS (a);\n+  nregs = ira_reg_class_nregs[cl][ALLOCNO_MODE (a)];\n+  dec_register_pressure (cl, nregs);\n+\n+  make_allocno_dead (a);\n+}\n+\n+/* Mark the hard register REG as dead.  Store a 0 in hard_regs_live\n+   for the register.  */\n+static void\n+mark_hard_reg_dead (rtx reg)\n+{\n+  int regno = REGNO (reg);\n+\n+  if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n     {\n-      int i;\n-      unsigned int j;\n       int last = regno + hard_regno_nregs[regno][GET_MODE (reg)];\n-      enum reg_class cover_class, cl;\n-      bool set_p;\n \n       while (regno < last)\n \t{\n \t  if (TEST_HARD_REG_BIT (hard_regs_live, regno))\n \t    {\n-\t      set_p = false;\n-\t      cover_class = ira_hard_regno_cover_class[regno];\n-\t      for (i = 0;\n-\t\t   (cl = ira_reg_class_super_classes[cover_class][i])\n-\t\t     != LIM_REG_CLASSES;\n-\t\t   i++)\n-  \t\t{\n-\t\t  curr_reg_pressure[cl]--;\n-\t\t  if (high_pressure_start_point[cl] >= 0\n-\t\t      && curr_reg_pressure[cl] <= ira_available_class_regs[cl])\n-\t\t    set_p = true;\n-\t\t  ira_assert (curr_reg_pressure[cl] >= 0);\n-\t\t}\n-\t      if (set_p)\n-\t\t{\n-\t\t  EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, j)\n-\t\t    update_allocno_pressure_excess_length (ira_allocnos[j]);\n-\t\t  for (i = 0;\n-\t\t       (cl = ira_reg_class_super_classes[cover_class][i])\n-\t\t\t != LIM_REG_CLASSES;\n-\t\t       i++)\n-\t\t    if (high_pressure_start_point[cl] >= 0\n-\t\t\t&& (curr_reg_pressure[cl]\n-\t\t\t    <= ira_available_class_regs[cl]))\n-\t\t      high_pressure_start_point[cl] = -1;\n-\t\t}\n-\t      make_regno_dead (regno);\n+\t      enum reg_class cover_class = ira_hard_regno_cover_class[regno];\n+\t      dec_register_pressure (cover_class, 1);\n+\t      make_hard_regno_dead (regno);\n \t    }\n \t  regno++;\n \t}\n@@ -402,7 +354,10 @@ mark_ref_dead (df_ref def)\n   reg = DF_REF_REG (def);\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n-  mark_reg_dead (reg);\n+  if (REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+    mark_pseudo_regno_dead (REGNO (reg));\n+  else\n+    mark_hard_reg_dead (reg);\n }\n \n /* Make pseudo REG conflicting with pseudo DREG, if the 1st pseudo\n@@ -427,10 +382,10 @@ make_pseudo_conflict (rtx reg, enum reg_class cl, rtx dreg, bool advance_p)\n   if (advance_p)\n     curr_point++;\n \n-  mark_reg_live (reg);\n-  mark_reg_live (dreg);\n-  mark_reg_dead (reg);\n-  mark_reg_dead (dreg);\n+  mark_pseudo_regno_live (REGNO (reg));\n+  mark_pseudo_regno_live (REGNO (dreg));\n+  mark_pseudo_regno_dead (REGNO (reg));\n+  mark_pseudo_regno_dead (REGNO (dreg));\n \n   return false;\n }\n@@ -961,15 +916,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t      }\n \t  }\n       EXECUTE_IF_SET_IN_BITMAP (reg_live_out, FIRST_PSEUDO_REGISTER, j, bi)\n-\t{\n-\t  ira_allocno_t a = ira_curr_regno_allocno_map[j];\n-\n-\t  if (a == NULL)\n-\t    continue;\n-\t  ira_assert (! sparseset_bit_p (allocnos_live, ALLOCNO_NUM (a)));\n-\t  set_allocno_live (a);\n-\t  make_regno_born (j);\n-\t}\n+\tmark_pseudo_regno_live (j);\n \n       freq = REG_FREQ_FROM_BB (bb);\n       if (freq == 0)\n@@ -1137,7 +1084,7 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t    unsigned int regno = EH_RETURN_DATA_REGNO (j);\n \t    if (regno == INVALID_REGNUM)\n \t      break;\n-\t    make_regno_born (regno);\n+\t    make_hard_regno_born (regno);\n \t  }\n #endif\n \n@@ -1155,21 +1102,19 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t      ALLOCNO_TOTAL_NO_STACK_REG_P (ira_allocnos[px]) = true;\n \t    }\n \t  for (px = FIRST_STACK_REG; px <= LAST_STACK_REG; px++)\n-\t    make_regno_born (px);\n+\t    make_hard_regno_born (px);\n #endif\n \t  /* No need to record conflicts for call clobbered regs if we\n \t     have nonlocal labels around, as we don't ever try to\n \t     allocate such regs in this case.  */\n \t  if (!cfun->has_nonlocal_label && bb_has_abnormal_call_pred (bb))\n \t    for (px = 0; px < FIRST_PSEUDO_REGISTER; px++)\n \t      if (call_used_regs[px])\n-\t\tmake_regno_born (px);\n+\t\tmake_hard_regno_born (px);\n \t}\n \n       EXECUTE_IF_SET_IN_SPARSESET (allocnos_live, i)\n-\t{\n-\t  make_regno_dead (ALLOCNO_REGNO (ira_allocnos[i]));\n-\t}\n+\tmake_allocno_dead (ira_allocnos[i]);\n \n       curr_point++;\n "}]}