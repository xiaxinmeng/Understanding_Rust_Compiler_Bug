{"sha": "16ba4214ee315678d2dabe417a71d09a9b867662", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZiYTQyMTRlZTMxNTY3OGQyZGFiZTQxN2E3MWQwOWE5Yjg2NzY2Mg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-09-05T11:09:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-05T11:09:09Z"}, "message": "pexecute.c: Updates from gcc.\n\n        * pexecute.c: Updates from gcc.  Copy in gcc has been removed.  This\n        is the canonical copy.  Define ISSPACE if !IN_GCC.\n        * alloca.c, vfprintf.c, choose-temp.c, mkstemp.c: Similarly.\n        * Makefile.in: Build mkstemp.o\n\nFrom-SVN: r22252", "tree": {"sha": "b12407c893adcd5286f08ea73d4406d44bbe36c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b12407c893adcd5286f08ea73d4406d44bbe36c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16ba4214ee315678d2dabe417a71d09a9b867662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ba4214ee315678d2dabe417a71d09a9b867662", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ba4214ee315678d2dabe417a71d09a9b867662", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ba4214ee315678d2dabe417a71d09a9b867662/comments", "author": null, "committer": null, "parents": [{"sha": "8c6c251db1090a3b0154d4da44bfe5880eef2860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c6c251db1090a3b0154d4da44bfe5880eef2860", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c6c251db1090a3b0154d4da44bfe5880eef2860"}], "stats": {"total": 206, "additions": 192, "deletions": 14}, "files": [{"sha": "eb29aecc5d0b845d847a1434a9c0b94db457cf1c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ba4214ee315678d2dabe417a71d09a9b867662/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ba4214ee315678d2dabe417a71d09a9b867662/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=16ba4214ee315678d2dabe417a71d09a9b867662", "patch": "@@ -2,6 +2,8 @@ Sat Sep  5 03:24:49 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* pexecute.c: Updates from gcc.  Copy in gcc has been removed.  This\n \tis the canonical copy.  Define ISSPACE if !IN_GCC.\n+\t* alloca.c, vfprintf.c, choose-temp.c, mkstemp.c: Similarly.\n+\t* Makefile.in: Build mkstemp.o\n \n Wed Aug 19 14:05:01 1998  Mumit Khan  <khan@xraylith.wisc.edu>\n "}, {"sha": "edc6440f0d2f9ee5797b346db75738acaaa5975d", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ba4214ee315678d2dabe417a71d09a9b867662/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ba4214ee315678d2dabe417a71d09a9b867662/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=16ba4214ee315678d2dabe417a71d09a9b867662", "patch": "@@ -114,7 +114,7 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c \\\n \tbzero.c choose-temp.c clock.c concat.c cplus-dem.c fdmatch.c \\\n \tfnmatch.c getcwd.c getopt.c getopt1.c getpagesize.c \\\n \tgetruntime.c floatformat.c hex.c index.c insque.c memchr.c \\\n-\tmemcmp.c memcpy.c memmove.c memset.c objalloc.c obstack.c \\\n+\tmemcmp.c memcpy.c memmove.c memset.c mkstemp.c objalloc.c obstack.c \\\n \tpexecute.c random.c rename.c rindex.c sigsetmask.c spaces.c \\\n \tstrcasecmp.c strncasecmp.c strchr.c strdup.c strerror.c \\\n \tstrrchr.c strsignal.c strstr.c strtod.c strtol.c strtoul.c \\\n@@ -124,7 +124,7 @@ CFILES = asprintf.c alloca.c argv.c atexit.c basename.c bcmp.c bcopy.c \\\n # These are always included in the library.\n REQUIRED_OFILES = argv.o choose-temp.o concat.o cplus-dem.o \\\n   fdmatch.o fnmatch.o getopt.o getopt1.o getruntime.o hex.o \\\n-  floatformat.o objalloc.o obstack.o pexecute.o spaces.o strerror.o \\\n+  floatformat.o mkstemp.o objalloc.o obstack.o pexecute.o spaces.o strerror.o \\\n   strsignal.o xatexit.o xexit.o xmalloc.o xstrdup.o xstrerror.o\n \n $(TARGETLIB): $(REQUIRED_OFILES) $(EXTRA_OFILES) $(LIBOBJS)\n@@ -229,6 +229,7 @@ getpagesize.o: config.h\n getruntime.o: config.h $(INCDIR)/libiberty.h\n hex.o: $(INCDIR)/libiberty.h\n floatformat.o: $(INCDIR)/floatformat.h\n+mkstemp.o: config.h\n objalloc.o: $(INCDIR)/objalloc.h\n obstack.o: $(INCDIR)/obstack.h\n pexecute.o: config.h $(INCDIR)/libiberty.h"}, {"sha": "46293367613b5ac18f4bb8a0faca3e82abc76852", "filename": "libiberty/choose-temp.c", "status": "modified", "additions": 66, "deletions": 12, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ba4214ee315678d2dabe417a71d09a9b867662/libiberty%2Fchoose-temp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ba4214ee315678d2dabe417a71d09a9b867662/libiberty%2Fchoose-temp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fchoose-temp.c?ref=16ba4214ee315678d2dabe417a71d09a9b867662", "patch": "@@ -17,7 +17,7 @@ License along with libiberty; see the file COPYING.LIB.  If not,\n write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* This file exports one function: choose_temp_base.  */\n+/* This file exports two functions: choose_temp_base and make_temp_file.  */\n \n /* This file lives in at least two places: libiberty and gcc.\n    Don't change one without the other.  */\n@@ -102,7 +102,10 @@ try (dir, base)\n /* Return a prefix for temporary file names or NULL if unable to find one.\n    The current directory is chosen if all else fails so the program is\n    exited if a temporary directory can't be found (mktemp fails).\n-   The buffer for the result is obtained with xmalloc.  */\n+   The buffer for the result is obtained with xmalloc. \n+\n+   This function is provided for backwards compatability only.  It use\n+   is not recommended.  */\n \n char *\n choose_temp_base ()\n@@ -113,7 +116,6 @@ choose_temp_base ()\n   static char tmp[] = { DIR_SEPARATOR, 't', 'm', 'p', 0 };\n   static char usrtmp[] = { DIR_SEPARATOR, 'u', 's', 'r', DIR_SEPARATOR, 't', 'm', 'p', 0 };\n \n-#ifndef MPW\n   base = try (getenv (\"TMPDIR\"), base);\n   base = try (getenv (\"TMP\"), base);\n   base = try (getenv (\"TEMP\"), base);\n@@ -130,28 +132,80 @@ choose_temp_base ()\n   if (base == 0)\n     base = \".\";\n \n-#else /* MPW */\n-  base = \":\";\n-#endif\n-\n   len = strlen (base);\n   temp_filename = xmalloc (len + 1 /*DIR_SEPARATOR*/\n \t\t\t   + strlen (TEMP_FILE) + 1);\n   strcpy (temp_filename, base);\n \n-#ifndef MPW\n   if (len != 0\n       && temp_filename[len-1] != '/'\n       && temp_filename[len-1] != DIR_SEPARATOR)\n     temp_filename[len++] = DIR_SEPARATOR;\n-#else /* MPW */\n-  if (temp_filename[len-1] != ':')\n-    temp_filename[len++] = ':';\n-#endif /* MPW */\n   strcpy (temp_filename + len, TEMP_FILE);\n \n   mktemp (temp_filename);\n   if (strlen (temp_filename) == 0)\n     abort ();\n   return temp_filename;\n }\n+/* Return a temporary file name (as a string) or NULL if unable to create\n+   one.  */\n+\n+char *\n+make_temp_file (suffix)\n+     char *suffix;\n+{\n+  char *base = 0;\n+  char *temp_filename;\n+  int base_len, suffix_len;\n+  int fd;\n+  static char tmp[] = { DIR_SEPARATOR, 't', 'm', 'p', 0 };\n+  static char usrtmp[] = { DIR_SEPARATOR, 'u', 's', 'r', DIR_SEPARATOR, 't', 'm', 'p', 0 };\n+\n+  base = try (getenv (\"TMPDIR\"), base);\n+  base = try (getenv (\"TMP\"), base);\n+  base = try (getenv (\"TEMP\"), base);\n+\n+#ifdef P_tmpdir\n+  base = try (P_tmpdir, base);\n+#endif\n+\n+  /* Try /usr/tmp, then /tmp.  */\n+  base = try (usrtmp, base);\n+  base = try (tmp, base);\n+ \n+  /* If all else fails, use the current directory!  */\n+  if (base == 0)\n+    base = \".\";\n+\n+  base_len = strlen (base);\n+\n+  if (suffix)\n+    suffix_len = strlen (suffix);\n+  else\n+    suffix_len = 0;\n+\n+  temp_filename = xmalloc (base_len + 1 /*DIR_SEPARATOR*/\n+\t\t\t   + strlen (TEMP_FILE)\n+\t\t\t   + suffix_len + 1);\n+  strcpy (temp_filename, base);\n+\n+  if (base_len != 0\n+      && temp_filename[base_len-1] != '/'\n+      && temp_filename[base_len-1] != DIR_SEPARATOR)\n+    temp_filename[base_len++] = DIR_SEPARATOR;\n+  strcpy (temp_filename + base_len, TEMP_FILE);\n+\n+  if (suffix)\n+    strcat (temp_filename, suffix);\n+\n+  fd = mkstemps (temp_filename, suffix_len);\n+  /* If mkstemps failed, then something bad is happening.  Maybe we should\n+     issue a message about a possible security attack in progress?  */\n+  if (fd == -1)\n+    abort ();\n+  /* Similarly if we can not close the file.  */\n+  if (close (fd))\n+    abort ();\n+  return temp_filename;\n+}"}, {"sha": "21afcf0d6399cd46e176f35eedade97eb46efb1b", "filename": "libiberty/mkstemp.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16ba4214ee315678d2dabe417a71d09a9b867662/libiberty%2Fmkstemp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16ba4214ee315678d2dabe417a71d09a9b867662/libiberty%2Fmkstemp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fmkstemp.c?ref=16ba4214ee315678d2dabe417a71d09a9b867662", "patch": "@@ -0,0 +1,121 @@\n+/* Copyright (C) 1991, 1992, 1996, 1998 Free Software Foundation, Inc.\n+   This file is derived from mkstemp.c from the GNU C Library.\n+\n+   The GNU C Library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU Library General Public License as\n+   published by the Free Software Foundation; either version 2 of the\n+   License, or (at your option) any later version.\n+\n+   The GNU C Library is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   Library General Public License for more details.\n+\n+   You should have received a copy of the GNU Library General Public\n+   License along with the GNU C Library; see the file COPYING.LIB.  If not,\n+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#ifndef IN_GCC\n+#include <stdlib.h>\n+#include <string.h>\n+#include <errno.h>\n+#include <stdio.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <sys/time.h>\n+#else\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"gansidecl.h\"\n+#endif\n+\n+/* We need to provide a type for gcc_uint64_t.  */\n+#ifdef __GNUC__\n+typedef unsigned long long gcc_uint64_t;\n+#else\n+typedef unsigned long gcc_uint64_t;\n+#endif\n+\n+#ifndef TMP_MAX\n+#define TMP_MAX 16384\n+#endif\n+\n+/* Generate a unique temporary file name from TEMPLATE.\n+\n+   TEMPLATE has the form:\n+\n+   <path>/ccXXXXXX<suffix>\n+\n+   SUFFIX_LEN tells us how long <suffix> is (it can be zero length).\n+\n+   The last six characters of TEMPLATE before <suffix> must be \"XXXXXX\";\n+   they are replaced with a string that makes the filename unique.\n+\n+   Returns a file descriptor open on the file for reading and writing.  */\n+int\n+mkstemps (template, suffix_len)\n+     char *template;\n+     int suffix_len;\n+{\n+  static const char letters[]\n+    = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n+  static gcc_uint64_t value;\n+#ifdef HAVE_GETTIMEOFDAY\n+  struct timeval tv;\n+#endif\n+  char *XXXXXX;\n+  size_t len;\n+  int count;\n+\n+  len = strlen (template);\n+\n+  if (len < 6 + suffix_len\n+      || strncmp (&template[len - 6 - suffix_len], \"XXXXXX\", 6))\n+    {\n+      return -1;\n+    }\n+\n+  XXXXXX = &template[len - 6 - suffix_len];\n+\n+#ifdef HAVE_GETTIMEOFDAY\n+  /* Get some more or less random data.  */\n+  gettimeofday (&tv, NULL);\n+  value += ((gcc_uint64_t) tv.tv_usec << 16) ^ tv.tv_sec ^ getpid ();\n+#else\n+  value += getpid ();\n+#endif\n+\n+  for (count = 0; count < TMP_MAX; ++count)\n+    {\n+      gcc_uint64_t v = value;\n+      int fd;\n+\n+      /* Fill in the random bits.  */\n+      XXXXXX[0] = letters[v % 62];\n+      v /= 62;\n+      XXXXXX[1] = letters[v % 62];\n+      v /= 62;\n+      XXXXXX[2] = letters[v % 62];\n+      v /= 62;\n+      XXXXXX[3] = letters[v % 62];\n+      v /= 62;\n+      XXXXXX[4] = letters[v % 62];\n+      v /= 62;\n+      XXXXXX[5] = letters[v % 62];\n+\n+      fd = open (template, O_RDWR|O_CREAT|O_EXCL, 0600);\n+      if (fd >= 0)\n+\t/* The file does not exist.  */\n+\treturn fd;\n+\n+      /* This is a random value.  It is only necessary that the next\n+\t TMP_MAX values generated by adding 7777 to VALUE are different\n+\t with (module 2^32).  */\n+      value += 7777;\n+    }\n+\n+  /* We return the null string if we can't find a unique file name.  */\n+  template[0] = '\\0';\n+  return -1;\n+}"}]}