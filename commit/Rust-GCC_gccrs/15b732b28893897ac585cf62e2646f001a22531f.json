{"sha": "15b732b28893897ac585cf62e2646f001a22531f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTViNzMyYjI4ODkzODk3YWM1ODVjZjYyZTI2NDZmMDAxYTIyNTMxZg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-05-11T06:38:48Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-05-11T06:38:48Z"}, "message": "c-common.c (finish_label_expr): New function, lifted from from cp/semantics.c.\n\n\t* c-common.c (finish_label_expr): New function, lifted from\n\tfrom cp/semantics.c.\n\t* c-common.h (finish_label_expr, lookup_label): New prototypes.\n\t* c-parse.in: Move 3 blocks of parser code into new functions.\n\t* c-typeck.c (simple_asm_stmt, c_cast_expr): New functions.\n\t* c-tree.h (simple_asm_stmt, c_cast_expr): New prototypes.\n\t(lookup_label): Remove.\n\nFrom-SVN: r41959", "tree": {"sha": "1a696e8ab4e8b4b64edcb8b6dc6f47202bb5ddae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a696e8ab4e8b4b64edcb8b6dc6f47202bb5ddae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15b732b28893897ac585cf62e2646f001a22531f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b732b28893897ac585cf62e2646f001a22531f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15b732b28893897ac585cf62e2646f001a22531f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15b732b28893897ac585cf62e2646f001a22531f/comments", "author": null, "committer": null, "parents": [{"sha": "8e93d44655a8a0cee4a687ac973a54d847e4924b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e93d44655a8a0cee4a687ac973a54d847e4924b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e93d44655a8a0cee4a687ac973a54d847e4924b"}], "stats": {"total": 143, "additions": 100, "deletions": 43}, "files": [{"sha": "2053f37be473850eb39040597a6363a85059f224", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b732b28893897ac585cf62e2646f001a22531f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b732b28893897ac585cf62e2646f001a22531f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15b732b28893897ac585cf62e2646f001a22531f", "patch": "@@ -1,3 +1,13 @@\n+2001-05-11  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-common.c (finish_label_expr): New function, lifted from\n+\tfrom cp/semantics.c.\n+\t* c-common.h (finish_label_expr, lookup_label): New prototypes.\n+\t* c-parse.in: Move 3 blocks of parser code into new functions.\n+\t* c-typeck.c (simple_asm_stmt, c_cast_expr): New functions.\n+\t* c-tree.h (simple_asm_stmt, c_cast_expr): New prototypes.\n+\t(lookup_label): Remove.\n+\n 2001-05-11  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/mn10300/t-mn10300 (dp-bit.c, fp-bit.c): Don't define"}, {"sha": "f037ecc9ae32d17d4e8e2fd8c370d3ad16368875", "filename": "gcc/c-common.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=15b732b28893897ac585cf62e2646f001a22531f", "patch": "@@ -4193,6 +4193,39 @@ c_add_case_label (cases, cond, low_value, high_value)\n   return case_label;\n }\n \n+/* Finish an expression taking the address of LABEL.  Returns an\n+   expression for the address.  */\n+\n+tree \n+finish_label_address_expr (label)\n+     tree label;\n+{\n+  tree result;\n+\n+  if (pedantic)\n+    {\n+      if (c_language == clk_cplusplus)\n+\tpedwarn (\"ISO C++ forbids taking the address of a label\");\n+      else\n+\tpedwarn (\"ISO C forbids taking the address of a label\");\n+    }\n+\n+  label = lookup_label (label);\n+  if (label == NULL_TREE)\n+    result = null_pointer_node;\n+  else\n+    {\n+      TREE_USED (label) = 1;\n+      result = build1 (ADDR_EXPR, ptr_type_node, label);\n+      TREE_CONSTANT (result) = 1;\n+      /* The current function in not necessarily uninlinable.\n+\t Computed gotos are incompatible with inlining, but the value\n+\t here could be used only in a diagnostic, for example.  */\n+    }\n+\n+  return result;\n+}\n+\n /* Mark P (a stmt_tree) for GC.  The use of a `void *' for the\n    parameter allows this function to be used as a GC-marking\n    function.  */"}, {"sha": "0c2f23a8c238a7f018fa4223bedb92baa35a73ac", "filename": "gcc/c-common.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=15b732b28893897ac585cf62e2646f001a22531f", "patch": "@@ -783,6 +783,12 @@ extern tree c_add_case_label                    PARAMS ((splay_tree,\n \n extern tree build_function_call\t\t\tPARAMS ((tree, tree));\n \n+extern tree finish_label_address_expr\t\tPARAMS ((tree));\n+\n+/* Same function prototype, but the C and C++ front ends have\n+   different implementations.  Used in c-common.c.  */\n+extern tree lookup_label\t\t\tPARAMS ((tree));\n+\n /* If this variable is defined to a non-NULL value, it will be called\n    after the file has been completely parsed.  The argument will be\n    the GLOBAL_NAMESPACE in C++, or the list of top-level declarations"}, {"sha": "253cb292b66d82279e78807990e8adf46c80f46b", "filename": "gcc/c-parse.in", "status": "modified", "additions": 3, "deletions": 41, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=15b732b28893897ac585cf62e2646f001a22531f", "patch": "@@ -493,18 +493,7 @@ unary_expr:\n \t\t  overflow_warning ($$); }\n \t/* Refer to the address of a label as a pointer.  */\n \t| ANDAND identifier\n-\t\t{ tree label = lookup_label ($2);\n-\t\t  if (pedantic)\n-\t\t    pedwarn (\"ISO C forbids `&&'\");\n-\t\t  if (label == 0)\n-\t\t    $$ = null_pointer_node;\n-\t\t  else\n-\t\t    {\n-\t\t      TREE_USED (label) = 1;\n-\t\t      $$ = build1 (ADDR_EXPR, ptr_type_node, label);\n-\t\t      TREE_CONSTANT ($$) = 1;\n-\t\t    }\n-\t\t}\n+\t\t{ $$ = finish_label_address_expr ($2); }\n /* This seems to be impossible on some machines, so let's turn it off.\n    You can use __builtin_next_arg to find the anonymous stack args.\n \t| '&' ELLIPSIS\n@@ -552,15 +541,7 @@ alignof:\n cast_expr:\n \tunary_expr\n \t| '(' typename ')' cast_expr  %prec UNARY\n-\t\t{ tree type;\n-\t\t  int SAVED_warn_strict_prototypes = warn_strict_prototypes;\n-\t\t  /* This avoids warnings about unprototyped casts on\n-                     integers.  E.g. \"#define SIG_DFL (void(*)())0\".  */\n-\t\t  if (TREE_CODE ($4) == INTEGER_CST)\n-\t\t    warn_strict_prototypes = 0;\n-\t\t  type = groktypename ($2);\n-\t\t  warn_strict_prototypes = SAVED_warn_strict_prototypes;\n-\t\t  $$ = build_c_cast (type, $4); }\n+\t\t{ $$ = c_cast_expr ($2, $4); }\n \t;\n \n expr_no_commas:\n@@ -2401,26 +2382,7 @@ stmt:\n \t\t  $$ = c_expand_return ($2); }\n \t| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'\n \t\t{ stmt_count++;\n-\t\t  STRIP_NOPS ($4);\n-\t\t  if ((TREE_CODE ($4) == ADDR_EXPR\n-\t\t       && TREE_CODE (TREE_OPERAND ($4, 0)) == STRING_CST)\n-\t\t      || TREE_CODE ($4) == STRING_CST)\n-\t\t    {\n-\t\t      if (TREE_CODE ($4) == ADDR_EXPR)\n-\t\t\t$4 = TREE_OPERAND ($4, 0);\n-\t\t      if (TREE_CHAIN ($4))\n-\t\t\t$4 = combine_strings ($4);\n-\t\t      $$ = add_stmt (build_stmt (ASM_STMT, NULL_TREE, $4,\n-\t\t\t\t\t\t NULL_TREE, NULL_TREE,\n-\t\t\t\t\t\t NULL_TREE));\n-\t\t      ASM_INPUT_P ($$) = 1;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      error (\"argument of `asm' is not a constant string\");\n-\t\t      $$ = NULL_TREE;\n-\t\t    }\n-\t\t}\n+\t\t  $$ = simple_asm_stmt ($4); }\n \t/* This is the case with just output operands.  */\n \t| ASM_KEYWORD maybe_type_qual '(' expr ':' asm_operands ')' ';'\n \t\t{ stmt_count++;"}, {"sha": "543a310280f27a596640ae182963c0d1b4aca8e5", "filename": "gcc/c-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=15b732b28893897ac585cf62e2646f001a22531f", "patch": "@@ -187,7 +187,6 @@ extern void implicit_decl_warning               PARAMS ((tree));\n extern int  in_parm_level_p                     PARAMS ((void));\n extern void keep_next_level                     PARAMS ((void));\n extern int  kept_level_p                        PARAMS ((void));\n-extern tree lookup_label                        PARAMS ((tree));\n extern tree lookup_name                         PARAMS ((tree));\n extern tree lookup_name_current_level\t\tPARAMS ((tree));\n extern tree lookup_name_current_level_global\tPARAMS ((tree));\n@@ -233,7 +232,8 @@ extern tree parser_build_binary_op              PARAMS ((enum tree_code,\n extern void readonly_warning\t\t\tPARAMS ((tree, const char *));\n extern tree build_conditional_expr              PARAMS ((tree, tree, tree));\n extern tree build_compound_expr                 PARAMS ((tree));\n-extern tree build_c_cast                        PARAMS ((tree, tree));\n+extern tree c_cast_expr\t\t\t\tPARAMS ((tree, tree));\n+extern tree build_c_cast\t                PARAMS ((tree, tree));\n extern tree build_modify_expr                   PARAMS ((tree, enum tree_code,\n \t\t\t\t\t\t\t tree));\n extern void store_init_value                    PARAMS ((tree, tree));\n@@ -251,6 +251,7 @@ extern void pedwarn_c99\t\t\t\tPARAMS ((const char *, ...))\n \t\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n extern tree c_start_case                        PARAMS ((tree));\n extern void c_finish_case                       PARAMS ((void));\n+extern tree simple_asm_stmt\t\t\tPARAMS ((tree));\n extern tree build_asm_stmt\t\t\tPARAMS ((tree, tree, tree,\n \t\t\t\t\t\t\t tree, tree));\n "}, {"sha": "3cbf6c6f3efdbef9910d9cd3fde9fbcd77c86a75", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15b732b28893897ac585cf62e2646f001a22531f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=15b732b28893897ac585cf62e2646f001a22531f", "patch": "@@ -3867,6 +3867,24 @@ build_c_cast (type, expr)\n \n   return value;\n }\n+\n+/* Interpret a cast of expression EXPR to type TYPE.  */\n+tree\n+c_cast_expr (type, expr)\n+     tree type, expr;\n+{\n+  int saved_wsp = warn_strict_prototypes;\n+\n+  /* This avoids warnings about unprototyped casts on\n+     integers.  E.g. \"#define SIG_DFL (void(*)())0\".  */\n+  if (TREE_CODE (expr) == INTEGER_CST)\n+    warn_strict_prototypes = 0;\n+  type = groktypename (type);\n+  warn_strict_prototypes = saved_wsp;\n+\n+  return build_c_cast (type, expr);\n+}\n+\n \f\n /* Build an assignment expression of lvalue LHS from value RHS.\n    MODIFYCODE is the code for a binary operator that we use\n@@ -6763,6 +6781,33 @@ process_init_element (value)\n   constructor_range_stack = 0;\n }\n \f\n+/* Build a simple asm-statement, from one string literal.  */\n+tree\n+simple_asm_stmt (expr)\n+     tree expr;\n+{\n+  STRIP_NOPS (expr);\n+\n+  if (TREE_CODE (expr) == ADDR_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+\n+  if (TREE_CODE (expr) == STRING_CST)\n+    {\n+      tree stmt;\n+\n+      if (TREE_CHAIN (expr))\n+\texpr = combine_strings (expr);\n+      stmt = add_stmt (build_stmt (ASM_STMT, NULL_TREE, expr,\n+\t\t\t\t   NULL_TREE, NULL_TREE,\n+\t\t\t\t   NULL_TREE));\n+      ASM_INPUT_P (stmt) = 1;\n+      return stmt;\n+    }\n+\n+  error (\"argument of `asm' is not a constant string\");\n+  return NULL_TREE;\n+}\n+\n /* Build an asm-statement, whose components are a CV_QUALIFIER, a\n    STRING, some OUTPUTS, some INPUTS, and some CLOBBERS.  */\n "}]}