{"sha": "020a40353445c2e9cf17496e777edeca59573ee1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIwYTQwMzUzNDQ1YzJlOWNmMTc0OTZlNzc3ZWRlY2E1OTU3M2VlMQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2006-01-17T20:22:19Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2006-01-17T20:22:19Z"}, "message": "re PR target/592 ([ARM/Thumb] Poor choice of PIC register)\n\n\tPR target/592\n\tPR middle-end/11135\n\t* arm.h (struct machine_function): Add pic_reg.\n\t* arm.c (arm_pic_register): Make unsigned.\n\t(arm_override_options): Only set arm_pic_register if\n\tTARGET_SINGLE_PIC_BASE.\n\t(use_return_insn): Only test for a pic register if it is fixed.\n\t(arm_compute_save_reg0_reg12_mask): Likewise.\n\t(thumb_compute_save_reg_mask): Likewise.\n\t(legitimate_pic_operand): Factor out some known invariants.\n\t(legitimize_pic_address): If we don't have a fixed pic register,\n\tthen set up a pseudo in the function entry sequence.  Handle the\n\tpic base being in a pseudo.\n\t(arm_load_pic_register): Handle the pic register being in a pseudo.\n\t(arm_expand_prologue): Only set up the pic register if it is fixed.\n\t(thumb_expand_prologue): Likewise.\n\t* arm.md (pic_load_addr_based): Handle the pic base being a pseudo.\n\t(pic_load_addr_based_insn): Likewise.\n\t(builtin_setjmp_receiver): Don't restore the pic base if it isn't\n\tfixed.\n\nFrom-SVN: r109839", "tree": {"sha": "60167f7dda7e44bbe4c14acf58d1a28a6405087e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60167f7dda7e44bbe4c14acf58d1a28a6405087e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/020a40353445c2e9cf17496e777edeca59573ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/020a40353445c2e9cf17496e777edeca59573ee1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/020a40353445c2e9cf17496e777edeca59573ee1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/020a40353445c2e9cf17496e777edeca59573ee1/comments", "author": null, "committer": null, "parents": [{"sha": "a5a97921829bb7d51f71fdb05f5ef0d65be3f354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5a97921829bb7d51f71fdb05f5ef0d65be3f354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5a97921829bb7d51f71fdb05f5ef0d65be3f354"}], "stats": {"total": 136, "additions": 104, "deletions": 32}, "files": [{"sha": "0fb17c1f3523fd2076083ba1d3a798e9b893d17e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020a40353445c2e9cf17496e777edeca59573ee1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020a40353445c2e9cf17496e777edeca59573ee1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=020a40353445c2e9cf17496e777edeca59573ee1", "patch": "@@ -1,3 +1,26 @@\n+2006-01-17  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/592\n+\tPR middle-end/11135\n+\t* arm.h (struct machine_function): Add pic_reg.\n+\t* arm.c (arm_pic_register): Make unsigned.\n+\t(arm_override_options): Only set arm_pic_register if\n+\tTARGET_SINGLE_PIC_BASE.\n+\t(use_return_insn): Only test for a pic register if it is fixed.\n+\t(arm_compute_save_reg0_reg12_mask): Likewise.\n+\t(thumb_compute_save_reg_mask): Likewise.\n+\t(legitimate_pic_operand): Factor out some known invariants.\n+\t(legitimize_pic_address): If we don't have a fixed pic register,\n+\tthen set up a pseudo in the function entry sequence.  Handle the\n+\tpic base being in a pseudo.\n+\t(arm_load_pic_register): Handle the pic register being in a pseudo.\n+\t(arm_expand_prologue): Only set up the pic register if it is fixed.\n+\t(thumb_expand_prologue): Likewise.\n+\t* arm.md (pic_load_addr_based): Handle the pic base being a pseudo.\n+\t(pic_load_addr_based_insn): Likewise.\n+\t(builtin_setjmp_receiver): Don't restore the pic base if it isn't\n+\tfixed.\n+\n 2006-01-18  Ben Elliston  <bje@au.ibm.com>\n \n \t* config/rs6000/rs6000.c (rs6000_hard_regno_mode_ok): Reject"}, {"sha": "e5309e046dddee03692dfce26b6c2b934dd31ee2", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020a40353445c2e9cf17496e777edeca59573ee1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020a40353445c2e9cf17496e777edeca59573ee1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=020a40353445c2e9cf17496e777edeca59573ee1", "patch": "@@ -1,6 +1,6 @@\n /* Output routines for GCC for ARM.\n    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n+   2002, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    and Martin Simmons (@harleqn.co.uk).\n    More major hacks by Richard Earnshaw (rearnsha@arm.com).\n@@ -524,7 +524,7 @@ int arm_cpp_interwork = 0;\n enum machine_mode output_memory_reference_mode;\n \n /* The register number to be used for the PIC offset register.  */\n-int arm_pic_register = INVALID_REGNUM;\n+unsigned arm_pic_register = INVALID_REGNUM;\n \n /* Set to 1 when a return insn is output, this means that the epilogue\n    is not needed.  */\n@@ -1096,7 +1096,7 @@ arm_override_options (void)\n \n   /* If stack checking is disabled, we can use r10 as the PIC register,\n      which keeps r9 available.  */\n-  if (flag_pic)\n+  if (flag_pic && TARGET_SINGLE_PIC_BASE)\n     arm_pic_register = TARGET_APCS_STACK ? 9 : 10;\n \n   if (TARGET_APCS_FLOAT)\n@@ -1547,7 +1547,9 @@ use_return_insn (int iscond, rtx sibling)\n       if (saved_int_regs != 0 && saved_int_regs != (1 << LR_REGNUM))\n \treturn 0;\n \n-      if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n+      if (flag_pic \n+\t  && arm_pic_register != INVALID_REGNUM\n+\t  && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n \treturn 0;\n     }\n \n@@ -3171,16 +3173,14 @@ arm_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n /* Addressing mode support functions.  */\n \n /* Return nonzero if X is a legitimate immediate operand when compiling\n-   for PIC.  */\n+   for PIC.  We know that X satisfies CONSTANT_P and flag_pic is true.  */\n int\n legitimate_pic_operand_p (rtx x)\n {\n-  if (CONSTANT_P (x)\n-      && flag_pic\n-      && (GET_CODE (x) == SYMBOL_REF\n-\t  || (GET_CODE (x) == CONST\n-\t      && GET_CODE (XEXP (x, 0)) == PLUS\n-\t      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF)))\n+  if (GET_CODE (x) == SYMBOL_REF\n+      || (GET_CODE (x) == CONST\n+\t  && GET_CODE (XEXP (x, 0)) == PLUS\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF))\n     return 0;\n \n   return 1;\n@@ -3198,6 +3198,49 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       rtx insn;\n       int subregs = 0;\n \n+      /* If this function doesn't have a pic register, create one now.\n+\t A lot of the logic here is made obscure by the fact that this\n+\t routine gets called as part of the rtx cost estimation\n+\t process.  We don't want those calls to affect any assumptions\n+\t about the real function; and further, we can't call\n+\t entry_of_function() until we start the real expansion\n+\t process.  */\n+      if (!current_function_uses_pic_offset_table)\n+\t{\n+\t  gcc_assert (!no_new_pseudos);\n+\t  if (arm_pic_register != INVALID_REGNUM)\n+\t    {\n+\t      cfun->machine->pic_reg = gen_rtx_REG (Pmode, arm_pic_register);\n+\n+\t      /* Play games to avoid marking the function as needing pic\n+\t\t if we are being called as part of the cost-estimation\n+\t\t process.  */\n+\t      if (!ir_type())\n+\t\tcurrent_function_uses_pic_offset_table = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx seq;\n+\n+\t      cfun->machine->pic_reg = gen_reg_rtx (Pmode);\n+\n+\t      /* Play games to avoid marking the function as needing pic\n+\t\t if we are being called as part of the cost-estimation\n+\t\t process.  */\n+\t      if (!ir_type())\n+\t\t{\n+\t\t  current_function_uses_pic_offset_table = 1;\n+\t\t  start_sequence ();\n+\n+\t\t  arm_load_pic_register (0UL);\n+\n+\t\t  seq = get_insns ();\n+\t\t  end_sequence ();\n+\t\t  emit_insn_after (seq, entry_of_function ());\n+\t\t}\n+\t    }\n+\t}\n+\n       if (reg == 0)\n \t{\n \t  gcc_assert (!no_new_pseudos);\n@@ -3225,17 +3268,16 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t   || (GET_CODE (orig) == SYMBOL_REF &&\n \t       SYMBOL_REF_LOCAL_P (orig)))\n \t  && NEED_GOT_RELOC)\n-\tpic_ref = gen_rtx_PLUS (Pmode, pic_offset_table_rtx, address);\n+\tpic_ref = gen_rtx_PLUS (Pmode, cfun->machine->pic_reg, address);\n       else\n \t{\n \t  pic_ref = gen_const_mem (Pmode,\n-\t\t\t\t   gen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n+\t\t\t\t   gen_rtx_PLUS (Pmode, cfun->machine->pic_reg,\n \t\t\t\t\t         address));\n \t}\n \n       insn = emit_move_insn (reg, pic_ref);\n #endif\n-      current_function_uses_pic_offset_table = 1;\n       /* Put a REG_EQUAL note on this insn, so that it can be optimized\n \t by loop.  */\n       REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, orig,\n@@ -3247,7 +3289,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       rtx base, offset;\n \n       if (GET_CODE (XEXP (orig, 0)) == PLUS\n-\t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n+\t  && XEXP (XEXP (orig, 0), 0) == cfun->machine->pic_reg)\n \treturn orig;\n \n       if (GET_CODE (XEXP (orig, 0)) == UNSPEC\n@@ -3387,13 +3429,14 @@ arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED)\n \n   if (TARGET_ARM)\n     {\n-      emit_insn (gen_pic_load_addr_arm (pic_offset_table_rtx, pic_rtx));\n-      emit_insn (gen_pic_add_dot_plus_eight (pic_offset_table_rtx,\n-\t\t\t\t\t     pic_offset_table_rtx, labelno));\n+      emit_insn (gen_pic_load_addr_arm (cfun->machine->pic_reg, pic_rtx));\n+      emit_insn (gen_pic_add_dot_plus_eight (cfun->machine->pic_reg,\n+\t\t\t\t\t     cfun->machine->pic_reg, labelno));\n     }\n   else\n     {\n-      if (REGNO (pic_offset_table_rtx) > LAST_LO_REGNUM)\n+      if (arm_pic_register != INVALID_REGNUM\n+\t  && REGNO (cfun->machine->pic_reg) > LAST_LO_REGNUM)\n \t{\n \t  /* We will have pushed the pic register, so we should always be\n \t     able to find a work register.  */\n@@ -3403,14 +3446,14 @@ arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED)\n \t  emit_insn (gen_movsi (pic_offset_table_rtx, pic_tmp));\n \t}\n       else\n-\temit_insn (gen_pic_load_addr_thumb (pic_offset_table_rtx, pic_rtx));\n-      emit_insn (gen_pic_add_dot_plus_four (pic_offset_table_rtx,\n-\t\t\t\t\t    pic_offset_table_rtx, labelno));\n+\temit_insn (gen_pic_load_addr_thumb (cfun->machine->pic_reg, pic_rtx));\n+      emit_insn (gen_pic_add_dot_plus_four (cfun->machine->pic_reg,\n+\t\t\t\t\t    cfun->machine->pic_reg, labelno));\n     }\n \n   /* Need to emit this whether or not we obey regdecls,\n      since setjmp/longjmp can cause life info to screw up.  */\n-  emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n+  emit_insn (gen_rtx_USE (VOIDmode, cfun->machine->pic_reg));\n #endif /* AOF_ASSEMBLER */\n }\n \n@@ -3690,7 +3733,7 @@ thumb_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n   /* This is PC relative data before arm_reorg runs.  */\n   else if (GET_MODE_SIZE (mode) >= 4 && CONSTANT_P (x)\n \t   && GET_CODE (x) == SYMBOL_REF\n-           && CONSTANT_POOL_ADDRESS_P (x) && ! flag_pic)\n+           && CONSTANT_POOL_ADDRESS_P (x) && !flag_pic)\n     return 1;\n \n   /* This is PC relative data after arm_reorg runs.  */\n@@ -9173,6 +9216,7 @@ arm_compute_save_reg0_reg12_mask (void)\n       /* Also save the pic base register if necessary.  */\n       if (flag_pic\n \t  && !TARGET_SINGLE_PIC_BASE\n+\t  && arm_pic_register != INVALID_REGNUM\n \t  && current_function_uses_pic_offset_table)\n \tsave_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n     }\n@@ -9195,6 +9239,7 @@ arm_compute_save_reg0_reg12_mask (void)\n \t don't stack it even though it may be live.  */\n       if (flag_pic\n \t  && !TARGET_SINGLE_PIC_BASE\n+\t  && arm_pic_register != INVALID_REGNUM\n \t  && (regs_ever_live[PIC_OFFSET_TABLE_REGNUM]\n \t      || current_function_uses_pic_offset_table))\n \tsave_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n@@ -9312,6 +9357,7 @@ thumb_compute_save_reg_mask (void)\n \n   if (flag_pic\n       && !TARGET_SINGLE_PIC_BASE\n+      && arm_pic_register != INVALID_REGNUM\n       && current_function_uses_pic_offset_table)\n     mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n \n@@ -10822,7 +10868,7 @@ arm_expand_prologue (void)\n     }\n \n \n-  if (flag_pic)\n+  if (flag_pic && arm_pic_register != INVALID_REGNUM)\n     arm_load_pic_register (0UL);\n \n   /* If we are profiling, make sure no instructions are scheduled before\n@@ -13584,7 +13630,7 @@ thumb_expand_prologue (void)\n   live_regs_mask = thumb_compute_save_reg_mask ();\n   /* Load the pic register before setting the frame pointer,\n      so we can use r7 as a temporary work register.  */\n-  if (flag_pic)\n+  if (flag_pic && arm_pic_register != INVALID_REGNUM)\n     arm_load_pic_register (live_regs_mask);\n \n   if (!frame_pointer_needed && CALLER_INTERWORKING_SLOT_SIZE > 0)"}, {"sha": "e2826dce49a7cf86a48d1497e59d2316d3c98e08", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020a40353445c2e9cf17496e777edeca59573ee1/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020a40353445c2e9cf17496e777edeca59573ee1/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=020a40353445c2e9cf17496e777edeca59573ee1", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler, for ARM.\n    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n    and Martin Simmons (@harleqn.co.uk).\n    More major hacks by Richard Earnshaw (rearnsha@arm.com)\n@@ -1519,6 +1519,8 @@ typedef struct machine_function GTY(())\n   /* Records if sibcalls are blocked because an argument\n      register is needed to preserve stack alignment.  */\n   int sibcall_blocked;\n+  /* The PIC register for this function.  This might be a pseudo.  */\n+  rtx pic_reg;\n   /* Labels for per-function Thumb call-via stubs.  One per potential calling\n      register.  We can never call via LR or PC.  We can call via SP if a\n      trampoline happens to be on the top of the stack.  */\n@@ -2206,7 +2208,7 @@ do {\t\t\t\t\t\t\t\\\n /* We decide which register to use based on the compilation options and\n    the assembler in use; this is more general than the APCS restriction of\n    using sb (r9) all the time.  */\n-extern int arm_pic_register;\n+extern unsigned arm_pic_register;\n \n /* The register number of the register used to address a table of static\n    data addresses in memory.  */"}, {"sha": "239961ad554c1ed32106089dd7f1d6592edf5427", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020a40353445c2e9cf17496e777edeca59573ee1/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020a40353445c2e9cf17496e777edeca59573ee1/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=020a40353445c2e9cf17496e777edeca59573ee1", "patch": "@@ -1,6 +1,6 @@\n ;;- Machine description for ARM for GNU compiler\n ;;  Copyright 1991, 1993, 1994, 1995, 1996, 1996, 1997, 1998, 1999, 2000,\n-;;  2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n+;;  2001, 2002, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n ;;  Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n ;;  and Martin Simmons (@harleqn.co.uk).\n ;;  More major hacks by Richard Earnshaw (rearnsha@arm.com).\n@@ -4448,15 +4448,15 @@\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(unspec:SI [(match_operand 1 \"\" \"\") (match_dup 2)] UNSPEC_PIC_SYM))]\n   \"TARGET_ARM && flag_pic\"\n-  \"operands[2] = pic_offset_table_rtx;\"\n+  \"operands[2] = cfun->machine->pic_reg;\"\n )\n \n (define_insn \"*pic_load_addr_based_insn\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(unspec:SI [(match_operand 1 \"\" \"\")\n \t\t    (match_operand 2 \"s_register_operand\" \"r\")]\n \t\t   UNSPEC_PIC_SYM))]\n-  \"TARGET_EITHER && flag_pic && operands[2] == pic_offset_table_rtx\"\n+  \"TARGET_EITHER && flag_pic && operands[2] == cfun->machine->pic_reg\"\n   \"*\n #ifdef AOF_ASSEMBLER\n   operands[1] = aof_pic_entry (operands[1]);\n@@ -4547,7 +4547,8 @@\n {\n   /* r3 is clobbered by set/longjmp, so we can use it as a scratch\n      register.  */\n-  arm_load_pic_register (3);\n+  if (arm_pic_register != INVALID_REGNUM)\n+    arm_load_pic_register (1UL << 3);\n   DONE;\n }\")\n "}]}