{"sha": "a151e93b2bf042c44d37044e887ebfaf038c2a73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE1MWU5M2IyYmYwNDJjNDRkMzcwNDRlODg3ZWJmYWYwMzhjMmE3Mw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-01-24T01:06:34Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-01-24T01:06:34Z"}, "message": "PR middle-end/78703 - -fprintf-return-value floating point handling incorrect...\n\nPR middle-end/78703 - -fprintf-return-value floating point handling incorrect in locales with a mulltibyte decimal point\n\t* gimple-ssa-sprintf.c (struct format_result): Remove constant member.\n\t(struct fmtresult, format_integer, format_floating): Adjust.\n\t(get_string_length, format_string,format_directive): Same.\n\t(pass_sprintf_length::compute_format_length): Same.\n\t(try_substitute_return_value): Simplify slightly.\n\nFrom-SVN: r244846", "tree": {"sha": "e3002395cfa36dad8f15318a09ccddcac58e38b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3002395cfa36dad8f15318a09ccddcac58e38b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a151e93b2bf042c44d37044e887ebfaf038c2a73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a151e93b2bf042c44d37044e887ebfaf038c2a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a151e93b2bf042c44d37044e887ebfaf038c2a73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a151e93b2bf042c44d37044e887ebfaf038c2a73/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "954b452ada953bcbc8d2f9ee802dfd74df079f8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/954b452ada953bcbc8d2f9ee802dfd74df079f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/954b452ada953bcbc8d2f9ee802dfd74df079f8d"}], "stats": {"total": 198, "additions": 88, "deletions": 110}, "files": [{"sha": "2f20d9ed4cc86afdb76d09957fc795574ebbe090", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a151e93b2bf042c44d37044e887ebfaf038c2a73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a151e93b2bf042c44d37044e887ebfaf038c2a73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a151e93b2bf042c44d37044e887ebfaf038c2a73", "patch": "@@ -1,5 +1,12 @@\n 2017-01-23  Martin Sebor  <msebor@redhat.com>\n \n+\tPR middle-end/78703\n+\t* gimple-ssa-sprintf.c (struct format_result): Remove constant member.\n+\t(struct fmtresult, format_integer, format_floating): Adjust.\n+\t(get_string_length, format_string,format_directive): Same.\n+\t(pass_sprintf_length::compute_format_length): Same.\n+\t(try_substitute_return_value): Simplify slightly.\n+\n \tPR middle-end/78703\n \t* gimple-ssa-sprintf.c (pass_sprintf_length::gate): Adjust formatting.\n \t(fmtresult::operator+=): Outlined."}, {"sha": "d63a51cb72a6b249113efa5506c85915a3f4977b", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 81, "deletions": 110, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a151e93b2bf042c44d37044e887ebfaf038c2a73/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a151e93b2bf042c44d37044e887ebfaf038c2a73/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=a151e93b2bf042c44d37044e887ebfaf038c2a73", "patch": "@@ -183,12 +183,6 @@ struct format_result\n      the return value of a call.  */\n   bool knownrange;\n \n-  /* True when the output of the formatted call is constant (and\n-     thus a candidate for string constant folding).  This is rare\n-     and typically requires that the arguments of all directives\n-     are also constant.  CONSTANT implies BOUNDED.  */\n-  bool constant;\n-\n   /* True if no individual directive resulted in more than 4095 bytes\n      of output (the total NUMBER_CHARS might be greater).  */\n   bool under4k;\n@@ -452,7 +446,6 @@ struct fmtresult\n   : argmin (), argmax (),\n     knownrange (min < HOST_WIDE_INT_MAX),\n     bounded (),\n-    constant (),\n     nullp ()\n   {\n     range.min = min;\n@@ -465,11 +458,10 @@ struct fmtresult\n   : argmin (), argmax (),\n     knownrange (min < HOST_WIDE_INT_MAX && max < HOST_WIDE_INT_MAX),\n     bounded (),\n-    constant (),\n     nullp ()\n   {\n     range.min = min;\n-    range.max = min;\n+    range.max = max;\n   }\n \n   /* The range a directive's argument is in.  */\n@@ -490,12 +482,6 @@ struct fmtresult\n      false otherwise.  */\n   bool bounded;\n \n-  /* True when the output of a directive is constant.  This is rare\n-     and typically requires that the argument(s) of the directive\n-     are also constant (such as determined by constant propagation,\n-     though not value range propagation).  */\n-  bool constant;\n-\n   /* True when the argument is a null pointer.  */\n   bool nullp;\n };\n@@ -818,7 +804,7 @@ static fmtresult\n format_none (const directive &, tree)\n {\n   fmtresult res (0);\n-  res.bounded = res.constant = true;\n+  res.bounded = true;\n   return res;\n }\n \n@@ -828,7 +814,7 @@ static fmtresult\n format_percent (const directive &, tree)\n {\n   fmtresult res (1);\n-  res.bounded = res.constant = true;\n+  res.bounded = true;\n   return res;\n }\n \n@@ -1095,7 +1081,6 @@ format_integer (const directive &dir, tree arg)\n \t{\n \t  res.range.max = len;\n \t  res.bounded = true;\n-\t  res.constant = true;\n \t  res.knownrange = true;\n \t  res.bounded = true;\n \t}\n@@ -1537,7 +1522,6 @@ format_floating (const directive &dir, tree arg)\n \n   /* The minimum and maximum number of bytes produced by the directive.  */\n   fmtresult res;\n-  res.constant = true;\n \n   /* Get the real type format desription for the target.  */\n   const REAL_VALUE_TYPE *rvp = TREE_REAL_CST_PTR (arg);\n@@ -1634,7 +1618,6 @@ get_string_length (tree str)\n       fmtresult res;\n       res.range.min = res.range.max = tree_to_shwi (slen);\n       res.bounded = true;\n-      res.constant = true;\n       res.knownrange = true;\n       return res;\n     }\n@@ -1662,11 +1645,6 @@ get_string_length (tree str)\n       res.bounded = res.range.max < target_int_max ();\n       res.knownrange = res.bounded;\n \n-      /* Set RES.CONSTANT to false even though that may be overly\n-\t conservative in rare cases like: 'x ? a : b' where a and\n-\t b have the same lengths and consist of the same characters.  */\n-      res.constant = false;\n-\n       return res;\n     }\n \n@@ -1713,7 +1691,6 @@ format_character (const directive &dir, tree arg)\n       res.range.min = res.range.max = 1;\n       res.bounded = true;\n       res.knownrange = true;\n-      res.constant = arg && TREE_CODE (arg) == INTEGER_CST;\n     }\n \n   /* Adjust the lengths for field width.  */\n@@ -1759,7 +1736,8 @@ format_string (const directive &dir, tree arg)\n \n   /* Compute the range the argument's length can be in.  */\n   fmtresult slen = get_string_length (arg);\n-  if (slen.constant)\n+  if (slen.range.min == slen.range.max\n+      && slen.range.min < HOST_WIDE_INT_MAX)\n     {\n       gcc_checking_assert (slen.range.min == slen.range.max);\n \n@@ -1807,7 +1785,6 @@ format_string (const directive &dir, tree arg)\n \t     precision is either not specified or it is specified and\n \t     its value is known.  */\n \t  res.bounded = true;\n-\t  res.constant = dir.prec != HOST_WIDE_INT_MIN;\n \t}\n       else if (dir.width == HOST_WIDE_INT_MIN)\n \t{\n@@ -1868,7 +1845,6 @@ format_string (const directive &dir, tree arg)\n \t of bytes is known or contrained to some range.  */\n       res.bounded = 0 <= dir.prec || slen.bounded;\n       res.knownrange = slen.knownrange;\n-      res.constant = false;\n     }\n \n   /* Adjust the lengths for field width.  */\n@@ -1888,7 +1864,7 @@ format_string (const directive &dir, tree arg)\n \n   /* When precision is specified the range of characters on output\n      is known to be bounded by it.  */\n-  if (HOST_WIDE_INT_MIN != dir.width && HOST_WIDE_INT_MIN != dir.prec)\n+  if (HOST_WIDE_INT_MIN != dir.width && -1 < dir.prec)\n     res.knownrange = true;\n \n   return res;\n@@ -1936,10 +1912,9 @@ format_directive (const pass_sprintf_length::call_info &info,\n   /* Compute the (approximate) length of the formatted output.  */\n   fmtresult fmtres = dir.fmtfunc (dir, arg);\n \n-  /* The overall result is bounded and constant only if the output\n-     of every directive is bounded and constant, respectively.  */\n+  /* The overall result is bounded only if the output of every directive\n+     is bounded.  */\n   res->bounded &= fmtres.bounded;\n-  res->constant &= fmtres.constant;\n \n   /* Record whether the output of all directives is known to be\n      bounded by some maximum, implying that their arguments are\n@@ -2792,11 +2767,10 @@ pass_sprintf_length::compute_format_length (call_info &info,\n   res->number_chars = res->number_chars_min = res->number_chars_max = 0;\n \n   /* No directive has been seen yet so the length of output is bounded\n-     by the known range [0, 0] and constant (with no conversion producing\n-     more than 4K bytes) until determined otherwise.  */\n+     by the known range [0, 0] (with no conversion producing more than\n+     4K bytes) until determined otherwise.  */\n   res->bounded = true;\n   res->knownrange = true;\n-  res->constant = true;\n   res->under4k = true;\n   res->floating = false;\n   res->warned = false;\n@@ -2877,42 +2851,71 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n \t\t\t     const pass_sprintf_length::call_info &info,\n \t\t\t     const format_result &res)\n {\n+  if (!res.bounded)\n+    return false;\n+\n   tree lhs = gimple_get_lhs (info.callstmt);\n \n+  /* Set to true when the entire call has been removed.  */\n+  bool removed = false;\n+\n+  /* The minumum return value.  */\n+  unsigned HOST_WIDE_INT minretval = res.number_chars_min;\n+\n+  /* The maximum return value.  */\n+  unsigned HOST_WIDE_INT maxretval = res.number_chars_max;\n+\n+  /* Adjust the number of bytes which includes the terminating nul\n+     to reflect the return value of the function which does not.\n+     Because the valid range of the function is [INT_MIN, INT_MAX],\n+     a valid range before the adjustment below is [0, INT_MAX + 1]\n+     (the functions only return negative values on error or undefined\n+     behavior).  */\n+  if (minretval <= target_int_max () + 1)\n+    --minretval;\n+  if (maxretval <= target_int_max () + 1)\n+    --maxretval;\n+\n   /* Avoid the return value optimization when the behavior of the call\n      is undefined either because any directive may have produced 4K or\n      more of output, or the return value exceeds INT_MAX, or because\n      the output overflows the destination object (but leave it enabled\n      when the function is bounded because then the behavior is well-\n      defined).  */\n-  if (lhs\n-      && res.bounded\n-      && res.under4k\n-      && (info.bounded || res.number_chars <= info.objsize)\n-      && res.number_chars - 1 <= target_int_max ()\n+  if (res.under4k\n+      && minretval == maxretval\n+      && (info.bounded || minretval < info.objsize)\n+      && minretval <= target_int_max ()\n       /* Not prepared to handle possibly throwing calls here; they shouldn't\n \t appear in non-artificial testcases, except when the __*_chk routines\n \t are badly declared.  */\n       && !stmt_ends_bb_p (info.callstmt))\n     {\n-      tree cst = build_int_cst (integer_type_node, res.number_chars - 1);\n+      tree cst = build_int_cst (integer_type_node, minretval);\n \n-      if (info.nowrite)\n+      if (lhs == NULL_TREE\n+\t  && info.nowrite)\n+\t{\n+\t  /* Remove the call to the bounded function with a zero size\n+\t     (e.g., snprintf(0, 0, \"%i\", 123)) if there is no lhs.  */\n+\t  unlink_stmt_vdef (info.callstmt);\n+\t  gsi_remove (gsi, true);\n+\t  removed = true;\n+\t}\n+      else if (info.nowrite)\n \t{\n \t  /* Replace the call to the bounded function with a zero size\n \t     (e.g., snprintf(0, 0, \"%i\", 123) with the constant result\n-\t     of the function minus 1 for the terminating NUL which\n-\t     the function's  return value does not include.  */\n+\t     of the function.  */\n \t  if (!update_call_from_tree (gsi, cst))\n \t    gimplify_and_update_call_from_tree (gsi, cst);\n \t  gimple *callstmt = gsi_stmt (*gsi);\n \t  update_stmt (callstmt);\n \t}\n-      else\n+      else if (lhs)\n \t{\n \t  /* Replace the left-hand side of the call with the constant\n-\t     result of the formatted function minus 1 for the terminating\n-\t     NUL which the function's return value does not include.  */\n+\t     result of the formatted function.  */\n \t  gimple_call_set_lhs (info.callstmt, NULL_TREE);\n \t  gimple *g = gimple_build_assign (lhs, cst);\n \t  gsi_insert_after (gsi, g, GSI_NEW_STMT);\n@@ -2921,88 +2924,56 @@ try_substitute_return_value (gimple_stmt_iterator *gsi,\n \n       if (dump_file)\n \t{\n-\t  location_t callloc = gimple_location (info.callstmt);\n-\t  fprintf (dump_file, \"On line %i substituting \",\n-\t\t   LOCATION_LINE (callloc));\n-\t  print_generic_expr (dump_file, cst, dump_flags);\n-\t  fprintf (dump_file, \" for \");\n-\t  print_generic_expr (dump_file, info.func, dump_flags);\n-\t  fprintf (dump_file, \" %s (output %s).\\n\",\n-\t\t   info.nowrite ? \"call\" : \"return value\",\n-\t\t   res.constant ? \"constant\" : \"variable\");\n+\t  if (removed)\n+\t    fprintf (dump_file, \"  Removing call statement.\");\n+\t  else\n+\t    {\n+\t      fprintf (dump_file, \"  Substituting \");\n+\t      print_generic_expr (dump_file, cst, dump_flags);\n+\t      fprintf (dump_file, \" for %s.\\n\",\n+\t\t       info.nowrite ? \"statement\" : \"return value\");\n+\t    }\n \t}\n     }\n-  else if (lhs == NULL_TREE\n-\t   && info.nowrite\n-\t   && !stmt_ends_bb_p (info.callstmt))\n+  else if (lhs)\n     {\n-      /* Remove the call to the bounded function with a zero size\n-\t (e.g., snprintf(0, 0, \"%i\", 123)) if there is no lhs.  */\n-      unlink_stmt_vdef (info.callstmt);\n-      gsi_remove (gsi, true);\n-      if (dump_file)\n-\t{\n-\t  location_t callloc = gimple_location (info.callstmt);\n-\t  fprintf (dump_file, \"On line %i removing \",\n-\t\t   LOCATION_LINE (callloc));\n-\t  print_generic_expr (dump_file, info.func, dump_flags);\n-\t  fprintf (dump_file, \" call.\\n\");\n-\t}\n-      return true;\n-    }\n-  else\n-    {\n-      unsigned HOST_WIDE_INT maxbytes;\n+      bool setrange = false;\n \n-      if (lhs\n-\t  && res.bounded\n-\t  && ((maxbytes = res.number_chars - 1) <= target_int_max ()\n-\t      || (res.number_chars_min - 1 <= target_int_max ()\n-\t\t  && (maxbytes = res.number_chars_max - 1) <= target_int_max ()))\n-\t  && (info.bounded || maxbytes < info.objsize))\n+      if ((info.bounded || maxretval < info.objsize)\n+\t  && res.under4k\n+\t  && (minretval < target_int_max ()\n+\t      && maxretval < target_int_max ()))\n \t{\n \t  /* If the result is in a valid range bounded by the size of\n \t     the destination set it so that it can be used for subsequent\n \t     optimizations.  */\n \t  int prec = TYPE_PRECISION (integer_type_node);\n \n-\t  if (res.number_chars < target_int_max () && res.under4k)\n-\t    {\n-\t      wide_int num = wi::shwi (res.number_chars - 1, prec);\n-\t      set_range_info (lhs, VR_RANGE, num, num);\n-\t    }\n-\t  else if (res.number_chars_min < target_int_max ()\n-\t\t   && res.number_chars_max < target_int_max ())\n-\t    {\n-\t      wide_int min = wi::shwi (res.under4k ? res.number_chars_min - 1\n-\t\t\t\t       : target_int_min (), prec);\n-\t      wide_int max = wi::shwi (res.number_chars_max - 1, prec);\n-\t      set_range_info (lhs, VR_RANGE, min, max);\n-\t    }\n+\t  wide_int min = wi::shwi (minretval, prec);\n+\t  wide_int max = wi::shwi (maxretval, prec);\n+\t  set_range_info (lhs, VR_RANGE, min, max);\n+\n+\t  setrange = true;\n \t}\n \n       if (dump_file)\n \t{\n \t  const char *inbounds\n-\t    = (res.number_chars_min <= info.objsize\n-\t       ? (res.number_chars_max <= info.objsize\n+\t    = (minretval < info.objsize\n+\t       ? (maxretval < info.objsize\n \t\t  ? \"in\" : \"potentially out-of\")\n \t       : \"out-of\");\n \n-\t  location_t callloc = gimple_location (info.callstmt);\n-\t  fprintf (dump_file, \"On line %i \", LOCATION_LINE (callloc));\n-\t  print_generic_expr (dump_file, info.func, dump_flags);\n-\n-\t  const char *ign = lhs ? \"\" : \" ignored\";\n-\t  if (res.number_chars >= HOST_WIDE_INT_MAX)\n+\t  const char *what = setrange ? \"Setting\" : \"Discarding\";\n+\t  if (minretval != maxretval)\n \t    fprintf (dump_file,\n-\t\t     \" %s-bounds return value in range [%lu, %lu]%s.\\n\",\n-\t\t     inbounds,\n-\t\t     (unsigned long)res.number_chars_min - 1,\n-\t\t     (unsigned long)res.number_chars_max - 1, ign);\n+\t\t     \"  %s %s-bounds return value range [%llu, %llu].\\n\",\n+\t\t     what, inbounds,\n+\t\t     (unsigned long long)minretval,\n+\t\t     (unsigned long long)maxretval);\n \t  else\n-\t    fprintf (dump_file, \" %s-bounds return value %lu%s.\\n\",\n-\t\t     inbounds, (unsigned long)res.number_chars - 1, ign);\n+\t    fprintf (dump_file, \"  %s %s-bounds return value %llu.\\n\",\n+\t\t     what, inbounds, (unsigned long long)minretval);\n \t}\n     }\n "}]}