{"sha": "17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdhZDhhM2JiOWQ1ZDhjY2VlNTViMDhhYmJhNmZiMTU0ZTVjZjMyYg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-10-24T23:36:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-10-24T23:36:42Z"}, "message": "mn10200.c (indirect_memory_operand): Delete unused function.\n\n        * mn10200.c (indirect_memory_operand): Delete unused function.\n        * mn10200.h (EXTRA_CONSTRAINT): Handle 'R'.\n        * mn10200.md (bset, bclr insns): Handle output in a reg too.\n\nFrom-SVN: r16169", "tree": {"sha": "b60a19035cb59659228b6a4a7063174f6ceb2f5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b60a19035cb59659228b6a4a7063174f6ceb2f5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b/comments", "author": null, "committer": null, "parents": [{"sha": "e16b49d379421f64b3d12b4f099ce2ae354c2355", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16b49d379421f64b3d12b4f099ce2ae354c2355", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e16b49d379421f64b3d12b4f099ce2ae354c2355"}], "stats": {"total": 73, "additions": 43, "deletions": 30}, "files": [{"sha": "d26d46476a86272c7c2bf71a0ba206fd949f54a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b", "patch": "@@ -1,3 +1,9 @@\n+Fri Oct 24 17:40:34 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* mn10200.c (indirect_memory_operand): Delete unused function.\n+\t* mn10200.h (EXTRA_CONSTRAINT): Handle 'R'.\n+\t* mn10200.md (bset, bclr insns): Handle output in a reg too.\n+\n Fri Oct 24 15:54:57 1997  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.md (call patterns): Revert Oct 16 change; if we are to elide"}, {"sha": "25d5e20b7c3f52a6e89aeaa70e944e49ad7914d8", "filename": "gcc/config/mn10200/mn10200.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b", "patch": "@@ -864,16 +864,6 @@ call_address_operand (op, mode)\n   return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n }\n \n-/* Return true if OP is an indirect memory operand, the \"bset\" and \"bclr\"\n-   insns use this predicate.  */\n-int\n-indirect_memory_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == REG);\n-}\n-\n /* Return true if OP is a memory operand with a constant address.\n    A special PSImode move pattern uses this predicate.  */\n int"}, {"sha": "3b2f74cd7ca845f6fca67625f13b1f93a2f8acfa", "filename": "gcc/config/mn10200/mn10200.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b/gcc%2Fconfig%2Fmn10200%2Fmn10200.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.h?ref=17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b", "patch": "@@ -614,10 +614,15 @@ extern struct rtx_def *function_arg();\n #define CONSTANT_ADDRESS_P(X)   CONSTANT_P (X)\n \n /* Extra constraints.  */\n+#define OK_FOR_R(OP) \\\n+   (GET_CODE (OP) == MEM\t\t\t\t\t\\\n+    && GET_MODE (OP) == QImode\t\t\t\t\t\\\n+    && REG_P (XEXP (OP, 0)))\n  \n /* Q is used for sp + <something> in the {zero,sign}_extendpsisi2 patterns.  */\n #define EXTRA_CONSTRAINT(OP, C) \\\n- ((C) == 'S' ? GET_CODE (OP) == SYMBOL_REF : \\\n+ ((C) == 'R' ? OK_FOR_R (OP) : \\\n+  (C) == 'S' ? GET_CODE (OP) == SYMBOL_REF : \\\n   (C) == 'Q' ? GET_CODE (OP) == PLUS : 0)\n \n /* Maximum number of registers that can appear in a valid memory address.  */"}, {"sha": "443fc8b633eaf3dc0b89e370cb89dcd1cfc8d79e", "filename": "gcc/config/mn10200/mn10200.md", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b/gcc%2Fconfig%2Fmn10200%2Fmn10200.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.md?ref=17ad8a3bb9d5d8ccee55b08abba6fb154e5cf32b", "patch": "@@ -650,54 +650,66 @@\n ;; BIT INSTRUCTIONS\n ;; -----------------------------------------------------------------\n \n-;; When clearing a set of bits in memory, we load the inverted bitmask into\n-;; a register, then use bclr.\n+;; These clears a constant set of bits in memory or in a register.\n+;; We must support register destinations to make reload happy.\n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+  [(set (match_operand:QI 0 \"general_operand\" \"R,d\")\n \t(subreg:QI\n \t  (and:HI (subreg:HI (match_dup 0) 0)\n \t\t  (match_operand 1 \"const_int_operand\" \"\")) 0))\n-   (clobber (match_scratch:HI 2 \"=&d\"))]\n+   (clobber (match_scratch:HI 2 \"=&d,X\"))]\n   \"\"\n-  \"mov %N1,%2\\;bclr %2,%0\"\n+  \"@\n+  mov %N1,%2\\;bclr %2,%0\n+  and %1,%0\"\n   [(set_attr \"cc\" \"clobber\")])\n \n-;; These clear a non-constant set of bits in memory.\n+;; This clears a variable set of bits in memory or in a register.\n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+  [(set (match_operand:QI 0 \"general_operand\" \"R,d\")\n \t(subreg:QI\n \t  (and:HI (subreg:HI (match_dup 0) 0)\n-\t\t  (not:HI (match_operand:HI 1 \"general_operand\" \"d\"))) 0))]\n+\t\t  (not:HI (match_operand:HI 1 \"general_operand\" \"d,d\"))) 0))\n+   (clobber (match_scratch:HI 2 \"=X,&d\"))]\n   \"\"\n-  \"bclr %1,%0\"\n+  \"@\n+  bclr %1,%0\n+  mov %1,%2\\;not %2\\;and %2,%0\"\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+  [(set (match_operand:QI 0 \"general_operand\" \"R,d\")\n \t(subreg:QI\n-\t  (and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"d\"))\n-\t\t  (subreg:HI (match_dup 0) 0)) 0))]\n+\t  (and:HI (not:HI (match_operand:HI 1 \"general_operand\" \"d,d\"))\n+\t\t  (subreg:HI (match_dup 0) 0)) 0))\n+   (clobber (match_scratch:HI 2 \"=X,&d\"))]\n   \"\"\n-  \"bclr %1,%0\"\n+  \"@\n+  bclr %1,%0\n+  mov %1,%2\\;not %2\\;and %2,%0\"\n   [(set_attr \"cc\" \"clobber\")])\n \n ;; These set bits in memory.\n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+  [(set (match_operand:QI 0 \"general_operand\" \"R,d\")\n \t(subreg:QI\n \t  (ior:HI (subreg:HI (match_dup 0) 0)\n-\t\t  (match_operand:HI 1 \"general_operand\" \"d\")) 0))]\n+\t\t  (match_operand:HI 1 \"general_operand\" \"d,d\")) 0))]\n   \"\"\n-  \"bset %1,%0\"\n+  \"@\n+  bset %1,%0\n+  or %1,%0\"\n   [(set_attr \"cc\" \"clobber\")])\n \n (define_insn \"\"\n-  [(set (match_operand:QI 0 \"indirect_memory_operand\" \"\")\n+  [(set (match_operand:QI 0 \"general_operand\" \"R,d\")\n \t(subreg:QI\n-\t  (ior:HI (match_operand:HI 1 \"general_operand\" \"d\")\n+\t  (ior:HI (match_operand:HI 1 \"general_operand\" \"d,d\")\n \t\t  (subreg:HI (match_dup 0) 0)) 0))]\n   \"\"\n-  \"bset %1,%0\"\n+  \"@\n+  bset %1,%0\n+  or %1,%0\"\n   [(set_attr \"cc\" \"clobber\")])\n \n ;; Not any shorter/faster than using cmp, but it might save a"}]}